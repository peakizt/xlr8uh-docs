Directory structure:
‚îî‚îÄ‚îÄ advdebug-anticrack-dotnet/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ AntiCrack-DotNet.sln
    ‚îú‚îÄ‚îÄ LICENSE
    ‚îú‚îÄ‚îÄ AntiCrack-DotNet/
    ‚îÇ   ‚îú‚îÄ‚îÄ AntiCrack-DotNet.csproj
    ‚îÇ   ‚îú‚îÄ‚îÄ AntiDebug.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ AntiInjection.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ AntiVirtualization.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ App.config
    ‚îÇ   ‚îú‚îÄ‚îÄ Delegates.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Hooks.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ HooksDetection.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ OtherChecks.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Program.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Structs.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Syscalls.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Utils.cs
    ‚îÇ   ‚îî‚îÄ‚îÄ Properties/
    ‚îÇ       ‚îî‚îÄ‚îÄ AssemblyInfo.cs
    ‚îî‚îÄ‚îÄ .github/
        ‚îî‚îÄ‚îÄ workflows/
            ‚îî‚îÄ‚îÄ codeql.yml

================================================
File: README.md
================================================
<p align="center">
  <a href="#"><img src="https://img.shields.io/github/stars/AdvDebug/AntiCrack-DotNet?style=for-the-badge"></a>
  <a href="#"><img src="https://img.shields.io/github/license/AdvDebug/AntiCrack-DotNet?style=for-the-badge"></a>
  <a href="#"><img src="https://img.shields.io/badge/LANGUAGE-CSHARP-green?style=for-the-badge"></a>
</p>

# üõ°Ô∏è AntiCrack DotNet üõ°Ô∏è
A .NET Project which Contains some useful techniques to detect debugging and other harmful actions and bypass methods which can be used by crackers to analyze your assembly. (also feel free to open an issue for adding additional anti-debugging features, etc) with syscall support.

you can see it's showcase <a href="https://www.youtube.com/watch?v=kQF2Q8uiH3I">here</a>. also please star the project if you found it useful, it will encourage me to continue developing it.

![image](https://github.com/user-attachments/assets/28edc57b-794d-42ea-9a35-63ad21a7f7a2)


## Hooks
* Preventing unauthorized retrieval of .NET functions pointer to prevent raw memory modifications of functions at runtime.

## Anti Debugging
* NtUserGetForegroundWindow (looks for bad active window names to check if it's a known debugger)

* Debugger.IsAttached

* Hide Threads From Debugger

* IsDebuggerPresent

* PEB.BeingDebugged

* PEB.NtGlobalFlag

* NtSetDebugFilterState

* Page Guard Breakpoints Detection

* NtQueryInformationProcess: ProcessDebugFlags, ProcessDebugPort, ProcessDebugObjectHandle

* NtClose: Invalid Handle, Protected Handle

* Parent Process Checking (Checks if parent are explorer.exe or cmd.exe)

* Detection of Hardware Breakpoints

* FindWindow (looks for bad window names)

* GetTickCount

* OutputDebugString

* Crashing Non-Managed Debuggers with a Debugger Breakpoint

* OllyDbg Format String Exploit

* Patching DbgUiRemoteBreakin and DbgBreakPoint (Anti-Debugger Attaching)

## Anti Virtualization

* Detecting Any.run

* Detecting Triage

* Detecting Qemu.

* Detecting Parallels.

* Detecting Sandboxie

* Detecting Comodo Container

* Detecting Qihoo360 Sandbox

* Detecting Cuckoo Sandbox

* Detecting VirtualBox and VMware

* Detecting HyperV

* Detecting Emulation

* Checking For Blacklisted Usernames

* Detecting KVM

* Detecting Wine

* Checking For Known Bad VM File Locations

* Checking For Known Bad Process Names

* Checking For Ports on the system (useful if the VM or the sandbox have no ports connected)

* Checking for devices created by VMs or Sandboxes

* Checking if AVX x64/x86 instructions are properly implemented to see if we are in an emulator.

* Checking for RDRAND x64/x86 instruction to see if it's properly implemented which could indicate an emulator.

* Checking for flags manipulation (for x64 and x86) checks to see if it's correctly handled.

## Anti Injection

* Taking Advantage of Binary Image Signature Mitigation Policy to prevent injecting Non-Microsoft Binaries.

* Checking if any injected libraries are present (simple dlls path whitelist check)

* Thread Injection Detection

* changing the main module info of the program like module name, base address, address of entrypoint, size of image, etc to prevent info lookups, dumping, and modification.

* Changing the CLR module image magic in the memory of the process to try to prevent (some) external processes/software from retrieving some critical info about our assemblies while still being functional by making it seem like debugger exports is missing.

* Detecting process hollowing in our program by checking suspicious image base address.

## Other Detections
* Detecting if Unsigned Drivers are Allowed to Load

* Detecting if Test-Signed Drivers are Allowed to Load

* Detecting if Kernel Debugging are Enabled on the System

* Detecting if Secure Boot are Enabled on the System

* Detecting if Virtualization-Based Security is Enabled.

* Detecting if Memory Integrity Protection is Enabled.

* Detecting if the current assembly has been invoked.

## Hooks Detection
* Detecting Most Anti Anti-Debugging Hooking Methods on Common Anti-Debugging Functions by checking for Bad Instructions on Functions Addresses and it detects user-mode anti anti-debuggers like scyllahide, and it can also detect some sandboxes which uses hooking to monitor application behaviour/activity (like <a href="https://github.com/sandboxie-plus/Sandboxie">Sandboxie/Sandboxie Plus</a>, <a href="https://www.hybrid-analysis.com">Hybrid Analysis</a>, <a href="https://cuckoosandbox.org/index.html">Cuckoo Sandbox</a>, and a lot of other online malware analysis websites/applications).

* Basic detection for stealthy page guard hooking.

* Detecting CLR Functions Hooking (like harmony hooks).

## Why in C# even tho it's easily decompiled?
I think C# as AOT is being developed more and more that it's gonna be suitable for this kind of stuff and such tool may come in handy for software protection or anti-cheat development.

# Notice
This Project are created for educational purposes only, also this project are licensed under MIT License. you can use the code however you please, just please use it responsibly (NOT for malware) (e.g. you are developing an anti-cheat).

[![Star History Chart](https://api.star-history.com/svg?repos=AdvDebug/AntiCrack-DotNet&type=Date)](https://star-history.com/#AdvDebug/AntiCrack-DotNet&Date)



================================================
File: AntiCrack-DotNet.sln
================================================
√Ø¬ª¬ø
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AntiCrack-DotNet", "AntiCrack-DotNet\AntiCrack-DotNet.csproj", "{9CE21C83-C4C3-426F-8580-03BBC0B9EB27}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9CE21C83-C4C3-426F-8580-03BBC0B9EB27}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9CE21C83-C4C3-426F-8580-03BBC0B9EB27}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9CE21C83-C4C3-426F-8580-03BBC0B9EB27}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9CE21C83-C4C3-426F-8580-03BBC0B9EB27}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0F3566FF-4961-4587-9568-F20B59ACF27C}
	EndGlobalSection
EndGlobal



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2022 AdvDebug

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: AntiCrack-DotNet/AntiCrack-DotNet.csproj
================================================
√Ø¬ª¬ø<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{9CE21C83-C4C3-426F-8580-03BBC0B9EB27}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>AntiCrack_DotNet</RootNamespace>
    <AssemblyName>AntiCrack-DotNet</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <TargetFrameworkProfile />
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugSymbols>false</DebugSymbols>
    <DebugType>none</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>5</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <TargetZone>LocalIntranet</TargetZone>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateManifests>false</GenerateManifests>
  </PropertyGroup>
  <PropertyGroup />
  <PropertyGroup />
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Management" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.ServiceProcess" />
    <Reference Include="System.Windows.Forms" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AntiDebug.cs" />
    <Compile Include="AntiInjection.cs" />
    <Compile Include="AntiVirtualization.cs" />
    <Compile Include="Delegates.cs" />
    <Compile Include="Hooks.cs" />
    <Compile Include="HooksDetection.cs" />
    <Compile Include="OtherChecks.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Structs.cs" />
    <Compile Include="Syscalls.cs" />
    <Compile Include="Utils.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.7.2">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.7.2 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PreBuildEvent>
    </PreBuildEvent>
  </PropertyGroup>
</Project>


================================================
File: AntiCrack-DotNet/AntiDebug.cs
================================================
√Ø¬ª¬øusing System;
using System.IO;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Reflection;
using static AntiCrack_DotNet.Structs;
using System.Security.Cryptography;

namespace AntiCrack_DotNet
{
    public sealed class AntiDebug
    {
        #region WinApi

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool SetHandleInformation(IntPtr hObject, uint dwMask, uint dwFlags);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern bool NtClose(IntPtr Handle);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr CreateMutexA(IntPtr lpMutexAttributes, bool bInitialOwner, string lpName);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool IsDebuggerPresent();

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetModuleHandle(string lib);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetProcAddress(IntPtr ModuleHandle, string Function);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool WriteProcessMemory(SafeHandle hProcess, IntPtr BaseAddress, byte[] Buffer, uint size, int NumOfBytes);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool ReadProcessMemory(SafeHandle hProcess, IntPtr BaseAddress, out byte[] Buffer, uint size, out int NumOfBytes);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtSetInformationThread(IntPtr ThreadHandle, uint ThreadInformationClass, IntPtr ThreadInformation, int ThreadInformationLength);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtOpenThread(out IntPtr hThread, uint dwDesiredAccess, ref OBJECT_ATTRIBUTES ObjectAttributes, ref CLIENT_ID ClientID);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern uint GetTickCount();

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetCurrentThread();

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern bool NtGetContextThread(IntPtr hThread, ref CONTEXT Context);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtQueryInformationProcess(IntPtr hProcess, uint ProcessInfoClass, out uint ProcessInfo, uint nSize, uint ReturnLength);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtQueryInformationProcess(IntPtr hProcess, uint ProcessInfoClass, out IntPtr ProcessInfo, uint nSize, uint ReturnLength);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtQueryInformationProcess(IntPtr hProcess, uint ProcessInfoClass, ref PROCESS_BASIC_INFORMATION ProcessInfo, uint nSize, uint ReturnLength);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern int QueryFullProcessImageNameA(SafeHandle hProcess, uint Flags, byte[] lpExeName, Int32[] lpdwSize);

        [DllImport("win32u.dll", SetLastError = true)]
        private static extern IntPtr NtUserGetForegroundWindow();

        [DllImport("user32.dll", SetLastError = true)]
        private static extern int GetWindowTextLengthA(IntPtr HWND);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern int GetWindowTextA(IntPtr HWND, StringBuilder WindowText, int nMaxCount);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtSetDebugFilterState(ulong ComponentId, uint Level, bool State);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern void GetSystemInfo(out SYSTEM_INFO lpSystemInfo);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern IntPtr memset(IntPtr Dst, int val, uint size);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool VirtualFree(IntPtr lpAddress, uint dwSize, uint dwFreeType);

        [DllImport("kernel32.dll")]
        private static extern int GetLastError();

        #endregion

        /// <summary>
        /// Attempts to close an invalid handle to detect debugger presence.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if an exception is caught, indicating no debugger, otherwise false.</returns>
        public static bool NtCloseAntiDebug_InvalidHandle(bool Syscall)
        {
            try
            {
                int RandomInt = new Random().Next(int.MinValue, int.MaxValue);
                IntPtr RandomIntPtr = new IntPtr(RandomInt);
                if (Syscall)
                    Syscalls.SyscallNtClose(RandomIntPtr);
                else
                    NtClose(RandomIntPtr);
                return false;
            }
            catch
            {
                return true;
            }
        }

        /// <summary>
        /// Attempts to close a protected handle to detect debugger presence.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if an exception is caught, indicating no debugger, otherwise false.</returns>
        public static bool NtCloseAntiDebug_ProtectedHandle(bool Syscall)
        {
            string RandomMutexName = new Random().Next(int.MinValue, int.MaxValue).ToString();
            IntPtr hMutex = CreateMutexA(IntPtr.Zero, false, RandomMutexName);
            uint HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002;
            SetHandleInformation(hMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE);
            bool Result = false;
            try
            {
                if (Syscall)
                    Syscalls.SyscallNtClose(hMutex);
                else
                    NtClose(hMutex);
                Result = false;
            }
            catch
            {
                Result = true;
            }
            SetHandleInformation(hMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
            NtClose(hMutex);
            return Result;
        }

        /// <summary>
        /// Checks if a debugger is attached to the process.
        /// </summary>
        /// <returns>Returns true if a debugger is attached, otherwise false.</returns>
        public static bool DebuggerIsAttached()
        {
            return Debugger.IsAttached;
        }

        /// <summary>
        /// Checks if a debugger is present using the IsDebuggerPresent API.
        /// </summary>
        /// <returns>Returns true if a debugger is present, otherwise false.</returns>
        public static bool IsDebuggerPresentCheck()
        {
            if (IsDebuggerPresent())
                return true;
            return false;
        }

        /// <summary>
        /// Checks for the BeingDebugged flag directly.
        /// </summary>
        /// <returns>Returns true if a debugger is present, otherwise false.</returns>
        public static bool BeingDebuggedCheck()
        {
            byte[] Code = new byte[30];
            if (IntPtr.Size == 8)
                Code = new byte[] { 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x0F, 0xB6, 0x40, 0x02, 0xC3 };
            else
                Code = new byte[] { 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x0F, 0xB6, 0x40, 0x02, 0xC3 };
            IntPtr BeingDebugged = Utils.AllocateCode(Code);
            if (BeingDebugged != IntPtr.Zero)
            {
                try
                {
                    Delegates.GenericInt Executed = (Delegates.GenericInt)Marshal.GetDelegateForFunctionPointer(BeingDebugged, typeof(Delegates.GenericInt));
                    int Result = Executed();
                    Utils.FreeCode(BeingDebugged);
                    if(Result == 1)
                        return true;
                }
                catch
                {
                    Utils.FreeCode(BeingDebugged);
                }
            }
            return false;
        }

        /// <summary>
        /// Checks for the NtGlobalFlag directly.
        /// </summary>
        /// <returns>Returns true if a debugger is present, otherwise false.</returns>
        public static bool NtGlobalFlagCheck()
        {
            byte[] Code = new byte[30];
            if (IntPtr.Size == 8)
                Code = new byte[] { 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xBC, 0x00, 0x00, 0x00, 0x48, 0x83, 0xE0, 0x70, 0x48, 0x83, 0xF8, 0x70, 0x74, 0x04, 0x48, 0x31, 0xC0, 0xC3, 0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00, 0xC3 };
            else
                Code = new byte[] { 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x68, 0x83, 0xE0, 0x70, 0x83, 0xF8, 0x70, 0x74, 0x03, 0x31, 0xC0, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xC3 };
            IntPtr NtGlobalFlag = Utils.AllocateCode(Code);
            if (NtGlobalFlag != IntPtr.Zero)
            {
                try
                {
                    Delegates.GenericInt Executed = (Delegates.GenericInt)Marshal.GetDelegateForFunctionPointer(NtGlobalFlag, typeof(Delegates.GenericInt));
                    int Result = Executed();
                    Utils.FreeCode(NtGlobalFlag);
                    if (Result == 1)
                        return true;
                }
                catch
                {
                    Utils.FreeCode(NtGlobalFlag);
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if the process has debug flags set using NtQueryInformationProcess
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if debug flags are set, otherwise false.</returns>
        public static bool NtQueryInformationProcessCheck_ProcessDebugFlags(bool Syscall)
        {
            uint ProcessDebugFlags = 0;
            uint Class = 0x1F;
            uint Size = sizeof(uint);
            uint Result = 0;
            if (Syscall)
                Syscalls.SyscallNtQueryInformationProcess(Class, out ProcessDebugFlags, Size, out Result);
            else
                NtQueryInformationProcess(new IntPtr(-1), 0x1F, out ProcessDebugFlags, sizeof(uint), 0);
            if (ProcessDebugFlags == 0)
                return true;
            return false;
        }

        /// <summary>
        /// Checks if the process has a debug port using NtQueryInformationProcess.
        /// <param name="Syscall">specifies if we should use syscalls to call the WinAPI functions.</param>.
        /// </summary>
        /// <returns>Returns true if a debug port is detected, otherwise false.</returns>
        public static bool NtQueryInformationProcessCheck_ProcessDebugPort(bool Syscall)
        {
            uint DebuggerPresent = 0;
            uint Size = sizeof(uint);
            if (Environment.Is64BitProcess)
                Size = sizeof(uint) * 2;
            uint Result = 0;
            if(Syscall)
                Syscalls.SyscallNtQueryInformationProcess(7, out DebuggerPresent, Size, out Result);
            else
                NtQueryInformationProcess(new IntPtr(-1), 7, out DebuggerPresent, Size, 0);
            if (DebuggerPresent != 0)
                return true;
            return false;
        }

        /// <summary>
        /// Checks if the process has a debug object handle using NtQueryInformationProcess.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if a debug object handle is detected, otherwise false.</returns>
        public static bool NtQueryInformationProcessCheck_ProcessDebugObjectHandle(bool Syscall)
        {
            IntPtr hDebugObject = IntPtr.Zero;
            uint Size = sizeof(uint);
            if (Environment.Is64BitProcess)
                Size = sizeof(uint) * 2;

            if (Syscall)
                Syscalls.SyscallNtQueryInformationProcess(0x1E, out hDebugObject, Size, 0);
            else
                NtQueryInformationProcess(new IntPtr(-1), 0x1E, out hDebugObject, Size, 0);
            if (hDebugObject != IntPtr.Zero)
                return true;
            return false;
        }

        /// <summary>
        /// Patches the DbgUiRemoteBreakin and DbgBreakPoint functions to prevent debugger attachment.
        /// </summary>
        /// <returns>Returns "Success" if the patching was successful, otherwise "Failed".</returns>
        public static string AntiDebugAttach()
        {
            IntPtr NtdllModule = Utils.LowLevelGetModuleHandle("ntdll.dll");
            IntPtr DbgUiRemoteBreakinAddress = Utils.LowLevelGetProcAddress(NtdllModule, "DbgUiRemoteBreakin");
            IntPtr DbgBreakPointAddress = Utils.LowLevelGetProcAddress(NtdllModule, "DbgBreakPoint");
            byte[] Int3InvaildCode = { 0xCC };
            byte[] RetCode = { 0xC3 };
            bool Status = WriteProcessMemory(Process.GetCurrentProcess().SafeHandle, DbgUiRemoteBreakinAddress, Int3InvaildCode, 1, 0);
            bool Status2 = WriteProcessMemory(Process.GetCurrentProcess().SafeHandle, DbgBreakPointAddress, RetCode, 1, 0);
            if (Status && Status2)
                return "Success";
            return "Failed";
        }

        /// <summary>
        /// Checks for the presence of known debugger windows.
        /// </summary>
        /// <returns>Returns true if a known debugger window is detected, otherwise false.</returns>
        public static bool FindWindowAntiDebug()
        {
            string[] BadWindowNames = { "x32dbg", "x64dbg", "windbg", "ollydbg", "dnspy", "immunity debugger", "hyperdbg", "cheat engine", "cheatengine", "ida" };
            Process[] GetProcesses = Process.GetProcesses();
            foreach (Process GetWindow in GetProcesses)
            {
                try
                {
                    if (GetWindow.MainWindowHandle != IntPtr.Zero)
                    {
                        string title = GetWindow.MainWindowTitle;
                        if (string.IsNullOrEmpty(title)) continue;

                        foreach (string BadWindows in BadWindowNames)
                        {
                            if (Utils.Contains(title, BadWindows))
                            {
                                GetWindow.Close();
                                return true;
                            }
                        }
                    }
                }
                catch
                {
                    continue;
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if the foreground window belongs to a known debugger.
        /// </summary>
        /// <returns>Returns true if a known debugger window is detected, otherwise false.</returns>
        public static bool NtUserGetForegroundWindowAntiDebug()
        {
            string[] BadWindowNames = { "x32dbg", "x64dbg", "windbg", "ollydbg", "dnspy", "immunity debugger", "hyperdbg", "debug", "debugger", "cheat engine", "cheatengine", "ida" };
            IntPtr HWND = NtUserGetForegroundWindow();
            if (HWND != IntPtr.Zero)
            {
                int WindowLength = GetWindowTextLengthA(HWND);
                if (WindowLength != 0)
                {
                    StringBuilder WindowName = new StringBuilder(WindowLength + 1);
                    GetWindowTextA(HWND, WindowName, WindowLength + 1);
                    foreach (string BadWindows in BadWindowNames)
                    {
                        if (Utils.Contains(WindowName.ToString().ToLower(), BadWindows))
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Hides threads from the debugger by setting the NtSetInformationThread.
        /// </summary>
        /// <returns>Returns "Success" if the threads were hidden successfully, otherwise "Failed".</returns>
        public static string HideThreadsAntiDebug()
        {
            try
            {
                bool AnyThreadFailed = false;
                int PID = Process.GetCurrentProcess().Id;
                ProcessThreadCollection GetCurrentProcessThreads = Process.GetCurrentProcess().Threads;
                foreach (ProcessThread Threads in GetCurrentProcessThreads)
                {
                    CLIENT_ID CI = new CLIENT_ID
                    {
                        UniqueProcess = (IntPtr)PID,
                        UniqueThread = (IntPtr)Threads.Id
                    };

                    OBJECT_ATTRIBUTES Attributes = new OBJECT_ATTRIBUTES
                    {
                        Length = Marshal.SizeOf(typeof(OBJECT_ATTRIBUTES)),
                        RootDirectory = IntPtr.Zero,
                        ObjectName = IntPtr.Zero,
                        Attributes = 0,
                        SecurityDescriptor = IntPtr.Zero,
                        SecurityQualityOfService = IntPtr.Zero
                    };

                    IntPtr hThread = IntPtr.Zero;
                    uint Status = NtOpenThread(out hThread, 0x0020, ref Attributes, ref CI);
                    if (Status == 0 || hThread != IntPtr.Zero)
                    {
                        uint Status2 = NtSetInformationThread(hThread, 0x11, IntPtr.Zero, 0);
                        NtClose(hThread);
                        if (Status2 != 0x00000000)
                            AnyThreadFailed = true;
                    }
                }
                if (!AnyThreadFailed)
                    return "Success";
                return "Failed";
            }
            catch
            {
                return "Failed";
            }
        }

        /// <summary>
        /// Uses GetTickCount to detect debugger presence.
        /// </summary>
        /// <returns>Returns true if debugger presence is detected, otherwise false.</returns>
        public static bool GetTickCountAntiDebug()
        {
            uint Start = GetTickCount();
            Thread.Sleep(0x10);
            return (GetTickCount() - Start) > 0x10;
        }

        /// <summary>
        /// Uses OutputDebugString to detect debugger presence.
        /// </summary>
        /// <returns>Returns true if debugger presence is detected, otherwise false.</returns>
        public static bool OutputDebugStringAntiDebug()
        {
            Debugger.Log(0, null, "just testing some stuff...");
            if (Marshal.GetLastWin32Error() == 0)
                return true;
            return false;
        }

        /// <summary>
        /// Exploits a format string vulnerability in OllyDbg.
        /// </summary>
        public static void OllyDbgFormatStringExploit()
        {
            Debugger.Log(0, null, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s");
        }

        /// <summary>
        /// Triggers a debug break to detect debugger presence.
        /// </summary>
        /// <returns>Returns true if an exception is caught, indicating no debugger, otherwise false.</returns>
        public static bool DebugBreakAntiDebug()
        {
            try
            {
                Utils.CallInternalCLRFunction("BreakInternal", typeof(Debugger), BindingFlags.NonPublic | BindingFlags.Static, null, null);
                return false;
            }
            catch
            {
                return true;
            }
        }

        private static long CONTEXT_DEBUG_REGISTERS = 0x00010000L | 0x00000010L;

        /// <summary>
        /// Detects hardware breakpoints by checking debug registers.
        /// </summary>
        /// <returns>Returns true if hardware breakpoints are detected, otherwise false.</returns>
        public static bool HardwareRegistersBreakpointsDetection()
        {
            CONTEXT Context = new CONTEXT();
            Context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
            int PID = Process.GetCurrentProcess().Id;
            foreach (ProcessThread Threads in Process.GetCurrentProcess().Threads)
            {
                uint THREAD_QUERY_INFORMATION = 0x0040;
                CLIENT_ID CI = new CLIENT_ID
                {
                    UniqueProcess = (IntPtr)PID,
                    UniqueThread = (IntPtr)Threads.Id
                };

                OBJECT_ATTRIBUTES Attributes = new OBJECT_ATTRIBUTES
                {
                    Length = Marshal.SizeOf(typeof(OBJECT_ATTRIBUTES)),
                    RootDirectory = IntPtr.Zero,
                    ObjectName = IntPtr.Zero,
                    Attributes = 0,
                    SecurityDescriptor = IntPtr.Zero,
                    SecurityQualityOfService = IntPtr.Zero
                };

                IntPtr hThread = IntPtr.Zero;
                uint Status = NtOpenThread(out hThread, THREAD_QUERY_INFORMATION, ref Attributes, ref CI);
                if (Status == 0 || hThread != IntPtr.Zero)
                {
                    if (NtGetContextThread(hThread, ref Context))
                    {
                        if ((Context.Dr1 != 0x00 || Context.Dr2 != 0x00 || Context.Dr3 != 0x00 || Context.Dr6 != 0x00 || Context.Dr7 != 0x00))
                        {
                            NtClose(hThread);
                            return true;
                        }
                    }
                    NtClose(hThread);
                }
            }
            return false;
        }

        /// <summary>
        /// Cleans the specified path by removing null characters.
        /// </summary>
        /// <param name="Path">The path to clean.</param>
        /// <returns>The cleaned path.</returns>
        private static string CleanPath(string Path)
        {
            string CleanedPath = null;
            foreach (char Null in Path)
            {
                if (Null != '\0')
                {
                    CleanedPath += Null;
                }
            }
            return CleanedPath;
        }

        /// <summary>
        /// Checks if the parent process is a debugger by querying process information.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if the parent process is a debugger, otherwise false.</returns>
        public static bool ParentProcessAntiDebug(bool Syscall)
        {
            try
            {
                PROCESS_BASIC_INFORMATION PBI = new PROCESS_BASIC_INFORMATION();
                uint ProcessBasicInformation = 0;
                uint Result = Syscall ? Syscalls.SyscallNtQueryInformationProcess(ProcessBasicInformation, ref PBI, (uint)Marshal.SizeOf(typeof(PROCESS_BASIC_INFORMATION)), 0) : NtQueryInformationProcess(new IntPtr(-1), ProcessBasicInformation, ref PBI, (uint)Marshal.SizeOf(typeof(PROCESS_BASIC_INFORMATION)), 0);
                if (Result == 0)
                {
                    int ParentPID = PBI.InheritedFromUniqueProcessId.ToInt32();
                    if (ParentPID != 0)
                    {
                        byte[] FileNameBuffer = new byte[256];
                        Int32[] Size = new Int32[256];
                        Size[0] = 256;
                        QueryFullProcessImageNameA(Process.GetProcessById(ParentPID).SafeHandle, 0, FileNameBuffer, Size);
                        string ParentFilePath = CleanPath(Encoding.UTF8.GetString(FileNameBuffer));
                        string ParentFileName = Path.GetFileName(ParentFilePath);
                        string[] Whitelisted = { "explorer.exe", "cmd.exe" };
                        foreach (string WhitelistedFileName in Whitelisted)
                        {
                            if (ParentFileName.Equals(WhitelistedFileName))
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                }
            }
            catch { }
            return false;
        }

        /// <summary>
        /// Uses NtSetDebugFilterState to prevent debugging.
        /// </summary>
        /// <returns>Returns true if the filter state was set successfully, otherwise false.</returns>
        public static bool NtSetDebugFilterStateAntiDebug()
        {
            if (NtSetDebugFilterState(0, 0, true) != 0)
                return false;
            return true;
        }

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate int ExecutionDelegate();

        /// <summary>
        /// Uses page guard to detect debugger presence by executing a function pointer.
        /// </summary>
        /// <returns>Returns true if debugger presence is detected, otherwise false.</returns>
        public static bool PageGuardAntiDebug()
        {
            SYSTEM_INFO SysInfo = new SYSTEM_INFO();
            GetSystemInfo(out SysInfo);
            uint MEM_COMMIT = 0x00001000;
            uint MEM_RESERVE = 0x00002000;
            uint PAGE_EXECUTE_READWRITE = 0x40;
            uint PAGE_GUARD = 0x100;
            uint MEM_RELEASE = 0x00008000;
            IntPtr AllocatedSpace = VirtualAlloc(IntPtr.Zero, SysInfo.PageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (AllocatedSpace != IntPtr.Zero)
            {
                memset(AllocatedSpace, 1, 0xC3);
                uint OldProtect = 0;
                if (Utils.ProtectMemory(AllocatedSpace, (UIntPtr)SysInfo.PageSize, PAGE_EXECUTE_READWRITE | PAGE_GUARD, out OldProtect))
                {
                    try
                    {
                        ExecutionDelegate IsDebugged = Marshal.GetDelegateForFunctionPointer<ExecutionDelegate>(AllocatedSpace);
                        int Result = IsDebugged();
                    }
                    catch
                    {
                        VirtualFree(AllocatedSpace, SysInfo.PageSize, MEM_RELEASE);
                        return false;
                    }
                    VirtualFree(AllocatedSpace, SysInfo.PageSize, MEM_RELEASE);
                    return true;
                }
            }
            return false;
        }
    }
}


================================================
File: AntiCrack-DotNet/AntiInjection.cs
================================================
√Ø¬ª¬øusing System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using static AntiCrack_DotNet.Structs;

namespace AntiCrack_DotNet
{
    [Flags]
    public enum Spoofs
    {
        BaseAddress = 1 << 0,
        ModuleName = 1 << 1,
        AddressOfEntryPoint = 1 << 2,
        SizeOfImage = 1 << 3,
        NumberOfSections = 1 << 4,
        ImageMagic = 1 << 5,
        NotExecutableNorDll = 1 << 6,
        PESignature = 1 << 7,
        ExecutableSectionName = 1 << 8,
        ExecutableSectionRawSize = 1 << 9,
        ExecutableSectionRawPointer = 1 << 10,
        ClearExecutableSectionCharacteristics = 1 << 11,
        ExecutableSectionVirtualSize = 1 << 12,
    }

    internal sealed class AntiInjection
    {

        #region WinApi

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetModuleHandle(string lib);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetProcAddress(IntPtr ModuleHandle, string Function);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool WriteProcessMemory(SafeHandle hProcess, IntPtr BaseAddress, byte[] Buffer, uint size, int NumOfBytes);

        [DllImport("kernelbase.dll", SetLastError = true)]
        public static extern bool SetProcessMitigationPolicy(int policy, ref Structs.PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY lpBuffer, int size);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtOpenThread(out IntPtr hThread, uint dwDesiredAccess, ref Structs.OBJECT_ATTRIBUTES ObjectAttributes, ref Structs.CLIENT_ID ClientID);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern int NtQueryInformationThread(IntPtr ThreadHandle, int ThreadInformationClass, ref IntPtr ThreadInformation, uint ThreadInformationLength, IntPtr ReturnLength);

        #endregion

        /// <summary>
        /// Sets the DLL load policy to only allow Microsoft-signed DLLs to be loaded.
        /// </summary>
        /// <returns>Returns "Success" if the policy was set successfully, otherwise "Failed".</returns>
        public static string SetDllLoadPolicy()
        {
            Structs.PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = new Structs.PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
            {
                MicrosoftSignedOnly = 1
            };
            if (SetProcessMitigationPolicy(8, ref policy, Marshal.SizeOf(policy)))
                return "Success";
            return "Failed";
        }

        /// <summary>
        /// Detects if an address is in range inside modules or not.
        /// </summary>
        /// <param name="Address">The address to check for.</param>
        /// <returns>Returns true if the address is in no module, otherwise false.</returns>
        private static bool IsAddressInRange(IntPtr Address)
        {
            foreach (ProcessModule module in Process.GetCurrentProcess().Modules)
            {
                IntPtr Base = module.BaseAddress;
                IntPtr End = IntPtr.Add(Base, module.ModuleMemorySize);
                if (Address.ToInt64() >= Base.ToInt64() && Address.ToInt64() < End.ToInt64())
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Detects if an address is in range inside modules or not.
        /// </summary>
        /// <param name="Syscall">Specifies whether we use syscalls for the check or not.</param>
        /// <param name="CheckModuleRange">Check if the threads start address is within modules range or not.</param>
        /// <returns>Returns true if no thread is injected, otherwise false.</returns>
        public static bool CheckInjectedThreads(bool Syscall, bool CheckModuleRange)
        {
            uint MEM_IMAGE = 0x1000000;
            uint MEM_COMMIT = 0x1000;
            int ThreadQuerySetWin32StartAddress = 9;
            uint THREAD_QUERY_INFORMATION = 0x0040;
            int PID = Process.GetCurrentProcess().Id;
            foreach (ProcessThread thread in Process.GetCurrentProcess().Threads)
            {
                CLIENT_ID CI = new CLIENT_ID
                {
                    UniqueProcess = (IntPtr)PID,
                    UniqueThread = (IntPtr)thread.Id
                };

                OBJECT_ATTRIBUTES Attributes = new OBJECT_ATTRIBUTES
                {
                    Length = Marshal.SizeOf(typeof(OBJECT_ATTRIBUTES)),
                    RootDirectory = IntPtr.Zero,
                    ObjectName = IntPtr.Zero,
                    Attributes = 0,
                    SecurityDescriptor = IntPtr.Zero,
                    SecurityQualityOfService = IntPtr.Zero
                };

                IntPtr hThread = IntPtr.Zero;
                uint Status = NtOpenThread(out hThread, THREAD_QUERY_INFORMATION, ref Attributes, ref CI);
                if (Status == 0 || hThread != IntPtr.Zero)
                {
                    IntPtr StartAddress = IntPtr.Zero;
                    int QueryStatus = Syscall ? Syscalls.SyscallNtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, ref StartAddress, (uint)IntPtr.Size, IntPtr.Zero) : NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, ref StartAddress, (uint)IntPtr.Size, IntPtr.Zero);
                    Utils.CloseHandle(hThread);
                    if (QueryStatus == 0)
                    {
                        MEMORY_BASIC_INFORMATION MBI = new MEMORY_BASIC_INFORMATION();
                        if (Utils.GetVirtualMemoryQuery(Syscall, StartAddress, ref MBI, out _))
                        {
                            if (MBI.Type != MEM_IMAGE || MBI.State != MEM_COMMIT)
                            {
                                return true;
                            }

                            if (CheckModuleRange)
                            {
                                if (!IsAddressInRange(StartAddress))
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Generate a random module name.
        /// </summary>
        /// <returns>the random module name.</returns>
        private static string GenerateRandomString()
        {
            string Letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            Random random = new Random();
            int RandomLength = random.Next(6, 32);
            char[] NewModule = new char[RandomLength];
            for (int i = 0; i < RandomLength; i++)
            {
                NewModule[i] = Letters[random.Next(Letters.Length)];
            }
            return new string(NewModule);
        }

        private static bool IsFlagsSet(Spoofs SpoofOptions, Spoofs[] spoofs)
        {
            foreach (Spoofs spoofa in spoofs)
            {
                if (SpoofOptions.HasFlag(spoofa))
                    return true;
            }
            return false;
        }

        private static bool IsPE_FlagsSet(Spoofs SpoofOptions)
        {
            Spoofs[] spoofs = {
        Spoofs.AddressOfEntryPoint, Spoofs.SizeOfImage, Spoofs.ExecutableSectionRawSize,
        Spoofs.ExecutableSectionRawPointer, Spoofs.PESignature, Spoofs.ImageMagic,
        Spoofs.NotExecutableNorDll, Spoofs.NumberOfSections, Spoofs.ClearExecutableSectionCharacteristics,
        Spoofs.ExecutableSectionVirtualSize };
            return IsFlagsSet(SpoofOptions, spoofs);
        }

        /// <summary>
        /// Changes the module information at runtime to avoid modification/lookups.
        /// </summary>
        /// <param name="ModuleName">The module name which we will change it's information. if left null, we get the main module of the process.</param>
        /// <param name="SpoofOptions">The spoofing options to apply.</param>
        /// <returns>Returns true if successfully changed the module info, otherwise false.</returns>
        public static bool ChangeModuleInfo(string ModuleName, Spoofs SpoofOptions)
        {
            try
            {
                string FinalModuleName = ModuleName ?? Process.GetCurrentProcess().MainModule.ModuleName;
                if (string.IsNullOrEmpty(FinalModuleName))
                    return false;

                IntPtr hModule = Utils.LowLevelGetModuleHandle(FinalModuleName);
                if (hModule == IntPtr.Zero)
                    return false;

                string Fake = $"{GenerateRandomString()}.dll";
                PEB Peb = Utils.GetPEB();
                _PEB_LDR_DATA Ldr = Marshal.PtrToStructure<_PEB_LDR_DATA>(Peb.Ldr);
                IntPtr f = Ldr.InMemoryOrderModuleList.Flink;
                Random RandGen = new Random();

                for (int count = 0; count < 256 && f != IntPtr.Zero; count++)
                {
                    _LDR_DATA_TABLE_ENTRY TableEntry = Marshal.PtrToStructure<_LDR_DATA_TABLE_ENTRY>(f);
                    string ModuleNameBuffer = Marshal.PtrToStringUni(TableEntry.FullDllName.Buffer);

                    if (!string.IsNullOrEmpty(ModuleNameBuffer) && ModuleNameBuffer == FinalModuleName)
                    {
                        if (IsPE_FlagsSet(SpoofOptions))
                        {
                            Spoofs[] SectionSpoof = {
                        Spoofs.ExecutableSectionName, Spoofs.ExecutableSectionRawPointer,
                        Spoofs.ExecutableSectionRawSize, Spoofs.ClearExecutableSectionCharacteristics, Spoofs.ExecutableSectionVirtualSize};

                            IMAGE_DOS_HEADER dosHeader = Marshal.PtrToStructure<IMAGE_DOS_HEADER>(hModule);
                            IntPtr pNtHeaders = IntPtr.Add(hModule, dosHeader.e_lfanew);

                            if (IntPtr.Size == 8)
                            {
                                IMAGE_NT_HEADERS64 NtHeadersStruct = Marshal.PtrToStructure<IMAGE_NT_HEADERS64>(pNtHeaders);
                                if (SpoofOptions.HasFlag(Spoofs.AddressOfEntryPoint))
                                    NtHeadersStruct.OptionalHeader.AddressOfEntryPoint = (uint)RandGen.Next(0x1000, 0x2000);

                                if (SpoofOptions.HasFlag(Spoofs.NumberOfSections))
                                    NtHeadersStruct.FileHeader.NumberOfSections = (ushort)RandGen.Next(NtHeadersStruct.FileHeader.NumberOfSections, NtHeadersStruct.FileHeader.NumberOfSections + 99);

                                if (SpoofOptions.HasFlag(Spoofs.ImageMagic))
                                    NtHeadersStruct.OptionalHeader.Magic = (ushort)RandGen.Next(0, int.MaxValue);

                                if (SpoofOptions.HasFlag(Spoofs.SizeOfImage))
                                    NtHeadersStruct.OptionalHeader.SizeOfImage = (uint)RandGen.Next((int)NtHeadersStruct.OptionalHeader.SizeOfImage, (int)(NtHeadersStruct.OptionalHeader.SizeOfImage + 0x10000));

                                if (SpoofOptions.HasFlag(Spoofs.NotExecutableNorDll))
                                {
                                    ushort IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
                                    ushort IMAGE_FILE_DLL = 0x2000;
                                    NtHeadersStruct.FileHeader.Characteristics &= (ushort)~IMAGE_FILE_EXECUTABLE_IMAGE;
                                    NtHeadersStruct.FileHeader.Characteristics &= (ushort)~IMAGE_FILE_DLL;
                                }

                                if (SpoofOptions.HasFlag(Spoofs.PESignature))
                                    NtHeadersStruct.Signature = 0x4D5A0000;

                                if (IsFlagsSet(SpoofOptions, SectionSpoof))
                                {
                                    IntPtr pSectionHeaders = IntPtr.Add(pNtHeaders, sizeof(uint) + Marshal.SizeOf(typeof(IMAGE_FILE_HEADER)) + NtHeadersStruct.FileHeader.SizeOfOptionalHeader); //defined in here for now
                                    IntPtr pSectionHeader = pSectionHeaders;
                                    int SectionSize = Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER));

                                    for (int i = 0; i < NtHeadersStruct.FileHeader.NumberOfSections; i++)
                                    {
                                        IMAGE_SECTION_HEADER SectionHeader = Marshal.PtrToStructure<IMAGE_SECTION_HEADER>(pSectionHeader);
                                        uint IMAGE_SCN_CNT_CODE = 0x00000020;
                                        if ((SectionHeader.Characteristics & IMAGE_SCN_CNT_CODE) == IMAGE_SCN_CNT_CODE)
                                        {
                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionName))
                                                SectionHeader.Name = Encoding.ASCII.GetBytes($".{GenerateRandomString()}");

                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionRawPointer))
                                                SectionHeader.PointerToRawData = (uint)RandGen.Next(0, int.MaxValue);

                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionRawSize))
                                                SectionHeader.SizeOfRawData = (uint)RandGen.Next(0, int.MaxValue);

                                            if (SpoofOptions.HasFlag(Spoofs.ClearExecutableSectionCharacteristics))
                                                SectionHeader.Characteristics = 0;

                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionVirtualSize))
                                                SectionHeader.VirtualSize = (uint)RandGen.Next((int)SectionHeader.VirtualSize, (int)SectionHeader.VirtualSize + 0x10000);

                                            Utils.WriteStructToPtr(SectionHeader, pSectionHeader, true, true);
                                            break;
                                        }

                                        pSectionHeader = IntPtr.Add(pSectionHeader, SectionSize);
                                    }
                                }

                                Utils.WriteStructToPtr(NtHeadersStruct, pNtHeaders, true, true);
                            }
                            else
                            {
                                IMAGE_NT_HEADERS32 NtHeadersStruct = Marshal.PtrToStructure<IMAGE_NT_HEADERS32>(pNtHeaders);
                                if (SpoofOptions.HasFlag(Spoofs.AddressOfEntryPoint))
                                    NtHeadersStruct.OptionalHeader.AddressOfEntryPoint = (uint)RandGen.Next(0x1000, 0x2000);

                                if (SpoofOptions.HasFlag(Spoofs.NumberOfSections))
                                    NtHeadersStruct.FileHeader.NumberOfSections = (ushort)RandGen.Next(NtHeadersStruct.FileHeader.NumberOfSections, NtHeadersStruct.FileHeader.NumberOfSections + 99);

                                if (SpoofOptions.HasFlag(Spoofs.ImageMagic))
                                    NtHeadersStruct.OptionalHeader.Magic = (ushort)RandGen.Next(0, int.MaxValue);

                                if (SpoofOptions.HasFlag(Spoofs.SizeOfImage))
                                    NtHeadersStruct.OptionalHeader.SizeOfImage = (uint)RandGen.Next((int)NtHeadersStruct.OptionalHeader.SizeOfImage, (int)(NtHeadersStruct.OptionalHeader.SizeOfImage + 0x10000));

                                if (SpoofOptions.HasFlag(Spoofs.NotExecutableNorDll))
                                {
                                    ushort IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002;
                                    ushort IMAGE_FILE_DLL = 0x2000;
                                    NtHeadersStruct.FileHeader.Characteristics &= (ushort)~IMAGE_FILE_EXECUTABLE_IMAGE;
                                    NtHeadersStruct.FileHeader.Characteristics &= (ushort)~IMAGE_FILE_DLL;
                                }

                                if (SpoofOptions.HasFlag(Spoofs.PESignature))
                                    NtHeadersStruct.Signature = 0x4D5A0000;

                                if (IsFlagsSet(SpoofOptions, SectionSpoof))
                                {
                                    IntPtr pSectionHeaders = IntPtr.Add(pNtHeaders, sizeof(uint) + Marshal.SizeOf(typeof(IMAGE_FILE_HEADER)) + NtHeadersStruct.FileHeader.SizeOfOptionalHeader); //defined in here for now
                                    IntPtr pSectionHeader = pSectionHeaders;
                                    int SectionSize = Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER));

                                    for (int i = 0; i < NtHeadersStruct.FileHeader.NumberOfSections; i++)
                                    {
                                        IMAGE_SECTION_HEADER SectionHeader = Marshal.PtrToStructure<IMAGE_SECTION_HEADER>(pSectionHeader);
                                        uint IMAGE_SCN_CNT_CODE = 0x00000020;
                                        if ((SectionHeader.Characteristics & IMAGE_SCN_CNT_CODE) == IMAGE_SCN_CNT_CODE)
                                        {
                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionName))
                                                SectionHeader.Name = Encoding.ASCII.GetBytes($".{GenerateRandomString()}");

                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionRawPointer))
                                                SectionHeader.PointerToRawData = (uint)RandGen.Next(0, int.MaxValue);

                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionRawSize))
                                                SectionHeader.SizeOfRawData = (uint)RandGen.Next(0, int.MaxValue);

                                            if (SpoofOptions.HasFlag(Spoofs.ClearExecutableSectionCharacteristics))
                                                SectionHeader.Characteristics = 0;

                                            if (SpoofOptions.HasFlag(Spoofs.ExecutableSectionVirtualSize))
                                                SectionHeader.VirtualSize = (uint)RandGen.Next((int)SectionHeader.VirtualSize, (int)SectionHeader.VirtualSize + 0x10000);

                                            Utils.WriteStructToPtr(SectionHeader, pSectionHeader, true, true);
                                            break;
                                        }

                                        pSectionHeader = IntPtr.Add(pSectionHeader, SectionSize);
                                    }
                                }

                                Utils.WriteStructToPtr(NtHeadersStruct, pNtHeaders, true, true);
                            }
                        }

                        if (SpoofOptions.HasFlag(Spoofs.BaseAddress))
                        {
                            TableEntry.DllBase = (IntPtr)(RandGen.Next(0x100000 / 0x1000, 0x7FFF000 / 0x1000) * 0x1000);
                        }

                        if (SpoofOptions.HasFlag(Spoofs.ModuleName))
                        {
                            IntPtr FakeDllBuffer = Marshal.StringToHGlobalUni(Fake);
                            TableEntry.FullDllName.Buffer = FakeDllBuffer;
                            TableEntry.FullDllName.Length = (ushort)(Fake.Length * 2);
                            TableEntry.FullDllName.MaximumLength = (ushort)((Fake.Length + 1) * 2);
                        }

                        Utils.WriteStructToPtr(TableEntry, f, true, true);
                        return true;
                    }
                    f = TableEntry.InLoadOrderLinks.Flink;
                }
            }
            catch
            {
                return false;
            }
            return false;
        }

        /// <summary>
        /// Changes CLR Module ImageMagic to prevent critical info lookups.
        /// </summary>
        /// <returns>Returns true if successful, otherwise false.</returns>
        public static bool ChangeCLRModuleImageMagic()
        {
            string CLR = Utils.GetCurrentCLRModuleName();
            if (!string.IsNullOrEmpty(CLR))
            {
                return ChangeModuleInfo(CLR, Spoofs.ImageMagic);
            }
            return false;
        }


        /// <summary>
        /// Detects ImageBaseAddress modification which could indicate code injection in our process (process hollowing).
        /// </summary>
        /// <returns>Returns true if the ImageBaseAddress is suspicious, otherwise false.</returns>
        public static bool CheckForSuspiciousBaseAddress()
        {
            try
            {
                PEB Peb = Utils.GetPEB();
                if (Peb.ImageBaseAddress != Process.GetCurrentProcess().MainModule.BaseAddress)
                    return true;
            }
            catch
            {

            }
            return false;
        }
    }
}


================================================
File: AntiCrack-DotNet/AntiVirtualization.cs
================================================
√Ø¬ª¬øusing System;
using System.IO;
using System.Threading;
using System.Management;
using System.Diagnostics;
using System.ServiceProcess;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using static AntiCrack_DotNet.Utils;
using static AntiCrack_DotNet.Delegates;

namespace AntiCrack_DotNet
{
    internal sealed class AntiVirtualization
    {

        #region WinApi

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern void RtlInitUnicodeString(out Structs.UNICODE_STRING DestinationString, string SourceString);

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        private static extern void RtlUnicodeStringToAnsiString(out Structs.ANSI_STRING DestinationString, Structs.UNICODE_STRING UnicodeString, bool AllocateDestinationString);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint LdrGetDllHandleEx(ulong Flags, [MarshalAs(UnmanagedType.LPWStr)] string DllPath, [MarshalAs(UnmanagedType.LPWStr)] string DllCharacteristics, Structs.UNICODE_STRING LibraryName, ref IntPtr DllHandle);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetModuleHandleA(string Library);

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        private static extern uint LdrGetProcedureAddressForCaller(IntPtr Module, Structs.ANSI_STRING ProcedureName, ushort ProcedureNumber, out IntPtr FunctionHandle, ulong Flags, IntPtr CallBack);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool WriteProcessMemory(SafeHandle hProcess, IntPtr BaseAddress, byte[] Buffer, uint size, int NumOfBytes);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool IsProcessCritical(SafeHandle hProcess, ref bool BoolToCheck);

        [DllImport("ucrtbase.dll", SetLastError = true)]
        private static extern IntPtr fopen(string filename, string mode);

        [DllImport("ucrtbase.dll", SetLastError = true)]
        private static extern int fclose(IntPtr filestream);

        #endregion

        /// <summary>
        /// Checks if Sandboxie is present on the system.
        /// </summary>
        /// <returns>True if Sandboxie is detected, otherwise false.</returns>
        public static bool IsSandboxiePresent()
        {
            if (LowLevelGetModuleHandle("SbieDll.dll").ToInt32() != 0)
                return true;
            return false;
        }

        /// <summary>
        /// Checks if Comodo Sandbox is present on the system.
        /// </summary>
        /// <returns>True if Comodo Sandbox is detected, otherwise false.</returns>
        public static bool IsComodoSandboxPresent()
        {
            if (LowLevelGetModuleHandle("cmdvrt32.dll").ToInt32() != 0 || LowLevelGetModuleHandle("cmdvrt64.dll").ToInt32() != 0)
                return true;
            return false;
        }

        /// <summary>
        /// Checks if Qihoo 360 Sandbox is present on the system.
        /// </summary>
        /// <returns>True if Qihoo 360 Sandbox is detected, otherwise false.</returns>
        public static bool IsQihoo360SandboxPresent()
        {
            if (LowLevelGetModuleHandle("SxIn.dll").ToInt32() != 0)
                return true;
            return false;
        }

        /// <summary>
        /// Checks if Cuckoo Sandbox is present on the system.
        /// </summary>
        /// <returns>True if Cuckoo Sandbox is detected, otherwise false.</returns>
        public static bool IsCuckooSandboxPresent()
        {
            if (LowLevelGetModuleHandle("cuckoomon.dll").ToInt32() != 0)
                return true;
            return false;
        }

        /// <summary>
        /// Checks if the environment is running in Wine.
        /// </summary>
        /// <returns>True if Wine is detected, otherwise false.</returns>
        public static bool IsWinePresent()
        {
            IntPtr ModuleHandle = LowLevelGetModuleHandle("kernel32.dll");
            if (GetFunctionExportAddress(ModuleHandle, "wine_get_unix_file_name").ToInt32() != 0)
                return true;
            return false;
        }

        /// <summary>
        /// Checks if the environment is running in VMware or VirtualBox.
        /// </summary>
        /// <returns>True if VMware or VirtualBox is detected, otherwise false.</returns>
        public static bool CheckForVMwareAndVirtualBox()
        {
            using (ManagementObjectSearcher ObjectSearcher = new ManagementObjectSearcher("Select * from Win32_ComputerSystem"))
            {
                using (ManagementObjectCollection ObjectItems = ObjectSearcher.Get())
                {
                    foreach (ManagementBaseObject Item in ObjectItems)
                    {
                        string ManufacturerString = Item["Manufacturer"].ToString().ToLower();
                        string ModelName = Item["Model"].ToString();
                        if ((ManufacturerString == "microsoft corporation" && Contains(ModelName.ToUpperInvariant(), "VIRTUAL") || Contains(ManufacturerString, "vmware")))
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if the environment is running in KVM.
        /// </summary>
        /// <returns>True if KVM is detected, otherwise false.</returns>
        public static bool CheckForKVM()
        {
            string[] BadDriversList = { "balloon.sys", "netkvm.sys", "vioinput", "viofs.sys", "vioser.sys" };
            foreach (string Drivers in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.System), "*"))
            {
                foreach (string BadDrivers in BadDriversList)
                {
                    if (Contains(Drivers, BadDrivers))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Checks if the environment is running in Hyper-V.
        /// </summary>
        /// <returns>True if Hyper-V is detected, otherwise false.</returns>
        public static bool CheckForHyperV()
        {
            ServiceController[] GetServicesOnSystem = ServiceController.GetServices();
            foreach (ServiceController CompareServicesNames in GetServicesOnSystem)
            {
                string[] Services = { "vmbus", "VMBusHID", "hyperkbd" };
                foreach (string ServicesToCheck in Services)
                {
                    if (Contains(CompareServicesNames.ServiceName, ServicesToCheck))
                        return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if the current user name matches any blacklisted names.
        /// </summary>
        /// <returns>True if a blacklisted name is detected, otherwise false.</returns>
        public static bool CheckForBlacklistedNames()
        {
            string[] BadNames = { "Johnson", "Miller", "malware", "maltest", "CurrentUser", "Sandbox", "virus", "John Doe", "test user", "sand box", "WDAGUtilityAccount" };
            string Username = Environment.UserName.ToLower();
            foreach (string BadUsernames in BadNames)
            {
                if (Username == BadUsernames.ToLower())
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Detects bad VM-related files and directories on the system.
        /// </summary>
        /// <returns>True if bad VM-related files or directories are detected, otherwise false.</returns>
        public static bool BadVMFilesDetection()
        {
            try
            {
                string[] BadFileNames = { "VBoxMouse.sys", "VBoxGuest.sys", "VBoxSF.sys", "VBoxVideo.sys", "vmmouse.sys", "vboxogl.dll" };
                string[] BadDirs = { @"C:\Program Files\VMware", @"C:\Program Files\oracle\virtualbox guest additions" };
                foreach (string System32File in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.System)))
                {
                    try
                    {
                        foreach (string BadFileName in BadFileNames)
                        {
                            if (File.Exists(System32File) && Path.GetFileName(System32File).ToLower() == BadFileName.ToLower())
                            {
                                return true;
                            }
                        }
                    }
                    catch
                    {
                        continue;
                    }
                }

                foreach (string BadDir in BadDirs)
                {
                    if (Directory.Exists(BadDir.ToLower()))
                    {
                        return true;
                    }
                }
            }
            catch
            {

            }
            return false;
        }

        /// <summary>
        /// Checks for the presence of bad VM-related process names.
        /// </summary>
        /// <returns>True if bad VM-related process names are detected, otherwise false.</returns>
        public static bool BadVMProcessNames()
        {
            try
            {
                string[] BadProcessNames = { "vboxservice", "VGAuthService", "vmusrvc", "qemu-ga" };
                foreach (Process Processes in Process.GetProcesses())
                {
                    foreach (string BadProcessName in BadProcessNames)
                    {
                        if (Processes.ProcessName == BadProcessName)
                        {
                            return true;
                        }
                    }
                }
            }
            catch { }
            return false;
        }

        /// <summary>
        /// Checks for VM-related device names.
        /// </summary>
        /// <returns>True if VM-related device names are detected, otherwise false.</returns>
        public static bool CheckDevices()
        {
            string[] Devices = { "\\\\.\\pipe\\cuckoo", "\\\\.\\HGFS", "\\\\.\\vmci", "\\\\.\\VBoxMiniRdrDN", "\\\\.\\VBoxGuest", "\\\\.\\pipe\\VBoxMiniRdDN", "\\\\.\\VBoxTrayIPC", "\\\\.\\pipe\\VBoxTrayIPC" };
            foreach (string Device in Devices)
            {
                try
                {
                    IntPtr File = fopen(Device, "r");
                    if (File != IntPtr.Zero)
                    {
                        fclose(File);
                        return true;
                    }
                }
                catch
                {
                    continue;
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if the environment is running in Parallels.
        /// </summary>
        /// <returns>True if Parallels is detected, otherwise false.</returns>
        public static bool CheckForParallels()
        {
            string[] BadDriversList = { "prl_sf", "prl_tg", "prl_eth" };
            foreach (string Drivers in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.System), "*"))
            {
                foreach (string BadDrivers in BadDriversList)
                {
                    if (Contains(Drivers, BadDrivers))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Checks for specific disk drive models that indicate a virtual environment.
        /// </summary>
        /// <returns>True if specific disk drive models are detected, otherwise false.</returns>
        public static bool TriageCheck()
        {
            using (var searcher = new ManagementObjectSearcher("SELECT * FROM Win32_DiskDrive"))
            {
                foreach (var item in searcher.Get())
                {
                    string model = item["Model"].ToString();
                    if (Contains(model, "DADY HARDDISK") || Contains(model, "QEMU HARDDISK"))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Checks for specific Machine GUIDs that indicate a virtual environment in Any.Run.
        /// </summary>
        /// <returns>True if specific Machine GUIDs are detected, otherwise false.</returns>
        public static bool AnyRunCheck()
        {
            string[] uuids = {
                "bb926e54-e3ca-40fd-ae90-2764341e7792", // win10 free
                "90059c37-1320-41a4-b58d-2b75a9850d2f", // win7 free
            };
            // https://app.any.run/tasks/a143d613-4e75-4cde-991a-6e096348bfec
            using (RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Cryptography"))
            {
                if (key != null)
                {
                    object value = key.GetValue("MachineGuid");

                    if (value != null)
                    {
                        foreach (string uuid in uuids)
                        {
                            if (uuid == value.ToString())
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if the environment is running in QEMU.
        /// </summary>
        /// <returns>True if QEMU is detected, otherwise false.</returns>
        public static bool CheckForQemu()
        {
            string[] BadDriversList = { "qemu-ga", "qemuwmi" };
            foreach (string Drivers in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.System), "*"))
            {
                foreach (string BadDrivers in BadDriversList)
                {
                    if (Contains(Drivers, BadDrivers))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public sealed class Generic
        {
            /// <summary>
            /// Checks for VM-related ports on the system.
            /// </summary>
            /// <returns>True if no port connectors are found, indicating a possible VM environment, otherwise false.</returns>
            public static bool PortConnectionAntiVM()
            {
                if (new ManagementObjectSearcher("SELECT * FROM Win32_PortConnector").Get().Count == 0)
                    return true;
                return false;
            }

            /// <summary>
            /// Checks if the environment is running in an emulation by measuring the sleep interval.
            /// </summary>
            /// <returns>True if emulation is detected, otherwise false.</returns>
            public static bool EmulationTimingCheck()
            {
                long Tick = Environment.TickCount;
                Thread.Sleep(500);
                long Tick2 = Environment.TickCount;
                if (((Tick2 - Tick) < 500L))
                {
                    return true;
                }
                return false;
            }

            /// <summary>
            /// Checks if the AVX instructions is properly implemented and handled.
            /// </summary>
            /// <returns>true if the instructions is not handled correctly, otherwise false.</returns>
            public static bool AVXInstructions()
            {
                try
                {
                    bool ResultBool = false;
                    byte[] Code = new byte[80];
                    if (IntPtr.Size == 8)
                        Code = new byte[] { 0x66, 0x0f, 0x5b, 0xe4, 0x75, 0x31, 0x74, 0x00, 0x66, 0x0f, 0x5b, 0xed, 0x75, 0x29, 0x74, 0x00, 0x0f, 0x28, 0xf0, 0x66, 0x0f, 0x70, 0xf1, 0xd8, 0x0f, 0x28, 0xfe, 0x66, 0x0f, 0x5b, 0xff, 0x75,0x16, 0x74, 0x00, 0x0f, 0x57, 0xc0, 0x44, 0x0f,0x28, 0xc0, 0x66, 0x45, 0x0f, 0x5b, 0xc0, 0x75, 0x06, 0x74, 0x00, 0x48, 0x31, 0xc0, 0xc3, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0xc3 };
                    else
                        Code = new byte[] { 0x66, 0x0f, 0x5b, 0xe4, 0x66, 0x0f, 0x7e, 0xe0, 0x74, 0x00, 0x66, 0x0f, 0x5b, 0xed, 0x66, 0x0f, 0x7e, 0xeb, 0x74, 0x00, 0x0f, 0x28, 0xf0, 0x66, 0x0f, 0x70, 0xf1, 0xd8, 0x0f, 0x28, 0xfe, 0x66, 0x0f, 0x5b, 0xff, 0x66, 0x0f, 0x7e, 0xf9, 0x74, 0x00, 0x0f, 0x57, 0xc0, 0x75, 0x05, 0x74, 0x00, 0x31, 0xc0, 0xc3, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xc3 };
                    IntPtr Allocated = AllocateCode(Code);
                    if (Allocated != IntPtr.Zero)
                    {
                        try
                        {
                            GenericInt Execute = (GenericInt)Marshal.GetDelegateForFunctionPointer(Allocated, typeof(GenericInt));
                            int Result = Execute();
                            if (Result == 1)
                            {
                                FreeCode(Allocated);
                                ResultBool = true;
                            }
                        }
                        catch
                        {
                            FreeCode(Allocated);
                            return false;
                        }
                        FreeCode(Allocated);
                        return ResultBool;
                    }
                    return false;
                }
                catch
                {
                    return false;
                }
            }

            /// <summary>
            /// Checks if the RDRAND instruction is properly implemented.
            /// </summary>
            /// <returns>true if the instruction is implemented correctly, otherwise false.</returns>
            public static bool RDRANDInstruction()
            {
                try
                {
                    bool ResultBool = false;
                    byte[] Code = new byte[80];
                    if (IntPtr.Size == 8)
                        Code = new byte[] { 0x48, 0x0F, 0xC7, 0xF0, 0x48, 0x89, 0xC3, 0x48, 0x83, 0xFB, 0x00, 0x74, 0x0F, 0x48, 0x0F, 0xC7, 0xF0, 0x48, 0x89, 0xC2, 0x48, 0x39, 0xDA, 0x74, 0x03, 0xB0, 0x00, 0xC3, 0xB0, 0x01, 0xC3 };
                    else
                        Code = new byte[] { 0x0F, 0xC7, 0xF0, 0x89, 0xC3, 0x83, 0xFB, 0x00, 0x74, 0x0C, 0x0F, 0xC7, 0xF0, 0x89, 0xC2, 0x39, 0xDA, 0x74, 0x03, 0xB0, 0x00, 0xC3, 0xB0, 0x01, 0xC3 };
                    IntPtr Allocated = AllocateCode(Code);
                    if (Allocated != IntPtr.Zero)
                    {
                        try
                        {
                            GenericInt Execute = (GenericInt)Marshal.GetDelegateForFunctionPointer(Allocated, typeof(GenericInt));
                            int Result = Execute();
                            if (Result == 1)
                            {
                                ResultBool = true;
                            }
                        }
                        catch
                        {
                            FreeCode(Allocated);
                            return false;
                        }
                        FreeCode(Allocated);
                        return ResultBool;
                    }
                    return false;
                }
                catch
                {
                    return false;
                }
            }

            /// <summary>
            /// Checks if the instructions that control the register flags is properly handling the register.
            /// </summary>
            /// <returns>true if everything is going correctly, otherwise false.</returns>
            public static bool FlagsManipulationInstructions()
            {
                try
                {
                    bool ResultBool = false;
                    byte[] Code = new byte[80];
                    if (IntPtr.Size == 8)
                        Code = new byte[] { 0x9C, 0x58, 0x48, 0x0D, 0x00, 0x02, 0x00, 0x00, 0x50, 0x9D, 0x9C, 0x58, 0x48, 0xA9, 0x00, 0x02, 0x00, 0x00, 0x74, 0x08, 0x48, 0xC7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x48, 0xC7, 0xC0, 0x01, 0x00, 0x00, 0x00, 0xC3 };
                    else
                        Code = new byte[] { 0x9C, 0x58, 0x0D, 0x00, 0x02, 0x00, 0x00, 0x50, 0x9D, 0x9C, 0x58, 0xA9, 0x00, 0x02, 0x00, 0x00, 0x74, 0x06, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0x00, 0xC3 };
                    IntPtr Allocated = AllocateCode(Code);
                    if (Allocated != IntPtr.Zero)
                    {
                        try
                        {
                            GenericInt Execute = (GenericInt)Marshal.GetDelegateForFunctionPointer(Allocated, typeof(GenericInt));
                            int Result = Execute();
                            if (Result == 1)
                            {
                                ResultBool = true;
                            }
                        }
                        catch
                        {
                            FreeCode(Allocated);
                            return false;
                        }
                        FreeCode(Allocated);
                        return ResultBool;
                    }
                    return false;
                }
                catch
                {
                    return false;
                }
            }
        }
    }
}


================================================
File: AntiCrack-DotNet/App.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/></startup>
</configuration>



================================================
File: AntiCrack-DotNet/Delegates.cs
================================================
√Ø¬ª¬øusing System;
using System.Runtime.InteropServices;

namespace AntiCrack_DotNet
{
    public sealed class Delegates
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate uint SysNtQueryInformationProcess(IntPtr hProcess, uint ProcessInfoClass, out uint ProcessInfo, uint nSize, out uint ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate uint SysNtQueryInformationProcess2(IntPtr hProcess, uint ProcessInfoClass, out IntPtr ProcessInfo, uint nSize, uint ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate uint SysNtQueryInformationProcess3(IntPtr hProcess, uint ProcessInfoClass, ref Structs.PROCESS_BASIC_INFORMATION ProcessInfo, uint nSize, uint ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate bool SysNtClose(IntPtr Handle);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate uint SysNtQuerySystemInformation(uint SystemInformationClass, ref Structs.SYSTEM_CODEINTEGRITY_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate uint SysNtQuerySystemInformation2(uint SystemInformationClass, ref Structs.SYSTEM_KERNEL_DEBUGGER_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate uint SysNtQuerySystemInformation3(uint SystemInformationClass, ref Structs.SYSTEM_SECUREBOOT_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate uint SysNtQueryVirtualMemory(IntPtr ProcessHandle, IntPtr BaseAddress, uint MemoryInformationClass, ref Structs.MEMORY_BASIC_INFORMATION MemoryInformation, uint MemoryInformationLength, out uint ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate int SysNtQueryInformationThread(IntPtr ThreadHandle, int ThreadInformationClass, ref IntPtr ThreadInformation, uint ThreadInformationLength, IntPtr ReturnLength);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate IntPtr GenericPtr();

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate int GenericInt();

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate IntPtr KeyboardHook(int nCode, IntPtr wParam, IntPtr lParam);
    }
}



================================================
File: AntiCrack-DotNet/Hooks.cs
================================================
√Ø¬ª¬øusing System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace AntiCrack_DotNet
{
    public sealed class Hooks
    {
        private static byte[] EnsureNonNullMethodInfoOriginal = new byte[6];
        private static byte[] EnsureNonNullMethodInfoHooked = new byte[6];
        private static IntPtr pEnsureNonNullMethodInfo = IntPtr.Zero;
        private static readonly object ENNM_lock = new object();
        private static bool PrintGFP = false;
        private static List<IntPtr> Whitelisted_FP = new List<IntPtr>();
        private static List<IntPtr> Blacklisted_FP = new List<IntPtr>();
        private static bool Whitelisting_FP = false;
        private static bool Blacklisting_FP = false;

        /// <summary>
        /// The hook to prevent unauthorized function retrieval by abusing EnsureNonNullMethodInfo without modifying GetFunctionPointer directly.
        /// </summary>
        /// <returns>Returns the method if all the conditions are right.</returns>
        private static MethodInfo EnsureNonNullHook(MethodInfo MI)
        {
            lock (ENNM_lock)
            {
                bool IsWhitelisted = false;
                bool IsBlacklisted = false;
                if (MI == null)
                    return null;
                try
                {
                    StackTrace trace = new StackTrace();
                    MethodBase IsGetFunctionPointer = trace.GetFrame(1)?.GetMethod();
                    if (IsGetFunctionPointer.Name == "GetFunctionPointer")
                    {
                        MethodBase MB = trace.GetFrame(2)?.GetMethod();
                        if (Whitelisting_FP)
                        {
                            if (MB != null)
                            {
                                Utils.InstallOrUninstallHook(EnsureNonNullMethodInfoOriginal, pEnsureNonNullMethodInfo);
                                IntPtr pSourceFunction = MB.MethodHandle.GetFunctionPointer();
                                Utils.InstallOrUninstallHook(EnsureNonNullMethodInfoHooked, pEnsureNonNullMethodInfo);
                                if (Whitelisted_FP != null)
                                {
                                    foreach (IntPtr WhiteListedMethod in Whitelisted_FP)
                                    {
                                        if (WhiteListedMethod != IntPtr.Zero)
                                        {
                                            if (WhiteListedMethod != IntPtr.Zero && WhiteListedMethod == pSourceFunction)
                                            {
                                                IsWhitelisted = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else if (Blacklisting_FP)
                        {
                            if (Blacklisted_FP != null)
                            {
                                Utils.InstallOrUninstallHook(EnsureNonNullMethodInfoOriginal, pEnsureNonNullMethodInfo);
                                IntPtr pSourceFunction = MI.MethodHandle.GetFunctionPointer();
                                Utils.InstallOrUninstallHook(EnsureNonNullMethodInfoHooked, pEnsureNonNullMethodInfo);
                                foreach (IntPtr BlacklistedMethod in Blacklisted_FP)
                                {
                                    if (BlacklistedMethod != IntPtr.Zero)
                                    {
                                        if (BlacklistedMethod != IntPtr.Zero && BlacklistedMethod == pSourceFunction)
                                        {
                                            IsBlacklisted = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        bool RefuseAccess = (Blacklisting_FP && IsBlacklisted || Whitelisting_FP && !IsWhitelisted);
                        if (PrintGFP)
                        {
                            if (RefuseAccess)
                            {
                                string message = string.Empty;
                                if (MB != null)
                                {
                                    message = $"---------------------------------------------------------\n";
                                    message += $"The function \"{MB}\" at the class \"{MB.DeclaringType?.Name}\" tried to get a function pointer directly and got prevented.\n";
                                    message += $"---------------------------------------------------------\n";
                                }
                                else
                                {
                                    message = $"---------------------------------------------------------\nA function tried to get a function pointer directly and got prevented.\n---------------------------------------------------------\n";
                                }
                                Console.ForegroundColor = ConsoleColor.DarkRed;
                                Console.WriteLine(message);
                                Console.ForegroundColor = ConsoleColor.White;
                            }
                        }

                        if (RefuseAccess)
                            return null;
                        return MI;
                    }
                    else
                    {
                        return MI;
                    }
                }
                catch
                {
                    return null;
                }
            }
        }



        /// <summary>
        /// Prevents the usage of GetFunctionPointer() from unauthorized assemblies.
        /// </summary>
        /// <param name="PrintAccessAttempts">An indication to know if the hook should print illegal access attempts to function pointers.</param>
        /// <param name="WhitelistedMethods">The methods which is always allowed to have a pointer of any function but no other method can, can be null if BlacklistedMethods parameter is not null (only one of them is accepted).</param>
        /// <param name="BlacklistedMethods">The methods that it's function pointer can't be retrieved, can be null if WhitelistedMethods is not null (only of them is accepted).</param>
        /// <returns>Returns true if successfully hooked, otherwise false.</returns>
        public static bool PreventUnauthorizedFunctionPointerRetrieval(bool PrintAccessAttempts, MethodInfo[] WhitelistedMethods, MethodInfo[] BlacklistedMethods, Type[] WhitelistedDeclaringTypes = null)
        {
            try
            {
                if (!Utils.IsReflectionEnabled(true, true))
                    return false;

                if (WhitelistedMethods == null && BlacklistedMethods == null)
                    return false;

                if (WhitelistedMethods != null && BlacklistedMethods != null)
                    return false;

                if (WhitelistedMethods != null)
                {
                    foreach(MethodInfo MIs in WhitelistedMethods)
                    {
                        try
                        {
                            if(MIs != null)
                            {
                                RuntimeHelpers.PrepareMethod(MIs.MethodHandle);
                                IntPtr FP = Utils.GetPointer(MIs);
                                if(FP != IntPtr.Zero)
                                {
                                    Whitelisted_FP.Add(FP);
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    Whitelisting_FP = true;
                }
                else if (BlacklistedMethods != null)
                {
                    foreach (MethodInfo MIs in BlacklistedMethods)
                    {
                        try
                        {
                            if (MIs != null)
                            {
                                RuntimeHelpers.PrepareMethod(MIs.MethodHandle);
                                IntPtr FP = Utils.GetPointer(MIs);
                                if (FP != IntPtr.Zero)
                                {
                                    Blacklisted_FP.Add(FP);
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    Blacklisting_FP = true;
                }
                
                PrintGFP = PrintAccessAttempts;
                MethodInfo MI = typeof(RuntimeMethodHandle).GetMethod("EnsureNonNullMethodInfo", BindingFlags.NonPublic | BindingFlags.Static);
                if (MI != null)
                {
                    foreach (MethodInfo Methods in MethodBase.GetCurrentMethod().DeclaringType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic))
                    {
                        if (Methods != null)
                        {
                            if (Methods.ReturnType == typeof(MethodInfo)) //corresponds to EnsureNonNullHook method but we are getting it like this to support renaming obfuscation
                            {
                                if (Utils.InstallHookCLR(MI, Methods, EnsureNonNullMethodInfoOriginal, out EnsureNonNullMethodInfoHooked, out pEnsureNonNullMethodInfo))
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            catch
            {
                return false;
            }
        }
    }
}


================================================
File: AntiCrack-DotNet/HooksDetection.cs
================================================
√Ø¬ª¬øusing System;
using System.IO;
using System.Reflection;
using System.Net.Sockets;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Linq;
using static AntiCrack_DotNet.Structs;
using System.Net;

namespace AntiCrack_DotNet
{
    public sealed class HooksDetection
    {
        public static object ProcessMethod { get; private set; }

        /// <summary>
        /// Detects hooks on common Windows API functions.
        /// </summary>
        /// <returns>Returns true if hooks are detected, otherwise false.</returns>
        public static bool DetectHooks()
        {
            string[] Libraries = { "kernel32.dll", "kernelbase.dll", "ntdll.dll", "user32.dll", "win32u.dll" };
            string[] CommonKernelLibFunctions = { "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "GetThreadContext", "CloseHandle", "OutputDebugStringA", "GetTickCount", "SetHandleInformation" };
            string[] CommonNtdllFunctions = { "NtQueryInformationProcess", "NtSetInformationThread", "NtClose", "NtGetContextThread", "NtQuerySystemInformation", "NtCreateFile", "NtCreateProcess", "NtCreateSection", "NtCreateThread", "NtYieldExecution", "NtCreateUserProcess", "NtAllocateVirtualMemory" };
            string[] CommonUser32Functions = { "FindWindowW", "FindWindowA", "FindWindowExW", "FindWindowExA", "GetForegroundWindow", "GetWindowTextLengthA", "GetWindowTextA", "BlockInput", "CreateWindowExW", "CreateWindowExA" };
            string[] CommonWin32uFunctions = { "NtUserBlockInput", "NtUserFindWindowEx", "NtUserQueryWindow", "NtUserGetForegroundWindow" };
            foreach (string Library in Libraries)
            {
                IntPtr hModule = Utils.LowLevelGetModuleHandle(Library);
                if (hModule != IntPtr.Zero)
                {
                    switch (Library)
                    {
                        case "kernel32.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonKernelLibFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        byte FunctionByte = Utils.InternalReadByte(Function);
                                        if (FunctionByte == 0x90 || FunctionByte == 0xE9)
                                        {
                                            return true;
                                        }
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "kernelbase.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonKernelLibFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        byte FunctionByte = Utils.InternalReadByte(Function);
                                        if (FunctionByte == 255 || FunctionByte == 0x90 || FunctionByte == 0xE9)
                                        {
                                            return true;
                                        }
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "ntdll.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonNtdllFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        byte FunctionByte = Utils.InternalReadByte(Function);
                                        if (FunctionByte == 255 || FunctionByte == 0x90 || FunctionByte == 0xE9)
                                        {
                                            return true;
                                        }
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "user32.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonUser32Functions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        byte FunctionByte = Utils.InternalReadByte(Function);
                                        if (FunctionByte == 0x90 || FunctionByte == 0xE9)
                                        {
                                            return true;
                                        }
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "win32u.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonWin32uFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        byte FunctionByte = Utils.InternalReadByte(Function);
                                        if (FunctionByte == 255 || FunctionByte == 0x90 || FunctionByte == 0xE9)
                                        {
                                            return true;
                                        }
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Detects inline hooks on specified functions within a module.
        /// </summary>
        /// <param name="ModuleName">The name of the module to check for hooks.</param>
        /// <param name="Functions">The list of functions to check for hooks.</param>
        /// <returns>Returns true if hooks are detected, otherwise false.</returns>
        public static bool DetectInlineHooks(string ModuleName, string[] Functions)
        {
            if (ModuleName != null && Functions != null)
            {
                try
                {
                    foreach (string function in Functions)
                    {
                        IntPtr hModule = Utils.LowLevelGetModuleHandle(ModuleName);
                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, function);
                        byte FunctionByte = Utils.InternalReadByte(Function);
                        if (FunctionByte == 255 || FunctionByte == 0x90 || FunctionByte == 0xE9)
                        {
                            return true;
                        }
                    }
                }
                catch { }
            }
            return false;
        }

        /// <summary>
        /// Detects potential guard page hooks on a specific memory address / function.
        /// </summary>
        /// <param name="pFunction">the address of the function.</param>
        /// <param name="Syscall">an indicator to whether or not to use syscalls for this check</param>
        /// <returns>Returns true if hooks are detected, otherwise false.</returns>
        public static bool DetectGuardPageHook(IntPtr pFunction, bool Syscall)
        {
            uint PAGE_GUARD = 0x100;
            Structs.MEMORY_BASIC_INFORMATION MBI = new Structs.MEMORY_BASIC_INFORMATION();
            
            if (Utils.GetVirtualMemoryQuery(Syscall, pFunction, ref MBI, out _))
            {
                if ((MBI.Protect & PAGE_GUARD) == PAGE_GUARD)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Detects potential guard page hooks on common winapi functions.
        /// </summary>
        /// <param name="Syscall">an indicator to whether or not to use syscalls for this check</param>
        /// <returns>Returns true if hooks are detected, otherwise false.</returns>
        public static bool DetectGuardPagesHooks(bool Syscall)
        {
            string[] Libraries = { "kernel32.dll", "kernelbase.dll", "ntdll.dll", "user32.dll", "win32u.dll" };
            string[] CommonKernelLibFunctions = { "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "GetThreadContext", "CloseHandle", "OutputDebugStringA", "GetTickCount", "SetHandleInformation" };
            string[] CommonNtdllFunctions = { "NtQueryInformationProcess", "NtSetInformationThread", "NtClose", "NtGetContextThread", "NtQuerySystemInformation", "NtCreateFile", "NtCreateProcess", "NtCreateSection", "NtCreateThread", "NtYieldExecution", "NtCreateUserProcess", "NtAllocateVirtualMemory", "NtQueryInformationThread", "NtQueryVirtualMemory" };
            string[] CommonUser32Functions = { "FindWindowW", "FindWindowA", "FindWindowExW", "FindWindowExA", "GetForegroundWindow", "GetWindowTextLengthA", "GetWindowTextA", "BlockInput", "CreateWindowExW", "CreateWindowExA" };
            string[] CommonWin32uFunctions = { "NtUserBlockInput", "NtUserFindWindowEx", "NtUserQueryWindow", "NtUserGetForegroundWindow" };
            foreach (string Library in Libraries)
            {
                IntPtr hModule = Utils.LowLevelGetModuleHandle(Library);
                if (hModule != IntPtr.Zero)
                {
                    switch (Library)
                    {
                        case "kernel32.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonKernelLibFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        if (DetectGuardPageHook(Function, Syscall))
                                            return true;
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "kernelbase.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonKernelLibFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        if (DetectGuardPageHook(Function, Syscall))
                                            return true;
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "ntdll.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonNtdllFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        if (DetectGuardPageHook(Function, Syscall))
                                            return true;
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "user32.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonUser32Functions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        if (DetectGuardPageHook(Function, Syscall))
                                            return true;
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                        case "win32u.dll":
                            {
                                try
                                {
                                    foreach (string WinAPIFunction in CommonWin32uFunctions)
                                    {
                                        IntPtr Function = Utils.GetFunctionExportAddress(hModule, WinAPIFunction);
                                        if (DetectGuardPageHook(Function, Syscall))
                                            return true;
                                    }
                                }
                                catch
                                {
                                    continue;
                                }
                            }
                            break;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Detects if an address is in range inside modules or not, used for compatibility.
        /// </summary>
        /// <param name="Address">The address to check for.</param>
        /// <returns>Returns true if the address is in no module, otherwise false.</returns>
        private static bool IsAddressInRange(IntPtr Address)
        {
            foreach (ProcessModule module in Process.GetCurrentProcess().Modules)
            {
                IntPtr Base = module.BaseAddress;
                IntPtr End = IntPtr.Add(Base, module.ModuleMemorySize);
                if (Address.ToInt64() >= Base.ToInt64() && Address.ToInt64() < End.ToInt64())
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Detects hooks in common .NET methods.
        /// </summary>
        /// <returns>Returns true if hooks are detected, otherwise false.</returns>
        public static bool DetectCLRHooks()
        {
            try
            {
                if (!Utils.IsReflectionEnabled(true, true))
                    return false;
                if (IntPtr.Size == 4)
                {
                    MethodInfo[] ProcessMethods = typeof(Process).GetMethods();
                    MethodInfo[] AssemblyMethods = typeof(Assembly).GetMethods();
                    MethodInfo[] FileMethods = typeof(File).GetMethods();
                    MethodInfo[] SocketMethods = typeof(Socket).GetMethods();
                    MethodInfo[] MarshalMethods = typeof(Marshal).GetMethods();
                    MethodInfo[] StringMethods = typeof(string).GetMethods();
                    foreach (MethodInfo ProcessMethod in ProcessMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(ProcessMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                {
                                    return true;
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    foreach (MethodInfo AssemblyMethod in AssemblyMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(AssemblyMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                    return true;
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    foreach (MethodInfo FileMethod in FileMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(FileMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                    return true;
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    foreach (MethodInfo SocketMethod in SocketMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(SocketMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                    return true;
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    foreach (MethodInfo MarshalMethod in MarshalMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(MarshalMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                    return true;
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    foreach (MethodInfo StringMethod in StringMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(StringMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                    return true;
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                    Assembly assembly = Assembly.GetExecutingAssembly();
                    foreach (Type type in assembly.GetTypes())
                    {
                        try
                        {
                            MethodInfo[] AllMethods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
                            var UserDefinedMethods = AllMethods.Where(method => !method.IsSpecialName).Where(method => method.DeclaringType.Assembly == assembly);
                            foreach (MethodInfo Method in UserDefinedMethods)
                            {
                                RuntimeHelpers.PrepareMethod(Method.MethodHandle);
                                IntPtr FP = Utils.GetPointer(Method);
                                if (FP != IntPtr.Zero)
                                {
                                    byte FirstByte = Utils.InternalReadByte(FP);
                                    if (FirstByte == 0xE9 || FirstByte == 255 || FirstByte == 0x90 || FirstByte == 144)
                                    {
                                        if (IsAddressInRange(FP))
                                            return true;
                                    }
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                }
                else if(IntPtr.Size == 8)
                {
                    MethodInfo[] ProcessMethods = typeof(Process).GetMethods();
                    MethodInfo[] AssemblyMethods = typeof(Assembly).GetMethods();
                    MethodInfo[] FileMethods = typeof(File).GetMethods();
                    MethodInfo[] SocketMethods = typeof(Socket).GetMethods();
                    MethodInfo[] MarshalMethods = typeof(Marshal).GetMethods();
                    MethodInfo[] StringMethods = typeof(string).GetMethods();
                    foreach (MethodInfo ProcessMethod in ProcessMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(ProcessMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                {
                                    if (IsAddressInRange(FP))
                                        return true;
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }

                    foreach (MethodInfo AssemblyMethod in AssemblyMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(AssemblyMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                {
                                    if (IsAddressInRange(FP))
                                        return true;
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }

                    foreach (MethodInfo FileMethod in FileMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(FileMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                {
                                    if (IsAddressInRange(FP))
                                        return true;
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }

                    foreach (MethodInfo SocketMethod in SocketMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(SocketMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                {
                                    if (IsAddressInRange(FP))
                                        return true;
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }

                    foreach (MethodInfo MarshalMethod in MarshalMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(MarshalMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                {
                                    if (IsAddressInRange(FP))
                                        return true;
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }

                    foreach (MethodInfo StringMethod in StringMethods)
                    {
                        try
                        {
                            IntPtr FP = Utils.GetPointer(StringMethod);
                            if (FP != IntPtr.Zero)
                            {
                                byte FirstByte = Utils.InternalReadByte(FP);
                                if (FirstByte == 0xE9 || FirstByte == 255)
                                {
                                    if (IsAddressInRange(FP))
                                        return true;
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }

                    Assembly assembly = Assembly.GetExecutingAssembly();
                    foreach (Type type in assembly.GetTypes())
                    {
                        try
                        {
                            MethodInfo[] AllMethods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
                            var UserDefinedMethods = AllMethods.Where(method => !method.IsSpecialName).Where(method => method.DeclaringType.Assembly == assembly);
                            foreach (MethodInfo Method in UserDefinedMethods)
                            {
                                RuntimeHelpers.PrepareMethod(Method.MethodHandle);
                                IntPtr FP = Utils.GetPointer(Method);
                                if (FP != IntPtr.Zero)
                                {
                                    byte FirstByte = Utils.InternalReadByte(FP);
                                    if (FirstByte == 0xE9 || FirstByte == 255 || FirstByte == 0x90 || FirstByte == 144)
                                    {
                                        if (IsAddressInRange(FP))
                                            return true;
                                    }
                                }
                            }
                        }
                        catch
                        {
                            continue;
                        }
                    }
                }
            }
            catch
            {
                return false;
            }
            return false;
        }
    }
}


================================================
File: AntiCrack-DotNet/OtherChecks.cs
================================================
√Ø¬ª¬øusing System;
using System.Reflection;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Diagnostics;
using static AntiCrack_DotNet.Structs;

namespace AntiCrack_DotNet
{
    public sealed class OtherChecks
    {
        #region WinApi 

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtQuerySystemInformation(uint SystemInformationClass, ref SYSTEM_CODEINTEGRITY_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtQuerySystemInformation(uint SystemInformationClass, ref SYSTEM_KERNEL_DEBUGGER_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtQuerySystemInformation(uint SystemInformationClass, ref SYSTEM_SECUREBOOT_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength);

        #endregion

        /// <summary>
        /// Checks if unsigned drivers are allowed on the system.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if unsigned drivers are allowed, otherwise false.</returns>
        public static bool IsUnsignedDriversAllowed(bool Syscall)
        {
            uint SystemCodeIntegrityInformation = 0x67;
            SYSTEM_CODEINTEGRITY_INFORMATION CodeIntegrityInfo = new SYSTEM_CODEINTEGRITY_INFORMATION();
            CodeIntegrityInfo.Length = (uint)Marshal.SizeOf(typeof(SYSTEM_CODEINTEGRITY_INFORMATION));
            uint ReturnLength = 0;
            uint result = Syscall ? Syscalls.SyscallNtQuerySystemInformation(SystemCodeIntegrityInformation, ref CodeIntegrityInfo, (uint)Marshal.SizeOf(CodeIntegrityInfo), out ReturnLength) : NtQuerySystemInformation(SystemCodeIntegrityInformation, ref CodeIntegrityInfo, (uint)Marshal.SizeOf(CodeIntegrityInfo), out ReturnLength);
            if (NtQuerySystemInformation(SystemCodeIntegrityInformation, ref CodeIntegrityInfo, (uint)Marshal.SizeOf(CodeIntegrityInfo), out ReturnLength) >= 0 && ReturnLength == (uint)Marshal.SizeOf(CodeIntegrityInfo))
            {
                uint CODEINTEGRITY_OPTION_ENABLED = 0x01;
                if ((CodeIntegrityInfo.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED) == CODEINTEGRITY_OPTION_ENABLED)
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Checks if test-signed drivers are allowed on the system.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if test-signed drivers are allowed, otherwise false.</returns>
        public static bool IsTestSignedDriversAllowed(bool Syscall)
        {
            uint SystemCodeIntegrityInformation = 0x67;
            SYSTEM_CODEINTEGRITY_INFORMATION CodeIntegrityInfo = new SYSTEM_CODEINTEGRITY_INFORMATION();
            CodeIntegrityInfo.Length = (uint)Marshal.SizeOf(typeof(SYSTEM_CODEINTEGRITY_INFORMATION));
            uint ReturnLength = 0;
            uint result = Syscall ? Syscalls.SyscallNtQuerySystemInformation(SystemCodeIntegrityInformation, ref CodeIntegrityInfo, (uint)Marshal.SizeOf(CodeIntegrityInfo), out ReturnLength) : NtQuerySystemInformation(SystemCodeIntegrityInformation, ref CodeIntegrityInfo, (uint)Marshal.SizeOf(CodeIntegrityInfo), out ReturnLength);
            if (result >= 0 && ReturnLength == (uint)Marshal.SizeOf(CodeIntegrityInfo))
            {
                uint CODEINTEGRITY_OPTION_TESTSIGN = 0x02;
                if ((CodeIntegrityInfo.CodeIntegrityOptions & CODEINTEGRITY_OPTION_TESTSIGN) == CODEINTEGRITY_OPTION_TESTSIGN)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if kernel debugging is enabled on the system.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if kernel debugging is enabled, otherwise false.</returns>
        public static bool IsKernelDebuggingEnabled(bool Syscall)
        {
            uint SystemKernelDebuggerInformation = 0x23;
            SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebugInfo = new SYSTEM_KERNEL_DEBUGGER_INFORMATION();
            KernelDebugInfo.KernelDebuggerEnabled = false;
            KernelDebugInfo.KernelDebuggerNotPresent = true;
            uint ReturnLength = 0;
            uint result = Syscall ? Syscalls.SyscallNtQuerySystemInformation(SystemKernelDebuggerInformation, ref KernelDebugInfo, (uint)Marshal.SizeOf(KernelDebugInfo), out ReturnLength) : NtQuerySystemInformation(SystemKernelDebuggerInformation, ref KernelDebugInfo, (uint)Marshal.SizeOf(KernelDebugInfo), out ReturnLength);
            if (result >= 0 && ReturnLength == (uint)Marshal.SizeOf(KernelDebugInfo))
            {
                if (KernelDebugInfo.KernelDebuggerEnabled || !KernelDebugInfo.KernelDebuggerNotPresent)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if Secure Boot is enabled on the system.
        /// <param name="Syscall">specifies if we should use syscall to call the WinAPI functions.</param>
        /// </summary>
        /// <returns>Returns true if Secure Boot is enabled, otherwise false.</returns>
        public static bool IsSecureBootEnabled(bool Syscall)
        {
            uint SystemSecureBootInformation = 0x91;
            SYSTEM_SECUREBOOT_INFORMATION SecureBoot = new SYSTEM_SECUREBOOT_INFORMATION();
            SecureBoot.SecureBootCapable = false;
            SecureBoot.SecureBootEnabled = false;
            uint ReturnLength = 0;
            uint result = Syscall ? Syscalls.SyscallNtQuerySystemInformation(SystemSecureBootInformation, ref SecureBoot, (uint)Marshal.SizeOf(SecureBoot), out ReturnLength) : NtQuerySystemInformation(SystemSecureBootInformation, ref SecureBoot, (uint)Marshal.SizeOf(SecureBoot), out ReturnLength);
            if (result >= 0)
            {
                if (SecureBoot.SecureBootEnabled)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Checks if virtualization-based security is enabled on the system.
        /// </summary>
        /// <returns>Returns true if virtualization-based security is enabled, otherwise false.</returns>
        public static bool IsVirtualizationBasedSecurityEnabled()
        {
            try
            {
                using (var searcher = new System.Management.ManagementObjectSearcher(@"root\cimv2\Security\MicrosoftVolumeEncryption", "SELECT * FROM Win32_EncryptableVolume WHERE DriveLetter = C:"))
                {
                    foreach (var obj in searcher.Get())
                    {
                        var protectionStatus = (uint)obj["ProtectionStatus"];
                        if (protectionStatus == 1)
                        {
                            return true;
                        }
                    }
                }
            }
            catch
            {
                return false;
            }
            return false;
        }

        /// <summary>
        /// Checks if memory integrity (Hypervisor-enforced Code Integrity) is enabled on the system.
        /// </summary>
        /// <returns>Returns true if memory integrity is enabled, otherwise false.</returns>
        public static bool IsMemoryIntegrityEnabled()
        {
            try
            {
                using (RegistryKey key = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity"))
                {
                    if (key != null)
                    {
                        object value = key.GetValue("Enabled");
                        if (value != null && (int)value == 1)
                        {
                            return true;
                        }
                    }
                }
            }
            catch
            {
                return false;
            }
            return false;
        }

        /// <summary>
        /// Checks if the current assembly is invoked by another assembly.
        /// </summary>
        /// <param name="DetectHooks">True if we are gonna check for hooks that may return incorrect assembly results, if we found a hook (or we are invoked) the method will return true.</param>
        /// <returns>Returns true if the current assembly is invoked by another assembly, otherwise false.</returns>
        public static bool IsInvokedAssembly(bool DetectHooks)
        {
            Assembly EntryAsm = Utils.LowLevelGetEntryAssembly();
            Assembly EntryAssemblyDM = new AppDomainManager().EntryAssembly;
            Assembly AsmEP = Assembly.GetEntryAssembly();
            Assembly ExecAsm = Utils.LowLevelGetExecutingAssembly();
            Assembly ExecutingAssembly = Assembly.GetExecutingAssembly();
            bool IsExecAsmNotNull = ExecAsm != null;
            bool IsEntryAsmNotNull = EntryAsm != null;
            bool IsEntryAssemblyDMNotNull = EntryAssemblyDM != null;
            string ExecutablePath = Process.GetCurrentProcess().MainModule.FileName;
            if (DetectHooks)
            {
                if (IsEntryAsmNotNull)
                {
                    if (AsmEP == null)
                        return true;
                    if (EntryAssemblyDM == null)
                        return true;
                    if (EntryAsm.Location != AsmEP.Location || EntryAsm.Location != EntryAssemblyDM.Location || EntryAsm.Location != ExecutablePath)
                        return true;
                }

                if (IsEntryAssemblyDMNotNull)
                {
                    if (AsmEP == null)
                        return true;
                    if (EntryAssemblyDM.Location != AsmEP.Location || EntryAssemblyDM.Location != ExecutablePath || AsmEP.Location != ExecutablePath)
                        return true;
                }

                if (AsmEP == null && IsEntryAsmNotNull || AsmEP == null && IsEntryAssemblyDMNotNull)
                    return true;

                if (IsExecAsmNotNull)
                {
                    if (ExecutingAssembly == null)
                        return true;
                    if (ExecAsm.Location != ExecutingAssembly.Location)
                        return true;
                }
            }

            if (IsEntryAsmNotNull || IsExecAsmNotNull)
            {
                if (IsExecAsmNotNull && IsEntryAsmNotNull && EntryAsm.Location != ExecAsm.Location)
                    return true;
                if (IsExecAsmNotNull && ExecAsm.Location != ExecutablePath)
                    return true;
                if (IsEntryAsmNotNull && IsExecAsmNotNull && EntryAsm.GetName().Name != ExecAsm.GetName().Name)
                    return true;
            }

            if (EntryAssemblyDM != null || AsmEP != null)
            {
                if (ExecutingAssembly.Location != EntryAssemblyDM.Location)
                    return true;
                if (ExecutingAssembly.GetName().Name != EntryAssemblyDM.GetName().Name)
                    return true;
                if (ExecutingAssembly.Location != ExecutablePath)
                    return true;
                if (ExecutingAssembly.Location != AsmEP.Location)
                    return true;
            }
            return false;
        }
    }
}


================================================
File: AntiCrack-DotNet/Program.cs
================================================
√Ø¬ª¬øusing System;
using System.Reflection;
using System.Globalization;

namespace AntiCrack_DotNet
{
    internal sealed class Program
    {
        private sealed class ConsoleConfig
        {
            public static bool IsHooksEnabled = true;
            public static bool IsAntiDebugChecksEnabled = true;
            public static bool IsAntiVirtualizationChecksEnabled = true;
            public static bool IsAntiInjectionEnabled = true;
            public static bool IsOtherDetectionChecksEnabled = true;
            public static bool IsAntiHookChecksEnabled = true;

            public static void ProcessArgs(string[] args)
            {
                if (args != null && args.Length != 0)
                {
                    foreach (string arg in args)
                    {
                        string lower_arg = CultureInfo.CurrentCulture.TextInfo.ToLower(arg);
                        switch (lower_arg)
                        {
                            case "--disable-hooks":
                                IsHooksEnabled = false;
                                break;
                            case "--disable-antidebug":
                                IsAntiDebugChecksEnabled = false;
                                break;
                            case "--disable-antivirtualization":
                                IsAntiVirtualizationChecksEnabled = false;
                                break;
                            case "--disable-antiinjection":
                                IsAntiInjectionEnabled = false;
                                break;
                            case "--disable-otherdetections":
                                IsOtherDetectionChecksEnabled = false;
                                break;
                            case "--disable-hooksdetection":
                                IsAntiHookChecksEnabled = false;
                                break;
                        }
                    }
                }
            }

            public static void SetDefaultColors()
            {
                Console.BackgroundColor = ConsoleColor.Black;
                Console.ForegroundColor = ConsoleColor.White;
                Console.Clear();
            }

            public static void SetTitle(string title)
            {
                Console.Title = title;
            }

            public static void DisplayHeader(string header)
            {
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine($"\n------ {header} ------\n");
                Console.ForegroundColor = ConsoleColor.White;
            }

            public static void DisplayFooter()
            {
                Console.ForegroundColor = ConsoleColor.Cyan;
                Console.WriteLine("---------------------------------------------------------\n");
                Console.ForegroundColor = ConsoleColor.White;
            }

            public static void DisplayResult(string text, bool result, bool SwapResult, string Info = "")
            {
                Console.Write(text);
                if (result)
                {
                    if (SwapResult)
                    {
                        Console.ForegroundColor = ConsoleColor.Green;
                        Console.Write("[Good] ");
                    }
                    else
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.Write("[Bad] ");
                    }
                }
                else
                {
                    if (SwapResult)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.Write("[Bad] ");
                    }
                    else
                    {
                        Console.ForegroundColor = ConsoleColor.Green;
                        Console.Write("[Good] ");
                    }
                }
                Console.ForegroundColor = ConsoleColor.Gray;
                Console.WriteLine(Info);
                Console.ForegroundColor = ConsoleColor.White;

            }

            public static void DisplayResult(string text, string result, string Info = "")
            {
                Console.Write(text);
                string lower_result = CultureInfo.CurrentCulture.TextInfo.ToLower(result);
                switch (lower_result)
                {
                    case "[bad]":
                    case "failed":
                        Console.ForegroundColor = ConsoleColor.Red;
                        break;
                    case "skipped":
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        break;
                    default:
                        Console.ForegroundColor = ConsoleColor.Green;
                        break;
                }

                if (lower_result.Contains("failed") || lower_result.Contains("success") || lower_result.Contains("skipped") || lower_result.Contains("bad"))
                {
                    Console.WriteLine($"[Operation Result = {result}] {Info}");
                }
                else
                {
                    Console.WriteLine($"{result} {Info}");
                }
                Console.ForegroundColor = ConsoleColor.White;
            }

            public static void SyscallPrompt()
            {
                string Arch = IntPtr.Size == 8 ? "[x64 Environment]" : "[x86 Environment]";
                SetTitle($"AntiCrack DotNet {Arch} | Syscall Mode: Undetermined");
                Console.Write("Do you want to use syscalls for some of the detections? (Y/N): ");
                string Response = Console.ReadLine().ToLower();
                Console.Clear();
                if (Response == "y" || Response == "yes")
                {
                    syscall = true;
                    SetTitle($"AntiCrack DotNet {Arch} | Syscall Mode: {syscall}");
                    Syscalls.InitSyscall();
                    Syscalls.BuildNumber = Syscalls.GetBuildNumber(false, true);
                    if (!Syscalls.IsBuildNumberSaved())
                    {
                        Console.ForegroundColor = ConsoleColor.DarkRed;
                        Console.WriteLine("your system build number is not saved, we will try to get the most common syscall number used across platforms or dynamically get the syscalls and work with what we got.");
                        Console.ForegroundColor = ConsoleColor.White;
                    }
                }
                else
                {
                    SetTitle($"AntiCrack DotNet {Arch} | Syscall Mode: {syscall}");
                }
            }
        }

        private static bool syscall = false;

        private static void ExecuteHooks()
        {
            if (!ConsoleConfig.IsHooksEnabled)
                return;
            ConsoleConfig.DisplayHeader("Executing Hooks");
            ConsoleConfig.DisplayResult("Prevent unauthorized retrieval of .NET functions pointer: ", Hooks.PreventUnauthorizedFunctionPointerRetrieval(true, new MethodInfo[] { typeof(Utils).GetMethod("GetPointer", BindingFlags.Public | BindingFlags.Static) }, null), true, "Prevents unauthorized retrieval of .NET functions pointer to prevent raw memory modifications of functions at runtime by whitelisting our own function to get the pointer for the other checks. you should use, test, and modify it carefully based on your needs if you wanna use it in real-world apps or games.");
            ConsoleConfig.DisplayFooter();
        }

        private static void ExecuteAntiDebuggingTricks()
        {
            if (!ConsoleConfig.IsAntiDebugChecksEnabled)
                return;
            ConsoleConfig.DisplayHeader("Executing Anti Debugging Tricks");
            ConsoleConfig.DisplayResult("NtUserGetForegroundWindow (Looking For Bad Active Debugger Windows): ", AntiDebug.NtUserGetForegroundWindowAntiDebug(), false, "Checks if a debugger window is in the foreground.");
            ConsoleConfig.DisplayResult("Debugger.IsAttached: ", AntiDebug.DebuggerIsAttached(), false, "Checks if a managed debugger is attached.");
            ConsoleConfig.DisplayResult("Hide Threads From Debugger..... ", AntiDebug.HideThreadsAntiDebug(), "Attempts to hide threads from the debugger.");
            ConsoleConfig.DisplayResult("IsDebuggerPresent: ", AntiDebug.IsDebuggerPresentCheck(), false, "Checks if a debugger is present.");
            ConsoleConfig.DisplayResult("Checking for the BeingDebugged flag from the PEB directly: ", AntiDebug.BeingDebuggedCheck(), false, "Checks for the BeingDebugged flag from PEB instead of IsDebuggerPresent.");
            ConsoleConfig.DisplayResult("Checking for the NtGlobalFlag from the PEB directly: ", AntiDebug.NtGlobalFlagCheck(), false, "Checks for the NtGlobalFlag from the PEB.");
            ConsoleConfig.DisplayResult("NtSetDebugFilterState Check: ", AntiDebug.NtSetDebugFilterStateAntiDebug(), false, "Sets the debug filter state.");
            ConsoleConfig.DisplayResult("Page Guard Breakpoints Detection Check: ", AntiDebug.PageGuardAntiDebug(), false, "Detects page guard breakpoints.");
            ConsoleConfig.DisplayResult("NtQueryInformationProcess ProcessDebugFlags: ", AntiDebug.NtQueryInformationProcessCheck_ProcessDebugFlags(syscall), false, "Queries process debug flags.");
            ConsoleConfig.DisplayResult("NtQueryInformationProcess ProcessDebugPort: ", AntiDebug.NtQueryInformationProcessCheck_ProcessDebugPort(syscall), false, "Queries process debug port.");
            ConsoleConfig.DisplayResult("NtQueryInformationProcess ProcessDebugObjectHandle: ", AntiDebug.NtQueryInformationProcessCheck_ProcessDebugObjectHandle(syscall), false, "Queries process debug object handle.");
            ConsoleConfig.DisplayResult("NtClose (Invalid Handle): ", AntiDebug.NtCloseAntiDebug_InvalidHandle(syscall), false, "Tests NtClose with an invalid handle.");
            ConsoleConfig.DisplayResult("NtClose (Protected Handle): ", AntiDebug.NtCloseAntiDebug_ProtectedHandle(syscall), false, "Tests NtClose with a protected handle.");
            ConsoleConfig.DisplayResult("Parent Process (Checking if the parent process is cmd.exe or explorer.exe): ", AntiDebug.ParentProcessAntiDebug(syscall), false, "Checks if the parent process is a known process.");
            ConsoleConfig.DisplayResult("Hardware Registers Breakpoints Detection: ", AntiDebug.HardwareRegistersBreakpointsDetection(), false, "Detects hardware register breakpoints.");
            ConsoleConfig.DisplayResult("FindWindow (Looking For Bad Debugger Windows): ", AntiDebug.FindWindowAntiDebug(), false, "Finds windows with debugger-related titles.");
            ConsoleConfig.DisplayResult("GetTickCount Anti Debug: ", "Skipped", "Unreliable for real anti-debug use.");
            ConsoleConfig.DisplayResult("OutputDebugString Anti Debug: ", "Skipped", "Unreliable for real anti-debug use.");
            ConsoleConfig.DisplayResult("Trying To Crash Non-Managed Debuggers with a Debugger Breakpoint..... ", "Skipped");
            Console.WriteLine("Executing OllyDbg Format String Exploit.....");
            AntiDebug.OllyDbgFormatStringExploit();
            ConsoleConfig.DisplayResult("Patching DbgUiRemoteBreakin and DbgBreakPoint To Prevent Debugger Attaching..... ", AntiDebug.AntiDebugAttach(), "Patches functions to prevent debugger attaching.");
            ConsoleConfig.DisplayFooter();
        }

        private static void ExecuteAntiVirtualizationTricks()
        {
            if (!ConsoleConfig.IsAntiVirtualizationChecksEnabled)
                return;
            ConsoleConfig.DisplayHeader("Executing Anti Virtualization Tricks");
            ConsoleConfig.DisplayResult("Checking For Any.run: ", AntiVirtualization.AnyRunCheck(), false, "Checks if Any.run is present through crypto id.");
            ConsoleConfig.DisplayResult("Checking For Triage: ", AntiVirtualization.TriageCheck(), false, "Checks if Triage is present through disk.");
            ConsoleConfig.DisplayResult("Checking For Qemu: ", AntiVirtualization.CheckForQemu(), false, "Checks if running under Qemu.");
            ConsoleConfig.DisplayResult("Checking For Parallels: ", AntiVirtualization.CheckForParallels(), false, "Checks if running under Parallels.");
            ConsoleConfig.DisplayResult("Checking For Sandboxie Module in Current Process: ", AntiVirtualization.IsSandboxiePresent(), false, "Checks if Sandboxie is present.");
            ConsoleConfig.DisplayResult("Checking For Comodo Sandbox Module in Current Process: ", AntiVirtualization.IsComodoSandboxPresent(), false, "Checks if Comodo Sandbox is present.");
            ConsoleConfig.DisplayResult("Checking For Cuckoo Sandbox Module in Current Process: ", AntiVirtualization.IsCuckooSandboxPresent(), false, "Checks if Cuckoo Sandbox is present.");
            ConsoleConfig.DisplayResult("Checking For Qihoo360 Sandbox Module in Current Process: ", AntiVirtualization.IsQihoo360SandboxPresent(), false, "Checks if Qihoo360 Sandbox is present.");
            ConsoleConfig.DisplayResult("Checking For Blacklisted Usernames: ", AntiVirtualization.CheckForBlacklistedNames(), false, "Checks if the username is blacklisted.");
            ConsoleConfig.DisplayResult("Checking if the Program is running under wine using dll exports detection: ", AntiVirtualization.IsWinePresent(), false, "Checks if the program is running under Wine.");
            ConsoleConfig.DisplayResult("Checking For VirtualBox and VMware: ", AntiVirtualization.CheckForVMwareAndVirtualBox(), false, "Checks if the program is running in VirtualBox or VMware.");
            ConsoleConfig.DisplayResult("Checking For KVM: ", AntiVirtualization.CheckForKVM(), false, "Checks if the program is running in KVM.");
            ConsoleConfig.DisplayResult("Checking For HyperV: ", AntiVirtualization.CheckForHyperV(), false, "Checks if the program is running in HyperV.");
            ConsoleConfig.DisplayResult("Checking For Known Bad VM File Locations: ", AntiVirtualization.BadVMFilesDetection(), false, "Detects known bad VM file locations.");
            ConsoleConfig.DisplayResult("Checking For Known Bad Process Names: ", AntiVirtualization.BadVMProcessNames(), false, "Detects known bad VM process names.");
            ConsoleConfig.DisplayResult("Checking for devices created by VMs or Sandboxes: ", AntiVirtualization.CheckDevices(), false, "Checks for VM or sandbox devices.");
            ConsoleConfig.DisplayResult("Checking if the program is emulated using a timing check: ", AntiVirtualization.Generic.EmulationTimingCheck(), false, "Checks if the program is emulated using a timing check.");
            ConsoleConfig.DisplayResult("Checking For Ports (useful to detect VMs which have no ports connected): ", AntiVirtualization.Generic.PortConnectionAntiVM(), false, "Checks for VM port connections.");
            ConsoleConfig.DisplayResult("Checking for AVX instructions not being implemented properly: ", AntiVirtualization.Generic.AVXInstructions(), false, "Checks to see if the AVX instructions are properly implemented to see if we are running in a virtual/emulated CPU.");
            ConsoleConfig.DisplayResult("Checking for RDRAND instruction not being implemented/misconfigured: ", AntiVirtualization.Generic.RDRANDInstruction(), false, "Checks to see if the RDRAND instruction is supported and properly implemented which some emulators don't.");
            ConsoleConfig.DisplayResult("Checking if the instructions that control the RFlags (or EFlags) register are handled correctly: ", AntiVirtualization.Generic.FlagsManipulationInstructions(), false, "Verifies if the RFlags (or EFlags) register manipulations are correct, which may indicate an emulator.");
            ConsoleConfig.DisplayFooter();
        }

        private static void ExecuteAntiInjectionTricks()
        {
            if (!ConsoleConfig.IsAntiInjectionEnabled)
                return;
            ConsoleConfig.DisplayHeader("Executing Anti Injection Tricks");
            ConsoleConfig.DisplayResult("Taking Advantage of Binary Image Signature Mitigation Policy to Prevent Non-Microsoft Binaries From Being Injected..... ", AntiInjection.SetDllLoadPolicy(), "Enforces binary image signature mitigation policy.");
            ConsoleConfig.DisplayResult("Checking for Injected Threads: ", AntiInjection.CheckInjectedThreads(syscall, true), false, "Checks for injected threads that it's start address is neither committed nor from image, or not in modules range.");
            ConsoleConfig.DisplayResult("Changing the main module info: ", AntiInjection.ChangeModuleInfo(null, Spoofs.ModuleName | Spoofs.BaseAddress | Spoofs.AddressOfEntryPoint | Spoofs.SizeOfImage | Spoofs.ImageMagic | Spoofs.NotExecutableNorDll | Spoofs.ExecutableSectionName | Spoofs.ExecutableSectionRawSize | Spoofs.ExecutableSectionRawPointer | Spoofs.ClearExecutableSectionCharacteristics | Spoofs.ExecutableSectionVirtualSize), true, "Changes the main module info including module name, base address, etc to prevent modifications, runtime lookups or some kinds of dumping.");
            ConsoleConfig.DisplayResult("Changing the CLR module ImageMagic: ", AntiInjection.ChangeCLRModuleImageMagic(), true, "Changes the CLR module image magic in the memory of the process to try to prevent (some) external processes/software from retrieving some critical info about our assemblies while still being functional by making it seem like debugger exports is missing. (only if the module is present. if it's not present or this is AOT compiled then this will fail)");
            ConsoleConfig.DisplayResult("Checks for suspicious image base address (process hollowing): ", AntiInjection.CheckForSuspiciousBaseAddress(), false, "Checks for suspicious image base address by comparing it with the one in the main module.");
            ConsoleConfig.DisplayFooter();
        }

        private static void ExecuteOtherDetectionTricks()
        {
            if (!ConsoleConfig.IsOtherDetectionChecksEnabled)
                return;
            ConsoleConfig.DisplayHeader("Executing Other Detection Tricks");
            ConsoleConfig.DisplayResult("Detecting if Unsigned Drivers are Allowed to Load: ", OtherChecks.IsUnsignedDriversAllowed(syscall), false, "Checks if unsigned drivers are allowed.");
            ConsoleConfig.DisplayResult("Detecting if Test-Signed Drivers are Allowed to Load: ", OtherChecks.IsTestSignedDriversAllowed(syscall), false, "Checks if test-signed drivers are allowed.");
            ConsoleConfig.DisplayResult("Detecting if Kernel Debugging is Enabled on the System: ", OtherChecks.IsKernelDebuggingEnabled(syscall), false, "Checks if kernel debugging is enabled.");
            ConsoleConfig.DisplayResult("Detecting if Secure Boot is Enabled on the System: ", OtherChecks.IsSecureBootEnabled(syscall), true, "Checks if secure boot is enabled.");
            ConsoleConfig.DisplayResult("Detecting if Virtualization-Based Security is Enabled: ", OtherChecks.IsVirtualizationBasedSecurityEnabled(), true, "Checks if VBS is enabled.");
            ConsoleConfig.DisplayResult("Detecting if Memory Integrity Protection is Enabled: ", OtherChecks.IsMemoryIntegrityEnabled(), true, "Checks if Memory Integrity is enabled.");
            ConsoleConfig.DisplayResult("Detecting if the current assembly has been invoked by another one: ", OtherChecks.IsInvokedAssembly(true), false, "Checks to see if the assembly has been invoked.");
            ConsoleConfig.DisplayFooter();
        }

        private static void ExecuteHooksDetectionTricks()
        {
            if (!ConsoleConfig.IsAntiHookChecksEnabled)
                return;
            ConsoleConfig.DisplayHeader("Executing Hooks Detection Tricks");
            ConsoleConfig.DisplayResult("Detecting hooks on common WinApi functions by checking for bad instructions on functions addresses: ", HooksDetection.DetectHooks(), false, "Detects hooks on common WinAPI functions.");
            ConsoleConfig.DisplayResult("Basic Detection for Stealthy Page Guard hooking on common WinApi Functions: ", HooksDetection.DetectGuardPagesHooks(syscall), false, "Detects hooks that depends on Page Guard exception handling.");
            ConsoleConfig.DisplayResult("Detecting Hooks on CLR Functions: ", HooksDetection.DetectCLRHooks(), false, "Detects hooks on CLR Functions.");
            ConsoleConfig.DisplayFooter();
        }

        public static void Main(string[] args)
        {
            ConsoleConfig.ProcessArgs(args);
            ConsoleConfig.SetDefaultColors();
            ConsoleConfig.SyscallPrompt();
            ExecuteHooks();
            while (true)
            {
                ExecuteAntiDebuggingTricks();
                ExecuteAntiVirtualizationTricks();
                ExecuteAntiInjectionTricks();
                ExecuteOtherDetectionTricks();
                ExecuteHooksDetectionTricks();
                Console.WriteLine("Press Enter to run again or Ctrl+C to exit...");
                Console.ReadLine();
            }
        }
    }
}


================================================
File: AntiCrack-DotNet/Structs.cs
================================================
√Ø¬ª¬øusing System;
using System.Runtime.InteropServices;

namespace AntiCrack_DotNet
{
    public sealed class Structs
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct CONTEXT
        {
            public uint P1Home;
            public uint P2Home;
            public uint P3Home;
            public uint P4Home;
            public uint P5Home;
            public uint P6Home;
            public long ContextFlags;
            public IntPtr MxCsr;
            public IntPtr SegCs;
            public IntPtr SegDs;
            public IntPtr SegEs;
            public IntPtr SegFs;
            public IntPtr SegGs;
            public IntPtr SegSs;
            public IntPtr EFlags;
            public uint Dr0;
            public uint Dr1;
            public uint Dr2;
            public uint Dr3;
            public uint Dr6;
            public uint Dr7;
        }

        public struct PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
        {
            public uint MicrosoftSignedOnly;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct SYSTEM_CODEINTEGRITY_INFORMATION
        {
            [FieldOffset(0)]
            public ulong Length;

            [FieldOffset(4)]
            public uint CodeIntegrityOptions;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_BASIC_INFORMATION
        {
            internal IntPtr Reserved1;
            internal IntPtr PebBaseAddress;
            internal IntPtr Reserved2_0;
            internal IntPtr Reserved2_1;
            internal IntPtr UniqueProcessId;
            internal IntPtr InheritedFromUniqueProcessId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SYSTEM_KERNEL_DEBUGGER_INFORMATION
        {
            [MarshalAs(UnmanagedType.U1)]
            public bool KernelDebuggerEnabled;

            [MarshalAs(UnmanagedType.U1)]
            public bool KernelDebuggerNotPresent;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct UNICODE_STRING
        {
            public ushort Length;
            public ushort MaximumLength;
            public IntPtr Buffer;
        }

        public struct ANSI_STRING
        {
            public short Length;
            public short MaximumLength;
            public string Buffer;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SYSTEM_SECUREBOOT_INFORMATION
        {
            public bool SecureBootEnabled;
            public bool SecureBootCapable;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SYSTEM_INFO
        {
            public ushort ProcessorArchitecture;
            ushort Reserved;
            public uint PageSize;
            public IntPtr MinimumApplicationAddress;
            public IntPtr MaximumApplicationAddress;
            public IntPtr ActiveProcessorMask;
            public uint NumberOfProcessors;
            public uint ProcessorType;
            public uint AllocationGranularity;
            public ushort ProcessorLevel;
            public ushort ProcessorRevision;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct OSVERSIONINFOEX
        {
            public int dwOSVersionInfoSize;
            public int dwMajorVersion;
            public int dwMinorVersion;
            public int dwBuildNumber;
            public int dwPlatformId;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string szCSDVersion;
            public ushort wServicePackMajor;
            public ushort wServicePackMinor;
            public ushort wSuiteMask;
            public byte wProductType;
            public byte wReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_DOS_HEADER
        {
            public ushort e_magic;
            public ushort e_cblp;
            public ushort e_cp;
            public ushort e_crlc;
            public ushort e_cparhdr;
            public ushort e_minalloc;
            public ushort e_maxalloc;
            public ushort e_ss;
            public ushort e_sp;
            public ushort e_csum;
            public ushort e_ip;
            public ushort e_cs;
            public ushort e_lfarlc;
            public ushort e_ovno;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public ushort[] e_res1;
            public ushort e_oemid;
            public ushort e_oeminfo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
            public ushort[] e_res2;
            public int e_lfanew;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct IMAGE_NT_HEADERS32
        {
            public UInt32 Signature;
            public IMAGE_FILE_HEADER FileHeader;
            public IMAGE_OPTIONAL_HEADER32 OptionalHeader;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct IMAGE_NT_HEADERS64
        {
            public UInt32 Signature;
            public IMAGE_FILE_HEADER FileHeader;
            public IMAGE_OPTIONAL_HEADER64 OptionalHeader;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_FILE_HEADER
        {
            public ushort Machine;
            public ushort NumberOfSections;
            public uint TimeDateStamp;
            public uint PointerToSymbolTable;
            public uint NumberOfSymbols;
            public ushort SizeOfOptionalHeader;
            public ushort Characteristics;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct IMAGE_OPTIONAL_HEADER64
        {
            public UInt16 Magic;
            public byte MajorLinkerVersion;
            public byte MinorLinkerVersion;
            public uint SizeOfCode;
            public uint SizeOfInitializedData;
            public uint SizeOfUninitializedData;
            public uint AddressOfEntryPoint;
            public uint BaseOfCode;
            public ulong ImageBase;
            public uint SectionAlignment;
            public uint FileAlignment;
            public ushort MajorOperatingSystemVersion;
            public ushort MinorOperatingSystemVersion;
            public ushort MajorImageVersion;
            public ushort MinorImageVersion;
            public ushort MajorSubsystemVersion;
            public ushort MinorSubsystemVersion;
            public uint Win32VersionValue;
            public uint SizeOfImage;
            public uint SizeOfHeaders;
            public uint CheckSum;
            public UInt16 Subsystem;
            public UInt16 DllCharacteristics;
            public ulong SizeOfStackReserve;
            public ulong SizeOfStackCommit;
            public ulong SizeOfHeapReserve;
            public ulong SizeOfHeapCommit;
            public uint LoaderFlags;
            public uint NumberOfRvaAndSizes;
            public IMAGE_DATA_DIRECTORY DataDirectory;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct IMAGE_OPTIONAL_HEADER32
        {
            public UInt16 Magic;
            public Byte MajorLinkerVersion;
            public Byte MinorLinkerVersion;
            public UInt32 SizeOfCode;
            public UInt32 SizeOfInitializedData;
            public UInt32 SizeOfUninitializedData;
            public UInt32 AddressOfEntryPoint;
            public UInt32 BaseOfCode;
            public UInt32 BaseOfData;
            public UInt32 ImageBase;
            public UInt32 SectionAlignment;
            public UInt32 FileAlignment;
            public UInt16 MajorOperatingSystemVersion;
            public UInt16 MinorOperatingSystemVersion;
            public UInt16 MajorImageVersion;
            public UInt16 MinorImageVersion;
            public UInt16 MajorSubsystemVersion;
            public UInt16 MinorSubsystemVersion;
            public UInt32 Win32VersionValue;
            public UInt32 SizeOfImage;
            public UInt32 SizeOfHeaders;
            public UInt32 CheckSum;
            public UInt16 Subsystem;
            public UInt16 DllCharacteristics;
            public UInt32 SizeOfStackReserve;
            public UInt32 SizeOfStackCommit;
            public UInt32 SizeOfHeapReserve;
            public UInt32 SizeOfHeapCommit;
            public UInt32 LoaderFlags;
            public UInt32 NumberOfRvaAndSizes;
            public IMAGE_DATA_DIRECTORY DataDirectory;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_DATA_DIRECTORY
        {
            public uint VirtualAddress;
            public uint Size;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_EXPORT_DIRECTORY
        {
            public uint Characteristics;
            public uint TimeDateStamp;
            public ushort MajorVersion;
            public ushort MinorVersion;
            public uint Name;
            public uint Base;
            public uint NumberOfFunctions;
            public uint NumberOfNames;
            public uint AddressOfFunctions;
            public uint AddressOfNames;
            public uint AddressOfNameOrdinals;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct IMAGE_SECTION_HEADER
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public byte[] Name;

            public uint VirtualSize;
            public uint VirtualAddress;
            public uint SizeOfRawData;
            public uint PointerToRawData;
            public uint PointerToRelocations;
            public uint PointerToLinenumbers;
            public ushort NumberOfRelocations;
            public ushort NumberOfLinenumbers;
            public uint Characteristics;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct MEMORY_BASIC_INFORMATION
        {
            public IntPtr BaseAddress;
            public IntPtr AllocationBase;
            public uint AllocationProtect;
            public IntPtr RegionSize;
            public uint State;
            public uint Protect;
            public uint Type;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct OBJECT_ATTRIBUTES
        {
            public int Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName;
            public uint Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CLIENT_ID
        {
            public IntPtr UniqueProcess;
            public IntPtr UniqueThread;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct _LIST_ENTRY
        {
            public IntPtr Flink;
            public IntPtr Blink;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct _PEB_LDR_DATA
        {
            public UInt32 Length;
            public Byte Initialized;
            public IntPtr SsHandle;
            public _LIST_ENTRY InLoadOrderModuleList;
            public _LIST_ENTRY InMemoryOrderModuleList;
            public _LIST_ENTRY InInitializationOrderModuleList;
            public IntPtr EntryInProgress;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct _LDR_DATA_TABLE_ENTRY
        {
            public _LIST_ENTRY InLoadOrderLinks;
            public _LIST_ENTRY InMemoryOrderLinks;
            public _LIST_ENTRY InInitializationOrderLinks;
            public IntPtr DllBase;
            public IntPtr EntryPoint;
            public UInt32 SizeOfImage;
            public UNICODE_STRING FullDllName;
            public UNICODE_STRING BaseDllName;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RTL_USER_PROCESS_PARAMETERS
        {
            public long MaximumLength;
            public long Length;
            public long Flags;
            public long DebugFlags;
            public IntPtr ConsoleHandle;
            public long ConsoleFlags;
            public IntPtr StdInputHandle;
            public IntPtr StdOutputHandle;
            public IntPtr StdErrorHandle;
            public IntPtr CurrentDirectory;
            public UNICODE_STRING DllPath;
            public UNICODE_STRING ImagePathName;
            public UNICODE_STRING CommandLine;
            public IntPtr Environment;
            public long StartingPositionLeft;
            public long StartingPositionTop;
            public long Width;
            public long Height;
            public long CharWidth;
            public long CharHeight;
            public long ConsoleTextAttributes;
            public long WindowFlags;
            public long ShowWindowFlags;
            public UNICODE_STRING WindowTitle;
            public UNICODE_STRING DesktopName;
            public UNICODE_STRING ShellInfo;
            public UNICODE_STRING RuntimeData;
            public IntPtr DLCurrentDirectory;
            public long EnvironmentSize;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct PEB
        {
            public byte InheritedAddressSpace;
            public byte ReadImageFileExecOptions;
            public byte BeingDebugged;
            public byte SpareBool;
            public IntPtr Mutant;
            public IntPtr ImageBaseAddress;
            public IntPtr Ldr;
            public IntPtr ProcessParameters;
            public IntPtr SubSystemData;
            public IntPtr ProcessHeap;
            public IntPtr FastPebLock;
            public IntPtr AtlThunkSListPtr;
            public IntPtr IFEOKey;
            public uint CrossProcessFlags;
            public IntPtr KernelCallbackTable;
            public uint SystemReserved;
            public uint AtlThunkSListPtr32;
            public IntPtr ApiSetMap;
            public uint TlsExpansionCounter;
            public IntPtr TlsBitmap;
            public fixed uint TlsBitmapBits[2];
            public IntPtr ReadOnlySharedMemoryBase;
            public IntPtr SharedData;
            public IntPtr ReadOnlyStaticServerData;
            public IntPtr AnsiCodePageData;
            public IntPtr OemCodePageData;
            public IntPtr UnicodeCaseTableData;
            public uint NumberOfProcessors;
            public uint NtGlobalFlag;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct KBDLLHOOKSTRUCT
        {
            public uint vkCode;
            public uint scanCode;
            public uint flags;
            public uint time;
            public IntPtr dwExtraInfo;
        }
    }
}


================================================
File: AntiCrack-DotNet/Syscalls.cs
================================================
√Ø¬ª¬øusing System;
using System.Collections.Generic;
using System.Management;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using static AntiCrack_DotNet.Structs;
using static AntiCrack_DotNet.Delegates;
using static AntiCrack_DotNet.Utils;

namespace AntiCrack_DotNet
{
    public sealed class Syscalls
    {
        #region WinApi

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern void RtlInitUnicodeString(out Structs.UNICODE_STRING DestinationString, string SourceString);

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        private static extern void RtlUnicodeStringToAnsiString(out Structs.ANSI_STRING DestinationString, Structs.UNICODE_STRING UnicodeString, bool AllocateDestinationString);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint LdrGetDllHandleEx(ulong Flags, [MarshalAs(UnmanagedType.LPWStr)] string DllPath, [MarshalAs(UnmanagedType.LPWStr)] string DllCharacteristics, Structs.UNICODE_STRING LibraryName, ref IntPtr DllHandle);

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        private static extern uint LdrGetProcedureAddressForCaller(IntPtr Module, Structs.ANSI_STRING ProcedureName, ushort ProcedureNumber, out IntPtr FunctionHandle, ulong Flags, IntPtr CallBack);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetModuleHandleA(string Library);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetProcAddress(IntPtr hModule, string Function);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern int RtlGetVersion(ref Structs.OSVERSIONINFOEX versionInfo);

        #endregion

        #region Utils

        /// <summary>
        /// Get the most common syscall number which is used across different builds.
        /// </summary>
        /// <param name="Function">the function name to search for the syscall.</param>
        /// <returns>The syscall byte.</returns>
        public static byte GetCommonSyscallByte(string Function)
        {
            foreach (Syscall GetSyscalls in syscalls)
            {
                if (GetSyscalls.Name.ToLower() == Function.ToLower())
                {
                    return GetSyscalls.CommonSyscall;
                }
            }
            return 0x00;
        }

        /// <summary>
        /// Searches for the syscall number from the function bytes.
        /// </summary>
        /// <param name="bytes">the bytes to search for the syscall.</param>
        /// <returns>The syscall byte.</returns>
        public static byte ExtractSyscallByte(byte[] bytes, string Function)
        {
            bool RetFoundFirst = false;
            for (int i = 0; i < bytes.Length; i++)
            {
                if (bytes[i] == 0xB8)
                {
                    if (Function != null && RetFoundFirst || bytes[0] == 0xE9 || bytes[0] == 0x90)
                    {
                        byte Common = GetCommonSyscallByte(Function);
                        if(Common != 0x00)
                        {
                            return Common;
                        }
                    }
                    return bytes[i + 1];
                }

                if (bytes[i] == 0xC3 || bytes[i] == 0xC2)
                {
                    RetFoundFirst = true;
                }
            }
            return 0;
        }

        private sealed class Syscall
        {
            public string Name { get; set; }
            public List<(string BuildNumber, byte SyscallNumber)> BuildNumber { get; set; }
            public byte CommonSyscall { get; set; }
        }

        private static List<Syscall> syscalls = new List<Syscall>();

        /// <summary>
        /// Initializes the build numbers along with syscalls.
        /// </summary>
        public static void InitSyscall()
        {
            syscalls = new List<Syscall>
            {
                new Syscall
                {
                    CommonSyscall = 0xF,
                    Name = "NtClose",
                    BuildNumber = new List<(string, byte)>
                    {
                        ("7601", 0xF),
                        ("9200", 0xF),
                        ("9600", 0xF),
                        ("10240", 0xF),
                        ("10586", 0xF),
                        ("14393", 0xF),
                        ("15063", 0xF),
                        ("16299", 0xF),
                        ("17134", 0xF),
                        ("17763", 0xF),
                        ("18362", 0xF),
                        ("18363", 0xF),
                        ("19041", 0xF),
                        ("19042", 0xF),
                        ("19043", 0xF),
                        ("19044", 0xF),
                        ("19045", 0xF),
                        ("22621", 0xF),
                        ("22631", 0xF),
                        ("25915", 0xF),
                        ("26000", 0xF)
                    }
                },
                new Syscall
                {
                    CommonSyscall = 0x19,
                    Name = "NtQueryInformationProcess",
                    BuildNumber = new List<(string, byte)>
                    {
                        ("7601", 0x16),
                        ("9200", 0x17),
                        ("9600", 0x18),
                        ("10240", 0x19),
                        ("10586", 0x19),
                        ("14393", 0x19),
                        ("15063", 0x19),
                        ("16299", 0x19),
                        ("17134", 0x19),
                        ("17763", 0x19),
                        ("18362", 0x19),
                        ("18363", 0x19),
                        ("19041", 0x19),
                        ("19042", 0x19),
                        ("19043", 0x19),
                        ("19044", 0x19),
                        ("19045", 0x19),
                        ("22621", 0x19),
                        ("22631", 0x19),
                        ("25915", 0x19),
                        ("26000", 0x19)
                    }
                },
                new Syscall
                {
                    CommonSyscall = 0x36,
                    Name = "NtQuerySystemInformation",
                    BuildNumber = new List<(string DisplayVersion, byte SyscallNumber)>
                    {
                        ("7601", 0x33),
                        ("9200", 0x34),
                        ("9600", 0x35),
                        ("10240", 0x36),
                        ("10586", 0x36),
                        ("14393", 0x36),
                        ("15063", 0x36),
                        ("16299", 0x36),
                        ("17134", 0x36),
                        ("17763", 0x36),
                        ("18362", 0x36),
                        ("18363", 0x36),
                        ("19041", 0x36),
                        ("19042", 0x36),
                        ("19043", 0x36),
                        ("19044", 0x36),
                        ("19045", 0x36),
                        ("22621", 0x36),
                        ("22631", 0x36),
                        ("25915", 0x36),
                        ("26000", 0x36)
                    }
                },
                new Syscall
                {
                    CommonSyscall = 0x23,
                    Name = "NtQueryVirtualMemory",
                    BuildNumber = new List<(string, byte)>
                    {
                        ("7601", 0x20),
                        ("9200", 0x21),
                        ("9600", 0x22),
                        ("10240", 0x23),
                        ("10586", 0x23),
                        ("14393", 0x23),
                        ("15063", 0x23),
                        ("16299", 0x23),
                        ("17134", 0x23),
                        ("17763", 0x23),
                        ("18362", 0x23),
                        ("18363", 0x23),
                        ("19041", 0x23),
                        ("19042", 0x23),
                        ("19043", 0x23),
                        ("19044", 0x23),
                        ("19045", 0x23),
                        ("22621", 0x23),
                        ("22631", 0x23),
                        ("25915", 0x23),
                        ("26000", 0x23)
                    }
                },
                new Syscall
                {
                    CommonSyscall = 0x25,
                    Name = "NtQueryInformationThread",
                    BuildNumber = new List<(string, byte)>
                    {
                        ("7601", 0x22),
                        ("9200", 0x23),
                        ("9600", 0x24),
                        ("10240", 0x25),
                        ("10586", 0x25),
                        ("14393", 0x25),
                        ("15063", 0x25),
                        ("16299", 0x25),
                        ("17134", 0x25),
                        ("17763", 0x25),
                        ("18362", 0x25),
                        ("18363", 0x25),
                        ("19041", 0x25),
                        ("19042", 0x25),
                        ("19043", 0x25),
                        ("19044", 0x25),
                        ("19045", 0x25),
                        ("22621", 0x25),
                        ("22631", 0x25),
                        ("25915", 0x25),
                        ("26000", 0x25)
                    }
                },
            };
        }

        /// <summary>
        /// Searches for the return value from the function bytes.
        /// </summary>
        /// <param name="bytes">the bytes to search for the ret value.</param>
        /// <returns>The return value byte.</returns>
        public static byte ExtractSyscallRetValue(byte[] bytes)
        {
            for (int i = 0; i < bytes.Length; i++)
            {
                if (bytes[i] == 0xC2)
                {
                    return bytes[i + 1];
                }
            }
            return 0;
        }

        /// <summary>
        /// Checks to see if the build number is already saved.
        /// </summary>
        /// <returns>An indicator to see if the build number is saved or not.</returns>
        public static bool IsBuildNumberSaved()
        {
            foreach (Syscall GetSyscalls in syscalls)
            {
                for (int i = 0; i < GetSyscalls.BuildNumber.Count; i++)
                {
                    if (GetSyscalls.BuildNumber[i].BuildNumber.ToLower() == BuildNumber)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public static string BuildNumber = null;

        /// <summary>
        /// Searches for the build number in registry.
        /// </summary>
        /// <returns>The build number.</returns>
        private static string GetWindowsBuildNumberReg()
        {
            try
            {
                using (RegistryKey CurrentKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion"))
                {
                    if (CurrentKey != null)
                    {
                        object value = CurrentKey.GetValue("CurrentBuildNumber");
                        return value.ToString();
                    }
                }
            }
            catch
            {
                return null;
            }
            return null;
        }

        /// <summary>
        /// Searches for build number in WMI.
        /// </summary>
        /// <returns>The build number.</returns>
        private static string GetWindowsBuildNumberWMI()
        {
            try
            {
                using (var searcher = new ManagementObjectSearcher("SELECT * FROM Win32_OperatingSystem"))
                {
                    foreach (ManagementObject os in searcher.Get())
                    {
                        object build = os["BuildNumber"];
                        return build.ToString();
                    }
                }
            }
            catch
            {
                return null;
            }
            return null;
        }


        /// <summary>
        /// Gets the build number using RtlGetVersion WinAPI.
        /// </summary>
        /// <returns>The build number.</returns>
        private static string GetWindowsBuildNumberWinAPI()
        {
            OSVERSIONINFOEX VI = new OSVERSIONINFOEX();
            VI.dwOSVersionInfoSize = Marshal.SizeOf(typeof(OSVERSIONINFOEX));
            int status = RtlGetVersion(ref VI);
            if (status == 0)
            {
                return VI.dwBuildNumber.ToString();
            }
            return null;
        }


        /// <summary>
        /// Searches for the return value from the function bytes.
        /// </summary>
        /// <returns>returns if the build numbers have been tampered with.</returns>
        private static bool IsTampered(string WinAPI, string WMI, string Registry)
        {
            bool isMatch = (WinAPI == WMI) && (WMI == Registry);
            return !isMatch;
        }

        /// <summary>
        /// Searches for the return value from the function bytes.
        /// </summary>
        /// <returns>The most suitable build number.</returns>
        public static string GetMostMatching(string WinAPI, string WMI, string Registry)
        {
            if (Tampered)
            {
                if (WinAPI == WMI)
                {
                    return WinAPI;
                }
                else if (WinAPI == Registry)
                {
                    return WinAPI;
                }
                else if (WMI == Registry)
                {
                    return WMI;
                }
                else
                {
                    return WinAPI;
                }
            }
            else
            {
                return WinAPI;
            }
        }

        private static bool ShowedBefore = false;
        public static bool Tampered = false;

        /// <summary>
        /// Gets the system build number.
        /// </summary>
        /// <param name="ExitOnBuildNumberTamper">Exit if we found that the build number was tampered with.</param>
        /// <param name="OnlyShowOnTamper">Only print a console message that says that the function was tampered with.</param>
        /// <returns>The current system build number.</returns>
        public static string GetBuildNumber(bool ExitOnBuildNumberTamper, bool OnlyShowOnTamper)
        {
            string WinAPI = GetWindowsBuildNumberWinAPI();
            string WMI = GetWindowsBuildNumberWMI();
            string Registry = GetWindowsBuildNumberReg();
            if (IsTampered(WinAPI, WMI, Registry))
            {
                Tampered = true;
                if (OnlyShowOnTamper)
                {
                    if (!ShowedBefore)
                    {
                        Console.ForegroundColor = ConsoleColor.DarkRed;
                        Console.WriteLine("\nThe build number may have been tampered with. We will try to identify the most appropriate build number based on other detections and proceed with it, but there is a risk of incorrect syscalls...");
                        Console.ForegroundColor = ConsoleColor.White;
                        ShowedBefore = true;
                    }
                }
                else if(ExitOnBuildNumberTamper)
                {
                    ForceExit();
                }
            }
            return GetMostMatching(WinAPI, WMI, Registry);
        }

        /// <summary>
        /// Prepares the syscall code for the function provided.
        /// </summary>
        /// <param name="Library">the function library name.</param>
        /// <param name="Function">the function to get it's syscall code for.</param>
        /// <returns>An allocated memory to the syscall code.</returns>
        public static IntPtr SyscallCode(string Library, string Function)
        {
            try
            {
                bool Extract = true;
                byte SyscallNumber = 0x0;
                foreach (Syscall GetSyscalls in syscalls)
                {
                    if (GetSyscalls.Name.ToLower() == Function.ToLower())
                    {
                        for (int i = 0; i < GetSyscalls.BuildNumber.Count; i++)
                        {
                            if (GetSyscalls.BuildNumber[i].BuildNumber.ToLower() == BuildNumber)
                            {
                                Extract = false;
                                SyscallNumber = GetSyscalls.BuildNumber[i].SyscallNumber;
                                break;
                            }
                        }
                    }
                }
                IntPtr Address = GetFunctionExportAddress(Library, Function);
                if (Address != IntPtr.Zero)
                {
                    byte[] FunctionCode = new byte[40];
                    CopyMem(FunctionCode, Address, false);
                    if (Extract)
                    {
                        SyscallNumber = ExtractSyscallByte(FunctionCode, Function);
                    }
                    if (SyscallNumber != 0)
                    {
                        byte[] Code = new byte[40];
                        if (IntPtr.Size == 8)
                        {
                            Code = new byte[] { 0x49, 0x89, 0xCA, 0xB8, SyscallNumber, 0x00, 0x00, 0x00, 0x0F, 0x05, 0xC3 };
                        }
                        else
                        {
                            byte RetValue = ExtractSyscallRetValue(Code);
                            Code = new byte[] { 0xB8, SyscallNumber, 0x00, 0x00, 0x00, 0x64, 0xFF, 0x15, 0xC0, 0x00, 0x00, 0x00, 0xC2, RetValue, 0x00 };
                        }
                        return AllocateCode(Code);
                    }
                }
                return IntPtr.Zero;
            }
            catch
            {
                //this shouldn't happen in normal conditions
                ForceExit();
                return IntPtr.Zero;
            }
        }

        #endregion

        #region Syscalls

        public static uint SyscallNtQueryInformationProcess(uint ProcessInfoClass, out uint ProcessInfo, uint nSize, out uint ReturnLength)
        {
            ProcessInfo = 0;
            ReturnLength = 0;
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQueryInformationProcess");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQueryInformationProcess Executed = (SysNtQueryInformationProcess)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQueryInformationProcess));
                    uint Result = Executed(new IntPtr(-1), ProcessInfoClass, out ProcessInfo, nSize, out ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 0;
        }

        public static uint SyscallNtQueryInformationProcess(uint ProcessInfoClass, out IntPtr ProcessInfo, uint nSize, uint ReturnLength)
        {
            ProcessInfo = IntPtr.Zero;
            ReturnLength = 0;
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQueryInformationProcess");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQueryInformationProcess2 Executed = (SysNtQueryInformationProcess2)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQueryInformationProcess2));
                    uint Result = Executed(new IntPtr(-1), ProcessInfoClass, out ProcessInfo, nSize, ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 0;
        }

        public static uint SyscallNtQueryInformationProcess(uint ProcessInfoClass, ref Structs.PROCESS_BASIC_INFORMATION ProcessInfo, uint nSize, uint ReturnLength)
        {
            ProcessInfo = new PROCESS_BASIC_INFORMATION();
            ReturnLength = 0;
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQueryInformationProcess");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQueryInformationProcess3 Executed = (SysNtQueryInformationProcess3)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQueryInformationProcess3));
                    uint Result = Executed(new IntPtr(-1), ProcessInfoClass, ref ProcessInfo, nSize, ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 0;
        }

        public static bool SyscallNtClose(IntPtr Handle)
        {
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtClose");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtClose Executed = (SysNtClose)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtClose));
                    bool Result = Executed(Handle);
                    FreeCode(Syscall);
                    return Result;
                }
                finally
                {
                    FreeCode(Syscall);
                }
            }
            return false;
        }

        public static uint SyscallNtQuerySystemInformation(uint SystemInformationClass, ref Structs.SYSTEM_CODEINTEGRITY_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength)
        {
            ReturnLength = 0;
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQuerySystemInformation");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQuerySystemInformation Executed = (SysNtQuerySystemInformation)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQuerySystemInformation));
                    uint Result = Executed(SystemInformationClass, ref SystemInformation, SystemInformationLength, out ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 0;
        }

        public static uint SyscallNtQuerySystemInformation(uint SystemInformationClass, ref Structs.SYSTEM_KERNEL_DEBUGGER_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength)
        {
            ReturnLength = 0;
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQuerySystemInformation");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQuerySystemInformation2 Executed = (SysNtQuerySystemInformation2)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQuerySystemInformation2));
                    uint Result = Executed(SystemInformationClass, ref SystemInformation, SystemInformationLength, out ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 0;
        }

        public static uint SyscallNtQuerySystemInformation(uint SystemInformationClass, ref Structs.SYSTEM_SECUREBOOT_INFORMATION SystemInformation, uint SystemInformationLength, out uint ReturnLength)
        {
            ReturnLength = 0;
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQuerySystemInformation");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQuerySystemInformation3 Executed = (SysNtQuerySystemInformation3)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQuerySystemInformation3));
                    uint Result = Executed(SystemInformationClass, ref SystemInformation, SystemInformationLength, out ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 0;
        }

        public static uint SyscallNtQueryVirtualMemory(IntPtr ProcessHandle, IntPtr BaseAddress, uint MemoryInformationClass, ref Structs.MEMORY_BASIC_INFORMATION MemoryInformation, uint MemoryInformationLength, out uint ReturnLength)
        {
            ReturnLength = 0;
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQueryVirtualMemory");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQueryVirtualMemory Executed = (SysNtQueryVirtualMemory)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQueryVirtualMemory));
                    uint Result = Executed(ProcessHandle, BaseAddress, MemoryInformationClass, ref MemoryInformation, MemoryInformationLength, out ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 0;
        }

        public static int SyscallNtQueryInformationThread(IntPtr ThreadHandle, int ThreadInformationClass, ref IntPtr ThreadInformation, uint ThreadInformationLength, IntPtr ReturnLength)
        {
            IntPtr Syscall = SyscallCode("ntdll.dll", "NtQueryInformationThread");
            if (Syscall != IntPtr.Zero)
            {
                try
                {
                    SysNtQueryInformationThread Executed = (SysNtQueryInformationThread)Marshal.GetDelegateForFunctionPointer(Syscall, typeof(SysNtQueryInformationThread));
                    int Result = Executed(ThreadHandle, ThreadInformationClass, ref ThreadInformation, ThreadInformationLength, ReturnLength);
                    FreeCode(Syscall);
                    return Result;
                }
                catch
                {
                    FreeCode(Syscall);
                }
            }
            return 1;
        }
        #endregion
    }
}


================================================
File: AntiCrack-DotNet/Utils.cs
================================================
√Ø¬ª¬øusing System;
using System.Runtime.InteropServices;
using System.Text;
using static AntiCrack_DotNet.Structs;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Globalization;
using static AntiCrack_DotNet.Delegates;
using System.Diagnostics;

namespace AntiCrack_DotNet
{
    public sealed class Utils
    {
        #region WinApi

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtAllocateVirtualMemory(IntPtr ProcessHandle, ref IntPtr BaseAddress, uint ZeroBits, ref uint RegionSize, uint AllocationType, uint Protect);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern bool VirtualFree(IntPtr lpAddress, uint dwSize, uint dwFreeType);

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern void RtlInitUnicodeString(out Structs.UNICODE_STRING DestinationString, string SourceString);

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        private static extern void RtlUnicodeStringToAnsiString(out Structs.ANSI_STRING DestinationString, Structs.UNICODE_STRING UnicodeString, bool AllocateDestinationString);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint LdrGetDllHandleEx(ulong Flags, [MarshalAs(UnmanagedType.LPWStr)] string DllPath, [MarshalAs(UnmanagedType.LPWStr)] string DllCharacteristics, Structs.UNICODE_STRING LibraryName, ref IntPtr DllHandle);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetModuleHandleA(string Library);

        [DllImport("kernelbase.dll", SetLastError = true)]
        private static extern IntPtr GetProcAddress(IntPtr hModule, string Function);

        [DllImport("ntdll.dll", SetLastError = true, CharSet = CharSet.Ansi)]
        private static extern uint LdrGetProcedureAddressForCaller(IntPtr Module, Structs.ANSI_STRING ProcedureName, ushort ProcedureNumber, out IntPtr FunctionHandle, ulong Flags, IntPtr CallBack);

        [DllImport("kernelbase.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern uint GetModuleFileName(IntPtr hModule, StringBuilder lpFileName, uint nSize);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern int NtProtectVirtualMemory(IntPtr hProcess, ref IntPtr BaseAddress, ref UIntPtr RegionSize, uint NewProtect, out uint oldProtect);

        [DllImport("ntdll.dll", SetLastError = true)]
        private static extern uint NtQueryVirtualMemory(IntPtr ProcessHandle, IntPtr BaseAddress, uint MemoryInformationClass, ref Structs.MEMORY_BASIC_INFORMATION MemoryInformation, uint MemoryInformationLength, out uint ReturnLength);

        [DllImport("ntdll", SetLastError = true)]
        private static extern uint NtClose(IntPtr hObject);

        #endregion

        /// <summary>
        /// Gets the handle of a specified module using low-level functions.
        /// </summary>
        /// <param name="Library">The name of the library to get the handle for.</param>
        /// <returns>The handle to the module.</returns>
        public static IntPtr LowLevelGetModuleHandle(string Library)
        {
            if (IntPtr.Size == 4)
                return GetModuleHandleA(Library);
            IntPtr hModule = IntPtr.Zero;
            Structs.UNICODE_STRING UnicodeString = new Structs.UNICODE_STRING();
            RtlInitUnicodeString(out UnicodeString, Library);
            LdrGetDllHandleEx(0, null, null, UnicodeString, ref hModule);
            return hModule;
        }

        /// <summary>
        /// Gets the address of a specified function using low-level functions.
        /// </summary>
        /// <param name="hModule">The handle to the module.</param>
        /// <param name="Function">The name of the function to get the address for.</param>
        /// <returns>The address of the function.</returns>
        public static IntPtr LowLevelGetProcAddress(IntPtr hModule, string Function)
        {
            if (IntPtr.Size == 4)
                return GetProcAddress(hModule, Function);
            IntPtr FunctionHandle = IntPtr.Zero;
            Structs.UNICODE_STRING UnicodeString = new Structs.UNICODE_STRING();
            Structs.ANSI_STRING AnsiString = new Structs.ANSI_STRING();
            RtlInitUnicodeString(out UnicodeString, Function);
            RtlUnicodeStringToAnsiString(out AnsiString, UnicodeString, true);
            LdrGetProcedureAddressForCaller(hModule, AnsiString, 0, out FunctionHandle, 0, IntPtr.Zero);
            return FunctionHandle;
        }

        /// <summary>
        /// Gets the export address of a function.
        /// </summary>
        /// <param name="Module">The module name.</param>
        /// <param name="Function">The name of the function to get the export address for.</param>
        /// <returns>The address of the function.</returns>
        public static IntPtr GetFunctionExportAddress(string Module, string Function)
        {
            IntPtr hModule = LowLevelGetModuleHandle(Module);
            try
            {
                IntPtr pDosHeader = hModule;
                IMAGE_DOS_HEADER dosHeader = Marshal.PtrToStructure<IMAGE_DOS_HEADER>(pDosHeader);
                IntPtr pNtHeaders = IntPtr.Add(pDosHeader, dosHeader.e_lfanew);
                dynamic NtHeadersStruct;
                if (IntPtr.Size == 8)
                    NtHeadersStruct = Marshal.PtrToStructure<IMAGE_NT_HEADERS64>(pNtHeaders);
                else
                    NtHeadersStruct = Marshal.PtrToStructure<IMAGE_NT_HEADERS32>(pNtHeaders);
                IMAGE_DATA_DIRECTORY EPData = NtHeadersStruct.OptionalHeader.DataDirectory;
                IntPtr pExportDirectory = IntPtr.Add(hModule, (int)EPData.VirtualAddress);
                IMAGE_EXPORT_DIRECTORY ED = Marshal.PtrToStructure<IMAGE_EXPORT_DIRECTORY>(pExportDirectory);
                IntPtr pAddressOfFunctions = IntPtr.Add(hModule, (int)ED.AddressOfFunctions);
                IntPtr pAddressOfNames = IntPtr.Add(hModule, (int)ED.AddressOfNames);
                IntPtr pAddressOfNameOrdinals = IntPtr.Add(hModule, (int)ED.AddressOfNameOrdinals);
                int NamesCount = (int)ED.NumberOfNames;
                for (int i = 0; i < NamesCount; i++)
                {
                    int FunctionNameRva = Marshal.ReadInt32(IntPtr.Add(pAddressOfNames, i * 4));
                    string FunctionName = Marshal.PtrToStringAnsi(IntPtr.Add(hModule, FunctionNameRva));
                    if (FunctionName == Function)
                    {
                        int FunctionOrdinal = Marshal.ReadInt16(IntPtr.Add(pAddressOfNameOrdinals, i * 2));
                        int FunctionRVA = Marshal.ReadInt32(IntPtr.Add(pAddressOfFunctions, FunctionOrdinal * 4));
                        return IntPtr.Add(hModule, FunctionRVA);
                    }
                }
            }
            catch
            {

            }
            return LowLevelGetProcAddress(hModule, Function);
        }

        /// <summary>
        /// Gets the export address of a function.
        /// </summary>
        /// <param name="hModule">The module handle.</param>
        /// <param name="Function">The name of the function to get the export address for.</param>
        /// <returns>The address of the function.</returns>
        public static IntPtr GetFunctionExportAddress(IntPtr hModule, string Function)
        {
            try
            {
                IntPtr pDosHeader = hModule;
                IMAGE_DOS_HEADER dosHeader = Marshal.PtrToStructure<IMAGE_DOS_HEADER>(pDosHeader);
                IntPtr pNtHeaders = IntPtr.Add(pDosHeader, dosHeader.e_lfanew);
                dynamic NtHeadersStruct;
                if (IntPtr.Size == 8)
                    NtHeadersStruct = Marshal.PtrToStructure<IMAGE_NT_HEADERS64>(pNtHeaders);
                else
                    NtHeadersStruct = Marshal.PtrToStructure<IMAGE_NT_HEADERS32>(pNtHeaders);
                IMAGE_DATA_DIRECTORY EPData = NtHeadersStruct.OptionalHeader.DataDirectory;
                IntPtr pExportDirectory = IntPtr.Add(hModule, (int)EPData.VirtualAddress);
                IMAGE_EXPORT_DIRECTORY ED = Marshal.PtrToStructure<IMAGE_EXPORT_DIRECTORY>(pExportDirectory);
                IntPtr pAddressOfFunctions = IntPtr.Add(hModule, (int)ED.AddressOfFunctions);
                IntPtr pAddressOfNames = IntPtr.Add(hModule, (int)ED.AddressOfNames);
                IntPtr pAddressOfNameOrdinals = IntPtr.Add(hModule, (int)ED.AddressOfNameOrdinals);
                int NamesCount = (int)ED.NumberOfNames;
                for (int i = 0; i < NamesCount; i++)
                {
                    int FunctionNameRva = Marshal.ReadInt32(IntPtr.Add(pAddressOfNames, i * 4));
                    string FunctionName = Marshal.PtrToStringAnsi(IntPtr.Add(hModule, FunctionNameRva));
                    if (FunctionName == Function)
                    {
                        int FunctionOrdinal = Marshal.ReadInt16(IntPtr.Add(pAddressOfNameOrdinals, i * 2));
                        int FunctionRVA = Marshal.ReadInt32(IntPtr.Add(pAddressOfFunctions, FunctionOrdinal * 4));
                        return IntPtr.Add(hModule, FunctionRVA);
                    }
                }
            }
            catch
            {

            }
            return LowLevelGetProcAddress(hModule, Function);
        }

        /// <summary>
        /// Writes the struct to a pointer.
        /// </summary>
        /// <param name="structure">The struct.</param>
        /// <param name="ptr">The pointer to the address that represents the struct.</param>
        /// <param name="fDeleteOld">An indicator to whether we should delete the old struct after writing or not.</param>
        /// <param name="ChangeMemoryProtection">An indicator to whether we should change the ptr memory protection before writing.</param>
        /// <returns>return true if successful, otherwise false.</returns>
        public static bool WriteStructToPtr<T>(T structure, IntPtr ptr, bool fDeleteOld, bool ChangeMemoryProtection)
        {
            try
            {
                if (ChangeMemoryProtection)
                {
                    uint Old = 0;
                    ProtectMemory(ptr, (UIntPtr)Marshal.SizeOf(structure), PAGE_EXECUTE_READWRITE, out Old);
                    Marshal.StructureToPtr(structure, ptr, fDeleteOld);
                    ProtectMemory(ptr, (UIntPtr)Marshal.SizeOf(structure), Old, out Old);
                    return true;
                }
                else
                {
                    Marshal.StructureToPtr(structure, ptr, fDeleteOld);
                    return true;
                }
            }
            catch
            {
                
            }
            return false;
        }

        public static string GetCurrentCLRModuleName()
        {
            string[] CLRs = { "clr.dll", "coreclr.dll" };
            foreach(ProcessModule module in Process.GetCurrentProcess().Modules)
            {
                foreach (string CLR in CLRs)
                {
                    if (module.ModuleName.ToLower() == CLR)
                    {
                        return module.ModuleName;
                    }
                }
            }
            return null;
        }

        /// <summary>
        /// Changes the page protection for an address.
        /// </summary>
        /// <param name="BaseAddress">The Address to change the protection for.</param>
        /// <param name="RegionSize">The size of the address.</param>
        /// <param name="NewProtect">The new protection to apply.</param>
        /// <param name="oldProtect">The old protection if you wanna set it back again.</param>
        /// <returns>return true if successfully did it's job, otherwise false.</returns>
        public static bool ProtectMemory(IntPtr BaseAddress, UIntPtr RegionSize, uint NewProtect, out uint oldProtect)
        {
            int Status = NtProtectVirtualMemory(new IntPtr(-1), ref BaseAddress, ref RegionSize, NewProtect, out oldProtect);
            if (Status == 0)
                return true;
            return false;
        }

        /// <summary>
        /// Reads a byte from a specified memory address.
        /// </summary>
        /// <param name="ptr">The memory address to read from.</param>
        /// <returns>The byte read from the memory address.</returns>
        public static byte InternalReadByte(IntPtr ptr)
        {
            unsafe
            {
                try
                {
                    byte* ptr2 = (byte*)(void*)ptr;
                    return *ptr2;
                }
                catch
                {
                    return 0;
                }
            }
        }

        /// <summary>
        /// Force exits the process even if hooked.
        /// </summary>
        public static void ForceExit()
        {
            Environment.Exit(0);
            unsafe
            {
                int* ptr = null;
                *ptr = 42;
            }
            throw new Exception(new Random().Next(int.MinValue, int.MaxValue).ToString());
        }

        /// <summary>
        /// copies memory from a byte array to an IntPtr.
        /// </summary>
        /// <param name="dst">The IntPtr destination in which the data will be copied to.</param>
        /// <param name="src">The byte array source in which the data will be copied from.</param>
        public static void CopyMem(IntPtr dst, byte[] src, bool ChangeProtection)
        {
            unsafe
            {
                fixed (byte* source = src)
                {
                    if (ChangeProtection)
                    {
                        uint oldProtect = 0;
                        if (ProtectMemory(dst, (UIntPtr)src.Length, 0x40, out oldProtect))
                        {
                            Buffer.MemoryCopy(source, (void*)dst, src.Length, src.Length);
                            ProtectMemory(dst, (UIntPtr)src.Length, oldProtect, out oldProtect);
                        }
                    }
                    else
                    {
                        Buffer.MemoryCopy(source, (void*)dst, src.Length, src.Length);
                    }
                }
            }
        }

        /// <summary>
        /// copies memory from an IntPtr to a byte array.
        /// </summary>
        /// <param name="dst">The byte array destination in which the data will be copied to.</param>
        /// <param name="src">The IntPtr source in which the data will be copied from.</param>
        public static void CopyMem(byte[] dst, IntPtr src, bool ChangeProtection)
        {
            unsafe
            {
                fixed (byte* destination = dst)
                {
                    if (ChangeProtection)
                    {
                        uint oldProtect = 0;
                        if (ProtectMemory(src, (UIntPtr)dst.Length, 0x40, out oldProtect))
                        {
                            Buffer.MemoryCopy((void*)src, destination, dst.Length, dst.Length);
                            ProtectMemory(src, (UIntPtr)dst.Length, oldProtect, out oldProtect);
                        }
                    }
                    else
                    {
                        Buffer.MemoryCopy((void*)src, destination, dst.Length, dst.Length);
                    }
                }
            }
        }

        /// <summary>
        /// copies memory from an IntPtr to another.
        /// </summary>
        /// <param name="dst">The byte array destination in which the data will be copied to.</param>
        /// <param name="src">The IntPtr source in which the data will be copied from.</param>
        public static void CopyMem(IntPtr dst, IntPtr src, bool ChangeProtection)
        {
            unsafe
            {
                int SizeDst = Marshal.SizeOf(dst);
                if (ChangeProtection)
                {
                    uint oldProtect = 0;
                    if (ProtectMemory(dst, (UIntPtr)SizeDst, 0x40, out oldProtect))
                    {
                        Buffer.MemoryCopy((void*)src, (void*)dst, SizeDst, SizeDst);
                        ProtectMemory(dst, (UIntPtr)SizeDst, oldProtect, out oldProtect);
                    }
                }
                else
                {
                    Buffer.MemoryCopy((void*)src, (void*)dst, SizeDst, SizeDst);
                }
            }
        }

        /// <summary>
        /// Sees if the first string contains the second string.
        /// </summary>
        /// <param name="First">First string to see if it contains the second string.</param>
        /// <param name="Second">The second string that will be searched for.</param>
        /// <returns>if the second string contains a string from the first one then the result is true, otherwise false.</returns>
        public static bool Contains(string First, string Second)
        {
            if (CultureInfo.InvariantCulture.CompareInfo.IndexOf(First, Second, 0, First.Length, CompareOptions.OrdinalIgnoreCase) >= 0)
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// The method which is invoked to test reflection for IsReflectionEnabled.
        /// </summary>
        /// <returns>a random number from 1-99</returns>
        private static int TestInvoke()
        {
            return new Random().Next(1, 99);
        }

        /// <summary>
        /// Checks if reflection is supported before doing reflection operations.
        /// </summary>
        /// <param name="FPSupport">Check if we can get a function pointer.</param>
        /// <param name="InvokeSupport">Check if we can invoke another function.</param>
        /// <returns>return true if reflection is enabled and supports the options you provided, otherwise false.</returns>
        public static bool IsReflectionEnabled(bool FPSupport, bool InvokeSupport)
        {
            try
            {
                MethodBase BaseMethodTest = MethodBase.GetCurrentMethod().DeclaringType.GetMethod("TestInvoke", BindingFlags.NonPublic | BindingFlags.Static);
                if (BaseMethodTest == null)
                    return false;
                if (InvokeSupport)
                {
                    if (BaseMethodTest.Invoke(null, null) == null || (int)BaseMethodTest.Invoke(null, null) == 0)
                        return false;
                }

                if (FPSupport)
                {
                    if (GetPointer(BaseMethodTest as MethodInfo) == IntPtr.Zero)
                        return false;
                }
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Converts a cast to a stack pointer.
        /// </summary>
        /// <returns>The stack pointer of the cast you provided.</returns>
        private static IntPtr UnsafeCastToStackPointer<T>(ref T o) where T : class
        {
            unsafe
            {
                fixed (T* ptr = &o)
                {
                    return (IntPtr)ptr;
                }
            }
        }

        /// <summary>
        /// Gets the entry assembly directly using internal .NET functions using reflection.
        /// </summary>
        /// <returns>if successful then it returns the entry assembly, otherwise null.</returns>
        public static Assembly LowLevelGetEntryAssembly()
        {
            if (!IsReflectionEnabled(false, true))
                return null;
            Assembly EntryAsm = null;
            try
            {
                IntPtr AsmPtr = UnsafeCastToStackPointer(ref EntryAsm);
                if (AsmPtr != IntPtr.Zero)
                {
                    Type ObjectHandleOnStackType = Type.GetType("System.Runtime.CompilerServices.ObjectHandleOnStack");
                    if (ObjectHandleOnStackType != null)
                    {
                        object InstanceObjectHandle = Activator.CreateInstance(ObjectHandleOnStackType);
                        FieldInfo mPtrFieldObjectHandle = ObjectHandleOnStackType.GetField("m_ptr", BindingFlags.NonPublic | BindingFlags.Instance);
                        mPtrFieldObjectHandle.SetValue(InstanceObjectHandle, AsmPtr);
                        Utils.CallInternalCLRFunction("GetEntryAssembly", typeof(AppDomainManager), BindingFlags.NonPublic | BindingFlags.Static, null, new object[] { InstanceObjectHandle }, null);
                    }
                }
            }
            catch
            {
                return null;
            }
            return EntryAsm;
        }

        /// <summary>
        /// Gets the currently executing assembly directly using internal .NET functions using reflection.
        /// </summary>
        /// <returns>if successful then it returns the executing assembly, otherwise null.</returns>
        public static Assembly LowLevelGetExecutingAssembly()
        {
            if (!IsReflectionEnabled(false, true))
                return null;
            Assembly ExecutingAssembly = null;
            try
            {
                IntPtr AsmPtr = UnsafeCastToStackPointer(ref ExecutingAssembly);
                if (AsmPtr != IntPtr.Zero)
                {
                    Type ObjectHandleOnStackType = Type.GetType("System.Runtime.CompilerServices.ObjectHandleOnStack");
                    Type StackCrawlMarksType = Type.GetType("System.Runtime.CompilerServices.StackCrawlMarkHandle");
                    if (ObjectHandleOnStackType != null && StackCrawlMarksType != null)
                    {
                        object InstanceObjectHandle = Activator.CreateInstance(ObjectHandleOnStackType);
                        FieldInfo mPtrFieldObjectHandle = ObjectHandleOnStackType.GetField("m_ptr", BindingFlags.NonPublic | BindingFlags.Instance);
                        mPtrFieldObjectHandle.SetValue(InstanceObjectHandle, AsmPtr);
                        Type StackCrawlMarkEnumType = Type.GetType("System.Threading.StackCrawlMark");
                        object LookForMyCaller = Enum.Parse(StackCrawlMarkEnumType, "LookForMyCaller");
                        IntPtr StackCrawlMarkPtr = UnsafeCastToStackPointer(ref LookForMyCaller);
                        if (StackCrawlMarkPtr != IntPtr.Zero)
                        {
                            object InstanceStackCrawl = Activator.CreateInstance(StackCrawlMarksType);
                            FieldInfo mPtrFieldStackCrawl = StackCrawlMarksType.GetField("m_ptr", BindingFlags.NonPublic | BindingFlags.Instance);
                            mPtrFieldStackCrawl.SetValue(InstanceStackCrawl, StackCrawlMarkPtr);
                            Utils.CallInternalCLRFunction("GetExecutingAssembly", Type.GetType("System.Reflection.RuntimeAssembly"), typeof(void), new object[] { InstanceStackCrawl, InstanceObjectHandle }, null);
                        }
                    }
                }
            }
            catch
            {
                return null;
            }
            return ExecutingAssembly;
        }

        /// <summary>
        /// Calls methods in the CLR which isn't normally/directly accessible.
        /// </summary>
        /// <param name="InternalMethod">The name of the internal function.</param>
        /// <param name="InternalMethodType">The class or type that the method is in.</param>
        /// <param name="Flags">The method flags which will be used to find the exact method.</param>
        /// <param name="Parameters">The parameters which is used to search for the function using it, will be used instead of Flags if not left null.</param>
        /// <param name="InvokeParameters">The parameters passed to the method. can be null.</param>
        /// <param name="GenericParameter">The type arguments if the method is a generic method.</param>
        /// <returns>the return value of the method (if any).</returns>
        public static object CallInternalCLRFunction(string InternalMethod, Type InternalMethodType, BindingFlags Flags, Type[] Parameters, object[] InvokeParameters, Type GenericParameter = null)
        {
            try
            {
                if (!IsReflectionEnabled(false, true))
                    return null;
                if (string.IsNullOrEmpty(InternalMethod) || InternalMethodType == null)
                    return null;

                MethodInfo MI = null;
                if (Parameters != null)
                {
                    MI = InternalMethodType.GetMethod(InternalMethod, Parameters);
                }
                else
                {
                    MI = InternalMethodType.GetMethod(InternalMethod, Flags);
                }

                if(MI.IsGenericMethod && GenericParameter != null)
                {
                    MI = MI.MakeGenericMethod(GenericParameter);
                }
                
                if (MI != null)
                {
                    object instance = MI.IsStatic ? null : Activator.CreateInstance(InternalMethodType);
                    return MI.Invoke(instance, InvokeParameters);
                }
                return null;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Calls methods in the CLR which isn't normally/directly accessible.
        /// </summary>
        /// <param name="InternalMethod">The name of the internal function.</param>
        /// <param name="InternalMethodType">The class or type that the method is in.</param>
        /// <param name="ReturnType">The return type of the method to be searched for.</param>
        /// <param name="InvokeParameters">The parameters passed to the method. can be null.</param>
        /// <param name="GenericParameter">The type arguments if the method is a generic method.</param>
        /// <returns>the return value of the method (if any).</returns>
        public static object CallInternalCLRFunction(string InternalMethod, Type InternalMethodType, Type ReturnType, object[] InvokeParameters, Type GenericParameter = null)
        {
            try
            {
                if (!IsReflectionEnabled(false, true))
                    return null;
                if (string.IsNullOrEmpty(InternalMethod) || InternalMethodType == null)
                    return null;
                MethodInfo MI = null;
                foreach (MethodInfo methods in InternalMethodType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static))
                {
                    if (methods.Name.ToLower() == InternalMethod.ToLower())
                    {
                        if (methods.ReturnType == ReturnType)
                        {
                            MI = methods;
                            break;
                        }
                    }
                }

                if (MI.IsGenericMethod && GenericParameter != null)
                {
                    MI = MI.MakeGenericMethod(GenericParameter);
                }

                if (MI != null)
                {
                    object instance = MI.IsStatic ? null : Activator.CreateInstance(InternalMethodType);
                    return MI.Invoke(instance, InvokeParameters);
                }
                return null;
            }
            catch
            {
                return null;
            }
        }

        private static uint PAGE_EXECUTE_READWRITE = 0x40;
        private static uint MEM_RELEASE = 0x00008000;

        /// <summary>
        /// Gets the Process Environment Block with it's struct.
        /// </summary>
        /// <returns>returns the PEB.</returns>
        public static PEB GetPEB()
        {
            byte[] PEBCode = new byte[20];
            if (IntPtr.Size == 8)
                PEBCode = new byte[] { 0x48, 0x31, 0xC0, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0xC3 };
            else
                PEBCode = new byte[] { 0x31, 0xC0, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0xC3 };
            IntPtr AllocatedCode = AllocateCode(PEBCode);
            if (AllocatedCode != IntPtr.Zero)
            {
                try
                {
                    GenericPtr PebDel = (GenericPtr)Marshal.GetDelegateForFunctionPointer(AllocatedCode, typeof(GenericPtr));
                    IntPtr PebPtr = PebDel();
                    FreeCode(AllocatedCode);
                    if (PebPtr != IntPtr.Zero)
                    {
                        return Marshal.PtrToStructure<PEB>(PebPtr);
                    }
                }
                catch
                {
                    FreeCode(AllocatedCode);
                }
            }
            return new PEB();
        }

        /// <summary>
        /// Allocates assembly code from byte array.
        /// </summary>
        /// <param name="Code">The assembly code in byte array.</param>
        /// <returns>Allocated memory to the assembly code.</returns>
        public static IntPtr AllocateCode(byte[] Code)
        {
            IntPtr Allocated = IntPtr.Zero;
            uint Length = (uint)Code.Length;
            uint Status = NtAllocateVirtualMemory(new IntPtr(-1), ref Allocated, 0, ref Length, 0x1000, PAGE_EXECUTE_READWRITE);
            if (Status == 0)
            {
                CopyMem(Allocated, Code, false);
                return Allocated;
            }
            return IntPtr.Zero;
        }

        /// <summary>
        /// Frees the allocated memory.
        /// </summary>
        /// <param name="AllocatedCode">The allocated assembly code to be freed.</param>
        /// <returns>An indicator if the memory was freed or not.</returns>
        public static bool FreeCode(IntPtr AllocatedCode)
        {
            return VirtualFree(AllocatedCode, 0, MEM_RELEASE);
        }

        /// <summary>
        /// Closes a handle.
        /// </summary>
        /// <param name="Handle">The handle to be closed.</param>
        /// <returns>true if the handle has been closed, otherwise false.</returns>
        public static bool CloseHandle(IntPtr Handle)
        {
            if (NtClose(Handle) == 0)
                return true;
            return false;
        }

        public static bool GetVirtualMemoryQuery(bool Syscall, IntPtr BaseAddress, ref MEMORY_BASIC_INFORMATION MemoryInformation, out uint ReturnLength)
        {
            uint Length = (uint)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION));
            uint Result = Syscall ? Syscalls.SyscallNtQueryVirtualMemory(new IntPtr(-1), BaseAddress, 0, ref MemoryInformation, Length, out ReturnLength) : NtQueryVirtualMemory(new IntPtr(-1), BaseAddress, 0, ref MemoryInformation, Length, out ReturnLength);
            if (Result == 0)
                return true;
            return false;
        }

        /// <summary>
        /// Installs a function hook.
        /// </summary>
        /// <param name="Source">The source function pointer to be hooked.</param>
        /// <param name="Destination">The destination function pointer to be the hooking function.</param>
        /// <param name="Hooked">The hooked code which will be written to if you wanna hook the function later (6 bytes in length).</param>
        private static bool HookFunction(IntPtr Source, IntPtr Destination, out byte[] Hooked)
        {
            byte[] HookCode = new byte[6];
            HookCode[0] = 0x90;
            HookCode[1] = 0xE9;
            if (IntPtr.Size == 8)
            {
                long offset = Destination.ToInt64() - Source.ToInt64() - HookCode.Length;
                byte[] offsetBytes = BitConverter.GetBytes(offset);
                Array.Copy(offsetBytes, 0, HookCode, 2, HookCode.Length - 2);
            }
            else
            {
                long offset = Destination.ToInt32() - Source.ToInt32() - HookCode.Length;
                byte[] offsetBytes = BitConverter.GetBytes((int)offset);
                Array.Copy(offsetBytes, 0, HookCode, 2, HookCode.Length - 2);
            }
            CopyMem(Source, HookCode, true);
            Hooked = HookCode;
            return true;
        }

        /// <summary>
        /// Installs/Uninstalls a hook to/from the function.
        /// </summary>
        /// <param name="code">The code which is hooked/unhooked to apply.</param>
        /// <param name="pFunction">pointer to the function.</param>
        public static void InstallOrUninstallHook(byte[] code, IntPtr pFunction)
        {
            CopyMem(pFunction, code, true);
        }

        /// <summary>
        /// The whitelisted function by the hook which should get the original function pointer.
        /// </summary>
        /// <param name="MI">The method to get the pointer for.</param>
        /// <returns>Returns the pointer if successful, otherwise IntPtr.Zero</returns>
        public static IntPtr GetPointer(MethodInfo MI)
        {
            return MI.MethodHandle.GetFunctionPointer();
        }

        /// <summary>
        /// The whitelisted function by the hook which should get the original function pointer from the delegate.
        /// </summary>
        /// <param name="MI">The method to get the pointer for.</param>
        /// <returns>Returns the pointer if successful, otherwise IntPtr.Zero</returns>
        public static IntPtr GetPointerDelegate(Delegate DelegateMethod)
        {
            if (IsReflectionEnabled(false, true))
            {
                return (IntPtr)CallInternalCLRFunction("GetFunctionPointerForDelegateInternal", typeof(Marshal), BindingFlags.NonPublic | BindingFlags.Static, null, new object[] { DelegateMethod });
            }
            return Marshal.GetFunctionPointerForDelegate(DelegateMethod);
        }

        //to be used later in future releases.
        /// <summary>
        /// Installs a WinAPI hook.
        /// </summary>
        /// <param name="Dll">The name of the module or dll to get the function from.</param>
        /// <param name="Function">The name of the function to be hooked.</param>
        /// <param name="HookingMethod">The method which will be the hook.</param>
        /// <param name="OriginalCode">The original code which will be written to if you wanna unhook the function later (6 bytes in length).</param>
        /// <param name="HookedCode">The hook code which can be used to hook the function after unhooking it. (6 bytes in length)</param>
        /// <param name="pFunction">A pointer to the function in which you can install/uninstall hooks from using InstallOrUninstallHook function.</param>
        /// <returns>Returns true if successfully hooked, otherwise false.</returns>
        public static bool InstallHookWinApi(string Dll, string Function, MethodInfo HookingMethod, byte[] OriginalCode, out byte[] HookedCode, out IntPtr pFunction)
        {
            try
            {
                if (!IsReflectionEnabled(true, true))
                {
                    HookedCode = null;
                    pFunction = IntPtr.Zero;
                    return false;
                }
                RuntimeHelpers.PrepareMethod(HookingMethod.MethodHandle);
                IntPtr pSource = GetFunctionExportAddress(Dll, Function);
                if (OriginalCode != null)
                    CopyMem(OriginalCode, pSource, false);
                IntPtr pHookingMethod = GetPointer(HookingMethod);
                if (pHookingMethod != IntPtr.Zero)
                {
                    if (HookFunction(pSource, pHookingMethod, out HookedCode))
                    {
                        pFunction = pSource;
                        return true;
                    }
                }
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
            catch
            {
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
        }

        //to be used later in future releases.
        /// <summary>
        /// Installs a WinAPI hook.
        /// </summary>
        /// <param name="Dll">The name of the module or dll to get the function from.</param>
        /// <param name="Function">The name of the function to be hooked.</param>
        /// <param name="HookingMethodDelegate">A delegate for the hooking function which is recommended if the hooking method receives incorrect parameters because of call conventions or reflection support.</param>
        /// <param name="OriginalCode">The original code which will be written to if you wanna unhook the function later (6 bytes in length).</param>
        /// <param name="HookedCode">The hook code which can be used to hook the function after unhooking it. (6 bytes in length)</param>
        /// <param name="pFunction">A pointer to the function in which you can install/uninstall hooks from using InstallOrUninstallHook function.</param>
        /// <returns>Returns true if successfully hooked, otherwise false.</returns>
        public static bool InstallHookWinApi(string Dll, string Function, Delegate HookingMethodDelegate, byte[] OriginalCode, out byte[] HookedCode, out IntPtr pFunction)
        {
            try
            {
                if (!IsReflectionEnabled(false, true))
                {
                    HookedCode = null;
                    pFunction = IntPtr.Zero;
                    return false;
                }
                IntPtr pSource = GetFunctionExportAddress(Dll, Function);
                if (OriginalCode != null)
                    CopyMem(OriginalCode, pSource, false);
                if (HookingMethodDelegate != null)
                {
                    IntPtr DelegatePtr = GetPointerDelegate(HookingMethodDelegate);
                    if (DelegatePtr != IntPtr.Zero)
                    {
                        if (HookFunction(pSource, DelegatePtr, out HookedCode))
                        {
                            pFunction = pSource;
                            return true;
                        }
                    }
                }
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
            catch
            {
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
        }

        /// <summary>
        /// Installs a CLR hook.
        /// </summary>
        /// <param name="SourceFunction">The method to be hooked.</param>
        /// <param name="DestinationFunction">The hook method.</param>
        /// <param name="OriginalCode">The original code which will be written to if you wanna unhook the function later (6 bytes in length).</param>
        /// <param name="HookedCode">The hook code which can be used to hook the function after unhooking it (6 bytes in length).</param>
        /// <param name="pFunction">A pointer to the function in which you can install/uninstall hooks from using InstallOrUninstallHook function.</param>
        /// <returns>Returns true if successfully hooked, otherwise false.</returns>
        public static bool InstallHookCLR(MethodInfo SourceFunction, MethodInfo DestinationFunction, byte[] OriginalCode, out byte[] HookedCode, out IntPtr pFunction)
        {
            try
            {
                if (!IsReflectionEnabled(true, true))
                {
                    HookedCode = null;
                    pFunction = IntPtr.Zero;
                    return false;
                }
                RuntimeHelpers.PrepareMethod(SourceFunction.MethodHandle);
                RuntimeHelpers.PrepareMethod(DestinationFunction.MethodHandle);
                IntPtr pSource = GetPointer(SourceFunction);
                IntPtr pDestination = GetPointer(DestinationFunction);
                if (pSource != IntPtr.Zero && pDestination != IntPtr.Zero)
                {
                    if (OriginalCode != null)
                        CopyMem(OriginalCode, pSource, false);
                    if (HookFunction(pSource, pDestination, out HookedCode))
                    {
                        pFunction = pSource;
                        return true;
                    }
                }
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
            catch
            {
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
        }

        /// <summary>
        /// Installs a CLR hook using delegates, for some software that have AOT.
        /// </summary>
        /// <param name="SourceFunction">The method to be hooked.</param>
        /// <param name="DestinationFunction">The hook method.</param>
        /// <param name="OriginalCode">The original code which will be written to if you wanna unhook the function later (6 bytes in length).</param>
        /// <param name="HookedCode">The hook code which can be used to hook the function after unhooking it (6 bytes in length).</param>
        /// <param name="pFunction">A pointer to the function in which you can install/uninstall hooks from using InstallOrUninstallHook function.</param>
        /// <returns>Returns true if successfully hooked, otherwise false.</returns>
        public static bool InstallHookCLR(Delegate SourceFunction, Delegate DestinationFunction, byte[] OriginalCode, out byte[] HookedCode, out IntPtr pFunction)
        {
            try
            {
                IntPtr pSource = GetPointerDelegate(SourceFunction);
                IntPtr pDestination = GetPointerDelegate(DestinationFunction);
                if (pSource != IntPtr.Zero && pDestination != IntPtr.Zero)
                {
                    if (OriginalCode != null)
                        CopyMem(OriginalCode, pSource, false);
                    if (HookFunction(pSource, pDestination, out HookedCode))
                    {
                        pFunction = pSource;
                        return true;
                    }
                }
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
            catch
            {
                HookedCode = null;
                pFunction = IntPtr.Zero;
                return false;
            }
        }
    }
}


================================================
File: AntiCrack-DotNet/Properties/AssemblyInfo.cs
================================================
√Ø¬ª¬øusing System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AntiCrack-DotNet")]
[assembly: AssemblyDescription("Anti-Cracking Techniques made by AdvDebug on GitHub.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("AdvDebug")]
[assembly: AssemblyProduct("AntiCrack-DotNet")]
[assembly: AssemblyCopyright("Copyright √Ç¬©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9ce21c83-c4c3-426f-8580-03bbc0b9eb27")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.2.9.0")]
[assembly: AssemblyFileVersion("1.2.9.0")]



================================================
File: .github/workflows/codeql.yml
================================================
# For most projects, this workflow file will not need changing; you simply need
# to commit it to your repository.
#
# You may wish to alter this file to override the set of languages analyzed,
# or to provide custom queries or build logic.
#
# ******** NOTE ********
# We have attempted to detect the languages in your repository. Please check
# the `language` matrix defined below to confirm you have the correct set of
# supported CodeQL languages.
#
name: "CodeQL Advanced"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '22 19 * * 4'

jobs:
  analyze:
    name: Analyze (${{ matrix.language }})
    # Runner size impacts CodeQL analysis time. To learn more, please see:
    #   - https://gh.io/recommended-hardware-resources-for-running-codeql
    #   - https://gh.io/supported-runners-and-hardware-resources
    #   - https://gh.io/using-larger-runners (GitHub.com only)
    # Consider using larger runners or machines with greater resources for possible analysis time improvements.
    runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }}
    permissions:
      # required for all workflows
      security-events: write

      # required to fetch internal or private CodeQL packs
      packages: read

      # only required for workflows in private repositories
      actions: read
      contents: read

    strategy:
      fail-fast: false
      matrix:
        include:
        - language: csharp
          build-mode: none
        # CodeQL supports the following values keywords for 'language': 'c-cpp', 'csharp', 'go', 'java-kotlin', 'javascript-typescript', 'python', 'ruby', 'swift'
        # Use `c-cpp` to analyze code written in C, C++ or both
        # Use 'java-kotlin' to analyze code written in Java, Kotlin or both
        # Use 'javascript-typescript' to analyze code written in JavaScript, TypeScript or both
        # To learn more about changing the languages that are analyzed or customizing the build mode for your analysis,
        # see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning.
        # If you are analyzing a compiled language, you can modify the 'build-mode' for that language to customize how
        # your codebase is analyzed, see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: ${{ matrix.language }}
        build-mode: ${{ matrix.build-mode }}
        # If you wish to specify custom queries, you can do so here or in a config file.
        # By default, queries listed here will override any specified in a config file.
        # Prefix the list here with "+" to use these queries and those in the config file.

        # For more details on CodeQL's query packs, refer to: https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs
        # queries: security-extended,security-and-quality

    # If the analyze step fails for one of the languages you are analyzing with
    # "We were unable to automatically build your code", modify the matrix above
    # to set the build mode to "manual" for that language. Then modify this step
    # to build your code.
    # ‚ÑπÔ∏è Command-line programs to run using the OS shell.
    # üìö See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun
    - if: matrix.build-mode == 'manual'
      shell: bash
      run: |
        echo 'If you are using a "manual" build mode for one or more of the' \
          'languages you are analyzing, replace this with the commands to build' \
          'your code, for example:'
        echo '  make bootstrap'
        echo '  make release'
        exit 1

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:${{matrix.language}}"



Directory structure:
└── codecracker-tools-megadumper/
    ├── README.md
    ├── MegaDumper.sln
    └── MegaDumper/
        ├── AboutForm.Designer.cs
        ├── AboutForm.cs
        ├── AboutForm.resx
        ├── DetectAntidumps.Designer.cs
        ├── DetectAntidumps.cs
        ├── DetectAntidumps.resx
        ├── EmptyForm.Designer.cs
        ├── EmptyForm.cs
        ├── EmptyForm.resx
        ├── EnumAppDomains.Designer.cs
        ├── EnumAppDomains.cs
        ├── EnumAppDomains.resx
        ├── FrmModules.Designer.cs
        ├── FrmModules.cs
        ├── FrmModules.resx
        ├── GenerateDmp.Designer.cs
        ├── GenerateDmp.cs
        ├── GenerateDmp.resx
        ├── HeapHealper.cs
        ├── HeapView.Designer.cs
        ├── HeapView.cs
        ├── HeapView.resx
        ├── InstalledFramework.Designer.cs
        ├── InstalledFramework.cs
        ├── InstalledFramework.resx
        ├── MainForm.Designer.cs
        ├── MainForm.cs
        ├── MainForm.resx
        ├── ManagedInjector.Designer.cs
        ├── ManagedInjector.cs
        ├── ManagedInjector.resx
        ├── MegaDumper.csproj
        ├── MiniDmp.cs
        ├── NetPerformance.Designer.cs
        ├── NetPerformance.cs
        ├── NetPerformance.resx
        ├── ProcessManager.Designer.cs
        ├── ProcessManager.cs
        ├── ProcessManager.resx
        ├── Program.cs
        ├── ViewWindowsHoocks.Designer.cs
        ├── ViewWindowsHoocks.cs
        ├── ViewWindowsHoocks.resx
        ├── VirtualMemoryView.Designer.cs
        ├── VirtualMemoryView.cs
        ├── VirtualMemoryView.resx
        ├── Properties/
        │   └── AssemblyInfo.cs
        └── Utils/
            ├── EnumWindows.cs
            ├── HandleEnumeration.cs
            ├── MemoryAlloc.cs
            ├── ProcessStatistics.cs
            └── ProcessUtil.cs

================================================
File: README.md
================================================
# MegaDumper
Dump native and .NET assemblies
# How to clone
## Regular branch:
git clone https://github.com/CodeCracker-Tools/MegaDumper MegaDumper
## Filter mod by sleeyax
git clone https://github.com/CodeCracker-Tools/MegaDumper MegaDumper -b filter-mod



================================================
File: MegaDumper.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 10.00
# Visual Studio 2008
# SharpDevelop 3.2.1.6466
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MegaDumper", "MegaDumper\MegaDumper.csproj", "{5FF5C138-ED9E-4120-B787-B8300AEE2EB0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5FF5C138-ED9E-4120-B787-B8300AEE2EB0}.Debug|x86.Build.0 = Debug|x86
		{5FF5C138-ED9E-4120-B787-B8300AEE2EB0}.Debug|x86.ActiveCfg = Debug|x86
		{5FF5C138-ED9E-4120-B787-B8300AEE2EB0}.Release|x86.Build.0 = Release|x86
		{5FF5C138-ED9E-4120-B787-B8300AEE2EB0}.Release|x86.ActiveCfg = Release|x86
	EndGlobalSection
EndGlobal



================================================
File: MegaDumper/AboutForm.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 04.03.2011
 * Time: 16:14
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class AboutForm
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.buttonClose = new System.Windows.Forms.Button();
			this.linkSourceforge = new System.Windows.Forms.LinkLabel();
			this.labelAppName = new System.Windows.Forms.Label();
			this.labelVersion = new System.Windows.Forms.Label();
			this.label14 = new System.Windows.Forms.Label();
			this.flowCredits = new System.Windows.Forms.FlowLayoutPanel();
			this.label8 = new System.Windows.Forms.Label();
			this.label5 = new System.Windows.Forms.Label();
			this.label11 = new System.Windows.Forms.Label();
			this.label13 = new System.Windows.Forms.Label();
			this.label1 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.flowCredits.SuspendLayout();
			this.SuspendLayout();
			// 
			// buttonClose
			// 
			this.buttonClose.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.buttonClose.FlatStyle = System.Windows.Forms.FlatStyle.System;
			this.buttonClose.Location = new System.Drawing.Point(418, 215);
			this.buttonClose.Name = "buttonClose";
			this.buttonClose.Size = new System.Drawing.Size(62, 23);
			this.buttonClose.TabIndex = 23;
			this.buttonClose.Text = "Cool";
			this.buttonClose.UseVisualStyleBackColor = true;
			this.buttonClose.Click += new System.EventHandler(this.ButtonCloseClick);
			// 
			// linkSourceforge
			// 
			this.linkSourceforge.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.linkSourceforge.AutoSize = true;
			this.linkSourceforge.Location = new System.Drawing.Point(36, 215);
			this.linkSourceforge.Name = "linkSourceforge";
			this.linkSourceforge.Size = new System.Drawing.Size(135, 13);
			this.linkSourceforge.TabIndex = 20;
			this.linkSourceforge.TabStop = true;
			this.linkSourceforge.Text = "http://forum.tuts4you.com/";
			this.linkSourceforge.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.LinkSourceforgeLinkClicked);
			// 
			// labelAppName
			// 
			this.labelAppName.AutoSize = true;
			this.labelAppName.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.labelAppName.Location = new System.Drawing.Point(220, 19);
			this.labelAppName.Name = "labelAppName";
			this.labelAppName.Size = new System.Drawing.Size(101, 16);
			this.labelAppName.TabIndex = 16;
			this.labelAppName.Text = "MegaDumper";
			// 
			// labelVersion
			// 
			this.labelVersion.AutoSize = true;
			this.labelVersion.Location = new System.Drawing.Point(220, 40);
			this.labelVersion.Name = "labelVersion";
			this.labelVersion.Size = new System.Drawing.Size(60, 13);
			this.labelVersion.TabIndex = 17;
			this.labelVersion.Text = "Version 1.0";
			// 
			// label14
			// 
			this.label14.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.label14.AutoSize = true;
			this.label14.Location = new System.Drawing.Point(36, 202);
			this.label14.Name = "label14";
			this.label14.Size = new System.Drawing.Size(82, 13);
			this.label14.TabIndex = 26;
			this.label14.Text = "Visit homepage:";
			// 
			// flowCredits
			// 
			this.flowCredits.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
									| System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.flowCredits.AutoScroll = true;
			this.flowCredits.Controls.Add(this.label8);
			this.flowCredits.Controls.Add(this.label5);
			this.flowCredits.Controls.Add(this.label11);
			this.flowCredits.Controls.Add(this.label13);
			this.flowCredits.Controls.Add(this.label1);
			this.flowCredits.Controls.Add(this.label3);
			this.flowCredits.FlowDirection = System.Windows.Forms.FlowDirection.TopDown;
			this.flowCredits.Location = new System.Drawing.Point(220, 76);
			this.flowCredits.Name = "flowCredits";
			this.flowCredits.Padding = new System.Windows.Forms.Padding(3);
			this.flowCredits.Size = new System.Drawing.Size(291, 99);
			this.flowCredits.TabIndex = 29;
			this.flowCredits.WrapContents = false;
			// 
			// label8
			// 
			this.label8.AutoSize = true;
			this.label8.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.label8.Location = new System.Drawing.Point(6, 3);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(44, 13);
			this.label8.TabIndex = 17;
			this.label8.Text = "Author";
			// 
			// label5
			// 
			this.label5.AutoSize = true;
			this.label5.Location = new System.Drawing.Point(6, 16);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(103, 13);
			this.label5.TabIndex = 18;
			this.label5.Text = "CodeCracker / SND";
			// 
			// label11
			// 
			this.label11.AutoSize = true;
			this.label11.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.label11.Location = new System.Drawing.Point(6, 29);
			this.label11.Name = "label11";
			this.label11.Size = new System.Drawing.Size(68, 13);
			this.label11.TabIndex = 17;
			this.label11.Text = "Thanks to:";
			// 
			// label13
			// 
			this.label13.AutoSize = true;
			this.label13.Location = new System.Drawing.Point(6, 42);
			this.label13.Name = "label13";
			this.label13.Size = new System.Drawing.Size(138, 13);
			this.label13.TabIndex = 30;
			this.label13.Text = "Kurapica - BlackStorm team";
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(6, 55);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(169, 13);
			this.label1.TabIndex = 31;
			this.label1.Text = "Whoknows - BlackStorm team";
			// 
			// label3
			// 
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(6, 68);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(0, 13);
			this.label3.TabIndex = 15;
			// 
			// AboutForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(521, 244);
			this.Controls.Add(this.flowCredits);
			this.Controls.Add(this.label14);
			this.Controls.Add(this.buttonClose);
			this.Controls.Add(this.linkSourceforge);
			this.Controls.Add(this.labelAppName);
			this.Controls.Add(this.labelVersion);
			this.Name = "AboutForm";
			this.Text = "AboutForm";
			this.flowCredits.ResumeLayout(false);
			this.flowCredits.PerformLayout();
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label14;
		private System.Windows.Forms.Label labelVersion;
		private System.Windows.Forms.Label labelAppName;
		private System.Windows.Forms.LinkLabel linkSourceforge;
		private System.Windows.Forms.Button buttonClose;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label13;
		private System.Windows.Forms.Label label11;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.FlowLayoutPanel flowCredits;
		private System.Windows.Forms.Label label8;
	}
}



================================================
File: MegaDumper/AboutForm.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 04.03.2011
 * Time: 16:14
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;

namespace Mega_Dumper
{
	/// <summary>
	/// Description of AboutForm.
	/// </summary>
	public partial class AboutForm : Form
	{
		public AboutForm()
		{
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
		void ButtonCloseClick(object sender, EventArgs e)
		{
		this.Close();
		}
		
	    public static void TryStart(string command)
        {
            try
            {
                System.Diagnostics.Process.Start(command);
            }
            catch (Exception ex)
            {
                if (command.StartsWith("http://"))
                {
                    if (ex is System.ComponentModel.Win32Exception)
                    {
                        // Ignore file not found errors when opening web pages.
                        if ((ex as System.ComponentModel.Win32Exception).NativeErrorCode == 2)
                            return;
                    }
                }

                MessageBox.Show(ex.Message,ex.Source);
            }
        }
		void LinkSourceforgeLinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
TryStart("http://forum.tuts4you.com/");

		}

	}
}



================================================
File: MegaDumper/AboutForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/DetectAntidumps.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 01.05.2011
 * Time: 14:52
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace MegaDumper
{
	partial class DetectAntidumps
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(-1, -1);
			this.textBox1.Multiline = true;
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(465, 339);
			this.textBox1.TabIndex = 1;
			// 
			// DetectAntidumps
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(463, 338);
			this.Controls.Add(this.textBox1);
			this.Name = "DetectAntidumps";
			this.Text = "Detect Anti-dumps";
			this.Shown += new System.EventHandler(this.DetectAntidumpsShown);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.TextBox textBox1;
	}
}



================================================
File: MegaDumper/DetectAntidumps.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 01.05.2011
 * Time: 14:52
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Collections.Generic;

namespace MegaDumper
{
	/// <summary>
	/// Description of DetectAntidumps.
	/// </summary>
	public partial class DetectAntidumps : Form
	{
		string strmodulename;
		int baseaddress;
		int modulesize;
		public int procid;
	
		public DetectAntidumps(int prid,string strmn,int ba,int ms)
		{
		strmodulename = strmn;
		baseaddress = ba;
		modulesize = ms;
		procid = prid;
		
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
     [DllImport("kernel32.dll")]
     static extern IntPtr OpenProcess(UInt32 dwDesiredAccess,  Int32 bInheritHandle, UInt32 dwProcessId);
     
     [DllImport("kernel32.dll", SetLastError=true)]
     [return: MarshalAs(UnmanagedType.Bool)]
     static extern bool CloseHandle(IntPtr hObject);
     
     	private const uint PROCESS_TERMINATE = 0x0001;
		private const uint PROCESS_CREATE_THREAD = 0x0002;
		private const uint PROCESS_SET_SESSIONID = 0x0004;
		private const uint PROCESS_VM_OPERATION = 0x0008;
		private const uint PROCESS_VM_READ = 0x0010;
		private const uint PROCESS_VM_WRITE = 0x0020;
		private const uint PROCESS_DUP_HANDLE = 0x0040;
		private const uint PROCESS_CREATE_PROCESS = 0x0080;
		private const uint PROCESS_SET_QUOTA = 0x0100;
		private const uint PROCESS_SET_INFORMATION = 0x0200;
		private const uint PROCESS_QUERY_INFORMATION = 0x0400;
		
[StructLayout(LayoutKind.Sequential)]
public struct SYSTEM_INFO
{
	public uint dwOemId;
	public uint dwPageSize;
	public uint lpMinimumApplicationAddress;
	public uint lpMaximumApplicationAddress;
	public uint dwActiveProcessorMask;
	public uint dwNumberOfProcessors;
	public uint dwProcessorType;
	public uint dwAllocationGranularity;
	public uint dwProcessorLevel;
	public uint dwProcessorRevision;
}

[DllImport("kernel32")]
public static extern void GetSystemInfo(ref SYSTEM_INFO pSI); 

public static MemoryBasicInformation mbi;

    [StructLayout(LayoutKind.Sequential)]
    public struct MemoryBasicInformation
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public MemoryProtection AllocationProtect;
        public IntPtr RegionSize;
        public MemoryState State;
        public MemoryProtection Protect;
        public MemoryType Type;
    }
    
    [Flags]
public enum MemoryState : uint
{
    Commit = 0x1000,
    Decommit = 0x4000,
    Free = 0x10000,
    LargePages = 0x20000000,
    Physical = 0x400000,
    Release = 0x8000,
    Reserve = 0x2000,
    Reset = 0x80000
}

    [Flags]
    public enum MemoryProtection : uint
    {
        AccessDenied = 0x0,
        Execute = 0x10,
        ExecuteRead = 0x20,
        ExecuteReadWrite = 0x40,
        ExecuteWriteCopy = 0x80,
        Guard = 0x100,
        NoCache = 0x200,
        WriteCombine = 0x400,
        NoAccess = 0x01,
        ReadOnly = 0x02,
        ReadWrite = 0x04,
        WriteCopy = 0x08
    }
    
    
    public enum MemoryType
{
    Image = 0x1000000,
    Mapped = 0x40000,
    Private = 0x20000
}
    
    
    [DllImport("kernel32.dll")]
public static extern bool VirtualQueryEx(IntPtr hProcess,
uint lpAddress, out MemoryBasicInformation lpBuffer,
uint dwLength);

    	[DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
        
		void DetectAntidumpsShown(object sender, EventArgs e)
		{

string buildedstring = "Finding anti-dumps on module: "+strmodulename+" address: "+baseaddress.ToString("X8")+
" size: "+modulesize.ToString("X8")+"\r\n";
	
SYSTEM_INFO pSI = new SYSTEM_INFO();
pSI.dwPageSize = 0x1000;
pSI.lpMaximumApplicationAddress = 0xF0000000;
pSI.lpMinimumApplicationAddress = 0;

try
{
GetSystemInfo(ref pSI);
}
catch
{
}

uint i = 0;
Dictionary<uint, uint> allmemory = new Dictionary<uint, uint>();
Dictionary<uint, uint> neededmemory = new Dictionary<uint, uint>();

uint firstaddress = 0;

IntPtr hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_TERMINATE, 0, (uint)procid);

if (hProcess!=IntPtr.Zero)
{

while (i < pSI.lpMaximumApplicationAddress)
{
if (VirtualQueryEx(hProcess,i,
out mbi,(uint)System.Runtime.InteropServices.Marshal.SizeOf(mbi))
)
{
if (firstaddress==0) firstaddress=(uint)mbi.BaseAddress;

i = (uint)mbi.BaseAddress + (uint)mbi.RegionSize;
if (mbi.State == MemoryState.Commit)
{
if ((uint)mbi.BaseAddress<(uint)baseaddress||i>(uint)(baseaddress+modulesize))
{

if (allmemory.ContainsKey((uint)mbi.AllocationBase))
{
uint oldmaxim=0;
allmemory.TryGetValue((uint)mbi.AllocationBase,out oldmaxim);
uint newmaxim = 0;
if (oldmaxim>i) newmaxim=oldmaxim;
else newmaxim=i;

allmemory.Remove((uint)mbi.AllocationBase);
allmemory.Add((uint)mbi.AllocationBase,newmaxim);

}
else
{
allmemory.Add((uint)mbi.AllocationBase,i);
}
}
}
}
}
// end of loop
/*
Stack antidumps:
"MOV DWORD PTR SS:[EBP+xxx],value"
opcode C785 folowed by address

"MOV register,DWORD PTR SS:[EBP+xxx]"
opcode 8B85/8B8D/8B95 folowed by address

"CMP DWORD PTR SS:[EBP+xxx],value"
opcode 83BD/81BD folowed by address
 
 */

bool isok;
byte[] onepage = new byte[pSI.dwPageSize];
uint BytesRead=0;
byte[] infokeep = new byte[8];

isok = ReadProcessMemory(hProcess,(IntPtr)baseaddress,onepage,(uint)onepage.Length, ref BytesRead);
if (isok)
{
if (ReadProcessMemory(hProcess,(IntPtr)(baseaddress+0x03C),infokeep,4, ref BytesRead))
{
int PEOffset=BitConverter.ToInt32(infokeep, 0);
if (PEOffset>0&&(PEOffset+0x0120)<onepage.Length)
{
if (ReadProcessMemory(hProcess,(IntPtr)(baseaddress+PEOffset),infokeep,2, ref BytesRead))
{
int nrofsection = (int)BitConverter.ToInt16(onepage, PEOffset+0x06);
if (nrofsection>0)
{

int virtualsize = BitConverter.ToInt32(onepage, PEOffset+0x0F8+0x28*0+08);
int virtualAddress = BitConverter.ToInt32(onepage, PEOffset+0x0F8+0x28*0+012);
byte[] firstsection = new byte[virtualsize];

if (ReadProcessMemory(hProcess,(IntPtr)(baseaddress+virtualAddress),
  firstsection,(uint)firstsection.Length, ref BytesRead))
{
for (int j=0;j<firstsection.Length-6;j++)
{
// Find ouside address:



}

textBox1.Text = buildedstring;
}


}
}
}
}
}

}

		}
	}
}



================================================
File: MegaDumper/DetectAntidumps.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/EmptyForm.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 27.10.2010
 * Time: 18:14
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{

	partial class EmptyForm
	{
		
		
	
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(0, 0);
			this.textBox1.Multiline = true;
			this.textBox1.Name = "textBox1";
			this.textBox1.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.textBox1.Size = new System.Drawing.Size(413, 317);
			this.textBox1.TabIndex = 0;
			// 
			// EmptyForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(411, 316);
			this.Controls.Add(this.textBox1);
			this.Name = "EmptyForm";
			this.Text = "Empty Form";
			this.Load += new System.EventHandler(this.Form3Load);
			this.Shown += new System.EventHandler(this.EmptyFormShown);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.TextBox textBox1;
		

	}
}



================================================
File: MegaDumper/EmptyForm.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 27.10.2010
 * Time: 18:14
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
using System.IO;
using System.Threading;
using System.Text;

using ProcessUtils;

namespace Mega_Dumper
{
	/// <summary>
	/// Description of Form3.
	/// </summary>
	/// 
	 

	public partial class EmptyForm : Form
	{
	public string ProcessName;
	public int procid;
	public int whattodo;

		public EmptyForm(string procname,int prid,int todo)
		{
		ProcessName=procname;
		procid=prid;
		whattodo=todo;
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
	
		
		void Form3Load(object sender, System.EventArgs e)
		{
		textBox1.Text="";
		if (whattodo==1)
		this.Text="Hook detection for "+ProcessName+" whit PID="+procid.ToString();
		else if (whattodo==2)
		this.Text="Environment Variables for "+ProcessName+" whit PID="+procid.ToString();
		else if (whattodo==3)
		this.Text="Files/directories from "+ProcessName+" whit PID="+procid.ToString();
		else if (whattodo==4)
		this.Text="Code section differences: process name "+ProcessName+"; PID="+procid.ToString();
		}

		[DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
        
public enum ProcessAccess : int
{
    /// <summary>Specifies all possible access flags for the process object.</summary>
    AllAccess = CreateThread | DuplicateHandle | QueryInformation | SetInformation | Terminate | VMOperation | VMRead | VMWrite | Synchronize,
    /// <summary>Enables usage of the process handle in the CreateRemoteThread function to create a thread in the process.</summary>
    CreateThread = 0x2,
    /// <summary>Enables usage of the process handle as either the source or target process in the DuplicateHandle function to duplicate a handle.</summary>
    DuplicateHandle = 0x40,
    /// <summary>Enables usage of the process handle in the GetExitCodeProcess and GetPriorityClass functions to read information from the process object.</summary>
    QueryInformation = 0x400,
    /// <summary>Enables usage of the process handle in the SetPriorityClass function to set the priority class of the process.</summary>
    SetInformation = 0x200,
    /// <summary>Enables usage of the process handle in the TerminateProcess function to terminate the process.</summary>
    Terminate = 0x1,
    /// <summary>Enables usage of the process handle in the VirtualProtectEx and WriteProcessMemory functions to modify the virtual memory of the process.</summary>
    VMOperation = 0x8,
    /// <summary>Enables usage of the process handle in the ReadProcessMemory function to' read from the virtual memory of the process.</summary>
    VMRead = 0x10,
    /// <summary>Enables usage of the process handle in the WriteProcessMemory function to write to the virtual memory of the process.</summary>
    VMWrite = 0x20,
    /// <summary>Enables usage of the process handle in any of the wait functions to wait for the process to terminate.</summary>
    Synchronize = 0x100000
}

private const uint PROCESS_TERMINATE = 0x0001;
private const uint PROCESS_CREATE_THREAD = 0x0002;
private const uint PROCESS_SET_SESSIONID = 0x0004;
private const uint PROCESS_VM_OPERATION = 0x0008;
private const uint PROCESS_VM_READ = 0x0010;
private const uint PROCESS_VM_WRITE = 0x0020;
private const uint PROCESS_DUP_HANDLE = 0x0040;
private const uint PROCESS_CREATE_PROCESS = 0x0080;
private const uint PROCESS_SET_QUOTA = 0x0100;
private const uint PROCESS_SET_INFORMATION = 0x0200;
private const uint PROCESS_QUERY_INFORMATION = 0x0400;

		
[StructLayout(LayoutKind.Sequential, Pack = 1)]
private struct PROCESS_BASIC_INFORMATION
{
  public int ExitStatus;
  public int PebBaseAddress;
  public int AffinityMask;
  public int BasePriority;
  public int UniqueProcessId;
  public int InheritedFromUniqueProcessId;

  public int Size
  {
    get { return (6*4); }
  }
}

     [DllImport("kernel32.dll")]
     static extern IntPtr OpenProcess(UInt32 dwDesiredAccess,  Int32 bInheritHandle, UInt32 dwProcessId);
     
     [DllImport("kernel32.dll", SetLastError=true)]
     [return: MarshalAs(UnmanagedType.Bool)]
     static extern bool CloseHandle(IntPtr hObject);
     
[DllImport("ntdll.dll", SetLastError=true)]
static extern int NtQueryInformationProcess(IntPtr processHandle,
   int processInformationClass, ref PROCESS_BASIC_INFORMATION processInformation, uint processInformationLength,
   out int returnLength);
   
   /*
	[DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
   */     
        
[DllImport("kernel32.dll")]
static extern IntPtr OpenProcess(ProcessAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, UInt32 dwProcessId);
     
void HoockDetect()
{
textBox1.Text= "Detecting hooks for process whit the name "+ProcessName+" and PID="+procid.ToString()+"\r\n";

byte[] Forread = new byte[0x500];
uint BytesRead=0;
int CompileAddress = 0;
IntPtr processHandle = IntPtr.Zero;

try
{
processHandle = OpenProcess(ProcessAccess.QueryInformation|ProcessAccess.VMRead, false, (uint)procid);
}
catch
{
}
if (processHandle!=IntPtr.Zero)
{
ProcModule.ModuleInfo targetmscorjit = null;
ProcModule.ModuleInfo[] modules = ProcModule.GetModuleInfos(procid);

if (modules!=null&&modules.Length>0)
{
for (int i=0;i<modules.Length;i++)
{
if (modules[i].baseName.ToLower().Contains("mscorjit"))
{
targetmscorjit = modules[i];
break;
}
}
}

if (targetmscorjit==null)
{
textBox1.Text= textBox1.Text + "Seems that the target process is not a .NET process!"+"\r\n";
}
else
{

int getJitrva = ExportTable.ProcGetExpAddress(processHandle,targetmscorjit.baseOfDll,"getJit");
bool isok=false;
isok = ReadProcessMemory(processHandle,
(IntPtr)((long)targetmscorjit.baseOfDll+(long)getJitrva),Forread,(uint)Forread.Length, ref BytesRead);
if (isok)
{
int count = 0;
while (Forread[count]!=0x0C3)
{
count++;
}

long cmpointer = (long)targetmscorjit.baseOfDll+getJitrva+count+1;
textBox1.Text= textBox1.Text + "Pointer of compile method : "+cmpointer.ToString("X8")+"\r\n";

CompileAddress =  BitConverter.ToInt32(Forread,count+1);
textBox1.Text= textBox1.Text + "Address of compile method is : "+CompileAddress.ToString("X8")+"\r\n";

if ((CompileAddress<(int)targetmscorjit.baseOfDll)||(CompileAddress>(int)targetmscorjit.baseOfDll+targetmscorjit.sizeOfImage))
{
textBox1.Text= textBox1.Text + "Address of compile method changed!!!"+"\r\n";
}
else
{
textBox1.Text= textBox1.Text +
"Address of compile method seems to be the original one!"+"\r\n";

}

}
else
{
textBox1.Text= textBox1.Text + "Failed to read from selected process!"+"\r\n";
}
ProcModule.CloseHandle(processHandle);
}  // end if is not .NET

}
else
{
textBox1.Text= textBox1.Text + "Failed to open selected process!"+"\r\n";
}


}

void EnumEnvironmentVars()
{
this.Text="Environment Variables for "+ProcessName+" whit PID="+procid.ToString();


 if (Environment.OSVersion.Platform == PlatformID.Win32NT)
        {

        try
        {
		IntPtr hProcess =
		OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, (uint)procid);
		if (hProcess!=IntPtr.Zero)
		{
      
        PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
         int bytesWritten;
         int result = NtQueryInformationProcess(hProcess,0, ref pbi, (uint)Marshal.SizeOf(pbi),out bytesWritten);
         if (result>=0)  // == 0 is OK
         {
         byte[] peb = new byte[472];
         uint BytesRead=0;
         bool isok = ReadProcessMemory(hProcess,(IntPtr)(pbi.PebBaseAddress),peb,(uint)(peb.Length), ref BytesRead);
         if (isok)
         {
         // this is on all Windows NT version - including Windows 7/Vista
       	 IntPtr AProcessParameters = (IntPtr)BitConverter.ToInt32(peb,016);
         // RTL_USER_PROCESS_PARAMETERS structure
         byte[] datas = new byte[0x64];
         isok = ReadProcessMemory(hProcess,AProcessParameters,datas,(uint)(datas.Length), ref BytesRead);  
         if (isok)
         {
         int EnvirAddress = BitConverter.ToInt32(datas,072);
         int blocksize = 0;
         IntPtr raddress = (IntPtr)(EnvirAddress+blocksize);
         int toskip = 0;

         while (ReadProcessMemory(hProcess,raddress,datas,4, ref BytesRead))
         {
         blocksize++;
         raddress = (IntPtr)(EnvirAddress+blocksize);
         if (toskip==0&&datas[0]==0&&datas[1]==0)
         {
         toskip = blocksize;
         }
         
         if (datas[0]==0&&datas[1]==0
         &&datas[2]==0&&datas[3]==0
         )
         {
         break;
         }
         }
// read datas:
toskip = toskip+2;
raddress = (IntPtr)(EnvirAddress+toskip);
datas = new byte[blocksize-toskip];
ReadProcessMemory(hProcess,raddress,datas,(uint)datas.Length, ref BytesRead);
System.Text.Encoding encoding = System.Text.Encoding.Unicode;
string envirstring = encoding.GetString(datas);
envirstring = envirstring.Replace("\x0000","\r\n");
envirstring = envirstring+"\r\n";
textBox1.Text = envirstring;
         }
         }
         }
         
         CloseHandle(hProcess);
		}
        }
        catch
        {
        
        }
 }
		
}

void DirectoriesFilesList()
{

this.Text="Directories/Files from "+ProcessName+" whit PID="+procid.ToString();

string filelist = "";
string directorylist = "";

        //try
        //{
		IntPtr hProcess =
		OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, (uint)procid);
		if (hProcess!=IntPtr.Zero)
		{
		uint minaddress = 0;
		uint maxaddress = 0xF0000000;
		uint pagesize = 0x1000;
		
		try
		{
		MainForm.SYSTEM_INFO pSI = new MainForm.SYSTEM_INFO();
		MainForm.GetSystemInfo(ref pSI);
		minaddress = pSI.lpMinimumApplicationAddress;
		maxaddress = pSI.lpMaximumApplicationAddress;
		pagesize = pSI.dwPageSize;
		}
		catch
		{
		}
		
		bool isok;
		byte[] onepage = new byte[pagesize];
		uint BytesRead=0;
		
		for (uint j = minaddress; j < maxaddress; j+= pagesize)
    	{
		isok = MainForm.ReadProcessMemory(hProcess,j,onepage,pagesize, ref BytesRead);

		if (isok)
		{
		
		for (int k = 0; k < onepage.Length; k++)
        {
		if (onepage[k]==0x3A)
		{
		byte[] testbyte = new byte[1];
		isok = MainForm.ReadProcessMemory(hProcess,(uint)(j+k+1),testbyte,1, ref BytesRead);
		bool IsFinded = false;
		bool unicode = false;
		
		if (isok)
		{
		if (testbyte[0]==0x5C)
		{
		IsFinded = true;
		unicode = false;
		}
		else if (testbyte[0]==0)
		{
		testbyte = new byte[2];
		isok = MainForm.ReadProcessMemory(hProcess,(uint)(j+k+2),testbyte,2, ref BytesRead);
		if (isok)
		{
		if (testbyte[0]==0x5C&&testbyte[1]==00)
		{
		IsFinded = true;
		unicode = true;
		}
		}
		}
		}
		
		if (IsFinded)
		{
		string thepath = "";
		testbyte = new byte[2];
		testbyte[0] = 11;
		uint l=0;
		int onecharbefore = 1;
		if (unicode)  // if is unicode
		onecharbefore++;
		
		if (unicode)
		{
		uint hoha = (uint)(j+k);
		}
		
		while (true)
		{
		isok = MainForm.ReadProcessMemory(hProcess,(uint)(j+k-onecharbefore+l),testbyte,1, ref BytesRead);
		if (isok&&testbyte[0]!=0)
		{
		thepath = thepath+(char)testbyte[0];
		}
		else
		{
		break;
		}
		l++;
		if (unicode)  // if is unicode
		l++;
		}
		
		if (File.Exists(thepath))
		if (!filelist.Contains(thepath))
		filelist=filelist+thepath+"\r\n";
		
		if (Directory.Exists(thepath))
		if (!directorylist.Contains(thepath))
		directorylist=directorylist+thepath+"\r\n";
		
		}  // end of IsFinded if
		
		}
		}
		}
		}
		
		textBox1.Text = "Directories:\r\n"+directorylist+"\r\n"+
			"Files:\r\n"+filelist+"\r\n";
		}  // end of if the process can be opened!
        //}
        //catch
        //{
        //}
}
public string modulename = "";
public IntPtr baseaddress = IntPtr.Zero;

		public int RVA2Section(MainForm.image_section_header[] sections,int rva)
		{
		
		for (int i = 0; i < sections.Length; i++)
        {
		if ((sections[i].virtual_address<=rva)&&(sections[i].virtual_address + sections[i].virtual_size >= rva))
        return i;
		}
		
		return -1;
		}
		
unsafe void CodeSectionDifferences()
{
this.Text="Process name: "+ProcessName+"; PID="+procid.ToString();
textBox1.Text="Code section diferences in module "+modulename+" base address:"+
	baseaddress.ToString("X4")+"\r\n";
	
if (!File.Exists(modulename))
{
textBox1.Text=textBox1.Text+"The file: "+modulename+"don't exist!" +
	"Finding diferences aborted!"+"\r\n";
}
else
{
byte[] filebytes = File.ReadAllBytes(modulename);
if (filebytes.Length<0x200||filebytes[0]!=0x4D||filebytes[1]!=0x5A)
{
textBox1.Text = textBox1.Text+"Invalid PE file: "+modulename+"\r\n";
}
else
{
int PEOffset=BitConverter.ToInt32(filebytes, 0x03C);
if (PEOffset<=0||PEOffset>=filebytes.Length||
    filebytes[PEOffset]!=0x50||filebytes[PEOffset+1]!=0x45)
{
textBox1.Text = textBox1.Text+"Invalid PE file: "+modulename+"\r\n";
}
else
{
short nrofsection=BitConverter.ToInt16(filebytes, PEOffset+0x6);
short sizeofoptionalheader=BitConverter.ToInt16(filebytes, PEOffset+0x14);
int BaseOfCode=BitConverter.ToInt32(filebytes, PEOffset+0x1C);

MainForm.image_section_header[] sections = new MainForm.image_section_header[nrofsection];

long ptr = (long)(PEOffset)+(long)sizeofoptionalheader+4+
	(long)Marshal.SizeOf(typeof(MainForm.IMAGE_FILE_HEADER));
byte[] datakeeper = new byte[Marshal.SizeOf(typeof(MainForm.image_section_header))];
IntPtr pointer = IntPtr.Zero;

for (int i = 0; i < nrofsection; i++)
{
Array.Copy(filebytes,ptr,datakeeper,0,Marshal.SizeOf(typeof(MainForm.image_section_header)));
fixed (byte* p = datakeeper)
{
pointer = (IntPtr)p;
}

sections[i] = (MainForm.image_section_header)Marshal.PtrToStructure(pointer, typeof(MainForm.image_section_header));
ptr = ptr+(long)Marshal.SizeOf(typeof(MainForm.image_section_header));
}

int codesectionindex = RVA2Section(sections,BaseOfCode);
if (codesectionindex==-1)
{
textBox1.Text = textBox1.Text+"Failed to get code section for the file: "+modulename+"\r\n";
}
else
{

}

}

}
}


}

void EmptyFormShown(object sender, EventArgs e)
{
if (whattodo==1)
HoockDetect();
else if (whattodo==2)
EnumEnvironmentVars();
else if (whattodo==3)
DirectoriesFilesList();
else if (whattodo==4)
CodeSectionDifferences();
}
}

}



================================================
File: MegaDumper/EmptyForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/EnumAppDomains.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 02.03.2011
 * Time: 19:07
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class EnumAppDomains
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.lvdomains = new System.Windows.Forms.ListView();
			this.id = new System.Windows.Forms.ColumnHeader();
			this.name = new System.Windows.Forms.ColumnHeader();
			this.SuspendLayout();
			// 
			// lvdomains
			// 
			this.lvdomains.Alignment = System.Windows.Forms.ListViewAlignment.Default;
			this.lvdomains.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
									| System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.lvdomains.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
									this.id,
									this.name});
			this.lvdomains.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(238)));
			this.lvdomains.FullRowSelect = true;
			this.lvdomains.Location = new System.Drawing.Point(-1, -1);
			this.lvdomains.MultiSelect = false;
			this.lvdomains.Name = "lvdomains";
			this.lvdomains.Size = new System.Drawing.Size(518, 199);
			this.lvdomains.TabIndex = 10;
			this.lvdomains.UseCompatibleStateImageBehavior = false;
			this.lvdomains.View = System.Windows.Forms.View.Details;
			// 
			// id
			// 
			this.id.Text = "Id";
			this.id.Width = 56;
			// 
			// name
			// 
			this.name.Text = "Appdomain name";
			this.name.Width = 373;
			// 
			// EnumAssemblies
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(516, 196);
			this.Controls.Add(this.lvdomains);
			this.Name = "Enum AppDomains";
			this.Text = "Enum AppDomains";
			this.Shown += new System.EventHandler(this.EnumAppDomainsShown);
			this.ResumeLayout(false);
		}
		private System.Windows.Forms.ListView lvdomains;
		private System.Windows.Forms.ColumnHeader id;
		private System.Windows.Forms.ColumnHeader name;
	}
}



================================================
File: MegaDumper/EnumAppDomains.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 02.03.2011
 * Time: 19:07
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;


namespace Mega_Dumper
{
	/// <summary>
	/// Description of EnumAssemblies.
	/// </summary>
	public partial class EnumAppDomains : Form
	{
	int procid = 0;
		public EnumAppDomains(int processid)
		{
		procid = processid;
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
	

		
		void EnumAppDomainsShown(object sender, EventArgs e)
		{
		ICorPublish publish = (ICorPublish) new CorpubPublish();

		if (publish != null)
		{
        ICorPublishProcess ppProcess = null;
        try
        {
        publish.GetProcess((uint)procid, out ppProcess);
        }
        catch
        {
        }
        
        if (ppProcess != null)
        {
        bool IsManaged = false;
        ppProcess.IsManaged(out IsManaged);
        if (IsManaged)
        {
// Enumerate the domains within the process.
        ICorPublishAppDomainEnum ppEnum = null;
        ppProcess.EnumAppDomains(out ppEnum);
        
        ICorPublishAppDomain pappDomain;  // ICorPublishAppDomain
        uint aFetched = 0;
        while (ppEnum.Next(1,out pappDomain,out aFetched)==0 && aFetched > 0)
        {
	
    StringBuilder szName= null;
    try
    {
    uint pcchName = 0;
    pappDomain.GetName(0, out pcchName, null);
    szName = new StringBuilder((int) pcchName);
    pappDomain.GetName((uint)szName.Capacity, out pcchName, szName);
    }
    catch
    {
    }
    
    string appdomainname = szName.ToString();
    uint appdomainid = 0;
    pappDomain.GetID(out appdomainid);
    
ListViewItem appdomaintoadd = new ListViewItem(new string[]{appdomainid.ToString(),appdomainname});
lvdomains.Items.Add(appdomaintoadd);

        }
        }
        else
        {
MessageBox.Show("Selected process is not a managed .NET process!","Warning",MessageBoxButtons.OK,MessageBoxIcon.Warning);

        }
        }
        else
        {
MessageBox.Show("Failed to open slected process \r\n" +
        	                "maybe is not a .NET process!","Warning",MessageBoxButtons.OK,MessageBoxIcon.Warning);

        }
		}
		}
	}
}



================================================
File: MegaDumper/EnumAppDomains.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/FrmModules.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 22.01.2011
 * Time: 14:37
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class FrmModules
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.lvmodules = new System.Windows.Forms.ListView();
			this.modulename = new System.Windows.Forms.ColumnHeader();
			this.ba = new System.Windows.Forms.ColumnHeader();
			this.ms = new System.Windows.Forms.ColumnHeader();
			this.ep = new System.Windows.Forms.ColumnHeader();
			this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.dumpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.copyToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.freeModuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.codeSectionChangesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.detectAntidumpsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.button1 = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.button2 = new System.Windows.Forms.Button();
			this.button3 = new System.Windows.Forms.Button();
			this.button4 = new System.Windows.Forms.Button();
			this.contextMenuStrip1.SuspendLayout();
			this.SuspendLayout();
			// 
			// lvmodules
			// 
			this.lvmodules.Alignment = System.Windows.Forms.ListViewAlignment.Default;
			this.lvmodules.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
									| System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.lvmodules.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
									this.modulename,
									this.ba,
									this.ms,
									this.ep});
			this.lvmodules.ContextMenuStrip = this.contextMenuStrip1;
			this.lvmodules.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(238)));
			this.lvmodules.FullRowSelect = true;
			this.lvmodules.Location = new System.Drawing.Point(0, 0);
			this.lvmodules.MultiSelect = false;
			this.lvmodules.Name = "lvmodules";
			this.lvmodules.Size = new System.Drawing.Size(583, 320);
			this.lvmodules.TabIndex = 9;
			this.lvmodules.UseCompatibleStateImageBehavior = false;
			this.lvmodules.View = System.Windows.Forms.View.Details;
			// 
			// modulename
			// 
			this.modulename.Text = "Module Name";
			this.modulename.Width = 137;
			// 
			// ba
			// 
			this.ba.Text = "Base Address";
			this.ba.Width = 88;
			// 
			// ms
			// 
			this.ms.Text = "Module size";
			this.ms.Width = 83;
			// 
			// ep
			// 
			this.ep.Text = "EntryPointAddress";
			this.ep.Width = 109;
			// 
			// contextMenuStrip1
			// 
			this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.dumpToolStripMenuItem,
									this.copyToolStripMenuItem,
									this.freeModuleToolStripMenuItem,
									this.codeSectionChangesToolStripMenuItem,
									this.detectAntidumpsToolStripMenuItem});
			this.contextMenuStrip1.Name = "contextMenuStrip1";
			this.contextMenuStrip1.Size = new System.Drawing.Size(191, 114);
			// 
			// dumpToolStripMenuItem
			// 
			this.dumpToolStripMenuItem.Name = "dumpToolStripMenuItem";
			this.dumpToolStripMenuItem.Size = new System.Drawing.Size(190, 22);
			this.dumpToolStripMenuItem.Text = "Dump";
			this.dumpToolStripMenuItem.Click += new System.EventHandler(this.DumpToolStripMenuItemClick);
			// 
			// copyToolStripMenuItem
			// 
			this.copyToolStripMenuItem.Name = "copyToolStripMenuItem";
			this.copyToolStripMenuItem.Size = new System.Drawing.Size(190, 22);
			this.copyToolStripMenuItem.Text = "Copy info";
			this.copyToolStripMenuItem.Click += new System.EventHandler(this.CopyToolStripMenuItemClick);
			// 
			// freeModuleToolStripMenuItem
			// 
			this.freeModuleToolStripMenuItem.Name = "freeModuleToolStripMenuItem";
			this.freeModuleToolStripMenuItem.Size = new System.Drawing.Size(190, 22);
			this.freeModuleToolStripMenuItem.Text = "Free module";
			this.freeModuleToolStripMenuItem.Click += new System.EventHandler(this.FreeModuleToolStripMenuItemClick);
			// 
			// codeSectionChangesToolStripMenuItem
			// 
			this.codeSectionChangesToolStripMenuItem.Name = "codeSectionChangesToolStripMenuItem";
			this.codeSectionChangesToolStripMenuItem.Size = new System.Drawing.Size(190, 22);
			this.codeSectionChangesToolStripMenuItem.Text = "Code section changes";
			this.codeSectionChangesToolStripMenuItem.Click += new System.EventHandler(this.CodeSectionChangesToolStripMenuItemClick);
			// 
			// detectAntidumpsToolStripMenuItem
			// 
			this.detectAntidumpsToolStripMenuItem.Name = "detectAntidumpsToolStripMenuItem";
			this.detectAntidumpsToolStripMenuItem.Size = new System.Drawing.Size(190, 22);
			this.detectAntidumpsToolStripMenuItem.Text = "Detect anti-dumps";
			this.detectAntidumpsToolStripMenuItem.Click += new System.EventHandler(this.DetectAntidumpsToolStripMenuItemClick);
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.button1.Location = new System.Drawing.Point(12, 353);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(82, 22);
			this.button1.TabIndex = 10;
			this.button1.Text = "Refresh";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.Button1Click);
			// 
			// label2
			// 
			this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.label2.Location = new System.Drawing.Point(0, 323);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(583, 23);
			this.label2.TabIndex = 13;
			// 
			// button2
			// 
			this.button2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.button2.Location = new System.Drawing.Point(256, 352);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(73, 23);
			this.button2.TabIndex = 14;
			this.button2.Text = "Copy infos";
			this.button2.UseVisualStyleBackColor = true;
			this.button2.Click += new System.EventHandler(this.Button2Click);
			// 
			// button3
			// 
			this.button3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.button3.Location = new System.Drawing.Point(383, 353);
			this.button3.Name = "button3";
			this.button3.Size = new System.Drawing.Size(114, 23);
			this.button3.TabIndex = 15;
			this.button3.Text = "Copy module names";
			this.button3.UseVisualStyleBackColor = true;
			this.button3.Click += new System.EventHandler(this.Button3Click);
			// 
			// button4
			// 
			this.button4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.button4.Location = new System.Drawing.Point(125, 353);
			this.button4.Name = "button4";
			this.button4.Size = new System.Drawing.Size(75, 23);
			this.button4.TabIndex = 16;
			this.button4.Text = "Inject dll";
			this.button4.UseVisualStyleBackColor = true;
			this.button4.Click += new System.EventHandler(this.Button4Click);
			// 
			// FrmModules
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(583, 387);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.button4);
			this.Controls.Add(this.button3);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.button1);
			this.Controls.Add(this.lvmodules);
			this.Name = "FrmModules";
			this.Text = "Modules";
			this.Shown += new System.EventHandler(this.FrmModulesShown);
			this.contextMenuStrip1.ResumeLayout(false);
			this.ResumeLayout(false);
		}
		private System.Windows.Forms.ToolStripMenuItem codeSectionChangesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem detectAntidumpsToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem freeModuleToolStripMenuItem;
		private System.Windows.Forms.Button button4;
		private System.Windows.Forms.ToolStripMenuItem copyToolStripMenuItem;
		private System.Windows.Forms.Button button3;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.ToolStripMenuItem dumpToolStripMenuItem;
		private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;
		private System.Windows.Forms.ColumnHeader ep;
		private System.Windows.Forms.ColumnHeader ba;
		private System.Windows.Forms.ColumnHeader ms;
		private System.Windows.Forms.ColumnHeader modulename;
		private System.Windows.Forms.ListView lvmodules;
		

		

		

	}
}



================================================
File: MegaDumper/FrmModules.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 22.01.2011
 * Time: 14:37
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Threading;
using System.Collections;
using System.Globalization;

using ProcessUtils;

namespace Mega_Dumper
{
	/// <summary>
	/// Description of Form4.
	/// </summary>
	public partial class FrmModules : Form
	{
    public string ProcessName;
    public string DirName;
	public int procid;



		public FrmModules(string procname,int prid,string Dir)
		{
		ProcessName=procname;
		procid=prid;
		DirName=Dir;
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
		[StructLayout(LayoutKind.Sequential, Pack=1)]
		private struct TOKEN_PRIVILEGES
		{
			public int PrivilegeCount;
			public long Luid;
			public int Attributes;
		}
		
		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int OpenProcessToken(int ProcessHandle, int DesiredAccess, ref int tokenhandle);
		
		[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
		private static extern int GetCurrentProcess();

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int LookupPrivilegeValue(string lpsystemname, string lpname, ref long lpLuid);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int AdjustTokenPrivileges(int tokenhandle, int disableprivs, ref TOKEN_PRIVILEGES Newstate, int bufferlength, int PreivousState, int Returnlength);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int GetSecurityInfo( int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, out IntPtr pDACL, IntPtr pSACL, out IntPtr pSecurityDescriptor);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int SetSecurityInfo( int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, IntPtr pDACL, IntPtr pSACL);

		
		private const uint PROCESS_TERMINATE = 0x0001;
		private const uint PROCESS_CREATE_THREAD = 0x0002;
		private const uint PROCESS_SET_SESSIONID = 0x0004;
		private const uint PROCESS_VM_OPERATION = 0x0008;
		private const uint PROCESS_VM_READ = 0x0010;
		private const uint PROCESS_VM_WRITE = 0x0020;
		private const uint PROCESS_DUP_HANDLE = 0x0040;
		private const uint PROCESS_CREATE_PROCESS = 0x0080;
		private const uint PROCESS_SET_QUOTA = 0x0100;
		private const uint PROCESS_SET_INFORMATION = 0x0200;
		private const uint PROCESS_QUERY_INFORMATION = 0x0400;
		
     [DllImport("kernel32.dll")]
     static extern IntPtr OpenProcess(UInt32 dwDesiredAccess,  Int32 bInheritHandle, UInt32 dwProcessId);
     
     
     
		[DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
        
        
        [DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            uint lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
     

		private ProcModule.ModuleInfo[] modules = null;
		void EnumModules()
		{
		this.Text="Modules from "+ProcessName+" whit PID="+procid.ToString();
		modules = ProcModule.GetModuleInfos(procid);
		
		if (modules!=null&&modules.Length>0)
		{
		for (int i=0;i<modules.Length;i++)
		{
         Graphics g = lvmodules.CreateGraphics();
         Font objFont = new Font("Microsoft Sans Serif", 8);
         SizeF stringSize = new SizeF();
         stringSize = g.MeasureString(modules[i].baseName, objFont);
         int processlenght = (int)(stringSize.Width+lvmodules.Margin.Horizontal*2);

         if (processlenght>modulename.Width)
         {
         modulename.Width=processlenght;
         }

         string[] prcdetails = new string[]{modules[i].baseName,modules[i].baseOfDll.ToString("X8"),
         modules[i].sizeOfImage.ToString("X8"),modules[i].entryPoint.ToString("X8")	};
         ListViewItem proc = new ListViewItem(prcdetails);
         lvmodules.Items.Add(proc);

		}
		}
		
		
		}
		
		void Button1Click(object sender, EventArgs e)
		{
		lvmodules.Items.Clear();
		EnumModules();
		}
		
		public static bool BytesEqual(byte[] Array1,byte[] Array2)
		{
		if (Array1.Length!=Array2.Length) return false;
		for (int i = 0; i < Array1.Length; i++)
		{
		if (Array1[i]!=Array2[i]) return false;
		}
		return true;
		}
		
		void DumpToolStripMenuItemClick(object sender, EventArgs e)
		{
		DumpModule();
		}
		
[StructLayout(LayoutKind.Sequential)]
public struct SYSTEM_INFO
{
	public uint dwOemId;
	public uint dwPageSize;
	public uint lpMinimumApplicationAddress;
	public uint lpMaximumApplicationAddress;
	public uint dwActiveProcessorMask;
	public uint dwNumberOfProcessors;
	public uint dwProcessorType;
	public uint dwAllocationGranularity;
	public uint dwProcessorLevel;
	public uint dwProcessorRevision;
}

[DllImport("kernel32")]
public static extern void GetSystemInfo(ref SYSTEM_INFO pSI); 
     
     
		void Button2Click(object sender, EventArgs e)
		{
string strtoset = "";
int count = lvmodules.Items.Count;
for (int i=0;i<count;i++)
{
strtoset = strtoset+lvmodules.Items[i].SubItems[0].Text+"\t";
strtoset = strtoset+lvmodules.Items[i].SubItems[1].Text+"\t";
strtoset = strtoset+lvmodules.Items[i].SubItems[2].Text+"\t";
strtoset = strtoset+lvmodules.Items[i].SubItems[3].Text+"\t";
strtoset = strtoset+"\r\n";
}
if (strtoset!="") Clipboard.SetText(strtoset);


		}
		
		void DumpModule()
		{
		IntPtr hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_TERMINATE, 0, (uint)procid);
		
		if( hProcess == IntPtr.Zero)
		{
		IntPtr pDACL, pSecDesc;

		GetSecurityInfo( (int) Process.GetCurrentProcess().Handle, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
		hProcess = OpenProcess( 0x40000, 0, (uint)procid);
		SetSecurityInfo( (int) hProcess, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4 | /*UNPROTECTED_DACL_SECURITY_INFORMATION*/ 0x20000000, 0, 0, pDACL, IntPtr.Zero);
		ProcModule.CloseHandle( hProcess);
		hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_TERMINATE, 0, (uint)procid);
		}

		if( hProcess != IntPtr.Zero)
		{
		string newdirname = DirName;
		if (DirName.Length<2||!Directory.Exists(DirName))
		newdirname="C:\\";
		
		newdirname=Path.Combine(DirName,"Dumps");
		System.IO.Directory.CreateDirectory(newdirname);
		int ImageBase = System.Convert.ToInt32(lvmodules.Items[lvmodules.SelectedIndices[0]].SubItems[1].Text, 16);
		string moduleName = lvmodules.Items[lvmodules.SelectedIndices[0]].SubItems[0].Text;
		
		bool isok;
		uint speed = 0x1000;
		
		try
		{
		SYSTEM_INFO pSI = new SYSTEM_INFO();
		GetSystemInfo(ref pSI);
		speed = pSI.dwPageSize;
		}
		catch
		{
		}
		
		byte[] bigMem = new byte[speed];
		byte[] InfoKeep = new byte[8];
		uint BytesRead=0;
		
		    int nrofsection=0;
		    byte[] Dump=null;
		    byte[] Partkeep=null;
		    int filealignment=0;
		    int rawaddress;
		    int address=0;
		    int offset=0;
		    bool ShouldFixrawsize=false;

		    isok = ReadProcessMemory(hProcess,(uint)(ImageBase+0x03C),InfoKeep,4, ref BytesRead);
		    int PEOffset=BitConverter.ToInt32(InfoKeep, 0);
		    
		    try
		    {
		    isok = ReadProcessMemory(hProcess,(uint)(ImageBase+PEOffset+0x0F8+20),InfoKeep,4, ref BytesRead);
		    byte[] PeHeader = new byte[speed];

		    rawaddress = BitConverter.ToInt32(InfoKeep, 0);
		    int sizetocopy = rawaddress;
		    if (sizetocopy>speed) sizetocopy=(int)speed;
		    isok = ReadProcessMemory(hProcess,(uint)(ImageBase),PeHeader,(uint)sizetocopy, ref BytesRead);
			offset=offset+rawaddress;
			
			nrofsection = (int)BitConverter.ToInt16(PeHeader, PEOffset+0x06);
		    int sectionalignment = BitConverter.ToInt32(PeHeader, PEOffset+0x038);
		 	filealignment = BitConverter.ToInt32(PeHeader, PEOffset+0x03C);
		    
			int sizeofimage = BitConverter.ToInt32(PeHeader, PEOffset+0x050);

			int calculatedimagesize = BitConverter.ToInt32(PeHeader, PEOffset+0x0F8+012);
			
			for (int i = 0; i < nrofsection; i++)
            {
			int virtualsize = BitConverter.ToInt32(PeHeader, PEOffset+0x0F8+0x28*i+08);
            int toadd = (virtualsize%sectionalignment);
			if (toadd!=0) toadd = sectionalignment-toadd;
			calculatedimagesize = calculatedimagesize+virtualsize+toadd;
			}
			
			if (calculatedimagesize>sizeofimage) sizeofimage=calculatedimagesize;
		    Dump = new byte[sizeofimage];
		    Array.Copy(PeHeader,Dump,sizetocopy);
		    Partkeep = new byte[sizeofimage];

		    }
		    catch
		    {

		    }
		    
		
			int calcrawsize=0;
            for (int i = 0; i < nrofsection; i++)
            {
            
			int rawsize,virtualsize,virtualAddress;
            for (int l = 0; l < nrofsection; l++)
            {
            rawsize = BitConverter.ToInt32(Dump, PEOffset+0x0F8+0x28*l+16);
            virtualsize = BitConverter.ToInt32(Dump, PEOffset+0x0F8+0x28*l+08);
            virtualAddress = BitConverter.ToInt32(Dump, PEOffset+0x0F8+0x28*l+012);
            
            // RawSize = Virtual Size rounded on FileAlligment
            calcrawsize=0;
            calcrawsize = virtualsize%filealignment;
            if (calcrawsize!=0) calcrawsize = filealignment-calcrawsize;
            calcrawsize = virtualsize+calcrawsize;

            if (calcrawsize!=0&&rawsize!=calcrawsize&&rawsize!=virtualsize)
            {
            ShouldFixrawsize=true;
            break;
            }
            }
            
            rawsize = BitConverter.ToInt32(Dump, PEOffset+0x0F8+0x28*i+16);
            virtualsize = BitConverter.ToInt32(Dump, PEOffset+0x0F8+0x28*i+08);
            // RawSize = Virtual Size rounded on FileAlligment
            virtualAddress = BitConverter.ToInt32(Dump, PEOffset+0x0F8+0x28*i+012);
            
            
            if (ShouldFixrawsize)
            {
            rawsize = virtualsize;
            BinaryWriter writer = new BinaryWriter(new MemoryStream(Dump));
            writer.BaseStream.Position=PEOffset+0x0F8+0x28*i+16;
            writer.Write(virtualsize);
            writer.BaseStream.Position=PEOffset+0x0F8+0x28*i+20;
            writer.Write(virtualAddress);
            writer.Close();

            }
            
    
                        
            address = BitConverter.ToInt32(Dump, PEOffset+0x0F8+0x28*i+12);
            
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+address),Partkeep,(uint)rawsize, ref BytesRead);
            if (!isok)
            {
            byte[] onepage = new byte[512];
            for (int c = 0; c < virtualsize; c=c+512)
            {
isok = ReadProcessMemory(hProcess,(uint)(ImageBase+virtualAddress+c),onepage,(uint)512, ref BytesRead);
Array.Copy(onepage, 0, Partkeep, c, 512);
            }
            }
         
            
            if (ShouldFixrawsize)
            {
            Array.Copy(Partkeep, 0, Dump, virtualAddress, rawsize);
            offset = virtualAddress+rawsize;
            }
            else
            {
            Array.Copy(Partkeep, 0, Dump, offset, rawsize);
            offset = offset+rawsize;
            }
            }
		    
		    
         
           
           
            if (Dump!=null&&Dump.Length>0&&Dump.Length>=offset)
            {
            int ImportDirectoryRva = BitConverter.ToInt32(Dump, PEOffset+0x080);
            if (ImportDirectoryRva>0&&ImportDirectoryRva<offset)
            {
            int current=0;
            int ThunkToFix=0;
            int ThunkData=0;
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ImportDirectoryRva+current+12),Partkeep,4, ref BytesRead);
            int NameOffset = BitConverter.ToInt32(Partkeep, 0);
            while (isok&&NameOffset!=0)
            {
            byte[] mscoreeAscii = {0x6D, 0x73, 0x63, 0x6F, 0x72, 0x65, 0x65, 0x2E, 0x64, 0x6C, 0x6C, 0x00};
            byte[] NameKeeper = new byte[mscoreeAscii.Length];
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+NameOffset),NameKeeper,(uint)mscoreeAscii.Length, ref BytesRead);
            if (isok&&BytesEqual(NameKeeper,mscoreeAscii))
            {
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ImportDirectoryRva+current),Partkeep,4, ref BytesRead);
            int OriginalFirstThunk = BitConverter.ToInt32(Partkeep, 0);  // OriginalFirstThunk;
            if (OriginalFirstThunk>0&&OriginalFirstThunk<offset)
            {
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+OriginalFirstThunk),Partkeep,4, ref BytesRead);
            ThunkData = BitConverter.ToInt32(Partkeep, 0);
            if (ThunkData>0&&ThunkData<offset)
            {
            byte[] CorExeMain = {0x5F, 0x43, 0x6F, 0x72, 0x45, 0x78, 0x65, 0x4D, 0x61, 0x69, 0x6E, 0x00};
            byte[] CorDllMain = {0x5F, 0x43, 0x6F, 0x72, 0x44, 0x6C, 0x6C, 0x4D, 0x61, 0x69, 0x6E, 0x00};
            NameKeeper = new byte[CorExeMain.Length];
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ThunkData+2),NameKeeper,
            (uint)CorExeMain.Length, ref BytesRead);
            if (isok&&(BytesEqual(NameKeeper,CorExeMain)||BytesEqual(NameKeeper,CorDllMain)))
            {
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ImportDirectoryRva+current+16),Partkeep,4, ref BytesRead);
            ThunkToFix = BitConverter.ToInt32(Partkeep, 0);  // FirstThunk;
            break;
            }
            }
            }
            }
            
            current = current+20; // 20 size of IMAGE_IMPORT_DESCRIPTOR
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ImportDirectoryRva+current+12),Partkeep,4, ref BytesRead);
            NameOffset = BitConverter.ToInt32(Partkeep, 0);
            }
            
            if (ThunkToFix>0&&ThunkToFix<offset)
            {
            BinaryWriter writer = new BinaryWriter(new MemoryStream(Dump));
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ThunkToFix),Partkeep,4, ref BytesRead);
            int ThunkValue = BitConverter.ToInt32(Partkeep, 0);
            if (isok&&(ThunkValue<0||ThunkValue>offset))
            {
            int fvirtualsize = BitConverter.ToInt32(Dump, PEOffset+0x0F8+08);
            int fvirtualAddress = BitConverter.ToInt32(Dump, PEOffset+0x0F8+012);
            int frawAddress = BitConverter.ToInt32(Dump, PEOffset+0x0F8+20);
            writer.BaseStream.Position=ThunkToFix-fvirtualAddress+frawAddress;
            writer.Write(ThunkData);
            }
            
            int EntryPoint = BitConverter.ToInt32(Dump, PEOffset+0x028);
            if (EntryPoint<=0||EntryPoint>offset)
            {
            int ca=0;
            do
            {
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ThunkData+ca),Partkeep,1, ref BytesRead);
            if (isok&&Partkeep[0]==0x0FF)
            {
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ThunkData+ca+1),Partkeep,1, ref BytesRead);
            if (isok&&Partkeep[0]==0x025)
            {
            isok = ReadProcessMemory(hProcess,(uint)(ImageBase+ThunkData+ca+2),Partkeep,4, ref BytesRead);
            if (isok)
            {
            int RealEntryPoint=ThunkData+ca;
            writer.BaseStream.Position=PEOffset+0x028;
            writer.Write(RealEntryPoint);
            }

            }
            }
            ca++;
            }
            while (isok);
            }
            writer.Close();
            }
            
            }
            }
                        
            if (Dump!=null&&Dump.Length>0&&Dump.Length>=offset)
            {
            FileStream fout;
            string filename = newdirname+"\\"+moduleName;
            fout = new FileStream(filename, FileMode.Create);
            fout.Write(Dump,0,offset);
            fout.Close();

            label2.ForeColor=Color.Blue;
			label2.Text = "Module saved in "+filename;
            }
            else
            {
            label2.ForeColor=Color.Red;	
			label2.Text = "Failed to dump module!";
            }

		    
		
		}
		else
		{
		label2.ForeColor=Color.Red;	
		label2.Text = "Failed to open process!";
		}
		}
		
		
		void Button3Click(object sender, EventArgs e)
		{
string strtoset = "";
int count = lvmodules.Items.Count;
for (int i=0;i<count;i++)
{
strtoset = strtoset+lvmodules.Items[i].SubItems[0].Text;
strtoset = strtoset+"\r\n";
}
if (strtoset!="") Clipboard.SetText(strtoset);

		}
		
string DirectoryName="";
	
		void Button4Click(object sender, EventArgs e)
		{
		OpenFileDialog fdlg = new OpenFileDialog();
		fdlg.Title = "Browse for target dll:";
		fdlg.InitialDirectory = @"c:\";
		if (DirectoryName!="") fdlg.InitialDirectory = DirectoryName;
		fdlg.Filter = "All files (*.dll)|*.dll";
		fdlg.FilterIndex = 2;
		fdlg.RestoreDirectory = true;
		fdlg.Multiselect = false;
		if(fdlg.ShowDialog() == DialogResult.OK)
		{
string FileName = fdlg.FileName;
int lastslash = FileName.LastIndexOf("\\");
if (lastslash!=-1) DirectoryName = FileName.Remove(lastslash,FileName.Length-lastslash);
if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";

string error = "";
string libname = fdlg.FileName;
IntPtr retaddress = ProcModule.InjectLibraryInternal((uint)procid,libname,out error);
if (retaddress==IntPtr.Zero)
{
label2.ForeColor=Color.Red;
label2.Text = "Error: "+error;
}
else
{
label2.ForeColor=Color.Blue;
label2.Text = "Dll injected at address: "+retaddress.ToString("X8");
lvmodules.Items.Clear();
EnumModules();
}

}
		


		}
		
		void FreeModuleToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvmodules.SelectedIndices.Count>0)
{
string libaddress = lvmodules.Items[lvmodules.SelectedIndices[0]].SubItems[1].Text;
IntPtr libaddressptr = (IntPtr)System.Convert.ToInt32(libaddress, 16);
string error = "";
if (!ProcModule.FreeLibraryInternal((uint)procid,libaddressptr,out error))
{
label2.ForeColor=Color.Red;
label2.Text = "Error: "+error;
}
else
{
label2.ForeColor=Color.Blue;
label2.Text = "Dll free succesfully!";
lvmodules.Items.Clear();
EnumModules();
}

}
		}
		


		
		void FrmModulesShown(object sender, EventArgs e)
		{
		lvmodules.Items.Clear();
		EnumModules();
		}
		
		void DetectAntidumpsToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvmodules.SelectedIndices.Count>0)
		{
		string strmodulename = lvmodules.Items[lvmodules.SelectedIndices[0]].SubItems[0].Text;
		int baseaddress = int.Parse(lvmodules.Items[lvmodules.SelectedIndices[0]].SubItems[1].Text,NumberStyles.HexNumber);
		int modulesize = int.Parse(lvmodules.Items[lvmodules.SelectedIndices[0]].SubItems[2].Text,NumberStyles.HexNumber);
		MegaDumper.DetectAntidumps detectanti = new MegaDumper.DetectAntidumps(procid,strmodulename,baseaddress,modulesize);
		detectanti.Show();
		}
		}

		
		void CodeSectionChangesToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvmodules.SelectedIndices.Count>0)
		{
		EmptyForm detectchanges = new EmptyForm(ProcessName,procid,4);
		detectchanges.modulename = modules[lvmodules.SelectedIndices[0]].fileName;
		detectchanges.baseaddress = modules[lvmodules.SelectedIndices[0]].baseOfDll;
		detectchanges.Show();
		}
		}
		
		void CopyToolStripMenuItemClick(object sender, System.EventArgs e)
		{
if (lvmodules.SelectedIndices.Count>0)
{
string strtoset = "";
for (int i=0;i<4;i++)
strtoset = strtoset+lvmodules.Items[lvmodules.SelectedIndices[0]].SubItems[i].Text+"\t";

if (strtoset!="") Clipboard.SetText(strtoset);
}
		}
		
		void CopyNameToolStripMenuItemClick(object sender, EventArgs e)
		{
string strtoset = "";
int count = lvmodules.Items.Count;
for (int i=0;i<count;i++)
strtoset = strtoset+lvmodules.Items[i].SubItems[0].Text+"\r\n";

if (strtoset!="") Clipboard.SetText(strtoset);

		}
	}
}



================================================
File: MegaDumper/FrmModules.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="contextMenuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>


================================================
File: MegaDumper/GenerateDmp.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 19.04.2011
 * Time: 20:05
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class GenerateDmp
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.button1 = new System.Windows.Forms.Button();
			this.dmpoption = new System.Windows.Forms.ComboBox();
			this.button2 = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.BackColor = System.Drawing.Color.Transparent;
			this.label1.ForeColor = System.Drawing.Color.Black;
			this.label1.Location = new System.Drawing.Point(44, 20);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(100, 14);
			this.label1.TabIndex = 16;
			this.label1.Text = "Name of dmp file:";
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(44, 38);
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(544, 20);
			this.textBox1.TabIndex = 15;
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(10, 37);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(28, 20);
			this.button1.TabIndex = 14;
			this.button1.Text = "...";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.Button1Click);
			// 
			// dmpoption
			// 
			this.dmpoption.FormattingEnabled = true;
			this.dmpoption.Location = new System.Drawing.Point(44, 116);
			this.dmpoption.Name = "dmpoption";
			this.dmpoption.Size = new System.Drawing.Size(274, 21);
			this.dmpoption.TabIndex = 17;
			// 
			// button2
			// 
			this.button2.Location = new System.Drawing.Point(365, 114);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(97, 22);
			this.button2.TabIndex = 18;
			this.button2.Text = "Generate dmp";
			this.button2.UseVisualStyleBackColor = true;
			this.button2.Click += new System.EventHandler(this.Button2Click);
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(44, 101);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(100, 12);
			this.label2.TabIndex = 19;
			this.label2.Text = "DumpType:";
			// 
			// label3
			// 
			this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.label3.Location = new System.Drawing.Point(44, 78);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(544, 15);
			this.label3.TabIndex = 20;
			this.label3.Text = "Statut";
			// 
			// GenerateDmp
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(631, 149);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.dmpoption);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.textBox1);
			this.Controls.Add(this.button1);
			this.Name = "GenerateDmp";
			this.Text = "Generate dmp";
			this.Shown += new System.EventHandler(this.GenerateDmpShown);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.ComboBox dmpoption;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.Label label1;
	}
}



================================================
File: MegaDumper/GenerateDmp.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 19.04.2011
 * Time: 20:05
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.IO;
using System.Drawing;
using System.Windows.Forms;

namespace Mega_Dumper
{
	
	/// <summary>
	/// Description of GenerateDmp.
	/// </summary>
	public partial class GenerateDmp : Form
	{
	public string ProcessName;
    public string DirName;
	public int procid;
	
		public GenerateDmp(string procname,int prid,string Dir)
		{
		ProcessName=procname;
		procid=prid;
		DirName=Dir;
		
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
		string DirectoryName ="";
		void Button1Click(object sender, EventArgs e)
		{
		SaveFileDialog fdlg = new SaveFileDialog();
		fdlg.Title = "Browse for program:";
		fdlg.InitialDirectory = @"c:\";
		if (DirectoryName!="") fdlg.InitialDirectory = DirectoryName;
		fdlg.Filter = "dmp file (*.dmp)|*.dmp";
		fdlg.FilterIndex = 2;
		fdlg.RestoreDirectory = true;
		if(fdlg.ShowDialog() == DialogResult.OK)
		{
		string FileName = fdlg.FileName;
		textBox1.Text = FileName;
		int lastslash = FileName.LastIndexOf("\\");
		if (lastslash!=-1) DirectoryName = FileName.Remove(lastslash,FileName.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
		}
		}
		
		void GenerateDmpShown(object sender, EventArgs e)
		{
		if (DirName!=""&&Directory.Exists(DirName)&&ProcessName!="")
		textBox1.Text = Path.Combine(DirName,Path.GetFileNameWithoutExtension(ProcessName)+".dmp");
		
		if (DirName!=""&&Directory.Exists(DirName))
		DirectoryName = DirName;
					
		string[] dtypenames = MiniDmp.DType.GetNames(typeof(MiniDmp.DType));
		
		for (int i=0;i<dtypenames.Length;i++)
		{
		dmpoption.Items.Add(dtypenames[i]);
		}
		
		dmpoption.SelectedIndex = 0;
		
		}
		
		bool MsgOverwrite(string dumpfilename)
		{
		if (File.Exists(dumpfilename))
		{

DialogResult result = MessageBox.Show("A file whit same name already exist!\r\n" +
"Do you want to ovewrite the file ?","Warning",MessageBoxButtons.YesNo,MessageBoxIcon.Question);
if (result == DialogResult.Yes)
{
return true;
}
else if (result == DialogResult.No)
{
return false;
}

		}
		return true;
		
		}
		
		void Button2Click(object sender, EventArgs e)
		{
		string dumpfilename = textBox1.Text;
		
		if (dumpfilename=="")
		{
		label3.Text = "Please select a name for dump first!";
		}
		else
		{
		if (!MsgOverwrite(dumpfilename))
		{
		label3.Text = "Aborted by user!";
		}
		else
		{
		string selectedDType = dmpoption.SelectedItem.ToString();
		MiniDmp.DType selDType = (MiniDmp.DType)Enum.Parse(typeof(MiniDmp.DType), selectedDType);
		
		    try
            {
            string a = null;
            a.PadLeft(10);
            }
            catch
            {
            bool opok = MiniDmp.WriteDump((uint)procid,dumpfilename,selDType);
            if (opok)
			label3.Text = "Dump file saved on "+dumpfilename+"!";
            else
			label3.Text = "Error while generating the dump file!";
            
            }
            
		}
		}
			
		}
	}
}



================================================
File: MegaDumper/GenerateDmp.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/HeapHealper.cs
================================================
ï»¿using System;

using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace Mega_Dumper
{
	

	public static class HeapHealper
	{
		
        public const uint TH32CS_SNAPHEAPLIST = 0x00000001;
        public const uint TH32CS_SNAPPROCESS = 0x00000002;
        public const uint TH32CS_SNAPTHREAD = 0x00000004;
        public const uint TH32CS_SNAPMODULE = 0x00000008;
        public const uint TH32CS_SNAPMODULE32 = 0x00000010;
        public const uint TH32CS_SNAPALL = (TH32CS_SNAPHEAPLIST |
                                                 TH32CS_SNAPPROCESS |
                                                 TH32CS_SNAPTHREAD |
                                                 TH32CS_SNAPMODULE);
        public const uint TH32CS_INHERIT = 0x80000000;
        
		public const uint HF32_DEFAULT = 1;
        public const uint HF32_SHARED = 2; 

		public const uint LF32_FIXED = 0x00000001;
		public const uint LF32_FREE = 0x00000002;
		public const uint LF32_MOVEABLE = 0x00000004;

        public struct HEAPLIST32
        {
            public uint dwSize;
			public uint th32ProcessID;
			public uint th32HeapID;
			public uint dwFlags; 
        }

        public struct HEAPENTRY32
        {
			public uint dwSize;
			public IntPtr hHandle; 
			public uint dwAddress; 
			public uint dwBlockSize;
			public uint dwFlags;
			public uint dwLockCount;
			public uint dwResvd;
			public uint th32ProcessID;
			public uint th32HeapID; 
        }


        public struct PROCESSENTRY32W
        {
			public uint dwSize;
			public uint cntUsage;
			public uint th32ProcessID; 
			public UIntPtr th32DefaultHeapID;
			public uint th32ModuleID; 
			public uint cntThreads;
			public uint th32ParentProcessID; 
			public int pcPriClassBase; 
			public uint dwFlags;
			public string szExeFile; 
        }

        public struct PROCESSENTRY32
        {
			public uint dwSize;
			public uint cntUsage;
			public uint th32ProcessID;
			public uint th32DefaultHeapID;
			public uint th32ModuleID; 
			public uint cntThreads;
			public uint th32ParentProcessID; 
			public int pcPriClassBase; 
			public uint dwFlags;
			public string szExeFile; 
        }

        public struct THREADENTRY32
        {
			public uint dwSize;
			public uint cntUsage;
			public uint th32ThreadID;            
			public uint th32OwnerProcessID;      
			public int tpBasePri;
			public int tpDeltaPri;
			public uint dwFlags;
        }

        public struct MODULEENTRY32W
        {
			public uint dwSize;
			public uint th32ModuleID;  
			public uint th32ProcessID; 
			public uint GlblcntUsage;  
			public uint ProccntUsage;  
			public IntPtr modBaseAddr; 
			public uint modBaseSize;   
			public IntPtr hModule;     
			public string szModule;
			public string szExePath;
        }

        public struct MODULEENTRY32
        {
			public uint dwSize;
			public uint th32ModuleID; 
			public uint th32ProcessID;
			public uint GlblcntUsage; 
			public uint ProccntUsage; 
			public IntPtr modBaseAddr;
			public uint modBaseSize;  
			public IntPtr hModule;    
			public string szModule;
			public string szExePath;
        }

		[DllImport("kernel32.dll")]
		public static extern IntPtr CreateToolhelp32Snapshot(uint dwFlags, uint th32ProcessID);

		[DllImport("kernel32.dll")]
		public static extern bool CloseHandle(IntPtr hHeapSnapshot);

		[DllImport("kernel32.dll")]
		public static extern bool Heap32ListFirst(IntPtr hSnapshot, ref HEAPLIST32 lphl);

		[DllImport("kernel32.dll")]
		public static extern bool Heap32ListNext(IntPtr hSnapshot, ref HEAPLIST32 lphl);

		[DllImport("kernel32.dll")]
		public static extern bool Heap32First(ref HEAPENTRY32 lphe,
			uint th32ProcessID, uint th32HeapID);

		[DllImport("kernel32.dll")]
		public static extern bool Heap32Next(ref HEAPENTRY32 lphe);

		[DllImport("kernel32.dll")]
		public static extern bool Toolhelp32ReadProcessMemory(uint th32ProcessID,
			IntPtr lpBaseAddress, IntPtr lpBuffer, uint cbRead, IntPtr lpNumberOfBytesRead);

		[DllImport("kernel32.dll")]
		public static extern bool Process32FirstW(IntPtr hSnapshot, ref PROCESSENTRY32W lppe);

		[DllImport("kernel32.dll")]
		public static extern bool Process32NextW(IntPtr hSnapshot, ref PROCESSENTRY32W lppe);

		[DllImport("kernel32.dll")]
		public static extern bool Process32First(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

		[DllImport("kernel32.dll")]
		public static extern bool Process32Next(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

		[DllImport("kernel32.dll")]
		public static extern bool Thread32First(IntPtr hSnapshot, ref THREADENTRY32 lpte);

		[DllImport("kernel32.dll")]
		public static extern bool Thread32Next(IntPtr hSnapshot, ref THREADENTRY32 lpte);

		[DllImport("kernel32.dll")]
		public static extern bool Module32FirstW(IntPtr hSnapshot, ref MODULEENTRY32W lpme);

		[DllImport("kernel32.dll")]
		public static extern bool Module32NextW(IntPtr hSnapshot, ref MODULEENTRY32W lpme);

		[DllImport("kernel32.dll")]
		public static extern bool Module32First(IntPtr hSnapshot, ref MODULEENTRY32W lpme);

		[DllImport("kernel32.dll")]
		public static extern bool Module32Next(IntPtr hSnapshot, ref MODULEENTRY32W lpme);
		
		[DllImport("kernel32.dll")]
		public static extern uint GetCurrentProcessId();
		
[DllImport("kernel32.dll")]
public static extern uint GetProcessHeaps(uint NumberOfHeaps,
IntPtr[] ProcessHeaps);

[DllImport("kernel32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool HeapWalk(IntPtr hHeap,
ref PROCESS_HEAP_ENTRY lpEntry);

[DllImport("kernel32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool HeapLock(IntPtr heap);

[DllImport("kernel32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool HeapUnlock(IntPtr heap);

// structs
[Flags]
public enum PROCESS_HEAP_ENTRY_WFLAGS : ushort
{
PROCESS_HEAP_ENTRY_BUSY = 0x0004,
PROCESS_HEAP_ENTRY_DDESHARE = 0x0020,
PROCESS_HEAP_ENTRY_MOVEABLE = 0x0010,
PROCESS_HEAP_REGION = 0x0001,
PROCESS_HEAP_UNCOMMITTED_RANGE = 0x0002,
}

[StructLayoutAttribute(LayoutKind.Explicit)]
public struct UNION_BLOCK
{
[FieldOffset(0)]
public STRUCT_BLOCK Block;

[FieldOffset(0)]
public STRUCT_REGION Region;
}

[StructLayoutAttribute(LayoutKind.Sequential)]
public struct STRUCT_BLOCK
{
public IntPtr hMem;
public uint dwReserved1_1;
public uint dwReserved1_2;
public uint dwReserved1_3;
}

[StructLayoutAttribute(LayoutKind.Sequential)]
public struct STRUCT_REGION
{
public uint dwCommittedSize;
public uint dwUnCommittedSize;
public IntPtr lpFirstBlock;
public IntPtr lpLastBlock;
}

[StructLayoutAttribute(LayoutKind.Sequential)]
public struct PROCESS_HEAP_ENTRY
{
public IntPtr lpData;
public uint cbData;
public byte cbOverhead;
public byte iRegionIndex;
public PROCESS_HEAP_ENTRY_WFLAGS wFlags;
public UNION_BLOCK UnionBlock;
}

	}
}



================================================
File: MegaDumper/HeapView.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 03.03.2011
 * Time: 21:44
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class HeapView
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.lvheaps = new System.Windows.Forms.ListView();
			this.address = new System.Windows.Forms.ColumnHeader();
			this.blocksize = new System.Windows.Forms.ColumnHeader();
			this.flags = new System.Windows.Forms.ColumnHeader();
			this.SuspendLayout();
			// 
			// lvheaps
			// 
			this.lvheaps.Alignment = System.Windows.Forms.ListViewAlignment.Default;
			this.lvheaps.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
									| System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.lvheaps.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
									this.address,
									this.blocksize,
									this.flags});
			this.lvheaps.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(238)));
			this.lvheaps.FullRowSelect = true;
			this.lvheaps.Location = new System.Drawing.Point(-1, 0);
			this.lvheaps.MultiSelect = false;
			this.lvheaps.Name = "lvheaps";
			this.lvheaps.Size = new System.Drawing.Size(390, 373);
			this.lvheaps.TabIndex = 11;
			this.lvheaps.UseCompatibleStateImageBehavior = false;
			this.lvheaps.View = System.Windows.Forms.View.Details;
			// 
			// address
			// 
			this.address.Text = "Address";
			this.address.Width = 105;
			// 
			// blocksize
			// 
			this.blocksize.Text = "BlockSize";
			this.blocksize.Width = 124;
			// 
			// flags
			// 
			this.flags.Text = "Flags";
			this.flags.Width = 143;
			// 
			// HeapView
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(387, 373);
			this.Controls.Add(this.lvheaps);
			this.Name = "HeapView";
			this.Text = "HeapView";
			this.Shown += new System.EventHandler(this.HeapViewShown);
			this.ResumeLayout(false);
		}
		private System.Windows.Forms.ColumnHeader flags;
		private System.Windows.Forms.ColumnHeader address;
		private System.Windows.Forms.ColumnHeader blocksize;
		private System.Windows.Forms.ListView lvheaps;
	}
}



================================================
File: MegaDumper/HeapView.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 03.03.2011
 * Time: 21:44
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.IO;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Text;

namespace Mega_Dumper
{
	/// <summary>
	/// Description of HeapView.
	/// </summary>
	public partial class HeapView : Form
	{
		
		string processname;
		int processid;
			
		public HeapView(string pname,int prid)
		{
			processname = pname;
			processid = prid;
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
IntPtr INVALID_HANDLE_VALUE = (IntPtr)(-1);


		
		void HeapViewShown(object sender, EventArgs e)
		{

		IntPtr snapshot = HeapHealper.CreateToolhelp32Snapshot(HeapHealper.TH32CS_SNAPHEAPLIST, (uint)processid);
		if (snapshot != INVALID_HANDLE_VALUE)
		{

		HeapHealper.HEAPLIST32  hlist = new HeapHealper.HEAPLIST32();
		HeapHealper.HEAPENTRY32 heap  = new HeapHealper.HEAPENTRY32();
		
		hlist.dwSize = (uint)Marshal.SizeOf(hlist);
		heap.dwSize = (uint)Marshal.SizeOf(heap);
		
		
		    HeapHealper.Heap32ListFirst(snapshot, ref hlist);

			do
			{
			HeapHealper.Heap32First(ref heap, hlist.th32ProcessID, hlist.th32HeapID);
				do
				{
string flags = "";
if (heap.dwFlags==0x00000001)
flags = "LF32_FIXED";

if (heap.dwFlags==0x00000002)
flags = "LF32_FREE";

if (heap.dwFlags==0x00000004)
flags = "LF32_MOVEABLE";

ListViewItem heaptoadd = new ListViewItem(new string[]{heap.dwAddress.ToString("X8"),heap.dwBlockSize.ToString("X8"),flags});
lvheaps.Items.Add(heaptoadd);

				} while (HeapHealper.Heap32Next(ref heap));
                
            } while (HeapHealper.Heap32ListNext(snapshot, ref hlist));
			

		 	HeapHealper.CloseHandle(snapshot);
			}
			
		}
	}
}



================================================
File: MegaDumper/HeapView.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/InstalledFramework.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 14.04.2011
 * Time: 18:22
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class InstalledFramework
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.button3 = new System.Windows.Forms.Button();
			this.button2 = new System.Windows.Forms.Button();
			this.button1 = new System.Windows.Forms.Button();
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// button3
			// 
			this.button3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.button3.Location = new System.Drawing.Point(312, 252);
			this.button3.Name = "button3";
			this.button3.Size = new System.Drawing.Size(75, 23);
			this.button3.TabIndex = 8;
			this.button3.Text = "Exit";
			this.button3.UseVisualStyleBackColor = true;
			this.button3.Click += new System.EventHandler(this.Button3Click);
			// 
			// button2
			// 
			this.button2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.button2.Location = new System.Drawing.Point(187, 252);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(75, 23);
			this.button2.TabIndex = 7;
			this.button2.Text = "Copy";
			this.button2.UseVisualStyleBackColor = true;
			this.button2.Click += new System.EventHandler(this.Button2Click);
			// 
			// button1
			// 
			this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.button1.Location = new System.Drawing.Point(53, 252);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(75, 23);
			this.button1.TabIndex = 6;
			this.button1.Text = "Refresh";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.Button1Click);
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
									| System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(30, 22);
			this.textBox1.Multiline = true;
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(432, 224);
			this.textBox1.TabIndex = 5;
			// 
			// InstalledFramework
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(492, 297);
			this.Controls.Add(this.button3);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.button1);
			this.Controls.Add(this.textBox1);
			this.Name = "InstalledFramework";
			this.Text = "Installed Framework Detect";
			this.Shown += new System.EventHandler(this.InstalledFrameworkShown);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Button button3;
	}
}



================================================
File: MegaDumper/InstalledFramework.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 14.04.2011
 * Time: 18:22
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Text;
using System.IO;

namespace Mega_Dumper
{
	/// <summary>
	/// Description of InstalledFramework.
	/// </summary>
	public partial class InstalledFramework : Form
	{
		public InstalledFramework()
		{
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
			
		public void GetInstalledFrameworks()
		{
			textBox1.Text = "Installed .Net Frameworks:"+"\r\n";
		    RegistryKey installed_versions = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\NET Framework Setup\NDP");
            string[] version_names = installed_versions.GetSubKeyNames();
            for (int i = 0; i < version_names.Length; i++)
            {
                RegistryKey spsubk = installed_versions.OpenSubKey(version_names[i]);
                if (spsubk.SubKeyCount>0&&version_names[i]!="CDF")
                {
                object spsub = spsubk.GetValue("SP", 0);
                int SP = Convert.ToInt32(spsub);
                object versionsub = spsubk.GetValue("Version", 0);
                string version = versionsub.ToString();
                version = version.Replace("v","");
                if (version_names[i]=="v4")
                {
                textBox1.Text += version_names[i];
                string[] fr4versions = spsubk.GetSubKeyNames();
                for (int j = 0; j < fr4versions.Length; j++)
            	{
                RegistryKey fr4 = spsubk.OpenSubKey(fr4versions[j]);
                object f4versionsub = fr4.GetValue("Version", 0);
                textBox1.Text += "      -"+fr4versions[j]+" version "+f4versionsub.ToString();
                if (j+1<fr4versions.Length) textBox1.Text += "\r\n";
                if (j==0) textBox1.Text += "    ";
                fr4.Close();
                }
                }
                else
                {
                textBox1.Text += version_names[i] + (SP > 0 ? " SP " + SP.ToString() : "");
                if (version!="0")
                textBox1.Text += "   version "+version;
                }
                textBox1.Text += "\r\n";
                }

                spsubk.Close();
                
            }
            
            installed_versions.Close();
            
            RegistryKey framework = Registry.LocalMachine.OpenSubKey(@"Software\\Microsoft\\.NetFramework");
            string frameworkdir = (string)framework.GetValue("InstallRoot", 0);
            framework.Close();
            textBox1.Text += "\r\n";
            textBox1.Text += ".NET Framework InstallRoot: "+frameworkdir+"\r\n";
            textBox1.Text += ".NET Framework directories:"+"\r\n";


         
            string [] dirs = Directory.GetDirectories(frameworkdir, "*.*");
            for (int i=0;i<dirs.Length;i++)
            {
            if (Directory.GetDirectories(dirs[i]).Length>0)
            textBox1.Text += dirs[i]+"\r\n";
            }
        
		}
		void InstalledFrameworkShown(object sender, EventArgs e)
		{
		GetInstalledFrameworks();
		}
		
		void Button1Click(object sender, EventArgs e)
		{
		GetInstalledFrameworks();
		}
		
		void Button2Click(object sender, EventArgs e)
		{
		if (textBox1.Text!="") Clipboard.SetText(textBox1.Text);
		}
		
		void Button3Click(object sender, EventArgs e)
		{
		this.Close();
		}
	}
}



================================================
File: MegaDumper/InstalledFramework.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/MainForm.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 11.10.2010
 * Time: 15:47
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class MainForm
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
			this.lvprocesslist = new System.Windows.Forms.ListView();
			this.procname = new System.Windows.Forms.ColumnHeader();
			this.PID = new System.Windows.Forms.ColumnHeader();
			this.status = new System.Windows.Forms.ColumnHeader();
			this.isnet = new System.Windows.Forms.ColumnHeader();
			this.location = new System.Windows.Forms.ColumnHeader();
			this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);
			this.dumpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.dumpModuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.gotoLocationToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.copyToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.advancedInfoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.virtualMemoryToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.viewHeapToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.enumAppdomainsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.nETPerformanceToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.hookDetectionToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.environmentVariablesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.fileDirectoriesListToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.generateDmpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.injectManagedDllToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
			this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripMenuItem();
			this.bringToFrontToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.restoreToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.minimizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.maximizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.closeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.priorityToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.rttoolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.hToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.anToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.nToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.bnToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.iToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.suspendProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.resumeProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.killProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.menuStrip1 = new System.Windows.Forms.MenuStrip();
			this.mainToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.testToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.processManagerToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.windowsHoocksToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.installedFrameworkToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.dumpingOptionToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.dumpNativeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.autoRefreshToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.dontRestoreFilenameToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.helpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
			this.contextMenuStrip1.SuspendLayout();
			this.menuStrip1.SuspendLayout();
			this.SuspendLayout();
			// 
			// lvprocesslist
			// 
			this.lvprocesslist.Alignment = System.Windows.Forms.ListViewAlignment.Default;
			this.lvprocesslist.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
									| System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.lvprocesslist.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
									this.procname,
									this.PID,
									this.status,
									this.isnet,
									this.location});
			this.lvprocesslist.ContextMenuStrip = this.contextMenuStrip1;
			this.lvprocesslist.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(238)));
			this.lvprocesslist.FullRowSelect = true;
			this.lvprocesslist.Location = new System.Drawing.Point(0, 24);
			this.lvprocesslist.MultiSelect = false;
			this.lvprocesslist.Name = "lvprocesslist";
			this.lvprocesslist.Size = new System.Drawing.Size(790, 417);
			this.lvprocesslist.TabIndex = 8;
			this.lvprocesslist.UseCompatibleStateImageBehavior = false;
			this.lvprocesslist.View = System.Windows.Forms.View.Details;
			// 
			// procname
			// 
			this.procname.Text = "Process Name";
			this.procname.Width = 87;
			// 
			// PID
			// 
			this.PID.Text = "PID";
			this.PID.Width = 41;
			// 
			// status
			// 
			this.status.Text = "Status";
			// 
			// isnet
			// 
			this.isnet.Text = ".NET";
			// 
			// location
			// 
			this.location.Text = "Location";
			this.location.Width = 104;
			// 
			// contextMenuStrip1
			// 
			this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.dumpToolStripMenuItem,
									this.dumpModuleToolStripMenuItem,
									this.gotoLocationToolStripMenuItem,
									this.copyToolStripMenuItem,
									this.advancedInfoToolStripMenuItem,
									this.injectManagedDllToolStripMenuItem,
									this.toolStripSeparator1,
									this.toolStripMenuItem1,
									this.priorityToolStripMenuItem,
									this.suspendProcessToolStripMenuItem,
									this.resumeProcessToolStripMenuItem,
									this.killProcessToolStripMenuItem});
			this.contextMenuStrip1.Name = "contextMenuStrip1";
			this.contextMenuStrip1.Size = new System.Drawing.Size(208, 274);
			// 
			// dumpToolStripMenuItem
			// 
			this.dumpToolStripMenuItem.Name = "dumpToolStripMenuItem";
			this.dumpToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.dumpToolStripMenuItem.Text = ".NET dump";
			this.dumpToolStripMenuItem.Click += new System.EventHandler(this.DumpToolStripMenuItemClick);
			// 
			// dumpModuleToolStripMenuItem
			// 
			this.dumpModuleToolStripMenuItem.Name = "dumpModuleToolStripMenuItem";
			this.dumpModuleToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.dumpModuleToolStripMenuItem.Text = "Modules";
			this.dumpModuleToolStripMenuItem.Click += new System.EventHandler(this.DumpModuleToolStripMenuItemClick);
			// 
			// gotoLocationToolStripMenuItem
			// 
			this.gotoLocationToolStripMenuItem.Name = "gotoLocationToolStripMenuItem";
			this.gotoLocationToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.gotoLocationToolStripMenuItem.Text = "Goto Location";
			this.gotoLocationToolStripMenuItem.Click += new System.EventHandler(this.GotoLocationToolStripMenuItemClick);
			// 
			// copyToolStripMenuItem
			// 
			this.copyToolStripMenuItem.Name = "copyToolStripMenuItem";
			this.copyToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.copyToolStripMenuItem.Text = "Copy Location";
			this.copyToolStripMenuItem.Click += new System.EventHandler(this.CopyToolStripMenuItemClick);
			// 
			// advancedInfoToolStripMenuItem
			// 
			this.advancedInfoToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.virtualMemoryToolStripMenuItem,
									this.viewHeapToolStripMenuItem,
									this.enumAppdomainsToolStripMenuItem,
									this.nETPerformanceToolStripMenuItem,
									this.hookDetectionToolStripMenuItem,
									this.environmentVariablesToolStripMenuItem,
									this.fileDirectoriesListToolStripMenuItem,
									this.generateDmpToolStripMenuItem});
			this.advancedInfoToolStripMenuItem.Name = "advancedInfoToolStripMenuItem";
			this.advancedInfoToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.advancedInfoToolStripMenuItem.Text = "Advanced Info";
			// 
			// virtualMemoryToolStripMenuItem
			// 
			this.virtualMemoryToolStripMenuItem.Name = "virtualMemoryToolStripMenuItem";
			this.virtualMemoryToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.virtualMemoryToolStripMenuItem.Text = "Virtual Memory";
			this.virtualMemoryToolStripMenuItem.Click += new System.EventHandler(this.VirtualMemoryToolStripMenuItemClick);
			// 
			// viewHeapToolStripMenuItem
			// 
			this.viewHeapToolStripMenuItem.Name = "viewHeapToolStripMenuItem";
			this.viewHeapToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.viewHeapToolStripMenuItem.Text = "View Heap";
			this.viewHeapToolStripMenuItem.Click += new System.EventHandler(this.ViewHeapToolStripMenuItemClick);
			// 
			// enumAppdomainsToolStripMenuItem
			// 
			this.enumAppdomainsToolStripMenuItem.Name = "enumAppdomainsToolStripMenuItem";
			this.enumAppdomainsToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.enumAppdomainsToolStripMenuItem.Text = "Enum Appdomains";
			this.enumAppdomainsToolStripMenuItem.Click += new System.EventHandler(this.EnumAppdomainsToolStripMenuItemClick);
			// 
			// nETPerformanceToolStripMenuItem
			// 
			this.nETPerformanceToolStripMenuItem.Name = "nETPerformanceToolStripMenuItem";
			this.nETPerformanceToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.nETPerformanceToolStripMenuItem.Text = ".NET Performance";
			this.nETPerformanceToolStripMenuItem.Click += new System.EventHandler(this.NETPerformanceToolStripMenuItemClick);
			// 
			// hookDetectionToolStripMenuItem
			// 
			this.hookDetectionToolStripMenuItem.Name = "hookDetectionToolStripMenuItem";
			this.hookDetectionToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.hookDetectionToolStripMenuItem.Text = "JIT hook detection";
			this.hookDetectionToolStripMenuItem.Click += new System.EventHandler(this.HookDetectionToolStripMenuItemClick);
			// 
			// environmentVariablesToolStripMenuItem
			// 
			this.environmentVariablesToolStripMenuItem.Name = "environmentVariablesToolStripMenuItem";
			this.environmentVariablesToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.environmentVariablesToolStripMenuItem.Text = "Environment Variables";
			this.environmentVariablesToolStripMenuItem.Click += new System.EventHandler(this.EnvironmentVariablesToolStripMenuItemClick);
			// 
			// fileDirectoriesListToolStripMenuItem
			// 
			this.fileDirectoriesListToolStripMenuItem.Name = "fileDirectoriesListToolStripMenuItem";
			this.fileDirectoriesListToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.fileDirectoriesListToolStripMenuItem.Text = "Files/Directories list";
			this.fileDirectoriesListToolStripMenuItem.Click += new System.EventHandler(this.FileDirectoriesListToolStripMenuItemClick);
			// 
			// generateDmpToolStripMenuItem
			// 
			this.generateDmpToolStripMenuItem.Name = "generateDmpToolStripMenuItem";
			this.generateDmpToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.generateDmpToolStripMenuItem.Text = "Generate dmp";
			this.generateDmpToolStripMenuItem.Click += new System.EventHandler(this.GenerateDmpToolStripMenuItemClick);
			// 
			// injectManagedDllToolStripMenuItem
			// 
			this.injectManagedDllToolStripMenuItem.Name = "injectManagedDllToolStripMenuItem";
			this.injectManagedDllToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.injectManagedDllToolStripMenuItem.Text = "Inject Managed assembly";
			this.injectManagedDllToolStripMenuItem.Click += new System.EventHandler(this.InjectManagedDllToolStripMenuItemClick);
			// 
			// toolStripSeparator1
			// 
			this.toolStripSeparator1.Name = "toolStripSeparator1";
			this.toolStripSeparator1.Size = new System.Drawing.Size(204, 6);
			// 
			// toolStripMenuItem1
			// 
			this.toolStripMenuItem1.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.bringToFrontToolStripMenuItem,
									this.restoreToolStripMenuItem,
									this.minimizeToolStripMenuItem,
									this.maximizeToolStripMenuItem,
									this.closeToolStripMenuItem});
			this.toolStripMenuItem1.Name = "toolStripMenuItem1";
			this.toolStripMenuItem1.Size = new System.Drawing.Size(207, 22);
			this.toolStripMenuItem1.Text = "Main Window";
			// 
			// bringToFrontToolStripMenuItem
			// 
			this.bringToFrontToolStripMenuItem.Name = "bringToFrontToolStripMenuItem";
			this.bringToFrontToolStripMenuItem.Size = new System.Drawing.Size(151, 22);
			this.bringToFrontToolStripMenuItem.Text = "Bring to Front";
			this.bringToFrontToolStripMenuItem.Click += new System.EventHandler(this.BringToFrontToolStripMenuItemClick);
			// 
			// restoreToolStripMenuItem
			// 
			this.restoreToolStripMenuItem.Name = "restoreToolStripMenuItem";
			this.restoreToolStripMenuItem.Size = new System.Drawing.Size(151, 22);
			this.restoreToolStripMenuItem.Text = "Restore";
			this.restoreToolStripMenuItem.Click += new System.EventHandler(this.RestoreToolStripMenuItemClick);
			// 
			// minimizeToolStripMenuItem
			// 
			this.minimizeToolStripMenuItem.Name = "minimizeToolStripMenuItem";
			this.minimizeToolStripMenuItem.Size = new System.Drawing.Size(151, 22);
			this.minimizeToolStripMenuItem.Text = "Minimize";
			this.minimizeToolStripMenuItem.Click += new System.EventHandler(this.MinimizeToolStripMenuItemClick);
			// 
			// maximizeToolStripMenuItem
			// 
			this.maximizeToolStripMenuItem.Name = "maximizeToolStripMenuItem";
			this.maximizeToolStripMenuItem.Size = new System.Drawing.Size(151, 22);
			this.maximizeToolStripMenuItem.Text = "Maximize";
			this.maximizeToolStripMenuItem.Click += new System.EventHandler(this.MaximizeToolStripMenuItemClick);
			// 
			// closeToolStripMenuItem
			// 
			this.closeToolStripMenuItem.Name = "closeToolStripMenuItem";
			this.closeToolStripMenuItem.Size = new System.Drawing.Size(151, 22);
			this.closeToolStripMenuItem.Text = "Close";
			this.closeToolStripMenuItem.Click += new System.EventHandler(this.CloseToolStripMenuItemClick);
			// 
			// priorityToolStripMenuItem
			// 
			this.priorityToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.rttoolStripMenuItem,
									this.hToolStripMenuItem,
									this.anToolStripMenuItem,
									this.nToolStripMenuItem,
									this.bnToolStripMenuItem,
									this.iToolStripMenuItem});
			this.priorityToolStripMenuItem.Name = "priorityToolStripMenuItem";
			this.priorityToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.priorityToolStripMenuItem.Text = "Priority";
			this.priorityToolStripMenuItem.Click += new System.EventHandler(this.PriorityToolStripMenuItemClick);
			// 
			// rttoolStripMenuItem
			// 
			this.rttoolStripMenuItem.Name = "rttoolStripMenuItem";
			this.rttoolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.rttoolStripMenuItem.Text = "Real Time";
			this.rttoolStripMenuItem.Click += new System.EventHandler(this.ToolStripMenuItem3Click);
			// 
			// hToolStripMenuItem
			// 
			this.hToolStripMenuItem.Name = "hToolStripMenuItem";
			this.hToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.hToolStripMenuItem.Text = "High";
			this.hToolStripMenuItem.Click += new System.EventHandler(this.HToolStripMenuItemClick);
			// 
			// anToolStripMenuItem
			// 
			this.anToolStripMenuItem.Name = "anToolStripMenuItem";
			this.anToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.anToolStripMenuItem.Text = "Above Normal";
			this.anToolStripMenuItem.Click += new System.EventHandler(this.AnToolStripMenuItemClick);
			// 
			// nToolStripMenuItem
			// 
			this.nToolStripMenuItem.Name = "nToolStripMenuItem";
			this.nToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.nToolStripMenuItem.Text = "Normal";
			this.nToolStripMenuItem.Click += new System.EventHandler(this.NToolStripMenuItemClick);
			// 
			// bnToolStripMenuItem
			// 
			this.bnToolStripMenuItem.Name = "bnToolStripMenuItem";
			this.bnToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.bnToolStripMenuItem.Text = "Below Normal";
			this.bnToolStripMenuItem.Click += new System.EventHandler(this.BnToolStripMenuItemClick);
			// 
			// iToolStripMenuItem
			// 
			this.iToolStripMenuItem.Name = "iToolStripMenuItem";
			this.iToolStripMenuItem.Size = new System.Drawing.Size(152, 22);
			this.iToolStripMenuItem.Text = "Idle";
			this.iToolStripMenuItem.Click += new System.EventHandler(this.IToolStripMenuItemClick);
			// 
			// suspendProcessToolStripMenuItem
			// 
			this.suspendProcessToolStripMenuItem.Name = "suspendProcessToolStripMenuItem";
			this.suspendProcessToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.suspendProcessToolStripMenuItem.Text = "Suspend process";
			this.suspendProcessToolStripMenuItem.Click += new System.EventHandler(this.SuspendProcessToolStripMenuItemClick);
			// 
			// resumeProcessToolStripMenuItem
			// 
			this.resumeProcessToolStripMenuItem.Name = "resumeProcessToolStripMenuItem";
			this.resumeProcessToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.resumeProcessToolStripMenuItem.Text = "Resume process";
			this.resumeProcessToolStripMenuItem.Click += new System.EventHandler(this.ResumeProcessToolStripMenuItemClick);
			// 
			// killProcessToolStripMenuItem
			// 
			this.killProcessToolStripMenuItem.Name = "killProcessToolStripMenuItem";
			this.killProcessToolStripMenuItem.Size = new System.Drawing.Size(207, 22);
			this.killProcessToolStripMenuItem.Text = "Kill process";
			this.killProcessToolStripMenuItem.Click += new System.EventHandler(this.KillProcessToolStripMenuItemClick);
			// 
			// menuStrip1
			// 
			this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.mainToolStripMenuItem,
									this.helpToolStripMenuItem});
			this.menuStrip1.Location = new System.Drawing.Point(0, 0);
			this.menuStrip1.Name = "menuStrip1";
			this.menuStrip1.Size = new System.Drawing.Size(790, 24);
			this.menuStrip1.TabIndex = 14;
			this.menuStrip1.Text = "menuStrip1";
			// 
			// mainToolStripMenuItem
			// 
			this.mainToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.testToolStripMenuItem,
									this.processManagerToolStripMenuItem,
									this.windowsHoocksToolStripMenuItem,
									this.installedFrameworkToolStripMenuItem,
									this.dumpingOptionToolStripMenuItem,
									this.exitToolStripMenuItem});
			this.mainToolStripMenuItem.Name = "mainToolStripMenuItem";
			this.mainToolStripMenuItem.Size = new System.Drawing.Size(41, 20);
			this.mainToolStripMenuItem.Text = "Main";
			// 
			// testToolStripMenuItem
			// 
			this.testToolStripMenuItem.Name = "testToolStripMenuItem";
			this.testToolStripMenuItem.Size = new System.Drawing.Size(182, 22);
			this.testToolStripMenuItem.Text = "Refresh list";
			this.testToolStripMenuItem.Click += new System.EventHandler(this.TestToolStripMenuItemClick);
			// 
			// processManagerToolStripMenuItem
			// 
			this.processManagerToolStripMenuItem.Name = "processManagerToolStripMenuItem";
			this.processManagerToolStripMenuItem.Size = new System.Drawing.Size(182, 22);
			this.processManagerToolStripMenuItem.Text = "Process manager";
			this.processManagerToolStripMenuItem.Click += new System.EventHandler(this.ProcessManagerToolStripMenuItemClick);
			// 
			// windowsHoocksToolStripMenuItem
			// 
			this.windowsHoocksToolStripMenuItem.Name = "windowsHoocksToolStripMenuItem";
			this.windowsHoocksToolStripMenuItem.Size = new System.Drawing.Size(182, 22);
			this.windowsHoocksToolStripMenuItem.Text = "WindowsHoocks";
			this.windowsHoocksToolStripMenuItem.Click += new System.EventHandler(this.WindowsHoocksToolStripMenuItemClick);
			// 
			// installedFrameworkToolStripMenuItem
			// 
			this.installedFrameworkToolStripMenuItem.Name = "installedFrameworkToolStripMenuItem";
			this.installedFrameworkToolStripMenuItem.Size = new System.Drawing.Size(182, 22);
			this.installedFrameworkToolStripMenuItem.Text = "Installed Framework";
			this.installedFrameworkToolStripMenuItem.Click += new System.EventHandler(this.InstalledFrameworkToolStripMenuItemClick);
			// 
			// dumpingOptionToolStripMenuItem
			// 
			this.dumpingOptionToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.dumpNativeToolStripMenuItem,
									this.autoRefreshToolStripMenuItem,
									this.dontRestoreFilenameToolStripMenuItem});
			this.dumpingOptionToolStripMenuItem.Name = "dumpingOptionToolStripMenuItem";
			this.dumpingOptionToolStripMenuItem.Size = new System.Drawing.Size(182, 22);
			this.dumpingOptionToolStripMenuItem.Text = "DumpingOption";
			// 
			// dumpNativeToolStripMenuItem
			// 
			this.dumpNativeToolStripMenuItem.CheckOnClick = true;
			this.dumpNativeToolStripMenuItem.Name = "dumpNativeToolStripMenuItem";
			this.dumpNativeToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.dumpNativeToolStripMenuItem.Text = "Dump native";
			// 
			// autoRefreshToolStripMenuItem
			// 
			this.autoRefreshToolStripMenuItem.Name = "autoRefreshToolStripMenuItem";
			this.autoRefreshToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.autoRefreshToolStripMenuItem.Text = "AutoRefresh";
			// 
			// dontRestoreFilenameToolStripMenuItem
			// 
			this.dontRestoreFilenameToolStripMenuItem.CheckOnClick = true;
			this.dontRestoreFilenameToolStripMenuItem.Name = "dontRestoreFilenameToolStripMenuItem";
			this.dontRestoreFilenameToolStripMenuItem.Size = new System.Drawing.Size(191, 22);
			this.dontRestoreFilenameToolStripMenuItem.Text = "Don\'t restore filename";
			// 
			// exitToolStripMenuItem
			// 
			this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
			this.exitToolStripMenuItem.Size = new System.Drawing.Size(182, 22);
			this.exitToolStripMenuItem.Text = "Exit";
			this.exitToolStripMenuItem.Click += new System.EventHandler(this.ExitToolStripMenuItemClick);
			// 
			// helpToolStripMenuItem
			// 
			this.helpToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
									this.aboutToolStripMenuItem});
			this.helpToolStripMenuItem.Name = "helpToolStripMenuItem";
			this.helpToolStripMenuItem.Size = new System.Drawing.Size(40, 20);
			this.helpToolStripMenuItem.Text = "Help";
			// 
			// aboutToolStripMenuItem
			// 
			this.aboutToolStripMenuItem.Name = "aboutToolStripMenuItem";
			this.aboutToolStripMenuItem.Size = new System.Drawing.Size(114, 22);
			this.aboutToolStripMenuItem.Text = "About";
			this.aboutToolStripMenuItem.Click += new System.EventHandler(this.AboutToolStripMenuItemClick);
			// 
			// MainForm
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(790, 444);
			this.Controls.Add(this.menuStrip1);
			this.Controls.Add(this.lvprocesslist);
			this.Font = new System.Drawing.Font("Microsoft Sans Serif", 8F);
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MainMenuStrip = this.menuStrip1;
			this.Name = "MainForm";
			this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Show;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "MegaDumper 1.0 by CodeCracker / SnD";
			this.WindowState = System.Windows.Forms.FormWindowState.Maximized;
			this.Load += new System.EventHandler(this.MainFormLoad);
			this.contextMenuStrip1.ResumeLayout(false);
			this.menuStrip1.ResumeLayout(false);
			this.menuStrip1.PerformLayout();
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.ToolStripMenuItem injectManagedDllToolStripMenuItem;
		private System.Windows.Forms.ColumnHeader status;
		private System.Windows.Forms.ToolStripMenuItem fileDirectoriesListToolStripMenuItem;
		private System.Windows.Forms.ColumnHeader isnet;
		private System.Windows.Forms.ToolStripMenuItem generateDmpToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem environmentVariablesToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem hookDetectionToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem enumAppdomainsToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem virtualMemoryToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem advancedInfoToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem dontRestoreFilenameToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem autoRefreshToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem dumpNativeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem dumpingOptionToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem installedFrameworkToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem windowsHoocksToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem processManagerToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem exitToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem mainToolStripMenuItem;
		private System.Windows.Forms.MenuStrip menuStrip1;
		private System.Windows.Forms.ToolStripMenuItem testToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem viewHeapToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem rttoolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem hToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem anToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem nToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem bnToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem iToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem priorityToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem closeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem maximizeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem minimizeToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem restoreToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem bringToFrontToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem toolStripMenuItem1;
		private System.Windows.Forms.ToolStripMenuItem killProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem resumeProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem suspendProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
		private System.Windows.Forms.ToolStripMenuItem gotoLocationToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem dumpModuleToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem copyToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem nETPerformanceToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem dumpToolStripMenuItem;
		private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;
		private System.Windows.Forms.ColumnHeader location;
		private System.Windows.Forms.ColumnHeader PID;
		private System.Windows.Forms.ColumnHeader procname;
		private System.Windows.Forms.ListView lvprocesslist;
	}
}



================================================
File: MegaDumper/MainForm.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 11.10.2010
 * Time: 15:47
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Collections;

using ProcessUtils;
using WinEnumerator;
using Mega_Dumper;
	
namespace Mega_Dumper
{
	/// <summary>
	/// Description of MainForm.
	/// </summary>
	public partial class MainForm : Form
	{
		
		[DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
        
        
        [DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            uint lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );

public enum ProcessAccess : int
{
    /// <summary>Specifies all possible access flags for the process object.</summary>
    AllAccess = CreateThread | DuplicateHandle | QueryInformation | SetInformation | Terminate | VMOperation | VMRead | VMWrite | Synchronize,
    /// <summary>Enables usage of the process handle in the CreateRemoteThread function to create a thread in the process.</summary>
    CreateThread = 0x2,
    /// <summary>Enables usage of the process handle as either the source or target process in the DuplicateHandle function to duplicate a handle.</summary>
    DuplicateHandle = 0x40,
    /// <summary>Enables usage of the process handle in the GetExitCodeProcess and GetPriorityClass functions to read information from the process object.</summary>
    QueryInformation = 0x400,
    /// <summary>Enables usage of the process handle in the SetPriorityClass function to set the priority class of the process.</summary>
    SetInformation = 0x200,
    /// <summary>Enables usage of the process handle in the TerminateProcess function to terminate the process.</summary>
    Terminate = 0x1,
    /// <summary>Enables usage of the process handle in the VirtualProtectEx and WriteProcessMemory functions to modify the virtual memory of the process.</summary>
    VMOperation = 0x8,
    /// <summary>Enables usage of the process handle in the ReadProcessMemory function to' read from the virtual memory of the process.</summary>
    VMRead = 0x10,
    /// <summary>Enables usage of the process handle in the WriteProcessMemory function to write to the virtual memory of the process.</summary>
    VMWrite = 0x20,
    /// <summary>Enables usage of the process handle in any of the wait functions to wait for the process to terminate.</summary>
    Synchronize = 0x100000
}



		
[StructLayout(LayoutKind.Sequential)]
public struct SYSTEM_INFO
{
	public uint dwOemId;
	public uint dwPageSize;
	public uint lpMinimumApplicationAddress;
	public uint lpMaximumApplicationAddress;
	public uint dwActiveProcessorMask;
	public uint dwNumberOfProcessors;
	public uint dwProcessorType;
	public uint dwAllocationGranularity;
	public uint dwProcessorLevel;
	public uint dwProcessorRevision;
}

[DllImport("kernel32")]
public static extern void GetSystemInfo(ref SYSTEM_INFO pSI); 
     
     [DllImport("kernel32.dll")]
     static extern IntPtr OpenProcess(UInt32 dwDesiredAccess,  Int32 bInheritHandle, UInt32 dwProcessId);
     
     [DllImport("kernel32.dll", SetLastError=true)]
     [return: MarshalAs(UnmanagedType.Bool)]
     static extern bool CloseHandle(IntPtr hObject);
     
     
		private const uint PROCESS_TERMINATE = 0x0001;
		private const uint PROCESS_CREATE_THREAD = 0x0002;
		private const uint PROCESS_SET_SESSIONID = 0x0004;
		private const uint PROCESS_VM_OPERATION = 0x0008;
		private const uint PROCESS_VM_READ = 0x0010;
		private const uint PROCESS_VM_WRITE = 0x0020;
		private const uint PROCESS_DUP_HANDLE = 0x0040;
		private const uint PROCESS_CREATE_PROCESS = 0x0080;
		private const uint PROCESS_SET_QUOTA = 0x0100;
		private const uint PROCESS_SET_INFORMATION = 0x0200;
		private const uint PROCESS_QUERY_INFORMATION = 0x0400;
     
     //inner enum used only internally
    [Flags]
    private enum SnapshotFlags : uint
    {
    HeapList = 0x00000001,
    Process = 0x00000002,
    Thread = 0x00000004,
    Module = 0x00000008,
    Module32 = 0x00000010,
    Inherit = 0x80000000,
    All = 0x0000001F
    }
    //inner struct used only internally
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    private struct PROCESSENTRY32
    {
    const int MAX_PATH = 260;
    internal UInt32 dwSize;
    internal UInt32 cntUsage;
    internal UInt32 th32ProcessID;
    internal IntPtr th32DefaultHeapID;
    internal UInt32 th32ModuleID;
    internal UInt32 cntThreads;
    internal UInt32 th32ParentProcessID;
    internal Int32 pcPriClassBase;
    internal UInt32 dwFlags;
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = MAX_PATH)]
    internal string szExeFile;
    }

    [DllImport("kernel32", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
    static extern IntPtr CreateToolhelp32Snapshot([In]UInt32 dwFlags, [In]UInt32 th32ProcessID);

    [DllImport("kernel32", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
    static extern bool Process32First([In]IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

    [DllImport("kernel32", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
    static extern bool Process32Next([In]IntPtr hSnapshot, ref PROCESSENTRY32 lppe);


[DllImport("ntdll.dll", SetLastError=true)]
static extern int NtQueryInformationProcess(IntPtr processHandle,
   int processInformationClass, ref PROCESS_BASIC_INFORMATION processInformation, uint processInformationLength,
   out int returnLength);
   
[StructLayout(LayoutKind.Sequential, Pack = 1)]
private struct PROCESS_BASIC_INFORMATION
{
  public int ExitStatus;
  public int PebBaseAddress;
  public int AffinityMask;
  public int BasePriority;
  public int UniqueProcessId;
  public int InheritedFromUniqueProcessId;

  public int Size
  {
    get { return (6*4); }
  }
}


 
		public MainForm()
		{
		
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		



		void Button1Click(object sender, EventArgs e)
		{
		Application.Exit();
		}

[DllImport("kernel32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool GetExitCodeProcess(IntPtr hProcess, out uint lpExitCode);

public void OnTimerEvent(object source, EventArgs e)
{
UInt32[] oldproc = new UInt32[lvprocesslist.Items.Count];

// get old list of process: 
for (int i=0;i<oldproc.Length;i++)
{
oldproc[i]=Convert.ToUInt32(lvprocesslist.Items[i].SubItems[1].Text);
}

uint[] processIds = new uint[0x200];
int proccount = 0;

        try
        {
        IntPtr handleToSnapshot = IntPtr.Zero;
        PROCESSENTRY32 procEntry = new PROCESSENTRY32();
        procEntry.dwSize = (UInt32)Marshal.SizeOf(typeof(PROCESSENTRY32));
        handleToSnapshot = CreateToolhelp32Snapshot((uint)SnapshotFlags.Process, 0);
        if (Process32First(handleToSnapshot, ref procEntry))
        {
        do
        {
bool isThere = false;

for (int i=0;i<oldproc.Length;i++)
{
if (procEntry.th32ProcessID == oldproc[i])
{
isThere = true;
break;
}
}

// new process created ?
if (!isThere)
{
		Process theProc = null;
        string directoryName ="";
        string processname = procEntry.szExeFile;
        string isnet = "false";
        
        try
		{
        theProc = Process.GetProcessById((int)procEntry.th32ProcessID);
 		if (IsNetProcess((int)procEntry.th32ProcessID))
        {
        isnet = "true";
        }
        else
        {
        isnet = "false";
        }
        
        }
        catch
        {
        }
        string rname = "";
        try
		{
        rname = theProc.MainModule.FileName.Replace("\\??\\","");
        if (File.Exists(rname))
        {
        directoryName=Path.GetDirectoryName(rname);
        }
		}
		catch
		{
		}
        theProc.Close();
        
        if (!File.Exists(rname))
        {
        if (Environment.OSVersion.Platform == PlatformID.Win32NT)
        {

        string newname="";
        try
        {
		IntPtr hProcess =
		OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, procEntry.th32ProcessID);
		if (hProcess!=IntPtr.Zero)
		{
      
        PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
         int bytesWritten;
         int result = NtQueryInformationProcess(hProcess,0, ref pbi, (uint)Marshal.SizeOf(pbi),out bytesWritten);
         if (result>=0)  // == 0 is OK
         {
         byte[] peb = new byte[472];
         uint BytesRead=0;
         bool isok = ReadProcessMemory(hProcess,(IntPtr)(pbi.PebBaseAddress),peb,(uint)(peb.Length), ref BytesRead);
         if (isok)
         {
         // this is on all Windows NT version - including Windows 7/Vista
       	 IntPtr AProcessParameters = (IntPtr)BitConverter.ToInt32(peb,016);
         
         byte[] ProcessParameters = new byte[72];
         isok = ReadProcessMemory(hProcess,AProcessParameters,ProcessParameters,(uint)(ProcessParameters.Length), ref BytesRead);  
         if (isok)
         {
         int aCurrentDirectory = BitConverter.ToInt32(ProcessParameters,040);
         byte[] Forread = new byte[2];
         int size=0;
         
         do
         {
         isok = ReadProcessMemory(hProcess,(IntPtr)(aCurrentDirectory+size),Forread,2, ref BytesRead);
         size=size+2;
         }
         while (isok&&Forread[0]!=0);
         size=size-2;
         byte[] CurrentDirectory = new byte[size];
         isok = ReadProcessMemory(hProcess,(IntPtr)(aCurrentDirectory),CurrentDirectory,(uint)size, ref BytesRead);
         newname = System.Text.Encoding.Unicode.GetString(CurrentDirectory);
		 if (newname.Length>=3)
		 {
		 newname = newname.Replace("\\??\\","");
		 directoryName = newname;
		 }
         }
         }

         }
        CloseHandle(hProcess);
        }
        }
        catch
        {
        
        }
        }
        }
        

        
 		 // compute size:
         Graphics g = lvprocesslist.CreateGraphics();
         Font objFont = new Font("Microsoft Sans Serif", 8);
         SizeF stringSize = new SizeF();
         stringSize = g.MeasureString(processname, objFont);
         int processlenght = (int)(stringSize.Width+lvprocesslist.Margin.Horizontal*2)+5;
         stringSize = g.MeasureString(directoryName, objFont);
         int directorylenght = (int)(stringSize.Width+lvprocesslist.Margin.Horizontal*2)+40;
         
         if (processlenght>procname.Width)
         {
         procname.Width=processlenght;
         }
         
         if (directorylenght>location.Width)
         {
         location.Width=directorylenght;
         }
         
         string[] prcdetails = new string[]{processname,procEntry.th32ProcessID.ToString(),"",isnet,directoryName};
         ListViewItem proc = new ListViewItem(prcdetails);
         lvprocesslist.Items.Add(proc);
        
		}
		else
		{
		proccount++;
		processIds[proccount]=procEntry.th32ProcessID;
		}
		
        } while (Process32Next(handleToSnapshot, ref procEntry));
        }
        CloseHandle(handleToSnapshot);
        }
        catch
        {
        }

// check statut of old processes: 
for (int i=0;i<oldproc.Length;i++)
{
bool isThere = false;
for (int j=0;j<processIds.Length;j++)
{
if (oldproc[i]== processIds[j])
isThere = true;
}

if (!isThere)
{
if (lvprocesslist.Items[i].SubItems[2].Text!="Killed")
lvprocesslist.Items[i].SubItems[2].Text ="Killed";
}

}

}


public bool IsNetProcess(int processid)
{
        ProcModule.ModuleInfo[] modules = ProcModule.GetModuleInfos(processid);
        string lowerfn = "";
        for (int i=0;i<modules.Length;i++)
        {
        lowerfn = modules[i].baseName.ToLower();
        if (lowerfn=="mscorjit.dll"||lowerfn=="mscorlib.dll"||
            lowerfn=="mscoree.dll"||lowerfn=="mscorwks.dll")
        return true;
        
        if (lowerfn=="clr.dll"||lowerfn=="clrjit.dll")  // Fr 4.0
        return true;
        
        }
        
        return false;
}
        
		public Timer timer1;
		private void EnumProcesses()
		{
if (timer1==null)
{
timer1 = new Timer();
timer1.Interval = 100;
timer1.Enabled = true;
timer1.Tick += new System.EventHandler (OnTimerEvent);
}

	    lvprocesslist.Items.Clear();
        Process theProc=null;

        string directoryName="";
        string processname="";
        string isnet = "false";
        
/*
IMO the key difference is in priviledges requirements.
I've seen cases in which EnumProcesses() would fail,
but CreateToolhelp32Snapshot() ran perfectly well.
*/ 
        try
        {
        IntPtr handleToSnapshot = IntPtr.Zero;
        PROCESSENTRY32 procEntry = new PROCESSENTRY32();
        procEntry.dwSize = (UInt32)Marshal.SizeOf(typeof(PROCESSENTRY32));
        handleToSnapshot = CreateToolhelp32Snapshot((uint)SnapshotFlags.Process, 0);
        if (Process32First(handleToSnapshot, ref procEntry))
        {
        do
        {
        directoryName ="";
        processname = procEntry.szExeFile;
        string statut = "";//exited
        try
		{
        theProc = Process.GetProcessById((int)procEntry.th32ProcessID);
        
        if (IsNetProcess((int)procEntry.th32ProcessID))
        {
        isnet = "true";
        }
        else
        {
        isnet = "false";
        }
        
        }
        catch
        {
        }
        
     	string rname = "";
        try
		{
        rname = theProc.MainModule.FileName.Replace("\\??\\","");
        if (File.Exists(rname))
        {
        directoryName=Path.GetDirectoryName(rname);
        }
		}
		catch
		{
		}
		
        theProc.Close();
        
        if (!File.Exists(rname))
        {
        if (Environment.OSVersion.Platform == PlatformID.Win32NT)
        {

        string newname="";
        try
        {
		IntPtr hProcess =
		OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, procEntry.th32ProcessID);
		if (hProcess!=IntPtr.Zero)
		{
      
        PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
         int bytesWritten;
         int result = NtQueryInformationProcess(hProcess,0, ref pbi, (uint)Marshal.SizeOf(pbi),out bytesWritten);
         if (result>=0)  // == 0 is OK
         {
         byte[] peb = new byte[472];
         uint BytesRead=0;
         bool isok = ReadProcessMemory(hProcess,(IntPtr)(pbi.PebBaseAddress),peb,(uint)(peb.Length), ref BytesRead);
         if (isok)
         {
         // this is on all Windows NT version - including Windows 7/Vista
       	 IntPtr AProcessParameters = (IntPtr)BitConverter.ToInt32(peb,016);
         
         byte[] ProcessParameters = new byte[72];
         isok = ReadProcessMemory(hProcess,AProcessParameters,ProcessParameters,(uint)(ProcessParameters.Length), ref BytesRead);  
         if (isok)
         {
         int aCurrentDirectory = BitConverter.ToInt32(ProcessParameters,040);
         byte[] Forread = new byte[2];
         int size=0;
         
         do
         {
         isok = ReadProcessMemory(hProcess,(IntPtr)(aCurrentDirectory+size),Forread,2, ref BytesRead);
         size=size+2;
         }
         while (isok&&Forread[0]!=0);
         size=size-2;
         byte[] CurrentDirectory = new byte[size];
         isok = ReadProcessMemory(hProcess,(IntPtr)(aCurrentDirectory),CurrentDirectory,(uint)size, ref BytesRead);
         newname = System.Text.Encoding.Unicode.GetString(CurrentDirectory);
		 if (newname.Length>=3)
		 {
		 newname = newname.Replace("\\??\\","");
		 directoryName = newname;
		 }
         }
         }

         }
        CloseHandle(hProcess);
        }
        }
        catch
        {
        
        }
        
        }
        }
        

        
 		 // compute size:
         Graphics g = lvprocesslist.CreateGraphics();
         Font objFont = new Font("Microsoft Sans Serif", 8);
         SizeF stringSize = new SizeF();
         stringSize = g.MeasureString(processname, objFont);
         int processlenght = (int)(stringSize.Width+lvprocesslist.Margin.Horizontal*2)+5;
         stringSize = g.MeasureString(directoryName, objFont);
         int directorylenght = (int)(stringSize.Width+lvprocesslist.Margin.Horizontal*2)+40;
         
         if (processlenght>procname.Width)
         {
         procname.Width=processlenght;
         }
         
         if (directorylenght>location.Width)
         {
         location.Width=directorylenght;
         }
         
         string[] prcdetails = new string[]{processname,procEntry.th32ProcessID.ToString(),statut,isnet,directoryName};
         ListViewItem proc = new ListViewItem(prcdetails);
         lvprocesslist.Items.Add(proc);
         
        } while (Process32Next(handleToSnapshot, ref procEntry));
        }
        CloseHandle(handleToSnapshot);
        
        }
        catch
        {
        }
  	
 
         }
		
		void MainFormLoad(object sender, EventArgs e)
		{
		EnableDebuggerPrivileges();
		EnumProcesses();	
		}
		
		[StructLayout(LayoutKind.Sequential, Pack=1)]
		private struct TOKEN_PRIVILEGES
		{
			public int PrivilegeCount;
			public long Luid;
			public int Attributes;
		}
		
		private const int SE_PRIVILEGE_ENABLED = 0x00000002;
		private const int TOKEN_ADJUST_PRIVILEGES = 0x00000020;
		private const int TOKEN_QUERY = 0x00000008;
		
		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int OpenProcessToken(int ProcessHandle, int DesiredAccess, ref int tokenhandle);
		
		[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
		private static extern int GetCurrentProcess();

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int LookupPrivilegeValue(string lpsystemname, string lpname, ref long lpLuid);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int AdjustTokenPrivileges(int tokenhandle, int disableprivs, ref TOKEN_PRIVILEGES Newstate, int bufferlength, int PreivousState, int Returnlength);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int GetSecurityInfo( int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, out IntPtr pDACL, IntPtr pSACL, out IntPtr pSecurityDescriptor);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int SetSecurityInfo( int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, IntPtr pDACL, IntPtr pSACL);

		
		internal void EnableDebuggerPrivileges()
		{
			try
			{
			int token = 0;
			TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES();
			tp.PrivilegeCount = 1;
			tp.Luid = 0;
			tp.Attributes = SE_PRIVILEGE_ENABLED;

			// We just assume this works
			if (OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ref token) == 0)
			return;

			if( LookupPrivilegeValue( null, "SeDebugPrivilege", ref tp.Luid) == 0)
			return;

			if( AdjustTokenPrivileges( token, 0, ref tp, Marshal.SizeOf(tp), 0, 0) == 0)
			return;
			}
			catch
			{
			
			}
		}
		
		

		
		void DumpToolStripMenuItemClick(object sender, EventArgs e)
		{
		DumpProcess();
		}
		
		public int RVA2Offset(byte[] input,int rva)
		{
		int PEOffset=BitConverter.ToInt32(input, 0x3C);
		int nrofsection = (int)BitConverter.ToInt16(input, PEOffset+0x06);
		
		for (int i = 0; i < nrofsection; i++)
        {
        int virtualAddress = BitConverter.ToInt32(input, PEOffset+0x0F8+0x28*i+012);
        int fvirtualsize = BitConverter.ToInt32(input, PEOffset+0x0F8+0x28*i+08);
        int frawAddress = BitConverter.ToInt32(input, PEOffset+0x28*i+0x0F8+20);
        if ((virtualAddress<=rva)&&(virtualAddress + fvirtualsize >= rva))
        return (frawAddress+ (rva - virtualAddress));
		}
		
		return -1;
		}
		
		
		public int Offset2RVA(byte[] input,int offset)
		{
		int PEOffset=BitConverter.ToInt32(input, 0x3C);
		int nrofsection = (int)BitConverter.ToInt16(input, PEOffset+0x06);
		
		for (int i = 0; i < nrofsection; i++)
        {
        int virtualAddress = BitConverter.ToInt32(input, PEOffset+0x0F8+0x28*i+012);
        int virtualsize = BitConverter.ToInt32(input, PEOffset+0x0F8+0x28*i+08);
        int frawAddress = BitConverter.ToInt32(input, PEOffset+0x28*i+0x0F8+20);
        int frawsize = BitConverter.ToInt32(input, PEOffset+0x28*i+0x0F8+16);
        if ((frawAddress<=offset)&&(frawAddress + frawsize >= offset))
        return (virtualAddress+ (offset- frawAddress));
		}
		
		return -1;
		}
		
public unsafe struct image_section_header
{
  public fixed byte name[8];
  public int  virtual_size;
  public int  virtual_address;
  public int  size_of_raw_data;
  public int  pointer_to_raw_data;
  public int  pointer_to_relocations;
  public int  pointer_to_linenumbers;
  public short number_of_relocations;
  public short number_of_linenumbers;
  public int  characteristics;
};
		
public struct IMAGE_FILE_HEADER
{
  public short  Machine;
  public short  NumberOfSections;
  public int TimeDateStamp;
  public int PointerToSymbolTable;
  public int NumberOfSymbols;
  public short  SizeOfOptionalHeader;
  public short  Characteristics;
}



		public bool FixImportandEntryPoint(int dumpVA,byte[] Dump)
		{
		if (Dump==null||Dump.Length==0) return false;
		
		int PEOffset=BitConverter.ToInt32(Dump, 0x3C);
				
        int ImportDirectoryRva = BitConverter.ToInt32(Dump, PEOffset+0x080);
        int impdiroffset = RVA2Offset(Dump,ImportDirectoryRva);
        if (impdiroffset==-1) return false;
        
		byte[] mscoreeAscii = {0x6D, 0x73, 0x63, 0x6F, 0x72, 0x65, 0x65, 0x2E, 0x64, 0x6C, 0x6C, 0x00};
        byte[] CorExeMain = {0x5F, 0x43, 0x6F, 0x72, 0x45, 0x78, 0x65, 0x4D, 0x61, 0x69, 0x6E, 0x00};
        byte[] CorDllMain = {0x5F, 0x43, 0x6F, 0x72, 0x44, 0x6C, 0x6C, 0x4D, 0x61, 0x69, 0x6E, 0x00};
        int ThunkToFix = 0;
        int ThunkData = 0;
        
        byte[] NameKeeper = new byte[mscoreeAscii.Length];
        int current=0;
        int NameRVA = BitConverter.ToInt32(Dump, impdiroffset+current+12);
        while (NameRVA>0)
        {
        int NameOffset = RVA2Offset(Dump,NameRVA);
        if (NameOffset>0)
        {
        try
        {
        bool ismscoree = true;
        for (int i = 0; i < mscoreeAscii.Length; i++)
        {
        if (Dump[NameOffset+i]!=mscoreeAscii[i])
        {
        ismscoree=false;
        break;
        }
        }
        
        if (ismscoree)
        {
        int OriginalFirstThunk = BitConverter.ToInt32(Dump, impdiroffset+current);
        int OriginalFirstThunkfo = RVA2Offset(Dump,OriginalFirstThunk);
        if (OriginalFirstThunkfo>0)
        {
        ThunkData = BitConverter.ToInt32(Dump,OriginalFirstThunkfo);
        int ThunkDatafo = RVA2Offset(Dump,ThunkData);
        if (ThunkDatafo>0)
        {
		ismscoree = true;
        for (int i = 0; i < mscoreeAscii.Length; i++)
        {
        if (Dump[ThunkDatafo+2+i]!=CorExeMain[i]&&Dump[ThunkDatafo+2+i]!=CorDllMain[i])
        {
        ismscoree=false;
        break;
        }
        }
        
        if (ismscoree)
        {
		ThunkToFix = BitConverter.ToInt32(Dump, impdiroffset+current+16);  // FirstThunk;
		break;
        }
        
        }
        }
                
        }
        }
        catch
        {
        }
        
        }
        
        try
        {
		current = current+20; // 20 = size of IMAGE_IMPORT_DESCRIPTOR
		NameRVA = BitConverter.ToInt32(Dump, ImportDirectoryRva+current+12);
        }
        catch
        {
        break;
        }
        }
        
        if (ThunkToFix<=0||ThunkData==0) return false;
        
        int ThunkToFixfo = RVA2Offset(Dump,ThunkToFix);
        if (ThunkToFixfo<0) return false;
        
        BinaryWriter writer = new BinaryWriter(new MemoryStream(Dump));
		int ThunkValue = BitConverter.ToInt32(Dump, ThunkToFixfo);  // old thunk value
        if (ThunkValue<=0||RVA2Offset(Dump,ThunkValue)<0)
        {
        writer.BaseStream.Position=ThunkToFixfo;
        writer.Write(ThunkData);
        }
        
        int EntryPoint = BitConverter.ToInt32(Dump, PEOffset+0x028);
        if (EntryPoint<=0||RVA2Offset(Dump,EntryPoint)<0)
        {
		byte[] ThunkToFixbytes = BitConverter.GetBytes((int)(ThunkToFix+dumpVA));
        for (int i=0;i<Dump.Length-6;i++)
        {
        if (Dump[i+0]==0x0FF&&Dump[i+1]==0x025&&Dump[i+2]==ThunkToFixbytes[0]&&Dump[i+3]==ThunkToFixbytes[1]&&Dump[i+4]==ThunkToFixbytes[2]&&Dump[i+5]==ThunkToFixbytes[3])
        {
        int EntrPointRVA = Offset2RVA(Dump,i);
        writer.BaseStream.Position=PEOffset+0x028;
        writer.Write(EntrPointRVA);
        break;
        }
        }
        }
        
        writer.Close();
        return true;
		}
		
public struct DUMP_DIRECTORIES
{
  public string  root;
  public string  dumps;
  public string  nativedirname;
  public string  sysdirname;
  public string  unknowndirname;
}

public void SetDirectoriesPath(ref DUMP_DIRECTORIES dpmdirs)
{
dpmdirs.dumps = Path.Combine(dpmdirs.root,"Dumps");
dpmdirs.nativedirname = Path.Combine(dpmdirs.dumps,"Native");
dpmdirs.sysdirname = Path.Combine(dpmdirs.dumps,"System");
dpmdirs.unknowndirname = Path.Combine(dpmdirs.dumps,"UnknownName");
}

public bool CreateDirectories(ref DUMP_DIRECTORIES dpmdirs)
{
SetDirectoriesPath(ref dpmdirs);

		if (!Directory.Exists(dpmdirs.dumps))
		{
		try
		{
		System.IO.Directory.CreateDirectory(dpmdirs.dumps);
		}
		catch
		{
System.Windows.Forms.FolderBrowserDialog browse =
new System.Windows.Forms.FolderBrowserDialog();
browse.ShowNewFolderButton = false;
browse.Description="Failed to create the directory - select a new location:";
browse.SelectedPath=dpmdirs.root;

	if (browse.ShowDialog()==System.Windows.Forms.DialogResult.OK)
	{
dpmdirs.root = browse.SelectedPath;
CreateDirectories(ref dpmdirs);
    }
	else
	{
	return false;
	}
	
		}
		}

		
		if (!Directory.Exists(dpmdirs.nativedirname))
		{
		try
		{
		System.IO.Directory.CreateDirectory(dpmdirs.nativedirname);
		}
		catch
		{
System.Windows.Forms.FolderBrowserDialog browse =
new System.Windows.Forms.FolderBrowserDialog();
browse.ShowNewFolderButton = false;
browse.Description="Failed to create the directory - select a new location:";
browse.SelectedPath=dpmdirs.root;

	if (browse.ShowDialog()==System.Windows.Forms.DialogResult.OK)
	{
dpmdirs.root = browse.SelectedPath;
CreateDirectories(ref dpmdirs);
    }
	else
	{
	return false;
	}
	
		}
		}

		
		if (!Directory.Exists(dpmdirs.sysdirname))
		{
		try
		{
		System.IO.Directory.CreateDirectory(dpmdirs.sysdirname);
		}
		catch
		{
System.Windows.Forms.FolderBrowserDialog browse =
new System.Windows.Forms.FolderBrowserDialog();
browse.ShowNewFolderButton = false;
browse.Description="Failed to create the directory - select a new location:";
browse.SelectedPath=dpmdirs.root;

	if (browse.ShowDialog()==System.Windows.Forms.DialogResult.OK)
	{
dpmdirs.root = browse.SelectedPath;
CreateDirectories(ref dpmdirs);
    }
	else
	{
	return false;
	}
	
		}
		}
		
		
		if (!Directory.Exists(dpmdirs.unknowndirname))
		{
		try
		{
		System.IO.Directory.CreateDirectory(dpmdirs.unknowndirname);
		}
		catch
		{
System.Windows.Forms.FolderBrowserDialog browse =
new System.Windows.Forms.FolderBrowserDialog();
browse.ShowNewFolderButton = false;
browse.Description="Failed to create the directory - select a new location:";
browse.SelectedPath=dpmdirs.root;

	if (browse.ShowDialog()==System.Windows.Forms.DialogResult.OK)
	{
dpmdirs.root = browse.SelectedPath;
CreateDirectories(ref dpmdirs);
    }
	else
	{
	return false;
	}
	
		}
		}

		return true;
}

		unsafe void DumpProcess()
		{
if (lvprocesslist.SelectedIndices.Count==0)
return;

		int intselectedindex = lvprocesslist.SelectedIndices[0]; 
		if (intselectedindex!=-1)
		{
		UInt32 processId = Convert.ToUInt32(lvprocesslist.Items[intselectedindex].SubItems[1].Text);
		
		IntPtr hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, processId);
		
		if( hProcess == IntPtr.Zero)
		{
		IntPtr pDACL, pSecDesc;

		GetSecurityInfo( (int) Process.GetCurrentProcess().Handle, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
		hProcess = OpenProcess( 0x40000, 0, processId);
		SetSecurityInfo( (int) hProcess, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4 | /*UNPROTECTED_DACL_SECURITY_INFORMATION*/ 0x20000000, 0, 0, pDACL, IntPtr.Zero);
		CloseHandle( hProcess);
		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, processId);
		}

		if( hProcess != IntPtr.Zero)
		{
		uint minaddress = 0;
		uint maxaddress = 0xF0000000;
		uint pagesize = 0x1000;
		
		try
		{
		SYSTEM_INFO pSI = new SYSTEM_INFO();
		GetSystemInfo(ref pSI);
		minaddress = pSI.lpMinimumApplicationAddress;
		maxaddress = pSI.lpMaximumApplicationAddress;
		pagesize = pSI.dwPageSize;
		}
		catch
		{
		}

		int CurrentCount=1;
		string dirname = lvprocesslist.Items[intselectedindex].SubItems[4].Text;
		if (dirname.Length<2||!Directory.Exists(dirname))
		dirname="C:\\";
		
		//StartOfDirCreation1:
		DUMP_DIRECTORIES ddirs = new MainForm.DUMP_DIRECTORIES();
		ddirs.root = dirname;
		CreateDirectories(ref ddirs);
		
		//dirname = Path.Combine(dirname,"Dumps");
		//string nativedirname = Path.Combine(dirname,"Native");	
		//string sysdirname = Path.Combine(dirname,"System");
		//string unknowndirname = Path.Combine(dirname,"UnknownName");
	
		
		bool isok;
		byte[] onepage = new byte[pagesize];
		uint BytesRead=0;
		byte[] infokeep = new byte[8];
	
		for (uint j = minaddress; j < maxaddress; j+= pagesize)
    	{
		
		isok = ReadProcessMemory(hProcess,j,onepage,pagesize, ref BytesRead);

		if (isok)
		{
		for (int k = 0; k < onepage.Length - 2; k++)
        {

		    if (onepage[k]==0x4D&&onepage[k+1]==0x5A)
            {
		    if (ReadProcessMemory(hProcess,(uint)(j+k+0x03C),infokeep,4, ref BytesRead))
		    {
		    int PEOffset=BitConverter.ToInt32(infokeep, 0);
		    if (PEOffset>0&&(PEOffset+0x0120)<pagesize)
		    {
		    if (ReadProcessMemory(hProcess,(uint)(j+k+PEOffset),infokeep,2, ref BytesRead))
		    {
		    if (infokeep[0]==0x050&&infokeep[1]==0x045)
		    {
long NetMetadata = 0;
if (ReadProcessMemory(hProcess,(uint)(j+k+PEOffset+0x0E8),infokeep,8, ref BytesRead))
NetMetadata = BitConverter.ToInt64(infokeep,0);

if (dumpNativeToolStripMenuItem.Checked||NetMetadata!=0)
		    {
byte[] PeHeader = new byte[pagesize];
if (ReadProcessMemory(hProcess,(uint)(j+k),PeHeader,pagesize, ref BytesRead))
{
int nrofsection = (int)BitConverter.ToInt16(PeHeader, PEOffset+0x06);
if (nrofsection>0)
{
bool isNetFile = true;
string dumpdir = "";
//string dumpdir = ddirs.dumps;
if (NetMetadata==0)
isNetFile = false;

int sectionalignment = BitConverter.ToInt32(PeHeader, PEOffset+0x038);
int filealignment = BitConverter.ToInt32(PeHeader, PEOffset+0x03C);
short sizeofoptionalheader = BitConverter.ToInt16(PeHeader, PEOffset+0x014);

bool IsDll = false;
if ((PeHeader[PEOffset+0x017]&32)!=0) IsDll = true;
IntPtr pointer = IntPtr.Zero;
image_section_header[] sections = new image_section_header[nrofsection];
uint ptr = (uint)(j+k+PEOffset)+(uint)sizeofoptionalheader+4+
	(uint)Marshal.SizeOf(typeof(IMAGE_FILE_HEADER));

for (int i = 0; i < nrofsection; i++)
{
byte[] datakeeper = new byte[Marshal.SizeOf(typeof(image_section_header))];
ReadProcessMemory(hProcess,ptr,datakeeper,(uint)datakeeper.Length, ref BytesRead);
fixed (byte* p = datakeeper)
{
pointer = (IntPtr)p;
}
		
sections[i] = (image_section_header)Marshal.PtrToStructure(pointer, typeof(image_section_header));
ptr = ptr+(uint)Marshal.SizeOf(typeof(image_section_header));
}



// get total raw size (of all sections):
int totalrawsize = 0;
int rawsizeoflast = sections[nrofsection-1].size_of_raw_data;
int rawaddressoflast = sections[nrofsection-1].pointer_to_raw_data;
if (rawsizeoflast>0&&rawaddressoflast>0)
totalrawsize = rawsizeoflast+rawaddressoflast;
string filename = "";

// calculate right size of image
int actualsizeofimage = BitConverter.ToInt32(PeHeader, PEOffset+0x050);
int sizeofimage = actualsizeofimage;
int calculatedimagesize = BitConverter.ToInt32(PeHeader, PEOffset+0x0F8+012);
int rawsize,rawAddress,virtualsize,virtualAddress=0;
int calcrawsize=0;

for (int i = 0; i < nrofsection; i++)
{
virtualsize = sections[i].virtual_size;
int toadd = (virtualsize%sectionalignment);
if (toadd!=0) toadd = sectionalignment-toadd;
calculatedimagesize = calculatedimagesize+virtualsize+toadd;
}

if (calculatedimagesize>sizeofimage) sizeofimage=calculatedimagesize;

try
{
byte[] crap = new byte[totalrawsize];
}
catch
{
totalrawsize = sizeofimage;
}

if (totalrawsize!=0)
{
try
{
byte[] rawdump = new byte[totalrawsize];
isok = ReadProcessMemory(hProcess,(uint)(j+k),rawdump,(uint)rawdump.Length, ref BytesRead);
if (isok)
{

CreateTheFile1:
dumpdir = ddirs.nativedirname;
if (isNetFile)
dumpdir = ddirs.dumps;

filename = dumpdir+"\\rawdump_"+(j+k).ToString("X8");
if (File.Exists(filename))
filename = dumpdir+"\\rawdump"+CurrentCount.ToString()+"_"+(j+k).ToString("X8");


if (IsDll)
filename=filename+".dll";
else
filename=filename+".exe";

try
{
File.WriteAllBytes(filename,rawdump);
}
catch
{
System.Windows.Forms.FolderBrowserDialog browse =
new System.Windows.Forms.FolderBrowserDialog();
browse.ShowNewFolderButton = false;
browse.Description="Failed to create the file - select a new location:";
browse.SelectedPath=ddirs.root;

	if (browse.ShowDialog()==System.Windows.Forms.DialogResult.OK)
	{
ddirs.root = browse.SelectedPath;
CreateDirectories(ref ddirs);
    }
	else
	{
	return;
	}
goto CreateTheFile1;
}

CurrentCount++;

}
}
catch
{
}
}



byte[] virtualdump = new byte[sizeofimage];
Array.Copy(PeHeader,virtualdump,pagesize);

int rightrawsize = 0;
	for (int l = 0; l < nrofsection; l++)
	{
	rawsize = sections[l].size_of_raw_data;
	rawAddress = sections[l].pointer_to_raw_data;
	virtualsize = sections[l].virtual_size;
	virtualAddress = sections[l].virtual_address;
	
	// RawSize = Virtual Size rounded on FileAlligment
	calcrawsize=0;
	calcrawsize = virtualsize%filealignment;
	if (calcrawsize!=0) calcrawsize = filealignment-calcrawsize;
	calcrawsize = virtualsize+calcrawsize;

	if (calcrawsize!=0&&rawsize!=calcrawsize&&rawsize!=virtualsize
	   ||rawAddress<0)
	{
	// if raw size is bad:
	rawsize = virtualsize;
	rawAddress = virtualAddress;
	BinaryWriter writer = new BinaryWriter(new MemoryStream(virtualdump));
	writer.BaseStream.Position=PEOffset+0x0F8+0x28*l+16;
	writer.Write(virtualsize);
	writer.BaseStream.Position=PEOffset+0x0F8+0x28*l+20;
	writer.Write(virtualAddress);
	writer.Close();
	}
	
	byte[] csection = new byte[0];
	try
	{
	csection = new byte[rawsize];
	}
	catch
	{
	csection = new byte[virtualsize];
	}
	int rightsize = csection.Length;
	isok = ReadProcessMemory(hProcess,(uint)(j+k+virtualAddress),csection,(uint)rawsize, ref BytesRead);
	if (!isok||BytesRead!=rawsize)
	{
	rightsize = 0;
	byte[] currentpage = new byte[pagesize];
	for (int c = 0; c < rawsize; c=c+(int)pagesize)
	{
// some section have a houge size so : try
try
{
isok = ReadProcessMemory(hProcess,(uint)(j+k+virtualAddress+c),currentpage,(uint)pagesize, ref BytesRead);
}
catch
{
break;
}

if (isok)
{
rightsize = rightsize+(int)pagesize;
for (int i=0;i<pagesize;i++)
{
if ((c+i)<csection.Length)
csection[c+i]=currentpage[i];
}
}


	}
	}
    
	
	try
	{
	Array.Copy(csection, 0, virtualdump, rawAddress, rightsize);
	}
	catch
	{
	}
	
	if (l==nrofsection-1)
	{
	rightrawsize = rawAddress+rawsize;
	}
	
    }

FixImportandEntryPoint((int)(j+k),virtualdump);

CreateTheFile2:
dumpdir = ddirs.nativedirname;
if (isNetFile)
dumpdir = ddirs.dumps;

filename = dumpdir+"\\vdump_"+(j+k).ToString("X8");
if (File.Exists(filename))
filename = dumpdir+"\\vdump"+CurrentCount.ToString()+"_"+(j+k).ToString("X8");

if (IsDll)
filename=filename+".dll";
else
filename=filename+".exe";

FileStream fout = null;


try
{
fout = new FileStream(filename, FileMode.Create);
}
catch
{
System.Windows.Forms.FolderBrowserDialog browse =
new System.Windows.Forms.FolderBrowserDialog();
browse.ShowNewFolderButton = false;
browse.Description="Failed to create the file - select a new location:";
browse.SelectedPath=ddirs.root;

	if (browse.ShowDialog()==System.Windows.Forms.DialogResult.OK)
	{
ddirs.root = browse.SelectedPath;
CreateDirectories(ref ddirs);
    }
	else
	{
	return;
	}
goto CreateTheFile2;
}

if (fout!=null)
{
if (rightrawsize>virtualdump.Length) rightrawsize=virtualdump.Length;

fout.Write(virtualdump,0,rightrawsize);
fout.Close();
}
CurrentCount++;




}
}


            // dumping end here
		    }
		    }
		    }
		    }
		    }
            }
	
		}
		}


		}
		
		if (!dontRestoreFilenameToolStripMenuItem.Checked)
		{

		
		// rename files:
		if (Directory.Exists(ddirs.dumps))
		{
		DirectoryInfo di = new DirectoryInfo(ddirs.dumps);
		FileInfo[] rgFiles = di.GetFiles();
 
		foreach(FileInfo fi in rgFiles)
		{
string placedir = ddirs.dumps;
FileVersionInfo info = FileVersionInfo.GetVersionInfo(fi.FullName);
if (info.CompanyName!=null&&info.CompanyName.ToLower().Contains("microsoft corporation")
   &&(info.ProductName.ToLower().Contains(".net framework")||
   info.FileDescription.ToLower().Contains("runtime library")
  ))
{
placedir = ddirs.sysdirname;
}
if (info.OriginalFilename!=null&&info.OriginalFilename!="")
{
string Newfilename=Path.Combine(placedir,info.OriginalFilename);
int count = 2;
if (File.Exists(Newfilename))
{
string extension = Path.GetExtension(Newfilename);
if (extension=="") extension = ".dll";
do
{
Newfilename = placedir+"\\"+Path.GetFileNameWithoutExtension(info.OriginalFilename)
	+"("+count.ToString()+")"+extension;
		
count++;
}
while (File.Exists(Newfilename));
}

System.IO.File.Move(fi.FullName,Newfilename);
}
else
{
string Newfilename = Path.Combine(ddirs.unknowndirname,fi.Name);
int count = 2;
if (File.Exists(Newfilename))
{
string extension = Path.GetExtension(fi.Name);

do
{
Newfilename = ddirs.unknowndirname+"\\"+Path.GetFileNameWithoutExtension(fi.Name)
	+"("+count.ToString()+")"+extension;
		
count++;
}
while (File.Exists(Newfilename));
}

System.IO.File.Move(fi.FullName,Newfilename);
}


		}
		}
		
		// rename files:
		if (Directory.Exists(ddirs.nativedirname))
		{
		DirectoryInfo di = new DirectoryInfo(ddirs.nativedirname);
		FileInfo[] rgFiles = di.GetFiles();
 
		foreach(FileInfo fi in rgFiles)
		{
FileVersionInfo info = FileVersionInfo.GetVersionInfo(fi.FullName);
if (info.OriginalFilename!=null&&info.OriginalFilename!="")
{
string Newfilename=Path.Combine(ddirs.nativedirname,info.OriginalFilename);
int count = 2;
if (File.Exists(Newfilename))
{
string extension = Path.GetExtension(Newfilename);
if (extension=="") extension = ".dll";
do
{
Newfilename = ddirs.nativedirname+"\\"+Path.GetFileNameWithoutExtension(info.OriginalFilename)
	+"("+count.ToString()+")"+extension;
		
count++;
}
while (File.Exists(Newfilename));
}

System.IO.File.Move(fi.FullName,Newfilename);
}
		}
		}
		}
		CurrentCount--;
		MessageBox.Show(CurrentCount.ToString()+" files dumped in directory "+ddirs.dumps,"Success!",0,MessageBoxIcon.Information);

		}
		else
		{
		MessageBox.Show("Failed to open selected process!","Error!",0,MessageBoxIcon.Error);
		}
		CloseHandle(hProcess);
		}
		}
		
		

		
		void CopyToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count>0)
{	
string strtoset = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[4].Text;
if (strtoset!="") Clipboard.SetText(strtoset);
}
}
		
		void DumpModuleToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count==0)
return;

		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		string dirname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[4].Text;
		if (strprname!="")
		{
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		FrmModules pmodfrm = new FrmModules(strprname,procid,dirname);
		pmodfrm.Show();
		}

		}
		
		void Button3Click(object sender, EventArgs e)
		{
		ProcessManager prman = new ProcessManager();
		prman.Show();
		}

		void GotoLocationToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count==0)
return;
	
string dirname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[4].Text;
string filename = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
string fullfilename = Path.Combine(dirname,filename);
if (Directory.Exists(dirname))
{
try
{
string argument = @"/select, " + fullfilename;
System.Diagnostics.Process.Start("explorer.exe", argument);
}
catch
{
}

}
		}
		
		void ToolStripMenuItem2Click(object sender, EventArgs e)
		{
			
		}
		
[DllImport("kernel32.dll", SetLastError=true)]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool TerminateProcess(IntPtr hProcess, uint uExitCode);

		void KillProcessToolStripMenuItemClick(object sender, EventArgs e)
		{
		int intselectedindex = lvprocesslist.SelectedIndices[0]; 
		if (intselectedindex!=-1)
		{
		UInt32 processId = Convert.ToUInt32(lvprocesslist.Items[intselectedindex].SubItems[1].Text);
		IntPtr hProcess = OpenProcess(PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, processId);
		
		if( hProcess == IntPtr.Zero)
		{
		IntPtr pDACL, pSecDesc;

		GetSecurityInfo( (int) Process.GetCurrentProcess().Handle, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
		hProcess = OpenProcess( 0x40000, 0, processId);
		SetSecurityInfo( (int) hProcess, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4 | /*UNPROTECTED_DACL_SECURITY_INFORMATION*/ 0x20000000, 0, 0, pDACL, IntPtr.Zero);
		CloseHandle( hProcess);
		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, processId);
		}
		
		try
		{
		TerminateProcess(hProcess,0);
		}
		catch
		{
		}
		CloseHandle( hProcess);
		
		}
		}
		
[DllImport("ntdll.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool ZwSuspendProcess(IntPtr hProcess);

[DllImport("ntdll.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool ZwResumeProcess(IntPtr hProcess);


		void SuspendProcessToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count==0)
return;

		int intselectedindex = lvprocesslist.SelectedIndices[0]; 
		if (intselectedindex!=-1)
		{
		UInt32 processId = Convert.ToUInt32(lvprocesslist.Items[intselectedindex].SubItems[1].Text);
		IntPtr hProcess = OpenProcess(0x800, 0, processId);
		
		if( hProcess == IntPtr.Zero)
		{
		IntPtr pDACL, pSecDesc;

		GetSecurityInfo( (int) Process.GetCurrentProcess().Handle, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
		hProcess = OpenProcess( 0x40000, 0, processId);
		SetSecurityInfo( (int) hProcess, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4 | /*UNPROTECTED_DACL_SECURITY_INFORMATION*/ 0x20000000, 0, 0, pDACL, IntPtr.Zero);
		CloseHandle( hProcess);
		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, processId);
		}
		
		try
		{
		ZwSuspendProcess(hProcess);
		}
		catch
		{
		}
		CloseHandle( hProcess);
		
		}
		}
		
		void ResumeProcessToolStripMenuItemClick(object sender, EventArgs e)
		{
		int intselectedindex = lvprocesslist.SelectedIndices[0]; 
		if (intselectedindex!=-1)
		{
		UInt32 processId = Convert.ToUInt32(lvprocesslist.Items[intselectedindex].SubItems[1].Text);
		IntPtr hProcess = OpenProcess(0x800, 0, processId);
		
		if( hProcess == IntPtr.Zero)
		{
		IntPtr pDACL, pSecDesc;

		GetSecurityInfo( (int) Process.GetCurrentProcess().Handle, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
		hProcess = OpenProcess( 0x40000, 0, processId);
		SetSecurityInfo( (int) hProcess, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4 | /*UNPROTECTED_DACL_SECURITY_INFORMATION*/ 0x20000000, 0, 0, pDACL, IntPtr.Zero);
		CloseHandle( hProcess);
		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, 0, processId);
		}
		
		try
		{
		ZwResumeProcess(hProcess);
		}
		catch
		{
		}
		CloseHandle( hProcess);
		
		}
		}

		
		void CheckBox3CheckedChanged(object sender, EventArgs e)
		{
timer1.Stop();
timer1.Dispose();
timer1 = null;


if (timer1==null)
{
timer1 = new Timer();
timer1.Interval = 100;
timer1.Enabled = true;
timer1.Tick += new System.EventHandler (OnTimerEvent);
}



		}


[DllImport("user32.dll")]
public static extern Int32 SetForegroundWindow(IntPtr hWnd);

[DllImport("user32.dll", SetLastError=true)]
static extern uint GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);

[DllImport("user32.dll")]
static extern bool CloseWindow(IntPtr hWnd);

public enum ShowWindowCommand : int
{
    /// <summary>
    /// Hides the window and activates another window.
    /// </summary>
    Hide = 0,
    /// <summary>
    /// Activates and displays a window. If the window is minimized or
    /// maximized, the system restores it to its original size and position.
    /// An application should specify this flag when displaying the window
    /// for the first time.
    /// </summary>
    Normal = 1,
    /// <summary>
    /// Activates the window and displays it as a minimized window.
    /// </summary>
    ShowMinimized = 2,
    /// <summary>
    /// Maximizes the specified window.
    /// </summary>
    Maximize = 3, // is this the right value?
    /// <summary>
    /// Activates the window and displays it as a maximized window.
    /// </summary>      
    ShowMaximized = 3,
    /// <summary>
    /// Displays a window in its most recent size and position. This value
    /// is similar to <see cref="Win32.ShowWindowCommand.Normal"/>, except
    /// the window is not actived.
    /// </summary>
    ShowNoActivate = 4,
    /// <summary>
    /// Activates the window and displays it in its current size and position.
    /// </summary>
    Show = 5,
    /// <summary>
    /// Minimizes the specified window and activates the next top-level
    /// window in the Z order.
    /// </summary>
    Minimize = 6,
    /// <summary>
    /// Displays the window as a minimized window. This value is similar to
    /// <see cref="Win32.ShowWindowCommand.ShowMinimized"/>, except the
    /// window is not activated.
    /// </summary>
    ShowMinNoActive = 7,
    /// <summary>
    /// Displays the window in its current size and position. This value is
    /// similar to <see cref="Win32.ShowWindowCommand.Show"/>, except the
    /// window is not activated.
    /// </summary>
    ShowNA = 8,
    /// <summary>
    /// Activates and displays the window. If the window is minimized or
    /// maximized, the system restores it to its original size and position.
    /// An application should specify this flag when restoring a minimized window.
    /// </summary>
    Restore = 9,
    /// <summary>
    /// Sets the show state based on the SW_* value specified in the
    /// STARTUPINFO structure passed to the CreateProcess function by the
    /// program that started the application.
    /// </summary>
    ShowDefault = 10,
    /// <summary>
    ///  <b>Windows 2000/XP:</b> Minimizes a window, even if the thread
    /// that owns the window is not responding. This flag should only be
    /// used when minimizing windows from a different thread.
    /// </summary>
    ForceMinimize = 11
}

[DllImport("user32.dll")]
static extern bool ShowWindow(IntPtr hWnd, ShowWindowCommand nCmdShow);

[DllImport("user32.dll")]
private static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow); 

[DllImport("user32.dll", EntryPoint="SystemParametersInfo")]
public static extern bool SystemParametersInfo(uint uiAction, uint uiParam, uint pvParam, uint fWinIni);


void BringToFrontToolStripMenuItemClick(object sender, EventArgs e)
{
if (lvprocesslist.SelectedIndices.Count>0)
{	
string strwhitpid = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text;
int processpid = System.Convert.ToInt32(strwhitpid, 10);

EnumWindows eW = new EnumWindows();
eW.GetWindows();
foreach (EnumWindowsItem item in eW.Items)
{
if (item.Visible)
{
int currentpid = 0;
uint threadid = GetWindowThreadProcessId(item.Handle,out currentpid);
if (currentpid==processpid)
{
  // SPI_SETFOREGROUNDLOCKTIMEOUT = 0x2001
SystemParametersInfo( (uint) 0x2001, 0, 0, 0x0002 | 0x0001);
ShowWindowAsync(item.Handle, 3);
SetForegroundWindow(item.Handle);
SystemParametersInfo( (uint) 0x2001, 200000, 200000, 0x0002 | 0x0001);

}
}
}
}


}

		
		void RestoreToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count==0)
return;

string strwhitpid = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text;
int processpid = System.Convert.ToInt32(strwhitpid, 10);

EnumWindows eW = new EnumWindows();
eW.GetWindows();
foreach (EnumWindowsItem item in eW.Items)
{
if (item.Visible)
{
int currentpid = 0;
uint threadid = GetWindowThreadProcessId(item.Handle,out currentpid);
if (currentpid==processpid)
{
ShowWindow(item.Handle, ShowWindowCommand.Restore);
}
}
}
}

	
void MinimizeToolStripMenuItemClick(object sender, EventArgs e)
{
if (lvprocesslist.SelectedIndices.Count==0)
return;

string strwhitpid = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text;
int processpid = System.Convert.ToInt32(strwhitpid, 10);

EnumWindows eW = new EnumWindows();
eW.GetWindows();
foreach (EnumWindowsItem item in eW.Items)
{
if (item.Visible)
{
int currentpid = 0;
uint threadid = GetWindowThreadProcessId(item.Handle,out currentpid);
if (currentpid==processpid)
{
ShowWindow(item.Handle, ShowWindowCommand.Minimize);
}
}
}
}

		
		void MaximizeToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count==0)
return;

string strwhitpid = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text;
int processpid = System.Convert.ToInt32(strwhitpid, 10);

EnumWindows eW = new EnumWindows();
eW.GetWindows();
foreach (EnumWindowsItem item in eW.Items)
{
if (item.Visible)
{
int currentpid = 0;
uint threadid = GetWindowThreadProcessId(item.Handle,out currentpid);
if (currentpid==processpid)
{
ShowWindow(item.Handle, ShowWindowCommand.Maximize);
}
}
}
		}
		
		void CloseToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count==0)
return;

string strwhitpid = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text;
int processpid = System.Convert.ToInt32(strwhitpid, 10);

EnumWindows eW = new EnumWindows();
eW.GetWindows();
foreach (EnumWindowsItem item in eW.Items)
{
if (item.Visible)
{
int currentpid = 0;
uint threadid = GetWindowThreadProcessId(item.Handle,out currentpid);
if (currentpid==processpid)
{
CloseWindow(item.Handle);
}
}
}
		}
		

		

		
public enum ProcessPriorities : uint
{
      Above_Normal = 0x00008000, //Process that has priority above NORMAL_PRIORITY_CLASS but below HIGH_PRIORITY_CLASS.
      Below_Normal = 0x00004000, //Process that has priority above IDLE_PRIORITY_CLASS but below NORMAL_PRIORITY_CLASS.
      High = 0x00000080,         //Process that performs time-critical tasks that must be executed immediately for it to run correctly. The threads of a high-priority class process preempt the threads of normal or idle priority class processes. An example is the Task List, which must respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a high-priority class CPU-bound application can use nearly all available cycles.
      Idle = 0x00000040,         //Process whose threads run only when the system is idle and are preempted by the threads of any process running in a higher priority class. An example is a screen saver. The idle priority class is inherited by child processes.
      Normal = 0x00000020,       //Process with no special scheduling needs.
      Real_Time = 0x00000100      //Process that has the highest possible priority. The threads of a real-time priority class process preempt the threads of all other processes, including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches not to flush or cause the mouse to be unresponsive.
}

[DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true)]
public static extern ProcessPriorities GetPriorityClass(IntPtr handle);

[DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true)]
public static extern bool SetPriorityClass(IntPtr handle, ProcessPriorities priority);

void PriorityToolStripMenuItemClick(object sender, EventArgs e)
{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
IntPtr hProcess =
OpenProcess(PROCESS_QUERY_INFORMATION, 0, (uint)procid);
if (hProcess!=IntPtr.Zero)
{
ProcessPriorities cpriority = GetPriorityClass(hProcess);
switch (cpriority)
{
    case ProcessPriorities.Real_Time: 
        rttoolStripMenuItem.Checked = true;
        
        hToolStripMenuItem.Checked = false;
        anToolStripMenuItem.Checked = false;
        nToolStripMenuItem.Checked = false;
        bnToolStripMenuItem.Checked = false;
        iToolStripMenuItem.Checked = false;
        break;
    case ProcessPriorities.High:
        hToolStripMenuItem.Checked = true;
        
        rttoolStripMenuItem.Checked = false;
        anToolStripMenuItem.Checked = false;
        nToolStripMenuItem.Checked = false;
        bnToolStripMenuItem.Checked = false;
        iToolStripMenuItem.Checked = false;
        break;
    case ProcessPriorities.Above_Normal:
        anToolStripMenuItem.Checked = true;
        
        rttoolStripMenuItem.Checked = false;
        hToolStripMenuItem.Checked = false;
        nToolStripMenuItem.Checked = false;
        bnToolStripMenuItem.Checked = false;
        iToolStripMenuItem.Checked = false; 
    	break;
    case ProcessPriorities.Normal:
        nToolStripMenuItem.Checked = true;
        
        rttoolStripMenuItem.Checked = false;
        hToolStripMenuItem.Checked = false;
        anToolStripMenuItem.Checked = false;
        bnToolStripMenuItem.Checked = false;
        iToolStripMenuItem.Checked = false;
    	break;
    case ProcessPriorities.Below_Normal:
        bnToolStripMenuItem.Checked = true;
        
        rttoolStripMenuItem.Checked = false;
        hToolStripMenuItem.Checked = false;
        anToolStripMenuItem.Checked = false;
        nToolStripMenuItem.Checked = false;
        iToolStripMenuItem.Checked = false;
    	break;
    case ProcessPriorities.Idle:
        iToolStripMenuItem.Checked = true;
        
        rttoolStripMenuItem.Checked = false;
        hToolStripMenuItem.Checked = false;
        anToolStripMenuItem.Checked = false;
        nToolStripMenuItem.Checked = false;
        bnToolStripMenuItem.Checked = false;
    	break;
    default:
        break;
}

CloseHandle(hProcess);
}

}
	
}
//ProcessPriorities retuened = 
}


void ToolStripMenuItem3Click(object sender, EventArgs e)
{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
IntPtr hProcess =
OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION, 0, (uint)procid);
if (hProcess!=IntPtr.Zero)
{
if (SetPriorityClass(hProcess, ProcessPriorities.Real_Time))
{
rttoolStripMenuItem.Checked = true;
}
}
}
}
}
		
void HToolStripMenuItemClick(object sender, EventArgs e)
{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
IntPtr hProcess =
OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION, 0, (uint)procid);
if (hProcess!=IntPtr.Zero)
{
if (SetPriorityClass(hProcess, ProcessPriorities.High))
{
hToolStripMenuItem.Checked = true;
}
}
}
}
		}
		
		void AnToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
IntPtr hProcess =
OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION, 0, (uint)procid);
if (hProcess!=IntPtr.Zero)
{
if (SetPriorityClass(hProcess, ProcessPriorities.Above_Normal))
{
anToolStripMenuItem.Checked = true;
}
}
}
}
		}
		
		void NToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
IntPtr hProcess =
OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION, 0, (uint)procid);
if (hProcess!=IntPtr.Zero)
{
if (SetPriorityClass(hProcess, ProcessPriorities.Normal))
{
nToolStripMenuItem.Checked = true;
}
}
}
}
		}
		
		void BnToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
IntPtr hProcess =
OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION, 0, (uint)procid);
if (hProcess!=IntPtr.Zero)
{
if (SetPriorityClass(hProcess, ProcessPriorities.Below_Normal))
{
bnToolStripMenuItem.Checked = true;
}
}
}
}
		}
		
		void IToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
IntPtr hProcess =
OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION, 0, (uint)procid);
if (hProcess!=IntPtr.Zero)
{
if (SetPriorityClass(hProcess, ProcessPriorities.Idle))
{
iToolStripMenuItem.Checked = true;
}
}
}
}
		}
		

		

		void TestToolStripMenuItemClick(object sender, EventArgs e)
		{
		EnumProcesses();
		}
		
		void ExitToolStripMenuItemClick(object sender, EventArgs e)
		{
		Application.Exit();
		}
		
		
		void AboutToolStripMenuItemClick(object sender, EventArgs e)
		{
		AboutForm abf = new AboutForm();
		abf.Show();
		}
		
		void ProcessManagerToolStripMenuItemClick(object sender, EventArgs e)
		{
		ProcessManager prman = new ProcessManager();
		prman.Show();
		}
		
		void WindowsHoocksToolStripMenuItemClick(object sender, EventArgs e)
		{
	ViewWindowsHoocks wwh = new ViewWindowsHoocks();
	wwh.Show();
		}
		
		
		void InstalledFrameworkToolStripMenuItemClick(object sender, EventArgs e)
		{
		InstalledFramework insfr = new InstalledFramework();
		insfr.Show();
		}
		


		
		void VirtualMemoryToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		VirtualMemoryView vmv = new VirtualMemoryView(procid,strprname);
		vmv.Show();

		}
		}
		
		void EnumAppdomainsToolStripMenuItemClick(object sender, EventArgs e)
		{
if (lvprocesslist.SelectedIndices.Count>0)
{
int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
if (procid!=0)
{
EnumAppDomains enumasm = new EnumAppDomains(procid);
enumasm.Show();
}
}

		}
		
		void HookDetectionToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		if (strprname!="")
		{
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		EmptyForm hdet = new EmptyForm(strprname,procid,1);
		hdet.Show();
		}
		}
		}
		
		void EnvironmentVariablesToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		EmptyForm envenum = new EmptyForm(strprname,procid,2);
		envenum.Show();

		}
		}
		

		
		void ViewHeapToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		if (strprname!="")
		{
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		if ((uint)(procid)==HeapHealper.GetCurrentProcessId())
		{
MessageBox.Show("Can't enumerate heap for MegaDumper itself!","Error",MessageBoxButtons.OK,MessageBoxIcon.Error);

		}
		else
		{
		HeapView hw = new HeapView(strprname,procid);
		hw.Show();
		}
		}

		}
		}
		
		void NETPerformanceToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		if (strprname!="")
		{
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		NetPerformance np = new NetPerformance(strprname,procid);
		np.Show();

		}
		}
		}
		

		
		void GenerateDmpToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		string dirname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[4].Text;
		if (strprname!="")
		{
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		GenerateDmp pmodfrm = new GenerateDmp(strprname,procid,dirname);
		pmodfrm.Show();
		}
		}
		}
		

		
		void FileDirectoriesListToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		EmptyForm envenum = new EmptyForm(strprname,procid,3);
		envenum.Show();

		}
		}
		
		void InjectManagedDllToolStripMenuItemClick(object sender, EventArgs e)
		{
		if (lvprocesslist.SelectedIndices.Count>0)
		{
		string strprname = lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[0].Text;
		int procid = int.Parse(lvprocesslist.Items[lvprocesslist.SelectedIndices[0]].SubItems[1].Text);
		MegaDumper.ManagedInjector maninject = new MegaDumper.ManagedInjector(strprname,procid);
		maninject.Show();

		}
		}
}
}



================================================
File: MegaDumper/MainForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="contextMenuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>8, 19</value>
  </metadata>
  <metadata name="menuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>158, 19</value>
  </metadata>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>93</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAIAMDAAAAEACACoDgAAJgAAABAQAAABAAgAaAUAAM4OAAAoAAAAMAAAAGAAAAABAAgAAAAAAAAJ
        AAAAAAAAAAAAAAABAAAAAQAAAAAAAAcHBQAHBw4ACgoKAA0MCwALDAwADQ0MAA8QDwAQDxAAEBAQABQT
        FAAUFBQAGRkZABwbGwAdHR0AHyAgACEhIQAlJSUAKywmACoqKgAtLC0AMTEwADQ0MwA3NzYAODc3ADk5
        OQA9PT0AHh1HAA0MbAAFBX4AQUFBAEZFQwBFREQASEhGAElISABNTk0AUVFRAFRTUABVVVUAYGBbAGFf
        YQBjY2MAZ2ZjAGRkZABpaWkAbWtrAG5ubQBycnIAcnJ0AHl1dAB4eHgAfX19AA4NgQAMDIwAEBCBABIS
        lwAuL4sAPT2AAD4+hAA1M5IAFBOmABcWswAYF7IAHBq+AFRUlgB0c5UAU1OiAFlZtgB7e6oAFxjBABsa
        wAAdHMIAIyLEACAgyQAiI84AJCXRACgo0wArK9UAKCnZAD8/2ABGR9QASEnYAFRV1ABWVdwAYWLkAIiH
        hQCOiocAjYyLAIuLjACNjY0AkYyLAJKOjACSkI0AlZGOAJaSkACXlJAAmZWSAJmVlACbmJcAnJiWAJ2a
        mACenJkAnp2cAKGdmgChnZ0Ao6CdAKShngCkoaEApqShAKaipwCppqIAqaalAKmopgCsqKYAramoAK6s
        qgCurawAsK2qALGurQCysK4AtLGvALWysAC2tLIAt7W0ALi1sgC5trQAvLe3ALq4tgC8ubYAurm4AL26
        uQC+vLoAv728AMC8ugDBvrwAwsC+AMTBvgCGhsQAmZnCAMLBwADFwsAAxcTBAMfFxADIxcMAycbFAMrI
        xgDMycYAy8nIAM3KyQDPzcsAz87MANDOzADS0M4A0tHQANTS0ADV1NIA19bUANjW1ADa2NUA2tnYAN3b
        2wDe3dwA4N/dAOLg3wDj4uEA5uTjAOro5wDt7esA7u3tAPHw7wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAA////AAAAAAAmAAAAAAAAAC8AAAAADgAAAAAAACYAAAAAAAAOAAAvAAAA
        AAAAAAAAJgAAAAAAAAAmAAAAAAAAABkAAAAAACYAAAAAACYAAAAAAAAOABkALwAAAAAAAAAAJgAAAAAA
        AAAmAAAAAAAAGQAAAAAvAAAAAAAAACYAAAAAGQAAAAAOAAAAAAAAAAAAJgAAAAAAAAAmAAAAAAAALwAA
        AAAAAAAAAAAAACYAAAAAACYAAAAmAAAAAAAAAAAAJgAAAAAAAAAZAAAAAAAAAAAvAAAOAAAAAAAAACYA
        AAAAACYAAAAAAAAAAAAAAAAAJgAAAAAAAAAAAAAAGQAAAAAZAAAAJgAAAAAAACYAAAAAAAAAAAAAAAAA
        AAAZJiYmDgAAAAAAAAAmAAAvAA4AABkAAAAAAAAAAAAAACYAAAAAAAAAAAAAAAAAAAAZJiYmDgAAAAAA
        AAAmAAAALwAAAC8AACYAAAAAAAAAACYAAAAAACYAAAAAAAAAAAAAAAAAJgAAAAAAAAAmAAAAAAAAAAAA
        Lw4AAAAAAAAAACYAAAAAACYAAAAZAAAAAAAAAAAAJgAAAAAAAAAmAAAAGQAAAAAAGQAmAAAAAAAAACYA
        AAAAGQAAAAAAGQAAAAAAAAAAJgAAAAAAAAAZAAAOACYAAAAZAAAAAAAAAAAAABkAAAAAAAAOAA4AAAAA
        AAAAAAAAJgAAAAAAAAAAAAAZAAAAAAAvAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAJgAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVVxbVwAAAAAAAAAA
        AAAAAAAAAAAgDhArAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsXgAAaGYAAAAAAAAAAAAAAAAAAAAFAAUO
        LgAAAAAAAAAAAAAAAAAAAAAAAAAAAACDcgAAd1wAAAAAAAAAAAAAAAAAAAAFAA4QHgAAAAAAAAAAAAAA
        AAAAAAAAAAAAAACgaAAAaHFoAAAAAAAAAAAAAAAAAAAACQ4VGVcAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        g1tbcZR9aQAAAAAAAAAAAAAAABMJDxUgLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH1meIaSd3cAAAAA
        AAAAAAAAIAUOExkuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB9YXmGkHKDAAAAAAAAAAAiBQwVGSMA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfWF3hpJsAAAAAAAAACYFCRAZIAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAH1ieIyQcQAAAAAAKwUJERkgVwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAB9Yn2IiHIAAAAyBQUOFRkvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeWJ4jIN5
        ADIFCQ4YGSsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH1lfYyDYhEFDhMZJgAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB3Zn2QfSYHExgkAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAeGh4koAhEyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAGFpgJBxIVcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMiNi
        aYCQbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAhaGmAjIgAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6HBsTLWJpg4aMAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAEQ2Rkg5J5JpbIOGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAADQ+SU5SAAAAbGmAeZIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODxGTFQA
        AAAAAHFxeICMlACDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAN0ZMUwAAAAAAAKByeQB5eYN3
        fQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEI1P0lRAAAAAAAAAACDgwBejKV5lAAAAAAAAAAAAAAA
        AAAAAAAAAGZmAAAAAAAAQR09SU8AAAAAAAAAAACQhnlyAJl5bAAAAAAAAAAAAAAAAAAAAAAAcWFbXAAA
        AAB9aDtFTIkAAAAAAAAAAACZg3J5AIhsYnIAAAAAAAAAAAAAAAAAAACZl4hoMWiIeWhpcXJDUQAAAAAA
        AAAAAAAAg4ODg4ODeXiUAAAAAAAAAAAAAAAAAAAApp59XCpWXGJlaG5xigAAAAAAAAAAAAAAjIODg5kA
        AJmMAAAAAAAAAAAAAAAAAAAAAACgYmJpYV1hYmVxAAAAAAAAAAAAAAAAmYaGhgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAmp2DcmVdXWV8AAAAAAAAAAAAAAAApYaIiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKii
        kHdsYl0AAAAAAAAAAAAAAAAAAJKIjJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACppZB9cWWIAAAAAAAA
        AAAAAAAAAKiSjIySlwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKiaiHxxfQAAhn2MAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACpoJSGd2hslwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAKiimaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOfnnn4e8wAA5+eefI7z
        AADn5z55zvMAAOfgPnnO8wAA5/M+ef7zAADgcz57/gMAAOYzfnv+AwAA5zJ+ef7zAADnuH55zvMAAOc4
        fnnO8wAA5jj+fJ7zAADg+PAOPvMAAP///////wAA////////AAD//D//w/8AAP/5n//B/wAA//mf/8H/
        AAD/+Y//wP8AAP/8B/+B/wAA//4D/wP/AAD//wH+B/8AAP//gfwP/wAA///A+A//AAD//+BwH/8AAP//
        8CA//wAA///4AH//AAD///wA//8AAP///gH//wAA////Af//AAD///4D//8AAP///gH//wAA///8AP//
        AAD///gA//8AAP//+Dg//wAA///wfAv/AAD//+D8Qf8AAP//wf5B/wAA/5+D/hH/AAD/DwP+EP8AAP4A
        B/8AfwAA/wAH/wZ/AAD/wA//D/8AAP/gD/8P/wAA//Af/4f/AAD/+A//gf8AAP/+Bj///wAA//8A////
        AAD//8P///8AACgAAAAQAAAAIAAAAAEACAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAERERABwc
        HAAhISEAJiYmACYmdwBAQEAARUVFAElJSQBOTk4AXlxVAFRUewBiYmIAZmZmAHFxcQBzcnUAd3Z2AB0e
        oQAnJ70APTzPAEZGyABNTcgAhoSDAIaFhQCNjIoAjo2MAJCPjgCUkI8AiYabAJKRkACVlJMAlpSUAJiX
        lQCZmJcAmpmZAJ6bmgCdnJoAoZ6cAJaUoQCloqEAqaalAKuqqgCwrq0AtrKrALOxrwC3tLMAuLa1ALu4
        tgC8ubcAvru5AL++vQDBvrsAwb68AMbDwADHxMIAyMXEANDNywDSz84A0tDPANTR0ADb2NcAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAAAAAA
        AAAAAAAAAAAAAAAAABkWAAAAAAAAAAEHAAAAAAAWJR0AAAAAAA0ECQAAAAAAADA7GQAAAAAEBwAAAAAA
        AAAAMDgdAAACBxYAAAAAAAAAAAAxNxABBw4AAAAAAAAAAAAAADQuBg0AAAAAAAAAAAAAAAAKNCwAAAAA
        AAAAAAAAAAALBRAxJwAAAAAAAAAAAAAAEhUAADUkJAAAAAAAAAAAERQAAAAoGR0oAAAkGwAdHBMAAAAA
        ACokLR0AACgkJysmAAAAAAA4KgAqAAAAODcoAAAAAAAALjcAAAAAAAA0PCQaHQAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAP//AADn8wAA4+MAAPHnAAD4xwAA/A8AAP4fAAD+PwAA/B8AAPzHAAD5wwAAI+EAAIPl
        AADH5wAA4P8AAP//AAA=
</value>
  </data>
</root>


================================================
File: MegaDumper/ManagedInjector.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 01.01.2013
 * Time: 09:24
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace MegaDumper
{
	partial class ManagedInjector
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.button1 = new System.Windows.Forms.Button();
			this.button2 = new System.Windows.Forms.Button();
			this.textBox2 = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.textBox3 = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.BackColor = System.Drawing.Color.Transparent;
			this.label1.ForeColor = System.Drawing.Color.Black;
			this.label1.Location = new System.Drawing.Point(60, 18);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(100, 14);
			this.label1.TabIndex = 16;
			this.label1.Text = "Name of assembly:";
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(60, 35);
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(471, 20);
			this.textBox1.TabIndex = 15;
			this.textBox1.DragDrop += new System.Windows.Forms.DragEventHandler(this.TextBox1DragDrop);
			this.textBox1.DragEnter += new System.Windows.Forms.DragEventHandler(this.TextBox1DragEnter);
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(26, 35);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(28, 20);
			this.button1.TabIndex = 14;
			this.button1.Text = "...";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.Button1Click);
			// 
			// button2
			// 
			this.button2.Location = new System.Drawing.Point(74, 161);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(61, 23);
			this.button2.TabIndex = 17;
			this.button2.Text = "Inject";
			this.button2.UseVisualStyleBackColor = true;
			this.button2.Click += new System.EventHandler(this.Button2Click);
			// 
			// textBox2
			// 
			this.textBox2.Location = new System.Drawing.Point(60, 82);
			this.textBox2.Name = "textBox2";
			this.textBox2.Size = new System.Drawing.Size(471, 20);
			this.textBox2.TabIndex = 18;
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(60, 68);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(441, 11);
			this.label2.TabIndex = 19;
			this.label2.Text = "Class name in format Namespace.Class:";
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(60, 117);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(441, 11);
			this.label3.TabIndex = 21;
			this.label3.Text = "Method name (it must have a string argument, public attribute and must return int" +
			"):";
			// 
			// textBox3
			// 
			this.textBox3.Location = new System.Drawing.Point(60, 131);
			this.textBox3.Name = "textBox3";
			this.textBox3.Size = new System.Drawing.Size(471, 20);
			this.textBox3.TabIndex = 20;
			// 
			// ManagedInjector
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(556, 202);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.textBox3);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.textBox2);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.textBox1);
			this.Controls.Add(this.button1);
			this.Name = "ManagedInjector";
			this.Text = "Managed Injector";
			this.Shown += new System.EventHandler(this.ManagedInjectorShown);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.TextBox textBox3;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.TextBox textBox2;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.Label label1;
	}
}



================================================
File: MegaDumper/ManagedInjector.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 01.01.2013
 * Time: 09:24
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using ProcessUtils;
using System.Text;

namespace MegaDumper
{
	
		public class InlineASM
		{
		public byte[] asm;
		int pos = 0;

		public InlineASM()
		{
		asm=new byte[500];
		pos=0;
		}
		
		public void PushOffset(IntPtr address)
		{
		asm[pos]=0x68;
		byte[] abytes = BitConverter.GetBytes((uint)address);
		asm[pos+1]=abytes[0];
		asm[pos+2]=abytes[1];
		asm[pos+3]=abytes[2];
		asm[pos+4]=abytes[3];
		pos=pos+5;
		}
		public void MovEaxValue(IntPtr address)
		{
		asm[pos]=0xB8;
		byte[] abytes = BitConverter.GetBytes((uint)address);
		asm[pos+1]=abytes[0];
		asm[pos+2]=abytes[1];
		asm[pos+3]=abytes[2];
		asm[pos+4]=abytes[3];
		pos=pos+5;
		}
		public void CallEax()
		{
		asm[pos]=0xFF;
		asm[pos+1]=0xD0;
		pos=pos+2;
		}
		public void CallEcx()
		{
		asm[pos]=0xFF;
		asm[pos+1]=0xD1;
		pos=pos+2;
		}
		public void CallEdx()
		{
		asm[pos]=0xFF;
		asm[pos+1]=0xD2;
		pos=pos+2;
		}
		public void PushEax()
		{
		asm[pos]=0x50;
		pos=pos+1;
		}
		public void PushByte(byte inputbyte)
		{
		asm[pos]=0x6A;
		asm[pos+1]=inputbyte;
		pos=pos+2;
		}
		public void MovEcxDwordPtr(IntPtr address)
		{
		asm[pos]=0x8B;
		asm[pos+1]=0x0D;
		byte[] abytes = BitConverter.GetBytes((uint)address);
		asm[pos+2]=abytes[0];
		asm[pos+3]=abytes[1];
		asm[pos+4]=abytes[2];
		asm[pos+5]=abytes[3];
		pos=pos+6;
		}
		public void MovEcxDwordPtrEdxOffset(byte offset)
		{
		asm[pos]=0x8B;
		asm[pos+1]=0x4A;
		asm[pos+2]=offset;
		pos=pos+3;
		}
		public void MovEaxDwordPtrEcxOffset(byte offset)
		{
		asm[pos]=0x8B;
		asm[pos+1]=0x41;
		asm[pos+2]=offset;
		pos=pos+3;
		}
		public void MovEdxDwordPtrEcxOffset(byte offset)
		{
		asm[pos]=0x8B;
		asm[pos+1]=0x51;
		asm[pos+2]=offset;
		pos=pos+3;
		}
		public void MovEcxDwordPtrEax()
		{
		asm[pos]=0x8B;
		asm[pos+1]=0x08;
		pos=pos+2;
		}
		public void MovEaxDwordPtr(IntPtr address)
		{
		asm[pos]=0xA1;
		byte[] abytes = BitConverter.GetBytes((uint)address);
		asm[pos+1]=abytes[0];
		asm[pos+2]=abytes[1];
		asm[pos+3]=abytes[2];
		asm[pos+4]=abytes[3];
		pos=pos+5;
		}
		public void MovEdxDwordPtrEcx()
		{
		asm[pos]=0x8B;
		asm[pos+1]=0x11;
		pos=pos+2;
		}
		public void Retn()
		{
		asm[pos]=0xC3;
		pos=pos+1;
		}
		}
		
	/// <summary>
	/// Description of ManagedInjector.
	/// </summary>
	public partial class ManagedInjector : Form
	{	
		static string processname;
		static int processid;
		static IntPtr hprocess = IntPtr.Zero;
		public ManagedInjector(string pname,int prid)
		{
			processname = pname;
			processid = prid;
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
        static byte[] CLSID_CLRRuntimeHost = new byte[] { 0x6E, 0xA0, 0xF1, 0x90, 0x12, 0x77, 0x62, 0x47, 0x86, 0xB5, 0x7A, 0x5E, 0xBA, 0x6B, 0xDB, 0x02 };
        static byte[] IID_ICLRRuntimeHost = new byte[] { 0x6C, 0xA0, 0xF1, 0x90, 0x12, 0x77, 0x62, 0x47, 0x86, 0xB5, 0x7A, 0x5E, 0xBA, 0x6B, 0xDB, 0x02 };
		void ManagedInjectorShown(object sender, EventArgs e)
		{
this.Text="Managed injector in "+processname+" whit PID="+processid.ToString();

		}
		
		void Button2Click(object sender, EventArgs e)
		{
		HostCLR_RunMethod(textBox1.Text, textBox2.Text, textBox3.Text, "Testargs","v2.0.50727");
		}
		
		static IntPtr CorBindToRuntimeExAddress()
		{
ProcModule.ModuleInfo targetmscoree = null;
ProcModule.ModuleInfo[] modules = ProcModule.GetModuleInfos((int)processid);

if (modules!=null&&modules.Length>0)
{
for (int i=0;i<modules.Length;i++)
{
if (modules[i].baseName.ToLower().Contains("mscoree.dll"))
{
targetmscoree = modules[i];
break;
}
}
}


if (targetmscoree==null||targetmscoree.baseOfDll==IntPtr.Zero)
{
return IntPtr.Zero;
}

IntPtr CLRCreateInstanceAddress =IntPtr.Zero;

if (hprocess!=IntPtr.Zero)
{
int CLRCreateInstancerva = ExportTable.ProcGetExpAddress
	(hprocess, targetmscoree.baseOfDll,"CorBindToRuntimeEx");
if (CLRCreateInstancerva==0)
return IntPtr.Zero;

return (IntPtr)((long)targetmscoree.baseOfDll+(long)CLRCreateInstancerva);
}
return IntPtr.Zero;
		}
		
				
		static void WriteUnicodeString(IntPtr Address,string istring)
		{
		UnicodeEncoding Unicode = new UnicodeEncoding();
		byte[] ubytes = Unicode.GetBytes(istring);
		uint BytesRead=0;
		ProcModule.WriteProcessMemory(hprocess,Address,ubytes,(uint)ubytes.Length, out BytesRead);
		
		}
  public static void HostCLR_RunMethod(String AssemblyPath, String TypeName, String MethodName, String Args, String Version)
        {
hprocess = ProcModule.OpenProcess(ProcModule.PROCESS_QUERY_INFORMATION | ProcModule.PROCESS_VM_OPERATION | ProcModule.PROCESS_VM_WRITE | ProcModule.PROCESS_VM_READ | ProcModule.PROCESS_CREATE_THREAD, 0, (uint)processid);
IntPtr CorBindToRuntimeExPtr = CorBindToRuntimeExAddress();
uint BytesRead=0;

IntPtr codeCave_Code = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, 500, ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ExecuteReadWrite);
IntPtr CLSID_CLRRuntimeHostPtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, (uint)CLSID_CLRRuntimeHost.Length * 4, ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);
IntPtr IID_ICLRRuntimeHostPtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, (uint)IID_ICLRRuntimeHost.Length, ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);
IntPtr ClrHostPtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, 04, ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);
IntPtr dwRetPtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, 0x4, ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);

IntPtr AssemblyPathPtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, (uint)(AssemblyPath.Length*2 + 2), ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);
IntPtr TypeNamePtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, (uint)(TypeName.Length*2 + 2), ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);
IntPtr MethodNamePtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, (uint)(MethodName.Length*2 + 2), ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);
IntPtr ArgsPtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, (uint)(Args.Length*2 + 2), ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);
  
IntPtr BuildFlavorPtr = ProcModule.VirtualAllocEx(hprocess, IntPtr.Zero, 0x10, ProcModule.AllocationType.Commit, ProcModule.MemoryProtection.ReadWrite);

ProcModule.WriteProcessMemory(hprocess,CLSID_CLRRuntimeHostPtr,CLSID_CLRRuntimeHost,(uint)CLSID_CLRRuntimeHost.Length, out BytesRead);
ProcModule.WriteProcessMemory(hprocess,IID_ICLRRuntimeHostPtr,IID_ICLRRuntimeHost,(uint)IID_ICLRRuntimeHost.Length, out BytesRead);
WriteUnicodeString(BuildFlavorPtr, "wks");
WriteUnicodeString(AssemblyPathPtr, AssemblyPath);
WriteUnicodeString(TypeNamePtr, TypeName);
WriteUnicodeString(MethodNamePtr, MethodName);
WriteUnicodeString(ArgsPtr, Args);

InlineASM inline = new InlineASM();
inline.PushOffset(ClrHostPtr);
inline.PushOffset(IID_ICLRRuntimeHostPtr);
inline.PushOffset(CLSID_CLRRuntimeHostPtr);
inline.PushByte(0);
inline.PushOffset(BuildFlavorPtr);
inline.PushByte(0);
inline.MovEaxValue(CorBindToRuntimeExPtr);
inline.CallEax(); // call CorBindToRuntimeEx

inline.MovEaxDwordPtr(ClrHostPtr);
inline.MovEcxDwordPtrEax();
inline.MovEdxDwordPtrEcxOffset(0x0C);
inline.PushEax();
inline.CallEdx();  // pClrHost->Start();

inline.PushOffset(dwRetPtr);
inline.PushOffset(ArgsPtr);
inline.PushOffset(MethodNamePtr);
inline.PushOffset(TypeNamePtr);
inline.PushOffset(AssemblyPathPtr);
inline.MovEaxDwordPtr(ClrHostPtr);
inline.MovEcxDwordPtrEax();
inline.PushEax();
inline.MovEaxDwordPtrEcxOffset(0x2C);
inline.CallEax();  // pClrHost->ExecuteInDefaultAppDomain

inline.Retn();
ProcModule.WriteProcessMemory(hprocess,codeCave_Code,inline.asm,(uint)inline.asm.Length, out BytesRead);

IntPtr hThread = ProcModule.CreateRemoteThread(hprocess,IntPtr.Zero, 0,
codeCave_Code, IntPtr.Zero, 0, IntPtr.Zero);

/*
if (ProcModule.WaitForSingleObject(hThread,uint.MaxValue)!=0)
{
return;
}
*/

IntPtr retcode = IntPtr.Zero;
if (!ProcModule.GetExitCodeThread(hThread, out retcode))
{
return;
}

ProcModule.CloseHandle(hprocess);

  }
		public string DirectoryName = "";
		void Button1Click(object sender, EventArgs e)
		{
		OpenFileDialog fdlg = new OpenFileDialog();
		fdlg.Title = "Browse for assembly";
		fdlg.InitialDirectory = @"c:\";
		if (DirectoryName!="") fdlg.InitialDirectory = DirectoryName;
		fdlg.Filter = "Executable files (*.exe,*.dll)|*.exe;*.dll";
		fdlg.FilterIndex = 2;
		fdlg.RestoreDirectory = true;
		if(fdlg.ShowDialog() == DialogResult.OK)
		{
		string FileName = fdlg.FileName;
		textBox1.Text = FileName;
		int lastslash = FileName.LastIndexOf("\\");
		if (lastslash!=-1) DirectoryName = FileName.Remove(lastslash,FileName.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
		}
		}
		
		void TextBox1DragEnter(object sender, DragEventArgs e)
		{
		if (e.Data.GetDataPresent(DataFormats.FileDrop))
        e.Effect = DragDropEffects.Copy;
    	else
    	e.Effect = DragDropEffects.None;
		}
		
		void TextBox1DragDrop(object sender, DragEventArgs e)
		{
		try
        {
        Array a = (Array) e.Data.GetData(DataFormats.FileDrop);
        if(a != null)
        {
        string s = a.GetValue(0).ToString();
        int lastoffsetpoint = s.LastIndexOf(".");
        if (lastoffsetpoint != -1)
        {
        string Extension = s.Substring(lastoffsetpoint);
        Extension=Extension.ToLower();
        if (Extension == ".exe"||Extension == ".dll")
        {
        this.Activate();
        textBox1.Text = s;
        int lastslash = s.LastIndexOf("\\");
        if (lastslash!=-1) DirectoryName = s.Remove(lastslash,s.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
        }
        }
        }
        }
        catch
        {

        }
		}
	}
}



================================================
File: MegaDumper/ManagedInjector.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/MegaDumper.csproj
================================================
ï»¿<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ProjectGuid>{5FF5C138-ED9E-4120-B787-B8300AEE2EB0}</ProjectGuid>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <OutputType>WinExe</OutputType>
    <RootNamespace>MegaDumper</RootNamespace>
    <AssemblyName>MegaDumper</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <SourceAnalysisOverrideSettingsFile>C:\Documents and Settings\Mihai\Application Data\ICSharpCode/SharpDevelop3.0\Settings.SourceAnalysis</SourceAnalysisOverrideSettingsFile>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
    <NoStdLib>False</NoStdLib>
    <WarningLevel>4</WarningLevel>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
    <ApplicationIcon>..\SND Blue Square.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Platform)' == 'x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <RegisterForComInterop>False</RegisterForComInterop>
    <GenerateSerializationAssemblies>Auto</GenerateSerializationAssemblies>
    <BaseAddress>4194304</BaseAddress>
    <FileAlignment>4096</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
    <OutputPath>bin\Debug\</OutputPath>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>Full</DebugType>
    <Optimize>False</Optimize>
    <CheckForOverflowUnderflow>True</CheckForOverflowUnderflow>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <OutputPath>bin\Release\</OutputPath>
    <DebugSymbols>False</DebugSymbols>
    <DebugType>None</DebugType>
    <Optimize>True</Optimize>
    <CheckForOverflowUnderflow>False</CheckForOverflowUnderflow>
    <DefineConstants>TRACE</DefineConstants>
  </PropertyGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.Targets" />
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AboutForm.cs" />
    <Compile Include="AboutForm.Designer.cs">
      <DependentUpon>AboutForm.cs</DependentUpon>
    </Compile>
    <Compile Include="DetectAntidumps.cs" />
    <Compile Include="DetectAntidumps.Designer.cs">
      <DependentUpon>DetectAntidumps.cs</DependentUpon>
    </Compile>
    <Compile Include="EnumAppDomains.cs" />
    <Compile Include="EnumAppDomains.Designer.cs">
      <DependentUpon>EnumAppDomains.cs</DependentUpon>
    </Compile>
    <Compile Include="FrmModules.cs" />
    <Compile Include="FrmModules.Designer.cs">
      <DependentUpon>FrmModules.cs</DependentUpon>
    </Compile>
    <Compile Include="GenerateDmp.cs" />
    <Compile Include="GenerateDmp.Designer.cs">
      <DependentUpon>GenerateDmp.cs</DependentUpon>
    </Compile>
    <Compile Include="HeapHealper.cs" />
    <Compile Include="HeapView.cs" />
    <Compile Include="HeapView.Designer.cs">
      <DependentUpon>HeapView.cs</DependentUpon>
    </Compile>
    <Compile Include="EmptyForm.cs" />
    <Compile Include="EmptyForm.Designer.cs">
      <DependentUpon>EmptyForm.cs</DependentUpon>
    </Compile>
    <Compile Include="InstalledFramework.cs" />
    <Compile Include="InstalledFramework.Designer.cs">
      <DependentUpon>InstalledFramework.cs</DependentUpon>
    </Compile>
    <Compile Include="MainForm.cs" />
    <Compile Include="MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Include="ManagedInjector.cs" />
    <Compile Include="ManagedInjector.Designer.cs">
      <DependentUpon>ManagedInjector.cs</DependentUpon>
    </Compile>
    <Compile Include="MiniDmp.cs" />
    <Compile Include="NetPerformance.cs" />
    <Compile Include="NetPerformance.Designer.cs">
      <DependentUpon>NetPerformance.cs</DependentUpon>
    </Compile>
    <Compile Include="ProcessManager.cs" />
    <Compile Include="ProcessManager.Designer.cs">
      <DependentUpon>ProcessManager.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Utils\EnumWindows.cs" />
    <Compile Include="Utils\HandleEnumeration.cs" />
    <Compile Include="Utils\MemoryAlloc.cs" />
    <Compile Include="Utils\ProcessStatistics.cs" />
    <Compile Include="Utils\ProcessUtil.cs" />
    <Compile Include="ViewWindowsHoocks.cs" />
    <Compile Include="ViewWindowsHoocks.Designer.cs">
      <DependentUpon>ViewWindowsHoocks.cs</DependentUpon>
    </Compile>
    <Compile Include="VirtualMemoryView.cs" />
    <Compile Include="VirtualMemoryView.Designer.cs">
      <DependentUpon>VirtualMemoryView.cs</DependentUpon>
    </Compile>
    <EmbeddedResource Include="AboutForm.resx">
      <DependentUpon>AboutForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="DetectAntidumps.resx">
      <DependentUpon>DetectAntidumps.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="EnumAppDomains.resx">
      <DependentUpon>EnumAppDomains.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="FrmModules.resx">
      <DependentUpon>FrmModules.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="GenerateDmp.resx">
      <DependentUpon>GenerateDmp.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="HeapView.resx">
      <DependentUpon>HeapView.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="EmptyForm.resx">
      <DependentUpon>EmptyForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="InstalledFramework.resx">
      <DependentUpon>InstalledFramework.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="ManagedInjector.resx">
      <DependentUpon>ManagedInjector.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="NetPerformance.resx">
      <DependentUpon>NetPerformance.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="ProcessManager.resx">
      <DependentUpon>ProcessManager.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="ViewWindowsHoocks.resx">
      <DependentUpon>ViewWindowsHoocks.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="VirtualMemoryView.resx">
      <DependentUpon>VirtualMemoryView.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <Folder Include="Utils" />
  </ItemGroup>
</Project>


================================================
File: MegaDumper/MiniDmp.cs
================================================
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;

using ProcessUtils;

namespace Mega_Dumper
{
    public sealed class MiniDmp
    {
        [Flags]
        public enum DType : uint
        {
            // From dbghelp.h:
            MiniDumpNormal = 0x00000000,
            MiniDumpWithDataSegs = 0x00000001,
            MiniDumpWithFullMemory = 0x00000002,
            MiniDumpWithHandleData = 0x00000004,
            MiniDumpFilterMemory = 0x00000008,
            MiniDumpScanMemory = 0x00000010,
            MiniDumpWithUnloadedModules = 0x00000020,
            MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
            MiniDumpFilterModulePaths = 0x00000080,
            MiniDumpWithProcessThreadData = 0x00000100,
            MiniDumpWithPrivateReadWriteMemory = 0x00000200,
            MiniDumpWithoutOptionalData = 0x00000400,
            MiniDumpWithFullMemoryInfo = 0x00000800,
            MiniDumpWithThreadInfo = 0x00001000,
            MiniDumpWithCodeSegs = 0x00002000,
            MiniDumpWithoutAuxiliaryState = 0x00004000,
            MiniDumpWithFullAuxiliaryState = 0x00008000,
            MiniDumpWithPrivateWriteCopyMemory = 0x00010000,
            MiniDumpIgnoreInaccessibleMemory = 0x00020000,
            MiniDumpValidTypeFlags = 0x0003ffff,
        };

        //typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
        //    DWORD ThreadId;
        //    PEXCEPTION_POINTERS ExceptionPointers;
        //    BOOL ClientPointers;
        //} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;
        [StructLayout(LayoutKind.Sequential, Pack = 4)]  // Pack=4 is important! So it works also for x64!
        struct MiniDumpExceptionInformation
        {
          public uint ThreadId;
          public IntPtr ExceptioonPointers;
          [MarshalAs(UnmanagedType.Bool)]
          public bool ClientPointers;
        }

        //BOOL
        //WINAPI
        //MiniDumpWriteDump(
        //    __in HANDLE hProcess,
        //    __in DWORD ProcessId,
        //    __in HANDLE hFile,
        //    __in MINIDUMP_TYPE DumpType,
        //    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
        //    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
        //    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
        //    );
        [DllImport("dbghelp.dll",
          EntryPoint = "MiniDumpWriteDump",
          CallingConvention = CallingConvention.StdCall,
          CharSet = CharSet.Unicode,
          ExactSpelling = true, SetLastError = true)]
        static extern bool MiniDumpWriteDump(
          IntPtr hProcess,
          uint processId,
          IntPtr hFile,
          uint dumpType,
          ref MiniDumpExceptionInformation expParam,
          IntPtr userStreamParam,
          IntPtr callbackParam);

        [DllImport("kernel32.dll", EntryPoint = "GetCurrentThreadId", ExactSpelling = true)]
        static extern uint GetCurrentThreadId();

        [DllImport("kernel32.dll", EntryPoint = "GetCurrentProcess", ExactSpelling = true)]
        static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll", EntryPoint = "GetCurrentProcessId", ExactSpelling = true)]
        static extern uint GetCurrentProcessId();

[StructLayout(LayoutKind.Sequential, Pack=1)]
		private struct TOKEN_PRIVILEGES
		{
			public int PrivilegeCount;
			public long Luid;
			public int Attributes;
		}
		
		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int OpenProcessToken(int ProcessHandle, int DesiredAccess, ref int tokenhandle);
		

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int LookupPrivilegeValue(string lpsystemname, string lpname, ref long lpLuid);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int AdjustTokenPrivileges(int tokenhandle, int disableprivs, ref TOKEN_PRIVILEGES Newstate, int bufferlength, int PreivousState, int Returnlength);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int GetSecurityInfo( int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, out IntPtr pDACL, IntPtr pSACL, out IntPtr pSecurityDescriptor);

		[DllImport("advapi32.dll", CharSet=CharSet.Auto, SetLastError=true)]
		private static extern int SetSecurityInfo( int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, IntPtr pDACL, IntPtr pSACL);

		
		private const uint PROCESS_TERMINATE = 0x0001;
		private const uint PROCESS_CREATE_THREAD = 0x0002;
		private const uint PROCESS_SET_SESSIONID = 0x0004;
		private const uint PROCESS_VM_OPERATION = 0x0008;
		private const uint PROCESS_VM_READ = 0x0010;
		private const uint PROCESS_VM_WRITE = 0x0020;
		private const uint PROCESS_DUP_HANDLE = 0x0040;
		private const uint PROCESS_CREATE_PROCESS = 0x0080;
		private const uint PROCESS_SET_QUOTA = 0x0100;
		private const uint PROCESS_SET_INFORMATION = 0x0200;
		private const uint PROCESS_QUERY_INFORMATION = 0x0400;
		
     [DllImport("kernel32.dll")]
     static extern IntPtr OpenProcess(UInt32 dwDesiredAccess,  Int32 bInheritHandle, UInt32 dwProcessId);
     
         
      
        public static bool WriteDump(uint processId,string fileName, DType dumpTyp)
        {
        IntPtr hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_TERMINATE, 0, (uint)processId);
		
		if (hProcess == IntPtr.Zero)
		{
		IntPtr pDACL, pSecDesc;

		GetSecurityInfo( (int) Process.GetCurrentProcess().Handle, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
		hProcess = OpenProcess( 0x40000, 0, processId);
		SetSecurityInfo( (int) hProcess, /*SE_KERNEL_OBJECT*/ 6, /*DACL_SECURITY_INFORMATION*/ 4 | /*UNPROTECTED_DACL_SECURITY_INFORMATION*/ 0x20000000, 0, 0, pDACL, IntPtr.Zero);
		ProcModule.CloseHandle( hProcess);
		hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_TERMINATE, 0, processId);
		}
		
		if( hProcess == IntPtr.Zero)
		{
		return false;
		}
		else
		{
            using (var fs = new System.IO.FileStream(fileName, System.IO.FileMode.Create, System.IO.FileAccess.Write, System.IO.FileShare.None))
            {
                MiniDumpExceptionInformation exp;
                exp.ThreadId = GetCurrentThreadId();
                exp.ClientPointers = false;
                exp.ExceptioonPointers = System.Runtime.InteropServices.Marshal.GetExceptionPointers();
                       
                bool bRet = MiniDumpWriteDump(
                  GetCurrentProcess(),
                  GetCurrentProcessId(),
                  fs.SafeFileHandle.DangerousGetHandle(),
                  (uint)dumpTyp,
                  ref exp,
                  IntPtr.Zero,
                  IntPtr.Zero);
                return bRet;
            }
		}

        }
    }



}



================================================
File: MegaDumper/NetPerformance.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 27.10.2010
 * Time: 18:02
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class NetPerformance
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.comboBox1 = new System.Windows.Forms.ComboBox();
			this.value = new System.Windows.Forms.ColumnHeader();
			this.counter = new System.Windows.Forms.ColumnHeader();
			this.perfobject = new System.Windows.Forms.ListView();
			this.SuspendLayout();
			// 
			// comboBox1
			// 
			this.comboBox1.FormattingEnabled = true;
			this.comboBox1.Location = new System.Drawing.Point(36, 25);
			this.comboBox1.Name = "comboBox1";
			this.comboBox1.Size = new System.Drawing.Size(171, 21);
			this.comboBox1.TabIndex = 7;
			this.comboBox1.SelectedIndexChanged += new System.EventHandler(this.ComboBox1SelectedIndexChanged);
			// 
			// value
			// 
			this.value.Text = "Value";
			this.value.Width = 114;
			// 
			// counter
			// 
			this.counter.Text = "Counter";
			this.counter.Width = 338;
			// 
			// perfobject
			// 
			this.perfobject.Alignment = System.Windows.Forms.ListViewAlignment.Default;
			this.perfobject.Anchor = System.Windows.Forms.AnchorStyles.None;
			this.perfobject.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
									this.counter,
									this.value});
			this.perfobject.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(238)));
			this.perfobject.FullRowSelect = true;
			this.perfobject.Location = new System.Drawing.Point(35, 52);
			this.perfobject.MultiSelect = false;
			this.perfobject.Name = "perfobject";
			this.perfobject.Size = new System.Drawing.Size(524, 490);
			this.perfobject.TabIndex = 8;
			this.perfobject.UseCompatibleStateImageBehavior = false;
			this.perfobject.View = System.Windows.Forms.View.Details;
			// 
			// Form2
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(587, 566);
			this.Controls.Add(this.comboBox1);
			this.Controls.Add(this.perfobject);
			this.Name = "Form2";
			this.Text = ".NET Performance";
			this.Load += new System.EventHandler(this.Form2Load);
			this.ResumeLayout(false);
		}
		private System.Windows.Forms.ListView perfobject;
		private System.Windows.Forms.ColumnHeader counter;
		private System.Windows.Forms.ColumnHeader value;
		private System.Windows.Forms.ComboBox comboBox1;
	}
}



================================================
File: MegaDumper/NetPerformance.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 27.10.2010
 * Time: 18:02
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections;

namespace Mega_Dumper
{
	
	internal enum COR_PUB_ENUMPROCESS
    {
        /// Indicates that we need to get managed processes only
        COR_PUB_MANAGEDONLY = 0x00000001
    }
    
    
    /// This is ICorePublish default interface implementation
    [GuidAttribute("047a9a40-657e-11d3-8d5b-00104b35e7ef")]
    [ClassInterfaceAttribute(ClassInterfaceType.None)]
    [ComImportAttribute()]
    internal class CorpubPublish { }
    
    
     /// CLR core interface for working with managed processes
    [ComImport()]
    [Guid("9613A0E7-5A68-11D3-8F84-00A0C9B4D50C")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICorPublish
    {
        /// Gets a set of managed processes
        void EnumProcesses([In]COR_PUB_ENUMPROCESS Type, [Out] out ICorPublishProcessEnum ppIenum);

        /// Gets a managed process by ID
        void GetProcess([In] uint pid, [Out] out ICorPublishProcess ppProcess);
    }
    
    
    [ComImport()]
    [Guid("D6315C8F-5A6A-11d3-8F84-00A0C9B4D50C")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICorPublishAppDomain
    {
        /// Gets domain ID
        void GetID([Out] out uint puId);
        
        /// Gets domain name
        void GetName([In, MarshalAs(UnmanagedType.U4)] uint cchName, [Out, MarshalAs(UnmanagedType.U4)] out uint pcchName, [Out, MarshalAs(UnmanagedType.LPWStr)]  StringBuilder szName);
    }
    
    [ComImport()]
    [Guid("9F0C98F5-5A6A-11d3-8F84-00A0C9B4D50C")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICorPublishAppDomainEnum
    {
        /// Skips a set of domains
        void Skip([In] uint celt);

        /// Resets the collection
        void Reset();

        /// Creates a deep copy of the collection
        void Clone([Out] out ICorPublishEnum ppEnum);

        /// Gets the collection size
        void GetCount([Out]out uint pcelt);

        /// Gets next set of managed domains
        int Next([In]  uint celt,[MarshalAs(UnmanagedType.Interface)] [Out] out ICorPublishAppDomain objects, [Out] out uint pceltFetched);
    }
    
    
    [ComImport()]
    [Guid("C0B22967-5A69-11D3-8F84-00A0C9B4D50C")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICorPublishEnum
    {
        void Skip([In] uint celt);
        void Reset();
        void Clone([Out] out ICorPublishEnum ppEnum);
        void GetCount([Out]out uint pcelt);
    }

    
    [ComImport()]
    [Guid("18D87AF1-5A6A-11d3-8F84-00A0C9B4D50C")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICorPublishProcess
    {
        /// Gets if the process is managed
        void IsManaged([Out, MarshalAs(UnmanagedType.Bool)] out bool pbManaged);

        /// Gets loaded domains set for process
        void EnumAppDomains([Out] out ICorPublishAppDomainEnum ppEnum);
        
        /// Gets process ID
        void GetProcessID([Out] out uint pid);

        /// Gets process name
        void GetDisplayName([In] uint cchName, [Out] out uint pcchName, [Out]  StringBuilder szName);
    }
    
    [ComImport()]
    [Guid("A37FBD41-5A69-11d3-8F84-00A0C9B4D50C")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICorPublishProcessEnum
    {
        /// Skips a set of processes
        void Skip([In] uint celt);

        /// Resets the collection
        void Reset();

        /// Creates a deep copy of the collection
        void Clone([Out] out ICorPublishEnum ppEnum);

        /// Gets the collection size
        void GetCount([Out]out uint pcelt);

        /// Gets the set of managed processes
        int Next([In]  uint celt, [Out] out ICorPublishProcess objects, [Out] out uint pceltFetched);
    }
    
    public class ManagedProcessInfoCollection : IEnumerator, ICollection, IEnumerable, ICloneable
{
    // Fields
    private object _SyncRoot = new object();
    private ICorPublishProcess CurrentProcess;
    private ICorPublishProcessEnum Processes;

    // Methods
    internal ManagedProcessInfoCollection(ICorPublishProcessEnum AllProcesses)
    {
        this.Processes = AllProcesses;
        this.CurrentProcess = null;
    }

    public object Clone()
    {
        ICorPublishEnum ppEnum = null;
        ((ICorPublishEnum) this.Processes).Clone(out ppEnum);
        if (ppEnum != null)
        {
            return new ManagedProcessInfoCollection((ICorPublishProcessEnum) ppEnum);
        }
        return null;
    }

    public void CopyTo(Array Destination, int index)
    {
        if (Destination == null)
        {
            throw new ArgumentNullException("Destination array cannot be null.");
        }
        if (Destination.Rank != 1)
        {
            throw new ArgumentException("Invalid array rank!");
        }
        int num = index;
        ManagedProcessInfo[] infoArray = (ManagedProcessInfo[]) Destination;
        foreach (ManagedProcessInfo info in this)
        {
            infoArray[num++] = info;
        }
    }

    public IEnumerator GetEnumerator()
    {
        return this;
    }

    public bool MoveNext()
    {
        uint pceltFetched = 0;
        this.Processes.Next(1, out this.CurrentProcess, out pceltFetched);
        if (pceltFetched != 1)
        {
            this.CurrentProcess = null;
        }
        return ((this.CurrentProcess != null) && (pceltFetched == 1));
    }

    public void Reset()
    {
        this.Processes.Reset();
        this.CurrentProcess = null;
    }

    // Properties
    public int Count
    {
        get
        {
            uint pcelt = 0;
            this.Processes.GetCount(out pcelt);
            return (int) pcelt;
        }
    }

    public object Current
    {
        get
        {
            if (this.CurrentProcess != null)
            {
                return new ManagedProcessInfo(this.CurrentProcess);
            }
            return null;
        }
    }

    public bool IsSynchronized
    {
        get
        {
            return true;
        }
    }

    public object SyncRoot
    {
        get
        {
            return this._SyncRoot;
        }
    }
}

    public class ManagedDomainInfo
{
    // Fields
    private ICorPublishAppDomain Domain;

    // Methods
    internal ManagedDomainInfo(ICorPublishAppDomain SingleDomain)
    {
        this.Domain = SingleDomain;
    }

    // Properties
    public uint DomainID
    {
        get
        {
            uint puId = 0;
            this.Domain.GetID(out puId);
            return puId;
        }
    }

    public string DomainName
    {
        get
        {
            uint pcchName = 0;
            StringBuilder szName = new StringBuilder(0xff);
            this.Domain.GetName(0xff, out pcchName, szName);
            if ((pcchName > 0) && (pcchName > 0xff))
            {
                szName = new StringBuilder((int) pcchName);
                this.Domain.GetName(pcchName, out pcchName, szName);
            }
            return szName.ToString();
        }
    }
}

 

    
 public class ManagedDomainInfoCollection : IEnumerator, ICollection, IEnumerable, ICloneable
{
    // Fields
    private object _SyncRoot = new object();
    private ICorPublishAppDomain CurrentDomain;
    private ICorPublishAppDomainEnum Domains;

    // Methods
    internal ManagedDomainInfoCollection(ICorPublishAppDomainEnum AllDomains)
    {
        this.Domains = AllDomains;
        this.CurrentDomain = null;
    }

    public object Clone()
    {
        ICorPublishEnum ppEnum = null;
        ((ICorPublishEnum) this.Domains).Clone(out ppEnum);
        if (ppEnum != null)
        {
            return new ManagedDomainInfoCollection((ICorPublishAppDomainEnum) ppEnum);
        }
        return null;
    }

    public void CopyTo(Array Destination, int index)
    {
        if (Destination == null)
        {
            throw new ArgumentNullException("Destination array cannot be null.");
        }
        if (Destination.Rank != 1)
        {
            throw new ArgumentException("Invalid array rank!");
        }
        int num = index;
        ManagedDomainInfo[] infoArray = (ManagedDomainInfo[]) Destination;
        foreach (ManagedDomainInfo info in this)
        {
            infoArray[num++] = info;
        }
    }

    public IEnumerator GetEnumerator()
    {
        return this;
    }

    public bool MoveNext()
    {
        uint pceltFetched = 0;
        this.Domains.Next(1, out this.CurrentDomain, out pceltFetched);
        if (pceltFetched != 1)
        {
            this.CurrentDomain = null;
        }
        return ((this.CurrentDomain != null) && (pceltFetched == 1));
    }

    public void Reset()
    {
        this.Domains.Reset();
        this.CurrentDomain = null;
    }

    // Properties
    public int Count
    {
        get
        {
            uint pcelt = 0;
            this.Domains.GetCount(out pcelt);
            return (int) pcelt;
        }
    }

    public object Current
    {
        get
        {
            if (this.CurrentDomain != null)
            {
                return new ManagedDomainInfo(this.CurrentDomain);
            }
            return null;
        }
    }

    public bool IsSynchronized
    {
        get
        {
            return true;
        }
    }

    public object SyncRoot
    {
        get
        {
            return this._SyncRoot;
        }
    }
}

 


    public class ManagedProcessInfo
{
    // Fields
    private ICorPublishProcess Process;

    // Methods
    internal ManagedProcessInfo(ICorPublishProcess SingleProcess)
    {
        this.Process = SingleProcess;
    }

    public System.Diagnostics.Process ConvertToDiagnosticsProcess()
    {
        return System.Diagnostics.Process.GetProcessById((int) this.ProcessID);
    }

    public static ManagedProcessInfo GetProcessByID(uint ID)
    {
        ICorPublish publish = (ICorPublish) new CorpubPublish();
        if (publish != null)
        {
            ICorPublishProcess ppProcess = null;
            publish.GetProcess(ID, out ppProcess);
            if (ppProcess != null)
            {
                return new ManagedProcessInfo(ppProcess);
            }
        }
        return null;
    }

    public class ManagedProcessInfoCollection : IEnumerator, ICollection, IEnumerable, ICloneable
{
    // Fields
    private object _SyncRoot = new object();
    private ICorPublishProcess CurrentProcess;
    private ICorPublishProcessEnum Processes;

    // Methods
    internal ManagedProcessInfoCollection(ICorPublishProcessEnum AllProcesses)
    {
        this.Processes = AllProcesses;
        this.CurrentProcess = null;
    }

    public object Clone()
    {
        ICorPublishEnum ppEnum = null;
        ((ICorPublishEnum) this.Processes).Clone(out ppEnum);
        if (ppEnum != null)
        {
            return new ManagedProcessInfoCollection((ICorPublishProcessEnum) ppEnum);
        }
        return null;
    }

    public void CopyTo(Array Destination, int index)
    {
        if (Destination == null)
        {
            throw new ArgumentNullException("Destination array cannot be null.");
        }
        if (Destination.Rank != 1)
        {
            throw new ArgumentException("Invalid array rank!");
        }
        int num = index;
        ManagedProcessInfo[] infoArray = (ManagedProcessInfo[]) Destination;
        foreach (ManagedProcessInfo info in this)
        {
            infoArray[num++] = info;
        }
    }

    public IEnumerator GetEnumerator()
    {
        return this;
    }

    public bool MoveNext()
    {
        uint pceltFetched = 0;
        this.Processes.Next(1, out this.CurrentProcess, out pceltFetched);
        if (pceltFetched != 1)
        {
            this.CurrentProcess = null;
        }
        return ((this.CurrentProcess != null) && (pceltFetched == 1));
    }

    public void Reset()
    {
        this.Processes.Reset();
        this.CurrentProcess = null;
    }

    // Properties
    public int Count
    {
        get
        {
            uint pcelt = 0;
            this.Processes.GetCount(out pcelt);
            return (int) pcelt;
        }
    }

    public object Current
    {
        get
        {
            if (this.CurrentProcess != null)
            {
                return new ManagedProcessInfo(this.CurrentProcess);
            }
            return null;
        }
    }

    public bool IsSynchronized
    {
        get
        {
            return true;
        }
    }

    public object SyncRoot
    {
        get
        {
            return this._SyncRoot;
        }
    }
}


    public static ManagedProcessInfoCollection GetProcesses()
    {
        ICorPublish publish = (ICorPublish) new CorpubPublish();
        if (publish != null)
        {
            ICorPublishProcessEnum ppIenum = null;
            publish.EnumProcesses(COR_PUB_ENUMPROCESS.COR_PUB_MANAGEDONLY, out ppIenum);
            if (ppIenum != null)
            {
                return new ManagedProcessInfoCollection(ppIenum);
            }
        }
        return null;
    }

    // Properties
    public string DisplayName
    {
        get
        {
            uint pcchName = 0;
            StringBuilder szName = new StringBuilder(0xff);
            this.Process.GetDisplayName(0xff, out pcchName, szName);
            if ((pcchName > 0) && (pcchName > 0xff))
            {
                szName = new StringBuilder((int) pcchName);
                this.Process.GetDisplayName(pcchName, out pcchName, szName);
            }
            return szName.ToString();
        }
    }

    public ManagedDomainInfoCollection LoadedDomains
    {
        get
        {
            ICorPublishAppDomainEnum ppEnum = null;
            this.Process.EnumAppDomains(out ppEnum);
            if (ppEnum != null)
            {
                return new ManagedDomainInfoCollection(ppEnum);
            }
            return null;
        }
    }

    public uint ProcessID
    {
        get
        {
            uint pid = 0;
            this.Process.GetProcessID(out pid);
            return pid;
        }
    }
    }
    
	/// <summary>
	/// Description of Form2.
	/// </summary>
	public partial class NetPerformance : Form
	{
	public string ProcessName;
	public int procid;
		public NetPerformance(string procname,int prid)
		{
		ProcessName=procname;
		procid=prid;
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();

			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
		void Form2Load(object sender, EventArgs e)
		{
		this.Text=".NET Performance for "+ProcessName+" whit PID="+procid.ToString();
		comboBox1.Items.Add(".NET CLR Memory");
		comboBox1.Items.Add(".NET CLR Jit");
		comboBox1.Items.Add(".NET CLR Exceptions");
		comboBox1.Items.Add(".NET CLR LocksAndThreads");
		comboBox1.Items.Add(".NET CLR Data");
		comboBox1.Items.Add(".NET CLR Interop");
		comboBox1.Items.Add(".NET CLR Loading");
		comboBox1.Items.Add(".NET CLR Remoting");
		comboBox1.Items.Add(".NET CLR Security");
		comboBox1.SelectedIndex = 0;
	  
		}
		
		void ComboBox1SelectedIndexChanged(object sender, EventArgs e)
		{
		perfobject.Items.Clear();
		string[] instanceNames;
        System.Collections.ArrayList counters = new System.Collections.ArrayList();
         if (comboBox1.SelectedIndex != -1)
         {
         bool IsFinded=false;
         System.Diagnostics.PerformanceCounterCategory mycat = new System.Diagnostics.PerformanceCounterCategory(comboBox1.SelectedItem.ToString());
         instanceNames = mycat.GetInstanceNames();
         int proccount=0;
         for (int i = 0; i < instanceNames.Length; i++)
         {
string fortest = instanceNames[i].ToLower();
int lastdiez = fortest.LastIndexOf("#");
if (lastdiez!=-1)
{
fortest = fortest.Remove(lastdiez,fortest.Length-lastdiez);
}
if (ProcessName.ToLower().Contains(fortest))
         {
         proccount++;
         if (proccount>=2) break;
         }
         }

         for (int i = 0; i < instanceNames.Length; i++)
         {
         IsFinded=false;
         System.Diagnostics.PerformanceCounterCategory mycattest = new System.Diagnostics.PerformanceCounterCategory(".NET CLR Memory");
         System.Collections.ArrayList testcounters = new System.Collections.ArrayList();
         testcounters.AddRange(mycattest.GetCounters(instanceNames[i]));
         
         foreach (System.Diagnostics.PerformanceCounter tcounter in testcounters)
         {
         if (tcounter.CounterName=="Process ID")
         {
         if ((int)tcounter.RawValue==procid)
         IsFinded=true;
         else
         IsFinded=false;
         }
         }
         

         if (!IsFinded||proccount>=2)
         {
string fortest = instanceNames[i];
int lastdiez = fortest.LastIndexOf("#");
if (lastdiez!=-1)
{
fortest = fortest.Remove(lastdiez,fortest.Length-lastdiez);
}
if (ProcessName.ToLower().Contains(fortest.ToLower()))
         {
IsFinded=true;
string[] prcdet = new string[]{""};
ListViewItem proctadd = new ListViewItem(prcdet);
perfobject.Items.Add(proctadd);
prcdet = new string[]{instanceNames[i]};
proctadd = new ListViewItem(prcdet);
perfobject.Items.Add(proctadd);
         }
         }
         
         if (IsFinded)
         {
         counters.AddRange(mycat.GetCounters(instanceNames[i]));
         // Add the retrieved counters to the list.
         foreach (System.Diagnostics.PerformanceCounter counter in counters)
         {
         string[] prcdetails = new string[]{counter.CounterName,counter.RawValue.ToString()};
         ListViewItem proc = new ListViewItem(prcdetails);
         perfobject.Items.Add(proc);


         }
         }
         if (proccount<2&&IsFinded) break;
         }
         
         }
        
		}
	}
}



================================================
File: MegaDumper/NetPerformance.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/ProcessManager.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 27.02.2011
 * Time: 15:58
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class ProcessManager
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.button1 = new System.Windows.Forms.Button();
			this.button2 = new System.Windows.Forms.Button();
			this.textBox2 = new System.Windows.Forms.TextBox();
			this.En = new System.Windows.Forms.Label();
			this.button3 = new System.Windows.Forms.Button();
			this.textBox3 = new System.Windows.Forms.TextBox();
			this.checkBox1 = new System.Windows.Forms.CheckBox();
			this.checkBox2 = new System.Windows.Forms.CheckBox();
			this.checkBox3 = new System.Windows.Forms.CheckBox();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.BackColor = System.Drawing.Color.Transparent;
			this.label1.ForeColor = System.Drawing.Color.Black;
			this.label1.Location = new System.Drawing.Point(57, 20);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(100, 14);
			this.label1.TabIndex = 13;
			this.label1.Text = "Name of program:";
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(57, 37);
			this.textBox1.Name = "textBox1";
			this.textBox1.Size = new System.Drawing.Size(585, 20);
			this.textBox1.TabIndex = 12;
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(23, 37);
			this.button1.Name = "button1";
			this.button1.Size = new System.Drawing.Size(28, 20);
			this.button1.TabIndex = 11;
			this.button1.Text = "...";
			this.button1.UseVisualStyleBackColor = true;
			this.button1.Click += new System.EventHandler(this.Button1Click);
			// 
			// button2
			// 
			this.button2.Location = new System.Drawing.Point(23, 242);
			this.button2.Name = "button2";
			this.button2.Size = new System.Drawing.Size(75, 23);
			this.button2.TabIndex = 14;
			this.button2.Text = "Start";
			this.button2.UseVisualStyleBackColor = true;
			this.button2.Click += new System.EventHandler(this.Button2Click);
			// 
			// textBox2
			// 
			this.textBox2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox2.Location = new System.Drawing.Point(23, 85);
			this.textBox2.Multiline = true;
			this.textBox2.Name = "textBox2";
			this.textBox2.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.textBox2.Size = new System.Drawing.Size(619, 137);
			this.textBox2.TabIndex = 15;
			// 
			// En
			// 
			this.En.Location = new System.Drawing.Point(23, 72);
			this.En.Name = "En";
			this.En.Size = new System.Drawing.Size(177, 11);
			this.En.TabIndex = 16;
			this.En.Text = "Environment Variables to set:";
			// 
			// button3
			// 
			this.button3.Location = new System.Drawing.Point(125, 242);
			this.button3.Name = "button3";
			this.button3.Size = new System.Drawing.Size(75, 23);
			this.button3.TabIndex = 17;
			this.button3.Text = "Continue";
			this.button3.UseVisualStyleBackColor = true;
			this.button3.Click += new System.EventHandler(this.Button3Click);
			// 
			// textBox3
			// 
			this.textBox3.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox3.Location = new System.Drawing.Point(23, 272);
			this.textBox3.Multiline = true;
			this.textBox3.Name = "textBox3";
			this.textBox3.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.textBox3.Size = new System.Drawing.Size(619, 140);
			this.textBox3.TabIndex = 18;
			// 
			// checkBox1
			// 
			this.checkBox1.Location = new System.Drawing.Point(222, 242);
			this.checkBox1.Name = "checkBox1";
			this.checkBox1.Size = new System.Drawing.Size(93, 24);
			this.checkBox1.TabIndex = 19;
			this.checkBox1.Text = "Break on load";
			this.checkBox1.UseVisualStyleBackColor = true;
			// 
			// checkBox2
			// 
			this.checkBox2.Checked = true;
			this.checkBox2.CheckState = System.Windows.Forms.CheckState.Checked;
			this.checkBox2.Location = new System.Drawing.Point(321, 242);
			this.checkBox2.Name = "checkBox2";
			this.checkBox2.Size = new System.Drawing.Size(116, 24);
			this.checkBox2.TabIndex = 20;
			this.checkBox2.Text = "Log CreateProcess";
			this.checkBox2.UseVisualStyleBackColor = true;
			// 
			// checkBox3
			// 
			this.checkBox3.Checked = true;
			this.checkBox3.CheckState = System.Windows.Forms.CheckState.Checked;
			this.checkBox3.Location = new System.Drawing.Point(443, 241);
			this.checkBox3.Name = "checkBox3";
			this.checkBox3.Size = new System.Drawing.Size(87, 24);
			this.checkBox3.TabIndex = 21;
			this.checkBox3.Text = "Log memcpy";
			this.checkBox3.UseVisualStyleBackColor = true;
			// 
			// ProcessManager
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(683, 417);
			this.Controls.Add(this.checkBox3);
			this.Controls.Add(this.checkBox2);
			this.Controls.Add(this.checkBox1);
			this.Controls.Add(this.textBox3);
			this.Controls.Add(this.button3);
			this.Controls.Add(this.En);
			this.Controls.Add(this.textBox2);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.textBox1);
			this.Controls.Add(this.button1);
			this.Name = "ProcessManager";
			this.Text = "Process Manager:";
			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.ProcessManagerFormClosing);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.CheckBox checkBox3;
		private System.Windows.Forms.CheckBox checkBox2;
		private System.Windows.Forms.CheckBox checkBox1;
		private System.Windows.Forms.TextBox textBox3;
		private System.Windows.Forms.Button button3;
		private System.Windows.Forms.Label En;
		private System.Windows.Forms.TextBox textBox2;
		private System.Windows.Forms.Button button2;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.Label label1;
	}
}



================================================
File: MegaDumper/ProcessManager.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 27.02.2011
 * Time: 15:58
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Collections.Specialized;
using System.Text;
using System.Threading;
using System.Collections;

using ProcessUtils;

namespace Mega_Dumper
{
	/// <summary>
	/// Description of ProcessManager.
	/// </summary>
	/// 
	    internal class OrdinalCaseInsensitiveComparer : System.Collections.IComparer {
        internal static readonly OrdinalCaseInsensitiveComparer Default = new OrdinalCaseInsensitiveComparer();
  
        public int Compare(Object a, Object b) {
            String sa = a as String;
            String sb = b as String;
            if (sa != null && sb != null) {
                return String.CompareOrdinal(sa.ToUpperInvariant(), sb.ToUpperInvariant());
            }
            return System.Collections.Comparer.Default.Compare(a,b);
        }
    } 
	public partial class ProcessManager : Form
	{
		public ProcessManager()
		{
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}



public enum ProcessAccess : int
{
    /// <summary>Specifies all possible access flags for the process object.</summary>
    AllAccess = CreateThread | DuplicateHandle | QueryInformation | SetInformation | Terminate | VMOperation | VMRead | VMWrite | Synchronize,
    /// <summary>Enables usage of the process handle in the CreateRemoteThread function to create a thread in the process.</summary>
    CreateThread = 0x2,
    /// <summary>Enables usage of the process handle as either the source or target process in the DuplicateHandle function to duplicate a handle.</summary>
    DuplicateHandle = 0x40,
    /// <summary>Enables usage of the process handle in the GetExitCodeProcess and GetPriorityClass functions to read information from the process object.</summary>
    QueryInformation = 0x400,
    /// <summary>Enables usage of the process handle in the SetPriorityClass function to set the priority class of the process.</summary>
    SetInformation = 0x200,
    /// <summary>Enables usage of the process handle in the TerminateProcess function to terminate the process.</summary>
    Terminate = 0x1,
    /// <summary>Enables usage of the process handle in the VirtualProtectEx and WriteProcessMemory functions to modify the virtual memory of the process.</summary>
    VMOperation = 0x8,
    /// <summary>Enables usage of the process handle in the ReadProcessMemory function to' read from the virtual memory of the process.</summary>
    VMRead = 0x10,
    /// <summary>Enables usage of the process handle in the WriteProcessMemory function to write to the virtual memory of the process.</summary>
    VMWrite = 0x20,
    /// <summary>Enables usage of the process handle in any of the wait functions to wait for the process to terminate.</summary>
    Synchronize = 0x100000
}

     
     [DllImport("kernel32.dll")]
     static extern IntPtr OpenProcess(ProcessAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, UInt32 dwProcessId);
     
     
     [DllImport("kernel32.dll", SetLastError=true)]
     [return: MarshalAs(UnmanagedType.Bool)]
     static extern bool CloseHandle(IntPtr hObject);
     
     [DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true, ExactSpelling=true)]
     public static extern bool CloseHandle(HandleRef handle);
 

		public string DirectoryName = "";
		void Button1Click(object sender, EventArgs e)
		{
		OpenFileDialog fdlg = new OpenFileDialog();
		fdlg.Title = "Browse for program:";
		fdlg.InitialDirectory = @"c:\";
		if (DirectoryName!="") fdlg.InitialDirectory = DirectoryName;
		fdlg.Filter = "All files (*.exe)|*.exe";
		fdlg.FilterIndex = 2;
		fdlg.RestoreDirectory = true;
		fdlg.Multiselect = false;
		if(fdlg.ShowDialog() == DialogResult.OK)
		{
		string FileName = fdlg.FileName;
		textBox1.Text = FileName;
		int lastslash = FileName.LastIndexOf("\\");
		if (lastslash!=-1) DirectoryName = FileName.Remove(lastslash,FileName.Length-lastslash);
        if (DirectoryName.Length==2) DirectoryName=DirectoryName+"\\";
		}
		}
		
[DllImport("kernel32", EntryPoint="CreateProcessW", CharSet=CharSet.Ansi, SetLastError=true, ExactSpelling=true)]
public static extern int CreateProcess(IntPtr lpApplicationName, IntPtr lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, int bInheritHandles, int dwCreationFlags, IntPtr lpEnvironment, IntPtr lpCurrentDriectory, ref STARTUPINFO lpStartupInfo, ref PROCESS_INFORMATION lpProcessInformation);
 
[DllImport( "kernel32.dll")]
public static extern bool ResumeThread(IntPtr hThread);

[DllImport("kernel32.dll")]
public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,[In, Out] byte[] buffer, UInt32 size, out uint lpNumberOfBytesWritten);


[DllImport("kernel32.dll", SetLastError=true)]
public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

public struct PROCESS_INFORMATION
{
public IntPtr hProcess;
public IntPtr hThread;
public uint dwProcessId;
public uint dwThreadId;
}

public struct STARTUPINFO
{
public uint cb;
public string lpReserved;
public string lpDesktop;
public string lpTitle;
public uint dwX;
public uint dwY;
public uint dwXSize;
public uint dwYSize;
public uint dwXCountChars;
public uint dwYCountChars;
public uint dwFillAttribute;
public uint dwFlags;
public short wShowWindow;
public short cbReserved2;
public IntPtr lpReserved2;
public IntPtr hStdInput;
public IntPtr hStdOutput;
public IntPtr hStdError;
}

public enum ProcessCreationFlags : int
{
   DEBUG_PROCESS              = 0x1,
   DEBUG_ONLY_THIS_PROCESS    = 0x2,
   CREATE_SUSPENDED           = 0x4,
   DETACHED_PROCESS           = 0x8,
   CREATE_NEW_CONSOLE         = 0x10,
   NORMAL_PRIORITY_CLASS      = 0x20,
   IDLE_PRIORITY_CLASS        = 0x40,
   HIGH_PRIORITY_CLASS        = 0x80,
   REALTIME_PRIORITY_CLASS    = 0x100,
   CREATE_NEW_PROCESS_GROUP   = 0x200,
   CREATE_UNICODE_ENVIRONMENT = 0x400,
   CREATE_SEPARATE_WOW_VDM    = 0x800,
   CREATE_SHARED_WOW_VDM      = 0x1000,
   CREATE_FORCEDOS            = 0x2000,
   CREATE_DEFAULT_ERROR_MODE  = 0x4000000,
   CREATE_NO_WINDOW           = 0x8000000
}
	
const UInt32 INFINITE = 0xFFFFFFFF;

        public static byte[] ToByteArray(StringDictionary sd, bool unicode)
        {
            // get the keys
            string[] keys = new string[sd.Count];
            byte[] envBlock = null;
            sd.Keys.CopyTo(keys, 0);
            
            // get the values
            string[] values = new string[sd.Count];
            sd.Values.CopyTo(values, 0);
            
            // sort both by the keys
            // Windows 2000 requires the environment block to be sorted by the key
            // It will first converting the case the strings and do ordinal comparison.
            Array.Sort(keys, values, OrdinalCaseInsensitiveComparer.Default);

            // create a list of null terminated "key=val" strings
            StringBuilder stringBuff = new StringBuilder();
            for (int i = 0; i < sd.Count; ++ i) {
                stringBuff.Append(keys[i]);
                stringBuff.Append('=');
                stringBuff.Append(values[i]);
                stringBuff.Append('\0');
            }
            // an extra null at the end indicates end of list.
            stringBuff.Append('\0');
                        
            if( unicode) {
                envBlock = Encoding.Unicode.GetBytes(stringBuff.ToString());                        
            }
            else
                envBlock = Encoding.Default.GetBytes(stringBuff.ToString());

            //if (envBlock.Length > UInt16.MaxValue)
            //    throw new InvalidOperationException(SR.GetString(SR.EnvironmentBlockTooLong, envBlock.Length));

            return envBlock;
        }
        
public static IntPtr hprocess;
public static uint cprocessid;
public static IntPtr hcthread;
public static ProcModule.ModuleInfo targetkernel32 = null;
public static ProcModule.ModuleInfo targetMSVCR80 = null;

[DllImport("kernel32.dll")]
static extern uint SuspendThread(IntPtr hThread);

[DllImport("kernel32.dll")]
static extern bool Sleep(long Milliseconds);

[DllImport("psapi.dll", CharSet=CharSet.Auto)]
public static extern bool EnumProcessModules(IntPtr handle, IntPtr modules, int size, ref int needed);
 
[DllImport("kernel32.dll", ExactSpelling=true)]
static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress,
   uint dwSize, AllocationType flAllocationType, MemoryProtection flProtect);

[DllImport("Kernel32.dll")]
public static extern bool ReadProcessMemory
(
 IntPtr hProcess,
 IntPtr lpBaseAddress,
 byte[] lpBuffer,
 UInt32 nSize,
 ref UInt32 lpNumberOfBytesRead
 );
 
 
[Flags]
public enum AllocationType
{
     Commit = 0x1000,
     Reserve = 0x2000,
     Decommit = 0x4000,
     Release = 0x8000,
     Reset = 0x80000,
     Physical = 0x400000,
     TopDown = 0x100000,
     WriteWatch = 0x200000,
     LargePages = 0x20000000
}

[Flags]
public enum MemoryProtection
{
     Execute = 0x10,
     ExecuteRead = 0x20,
     ExecuteReadWrite = 0x40,
     ExecuteWriteCopy = 0x80,
     NoAccess = 0x01,
     ReadOnly = 0x02,
     ReadWrite = 0x04,
     WriteCopy = 0x08,
     GuardModifierflag = 0x100,
     NoCacheModifierflag = 0x200,
     WriteCombineModifierflag = 0x400
}

static void LoopWhileModulesAreLoadedNt(uint procid,IntPtr htread)
{

IntPtr processHandle = IntPtr.Zero;
try
{
processHandle = OpenProcess(ProcessAccess.QueryInformation|ProcessAccess.VMRead, false, (uint)procid);
}
catch
{
}

if (processHandle==IntPtr.Zero)
return;

int oldneeded = 0;

while (true)
{
ResumeThread(htread);
Sleep(1);
SuspendThread(htread);

int newneeded = 0;
EnumProcessModules(processHandle,IntPtr.Zero,0,ref newneeded);
if (newneeded>oldneeded)  // new module is loaded!
{
oldneeded = newneeded;
if (newneeded>=12)  // if we have at last 3 module
return;
}



}
}

[DllImport("kernel32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool GetExitCodeProcess(IntPtr hProcess, out uint lpExitCode);

System.Windows.Forms.Timer checktimer;
public void CheckStatut(object source, EventArgs e)
{
uint exitcode = 0;
GetExitCodeProcess(hprocess,out exitcode);

if (exitcode!=259)  // STILL_ACTIVE = 259
{
button2.Enabled = true;
textBox3.AppendText("\r\n"+"Process terminated, exit code: "+exitcode.ToString()+"\r\n");

checktimer.Stop();
checktimer.Dispose();
checktimer = null;

hprocess = IntPtr.Zero;
cprocessid = 0;
hcthread = IntPtr.Zero;
targetkernel32 = null;
targetMSVCR80 = null;
VirtualAlloc1 = IntPtr.Zero;
VirtualAlloc2 = IntPtr.Zero;
VirtualAlloc3 = IntPtr.Zero;
}
else
{
byte[] keeper = new byte[4];
uint BytesRead=0;
if (VirtualAlloc1!=IntPtr.Zero&&ReadProcessMemory(hprocess,VirtualAlloc1,keeper,4, ref BytesRead))
{
if (keeper[0]!=0||keeper[1]!=0||keeper[2]!=0||keeper[2]!=0)
{
int ESPvalue = BitConverter.ToInt32(keeper,0);
byte[] eraser = new byte[]{0,0,0,0};
byte[] infiniteloop = new byte[]{0x0EB,0x0FE};
byte[] nops = new byte[]{0x090,0x090};

// write infinit loop to second:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc1+12),infiniteloop,2, out BytesRead);
// nop the first and write infinit loop back:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc1+10),nops,2, out BytesRead);
Sleep(2);
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc1+10),infiniteloop,2, out BytesRead);

textBox3.AppendText("\r\n");
textBox3.AppendText("CreateProcessW reached:"+"\r\n");
textBox3.AppendText("Value of ESP:"+ESPvalue.ToString("X8")+"\r\n");
byte[] parbytes = new byte[14*4];

if (ReadProcessMemory(hprocess,(IntPtr)ESPvalue,parbytes,(uint)parbytes.Length, ref BytesRead))
{
int[] parameters = new int[14];
for (int i=0;i<parameters.Length;i++)
{
parameters[i]=BitConverter.ToInt32(parbytes,i*4);
}

textBox3.AppendText("Return address: "+parameters[0].ToString("X8")+"\r\n");
textBox3.AppendText("hToken: "+parameters[1].ToString("X8")+"\r\n");
textBox3.AppendText("ModuleFileName: "+parameters[2].ToString("X8")+"  ");
string result = MemStringReader.ReadUnicodeString(hprocess,(IntPtr)parameters[2]);
if (result!=null)
{
textBox3.AppendText(result);
}
textBox3.AppendText("\r\n");

textBox3.AppendText("CommandLine: "+parameters[3].ToString("X8")+"  ");
result = MemStringReader.ReadUnicodeString(hprocess,(IntPtr)parameters[3]);
if (result!=null)
{
textBox3.AppendText(result);
}
textBox3.AppendText("\r\n");

textBox3.AppendText("pProcessSecurity: "+parameters[4].ToString("X8")+"\r\n");
textBox3.AppendText("pThreadSecurity: "+parameters[5].ToString("X8")+"\r\n");
textBox3.AppendText("InheritHandles: "+parameters[6].ToString("X8")+"\r\n");
textBox3.AppendText("CreationFlags: "+parameters[7].ToString("X8")+"\r\n");
textBox3.AppendText("pEnvironment: "+parameters[8].ToString("X8")+"\r\n");
textBox3.AppendText("CurrentDir: "+parameters[9].ToString("X8")+"  ");
result = MemStringReader.ReadUnicodeString(hprocess,(IntPtr)parameters[9]);
if (result!=null)
{
textBox3.AppendText(result);
}
textBox3.AppendText("\r\n");

textBox3.AppendText("pStartupInfo: "+parameters[10].ToString("X8")+"\r\n");
textBox3.AppendText("pProcessInfo: "+parameters[11].ToString("X8")+"\r\n");
textBox3.AppendText("hNewToken: "+parameters[12].ToString("X8")+"\r\n");

}

// clean old value:
WriteProcessMemory(hprocess,VirtualAlloc1,eraser,4, out BytesRead);


// suspend thread an let the user choose when to continue
SuspendThread(hcthread);
// finaly release second infinite loop:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc1+12),nops,2, out BytesRead);

}
}

if (VirtualAlloc2!=IntPtr.Zero&&ReadProcessMemory(hprocess,VirtualAlloc2,keeper,4, ref BytesRead))
{
if (keeper[0]!=0||keeper[1]!=0||keeper[2]!=0||keeper[2]!=0)
{
int ESPvalue = BitConverter.ToInt32(keeper,0);
byte[] eraser = new byte[]{0,0,0,0};
byte[] infiniteloop = new byte[]{0x0EB,0x0FE};
byte[] nops = new byte[]{0x090,0x090};

// write infinit loop to second:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc2+12),infiniteloop,2, out BytesRead);
// nop the first and write infinit loop back:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc2+10),nops,2, out BytesRead);
Sleep(2);
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc2+10),infiniteloop,2, out BytesRead);

textBox3.AppendText("\r\n");
textBox3.AppendText("CreateProcessW reached:"+"\r\n");
textBox3.AppendText("Value of ESP:"+ESPvalue.ToString("X8")+"\r\n");
byte[] parbytes = new byte[14*4];

if (ReadProcessMemory(hprocess,(IntPtr)ESPvalue,parbytes,(uint)parbytes.Length, ref BytesRead))
{
int[] parameters = new int[14];
for (int i=0;i<parameters.Length;i++)
{
parameters[i]=BitConverter.ToInt32(parbytes,i*4);
}

textBox3.AppendText("Return address: "+parameters[0].ToString("X8")+"\r\n");
textBox3.AppendText("hToken: "+parameters[1].ToString("X8")+"\r\n");
textBox3.AppendText("ModuleFileName: "+parameters[2].ToString("X8")+"  ");
string result = MemStringReader.ReadAsciiString(hprocess,(IntPtr)parameters[2]);
if (result!=null)
{
textBox3.AppendText(result);
}
textBox3.AppendText("\r\n");

textBox3.AppendText("CommandLine: "+parameters[3].ToString("X8")+"  ");
result = MemStringReader.ReadAsciiString(hprocess,(IntPtr)parameters[3]);
if (result!=null)
{
textBox3.AppendText(result);
}
textBox3.AppendText("\r\n");

textBox3.AppendText("pProcessSecurity: "+parameters[4].ToString("X8")+"\r\n");
textBox3.AppendText("pThreadSecurity: "+parameters[5].ToString("X8")+"\r\n");
textBox3.AppendText("InheritHandles: "+parameters[6].ToString("X8")+"\r\n");
textBox3.AppendText("CreationFlags: "+parameters[7].ToString("X8")+"\r\n");
textBox3.AppendText("pEnvironment: "+parameters[8].ToString("X8")+"\r\n");
textBox3.AppendText("CurrentDir: "+parameters[9].ToString("X8")+"  ");
result = MemStringReader.ReadAsciiString(hprocess,(IntPtr)parameters[9]);
if (result!=null)
{
textBox3.AppendText(result);
}
textBox3.AppendText("\r\n");

textBox3.AppendText("pStartupInfo: "+parameters[10].ToString("X8")+"\r\n");
textBox3.AppendText("pProcessInfo: "+parameters[11].ToString("X8")+"\r\n");
textBox3.AppendText("hNewToken: "+parameters[12].ToString("X8")+"\r\n");

}

// clean old value:
WriteProcessMemory(hprocess,VirtualAlloc2,eraser,4, out BytesRead);

// suspend thread an let the user choose when to continue
SuspendThread(hcthread);
// finaly release second infinite loop:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc2+12),nops,2, out BytesRead);

}
}

if (VirtualAlloc3!=IntPtr.Zero&&ReadProcessMemory(hprocess,VirtualAlloc3,keeper,4, ref BytesRead))
{
if (keeper[0]!=0||keeper[1]!=0||keeper[2]!=0||keeper[2]!=0)
{
int EBPvalue = BitConverter.ToInt32(keeper,0);

byte[] eraser = new byte[]{0,0,0,0};
byte[] infiniteloop = new byte[]{0x0EB,0x0FE};
byte[] nops = new byte[]{0x090,0x090};

// write infinit loop to second:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc3+0x1C),infiniteloop,2, out BytesRead);
// nop the first and write infinit loop back:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc3+0x1A),nops,2, out BytesRead);
Sleep(2);
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc3+0x1A),infiniteloop,2, out BytesRead);

textBox3.AppendText("\r\n");
textBox3.AppendText("memcpy reached:"+"\r\n");
textBox3.AppendText("Value of EBP:"+EBPvalue.ToString("X8")+"\r\n");

byte[] parbytes = new byte[5*4];

if (ReadProcessMemory(hprocess,(IntPtr)EBPvalue,parbytes,(uint)parbytes.Length, ref BytesRead))
{
int[] parameters = new int[5];
for (int i=0;i<parameters.Length;i++)
{
parameters[i]=BitConverter.ToInt32(parbytes,i*4);
}

textBox3.AppendText("Old ESP: "+parameters[0].ToString("X8")+"\r\n");
textBox3.AppendText("Return Address: "+parameters[1].ToString("X8")+"\r\n");
textBox3.AppendText("Source: "+parameters[3].ToString("X8"));
string result = MemStringReader.ReadAsciiString(hprocess,(IntPtr)parameters[3]);
if (result!=null)
{
textBox3.AppendText("  "+result);
}
textBox3.AppendText("\r\n");

textBox3.AppendText("len: (hex) "+parameters[4].ToString("X8")+"\r\n");
textBox3.AppendText("Destination: "+parameters[2].ToString("X8")+"\r\n");
}

// clean old value:
WriteProcessMemory(hprocess,VirtualAlloc3,eraser,4, out BytesRead);

// suspend thread an let the user choose when to continue
SuspendThread(hcthread);
// finaly release second infinite loop:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc3+0x1C),nops,2, out BytesRead);



}
}


}

}

void Button2Click(object sender, EventArgs e)
{
string filename = textBox1.Text;
string enviroments = textBox2.Text;

if (filename!=""&&File.Exists(filename))
{

int processflags = processflags = 0 | (int)ProcessCreationFlags.CREATE_SUSPENDED;
IntPtr memptr = IntPtr.Zero;
button2.Enabled = false;
textBox3.Text = "";
GCHandle gchenv = new GCHandle();

if (enviroments.Length!=0)
{
if (enviroments.Length>=3&&enviroments.Contains("="))
{
textBox3.AppendText("Setting Environment Variables...");

try
{

char[] separator = "\r\n".ToCharArray();
string[] realvalues = enviroments.Split(separator);
IntPtr newptr = memptr;
bool unicode = false;
if (Environment.OSVersion.Platform == PlatformID.Win32NT)
{
processflags = processflags | (int)ProcessCreationFlags.CREATE_UNICODE_ENVIRONMENT;
unicode = true;
}
StringDictionary environmentVariables = new StringDictionary();

// add Environments of the parent to the child!
foreach (System.Collections.DictionaryEntry entry in Environment.GetEnvironmentVariables())
{
environmentVariables.Add((string) entry.Key, (string) entry.Value);
}

for (int i=0;i<realvalues.Length;i++)
{
if (realvalues[i]!=""&&realvalues[i].Contains("="))
{
separator = "=".ToCharArray();
string[] currentvalue = realvalues[i].Split(separator);
if (currentvalue[0]!="")
{
if (environmentVariables.ContainsKey(currentvalue[0]))
{
textBox3.AppendText("\r\n"+"The key whit the name "+
	currentvalue[0]+" is already on dictinonary!");
}
else
{
environmentVariables.Add(currentvalue[0],currentvalue[1]);
}
}

}
}


gchenv = GCHandle.Alloc(ToByteArray(environmentVariables, unicode), GCHandleType.Pinned);
memptr = gchenv.AddrOfPinnedObject();

textBox3.AppendText("\r\n"+"Environment Variables setted!");
}
catch (Exception exc)
{
textBox3.AppendText("\r\n"+exc.Message+"\r\n");

}

}
else
{
textBox3.AppendText("Invalid Environment Variables!"+"\r\n");
}
}

STARTUPINFO structure = new STARTUPINFO();
PROCESS_INFORMATION process_information = new PROCESS_INFORMATION();
IntPtr lpApplicationName = Marshal.StringToHGlobalUni(filename);
try
{
CreateProcess(lpApplicationName, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, 0, processflags, memptr, IntPtr.Zero, ref structure, ref process_information);
hprocess = process_information.hProcess;
hcthread = process_information.hThread;
cprocessid = process_information.dwProcessId;
if (gchenv.IsAllocated)
gchenv.Free();

textBox3.AppendText("\r\n"+"Process created");
if (checkBox1.Checked)
{
textBox3.AppendText(" on suspended mode");
button3.Enabled = true;
}
textBox3.AppendText("!"+"\r\n");
}
catch (Exception ex3)
{
textBox3.AppendText("\r\n"+"Failed to start process whit the message"+
	                    ex3.Message+"\r\n");
return;
}

checktimer = new System.Windows.Forms.Timer();
checktimer.Interval = 30;
checktimer.Enabled = true;
checktimer.Tick += new System.EventHandler (CheckStatut);

if (checkBox2.Checked)
{
ProcModule.ModuleInfo[] modules = null;

for (int k=0;k<500;k++)  // try it 500 times!
{
LoopWhileModulesAreLoadedNt(process_information.dwProcessId,process_information.hThread);
modules = ProcModule.GetModuleInfos((int)process_information.dwProcessId);
if (modules!=null&&modules.Length>0)
{
for (int i=0;i<modules.Length;i++)
{
if (modules[i].baseName.ToLower().Contains("kernel32"))
{
targetkernel32 = modules[i];
break;
}
}
}
if (targetkernel32!=null)
break;
}

if (targetkernel32!=null&&targetkernel32.baseOfDll!=IntPtr.Zero)
HookCreateProcess(targetkernel32.baseOfDll);

}


if (checkBox3.Checked)
{
ProcModule.ModuleInfo[] modules = null;

for (int k=0;k<50;k++)  // try it 50 times!
{
LoopWhileModulesAreLoadedNt(process_information.dwProcessId,process_information.hThread);
modules = ProcModule.GetModuleInfos((int)process_information.dwProcessId);
if (modules!=null&&modules.Length>0)
{
for (int i=0;i<modules.Length;i++)
{
if (modules[i].baseName.Length>10&&modules[i].baseName.ToLower().StartsWith("msvcr"))
{
targetMSVCR80 = modules[i];
break;
}
}
}
if (targetMSVCR80!=null)
break;
}

if (targetMSVCR80!=null&&targetMSVCR80.baseOfDll!=IntPtr.Zero)
LogmemcpyInit(targetMSVCR80.baseOfDll);

}


if (!checkBox1.Checked)
{
ResumeThread(process_information.hThread);
}



}
else
{
textBox3.Text = "Please select a valid file!"+"\r\n";
}


		}





/*
CreateProcessW:
7C802332 >  8BFF         MOV EDI,EDI
7C802334    55           PUSH EBP
7C802335    8BEC         MOV EBP,ESP
7C802337    6A 00        PUSH 0
7C802339    FF75 2C      PUSH DWORD PTR SS:[EBP+2C]
7C80233C    FF75 28      PUSH DWORD PTR SS:[EBP+28]
7C80233F    FF75 24      PUSH DWORD PTR SS:[EBP+24]
7C802342    FF75 20      PUSH DWORD PTR SS:[EBP+20]
7C802345    FF75 1C      PUSH DWORD PTR SS:[EBP+1C] 
7C802348    FF75 18      PUSH DWORD PTR SS:[EBP+18]
7C80234B    FF75 14      PUSH DWORD PTR SS:[EBP+14]
7C80234E    FF75 10      PUSH DWORD PTR SS:[EBP+10]
7C802351    FF75 0C      PUSH DWORD PTR SS:[EBP+C]
7C802354    FF75 08      PUSH DWORD PTR SS:[EBP+8]
7C802357    6A 00        PUSH 0
7C802359    E8 C6730100  CALL 7C819724 ; KERNEL32.CreateProcessInternalW
7C80235E    5D           POP EBP
7C80235F    C2 2800      RETN 28

7C802367    8BFF          MOV EDI,EDI
7C802369    55            PUSH EBP
7C80236A    8BEC          MOV EBP,ESP
7C80236C    6A 00         PUSH 0
7C80236E    FF75 2C       PUSH DWORD PTR SS:[EBP+2C]
7C802371    FF75 28       PUSH DWORD PTR SS:[EBP+28]
7C802374    FF75 24       PUSH DWORD PTR SS:[EBP+24]
7C802377    FF75 20       PUSH DWORD PTR SS:[EBP+20]
7C80237A    FF75 1C       PUSH DWORD PTR SS:[EBP+1C]
7C80237D    FF75 18       PUSH DWORD PTR SS:[EBP+18]
7C802380    FF75 14       PUSH DWORD PTR SS:[EBP+14]
7C802383    FF75 10       PUSH DWORD PTR SS:[EBP+10]
7C802386    FF75 0C       PUSH DWORD PTR SS:[EBP+C]
7C802389    FF75 08       PUSH DWORD PTR SS:[EBP+8]
7C80238C    6A 00         PUSH 0
7C80238E    E8 2BB10100   CALL 7C81D4BE ; KERNEL32.CreateProcessInternalA
7C802393    5D            POP EBP
7C802394    C2 2800       RETN 28
*/
     
public static IntPtr VirtualAlloc1;
public static IntPtr VirtualAlloc2;
public static IntPtr VirtualAlloc3;

public void HookCreateProcess(IntPtr kernelbase)
{
if (cprocessid==0||hprocess==IntPtr.Zero) return;

int CreateProcessWRva = ExportTable.ProcGetExpAddress(
hprocess,kernelbase,"CreateProcessW");

int CreateProcessARva = ExportTable.ProcGetExpAddress(
hprocess,kernelbase,"CreateProcessA");

if (CreateProcessWRva==0||CreateProcessARva==0) return;

IntPtr CreateProcessWPatch1 = IntPtr.Zero;
IntPtr CreateProcessAPatch2 = IntPtr.Zero;

int tobecalled1 = 0;
int tobecalled2 = 0;

byte[] Forread = new byte[0x500];
uint BytesRead=0;
if (!ReadProcessMemory(hprocess,(IntPtr)((long)kernelbase+(long)CreateProcessWRva),Forread,(uint)0x500, ref BytesRead))
return;

int count = 0;
while (count<Forread.Length)
{
if (Forread[count]==0x0E8)
{
break;
}
count++;
}

long CreateProcessWcall = (long)kernelbase+(long)CreateProcessWRva+count;
tobecalled1 = BitConverter.ToInt32(Forread,count+1);
tobecalled1 = tobecalled1 + (int)CreateProcessWcall+5;
CreateProcessWPatch1 = (IntPtr)(CreateProcessWcall+1);

if (!ReadProcessMemory(hprocess,(IntPtr)((long)kernelbase+(long)CreateProcessARva),Forread,(uint)0x500, ref BytesRead))
return;

count = 0;
while (count<Forread.Length)
{
if (Forread[count]==0x0E8)
{
break;
}
count++;
}

long CreateProcessAcall = (long)kernelbase+(long)CreateProcessARva+count;
tobecalled2 = BitConverter.ToInt32(Forread,count+1);
tobecalled2 = tobecalled2 + (int)CreateProcessAcall+5;
CreateProcessAPatch2 = (IntPtr)(CreateProcessAcall+1);

// alocate memory for hooks:
VirtualAlloc1 = VirtualAllocEx(hprocess, IntPtr.Zero, 512, AllocationType.Commit, MemoryProtection.ReadWrite);
VirtualAlloc2 = VirtualAllocEx(hprocess, IntPtr.Zero, 512, AllocationType.Commit, MemoryProtection.ReadWrite);

if (VirtualAlloc1==IntPtr.Zero||VirtualAlloc2==IntPtr.Zero) return;

IntPtr bodyPlace1 = (IntPtr)((long)VirtualAlloc1+4);
IntPtr bodyPlace2 = (IntPtr)((long)VirtualAlloc2+4);

// body of first hook:
byte[] hoockbody = new byte[]{
0x89, 0x25, 0x34, 0x32, 0x24, 0x00,
0xEB, 0xFE,
0x90, 0x90,
0xBE, 0x35, 0x45, 0x53, 0x43,
0xFF, 0xE6};

byte[] fixer = BitConverter.GetBytes((int)VirtualAlloc1);

for (int k=0;k<fixer.Length;k++)
{
hoockbody[k+2]=fixer[k];
}

fixer = BitConverter.GetBytes(tobecalled1);

for (int k=0;k<fixer.Length;k++)
{
hoockbody[k+11]=fixer[k];
}

WriteProcessMemory(hprocess,bodyPlace1,hoockbody,(uint)hoockbody.Length,out BytesRead);

// body of second hook:
fixer = BitConverter.GetBytes((int)VirtualAlloc2);

for (int k=0;k<fixer.Length;k++)
{
hoockbody[k+2]=fixer[k];
}

fixer = BitConverter.GetBytes(tobecalled2);

for (int k=0;k<fixer.Length;k++)
{
hoockbody[k+11]=fixer[k];
}

WriteProcessMemory(hprocess,bodyPlace2,hoockbody,(uint)hoockbody.Length,out BytesRead);


// jump to my hoock1:
int jumptomyhook1 = (int)bodyPlace1-(int)CreateProcessWcall-5;
byte[] jumpbytes = BitConverter.GetBytes(jumptomyhook1);
WriteProcessMemory(hprocess,CreateProcessWPatch1,jumpbytes,(uint)jumpbytes.Length,out BytesRead);

// jump to my hoock2:
int jumptomyhook2 = (int)bodyPlace2-(int)CreateProcessAcall-5;
jumpbytes = BitConverter.GetBytes(jumptomyhook2);
WriteProcessMemory(hprocess,CreateProcessAPatch2,jumpbytes,(uint)jumpbytes.Length,out BytesRead);

textBox3.AppendText("CreateProcess hoocked!"+"\r\n");

}

/*
MSVCR80.memcpy:
78144FB0    55              PUSH EBP
78144FB1    8BEC            MOV EBP,ESP
78144FB3    57              PUSH EDI
78144FB4    56              PUSH ESI
78144FB5    8B75 0C         MOV ESI,DWORD PTR SS:[EBP+C]
78144FB8    8B4D 10         MOV ECX,DWORD PTR SS:[EBP+10]
78144FBB    8B7D 08         MOV EDI,DWORD PTR SS:[EBP+8]
78144FBE    8BC1            MOV EAX,ECX 

for finding right one: n should be >= size of one page:
00D40004    8B75 0C             MOV ESI,DWORD PTR SS:[EBP+C]
00D40007    8B4D 10             MOV ECX,DWORD PTR SS:[EBP+10]
00D4000A    817D 10 00100000    CMP DWORD PTR SS:[EBP+10],1000
00D40011    7D 01               JGE SHORT 00D40014
00D40013    C3                  RETN
; do my code!


 */ 
 
public void LogmemcpyInit(IntPtr MSVCR80base)
{
if (cprocessid==0||hprocess==IntPtr.Zero) return;

int memcpyRva = ExportTable.ProcGetExpAddress(
hprocess,MSVCR80base,"memcpy");

if (memcpyRva==0) return;

byte[] Forread = new byte[0x50];
uint BytesRead=0;
if (!ReadProcessMemory(hprocess,(IntPtr)((long)MSVCR80base+(long)memcpyRva),Forread,0x50, ref BytesRead))
return;


int count = 0;
while (count<Forread.Length)
{
if (Forread[count]==0x8B&&Forread[count+1]<0x80)
{
break;
}
count++;
}

byte[] oldbytes = new byte[6];
for (int i=0;i<oldbytes.Length;i++)
{
oldbytes[i]=Forread[count+i];
}
// alocate memory for hook:
VirtualAlloc3 = VirtualAllocEx(hprocess, IntPtr.Zero, 512, AllocationType.Commit, MemoryProtection.ReadWrite);
if (VirtualAlloc3==IntPtr.Zero) return;

// write old bytes under my code cave!
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc3+4),oldbytes,(uint)oldbytes.Length,out BytesRead);

byte[] mycode = new byte[]
{ 0x81, 0x7D, 0x10, 0x00, 0x20, 0x00, 0x00, 0x7D, 0x01, 0xC3 };

// write my code:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc3+oldbytes.Length+4),mycode,(uint)mycode.Length,out BytesRead);


// body of first hook:
byte[] hoockbody = new byte[]
{ 0x89, 0x2D, 0x34, 0x32, 0x24, 0x00,
0xEB, 0xFE,
0x90, 0x90,
0x0C3
};

byte[] fixer = BitConverter.GetBytes((int)VirtualAlloc3);

for (int k=0;k<fixer.Length;k++)
{
hoockbody[k+2]=fixer[k];
}

// write hoock body:
WriteProcessMemory(hprocess,(IntPtr)((long)VirtualAlloc3+mycode.Length+oldbytes.Length+4),hoockbody,(uint)hoockbody.Length,out BytesRead);


// jump to my hoock3:
int jumptomyhook3 = (int)VirtualAlloc3+4-(int)MSVCR80base-memcpyRva-count-5;
byte[] jumpbytes = BitConverter.GetBytes(jumptomyhook3);

oldbytes[0]=0xE8;  // E8 = call
oldbytes[5]=0x90;  // last byte nop
for (int i=0;i<4;i++)
{
oldbytes[i+1]=jumpbytes[i];
}

WriteProcessMemory(hprocess,(IntPtr)((long)MSVCR80base+(long)memcpyRva+count),oldbytes,(uint)oldbytes.Length,out BytesRead);


textBox3.AppendText("Logging memcpy enabled!"+"\r\n");

}
		
void Button3Click(object sender, EventArgs e)
{
if (hcthread!=IntPtr.Zero)
{
ResumeThread(hcthread);
}
 //textBox3.SelectionStart = textBox3.Text.Length;
 //textBox3.ScrollToCaret();
 //textBox3.Refresh();


}
		
void ProcessManagerFormClosing(object sender, FormClosingEventArgs e)
{
uint exitcode = 0;
GetExitCodeProcess(hprocess,out exitcode);

if (exitcode==259)  // STILL_ACTIVE = 259
{


}

}
		
}
}



================================================
File: MegaDumper/ProcessManager.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/Program.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 11.10.2010
 * Time: 15:47
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Collections;
using System.Collections.Generic;
using System.Resources;
using System.Data;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Threading;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.IO.IsolatedStorage;
using System.Globalization;

namespace Mega_Dumper
{
	
	/// <summary>
	/// Class with program entry point.
	/// </summary>
	internal sealed class Program
	{
		
		/// <summary>
		/// Program entry point.
		/// </summary>
		[STAThread]
        private static void Main(string[] args)
		{
		Application.EnableVisualStyles();
		Application.Run(new MainForm());
			
		}
		
	}
}



================================================
File: MegaDumper/ViewWindowsHoocks.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 02.03.2011
 * Time: 00:20
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class ViewWindowsHoocks
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// textBox1
			// 
			this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.textBox1.Location = new System.Drawing.Point(0, 0);
			this.textBox1.Multiline = true;
			this.textBox1.Name = "textBox1";
			this.textBox1.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.textBox1.Size = new System.Drawing.Size(476, 290);
			this.textBox1.TabIndex = 0;
			// 
			// ViewWindowsHoocks
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(475, 289);
			this.Controls.Add(this.textBox1);
			this.Name = "ViewWindowsHoocks";
			this.Text = "Windows Hoocks from System:";
			this.Shown += new System.EventHandler(this.ViewWindowsHoocksShown);
			this.ResumeLayout(false);
			this.PerformLayout();
		}
		private System.Windows.Forms.TextBox textBox1;
	}
}



================================================
File: MegaDumper/ViewWindowsHoocks.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 02.03.2011
 * Time: 00:20
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;
using System.Reflection;

namespace Mega_Dumper
{
	/// <summary>
	/// Description of ViewWindowsHoocks.
	/// </summary>
	public partial class ViewWindowsHoocks : Form
	{
		public ViewWindowsHoocks()
		{
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}
		
[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern uint GetModuleHandleW(string libname);
 
[DllImport("kernel32.dll", CharSet=CharSet.Ansi)]
unsafe static extern byte* GetProcAddress(uint hModule, string procName);

[DllImport("ntdll.dll")]
public static extern uint NtCurrentTeb();

public enum HookType : uint
{
     WH_JOURNALRECORD = 0,
     WH_JOURNALPLAYBACK = 1,
     WH_KEYBOARD = 2,
     WH_GETMESSAGE = 3,
     WH_CALLWNDPROC = 4,
     WH_CBT = 5,
     WH_SYSMSGFILTER = 6,
     WH_MOUSE = 7,
     WH_HARDWARE = 8,
     WH_DEBUG = 9,
     WH_SHELL = 10,
     WH_FOREGROUNDIDLE = 11,
     WH_CALLWNDPROCRET = 12,    
     WH_KEYBOARD_LL = 13,
     WH_MOUSE_LL = 14
}

/*
typedef struct _HOOK
{
    // 0x00  ULONG Handle;
    // 0x04  ULONG LockObj;
	// 0x08  PVOID ThreadInfo;
	// 0x0C  PVOID Desktop1;
	// 0x10  PVOID Self;
    // 0x14  PVOID NextHook;
    // 0x18  LONG HookType;
    // 0x1C  PVOID FunctionAddress;
    // 0x20  ULONG Flags;
    // 0x24  ULONG ModuleHandle;
    // 0x28  PVOID Hooked;
    // 0x2C  PVOID Desktop2;
    // 0x30 
}
or

typedef struct _HOOK {
ULONG hHook;
ULONG cLockObj;
PTHREADINFO pti;
ULONG rpdesk;
ULONG pSelf;
struct _HOOK *phkNext;
int iHook;
ULONG offPfn;
unsigned int flags;
int ihmod;
PTHREADINFO ptiHooked;
PDESKTOP rpdesk;
} HOOK, *PHOOK;

Fields:
- hHook
Handle to the hook procedure, itâ€™s the value returned by SetWindowsHookEx and it comes from HMAllocObject
- clockObj
  unknown !!!
- pti
Pointer to THREADINFO structure of the process which sets the hook
- rpdesk
  unknown !!!
- pSelf
Pointer to this HOOK structure
- phkNext
Next structure in the hook chain
- iHook
Hook type (i.e. WH_MOUSE or WH_KEYBOARD). This is the first parameter
passed to SetWindowsHookEx
- offPfn
Offset of the filter procedure, it is obtained by a simple substration
between the address of the hook procedure and the initial address of the dll
- flags
HF_xxx flags (HF_GLOBALS, HF_LOCAL, HF_DESTROYEDâ€¦)
- ihmod
Number of hooks set into the module
- ptiHooked
Pointer to THREADINFO structure of the hooked thread. If HF_GLOBAL
is setted the pointer is setted to NULL because the hook works for
every running thread


 */
 

unsafe void LogAllHooks()
{

/* at the end of USER32!UserRegisterWowHandlers:
7e4537f5 b8a010477e mov     eax,offset USER32!gSharedInfo (7e4710a0)
7e4537fa 5d         pop     ebp
7e4537fb c20800     ret     8
*/
string hoocktext = "";
hoocktext = hoocktext+"Init variables:"+"\r\n";
uint pgSharedInfo = 0x77D700A0;
uint* pointer = null;
byte* UserRegisterWowHandlers = GetProcAddress(GetModuleHandleW("user32.dll"), "UserRegisterWowHandlers");

hoocktext = hoocktext+"user32.UserRegisterWowHandlers: "+
 ((uint)UserRegisterWowHandlers).ToString("X8")+"\r\n";

uint i=0;
do
{
if (UserRegisterWowHandlers[i]==0x0B8)
{
pointer = (uint*)(UserRegisterWowHandlers+i+1);
pgSharedInfo = pointer[0]; // get SharedInfo
break;
}
i++;
} while (i<0x256);

hoocktext = hoocktext+"USER32!gSharedInfo: "+pgSharedInfo.ToString("X8")+"\r\n";
 
uint ptrSharedDelta = NtCurrentTeb()+0x6CC;  // 0x7FFDF000
hoocktext = hoocktext+"ptrSharedDelta: "+ptrSharedDelta.ToString("X8")+"\r\n";
uint SharedDelta = ((uint*)(ptrSharedDelta))[7];
hoocktext = hoocktext+"SharedDelta: "+SharedDelta.ToString("X8")+"\r\n";
pointer = (uint*)(((uint*)(pgSharedInfo))[0]);
uint HandleEntries = pointer[2];
hoocktext = hoocktext+"HandleEntries: "+HandleEntries.ToString("X8")+"\r\n";
uint UserHandleTable = ((uint*)(pgSharedInfo))[1];
hoocktext = hoocktext+"UserHandleTable: "+UserHandleTable.ToString("X8")+"\r\n";
hoocktext = hoocktext+"\r\n";
hoocktext = hoocktext+"Start login hooks..."+"\r\n";

for(i=0; i<HandleEntries; i++)
{

//i*12
byte* hook = (byte*)(i*12+UserHandleTable);
// _HANDLE_ENTRY
if (hook[8]==5) // if _HANDLE_ENTRY.Type is TYPE_HOOK
{
try
{

hoocktext = hoocktext+"\r\n";
hoocktext = hoocktext+"HOOK: "+((uint)hook).ToString("X8")+"\r\n";
uint HookInfo = ((uint*)(hook))[0] - SharedDelta;
hoocktext = hoocktext+"HookInfo: "+HookInfo.ToString("X8")+"\r\n";
uint hookhandle = ((uint*)(HookInfo))[0];
hoocktext = hoocktext+"HookHadle: "+hookhandle.ToString("X8")+"\r\n";
// ---------------------------------------------------
uint LockObj = ((uint*)(HookInfo))[1];
hoocktext = hoocktext+"LockObj: "+LockObj.ToString("X8")+"\r\n";;
uint threadinfov = ((uint*)(HookInfo))[2];
hoocktext = hoocktext+"ThreadInfo: "+threadinfov.ToString("X8")+"\r\n";
uint desktop1 = ((uint*)(HookInfo))[3];
hoocktext = hoocktext+"Desktop1: "+desktop1.ToString("X8")+"\r\n";
uint selfv = ((uint*)(HookInfo))[4];
hoocktext = hoocktext+"Self: "+selfv.ToString("X8")+"\r\n";
uint nexthookv = ((uint*)(HookInfo))[5];
hoocktext = hoocktext+"NextHook: "+nexthookv.ToString("X8")+"\r\n";
// Important values comes here:
// WH_CBT = 5 - are global hooks
uint hooktype = ((uint*)(HookInfo))[6];
if (hooktype<=14)
hoocktext = hoocktext+"HookType: "+((HookType)hooktype).ToString()+
             " - "+hooktype.ToString("X8")+"\r\n";
else
hoocktext = hoocktext+"HookType: "+((HookType)hooktype).ToString()+"\r\n";
	             
uint functionrva = ((uint*)(HookInfo))[7];
hoocktext = hoocktext+"FunctionRVA: "+functionrva.ToString("X8")+"\r\n";
uint flagsv = ((uint*)(HookInfo))[8];

string flagsstring = "";
if ((flagsv&1)!=0)  // G_HOOK_FLAG_ACTIVE = 1
{
flagsstring = "G_HOOK_FLAG_ACTIVE";
}

if ((flagsv&2)!=0)  // G_HOOK_FLAG_IN_CALL = 2
{
if (flagsstring!="") flagsstring=flagsstring+",";
flagsstring = flagsstring+"G_HOOK_FLAG_IN_CALL";
}
/*
#define HF_GLOBAL 0x0001
#define HF_ANSI 0x0002
#define HF_NEEDHC_SKIP 0x0004
#define HF_HUNG 0x0008
#define HF_HOOKFAULTED 0x0010
#define HF_NOPLAYBACKDELAY 0x0020
#define HF_WX86KNOWINDOWLL 0x0040
#define HF_DESTROYED 0x0080
 */

hoocktext = hoocktext+"Flags: "+flagsstring+" - "+flagsv.ToString("X8")+"\r\n";
uint ihmod = ((uint*)(HookInfo))[9];
hoocktext = hoocktext+"ModuleHooksCount: "+ihmod.ToString("X8")+"\r\n";
uint hookedp = ((uint*)(HookInfo))[10];
hoocktext = hoocktext+"ptiHooked: "+hookedp.ToString("X8")+"\r\n";
uint desktop2v = ((uint*)(HookInfo))[11];
hoocktext = hoocktext+"Desktop2: "+desktop2v.ToString("X8")+"\r\n";


}
catch
{

}

}
}
textBox1.Text = hoocktext;
}

void ViewWindowsHoocksShown(object sender, EventArgs e)
{
LogAllHooks();
}

		

}
}



================================================
File: MegaDumper/ViewWindowsHoocks.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/VirtualMemoryView.Designer.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 02.03.2011
 * Time: 00:47
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
namespace Mega_Dumper
{
	partial class VirtualMemoryView
	{
		/// <summary>
		/// Designer variable used to keep track of non-visual components.
		/// </summary>
		private System.ComponentModel.IContainer components = null;
		
		/// <summary>
		/// Disposes resources used by the form.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing) {
				if (components != null) {
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		
		/// <summary>
		/// This method is required for Windows Forms designer support.
		/// Do not change the method contents inside the source code editor. The Forms designer might
		/// not be able to load this method if it was changed manually.
		/// </summary>
		private void InitializeComponent()
		{
			this.lvvirtualmem = new System.Windows.Forms.ListView();
			this.alocbase = new System.Windows.Forms.ColumnHeader();
			this.ap = new System.Windows.Forms.ColumnHeader();
			this.ba = new System.Windows.Forms.ColumnHeader();
			this.prot = new System.Windows.Forms.ColumnHeader();
			this.ressize = new System.Windows.Forms.ColumnHeader();
			this.state = new System.Windows.Forms.ColumnHeader();
			this.type = new System.Windows.Forms.ColumnHeader();
			this.additional = new System.Windows.Forms.ColumnHeader();
			this.SuspendLayout();
			// 
			// lvvirtualmem
			// 
			this.lvvirtualmem.Alignment = System.Windows.Forms.ListViewAlignment.Default;
			this.lvvirtualmem.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
									| System.Windows.Forms.AnchorStyles.Left) 
									| System.Windows.Forms.AnchorStyles.Right)));
			this.lvvirtualmem.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
									this.alocbase,
									this.ap,
									this.ba,
									this.prot,
									this.ressize,
									this.state,
									this.type,
									this.additional});
			this.lvvirtualmem.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(238)));
			this.lvvirtualmem.FullRowSelect = true;
			this.lvvirtualmem.Location = new System.Drawing.Point(-1, 0);
			this.lvvirtualmem.MultiSelect = false;
			this.lvvirtualmem.Name = "lvvirtualmem";
			this.lvvirtualmem.Size = new System.Drawing.Size(876, 338);
			this.lvvirtualmem.TabIndex = 10;
			this.lvvirtualmem.UseCompatibleStateImageBehavior = false;
			this.lvvirtualmem.View = System.Windows.Forms.View.Details;
			// 
			// alocbase
			// 
			this.alocbase.Text = "AllocationBase";
			this.alocbase.Width = 105;
			// 
			// ap
			// 
			this.ap.Text = "AllocationProtect";
			this.ap.Width = 106;
			// 
			// ba
			// 
			this.ba.Text = "BaseAddress";
			this.ba.Width = 83;
			// 
			// prot
			// 
			this.prot.Text = "Protect";
			this.prot.Width = 88;
			// 
			// ressize
			// 
			this.ressize.Text = "RegionSize";
			this.ressize.Width = 82;
			// 
			// state
			// 
			this.state.Text = "State";
			// 
			// type
			// 
			this.type.Text = "Type";
			// 
			// additional
			// 
			this.additional.Text = "Additional";
			this.additional.Width = 198;
			// 
			// VirtualMemoryView
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(875, 336);
			this.Controls.Add(this.lvvirtualmem);
			this.Name = "VirtualMemoryView";
			this.Text = "VirtualMemoryView";
			this.Shown += new System.EventHandler(this.VirtualMemoryViewShown);
			this.ResumeLayout(false);
		}
		private System.Windows.Forms.ColumnHeader additional;
		private System.Windows.Forms.ColumnHeader alocbase;
		private System.Windows.Forms.ColumnHeader ap;
		private System.Windows.Forms.ColumnHeader prot;
		private System.Windows.Forms.ColumnHeader type;
		private System.Windows.Forms.ColumnHeader state;
		private System.Windows.Forms.ColumnHeader ressize;
		private System.Windows.Forms.ColumnHeader ba;
		private System.Windows.Forms.ListView lvvirtualmem;
	}
}



================================================
File: MegaDumper/VirtualMemoryView.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 02.03.2011
 * Time: 00:47
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Collections;
using System.Text;

namespace Mega_Dumper
{

	/// <summary>
	/// Description of VirtualMemoryView.
	/// </summary>
	public partial class VirtualMemoryView : Form
	{
		public int procid;
		public string processname;
		public VirtualMemoryView(int iprocid,string prname)
		{
		procid = iprocid;
		processname = prname;
			//
			// The InitializeComponent() call is required for Windows Forms designer support.
			//
			InitializeComponent();
			
			//
			// TODO: Add constructor code after the InitializeComponent() call.
			//
		}


[StructLayout(LayoutKind.Sequential)]
private struct SYSTEM_INFO
{
	public uint dwOemId;
	public uint dwPageSize;
	public uint lpMinimumApplicationAddress;
	public uint lpMaximumApplicationAddress;
	public uint dwActiveProcessorMask;
	public uint dwNumberOfProcessors;
	public uint dwProcessorType;
	public uint dwAllocationGranularity;
	public uint dwProcessorLevel;
	public uint dwProcessorRevision;
}

    [StructLayout(LayoutKind.Sequential)]
    public struct MemoryBasicInformation
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public MemoryProtection AllocationProtect;
        public IntPtr RegionSize;
        public MemoryState State;
        public MemoryProtection Protect;
        public MemoryType Type;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 16)]
    public struct MemoryBasicInformation64
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public MemoryProtection AllocationProtect;
        private int _alignment1;
        public ulong RegionSize;
        public MemoryState State;
        public MemoryProtection Protect;
        public MemoryType Type;
        private int _alignment2;
    }
    
    [Flags]
    public enum MemoryProtection : uint
    {
        AccessDenied = 0x0,
        Execute = 0x10,
        ExecuteRead = 0x20,
        ExecuteReadWrite = 0x40,
        ExecuteWriteCopy = 0x80,
        Guard = 0x100,
        NoCache = 0x200,
        WriteCombine = 0x400,
        NoAccess = 0x01,
        ReadOnly = 0x02,
        ReadWrite = 0x04,
        WriteCopy = 0x08
    }

[DllImport("kernel32")]
private static extern void GetSystemInfo(ref SYSTEM_INFO pSI); 

[DllImport("kernel32.dll")]
public static extern bool VirtualQueryEx(IntPtr hProcess,
uint lpAddress, out MemoryBasicInformation lpBuffer,
uint dwLength);

[DllImport("psapi.dll", SetLastError = true, CharSet = CharSet.Unicode)]
public static extern int GetMappedFileName(
[In] int ProcessHandle,
[In] IntPtr Address,
[Out] StringBuilder Buffer,
[In] int Size);

[Flags]
public enum MemoryState : uint
{
    Commit = 0x1000,
    Decommit = 0x4000,
    Free = 0x10000,
    LargePages = 0x20000000,
    Physical = 0x400000,
    Release = 0x8000,
    Reserve = 0x2000,
    Reset = 0x80000
}

public enum MemoryType
{
    Image = 0x1000000,
    Mapped = 0x40000,
    Private = 0x20000
}

 
public static MemoryBasicInformation mbi;

[DllImport("psapi.dll", SetLastError = true)]
private static extern uint GetMappedFileName(IntPtr m_hProcess, IntPtr lpv,
out string lpFilename, uint nSize);

[DllImport("kernel32.dll")]
static extern IntPtr OpenProcess(UInt32 dwDesiredAccess,  Int32 bInheritHandle, UInt32 dwProcessId);
     	
private const uint PROCESS_TERMINATE = 0x0001;
private const uint PROCESS_CREATE_THREAD = 0x0002;
private const uint PROCESS_SET_SESSIONID = 0x0004;
private const uint PROCESS_VM_OPERATION = 0x0008;
private const uint PROCESS_VM_READ = 0x0010;
private const uint PROCESS_VM_WRITE = 0x0020;
private const uint PROCESS_DUP_HANDLE = 0x0040;
private const uint PROCESS_CREATE_PROCESS = 0x0080;
private const uint PROCESS_SET_QUOTA = 0x0100;
private const uint PROCESS_SET_INFORMATION = 0x0200;
private const uint PROCESS_QUERY_INFORMATION = 0x0400;
			
public void GetVirtualmemoryBlocks()
{

SYSTEM_INFO pSI = new SYSTEM_INFO();
GetSystemInfo(ref pSI);
uint i = 0;

IntPtr hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_TERMINATE, 0, (uint)procid);

while (i < pSI.lpMaximumApplicationAddress)
{
if (VirtualQueryEx(hProcess,i,
out mbi,(uint)System.Runtime.InteropServices.Marshal.SizeOf(mbi))
)
{
uint alocbase = (uint)mbi.AllocationBase;



string mappedname = "";
if (mbi.Type == MemoryType.Mapped)
{
StringBuilder sb = new StringBuilder(1024);
GetMappedFileName(-1,mbi.BaseAddress,sb,1024);
if (sb.Length!=0)
{
mappedname = sb.ToString();
}
}

string[] prcdetails = new string[]{
mbi.BaseAddress.ToString("X8"),mbi.AllocationProtect.ToString(),
alocbase.ToString("X8"),mbi.Protect.ToString(),mbi.RegionSize.ToString("X8"),
mbi.State.ToString(),mbi.Type.ToString(),mappedname};
ListViewItem proc = new ListViewItem(prcdetails);
lvvirtualmem.Items.Add(proc);


i = (uint)mbi.BaseAddress + (uint)mbi.RegionSize;


}
}


}

		void VirtualMemoryViewShown(object sender, EventArgs e)
		{
this.Text="Virtual memory for "+processname+" whit PID="+procid.ToString();
GetVirtualmemoryBlocks();

		}
		

	}
}



================================================
File: MegaDumper/VirtualMemoryView.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: MegaDumper/Properties/AssemblyInfo.cs
================================================
ï»¿#region Using directives

using System;
using System.Reflection;
using System.Runtime.InteropServices;

#endregion

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("MegaDumper")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("MegaDumper")]
[assembly: AssemblyCopyright("Copyright 2011")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// This sets the default COM visibility of types in the assembly to invisible.
// If you need to expose a type to COM, use [ComVisible(true)] on that type.
[assembly: ComVisible(false)]

// The assembly version has following format :
//
// Major.Minor.Build.Revision
//
// You can specify all the values or you can use the default the Revision and 
// Build Numbers by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.*")]



================================================
File: MegaDumper/Utils/EnumWindows.cs
================================================
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;

namespace WinEnumerator
{
	/// <summary>
	/// Window Style Flags
	/// </summary>
	[Flags]
	public enum WindowStyleFlags : uint
	{
		WS_OVERLAPPED      = 0x00000000,
		WS_POPUP           = 0x80000000,
		WS_CHILD           = 0x40000000,
		WS_MINIMIZE        = 0x20000000,
		WS_VISIBLE         = 0x10000000,
		WS_DISABLED        = 0x08000000,
		WS_CLIPSIBLINGS    = 0x04000000,
		WS_CLIPCHILDREN    = 0x02000000,
		WS_MAXIMIZE        = 0x01000000,
		WS_BORDER          = 0x00800000,
		WS_DLGFRAME        = 0x00400000,
		WS_VSCROLL         = 0x00200000,
		WS_HSCROLL         = 0x00100000,
		WS_SYSMENU         = 0x00080000,
		WS_THICKFRAME      = 0x00040000,
		WS_GROUP           = 0x00020000,
		WS_TABSTOP         = 0x00010000,
		WS_MINIMIZEBOX     = 0x00020000,
		WS_MAXIMIZEBOX     = 0x00010000,
	}
	
	/// <summary>
	/// Extended Windows Style flags
	/// </summary>
	[Flags]
	public enum ExtendedWindowStyleFlags : int
	{
		 WS_EX_DLGMODALFRAME    = 0x00000001,
		 WS_EX_NOPARENTNOTIFY   = 0x00000004,
		 WS_EX_TOPMOST          = 0x00000008,
		 WS_EX_ACCEPTFILES      = 0x00000010,
		 WS_EX_TRANSPARENT      = 0x00000020,

		 WS_EX_MDICHILD         = 0x00000040,
		 WS_EX_TOOLWINDOW       = 0x00000080,
		 WS_EX_WINDOWEDGE       = 0x00000100,
		 WS_EX_CLIENTEDGE       = 0x00000200,
		 WS_EX_CONTEXTHELP      = 0x00000400,

		 WS_EX_RIGHT            = 0x00001000,
		 WS_EX_LEFT             = 0x00000000,
		 WS_EX_RTLREADING       = 0x00002000,
		 WS_EX_LTRREADING       = 0x00000000,
		 WS_EX_LEFTSCROLLBAR    = 0x00004000,
		 WS_EX_RIGHTSCROLLBAR   = 0x00000000,

		 WS_EX_CONTROLPARENT    = 0x00010000,
		 WS_EX_STATICEDGE       = 0x00020000,
		 WS_EX_APPWINDOW        = 0x00040000,

		 WS_EX_LAYERED          = 0x00080000,

		 WS_EX_NOINHERITLAYOUT  = 0x00100000, // Disable inheritence of mirroring by children
		 WS_EX_LAYOUTRTL        = 0x00400000, // Right to left mirroring

		 WS_EX_COMPOSITED       = 0x02000000,
		 WS_EX_NOACTIVATE       = 0x08000000
	}


	#region EnumWindows
	/// <summary>
	/// EnumWindows wrapper for .NET
	/// </summary>
	public class EnumWindows
	{
		#region Delegates
		private delegate int EnumWindowsProc(IntPtr hwnd, int lParam);
		#endregion

		#region UnManagedMethods
		private class UnManagedMethods
		{
			[DllImport("user32")]
			public extern static int EnumWindows (
				EnumWindowsProc lpEnumFunc, 
				int lParam);
			[DllImport("user32")]
			public extern static int EnumChildWindows (
				IntPtr hWndParent,
				EnumWindowsProc lpEnumFunc, 
				int lParam);
		}
		#endregion

		#region Member Variables
		private EnumWindowsCollection items = null;
		#endregion

		/// <summary>
		/// Returns the collection of windows returned by
		/// GetWindows
		/// </summary>
		public EnumWindowsCollection Items
		{
			get
			{
				return this.items;
			}
		}

		/// <summary>
		/// Gets all top level windows on the system.
		/// </summary>
		public void GetWindows()
		{
			this.items = new EnumWindowsCollection();
			UnManagedMethods.EnumWindows(
				new EnumWindowsProc(this.WindowEnum),
				0);
		}
		/// <summary>
		/// Gets all child windows of the specified window
		/// </summary>
		/// <param name="hWndParent">Window Handle to get children for</param>
		public void GetWindows(
			IntPtr hWndParent)
		{
			this.items = new EnumWindowsCollection();
			UnManagedMethods.EnumChildWindows(
				hWndParent,
				new EnumWindowsProc(this.WindowEnum),
				0);
		}

		#region EnumWindows callback
		/// <summary>
		/// The enum Windows callback.
		/// </summary>
		/// <param name="hWnd">Window Handle</param>
		/// <param name="lParam">Application defined value</param>
		/// <returns>1 to continue enumeration, 0 to stop</returns>
		private int WindowEnum(
			IntPtr hWnd,
			int lParam)
		{
			if (this.OnWindowEnum(hWnd))
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		#endregion

		/// <summary>
		/// Called whenever a new window is about to be added
		/// by the Window enumeration called from GetWindows.
		/// If overriding this function, return true to continue
		/// enumeration or false to stop.  If you do not call
		/// the base implementation the Items collection will
		/// be empty.
		/// </summary>
		/// <param name="hWnd">Window handle to add</param>
		/// <returns>True to continue enumeration, False to stop</returns>
		protected virtual bool OnWindowEnum(
			IntPtr hWnd)
		{
			items.Add(hWnd);
			return true;
		}

		#region Constructor, Dispose
		public EnumWindows()
		{
			// nothing to do
		}
		#endregion
	}	
	#endregion EnumWindows

	#region EnumWindowsCollection
	/// <summary>
	/// Holds a collection of Windows returned by GetWindows.
	/// </summary>
	public class EnumWindowsCollection : ReadOnlyCollectionBase
	{
		/// <summary>
		/// Add a new Window to the collection.  Intended for
		/// internal use by EnumWindows only.
		/// </summary>
		/// <param name="hWnd">Window handle to add</param>
		public void Add(IntPtr hWnd)
		{
			EnumWindowsItem item = new EnumWindowsItem(hWnd);
			this.InnerList.Add(item);
		}

		/// <summary>
		/// Gets the Window at the specified index
		/// </summary>
		public EnumWindowsItem this[int index]
		{
			get
			{
				return (EnumWindowsItem)this.InnerList[index];
			}
		}

		/// <summary>
		/// Constructs a new EnumWindowsCollection object.
		/// </summary>
		public EnumWindowsCollection()
		{
			// nothing to do
		}
	}
	#endregion		

	#region EnumWindowsItem
	/// <summary>
	/// Provides details about a Window returned by the 
	/// enumeration
	/// </summary>
	public class EnumWindowsItem
	{
		#region Structures
		[StructLayout(LayoutKind.Sequential, Pack = 4)]
		private struct RECT
		{
			public int Left;
			public int Top;
			public int Right;
			public int Bottom;
		}
		[StructLayout(LayoutKind.Sequential, Pack = 4)]
		private struct FLASHWINFO
		{
			public int cbSize;
			public IntPtr hwnd;
			public int dwFlags;
			public int uCount;
			public int dwTimeout;
		}
		#endregion

		#region UnManagedMethods
		private class UnManagedMethods
		{
			[DllImport("user32")]
			public extern static int IsWindowVisible (
				IntPtr hWnd);
			[DllImport("user32", CharSet = CharSet.Auto)]
			public extern static int GetWindowText(
				IntPtr hWnd, 
				StringBuilder lpString, 
				int cch);
			[DllImport("user32", CharSet = CharSet.Auto)]
			public extern static int GetWindowTextLength(
				IntPtr hWnd);
			[DllImport("user32")]
			public extern static int BringWindowToTop (IntPtr hWnd);
			[DllImport("user32")]
			public extern static int SetForegroundWindow (IntPtr hWnd);
			[DllImport("user32")]
			public extern static int IsIconic(IntPtr hWnd);
			[DllImport("user32")]
			public extern static int IsZoomed(IntPtr hwnd);
			[DllImport("user32", CharSet = CharSet.Auto)]
			public extern static int GetClassName (
				IntPtr hWnd, 
				StringBuilder lpClassName, 
				int nMaxCount);
			[DllImport("user32")]
			public extern static int FlashWindow (
				IntPtr hWnd,
				ref FLASHWINFO pwfi);
			[DllImport("user32")]
			public extern static int GetWindowRect (
				IntPtr hWnd, 
				ref RECT lpRect);
			[DllImport("user32", CharSet = CharSet.Auto)]
			public extern static int SendMessage(
				IntPtr hWnd, 
				int wMsg, 
				IntPtr wParam, 
				IntPtr lParam);
			[DllImport("user32", CharSet = CharSet.Auto)]
			public extern static uint GetWindowLong (
				IntPtr hwnd, 
				int nIndex);
			public const int WM_COMMAND = 0x111;
			public const int WM_SYSCOMMAND = 0x112;
				
			public const int SC_RESTORE = 0xF120;
			public const int SC_CLOSE = 0xF060;
			public const int SC_MAXIMIZE = 0xF030;
			public const int SC_MINIMIZE = 0xF020;

			public const int GWL_STYLE = (-16);
			public const int GWL_EXSTYLE = (-20);

			/// <summary>
			/// Stop flashing. The system restores the window to its original state.
			/// </summary>
			public const int FLASHW_STOP = 0;
			/// <summary>
			/// Flash the window caption. 
			/// </summary>
			public const int FLASHW_CAPTION = 0x00000001;
			/// <summary>
			/// Flash the taskbar button.
			/// </summary>
			public const int FLASHW_TRAY = 0x00000002;
			/// <summary>
			/// Flash both the window caption and taskbar button.
			/// </summary>
			public const int FLASHW_ALL = (FLASHW_CAPTION | FLASHW_TRAY);
			/// <summary>
			/// Flash continuously, until the FLASHW_STOP flag is set.
			/// </summary>
			public const int FLASHW_TIMER = 0x00000004;
			/// <summary>
			/// Flash continuously until the window comes to the foreground. 
			/// </summary>
			public const int FLASHW_TIMERNOFG = 0x0000000C;
		}
		#endregion

		/// <summary>
		/// The window handle.
		/// </summary>
		private IntPtr hWnd = IntPtr.Zero;

		/// <summary>
		/// To allow items to be compared, the hash code
		/// is set to the Window handle, so two EnumWindowsItem
		/// objects for the same Window will be equal.
		/// </summary>
		/// <returns>The Window Handle for this window</returns>
		public override System.Int32 GetHashCode()
		{
			return (System.Int32)this.hWnd;
		}

		/// <summary>
		/// Gets the window's handle
		/// </summary>
		public IntPtr Handle
		{
			get
			{
				return this.hWnd;
			}
		}

		/// <summary>
		/// Gets the window's title (caption)
		/// </summary>
		public string Text
		{
			get
			{
				StringBuilder title = new StringBuilder(260, 260);
				UnManagedMethods.GetWindowText(this.hWnd, title, title.Capacity);
				return title.ToString();
			}
		}

		/// <summary>
		/// Gets the window's class name.
		/// </summary>
		public string ClassName
		{
			get
			{
				StringBuilder className = new StringBuilder(260, 260);
				UnManagedMethods.GetClassName(this.hWnd, className, className.Capacity);
				return className.ToString();
			}
		}

		/// <summary>
		/// Gets/Sets whether the window is iconic (mimimised) or not.
		/// </summary>
		public bool Iconic
		{
			get
			{
				return ((UnManagedMethods.IsIconic(this.hWnd) == 0) ? false : true);
			}
			set
			{
				UnManagedMethods.SendMessage(
					this.hWnd, 
					UnManagedMethods.WM_SYSCOMMAND, 
					(IntPtr)UnManagedMethods.SC_MINIMIZE,
					IntPtr.Zero);
			}
		}
			
		/// <summary>
		/// Gets/Sets whether the window is maximised or not.
		/// </summary>
		public bool Maximised
		{
			get
			{
				return ((UnManagedMethods.IsZoomed(this.hWnd) == 0) ? false : true);
			}
			set
			{
				UnManagedMethods.SendMessage(
					this.hWnd,
					UnManagedMethods.WM_SYSCOMMAND, 
					(IntPtr)UnManagedMethods.SC_MAXIMIZE,
					IntPtr.Zero);
			}
		}

		/// <summary>
		/// Gets whether the window is visible.
		/// </summary>
		public bool Visible
		{
			get
			{
				return ((UnManagedMethods.IsWindowVisible(this.hWnd) == 0) ? false : true);
			}
		}

		/// <summary>
		/// Gets the bounding rectangle of the window
		/// </summary>
		public System.Drawing.Rectangle Rect
		{
			get
			{
				RECT rc = new RECT();
				UnManagedMethods.GetWindowRect(
					this.hWnd,
					ref rc);
				System.Drawing.Rectangle rcRet = new System.Drawing.Rectangle(
					rc.Left, rc.Top,
					rc.Right - rc.Left, rc.Bottom - rc.Top);
				return rcRet;
			}
		}

		/// <summary>
		/// Gets the location of the window relative to the screen.
		/// </summary>
		public System.Drawing.Point Location
		{
			get
			{
				System.Drawing.Rectangle rc = Rect;
				System.Drawing.Point pt = new System.Drawing.Point(
					rc.Left,
					rc.Top);
				return pt;
			}
		}
			
		/// <summary>
		/// Gets the size of the window.
		/// </summary>
		public System.Drawing.Size Size
		{
			get
			{
				System.Drawing.Rectangle rc = Rect;
				System.Drawing.Size sz = new System.Drawing.Size(
					rc.Right - rc.Left,
					rc.Bottom - rc.Top);
				return sz;
			}
		}

		/// <summary>
		/// Restores and Brings the window to the front, 
		/// assuming it is a visible application window.
		/// </summary>
		public void Restore()
		{
			if (Iconic)
			{
				UnManagedMethods.SendMessage(
					this.hWnd, 
					UnManagedMethods.WM_SYSCOMMAND, 
					(IntPtr)UnManagedMethods.SC_RESTORE, 
					IntPtr.Zero);
			}
			UnManagedMethods.BringWindowToTop(this.hWnd);
			UnManagedMethods.SetForegroundWindow(this.hWnd);
		}

		public WindowStyleFlags WindowStyle
		{
			get
			{
				return (WindowStyleFlags)UnManagedMethods.GetWindowLong(
					this.hWnd, UnManagedMethods.GWL_STYLE);
			}
		}
		
		public ExtendedWindowStyleFlags ExtendedWindowStyle
		{
			get
			{
				return (ExtendedWindowStyleFlags)UnManagedMethods.GetWindowLong(
					this.hWnd, UnManagedMethods.GWL_EXSTYLE);
			}
		}

		/// <summary>
		///  Constructs a new instance of this class for
		///  the specified Window Handle.
		/// </summary>
		/// <param name="hWnd">The Window Handle</param>
		public EnumWindowsItem(IntPtr hWnd)
		{
			this.hWnd = hWnd;
		}
	}
	#endregion
}



================================================
File: MegaDumper/Utils/HandleEnumeration.cs
================================================
// =======================================================
// Yet Another (remote) Process Monitor (YAPM)
// Copyright (c) 2008-2009 Alain Descotes (violent_ken)
// https://sourceforge.net/projects/yaprocmon/
// =======================================================
// YAPM is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3 of the License, or
// (at your [option]) any later version.
//
// YAPM is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with YAPM; if not, see http://www.gnu.org/licenses/.
// Thanks to ShareVB for the KernelMemory driver.
// http://www.vbfrance.com/codes/LISTER-HANDLES-FICHIERS-CLE-REGISTRES-OUVERTS-PROGRAMME-NT_39333.aspx
// ERROR: Not supported in C: OptionDeclaration
using System;
using System.Runtime.InteropServices;
using Native.Memory;

namespace HandleEnum
{

[Flags]
public enum HandleFlags : byte
{
    AuditObjectClose = 4,
    Inherit = 2,
    ProtectFromClose = 1
}

[Flags]
public enum StandardRights : uint
{
    AccessSystemSecurity = 0x1000000,
    All = 0x1f0000,
    Delete = 0x10000,
    Execute = 0x20000,
    GenericAll = 0x10000000,
    GenericExecute = 0x20000000,
    GenericRead = 0x80000000,
    GenericWrite = 0x40000000,
    MaximumAllowed = 0x2000000,
    Read = 0x20000,
    ReadControl = 0x20000,
    Required = 0xf0000,
    SpecificRightsAll = 0xffff,
    Synchronize = 0x100000,
    Write = 0x20000,
    WriteDac = 0x40000,
    WriteOwner = 0x80000
}

[StructLayout(LayoutKind.Sequential)]
public struct SystemHandleEntry
{
    public int ProcessId;
    public byte ObjectTypeNumber;
    public HandleFlags Flags;
    public short Handle;
    public UIntPtr Object;
    public StandardRights GrantedAccess;
}

public enum SystemInformationClass
{
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemMirrorMemoryInformation,
    SystemPerformanceTraceInformation,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeparation,
    SystemVerifierAddDriverInformation,
    SystemVerifierRemoveDriverInformation,
    SystemProcessorIdleInformation,
    SystemLegacyDriverInformation,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification,
    SystemSessionCreate,
    SystemSessionDetach,
    SystemSessionInformation,
    SystemRangeStartInformation,
    SystemVerifierInformation,
    SystemVerifierThunkExtend,
    SystemSessionProcessInformation,
    SystemLoadGdiDriverInSystemSpace,
    SystemNumaProcessorMap,
    SystemPrefetcherInformation,
    SystemExtendedProcessInformation,
    SystemRecommendedSharedDataAlignment,
    SystemComPlusPackage,
    SystemNumaAvailableMemory,
    SystemProcessorPowerInformation,
    SystemEmulationBasicInformation,
    SystemEmulationProcessorInformation,
    SystemExtendedHandleInformation,
    SystemLostDelayedWriteInformation,
    SystemBigPoolInformation,
    SystemSessionPoolTagInformation,
    SystemSessionMappedViewInformation,
    SystemHotpatchInformation,
    SystemObjectSecurityMode,
    SystemWatchdogTimerHandler,
    SystemWatchdogTimerInformation,
    SystemLogicalProcessorInformation,
    SystemWow64SharedInformation,
    SystemRegisterFirmwareTableInformationHandler,
    SystemFirmwareTableInformation,
    SystemModuleInformationEx,
    SystemVerifierTriageInformation,
    SystemSuperfetchInformation,
    SystemMemoryListInformation,
    SystemFileCacheInformationEx,
    SystemNotImplemented19,
    SystemProcessorDebugInformation,
    SystemVerifierInformation2,
    SystemNotImplemented20,
    SystemRefTraceInformation,
    SystemSpecialPoolTag,
    SystemProcessImageName,
    SystemNotImplemented21,
    SystemBootEnvironmentInformation,
    SystemEnlightenmentInformation,
    SystemVerifierInformationEx,
    SystemNotImplemented22,
    SystemNotImplemented23,
    SystemCovInformation,
    SystemNotImplemented24,
    SystemNotImplemented25,
    SystemPartitionInformation,
    SystemSystemDiskInformation,
    SystemPerformanceDistributionInformation,
    SystemNumaProximityNodeInformation,
    SystemTimeZoneInformation2,
    SystemCodeIntegrityInformation,
    SystemNotImplemented26,
    SystemUnknownInformation,
    SystemVaInformation
}


[StructLayout(LayoutKind.Sequential)]
public struct SystemHandleInformation
{
    public int HandleCount;
    public SystemHandleEntry Entries;
    public static int HandlesOffset
    {
        get
        {
            return Marshal.OffsetOf(typeof(SystemHandleInformation), "Entries").ToInt32();
        }
    }
}

 public enum HandleObjectType
{
    Adapter,
    AlpcPort,
    Callback,
    Controller,
    DebugObject,
    Desktop,
    Device,
    Directory,
    Driver,
    EtwRegistration,
    Event,
    EventPair,
    File,
    FilterCommunicationPort,
    FilterConnectionPort,
    IoCompletion,
    Job,
    Key,
    KeyedEvent,
    Mutant,
    Process,
    Profile,
    Section,
    Semaphore,
    Session,
    SymbolicLink,
    Thread,
    Timer,
    TmEn,
    TmRm,
    TmTm,
    TmTx,
    Token,
    TpWorkerFactory,
    Type,
    WindowStation,
    WmiGuid
}

 

	
public class HandleEnumeration
{
 public const uint STATUS_INFO_LENGTH_MISMATCH = 0xc0000004;
 

// ========================================
// Private attributes
// ========================================

// Some mem allocation for buffer of handles
private Native.Memory.MemoryAlloc memAllocPIDs = new Native.Memory.MemoryAlloc(256);
//private Native.Memory.MemoryAlloc memAllocPID = new Native.Memory.MemoryAlloc(256);


 [DllImport("ntdll.dll")]
public static extern uint NtQuerySystemInformation([In] SystemInformationClass SystemInformationClass, [Out] IntPtr SystemInformation, [In] int SystemInformationLength, [Optional] out int ReturnLength);
 
// Create a buffer containing handles
public SystemHandleEntry[] CreateQueryHandlesBuffer( // ERROR: Unsupported modifier : In, Optional
int oneProcessId)
{
int Length;
int ret;

Length = memAllocPIDs.Size;
// While length is too small
while (NtQuerySystemInformation(SystemInformationClass.SystemHandleInformation, memAllocPIDs.Pointer, memAllocPIDs.Size, out ret) == STATUS_INFO_LENGTH_MISMATCH) {
// Resize buffer
Length = Length * 2;
memAllocPIDs.Resize(Length);
}

SystemHandleInformation shi = new SystemHandleInformation();

shi = (SystemHandleInformation)Marshal.PtrToStructure(memAllocPIDs.Pointer, typeof(SystemHandleInformation));
int handleCount = shi.HandleCount;

SystemHandleEntry[] entryArray = new SystemHandleEntry[(handleCount - 1) + 1];
int handlesOffset = SystemHandleInformation.HandlesOffset;
int counter = handleCount - 1;

int prochadlecount = 0;

for (int i = 0; i <= counter; i++)
{
entryArray[i] = (SystemHandleEntry)Marshal.PtrToStructure
((IntPtr)((long)memAllocPIDs.Pointer+(long)handlesOffset+
	     (long)(Marshal.SizeOf(typeof(SystemHandleEntry))*i))
, typeof(SystemHandleEntry));

if (entryArray[i].ProcessId == oneProcessId)
{
prochadlecount++;
}
}

int cnt = 0;
SystemHandleEntry[] processentries = new SystemHandleEntry[prochadlecount];
for (int i = 0; i < entryArray.Length; i++)
{
if (entryArray[i].ProcessId == oneProcessId)
{
processentries[cnt]=entryArray[i];
cnt++;
}
}

return processentries;

}



}

}



================================================
File: MegaDumper/Utils/MemoryAlloc.cs
================================================
namespace Native.Memory
{
    using System;
    using System.Runtime.InteropServices;
    using System.Text;

    public class MemoryAlloc : IDisposable
    {
        private IntPtr _ptr;
        private int _size;

        public MemoryAlloc()
        {
        }

        public MemoryAlloc(int size)
        {
            this._ptr = Marshal.AllocHGlobal(size);
            this._size = size;
        }

        public MemoryAlloc(IntPtr ptr) : this(ptr, 0)
        {
        }

        public MemoryAlloc(IntPtr ptr, int size)
        {
            this._ptr = ptr;
            this._size = size;
        }

        public void Dispose()
        {
            this.Free();
        }

        public void Free()
        {
            if (this.Pointer != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(this.Pointer);
            }
        }

        public void IncrementSize(int newBytesCount)
        {
            IntPtr cb = new IntPtr(newBytesCount + this._size);
            this._ptr = Marshal.ReAllocHGlobal(this._ptr, cb);
            this._size = newBytesCount + this._size;
        }

        public static implicit operator int(MemoryAlloc memory)
        {
            return memory.Pointer.ToInt32();
        }

        public static implicit operator long(MemoryAlloc memory)
        {
            return memory.Pointer.ToInt64();
        }

        public static implicit operator IntPtr(MemoryAlloc memory)
        {
            return memory.Pointer;
        }

        public int ReadByte(int offset)
        {
            return this.ReadByte(offset, 0);
        }

        public int ReadByte(int offset, int index)
        {
            return Marshal.ReadByte(this._ptr, offset + (index * 4));
        }

        public byte[] ReadBytes(int length)
        {
            return this.ReadBytes(0, length);
        }

        public byte[] ReadBytes(int offset, int length)
        {
            byte[] buffer = new byte[(length - 1) + 1];
            this.ReadBytes(offset, buffer, 0, length);
            return buffer;
        }

        public void ReadBytes(byte[] buffer, int startIndex, int length)
        {
            this.ReadBytes(0, buffer, startIndex, length);
        }

        public void ReadBytes(int offset, byte[] buffer, int startIndex, int length)
        {
        	this._ptr = new IntPtr(this._ptr.ToInt32() + offset);
            Marshal.Copy(this._ptr, buffer, startIndex, length);
        }

        public int ReadInt32(int offset)
        {
            return this.ReadInt32(offset, 0);
        }

        public int ReadInt32(int offset, int index)
        {
            return Marshal.ReadInt32(this._ptr, offset + (index * 4));
        }

        public IntPtr ReadIntPtr(int offset)
        {
            return this.ReadIntPtr(offset, 0);
        }

        public IntPtr ReadIntPtr(int offset, int index)
        {
            return Marshal.ReadIntPtr(this._ptr, offset + (index * IntPtr.Size));
        }

        public T ReadStruct<T>()
        {
            return this.ReadStruct<T>(0);
        }

        public T ReadStruct<T>(int index)
        {
            return this.ReadStruct<T>(0, index);
        }

        public T ReadStruct<T>(int offset, int index)
        {
        	this._ptr = new IntPtr((int) (offset + (Marshal.SizeOf(typeof(T)) * index)) + this._ptr.ToInt32());
            return (T) Marshal.PtrToStructure(this._ptr, typeof(T));
        }

        public T ReadStructOffset<T>(int offset)
        {
        	this._ptr = new IntPtr(this._ptr.ToInt32()+offset);
            return (T) Marshal.PtrToStructure(this._ptr, typeof(T));
        }

        public uint ReadUInt32(int offset)
        {
            return this.ReadUInt32(offset, 0);
        }

        public uint ReadUInt32(int offset, int index)
        {
            return (uint) this.ReadInt32(offset, index);
        }

        public void Resize(int newSize)
        {
            IntPtr cb = new IntPtr(newSize);
            this._ptr = Marshal.ReAllocHGlobal(this._ptr, cb);
            this._size = newSize;
        }

        public void WriteByte(int offset, byte b)
        {
            Marshal.WriteByte((IntPtr) this, offset, b);
        }

        public void WriteBytes(int offset, byte[] b)
        {
        	this._ptr = new IntPtr(this._ptr.ToInt32()+offset);
            Marshal.Copy(b, 0, this._ptr, b.Length);
        }

        public void WriteInt16(int offset, short i)
        {
            Marshal.WriteInt16((IntPtr) this, offset, i);
        }

        public void WriteInt32(int offset, int i)
        {
            Marshal.WriteInt32((IntPtr) this, offset, i);
        }

        public void WriteIntPtr(int offset, IntPtr i)
        {
            Marshal.WriteIntPtr((IntPtr) this, offset, i);
        }

        public void WriteStruct<T>(T s)
        {
            this.WriteStruct<T>(0, s);
        }

        public void WriteStruct<T>(int index, T s)
        {
            this.WriteStruct<T>(0, index, s);
        }

        public void WriteStruct<T>(int offset, int index, T s)
        {
        	this._ptr = new IntPtr(this._ptr.ToInt32()+(int) (offset + (Marshal.SizeOf(typeof(T)) * index)));
            Marshal.StructureToPtr(s, this._ptr, false);
        }

        public void WriteUnicodeString(int offset, string s)
        {
            byte[] bytes = Encoding.Unicode.GetBytes(s);
            int num = bytes.Length - 1;
            for (int i = 0; i <= num; i++)
            {
                Marshal.WriteByte(this.Pointer, offset + i, bytes[i]);
            }
        }

        public IntPtr Pointer
        {
            get
            {
                return this._ptr;
            }
            set
            {
                this._ptr = value;
            }
        }

        public int Size
        {
            get
            {
                return this._size;
            }
            set
            {
                this._size = value;
            }
        }
    }
}




================================================
File: MegaDumper/Utils/ProcessStatistics.cs
================================================
using System;
using System.Runtime.InteropServices;
using System.Collections;
using System.IO;

namespace ProcessStatistics
{

    		        
  /// <summary>
    /// A NT status value.
    /// </summary>
    public enum NtStatus : uint
    {
        // Success
        Success = 0x00000000,
        Wait0 = 0x00000000,
        Wait1 = 0x00000001,
        Wait2 = 0x00000002,
        Wait3 = 0x00000003,
        Wait63 = 0x0000003f,
        Abandoned = 0x00000080,
        AbandonedWait0 = 0x00000080,
        AbandonedWait1 = 0x00000081,
        AbandonedWait2 = 0x00000082,
        AbandonedWait3 = 0x00000083,
        AbandonedWait63 = 0x000000bf,
        UserApc = 0x000000c0,
        KernelApc = 0x00000100,
        Alerted = 0x00000101,
        Timeout = 0x00000102,
        Pending = 0x00000103,
        Reparse = 0x00000104,
        MoreEntries = 0x00000105,
        NotAllAssigned = 0x00000106,
        SomeNotMapped = 0x00000107,
        OpLockBreakInProgress = 0x00000108,
        VolumeMounted = 0x00000109,
        RxActCommitted = 0x0000010a,
        NotifyCleanup = 0x0000010b,
        NotifyEnumDir = 0x0000010c,
        NoQuotasForAccount = 0x0000010d,
        PrimaryTransportConnectFailed = 0x0000010e,
        PageFaultTransition = 0x00000110,
        PageFaultDemandZero = 0x00000111,
        PageFaultCopyOnWrite = 0x00000112,
        PageFaultGuardPage = 0x00000113,
        PageFaultPagingFile = 0x00000114,
        CrashDump = 0x00000116,
        ReparseObject = 0x00000118,
        NothingToTerminate = 0x00000122,
        ProcessNotInJob = 0x00000123,
        ProcessInJob = 0x00000124,
        ProcessCloned = 0x00000129,
        FileLockedWithOnlyReaders = 0x0000012a,
        FileLockedWithWriters = 0x0000012b,

        // Informational
        Informational = 0x40000000,
        ObjectNameExists = 0x40000000,
        ThreadWasSuspended = 0x40000001,
        WorkingSetLimitRange = 0x40000002,
        ImageNotAtBase = 0x40000003,
        RegistryRecovered = 0x40000009,

        // Warning
        Warning = 0x80000000,
        GuardPageViolation = 0x80000001,
        DatatypeMisalignment = 0x80000002,
        Breakpoint = 0x80000003,
        SingleStep = 0x80000004,
        BufferOverflow = 0x80000005,
        NoMoreFiles = 0x80000006,
        HandlesClosed = 0x8000000a,
        PartialCopy = 0x8000000d,
        DeviceBusy = 0x80000011,
        InvalidEaName = 0x80000013,
        EaListInconsistent = 0x80000014,
        NoMoreEntries = 0x8000001a,
        LongJump = 0x80000026,
        DllMightBeInsecure = 0x8000002b,

        // Error
        Error = 0xc0000000,
        Unsuccessful = 0xc0000001,
        NotImplemented = 0xc0000002,
        InvalidInfoClass = 0xc0000003,
        InfoLengthMismatch = 0xc0000004,
        AccessViolation = 0xc0000005,
        InPageError = 0xc0000006,
        PagefileQuota = 0xc0000007,
        InvalidHandle = 0xc0000008,
        BadInitialStack = 0xc0000009,
        BadInitialPc = 0xc000000a,
        InvalidCid = 0xc000000b,
        TimerNotCanceled = 0xc000000c,
        InvalidParameter = 0xc000000d,
        NoSuchDevice = 0xc000000e,
        NoSuchFile = 0xc000000f,
        InvalidDeviceRequest = 0xc0000010,
        EndOfFile = 0xc0000011,
        WrongVolume = 0xc0000012,
        NoMediaInDevice = 0xc0000013,
        NoMemory = 0xc0000017,
        NotMappedView = 0xc0000019,
        UnableToFreeVm = 0xc000001a,
        UnableToDeleteSection = 0xc000001b,
        IllegalInstruction = 0xc000001d,
        AlreadyCommitted = 0xc0000021,
        AccessDenied = 0xc0000022,
        BufferTooSmall = 0xc0000023,
        ObjectTypeMismatch = 0xc0000024,
        NonContinuableException = 0xc0000025,
        BadStack = 0xc0000028,
        NotLocked = 0xc000002a,
        NotCommitted = 0xc000002d,
        InvalidParameterMix = 0xc0000030,
        ObjectNameInvalid = 0xc0000033,
        ObjectNameNotFound = 0xc0000034,
        ObjectNameCollision = 0xc0000035,
        ObjectPathInvalid = 0xc0000039,
        ObjectPathNotFound = 0xc000003a,
        ObjectPathSyntaxBad = 0xc000003b,
        DataOverrun = 0xc000003c,
        DataLate = 0xc000003d,
        DataError = 0xc000003e,
        CrcError = 0xc000003f,
        SectionTooBig = 0xc0000040,
        PortConnectionRefused = 0xc0000041,
        InvalidPortHandle = 0xc0000042,
        SharingViolation = 0xc0000043,
        QuotaExceeded = 0xc0000044,
        InvalidPageProtection = 0xc0000045,
        MutantNotOwned = 0xc0000046,
        SemaphoreLimitExceeded = 0xc0000047,
        PortAlreadySet = 0xc0000048,
        SectionNotImage = 0xc0000049,
        SuspendCountExceeded = 0xc000004a,
        ThreadIsTerminating = 0xc000004b,
        BadWorkingSetLimit = 0xc000004c,
        IncompatibleFileMap = 0xc000004d,
        SectionProtection = 0xc000004e,
        EasNotSupported = 0xc000004f,
        EaTooLarge = 0xc0000050,
        NonExistentEaEntry = 0xc0000051,
        NoEasOnFile = 0xc0000052,
        EaCorruptError = 0xc0000053,
        FileLockConflict = 0xc0000054,
        LockNotGranted = 0xc0000055,
        DeletePending = 0xc0000056,
        CtlFileNotSupported = 0xc0000057,
        UnknownRevision = 0xc0000058,
        RevisionMismatch = 0xc0000059,
        InvalidOwner = 0xc000005a,
        InvalidPrimaryGroup = 0xc000005b,
        NoImpersonationToken = 0xc000005c,
        CantDisableMandatory = 0xc000005d,
        NoLogonServers = 0xc000005e,
        NoSuchLogonSession = 0xc000005f,
        NoSuchPrivilege = 0xc0000060,
        PrivilegeNotHeld = 0xc0000061,
        InvalidAccountName = 0xc0000062,
        UserExists = 0xc0000063,
        NoSuchUser = 0xc0000064,
        GroupExists = 0xc0000065,
        NoSuchGroup = 0xc0000066,
        MemberInGroup = 0xc0000067,
        MemberNotInGroup = 0xc0000068,
        LastAdmin = 0xc0000069,
        WrongPassword = 0xc000006a,
        IllFormedPassword = 0xc000006b,
        PasswordRestriction = 0xc000006c,
        LogonFailure = 0xc000006d,
        AccountRestriction = 0xc000006e,
        InvalidLogonHours = 0xc000006f,
        InvalidWorkstation = 0xc0000070,
        PasswordExpired = 0xc0000071,
        AccountDisabled = 0xc0000072,
        NoneMapped = 0xc0000073,
        TooManyLuidsRequested = 0xc0000074,
        LuidsExhausted = 0xc0000075,
        InvalidSubAuthority = 0xc0000076,
        InvalidAcl = 0xc0000077,
        InvalidSid = 0xc0000078,
        InvalidSecurityDescr = 0xc0000079,
        ProcedureNotFound = 0xc000007a,
        InvalidImageFormat = 0xc000007b,
        NoToken = 0xc000007c,
        BadInheritanceAcl = 0xc000007d,
        RangeNotLocked = 0xc000007e,
        DiskFull = 0xc000007f,
        ServerDisabled = 0xc0000080,
        ServerNotDisabled = 0xc0000081,
        TooManyGuidsRequested = 0xc0000082,
        GuidsExhausted = 0xc0000083,
        InvalidIdAuthority = 0xc0000084,
        AgentsExhausted = 0xc0000085,
        InvalidVolumeLabel = 0xc0000086,
        SectionNotExtended = 0xc0000087,
        NotMappedData = 0xc0000088,
        ResourceDataNotFound = 0xc0000089,
        ResourceTypeNotFound = 0xc000008a,
        ResourceNameNotFound = 0xc000008b,
        ArrayBoundsExceeded = 0xc000008c,
        FloatDenormalOperand = 0xc000008d,
        FloatDivideByZero = 0xc000008e,
        FloatInexactResult = 0xc000008f,
        FloatInvalidOperation = 0xc0000090,
        FloatOverflow = 0xc0000091,
        FloatStackCheck = 0xc0000092,
        FloatUnderflow = 0xc0000093,
        IntegerDivideByZero = 0xc0000094,
        IntegerOverflow = 0xc0000095,
        PrivilegedInstruction = 0xc0000096,
        TooManyPagingFiles = 0xc0000097,
        FileInvalid = 0xc0000098,
        InstanceNotAvailable = 0xc00000ab,
        PipeNotAvailable = 0xc00000ac,
        InvalidPipeState = 0xc00000ad,
        PipeBusy = 0xc00000ae,
        IllegalFunction = 0xc00000af,
        PipeDisconnected = 0xc00000b0,
        PipeClosing = 0xc00000b1,
        PipeConnected = 0xc00000b2,
        PipeListening = 0xc00000b3,
        InvalidReadMode = 0xc00000b4,
        IoTimeout = 0xc00000b5,
        FileForcedClosed = 0xc00000b6,
        ProfilingNotStarted = 0xc00000b7,
        ProfilingNotStopped = 0xc00000b8,
        NotSameDevice = 0xc00000d4,
        FileRenamed = 0xc00000d5,
        CantWait = 0xc00000d8,
        PipeEmpty = 0xc00000d9,
        CantTerminateSelf = 0xc00000db,
        InternalError = 0xc00000e5,
        InvalidParameter1 = 0xc00000ef,
        InvalidParameter2 = 0xc00000f0,
        InvalidParameter3 = 0xc00000f1,
        InvalidParameter4 = 0xc00000f2,
        InvalidParameter5 = 0xc00000f3,
        InvalidParameter6 = 0xc00000f4,
        InvalidParameter7 = 0xc00000f5,
        InvalidParameter8 = 0xc00000f6,
        InvalidParameter9 = 0xc00000f7,
        InvalidParameter10 = 0xc00000f8,
        InvalidParameter11 = 0xc00000f9,
        InvalidParameter12 = 0xc00000fa,
        MappedFileSizeZero = 0xc000011e,
        TooManyOpenedFiles = 0xc000011f,
        Cancelled = 0xc0000120,
        CannotDelete = 0xc0000121,
        InvalidComputerName = 0xc0000122,
        FileDeleted = 0xc0000123,
        SpecialAccount = 0xc0000124,
        SpecialGroup = 0xc0000125,
        SpecialUser = 0xc0000126,
        MembersPrimaryGroup = 0xc0000127,
        FileClosed = 0xc0000128,
        TooManyThreads = 0xc0000129,
        ThreadNotInProcess = 0xc000012a,
        TokenAlreadyInUse = 0xc000012b,
        PagefileQuotaExceeded = 0xc000012c,
        CommitmentLimit = 0xc000012d,
        InvalidImageLeFormat = 0xc000012e,
        InvalidImageNotMz = 0xc000012f,
        InvalidImageProtect = 0xc0000130,
        InvalidImageWin16 = 0xc0000131,
        LogonServer = 0xc0000132,
        DifferenceAtDc = 0xc0000133,
        SynchronizationRequired = 0xc0000134,
        DllNotFound = 0xc0000135,
        IoPrivilegeFailed = 0xc0000137,
        OrdinalNotFound = 0xc0000138,
        EntryPointNotFound = 0xc0000139,
        ControlCExit = 0xc000013a,
        PortNotSet = 0xc0000353,
        DebuggerInactive = 0xc0000354,
        CallbackBypass = 0xc0000503,
        PortClosed = 0xc0000700,
        MessageLost = 0xc0000701,
        InvalidMessage = 0xc0000702,
        RequestCanceled = 0xc0000703,
        RecursiveDispatch = 0xc0000704,
        LpcReceiveBufferExpected = 0xc0000705,
        LpcInvalidConnectionUsage = 0xc0000706,
        LpcRequestsNotAllowed = 0xc0000707,
        ResourceInUse = 0xc0000708,
        ProcessIsProtected = 0xc0000712,
        VolumeDirty = 0xc0000806,
        FileCheckedOut = 0xc0000901,
        CheckOutRequired = 0xc0000902,
        BadFileType = 0xc0000903,
        FileTooLarge = 0xc0000904,
        FormsAuthRequired = 0xc0000905,
        VirusInfected = 0xc0000906,
        VirusDeleted = 0xc0000907,
        TransactionalConflict = 0xc0190001,
        InvalidTransaction = 0xc0190002,
        TransactionNotActive = 0xc0190003,
        TmInitializationFailed = 0xc0190004,
        RmNotActive = 0xc0190005,
        RmMetadataCorrupt = 0xc0190006,
        TransactionNotJoined = 0xc0190007,
        DirectoryNotRm = 0xc0190008,
        CouldNotResizeLog = 0xc0190009,
        TransactionsUnsupportedRemote = 0xc019000a,
        LogResizeInvalidSize = 0xc019000b,
        RemoteFileVersionMismatch = 0xc019000c,
        CrmProtocolAlreadyExists = 0xc019000f,
        TransactionPropagationFailed = 0xc0190010,
        CrmProtocolNotFound = 0xc0190011,
        TransactionSuperiorExists = 0xc0190012,
        TransactionRequestNotValid = 0xc0190013,
        TransactionNotRequested = 0xc0190014,
        TransactionAlreadyAborted = 0xc0190015,
        TransactionAlreadyCommitted = 0xc0190016,
        TransactionInvalidMarshallBuffer = 0xc0190017,
        CurrentTransactionNotValid = 0xc0190018,
        LogGrowthFailed = 0xc0190019,
        ObjectNoLongerExists = 0xc0190021,
        StreamMiniversionNotFound = 0xc0190022,
        StreamMiniversionNotValid = 0xc0190023,
        MiniversionInaccessibleFromSpecifiedTransaction = 0xc0190024,
        CantOpenMiniversionWithModifyIntent = 0xc0190025,
        CantCreateMoreStreamMiniversions = 0xc0190026,
        HandleNoLongerValid = 0xc0190028,
        NoTxfMetadata = 0xc0190029,
        LogCorruptionDetected = 0xc0190030,
        CantRecoverWithHandleOpen = 0xc0190031,
        RmDisconnected = 0xc0190032,
        EnlistmentNotSuperior = 0xc0190033,
        RecoveryNotNeeded = 0xc0190034,
        RmAlreadyStarted = 0xc0190035,
        FileIdentityNotPersistent = 0xc0190036,
        CantBreakTransactionalDependency = 0xc0190037,
        CantCrossRmBoundary = 0xc0190038,
        TxfDirNotEmpty = 0xc0190039,
        IndoubtTransactionsExist = 0xc019003a,
        TmVolatile = 0xc019003b,
        RollbackTimerExpired = 0xc019003c,
        TxfAttributeCorrupt = 0xc019003d,
        EfsNotAllowedInTransaction = 0xc019003e,
        TransactionalOpenNotAllowed = 0xc019003f,
        TransactedMappingUnsupportedRemote = 0xc0190040,
        TxfMetadataAlreadyPresent = 0xc0190041,
        TransactionScopeCallbacksNotSet = 0xc0190042,
        TransactionRequiredPromotion = 0xc0190043,
        CannotExecuteFileInTransaction = 0xc0190044,
        TransactionsNotFrozen = 0xc0190045,

        MaximumNtStatus = 0xffffffff
    }
    
    
public class ProcessInfo
{
    // Fields
    public int basePriority;
    public int handleCount;
    public int mainModuleId;
    public long pageFileBytes;
    public long pageFileBytesPeak;
    public long poolNonpagedBytes;
    public long poolPagedBytes;
    public long privateBytes;
    public int processId;
    public string processName;
    public int sessionId;
    public ArrayList threadInfoList = new ArrayList();
    public long virtualBytes;
    public long virtualBytesPeak;
    public long workingSet;
    public long workingSetPeak;
}


	        
public class PStatistics
{

[DllImport("ntdll.dll")]
public static extern NtStatus NtQueryInformationProcess([In] IntPtr ProcessHandle,
[In] ProcessInformationClass ProcessInformationClass,
out VmCounters ProcessInformation, [In] int ProcessInformationLength, [Optional] out int ReturnLength);
 
[DllImport("ntdll.dll")]
public static extern NtStatus NtQueryInformationProcess(
[In] IntPtr ProcessHandle, [In] ProcessInformationClass ProcessInformationClass, out int ProcessInformation, [In] int ProcessInformationLength, [Optional] out int ReturnLength);
 

 


 

[DllImport("ntdll.dll", CharSet = CharSet.Auto)]
public static extern int NtQuerySystemInformation(
int query, IntPtr dataPtr, int size, out int returnedSize);

    
    public enum ProcessInformationClass : int
    {
        ProcessBasicInformation, // 0
        ProcessQuotaLimits,
        ProcessIoCounters,
        ProcessVmCounters,
        ProcessTimes,
        ProcessBasePriority,
        ProcessRaisePriority,
        ProcessDebugPort,
        ProcessExceptionPort,
        ProcessAccessToken,
        ProcessLdtInformation, // 10
        ProcessLdtSize,
        ProcessDefaultHardErrorMode,
        ProcessIoPortHandlers,
        ProcessPooledUsageAndLimits,
        ProcessWorkingSetWatch,
        ProcessUserModeIOPL,
        ProcessEnableAlignmentFaultFixup,
        ProcessPriorityClass,
        ProcessWx86Information,
        ProcessHandleCount, // 20
        ProcessAffinityMask,
        ProcessPriorityBoost,
        ProcessDeviceMap,
        ProcessSessionInformation,
        ProcessForegroundInformation,
        ProcessWow64Information,
        ProcessImageFileName,
        ProcessLUIDDeviceMapsEnabled,
        ProcessBreakOnTermination,
        ProcessDebugObjectHandle, // 30
        ProcessDebugFlags,
        ProcessHandleTracing,
        ProcessIoPriority,
        ProcessExecuteFlags,
        ProcessResourceManagement,
        ProcessCookie,
        ProcessImageInformation,
        ProcessCycleTime,
        ProcessPagePriority,
        ProcessInstrumentationCallback, // 40
        ProcessThreadStackAllocation,
        ProcessWorkingSetWatchEx,
        ProcessImageFileNameWin32,
        ProcessImageFileMapping,
        ProcessAffinityUpdateMode,
        ProcessMemoryAllocationMode,
        ProcessGroupInformation,
        ProcessTokenVirtualizationEnabled,
        ProcessConsoleHostProcess,
        ProcessWindowInformation, // 50
        MaxProcessInfoClass
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct VmCounters
    {
        public IntPtr PeakVirtualSize;
        public IntPtr VirtualSize;
        public int PageFaultCount;
        public IntPtr PeakWorkingSetSize;
        public IntPtr WorkingSetSize;
        public IntPtr QuotaPeakPagedPoolUsage;
        public IntPtr QuotaPagedPoolUsage;
        public IntPtr QuotaPeakNonPagedPoolUsage;
        public IntPtr QuotaNonPagedPoolUsage;
        public IntPtr PagefileUsage;
        public IntPtr PeakPagefileUsage;
    }
    
    [StructLayout(LayoutKind.Sequential)]
internal class SystemProcessInformation
{
    internal int NextEntryOffset;
    internal uint NumberOfThreads;
    private long SpareLi1;
    private long SpareLi2;
    private long SpareLi3;
    private long CreateTime;
    private long UserTime;
    private long KernelTime;
    internal ushort NameLength;
    internal ushort MaximumNameLength;
    internal IntPtr NamePtr;
    internal int BasePriority;
    internal IntPtr UniqueProcessId;
    internal IntPtr InheritedFromUniqueProcessId;
    internal uint HandleCount;
    internal uint SessionId;
    internal IntPtr PageDirectoryBase;
    internal IntPtr PeakVirtualSize;
    internal IntPtr VirtualSize;
    internal uint PageFaultCount;
    internal IntPtr PeakWorkingSetSize;
    internal IntPtr WorkingSetSize;
    internal IntPtr QuotaPeakPagedPoolUsage;
    internal IntPtr QuotaPagedPoolUsage;
    internal IntPtr QuotaPeakNonPagedPoolUsage;
    internal IntPtr QuotaNonPagedPoolUsage;
    internal IntPtr PagefileUsage;
    internal IntPtr PeakPagefileUsage;
    internal IntPtr PrivatePageCount;
    private long ReadOperationCount;
    private long WriteOperationCount;
    private long OtherOperationCount;
    private long ReadTransferCount;
    private long WriteTransferCount;
    private long OtherTransferCount;
}

 
[StructLayout(LayoutKind.Sequential)]
internal class SystemThreadInformation
{
    private long KernelTime;
    private long UserTime;
    private long CreateTime;
    private uint WaitTime;
    internal IntPtr StartAddress;
    internal IntPtr UniqueProcess;
    internal IntPtr UniqueThread;
    internal int Priority;
    internal int BasePriority;
    internal uint ContextSwitches;
    internal uint ThreadState;
    internal uint WaitReason;
}

public enum ThreadState
{
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Wait,
    Transition,
    Unknown
}

public enum ThreadWaitReason
{
    Executive,
    FreePage,
    PageIn,
    SystemAllocation,
    ExecutionDelay,
    Suspended,
    UserRequest,
    EventPairHigh,
    EventPairLow,
    LpcReceive,
    LpcReply,
    VirtualMemory,
    PageOut,
    Unknown
}


 internal class ThreadInfo
{
    // Fields
    public int basePriority;
    public int currentPriority;
    public int processId;
    public IntPtr startAddress;
    public int threadId;
    public ThreadState threadState;
    public ThreadWaitReason threadWaitReason;
}

 

 internal static ThreadWaitReason GetThreadWaitReason(int value)
{
    switch (value)
    {
        case 0:
        case 7:
            return ThreadWaitReason.Executive;

        case 1:
        case 8:
            return ThreadWaitReason.FreePage;

        case 2:
        case 9:
            return ThreadWaitReason.PageIn;

        case 3:
        case 10:
            return ThreadWaitReason.SystemAllocation;

        case 4:
        case 11:
            return ThreadWaitReason.ExecutionDelay;

        case 5:
        case 12:
            return ThreadWaitReason.Suspended;

        case 6:
        case 13:
            return ThreadWaitReason.UserRequest;

        case 14:
            return ThreadWaitReason.EventPairHigh;

        case 15:
            return ThreadWaitReason.EventPairLow;

        case 0x10:
            return ThreadWaitReason.LpcReceive;

        case 0x11:
            return ThreadWaitReason.LpcReply;

        case 0x12:
            return ThreadWaitReason.VirtualMemory;

        case 0x13:
            return ThreadWaitReason.PageOut;
    }
    return ThreadWaitReason.Unknown;
}

 

    
public static VmCounters GetMemoryStatistics(IntPtr phandle)
{

 NtStatus status;
 VmCounters counters;
 int retLength;

 if ((status = NtQueryInformationProcess(
     phandle,
     ProcessInformationClass.ProcessVmCounters,
     out counters,
     Marshal.SizeOf(typeof(VmCounters)),
     out retLength
     )) >= NtStatus.Error)
     throw new ArgumentException(status.ToString());

     return counters;
    
}

   

private static int GetNewBufferSize(int existingBufferSize, int requiredSize)
{
    if (requiredSize != 0)
    {
        return (requiredSize + 0x2800);
    }
    int num = existingBufferSize * 2;
    if (num < existingBufferSize)
    {
        throw new OutOfMemoryException();
    }
    return num;
}

 

 

  public static ProcessInfo[] NtGetProcessInfos()
  {
  ProcessInfo[] processInfos;
  int size = 0x20000;
  int returnedSize = 0;
  GCHandle handle = new GCHandle();

   try
   {
        int num3;
        do
        {
            byte[] buffer = new byte[size];
            handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            num3 = NtQuerySystemInformation(5, handle.AddrOfPinnedObject(), size, out returnedSize);
            if (num3 == -1073741820)
            {
                if (handle.IsAllocated)
                {
                    handle.Free();
                }
                size = GetNewBufferSize(size, returnedSize);
            }
        }
        while (num3 == -1073741820);
        if (num3 < 0)
        {
        return null;
        }
   processInfos = NtGetProcessInfos(handle.AddrOfPinnedObject());
   return processInfos;

   }
    finally
    {
     if (handle.IsAllocated)
     {
     handle.Free();
     }
    }

  }

   public static ProcessInfo[] NtGetProcessInfos(IntPtr dataPtr)
  {
   IntPtr ptr;
   Hashtable hashtable = new Hashtable(100);
   uint num = 0;
  Label_000B:
   ptr = (IntPtr)(((uint)dataPtr) + num);
   SystemProcessInformation structure = new SystemProcessInformation();
   Marshal.PtrToStructure(ptr, structure);
   
   ProcessInfo info = new ProcessInfo();
    info.processId = structure.UniqueProcessId.ToInt32();
    info.handleCount = (int) structure.HandleCount;
    info.sessionId = (int) structure.SessionId;
    info.poolPagedBytes = (long) structure.QuotaPagedPoolUsage;
    info.poolNonpagedBytes = (long) structure.QuotaNonPagedPoolUsage;
    info.virtualBytes = (long) structure.VirtualSize;
    info.virtualBytesPeak = (long) structure.PeakVirtualSize;
    info.workingSetPeak = (long) structure.PeakWorkingSetSize;
    info.workingSet = (long) structure.WorkingSetSize;
    info.pageFileBytesPeak = (long) structure.PeakPagefileUsage;
    info.pageFileBytes = (long) structure.PagefileUsage;
    info.privateBytes = (long) structure.PrivatePageCount;
    info.basePriority = structure.BasePriority;

  
   hashtable[info.processId] = info;
   try
   {
    ptr = (IntPtr)(((long)ptr) + Marshal.SizeOf(structure));
   }
   catch
   {
   }
   for (int i = 0; i < structure.NumberOfThreads; i++)
   {
    SystemThreadInformation information2 = new SystemThreadInformation();
    Marshal.PtrToStructure(ptr, information2);
    ThreadInfo info2 = new ThreadInfo
    {
     processId = (int)information2.UniqueProcess,
     threadId = (int)information2.UniqueThread,
     basePriority = information2.BasePriority,
     currentPriority = information2.Priority,
     startAddress = information2.StartAddress,
     threadState = (ThreadState)information2.ThreadState,
     threadWaitReason = GetThreadWaitReason((int)information2.WaitReason)
    };
    info.threadInfoList.Add(info2);
    try
    {
     ptr = (IntPtr)(((long)ptr) + Marshal.SizeOf(information2));
    }
    catch
    {
    }
   }
   if (structure.NextEntryOffset != 0)
   {
   num += (uint)structure.NextEntryOffset;
   goto Label_000B;
   }
   
   ProcessInfo[] array = new ProcessInfo[hashtable.Values.Count];
   hashtable.Values.CopyTo(array, 0);
   return array;
  }

   public static bool IsNt()
{
    return (Environment.OSVersion.Platform == PlatformID.Win32NT);
}

 
public static ProcessInfo[] GetProcessInfos()
{
	if (IsNt())
    {
    return NtGetProcessInfos();
    }

    return OldGetProcessInfos();
}

[StructLayout(LayoutKind.Sequential)]
internal class WinProcessEntry
{
    public const int sizeofFileName = 260;
    public int dwSize;
    public int cntUsage;
    public int th32ProcessID;
    public IntPtr th32DefaultHeapID = IntPtr.Zero;
    public int th32ModuleID;
    public int cntThreads;
    public int th32ParentProcessID;
    public int pcPriClassBase;
    public int dwFlags;
}

[StructLayout(LayoutKind.Sequential)]
public class WinThreadEntry
{
    public int dwSize;
    public int cntUsage;
    public int th32ThreadID;
    public int th32OwnerProcessID;
    public int tpBasePri;
    public int tpDeltaPri;
    public int dwFlags;
}

 

 


[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern IntPtr CreateToolhelp32Snapshot(int flags, int processId);
  
[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern bool Process32First(HandleRef handle, IntPtr entry);
 
[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern bool Process32Next(HandleRef handle, IntPtr entry);
 
[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern bool Thread32First(HandleRef handle, WinThreadEntry entry);
 
[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern bool Thread32Next(HandleRef handle, WinThreadEntry entry);
 
[DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true, ExactSpelling=true)]
public static extern bool CloseHandle(HandleRef handle);
 

 
 public static ProcessInfo[] OldGetProcessInfos()
{
    IntPtr ptr = (IntPtr) (-1);
    GCHandle handle = new GCHandle();
    ArrayList list = new ArrayList();
    Hashtable hashtable = new Hashtable();
    try
    {
        ptr = CreateToolhelp32Snapshot(6, 0);
        if (ptr == ((IntPtr) (-1)))
        {
        return null;
        }
        int num = Marshal.SizeOf(typeof(WinProcessEntry));
        int val = num + 260;
        int[] numArray = new int[val / 4];
        handle = GCHandle.Alloc(numArray, GCHandleType.Pinned);
        IntPtr ptr2 = handle.AddrOfPinnedObject();
        Marshal.WriteInt32(ptr2, val);
        HandleRef ref2 = new HandleRef(null, ptr);
        if (Process32First(ref2, ptr2))
        {
            do
            {
                WinProcessEntry entry = new WinProcessEntry();
                Marshal.PtrToStructure(ptr2, entry);
                ProcessInfo info = new ProcessInfo();
                string path = Marshal.PtrToStringAnsi((IntPtr) (((long) ptr2) + num));
                info.processName = Path.ChangeExtension(Path.GetFileName(path), null);
                info.handleCount = entry.cntUsage;
                info.processId = entry.th32ProcessID;
                info.basePriority = entry.pcPriClassBase;
                info.mainModuleId = entry.th32ModuleID;
                hashtable.Add(info.processId, info);
                Marshal.WriteInt32(ptr2, val);
            }
            while (Process32Next(ref2, ptr2));
        }
        WinThreadEntry structure = new WinThreadEntry();
        structure.dwSize = Marshal.SizeOf(structure);
        if (Thread32First(ref2, structure))
        {
            do
            {
                ThreadInfo info2 = new ThreadInfo();
                info2.threadId = structure.th32ThreadID;
                info2.processId = structure.th32OwnerProcessID;
                info2.basePriority = structure.tpBasePri;
                info2.currentPriority = structure.tpBasePri + structure.tpDeltaPri;
                list.Add(info2);
            }
            while (Thread32Next(ref2, structure));
        }
        for (int i = 0; i < list.Count; i++)
        {
            ThreadInfo info3 = (ThreadInfo) list[i];
            ProcessInfo info4 = (ProcessInfo) hashtable[info3.processId];
            if (info4 != null)
            {
                info4.threadInfoList.Add(info3);
            }
        }
    }
    finally
    {
        if (handle.IsAllocated)
        {
            handle.Free();
        }
        if (ptr != ((IntPtr) (-1)))
        {
        CloseHandle(new HandleRef(null, ptr));
        }
    }
    ProcessInfo[] array = new ProcessInfo[hashtable.Values.Count];
    hashtable.Values.CopyTo(array, 0);
    return array;
}

 


 

 
}
}


================================================
File: MegaDumper/Utils/ProcessUtil.cs
================================================
ï»¿/*
 * Created by SharpDevelop.
 * User: Bogdan
 * Date: 11.10.2010
 * Time: 15:47
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Collections;
using System.Text;
using System.IO;
using System.Threading;

namespace ProcessUtils
{

	public class ProcModule
	{

//  begin of enum modules

public enum ProcessAccess : int
{
    /// <summary>Specifies all possible access flags for the process object.</summary>
    AllAccess = CreateThread | DuplicateHandle | QueryInformation | SetInformation | Terminate | VMOperation | VMRead | VMWrite | Synchronize,
    /// <summary>Enables usage of the process handle in the CreateRemoteThread function to create a thread in the process.</summary>
    CreateThread = 0x2,
    /// <summary>Enables usage of the process handle as either the source or target process in the DuplicateHandle function to duplicate a handle.</summary>
    DuplicateHandle = 0x40,
    /// <summary>Enables usage of the process handle in the GetExitCodeProcess and GetPriorityClass functions to read information from the process object.</summary>
    QueryInformation = 0x400,
    /// <summary>Enables usage of the process handle in the SetPriorityClass function to set the priority class of the process.</summary>
    SetInformation = 0x200,
    /// <summary>Enables usage of the process handle in the TerminateProcess function to terminate the process.</summary>
    Terminate = 0x1,
    /// <summary>Enables usage of the process handle in the VirtualProtectEx and WriteProcessMemory functions to modify the virtual memory of the process.</summary>
    VMOperation = 0x8,
    /// <summary>Enables usage of the process handle in the ReadProcessMemory function to' read from the virtual memory of the process.</summary>
    VMRead = 0x10,
    /// <summary>Enables usage of the process handle in the WriteProcessMemory function to write to the virtual memory of the process.</summary>
    VMWrite = 0x20,
    /// <summary>Enables usage of the process handle in any of the wait functions to wait for the process to terminate.</summary>
    Synchronize = 0x100000
}

     
     [DllImport("kernel32.dll")]
     static extern IntPtr OpenProcess(ProcessAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, UInt32 dwProcessId);
     
     [DllImport("kernel32.dll", SetLastError=true)]
     [return: MarshalAs(UnmanagedType.Bool)]
     public static extern bool CloseHandle(IntPtr hObject);
     
     [DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true, ExactSpelling=true)]
     public static extern bool CloseHandle(HandleRef handle);
 

     //inner enum used only internally
    [Flags]
    private enum SnapshotFlags : uint
    {
    HeapList = 0x00000001,
    Process = 0x00000002,
    Thread = 0x00000004,
    Module = 0x00000008,
    Module32 = 0x00000010,
    Inherit = 0x80000000,
    All = 0x0000001F
    }
    //inner struct used only internally
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    private struct PROCESSENTRY32
    {
    const int MAX_PATH = 260;
    internal UInt32 dwSize;
    internal UInt32 cntUsage;
    internal UInt32 th32ProcessID;
    internal IntPtr th32DefaultHeapID;
    internal UInt32 th32ModuleID;
    internal UInt32 cntThreads;
    internal UInt32 th32ParentProcessID;
    internal Int32 pcPriClassBase;
    internal UInt32 dwFlags;
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = MAX_PATH)]
    internal string szExeFile;
    }

    [DllImport("kernel32", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
    static extern IntPtr CreateToolhelp32Snapshot([In]UInt32 dwFlags, [In]UInt32 th32ProcessID);

    [DllImport("kernel32", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
    static extern bool Process32First([In]IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

    [DllImport("kernel32", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
    static extern bool Process32Next([In]IntPtr hSnapshot, ref PROCESSENTRY32 lppe);

 	[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
	public static extern bool Module32First(HandleRef handle, IntPtr entry);
 
	[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
	public static extern bool Module32Next(HandleRef handle, IntPtr entry);
 

		
	public static bool get_IsNt()
	{
    return (Environment.OSVersion.Platform == PlatformID.Win32NT);
	}

    /// This data structure contains information about a module
    /// in a process that is collected in bulk by querying the
    /// operating system. 
    /// The reason to make this a separate structure from the ProcessModule
    /// component is so that we can throw it away all at once when
    /// Refresh is called on the component. 

    public class ModuleInfo
    {
        public string baseName;
        public string fileName;
        public IntPtr baseOfDll;
        public IntPtr entryPoint; 
        public int sizeOfImage;
        public int Id; // used only on win9x - for matching up with ProcessInfo.mainModuleId 
    } 

[StructLayout(LayoutKind.Sequential)]
public class WinModuleEntry
{
    public const int sizeofModuleName = 0x100;
    public const int sizeofFileName = 260;
    public int dwSize;
    public int th32ModuleID;
    public int th32ProcessID;
    public int GlblcntUsage;
    public int ProccntUsage;
    public IntPtr modBaseAddr = IntPtr.Zero;
    public int modBaseSize;
    public IntPtr hModule = IntPtr.Zero;
}

 

     public static ModuleInfo[] WinGetModuleInfos(uint processId)
     {
            IntPtr handle = (IntPtr)(-1);
            GCHandle bufferHandle = new GCHandle(); 
            ArrayList moduleInfos = new ArrayList();
 
            try {
                handle = CreateToolhelp32Snapshot(8, processId);
                if (handle == (IntPtr)(-1))
                {
                return null;
                }
                int entrySize = Marshal.SizeOf(typeof(WinModuleEntry));
                int bufferSize = entrySize + WinModuleEntry.sizeofFileName + WinModuleEntry.sizeofModuleName;
                int[] buffer = new int[bufferSize / 4];
                bufferHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned); 
                IntPtr bufferPtr = bufferHandle.AddrOfPinnedObject();
                Marshal.WriteInt32(bufferPtr, bufferSize); 
 
                HandleRef handleRef = new HandleRef(null, handle);
 
                if (Module32First(handleRef, bufferPtr)) {
                    do {
                        WinModuleEntry module = new WinModuleEntry();
                        Marshal.PtrToStructure(bufferPtr, module); 
                        ModuleInfo moduleInfo = new ModuleInfo();
                        moduleInfo.baseName = Marshal.PtrToStringAnsi((IntPtr)((long)bufferPtr + entrySize)); 
                        moduleInfo.fileName = Marshal.PtrToStringAnsi((IntPtr)((long)bufferPtr + entrySize + WinModuleEntry.sizeofModuleName)); 
                        moduleInfo.baseOfDll = module.modBaseAddr;
                        moduleInfo.sizeOfImage = module.modBaseSize; 
                        moduleInfo.Id = module.th32ModuleID;
                        moduleInfos.Add(moduleInfo);
                        Marshal.WriteInt32(bufferPtr, bufferSize);
                    } 
                    while (Module32Next(handleRef, bufferPtr));
                } 
            } 
            finally {
                if (bufferHandle.IsAllocated) bufferHandle.Free(); 
                if (handle != (IntPtr)(-1)) CloseHandle(new HandleRef(null, handle));
            }
 
            ModuleInfo[] temp = new ModuleInfo[moduleInfos.Count];
            moduleInfos.CopyTo(temp, 0); 
            return temp; 
        }
    
public static ModuleInfo[] NtGetModuleInfos(int processId)
{
return NtGetModuleInfos(processId, false);
}

		public static bool IsOSOlderThanXP()
       {
       return Environment.OSVersion.Version.Major < 5 ||
       (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor == 0);

       }
		
[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern IntPtr OpenProcess(ProcessAccess access, bool inherit, int processId);
 
[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
internal static extern int GetCurrentProcessId();

[DllImport("psapi.dll", CharSet=CharSet.Auto)]
public static extern bool EnumProcessModules(IntPtr handle, IntPtr modules, int size, ref int needed);
 
// There is no need to call CloseProcess or to use a SafeHandle if you get the handle
// using GetCurrentProcess as it returns a pseudohandle 
[DllImport("kernel32.dll",CallingConvention = CallingConvention.Winapi)]
[return: MarshalAs(UnmanagedType.Bool)]
internal static extern bool IsWow64Process( 
                   [In] IntPtr hSourceProcessHandle, 
                   [Out, MarshalAs(UnmanagedType.Bool)] 
                   out bool isWow64);
        
[DllImport("psapi.dll", CharSet=CharSet.Auto)]
public static extern bool GetModuleInformation(IntPtr processHandle, HandleRef moduleHandle, NtModuleInfo ntModuleInfo, int size);
[StructLayout(LayoutKind.Sequential)]

public class NtModuleInfo
{
    public IntPtr BaseOfDll = IntPtr.Zero;
    public int SizeOfImage;
    public IntPtr EntryPoint = IntPtr.Zero;
}
 
[DllImport("psapi.dll", CharSet=CharSet.Auto)]
public static extern int GetModuleBaseName(IntPtr processHandle, HandleRef moduleHandle, StringBuilder baseName, int size);
 
[DllImport("psapi.dll", CharSet=CharSet.Auto)]
public static extern int GetModuleFileNameEx(IntPtr processHandle, HandleRef moduleHandle, StringBuilder baseName, int size);
 

        private static ModuleInfo[] NtGetModuleInfos(int processId, bool firstModuleOnly) { 
            // preserving Everett behavior. 
            //if( processId == SystemProcessID || processId == IdleProcessID)
            //{
            // system process and idle process doesn't have any modules 
            //    throw new Win32Exception(HResults.EFail,SR.GetString(SR.EnumProcessModuleFailed));
            //}

            IntPtr processHandle = IntPtr.Zero; 
            try {
             // PROCESS_QUERY_INFORMATION | PROCESS_VM_READ
                processHandle = OpenProcess(ProcessAccess.QueryInformation|ProcessAccess.VMRead, false, processId);

                IntPtr[] moduleHandles = new IntPtr[64];
                GCHandle moduleHandlesArrayHandle = new GCHandle(); 
                int moduleCount = 0;
                for (;;) {
                    bool enumResult = false;
                    try { 
                        moduleHandlesArrayHandle = GCHandle.Alloc(moduleHandles, GCHandleType.Pinned);
                        enumResult = EnumProcessModules(processHandle, moduleHandlesArrayHandle.AddrOfPinnedObject(), moduleHandles.Length * IntPtr.Size, ref moduleCount); 
 
                        // The API we need to use to enumerate process modules differs on two factors:
                        //   1) If our process is running in WOW64. 
                        //   2) The bitness of the process we wish to introspect.
                        //
                        // If we are not running in WOW64 or we ARE in WOW64 but want to inspect a 32 bit process
                        // we can call psapi!EnumProcessModules. 
                        //
                        // If we are running in WOW64 and we want to inspect the modules of a 64 bit process then 
                        // psapi!EnumProcessModules will return false with ERROR_PARTIAL_COPY (299).  In this case we can't 
                        // do the enumeration at all.  So we'll detect this case and bail out.
                        // 
                        // Also, EnumProcessModules is not a reliable method to get the modules for a process.
                        // If OS loader is touching module information, this method might fail and copy part of the data.
                        // This is no easy solution to this problem. The only reliable way to fix this is to
                        // suspend all the threads in target process. Of course we don't want to do this in Process class. 
                        // So we just to try avoid the ---- by calling the same method 50 (an arbitary number) times.
                        // 
                        if (!enumResult)
                        {
                            bool sourceProcessIsWow64 = false;
                            bool targetProcessIsWow64 = false; 
                            if (!IsOSOlderThanXP()) {
                                IntPtr hCurProcess = IntPtr.Zero;
                                try {
                                    hCurProcess = OpenProcess(ProcessAccess.QueryInformation,true,GetCurrentProcessId()); 
                                    bool wow64Ret;
 
                                    wow64Ret = IsWow64Process(hCurProcess, out sourceProcessIsWow64); 
                                    if (!wow64Ret) {
                                        return null; 
                                    }

                                    wow64Ret = IsWow64Process(processHandle, out targetProcessIsWow64);
                                    if (!wow64Ret) { 
                                        return null;
                                    } 
 
                                    if (sourceProcessIsWow64 && !targetProcessIsWow64) {
                                    // Wow64 isn't going to allow this to happen,
                                    // the best we can do is give a descriptive error to the user.
                                    // throw new Win32Exception(299 /* ERROR_PARTIAL_COPY */,
                                    // SR.GetString(SR.EnumProcessModuleFailedDueToWow));
                                    return null;
                                    }

                                } finally {
                                    if (hCurProcess != IntPtr.Zero) {
                                        CloseHandle(hCurProcess); 
                                    } 
                                }
                            } 

                            // If the failure wasn't due to Wow64, try again.
                            for (int i = 0; i < 50; i++) {
                                enumResult = EnumProcessModules(processHandle, moduleHandlesArrayHandle.AddrOfPinnedObject(), moduleHandles.Length * IntPtr.Size, ref moduleCount); 
                                if (enumResult) {
                                    break; 
                                } 
                                Thread.Sleep(1);
                            } 
                        }
                    }
                    finally {
                        moduleHandlesArrayHandle.Free(); 
                    }
 
                    if (!enumResult) { 
                        return null;
                    } 

                    moduleCount /= IntPtr.Size;
                    if (moduleCount <= moduleHandles.Length) break;
                    moduleHandles = new IntPtr[moduleHandles.Length * 2]; 
                }
                ArrayList moduleInfos = new ArrayList(); 
 
                int ret;
                for (int i = 0; i < moduleCount; i++) { 
                    ModuleInfo moduleInfo = new ModuleInfo();
                    IntPtr moduleHandle = moduleHandles[i];
                    NtModuleInfo ntModuleInfo = new NtModuleInfo();
                    if (!GetModuleInformation(processHandle, new HandleRef(null, moduleHandle), ntModuleInfo, Marshal.SizeOf(ntModuleInfo))) 
                        return null;
                    moduleInfo.sizeOfImage = ntModuleInfo.SizeOfImage; 
                    moduleInfo.entryPoint = ntModuleInfo.EntryPoint; 
                    moduleInfo.baseOfDll = ntModuleInfo.BaseOfDll;
 
                    StringBuilder baseName = new StringBuilder(1024);
                    ret = GetModuleBaseName(processHandle, new HandleRef(null, moduleHandle), baseName, baseName.Capacity * 2);
                    if (ret == 0) return null;;
                    moduleInfo.baseName = baseName.ToString();

                    StringBuilder fileName = new StringBuilder(1024); 
                    ret = GetModuleFileNameEx(processHandle, new HandleRef(null, moduleHandle), fileName, fileName.Capacity * 2); 
                    if (ret == 0) return null;;
                    moduleInfo.fileName = fileName.ToString(); 

                    // smss.exe is started before the win32 subsystem so it get this funny "\systemroot\.." path.
                    // We change this to the actual path by appending "smss.exe" to GetSystemDirectory()
                    if (string.Compare(moduleInfo.fileName, "\\SystemRoot\\System32\\smss.exe", StringComparison.OrdinalIgnoreCase) == 0) { 
                        moduleInfo.fileName = Path.Combine(Environment.SystemDirectory, "smss.exe");
                    } 
                    // Avoid returning Unicode-style long string paths.  IO methods cannot handle them. 
                    if (moduleInfo.fileName != null
                        && moduleInfo.fileName.Length >= 4 
                        && moduleInfo.fileName.StartsWith(@"\\?\", StringComparison.Ordinal)) {

                            moduleInfo.fileName = moduleInfo.fileName.Substring(4);
                    } 

                    moduleInfos.Add(moduleInfo); 
                    // 
                    // If the user is only interested in the main module, break now.
                    // This avoid some waste of time. In addition, if the application unloads a DLL 
                    // we will not get an exception.
                    //
                    if( firstModuleOnly) { break; }
                } 
                ModuleInfo[] temp = new ModuleInfo[moduleInfos.Count];
                moduleInfos.CopyTo(temp, 0); 
                return temp; 
            }
            finally { 
                //Debug.WriteLineIf(Process.processTracing.TraceVerbose, "Process - CloseHandle(process)");
                if (processHandle!=IntPtr.Zero)
                {
                CloseHandle(processHandle);
                } 
            }
        }
     
        public static ModuleInfo[] GetModuleInfos(int processId)
        {
        if (get_IsNt())
        return NtGetModuleInfos(processId); 
        else
        return WinGetModuleInfos((uint)processId);
        }
		
// end of get modules!

// begin of module Injection

		public const uint PROCESS_TERMINATE = 0x0001;
		public const uint PROCESS_CREATE_THREAD = 0x0002;
		public const uint PROCESS_SET_SESSIONID = 0x0004;
		public const uint PROCESS_VM_OPERATION = 0x0008;
		public const uint PROCESS_VM_READ = 0x0010;
		public const uint PROCESS_VM_WRITE = 0x0020;
		public const uint PROCESS_DUP_HANDLE = 0x0040;
		public const uint PROCESS_CREATE_PROCESS = 0x0080;
		public const uint PROCESS_SET_QUOTA = 0x0100;
		public const uint PROCESS_SET_INFORMATION = 0x0200;
		public const uint PROCESS_QUERY_INFORMATION = 0x0400;
		
		
[Flags]
public enum AllocationType
{
     Commit = 0x1000,
     Reserve = 0x2000,
     Decommit = 0x4000,
     Release = 0x8000,
     Reset = 0x80000,
     Physical = 0x400000,
     TopDown = 0x100000,
     WriteWatch = 0x200000,
     LargePages = 0x20000000
}

[Flags]
public enum MemoryProtection
{
     Execute = 0x10,
     ExecuteRead = 0x20,
     ExecuteReadWrite = 0x40,
     ExecuteWriteCopy = 0x80,
     NoAccess = 0x01,
     ReadOnly = 0x02,
     ReadWrite = 0x04,
     WriteCopy = 0x08,
     GuardModifierflag = 0x100,
     NoCacheModifierflag = 0x200,
     WriteCombineModifierflag = 0x400
}

[DllImport("kernel32.dll")]
public static extern IntPtr OpenProcess(UInt32 dwDesiredAccess,  Int32 bInheritHandle, UInt32 dwProcessId);


[DllImport("kernel32.dll", ExactSpelling=true)]
public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress,
   uint dwSize, AllocationType flAllocationType, MemoryProtection flProtect);

[DllImport("kernel32", ExactSpelling=true, CharSet=CharSet.Ansi)]
private static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, uint nSize, ref int lpNumberOfBytesWritten);

[DllImport("kernel32.dll")]
public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,[In, Out] byte[] buffer, UInt32 size, out uint lpNumberOfBytesWritten);

// CreateRemoteThread, since ThreadProc is in remote process, we must use a raw function-pointer.
        [DllImport("kernel32.dll")]
        public static extern IntPtr CreateRemoteThread(        
          IntPtr hProcess,
          IntPtr lpThreadAttributes,
          uint dwStackSize,
          IntPtr lpStartAddress, // raw Pointer into remote process
          IntPtr lpParameter,
          uint dwCreationFlags,
          IntPtr lpThreadId
        );
        
[DllImport("kernel32.dll")]
public static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

[DllImport("kernel32.dll", ExactSpelling=true)]
public static extern bool VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress,
   int dwSize, FreeType dwFreeType);
   
[Flags]
public enum FreeType
{
     Decommit = 0x4000,
     Release = 0x8000,
}

[DllImport("kernel32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool GetExitCodeThread(IntPtr hThread, out IntPtr lpExitCode);

[DllImport("kernel32.dll", CharSet=CharSet.Auto)]
public static extern IntPtr GetModuleHandleW(string lpModuleName);

[DllImport("kernel32.dll", CharSet=CharSet.Ansi)]
public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);


public static string PostVerify(uint hprocess,string libFullPath)
{
if (hprocess==0)
{
return "Invalid process";
}

if (libFullPath==""||!File.Exists(libFullPath))
{
return "Invalid file!";
}

return "";
}

public static IntPtr InjectLibraryInternal(uint processid,string libFullPath,out string error)
{
error = PostVerify(processid,libFullPath);
if (error!="") return IntPtr.Zero;

ModuleInfo targetkernel = null;
ModuleInfo[] modules = GetModuleInfos((int)processid);

if (modules!=null&&modules.Length>0)
{
for (int i=0;i<modules.Length;i++)
{
if (modules[i].baseName.ToLower().Contains("kernel32"))
{
targetkernel = modules[i];
break;
}
}
}



// 
//	GetProcAddress(GetModuleHandleW("kernel32.dll"),"LoadLibraryA");
if (targetkernel==null||targetkernel.baseOfDll==IntPtr.Zero)
{
error = "Failed to get base of kernel32!";
return IntPtr.Zero;
}

IntPtr hprocess = IntPtr.Zero;
hprocess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_CREATE_THREAD, 0, processid);
if (hprocess==IntPtr.Zero)
{
error = "Can't open selected process!";
return IntPtr.Zero;
}
else
{
int LoadLibraryArva = ExportTable.ProcGetExpAddress
	(hprocess, targetkernel.baseOfDll,"LoadLibraryA");
if (LoadLibraryArva==0)
{
CloseHandle(hprocess);
error = "Failed to get address of LoadLibraryA!";
return IntPtr.Zero;
}
IntPtr loadlibraryAddress = (IntPtr)((long)targetkernel.baseOfDll+(long)LoadLibraryArva);

uint sizeAscii = (uint)Encoding.ASCII.GetByteCount(libFullPath)+1;
// allocate memory to the local process for libFullPath
IntPtr pLibPath = VirtualAllocEx(hprocess, IntPtr.Zero, sizeAscii, AllocationType.Commit, MemoryProtection.ReadWrite);
if (pLibPath==IntPtr.Zero)
{
CloseHandle(hprocess);
error = "Can't alocate memory on process!";
return IntPtr.Zero;
}
else
{
int bytesWritten=0;
// write libFullPath to pLibPath
if (!WriteProcessMemory(hprocess,pLibPath,Marshal.StringToHGlobalAnsi(libFullPath),
	sizeAscii-1,ref bytesWritten)||bytesWritten != (int)sizeAscii-1)
{
VirtualFreeEx(hprocess, pLibPath, 0, FreeType.Release);
CloseHandle(hprocess);
error = "Can't write libname on process!";
return IntPtr.Zero;
}
else
{
// load dll via call to LoadLibrary using CreateRemoteThread
IntPtr hThread = CreateRemoteThread(hprocess,IntPtr.Zero, 0,
loadlibraryAddress, pLibPath, 0, IntPtr.Zero);

if (hThread==IntPtr.Zero)
{
VirtualFreeEx(hprocess, pLibPath, 0, FreeType.Release);
CloseHandle(hprocess);
error = "Can't create the remote thread!";
return IntPtr.Zero;
}
else
{
if (WaitForSingleObject(hThread,uint.MaxValue)!=0)
{
VirtualFreeEx(hprocess, pLibPath, 0, FreeType.Release);
CloseHandle(hprocess);
error = "Error on WaitForSingleObject!";
return IntPtr.Zero;
}
// get address of loaded module
IntPtr hLibModule = IntPtr.Zero;
if (!GetExitCodeThread(hThread, out hLibModule))
{
VirtualFreeEx(hprocess, pLibPath, 0, FreeType.Release);
CloseHandle(hprocess);
error = "Error on GetExitCodeThread!";
return IntPtr.Zero;
}

if (hLibModule == IntPtr.Zero)
{
VirtualFreeEx(hprocess, pLibPath, 0, FreeType.Release);
CloseHandle(hprocess);
error = "Code executed properly, but unable to get an appropriate module handle!";
return IntPtr.Zero;
}

error = "";
VirtualFreeEx(hprocess, pLibPath, 0, FreeType.Release);
CloseHandle(hprocess);
return hLibModule;
}

}


}

}

}
	

public static bool FreeLibraryInternal(uint processid,IntPtr libAddress,out string error)
{
ModuleInfo targetkernel = null;
ModuleInfo[] modules = GetModuleInfos((int)processid);

if (modules!=null&&modules.Length>0)
{
for (int i=0;i<modules.Length;i++)
{
if (modules[i].baseName.ToLower().Contains("kernel32"))
{
targetkernel = modules[i];
break;
}
}
}

if (targetkernel==null||targetkernel.baseOfDll==IntPtr.Zero)
{
error = "Failed to get base of kernel32!";
return false;
}

IntPtr hprocess = IntPtr.Zero;
hprocess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_CREATE_THREAD, 0, processid);
if (hprocess==IntPtr.Zero)
{
error = "Can't open selected process!";
return false;
}
else
{
int FreeLibraryrva = ExportTable.ProcGetExpAddress
	(hprocess, targetkernel.baseOfDll,"FreeLibrary");
if (FreeLibraryrva==0)
{
CloseHandle(hprocess);
error = "Failed to get address of FreeLibrary!";
return false;
}
else
{
IntPtr FreeLibAddress = (IntPtr)((long)targetkernel.baseOfDll+(long)FreeLibraryrva);
// load dll via call to LoadLibrary using CreateRemoteThread
IntPtr hThread = CreateRemoteThread(hprocess,IntPtr.Zero, 0,
FreeLibAddress, libAddress, 0, IntPtr.Zero);

if (hThread==IntPtr.Zero)
{
CloseHandle(hprocess);
error = "Can't create the remote thread!";
return false;
}
else
{
if (WaitForSingleObject(hThread,uint.MaxValue)!=0)
{
CloseHandle(hprocess);
error = "Error on WaitForSingleObject!";
return false;
}
else
{
error = "";
return true;
}
}
}
}

}

	}
	
	public class ExportTable
	{
// begin of Export reader:
    
    [StructLayout(LayoutKind.Sequential)]
    public struct IMAGE_EXPORT_DIRECTORY
    {
        public UInt32 Characteristics;
        public UInt32 TimeDateStamp;
        public UInt16 MajorVersion;
        public UInt16 MinorVersion;
        public UInt32 Name;
        public UInt32 Base;
        public UInt32 NumberOfFunctions;
        public UInt32 NumberOfNames;
        public UInt32 AddressOfFunctions;     // RVA from base of image
        public UInt32 AddressOfNames;     // RVA from base of image
        public UInt32 AddressOfNameOrdinals;  // RVA from base of image
    }
    
		[DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
        
public unsafe static int ProcGetExpAddress(
IntPtr hprocess,IntPtr hmodule,string exportnname)
{
byte[] Forread = new byte[8];
uint BytesRead = 0;
int PEOffset = 0;
int ExportDirectoryRVA = 0;
int ExportDirectorySize = 0;

if (!ReadProcessMemory(hprocess,(IntPtr)((long)hmodule+0x3C),Forread,4, ref BytesRead))
return -1;

PEOffset = BitConverter.ToInt32(Forread,0);

if (!ReadProcessMemory(hprocess,(IntPtr)((long)hmodule+PEOffset+0x78),Forread,8, ref BytesRead))
return -1;

try
{
ExportDirectoryRVA  = BitConverter.ToInt32(Forread,0);
ExportDirectorySize = BitConverter.ToInt32(Forread,4);
Forread = new byte[ExportDirectorySize];
if (!ReadProcessMemory(hprocess,(IntPtr)((long)hmodule+ExportDirectoryRVA),Forread,(uint)ExportDirectorySize, ref BytesRead))
return -1;

IntPtr ptPoit = Marshal.AllocHGlobal(ExportDirectorySize);
Marshal.Copy(Forread, 0, ptPoit, ExportDirectorySize);
IMAGE_EXPORT_DIRECTORY IED = (IMAGE_EXPORT_DIRECTORY)Marshal.PtrToStructure(ptPoit, typeof(IMAGE_EXPORT_DIRECTORY));
Marshal.FreeHGlobal(ptPoit);

int[] funcaddresses = new int[IED.NumberOfFunctions];
int[] funcnames = new int[IED.NumberOfNames];
ushort[] ordinals = new ushort[IED.NumberOfFunctions];

byte[] keeper = new byte[IED.NumberOfFunctions*4];
if (!ReadProcessMemory(hprocess,(IntPtr)((long)hmodule+IED.AddressOfFunctions),keeper,(uint)IED.NumberOfFunctions*4, ref BytesRead))
return -1;

for (int i=0;i<funcaddresses.Length;i++)
funcaddresses[i]=BitConverter.ToInt32(keeper,i*4);

if (!ReadProcessMemory(hprocess,(IntPtr)((long)hmodule+IED.AddressOfNames),keeper,(uint)IED.NumberOfNames*4, ref BytesRead))
return -1;

for (int i=0;i<funcnames.Length;i++)
funcnames[i]=BitConverter.ToInt32(keeper,i*4);

if (!ReadProcessMemory(hprocess,(IntPtr)((long)hmodule+IED.AddressOfNameOrdinals),keeper,(uint)IED.NumberOfFunctions*2, ref BytesRead))
return -1;

for (int i=0;i<funcnames.Length;i++)
ordinals[i]=BitConverter.ToUInt16(keeper,i*2);

// wrong: the first name is CLRCreateInstance
for (int i=0;i<funcnames.Length;i++)
{
if (funcnames[i]!=0)
{
byte[] currentchar = new byte[1];
int count = 0;
string funcname = "";
while (ReadProcessMemory(hprocess,(IntPtr)((long)hmodule+funcnames[i]+count),
      currentchar,1, ref BytesRead)&&currentchar[0]!=0)
{
funcname = funcname+(char)currentchar[0];
count++;
}

if (funcname==exportnname)
{
return funcaddresses[ordinals[i]];
}

}
}

}
catch
{
return -1;
}
return -1;
	}


// end of Export reader



	}
	
	public class MemStringReader
	{
	[DllImport("Kernel32.dll")]
        public static extern bool ReadProcessMemory
        (
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            UInt32 nSize,
            ref UInt32 lpNumberOfBytesRead
        );
        
     
public unsafe static string ReadUnicodeString(
IntPtr hprocess,IntPtr address)
	{
if (hprocess==IntPtr.Zero||address==IntPtr.Zero)
return null;

string readedstring = "";
byte[] datas = new byte[2];
uint BytesRead = 0;

uint count=0;

while (ReadProcessMemory(hprocess,(IntPtr)((long)address+(long)count),datas,2, ref BytesRead))
{
if (datas[0]==0&&datas[1]==0)
{
break;
}
count=count+2;
}
if (count==0) return "";

datas = new byte[count];
if (!ReadProcessMemory(hprocess,(IntPtr)((long)address),datas,count, ref BytesRead))
return "";

System.Text.Encoding encoding = System.Text.Encoding.Unicode;
readedstring = encoding.GetString(datas);

return readedstring;
	}
	
           
public unsafe static string ReadAsciiString(
IntPtr hprocess,IntPtr address)
	{
if (hprocess==IntPtr.Zero||address==IntPtr.Zero)
return null;

string readedstring = "";
byte[] datas = new byte[1];
uint BytesRead = 0;

uint count=0;

while (ReadProcessMemory(hprocess,(IntPtr)((long)address+(long)count),datas,1, ref BytesRead))
{
if (datas[0]==0)
{
break;
}
count++;
}
if (count==0) return "";

datas = new byte[count];
if (!ReadProcessMemory(hprocess,(IntPtr)((long)address),datas,count, ref BytesRead))
return "";

System.Text.Encoding encoding = System.Text.Encoding.ASCII;
readedstring = encoding.GetString(datas);

return readedstring;
	}
	
	}
	
}




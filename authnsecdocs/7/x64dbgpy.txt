Directory structure:
└── x64dbg-x64dbgpy/
    ├── README.md
    ├── LICENSE
    ├── copy_plugins.bat
    ├── install.bat
    ├── install32.bat
    ├── install64.bat
    ├── pluginmain.cpp
    ├── pluginmain.h
    ├── py.cpp
    ├── py.h
    ├── resource.h
    ├── setenv.bat
    ├── stringutils.cpp
    ├── stringutils.h
    ├── x64dbgpy.h
    ├── x64dbgpy.rc
    ├── x64dbgpy.sln
    ├── x64dbgpy.vcxproj
    ├── x64dbgpy.vcxproj.filters
    ├── .editorconfig
    ├── hooks/
    │   └── pre-commit
    ├── pluginsdk/
    │   ├── _dbgfunctions.h
    │   ├── _plugin_types.h
    │   ├── _plugins.h
    │   ├── _scriptapi.h
    │   ├── _scriptapi_argument.h
    │   ├── _scriptapi_assembler.h
    │   ├── _scriptapi_bookmark.h
    │   ├── _scriptapi_comment.h
    │   ├── _scriptapi_debug.h
    │   ├── _scriptapi_flag.h
    │   ├── _scriptapi_function.h
    │   ├── _scriptapi_gui.h
    │   ├── _scriptapi_label.h
    │   ├── _scriptapi_memory.h
    │   ├── _scriptapi_misc.h
    │   ├── _scriptapi_module.h
    │   ├── _scriptapi_pattern.h
    │   ├── _scriptapi_register.h
    │   ├── _scriptapi_stack.h
    │   ├── _scriptapi_symbol.h
    │   ├── bridgegraph.h
    │   ├── bridgelist.h
    │   ├── bridgemain.h
    │   ├── DeviceNameResolver/
    │   │   └── DeviceNameResolver.h
    │   ├── TitanEngine/
    │   │   └── TitanEngine.h
    │   ├── XEDParse/
    │   │   └── XEDParse.h
    │   ├── capstone/
    │   │   ├── arm.h
    │   │   ├── arm64.h
    │   │   ├── capstone.h
    │   │   ├── m68k.h
    │   │   ├── mips.h
    │   │   ├── platform.h
    │   │   ├── ppc.h
    │   │   ├── sparc.h
    │   │   ├── systemz.h
    │   │   ├── x86.h
    │   │   └── xcore.h
    │   ├── dbghelp/
    │   │   └── dbghelp.h
    │   ├── jansson/
    │   │   ├── jansson.h
    │   │   ├── jansson_config.h
    │   │   └── jansson_x64dbg.h
    │   ├── lz4/
    │   │   ├── lz4.h
    │   │   ├── lz4file.h
    │   │   └── lz4hc.h
    │   └── yara/
    │       ├── yara.h
    │       └── yara/
    │           ├── ahocorasick.h
    │           ├── arena.h
    │           ├── atoms.h
    │           ├── compiler.h
    │           ├── dotnet.h
    │           ├── elf.h
    │           ├── endian.h
    │           ├── error.h
    │           ├── exec.h
    │           ├── exefiles.h
    │           ├── filemap.h
    │           ├── globals.h
    │           ├── hash.h
    │           ├── hex_lexer.h
    │           ├── integers.h
    │           ├── lexer.h
    │           ├── libyara.h
    │           ├── limits.h
    │           ├── mem.h
    │           ├── modules.h
    │           ├── object.h
    │           ├── parser.h
    │           ├── pe.h
    │           ├── pe_utils.h
    │           ├── proc.h
    │           ├── re.h
    │           ├── re_lexer.h
    │           ├── rules.h
    │           ├── scan.h
    │           ├── sizedstr.h
    │           ├── stream.h
    │           ├── strutils.h
    │           ├── threading.h
    │           ├── types.h
    │           └── utils.h
    ├── pybind11/
    ├── res/
    ├── scriptapi/
    │   ├── scriptapi.cpp
    │   ├── scriptapi.vcxproj
    │   └── scriptapi.vcxproj.filters
    └── swig/
        ├── _plugins.i
        ├── _scriptapi.i
        ├── _scriptapi_argument.i
        ├── _scriptapi_assembler.i
        ├── _scriptapi_bookmark.i
        ├── _scriptapi_comment.i
        ├── _scriptapi_debug.i
        ├── _scriptapi_flag.i
        ├── _scriptapi_function.i
        ├── _scriptapi_gui.i
        ├── _scriptapi_label.i
        ├── _scriptapi_memory.i
        ├── _scriptapi_misc.i
        ├── _scriptapi_module.i
        ├── _scriptapi_pattern.i
        ├── _scriptapi_register.i
        ├── _scriptapi_stack.i
        ├── _scriptapi_symbol.i
        ├── bridgelist.i
        ├── bridgemain.i
        ├── clean.bat
        ├── setup.py
        ├── x64dbg.i
        ├── include/
        │   └── stdint.h
        ├── swigwin-3.0.8/
        │   └── Lib/
        │       ├── allkw.swg
        │       ├── attribute.i
        │       ├── carrays.i
        │       ├── cdata.i
        │       ├── cmalloc.i
        │       ├── constraints.i
        │       ├── cpointer.i
        │       ├── cstring.i
        │       ├── cwstring.i
        │       ├── director_common.swg
        │       ├── exception.i
        │       ├── intrusive_ptr.i
        │       ├── inttypes.i
        │       ├── linkruntime.c
        │       ├── math.i
        │       ├── pointer.i
        │       ├── runtime.swg
        │       ├── shared_ptr.i
        │       ├── std_except.i
        │       ├── stdint.i
        │       ├── stl.i
        │       ├── swig.swg
        │       ├── swigarch.i
        │       ├── swigerrors.swg
        │       ├── swiginit.swg
        │       ├── swiglabels.swg
        │       ├── swigrun.i
        │       ├── swigrun.swg
        │       ├── swigwarn.swg
        │       ├── swigwarnings.swg
        │       ├── wchar.i
        │       ├── windows.i
        │       ├── cffi/
        │       │   └── cffi.swg
        │       ├── python/
        │       │   ├── Makefile.in
        │       │   ├── README
        │       │   ├── argcargv.i
        │       │   ├── attribute.i
        │       │   ├── boost_shared_ptr.i
        │       │   ├── builtin.swg
        │       │   ├── carrays.i
        │       │   ├── ccomplex.i
        │       │   ├── cdata.i
        │       │   ├── cmalloc.i
        │       │   ├── cni.i
        │       │   ├── complex.i
        │       │   ├── cpointer.i
        │       │   ├── cstring.i
        │       │   ├── cwstring.i
        │       │   ├── defarg.swg
        │       │   ├── director.swg
        │       │   ├── embed.i
        │       │   ├── embed15.i
        │       │   ├── exception.i
        │       │   ├── factory.i
        │       │   ├── file.i
        │       │   ├── implicit.i
        │       │   ├── jstring.i
        │       │   ├── pyabc.i
        │       │   ├── pyapi.swg
        │       │   ├── pybackward.swg
        │       │   ├── pybuffer.i
        │       │   ├── pyclasses.swg
        │       │   ├── pycomplex.swg
        │       │   ├── pycontainer.swg
        │       │   ├── pydocs.swg
        │       │   ├── pyerrors.swg
        │       │   ├── pyfragments.swg
        │       │   ├── pyhead.swg
        │       │   ├── pyinit.swg
        │       │   ├── pyiterators.swg
        │       │   ├── pymacros.swg
        │       │   ├── pyname_compat.i
        │       │   ├── pyopers.swg
        │       │   ├── pyprimtypes.swg
        │       │   ├── pyrun.swg
        │       │   ├── pyruntime.swg
        │       │   ├── pystdcommon.swg
        │       │   ├── pystrings.swg
        │       │   ├── python.swg
        │       │   ├── pythonkw.swg
        │       │   ├── pythreads.swg
        │       │   ├── pytuplehlp.swg
        │       │   ├── pytypemaps.swg
        │       │   ├── pyuserdir.swg
        │       │   ├── pywstrings.swg
        │       │   ├── std_alloc.i
        │       │   ├── std_array.i
        │       │   ├── std_auto_ptr.i
        │       │   ├── std_basic_string.i
        │       │   ├── std_carray.i
        │       │   ├── std_char_traits.i
        │       │   ├── std_common.i
        │       │   ├── std_complex.i
        │       │   ├── std_container.i
        │       │   ├── std_deque.i
        │       │   ├── std_except.i
        │       │   ├── std_ios.i
        │       │   ├── std_iostream.i
        │       │   ├── std_list.i
        │       │   ├── std_map.i
        │       │   ├── std_multimap.i
        │       │   ├── std_multiset.i
        │       │   ├── std_pair.i
        │       │   ├── std_set.i
        │       │   ├── std_shared_ptr.i
        │       │   ├── std_sstream.i
        │       │   ├── std_streambuf.i
        │       │   ├── std_string.i
        │       │   ├── std_unordered_map.i
        │       │   ├── std_unordered_multimap.i
        │       │   ├── std_unordered_multiset.i
        │       │   ├── std_unordered_set.i
        │       │   ├── std_vector.i
        │       │   ├── std_vectora.i
        │       │   ├── std_wios.i
        │       │   ├── std_wiostream.i
        │       │   ├── std_wsstream.i
        │       │   ├── std_wstreambuf.i
        │       │   ├── std_wstring.i
        │       │   ├── stl.i
        │       │   ├── typemaps.i
        │       │   └── wchar.i
        │       ├── std/
        │       │   ├── README
        │       │   ├── _std_deque.i
        │       │   ├── std_alloc.i
        │       │   ├── std_array.i
        │       │   ├── std_basic_string.i
        │       │   ├── std_carray.swg
        │       │   ├── std_char_traits.i
        │       │   ├── std_common.i
        │       │   ├── std_container.i
        │       │   ├── std_deque.i
        │       │   ├── std_except.i
        │       │   ├── std_ios.i
        │       │   ├── std_iostream.i
        │       │   ├── std_list.i
        │       │   ├── std_map.i
        │       │   ├── std_multimap.i
        │       │   ├── std_multiset.i
        │       │   ├── std_pair.i
        │       │   ├── std_queue.i
        │       │   ├── std_set.i
        │       │   ├── std_sstream.i
        │       │   ├── std_stack.i
        │       │   ├── std_streambuf.i
        │       │   ├── std_string.i
        │       │   ├── std_unordered_map.i
        │       │   ├── std_unordered_multimap.i
        │       │   ├── std_unordered_multiset.i
        │       │   ├── std_unordered_set.i
        │       │   ├── std_vector.i
        │       │   ├── std_vectora.i
        │       │   ├── std_wios.i
        │       │   ├── std_wiostream.i
        │       │   ├── std_wsstream.i
        │       │   ├── std_wstreambuf.i
        │       │   └── std_wstring.i
        │       └── typemaps/
        │           ├── README
        │           ├── attribute.swg
        │           ├── carrays.swg
        │           ├── cdata.swg
        │           ├── cmalloc.swg
        │           ├── cpointer.swg
        │           ├── cstring.swg
        │           ├── cstrings.swg
        │           ├── cwstring.swg
        │           ├── enumint.swg
        │           ├── exception.swg
        │           ├── factory.swg
        │           ├── fragments.swg
        │           ├── implicit.swg
        │           ├── inoutlist.swg
        │           ├── misctypes.swg
        │           ├── primtypes.swg
        │           ├── ptrtypes.swg
        │           ├── std_except.swg
        │           ├── std_string.swg
        │           ├── std_strings.swg
        │           ├── std_wstring.swg
        │           ├── string.swg
        │           ├── strings.swg
        │           ├── swigmacros.swg
        │           ├── swigobject.swg
        │           ├── swigtype.swg
        │           ├── swigtypemaps.swg
        │           ├── traits.swg
        │           ├── typemaps.swg
        │           ├── valtypes.swg
        │           ├── void.swg
        │           └── wstring.swg
        └── x64dbgpy/
            ├── __breakpoints.py
            ├── __events.py
            ├── __flags.py
            ├── __init__.py
            ├── __registers.py
            ├── hooks.py
            ├── utils.py
            ├── autorun/
            │   └── README.md
            └── pluginsdk/
                ├── __init__.py
                ├── _plugins.py
                ├── bridgemain.py
                └── _scriptapi/
                    ├── __init__.py
                    ├── argument.py
                    ├── assembler.py
                    ├── bookmark.py
                    ├── comment.py
                    ├── debug.py
                    ├── flag.py
                    ├── function.py
                    ├── gui.py
                    ├── label.py
                    ├── memory.py
                    ├── misc.py
                    ├── module.py
                    ├── pattern.py
                    ├── register.py
                    ├── stack.py
                    └── symbol.py

================================================
File: README.md
================================================
# x64dbgpy

[![Build status](https://ci.appveyor.com/api/projects/status/uai2omdvrw3xcie4?svg=true)](https://ci.appveyor.com/project/mrexodia/x64dbg-python)

Automating [x64dbg](http://x64dbg.com) using Python.

Works with: http://releases.x64dbg.com

Get PyQt5 [here](https://github.com/x64dbg/PyQt5/releases). Video tutorial [here](https://youtu.be/rIFA6t1Z9Fc).

### To develop you will need:

1. Visual Studio 2015 Community: https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx <br />
2. Python 2.7 x64 + x86 && pip (Python 2.7.10 has pip on it) - https://www.python.org/downloads/release/python-2710/ <br />
3. Microsoft Visual C++ Compiler for Python 2.7: http://www.microsoft.com/en-us/download/details.aspx?id=44266 <br />
4. PyCharm Community Edition (If you are python developer) : https://www.jetbrains.com/pycharm/download/

### To install and test:

1. Install Python 2.7.10 (x64 + x86) In seperate folders
2. Install Visual Studio 2015 Community.
3. Open setenv.bat from the project folder.
4. Compile the win32 and win64 dlls.
5. Copy the release folder from the snapshot to the project directory.
6. Run install32.bat and install64.bat.

### Contributors:

1. Run install.bat (git hook for code buetify)
2. Test your code
3. Read PEP8: https://www.python.org/dev/peps/pep-0008/

### Example scripts:

* https://github.com/realgam3/ReversingAutomation/tree/master/X64dbgPy

### Help:

* I need help with the swig / cpp development,
* Translating the event callbacks to swig and use it without the code in py.cpp file.
* Connecting ipython interpreter to x64dbgpy.
* Python multiprocessing with x64dbgpy plugin (Python embedded).


================================================
File: LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2015 RealGame (Tomer Zait)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




================================================
File: copy_plugins.bat
================================================
@echo off
call install32.bat
call install64.bat
xcopy release\x32\* ..\x64dbg\bin\x32\ /S /Y
xcopy release\x64\* ..\x64dbg\bin\x64\ /S /Y


================================================
File: install.bat
================================================
@echo off
echo Run this to install the auto-format hook.
copy hooks\pre-commit .git\hooks\pre-commit


================================================
File: install32.bat
================================================
@echo off

set RELEASEDIR=%~dp0release
set PLUGINDIR="%RELEASEDIR%\x32\plugins"
mkdir %PLUGINDIR%
copy bin\x32\x64dbgpy.dp32 %PLUGINDIR%\
copy bin\x32\x64dbgpy.lib %RELEASEDIR%\x64dbgpy_x86.lib
copy x64dbgpy.h %RELEASEDIR%\

@cd swig
call clean.bat
call "%~dp0\setenv.bat"
call %VCVARS% x86
set PYTHONHOME=%PYTHON27X86%
"%PYTHON27X86%\python.exe" setup.py  install --install-lib=%PLUGINDIR%\x64dbgpy
@cd ..

copy bin\x32\scriptapi.pyd %PLUGINDIR%\x64dbgpy\

@echo on


================================================
File: install64.bat
================================================
@echo off

set RELEASEDIR=%~dp0release
set PLUGINDIR="%RELEASEDIR%\x64\plugins"
mkdir %PLUGINDIR%
copy bin\x64\x64dbgpy.dp64 %PLUGINDIR%\
copy bin\x64\x64dbgpy.lib %RELEASEDIR%\x64dbgpy_x64.lib
copy x64dbgpy.h %RELEASEDIR%\

@cd swig
call clean.bat
call "%~dp0\setenv.bat"
call %VCVARS% x86_amd64
set PYTHONHOME=%PYTHON27X64%
"%PYTHON27X64%\python.exe" setup.py  install --install-lib=%PLUGINDIR%\x64dbgpy
@cd ..

copy bin\x64\scriptapi.pyd %PLUGINDIR%\x64dbgpy\

@echo on


================================================
File: pluginmain.cpp
================================================
#include "pluginmain.h"
#include "py.h"

int pluginHandle;
HWND hwndDlg;
int hMenu;
int hMenuDisasm;
int hMenuDump;
int hMenuStack;

DLL_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    initStruct->pluginVersion = plugin_version;
    initStruct->sdkVersion = PLUG_SDKVERSION;
    strcpy(initStruct->pluginName, plugin_name);
    pluginHandle = initStruct->pluginHandle;
    return pyInit(initStruct);
}

DLL_EXPORT bool plugstop()
{
    pyStop();
    return true;
}

DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    hwndDlg = setupStruct->hwndDlg;
    hMenu = setupStruct->hMenu;
    hMenuDisasm = setupStruct->hMenuDisasm;
    hMenuDump = setupStruct->hMenuDump;
    hMenuStack = setupStruct->hMenuStack;
    pySetup();
}

BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    if(fdwReason == DLL_PROCESS_ATTACH)
    {
        hInst = hinstDLL;
    }
    return TRUE;
}



================================================
File: pluginmain.h
================================================
#ifndef _PLUGINMAIN_H
#define _PLUGINMAIN_H

#pragma warning(disable:4091)

#include <windows.h>
#include "pluginsdk\_plugins.h"

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif //DLL_EXPORT

//superglobal variables
extern int pluginHandle;
extern HWND hwndDlg;
extern int hMenu;
extern int hMenuDisasm;
extern int hMenuDump;
extern int hMenuStack;

#define plugin_name "x64dbgpy"
#define plugin_version 1

#ifdef __cplusplus
extern "C"
{
#endif

DLL_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct);
DLL_EXPORT bool plugstop();
DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct);

#ifdef __cplusplus
}
#endif

#endif //_PLUGINMAIN_H



================================================
File: py.cpp
================================================
#include "py.h"
#include "stringutils.h"
#include "resource.h"
#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <python.h>
#include <shlwapi.h>

#pragma comment(lib, "shlwapi.lib")

#define module_name "x64dbgpy"
#define token_paste(a, b) token_paste_(a, b)
#define token_paste_(a, b) a ## b
#define event_object_name "Event"
#define autorun_directory L"plugins\\x64dbgpy\\x64dbgpy\\autorun"
// lParam: ScanCode=0x41(ALT), cRepeat=1, fExtended=False, fAltDown=True, fRepeat=False, fUp=False
#define ALT_F7_SYSKEYDOWN 0x20410001

PyObject* pModule, *pEventObject;
HINSTANCE hInst;
HMODULE hPython27;

// This is necessary because python27 is delay loaded
#define PYDATA(symbol) []() -> decltype(symbol)& { static auto ptr = GetProcAddress(hPython27, #symbol); return *(decltype(&symbol))ptr; }()

enum
{
    MENU_RUNSCRIPTASYNC,
    MENU_RUNGUISCRIPT,
    MENU_ABOUT
};

extern "C" __declspec(dllexport) void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info)
{
    switch(info->hEntry)
    {
    case MENU_RUNSCRIPTASYNC:
        DbgCmdExec("PyRunScriptAsync");
        break;

    case MENU_RUNGUISCRIPT:
        DbgCmdExec("PyRunGuiScript");
        break;

    case MENU_ABOUT:
        MessageBoxA(hwndDlg, "Made By RealGame (Tomer Zait)", plugin_name " Plugin", MB_ICONINFORMATION);
        break;
    }
}

static void pyCallback(const char* eventName, PyObject* pKwargs)
{
    PyObject* pFunc, *pValue;

    // Check if event object exist.
    if(pEventObject == NULL)
        return;

    pFunc = PyObject_GetAttrString(pEventObject, eventName);
    if(pFunc && PyCallable_Check(pFunc))
    {
        pValue = PyObject_Call(pFunc, PyTuple_New(0), pKwargs);
        Py_DECREF(pKwargs);
        Py_DECREF(pFunc);
        if(pValue == NULL)
        {
            _plugin_logprintf("[PYTHON] Could not use %s function.\n", eventName);
            PyErr_PrintEx(0);
            return;
        }

        Py_DECREF(pValue);
    }
}

static bool OpenFileDialog(wchar_t Buffer[MAX_PATH])
{
    OPENFILENAMEW sOpenFileName = { 0 };
    const wchar_t szFilterString[] = L"Python files\0*.py\0\0";
    const wchar_t szDialogTitle[] = L"Select script file...";
    sOpenFileName.lStructSize = sizeof(sOpenFileName);
    sOpenFileName.lpstrFilter = szFilterString;
    sOpenFileName.nFilterIndex = 1;
    sOpenFileName.lpstrFile = Buffer;
    sOpenFileName.nMaxFile = MAX_PATH;
    sOpenFileName.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
    sOpenFileName.lpstrTitle = szDialogTitle;
    sOpenFileName.hwndOwner = GuiGetWindowHandle();
    return (FALSE != GetOpenFileNameW(&sOpenFileName));
}

static bool FileExists(const wchar_t* file)
{
    DWORD attrib = GetFileAttributesW(file);
    return (attrib != INVALID_FILE_ATTRIBUTES && !(attrib & FILE_ATTRIBUTE_DIRECTORY));
}

static bool ExecutePythonScript(const wchar_t* szFileName, int argc, char* argv[])
{
    if(!FileExists(szFileName))
    {
        _plugin_logputs("[PYTHON] File does not exist...");
        return false;
    }

    std::vector<wchar_t> szShortFileName;
    szShortFileName.resize(wcslen(szFileName) * 2);
    GetShortPathNameW(szFileName, szShortFileName.data(), DWORD(szShortFileName.size()));
    String szFileNameA = Utf16ToUtf8(szShortFileName.data());
    PyObject* PyFileObject = PyFile_FromString((char*)szFileNameA.c_str(), "r");
    if(PyFileObject == NULL)
    {
        _plugin_logputs("[PYTHON] Could not open file....");
        PyErr_PrintEx(0);
        return false;
    }

    bool local = false;

    PyObject* module, *dict;
    module = PyImport_AddModule("__main__");
    dict = PyModule_GetDict(module);
    if(local)
    {
        dict = PyDict_Copy(dict);
    }
    else
    {
        Py_INCREF(dict); // avoid to further distinguish between local and global dict
    }

    if(PyDict_GetItemString(dict, "__file__") == NULL)
    {
        PyObject* f = PyString_FromString(szFileNameA.c_str());
        if(f == NULL)
        {
            Py_DECREF(dict);
            return false;
        }
        if(PyDict_SetItemString(dict, "__file__", f) < 0)
        {
            Py_DECREF(f);
            Py_DECREF(dict);
            return false;
        }
        Py_DECREF(f);
    }

    wchar_t szCurrentDir[MAX_PATH] = L"";
    GetCurrentDirectoryW(_countof(szCurrentDir), szCurrentDir);

    if(argc > 0)
        PySys_SetArgv(argc, argv);
    auto result = PyRun_File(PyFile_AsFile(PyFileObject), szFileNameA.c_str(), Py_file_input, dict, dict);
    SetCurrentDirectoryW(szCurrentDir);
    Py_DECREF(dict);
    Py_DECREF(PyFileObject);

    if(result == NULL)
    {
        if(PyErr_ExceptionMatches(PYDATA(PyExc_SystemExit)))
            _plugin_logprintf("[PYTHON] SystemExit...\n");
        else
            _plugin_logprintf("[PYTHON] Exception...\n");
        PyErr_PrintEx(1);
        return false;
    }
    else
        Py_DECREF(result);

    _plugin_logputs("[PYTHON] Execution is done!");
    GuiUpdateAllViews();
    return true;
}

// Exports for other plugins
extern "C" __declspec(dllexport) bool ExecutePythonScriptExA(const char* szFileName, int argc, char* argv[])
{
    _plugin_logprintf("[PYTHON] Executing script: \"%s\"\n", szFileName);
    return ExecutePythonScript(Utf8ToUtf16(szFileName).c_str(), argc, argv);
}

extern "C" __declspec(dllexport) bool ExecutePythonScriptA(const char* szFileName)
{
    return ExecutePythonScriptExA(szFileName, 0, nullptr);
}

extern "C" __declspec(dllexport) bool ExecutePythonScriptExW(const wchar_t* szFileName, int argc, wchar_t* argv[])
{
    std::vector<char*> argvPtr(argc);
    std::vector<std::vector<char>> argvData(argc);
    for(int i = 0; i < argc; i++)
    {
        auto conv = Utf16ToUtf8(argv[i]);
        argvData[i] = std::vector<char>(conv.begin(), conv.end());
        argvData[i].push_back('\0');
        argvPtr[i] = argvData[i].data();
    }
    _plugin_logprintf("[PYTHON] Executing script: \"%s\"\n", Utf16ToUtf8(szFileName).c_str());
    return ExecutePythonScript(szFileName, argc, argvPtr.data());
}

extern "C" __declspec(dllexport) bool ExecutePythonScriptW(const wchar_t* szFileName)
{
    return ExecutePythonScriptExW(szFileName, 0, nullptr);
}

// Command callbacks
static std::wstring scriptName;
static std::vector<std::vector<char>> scriptArgvData;
static std::vector<char*> scriptArgvPtr;

static bool openScriptName(int argc, char* argv[])
{
    // Get script name
    if(argc < 2)
    {
        wchar_t szFileName[MAX_PATH] = L"";
        if(!OpenFileDialog(szFileName))
            return false;
        scriptName = szFileName;
    }
    else
        scriptName = Utf8ToUtf16(argv[1]);

    // Get (optional) script arguments
    scriptArgvData.clear();
    scriptArgvPtr.clear();
    if(argc > 2)
    {
        auto pyArgc = argc - 1;
        scriptArgvData.resize(pyArgc);
        scriptArgvPtr.resize(pyArgc);
        for(int i = 0; i < pyArgc; i++)
        {
            auto arg = argv[i + 1];
            scriptArgvData[i] = std::vector<char>(arg, arg + strlen(arg) + 1);
            scriptArgvPtr[i] = scriptArgvData[i].data();
        }
    }
    return true;
}

static bool cbPythonCommand(int argc, char* argv[])
{
    if(argc < 2)
    {
        _plugin_logputs("[PYTHON] Command Example: Python \"print('Hello World')\".");
        return false;
    }
    PyRun_SimpleString(argv[0] + 7);
    GuiFlushLog();
    GuiUpdateAllViews();
    return true;
}

static bool cbPipCommand(int argc, char* argv[])
{
    PyObject* pUtilsModule, *pFunc;
    PyObject* pKwargs, /* *pArgs, */ *pValue;

    if(argc < 2)
    {
        _plugin_logputs("[PYTHON] Command Example: Pip freeze");
        return false;
    }

    // Import utils
    pUtilsModule = PyObject_GetAttrString(pModule, "utils");
    if(pEventObject == NULL)
    {
        _plugin_logputs("[PYTHON] Could not find utils package.");
        PyErr_PrintEx(0);
        return false;
    }

    pFunc = PyObject_GetAttrString(pUtilsModule, "x64dbg_pip");
    if(pFunc && PyCallable_Check(pFunc))
    {
        pKwargs = Py_BuildValue("{s:s}", "args", argv[0]);
        pValue = PyObject_Call(pFunc, PyTuple_New(0), pKwargs);
        Py_DECREF(pKwargs);
        Py_DECREF(pFunc);
        if(pValue == NULL)
        {
            _plugin_logputs("[PYTHON] Could not use x64dbg_pip function.");
            PyErr_PrintEx(0);
            return false;
        }
        Py_DECREF(pValue);
    }
    return true;
}

static bool cbPyRunScriptCommand(int argc, char* argv[])
{
    if(!openScriptName(argc, argv))
        return false;
    _plugin_logprintf("[PYTHON] Executing script: \"%s\"\n", Utf16ToUtf8(scriptName).c_str());
    return ExecutePythonScript(scriptName.c_str(), int(scriptArgvPtr.size()), scriptArgvPtr.data());
}

static bool cbPyRunScriptAsyncCommand(int argc, char* argv[])
{
    if(!openScriptName(argc, argv))
        return false;
    CloseHandle(CreateThread(nullptr, 0, [](void*) -> DWORD
    {
        _plugin_logprintf("[PYTHON] Executing script: \"%s\"\n", Utf16ToUtf8(scriptName).c_str());
        ExecutePythonScript(scriptName.c_str(), int(scriptArgvPtr.size()), scriptArgvPtr.data());
        return 0;
    }, nullptr, 0, nullptr));
    return true;
}

static bool cbPyRunGuiScriptCommand(int argc, char* argv[])
{
    if(!openScriptName(argc, argv))
        return false;
    GuiExecuteOnGuiThread([]()
    {
        _plugin_logprintf("[PYTHON] Executing script: \"%s\"\n", Utf16ToUtf8(scriptName).c_str());
        ExecutePythonScript(scriptName.c_str(), int(scriptArgvPtr.size()), scriptArgvPtr.data());
    });
    return true;
}

static bool cbPythonCommandExecute(const char* cmd)
{
    if(cmd)
    {
        PyRun_SimpleString(cmd);
        GuiFlushLog();
        GuiUpdateAllViews();
        return true;
    }
    return false;
}

static void cbWinEventCallback(CBTYPE cbType, void* info)
{
    MSG* msg = ((PLUG_CB_WINEVENT*)info)->message;
    switch(msg->message)
    {
    case WM_SYSKEYDOWN:
        // Hotkeys
        switch(msg->lParam)
        {
        case ALT_F7_SYSKEYDOWN:
            DbgCmdExec("PyRunGuiScript");
            break;
        }
        break;
    }
}

static void cbInitDebugCallback(CBTYPE cbType, void* info)
{
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    wchar_t autorunDirectory[MAX_PATH], currentDirectory[MAX_PATH];

    // Get Autorun Folder Path
    GetModuleFileNameW(NULL, autorunDirectory, MAX_PATH);
    PathRemoveFileSpecW(autorunDirectory);
    PathAppendW(autorunDirectory, autorun_directory);

    // Get Current Directory
    GetCurrentDirectoryW(MAX_PATH, currentDirectory);

    // Find And Execute *.py Files
    SetCurrentDirectoryW(autorunDirectory);
    hFind = FindFirstFileW(L"*.py", &FindFileData);
    if(hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            _plugin_logprintf("[PYTHON] Executing autorun file: \"%s\".\n", Utf16ToUtf8(FindFileData.cFileName).c_str());
            ExecutePythonScript(FindFileData.cFileName, int(scriptArgvPtr.size()), scriptArgvPtr.data());
        }
        while(FindNextFileW(hFind, &FindFileData) != 0);
        FindClose(hFind);
    }

    // Reset Current Directory
    SetCurrentDirectoryW(currentDirectory);
}

static void cbUnloadDllCallback(CBTYPE cbType, void* info)
{
    LPUNLOAD_DLL_DEBUG_INFO UnloadDll = ((PLUG_CB_UNLOADDLL*)info)->UnloadDll;

    pyCallback("unload_dll", Py_BuildValue(
                   "{s:N}",
                   "lpBaseOfDll", PyInt_FromSize_t((size_t)UnloadDll->lpBaseOfDll)
               ));
}

static void cbLoadDllCallback(CBTYPE cbType, void* info)
{
    PyObject* pLoadDll, *pPdbSig70, *pModInfo;

    PLUG_CB_LOADDLL* callbackInfo = (PLUG_CB_LOADDLL*)info;
    LOAD_DLL_DEBUG_INFO* LoadDll = callbackInfo->LoadDll;
    IMAGEHLP_MODULE64* modInfo = callbackInfo->modInfo;
    GUID PdbSig70 = modInfo->PdbSig70;

    pLoadDll = Py_BuildValue(
                   "{s:N, s:N, s:k, s:k, s:N, s:H}",
                   "hFile", PyInt_FromSize_t((size_t)LoadDll->hFile),
                   "lpBaseOfDll", PyInt_FromSize_t((size_t)LoadDll->lpBaseOfDll),
                   "dwDebugInfoFileOffset", LoadDll->dwDebugInfoFileOffset,
                   "nDebugInfoSize", LoadDll->nDebugInfoSize,
                   "lpImageName", PyInt_FromSize_t((size_t)LoadDll->lpImageName),
                   "fUnicode", LoadDll->fUnicode
               );
    pPdbSig70 = Py_BuildValue(
                    "{s:k, s:H, s:H, s:N}",
                    "Data1", PdbSig70.Data1,
                    "Data2", PdbSig70.Data2,
                    "Data3", PdbSig70.Data3,
                    "Data4", PyByteArray_FromStringAndSize(
                        (char*)PdbSig70.Data4, ARRAYSIZE(PdbSig70.Data4)
                    )
                );
    pModInfo = Py_BuildValue(
                   "{s:k, s:K, s:k, s:k, s:k, s:k, s:i, s:s, s:s, s:s, s:s, "
                   " s:k, s:s, s:k, s:N, s:k, s:N, s:N, s:N, s:N, s:N, s:N, s:N}",
                   "SizeOfStruct", modInfo->SizeOfStruct,
                   "BaseOfImage", modInfo->BaseOfImage,
                   "ImageSize", modInfo->TimeDateStamp,
                   "TimeDateStamp", modInfo->TimeDateStamp,
                   "CheckSum", modInfo->CheckSum,
                   "NumSyms", modInfo->NumSyms,
                   "SymType", modInfo->SymType,
                   "ModuleName", modInfo->ModuleName,
                   "ImageName", modInfo->ImageName,
                   "LoadedImageName", modInfo->LoadedImageName,
                   "LoadedPdbName", modInfo->LoadedPdbName,
                   "CVSig", modInfo->CVSig,
                   "CVData", modInfo->CVData,
                   "PdbSig", modInfo->PdbSig,
                   "PdbSig70", pPdbSig70,
                   "PdbAge", modInfo->PdbAge,
                   "PdbUnmatched", PyBool_FromLong(modInfo->PdbUnmatched),
                   "DbgUnmatched", PyBool_FromLong(modInfo->DbgUnmatched),
                   "LineNumbers", PyBool_FromLong(modInfo->LineNumbers),
                   "GlobalSymbols", PyBool_FromLong(modInfo->GlobalSymbols),
                   "TypeInfo", PyBool_FromLong(modInfo->TypeInfo),
                   "SourceIndexed", PyBool_FromLong(modInfo->SourceIndexed),
                   "Publics", PyBool_FromLong(modInfo->Publics)
               );
    pyCallback("load_dll", Py_BuildValue(
                   "{s:N, s:N, s:s}",
                   "LoadDll", pLoadDll,
                   "modInfo", pModInfo,
                   "modname", callbackInfo->modname
               ));
    Py_DECREF(pLoadDll);
    Py_DECREF(pPdbSig70);
    Py_DECREF(pModInfo);
}

static void cbSystemBreakpointCallback(CBTYPE cbType, void* info)
{
    pyCallback("system_breakpoint", PyDict_New());
}

static void cbExitThreadCallback(CBTYPE cbType, void* info)
{
    PLUG_CB_EXITTHREAD* callbackInfo = ((PLUG_CB_EXITTHREAD*)info);

    pyCallback("exit_thread", Py_BuildValue(
                   "{s:k, s:k}",
                   "dwThreadId", callbackInfo->dwThreadId,
                   "dwExitCode", callbackInfo->ExitThread->dwExitCode
               ));
}

static void cbCreateThreadCallback(CBTYPE cbType, void* info)
{
    PyObject* pCreateThread;

    PLUG_CB_CREATETHREAD* callbackInfo = (PLUG_CB_CREATETHREAD*)info;
    CREATE_THREAD_DEBUG_INFO* CreateThread = callbackInfo->CreateThread;

    pCreateThread = Py_BuildValue(
                        "{s:k, s:N, s:N}",
                        "hThread", CreateThread->hThread,
                        "lpThreadLocalBase", PyInt_FromSize_t((size_t)CreateThread->lpThreadLocalBase),
                        "lpStartAddress", PyInt_FromSize_t((size_t)CreateThread->lpThreadLocalBase)
                    );
    pyCallback("create_thread", Py_BuildValue(
                   "{s:k, s:N}",
                   "dwThreadId", callbackInfo->dwThreadId,
                   "CreateThread", pCreateThread
               ));
    Py_DECREF(pCreateThread);

}

static void cbExitProcessCallback(CBTYPE cbType, void* info)
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess = ((PLUG_CB_EXITPROCESS*)info)->ExitProcess;

    pyCallback("exit_process", Py_BuildValue(
                   "{s:k}",
                   "dwExitCode", ExitProcess->dwExitCode
               ));
}

static void cbCreateProcessCallback(CBTYPE cbType, void* info)
{
    PyObject* pCreateProcessInfo, *pPdbSig70, *pModInfo, *pFdProcessInfo;

    PLUG_CB_CREATEPROCESS* callbackInfo = (PLUG_CB_CREATEPROCESS*)info;
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo = callbackInfo->CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo = callbackInfo->modInfo;
    PROCESS_INFORMATION* fdProcessInfo = callbackInfo->fdProcessInfo;
    GUID PdbSig70 = modInfo->PdbSig70;

    pCreateProcessInfo = Py_BuildValue(
                             "{s:N, s:N, s:N, s:N, s:k, s:k, s:N, s:N, s:N, s:H}",
                             "hFile", PyInt_FromSize_t((size_t)CreateProcessInfo->hFile),
                             "hProcess", PyInt_FromSize_t((size_t)CreateProcessInfo->hProcess),
                             "hThread", PyInt_FromSize_t((size_t)CreateProcessInfo->hThread),
                             "lpBaseOfImage", PyInt_FromSize_t((size_t)CreateProcessInfo->lpBaseOfImage),
                             "dwDebugInfoFileOffset", CreateProcessInfo->dwDebugInfoFileOffset,
                             "nDebugInfoSize", CreateProcessInfo->nDebugInfoSize,
                             "lpThreadLocalBase", PyInt_FromSize_t((size_t)CreateProcessInfo->lpThreadLocalBase),
                             "lpStartAddress", PyInt_FromSize_t((size_t)CreateProcessInfo->lpStartAddress),
                             "lpImageName", PyInt_FromSize_t((size_t)CreateProcessInfo->lpImageName),
                             "fUnicode", CreateProcessInfo->fUnicode
                         );
    pPdbSig70 = Py_BuildValue(
                    "{s:k, s:H, s:H, s:N}",
                    "Data1", PdbSig70.Data1,
                    "Data2", PdbSig70.Data2,
                    "Data3", PdbSig70.Data3,
                    "Data4", PyByteArray_FromStringAndSize(
                        (char*)PdbSig70.Data4, ARRAYSIZE(PdbSig70.Data4)
                    )
                );
    pModInfo = Py_BuildValue(
                   "{s:k, s:K, s:k, s:k, s:k, s:k, s:i, s:s, s:s, s:s, s:s, "
                   " s:k, s:s, s:k, s:N, s:k, s:N, s:N, s:N, s:N, s:N, s:N, s:N}",
                   "SizeOfStruct", modInfo->SizeOfStruct,
                   "BaseOfImage", modInfo->BaseOfImage,
                   "ImageSize", modInfo->TimeDateStamp,
                   "TimeDateStamp", modInfo->TimeDateStamp,
                   "CheckSum", modInfo->CheckSum,
                   "NumSyms", modInfo->NumSyms,
                   "SymType", modInfo->SymType,
                   "ModuleName", modInfo->ModuleName,
                   "ImageName", modInfo->ImageName,
                   "LoadedImageName", modInfo->LoadedImageName,
                   "LoadedPdbName", modInfo->LoadedPdbName,
                   "CVSig", modInfo->CVSig,
                   "CVData", modInfo->CVData,
                   "PdbSig", modInfo->PdbSig,
                   "PdbSig70", pPdbSig70,
                   "PdbAge", modInfo->PdbAge,
                   "PdbUnmatched", PyBool_FromLong(modInfo->PdbUnmatched),
                   "DbgUnmatched", PyBool_FromLong(modInfo->DbgUnmatched),
                   "LineNumbers", PyBool_FromLong(modInfo->LineNumbers),
                   "GlobalSymbols", PyBool_FromLong(modInfo->GlobalSymbols),
                   "TypeInfo", PyBool_FromLong(modInfo->TypeInfo),
                   "SourceIndexed", PyBool_FromLong(modInfo->SourceIndexed),
                   "Publics", PyBool_FromLong(modInfo->Publics)
               );
    pFdProcessInfo = Py_BuildValue(
                         "{s:N, s:N, s:k, s:k}",
                         "hProcess", PyInt_FromSize_t((size_t)fdProcessInfo->hProcess),
                         "hThread", PyInt_FromSize_t((size_t)fdProcessInfo->hThread),
                         "dwProcessId", fdProcessInfo->dwProcessId,
                         "dwThreadId", fdProcessInfo->dwThreadId
                     );
    pyCallback("create_process", Py_BuildValue(
                   "{s:N, s:N, s:s, s:N}",
                   "CreateProcessInfo", pCreateProcessInfo,
                   "modInfo", pModInfo,
                   "DebugFileName", callbackInfo->DebugFileName,
                   "fdProcessInfo", pFdProcessInfo
               ));
    Py_DECREF(pCreateProcessInfo);
    Py_DECREF(pPdbSig70);
    Py_DECREF(pModInfo);
    Py_DECREF(pFdProcessInfo);
}

static void cbBreakPointCallback(CBTYPE cbType, void* info)
{
    BRIDGEBP* breakpoint = ((PLUG_CB_BREAKPOINT*)info)->breakpoint;

    pyCallback("breakpoint", Py_BuildValue(
                   "{s:i, s:N, s:N, s:N, s:N, s:s, s:s, s:i}",
                   "type", breakpoint->type,
                   "addr", PyInt_FromSize_t(breakpoint->addr),
                   "enabled", PyBool_FromLong(breakpoint->enabled),
                   "singleshoot", PyBool_FromLong(breakpoint->singleshoot),
                   "active", PyBool_FromLong(breakpoint->active),
                   "mod", breakpoint->mod,
                   "name", breakpoint->name,
                   "slot", breakpoint->slot
               ));
}

static void cbStopDebugCallback(CBTYPE cbType, void* info)
{
    pyCallback("stop_debug", PyDict_New());
}

static void cbTraceExecuteCallback(CBTYPE cbType, void* info)
{
    PLUG_CB_TRACEEXECUTE* traceInfo = (PLUG_CB_TRACEEXECUTE*)info;

    PyObject* pTraceExecute;

    pTraceExecute = Py_BuildValue(
                        "{s:N, s:N}",
                        "cip", PyInt_FromSize_t(traceInfo->cip),
                        "stop", PyBool_FromLong(traceInfo->stop)
                    );

    // Packed in another dict because then it is passed by reference, so "stop" can be changed by the script.
    pyCallback("trace_execute", Py_BuildValue("{s:N}", "trace", pTraceExecute));

    traceInfo->stop = !!PyObject_IsTrue(PyDict_GetItemString(pTraceExecute, "stop"));

    Py_DECREF(pTraceExecute);
}

static std::wstring makeX64dbgPackageDir(const std::wstring & directory)
{
    auto dir = directory;
    if(dir[dir.length() - 1] != L'\\')
        dir.push_back(L'\\');
    dir.append(L"Lib\\site-packages");
    return dir;
}

static bool isValidPythonHome(const wchar_t* directory)
{
    if(!directory || !*directory)
        return false;
    auto attr = GetFileAttributesW(makeX64dbgPackageDir(directory).c_str());
    if(attr == INVALID_FILE_ATTRIBUTES)
        return false;
    return (attr & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;
}

static bool findX64dbgPythonHome(std::wstring & home)
{
    //Get from configuration
    char setting[MAX_SETTING_SIZE] = "";
    if(BridgeSettingGet("x64dbgpy", "PythonHome", setting))
    {
        home = Utf8ToUtf16(setting);
        if(isValidPythonHome(home.c_str()))
        {
            _plugin_logputs("[PYTHON] Found valid PythonHome in the plugin settings!");
            return true;
        }
        _plugin_logprintf("[PYTHON] Found invalid PythonHome setting \"%s\"...\n", setting);
    }
    //Get from the developer environment variable
#ifdef _WIN64
    auto python27x = _wgetenv(L"PYTHON27X64");
#else
    auto python27x = _wgetenv(L"PYTHON27X86");
#endif //_WIN64
    if(isValidPythonHome(python27x))
    {
#ifdef _WIN64
        _plugin_logputs("[PYTHON] Found valid PythonHome in the PYTHON27X64 environment variable!");
#else
        _plugin_logputs("[PYTHON] Found valid PythonHome in the PYTHON27X86 environment variable!");
#endif //_WIN64
        home = python27x;
        return true;
    }
    //Get from registry
    HKEY hKey;
    wchar_t szRegHome[MAX_SETTING_SIZE] = L"";
    if(RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Python\\PythonCore\\2.7\\InstallPath", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(szRegHome);
        RegQueryValueExW(hKey, nullptr, nullptr, nullptr, LPBYTE(szRegHome), &dwSize);
        RegCloseKey(hKey);
    }
    if(isValidPythonHome(szRegHome))
    {
        _plugin_logputs("[PYTHON] Found valid PythonHome in the registry!");
        home = szRegHome;
        return true;
    }
    //Get from PYTHONHOME environment variable
    auto pythonHome = _wgetenv(L"PYTHONHOME");
    if(isValidPythonHome(pythonHome))
    {
        _plugin_logputs("[PYTHON] Found valid PythonHome in the PYTHONHOME environment variable!");
        home = pythonHome;
        return true;
    }
    return false;
}

bool pyInit(PLUG_INITSTRUCT* initStruct)
{
    // Find and set the PythonHome
    std::wstring home;
    if(!findX64dbgPythonHome(home))
    {
        _plugin_logputs("[PYTHON] Failed to find PythonHome (do you have \\Lib\\site-packages?)...");
        BridgeSettingSet("x64dbgpy", "PythonHome", "Install Python!");
        return false;
    }
    if(!home.empty() && home.back() == L'\\')
        home.pop_back();
    auto pythonDll = home + L"\\python27.dll";
    if(!FileExists(pythonDll.c_str()))
    {
        wchar_t szSystemDir[MAX_PATH] = L"";
        GetSystemDirectoryW(szSystemDir, _countof(szSystemDir));
        pythonDll = szSystemDir;
        if(!pythonDll.empty() && pythonDll.back() == L'\\')
            pythonDll.pop_back();
        pythonDll += L"\\python27.dll";
    }
    hPython27 = LoadLibraryW(pythonDll.c_str());
    if(!hPython27)
    {
        _plugin_logprintf("[PYTHON] Failed to load Python DLL: %s\n", Utf16ToUtf8(pythonDll).c_str());
        BridgeSettingSet("x64dbgpy", "PythonHome", "Install Python!");
        return false;
    }
    else
    {
        _plugin_logprintf("[PYTHON] Python DLL: %s\n", Utf16ToUtf8(pythonDll).c_str());
    }
    BridgeSettingSet("x64dbgpy", "PythonHome", Utf16ToUtf8(home).c_str());
    static wchar_t dir[65536] = L"";
    GetShortPathNameW(home.c_str(), dir, _countof(dir));
    static char PythonHomeStatic[65536] = "";
    strncpy_s(PythonHomeStatic, Utf16ToUtf8(dir).c_str(), _TRUNCATE);
    _plugin_logprintf("[PYTHON] PythonHome: \"%s\"\n", Utf16ToUtf8(home).c_str());
    Py_SetPythonHome(PythonHomeStatic);

    // Register python command handler
    SCRIPTTYPEINFO info;
    strcpy_s(info.name, "Python");
    info.id = 0;
    info.execute = cbPythonCommandExecute;
    info.completeCommand = nullptr;
    GuiRegisterScriptLanguage(&info);

    // Register commands
    auto regCmd = [](const char* command, CBPLUGINCOMMAND cbCommand)
    {
        if(!_plugin_registercommand(pluginHandle, command, cbCommand, false))
            _plugin_logputs((std::string("[PYTHON] error registering the \"") + command + std::string("\" command!")).c_str());
    };

    regCmd("Python", cbPythonCommand);
    regCmd("Pip", cbPipCommand);
    regCmd("PyRunScript", cbPyRunScriptCommand);
    regCmd("PyRunScriptAsync", cbPyRunScriptAsyncCommand);
    regCmd("PyRunGuiScript", cbPyRunGuiScriptCommand);
    regCmd("PyDebug", [](int argc, char* argv[])
    {
        PYDATA(Py_DebugFlag) = 1;
        PYDATA(Py_VerboseFlag) = 1;
        return true;
    });

    // Initialize threads & python interpreter
    PyEval_InitThreads();
    PYDATA(Py_InspectFlag) = 1;
    Py_InitializeEx(0);

    // Add 'plugins' (current directory) to sys.path
    GetCurrentDirectoryW(_countof(dir), dir);
    if(dir[wcslen(dir) - 1] != L'\\')
        wcsncat_s(dir, L"\\", _TRUNCATE);
    wcsncat_s(dir, token_paste(L, module_name), _TRUNCATE);
    GetShortPathNameW(dir, dir, _countof(dir));
    _plugin_logputs(Utf16ToUtf8(dir).c_str());
    PyList_Insert(PySys_GetObject("path"), 0, PyString_FromString(Utf16ToUtf8(dir).c_str()));

    // Import x64dbgpy
    pModule = PyImport_Import(PyString_FromString(module_name));
    if(pModule != NULL)
    {
        // Get Event Object
        pEventObject = PyObject_GetAttrString(pModule, event_object_name);
        if(pEventObject == NULL)
        {
            _plugin_logputs("[PYTHON] Could not find Event object.");
            PyErr_PrintEx(0);
        }
    }
    else
    {
        _plugin_logputs("[PYTHON] Could not import " module_name ".");
        PyErr_PrintEx(0);
    }

    PyRun_SimpleString("from " module_name " import *\n");
    return true;
}

void pyStop()
{
    // Properly ends the python environment
    Py_Finalize();
}

void pySetup()
{
    // Set Menu Icon
    ICONDATA pyIcon;
    HRSRC hRes = FindResourceW(hInst, MAKEINTRESOURCEW(IDB_PNG1), L"PNG");
    DWORD size = SizeofResource(hInst, hRes);
    HGLOBAL hMem = LoadResource(hInst, hRes);

    pyIcon.data = LockResource(hMem);
    pyIcon.size = size;
    _plugin_menuseticon(hMenu, &pyIcon);

    FreeResource(hMem);
    _plugin_menuaddentry(hMenu, MENU_RUNGUISCRIPT, "&Open GUI Script...\tAlt+F7");
    _plugin_menuaddentry(hMenu, MENU_RUNSCRIPTASYNC, "Open Async Script...");
    _plugin_menuaddentry(hMenu, MENU_ABOUT, "&About");

    // Set Callbacks
    _plugin_registercallback(pluginHandle, CB_WINEVENT, cbWinEventCallback);
    _plugin_registercallback(pluginHandle, CB_INITDEBUG, cbInitDebugCallback);
    _plugin_registercallback(pluginHandle, CB_BREAKPOINT, cbBreakPointCallback);
    _plugin_registercallback(pluginHandle, CB_STOPDEBUG, cbStopDebugCallback);
    _plugin_registercallback(pluginHandle, CB_CREATEPROCESS, cbCreateProcessCallback);
    _plugin_registercallback(pluginHandle, CB_EXITPROCESS, cbExitProcessCallback);
    _plugin_registercallback(pluginHandle, CB_CREATETHREAD, cbCreateThreadCallback);
    _plugin_registercallback(pluginHandle, CB_EXITTHREAD, cbExitThreadCallback);
    _plugin_registercallback(pluginHandle, CB_SYSTEMBREAKPOINT, cbSystemBreakpointCallback);
    _plugin_registercallback(pluginHandle, CB_LOADDLL, cbLoadDllCallback);
    _plugin_registercallback(pluginHandle, CB_UNLOADDLL, cbUnloadDllCallback);
    _plugin_registercallback(pluginHandle, CB_TRACEEXECUTE, cbTraceExecuteCallback);
}


================================================
File: py.h
================================================
#ifndef _PY_H
#define _PY_H

#include "pluginmain.h"

extern HINSTANCE hInst;

//functions
bool pyInit(PLUG_INITSTRUCT* initStruct);
void pyStop();
void pySetup();

#endif // _PY_H



================================================
File: resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by x64dbgpy.rc
//
#define IDB_PNG1                        101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
File: setenv.bat
================================================
@echo off

set MSSDK=1
set DISTUTILS_USE_SDK=1
set VCVARS="%LOCALAPPDATA%\Programs\Common\Microsoft\Visual C++ for Python\9.0\vcvarsall.bat"
set PATH=%~dp0swig\swigwin-3.0.8;%PATH%

IF EXIST "%PROGRAMFILES(X86)%" (
    FOR /f "tokens=3" %%x IN ('reg query HKLM\SOFTWARE\Wow6432Node\Python\PythonCore\2.7\InstallPath /ve') DO (
        set PYTHON27X86=%%x
        setx PYTHON27X86 %%x
    )
    
    FOR /f "tokens=3" %%x IN ('reg query HKLM\SOFTWARE\Python\PythonCore\2.7\InstallPath /ve') DO (
        set PYTHON27X64=%%x
        setx PYTHON27X64 %%x
    )
) ELSE (
    FOR /f "tokens=3" %%x IN ('reg query HKLM\SOFTWARE\Python\PythonCore\2.7\InstallPath /ve') DO (
        set PYTHON27X86=%%x
        setx PYTHON27X86 %%x
    )
)

@echo on


================================================
File: stringutils.cpp
================================================
#include "stringutils.h"
#include <windows.h>
#include <iostream>
#include <sstream>

// Functions from x64dbg project: https://github.com/x64dbg/x64dbg
//Conversion functions taken from: http://www.nubaria.com/en/blog/?p=289
String Utf16ToUtf8(const WString & wstr)
{
    String convertedString;
    int requiredSize = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, 0, 0, 0, 0);
    if(requiredSize > 0)
    {
        std::vector<char> buffer(requiredSize);
        WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &buffer[0], requiredSize, 0, 0);
        convertedString.assign(buffer.begin(), buffer.end() - 1);
    }
    return convertedString;
}

String Utf16ToUtf8(const wchar_t* wstr)
{
    return Utf16ToUtf8(wstr ? WString(wstr) : WString());
}

WString Utf8ToUtf16(const String & str)
{
    WString convertedString;
    int requiredSize = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, 0, 0);
    if(requiredSize > 0)
    {
        std::vector<wchar_t> buffer(requiredSize);
        MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &buffer[0], requiredSize);
        convertedString.assign(buffer.begin(), buffer.end() - 1);
    }
    return convertedString;
}

WString Utf8ToUtf16(const char* str)
{
    return Utf8ToUtf16(str ? String(str) : String());
}


================================================
File: stringutils.h
================================================
#ifndef _STRINGUTILS_H
#define _STRINGUTILS_H

#include <string>
#include <vector>

typedef std::string String;
typedef std::wstring WString;


String Utf16ToUtf8(const WString & wstr);
String Utf16ToUtf8(const wchar_t* wstr);
WString Utf8ToUtf16(const String & str);
WString Utf8ToUtf16(const char* str);

#endif //_STRINGUTILS_H


================================================
File: x64dbgpy.h
================================================
#pragma once

/**
\brief Executes a python script.
\param szFileName Path to the file (UTF-8).
\return true if it succeeds, false if it fails.
*/
extern "C" __declspec(dllimport) bool ExecutePythonScriptA(const char* szFileName);

/**
\brief Executes a python script.
\param szFileName Path to the file (UTF-8).
\param argc Number of arguments to pass to the python script.
\param argv Array of arguments to pass to the python script (UTF-8).
\return true if it succeeds, false if it fails.
*/
extern "C" __declspec(dllimport) bool ExecutePythonScriptExA(const char* szFileName, int argc, char* argv[]);

/**
\brief Executes a python script.
\param szFileName Path to the file (UTF-16).
\return true if it succeeds, false if it fails.
*/
extern "C" __declspec(dllimport) bool ExecutePythonScriptW(const wchar_t* szFileName);

/**
\brief Executes a python script.
\param szFileName Path to the file (UTF-16).
\param argc Number of arguments to pass to the python script.
\param argv Array of arguments to pass to the python script (UTF-16).
\return true if it succeeds, false if it fails.
*/
extern "C" __declspec(dllimport) bool ExecutePythonScriptExW(const wchar_t* szFileName, int argc, wchar_t* argv[]);



================================================
File: x64dbgpy.rc
================================================
[Non-text file]


================================================
File: x64dbgpy.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "x64dbgpy", "x64dbgpy.vcxproj", "{E7BA66E1-677E-D937-AC50-73AB6ADA89E0}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "scriptapi", "scriptapi\scriptapi.vcxproj", "{6E9A40BD-80E1-4C24-92BD-A402D9BE1419}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E7BA66E1-677E-D937-AC50-73AB6ADA89E0}.Release|Win32.ActiveCfg = Release|Win32
		{E7BA66E1-677E-D937-AC50-73AB6ADA89E0}.Release|Win32.Build.0 = Release|Win32
		{E7BA66E1-677E-D937-AC50-73AB6ADA89E0}.Release|x64.ActiveCfg = Release|x64
		{E7BA66E1-677E-D937-AC50-73AB6ADA89E0}.Release|x64.Build.0 = Release|x64
		{6E9A40BD-80E1-4C24-92BD-A402D9BE1419}.Release|Win32.ActiveCfg = Release|Win32
		{6E9A40BD-80E1-4C24-92BD-A402D9BE1419}.Release|Win32.Build.0 = Release|Win32
		{6E9A40BD-80E1-4C24-92BD-A402D9BE1419}.Release|x64.ActiveCfg = Release|x64
		{6E9A40BD-80E1-4C24-92BD-A402D9BE1419}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: x64dbgpy.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pluginmain.cpp" />
    <ClCompile Include="py.cpp" />
    <ClCompile Include="stringutils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pluginmain.h" />
    <ClInclude Include="pluginsdk\bridgemain.h" />
    <ClInclude Include="pluginsdk\capstone\arm.h" />
    <ClInclude Include="pluginsdk\capstone\arm64.h" />
    <ClInclude Include="pluginsdk\capstone\capstone.h" />
    <ClInclude Include="pluginsdk\capstone\mips.h" />
    <ClInclude Include="pluginsdk\capstone\platform.h" />
    <ClInclude Include="pluginsdk\capstone\ppc.h" />
    <ClInclude Include="pluginsdk\capstone\sparc.h" />
    <ClInclude Include="pluginsdk\capstone\systemz.h" />
    <ClInclude Include="pluginsdk\capstone\x86.h" />
    <ClInclude Include="pluginsdk\capstone\xcore.h" />
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h" />
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h" />
    <ClInclude Include="pluginsdk\jansson\jansson.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_config.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h" />
    <ClInclude Include="pluginsdk\lz4\lz4.h" />
    <ClInclude Include="pluginsdk\lz4\lz4file.h" />
    <ClInclude Include="pluginsdk\lz4\lz4hc.h" />
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h" />
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h" />
    <ClInclude Include="pluginsdk\yara\yara.h" />
    <ClInclude Include="pluginsdk\yara\yara\ahocorasick.h" />
    <ClInclude Include="pluginsdk\yara\yara\arena.h" />
    <ClInclude Include="pluginsdk\yara\yara\atoms.h" />
    <ClInclude Include="pluginsdk\yara\yara\compiler.h" />
    <ClInclude Include="pluginsdk\yara\yara\elf.h" />
    <ClInclude Include="pluginsdk\yara\yara\error.h" />
    <ClInclude Include="pluginsdk\yara\yara\exec.h" />
    <ClInclude Include="pluginsdk\yara\yara\exefiles.h" />
    <ClInclude Include="pluginsdk\yara\yara\filemap.h" />
    <ClInclude Include="pluginsdk\yara\yara\globals.h" />
    <ClInclude Include="pluginsdk\yara\yara\hash.h" />
    <ClInclude Include="pluginsdk\yara\yara\hex_lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\libyara.h" />
    <ClInclude Include="pluginsdk\yara\yara\limits.h" />
    <ClInclude Include="pluginsdk\yara\yara\mem.h" />
    <ClInclude Include="pluginsdk\yara\yara\modules.h" />
    <ClInclude Include="pluginsdk\yara\yara\object.h" />
    <ClInclude Include="pluginsdk\yara\yara\parser.h" />
    <ClInclude Include="pluginsdk\yara\yara\pe.h" />
    <ClInclude Include="pluginsdk\yara\yara\proc.h" />
    <ClInclude Include="pluginsdk\yara\yara\re.h" />
    <ClInclude Include="pluginsdk\yara\yara\re_lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\rules.h" />
    <ClInclude Include="pluginsdk\yara\yara\scan.h" />
    <ClInclude Include="pluginsdk\yara\yara\sizedstr.h" />
    <ClInclude Include="pluginsdk\yara\yara\strutils.h" />
    <ClInclude Include="pluginsdk\yara\yara\types.h" />
    <ClInclude Include="pluginsdk\yara\yara\utils.h" />
    <ClInclude Include="pluginsdk\_dbgfunctions.h" />
    <ClInclude Include="pluginsdk\_plugins.h" />
    <ClInclude Include="pluginsdk\_plugin_types.h" />
    <ClInclude Include="pluginsdk\_scriptapi.h" />
    <ClInclude Include="pluginsdk\_scriptapi_debug.h" />
    <ClInclude Include="pluginsdk\_scriptapi_gui.h" />
    <ClInclude Include="pluginsdk\_scriptapi_memory.h" />
    <ClInclude Include="pluginsdk\_scriptapi_module.h" />
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h" />
    <ClInclude Include="pluginsdk\_scriptapi_register.h" />
    <ClInclude Include="py.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stringutils.h" />
    <ClInclude Include="x64dbgpy.h" />
  </ItemGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="x64dbgpy.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\python.png" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectName>x64dbgpy</ProjectName>
    <ProjectGuid>{E7BA66E1-677E-D937-AC50-73AB6ADA89E0}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\x32\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <TargetName>x64dbgpy</TargetName>
    <TargetExt>.dp32</TargetExt>
    <IncludePath>$(Python27x86)\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(Python27x86)\libs;$(LibraryPath)</LibraryPath>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
    <TargetName>x64dbgpy</TargetName>
    <TargetExt>.dp64</TargetExt>
    <IncludePath>$(Python27x64)\include;$(IncludePath)</IncludePath>
    <LibraryPath>$(Python27x64)\libs;$(LibraryPath)</LibraryPath>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;X64_DBG_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>psapi.lib;pluginsdk\x32dbg.lib;pluginsdk\x32bridge.lib;pluginsdk\TitanEngine\TitanEngine_x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>python27.dll</DelayLoadDLLs>
    </Link>
    <PostBuildEvent>
      <Command>install32.bat</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Install x64dbgpy plugin 32bit version</Message>
    </PostBuildEvent>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>
      </Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;X64_DBG_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>psapi.lib;pluginsdk\x64dbg.lib;pluginsdk\x64bridge.lib;pluginsdk\TitanEngine\TitanEngine_x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <DelayLoadDLLs>python27.dll</DelayLoadDLLs>
    </Link>
    <PostBuildEvent>
      <Command>install64.bat</Command>
      <Message>Install x64dbgpy plugin 64bit version</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: x64dbgpy.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
    <Filter Include="Header Files\pluginsdk">
      <UniqueIdentifier>{a05d1021-30b7-4f10-9710-95993efcdc5a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\yara">
      <UniqueIdentifier>{88a328b6-0e41-465d-bdad-19682e94b0de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\yara\yara">
      <UniqueIdentifier>{9b13e4ef-e649-4f03-86b4-fa431ad3eb15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\XEDParse">
      <UniqueIdentifier>{5095b3d4-5f69-4d25-8b74-148726692bc6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\TitanEngine">
      <UniqueIdentifier>{94db5cc1-7568-4716-a294-8d901a8d5109}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\lz4">
      <UniqueIdentifier>{5b7876d5-1d9e-4d5b-a647-dde728941cbe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\jansson">
      <UniqueIdentifier>{1d92d67f-08e5-4062-b57c-1bd99a4e7792}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\DeviceNameResolver">
      <UniqueIdentifier>{817ba704-bc45-4d43-8c89-39bc7644c884}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\dbghelp">
      <UniqueIdentifier>{4cc5423a-c958-48ef-a77b-32fdcf3af653}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\capstone">
      <UniqueIdentifier>{eb803e58-8de8-471c-a27a-cdfbe1eae5f9}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pluginmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="py.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stringutils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pluginmain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="py.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_memory.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_gui.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_debug.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugins.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugin_types.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_dbgfunctions.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgemain.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_register.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_module.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara.h">
      <Filter>Header Files\pluginsdk\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\hash.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\hex_lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\libyara.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\limits.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\mem.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\modules.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\object.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\parser.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\pe.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\proc.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\re.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\re_lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\rules.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\scan.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\sizedstr.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\strutils.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\types.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\utils.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\ahocorasick.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\arena.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\atoms.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\compiler.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\elf.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\error.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\exec.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\exefiles.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\filemap.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\globals.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h">
      <Filter>Header Files\pluginsdk\XEDParse</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h">
      <Filter>Header Files\pluginsdk\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4hc.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4file.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_config.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h">
      <Filter>Header Files\pluginsdk\DeviceNameResolver</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h">
      <Filter>Header Files\pluginsdk\dbghelp</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\mips.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\capstone.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\arm64.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\arm.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\xcore.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\x86.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\systemz.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\sparc.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\ppc.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\platform.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="stringutils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbgpy.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="x64dbgpy.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\python.png">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: .editorconfig
================================================
; Top-most EditorConfig file
root = true

; Windows-style newlines
[*]
end_of_line = CRLF

; Tab indentation
[*.{cpp,h}]
indent_style = space
tab_width = 4


================================================
File: hooks/pre-commit
================================================
#!/bin/sh
#
# Simple script to auto-format every source file before committing.
#

#check if the formatter is present
if [ ! -f ./AStyleHelper.exe ]; then
    echo "AStyleHelper not found!"
    exit 0
fi

#format the code
"./AStyleHelper.exe" Silent

#exit when nothing needs to be done
if [ $? == 0 ]; then
    exit 0
fi

#stage the formatted files (when staged in this commit)
gitFiles=$(git diff-index --name-only --cached HEAD)
if [[ -n "${gitFiles}" ]]; then
    for fname in $gitFiles; do
        git add --all -- "${fname}"
    done
fi

#cancel commit if the changes were undone by the formatting
gitFiles=$(git diff-index --name-only --cached HEAD)
if [ -z "$gitFiles" ]; then
    "./AStyleHelper.exe" "After formatting, no files were staged..."
    exit 1
fi



================================================
File: pluginsdk/_dbgfunctions.h
================================================
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeMainWindowTitle[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef struct
{
    DWORD rva;
    BYTE type;
    WORD size;
} DBGRELOCATIONINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef struct
{
    duint handle;
    duint parent;
    DWORD threadId;
    DWORD style;
    DWORD styleEx;
    duint wndProc;
    bool enabled;
    RECT position;
    char windowTitle[MAX_COMMENT_SIZE];
    char windowClass[MAX_COMMENT_SIZE];
} WINDOW_INFO;

typedef struct
{
    duint addr;
    duint size;
    duint flags;
} HEAPINFO;

typedef struct
{
    const char* name;
    duint value;
} CONSTANTINFO;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*GETSEHCHAIN)(DBGSEHCHAIN* sehchain);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line, duint* displacement);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool (*PATCHGETEX)(duint addr, DBGPATCHINFO* info);
typedef bool (*GETBRIDGEBP)(BPXTYPE type, duint addr, BRIDGEBP* bp);
typedef bool (*STRINGFORMATINLINE)(const char* format, size_t resultSize, char* result);
typedef void (*GETMNEMONICBRIEF)(const char* mnem, size_t resultSize, char* result);
typedef unsigned int (*GETTRACERECORDHITCOUNT)(duint address);
typedef TRACERECORDBYTETYPE(*GETTRACERECORDBYTETYPE)(duint address);
typedef bool (*SETTRACERECORDTYPE)(duint pageAddress, TRACERECORDTYPE type);
typedef TRACERECORDTYPE(*GETTRACERECORDTYPE)(duint pageAddress);
typedef bool (*ENUMHANDLES)(ListOf(HANDLEINFO) handles);
typedef bool (*GETHANDLENAME)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
typedef bool (*ENUMTCPCONNECTIONS)(ListOf(TCPCONNECTIONINFO) connections);
typedef duint(*GETDBGEVENTS)();
typedef int (*MODGETPARTY)(duint base);
typedef void (*MODSETPARTY)(duint base, int party);
typedef bool(*WATCHISWATCHDOGTRIGGERED)(unsigned int id);
typedef bool(*MEMISCODEPAGE)(duint addr, bool refresh);
typedef bool(*ANIMATECOMMAND)(const char* command);
typedef void(*DBGSETDEBUGGEEINITSCRIPT)(const char* fileName);
typedef const char* (*DBGGETDEBUGGEEINITSCRIPT)();
typedef bool(*HANDLESENUMWINDOWS)(ListOf(WINDOW_INFO) windows);
typedef bool(*HANDLESENUMHEAPS)(ListOf(HEAPINFO) heaps);
typedef bool(*THREADGETNAME)(DWORD tid, char* name);
typedef bool(*ISDEPENABLED)();
typedef void(*GETCALLSTACKEX)(DBGCALLSTACK* callstack, bool cache);
typedef bool(*GETUSERCOMMENT)(duint addr, char* comment);
typedef void(*ENUMCONSTANTS)(ListOf(CONSTANTINFO) constants);
typedef duint(*MEMBPSIZE)(duint addr);
typedef bool(*MODRELOCATIONSFROMADDR)(duint addr, ListOf(DBGRELOCATIONINFO) relocations);
typedef bool(*MODRELOCATIONATADDR)(duint addr, DBGRELOCATIONINFO* relocation);
typedef bool(*MODRELOCATIONSINRANGE)(duint addr, duint size, ListOf(DBGRELOCATIONINFO) relocations);

//The list of all the DbgFunctions() return value.
//WARNING: This list is append only. Do not insert things in the middle or plugins would break.
typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    GETSEHCHAIN GetSEHChain;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
    GETBRIDGEBP GetBridgeBp;
    STRINGFORMATINLINE StringFormatInline;
    GETMNEMONICBRIEF GetMnemonicBrief;
    GETTRACERECORDHITCOUNT GetTraceRecordHitCount;
    GETTRACERECORDBYTETYPE GetTraceRecordByteType;
    SETTRACERECORDTYPE SetTraceRecordType;
    GETTRACERECORDTYPE GetTraceRecordType;
    ENUMHANDLES EnumHandles;
    GETHANDLENAME GetHandleName;
    ENUMTCPCONNECTIONS EnumTcpConnections;
    GETDBGEVENTS GetDbgEvents;
    MODGETPARTY ModGetParty;
    MODSETPARTY ModSetParty;
    WATCHISWATCHDOGTRIGGERED WatchIsWatchdogTriggered;
    MEMISCODEPAGE MemIsCodePage;
    ANIMATECOMMAND AnimateCommand;
    DBGSETDEBUGGEEINITSCRIPT DbgSetDebuggeeInitScript;
    DBGGETDEBUGGEEINITSCRIPT DbgGetDebuggeeInitScript;
    HANDLESENUMWINDOWS EnumWindows;
    HANDLESENUMHEAPS EnumHeaps;
    THREADGETNAME ThreadGetName;
    ISDEPENABLED IsDepEnabled;
    GETCALLSTACKEX GetCallStackEx;
    GETUSERCOMMENT GetUserComment;
    ENUMCONSTANTS EnumConstants;
    ENUMCONSTANTS EnumErrorCodes;
    ENUMCONSTANTS EnumExceptions;
    MEMBPSIZE MemBpSize;
    MODRELOCATIONSFROMADDR ModRelocationsFromAddr;
    MODRELOCATIONATADDR ModRelocationAtAddr;
    MODRELOCATIONSINRANGE ModRelocationsInRange;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H



================================================
File: pluginsdk/_plugin_types.h
================================================
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"
#include "jansson/jansson.h"
#include <dbghelp.h>

#else

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#include <dbghelp.h>
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H



================================================
File: pluginsdk/_plugins.h
================================================
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

typedef struct
{
    const char* symbol;
    bool retval;
} PLUG_CB_FILTERSYMBOL;

typedef struct
{
    duint cip;
    bool stop;
} PLUG_CB_TRACEEXECUTE;

typedef struct
{
    int hWindow;
    duint VA;
} PLUG_CB_SELCHANGED;

typedef struct
{
    BridgeCFGraphList graph;
} PLUG_CB_ANALYZE;

typedef struct
{
    duint addr;
    BRIDGE_ADDRINFO* addrinfo;
    bool retval;
} PLUG_CB_ADDRINFO;

typedef struct
{
    const char* string;
    duint value;
    int* value_size;
    bool* isvar;
    bool* hexonly;
    bool retval;
} PLUG_CB_VALFROMSTRING;

typedef struct
{
    const char* string;
    duint value;
    bool retval;
} PLUG_CB_VALTOSTRING;

typedef struct
{
    int hMenu;
} PLUG_CB_MENUPREPARE;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB, //PLUG_CB_LOADSAVEDB
    CB_FILTERSYMBOL, //PLUG_CB_FILTERSYMBOL
    CB_TRACEEXECUTE, //PLUG_CB_TRACEEXECUTE
    CB_SELCHANGED, //PLUG_CB_SELCHANGED
    CB_ANALYZE, //PLUG_CB_ANALYZE
    CB_ADDRINFO, //PLUG_CB_ADDRINFO
    CB_VALFROMSTRING, //PLUG_CB_VALFROMSTRING
    CB_VALTOSTRING, //PLUG_CB_VALTOSTRING
    CB_MENUPREPARE, //PLUG_CB_MENUPREPARE
    CB_LAST
} CBTYPE;

typedef enum
{
    FORMAT_ERROR, //generic failure (no message)
    FORMAT_SUCCESS, //success
    FORMAT_ERROR_MESSAGE, //formatting failed but an error was put in the buffer (there are always at least 511 characters available).
    FORMAT_BUFFER_TOO_SMALL //buffer too small (x64dbg will retry until the buffer is big enough)
} FORMATRESULT;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, duint* argv, void* userdata);
typedef FORMATRESULT(*CBPLUGINFORMATFUNCTION)(char* dest, size_t destCount, int argc, char* argv[], duint value, void* userdata);
typedef bool (*CBPLUGINPREDICATE)(void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_logprint(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentrysetchecked(int pluginHandle, int hEntry, bool checked);
PLUG_IMPEXP void _plugin_menusetvisible(int pluginHandle, int hMenu, bool visible);
PLUG_IMPEXP void _plugin_menuentrysetvisible(int pluginHandle, int hEntry, bool visible);
PLUG_IMPEXP void _plugin_menusetname(int pluginHandle, int hMenu, const char* name);
PLUG_IMPEXP void _plugin_menuentrysetname(int pluginHandle, int hEntry, const char* name);
PLUG_IMPEXP void _plugin_menuentrysethotkey(int pluginHandle, int hEntry, const char* hotkey);
PLUG_IMPEXP bool _plugin_menuremove(int hMenu);
PLUG_IMPEXP bool _plugin_menuentryremove(int pluginHandle, int hEntry);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);
PLUG_IMPEXP duint _plugin_hash(const void* data, duint size);
PLUG_IMPEXP bool _plugin_registerformatfunction(int pluginHandle, const char* type, CBPLUGINFORMATFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterformatfunction(int pluginHandle, const char* type);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H



================================================
File: pluginsdk/_scriptapi.h
================================================
#ifndef _SCRIPT_API_H
#define _SCRIPT_API_H

#include "_plugins.h"

#define SCRIPT_EXPORT PLUG_IMPEXP

#endif //_SCRIPT_API_H


================================================
File: pluginsdk/_scriptapi_argument.h
================================================
#ifndef _SCRIPTAPI_ARGUMENT_H
#define _SCRIPTAPI_ARGUMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Argument
    {
        struct ArgumentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const ArgumentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, ArgumentInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(ArgumentInfo) list); //caller has the responsibility to free the list
    }; //Argument
}; //Script

#endif //_SCRIPTAPI_ARGUMENT_H


================================================
File: pluginsdk/_scriptapi_assembler.h
================================================
#ifndef _SCRIPTAPI_ASSEMBLER_H
#define _SCRIPTAPI_ASSEMBLER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Assembler
    {
        SCRIPT_EXPORT bool Assemble(duint addr, unsigned char* dest, int* size, const char* instruction); //dest[16]
        SCRIPT_EXPORT bool AssembleEx(duint addr, unsigned char* dest, int* size, const char* instruction, char* error); //dest[16], error[MAX_ERROR_SIZE]
        SCRIPT_EXPORT bool AssembleMem(duint addr, const char* instruction);
        SCRIPT_EXPORT bool AssembleMemEx(duint addr, const char* instruction, int* size, char* error, bool fillnop); //error[MAX_ERROR_SIZE]
    }; //Assembler
}; //Script

#endif //_SCRIPTAPI_ASSEMBLER_H


================================================
File: pluginsdk/_scriptapi_bookmark.h
================================================
#ifndef _SCRIPTAPI_BOOKMARK_H
#define _SCRIPTAPI_BOOKMARK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Bookmark
    {
        struct BookmarkInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, bool manual = false);
        SCRIPT_EXPORT bool Set(const BookmarkInfo* info);
        SCRIPT_EXPORT bool Get(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, BookmarkInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(BookmarkInfo) list); //caller has the responsibility to free the list
    }; //Bookmark
}; //Script

#endif //_SCRIPTAPI_BOOKMARK_H


================================================
File: pluginsdk/_scriptapi_comment.h
================================================
#ifndef _SCRIPTAPI_COMMENT_H
#define _SCRIPTAPI_COMMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Comment
    {
        struct CommentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const CommentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_COMMENT_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, CommentInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(CommentInfo) list); //caller has the responsibility to free the list
    }; //Comment
}; //Script

#endif //_SCRIPTAPI_COMMENT_H


================================================
File: pluginsdk/_scriptapi_debug.h
================================================
#ifndef _SCRIPTAPI_DEBUG_H
#define _SCRIPTAPI_DEBUG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Debug
    {
        enum HardwareType
        {
            HardwareAccess,
            HardwareWrite,
            HardwareExecute
        };

        SCRIPT_EXPORT void Wait();
        SCRIPT_EXPORT void Run();
        SCRIPT_EXPORT void Pause();
        SCRIPT_EXPORT void Stop();
        SCRIPT_EXPORT void StepIn();
        SCRIPT_EXPORT void StepOver();
        SCRIPT_EXPORT void StepOut();
        SCRIPT_EXPORT bool SetBreakpoint(duint address);
        SCRIPT_EXPORT bool DeleteBreakpoint(duint address);
        SCRIPT_EXPORT bool DisableBreakpoint(duint address);
        SCRIPT_EXPORT bool SetHardwareBreakpoint(duint address, HardwareType type = HardwareExecute);
        SCRIPT_EXPORT bool DeleteHardwareBreakpoint(duint address);
    }; //Debug
}; //Script

#endif //_SCRIPTAPI_DEBUG_H


================================================
File: pluginsdk/_scriptapi_flag.h
================================================
#ifndef _SCRIPTAPI_FLAG_H
#define _SCRIPTAPI_FLAG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Flag
    {
        enum FlagEnum
        {
            ZF,
            OF,
            CF,
            PF,
            SF,
            TF,
            AF,
            DF,
            IF
        };

        SCRIPT_EXPORT bool Get(FlagEnum flag);
        SCRIPT_EXPORT bool Set(FlagEnum flag, bool value);

        SCRIPT_EXPORT bool GetZF();
        SCRIPT_EXPORT bool SetZF(bool value);
        SCRIPT_EXPORT bool GetOF();
        SCRIPT_EXPORT bool SetOF(bool value);
        SCRIPT_EXPORT bool GetCF();
        SCRIPT_EXPORT bool SetCF(bool value);
        SCRIPT_EXPORT bool GetPF();
        SCRIPT_EXPORT bool SetPF(bool value);
        SCRIPT_EXPORT bool GetSF();
        SCRIPT_EXPORT bool SetSF(bool value);
        SCRIPT_EXPORT bool GetTF();
        SCRIPT_EXPORT bool SetTF(bool value);
        SCRIPT_EXPORT bool GetAF();
        SCRIPT_EXPORT bool SetAF(bool value);
        SCRIPT_EXPORT bool GetDF();
        SCRIPT_EXPORT bool SetDF(bool value);
        SCRIPT_EXPORT bool GetIF();
        SCRIPT_EXPORT bool SetIF(bool value);
    };
};

#endif //_SCRIPTAPI_FLAG_H


================================================
File: pluginsdk/_scriptapi_function.h
================================================
#ifndef _SCRIPTAPI_FUNCTION_H
#define _SCRIPTAPI_FUNCTION_H

#include "_scriptapi.h"

namespace Script
{
    namespace Function
    {
        struct FunctionInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const FunctionInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, FunctionInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(FunctionInfo) list); //caller has the responsibility to free the list
    }; //Function
}; //Script

#endif //_SCRIPTAPI_FUNCTION_H



================================================
File: pluginsdk/_scriptapi_gui.h
================================================
#ifndef _SCRIPTAPI_GUI_H
#define _SCRIPTAPI_GUI_H

#include "_scriptapi.h"

namespace Script
{
    namespace Gui
    {
        namespace Disassembly
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Disassembly

        namespace Dump
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Dump

        namespace Stack
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Stack

        namespace Graph
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //Graph

        namespace MemMap
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //MemoryMap

        namespace SymMod
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //SymMod
    }; //Gui

    namespace Gui
    {
        enum Window
        {
            DisassemblyWindow,
            DumpWindow,
            StackWindow,
            GraphWindow,
            MemMapWindow,
            SymModWindow
        };

        SCRIPT_EXPORT bool SelectionGet(Window window, duint* start, duint* end);
        SCRIPT_EXPORT bool SelectionSet(Window window, duint start, duint end);
        SCRIPT_EXPORT duint SelectionGetStart(Window window);
        SCRIPT_EXPORT duint SelectionGetEnd(Window window);
        SCRIPT_EXPORT void Message(const char* message);
        SCRIPT_EXPORT bool MessageYesNo(const char* message);
        SCRIPT_EXPORT bool InputLine(const char* title, char* text); //text[GUI_MAX_LINE_SIZE]
        SCRIPT_EXPORT bool InputValue(const char* title, duint* value);
        SCRIPT_EXPORT void Refresh();
        SCRIPT_EXPORT void AddQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void ShowQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void CloseQWidgetTab(void* qWidget);

    }; //Gui
}; //Script

#endif //_SCRIPTAPI_GUI_H


================================================
File: pluginsdk/_scriptapi_label.h
================================================
#ifndef _SCRIPTAPI_LABEL_H
#define _SCRIPTAPI_LABEL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Label
    {
        struct LabelInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const LabelInfo* info);
        SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
    }; //Label
}; //Script

#endif //_SCRIPTAPI_LABEL_H


================================================
File: pluginsdk/_scriptapi_memory.h
================================================
#ifndef _SCRIPTAPI_MEMORY_H
#define _SCRIPTAPI_MEMORY_H

#include "_scriptapi.h"

namespace Script
{
    namespace Memory
    {
        SCRIPT_EXPORT bool Read(duint addr, void* data, duint size, duint* sizeRead);
        SCRIPT_EXPORT bool Write(duint addr, const void* data, duint size, duint* sizeWritten);
        SCRIPT_EXPORT bool IsValidPtr(duint addr);
        SCRIPT_EXPORT duint RemoteAlloc(duint addr, duint size);
        SCRIPT_EXPORT bool RemoteFree(duint addr);
        SCRIPT_EXPORT unsigned int GetProtect(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetBase(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetSize(duint addr, bool reserved = false, bool cache = true);

        SCRIPT_EXPORT unsigned char ReadByte(duint addr);
        SCRIPT_EXPORT bool WriteByte(duint addr, unsigned char data);
        SCRIPT_EXPORT unsigned short ReadWord(duint addr);
        SCRIPT_EXPORT bool WriteWord(duint addr, unsigned short data);
        SCRIPT_EXPORT unsigned int ReadDword(duint addr);
        SCRIPT_EXPORT bool WriteDword(duint addr, unsigned int data);
        SCRIPT_EXPORT unsigned long long ReadQword(duint addr);
        SCRIPT_EXPORT bool WriteQword(duint addr, unsigned long long data);
        SCRIPT_EXPORT duint ReadPtr(duint addr);
        SCRIPT_EXPORT bool WritePtr(duint addr, duint data);
    }; //Memory
}; //Script

#endif //_SCRIPTAPI_MEMORY_H


================================================
File: pluginsdk/_scriptapi_misc.h
================================================
#ifndef _SCRIPTAPI_MISC_H
#define _SCRIPTAPI_MISC_H

#include "_scriptapi.h"

namespace Script
{
    namespace Misc
    {
        SCRIPT_EXPORT bool ParseExpression(const char* expression, duint* value);
        SCRIPT_EXPORT duint RemoteGetProcAddress(const char* module, const char* api);
        SCRIPT_EXPORT duint ResolveLabel(const char* label);
        SCRIPT_EXPORT void* Alloc(duint size);
        SCRIPT_EXPORT void Free(void* ptr);
    }; //Misc
}; //Script

#endif //_SCRIPTAPI_MISC_H


================================================
File: pluginsdk/_scriptapi_module.h
================================================
#ifndef _SCRIPTAPI_MODULE_H
#define _SCRIPTAPI_MODULE_H

#include "_scriptapi.h"

namespace Script
{
    namespace Module
    {
        struct ModuleInfo
        {
            duint base;
            duint size;
            duint entry;
            int sectionCount;
            char name[MAX_MODULE_SIZE];
            char path[MAX_PATH];
        };

        struct ModuleSectionInfo
        {
            duint addr;
            duint size;
            char name[MAX_SECTION_SIZE * 5];
        };

        SCRIPT_EXPORT bool InfoFromAddr(duint addr, ModuleInfo* info);
        SCRIPT_EXPORT bool InfoFromName(const char* name, ModuleInfo* info);
        SCRIPT_EXPORT duint BaseFromAddr(duint addr);
        SCRIPT_EXPORT duint BaseFromName(const char* name);
        SCRIPT_EXPORT duint SizeFromAddr(duint addr);
        SCRIPT_EXPORT duint SizeFromName(const char* name);
        SCRIPT_EXPORT bool NameFromAddr(duint addr, char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool PathFromAddr(duint addr, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool PathFromName(const char* name, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT duint EntryFromAddr(duint addr);
        SCRIPT_EXPORT duint EntryFromName(const char* name);
        SCRIPT_EXPORT int SectionCountFromAddr(duint addr);
        SCRIPT_EXPORT int SectionCountFromName(const char* name);
        SCRIPT_EXPORT bool SectionFromAddr(duint addr, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionFromName(const char* name, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionListFromAddr(duint addr, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool SectionListFromName(const char* name, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool GetMainModuleInfo(ModuleInfo* info);
        SCRIPT_EXPORT duint GetMainModuleBase();
        SCRIPT_EXPORT duint GetMainModuleSize();
        SCRIPT_EXPORT duint GetMainModuleEntry();
        SCRIPT_EXPORT int GetMainModuleSectionCount();
        SCRIPT_EXPORT bool GetMainModuleName(char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool GetMainModulePath(char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool GetMainModuleSectionList(ListOf(ModuleSectionInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetList(ListOf(ModuleInfo) list); //caller has the responsibility to free the list
    }; //Module
}; //Script

#endif //_SCRIPTAPI_MODULE_H


================================================
File: pluginsdk/_scriptapi_pattern.h
================================================
#ifndef _SCRIPTAPI_PATTERN_H
#define _SCRIPTAPI_PATTERN_H

#include "_scriptapi.h"

namespace Script
{
    namespace Pattern
    {
        SCRIPT_EXPORT duint Find(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT void Write(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT void WriteMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT bool SearchAndReplace(unsigned char* data, duint datasize, const char* searchpattern, const char* replacepattern);
        SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern);
    };
};

#endif //_SCRIPTAPI_FIND_H


================================================
File: pluginsdk/_scriptapi_register.h
================================================
#ifndef _SCRIPTAPI_REGISTER_H
#define _SCRIPTAPI_REGISTER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Register
    {
        enum RegisterEnum
        {
            DR0,
            DR1,
            DR2,
            DR3,
            DR6,
            DR7,

            EAX,
            AX,
            AH,
            AL,
            EBX,
            BX,
            BH,
            BL,
            ECX,
            CX,
            CH,
            CL,
            EDX,
            DX,
            DH,
            DL,
            EDI,
            DI,
            ESI,
            SI,
            EBP,
            BP,
            ESP,
            SP,
            EIP,

#ifdef _WIN64
            RAX,
            RBX,
            RCX,
            RDX,
            RSI,
            SIL,
            RDI,
            DIL,
            RBP,
            BPL,
            RSP,
            SPL,
            RIP,
            R8,
            R8D,
            R8W,
            R8B,
            R9,
            R9D,
            R9W,
            R9B,
            R10,
            R10D,
            R10W,
            R10B,
            R11,
            R11D,
            R11W,
            R11B,
            R12,
            R12D,
            R12W,
            R12B,
            R13,
            R13D,
            R13W,
            R13B,
            R14,
            R14D,
            R14W,
            R14B,
            R15,
            R15D,
            R15W,
            R15B,
#endif //_WIN64

            CIP,
            CSP,
            CAX,
            CBX,
            CCX,
            CDX,
            CDI,
            CSI,
            CBP,
            CFLAGS
        }; //RegisterEnum

        SCRIPT_EXPORT duint Get(RegisterEnum reg);
        SCRIPT_EXPORT bool Set(RegisterEnum reg, duint value);
        SCRIPT_EXPORT int Size(); //gets architecture register size in bytes

        SCRIPT_EXPORT duint GetDR0();
        SCRIPT_EXPORT bool SetDR0(duint value);
        SCRIPT_EXPORT duint GetDR1();
        SCRIPT_EXPORT bool SetDR1(duint value);
        SCRIPT_EXPORT duint GetDR2();
        SCRIPT_EXPORT bool SetDR2(duint value);
        SCRIPT_EXPORT duint GetDR3();
        SCRIPT_EXPORT bool SetDR3(duint value);
        SCRIPT_EXPORT duint GetDR6();
        SCRIPT_EXPORT bool SetDR6(duint value);
        SCRIPT_EXPORT duint GetDR7();
        SCRIPT_EXPORT bool SetDR7(duint value);

        SCRIPT_EXPORT unsigned int GetEAX();
        SCRIPT_EXPORT bool SetEAX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetAX();
        SCRIPT_EXPORT bool SetAX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetAH();
        SCRIPT_EXPORT bool SetAH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetAL();
        SCRIPT_EXPORT bool SetAL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEBX();
        SCRIPT_EXPORT bool SetEBX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBX();
        SCRIPT_EXPORT bool SetBX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetBH();
        SCRIPT_EXPORT bool SetBH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetBL();
        SCRIPT_EXPORT bool SetBL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetECX();
        SCRIPT_EXPORT bool SetECX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetCX();
        SCRIPT_EXPORT bool SetCX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetCH();
        SCRIPT_EXPORT bool SetCH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetCL();
        SCRIPT_EXPORT bool SetCL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDX();
        SCRIPT_EXPORT bool SetEDX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDX();
        SCRIPT_EXPORT bool SetDX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetDH();
        SCRIPT_EXPORT bool SetDH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetDL();
        SCRIPT_EXPORT bool SetDL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDI();
        SCRIPT_EXPORT bool SetEDI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDI();
        SCRIPT_EXPORT bool SetDI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESI();
        SCRIPT_EXPORT bool SetESI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSI();
        SCRIPT_EXPORT bool SetSI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEBP();
        SCRIPT_EXPORT bool SetEBP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBP();
        SCRIPT_EXPORT bool SetBP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESP();
        SCRIPT_EXPORT bool SetESP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSP();
        SCRIPT_EXPORT bool SetSP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEIP();
        SCRIPT_EXPORT bool SetEIP(unsigned int value);

#ifdef _WIN64
        SCRIPT_EXPORT unsigned long long GetRAX();
        SCRIPT_EXPORT bool SetRAX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRBX();
        SCRIPT_EXPORT bool SetRBX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRCX();
        SCRIPT_EXPORT bool SetRCX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRDX();
        SCRIPT_EXPORT bool SetRDX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRSI();
        SCRIPT_EXPORT bool SetRSI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSIL();
        SCRIPT_EXPORT bool SetSIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRDI();
        SCRIPT_EXPORT bool SetRDI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetDIL();
        SCRIPT_EXPORT bool SetDIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRBP();
        SCRIPT_EXPORT bool SetRBP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetBPL();
        SCRIPT_EXPORT bool SetBPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRSP();
        SCRIPT_EXPORT bool SetRSP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSPL();
        SCRIPT_EXPORT bool SetSPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRIP();
        SCRIPT_EXPORT bool SetRIP(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetR8();
        SCRIPT_EXPORT bool SetR8(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR8D();
        SCRIPT_EXPORT bool SetR8D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR8W();
        SCRIPT_EXPORT bool SetR8W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR8B();
        SCRIPT_EXPORT bool SetR8B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR9();
        SCRIPT_EXPORT bool SetR9(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR9D();
        SCRIPT_EXPORT bool SetR9D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR9W();
        SCRIPT_EXPORT bool SetR9W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR9B();
        SCRIPT_EXPORT bool SetR9B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR10();
        SCRIPT_EXPORT bool SetR10(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR10D();
        SCRIPT_EXPORT bool SetR10D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR10W();
        SCRIPT_EXPORT bool SetR10W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR10B();
        SCRIPT_EXPORT bool SetR10B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR11();
        SCRIPT_EXPORT bool SetR11(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR11D();
        SCRIPT_EXPORT bool SetR11D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR11W();
        SCRIPT_EXPORT bool SetR11W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR11B();
        SCRIPT_EXPORT bool SetR11B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR12();
        SCRIPT_EXPORT bool SetR12(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR12D();
        SCRIPT_EXPORT bool SetR12D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR12W();
        SCRIPT_EXPORT bool SetR12W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR12B();
        SCRIPT_EXPORT bool SetR12B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR13();
        SCRIPT_EXPORT bool SetR13(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR13D();
        SCRIPT_EXPORT bool SetR13D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR13W();
        SCRIPT_EXPORT bool SetR13W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR13B();
        SCRIPT_EXPORT bool SetR13B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR14();
        SCRIPT_EXPORT bool SetR14(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR14D();
        SCRIPT_EXPORT bool SetR14D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR14W();
        SCRIPT_EXPORT bool SetR14W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR14B();
        SCRIPT_EXPORT bool SetR14B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR15();
        SCRIPT_EXPORT bool SetR15(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR15D();
        SCRIPT_EXPORT bool SetR15D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR15W();
        SCRIPT_EXPORT bool SetR15W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR15B();
        SCRIPT_EXPORT bool SetR15B(unsigned char value);
#endif //_WIN64

        SCRIPT_EXPORT duint GetCAX();
        SCRIPT_EXPORT bool SetCAX(duint value);
        SCRIPT_EXPORT duint GetCBX();
        SCRIPT_EXPORT bool SetCBX(duint value);
        SCRIPT_EXPORT duint GetCCX();
        SCRIPT_EXPORT bool SetCCX(duint value);
        SCRIPT_EXPORT duint GetCDX();
        SCRIPT_EXPORT bool SetCDX(duint value);
        SCRIPT_EXPORT duint GetCDI();
        SCRIPT_EXPORT bool SetCDI(duint value);
        SCRIPT_EXPORT duint GetCSI();
        SCRIPT_EXPORT bool SetCSI(duint value);
        SCRIPT_EXPORT duint GetCBP();
        SCRIPT_EXPORT bool SetCBP(duint value);
        SCRIPT_EXPORT duint GetCSP();
        SCRIPT_EXPORT bool SetCSP(duint value);
        SCRIPT_EXPORT duint GetCIP();
        SCRIPT_EXPORT bool SetCIP(duint value);
        SCRIPT_EXPORT duint GetCFLAGS();
        SCRIPT_EXPORT bool SetCFLAGS(duint value);
    }; //Register
}; //Script

#endif //_SCRIPTAPI_REGISTER_H


================================================
File: pluginsdk/_scriptapi_stack.h
================================================
#ifndef _SCRIPTAPI_STACK_H
#define _SCRIPTAPI_STACK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Stack
    {
        SCRIPT_EXPORT duint Pop();
        SCRIPT_EXPORT duint Push(duint value); //returns the previous top, equal to Peek(1)
        SCRIPT_EXPORT duint Peek(int offset = 0); //offset is in multiples of Register::Size(), for easy x32/x64 portability
    }; //Stack
}; //Script

#endif //_SCRIPTAPI_STACK_H


================================================
File: pluginsdk/_scriptapi_symbol.h
================================================
#ifndef _SCRIPTAPI_SYMBOL_H
#define _SCRIPTAPI_SYMBOL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Symbol
    {
        enum SymbolType
        {
            Function, //user-defined function
            Import, //IAT entry
            Export //export
        };

        struct SymbolInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char name[MAX_LABEL_SIZE];
            bool manual;
            SymbolType type;
        };

        SCRIPT_EXPORT bool GetList(ListOf(SymbolInfo) list); //caller has the responsibility to free the list
    }; //Symbol
}; //Script

#endif //_SCRIPTAPI_SYMBOL_H


================================================
File: pluginsdk/bridgegraph.h
================================================
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint addr; //virtual address of the instruction
    unsigned char data[15]; //instruction bytes
} BridgeCFInstruction;

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo instrs; //block instructions
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if _MSC_VER >= 1700 && !defined(NO_CPP11)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<BridgeCFInstruction> instrs; //block instructions

    static void Free(const BridgeCFNodeList* nodeList)
    {
        if(!BridgeList<duint>::Free(&nodeList->exits))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::Free(&nodeList->instrs))
            __debugbreak();
    }

    explicit BridgeCFNode(const BridgeCFNodeList* nodeList, bool freedata)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        indirectcall = nodeList->indirectcall;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::ToVector(&nodeList->instrs, instrs, freedata))
            __debugbreak();
    }

    explicit BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end),
          brtrue(0),
          brfalse(0),
          icount(0),
          terminal(false),
          indirectcall(false),
          split(false),
          userdata(nullptr)
    {
    }

    explicit BridgeCFNode()
        : parentGraph(0),
          start(0),
          end(0),
          brtrue(0),
          brfalse(0),
          icount(0),
          terminal(false),
          split(false),
          userdata(nullptr)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.indirectcall = indirectcall;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<BridgeCFInstruction>::CopyData(&out.instrs, instrs);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    static void Free(const BridgeCFGraphList* graphList)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            BridgeCFNode::Free(&data[i]);
        BridgeFree(data);
    }

    explicit BridgeCFGraph(const BridgeCFGraphList* graphList, bool freedata)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
        {
            parents[child] = std::unordered_set<duint>();
            parents[child].insert(parent);
        }
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H


================================================
File: pluginsdk/bridgelist.h
================================================
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type)) //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count())) //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool Free(const ListInfo* listInfo)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        BridgeFree(listInfo->data);
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H


================================================
File: pluginsdk/bridgemain.h
================================================
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions
BRIDGE_IMPEXP const wchar_t* BridgeInit();
BRIDGE_IMPEXP const wchar_t* BridgeStart();
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);
BRIDGE_IMPEXP void BridgeFree(void* ptr);
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);
BRIDGE_IMPEXP bool BridgeSettingFlush();
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);
BRIDGE_IMPEXP int BridgeGetDbgVersion();

#ifdef __cplusplus
}
#endif

//list structure (and C++ wrapper)
#include "bridgelist.h"

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 0x1,
    flaglabel = 0x2,
    flagcomment = 0x4,
    flagbookmark = 0x8,
    flagfunction = 0x10,
    flagloop = 0x20,
    flagargs = 0x40,
    flagNoFuncOffset = 0x80
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END,
    LOOP_SINGLE
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST,             // param1=ListOf(WATCHINFO),         param2=unused
    DBG_SELCHANGED,                 // param1=hWindow,                   param2=VA
    DBG_GET_PROCESS_HANDLE,         // param1=unused,                    param2=unused
    DBG_GET_THREAD_HANDLE,          // param1=unused,                    param2=unused
    DBG_GET_PROCESS_ID,             // param1=unused,                    param2=unused
    DBG_GET_THREAD_ID,              // param1=unused,                    param2=unused
    DBG_GET_PEB_ADDRESS,            // param1=DWORD ProcessId,           param2=unused
    DBG_GET_TEB_ADDRESS,            // param1=DWORD ThreadId,            param2=unused
    DBG_ANALYZE_FUNCTION,           // param1=BridgeCFGraphList* graph,  param2=duint entry
    DBG_MENU_PREPARE,               // param1=int hMenu,                 param2=unused
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes avx512 not supported
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

typedef enum
{
    hw_access,
    hw_write,
    hw_execute
} BPHWTYPE;

typedef enum
{
    mem_access,
    mem_read,
    mem_write,
    mem_execute
} BPMEMTYPE;

typedef enum
{
    dll_load = 1,
    dll_unload,
    dll_all
} BPDLLTYPE;

typedef enum
{
    ex_firstchance = 1,
    ex_secondchance,
    ex_all
} BPEXTYPE;

typedef enum
{
    hw_byte,
    hw_word,
    hw_dword,
    hw_qword
} BPHWSIZE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;
typedef struct SYMBOLINFO_ SYMBOLINFO;
typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef void (*CBSYMBOLENUM)(SYMBOLINFO* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned char typeEx; //BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE
    unsigned char hwSize; //BPHWSIZE
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} BRIDGE_ADDRINFO;

struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    bool isImported;
};

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool ES;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, void* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const void* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDump(REGDUMP* regdump);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr, duint* size);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);
BRIDGE_IMPEXP void DbgSelChanged(int hWindow, duint VA);
BRIDGE_IMPEXP HANDLE DbgGetProcessHandle();
BRIDGE_IMPEXP HANDLE DbgGetThreadHandle();
BRIDGE_IMPEXP DWORD DbgGetProcessId();
BRIDGE_IMPEXP DWORD DbgGetThreadId();
BRIDGE_IMPEXP duint DbgGetPebAddress(DWORD ProcessId);
BRIDGE_IMPEXP duint DbgGetTebAddress(DWORD ThreadId);
BRIDGE_IMPEXP bool DbgAnalyzeFunction(duint entry, BridgeCFGraphList* graph);
BRIDGE_IMPEXP duint DbgEval(const char* expression, bool* success = 0);
BRIDGE_IMPEXP void DbgMenuPrepare(int hMenu);

//Gui defines
#define GUI_PLUGIN_MENU 0
#define GUI_DISASM_MENU 1
#define GUI_DUMP_MENU 2
#define GUI_STACK_MENU 3

#define GUI_DISASSEMBLY 0
#define GUI_DUMP 1
#define GUI_STACK 2
#define GUI_GRAPH 3
#define GUI_MEMMAP 4
#define GUI_SYMMOD 5

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=int hWindow,          param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=int hWindow,          param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_UPDATE_SEHCHAIN,            // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=line
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACK,          param2=unused
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG,     // param1=int id,               param2=unused
    GUI_UPDATE_ARGUMENT_VIEW,       // param1=unused,               param2=unused
    GUI_FOCUS_VIEW,                 // param1=int hWindow,          param2=unused
    GUI_UPDATE_WATCH_VIEW,          // param1=unused,               param2=unused
    GUI_LOAD_GRAPH,                 // param1=BridgeCFGraphList*    param2=unused
    GUI_GRAPH_AT,                   // param1=duint addr            param2=unused
    GUI_UPDATE_GRAPH_VIEW,          // param1=unused,               param2=unused
    GUI_SET_LOG_ENABLED,            // param1=bool isEnabled        param2=unused
    GUI_ADD_FAVOURITE_TOOL,         // param1=const char* name      param2=const char* description
    GUI_ADD_FAVOURITE_COMMAND,      // param1=const char* command   param2=const char* shortcut
    GUI_SET_FAVOURITE_TOOL_SHORTCUT,// param1=const char* name      param2=const char* shortcut
    GUI_FOLD_DISASSEMBLY,           // param1=duint startAddress    param2=duint length
    GUI_SELECT_IN_MEMORY_MAP,       // param1=duint addr,           param2=unused
    GUI_GET_ACTIVE_VIEW,            // param1=ACTIVEVIEW*,          param2=unused
    GUI_MENU_SET_ENTRY_CHECKED,     // param1=int hEntry,           param2=bool checked
    GUI_ADD_INFO_LINE,              // param1=const char* infoline, param2=unused
    GUI_PROCESS_EVENTS,             // param1=unused,               param2=unused
    GUI_TYPE_ADDNODE,               // param1=void* parent,         param2=TYPEDESCRIPTOR* type
    GUI_TYPE_CLEAR,                 // param1=unused,               param2=unused
    GUI_UPDATE_TYPE_WIDGET,         // param1=unused,               param2=unused
    GUI_CLOSE_APPLICATION,          // param1=unused,               param2=unused
    GUI_MENU_SET_VISIBLE,           // param1=int hMenu,            param2=bool visible
    GUI_MENU_SET_ENTRY_VISIBLE,     // param1=int hEntry,           param2=bool visible
    GUI_MENU_SET_NAME,              // param1=int hMenu,            param2=const char* name
    GUI_MENU_SET_ENTRY_NAME,        // param1=int hEntry,           param2=const char* name
    GUI_FLUSH_LOG,                  // param1=unused,               param2=unused
    GUI_MENU_SET_ENTRY_HOTKEY,      // param1=int hEntry,           param2=const char* hack
    GUI_REF_SEARCH_GETROWCOUNT,     // param1=unused,               param2=unused
    GUI_REF_SEARCH_GETCELLCONTENT,  // param1=int row,              param2=int col
    GUI_MENU_REMOVE,                // param1=int hEntryMenu,       param2=unused
} GUIMSG;

//GUI Typedefs
struct _TYPEDESCRIPTOR;

typedef void (*GUICALLBACK)();
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);
typedef bool (*TYPETOSTRING)(const struct _TYPEDESCRIPTOR* type, char* dest, size_t* destCount); //don't change destCount for final failure

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

typedef struct
{
    void* titleHwnd;
    void* classHwnd;
    char title[MAX_STRING_SIZE];
    char className[MAX_STRING_SIZE];
} ACTIVEVIEW;

typedef struct _TYPEDESCRIPTOR
{
    bool expanded; //is the type node expanded?
    bool reverse; //big endian?
    const char* name; //type name (int b)
    duint addr; //virtual address
    duint offset; //offset to addr for the actual location
    int id; //type id
    int size; //sizeof(type)
    TYPETOSTRING callback; //convert to string
    void* userdata; //user data
} TYPEDESCRIPTOR;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiSetDebugStateFast(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP int GuiReferenceSearchGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP char* GuiReferenceSearchGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP void GuiMenuRemove(int hEntryMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(int hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(int hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFile(const char* path, int line);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryChecked(int hEntry, bool checked);
BRIDGE_IMPEXP void GuiMenuSetVisible(int hMenu, bool visible);
BRIDGE_IMPEXP void GuiMenuSetEntryVisible(int hEntry, bool visible);
BRIDGE_IMPEXP void GuiMenuSetName(int hMenu, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryName(int hEntry, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryHotkey(int hEntry, const char* hack);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP void GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP duint GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);
BRIDGE_IMPEXP void GuiGetActiveView(ACTIVEVIEW* activeView);
BRIDGE_IMPEXP void GuiAddInfoLine(const char* infoLine);
BRIDGE_IMPEXP void GuiProcessEvents();
BRIDGE_IMPEXP void* GuiTypeAddNode(void* parent, const TYPEDESCRIPTOR* type);
BRIDGE_IMPEXP bool GuiTypeClear();
BRIDGE_IMPEXP void GuiUpdateTypeWidget();
BRIDGE_IMPEXP void GuiCloseApplication();
BRIDGE_IMPEXP void GuiFlushLog();

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_



================================================
File: pluginsdk/DeviceNameResolver/DeviceNameResolver.h
================================================
#ifndef _DEVICENAMERESOLVER_H
#define _DEVICENAMERESOLVER_H

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

__declspec(dllexport) bool DevicePathToPathW(const wchar_t* szDevicePath, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathToPathA(const char* szDevicePath, char* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleW(HANDLE hFile, wchar_t* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleA(HANDLE hFile, char* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleW(HANDLE hFile, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleA(HANDLE hFile, char* szPath, size_t nSizeInChars);

#ifdef __cplusplus
}
#endif

#endif // _DEVICENAMERESOLVER_H



================================================
File: pluginsdk/TitanEngine/TitanEngine.h
================================================
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <stdint.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, const char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(const char* szFileName, const char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(const wchar_t* szFileName, const wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(const char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(const char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(const wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(const char* szFileName, const char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(const wchar_t* szFileName, const wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(const char* szFileName, const char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(const wchar_t* szFileName, const wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(const char* szInFileName, const char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(const wchar_t* szInFileName, const wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(const char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(const char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(const char* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(const char* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(const char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(const wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(const char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(const wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(const char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(const char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(const wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(const char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(const char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(const wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(const char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(const wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(const char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(const wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(const char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(const wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(const char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(const wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(const char* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(const wchar_t* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, const char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, const wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const char* szDumpFile1, const char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const wchar_t* szDumpFile1, const wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(const char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(const wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(const char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(const wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(const char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(const char* szFileName, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(const wchar_t* szFileName, char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(const char* szFileName, const char* szResourceType, DWORD ResourceType, const char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(const wchar_t* szFileName, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(const char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(const wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(const char* szFileName, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(const char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(const wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(const char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(const char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(const char* szDumpFileName, const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(const wchar_t* szDumpFileName, const wchar_t* szExportFileName, const wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(const char* szDLLName, const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, const char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, const wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(const char* szOriginalFile, const char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(const char* szOriginalFile, const char* szDumpFile, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile, const char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, const char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, const wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, const char* szDumpedFile, const char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, const wchar_t* szDumpedFile, const wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, const char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, const wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(const char* szModuleName, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(const char* szModuleName, const char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(const char* szModuleName, const char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(const char* szModuleName, const char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, const char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, const char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(const char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(const wchar_t* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(const wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(const char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(const char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(const char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(const wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(const char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(const wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(const char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(const char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(const wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(const char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(const wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(const char* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(const wchar_t* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(const char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(const wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, const char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, const wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(const char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(const wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(const char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(const wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(const char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(const wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(const char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(const wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(const wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(const char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(const char* szFileName, const char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(const wchar_t* szFileName, const wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(const char* szFileName, const char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(const wchar_t* szFileName, const wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(const char* WindowUnpackerTitle, const char* WindowUnpackerLongTitle, const char* WindowUnpackerName, const char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(const char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);
// Global.Engine.Extension.Functions:
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginLoaded(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginEnabled(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerDisableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerDisablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerEnableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerEnablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadPlugin(const char* szPluginName);
__declspec(dllexport) void* TITCALL ExtensionManagerGetPluginInfo(const char* szPluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/



================================================
File: pluginsdk/XEDParse/XEDParse.h
================================================
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H



================================================
File: pluginsdk/capstone/arm.h
================================================
#ifndef CAPSTONE_ARM_H
#define CAPSTONE_ARM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM shift type
typedef enum arm_shifter
{
    ARM_SFT_INVALID = 0,
    ARM_SFT_ASR,    // shift with immediate const
    ARM_SFT_LSL,    // shift with immediate const
    ARM_SFT_LSR,    // shift with immediate const
    ARM_SFT_ROR,    // shift with immediate const
    ARM_SFT_RRX,    // shift with immediate const
    ARM_SFT_ASR_REG,    // shift with register
    ARM_SFT_LSL_REG,    // shift with register
    ARM_SFT_LSR_REG,    // shift with register
    ARM_SFT_ROR_REG,    // shift with register
    ARM_SFT_RRX_REG,    // shift with register
} arm_shifter;

//> ARM condition code
typedef enum arm_cc
{
    ARM_CC_INVALID = 0,
    ARM_CC_EQ,            // Equal                      Equal
    ARM_CC_NE,            // Not equal                  Not equal, or unordered
    ARM_CC_HS,            // Carry set                  >, ==, or unordered
    ARM_CC_LO,            // Carry clear                Less than
    ARM_CC_MI,            // Minus, negative            Less than
    ARM_CC_PL,            // Plus, positive or zero     >, ==, or unordered
    ARM_CC_VS,            // Overflow                   Unordered
    ARM_CC_VC,            // No overflow                Not unordered
    ARM_CC_HI,            // Unsigned higher            Greater than, or unordered
    ARM_CC_LS,            // Unsigned lower or same     Less than or equal
    ARM_CC_GE,            // Greater than or equal      Greater than or equal
    ARM_CC_LT,            // Less than                  Less than, or unordered
    ARM_CC_GT,            // Greater than               Greater than
    ARM_CC_LE,            // Less than or equal         <, ==, or unordered
    ARM_CC_AL             // Always (unconditional)     Always (unconditional)
} arm_cc;

typedef enum arm_sysreg
{
    //> Special registers for MSR
    ARM_SYSREG_INVALID = 0,

    // SPSR* registers can be OR combined
    ARM_SYSREG_SPSR_C = 1,
    ARM_SYSREG_SPSR_X = 2,
    ARM_SYSREG_SPSR_S = 4,
    ARM_SYSREG_SPSR_F = 8,

    // CPSR* registers can be OR combined
    ARM_SYSREG_CPSR_C = 16,
    ARM_SYSREG_CPSR_X = 32,
    ARM_SYSREG_CPSR_S = 64,
    ARM_SYSREG_CPSR_F = 128,

    // independent registers
    ARM_SYSREG_APSR = 256,
    ARM_SYSREG_APSR_G,
    ARM_SYSREG_APSR_NZCVQ,
    ARM_SYSREG_APSR_NZCVQG,

    ARM_SYSREG_IAPSR,
    ARM_SYSREG_IAPSR_G,
    ARM_SYSREG_IAPSR_NZCVQG,
    ARM_SYSREG_IAPSR_NZCVQ,

    ARM_SYSREG_EAPSR,
    ARM_SYSREG_EAPSR_G,
    ARM_SYSREG_EAPSR_NZCVQG,
    ARM_SYSREG_EAPSR_NZCVQ,

    ARM_SYSREG_XPSR,
    ARM_SYSREG_XPSR_G,
    ARM_SYSREG_XPSR_NZCVQG,
    ARM_SYSREG_XPSR_NZCVQ,

    ARM_SYSREG_IPSR,
    ARM_SYSREG_EPSR,
    ARM_SYSREG_IEPSR,

    ARM_SYSREG_MSP,
    ARM_SYSREG_PSP,
    ARM_SYSREG_PRIMASK,
    ARM_SYSREG_BASEPRI,
    ARM_SYSREG_BASEPRI_MAX,
    ARM_SYSREG_FAULTMASK,
    ARM_SYSREG_CONTROL,

    // Banked Registers
    ARM_SYSREG_R8_USR,
    ARM_SYSREG_R9_USR,
    ARM_SYSREG_R10_USR,
    ARM_SYSREG_R11_USR,
    ARM_SYSREG_R12_USR,
    ARM_SYSREG_SP_USR,
    ARM_SYSREG_LR_USR,
    ARM_SYSREG_R8_FIQ,
    ARM_SYSREG_R9_FIQ,
    ARM_SYSREG_R10_FIQ,
    ARM_SYSREG_R11_FIQ,
    ARM_SYSREG_R12_FIQ,
    ARM_SYSREG_SP_FIQ,
    ARM_SYSREG_LR_FIQ,
    ARM_SYSREG_LR_IRQ,
    ARM_SYSREG_SP_IRQ,
    ARM_SYSREG_LR_SVC,
    ARM_SYSREG_SP_SVC,
    ARM_SYSREG_LR_ABT,
    ARM_SYSREG_SP_ABT,
    ARM_SYSREG_LR_UND,
    ARM_SYSREG_SP_UND,
    ARM_SYSREG_LR_MON,
    ARM_SYSREG_SP_MON,
    ARM_SYSREG_ELR_HYP,
    ARM_SYSREG_SP_HYP,

    ARM_SYSREG_SPSR_FIQ,
    ARM_SYSREG_SPSR_IRQ,
    ARM_SYSREG_SPSR_SVC,
    ARM_SYSREG_SPSR_ABT,
    ARM_SYSREG_SPSR_UND,
    ARM_SYSREG_SPSR_MON,
    ARM_SYSREG_SPSR_HYP,
} arm_sysreg;

//> The memory barrier constants map directly to the 4-bit encoding of
//> the option field for Memory Barrier operations.
typedef enum arm_mem_barrier
{
    ARM_MB_INVALID = 0,
    ARM_MB_RESERVED_0,
    ARM_MB_OSHLD,
    ARM_MB_OSHST,
    ARM_MB_OSH,
    ARM_MB_RESERVED_4,
    ARM_MB_NSHLD,
    ARM_MB_NSHST,
    ARM_MB_NSH,
    ARM_MB_RESERVED_8,
    ARM_MB_ISHLD,
    ARM_MB_ISHST,
    ARM_MB_ISH,
    ARM_MB_RESERVED_12,
    ARM_MB_LD,
    ARM_MB_ST,
    ARM_MB_SY,
} arm_mem_barrier;

//> Operand type for instruction's operands
typedef enum arm_op_type
{
    ARM_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    ARM_OP_REG, // = CS_OP_REG (Register operand).
    ARM_OP_IMM, // = CS_OP_IMM (Immediate operand).
    ARM_OP_MEM, // = CS_OP_MEM (Memory operand).
    ARM_OP_FP,  // = CS_OP_FP (Floating-Point operand).
    ARM_OP_CIMM = 64, // C-Immediate (coprocessor registers)
    ARM_OP_PIMM, // P-Immediate (coprocessor registers)
    ARM_OP_SETEND,  // operand for SETEND instruction
    ARM_OP_SYSREG,  // MSR/MRS special register operand
} arm_op_type;

//> Operand type for SETEND instruction
typedef enum arm_setend_type
{
    ARM_SETEND_INVALID = 0, // Uninitialized.
    ARM_SETEND_BE,  // BE operand.
    ARM_SETEND_LE, // LE operand
} arm_setend_type;

typedef enum arm_cpsmode_type
{
    ARM_CPSMODE_INVALID = 0,
    ARM_CPSMODE_IE = 2,
    ARM_CPSMODE_ID = 3
} arm_cpsmode_type;

//> Operand type for SETEND instruction
typedef enum arm_cpsflag_type
{
    ARM_CPSFLAG_INVALID = 0,
    ARM_CPSFLAG_F = 1,
    ARM_CPSFLAG_I = 2,
    ARM_CPSFLAG_A = 4,
    ARM_CPSFLAG_NONE = 16,  // no flag
} arm_cpsflag_type;

//> Data type for elements of vector instructions.
typedef enum arm_vectordata_type
{
    ARM_VECTORDATA_INVALID = 0,

    // Integer type
    ARM_VECTORDATA_I8,
    ARM_VECTORDATA_I16,
    ARM_VECTORDATA_I32,
    ARM_VECTORDATA_I64,

    // Signed integer type
    ARM_VECTORDATA_S8,
    ARM_VECTORDATA_S16,
    ARM_VECTORDATA_S32,
    ARM_VECTORDATA_S64,

    // Unsigned integer type
    ARM_VECTORDATA_U8,
    ARM_VECTORDATA_U16,
    ARM_VECTORDATA_U32,
    ARM_VECTORDATA_U64,

    // Data type for VMUL/VMULL
    ARM_VECTORDATA_P8,

    // Floating type
    ARM_VECTORDATA_F32,
    ARM_VECTORDATA_F64,

    // Convert float <-> float
    ARM_VECTORDATA_F16F64,  // f16.f64
    ARM_VECTORDATA_F64F16,  // f64.f16
    ARM_VECTORDATA_F32F16,  // f32.f16
    ARM_VECTORDATA_F16F32,  // f32.f16
    ARM_VECTORDATA_F64F32,  // f64.f32
    ARM_VECTORDATA_F32F64,  // f32.f64

    // Convert integer <-> float
    ARM_VECTORDATA_S32F32,  // s32.f32
    ARM_VECTORDATA_U32F32,  // u32.f32
    ARM_VECTORDATA_F32S32,  // f32.s32
    ARM_VECTORDATA_F32U32,  // f32.u32
    ARM_VECTORDATA_F64S16,  // f64.s16
    ARM_VECTORDATA_F32S16,  // f32.s16
    ARM_VECTORDATA_F64S32,  // f64.s32
    ARM_VECTORDATA_S16F64,  // s16.f64
    ARM_VECTORDATA_S16F32,  // s16.f64
    ARM_VECTORDATA_S32F64,  // s32.f64
    ARM_VECTORDATA_U16F64,  // u16.f64
    ARM_VECTORDATA_U16F32,  // u16.f32
    ARM_VECTORDATA_U32F64,  // u32.f64
    ARM_VECTORDATA_F64U16,  // f64.u16
    ARM_VECTORDATA_F32U16,  // f32.u16
    ARM_VECTORDATA_F64U32,  // f64.u32
} arm_vectordata_type;

//> ARM registers
typedef enum arm_reg
{
    ARM_REG_INVALID = 0,
    ARM_REG_APSR,
    ARM_REG_APSR_NZCV,
    ARM_REG_CPSR,
    ARM_REG_FPEXC,
    ARM_REG_FPINST,
    ARM_REG_FPSCR,
    ARM_REG_FPSCR_NZCV,
    ARM_REG_FPSID,
    ARM_REG_ITSTATE,
    ARM_REG_LR,
    ARM_REG_PC,
    ARM_REG_SP,
    ARM_REG_SPSR,
    ARM_REG_D0,
    ARM_REG_D1,
    ARM_REG_D2,
    ARM_REG_D3,
    ARM_REG_D4,
    ARM_REG_D5,
    ARM_REG_D6,
    ARM_REG_D7,
    ARM_REG_D8,
    ARM_REG_D9,
    ARM_REG_D10,
    ARM_REG_D11,
    ARM_REG_D12,
    ARM_REG_D13,
    ARM_REG_D14,
    ARM_REG_D15,
    ARM_REG_D16,
    ARM_REG_D17,
    ARM_REG_D18,
    ARM_REG_D19,
    ARM_REG_D20,
    ARM_REG_D21,
    ARM_REG_D22,
    ARM_REG_D23,
    ARM_REG_D24,
    ARM_REG_D25,
    ARM_REG_D26,
    ARM_REG_D27,
    ARM_REG_D28,
    ARM_REG_D29,
    ARM_REG_D30,
    ARM_REG_D31,
    ARM_REG_FPINST2,
    ARM_REG_MVFR0,
    ARM_REG_MVFR1,
    ARM_REG_MVFR2,
    ARM_REG_Q0,
    ARM_REG_Q1,
    ARM_REG_Q2,
    ARM_REG_Q3,
    ARM_REG_Q4,
    ARM_REG_Q5,
    ARM_REG_Q6,
    ARM_REG_Q7,
    ARM_REG_Q8,
    ARM_REG_Q9,
    ARM_REG_Q10,
    ARM_REG_Q11,
    ARM_REG_Q12,
    ARM_REG_Q13,
    ARM_REG_Q14,
    ARM_REG_Q15,
    ARM_REG_R0,
    ARM_REG_R1,
    ARM_REG_R2,
    ARM_REG_R3,
    ARM_REG_R4,
    ARM_REG_R5,
    ARM_REG_R6,
    ARM_REG_R7,
    ARM_REG_R8,
    ARM_REG_R9,
    ARM_REG_R10,
    ARM_REG_R11,
    ARM_REG_R12,
    ARM_REG_S0,
    ARM_REG_S1,
    ARM_REG_S2,
    ARM_REG_S3,
    ARM_REG_S4,
    ARM_REG_S5,
    ARM_REG_S6,
    ARM_REG_S7,
    ARM_REG_S8,
    ARM_REG_S9,
    ARM_REG_S10,
    ARM_REG_S11,
    ARM_REG_S12,
    ARM_REG_S13,
    ARM_REG_S14,
    ARM_REG_S15,
    ARM_REG_S16,
    ARM_REG_S17,
    ARM_REG_S18,
    ARM_REG_S19,
    ARM_REG_S20,
    ARM_REG_S21,
    ARM_REG_S22,
    ARM_REG_S23,
    ARM_REG_S24,
    ARM_REG_S25,
    ARM_REG_S26,
    ARM_REG_S27,
    ARM_REG_S28,
    ARM_REG_S29,
    ARM_REG_S30,
    ARM_REG_S31,

    ARM_REG_ENDING,     // <-- mark the end of the list or registers

    //> alias registers
    ARM_REG_R13 = ARM_REG_SP,
    ARM_REG_R14 = ARM_REG_LR,
    ARM_REG_R15 = ARM_REG_PC,

    ARM_REG_SB = ARM_REG_R9,
    ARM_REG_SL = ARM_REG_R10,
    ARM_REG_FP = ARM_REG_R11,
    ARM_REG_IP = ARM_REG_R12,
} arm_reg;

// Instruction's operand referring to memory
// This is associated with ARM_OP_MEM operand type above
typedef struct arm_op_mem
{
    arm_reg base;   // base register
    arm_reg index;  // index register
    int scale;  // scale for index register (can be 1, or -1)
    int disp;   // displacement/offset value
    int lshift; // left-shift on index register, or 0 if irrelevant.
} arm_op_mem;

// Instruction operand
typedef struct cs_arm_op
{
    int vector_index;   // Vector Index for some vector operands (or -1 if irrelevant)

    struct
    {
        arm_shifter type;
        unsigned int value;
    } shift;

    arm_op_type type;   // operand type

    union
    {
        int reg;    // register value for REG/SYSREG operand
        int32_t imm;            // immediate value for C-IMM, P-IMM or IMM operand
        double fp;          // floating point value for FP operand
        arm_op_mem mem;     // base/index/scale/disp value for MEM operand
        arm_setend_type setend; // SETEND instruction's operand type
    };

    // in some instructions, an operand can be subtracted or added to
    // the base register,
    bool subtracted; // if TRUE, this operand is subtracted. otherwise, it is added.

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;

    // Neon lane index for NEON instructions (or -1 if irrelevant)
    int8_t neon_lane;
} cs_arm_op;

// Instruction structure
typedef struct cs_arm
{
    bool usermode;  // User-mode registers to be loaded (for LDM/STM instructions)
    int vector_size;    // Scalar size for vector instructions
    arm_vectordata_type vector_data; // Data type for elements of vector instructions
    arm_cpsmode_type cps_mode;  // CPS mode for CPS instruction
    arm_cpsflag_type cps_flag;  // CPS mode for CPS instruction
    arm_cc cc;          // conditional code for this insn
    bool update_flags;  // does this insn update flags?
    bool writeback;     // does this insn write-back?
    arm_mem_barrier mem_barrier;    // Option for some memory barrier instructions

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_arm_op operands[36]; // operands for this instruction.
} cs_arm;

//> ARM instruction
typedef enum arm_insn
{
    ARM_INS_INVALID = 0,

    ARM_INS_ADC,
    ARM_INS_ADD,
    ARM_INS_ADR,
    ARM_INS_AESD,
    ARM_INS_AESE,
    ARM_INS_AESIMC,
    ARM_INS_AESMC,
    ARM_INS_AND,
    ARM_INS_BFC,
    ARM_INS_BFI,
    ARM_INS_BIC,
    ARM_INS_BKPT,
    ARM_INS_BL,
    ARM_INS_BLX,
    ARM_INS_BX,
    ARM_INS_BXJ,
    ARM_INS_B,
    ARM_INS_CDP,
    ARM_INS_CDP2,
    ARM_INS_CLREX,
    ARM_INS_CLZ,
    ARM_INS_CMN,
    ARM_INS_CMP,
    ARM_INS_CPS,
    ARM_INS_CRC32B,
    ARM_INS_CRC32CB,
    ARM_INS_CRC32CH,
    ARM_INS_CRC32CW,
    ARM_INS_CRC32H,
    ARM_INS_CRC32W,
    ARM_INS_DBG,
    ARM_INS_DMB,
    ARM_INS_DSB,
    ARM_INS_EOR,
    ARM_INS_ERET,
    ARM_INS_VMOV,
    ARM_INS_FLDMDBX,
    ARM_INS_FLDMIAX,
    ARM_INS_VMRS,
    ARM_INS_FSTMDBX,
    ARM_INS_FSTMIAX,
    ARM_INS_HINT,
    ARM_INS_HLT,
    ARM_INS_HVC,
    ARM_INS_ISB,
    ARM_INS_LDA,
    ARM_INS_LDAB,
    ARM_INS_LDAEX,
    ARM_INS_LDAEXB,
    ARM_INS_LDAEXD,
    ARM_INS_LDAEXH,
    ARM_INS_LDAH,
    ARM_INS_LDC2L,
    ARM_INS_LDC2,
    ARM_INS_LDCL,
    ARM_INS_LDC,
    ARM_INS_LDMDA,
    ARM_INS_LDMDB,
    ARM_INS_LDM,
    ARM_INS_LDMIB,
    ARM_INS_LDRBT,
    ARM_INS_LDRB,
    ARM_INS_LDRD,
    ARM_INS_LDREX,
    ARM_INS_LDREXB,
    ARM_INS_LDREXD,
    ARM_INS_LDREXH,
    ARM_INS_LDRH,
    ARM_INS_LDRHT,
    ARM_INS_LDRSB,
    ARM_INS_LDRSBT,
    ARM_INS_LDRSH,
    ARM_INS_LDRSHT,
    ARM_INS_LDRT,
    ARM_INS_LDR,
    ARM_INS_MCR,
    ARM_INS_MCR2,
    ARM_INS_MCRR,
    ARM_INS_MCRR2,
    ARM_INS_MLA,
    ARM_INS_MLS,
    ARM_INS_MOV,
    ARM_INS_MOVT,
    ARM_INS_MOVW,
    ARM_INS_MRC,
    ARM_INS_MRC2,
    ARM_INS_MRRC,
    ARM_INS_MRRC2,
    ARM_INS_MRS,
    ARM_INS_MSR,
    ARM_INS_MUL,
    ARM_INS_MVN,
    ARM_INS_ORR,
    ARM_INS_PKHBT,
    ARM_INS_PKHTB,
    ARM_INS_PLDW,
    ARM_INS_PLD,
    ARM_INS_PLI,
    ARM_INS_QADD,
    ARM_INS_QADD16,
    ARM_INS_QADD8,
    ARM_INS_QASX,
    ARM_INS_QDADD,
    ARM_INS_QDSUB,
    ARM_INS_QSAX,
    ARM_INS_QSUB,
    ARM_INS_QSUB16,
    ARM_INS_QSUB8,
    ARM_INS_RBIT,
    ARM_INS_REV,
    ARM_INS_REV16,
    ARM_INS_REVSH,
    ARM_INS_RFEDA,
    ARM_INS_RFEDB,
    ARM_INS_RFEIA,
    ARM_INS_RFEIB,
    ARM_INS_RSB,
    ARM_INS_RSC,
    ARM_INS_SADD16,
    ARM_INS_SADD8,
    ARM_INS_SASX,
    ARM_INS_SBC,
    ARM_INS_SBFX,
    ARM_INS_SDIV,
    ARM_INS_SEL,
    ARM_INS_SETEND,
    ARM_INS_SHA1C,
    ARM_INS_SHA1H,
    ARM_INS_SHA1M,
    ARM_INS_SHA1P,
    ARM_INS_SHA1SU0,
    ARM_INS_SHA1SU1,
    ARM_INS_SHA256H,
    ARM_INS_SHA256H2,
    ARM_INS_SHA256SU0,
    ARM_INS_SHA256SU1,
    ARM_INS_SHADD16,
    ARM_INS_SHADD8,
    ARM_INS_SHASX,
    ARM_INS_SHSAX,
    ARM_INS_SHSUB16,
    ARM_INS_SHSUB8,
    ARM_INS_SMC,
    ARM_INS_SMLABB,
    ARM_INS_SMLABT,
    ARM_INS_SMLAD,
    ARM_INS_SMLADX,
    ARM_INS_SMLAL,
    ARM_INS_SMLALBB,
    ARM_INS_SMLALBT,
    ARM_INS_SMLALD,
    ARM_INS_SMLALDX,
    ARM_INS_SMLALTB,
    ARM_INS_SMLALTT,
    ARM_INS_SMLATB,
    ARM_INS_SMLATT,
    ARM_INS_SMLAWB,
    ARM_INS_SMLAWT,
    ARM_INS_SMLSD,
    ARM_INS_SMLSDX,
    ARM_INS_SMLSLD,
    ARM_INS_SMLSLDX,
    ARM_INS_SMMLA,
    ARM_INS_SMMLAR,
    ARM_INS_SMMLS,
    ARM_INS_SMMLSR,
    ARM_INS_SMMUL,
    ARM_INS_SMMULR,
    ARM_INS_SMUAD,
    ARM_INS_SMUADX,
    ARM_INS_SMULBB,
    ARM_INS_SMULBT,
    ARM_INS_SMULL,
    ARM_INS_SMULTB,
    ARM_INS_SMULTT,
    ARM_INS_SMULWB,
    ARM_INS_SMULWT,
    ARM_INS_SMUSD,
    ARM_INS_SMUSDX,
    ARM_INS_SRSDA,
    ARM_INS_SRSDB,
    ARM_INS_SRSIA,
    ARM_INS_SRSIB,
    ARM_INS_SSAT,
    ARM_INS_SSAT16,
    ARM_INS_SSAX,
    ARM_INS_SSUB16,
    ARM_INS_SSUB8,
    ARM_INS_STC2L,
    ARM_INS_STC2,
    ARM_INS_STCL,
    ARM_INS_STC,
    ARM_INS_STL,
    ARM_INS_STLB,
    ARM_INS_STLEX,
    ARM_INS_STLEXB,
    ARM_INS_STLEXD,
    ARM_INS_STLEXH,
    ARM_INS_STLH,
    ARM_INS_STMDA,
    ARM_INS_STMDB,
    ARM_INS_STM,
    ARM_INS_STMIB,
    ARM_INS_STRBT,
    ARM_INS_STRB,
    ARM_INS_STRD,
    ARM_INS_STREX,
    ARM_INS_STREXB,
    ARM_INS_STREXD,
    ARM_INS_STREXH,
    ARM_INS_STRH,
    ARM_INS_STRHT,
    ARM_INS_STRT,
    ARM_INS_STR,
    ARM_INS_SUB,
    ARM_INS_SVC,
    ARM_INS_SWP,
    ARM_INS_SWPB,
    ARM_INS_SXTAB,
    ARM_INS_SXTAB16,
    ARM_INS_SXTAH,
    ARM_INS_SXTB,
    ARM_INS_SXTB16,
    ARM_INS_SXTH,
    ARM_INS_TEQ,
    ARM_INS_TRAP,
    ARM_INS_TST,
    ARM_INS_UADD16,
    ARM_INS_UADD8,
    ARM_INS_UASX,
    ARM_INS_UBFX,
    ARM_INS_UDF,
    ARM_INS_UDIV,
    ARM_INS_UHADD16,
    ARM_INS_UHADD8,
    ARM_INS_UHASX,
    ARM_INS_UHSAX,
    ARM_INS_UHSUB16,
    ARM_INS_UHSUB8,
    ARM_INS_UMAAL,
    ARM_INS_UMLAL,
    ARM_INS_UMULL,
    ARM_INS_UQADD16,
    ARM_INS_UQADD8,
    ARM_INS_UQASX,
    ARM_INS_UQSAX,
    ARM_INS_UQSUB16,
    ARM_INS_UQSUB8,
    ARM_INS_USAD8,
    ARM_INS_USADA8,
    ARM_INS_USAT,
    ARM_INS_USAT16,
    ARM_INS_USAX,
    ARM_INS_USUB16,
    ARM_INS_USUB8,
    ARM_INS_UXTAB,
    ARM_INS_UXTAB16,
    ARM_INS_UXTAH,
    ARM_INS_UXTB,
    ARM_INS_UXTB16,
    ARM_INS_UXTH,
    ARM_INS_VABAL,
    ARM_INS_VABA,
    ARM_INS_VABDL,
    ARM_INS_VABD,
    ARM_INS_VABS,
    ARM_INS_VACGE,
    ARM_INS_VACGT,
    ARM_INS_VADD,
    ARM_INS_VADDHN,
    ARM_INS_VADDL,
    ARM_INS_VADDW,
    ARM_INS_VAND,
    ARM_INS_VBIC,
    ARM_INS_VBIF,
    ARM_INS_VBIT,
    ARM_INS_VBSL,
    ARM_INS_VCEQ,
    ARM_INS_VCGE,
    ARM_INS_VCGT,
    ARM_INS_VCLE,
    ARM_INS_VCLS,
    ARM_INS_VCLT,
    ARM_INS_VCLZ,
    ARM_INS_VCMP,
    ARM_INS_VCMPE,
    ARM_INS_VCNT,
    ARM_INS_VCVTA,
    ARM_INS_VCVTB,
    ARM_INS_VCVT,
    ARM_INS_VCVTM,
    ARM_INS_VCVTN,
    ARM_INS_VCVTP,
    ARM_INS_VCVTT,
    ARM_INS_VDIV,
    ARM_INS_VDUP,
    ARM_INS_VEOR,
    ARM_INS_VEXT,
    ARM_INS_VFMA,
    ARM_INS_VFMS,
    ARM_INS_VFNMA,
    ARM_INS_VFNMS,
    ARM_INS_VHADD,
    ARM_INS_VHSUB,
    ARM_INS_VLD1,
    ARM_INS_VLD2,
    ARM_INS_VLD3,
    ARM_INS_VLD4,
    ARM_INS_VLDMDB,
    ARM_INS_VLDMIA,
    ARM_INS_VLDR,
    ARM_INS_VMAXNM,
    ARM_INS_VMAX,
    ARM_INS_VMINNM,
    ARM_INS_VMIN,
    ARM_INS_VMLA,
    ARM_INS_VMLAL,
    ARM_INS_VMLS,
    ARM_INS_VMLSL,
    ARM_INS_VMOVL,
    ARM_INS_VMOVN,
    ARM_INS_VMSR,
    ARM_INS_VMUL,
    ARM_INS_VMULL,
    ARM_INS_VMVN,
    ARM_INS_VNEG,
    ARM_INS_VNMLA,
    ARM_INS_VNMLS,
    ARM_INS_VNMUL,
    ARM_INS_VORN,
    ARM_INS_VORR,
    ARM_INS_VPADAL,
    ARM_INS_VPADDL,
    ARM_INS_VPADD,
    ARM_INS_VPMAX,
    ARM_INS_VPMIN,
    ARM_INS_VQABS,
    ARM_INS_VQADD,
    ARM_INS_VQDMLAL,
    ARM_INS_VQDMLSL,
    ARM_INS_VQDMULH,
    ARM_INS_VQDMULL,
    ARM_INS_VQMOVUN,
    ARM_INS_VQMOVN,
    ARM_INS_VQNEG,
    ARM_INS_VQRDMULH,
    ARM_INS_VQRSHL,
    ARM_INS_VQRSHRN,
    ARM_INS_VQRSHRUN,
    ARM_INS_VQSHL,
    ARM_INS_VQSHLU,
    ARM_INS_VQSHRN,
    ARM_INS_VQSHRUN,
    ARM_INS_VQSUB,
    ARM_INS_VRADDHN,
    ARM_INS_VRECPE,
    ARM_INS_VRECPS,
    ARM_INS_VREV16,
    ARM_INS_VREV32,
    ARM_INS_VREV64,
    ARM_INS_VRHADD,
    ARM_INS_VRINTA,
    ARM_INS_VRINTM,
    ARM_INS_VRINTN,
    ARM_INS_VRINTP,
    ARM_INS_VRINTR,
    ARM_INS_VRINTX,
    ARM_INS_VRINTZ,
    ARM_INS_VRSHL,
    ARM_INS_VRSHRN,
    ARM_INS_VRSHR,
    ARM_INS_VRSQRTE,
    ARM_INS_VRSQRTS,
    ARM_INS_VRSRA,
    ARM_INS_VRSUBHN,
    ARM_INS_VSELEQ,
    ARM_INS_VSELGE,
    ARM_INS_VSELGT,
    ARM_INS_VSELVS,
    ARM_INS_VSHLL,
    ARM_INS_VSHL,
    ARM_INS_VSHRN,
    ARM_INS_VSHR,
    ARM_INS_VSLI,
    ARM_INS_VSQRT,
    ARM_INS_VSRA,
    ARM_INS_VSRI,
    ARM_INS_VST1,
    ARM_INS_VST2,
    ARM_INS_VST3,
    ARM_INS_VST4,
    ARM_INS_VSTMDB,
    ARM_INS_VSTMIA,
    ARM_INS_VSTR,
    ARM_INS_VSUB,
    ARM_INS_VSUBHN,
    ARM_INS_VSUBL,
    ARM_INS_VSUBW,
    ARM_INS_VSWP,
    ARM_INS_VTBL,
    ARM_INS_VTBX,
    ARM_INS_VCVTR,
    ARM_INS_VTRN,
    ARM_INS_VTST,
    ARM_INS_VUZP,
    ARM_INS_VZIP,
    ARM_INS_ADDW,
    ARM_INS_ASR,
    ARM_INS_DCPS1,
    ARM_INS_DCPS2,
    ARM_INS_DCPS3,
    ARM_INS_IT,
    ARM_INS_LSL,
    ARM_INS_LSR,
    ARM_INS_ORN,
    ARM_INS_ROR,
    ARM_INS_RRX,
    ARM_INS_SUBW,
    ARM_INS_TBB,
    ARM_INS_TBH,
    ARM_INS_CBNZ,
    ARM_INS_CBZ,
    ARM_INS_POP,
    ARM_INS_PUSH,

    // special instructions
    ARM_INS_NOP,
    ARM_INS_YIELD,
    ARM_INS_WFE,
    ARM_INS_WFI,
    ARM_INS_SEV,
    ARM_INS_SEVL,
    ARM_INS_VPUSH,
    ARM_INS_VPOP,

    ARM_INS_ENDING, // <-- mark the end of the list of instructions
} arm_insn;

//> Group of ARM instructions
typedef enum arm_insn_group
{
    ARM_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    ARM_GRP_JUMP,   // = CS_GRP_JUMP
    ARM_GRP_CALL,   // = CS_GRP_CALL
    ARM_GRP_INT = 4, // = CS_GRP_INT
    ARM_GRP_PRIVILEGE = 6, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    ARM_GRP_CRYPTO = 128,
    ARM_GRP_DATABARRIER,
    ARM_GRP_DIVIDE,
    ARM_GRP_FPARMV8,
    ARM_GRP_MULTPRO,
    ARM_GRP_NEON,
    ARM_GRP_T2EXTRACTPACK,
    ARM_GRP_THUMB2DSP,
    ARM_GRP_TRUSTZONE,
    ARM_GRP_V4T,
    ARM_GRP_V5T,
    ARM_GRP_V5TE,
    ARM_GRP_V6,
    ARM_GRP_V6T2,
    ARM_GRP_V7,
    ARM_GRP_V8,
    ARM_GRP_VFP2,
    ARM_GRP_VFP3,
    ARM_GRP_VFP4,
    ARM_GRP_ARM,
    ARM_GRP_MCLASS,
    ARM_GRP_NOTMCLASS,
    ARM_GRP_THUMB,
    ARM_GRP_THUMB1ONLY,
    ARM_GRP_THUMB2,
    ARM_GRP_PREV8,
    ARM_GRP_FPVMLX,
    ARM_GRP_MULOPS,
    ARM_GRP_CRC,
    ARM_GRP_DPVFP,
    ARM_GRP_V6M,
    ARM_GRP_VIRTUALIZATION,

    ARM_GRP_ENDING,
} arm_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/arm64.h
================================================
#ifndef CAPSTONE_ARM64_H
#define CAPSTONE_ARM64_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM64 shift type
typedef enum arm64_shifter
{
    ARM64_SFT_INVALID = 0,
    ARM64_SFT_LSL = 1,
    ARM64_SFT_MSL = 2,
    ARM64_SFT_LSR = 3,
    ARM64_SFT_ASR = 4,
    ARM64_SFT_ROR = 5,
} arm64_shifter;

//> ARM64 extender type
typedef enum arm64_extender
{
    ARM64_EXT_INVALID = 0,
    ARM64_EXT_UXTB = 1,
    ARM64_EXT_UXTH = 2,
    ARM64_EXT_UXTW = 3,
    ARM64_EXT_UXTX = 4,
    ARM64_EXT_SXTB = 5,
    ARM64_EXT_SXTH = 6,
    ARM64_EXT_SXTW = 7,
    ARM64_EXT_SXTX = 8,
} arm64_extender;

//> ARM64 condition code
typedef enum arm64_cc
{
    ARM64_CC_INVALID = 0,
    ARM64_CC_EQ = 1,     // Equal
    ARM64_CC_NE = 2,     // Not equal:                 Not equal, or unordered
    ARM64_CC_HS = 3,     // Unsigned higher or same:   >, ==, or unordered
    ARM64_CC_LO = 4,     // Unsigned lower or same:    Less than
    ARM64_CC_MI = 5,     // Minus, negative:           Less than
    ARM64_CC_PL = 6,     // Plus, positive or zero:    >, ==, or unordered
    ARM64_CC_VS = 7,     // Overflow:                  Unordered
    ARM64_CC_VC = 8,     // No overflow:               Ordered
    ARM64_CC_HI = 9,     // Unsigned higher:           Greater than, or unordered
    ARM64_CC_LS = 10,     // Unsigned lower or same:    Less than or equal
    ARM64_CC_GE = 11,     // Greater than or equal:     Greater than or equal
    ARM64_CC_LT = 12,     // Less than:                 Less than, or unordered
    ARM64_CC_GT = 13,     // Signed greater than:       Greater than
    ARM64_CC_LE = 14,     // Signed less than or equal: <, ==, or unordered
    ARM64_CC_AL = 15,     // Always (unconditional):    Always (unconditional)
    ARM64_CC_NV = 16,     // Always (unconditional):   Always (unconditional)
    // Note the NV exists purely to disassemble 0b1111. Execution
    // is "always".
} arm64_cc;

//> System registers
typedef enum arm64_sysreg
{
    //> System registers for MRS
    ARM64_SYSREG_INVALID           = 0,
    ARM64_SYSREG_MDCCSR_EL0        = 0x9808, // 10  011  0000  0001  000
    ARM64_SYSREG_DBGDTRRX_EL0      = 0x9828, // 10  011  0000  0101  000
    ARM64_SYSREG_MDRAR_EL1         = 0x8080, // 10  000  0001  0000  000
    ARM64_SYSREG_OSLSR_EL1         = 0x808c, // 10  000  0001  0001  100
    ARM64_SYSREG_DBGAUTHSTATUS_EL1 = 0x83f6, // 10  000  0111  1110  110
    ARM64_SYSREG_PMCEID0_EL0       = 0xdce6, // 11  011  1001  1100  110
    ARM64_SYSREG_PMCEID1_EL0       = 0xdce7, // 11  011  1001  1100  111
    ARM64_SYSREG_MIDR_EL1          = 0xc000, // 11  000  0000  0000  000
    ARM64_SYSREG_CCSIDR_EL1        = 0xc800, // 11  001  0000  0000  000
    ARM64_SYSREG_CLIDR_EL1         = 0xc801, // 11  001  0000  0000  001
    ARM64_SYSREG_CTR_EL0           = 0xd801, // 11  011  0000  0000  001
    ARM64_SYSREG_MPIDR_EL1         = 0xc005, // 11  000  0000  0000  101
    ARM64_SYSREG_REVIDR_EL1        = 0xc006, // 11  000  0000  0000  110
    ARM64_SYSREG_AIDR_EL1          = 0xc807, // 11  001  0000  0000  111
    ARM64_SYSREG_DCZID_EL0         = 0xd807, // 11  011  0000  0000  111
    ARM64_SYSREG_ID_PFR0_EL1       = 0xc008, // 11  000  0000  0001  000
    ARM64_SYSREG_ID_PFR1_EL1       = 0xc009, // 11  000  0000  0001  001
    ARM64_SYSREG_ID_DFR0_EL1       = 0xc00a, // 11  000  0000  0001  010
    ARM64_SYSREG_ID_AFR0_EL1       = 0xc00b, // 11  000  0000  0001  011
    ARM64_SYSREG_ID_MMFR0_EL1      = 0xc00c, // 11  000  0000  0001  100
    ARM64_SYSREG_ID_MMFR1_EL1      = 0xc00d, // 11  000  0000  0001  101
    ARM64_SYSREG_ID_MMFR2_EL1      = 0xc00e, // 11  000  0000  0001  110
    ARM64_SYSREG_ID_MMFR3_EL1      = 0xc00f, // 11  000  0000  0001  111
    ARM64_SYSREG_ID_ISAR0_EL1      = 0xc010, // 11  000  0000  0010  000
    ARM64_SYSREG_ID_ISAR1_EL1      = 0xc011, // 11  000  0000  0010  001
    ARM64_SYSREG_ID_ISAR2_EL1      = 0xc012, // 11  000  0000  0010  010
    ARM64_SYSREG_ID_ISAR3_EL1      = 0xc013, // 11  000  0000  0010  011
    ARM64_SYSREG_ID_ISAR4_EL1      = 0xc014, // 11  000  0000  0010  100
    ARM64_SYSREG_ID_ISAR5_EL1      = 0xc015, // 11  000  0000  0010  101
    ARM64_SYSREG_ID_A64PFR0_EL1   = 0xc020, // 11  000  0000  0100  000
    ARM64_SYSREG_ID_A64PFR1_EL1   = 0xc021, // 11  000  0000  0100  001
    ARM64_SYSREG_ID_A64DFR0_EL1   = 0xc028, // 11  000  0000  0101  000
    ARM64_SYSREG_ID_A64DFR1_EL1   = 0xc029, // 11  000  0000  0101  001
    ARM64_SYSREG_ID_A64AFR0_EL1   = 0xc02c, // 11  000  0000  0101  100
    ARM64_SYSREG_ID_A64AFR1_EL1   = 0xc02d, // 11  000  0000  0101  101
    ARM64_SYSREG_ID_A64ISAR0_EL1  = 0xc030, // 11  000  0000  0110  000
    ARM64_SYSREG_ID_A64ISAR1_EL1  = 0xc031, // 11  000  0000  0110  001
    ARM64_SYSREG_ID_A64MMFR0_EL1  = 0xc038, // 11  000  0000  0111  000
    ARM64_SYSREG_ID_A64MMFR1_EL1  = 0xc039, // 11  000  0000  0111  001
    ARM64_SYSREG_MVFR0_EL1         = 0xc018, // 11  000  0000  0011  000
    ARM64_SYSREG_MVFR1_EL1         = 0xc019, // 11  000  0000  0011  001
    ARM64_SYSREG_MVFR2_EL1         = 0xc01a, // 11  000  0000  0011  010
    ARM64_SYSREG_RVBAR_EL1         = 0xc601, // 11  000  1100  0000  001
    ARM64_SYSREG_RVBAR_EL2         = 0xe601, // 11  100  1100  0000  001
    ARM64_SYSREG_RVBAR_EL3         = 0xf601, // 11  110  1100  0000  001
    ARM64_SYSREG_ISR_EL1           = 0xc608, // 11  000  1100  0001  000
    ARM64_SYSREG_CNTPCT_EL0        = 0xdf01, // 11  011  1110  0000  001
    ARM64_SYSREG_CNTVCT_EL0        = 0xdf02,  // 11  011  1110  0000  010

    // Trace registers
    ARM64_SYSREG_TRCSTATR          = 0x8818, // 10  001  0000  0011  000
    ARM64_SYSREG_TRCIDR8           = 0x8806, // 10  001  0000  0000  110
    ARM64_SYSREG_TRCIDR9           = 0x880e, // 10  001  0000  0001  110
    ARM64_SYSREG_TRCIDR10          = 0x8816, // 10  001  0000  0010  110
    ARM64_SYSREG_TRCIDR11          = 0x881e, // 10  001  0000  0011  110
    ARM64_SYSREG_TRCIDR12          = 0x8826, // 10  001  0000  0100  110
    ARM64_SYSREG_TRCIDR13          = 0x882e, // 10  001  0000  0101  110
    ARM64_SYSREG_TRCIDR0           = 0x8847, // 10  001  0000  1000  111
    ARM64_SYSREG_TRCIDR1           = 0x884f, // 10  001  0000  1001  111
    ARM64_SYSREG_TRCIDR2           = 0x8857, // 10  001  0000  1010  111
    ARM64_SYSREG_TRCIDR3           = 0x885f, // 10  001  0000  1011  111
    ARM64_SYSREG_TRCIDR4           = 0x8867, // 10  001  0000  1100  111
    ARM64_SYSREG_TRCIDR5           = 0x886f, // 10  001  0000  1101  111
    ARM64_SYSREG_TRCIDR6           = 0x8877, // 10  001  0000  1110  111
    ARM64_SYSREG_TRCIDR7           = 0x887f, // 10  001  0000  1111  111
    ARM64_SYSREG_TRCOSLSR          = 0x888c, // 10  001  0001  0001  100
    ARM64_SYSREG_TRCPDSR           = 0x88ac, // 10  001  0001  0101  100
    ARM64_SYSREG_TRCDEVAFF0        = 0x8bd6, // 10  001  0111  1010  110
    ARM64_SYSREG_TRCDEVAFF1        = 0x8bde, // 10  001  0111  1011  110
    ARM64_SYSREG_TRCLSR            = 0x8bee, // 10  001  0111  1101  110
    ARM64_SYSREG_TRCAUTHSTATUS     = 0x8bf6, // 10  001  0111  1110  110
    ARM64_SYSREG_TRCDEVARCH        = 0x8bfe, // 10  001  0111  1111  110
    ARM64_SYSREG_TRCDEVID          = 0x8b97, // 10  001  0111  0010  111
    ARM64_SYSREG_TRCDEVTYPE        = 0x8b9f, // 10  001  0111  0011  111
    ARM64_SYSREG_TRCPIDR4          = 0x8ba7, // 10  001  0111  0100  111
    ARM64_SYSREG_TRCPIDR5          = 0x8baf, // 10  001  0111  0101  111
    ARM64_SYSREG_TRCPIDR6          = 0x8bb7, // 10  001  0111  0110  111
    ARM64_SYSREG_TRCPIDR7          = 0x8bbf, // 10  001  0111  0111  111
    ARM64_SYSREG_TRCPIDR0          = 0x8bc7, // 10  001  0111  1000  111
    ARM64_SYSREG_TRCPIDR1          = 0x8bcf, // 10  001  0111  1001  111
    ARM64_SYSREG_TRCPIDR2          = 0x8bd7, // 10  001  0111  1010  111
    ARM64_SYSREG_TRCPIDR3          = 0x8bdf, // 10  001  0111  1011  111
    ARM64_SYSREG_TRCCIDR0          = 0x8be7, // 10  001  0111  1100  111
    ARM64_SYSREG_TRCCIDR1          = 0x8bef, // 10  001  0111  1101  111
    ARM64_SYSREG_TRCCIDR2          = 0x8bf7, // 10  001  0111  1110  111
    ARM64_SYSREG_TRCCIDR3          = 0x8bff, // 10  001  0111  1111  111

    // GICv3 registers
    ARM64_SYSREG_ICC_IAR1_EL1      = 0xc660, // 11  000  1100  1100  000
    ARM64_SYSREG_ICC_IAR0_EL1      = 0xc640, // 11  000  1100  1000  000
    ARM64_SYSREG_ICC_HPPIR1_EL1    = 0xc662, // 11  000  1100  1100  010
    ARM64_SYSREG_ICC_HPPIR0_EL1    = 0xc642, // 11  000  1100  1000  010
    ARM64_SYSREG_ICC_RPR_EL1       = 0xc65b, // 11  000  1100  1011  011
    ARM64_SYSREG_ICH_VTR_EL2       = 0xe659, // 11  100  1100  1011  001
    ARM64_SYSREG_ICH_EISR_EL2      = 0xe65b, // 11  100  1100  1011  011
    ARM64_SYSREG_ICH_ELSR_EL2      = 0xe65d, // 11  100  1100  1011  101
} arm64_sysreg;

typedef enum arm64_msr_reg
{
    //> System registers for MSR
    ARM64_SYSREG_DBGDTRTX_EL0      = 0x9828, // 10  011  0000  0101  000
    ARM64_SYSREG_OSLAR_EL1         = 0x8084, // 10  000  0001  0000  100
    ARM64_SYSREG_PMSWINC_EL0       = 0xdce4,  // 11  011  1001  1100  100

    // Trace Registers
    ARM64_SYSREG_TRCOSLAR          = 0x8884, // 10  001  0001  0000  100
    ARM64_SYSREG_TRCLAR            = 0x8be6, // 10  001  0111  1100  110

    // GICv3 registers
    ARM64_SYSREG_ICC_EOIR1_EL1     = 0xc661, // 11  000  1100  1100  001
    ARM64_SYSREG_ICC_EOIR0_EL1     = 0xc641, // 11  000  1100  1000  001
    ARM64_SYSREG_ICC_DIR_EL1       = 0xc659, // 11  000  1100  1011  001
    ARM64_SYSREG_ICC_SGI1R_EL1     = 0xc65d, // 11  000  1100  1011  101
    ARM64_SYSREG_ICC_ASGI1R_EL1    = 0xc65e, // 11  000  1100  1011  110
    ARM64_SYSREG_ICC_SGI0R_EL1     = 0xc65f, // 11  000  1100  1011  111
} arm64_msr_reg;

//> System PState Field (MSR instruction)
typedef enum arm64_pstate
{
    ARM64_PSTATE_INVALID = 0,
    ARM64_PSTATE_SPSEL = 0x05,
    ARM64_PSTATE_DAIFSET = 0x1e,
    ARM64_PSTATE_DAIFCLR = 0x1f
} arm64_pstate;

//> Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)
typedef enum arm64_vas
{
    ARM64_VAS_INVALID = 0,
    ARM64_VAS_8B,
    ARM64_VAS_16B,
    ARM64_VAS_4H,
    ARM64_VAS_8H,
    ARM64_VAS_2S,
    ARM64_VAS_4S,
    ARM64_VAS_1D,
    ARM64_VAS_2D,
    ARM64_VAS_1Q,
} arm64_vas;

//> Vector element size specifier
typedef enum arm64_vess
{
    ARM64_VESS_INVALID = 0,
    ARM64_VESS_B,
    ARM64_VESS_H,
    ARM64_VESS_S,
    ARM64_VESS_D,
} arm64_vess;

//> Memory barrier operands
typedef enum arm64_barrier_op
{
    ARM64_BARRIER_INVALID = 0,
    ARM64_BARRIER_OSHLD = 0x1,
    ARM64_BARRIER_OSHST = 0x2,
    ARM64_BARRIER_OSH =   0x3,
    ARM64_BARRIER_NSHLD = 0x5,
    ARM64_BARRIER_NSHST = 0x6,
    ARM64_BARRIER_NSH =   0x7,
    ARM64_BARRIER_ISHLD = 0x9,
    ARM64_BARRIER_ISHST = 0xa,
    ARM64_BARRIER_ISH =   0xb,
    ARM64_BARRIER_LD =    0xd,
    ARM64_BARRIER_ST =    0xe,
    ARM64_BARRIER_SY =    0xf
} arm64_barrier_op;

//> Operand type for instruction's operands
typedef enum arm64_op_type
{
    ARM64_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    ARM64_OP_REG, // = CS_OP_REG (Register operand).
    ARM64_OP_IMM, // = CS_OP_IMM (Immediate operand).
    ARM64_OP_MEM, // = CS_OP_MEM (Memory operand).
    ARM64_OP_FP,  // = CS_OP_FP (Floating-Point operand).
    ARM64_OP_CIMM = 64, // C-Immediate
    ARM64_OP_REG_MRS, // MRS register operand.
    ARM64_OP_REG_MSR, // MSR register operand.
    ARM64_OP_PSTATE, // PState operand.
    ARM64_OP_SYS, // SYS operand for IC/DC/AT/TLBI instructions.
    ARM64_OP_PREFETCH, // Prefetch operand (PRFM).
    ARM64_OP_BARRIER, // Memory barrier operand (ISB/DMB/DSB instructions).
} arm64_op_type;

//> TLBI operations
typedef enum arm64_tlbi_op
{
    ARM64_TLBI_INVALID = 0,
    ARM64_TLBI_VMALLE1IS,
    ARM64_TLBI_VAE1IS,
    ARM64_TLBI_ASIDE1IS,
    ARM64_TLBI_VAAE1IS,
    ARM64_TLBI_VALE1IS,
    ARM64_TLBI_VAALE1IS,
    ARM64_TLBI_ALLE2IS,
    ARM64_TLBI_VAE2IS,
    ARM64_TLBI_ALLE1IS,
    ARM64_TLBI_VALE2IS,
    ARM64_TLBI_VMALLS12E1IS,
    ARM64_TLBI_ALLE3IS,
    ARM64_TLBI_VAE3IS,
    ARM64_TLBI_VALE3IS,
    ARM64_TLBI_IPAS2E1IS,
    ARM64_TLBI_IPAS2LE1IS,
    ARM64_TLBI_IPAS2E1,
    ARM64_TLBI_IPAS2LE1,
    ARM64_TLBI_VMALLE1,
    ARM64_TLBI_VAE1,
    ARM64_TLBI_ASIDE1,
    ARM64_TLBI_VAAE1,
    ARM64_TLBI_VALE1,
    ARM64_TLBI_VAALE1,
    ARM64_TLBI_ALLE2,
    ARM64_TLBI_VAE2,
    ARM64_TLBI_ALLE1,
    ARM64_TLBI_VALE2,
    ARM64_TLBI_VMALLS12E1,
    ARM64_TLBI_ALLE3,
    ARM64_TLBI_VAE3,
    ARM64_TLBI_VALE3,
} arm64_tlbi_op;

//> AT operations
typedef enum arm64_at_op
{
    ARM64_AT_S1E1R,
    ARM64_AT_S1E1W,
    ARM64_AT_S1E0R,
    ARM64_AT_S1E0W,
    ARM64_AT_S1E2R,
    ARM64_AT_S1E2W,
    ARM64_AT_S12E1R,
    ARM64_AT_S12E1W,
    ARM64_AT_S12E0R,
    ARM64_AT_S12E0W,
    ARM64_AT_S1E3R,
    ARM64_AT_S1E3W,
} arm64_at_op;

//> DC operations
typedef enum arm64_dc_op
{
    ARM64_DC_INVALID = 0,
    ARM64_DC_ZVA,
    ARM64_DC_IVAC,
    ARM64_DC_ISW,
    ARM64_DC_CVAC,
    ARM64_DC_CSW,
    ARM64_DC_CVAU,
    ARM64_DC_CIVAC,
    ARM64_DC_CISW,
} arm64_dc_op;

//> IC operations
typedef enum arm64_ic_op
{
    ARM64_IC_INVALID = 0,
    ARM64_IC_IALLUIS,
    ARM64_IC_IALLU,
    ARM64_IC_IVAU,
} arm64_ic_op;

//> Prefetch operations (PRFM)
typedef enum arm64_prefetch_op
{
    ARM64_PRFM_INVALID = 0,
    ARM64_PRFM_PLDL1KEEP = 0x00 + 1,
    ARM64_PRFM_PLDL1STRM = 0x01 + 1,
    ARM64_PRFM_PLDL2KEEP = 0x02 + 1,
    ARM64_PRFM_PLDL2STRM = 0x03 + 1,
    ARM64_PRFM_PLDL3KEEP = 0x04 + 1,
    ARM64_PRFM_PLDL3STRM = 0x05 + 1,
    ARM64_PRFM_PLIL1KEEP = 0x08 + 1,
    ARM64_PRFM_PLIL1STRM = 0x09 + 1,
    ARM64_PRFM_PLIL2KEEP = 0x0a + 1,
    ARM64_PRFM_PLIL2STRM = 0x0b + 1,
    ARM64_PRFM_PLIL3KEEP = 0x0c + 1,
    ARM64_PRFM_PLIL3STRM = 0x0d + 1,
    ARM64_PRFM_PSTL1KEEP = 0x10 + 1,
    ARM64_PRFM_PSTL1STRM = 0x11 + 1,
    ARM64_PRFM_PSTL2KEEP = 0x12 + 1,
    ARM64_PRFM_PSTL2STRM = 0x13 + 1,
    ARM64_PRFM_PSTL3KEEP = 0x14 + 1,
    ARM64_PRFM_PSTL3STRM = 0x15 + 1,
} arm64_prefetch_op;


//> ARM64 registers
typedef enum arm64_reg
{
    ARM64_REG_INVALID = 0,

    ARM64_REG_X29,
    ARM64_REG_X30,
    ARM64_REG_NZCV,
    ARM64_REG_SP,
    ARM64_REG_WSP,
    ARM64_REG_WZR,
    ARM64_REG_XZR,
    ARM64_REG_B0,
    ARM64_REG_B1,
    ARM64_REG_B2,
    ARM64_REG_B3,
    ARM64_REG_B4,
    ARM64_REG_B5,
    ARM64_REG_B6,
    ARM64_REG_B7,
    ARM64_REG_B8,
    ARM64_REG_B9,
    ARM64_REG_B10,
    ARM64_REG_B11,
    ARM64_REG_B12,
    ARM64_REG_B13,
    ARM64_REG_B14,
    ARM64_REG_B15,
    ARM64_REG_B16,
    ARM64_REG_B17,
    ARM64_REG_B18,
    ARM64_REG_B19,
    ARM64_REG_B20,
    ARM64_REG_B21,
    ARM64_REG_B22,
    ARM64_REG_B23,
    ARM64_REG_B24,
    ARM64_REG_B25,
    ARM64_REG_B26,
    ARM64_REG_B27,
    ARM64_REG_B28,
    ARM64_REG_B29,
    ARM64_REG_B30,
    ARM64_REG_B31,
    ARM64_REG_D0,
    ARM64_REG_D1,
    ARM64_REG_D2,
    ARM64_REG_D3,
    ARM64_REG_D4,
    ARM64_REG_D5,
    ARM64_REG_D6,
    ARM64_REG_D7,
    ARM64_REG_D8,
    ARM64_REG_D9,
    ARM64_REG_D10,
    ARM64_REG_D11,
    ARM64_REG_D12,
    ARM64_REG_D13,
    ARM64_REG_D14,
    ARM64_REG_D15,
    ARM64_REG_D16,
    ARM64_REG_D17,
    ARM64_REG_D18,
    ARM64_REG_D19,
    ARM64_REG_D20,
    ARM64_REG_D21,
    ARM64_REG_D22,
    ARM64_REG_D23,
    ARM64_REG_D24,
    ARM64_REG_D25,
    ARM64_REG_D26,
    ARM64_REG_D27,
    ARM64_REG_D28,
    ARM64_REG_D29,
    ARM64_REG_D30,
    ARM64_REG_D31,
    ARM64_REG_H0,
    ARM64_REG_H1,
    ARM64_REG_H2,
    ARM64_REG_H3,
    ARM64_REG_H4,
    ARM64_REG_H5,
    ARM64_REG_H6,
    ARM64_REG_H7,
    ARM64_REG_H8,
    ARM64_REG_H9,
    ARM64_REG_H10,
    ARM64_REG_H11,
    ARM64_REG_H12,
    ARM64_REG_H13,
    ARM64_REG_H14,
    ARM64_REG_H15,
    ARM64_REG_H16,
    ARM64_REG_H17,
    ARM64_REG_H18,
    ARM64_REG_H19,
    ARM64_REG_H20,
    ARM64_REG_H21,
    ARM64_REG_H22,
    ARM64_REG_H23,
    ARM64_REG_H24,
    ARM64_REG_H25,
    ARM64_REG_H26,
    ARM64_REG_H27,
    ARM64_REG_H28,
    ARM64_REG_H29,
    ARM64_REG_H30,
    ARM64_REG_H31,
    ARM64_REG_Q0,
    ARM64_REG_Q1,
    ARM64_REG_Q2,
    ARM64_REG_Q3,
    ARM64_REG_Q4,
    ARM64_REG_Q5,
    ARM64_REG_Q6,
    ARM64_REG_Q7,
    ARM64_REG_Q8,
    ARM64_REG_Q9,
    ARM64_REG_Q10,
    ARM64_REG_Q11,
    ARM64_REG_Q12,
    ARM64_REG_Q13,
    ARM64_REG_Q14,
    ARM64_REG_Q15,
    ARM64_REG_Q16,
    ARM64_REG_Q17,
    ARM64_REG_Q18,
    ARM64_REG_Q19,
    ARM64_REG_Q20,
    ARM64_REG_Q21,
    ARM64_REG_Q22,
    ARM64_REG_Q23,
    ARM64_REG_Q24,
    ARM64_REG_Q25,
    ARM64_REG_Q26,
    ARM64_REG_Q27,
    ARM64_REG_Q28,
    ARM64_REG_Q29,
    ARM64_REG_Q30,
    ARM64_REG_Q31,
    ARM64_REG_S0,
    ARM64_REG_S1,
    ARM64_REG_S2,
    ARM64_REG_S3,
    ARM64_REG_S4,
    ARM64_REG_S5,
    ARM64_REG_S6,
    ARM64_REG_S7,
    ARM64_REG_S8,
    ARM64_REG_S9,
    ARM64_REG_S10,
    ARM64_REG_S11,
    ARM64_REG_S12,
    ARM64_REG_S13,
    ARM64_REG_S14,
    ARM64_REG_S15,
    ARM64_REG_S16,
    ARM64_REG_S17,
    ARM64_REG_S18,
    ARM64_REG_S19,
    ARM64_REG_S20,
    ARM64_REG_S21,
    ARM64_REG_S22,
    ARM64_REG_S23,
    ARM64_REG_S24,
    ARM64_REG_S25,
    ARM64_REG_S26,
    ARM64_REG_S27,
    ARM64_REG_S28,
    ARM64_REG_S29,
    ARM64_REG_S30,
    ARM64_REG_S31,
    ARM64_REG_W0,
    ARM64_REG_W1,
    ARM64_REG_W2,
    ARM64_REG_W3,
    ARM64_REG_W4,
    ARM64_REG_W5,
    ARM64_REG_W6,
    ARM64_REG_W7,
    ARM64_REG_W8,
    ARM64_REG_W9,
    ARM64_REG_W10,
    ARM64_REG_W11,
    ARM64_REG_W12,
    ARM64_REG_W13,
    ARM64_REG_W14,
    ARM64_REG_W15,
    ARM64_REG_W16,
    ARM64_REG_W17,
    ARM64_REG_W18,
    ARM64_REG_W19,
    ARM64_REG_W20,
    ARM64_REG_W21,
    ARM64_REG_W22,
    ARM64_REG_W23,
    ARM64_REG_W24,
    ARM64_REG_W25,
    ARM64_REG_W26,
    ARM64_REG_W27,
    ARM64_REG_W28,
    ARM64_REG_W29,
    ARM64_REG_W30,
    ARM64_REG_X0,
    ARM64_REG_X1,
    ARM64_REG_X2,
    ARM64_REG_X3,
    ARM64_REG_X4,
    ARM64_REG_X5,
    ARM64_REG_X6,
    ARM64_REG_X7,
    ARM64_REG_X8,
    ARM64_REG_X9,
    ARM64_REG_X10,
    ARM64_REG_X11,
    ARM64_REG_X12,
    ARM64_REG_X13,
    ARM64_REG_X14,
    ARM64_REG_X15,
    ARM64_REG_X16,
    ARM64_REG_X17,
    ARM64_REG_X18,
    ARM64_REG_X19,
    ARM64_REG_X20,
    ARM64_REG_X21,
    ARM64_REG_X22,
    ARM64_REG_X23,
    ARM64_REG_X24,
    ARM64_REG_X25,
    ARM64_REG_X26,
    ARM64_REG_X27,
    ARM64_REG_X28,

    ARM64_REG_V0,
    ARM64_REG_V1,
    ARM64_REG_V2,
    ARM64_REG_V3,
    ARM64_REG_V4,
    ARM64_REG_V5,
    ARM64_REG_V6,
    ARM64_REG_V7,
    ARM64_REG_V8,
    ARM64_REG_V9,
    ARM64_REG_V10,
    ARM64_REG_V11,
    ARM64_REG_V12,
    ARM64_REG_V13,
    ARM64_REG_V14,
    ARM64_REG_V15,
    ARM64_REG_V16,
    ARM64_REG_V17,
    ARM64_REG_V18,
    ARM64_REG_V19,
    ARM64_REG_V20,
    ARM64_REG_V21,
    ARM64_REG_V22,
    ARM64_REG_V23,
    ARM64_REG_V24,
    ARM64_REG_V25,
    ARM64_REG_V26,
    ARM64_REG_V27,
    ARM64_REG_V28,
    ARM64_REG_V29,
    ARM64_REG_V30,
    ARM64_REG_V31,

    ARM64_REG_ENDING,       // <-- mark the end of the list of registers

    //> alias registers

    ARM64_REG_IP1 = ARM64_REG_X16,
    ARM64_REG_IP0 = ARM64_REG_X17,
    ARM64_REG_FP = ARM64_REG_X29,
    ARM64_REG_LR = ARM64_REG_X30,
} arm64_reg;

// Instruction's operand referring to memory
// This is associated with ARM64_OP_MEM operand type above
typedef struct arm64_op_mem
{
    arm64_reg base; // base register
    arm64_reg index;    // index register
    int32_t disp;   // displacement/offset value
} arm64_op_mem;

// Instruction operand
typedef struct cs_arm64_op
{
    int vector_index;   // Vector Index for some vector operands (or -1 if irrelevant)
    arm64_vas vas;      // Vector Arrangement Specifier
    arm64_vess vess;    // Vector Element Size Specifier
    struct
    {
        arm64_shifter type; // shifter type of this operand
        unsigned int value; // shifter value of this operand
    } shift;
    arm64_extender ext;     // extender type of this operand
    arm64_op_type type; // operand type
    union
    {
        arm64_reg reg;  // register value for REG operand
        int64_t imm;        // immediate value, or index for C-IMM or IMM operand
        double fp;          // floating point value for FP operand
        arm64_op_mem mem;       // base/index/scale/disp value for MEM operand
        arm64_pstate pstate;        // PState field of MSR instruction.
        unsigned int sys;  // IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)
        arm64_prefetch_op prefetch;  // PRFM operation.
        arm64_barrier_op barrier;  // Memory barrier operation (ISB/DMB/DSB instructions).
    };

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;
} cs_arm64_op;

// Instruction structure
typedef struct cs_arm64
{
    arm64_cc cc;    // conditional code for this insn
    bool update_flags;  // does this insn update flags?
    bool writeback; // does this insn request writeback? 'True' means 'yes'

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_arm64_op operands[8]; // operands for this instruction.
} cs_arm64;

//> ARM64 instruction
typedef enum arm64_insn
{
    ARM64_INS_INVALID = 0,

    ARM64_INS_ABS,
    ARM64_INS_ADC,
    ARM64_INS_ADDHN,
    ARM64_INS_ADDHN2,
    ARM64_INS_ADDP,
    ARM64_INS_ADD,
    ARM64_INS_ADDV,
    ARM64_INS_ADR,
    ARM64_INS_ADRP,
    ARM64_INS_AESD,
    ARM64_INS_AESE,
    ARM64_INS_AESIMC,
    ARM64_INS_AESMC,
    ARM64_INS_AND,
    ARM64_INS_ASR,
    ARM64_INS_B,
    ARM64_INS_BFM,
    ARM64_INS_BIC,
    ARM64_INS_BIF,
    ARM64_INS_BIT,
    ARM64_INS_BL,
    ARM64_INS_BLR,
    ARM64_INS_BR,
    ARM64_INS_BRK,
    ARM64_INS_BSL,
    ARM64_INS_CBNZ,
    ARM64_INS_CBZ,
    ARM64_INS_CCMN,
    ARM64_INS_CCMP,
    ARM64_INS_CLREX,
    ARM64_INS_CLS,
    ARM64_INS_CLZ,
    ARM64_INS_CMEQ,
    ARM64_INS_CMGE,
    ARM64_INS_CMGT,
    ARM64_INS_CMHI,
    ARM64_INS_CMHS,
    ARM64_INS_CMLE,
    ARM64_INS_CMLT,
    ARM64_INS_CMTST,
    ARM64_INS_CNT,
    ARM64_INS_MOV,
    ARM64_INS_CRC32B,
    ARM64_INS_CRC32CB,
    ARM64_INS_CRC32CH,
    ARM64_INS_CRC32CW,
    ARM64_INS_CRC32CX,
    ARM64_INS_CRC32H,
    ARM64_INS_CRC32W,
    ARM64_INS_CRC32X,
    ARM64_INS_CSEL,
    ARM64_INS_CSINC,
    ARM64_INS_CSINV,
    ARM64_INS_CSNEG,
    ARM64_INS_DCPS1,
    ARM64_INS_DCPS2,
    ARM64_INS_DCPS3,
    ARM64_INS_DMB,
    ARM64_INS_DRPS,
    ARM64_INS_DSB,
    ARM64_INS_DUP,
    ARM64_INS_EON,
    ARM64_INS_EOR,
    ARM64_INS_ERET,
    ARM64_INS_EXTR,
    ARM64_INS_EXT,
    ARM64_INS_FABD,
    ARM64_INS_FABS,
    ARM64_INS_FACGE,
    ARM64_INS_FACGT,
    ARM64_INS_FADD,
    ARM64_INS_FADDP,
    ARM64_INS_FCCMP,
    ARM64_INS_FCCMPE,
    ARM64_INS_FCMEQ,
    ARM64_INS_FCMGE,
    ARM64_INS_FCMGT,
    ARM64_INS_FCMLE,
    ARM64_INS_FCMLT,
    ARM64_INS_FCMP,
    ARM64_INS_FCMPE,
    ARM64_INS_FCSEL,
    ARM64_INS_FCVTAS,
    ARM64_INS_FCVTAU,
    ARM64_INS_FCVT,
    ARM64_INS_FCVTL,
    ARM64_INS_FCVTL2,
    ARM64_INS_FCVTMS,
    ARM64_INS_FCVTMU,
    ARM64_INS_FCVTNS,
    ARM64_INS_FCVTNU,
    ARM64_INS_FCVTN,
    ARM64_INS_FCVTN2,
    ARM64_INS_FCVTPS,
    ARM64_INS_FCVTPU,
    ARM64_INS_FCVTXN,
    ARM64_INS_FCVTXN2,
    ARM64_INS_FCVTZS,
    ARM64_INS_FCVTZU,
    ARM64_INS_FDIV,
    ARM64_INS_FMADD,
    ARM64_INS_FMAX,
    ARM64_INS_FMAXNM,
    ARM64_INS_FMAXNMP,
    ARM64_INS_FMAXNMV,
    ARM64_INS_FMAXP,
    ARM64_INS_FMAXV,
    ARM64_INS_FMIN,
    ARM64_INS_FMINNM,
    ARM64_INS_FMINNMP,
    ARM64_INS_FMINNMV,
    ARM64_INS_FMINP,
    ARM64_INS_FMINV,
    ARM64_INS_FMLA,
    ARM64_INS_FMLS,
    ARM64_INS_FMOV,
    ARM64_INS_FMSUB,
    ARM64_INS_FMUL,
    ARM64_INS_FMULX,
    ARM64_INS_FNEG,
    ARM64_INS_FNMADD,
    ARM64_INS_FNMSUB,
    ARM64_INS_FNMUL,
    ARM64_INS_FRECPE,
    ARM64_INS_FRECPS,
    ARM64_INS_FRECPX,
    ARM64_INS_FRINTA,
    ARM64_INS_FRINTI,
    ARM64_INS_FRINTM,
    ARM64_INS_FRINTN,
    ARM64_INS_FRINTP,
    ARM64_INS_FRINTX,
    ARM64_INS_FRINTZ,
    ARM64_INS_FRSQRTE,
    ARM64_INS_FRSQRTS,
    ARM64_INS_FSQRT,
    ARM64_INS_FSUB,
    ARM64_INS_HINT,
    ARM64_INS_HLT,
    ARM64_INS_HVC,
    ARM64_INS_INS,

    ARM64_INS_ISB,
    ARM64_INS_LD1,
    ARM64_INS_LD1R,
    ARM64_INS_LD2R,
    ARM64_INS_LD2,
    ARM64_INS_LD3R,
    ARM64_INS_LD3,
    ARM64_INS_LD4,
    ARM64_INS_LD4R,

    ARM64_INS_LDARB,
    ARM64_INS_LDARH,
    ARM64_INS_LDAR,
    ARM64_INS_LDAXP,
    ARM64_INS_LDAXRB,
    ARM64_INS_LDAXRH,
    ARM64_INS_LDAXR,
    ARM64_INS_LDNP,
    ARM64_INS_LDP,
    ARM64_INS_LDPSW,
    ARM64_INS_LDRB,
    ARM64_INS_LDR,
    ARM64_INS_LDRH,
    ARM64_INS_LDRSB,
    ARM64_INS_LDRSH,
    ARM64_INS_LDRSW,
    ARM64_INS_LDTRB,
    ARM64_INS_LDTRH,
    ARM64_INS_LDTRSB,

    ARM64_INS_LDTRSH,
    ARM64_INS_LDTRSW,
    ARM64_INS_LDTR,
    ARM64_INS_LDURB,
    ARM64_INS_LDUR,
    ARM64_INS_LDURH,
    ARM64_INS_LDURSB,
    ARM64_INS_LDURSH,
    ARM64_INS_LDURSW,
    ARM64_INS_LDXP,
    ARM64_INS_LDXRB,
    ARM64_INS_LDXRH,
    ARM64_INS_LDXR,
    ARM64_INS_LSL,
    ARM64_INS_LSR,
    ARM64_INS_MADD,
    ARM64_INS_MLA,
    ARM64_INS_MLS,
    ARM64_INS_MOVI,
    ARM64_INS_MOVK,
    ARM64_INS_MOVN,
    ARM64_INS_MOVZ,
    ARM64_INS_MRS,
    ARM64_INS_MSR,
    ARM64_INS_MSUB,
    ARM64_INS_MUL,
    ARM64_INS_MVNI,
    ARM64_INS_NEG,
    ARM64_INS_NOT,
    ARM64_INS_ORN,
    ARM64_INS_ORR,
    ARM64_INS_PMULL2,
    ARM64_INS_PMULL,
    ARM64_INS_PMUL,
    ARM64_INS_PRFM,
    ARM64_INS_PRFUM,
    ARM64_INS_RADDHN,
    ARM64_INS_RADDHN2,
    ARM64_INS_RBIT,
    ARM64_INS_RET,
    ARM64_INS_REV16,
    ARM64_INS_REV32,
    ARM64_INS_REV64,
    ARM64_INS_REV,
    ARM64_INS_ROR,
    ARM64_INS_RSHRN2,
    ARM64_INS_RSHRN,
    ARM64_INS_RSUBHN,
    ARM64_INS_RSUBHN2,
    ARM64_INS_SABAL2,
    ARM64_INS_SABAL,

    ARM64_INS_SABA,
    ARM64_INS_SABDL2,
    ARM64_INS_SABDL,
    ARM64_INS_SABD,
    ARM64_INS_SADALP,
    ARM64_INS_SADDLP,
    ARM64_INS_SADDLV,
    ARM64_INS_SADDL2,
    ARM64_INS_SADDL,
    ARM64_INS_SADDW2,
    ARM64_INS_SADDW,
    ARM64_INS_SBC,
    ARM64_INS_SBFM,
    ARM64_INS_SCVTF,
    ARM64_INS_SDIV,
    ARM64_INS_SHA1C,
    ARM64_INS_SHA1H,
    ARM64_INS_SHA1M,
    ARM64_INS_SHA1P,
    ARM64_INS_SHA1SU0,
    ARM64_INS_SHA1SU1,
    ARM64_INS_SHA256H2,
    ARM64_INS_SHA256H,
    ARM64_INS_SHA256SU0,
    ARM64_INS_SHA256SU1,
    ARM64_INS_SHADD,
    ARM64_INS_SHLL2,
    ARM64_INS_SHLL,
    ARM64_INS_SHL,
    ARM64_INS_SHRN2,
    ARM64_INS_SHRN,
    ARM64_INS_SHSUB,
    ARM64_INS_SLI,
    ARM64_INS_SMADDL,
    ARM64_INS_SMAXP,
    ARM64_INS_SMAXV,
    ARM64_INS_SMAX,
    ARM64_INS_SMC,
    ARM64_INS_SMINP,
    ARM64_INS_SMINV,
    ARM64_INS_SMIN,
    ARM64_INS_SMLAL2,
    ARM64_INS_SMLAL,
    ARM64_INS_SMLSL2,
    ARM64_INS_SMLSL,
    ARM64_INS_SMOV,
    ARM64_INS_SMSUBL,
    ARM64_INS_SMULH,
    ARM64_INS_SMULL2,
    ARM64_INS_SMULL,
    ARM64_INS_SQABS,
    ARM64_INS_SQADD,
    ARM64_INS_SQDMLAL,
    ARM64_INS_SQDMLAL2,
    ARM64_INS_SQDMLSL,
    ARM64_INS_SQDMLSL2,
    ARM64_INS_SQDMULH,
    ARM64_INS_SQDMULL,
    ARM64_INS_SQDMULL2,
    ARM64_INS_SQNEG,
    ARM64_INS_SQRDMULH,
    ARM64_INS_SQRSHL,
    ARM64_INS_SQRSHRN,
    ARM64_INS_SQRSHRN2,
    ARM64_INS_SQRSHRUN,
    ARM64_INS_SQRSHRUN2,
    ARM64_INS_SQSHLU,
    ARM64_INS_SQSHL,
    ARM64_INS_SQSHRN,
    ARM64_INS_SQSHRN2,
    ARM64_INS_SQSHRUN,
    ARM64_INS_SQSHRUN2,
    ARM64_INS_SQSUB,
    ARM64_INS_SQXTN2,
    ARM64_INS_SQXTN,
    ARM64_INS_SQXTUN2,
    ARM64_INS_SQXTUN,
    ARM64_INS_SRHADD,
    ARM64_INS_SRI,
    ARM64_INS_SRSHL,
    ARM64_INS_SRSHR,
    ARM64_INS_SRSRA,
    ARM64_INS_SSHLL2,
    ARM64_INS_SSHLL,
    ARM64_INS_SSHL,
    ARM64_INS_SSHR,
    ARM64_INS_SSRA,
    ARM64_INS_SSUBL2,
    ARM64_INS_SSUBL,
    ARM64_INS_SSUBW2,
    ARM64_INS_SSUBW,
    ARM64_INS_ST1,
    ARM64_INS_ST2,
    ARM64_INS_ST3,
    ARM64_INS_ST4,
    ARM64_INS_STLRB,
    ARM64_INS_STLRH,
    ARM64_INS_STLR,
    ARM64_INS_STLXP,
    ARM64_INS_STLXRB,
    ARM64_INS_STLXRH,
    ARM64_INS_STLXR,
    ARM64_INS_STNP,
    ARM64_INS_STP,
    ARM64_INS_STRB,
    ARM64_INS_STR,
    ARM64_INS_STRH,
    ARM64_INS_STTRB,
    ARM64_INS_STTRH,
    ARM64_INS_STTR,
    ARM64_INS_STURB,
    ARM64_INS_STUR,
    ARM64_INS_STURH,
    ARM64_INS_STXP,
    ARM64_INS_STXRB,
    ARM64_INS_STXRH,
    ARM64_INS_STXR,
    ARM64_INS_SUBHN,
    ARM64_INS_SUBHN2,
    ARM64_INS_SUB,
    ARM64_INS_SUQADD,
    ARM64_INS_SVC,
    ARM64_INS_SYSL,
    ARM64_INS_SYS,
    ARM64_INS_TBL,
    ARM64_INS_TBNZ,
    ARM64_INS_TBX,
    ARM64_INS_TBZ,
    ARM64_INS_TRN1,
    ARM64_INS_TRN2,
    ARM64_INS_UABAL2,
    ARM64_INS_UABAL,
    ARM64_INS_UABA,
    ARM64_INS_UABDL2,
    ARM64_INS_UABDL,
    ARM64_INS_UABD,
    ARM64_INS_UADALP,
    ARM64_INS_UADDLP,
    ARM64_INS_UADDLV,
    ARM64_INS_UADDL2,
    ARM64_INS_UADDL,
    ARM64_INS_UADDW2,
    ARM64_INS_UADDW,
    ARM64_INS_UBFM,
    ARM64_INS_UCVTF,
    ARM64_INS_UDIV,
    ARM64_INS_UHADD,
    ARM64_INS_UHSUB,
    ARM64_INS_UMADDL,
    ARM64_INS_UMAXP,
    ARM64_INS_UMAXV,
    ARM64_INS_UMAX,
    ARM64_INS_UMINP,
    ARM64_INS_UMINV,
    ARM64_INS_UMIN,
    ARM64_INS_UMLAL2,
    ARM64_INS_UMLAL,
    ARM64_INS_UMLSL2,
    ARM64_INS_UMLSL,
    ARM64_INS_UMOV,
    ARM64_INS_UMSUBL,
    ARM64_INS_UMULH,
    ARM64_INS_UMULL2,
    ARM64_INS_UMULL,
    ARM64_INS_UQADD,
    ARM64_INS_UQRSHL,
    ARM64_INS_UQRSHRN,
    ARM64_INS_UQRSHRN2,
    ARM64_INS_UQSHL,
    ARM64_INS_UQSHRN,
    ARM64_INS_UQSHRN2,
    ARM64_INS_UQSUB,
    ARM64_INS_UQXTN2,
    ARM64_INS_UQXTN,
    ARM64_INS_URECPE,
    ARM64_INS_URHADD,
    ARM64_INS_URSHL,
    ARM64_INS_URSHR,
    ARM64_INS_URSQRTE,
    ARM64_INS_URSRA,
    ARM64_INS_USHLL2,
    ARM64_INS_USHLL,
    ARM64_INS_USHL,
    ARM64_INS_USHR,
    ARM64_INS_USQADD,
    ARM64_INS_USRA,
    ARM64_INS_USUBL2,
    ARM64_INS_USUBL,
    ARM64_INS_USUBW2,
    ARM64_INS_USUBW,
    ARM64_INS_UZP1,
    ARM64_INS_UZP2,
    ARM64_INS_XTN2,
    ARM64_INS_XTN,
    ARM64_INS_ZIP1,
    ARM64_INS_ZIP2,

    // alias insn
    ARM64_INS_MNEG,
    ARM64_INS_UMNEGL,
    ARM64_INS_SMNEGL,
    ARM64_INS_NOP,
    ARM64_INS_YIELD,
    ARM64_INS_WFE,
    ARM64_INS_WFI,
    ARM64_INS_SEV,
    ARM64_INS_SEVL,
    ARM64_INS_NGC,
    ARM64_INS_SBFIZ,
    ARM64_INS_UBFIZ,
    ARM64_INS_SBFX,
    ARM64_INS_UBFX,
    ARM64_INS_BFI,
    ARM64_INS_BFXIL,
    ARM64_INS_CMN,
    ARM64_INS_MVN,
    ARM64_INS_TST,
    ARM64_INS_CSET,
    ARM64_INS_CINC,
    ARM64_INS_CSETM,
    ARM64_INS_CINV,
    ARM64_INS_CNEG,
    ARM64_INS_SXTB,
    ARM64_INS_SXTH,
    ARM64_INS_SXTW,
    ARM64_INS_CMP,
    ARM64_INS_UXTB,
    ARM64_INS_UXTH,
    ARM64_INS_UXTW,
    ARM64_INS_IC,
    ARM64_INS_DC,
    ARM64_INS_AT,
    ARM64_INS_TLBI,

    ARM64_INS_NEGS,
    ARM64_INS_NGCS,

    ARM64_INS_ENDING,  // <-- mark the end of the list of insn
} arm64_insn;

//> Group of ARM64 instructions
typedef enum arm64_insn_group
{
    ARM64_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    ARM64_GRP_JUMP, // = CS_GRP_JUMP
    ARM64_GRP_CALL,
    ARM64_GRP_RET,
    ARM64_GRP_INT,
    ARM64_GRP_PRIVILEGE = 6, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    ARM64_GRP_CRYPTO = 128,
    ARM64_GRP_FPARMV8,
    ARM64_GRP_NEON,
    ARM64_GRP_CRC,

    ARM64_GRP_ENDING,  // <-- mark the end of the list of groups
} arm64_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/capstone.h
================================================
#ifndef CAPSTONE_ENGINE_H
#define CAPSTONE_ENGINE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

#if defined(CAPSTONE_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#define CAPSTONE_API __cdecl
#ifdef CAPSTONE_SHARED
#define CAPSTONE_EXPORT __declspec(dllexport)
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#else
#define CAPSTONE_API
#ifdef __GNUC__
#define CAPSTONE_EXPORT __attribute__((visibility("default")))
#else
#define CAPSTONE_EXPORT
#endif
#endif

#ifdef __GNUC__
#define CAPSTONE_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define CAPSTONE_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement CAPSTONE_DEPRECATED for this compiler")
#define CAPSTONE_DEPRECATED
#endif

// Capstone API version
#define CS_API_MAJOR 4
#define CS_API_MINOR 0

// Version for bleeding edge code of the Github's "next" branch.
// Use this if you want the absolutely latest developement code.
// This version number will be bumped up whenever we have a new major change.
#define CS_NEXT_VERSION 4

// Capstone package version
#define CS_VERSION_MAJOR CS_API_MAJOR
#define CS_VERSION_MINOR CS_API_MINOR
#define CS_VERSION_EXTRA 0

// Macro to create combined version which can be compared to
// result of cs_version() API.
#define CS_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Maximum size of an instruction mnemonic string.
#define CS_MNEMONIC_SIZE 32

// Handle using with all API
typedef size_t csh;

// Architecture type
typedef enum cs_arch
{
    CS_ARCH_ARM = 0,    // ARM architecture (including Thumb, Thumb-2)
    CS_ARCH_ARM64,      // ARM-64, also called AArch64
    CS_ARCH_MIPS,       // Mips architecture
    CS_ARCH_X86,        // X86 architecture (including x86 & x86-64)
    CS_ARCH_PPC,        // PowerPC architecture
    CS_ARCH_SPARC,      // Sparc architecture
    CS_ARCH_SYSZ,       // SystemZ architecture
    CS_ARCH_XCORE,      // XCore architecture
    CS_ARCH_M68K,       // 68K architecture
    CS_ARCH_MAX,
    CS_ARCH_ALL = 0xFFFF, // All architectures - for cs_support()
} cs_arch;

// Support value to verify diet mode of the engine.
// If cs_support(CS_SUPPORT_DIET) return True, the engine was compiled
// in diet mode.
#define CS_SUPPORT_DIET (CS_ARCH_ALL + 1)

// Support value to verify X86 reduce mode of the engine.
// If cs_support(CS_SUPPORT_X86_REDUCE) return True, the engine was compiled
// in X86 reduce mode.
#define CS_SUPPORT_X86_REDUCE (CS_ARCH_ALL + 2)

// Mode type
typedef enum cs_mode
{
    CS_MODE_LITTLE_ENDIAN = 0,  // little-endian mode (default mode)
    CS_MODE_ARM = 0,    // 32-bit ARM
    CS_MODE_16 = 1 << 1,    // 16-bit mode (X86)
    CS_MODE_32 = 1 << 2,    // 32-bit mode (X86)
    CS_MODE_64 = 1 << 3,    // 64-bit mode (X86, PPC)
    CS_MODE_THUMB = 1 << 4, // ARM's Thumb mode, including Thumb-2
    CS_MODE_MCLASS = 1 << 5,    // ARM's Cortex-M series
    CS_MODE_V8 = 1 << 6,    // ARMv8 A32 encodings for ARM
    CS_MODE_MICRO = 1 << 4, // MicroMips mode (MIPS)
    CS_MODE_MIPS3 = 1 << 5, // Mips III ISA
    CS_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA
    CS_MODE_V9 = 1 << 4, // SparcV9 mode (Sparc)
    CS_MODE_QPX = 1 << 4, // Quad Processing eXtensions mode (PPC)
    CS_MODE_M68K_000 = 1 << 1, // M68K 68000 mode
    CS_MODE_M68K_010 = 1 << 2, // M68K 68010 mode
    CS_MODE_M68K_020 = 1 << 3, // M68K 68020 mode
    CS_MODE_M68K_030 = 1 << 4, // M68K 68030 mode
    CS_MODE_M68K_040 = 1 << 5, // M68K 68040 mode
    CS_MODE_M68K_060 = 1 << 6, // M68K 68060 mode
    CS_MODE_BIG_ENDIAN = 1 << 31,   // big-endian mode
    CS_MODE_MIPS32 = CS_MODE_32,    // Mips32 ISA (Mips)
    CS_MODE_MIPS64 = CS_MODE_64,    // Mips64 ISA (Mips)
} cs_mode;

typedef void* (CAPSTONE_API* cs_malloc_t)(size_t size);
typedef void* (CAPSTONE_API* cs_calloc_t)(size_t nmemb, size_t size);
typedef void* (CAPSTONE_API* cs_realloc_t)(void* ptr, size_t size);
typedef void (CAPSTONE_API* cs_free_t)(void* ptr);
typedef int (CAPSTONE_API* cs_vsnprintf_t)(char* str, size_t size, const char* format, va_list ap);


// User-defined dynamic memory related functions: malloc/calloc/realloc/free/vsnprintf()
// By default, Capstone uses system's malloc(), calloc(), realloc(), free() & vsnprintf().
typedef struct cs_opt_mem
{
    cs_malloc_t malloc;
    cs_calloc_t calloc;
    cs_realloc_t realloc;
    cs_free_t free;
    cs_vsnprintf_t vsnprintf;
} cs_opt_mem;

// Customize mnemonic for instructions with alternative name.
// To reset existing customized instruction to its default mnemonic,
// call cs_option(CS_OPT_MNEMONIC) again with the same @id and NULL value
// for @mnemonic.
typedef struct cs_opt_mnem
{
    // ID of instruction to be customized.
    unsigned int id;
    // Customized instruction mnemonic.
    const char* mnemonic;
} cs_opt_mnem;

// Runtime option for the disassembled engine
typedef enum cs_opt_type
{
    CS_OPT_INVALID = 0, // No option specified
    CS_OPT_SYNTAX,  // Assembly output syntax
    CS_OPT_DETAIL,  // Break down instruction structure into details
    CS_OPT_MODE,    // Change engine's mode at run-time
    CS_OPT_MEM, // User-defined dynamic memory related functions
    CS_OPT_SKIPDATA, // Skip data when disassembling. Then engine is in SKIPDATA mode.
    CS_OPT_SKIPDATA_SETUP, // Setup user-defined function for SKIPDATA option
    CS_OPT_MNEMONIC, // Customize instruction mnemonic
    CS_OPT_UNSIGNED, // print immediate operands in unsigned form
} cs_opt_type;

// Runtime option value (associated with option type above)
typedef enum cs_opt_value
{
    CS_OPT_OFF = 0,  // Turn OFF an option - default for CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.
    CS_OPT_ON = 3, // Turn ON an option (CS_OPT_DETAIL, CS_OPT_SKIPDATA).
    CS_OPT_SYNTAX_DEFAULT = 0, // Default asm syntax (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_INTEL, // X86 Intel asm syntax - default on X86 (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_ATT,   // X86 ATT asm syntax (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_NOREGNAME, // Prints register name with only number (CS_OPT_SYNTAX)
    CS_OPT_SYNTAX_MASM, // X86 Intel Masm syntax (CS_OPT_SYNTAX).
} cs_opt_value;

//> Common instruction operand types - to be consistent across all architectures.
typedef enum cs_op_type
{
    CS_OP_INVALID = 0,  // uninitialized/invalid operand.
    CS_OP_REG,          // Register operand.
    CS_OP_IMM,          // Immediate operand.
    CS_OP_MEM,          // Memory operand.
    CS_OP_FP,           // Floating-Point operand.
} cs_op_type;

//> Common instruction operand access types - to be consistent across all architectures.
//> It is possible to combine access types, for example: CS_AC_READ | CS_AC_WRITE
typedef enum cs_ac_type
{
    CS_AC_INVALID = 0,        // Uninitialized/invalid access type.
    CS_AC_READ    = 1 << 0,   // Operand read from memory or register.
    CS_AC_WRITE   = 1 << 1,   // Operand write to memory or register.
} cs_ac_type;

//> Common instruction groups - to be consistent across all architectures.
typedef enum cs_group_type
{
    CS_GRP_INVALID = 0,  // uninitialized/invalid group.
    CS_GRP_JUMP,    // all jump instructions (conditional+direct+indirect jumps)
    CS_GRP_CALL,    // all call instructions
    CS_GRP_RET,     // all return instructions
    CS_GRP_INT,     // all interrupt instructions (int+syscall)
    CS_GRP_IRET,    // all interrupt return instructions
    CS_GRP_PRIVILEGE,    // all privileged instructions
} cs_group_type;

/*
 User-defined callback function for SKIPDATA option.
 See tests/test_skipdata.c for sample code demonstrating this API.

 @code: the input buffer containing code to be disassembled.
        This is the same buffer passed to cs_disasm().
 @code_size: size (in bytes) of the above @code buffer.
 @offset: the position of the currently-examining byte in the input
      buffer @code mentioned above.
 @user_data: user-data passed to cs_option() via @user_data field in
      cs_opt_skipdata struct below.

 @return: return number of bytes to skip, or 0 to immediately stop disassembling.
*/
typedef size_t (CAPSTONE_API* cs_skipdata_cb_t)(const uint8_t* code, size_t code_size, size_t offset, void* user_data);

// User-customized setup for SKIPDATA option
typedef struct cs_opt_skipdata
{
    // Capstone considers data to skip as special "instructions".
    // User can specify the string for this instruction's "mnemonic" here.
    // By default (if @mnemonic is NULL), Capstone use ".byte".
    const char* mnemonic;

    // User-defined callback function to be called when Capstone hits data.
    // If the returned value from this callback is positive (>0), Capstone
    // will skip exactly that number of bytes & continue. Otherwise, if
    // the callback returns 0, Capstone stops disassembling and returns
    // immediately from cs_disasm()
    // NOTE: if this callback pointer is NULL, Capstone would skip a number
    // of bytes depending on architectures, as following:
    // Arm:     2 bytes (Thumb mode) or 4 bytes.
    // Arm64:   4 bytes.
    // Mips:    4 bytes.
    // PowerPC: 4 bytes.
    // Sparc:   4 bytes.
    // SystemZ: 2 bytes.
    // X86:     1 bytes.
    // XCore:   2 bytes.
    cs_skipdata_cb_t callback;  // default value is NULL

    // User-defined data to be passed to @callback function pointer.
    void* user_data;
} cs_opt_skipdata;


#include "arm.h"
#include "arm64.h"
#include "m68k.h"
#include "mips.h"
#include "ppc.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"
#include "xcore.h"

// NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON
typedef struct cs_detail
{
    uint16_t regs_read[12]; // list of implicit registers read by this insn
    uint8_t regs_read_count; // number of implicit registers read by this insn

    uint16_t regs_write[20]; // list of implicit registers modified by this insn
    uint8_t regs_write_count; // number of implicit registers modified by this insn

    uint8_t groups[8]; // list of group this instruction belong to
    uint8_t groups_count; // number of groups this insn belongs to

    // Architecture-specific instruction info
    union
    {
        cs_x86 x86; // X86 architecture, including 16-bit, 32-bit & 64-bit mode
        cs_arm64 arm64; // ARM64 architecture (aka AArch64)
        cs_arm arm;     // ARM architecture (including Thumb/Thumb2)
        cs_m68k m68k;   // M68K architecture
        cs_mips mips;   // MIPS architecture
        cs_ppc ppc; // PowerPC architecture
        cs_sparc sparc; // Sparc architecture
        cs_sysz sysz;   // SystemZ architecture
        cs_xcore xcore; // XCore architecture
    };
} cs_detail;

// Detail information of disassembled instruction
typedef struct cs_insn
{
    // Instruction ID (basically a numeric ID for the instruction mnemonic)
    // Find the instruction id in the '[ARCH]_insn' enum in the header file
    // of corresponding architecture, such as 'arm_insn' in arm.h for ARM,
    // 'x86_insn' in x86.h for X86, etc...
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    // NOTE: in Skipdata mode, "data" instruction has 0 for this id field.
    unsigned int id;

    // Address (EIP) of this instruction
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint64_t address;

    // Size of this instruction
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint16_t size;

    // Machine bytes of this instruction, with number of bytes indicated by @size above
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint8_t bytes[16];

    // Ascii text of instruction mnemonic
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    char mnemonic[CS_MNEMONIC_SIZE];

    // Ascii text of instruction operands
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    char op_str[160];

    // Pointer to cs_detail.
    // NOTE: detail pointer is only valid when both requirements below are met:
    // (1) CS_OP_DETAIL = CS_OPT_ON
    // (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)
    //
    // NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer
    //     is not NULL, its content is still irrelevant.
    cs_detail* detail;
} cs_insn;


// Calculate the offset of a disassembled instruction in its buffer, given its position
// in its array of disassembled insn
// NOTE: this macro works with position (>=1), not index
#define CS_INSN_OFFSET(insns, post) (insns[post - 1].address - insns[0].address)


// All type of errors encountered by Capstone API.
// These are values returned by cs_errno()
typedef enum cs_err
{
    CS_ERR_OK = 0,   // No error: everything was fine
    CS_ERR_MEM,      // Out-Of-Memory error: cs_open(), cs_disasm(), cs_disasm_iter()
    CS_ERR_ARCH,     // Unsupported architecture: cs_open()
    CS_ERR_HANDLE,   // Invalid handle: cs_op_count(), cs_op_index()
    CS_ERR_CSH,      // Invalid csh argument: cs_close(), cs_errno(), cs_option()
    CS_ERR_MODE,     // Invalid/unsupported mode: cs_open()
    CS_ERR_OPTION,   // Invalid/unsupported option: cs_option()
    CS_ERR_DETAIL,   // Information is unavailable because detail option is OFF
    CS_ERR_MEMSETUP, // Dynamic memory management uninitialized (see CS_OPT_MEM)
    CS_ERR_VERSION,  // Unsupported version (bindings)
    CS_ERR_DIET,     // Access irrelevant data in "diet" engine
    CS_ERR_SKIPDATA, // Access irrelevant data for "data" instruction in SKIPDATA mode
    CS_ERR_X86_ATT,  // X86 AT&T syntax is unsupported (opt-out at compile time)
    CS_ERR_X86_INTEL, // X86 Intel syntax is unsupported (opt-out at compile time)
    CS_ERR_X86_MASM, // X86 Intel syntax is unsupported (opt-out at compile time)
} cs_err;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
     major & minor versions.
     NOTE: This returned value can be compared with version number made
     with macro CS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
CAPSTONE_EXPORT
unsigned int CAPSTONE_API cs_version(int* major, int* minor);


/*
 This API can be used to either ask for archs supported by this library,
 or check to see if the library was compile with 'diet' option (or called
 in 'diet' mode).

 To check if a particular arch is supported by this library, set @query to
 arch mode (CS_ARCH_* value).
 To verify if this library supports all the archs, use CS_ARCH_ALL.

 To check if this library is in 'diet' mode, set @query to CS_SUPPORT_DIET.

 @return True if this library supports the given arch, or in 'diet' mode.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_support(int query);

/*
 Initialize CS handle: this must be done before any usage of CS.

 @arch: architecture type (CS_ARCH_*)
 @mode: hardware mode. This is combined of CS_MODE_*
 @handle: pointer to handle, which will be updated at return time

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh* handle);

/*
 Close CS handle: MUST do to release the handle when it is not used anymore.
 NOTE: this must be only called when there is no longer usage of Capstone,
 not even access to cs_insn array. The reason is the this API releases some
 cached memory, thus access to any Capstone API after cs_close() might crash
 your application.

 In fact,this API invalidate @handle by ZERO out its value (i.e *handle = 0).

 @handle: pointer to a handle returned by cs_open()

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_close(csh* handle);

/*
 Set option for disassembling engine at runtime

 @handle: handle returned by cs_open()
 @type: type of option to be set
 @value: option value corresponding with @type

 @return: CS_ERR_OK on success, or other value on failure.
 Refer to cs_err enum for detailed error.

 NOTE: in the case of CS_OPT_MEM, handle's value can be anything,
 so that cs_option(handle, CS_OPT_MEM, value) can (i.e must) be called
 even before cs_open()
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);

/*
 Report the last error number when some API function fail.
 Like glibc's errno, cs_errno might not retain its old value once accessed.

 @handle: handle returned by cs_open()

 @return: error code of cs_err enum type (CS_ERR_*, see above)
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_errno(csh handle);


/*
 Return a string describing given error code.

 @code: error code (see CS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
    passed in the argument @code
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_strerror(cs_err code);

/*
 Disassemble binary code, given the code buffer, size, address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain disassembled instruction.
 Resulted instructions will be put into @*insn

 NOTE 1: this API will automatically determine memory needed to contain
 output disassembled instructions in @insn.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, the API cs_disasm_iter() might be a better choice than
 cs_disasm(). The reason is that with cs_disasm(), based on limited available
 memory, we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case @count=0,
 when cs_disasm() runs uncontrollably (until either end of input buffer, or
 when it encounters an invalid instruction).

 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled.
 @code_size: size of the above code buffer.
 @address: address of the first instruction in given raw code buffer.
 @insn: array of instructions filled in by this API.
       NOTE: @insn will be allocated by this function, and should be freed
       with cs_free() API.
 @count: number of instructions to be disassembled, or 0 to get all of them

 @return: the number of successfully disassembled instructions,
 or 0 if this function failed to disassemble the given code

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
size_t CAPSTONE_API cs_disasm(csh handle,
                              const uint8_t* code, size_t code_size,
                              uint64_t address,
                              size_t count,
                              cs_insn** insn);

/*
  Deprecated function - to be retired in the next version!
  Use cs_disasm() instead of cs_disasm_ex()
*/
CAPSTONE_EXPORT
CAPSTONE_DEPRECATED
size_t CAPSTONE_API cs_disasm_ex(csh handle,
                                 const uint8_t* code, size_t code_size,
                                 uint64_t address,
                                 size_t count,
                                 cs_insn** insn);

/*
 Free memory allocated by cs_malloc() or cs_disasm() (argument @insn)

 @insn: pointer returned by @insn argument in cs_disasm() or cs_malloc()
 @count: number of cs_insn structures returned by cs_disasm(), or 1
     to free memory allocated by cs_malloc().
*/
CAPSTONE_EXPORT
void CAPSTONE_API cs_free(cs_insn* insn, size_t count);


/*
 Allocate memory for 1 instruction to be used by cs_disasm_iter().

 @handle: handle returned by cs_open()

 NOTE: when no longer in use, you can reclaim the memory allocated for
 this instruction with cs_free(insn, 1)
*/
CAPSTONE_EXPORT
cs_insn* CAPSTONE_API cs_malloc(csh handle);

/*
 Fast API to disassemble binary code, given the code buffer, size, address
 and number of instructions to be decoded.
 This API put the resulted instruction into a given cache in @insn.
 See tests/test_iter.c for sample code demonstrating this API.

 NOTE 1: this API will update @code, @size & @address to point to the next
 instruction in the input buffer. Therefore, it is convenient to use
 cs_disasm_iter() inside a loop to quickly iterate all the instructions.
 While decoding one instruction at a time can also be achieved with
 cs_disasm(count=1), some benchmarks shown that cs_disasm_iter() can be 30%
 faster on random input.

 NOTE 2: the cache in @insn can be created with cs_malloc() API.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, this API is recommended over cs_disasm(), which
 allocates memory based on the number of instructions to be disassembled.
 The reason is that with cs_disasm(), based on limited available memory,
 we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case
 @count=0, when cs_disasm() runs uncontrollably (until either end of input
 buffer, or when it encounters an invalid instruction).

 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled
 @code_size: size of above code
 @address: address of the first insn in given raw code buffer
 @insn: pointer to instruction to be filled in by this API.

 @return: true if this API successfully decode 1 instruction,
 or false otherwise.

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_disasm_iter(csh handle,
                                 const uint8_t** code, size_t* size,
                                 uint64_t* address, cs_insn* insn);

/*
 Return friendly name of register in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM,
 x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store register name.

 @handle: handle returned by cs_open()
 @reg_id: register id

 @return: string name of the register, or NULL if @reg_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);

/*
 Return friendly name of an instruction in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store instruction name.

 @handle: handle returned by cs_open()
 @insn_id: instruction id

 @return: string name of the instruction, or NULL if @insn_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);

/*
 Return friendly name of a group id (that an instruction can belong to)
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store group name.

 @handle: handle returned by cs_open()
 @group_id: group id

 @return: string name of the group, or NULL if @group_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);

/*
 Check if a disassembled instruction belong to a particular group.
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @group_id matches any member of insn->groups array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default).

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @groups array.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @group_id: group that you want to check if this instruction belong to.

 @return: true if this instruction indeed belongs to aboved group, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn* insn, unsigned int group_id);

/*
 Check if a disassembled instruction IMPLICITLY used a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_read array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_read array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction used it.

 @return: true if this instruction indeed implicitly used aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn* insn, unsigned int reg_id);

/*
 Check if a disassembled instruction IMPLICITLY modified a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_write array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_write array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction modified it.

 @return: true if this instruction indeed implicitly modified aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn* insn, unsigned int reg_id);

/*
 Count the number of operands of a given type.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.

 @return: number of operands of given type @op_type in instruction @insn,
 or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_count(csh handle, const cs_insn* insn, unsigned int op_type);

/*
 Retrieve the position of operand of given type in <arch>.operands[] array.
 Later, the operand can be accessed using the returned position.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.
 @position: position of the operand to be found. This must be in the range
            [1, cs_op_count(handle, insn, op_type)]

 @return: index of operand of given type @op_type in <arch>.operands[] array
 in instruction @insn, or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_index(csh handle, const cs_insn* insn, unsigned int op_type,
                             unsigned int position);

// Type of array to keep the list of registers
typedef uint16_t cs_regs[64];

/*
 Retrieve all the registers accessed by an instruction, either explicitly or
 implicitly.

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store registers.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure returned from cs_disasm() or cs_disasm_iter()
 @regs_read: on return, this array contains all registers read by instruction.
 @regs_read_count: number of registers kept inside @regs_read array.
 @regs_write: on return, this array contains all registers written by instruction.
 @regs_write_count: number of registers kept inside @regs_write array.

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_regs_access(csh handle, const cs_insn* insn,
                                   cs_regs regs_read, uint8_t* regs_read_count,
                                   cs_regs regs_write, uint8_t* regs_write_count);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/m68k.h
================================================
#ifndef CAPSTONE_M68K_H
#define CAPSTONE_M68K_H

/* Capstone Disassembly Engine */
/* By Daniel Collin <daniel@collin.com>, 2015-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

#define M68K_OPERAND_COUNT 4

//> M68K registers and special registers
typedef enum m68k_reg
{
    M68K_REG_INVALID = 0,

    M68K_REG_D0,
    M68K_REG_D1,
    M68K_REG_D2,
    M68K_REG_D3,
    M68K_REG_D4,
    M68K_REG_D5,
    M68K_REG_D6,
    M68K_REG_D7,

    M68K_REG_A0,
    M68K_REG_A1,
    M68K_REG_A2,
    M68K_REG_A3,
    M68K_REG_A4,
    M68K_REG_A5,
    M68K_REG_A6,
    M68K_REG_A7,

    M68K_REG_FP0,
    M68K_REG_FP1,
    M68K_REG_FP2,
    M68K_REG_FP3,
    M68K_REG_FP4,
    M68K_REG_FP5,
    M68K_REG_FP6,
    M68K_REG_FP7,

    M68K_REG_PC,

    M68K_REG_SR,
    M68K_REG_CCR,
    M68K_REG_SFC,
    M68K_REG_DFC,
    M68K_REG_USP,
    M68K_REG_VBR,
    M68K_REG_CACR,
    M68K_REG_CAAR,
    M68K_REG_MSP,
    M68K_REG_ISP,
    M68K_REG_TC,
    M68K_REG_ITT0,
    M68K_REG_ITT1,
    M68K_REG_DTT0,
    M68K_REG_DTT1,
    M68K_REG_MMUSR,
    M68K_REG_URP,
    M68K_REG_SRP,

    M68K_REG_FPCR,
    M68K_REG_FPSR,
    M68K_REG_FPIAR,

    M68K_REG_ENDING,   // <-- mark the end of the list of registers
} m68k_reg;

//> M68K Addressing Modes
typedef enum m68k_address_mode
{
    M68K_AM_NONE = 0,           // No address mode.

    M68K_AM_REG_DIRECT_DATA,        // Register Direct - Data
    M68K_AM_REG_DIRECT_ADDR,        // Register Direct - Address

    M68K_AM_REGI_ADDR,              // Register Indirect - Address
    M68K_AM_REGI_ADDR_POST_INC,     // Register Indirect - Address with Postincrement
    M68K_AM_REGI_ADDR_PRE_DEC,      // Register Indirect - Address with Predecrement
    M68K_AM_REGI_ADDR_DISP,         // Register Indirect - Address with Displacement

    M68K_AM_AREGI_INDEX_8_BIT_DISP, // Address Register Indirect With Index- 8-bit displacement
    M68K_AM_AREGI_INDEX_BASE_DISP,  // Address Register Indirect With Index- Base displacement

    M68K_AM_MEMI_POST_INDEX,        // Memory indirect - Postindex
    M68K_AM_MEMI_PRE_INDEX,         // Memory indirect - Preindex

    M68K_AM_PCI_DISP,               // Program Counter Indirect - with Displacement

    M68K_AM_PCI_INDEX_8_BIT_DISP,   // Program Counter Indirect with Index - with 8-Bit Displacement
    M68K_AM_PCI_INDEX_BASE_DISP,    // Program Counter Indirect with Index - with Base Displacement

    M68K_AM_PC_MEMI_POST_INDEX,     // Program Counter Memory Indirect - Postindexed
    M68K_AM_PC_MEMI_PRE_INDEX,      // Program Counter Memory Indirect - Preindexed

    M68K_AM_ABSOLUTE_DATA_SHORT,    // Absolute Data Addressing  - Short
    M68K_AM_ABSOLUTE_DATA_LONG,     // Absolute Data Addressing  - Long
    M68K_AM_IMMEDIATE,              // Immediate value
} m68k_address_mode;

//> Operand type for instruction's operands
typedef enum m68k_op_type
{
    M68K_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    M68K_OP_REG,         // = CS_OP_REG (Register operand).
    M68K_OP_IMM,         // = CS_OP_IMM (Immediate operand).
    M68K_OP_MEM,         // = CS_OP_MEM (Memory operand).
    M68K_OP_FP_SINGLE,   // single precision Floating-Point operand
    M68K_OP_FP_DOUBLE,   // double precision Floating-Point operand
    M68K_OP_REG_BITS,    // Register bits move
    M68K_OP_REG_PAIR,    // Register pair in the same op (upper 4 bits for first reg, lower for second)
} m68k_op_type;

// Instruction's operand referring to memory
// This is associated with M68K_OP_MEM operand type above
typedef struct m68k_op_mem
{
    m68k_reg base_reg;      // base register (or M68K_REG_INVALID if irrelevant)
    m68k_reg index_reg;     // index register (or M68K_REG_INVALID if irrelevant)
    m68k_reg in_base_reg;   // indirect base register (or M68K_REG_INVALID if irrelevant)
    uint32_t in_disp;       // indirect displacement
    uint32_t out_disp;      // other displacement
    int16_t disp;           // displacement value
    uint8_t scale;          // scale for index register
    uint8_t bitfield;       // set to true if the two values below should be used
    uint8_t width;          // used for bf* instructions
    uint8_t offset;         // used for bf* instructions
    uint8_t index_size;     // 0 = w, 1 = l
} m68k_op_mem;

// Instruction operand
typedef struct cs_m68k_op
{
    union
    {
        uint64_t imm;               // immediate value for IMM operand
        double dimm;            // double imm
        float simm;             // float imm
        m68k_reg reg;           // register value for REG operand
        struct              // register pair in one operand
        {
            m68k_reg reg_0;
            m68k_reg reg_1;
        } reg_pair;
        m68k_op_mem mem;        // data when operand is targeting memory
        uint32_t register_bits; // register bits for movem etc. (always in d0-d7, a0-a7, fp0 - fp7 order)
    };
    m68k_op_type type;
    m68k_address_mode address_mode; // M68K addressing mode for this op
} cs_m68k_op;

// Operation size of the CPU instructions
typedef enum m68k_cpu_size
{
    M68K_CPU_SIZE_NONE = 0,     // unsized or unspecified
    M68K_CPU_SIZE_BYTE = 1,     // 1 byte in size
    M68K_CPU_SIZE_WORD = 2,     // 2 bytes in size
    M68K_CPU_SIZE_LONG = 4,     // 4 bytes in size
} m68k_cpu_size;

// Operation size of the FPU instructions (Notice that FPU instruction can also use CPU sizes if needed)
typedef enum m68k_fpu_size
{
    M68K_FPU_SIZE_NONE = 0,     // unsized like fsave/frestore
    M68K_FPU_SIZE_SINGLE = 4,       // 4 byte in size (single float)
    M68K_FPU_SIZE_DOUBLE = 8,       // 8 byte in size (double)
    M68K_FPU_SIZE_EXTENDED = 12,    // 12 byte in size (extended real format)
} m68k_fpu_size;

// Type of size that is being used for the current instruction
typedef enum m68k_size_type
{
    M68K_SIZE_TYPE_INVALID = 0,

    M68K_SIZE_TYPE_CPU,
    M68K_SIZE_TYPE_FPU,
} m68k_size_type;

// Operation size of the current instruction (NOT the actually size of instruction)
typedef struct m68k_op_size
{
    m68k_size_type type;
    union
    {
        m68k_cpu_size cpu_size;
        m68k_fpu_size fpu_size;
    };
} m68k_op_size;

// The M68K instruction and it's operands
typedef struct cs_m68k
{
    // Number of operands of this instruction or 0 when instruction has no operand.
    cs_m68k_op operands[M68K_OPERAND_COUNT]; // operands for this instruction.
    m68k_op_size op_size;   // size of data operand works on in bytes (.b, .w, .l, etc)
    uint8_t op_count; // number of operands for the instruction
} cs_m68k;

//> M68K instruction
typedef enum m68k_insn
{
    M68K_INS_INVALID = 0,

    M68K_INS_ABCD,
    M68K_INS_ADD,
    M68K_INS_ADDA,
    M68K_INS_ADDI,
    M68K_INS_ADDQ,
    M68K_INS_ADDX,
    M68K_INS_AND,
    M68K_INS_ANDI,
    M68K_INS_ASL,
    M68K_INS_ASR,
    M68K_INS_BHS,
    M68K_INS_BLO,
    M68K_INS_BHI,
    M68K_INS_BLS,
    M68K_INS_BCC,
    M68K_INS_BCS,
    M68K_INS_BNE,
    M68K_INS_BEQ,
    M68K_INS_BVC,
    M68K_INS_BVS,
    M68K_INS_BPL,
    M68K_INS_BMI,
    M68K_INS_BGE,
    M68K_INS_BLT,
    M68K_INS_BGT,
    M68K_INS_BLE,
    M68K_INS_BRA,
    M68K_INS_BSR,
    M68K_INS_BCHG,
    M68K_INS_BCLR,
    M68K_INS_BSET,
    M68K_INS_BTST,
    M68K_INS_BFCHG,
    M68K_INS_BFCLR,
    M68K_INS_BFEXTS,
    M68K_INS_BFEXTU,
    M68K_INS_BFFFO,
    M68K_INS_BFINS,
    M68K_INS_BFSET,
    M68K_INS_BFTST,
    M68K_INS_BKPT,
    M68K_INS_CALLM,
    M68K_INS_CAS,
    M68K_INS_CAS2,
    M68K_INS_CHK,
    M68K_INS_CHK2,
    M68K_INS_CLR,
    M68K_INS_CMP,
    M68K_INS_CMPA,
    M68K_INS_CMPI,
    M68K_INS_CMPM,
    M68K_INS_CMP2,
    M68K_INS_CINVL,
    M68K_INS_CINVP,
    M68K_INS_CINVA,
    M68K_INS_CPUSHL,
    M68K_INS_CPUSHP,
    M68K_INS_CPUSHA,
    M68K_INS_DBT,
    M68K_INS_DBF,
    M68K_INS_DBHI,
    M68K_INS_DBLS,
    M68K_INS_DBCC,
    M68K_INS_DBCS,
    M68K_INS_DBNE,
    M68K_INS_DBEQ,
    M68K_INS_DBVC,
    M68K_INS_DBVS,
    M68K_INS_DBPL,
    M68K_INS_DBMI,
    M68K_INS_DBGE,
    M68K_INS_DBLT,
    M68K_INS_DBGT,
    M68K_INS_DBLE,
    M68K_INS_DBRA,
    M68K_INS_DIVS,
    M68K_INS_DIVSL,
    M68K_INS_DIVU,
    M68K_INS_DIVUL,
    M68K_INS_EOR,
    M68K_INS_EORI,
    M68K_INS_EXG,
    M68K_INS_EXT,
    M68K_INS_EXTB,
    M68K_INS_FABS,
    M68K_INS_FSABS,
    M68K_INS_FDABS,
    M68K_INS_FACOS,
    M68K_INS_FADD,
    M68K_INS_FSADD,
    M68K_INS_FDADD,
    M68K_INS_FASIN,
    M68K_INS_FATAN,
    M68K_INS_FATANH,
    M68K_INS_FBF,
    M68K_INS_FBEQ,
    M68K_INS_FBOGT,
    M68K_INS_FBOGE,
    M68K_INS_FBOLT,
    M68K_INS_FBOLE,
    M68K_INS_FBOGL,
    M68K_INS_FBOR,
    M68K_INS_FBUN,
    M68K_INS_FBUEQ,
    M68K_INS_FBUGT,
    M68K_INS_FBUGE,
    M68K_INS_FBULT,
    M68K_INS_FBULE,
    M68K_INS_FBNE,
    M68K_INS_FBT,
    M68K_INS_FBSF,
    M68K_INS_FBSEQ,
    M68K_INS_FBGT,
    M68K_INS_FBGE,
    M68K_INS_FBLT,
    M68K_INS_FBLE,
    M68K_INS_FBGL,
    M68K_INS_FBGLE,
    M68K_INS_FBNGLE,
    M68K_INS_FBNGL,
    M68K_INS_FBNLE,
    M68K_INS_FBNLT,
    M68K_INS_FBNGE,
    M68K_INS_FBNGT,
    M68K_INS_FBSNE,
    M68K_INS_FBST,
    M68K_INS_FCMP,
    M68K_INS_FCOS,
    M68K_INS_FCOSH,
    M68K_INS_FDBF,
    M68K_INS_FDBEQ,
    M68K_INS_FDBOGT,
    M68K_INS_FDBOGE,
    M68K_INS_FDBOLT,
    M68K_INS_FDBOLE,
    M68K_INS_FDBOGL,
    M68K_INS_FDBOR,
    M68K_INS_FDBUN,
    M68K_INS_FDBUEQ,
    M68K_INS_FDBUGT,
    M68K_INS_FDBUGE,
    M68K_INS_FDBULT,
    M68K_INS_FDBULE,
    M68K_INS_FDBNE,
    M68K_INS_FDBT,
    M68K_INS_FDBSF,
    M68K_INS_FDBSEQ,
    M68K_INS_FDBGT,
    M68K_INS_FDBGE,
    M68K_INS_FDBLT,
    M68K_INS_FDBLE,
    M68K_INS_FDBGL,
    M68K_INS_FDBGLE,
    M68K_INS_FDBNGLE,
    M68K_INS_FDBNGL,
    M68K_INS_FDBNLE,
    M68K_INS_FDBNLT,
    M68K_INS_FDBNGE,
    M68K_INS_FDBNGT,
    M68K_INS_FDBSNE,
    M68K_INS_FDBST,
    M68K_INS_FDIV,
    M68K_INS_FSDIV,
    M68K_INS_FDDIV,
    M68K_INS_FETOX,
    M68K_INS_FETOXM1,
    M68K_INS_FGETEXP,
    M68K_INS_FGETMAN,
    M68K_INS_FINT,
    M68K_INS_FINTRZ,
    M68K_INS_FLOG10,
    M68K_INS_FLOG2,
    M68K_INS_FLOGN,
    M68K_INS_FLOGNP1,
    M68K_INS_FMOD,
    M68K_INS_FMOVE,
    M68K_INS_FSMOVE,
    M68K_INS_FDMOVE,
    M68K_INS_FMOVECR,
    M68K_INS_FMOVEM,
    M68K_INS_FMUL,
    M68K_INS_FSMUL,
    M68K_INS_FDMUL,
    M68K_INS_FNEG,
    M68K_INS_FSNEG,
    M68K_INS_FDNEG,
    M68K_INS_FNOP,
    M68K_INS_FREM,
    M68K_INS_FRESTORE,
    M68K_INS_FSAVE,
    M68K_INS_FSCALE,
    M68K_INS_FSGLDIV,
    M68K_INS_FSGLMUL,
    M68K_INS_FSIN,
    M68K_INS_FSINCOS,
    M68K_INS_FSINH,
    M68K_INS_FSQRT,
    M68K_INS_FSSQRT,
    M68K_INS_FDSQRT,
    M68K_INS_FSF,
    M68K_INS_FSBEQ,
    M68K_INS_FSOGT,
    M68K_INS_FSOGE,
    M68K_INS_FSOLT,
    M68K_INS_FSOLE,
    M68K_INS_FSOGL,
    M68K_INS_FSOR,
    M68K_INS_FSUN,
    M68K_INS_FSUEQ,
    M68K_INS_FSUGT,
    M68K_INS_FSUGE,
    M68K_INS_FSULT,
    M68K_INS_FSULE,
    M68K_INS_FSNE,
    M68K_INS_FST,
    M68K_INS_FSSF,
    M68K_INS_FSSEQ,
    M68K_INS_FSGT,
    M68K_INS_FSGE,
    M68K_INS_FSLT,
    M68K_INS_FSLE,
    M68K_INS_FSGL,
    M68K_INS_FSGLE,
    M68K_INS_FSNGLE,
    M68K_INS_FSNGL,
    M68K_INS_FSNLE,
    M68K_INS_FSNLT,
    M68K_INS_FSNGE,
    M68K_INS_FSNGT,
    M68K_INS_FSSNE,
    M68K_INS_FSST,
    M68K_INS_FSUB,
    M68K_INS_FSSUB,
    M68K_INS_FDSUB,
    M68K_INS_FTAN,
    M68K_INS_FTANH,
    M68K_INS_FTENTOX,
    M68K_INS_FTRAPF,
    M68K_INS_FTRAPEQ,
    M68K_INS_FTRAPOGT,
    M68K_INS_FTRAPOGE,
    M68K_INS_FTRAPOLT,
    M68K_INS_FTRAPOLE,
    M68K_INS_FTRAPOGL,
    M68K_INS_FTRAPOR,
    M68K_INS_FTRAPUN,
    M68K_INS_FTRAPUEQ,
    M68K_INS_FTRAPUGT,
    M68K_INS_FTRAPUGE,
    M68K_INS_FTRAPULT,
    M68K_INS_FTRAPULE,
    M68K_INS_FTRAPNE,
    M68K_INS_FTRAPT,
    M68K_INS_FTRAPSF,
    M68K_INS_FTRAPSEQ,
    M68K_INS_FTRAPGT,
    M68K_INS_FTRAPGE,
    M68K_INS_FTRAPLT,
    M68K_INS_FTRAPLE,
    M68K_INS_FTRAPGL,
    M68K_INS_FTRAPGLE,
    M68K_INS_FTRAPNGLE,
    M68K_INS_FTRAPNGL,
    M68K_INS_FTRAPNLE,
    M68K_INS_FTRAPNLT,
    M68K_INS_FTRAPNGE,
    M68K_INS_FTRAPNGT,
    M68K_INS_FTRAPSNE,
    M68K_INS_FTRAPST,
    M68K_INS_FTST,
    M68K_INS_FTWOTOX,
    M68K_INS_HALT,
    M68K_INS_ILLEGAL,
    M68K_INS_JMP,
    M68K_INS_JSR,
    M68K_INS_LEA,
    M68K_INS_LINK,
    M68K_INS_LPSTOP,
    M68K_INS_LSL,
    M68K_INS_LSR,
    M68K_INS_MOVE,
    M68K_INS_MOVEA,
    M68K_INS_MOVEC,
    M68K_INS_MOVEM,
    M68K_INS_MOVEP,
    M68K_INS_MOVEQ,
    M68K_INS_MOVES,
    M68K_INS_MOVE16,
    M68K_INS_MULS,
    M68K_INS_MULU,
    M68K_INS_NBCD,
    M68K_INS_NEG,
    M68K_INS_NEGX,
    M68K_INS_NOP,
    M68K_INS_NOT,
    M68K_INS_OR,
    M68K_INS_ORI,
    M68K_INS_PACK,
    M68K_INS_PEA,
    M68K_INS_PFLUSH,
    M68K_INS_PFLUSHA,
    M68K_INS_PFLUSHAN,
    M68K_INS_PFLUSHN,
    M68K_INS_PLOADR,
    M68K_INS_PLOADW,
    M68K_INS_PLPAR,
    M68K_INS_PLPAW,
    M68K_INS_PMOVE,
    M68K_INS_PMOVEFD,
    M68K_INS_PTESTR,
    M68K_INS_PTESTW,
    M68K_INS_PULSE,
    M68K_INS_REMS,
    M68K_INS_REMU,
    M68K_INS_RESET,
    M68K_INS_ROL,
    M68K_INS_ROR,
    M68K_INS_ROXL,
    M68K_INS_ROXR,
    M68K_INS_RTD,
    M68K_INS_RTE,
    M68K_INS_RTM,
    M68K_INS_RTR,
    M68K_INS_RTS,
    M68K_INS_SBCD,
    M68K_INS_ST,
    M68K_INS_SF,
    M68K_INS_SHI,
    M68K_INS_SLS,
    M68K_INS_SCC,
    M68K_INS_SHS,
    M68K_INS_SCS,
    M68K_INS_SLO,
    M68K_INS_SNE,
    M68K_INS_SEQ,
    M68K_INS_SVC,
    M68K_INS_SVS,
    M68K_INS_SPL,
    M68K_INS_SMI,
    M68K_INS_SGE,
    M68K_INS_SLT,
    M68K_INS_SGT,
    M68K_INS_SLE,
    M68K_INS_STOP,
    M68K_INS_SUB,
    M68K_INS_SUBA,
    M68K_INS_SUBI,
    M68K_INS_SUBQ,
    M68K_INS_SUBX,
    M68K_INS_SWAP,
    M68K_INS_TAS,
    M68K_INS_TRAP,
    M68K_INS_TRAPV,
    M68K_INS_TRAPT,
    M68K_INS_TRAPF,
    M68K_INS_TRAPHI,
    M68K_INS_TRAPLS,
    M68K_INS_TRAPCC,
    M68K_INS_TRAPHS,
    M68K_INS_TRAPCS,
    M68K_INS_TRAPLO,
    M68K_INS_TRAPNE,
    M68K_INS_TRAPEQ,
    M68K_INS_TRAPVC,
    M68K_INS_TRAPVS,
    M68K_INS_TRAPPL,
    M68K_INS_TRAPMI,
    M68K_INS_TRAPGE,
    M68K_INS_TRAPLT,
    M68K_INS_TRAPGT,
    M68K_INS_TRAPLE,
    M68K_INS_TST,
    M68K_INS_UNLK,
    M68K_INS_UNPK,
    M68K_INS_ENDING,   // <-- mark the end of the list of instructions

} m68k_insn;

//> Group of M68K instructions
typedef enum m68k_group_type
{
    M68K_GRP_INVALID = 0,  // CS_GRUP_INVALID
    M68K_GRP_JUMP,  // = CS_GRP_JUMP
    M68K_GRP_RET = 3,  // = CS_GRP_RET
    M68K_GRP_IRET = 5, // = CS_GRP_IRET

    M68K_GRP_ENDING,// <-- mark the end of the list of groups
} m68k_group_type;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/mips.h
================================================
#ifndef CAPSTONE_MIPS_H
#define CAPSTONE_MIPS_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum mips_op_type
{
    MIPS_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    MIPS_OP_REG, // = CS_OP_REG (Register operand).
    MIPS_OP_IMM, // = CS_OP_IMM (Immediate operand).
    MIPS_OP_MEM, // = CS_OP_MEM (Memory operand).
} mips_op_type;

//> MIPS registers
typedef enum mips_reg
{
    MIPS_REG_INVALID = 0,
    //> General purpose registers
    MIPS_REG_PC,

    MIPS_REG_0,
    MIPS_REG_1,
    MIPS_REG_2,
    MIPS_REG_3,
    MIPS_REG_4,
    MIPS_REG_5,
    MIPS_REG_6,
    MIPS_REG_7,
    MIPS_REG_8,
    MIPS_REG_9,
    MIPS_REG_10,
    MIPS_REG_11,
    MIPS_REG_12,
    MIPS_REG_13,
    MIPS_REG_14,
    MIPS_REG_15,
    MIPS_REG_16,
    MIPS_REG_17,
    MIPS_REG_18,
    MIPS_REG_19,
    MIPS_REG_20,
    MIPS_REG_21,
    MIPS_REG_22,
    MIPS_REG_23,
    MIPS_REG_24,
    MIPS_REG_25,
    MIPS_REG_26,
    MIPS_REG_27,
    MIPS_REG_28,
    MIPS_REG_29,
    MIPS_REG_30,
    MIPS_REG_31,

    //> DSP registers
    MIPS_REG_DSPCCOND,
    MIPS_REG_DSPCARRY,
    MIPS_REG_DSPEFI,
    MIPS_REG_DSPOUTFLAG,
    MIPS_REG_DSPOUTFLAG16_19,
    MIPS_REG_DSPOUTFLAG20,
    MIPS_REG_DSPOUTFLAG21,
    MIPS_REG_DSPOUTFLAG22,
    MIPS_REG_DSPOUTFLAG23,
    MIPS_REG_DSPPOS,
    MIPS_REG_DSPSCOUNT,

    //> ACC registers
    MIPS_REG_AC0,
    MIPS_REG_AC1,
    MIPS_REG_AC2,
    MIPS_REG_AC3,

    //> COP registers
    MIPS_REG_CC0,
    MIPS_REG_CC1,
    MIPS_REG_CC2,
    MIPS_REG_CC3,
    MIPS_REG_CC4,
    MIPS_REG_CC5,
    MIPS_REG_CC6,
    MIPS_REG_CC7,

    //> FPU registers
    MIPS_REG_F0,
    MIPS_REG_F1,
    MIPS_REG_F2,
    MIPS_REG_F3,
    MIPS_REG_F4,
    MIPS_REG_F5,
    MIPS_REG_F6,
    MIPS_REG_F7,
    MIPS_REG_F8,
    MIPS_REG_F9,
    MIPS_REG_F10,
    MIPS_REG_F11,
    MIPS_REG_F12,
    MIPS_REG_F13,
    MIPS_REG_F14,
    MIPS_REG_F15,
    MIPS_REG_F16,
    MIPS_REG_F17,
    MIPS_REG_F18,
    MIPS_REG_F19,
    MIPS_REG_F20,
    MIPS_REG_F21,
    MIPS_REG_F22,
    MIPS_REG_F23,
    MIPS_REG_F24,
    MIPS_REG_F25,
    MIPS_REG_F26,
    MIPS_REG_F27,
    MIPS_REG_F28,
    MIPS_REG_F29,
    MIPS_REG_F30,
    MIPS_REG_F31,

    MIPS_REG_FCC0,
    MIPS_REG_FCC1,
    MIPS_REG_FCC2,
    MIPS_REG_FCC3,
    MIPS_REG_FCC4,
    MIPS_REG_FCC5,
    MIPS_REG_FCC6,
    MIPS_REG_FCC7,

    //> AFPR128
    MIPS_REG_W0,
    MIPS_REG_W1,
    MIPS_REG_W2,
    MIPS_REG_W3,
    MIPS_REG_W4,
    MIPS_REG_W5,
    MIPS_REG_W6,
    MIPS_REG_W7,
    MIPS_REG_W8,
    MIPS_REG_W9,
    MIPS_REG_W10,
    MIPS_REG_W11,
    MIPS_REG_W12,
    MIPS_REG_W13,
    MIPS_REG_W14,
    MIPS_REG_W15,
    MIPS_REG_W16,
    MIPS_REG_W17,
    MIPS_REG_W18,
    MIPS_REG_W19,
    MIPS_REG_W20,
    MIPS_REG_W21,
    MIPS_REG_W22,
    MIPS_REG_W23,
    MIPS_REG_W24,
    MIPS_REG_W25,
    MIPS_REG_W26,
    MIPS_REG_W27,
    MIPS_REG_W28,
    MIPS_REG_W29,
    MIPS_REG_W30,
    MIPS_REG_W31,

    MIPS_REG_HI,
    MIPS_REG_LO,

    MIPS_REG_P0,
    MIPS_REG_P1,
    MIPS_REG_P2,

    MIPS_REG_MPL0,
    MIPS_REG_MPL1,
    MIPS_REG_MPL2,

    MIPS_REG_ENDING,    // <-- mark the end of the list or registers

    // alias registers
    MIPS_REG_ZERO = MIPS_REG_0,
    MIPS_REG_AT = MIPS_REG_1,
    MIPS_REG_V0 = MIPS_REG_2,
    MIPS_REG_V1 = MIPS_REG_3,
    MIPS_REG_A0 = MIPS_REG_4,
    MIPS_REG_A1 = MIPS_REG_5,
    MIPS_REG_A2 = MIPS_REG_6,
    MIPS_REG_A3 = MIPS_REG_7,
    MIPS_REG_T0 = MIPS_REG_8,
    MIPS_REG_T1 = MIPS_REG_9,
    MIPS_REG_T2 = MIPS_REG_10,
    MIPS_REG_T3 = MIPS_REG_11,
    MIPS_REG_T4 = MIPS_REG_12,
    MIPS_REG_T5 = MIPS_REG_13,
    MIPS_REG_T6 = MIPS_REG_14,
    MIPS_REG_T7 = MIPS_REG_15,
    MIPS_REG_S0 = MIPS_REG_16,
    MIPS_REG_S1 = MIPS_REG_17,
    MIPS_REG_S2 = MIPS_REG_18,
    MIPS_REG_S3 = MIPS_REG_19,
    MIPS_REG_S4 = MIPS_REG_20,
    MIPS_REG_S5 = MIPS_REG_21,
    MIPS_REG_S6 = MIPS_REG_22,
    MIPS_REG_S7 = MIPS_REG_23,
    MIPS_REG_T8 = MIPS_REG_24,
    MIPS_REG_T9 = MIPS_REG_25,
    MIPS_REG_K0 = MIPS_REG_26,
    MIPS_REG_K1 = MIPS_REG_27,
    MIPS_REG_GP = MIPS_REG_28,
    MIPS_REG_SP = MIPS_REG_29,
    MIPS_REG_FP = MIPS_REG_30, MIPS_REG_S8 = MIPS_REG_30,
    MIPS_REG_RA = MIPS_REG_31,

    MIPS_REG_HI0 = MIPS_REG_AC0,
    MIPS_REG_HI1 = MIPS_REG_AC1,
    MIPS_REG_HI2 = MIPS_REG_AC2,
    MIPS_REG_HI3 = MIPS_REG_AC3,

    MIPS_REG_LO0 = MIPS_REG_HI0,
    MIPS_REG_LO1 = MIPS_REG_HI1,
    MIPS_REG_LO2 = MIPS_REG_HI2,
    MIPS_REG_LO3 = MIPS_REG_HI3,
} mips_reg;

// Instruction's operand referring to memory
// This is associated with MIPS_OP_MEM operand type above
typedef struct mips_op_mem
{
    mips_reg base;  // base register
    int64_t disp;   // displacement/offset value
} mips_op_mem;

// Instruction operand
typedef struct cs_mips_op
{
    mips_op_type type;  // operand type
    union
    {
        mips_reg reg;       // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        mips_op_mem mem;    // base/index/scale/disp value for MEM operand
    };
} cs_mips_op;

// Instruction structure
typedef struct cs_mips
{
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_mips_op operands[8]; // operands for this instruction.
} cs_mips;

//> MIPS instruction
typedef enum mips_insn
{
    MIPS_INS_INVALID = 0,

    MIPS_INS_ABSQ_S,
    MIPS_INS_ADD,
    MIPS_INS_ADDIUPC,
    MIPS_INS_ADDIUR1SP,
    MIPS_INS_ADDIUR2,
    MIPS_INS_ADDIUS5,
    MIPS_INS_ADDIUSP,
    MIPS_INS_ADDQH,
    MIPS_INS_ADDQH_R,
    MIPS_INS_ADDQ,
    MIPS_INS_ADDQ_S,
    MIPS_INS_ADDSC,
    MIPS_INS_ADDS_A,
    MIPS_INS_ADDS_S,
    MIPS_INS_ADDS_U,
    MIPS_INS_ADDU16,
    MIPS_INS_ADDUH,
    MIPS_INS_ADDUH_R,
    MIPS_INS_ADDU,
    MIPS_INS_ADDU_S,
    MIPS_INS_ADDVI,
    MIPS_INS_ADDV,
    MIPS_INS_ADDWC,
    MIPS_INS_ADD_A,
    MIPS_INS_ADDI,
    MIPS_INS_ADDIU,
    MIPS_INS_ALIGN,
    MIPS_INS_ALUIPC,
    MIPS_INS_AND,
    MIPS_INS_AND16,
    MIPS_INS_ANDI16,
    MIPS_INS_ANDI,
    MIPS_INS_APPEND,
    MIPS_INS_ASUB_S,
    MIPS_INS_ASUB_U,
    MIPS_INS_AUI,
    MIPS_INS_AUIPC,
    MIPS_INS_AVER_S,
    MIPS_INS_AVER_U,
    MIPS_INS_AVE_S,
    MIPS_INS_AVE_U,
    MIPS_INS_B16,
    MIPS_INS_BADDU,
    MIPS_INS_BAL,
    MIPS_INS_BALC,
    MIPS_INS_BALIGN,
    MIPS_INS_BBIT0,
    MIPS_INS_BBIT032,
    MIPS_INS_BBIT1,
    MIPS_INS_BBIT132,
    MIPS_INS_BC,
    MIPS_INS_BC0F,
    MIPS_INS_BC0FL,
    MIPS_INS_BC0T,
    MIPS_INS_BC0TL,
    MIPS_INS_BC1EQZ,
    MIPS_INS_BC1F,
    MIPS_INS_BC1FL,
    MIPS_INS_BC1NEZ,
    MIPS_INS_BC1T,
    MIPS_INS_BC1TL,
    MIPS_INS_BC2EQZ,
    MIPS_INS_BC2F,
    MIPS_INS_BC2FL,
    MIPS_INS_BC2NEZ,
    MIPS_INS_BC2T,
    MIPS_INS_BC2TL,
    MIPS_INS_BC3F,
    MIPS_INS_BC3FL,
    MIPS_INS_BC3T,
    MIPS_INS_BC3TL,
    MIPS_INS_BCLRI,
    MIPS_INS_BCLR,
    MIPS_INS_BEQ,
    MIPS_INS_BEQC,
    MIPS_INS_BEQL,
    MIPS_INS_BEQZ16,
    MIPS_INS_BEQZALC,
    MIPS_INS_BEQZC,
    MIPS_INS_BGEC,
    MIPS_INS_BGEUC,
    MIPS_INS_BGEZ,
    MIPS_INS_BGEZAL,
    MIPS_INS_BGEZALC,
    MIPS_INS_BGEZALL,
    MIPS_INS_BGEZALS,
    MIPS_INS_BGEZC,
    MIPS_INS_BGEZL,
    MIPS_INS_BGTZ,
    MIPS_INS_BGTZALC,
    MIPS_INS_BGTZC,
    MIPS_INS_BGTZL,
    MIPS_INS_BINSLI,
    MIPS_INS_BINSL,
    MIPS_INS_BINSRI,
    MIPS_INS_BINSR,
    MIPS_INS_BITREV,
    MIPS_INS_BITSWAP,
    MIPS_INS_BLEZ,
    MIPS_INS_BLEZALC,
    MIPS_INS_BLEZC,
    MIPS_INS_BLEZL,
    MIPS_INS_BLTC,
    MIPS_INS_BLTUC,
    MIPS_INS_BLTZ,
    MIPS_INS_BLTZAL,
    MIPS_INS_BLTZALC,
    MIPS_INS_BLTZALL,
    MIPS_INS_BLTZALS,
    MIPS_INS_BLTZC,
    MIPS_INS_BLTZL,
    MIPS_INS_BMNZI,
    MIPS_INS_BMNZ,
    MIPS_INS_BMZI,
    MIPS_INS_BMZ,
    MIPS_INS_BNE,
    MIPS_INS_BNEC,
    MIPS_INS_BNEGI,
    MIPS_INS_BNEG,
    MIPS_INS_BNEL,
    MIPS_INS_BNEZ16,
    MIPS_INS_BNEZALC,
    MIPS_INS_BNEZC,
    MIPS_INS_BNVC,
    MIPS_INS_BNZ,
    MIPS_INS_BOVC,
    MIPS_INS_BPOSGE32,
    MIPS_INS_BREAK,
    MIPS_INS_BREAK16,
    MIPS_INS_BSELI,
    MIPS_INS_BSEL,
    MIPS_INS_BSETI,
    MIPS_INS_BSET,
    MIPS_INS_BZ,
    MIPS_INS_BEQZ,
    MIPS_INS_B,
    MIPS_INS_BNEZ,
    MIPS_INS_BTEQZ,
    MIPS_INS_BTNEZ,
    MIPS_INS_CACHE,
    MIPS_INS_CEIL,
    MIPS_INS_CEQI,
    MIPS_INS_CEQ,
    MIPS_INS_CFC1,
    MIPS_INS_CFCMSA,
    MIPS_INS_CINS,
    MIPS_INS_CINS32,
    MIPS_INS_CLASS,
    MIPS_INS_CLEI_S,
    MIPS_INS_CLEI_U,
    MIPS_INS_CLE_S,
    MIPS_INS_CLE_U,
    MIPS_INS_CLO,
    MIPS_INS_CLTI_S,
    MIPS_INS_CLTI_U,
    MIPS_INS_CLT_S,
    MIPS_INS_CLT_U,
    MIPS_INS_CLZ,
    MIPS_INS_CMPGDU,
    MIPS_INS_CMPGU,
    MIPS_INS_CMPU,
    MIPS_INS_CMP,
    MIPS_INS_COPY_S,
    MIPS_INS_COPY_U,
    MIPS_INS_CTC1,
    MIPS_INS_CTCMSA,
    MIPS_INS_CVT,
    MIPS_INS_C,
    MIPS_INS_CMPI,
    MIPS_INS_DADD,
    MIPS_INS_DADDI,
    MIPS_INS_DADDIU,
    MIPS_INS_DADDU,
    MIPS_INS_DAHI,
    MIPS_INS_DALIGN,
    MIPS_INS_DATI,
    MIPS_INS_DAUI,
    MIPS_INS_DBITSWAP,
    MIPS_INS_DCLO,
    MIPS_INS_DCLZ,
    MIPS_INS_DDIV,
    MIPS_INS_DDIVU,
    MIPS_INS_DERET,
    MIPS_INS_DEXT,
    MIPS_INS_DEXTM,
    MIPS_INS_DEXTU,
    MIPS_INS_DI,
    MIPS_INS_DINS,
    MIPS_INS_DINSM,
    MIPS_INS_DINSU,
    MIPS_INS_DIV,
    MIPS_INS_DIVU,
    MIPS_INS_DIV_S,
    MIPS_INS_DIV_U,
    MIPS_INS_DLSA,
    MIPS_INS_DMFC0,
    MIPS_INS_DMFC1,
    MIPS_INS_DMFC2,
    MIPS_INS_DMOD,
    MIPS_INS_DMODU,
    MIPS_INS_DMTC0,
    MIPS_INS_DMTC1,
    MIPS_INS_DMTC2,
    MIPS_INS_DMUH,
    MIPS_INS_DMUHU,
    MIPS_INS_DMUL,
    MIPS_INS_DMULT,
    MIPS_INS_DMULTU,
    MIPS_INS_DMULU,
    MIPS_INS_DOTP_S,
    MIPS_INS_DOTP_U,
    MIPS_INS_DPADD_S,
    MIPS_INS_DPADD_U,
    MIPS_INS_DPAQX_SA,
    MIPS_INS_DPAQX_S,
    MIPS_INS_DPAQ_SA,
    MIPS_INS_DPAQ_S,
    MIPS_INS_DPAU,
    MIPS_INS_DPAX,
    MIPS_INS_DPA,
    MIPS_INS_DPOP,
    MIPS_INS_DPSQX_SA,
    MIPS_INS_DPSQX_S,
    MIPS_INS_DPSQ_SA,
    MIPS_INS_DPSQ_S,
    MIPS_INS_DPSUB_S,
    MIPS_INS_DPSUB_U,
    MIPS_INS_DPSU,
    MIPS_INS_DPSX,
    MIPS_INS_DPS,
    MIPS_INS_DROTR,
    MIPS_INS_DROTR32,
    MIPS_INS_DROTRV,
    MIPS_INS_DSBH,
    MIPS_INS_DSHD,
    MIPS_INS_DSLL,
    MIPS_INS_DSLL32,
    MIPS_INS_DSLLV,
    MIPS_INS_DSRA,
    MIPS_INS_DSRA32,
    MIPS_INS_DSRAV,
    MIPS_INS_DSRL,
    MIPS_INS_DSRL32,
    MIPS_INS_DSRLV,
    MIPS_INS_DSUB,
    MIPS_INS_DSUBU,
    MIPS_INS_EHB,
    MIPS_INS_EI,
    MIPS_INS_ERET,
    MIPS_INS_EXT,
    MIPS_INS_EXTP,
    MIPS_INS_EXTPDP,
    MIPS_INS_EXTPDPV,
    MIPS_INS_EXTPV,
    MIPS_INS_EXTRV_RS,
    MIPS_INS_EXTRV_R,
    MIPS_INS_EXTRV_S,
    MIPS_INS_EXTRV,
    MIPS_INS_EXTR_RS,
    MIPS_INS_EXTR_R,
    MIPS_INS_EXTR_S,
    MIPS_INS_EXTR,
    MIPS_INS_EXTS,
    MIPS_INS_EXTS32,
    MIPS_INS_ABS,
    MIPS_INS_FADD,
    MIPS_INS_FCAF,
    MIPS_INS_FCEQ,
    MIPS_INS_FCLASS,
    MIPS_INS_FCLE,
    MIPS_INS_FCLT,
    MIPS_INS_FCNE,
    MIPS_INS_FCOR,
    MIPS_INS_FCUEQ,
    MIPS_INS_FCULE,
    MIPS_INS_FCULT,
    MIPS_INS_FCUNE,
    MIPS_INS_FCUN,
    MIPS_INS_FDIV,
    MIPS_INS_FEXDO,
    MIPS_INS_FEXP2,
    MIPS_INS_FEXUPL,
    MIPS_INS_FEXUPR,
    MIPS_INS_FFINT_S,
    MIPS_INS_FFINT_U,
    MIPS_INS_FFQL,
    MIPS_INS_FFQR,
    MIPS_INS_FILL,
    MIPS_INS_FLOG2,
    MIPS_INS_FLOOR,
    MIPS_INS_FMADD,
    MIPS_INS_FMAX_A,
    MIPS_INS_FMAX,
    MIPS_INS_FMIN_A,
    MIPS_INS_FMIN,
    MIPS_INS_MOV,
    MIPS_INS_FMSUB,
    MIPS_INS_FMUL,
    MIPS_INS_MUL,
    MIPS_INS_NEG,
    MIPS_INS_FRCP,
    MIPS_INS_FRINT,
    MIPS_INS_FRSQRT,
    MIPS_INS_FSAF,
    MIPS_INS_FSEQ,
    MIPS_INS_FSLE,
    MIPS_INS_FSLT,
    MIPS_INS_FSNE,
    MIPS_INS_FSOR,
    MIPS_INS_FSQRT,
    MIPS_INS_SQRT,
    MIPS_INS_FSUB,
    MIPS_INS_SUB,
    MIPS_INS_FSUEQ,
    MIPS_INS_FSULE,
    MIPS_INS_FSULT,
    MIPS_INS_FSUNE,
    MIPS_INS_FSUN,
    MIPS_INS_FTINT_S,
    MIPS_INS_FTINT_U,
    MIPS_INS_FTQ,
    MIPS_INS_FTRUNC_S,
    MIPS_INS_FTRUNC_U,
    MIPS_INS_HADD_S,
    MIPS_INS_HADD_U,
    MIPS_INS_HSUB_S,
    MIPS_INS_HSUB_U,
    MIPS_INS_ILVEV,
    MIPS_INS_ILVL,
    MIPS_INS_ILVOD,
    MIPS_INS_ILVR,
    MIPS_INS_INS,
    MIPS_INS_INSERT,
    MIPS_INS_INSV,
    MIPS_INS_INSVE,
    MIPS_INS_J,
    MIPS_INS_JAL,
    MIPS_INS_JALR,
    MIPS_INS_JALRS16,
    MIPS_INS_JALRS,
    MIPS_INS_JALS,
    MIPS_INS_JALX,
    MIPS_INS_JIALC,
    MIPS_INS_JIC,
    MIPS_INS_JR,
    MIPS_INS_JR16,
    MIPS_INS_JRADDIUSP,
    MIPS_INS_JRC,
    MIPS_INS_JALRC,
    MIPS_INS_LB,
    MIPS_INS_LBU16,
    MIPS_INS_LBUX,
    MIPS_INS_LBU,
    MIPS_INS_LD,
    MIPS_INS_LDC1,
    MIPS_INS_LDC2,
    MIPS_INS_LDC3,
    MIPS_INS_LDI,
    MIPS_INS_LDL,
    MIPS_INS_LDPC,
    MIPS_INS_LDR,
    MIPS_INS_LDXC1,
    MIPS_INS_LH,
    MIPS_INS_LHU16,
    MIPS_INS_LHX,
    MIPS_INS_LHU,
    MIPS_INS_LI16,
    MIPS_INS_LL,
    MIPS_INS_LLD,
    MIPS_INS_LSA,
    MIPS_INS_LUXC1,
    MIPS_INS_LUI,
    MIPS_INS_LW,
    MIPS_INS_LW16,
    MIPS_INS_LWC1,
    MIPS_INS_LWC2,
    MIPS_INS_LWC3,
    MIPS_INS_LWL,
    MIPS_INS_LWM16,
    MIPS_INS_LWM32,
    MIPS_INS_LWPC,
    MIPS_INS_LWP,
    MIPS_INS_LWR,
    MIPS_INS_LWUPC,
    MIPS_INS_LWU,
    MIPS_INS_LWX,
    MIPS_INS_LWXC1,
    MIPS_INS_LWXS,
    MIPS_INS_LI,
    MIPS_INS_MADD,
    MIPS_INS_MADDF,
    MIPS_INS_MADDR_Q,
    MIPS_INS_MADDU,
    MIPS_INS_MADDV,
    MIPS_INS_MADD_Q,
    MIPS_INS_MAQ_SA,
    MIPS_INS_MAQ_S,
    MIPS_INS_MAXA,
    MIPS_INS_MAXI_S,
    MIPS_INS_MAXI_U,
    MIPS_INS_MAX_A,
    MIPS_INS_MAX,
    MIPS_INS_MAX_S,
    MIPS_INS_MAX_U,
    MIPS_INS_MFC0,
    MIPS_INS_MFC1,
    MIPS_INS_MFC2,
    MIPS_INS_MFHC1,
    MIPS_INS_MFHI,
    MIPS_INS_MFLO,
    MIPS_INS_MINA,
    MIPS_INS_MINI_S,
    MIPS_INS_MINI_U,
    MIPS_INS_MIN_A,
    MIPS_INS_MIN,
    MIPS_INS_MIN_S,
    MIPS_INS_MIN_U,
    MIPS_INS_MOD,
    MIPS_INS_MODSUB,
    MIPS_INS_MODU,
    MIPS_INS_MOD_S,
    MIPS_INS_MOD_U,
    MIPS_INS_MOVE,
    MIPS_INS_MOVEP,
    MIPS_INS_MOVF,
    MIPS_INS_MOVN,
    MIPS_INS_MOVT,
    MIPS_INS_MOVZ,
    MIPS_INS_MSUB,
    MIPS_INS_MSUBF,
    MIPS_INS_MSUBR_Q,
    MIPS_INS_MSUBU,
    MIPS_INS_MSUBV,
    MIPS_INS_MSUB_Q,
    MIPS_INS_MTC0,
    MIPS_INS_MTC1,
    MIPS_INS_MTC2,
    MIPS_INS_MTHC1,
    MIPS_INS_MTHI,
    MIPS_INS_MTHLIP,
    MIPS_INS_MTLO,
    MIPS_INS_MTM0,
    MIPS_INS_MTM1,
    MIPS_INS_MTM2,
    MIPS_INS_MTP0,
    MIPS_INS_MTP1,
    MIPS_INS_MTP2,
    MIPS_INS_MUH,
    MIPS_INS_MUHU,
    MIPS_INS_MULEQ_S,
    MIPS_INS_MULEU_S,
    MIPS_INS_MULQ_RS,
    MIPS_INS_MULQ_S,
    MIPS_INS_MULR_Q,
    MIPS_INS_MULSAQ_S,
    MIPS_INS_MULSA,
    MIPS_INS_MULT,
    MIPS_INS_MULTU,
    MIPS_INS_MULU,
    MIPS_INS_MULV,
    MIPS_INS_MUL_Q,
    MIPS_INS_MUL_S,
    MIPS_INS_NLOC,
    MIPS_INS_NLZC,
    MIPS_INS_NMADD,
    MIPS_INS_NMSUB,
    MIPS_INS_NOR,
    MIPS_INS_NORI,
    MIPS_INS_NOT16,
    MIPS_INS_NOT,
    MIPS_INS_OR,
    MIPS_INS_OR16,
    MIPS_INS_ORI,
    MIPS_INS_PACKRL,
    MIPS_INS_PAUSE,
    MIPS_INS_PCKEV,
    MIPS_INS_PCKOD,
    MIPS_INS_PCNT,
    MIPS_INS_PICK,
    MIPS_INS_POP,
    MIPS_INS_PRECEQU,
    MIPS_INS_PRECEQ,
    MIPS_INS_PRECEU,
    MIPS_INS_PRECRQU_S,
    MIPS_INS_PRECRQ,
    MIPS_INS_PRECRQ_RS,
    MIPS_INS_PRECR,
    MIPS_INS_PRECR_SRA,
    MIPS_INS_PRECR_SRA_R,
    MIPS_INS_PREF,
    MIPS_INS_PREPEND,
    MIPS_INS_RADDU,
    MIPS_INS_RDDSP,
    MIPS_INS_RDHWR,
    MIPS_INS_REPLV,
    MIPS_INS_REPL,
    MIPS_INS_RINT,
    MIPS_INS_ROTR,
    MIPS_INS_ROTRV,
    MIPS_INS_ROUND,
    MIPS_INS_SAT_S,
    MIPS_INS_SAT_U,
    MIPS_INS_SB,
    MIPS_INS_SB16,
    MIPS_INS_SC,
    MIPS_INS_SCD,
    MIPS_INS_SD,
    MIPS_INS_SDBBP,
    MIPS_INS_SDBBP16,
    MIPS_INS_SDC1,
    MIPS_INS_SDC2,
    MIPS_INS_SDC3,
    MIPS_INS_SDL,
    MIPS_INS_SDR,
    MIPS_INS_SDXC1,
    MIPS_INS_SEB,
    MIPS_INS_SEH,
    MIPS_INS_SELEQZ,
    MIPS_INS_SELNEZ,
    MIPS_INS_SEL,
    MIPS_INS_SEQ,
    MIPS_INS_SEQI,
    MIPS_INS_SH,
    MIPS_INS_SH16,
    MIPS_INS_SHF,
    MIPS_INS_SHILO,
    MIPS_INS_SHILOV,
    MIPS_INS_SHLLV,
    MIPS_INS_SHLLV_S,
    MIPS_INS_SHLL,
    MIPS_INS_SHLL_S,
    MIPS_INS_SHRAV,
    MIPS_INS_SHRAV_R,
    MIPS_INS_SHRA,
    MIPS_INS_SHRA_R,
    MIPS_INS_SHRLV,
    MIPS_INS_SHRL,
    MIPS_INS_SLDI,
    MIPS_INS_SLD,
    MIPS_INS_SLL,
    MIPS_INS_SLL16,
    MIPS_INS_SLLI,
    MIPS_INS_SLLV,
    MIPS_INS_SLT,
    MIPS_INS_SLTI,
    MIPS_INS_SLTIU,
    MIPS_INS_SLTU,
    MIPS_INS_SNE,
    MIPS_INS_SNEI,
    MIPS_INS_SPLATI,
    MIPS_INS_SPLAT,
    MIPS_INS_SRA,
    MIPS_INS_SRAI,
    MIPS_INS_SRARI,
    MIPS_INS_SRAR,
    MIPS_INS_SRAV,
    MIPS_INS_SRL,
    MIPS_INS_SRL16,
    MIPS_INS_SRLI,
    MIPS_INS_SRLRI,
    MIPS_INS_SRLR,
    MIPS_INS_SRLV,
    MIPS_INS_SSNOP,
    MIPS_INS_ST,
    MIPS_INS_SUBQH,
    MIPS_INS_SUBQH_R,
    MIPS_INS_SUBQ,
    MIPS_INS_SUBQ_S,
    MIPS_INS_SUBSUS_U,
    MIPS_INS_SUBSUU_S,
    MIPS_INS_SUBS_S,
    MIPS_INS_SUBS_U,
    MIPS_INS_SUBU16,
    MIPS_INS_SUBUH,
    MIPS_INS_SUBUH_R,
    MIPS_INS_SUBU,
    MIPS_INS_SUBU_S,
    MIPS_INS_SUBVI,
    MIPS_INS_SUBV,
    MIPS_INS_SUXC1,
    MIPS_INS_SW,
    MIPS_INS_SW16,
    MIPS_INS_SWC1,
    MIPS_INS_SWC2,
    MIPS_INS_SWC3,
    MIPS_INS_SWL,
    MIPS_INS_SWM16,
    MIPS_INS_SWM32,
    MIPS_INS_SWP,
    MIPS_INS_SWR,
    MIPS_INS_SWXC1,
    MIPS_INS_SYNC,
    MIPS_INS_SYNCI,
    MIPS_INS_SYSCALL,
    MIPS_INS_TEQ,
    MIPS_INS_TEQI,
    MIPS_INS_TGE,
    MIPS_INS_TGEI,
    MIPS_INS_TGEIU,
    MIPS_INS_TGEU,
    MIPS_INS_TLBP,
    MIPS_INS_TLBR,
    MIPS_INS_TLBWI,
    MIPS_INS_TLBWR,
    MIPS_INS_TLT,
    MIPS_INS_TLTI,
    MIPS_INS_TLTIU,
    MIPS_INS_TLTU,
    MIPS_INS_TNE,
    MIPS_INS_TNEI,
    MIPS_INS_TRUNC,
    MIPS_INS_V3MULU,
    MIPS_INS_VMM0,
    MIPS_INS_VMULU,
    MIPS_INS_VSHF,
    MIPS_INS_WAIT,
    MIPS_INS_WRDSP,
    MIPS_INS_WSBH,
    MIPS_INS_XOR,
    MIPS_INS_XOR16,
    MIPS_INS_XORI,

    //> some alias instructions
    MIPS_INS_NOP,
    MIPS_INS_NEGU,

    //> special instructions
    MIPS_INS_JALR_HB,   // jump and link with Hazard Barrier
    MIPS_INS_JR_HB,     // jump register with Hazard Barrier

    MIPS_INS_ENDING,
} mips_insn;

//> Group of MIPS instructions
typedef enum mips_insn_group
{
    MIPS_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    MIPS_GRP_JUMP,  // = CS_GRP_JUMP
    // all call instructions
    MIPS_GRP_CALL,  // = CS_GRP_CALL
    // all return instructions
    MIPS_GRP_RET,   // = CS_GRP_RET
    // all interrupt instructions (int+syscall)
    MIPS_GRP_INT,   // = CS_GRP_INT
    // all interrupt return instructions
    MIPS_GRP_IRET,  // = CS_GRP_IRET
    // all privileged instructions
    MIPS_GRP_PRIVILEGE, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    MIPS_GRP_BITCOUNT = 128,
    MIPS_GRP_DSP,
    MIPS_GRP_DSPR2,
    MIPS_GRP_FPIDX,
    MIPS_GRP_MSA,
    MIPS_GRP_MIPS32R2,
    MIPS_GRP_MIPS64,
    MIPS_GRP_MIPS64R2,
    MIPS_GRP_SEINREG,
    MIPS_GRP_STDENC,
    MIPS_GRP_SWAP,
    MIPS_GRP_MICROMIPS,
    MIPS_GRP_MIPS16MODE,
    MIPS_GRP_FP64BIT,
    MIPS_GRP_NONANSFPMATH,
    MIPS_GRP_NOTFP64BIT,
    MIPS_GRP_NOTINMICROMIPS,
    MIPS_GRP_NOTNACL,
    MIPS_GRP_NOTMIPS32R6,
    MIPS_GRP_NOTMIPS64R6,
    MIPS_GRP_CNMIPS,
    MIPS_GRP_MIPS32,
    MIPS_GRP_MIPS32R6,
    MIPS_GRP_MIPS64R6,
    MIPS_GRP_MIPS2,
    MIPS_GRP_MIPS3,
    MIPS_GRP_MIPS3_32,
    MIPS_GRP_MIPS3_32R2,
    MIPS_GRP_MIPS4_32,
    MIPS_GRP_MIPS4_32R2,
    MIPS_GRP_MIPS5_32R2,
    MIPS_GRP_GP32BIT,
    MIPS_GRP_GP64BIT,

    MIPS_GRP_ENDING,
} mips_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/platform.h
================================================
/* Capstone Disassembly Engine */
/* By Axel Souchet & Nguyen Anh Quynh, 2014 */

#ifndef CAPSTONE_PLATFORM_H
#define CAPSTONE_PLATFORM_H


// handle C99 issue (for pre-2013 VisualStudio)
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < 1800) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif  // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif  // (_MSC_VER < 1800) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif  // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))


// handle inttypes.h / stdint.h compatibility
#if defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)
#include "windowsce/stdint.h"
#endif  // defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)

#if defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))
// this system does not have inttypes.h

#if defined(_MSC_VER) && (_MSC_VER < 1600 || defined(_KERNEL_MODE))
// this system does not have stdint.h
typedef signed char  int8_t;
typedef signed short int16_t;
typedef signed int   int32_t;
typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int   uint32_t;
typedef signed long long   int64_t;
typedef unsigned long long uint64_t;

#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64
#endif  // defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE))

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8         __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8         __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8         __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8         __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8         __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8         __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16        "hd"
#define PRIi16        "hi"
#define PRIo16        "ho"
#define PRIu16        "hu"
#define PRIx16        "hx"
#define PRIX16        "hX"

#if defined(_MSC_VER) && _MSC_VER <= 1700
#define PRId32        "ld"
#define PRIi32        "li"
#define PRIo32        "lo"
#define PRIu32        "lu"
#define PRIx32        "lx"
#define PRIX32        "lX"
#else   // OSX
#define PRId32        "d"
#define PRIi32        "i"
#define PRIo32        "o"
#define PRIu32        "u"
#define PRIx32        "x"
#define PRIX32        "X"
#endif  // defined(_MSC_VER) && _MSC_VER <= 1700

#if defined(_MSC_VER) && _MSC_VER <= 1700
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64        __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64        __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64        __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64        __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64        __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64        __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif  // defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))

#endif



================================================
File: pluginsdk/capstone/ppc.h
================================================
#ifndef CAPSTONE_PPC_H
#define CAPSTONE_PPC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> PPC branch codes for some branch instructions
typedef enum ppc_bc
{
    PPC_BC_INVALID  = 0,
    PPC_BC_LT       = (0 << 5) | 12,
    PPC_BC_LE       = (1 << 5) |  4,
    PPC_BC_EQ       = (2 << 5) | 12,
    PPC_BC_GE       = (0 << 5) |  4,
    PPC_BC_GT       = (1 << 5) | 12,
    PPC_BC_NE       = (2 << 5) |  4,
    PPC_BC_UN       = (3 << 5) | 12,
    PPC_BC_NU       = (3 << 5) |  4,

    // extra conditions
    PPC_BC_SO = (4 << 5) | 12,  // summary overflow
    PPC_BC_NS = (4 << 5) | 4,   // not summary overflow
} ppc_bc;

//> PPC branch hint for some branch instructions
typedef enum ppc_bh
{
    PPC_BH_INVALID = 0, // no hint
    PPC_BH_PLUS,    // PLUS hint
    PPC_BH_MINUS,   // MINUS hint
} ppc_bh;

//> Operand type for instruction's operands
typedef enum ppc_op_type
{
    PPC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    PPC_OP_REG, // = CS_OP_REG (Register operand).
    PPC_OP_IMM, // = CS_OP_IMM (Immediate operand).
    PPC_OP_MEM, // = CS_OP_MEM (Memory operand).
    PPC_OP_CRX = 64,    // Condition Register field
} ppc_op_type;

//> PPC registers
typedef enum ppc_reg
{
    PPC_REG_INVALID = 0,

    PPC_REG_CARRY,
    PPC_REG_CR0,
    PPC_REG_CR1,
    PPC_REG_CR2,
    PPC_REG_CR3,
    PPC_REG_CR4,
    PPC_REG_CR5,
    PPC_REG_CR6,
    PPC_REG_CR7,
    PPC_REG_CTR,
    PPC_REG_F0,
    PPC_REG_F1,
    PPC_REG_F2,
    PPC_REG_F3,
    PPC_REG_F4,
    PPC_REG_F5,
    PPC_REG_F6,
    PPC_REG_F7,
    PPC_REG_F8,
    PPC_REG_F9,
    PPC_REG_F10,
    PPC_REG_F11,
    PPC_REG_F12,
    PPC_REG_F13,
    PPC_REG_F14,
    PPC_REG_F15,
    PPC_REG_F16,
    PPC_REG_F17,
    PPC_REG_F18,
    PPC_REG_F19,
    PPC_REG_F20,
    PPC_REG_F21,
    PPC_REG_F22,
    PPC_REG_F23,
    PPC_REG_F24,
    PPC_REG_F25,
    PPC_REG_F26,
    PPC_REG_F27,
    PPC_REG_F28,
    PPC_REG_F29,
    PPC_REG_F30,
    PPC_REG_F31,
    PPC_REG_LR,
    PPC_REG_R0,
    PPC_REG_R1,
    PPC_REG_R2,
    PPC_REG_R3,
    PPC_REG_R4,
    PPC_REG_R5,
    PPC_REG_R6,
    PPC_REG_R7,
    PPC_REG_R8,
    PPC_REG_R9,
    PPC_REG_R10,
    PPC_REG_R11,
    PPC_REG_R12,
    PPC_REG_R13,
    PPC_REG_R14,
    PPC_REG_R15,
    PPC_REG_R16,
    PPC_REG_R17,
    PPC_REG_R18,
    PPC_REG_R19,
    PPC_REG_R20,
    PPC_REG_R21,
    PPC_REG_R22,
    PPC_REG_R23,
    PPC_REG_R24,
    PPC_REG_R25,
    PPC_REG_R26,
    PPC_REG_R27,
    PPC_REG_R28,
    PPC_REG_R29,
    PPC_REG_R30,
    PPC_REG_R31,
    PPC_REG_V0,
    PPC_REG_V1,
    PPC_REG_V2,
    PPC_REG_V3,
    PPC_REG_V4,
    PPC_REG_V5,
    PPC_REG_V6,
    PPC_REG_V7,
    PPC_REG_V8,
    PPC_REG_V9,
    PPC_REG_V10,
    PPC_REG_V11,
    PPC_REG_V12,
    PPC_REG_V13,
    PPC_REG_V14,
    PPC_REG_V15,
    PPC_REG_V16,
    PPC_REG_V17,
    PPC_REG_V18,
    PPC_REG_V19,
    PPC_REG_V20,
    PPC_REG_V21,
    PPC_REG_V22,
    PPC_REG_V23,
    PPC_REG_V24,
    PPC_REG_V25,
    PPC_REG_V26,
    PPC_REG_V27,
    PPC_REG_V28,
    PPC_REG_V29,
    PPC_REG_V30,
    PPC_REG_V31,
    PPC_REG_VRSAVE,
    PPC_REG_VS0,
    PPC_REG_VS1,
    PPC_REG_VS2,
    PPC_REG_VS3,
    PPC_REG_VS4,
    PPC_REG_VS5,
    PPC_REG_VS6,
    PPC_REG_VS7,
    PPC_REG_VS8,
    PPC_REG_VS9,
    PPC_REG_VS10,
    PPC_REG_VS11,
    PPC_REG_VS12,
    PPC_REG_VS13,
    PPC_REG_VS14,
    PPC_REG_VS15,
    PPC_REG_VS16,
    PPC_REG_VS17,
    PPC_REG_VS18,
    PPC_REG_VS19,
    PPC_REG_VS20,
    PPC_REG_VS21,
    PPC_REG_VS22,
    PPC_REG_VS23,
    PPC_REG_VS24,
    PPC_REG_VS25,
    PPC_REG_VS26,
    PPC_REG_VS27,
    PPC_REG_VS28,
    PPC_REG_VS29,
    PPC_REG_VS30,
    PPC_REG_VS31,
    PPC_REG_VS32,
    PPC_REG_VS33,
    PPC_REG_VS34,
    PPC_REG_VS35,
    PPC_REG_VS36,
    PPC_REG_VS37,
    PPC_REG_VS38,
    PPC_REG_VS39,
    PPC_REG_VS40,
    PPC_REG_VS41,
    PPC_REG_VS42,
    PPC_REG_VS43,
    PPC_REG_VS44,
    PPC_REG_VS45,
    PPC_REG_VS46,
    PPC_REG_VS47,
    PPC_REG_VS48,
    PPC_REG_VS49,
    PPC_REG_VS50,
    PPC_REG_VS51,
    PPC_REG_VS52,
    PPC_REG_VS53,
    PPC_REG_VS54,
    PPC_REG_VS55,
    PPC_REG_VS56,
    PPC_REG_VS57,
    PPC_REG_VS58,
    PPC_REG_VS59,
    PPC_REG_VS60,
    PPC_REG_VS61,
    PPC_REG_VS62,
    PPC_REG_VS63,
    PPC_REG_Q0,
    PPC_REG_Q1,
    PPC_REG_Q2,
    PPC_REG_Q3,
    PPC_REG_Q4,
    PPC_REG_Q5,
    PPC_REG_Q6,
    PPC_REG_Q7,
    PPC_REG_Q8,
    PPC_REG_Q9,
    PPC_REG_Q10,
    PPC_REG_Q11,
    PPC_REG_Q12,
    PPC_REG_Q13,
    PPC_REG_Q14,
    PPC_REG_Q15,
    PPC_REG_Q16,
    PPC_REG_Q17,
    PPC_REG_Q18,
    PPC_REG_Q19,
    PPC_REG_Q20,
    PPC_REG_Q21,
    PPC_REG_Q22,
    PPC_REG_Q23,
    PPC_REG_Q24,
    PPC_REG_Q25,
    PPC_REG_Q26,
    PPC_REG_Q27,
    PPC_REG_Q28,
    PPC_REG_Q29,
    PPC_REG_Q30,
    PPC_REG_Q31,

    // extra registers for PPCMapping.c
    PPC_REG_RM,
    PPC_REG_CTR8,
    PPC_REG_LR8,
    PPC_REG_CR1EQ,
    PPC_REG_X2,

    PPC_REG_ENDING,   // <-- mark the end of the list of registers
} ppc_reg;

// Instruction's operand referring to memory
// This is associated with PPC_OP_MEM operand type above
typedef struct ppc_op_mem
{
    ppc_reg base;   // base register
    int32_t disp;   // displacement/offset value
} ppc_op_mem;

typedef struct ppc_op_crx
{
    unsigned int scale;
    ppc_reg reg;
    ppc_bc cond;
} ppc_op_crx;

// Instruction operand
typedef struct cs_ppc_op
{
    ppc_op_type type;   // operand type
    union
    {
        ppc_reg reg;    // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        ppc_op_mem mem;     // base/disp value for MEM operand
        ppc_op_crx crx;     // operand with condition register
    };
} cs_ppc_op;

// Instruction structure
typedef struct cs_ppc
{
    // branch code for branch instructions
    ppc_bc bc;

    // branch hint for branch instructions
    ppc_bh bh;

    // if update_cr0 = True, then this 'dot' insn updates CR0
    bool update_cr0;

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_ppc_op operands[8]; // operands for this instruction.
} cs_ppc;

//> PPC instruction
typedef enum ppc_insn
{
    PPC_INS_INVALID = 0,

    PPC_INS_ADD,
    PPC_INS_ADDC,
    PPC_INS_ADDE,
    PPC_INS_ADDI,
    PPC_INS_ADDIC,
    PPC_INS_ADDIS,
    PPC_INS_ADDME,
    PPC_INS_ADDZE,
    PPC_INS_AND,
    PPC_INS_ANDC,
    PPC_INS_ANDIS,
    PPC_INS_ANDI,
    PPC_INS_ATTN,
    PPC_INS_B,
    PPC_INS_BA,
    PPC_INS_BC,
    PPC_INS_BCCTR,
    PPC_INS_BCCTRL,
    PPC_INS_BCL,
    PPC_INS_BCLR,
    PPC_INS_BCLRL,
    PPC_INS_BCTR,
    PPC_INS_BCTRL,
    PPC_INS_BCT,
    PPC_INS_BDNZ,
    PPC_INS_BDNZA,
    PPC_INS_BDNZL,
    PPC_INS_BDNZLA,
    PPC_INS_BDNZLR,
    PPC_INS_BDNZLRL,
    PPC_INS_BDZ,
    PPC_INS_BDZA,
    PPC_INS_BDZL,
    PPC_INS_BDZLA,
    PPC_INS_BDZLR,
    PPC_INS_BDZLRL,
    PPC_INS_BL,
    PPC_INS_BLA,
    PPC_INS_BLR,
    PPC_INS_BLRL,
    PPC_INS_BRINC,
    PPC_INS_CMPB,
    PPC_INS_CMPD,
    PPC_INS_CMPDI,
    PPC_INS_CMPLD,
    PPC_INS_CMPLDI,
    PPC_INS_CMPLW,
    PPC_INS_CMPLWI,
    PPC_INS_CMPW,
    PPC_INS_CMPWI,
    PPC_INS_CNTLZD,
    PPC_INS_CNTLZW,
    PPC_INS_CREQV,
    PPC_INS_CRXOR,
    PPC_INS_CRAND,
    PPC_INS_CRANDC,
    PPC_INS_CRNAND,
    PPC_INS_CRNOR,
    PPC_INS_CROR,
    PPC_INS_CRORC,
    PPC_INS_DCBA,
    PPC_INS_DCBF,
    PPC_INS_DCBI,
    PPC_INS_DCBST,
    PPC_INS_DCBT,
    PPC_INS_DCBTST,
    PPC_INS_DCBZ,
    PPC_INS_DCBZL,
    PPC_INS_DCCCI,
    PPC_INS_DIVD,
    PPC_INS_DIVDU,
    PPC_INS_DIVW,
    PPC_INS_DIVWU,
    PPC_INS_DSS,
    PPC_INS_DSSALL,
    PPC_INS_DST,
    PPC_INS_DSTST,
    PPC_INS_DSTSTT,
    PPC_INS_DSTT,
    PPC_INS_EQV,
    PPC_INS_EVABS,
    PPC_INS_EVADDIW,
    PPC_INS_EVADDSMIAAW,
    PPC_INS_EVADDSSIAAW,
    PPC_INS_EVADDUMIAAW,
    PPC_INS_EVADDUSIAAW,
    PPC_INS_EVADDW,
    PPC_INS_EVAND,
    PPC_INS_EVANDC,
    PPC_INS_EVCMPEQ,
    PPC_INS_EVCMPGTS,
    PPC_INS_EVCMPGTU,
    PPC_INS_EVCMPLTS,
    PPC_INS_EVCMPLTU,
    PPC_INS_EVCNTLSW,
    PPC_INS_EVCNTLZW,
    PPC_INS_EVDIVWS,
    PPC_INS_EVDIVWU,
    PPC_INS_EVEQV,
    PPC_INS_EVEXTSB,
    PPC_INS_EVEXTSH,
    PPC_INS_EVLDD,
    PPC_INS_EVLDDX,
    PPC_INS_EVLDH,
    PPC_INS_EVLDHX,
    PPC_INS_EVLDW,
    PPC_INS_EVLDWX,
    PPC_INS_EVLHHESPLAT,
    PPC_INS_EVLHHESPLATX,
    PPC_INS_EVLHHOSSPLAT,
    PPC_INS_EVLHHOSSPLATX,
    PPC_INS_EVLHHOUSPLAT,
    PPC_INS_EVLHHOUSPLATX,
    PPC_INS_EVLWHE,
    PPC_INS_EVLWHEX,
    PPC_INS_EVLWHOS,
    PPC_INS_EVLWHOSX,
    PPC_INS_EVLWHOU,
    PPC_INS_EVLWHOUX,
    PPC_INS_EVLWHSPLAT,
    PPC_INS_EVLWHSPLATX,
    PPC_INS_EVLWWSPLAT,
    PPC_INS_EVLWWSPLATX,
    PPC_INS_EVMERGEHI,
    PPC_INS_EVMERGEHILO,
    PPC_INS_EVMERGELO,
    PPC_INS_EVMERGELOHI,
    PPC_INS_EVMHEGSMFAA,
    PPC_INS_EVMHEGSMFAN,
    PPC_INS_EVMHEGSMIAA,
    PPC_INS_EVMHEGSMIAN,
    PPC_INS_EVMHEGUMIAA,
    PPC_INS_EVMHEGUMIAN,
    PPC_INS_EVMHESMF,
    PPC_INS_EVMHESMFA,
    PPC_INS_EVMHESMFAAW,
    PPC_INS_EVMHESMFANW,
    PPC_INS_EVMHESMI,
    PPC_INS_EVMHESMIA,
    PPC_INS_EVMHESMIAAW,
    PPC_INS_EVMHESMIANW,
    PPC_INS_EVMHESSF,
    PPC_INS_EVMHESSFA,
    PPC_INS_EVMHESSFAAW,
    PPC_INS_EVMHESSFANW,
    PPC_INS_EVMHESSIAAW,
    PPC_INS_EVMHESSIANW,
    PPC_INS_EVMHEUMI,
    PPC_INS_EVMHEUMIA,
    PPC_INS_EVMHEUMIAAW,
    PPC_INS_EVMHEUMIANW,
    PPC_INS_EVMHEUSIAAW,
    PPC_INS_EVMHEUSIANW,
    PPC_INS_EVMHOGSMFAA,
    PPC_INS_EVMHOGSMFAN,
    PPC_INS_EVMHOGSMIAA,
    PPC_INS_EVMHOGSMIAN,
    PPC_INS_EVMHOGUMIAA,
    PPC_INS_EVMHOGUMIAN,
    PPC_INS_EVMHOSMF,
    PPC_INS_EVMHOSMFA,
    PPC_INS_EVMHOSMFAAW,
    PPC_INS_EVMHOSMFANW,
    PPC_INS_EVMHOSMI,
    PPC_INS_EVMHOSMIA,
    PPC_INS_EVMHOSMIAAW,
    PPC_INS_EVMHOSMIANW,
    PPC_INS_EVMHOSSF,
    PPC_INS_EVMHOSSFA,
    PPC_INS_EVMHOSSFAAW,
    PPC_INS_EVMHOSSFANW,
    PPC_INS_EVMHOSSIAAW,
    PPC_INS_EVMHOSSIANW,
    PPC_INS_EVMHOUMI,
    PPC_INS_EVMHOUMIA,
    PPC_INS_EVMHOUMIAAW,
    PPC_INS_EVMHOUMIANW,
    PPC_INS_EVMHOUSIAAW,
    PPC_INS_EVMHOUSIANW,
    PPC_INS_EVMRA,
    PPC_INS_EVMWHSMF,
    PPC_INS_EVMWHSMFA,
    PPC_INS_EVMWHSMI,
    PPC_INS_EVMWHSMIA,
    PPC_INS_EVMWHSSF,
    PPC_INS_EVMWHSSFA,
    PPC_INS_EVMWHUMI,
    PPC_INS_EVMWHUMIA,
    PPC_INS_EVMWLSMIAAW,
    PPC_INS_EVMWLSMIANW,
    PPC_INS_EVMWLSSIAAW,
    PPC_INS_EVMWLSSIANW,
    PPC_INS_EVMWLUMI,
    PPC_INS_EVMWLUMIA,
    PPC_INS_EVMWLUMIAAW,
    PPC_INS_EVMWLUMIANW,
    PPC_INS_EVMWLUSIAAW,
    PPC_INS_EVMWLUSIANW,
    PPC_INS_EVMWSMF,
    PPC_INS_EVMWSMFA,
    PPC_INS_EVMWSMFAA,
    PPC_INS_EVMWSMFAN,
    PPC_INS_EVMWSMI,
    PPC_INS_EVMWSMIA,
    PPC_INS_EVMWSMIAA,
    PPC_INS_EVMWSMIAN,
    PPC_INS_EVMWSSF,
    PPC_INS_EVMWSSFA,
    PPC_INS_EVMWSSFAA,
    PPC_INS_EVMWSSFAN,
    PPC_INS_EVMWUMI,
    PPC_INS_EVMWUMIA,
    PPC_INS_EVMWUMIAA,
    PPC_INS_EVMWUMIAN,
    PPC_INS_EVNAND,
    PPC_INS_EVNEG,
    PPC_INS_EVNOR,
    PPC_INS_EVOR,
    PPC_INS_EVORC,
    PPC_INS_EVRLW,
    PPC_INS_EVRLWI,
    PPC_INS_EVRNDW,
    PPC_INS_EVSLW,
    PPC_INS_EVSLWI,
    PPC_INS_EVSPLATFI,
    PPC_INS_EVSPLATI,
    PPC_INS_EVSRWIS,
    PPC_INS_EVSRWIU,
    PPC_INS_EVSRWS,
    PPC_INS_EVSRWU,
    PPC_INS_EVSTDD,
    PPC_INS_EVSTDDX,
    PPC_INS_EVSTDH,
    PPC_INS_EVSTDHX,
    PPC_INS_EVSTDW,
    PPC_INS_EVSTDWX,
    PPC_INS_EVSTWHE,
    PPC_INS_EVSTWHEX,
    PPC_INS_EVSTWHO,
    PPC_INS_EVSTWHOX,
    PPC_INS_EVSTWWE,
    PPC_INS_EVSTWWEX,
    PPC_INS_EVSTWWO,
    PPC_INS_EVSTWWOX,
    PPC_INS_EVSUBFSMIAAW,
    PPC_INS_EVSUBFSSIAAW,
    PPC_INS_EVSUBFUMIAAW,
    PPC_INS_EVSUBFUSIAAW,
    PPC_INS_EVSUBFW,
    PPC_INS_EVSUBIFW,
    PPC_INS_EVXOR,
    PPC_INS_EXTSB,
    PPC_INS_EXTSH,
    PPC_INS_EXTSW,
    PPC_INS_EIEIO,
    PPC_INS_FABS,
    PPC_INS_FADD,
    PPC_INS_FADDS,
    PPC_INS_FCFID,
    PPC_INS_FCFIDS,
    PPC_INS_FCFIDU,
    PPC_INS_FCFIDUS,
    PPC_INS_FCMPU,
    PPC_INS_FCPSGN,
    PPC_INS_FCTID,
    PPC_INS_FCTIDUZ,
    PPC_INS_FCTIDZ,
    PPC_INS_FCTIW,
    PPC_INS_FCTIWUZ,
    PPC_INS_FCTIWZ,
    PPC_INS_FDIV,
    PPC_INS_FDIVS,
    PPC_INS_FMADD,
    PPC_INS_FMADDS,
    PPC_INS_FMR,
    PPC_INS_FMSUB,
    PPC_INS_FMSUBS,
    PPC_INS_FMUL,
    PPC_INS_FMULS,
    PPC_INS_FNABS,
    PPC_INS_FNEG,
    PPC_INS_FNMADD,
    PPC_INS_FNMADDS,
    PPC_INS_FNMSUB,
    PPC_INS_FNMSUBS,
    PPC_INS_FRE,
    PPC_INS_FRES,
    PPC_INS_FRIM,
    PPC_INS_FRIN,
    PPC_INS_FRIP,
    PPC_INS_FRIZ,
    PPC_INS_FRSP,
    PPC_INS_FRSQRTE,
    PPC_INS_FRSQRTES,
    PPC_INS_FSEL,
    PPC_INS_FSQRT,
    PPC_INS_FSQRTS,
    PPC_INS_FSUB,
    PPC_INS_FSUBS,
    PPC_INS_ICBI,
    PPC_INS_ICBT,
    PPC_INS_ICCCI,
    PPC_INS_ISEL,
    PPC_INS_ISYNC,
    PPC_INS_LA,
    PPC_INS_LBZ,
    PPC_INS_LBZCIX,
    PPC_INS_LBZU,
    PPC_INS_LBZUX,
    PPC_INS_LBZX,
    PPC_INS_LD,
    PPC_INS_LDARX,
    PPC_INS_LDBRX,
    PPC_INS_LDCIX,
    PPC_INS_LDU,
    PPC_INS_LDUX,
    PPC_INS_LDX,
    PPC_INS_LFD,
    PPC_INS_LFDU,
    PPC_INS_LFDUX,
    PPC_INS_LFDX,
    PPC_INS_LFIWAX,
    PPC_INS_LFIWZX,
    PPC_INS_LFS,
    PPC_INS_LFSU,
    PPC_INS_LFSUX,
    PPC_INS_LFSX,
    PPC_INS_LHA,
    PPC_INS_LHAU,
    PPC_INS_LHAUX,
    PPC_INS_LHAX,
    PPC_INS_LHBRX,
    PPC_INS_LHZ,
    PPC_INS_LHZCIX,
    PPC_INS_LHZU,
    PPC_INS_LHZUX,
    PPC_INS_LHZX,
    PPC_INS_LI,
    PPC_INS_LIS,
    PPC_INS_LMW,
    PPC_INS_LSWI,
    PPC_INS_LVEBX,
    PPC_INS_LVEHX,
    PPC_INS_LVEWX,
    PPC_INS_LVSL,
    PPC_INS_LVSR,
    PPC_INS_LVX,
    PPC_INS_LVXL,
    PPC_INS_LWA,
    PPC_INS_LWARX,
    PPC_INS_LWAUX,
    PPC_INS_LWAX,
    PPC_INS_LWBRX,
    PPC_INS_LWZ,
    PPC_INS_LWZCIX,
    PPC_INS_LWZU,
    PPC_INS_LWZUX,
    PPC_INS_LWZX,
    PPC_INS_LXSDX,
    PPC_INS_LXVD2X,
    PPC_INS_LXVDSX,
    PPC_INS_LXVW4X,
    PPC_INS_MBAR,
    PPC_INS_MCRF,
    PPC_INS_MCRFS,
    PPC_INS_MFCR,
    PPC_INS_MFCTR,
    PPC_INS_MFDCR,
    PPC_INS_MFFS,
    PPC_INS_MFLR,
    PPC_INS_MFMSR,
    PPC_INS_MFOCRF,
    PPC_INS_MFSPR,
    PPC_INS_MFSR,
    PPC_INS_MFSRIN,
    PPC_INS_MFTB,
    PPC_INS_MFVSCR,
    PPC_INS_MSYNC,
    PPC_INS_MTCRF,
    PPC_INS_MTCTR,
    PPC_INS_MTDCR,
    PPC_INS_MTFSB0,
    PPC_INS_MTFSB1,
    PPC_INS_MTFSF,
    PPC_INS_MTFSFI,
    PPC_INS_MTLR,
    PPC_INS_MTMSR,
    PPC_INS_MTMSRD,
    PPC_INS_MTOCRF,
    PPC_INS_MTSPR,
    PPC_INS_MTSR,
    PPC_INS_MTSRIN,
    PPC_INS_MTVSCR,
    PPC_INS_MULHD,
    PPC_INS_MULHDU,
    PPC_INS_MULHW,
    PPC_INS_MULHWU,
    PPC_INS_MULLD,
    PPC_INS_MULLI,
    PPC_INS_MULLW,
    PPC_INS_NAND,
    PPC_INS_NEG,
    PPC_INS_NOP,
    PPC_INS_ORI,
    PPC_INS_NOR,
    PPC_INS_OR,
    PPC_INS_ORC,
    PPC_INS_ORIS,
    PPC_INS_POPCNTD,
    PPC_INS_POPCNTW,
    PPC_INS_QVALIGNI,
    PPC_INS_QVESPLATI,
    PPC_INS_QVFABS,
    PPC_INS_QVFADD,
    PPC_INS_QVFADDS,
    PPC_INS_QVFCFID,
    PPC_INS_QVFCFIDS,
    PPC_INS_QVFCFIDU,
    PPC_INS_QVFCFIDUS,
    PPC_INS_QVFCMPEQ,
    PPC_INS_QVFCMPGT,
    PPC_INS_QVFCMPLT,
    PPC_INS_QVFCPSGN,
    PPC_INS_QVFCTID,
    PPC_INS_QVFCTIDU,
    PPC_INS_QVFCTIDUZ,
    PPC_INS_QVFCTIDZ,
    PPC_INS_QVFCTIW,
    PPC_INS_QVFCTIWU,
    PPC_INS_QVFCTIWUZ,
    PPC_INS_QVFCTIWZ,
    PPC_INS_QVFLOGICAL,
    PPC_INS_QVFMADD,
    PPC_INS_QVFMADDS,
    PPC_INS_QVFMR,
    PPC_INS_QVFMSUB,
    PPC_INS_QVFMSUBS,
    PPC_INS_QVFMUL,
    PPC_INS_QVFMULS,
    PPC_INS_QVFNABS,
    PPC_INS_QVFNEG,
    PPC_INS_QVFNMADD,
    PPC_INS_QVFNMADDS,
    PPC_INS_QVFNMSUB,
    PPC_INS_QVFNMSUBS,
    PPC_INS_QVFPERM,
    PPC_INS_QVFRE,
    PPC_INS_QVFRES,
    PPC_INS_QVFRIM,
    PPC_INS_QVFRIN,
    PPC_INS_QVFRIP,
    PPC_INS_QVFRIZ,
    PPC_INS_QVFRSP,
    PPC_INS_QVFRSQRTE,
    PPC_INS_QVFRSQRTES,
    PPC_INS_QVFSEL,
    PPC_INS_QVFSUB,
    PPC_INS_QVFSUBS,
    PPC_INS_QVFTSTNAN,
    PPC_INS_QVFXMADD,
    PPC_INS_QVFXMADDS,
    PPC_INS_QVFXMUL,
    PPC_INS_QVFXMULS,
    PPC_INS_QVFXXCPNMADD,
    PPC_INS_QVFXXCPNMADDS,
    PPC_INS_QVFXXMADD,
    PPC_INS_QVFXXMADDS,
    PPC_INS_QVFXXNPMADD,
    PPC_INS_QVFXXNPMADDS,
    PPC_INS_QVGPCI,
    PPC_INS_QVLFCDUX,
    PPC_INS_QVLFCDUXA,
    PPC_INS_QVLFCDX,
    PPC_INS_QVLFCDXA,
    PPC_INS_QVLFCSUX,
    PPC_INS_QVLFCSUXA,
    PPC_INS_QVLFCSX,
    PPC_INS_QVLFCSXA,
    PPC_INS_QVLFDUX,
    PPC_INS_QVLFDUXA,
    PPC_INS_QVLFDX,
    PPC_INS_QVLFDXA,
    PPC_INS_QVLFIWAX,
    PPC_INS_QVLFIWAXA,
    PPC_INS_QVLFIWZX,
    PPC_INS_QVLFIWZXA,
    PPC_INS_QVLFSUX,
    PPC_INS_QVLFSUXA,
    PPC_INS_QVLFSX,
    PPC_INS_QVLFSXA,
    PPC_INS_QVLPCLDX,
    PPC_INS_QVLPCLSX,
    PPC_INS_QVLPCRDX,
    PPC_INS_QVLPCRSX,
    PPC_INS_QVSTFCDUX,
    PPC_INS_QVSTFCDUXA,
    PPC_INS_QVSTFCDUXI,
    PPC_INS_QVSTFCDUXIA,
    PPC_INS_QVSTFCDX,
    PPC_INS_QVSTFCDXA,
    PPC_INS_QVSTFCDXI,
    PPC_INS_QVSTFCDXIA,
    PPC_INS_QVSTFCSUX,
    PPC_INS_QVSTFCSUXA,
    PPC_INS_QVSTFCSUXI,
    PPC_INS_QVSTFCSUXIA,
    PPC_INS_QVSTFCSX,
    PPC_INS_QVSTFCSXA,
    PPC_INS_QVSTFCSXI,
    PPC_INS_QVSTFCSXIA,
    PPC_INS_QVSTFDUX,
    PPC_INS_QVSTFDUXA,
    PPC_INS_QVSTFDUXI,
    PPC_INS_QVSTFDUXIA,
    PPC_INS_QVSTFDX,
    PPC_INS_QVSTFDXA,
    PPC_INS_QVSTFDXI,
    PPC_INS_QVSTFDXIA,
    PPC_INS_QVSTFIWX,
    PPC_INS_QVSTFIWXA,
    PPC_INS_QVSTFSUX,
    PPC_INS_QVSTFSUXA,
    PPC_INS_QVSTFSUXI,
    PPC_INS_QVSTFSUXIA,
    PPC_INS_QVSTFSX,
    PPC_INS_QVSTFSXA,
    PPC_INS_QVSTFSXI,
    PPC_INS_QVSTFSXIA,
    PPC_INS_RFCI,
    PPC_INS_RFDI,
    PPC_INS_RFI,
    PPC_INS_RFID,
    PPC_INS_RFMCI,
    PPC_INS_RLDCL,
    PPC_INS_RLDCR,
    PPC_INS_RLDIC,
    PPC_INS_RLDICL,
    PPC_INS_RLDICR,
    PPC_INS_RLDIMI,
    PPC_INS_RLWIMI,
    PPC_INS_RLWINM,
    PPC_INS_RLWNM,
    PPC_INS_SC,
    PPC_INS_SLBIA,
    PPC_INS_SLBIE,
    PPC_INS_SLBMFEE,
    PPC_INS_SLBMTE,
    PPC_INS_SLD,
    PPC_INS_SLW,
    PPC_INS_SRAD,
    PPC_INS_SRADI,
    PPC_INS_SRAW,
    PPC_INS_SRAWI,
    PPC_INS_SRD,
    PPC_INS_SRW,
    PPC_INS_STB,
    PPC_INS_STBCIX,
    PPC_INS_STBU,
    PPC_INS_STBUX,
    PPC_INS_STBX,
    PPC_INS_STD,
    PPC_INS_STDBRX,
    PPC_INS_STDCIX,
    PPC_INS_STDCX,
    PPC_INS_STDU,
    PPC_INS_STDUX,
    PPC_INS_STDX,
    PPC_INS_STFD,
    PPC_INS_STFDU,
    PPC_INS_STFDUX,
    PPC_INS_STFDX,
    PPC_INS_STFIWX,
    PPC_INS_STFS,
    PPC_INS_STFSU,
    PPC_INS_STFSUX,
    PPC_INS_STFSX,
    PPC_INS_STH,
    PPC_INS_STHBRX,
    PPC_INS_STHCIX,
    PPC_INS_STHU,
    PPC_INS_STHUX,
    PPC_INS_STHX,
    PPC_INS_STMW,
    PPC_INS_STSWI,
    PPC_INS_STVEBX,
    PPC_INS_STVEHX,
    PPC_INS_STVEWX,
    PPC_INS_STVX,
    PPC_INS_STVXL,
    PPC_INS_STW,
    PPC_INS_STWBRX,
    PPC_INS_STWCIX,
    PPC_INS_STWCX,
    PPC_INS_STWU,
    PPC_INS_STWUX,
    PPC_INS_STWX,
    PPC_INS_STXSDX,
    PPC_INS_STXVD2X,
    PPC_INS_STXVW4X,
    PPC_INS_SUBF,
    PPC_INS_SUBFC,
    PPC_INS_SUBFE,
    PPC_INS_SUBFIC,
    PPC_INS_SUBFME,
    PPC_INS_SUBFZE,
    PPC_INS_SYNC,
    PPC_INS_TD,
    PPC_INS_TDI,
    PPC_INS_TLBIA,
    PPC_INS_TLBIE,
    PPC_INS_TLBIEL,
    PPC_INS_TLBIVAX,
    PPC_INS_TLBLD,
    PPC_INS_TLBLI,
    PPC_INS_TLBRE,
    PPC_INS_TLBSX,
    PPC_INS_TLBSYNC,
    PPC_INS_TLBWE,
    PPC_INS_TRAP,
    PPC_INS_TW,
    PPC_INS_TWI,
    PPC_INS_VADDCUW,
    PPC_INS_VADDFP,
    PPC_INS_VADDSBS,
    PPC_INS_VADDSHS,
    PPC_INS_VADDSWS,
    PPC_INS_VADDUBM,
    PPC_INS_VADDUBS,
    PPC_INS_VADDUDM,
    PPC_INS_VADDUHM,
    PPC_INS_VADDUHS,
    PPC_INS_VADDUWM,
    PPC_INS_VADDUWS,
    PPC_INS_VAND,
    PPC_INS_VANDC,
    PPC_INS_VAVGSB,
    PPC_INS_VAVGSH,
    PPC_INS_VAVGSW,
    PPC_INS_VAVGUB,
    PPC_INS_VAVGUH,
    PPC_INS_VAVGUW,
    PPC_INS_VCFSX,
    PPC_INS_VCFUX,
    PPC_INS_VCLZB,
    PPC_INS_VCLZD,
    PPC_INS_VCLZH,
    PPC_INS_VCLZW,
    PPC_INS_VCMPBFP,
    PPC_INS_VCMPEQFP,
    PPC_INS_VCMPEQUB,
    PPC_INS_VCMPEQUD,
    PPC_INS_VCMPEQUH,
    PPC_INS_VCMPEQUW,
    PPC_INS_VCMPGEFP,
    PPC_INS_VCMPGTFP,
    PPC_INS_VCMPGTSB,
    PPC_INS_VCMPGTSD,
    PPC_INS_VCMPGTSH,
    PPC_INS_VCMPGTSW,
    PPC_INS_VCMPGTUB,
    PPC_INS_VCMPGTUD,
    PPC_INS_VCMPGTUH,
    PPC_INS_VCMPGTUW,
    PPC_INS_VCTSXS,
    PPC_INS_VCTUXS,
    PPC_INS_VEQV,
    PPC_INS_VEXPTEFP,
    PPC_INS_VLOGEFP,
    PPC_INS_VMADDFP,
    PPC_INS_VMAXFP,
    PPC_INS_VMAXSB,
    PPC_INS_VMAXSD,
    PPC_INS_VMAXSH,
    PPC_INS_VMAXSW,
    PPC_INS_VMAXUB,
    PPC_INS_VMAXUD,
    PPC_INS_VMAXUH,
    PPC_INS_VMAXUW,
    PPC_INS_VMHADDSHS,
    PPC_INS_VMHRADDSHS,
    PPC_INS_VMINUD,
    PPC_INS_VMINFP,
    PPC_INS_VMINSB,
    PPC_INS_VMINSD,
    PPC_INS_VMINSH,
    PPC_INS_VMINSW,
    PPC_INS_VMINUB,
    PPC_INS_VMINUH,
    PPC_INS_VMINUW,
    PPC_INS_VMLADDUHM,
    PPC_INS_VMRGHB,
    PPC_INS_VMRGHH,
    PPC_INS_VMRGHW,
    PPC_INS_VMRGLB,
    PPC_INS_VMRGLH,
    PPC_INS_VMRGLW,
    PPC_INS_VMSUMMBM,
    PPC_INS_VMSUMSHM,
    PPC_INS_VMSUMSHS,
    PPC_INS_VMSUMUBM,
    PPC_INS_VMSUMUHM,
    PPC_INS_VMSUMUHS,
    PPC_INS_VMULESB,
    PPC_INS_VMULESH,
    PPC_INS_VMULESW,
    PPC_INS_VMULEUB,
    PPC_INS_VMULEUH,
    PPC_INS_VMULEUW,
    PPC_INS_VMULOSB,
    PPC_INS_VMULOSH,
    PPC_INS_VMULOSW,
    PPC_INS_VMULOUB,
    PPC_INS_VMULOUH,
    PPC_INS_VMULOUW,
    PPC_INS_VMULUWM,
    PPC_INS_VNAND,
    PPC_INS_VNMSUBFP,
    PPC_INS_VNOR,
    PPC_INS_VOR,
    PPC_INS_VORC,
    PPC_INS_VPERM,
    PPC_INS_VPKPX,
    PPC_INS_VPKSHSS,
    PPC_INS_VPKSHUS,
    PPC_INS_VPKSWSS,
    PPC_INS_VPKSWUS,
    PPC_INS_VPKUHUM,
    PPC_INS_VPKUHUS,
    PPC_INS_VPKUWUM,
    PPC_INS_VPKUWUS,
    PPC_INS_VPOPCNTB,
    PPC_INS_VPOPCNTD,
    PPC_INS_VPOPCNTH,
    PPC_INS_VPOPCNTW,
    PPC_INS_VREFP,
    PPC_INS_VRFIM,
    PPC_INS_VRFIN,
    PPC_INS_VRFIP,
    PPC_INS_VRFIZ,
    PPC_INS_VRLB,
    PPC_INS_VRLD,
    PPC_INS_VRLH,
    PPC_INS_VRLW,
    PPC_INS_VRSQRTEFP,
    PPC_INS_VSEL,
    PPC_INS_VSL,
    PPC_INS_VSLB,
    PPC_INS_VSLD,
    PPC_INS_VSLDOI,
    PPC_INS_VSLH,
    PPC_INS_VSLO,
    PPC_INS_VSLW,
    PPC_INS_VSPLTB,
    PPC_INS_VSPLTH,
    PPC_INS_VSPLTISB,
    PPC_INS_VSPLTISH,
    PPC_INS_VSPLTISW,
    PPC_INS_VSPLTW,
    PPC_INS_VSR,
    PPC_INS_VSRAB,
    PPC_INS_VSRAD,
    PPC_INS_VSRAH,
    PPC_INS_VSRAW,
    PPC_INS_VSRB,
    PPC_INS_VSRD,
    PPC_INS_VSRH,
    PPC_INS_VSRO,
    PPC_INS_VSRW,
    PPC_INS_VSUBCUW,
    PPC_INS_VSUBFP,
    PPC_INS_VSUBSBS,
    PPC_INS_VSUBSHS,
    PPC_INS_VSUBSWS,
    PPC_INS_VSUBUBM,
    PPC_INS_VSUBUBS,
    PPC_INS_VSUBUDM,
    PPC_INS_VSUBUHM,
    PPC_INS_VSUBUHS,
    PPC_INS_VSUBUWM,
    PPC_INS_VSUBUWS,
    PPC_INS_VSUM2SWS,
    PPC_INS_VSUM4SBS,
    PPC_INS_VSUM4SHS,
    PPC_INS_VSUM4UBS,
    PPC_INS_VSUMSWS,
    PPC_INS_VUPKHPX,
    PPC_INS_VUPKHSB,
    PPC_INS_VUPKHSH,
    PPC_INS_VUPKLPX,
    PPC_INS_VUPKLSB,
    PPC_INS_VUPKLSH,
    PPC_INS_VXOR,
    PPC_INS_WAIT,
    PPC_INS_WRTEE,
    PPC_INS_WRTEEI,
    PPC_INS_XOR,
    PPC_INS_XORI,
    PPC_INS_XORIS,
    PPC_INS_XSABSDP,
    PPC_INS_XSADDDP,
    PPC_INS_XSCMPODP,
    PPC_INS_XSCMPUDP,
    PPC_INS_XSCPSGNDP,
    PPC_INS_XSCVDPSP,
    PPC_INS_XSCVDPSXDS,
    PPC_INS_XSCVDPSXWS,
    PPC_INS_XSCVDPUXDS,
    PPC_INS_XSCVDPUXWS,
    PPC_INS_XSCVSPDP,
    PPC_INS_XSCVSXDDP,
    PPC_INS_XSCVUXDDP,
    PPC_INS_XSDIVDP,
    PPC_INS_XSMADDADP,
    PPC_INS_XSMADDMDP,
    PPC_INS_XSMAXDP,
    PPC_INS_XSMINDP,
    PPC_INS_XSMSUBADP,
    PPC_INS_XSMSUBMDP,
    PPC_INS_XSMULDP,
    PPC_INS_XSNABSDP,
    PPC_INS_XSNEGDP,
    PPC_INS_XSNMADDADP,
    PPC_INS_XSNMADDMDP,
    PPC_INS_XSNMSUBADP,
    PPC_INS_XSNMSUBMDP,
    PPC_INS_XSRDPI,
    PPC_INS_XSRDPIC,
    PPC_INS_XSRDPIM,
    PPC_INS_XSRDPIP,
    PPC_INS_XSRDPIZ,
    PPC_INS_XSREDP,
    PPC_INS_XSRSQRTEDP,
    PPC_INS_XSSQRTDP,
    PPC_INS_XSSUBDP,
    PPC_INS_XSTDIVDP,
    PPC_INS_XSTSQRTDP,
    PPC_INS_XVABSDP,
    PPC_INS_XVABSSP,
    PPC_INS_XVADDDP,
    PPC_INS_XVADDSP,
    PPC_INS_XVCMPEQDP,
    PPC_INS_XVCMPEQSP,
    PPC_INS_XVCMPGEDP,
    PPC_INS_XVCMPGESP,
    PPC_INS_XVCMPGTDP,
    PPC_INS_XVCMPGTSP,
    PPC_INS_XVCPSGNDP,
    PPC_INS_XVCPSGNSP,
    PPC_INS_XVCVDPSP,
    PPC_INS_XVCVDPSXDS,
    PPC_INS_XVCVDPSXWS,
    PPC_INS_XVCVDPUXDS,
    PPC_INS_XVCVDPUXWS,
    PPC_INS_XVCVSPDP,
    PPC_INS_XVCVSPSXDS,
    PPC_INS_XVCVSPSXWS,
    PPC_INS_XVCVSPUXDS,
    PPC_INS_XVCVSPUXWS,
    PPC_INS_XVCVSXDDP,
    PPC_INS_XVCVSXDSP,
    PPC_INS_XVCVSXWDP,
    PPC_INS_XVCVSXWSP,
    PPC_INS_XVCVUXDDP,
    PPC_INS_XVCVUXDSP,
    PPC_INS_XVCVUXWDP,
    PPC_INS_XVCVUXWSP,
    PPC_INS_XVDIVDP,
    PPC_INS_XVDIVSP,
    PPC_INS_XVMADDADP,
    PPC_INS_XVMADDASP,
    PPC_INS_XVMADDMDP,
    PPC_INS_XVMADDMSP,
    PPC_INS_XVMAXDP,
    PPC_INS_XVMAXSP,
    PPC_INS_XVMINDP,
    PPC_INS_XVMINSP,
    PPC_INS_XVMSUBADP,
    PPC_INS_XVMSUBASP,
    PPC_INS_XVMSUBMDP,
    PPC_INS_XVMSUBMSP,
    PPC_INS_XVMULDP,
    PPC_INS_XVMULSP,
    PPC_INS_XVNABSDP,
    PPC_INS_XVNABSSP,
    PPC_INS_XVNEGDP,
    PPC_INS_XVNEGSP,
    PPC_INS_XVNMADDADP,
    PPC_INS_XVNMADDASP,
    PPC_INS_XVNMADDMDP,
    PPC_INS_XVNMADDMSP,
    PPC_INS_XVNMSUBADP,
    PPC_INS_XVNMSUBASP,
    PPC_INS_XVNMSUBMDP,
    PPC_INS_XVNMSUBMSP,
    PPC_INS_XVRDPI,
    PPC_INS_XVRDPIC,
    PPC_INS_XVRDPIM,
    PPC_INS_XVRDPIP,
    PPC_INS_XVRDPIZ,
    PPC_INS_XVREDP,
    PPC_INS_XVRESP,
    PPC_INS_XVRSPI,
    PPC_INS_XVRSPIC,
    PPC_INS_XVRSPIM,
    PPC_INS_XVRSPIP,
    PPC_INS_XVRSPIZ,
    PPC_INS_XVRSQRTEDP,
    PPC_INS_XVRSQRTESP,
    PPC_INS_XVSQRTDP,
    PPC_INS_XVSQRTSP,
    PPC_INS_XVSUBDP,
    PPC_INS_XVSUBSP,
    PPC_INS_XVTDIVDP,
    PPC_INS_XVTDIVSP,
    PPC_INS_XVTSQRTDP,
    PPC_INS_XVTSQRTSP,
    PPC_INS_XXLAND,
    PPC_INS_XXLANDC,
    PPC_INS_XXLEQV,
    PPC_INS_XXLNAND,
    PPC_INS_XXLNOR,
    PPC_INS_XXLOR,
    PPC_INS_XXLORC,
    PPC_INS_XXLXOR,
    PPC_INS_XXMRGHW,
    PPC_INS_XXMRGLW,
    PPC_INS_XXPERMDI,
    PPC_INS_XXSEL,
    PPC_INS_XXSLDWI,
    PPC_INS_XXSPLTW,
    PPC_INS_BCA,
    PPC_INS_BCLA,

    // extra & alias instructions
    PPC_INS_SLWI,
    PPC_INS_SRWI,
    PPC_INS_SLDI,

    PPC_INS_BTA,
    PPC_INS_CRSET,
    PPC_INS_CRNOT,
    PPC_INS_CRMOVE,
    PPC_INS_CRCLR,
    PPC_INS_MFBR0,
    PPC_INS_MFBR1,
    PPC_INS_MFBR2,
    PPC_INS_MFBR3,
    PPC_INS_MFBR4,
    PPC_INS_MFBR5,
    PPC_INS_MFBR6,
    PPC_INS_MFBR7,
    PPC_INS_MFXER,
    PPC_INS_MFRTCU,
    PPC_INS_MFRTCL,
    PPC_INS_MFDSCR,
    PPC_INS_MFDSISR,
    PPC_INS_MFDAR,
    PPC_INS_MFSRR2,
    PPC_INS_MFSRR3,
    PPC_INS_MFCFAR,
    PPC_INS_MFAMR,
    PPC_INS_MFPID,
    PPC_INS_MFTBLO,
    PPC_INS_MFTBHI,
    PPC_INS_MFDBATU,
    PPC_INS_MFDBATL,
    PPC_INS_MFIBATU,
    PPC_INS_MFIBATL,
    PPC_INS_MFDCCR,
    PPC_INS_MFICCR,
    PPC_INS_MFDEAR,
    PPC_INS_MFESR,
    PPC_INS_MFSPEFSCR,
    PPC_INS_MFTCR,
    PPC_INS_MFASR,
    PPC_INS_MFPVR,
    PPC_INS_MFTBU,
    PPC_INS_MTCR,
    PPC_INS_MTBR0,
    PPC_INS_MTBR1,
    PPC_INS_MTBR2,
    PPC_INS_MTBR3,
    PPC_INS_MTBR4,
    PPC_INS_MTBR5,
    PPC_INS_MTBR6,
    PPC_INS_MTBR7,
    PPC_INS_MTXER,
    PPC_INS_MTDSCR,
    PPC_INS_MTDSISR,
    PPC_INS_MTDAR,
    PPC_INS_MTSRR2,
    PPC_INS_MTSRR3,
    PPC_INS_MTCFAR,
    PPC_INS_MTAMR,
    PPC_INS_MTPID,
    PPC_INS_MTTBL,
    PPC_INS_MTTBU,
    PPC_INS_MTTBLO,
    PPC_INS_MTTBHI,
    PPC_INS_MTDBATU,
    PPC_INS_MTDBATL,
    PPC_INS_MTIBATU,
    PPC_INS_MTIBATL,
    PPC_INS_MTDCCR,
    PPC_INS_MTICCR,
    PPC_INS_MTDEAR,
    PPC_INS_MTESR,
    PPC_INS_MTSPEFSCR,
    PPC_INS_MTTCR,
    PPC_INS_NOT,
    PPC_INS_MR,
    PPC_INS_ROTLD,
    PPC_INS_ROTLDI,
    PPC_INS_CLRLDI,
    PPC_INS_ROTLWI,
    PPC_INS_CLRLWI,
    PPC_INS_ROTLW,
    PPC_INS_SUB,
    PPC_INS_SUBC,
    PPC_INS_LWSYNC,
    PPC_INS_PTESYNC,
    PPC_INS_TDLT,
    PPC_INS_TDEQ,
    PPC_INS_TDGT,
    PPC_INS_TDNE,
    PPC_INS_TDLLT,
    PPC_INS_TDLGT,
    PPC_INS_TDU,
    PPC_INS_TDLTI,
    PPC_INS_TDEQI,
    PPC_INS_TDGTI,
    PPC_INS_TDNEI,
    PPC_INS_TDLLTI,
    PPC_INS_TDLGTI,
    PPC_INS_TDUI,
    PPC_INS_TLBREHI,
    PPC_INS_TLBRELO,
    PPC_INS_TLBWEHI,
    PPC_INS_TLBWELO,
    PPC_INS_TWLT,
    PPC_INS_TWEQ,
    PPC_INS_TWGT,
    PPC_INS_TWNE,
    PPC_INS_TWLLT,
    PPC_INS_TWLGT,
    PPC_INS_TWU,
    PPC_INS_TWLTI,
    PPC_INS_TWEQI,
    PPC_INS_TWGTI,
    PPC_INS_TWNEI,
    PPC_INS_TWLLTI,
    PPC_INS_TWLGTI,
    PPC_INS_TWUI,
    PPC_INS_WAITRSV,
    PPC_INS_WAITIMPL,
    PPC_INS_XNOP,
    PPC_INS_XVMOVDP,
    PPC_INS_XVMOVSP,
    PPC_INS_XXSPLTD,
    PPC_INS_XXMRGHD,
    PPC_INS_XXMRGLD,
    PPC_INS_XXSWAPD,
    PPC_INS_BT,
    PPC_INS_BF,
    PPC_INS_BDNZT,
    PPC_INS_BDNZF,
    PPC_INS_BDZF,
    PPC_INS_BDZT,
    PPC_INS_BFA,
    PPC_INS_BDNZTA,
    PPC_INS_BDNZFA,
    PPC_INS_BDZTA,
    PPC_INS_BDZFA,
    PPC_INS_BTCTR,
    PPC_INS_BFCTR,
    PPC_INS_BTCTRL,
    PPC_INS_BFCTRL,
    PPC_INS_BTL,
    PPC_INS_BFL,
    PPC_INS_BDNZTL,
    PPC_INS_BDNZFL,
    PPC_INS_BDZTL,
    PPC_INS_BDZFL,
    PPC_INS_BTLA,
    PPC_INS_BFLA,
    PPC_INS_BDNZTLA,
    PPC_INS_BDNZFLA,
    PPC_INS_BDZTLA,
    PPC_INS_BDZFLA,
    PPC_INS_BTLR,
    PPC_INS_BFLR,
    PPC_INS_BDNZTLR,
    PPC_INS_BDZTLR,
    PPC_INS_BDZFLR,
    PPC_INS_BTLRL,
    PPC_INS_BFLRL,
    PPC_INS_BDNZTLRL,
    PPC_INS_BDNZFLRL,
    PPC_INS_BDZTLRL,
    PPC_INS_BDZFLRL,

    // QPX
    PPC_INS_QVFAND,
    PPC_INS_QVFCLR,
    PPC_INS_QVFANDC,
    PPC_INS_QVFCTFB,
    PPC_INS_QVFXOR,
    PPC_INS_QVFOR,
    PPC_INS_QVFNOR,
    PPC_INS_QVFEQU,
    PPC_INS_QVFNOT,
    PPC_INS_QVFORC,
    PPC_INS_QVFNAND,
    PPC_INS_QVFSET,

    PPC_INS_ENDING,   // <-- mark the end of the list of instructions
} ppc_insn;

//> Group of PPC instructions
typedef enum ppc_insn_group
{
    PPC_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    PPC_GRP_JUMP,   // = CS_GRP_JUMP

    //> Architecture-specific groups
    PPC_GRP_ALTIVEC = 128,
    PPC_GRP_MODE32,
    PPC_GRP_MODE64,
    PPC_GRP_BOOKE,
    PPC_GRP_NOTBOOKE,
    PPC_GRP_SPE,
    PPC_GRP_VSX,
    PPC_GRP_E500,
    PPC_GRP_PPC4XX,
    PPC_GRP_PPC6XX,
    PPC_GRP_ICBT,
    PPC_GRP_P8ALTIVEC,
    PPC_GRP_P8VECTOR,
    PPC_GRP_QPX,

    PPC_GRP_ENDING,   // <-- mark the end of the list of groups
} ppc_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/sparc.h
================================================
#ifndef CAPSTONE_SPARC_H
#define CAPSTONE_SPARC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to Sparc condition codes, both icc's and fcc's.
typedef enum sparc_cc
{
    SPARC_CC_INVALID = 0,   // invalid CC (default)
    //> Integer condition codes
    SPARC_CC_ICC_A   =  8 + 256, // Always
    SPARC_CC_ICC_N   =  0 + 256, // Never
    SPARC_CC_ICC_NE  =  9 + 256, // Not Equal
    SPARC_CC_ICC_E   =  1 + 256, // Equal
    SPARC_CC_ICC_G   = 10 + 256, // Greater
    SPARC_CC_ICC_LE  =  2 + 256, // Less or Equal
    SPARC_CC_ICC_GE  = 11 + 256, // Greater or Equal
    SPARC_CC_ICC_L   =  3 + 256, // Less
    SPARC_CC_ICC_GU  = 12 + 256, // Greater Unsigned
    SPARC_CC_ICC_LEU =  4 + 256, // Less or Equal Unsigned
    SPARC_CC_ICC_CC  = 13 + 256, // Carry Clear/Great or Equal Unsigned
    SPARC_CC_ICC_CS  =  5 + 256, // Carry Set/Less Unsigned
    SPARC_CC_ICC_POS = 14 + 256, // Positive
    SPARC_CC_ICC_NEG =  6 + 256, // Negative
    SPARC_CC_ICC_VC  = 15 + 256, // Overflow Clear
    SPARC_CC_ICC_VS  =  7 + 256, // Overflow Set

    //> Floating condition codes
    SPARC_CC_FCC_A   =  8 + 16 + 256, // Always
    SPARC_CC_FCC_N   =  0 + 16 + 256, // Never
    SPARC_CC_FCC_U   =  7 + 16 + 256, // Unordered
    SPARC_CC_FCC_G   =  6 + 16 + 256, // Greater
    SPARC_CC_FCC_UG  =  5 + 16 + 256, // Unordered or Greater
    SPARC_CC_FCC_L   =  4 + 16 + 256, // Less
    SPARC_CC_FCC_UL  =  3 + 16 + 256, // Unordered or Less
    SPARC_CC_FCC_LG  =  2 + 16 + 256, // Less or Greater
    SPARC_CC_FCC_NE  =  1 + 16 + 256, // Not Equal
    SPARC_CC_FCC_E   =  9 + 16 + 256, // Equal
    SPARC_CC_FCC_UE  = 10 + 16 + 256, // Unordered or Equal
    SPARC_CC_FCC_GE  = 11 + 16 + 256, // Greater or Equal
    SPARC_CC_FCC_UGE = 12 + 16 + 256, // Unordered or Greater or Equal
    SPARC_CC_FCC_LE  = 13 + 16 + 256, // Less or Equal
    SPARC_CC_FCC_ULE = 14 + 16 + 256, // Unordered or Less or Equal
    SPARC_CC_FCC_O   = 15 + 16 + 256, // Ordered
} sparc_cc;

//> Branch hint
typedef enum sparc_hint
{
    SPARC_HINT_INVALID = 0, // no hint
    SPARC_HINT_A    = 1 << 0,   // annul delay slot instruction
    SPARC_HINT_PT   = 1 << 1,   // branch taken
    SPARC_HINT_PN   = 1 << 2,   // branch NOT taken
} sparc_hint;

//> Operand type for instruction's operands
typedef enum sparc_op_type
{
    SPARC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    SPARC_OP_REG, // = CS_OP_REG (Register operand).
    SPARC_OP_IMM, // = CS_OP_IMM (Immediate operand).
    SPARC_OP_MEM, // = CS_OP_MEM (Memory operand).
} sparc_op_type;

//> SPARC registers
typedef enum sparc_reg
{
    SPARC_REG_INVALID = 0,

    SPARC_REG_F0,
    SPARC_REG_F1,
    SPARC_REG_F2,
    SPARC_REG_F3,
    SPARC_REG_F4,
    SPARC_REG_F5,
    SPARC_REG_F6,
    SPARC_REG_F7,
    SPARC_REG_F8,
    SPARC_REG_F9,
    SPARC_REG_F10,
    SPARC_REG_F11,
    SPARC_REG_F12,
    SPARC_REG_F13,
    SPARC_REG_F14,
    SPARC_REG_F15,
    SPARC_REG_F16,
    SPARC_REG_F17,
    SPARC_REG_F18,
    SPARC_REG_F19,
    SPARC_REG_F20,
    SPARC_REG_F21,
    SPARC_REG_F22,
    SPARC_REG_F23,
    SPARC_REG_F24,
    SPARC_REG_F25,
    SPARC_REG_F26,
    SPARC_REG_F27,
    SPARC_REG_F28,
    SPARC_REG_F29,
    SPARC_REG_F30,
    SPARC_REG_F31,
    SPARC_REG_F32,
    SPARC_REG_F34,
    SPARC_REG_F36,
    SPARC_REG_F38,
    SPARC_REG_F40,
    SPARC_REG_F42,
    SPARC_REG_F44,
    SPARC_REG_F46,
    SPARC_REG_F48,
    SPARC_REG_F50,
    SPARC_REG_F52,
    SPARC_REG_F54,
    SPARC_REG_F56,
    SPARC_REG_F58,
    SPARC_REG_F60,
    SPARC_REG_F62,
    SPARC_REG_FCC0, // Floating condition codes
    SPARC_REG_FCC1,
    SPARC_REG_FCC2,
    SPARC_REG_FCC3,
    SPARC_REG_FP,
    SPARC_REG_G0,
    SPARC_REG_G1,
    SPARC_REG_G2,
    SPARC_REG_G3,
    SPARC_REG_G4,
    SPARC_REG_G5,
    SPARC_REG_G6,
    SPARC_REG_G7,
    SPARC_REG_I0,
    SPARC_REG_I1,
    SPARC_REG_I2,
    SPARC_REG_I3,
    SPARC_REG_I4,
    SPARC_REG_I5,
    SPARC_REG_I7,
    SPARC_REG_ICC,  // Integer condition codes
    SPARC_REG_L0,
    SPARC_REG_L1,
    SPARC_REG_L2,
    SPARC_REG_L3,
    SPARC_REG_L4,
    SPARC_REG_L5,
    SPARC_REG_L6,
    SPARC_REG_L7,
    SPARC_REG_O0,
    SPARC_REG_O1,
    SPARC_REG_O2,
    SPARC_REG_O3,
    SPARC_REG_O4,
    SPARC_REG_O5,
    SPARC_REG_O7,
    SPARC_REG_SP,
    SPARC_REG_Y,

    // special register
    SPARC_REG_XCC,

    SPARC_REG_ENDING,   // <-- mark the end of the list of registers

    // extras
    SPARC_REG_O6 = SPARC_REG_SP,
    SPARC_REG_I6 = SPARC_REG_FP,
} sparc_reg;

// Instruction's operand referring to memory
// This is associated with SPARC_OP_MEM operand type above
typedef struct sparc_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `sparc_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    int32_t disp;       // displacement/offset value
} sparc_op_mem;

// Instruction operand
typedef struct cs_sparc_op
{
    sparc_op_type type; // operand type
    union
    {
        sparc_reg reg;  // register value for REG operand
        int32_t imm;        // immediate value for IMM operand
        sparc_op_mem mem;       // base/disp value for MEM operand
    };
} cs_sparc_op;

// Instruction structure
typedef struct cs_sparc
{
    sparc_cc cc;    // code condition for this insn
    sparc_hint hint;    // branch hint: encoding as bitwise OR of sparc_hint.
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_sparc_op operands[4]; // operands for this instruction.
} cs_sparc;

//> SPARC instruction
typedef enum sparc_insn
{
    SPARC_INS_INVALID = 0,

    SPARC_INS_ADDCC,
    SPARC_INS_ADDX,
    SPARC_INS_ADDXCC,
    SPARC_INS_ADDXC,
    SPARC_INS_ADDXCCC,
    SPARC_INS_ADD,
    SPARC_INS_ALIGNADDR,
    SPARC_INS_ALIGNADDRL,
    SPARC_INS_ANDCC,
    SPARC_INS_ANDNCC,
    SPARC_INS_ANDN,
    SPARC_INS_AND,
    SPARC_INS_ARRAY16,
    SPARC_INS_ARRAY32,
    SPARC_INS_ARRAY8,
    SPARC_INS_B,
    SPARC_INS_JMP,
    SPARC_INS_BMASK,
    SPARC_INS_FB,
    SPARC_INS_BRGEZ,
    SPARC_INS_BRGZ,
    SPARC_INS_BRLEZ,
    SPARC_INS_BRLZ,
    SPARC_INS_BRNZ,
    SPARC_INS_BRZ,
    SPARC_INS_BSHUFFLE,
    SPARC_INS_CALL,
    SPARC_INS_CASX,
    SPARC_INS_CAS,
    SPARC_INS_CMASK16,
    SPARC_INS_CMASK32,
    SPARC_INS_CMASK8,
    SPARC_INS_CMP,
    SPARC_INS_EDGE16,
    SPARC_INS_EDGE16L,
    SPARC_INS_EDGE16LN,
    SPARC_INS_EDGE16N,
    SPARC_INS_EDGE32,
    SPARC_INS_EDGE32L,
    SPARC_INS_EDGE32LN,
    SPARC_INS_EDGE32N,
    SPARC_INS_EDGE8,
    SPARC_INS_EDGE8L,
    SPARC_INS_EDGE8LN,
    SPARC_INS_EDGE8N,
    SPARC_INS_FABSD,
    SPARC_INS_FABSQ,
    SPARC_INS_FABSS,
    SPARC_INS_FADDD,
    SPARC_INS_FADDQ,
    SPARC_INS_FADDS,
    SPARC_INS_FALIGNDATA,
    SPARC_INS_FAND,
    SPARC_INS_FANDNOT1,
    SPARC_INS_FANDNOT1S,
    SPARC_INS_FANDNOT2,
    SPARC_INS_FANDNOT2S,
    SPARC_INS_FANDS,
    SPARC_INS_FCHKSM16,
    SPARC_INS_FCMPD,
    SPARC_INS_FCMPEQ16,
    SPARC_INS_FCMPEQ32,
    SPARC_INS_FCMPGT16,
    SPARC_INS_FCMPGT32,
    SPARC_INS_FCMPLE16,
    SPARC_INS_FCMPLE32,
    SPARC_INS_FCMPNE16,
    SPARC_INS_FCMPNE32,
    SPARC_INS_FCMPQ,
    SPARC_INS_FCMPS,
    SPARC_INS_FDIVD,
    SPARC_INS_FDIVQ,
    SPARC_INS_FDIVS,
    SPARC_INS_FDMULQ,
    SPARC_INS_FDTOI,
    SPARC_INS_FDTOQ,
    SPARC_INS_FDTOS,
    SPARC_INS_FDTOX,
    SPARC_INS_FEXPAND,
    SPARC_INS_FHADDD,
    SPARC_INS_FHADDS,
    SPARC_INS_FHSUBD,
    SPARC_INS_FHSUBS,
    SPARC_INS_FITOD,
    SPARC_INS_FITOQ,
    SPARC_INS_FITOS,
    SPARC_INS_FLCMPD,
    SPARC_INS_FLCMPS,
    SPARC_INS_FLUSHW,
    SPARC_INS_FMEAN16,
    SPARC_INS_FMOVD,
    SPARC_INS_FMOVQ,
    SPARC_INS_FMOVRDGEZ,
    SPARC_INS_FMOVRQGEZ,
    SPARC_INS_FMOVRSGEZ,
    SPARC_INS_FMOVRDGZ,
    SPARC_INS_FMOVRQGZ,
    SPARC_INS_FMOVRSGZ,
    SPARC_INS_FMOVRDLEZ,
    SPARC_INS_FMOVRQLEZ,
    SPARC_INS_FMOVRSLEZ,
    SPARC_INS_FMOVRDLZ,
    SPARC_INS_FMOVRQLZ,
    SPARC_INS_FMOVRSLZ,
    SPARC_INS_FMOVRDNZ,
    SPARC_INS_FMOVRQNZ,
    SPARC_INS_FMOVRSNZ,
    SPARC_INS_FMOVRDZ,
    SPARC_INS_FMOVRQZ,
    SPARC_INS_FMOVRSZ,
    SPARC_INS_FMOVS,
    SPARC_INS_FMUL8SUX16,
    SPARC_INS_FMUL8ULX16,
    SPARC_INS_FMUL8X16,
    SPARC_INS_FMUL8X16AL,
    SPARC_INS_FMUL8X16AU,
    SPARC_INS_FMULD,
    SPARC_INS_FMULD8SUX16,
    SPARC_INS_FMULD8ULX16,
    SPARC_INS_FMULQ,
    SPARC_INS_FMULS,
    SPARC_INS_FNADDD,
    SPARC_INS_FNADDS,
    SPARC_INS_FNAND,
    SPARC_INS_FNANDS,
    SPARC_INS_FNEGD,
    SPARC_INS_FNEGQ,
    SPARC_INS_FNEGS,
    SPARC_INS_FNHADDD,
    SPARC_INS_FNHADDS,
    SPARC_INS_FNOR,
    SPARC_INS_FNORS,
    SPARC_INS_FNOT1,
    SPARC_INS_FNOT1S,
    SPARC_INS_FNOT2,
    SPARC_INS_FNOT2S,
    SPARC_INS_FONE,
    SPARC_INS_FONES,
    SPARC_INS_FOR,
    SPARC_INS_FORNOT1,
    SPARC_INS_FORNOT1S,
    SPARC_INS_FORNOT2,
    SPARC_INS_FORNOT2S,
    SPARC_INS_FORS,
    SPARC_INS_FPACK16,
    SPARC_INS_FPACK32,
    SPARC_INS_FPACKFIX,
    SPARC_INS_FPADD16,
    SPARC_INS_FPADD16S,
    SPARC_INS_FPADD32,
    SPARC_INS_FPADD32S,
    SPARC_INS_FPADD64,
    SPARC_INS_FPMERGE,
    SPARC_INS_FPSUB16,
    SPARC_INS_FPSUB16S,
    SPARC_INS_FPSUB32,
    SPARC_INS_FPSUB32S,
    SPARC_INS_FQTOD,
    SPARC_INS_FQTOI,
    SPARC_INS_FQTOS,
    SPARC_INS_FQTOX,
    SPARC_INS_FSLAS16,
    SPARC_INS_FSLAS32,
    SPARC_INS_FSLL16,
    SPARC_INS_FSLL32,
    SPARC_INS_FSMULD,
    SPARC_INS_FSQRTD,
    SPARC_INS_FSQRTQ,
    SPARC_INS_FSQRTS,
    SPARC_INS_FSRA16,
    SPARC_INS_FSRA32,
    SPARC_INS_FSRC1,
    SPARC_INS_FSRC1S,
    SPARC_INS_FSRC2,
    SPARC_INS_FSRC2S,
    SPARC_INS_FSRL16,
    SPARC_INS_FSRL32,
    SPARC_INS_FSTOD,
    SPARC_INS_FSTOI,
    SPARC_INS_FSTOQ,
    SPARC_INS_FSTOX,
    SPARC_INS_FSUBD,
    SPARC_INS_FSUBQ,
    SPARC_INS_FSUBS,
    SPARC_INS_FXNOR,
    SPARC_INS_FXNORS,
    SPARC_INS_FXOR,
    SPARC_INS_FXORS,
    SPARC_INS_FXTOD,
    SPARC_INS_FXTOQ,
    SPARC_INS_FXTOS,
    SPARC_INS_FZERO,
    SPARC_INS_FZEROS,
    SPARC_INS_JMPL,
    SPARC_INS_LDD,
    SPARC_INS_LD,
    SPARC_INS_LDQ,
    SPARC_INS_LDSB,
    SPARC_INS_LDSH,
    SPARC_INS_LDSW,
    SPARC_INS_LDUB,
    SPARC_INS_LDUH,
    SPARC_INS_LDX,
    SPARC_INS_LZCNT,
    SPARC_INS_MEMBAR,
    SPARC_INS_MOVDTOX,
    SPARC_INS_MOV,
    SPARC_INS_MOVRGEZ,
    SPARC_INS_MOVRGZ,
    SPARC_INS_MOVRLEZ,
    SPARC_INS_MOVRLZ,
    SPARC_INS_MOVRNZ,
    SPARC_INS_MOVRZ,
    SPARC_INS_MOVSTOSW,
    SPARC_INS_MOVSTOUW,
    SPARC_INS_MULX,
    SPARC_INS_NOP,
    SPARC_INS_ORCC,
    SPARC_INS_ORNCC,
    SPARC_INS_ORN,
    SPARC_INS_OR,
    SPARC_INS_PDIST,
    SPARC_INS_PDISTN,
    SPARC_INS_POPC,
    SPARC_INS_RD,
    SPARC_INS_RESTORE,
    SPARC_INS_RETT,
    SPARC_INS_SAVE,
    SPARC_INS_SDIVCC,
    SPARC_INS_SDIVX,
    SPARC_INS_SDIV,
    SPARC_INS_SETHI,
    SPARC_INS_SHUTDOWN,
    SPARC_INS_SIAM,
    SPARC_INS_SLLX,
    SPARC_INS_SLL,
    SPARC_INS_SMULCC,
    SPARC_INS_SMUL,
    SPARC_INS_SRAX,
    SPARC_INS_SRA,
    SPARC_INS_SRLX,
    SPARC_INS_SRL,
    SPARC_INS_STBAR,
    SPARC_INS_STB,
    SPARC_INS_STD,
    SPARC_INS_ST,
    SPARC_INS_STH,
    SPARC_INS_STQ,
    SPARC_INS_STX,
    SPARC_INS_SUBCC,
    SPARC_INS_SUBX,
    SPARC_INS_SUBXCC,
    SPARC_INS_SUB,
    SPARC_INS_SWAP,
    SPARC_INS_TADDCCTV,
    SPARC_INS_TADDCC,
    SPARC_INS_T,
    SPARC_INS_TSUBCCTV,
    SPARC_INS_TSUBCC,
    SPARC_INS_UDIVCC,
    SPARC_INS_UDIVX,
    SPARC_INS_UDIV,
    SPARC_INS_UMULCC,
    SPARC_INS_UMULXHI,
    SPARC_INS_UMUL,
    SPARC_INS_UNIMP,
    SPARC_INS_FCMPED,
    SPARC_INS_FCMPEQ,
    SPARC_INS_FCMPES,
    SPARC_INS_WR,
    SPARC_INS_XMULX,
    SPARC_INS_XMULXHI,
    SPARC_INS_XNORCC,
    SPARC_INS_XNOR,
    SPARC_INS_XORCC,
    SPARC_INS_XOR,

    // alias instructions
    SPARC_INS_RET,
    SPARC_INS_RETL,

    SPARC_INS_ENDING,   // <-- mark the end of the list of instructions
} sparc_insn;

//> Group of SPARC instructions
typedef enum sparc_insn_group
{
    SPARC_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    SPARC_GRP_JUMP, // = CS_GRP_JUMP

    //> Architecture-specific groups
    SPARC_GRP_HARDQUAD = 128,
    SPARC_GRP_V9,
    SPARC_GRP_VIS,
    SPARC_GRP_VIS2,
    SPARC_GRP_VIS3,
    SPARC_GRP_32BIT,
    SPARC_GRP_64BIT,

    SPARC_GRP_ENDING,   // <-- mark the end of the list of groups
} sparc_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/systemz.h
================================================
#ifndef CAPSTONE_SYSTEMZ_H
#define CAPSTONE_SYSTEMZ_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to SystemZ condition codes
typedef enum sysz_cc
{
    SYSZ_CC_INVALID = 0,    // invalid CC (default)

    SYSZ_CC_O,
    SYSZ_CC_H,
    SYSZ_CC_NLE,
    SYSZ_CC_L,
    SYSZ_CC_NHE,
    SYSZ_CC_LH,
    SYSZ_CC_NE,
    SYSZ_CC_E,
    SYSZ_CC_NLH,
    SYSZ_CC_HE,
    SYSZ_CC_NL,
    SYSZ_CC_LE,
    SYSZ_CC_NH,
    SYSZ_CC_NO,
} sysz_cc;

//> Operand type for instruction's operands
typedef enum sysz_op_type
{
    SYSZ_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    SYSZ_OP_REG, // = CS_OP_REG (Register operand).
    SYSZ_OP_IMM, // = CS_OP_IMM (Immediate operand).
    SYSZ_OP_MEM, // = CS_OP_MEM (Memory operand).
    SYSZ_OP_ACREG = 64, // Access register operand.
} sysz_op_type;

//> SystemZ registers
typedef enum sysz_reg
{
    SYSZ_REG_INVALID = 0,

    SYSZ_REG_0,
    SYSZ_REG_1,
    SYSZ_REG_2,
    SYSZ_REG_3,
    SYSZ_REG_4,
    SYSZ_REG_5,
    SYSZ_REG_6,
    SYSZ_REG_7,
    SYSZ_REG_8,
    SYSZ_REG_9,
    SYSZ_REG_10,
    SYSZ_REG_11,
    SYSZ_REG_12,
    SYSZ_REG_13,
    SYSZ_REG_14,
    SYSZ_REG_15,
    SYSZ_REG_CC,
    SYSZ_REG_F0,
    SYSZ_REG_F1,
    SYSZ_REG_F2,
    SYSZ_REG_F3,
    SYSZ_REG_F4,
    SYSZ_REG_F5,
    SYSZ_REG_F6,
    SYSZ_REG_F7,
    SYSZ_REG_F8,
    SYSZ_REG_F9,
    SYSZ_REG_F10,
    SYSZ_REG_F11,
    SYSZ_REG_F12,
    SYSZ_REG_F13,
    SYSZ_REG_F14,
    SYSZ_REG_F15,

    SYSZ_REG_R0L,

    SYSZ_REG_ENDING,
} sysz_reg;

// Instruction's operand referring to memory
// This is associated with SYSZ_OP_MEM operand type above
typedef struct sysz_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `sysz_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    uint64_t length;    // BDLAddr operand
    int64_t disp;   // displacement/offset value
} sysz_op_mem;

// Instruction operand
typedef struct cs_sysz_op
{
    sysz_op_type type;  // operand type
    union
    {
        sysz_reg reg;       // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        sysz_op_mem mem;    // base/disp value for MEM operand
    };
} cs_sysz_op;

// Instruction structure
typedef struct cs_sysz
{
    sysz_cc cc;     // Code condition
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_sysz_op operands[6]; // operands for this instruction.
} cs_sysz;

//> SystemZ instruction
typedef enum sysz_insn
{
    SYSZ_INS_INVALID = 0,

    SYSZ_INS_A,
    SYSZ_INS_ADB,
    SYSZ_INS_ADBR,
    SYSZ_INS_AEB,
    SYSZ_INS_AEBR,
    SYSZ_INS_AFI,
    SYSZ_INS_AG,
    SYSZ_INS_AGF,
    SYSZ_INS_AGFI,
    SYSZ_INS_AGFR,
    SYSZ_INS_AGHI,
    SYSZ_INS_AGHIK,
    SYSZ_INS_AGR,
    SYSZ_INS_AGRK,
    SYSZ_INS_AGSI,
    SYSZ_INS_AH,
    SYSZ_INS_AHI,
    SYSZ_INS_AHIK,
    SYSZ_INS_AHY,
    SYSZ_INS_AIH,
    SYSZ_INS_AL,
    SYSZ_INS_ALC,
    SYSZ_INS_ALCG,
    SYSZ_INS_ALCGR,
    SYSZ_INS_ALCR,
    SYSZ_INS_ALFI,
    SYSZ_INS_ALG,
    SYSZ_INS_ALGF,
    SYSZ_INS_ALGFI,
    SYSZ_INS_ALGFR,
    SYSZ_INS_ALGHSIK,
    SYSZ_INS_ALGR,
    SYSZ_INS_ALGRK,
    SYSZ_INS_ALHSIK,
    SYSZ_INS_ALR,
    SYSZ_INS_ALRK,
    SYSZ_INS_ALY,
    SYSZ_INS_AR,
    SYSZ_INS_ARK,
    SYSZ_INS_ASI,
    SYSZ_INS_AXBR,
    SYSZ_INS_AY,
    SYSZ_INS_BCR,
    SYSZ_INS_BRC,
    SYSZ_INS_BRCL,
    SYSZ_INS_CGIJ,
    SYSZ_INS_CGRJ,
    SYSZ_INS_CIJ,
    SYSZ_INS_CLGIJ,
    SYSZ_INS_CLGRJ,
    SYSZ_INS_CLIJ,
    SYSZ_INS_CLRJ,
    SYSZ_INS_CRJ,
    SYSZ_INS_BER,
    SYSZ_INS_JE,
    SYSZ_INS_JGE,
    SYSZ_INS_LOCE,
    SYSZ_INS_LOCGE,
    SYSZ_INS_LOCGRE,
    SYSZ_INS_LOCRE,
    SYSZ_INS_STOCE,
    SYSZ_INS_STOCGE,
    SYSZ_INS_BHR,
    SYSZ_INS_BHER,
    SYSZ_INS_JHE,
    SYSZ_INS_JGHE,
    SYSZ_INS_LOCHE,
    SYSZ_INS_LOCGHE,
    SYSZ_INS_LOCGRHE,
    SYSZ_INS_LOCRHE,
    SYSZ_INS_STOCHE,
    SYSZ_INS_STOCGHE,
    SYSZ_INS_JH,
    SYSZ_INS_JGH,
    SYSZ_INS_LOCH,
    SYSZ_INS_LOCGH,
    SYSZ_INS_LOCGRH,
    SYSZ_INS_LOCRH,
    SYSZ_INS_STOCH,
    SYSZ_INS_STOCGH,
    SYSZ_INS_CGIJNLH,
    SYSZ_INS_CGRJNLH,
    SYSZ_INS_CIJNLH,
    SYSZ_INS_CLGIJNLH,
    SYSZ_INS_CLGRJNLH,
    SYSZ_INS_CLIJNLH,
    SYSZ_INS_CLRJNLH,
    SYSZ_INS_CRJNLH,
    SYSZ_INS_CGIJE,
    SYSZ_INS_CGRJE,
    SYSZ_INS_CIJE,
    SYSZ_INS_CLGIJE,
    SYSZ_INS_CLGRJE,
    SYSZ_INS_CLIJE,
    SYSZ_INS_CLRJE,
    SYSZ_INS_CRJE,
    SYSZ_INS_CGIJNLE,
    SYSZ_INS_CGRJNLE,
    SYSZ_INS_CIJNLE,
    SYSZ_INS_CLGIJNLE,
    SYSZ_INS_CLGRJNLE,
    SYSZ_INS_CLIJNLE,
    SYSZ_INS_CLRJNLE,
    SYSZ_INS_CRJNLE,
    SYSZ_INS_CGIJH,
    SYSZ_INS_CGRJH,
    SYSZ_INS_CIJH,
    SYSZ_INS_CLGIJH,
    SYSZ_INS_CLGRJH,
    SYSZ_INS_CLIJH,
    SYSZ_INS_CLRJH,
    SYSZ_INS_CRJH,
    SYSZ_INS_CGIJNL,
    SYSZ_INS_CGRJNL,
    SYSZ_INS_CIJNL,
    SYSZ_INS_CLGIJNL,
    SYSZ_INS_CLGRJNL,
    SYSZ_INS_CLIJNL,
    SYSZ_INS_CLRJNL,
    SYSZ_INS_CRJNL,
    SYSZ_INS_CGIJHE,
    SYSZ_INS_CGRJHE,
    SYSZ_INS_CIJHE,
    SYSZ_INS_CLGIJHE,
    SYSZ_INS_CLGRJHE,
    SYSZ_INS_CLIJHE,
    SYSZ_INS_CLRJHE,
    SYSZ_INS_CRJHE,
    SYSZ_INS_CGIJNHE,
    SYSZ_INS_CGRJNHE,
    SYSZ_INS_CIJNHE,
    SYSZ_INS_CLGIJNHE,
    SYSZ_INS_CLGRJNHE,
    SYSZ_INS_CLIJNHE,
    SYSZ_INS_CLRJNHE,
    SYSZ_INS_CRJNHE,
    SYSZ_INS_CGIJL,
    SYSZ_INS_CGRJL,
    SYSZ_INS_CIJL,
    SYSZ_INS_CLGIJL,
    SYSZ_INS_CLGRJL,
    SYSZ_INS_CLIJL,
    SYSZ_INS_CLRJL,
    SYSZ_INS_CRJL,
    SYSZ_INS_CGIJNH,
    SYSZ_INS_CGRJNH,
    SYSZ_INS_CIJNH,
    SYSZ_INS_CLGIJNH,
    SYSZ_INS_CLGRJNH,
    SYSZ_INS_CLIJNH,
    SYSZ_INS_CLRJNH,
    SYSZ_INS_CRJNH,
    SYSZ_INS_CGIJLE,
    SYSZ_INS_CGRJLE,
    SYSZ_INS_CIJLE,
    SYSZ_INS_CLGIJLE,
    SYSZ_INS_CLGRJLE,
    SYSZ_INS_CLIJLE,
    SYSZ_INS_CLRJLE,
    SYSZ_INS_CRJLE,
    SYSZ_INS_CGIJNE,
    SYSZ_INS_CGRJNE,
    SYSZ_INS_CIJNE,
    SYSZ_INS_CLGIJNE,
    SYSZ_INS_CLGRJNE,
    SYSZ_INS_CLIJNE,
    SYSZ_INS_CLRJNE,
    SYSZ_INS_CRJNE,
    SYSZ_INS_CGIJLH,
    SYSZ_INS_CGRJLH,
    SYSZ_INS_CIJLH,
    SYSZ_INS_CLGIJLH,
    SYSZ_INS_CLGRJLH,
    SYSZ_INS_CLIJLH,
    SYSZ_INS_CLRJLH,
    SYSZ_INS_CRJLH,
    SYSZ_INS_BLR,
    SYSZ_INS_BLER,
    SYSZ_INS_JLE,
    SYSZ_INS_JGLE,
    SYSZ_INS_LOCLE,
    SYSZ_INS_LOCGLE,
    SYSZ_INS_LOCGRLE,
    SYSZ_INS_LOCRLE,
    SYSZ_INS_STOCLE,
    SYSZ_INS_STOCGLE,
    SYSZ_INS_BLHR,
    SYSZ_INS_JLH,
    SYSZ_INS_JGLH,
    SYSZ_INS_LOCLH,
    SYSZ_INS_LOCGLH,
    SYSZ_INS_LOCGRLH,
    SYSZ_INS_LOCRLH,
    SYSZ_INS_STOCLH,
    SYSZ_INS_STOCGLH,
    SYSZ_INS_JL,
    SYSZ_INS_JGL,
    SYSZ_INS_LOCL,
    SYSZ_INS_LOCGL,
    SYSZ_INS_LOCGRL,
    SYSZ_INS_LOCRL,
    SYSZ_INS_LOC,
    SYSZ_INS_LOCG,
    SYSZ_INS_LOCGR,
    SYSZ_INS_LOCR,
    SYSZ_INS_STOCL,
    SYSZ_INS_STOCGL,
    SYSZ_INS_BNER,
    SYSZ_INS_JNE,
    SYSZ_INS_JGNE,
    SYSZ_INS_LOCNE,
    SYSZ_INS_LOCGNE,
    SYSZ_INS_LOCGRNE,
    SYSZ_INS_LOCRNE,
    SYSZ_INS_STOCNE,
    SYSZ_INS_STOCGNE,
    SYSZ_INS_BNHR,
    SYSZ_INS_BNHER,
    SYSZ_INS_JNHE,
    SYSZ_INS_JGNHE,
    SYSZ_INS_LOCNHE,
    SYSZ_INS_LOCGNHE,
    SYSZ_INS_LOCGRNHE,
    SYSZ_INS_LOCRNHE,
    SYSZ_INS_STOCNHE,
    SYSZ_INS_STOCGNHE,
    SYSZ_INS_JNH,
    SYSZ_INS_JGNH,
    SYSZ_INS_LOCNH,
    SYSZ_INS_LOCGNH,
    SYSZ_INS_LOCGRNH,
    SYSZ_INS_LOCRNH,
    SYSZ_INS_STOCNH,
    SYSZ_INS_STOCGNH,
    SYSZ_INS_BNLR,
    SYSZ_INS_BNLER,
    SYSZ_INS_JNLE,
    SYSZ_INS_JGNLE,
    SYSZ_INS_LOCNLE,
    SYSZ_INS_LOCGNLE,
    SYSZ_INS_LOCGRNLE,
    SYSZ_INS_LOCRNLE,
    SYSZ_INS_STOCNLE,
    SYSZ_INS_STOCGNLE,
    SYSZ_INS_BNLHR,
    SYSZ_INS_JNLH,
    SYSZ_INS_JGNLH,
    SYSZ_INS_LOCNLH,
    SYSZ_INS_LOCGNLH,
    SYSZ_INS_LOCGRNLH,
    SYSZ_INS_LOCRNLH,
    SYSZ_INS_STOCNLH,
    SYSZ_INS_STOCGNLH,
    SYSZ_INS_JNL,
    SYSZ_INS_JGNL,
    SYSZ_INS_LOCNL,
    SYSZ_INS_LOCGNL,
    SYSZ_INS_LOCGRNL,
    SYSZ_INS_LOCRNL,
    SYSZ_INS_STOCNL,
    SYSZ_INS_STOCGNL,
    SYSZ_INS_BNOR,
    SYSZ_INS_JNO,
    SYSZ_INS_JGNO,
    SYSZ_INS_LOCNO,
    SYSZ_INS_LOCGNO,
    SYSZ_INS_LOCGRNO,
    SYSZ_INS_LOCRNO,
    SYSZ_INS_STOCNO,
    SYSZ_INS_STOCGNO,
    SYSZ_INS_BOR,
    SYSZ_INS_JO,
    SYSZ_INS_JGO,
    SYSZ_INS_LOCO,
    SYSZ_INS_LOCGO,
    SYSZ_INS_LOCGRO,
    SYSZ_INS_LOCRO,
    SYSZ_INS_STOCO,
    SYSZ_INS_STOCGO,
    SYSZ_INS_STOC,
    SYSZ_INS_STOCG,
    SYSZ_INS_BASR,
    SYSZ_INS_BR,
    SYSZ_INS_BRAS,
    SYSZ_INS_BRASL,
    SYSZ_INS_J,
    SYSZ_INS_JG,
    SYSZ_INS_BRCT,
    SYSZ_INS_BRCTG,
    SYSZ_INS_C,
    SYSZ_INS_CDB,
    SYSZ_INS_CDBR,
    SYSZ_INS_CDFBR,
    SYSZ_INS_CDGBR,
    SYSZ_INS_CDLFBR,
    SYSZ_INS_CDLGBR,
    SYSZ_INS_CEB,
    SYSZ_INS_CEBR,
    SYSZ_INS_CEFBR,
    SYSZ_INS_CEGBR,
    SYSZ_INS_CELFBR,
    SYSZ_INS_CELGBR,
    SYSZ_INS_CFDBR,
    SYSZ_INS_CFEBR,
    SYSZ_INS_CFI,
    SYSZ_INS_CFXBR,
    SYSZ_INS_CG,
    SYSZ_INS_CGDBR,
    SYSZ_INS_CGEBR,
    SYSZ_INS_CGF,
    SYSZ_INS_CGFI,
    SYSZ_INS_CGFR,
    SYSZ_INS_CGFRL,
    SYSZ_INS_CGH,
    SYSZ_INS_CGHI,
    SYSZ_INS_CGHRL,
    SYSZ_INS_CGHSI,
    SYSZ_INS_CGR,
    SYSZ_INS_CGRL,
    SYSZ_INS_CGXBR,
    SYSZ_INS_CH,
    SYSZ_INS_CHF,
    SYSZ_INS_CHHSI,
    SYSZ_INS_CHI,
    SYSZ_INS_CHRL,
    SYSZ_INS_CHSI,
    SYSZ_INS_CHY,
    SYSZ_INS_CIH,
    SYSZ_INS_CL,
    SYSZ_INS_CLC,
    SYSZ_INS_CLFDBR,
    SYSZ_INS_CLFEBR,
    SYSZ_INS_CLFHSI,
    SYSZ_INS_CLFI,
    SYSZ_INS_CLFXBR,
    SYSZ_INS_CLG,
    SYSZ_INS_CLGDBR,
    SYSZ_INS_CLGEBR,
    SYSZ_INS_CLGF,
    SYSZ_INS_CLGFI,
    SYSZ_INS_CLGFR,
    SYSZ_INS_CLGFRL,
    SYSZ_INS_CLGHRL,
    SYSZ_INS_CLGHSI,
    SYSZ_INS_CLGR,
    SYSZ_INS_CLGRL,
    SYSZ_INS_CLGXBR,
    SYSZ_INS_CLHF,
    SYSZ_INS_CLHHSI,
    SYSZ_INS_CLHRL,
    SYSZ_INS_CLI,
    SYSZ_INS_CLIH,
    SYSZ_INS_CLIY,
    SYSZ_INS_CLR,
    SYSZ_INS_CLRL,
    SYSZ_INS_CLST,
    SYSZ_INS_CLY,
    SYSZ_INS_CPSDR,
    SYSZ_INS_CR,
    SYSZ_INS_CRL,
    SYSZ_INS_CS,
    SYSZ_INS_CSG,
    SYSZ_INS_CSY,
    SYSZ_INS_CXBR,
    SYSZ_INS_CXFBR,
    SYSZ_INS_CXGBR,
    SYSZ_INS_CXLFBR,
    SYSZ_INS_CXLGBR,
    SYSZ_INS_CY,
    SYSZ_INS_DDB,
    SYSZ_INS_DDBR,
    SYSZ_INS_DEB,
    SYSZ_INS_DEBR,
    SYSZ_INS_DL,
    SYSZ_INS_DLG,
    SYSZ_INS_DLGR,
    SYSZ_INS_DLR,
    SYSZ_INS_DSG,
    SYSZ_INS_DSGF,
    SYSZ_INS_DSGFR,
    SYSZ_INS_DSGR,
    SYSZ_INS_DXBR,
    SYSZ_INS_EAR,
    SYSZ_INS_FIDBR,
    SYSZ_INS_FIDBRA,
    SYSZ_INS_FIEBR,
    SYSZ_INS_FIEBRA,
    SYSZ_INS_FIXBR,
    SYSZ_INS_FIXBRA,
    SYSZ_INS_FLOGR,
    SYSZ_INS_IC,
    SYSZ_INS_ICY,
    SYSZ_INS_IIHF,
    SYSZ_INS_IIHH,
    SYSZ_INS_IIHL,
    SYSZ_INS_IILF,
    SYSZ_INS_IILH,
    SYSZ_INS_IILL,
    SYSZ_INS_IPM,
    SYSZ_INS_L,
    SYSZ_INS_LA,
    SYSZ_INS_LAA,
    SYSZ_INS_LAAG,
    SYSZ_INS_LAAL,
    SYSZ_INS_LAALG,
    SYSZ_INS_LAN,
    SYSZ_INS_LANG,
    SYSZ_INS_LAO,
    SYSZ_INS_LAOG,
    SYSZ_INS_LARL,
    SYSZ_INS_LAX,
    SYSZ_INS_LAXG,
    SYSZ_INS_LAY,
    SYSZ_INS_LB,
    SYSZ_INS_LBH,
    SYSZ_INS_LBR,
    SYSZ_INS_LCDBR,
    SYSZ_INS_LCEBR,
    SYSZ_INS_LCGFR,
    SYSZ_INS_LCGR,
    SYSZ_INS_LCR,
    SYSZ_INS_LCXBR,
    SYSZ_INS_LD,
    SYSZ_INS_LDEB,
    SYSZ_INS_LDEBR,
    SYSZ_INS_LDGR,
    SYSZ_INS_LDR,
    SYSZ_INS_LDXBR,
    SYSZ_INS_LDXBRA,
    SYSZ_INS_LDY,
    SYSZ_INS_LE,
    SYSZ_INS_LEDBR,
    SYSZ_INS_LEDBRA,
    SYSZ_INS_LER,
    SYSZ_INS_LEXBR,
    SYSZ_INS_LEXBRA,
    SYSZ_INS_LEY,
    SYSZ_INS_LFH,
    SYSZ_INS_LG,
    SYSZ_INS_LGB,
    SYSZ_INS_LGBR,
    SYSZ_INS_LGDR,
    SYSZ_INS_LGF,
    SYSZ_INS_LGFI,
    SYSZ_INS_LGFR,
    SYSZ_INS_LGFRL,
    SYSZ_INS_LGH,
    SYSZ_INS_LGHI,
    SYSZ_INS_LGHR,
    SYSZ_INS_LGHRL,
    SYSZ_INS_LGR,
    SYSZ_INS_LGRL,
    SYSZ_INS_LH,
    SYSZ_INS_LHH,
    SYSZ_INS_LHI,
    SYSZ_INS_LHR,
    SYSZ_INS_LHRL,
    SYSZ_INS_LHY,
    SYSZ_INS_LLC,
    SYSZ_INS_LLCH,
    SYSZ_INS_LLCR,
    SYSZ_INS_LLGC,
    SYSZ_INS_LLGCR,
    SYSZ_INS_LLGF,
    SYSZ_INS_LLGFR,
    SYSZ_INS_LLGFRL,
    SYSZ_INS_LLGH,
    SYSZ_INS_LLGHR,
    SYSZ_INS_LLGHRL,
    SYSZ_INS_LLH,
    SYSZ_INS_LLHH,
    SYSZ_INS_LLHR,
    SYSZ_INS_LLHRL,
    SYSZ_INS_LLIHF,
    SYSZ_INS_LLIHH,
    SYSZ_INS_LLIHL,
    SYSZ_INS_LLILF,
    SYSZ_INS_LLILH,
    SYSZ_INS_LLILL,
    SYSZ_INS_LMG,
    SYSZ_INS_LNDBR,
    SYSZ_INS_LNEBR,
    SYSZ_INS_LNGFR,
    SYSZ_INS_LNGR,
    SYSZ_INS_LNR,
    SYSZ_INS_LNXBR,
    SYSZ_INS_LPDBR,
    SYSZ_INS_LPEBR,
    SYSZ_INS_LPGFR,
    SYSZ_INS_LPGR,
    SYSZ_INS_LPR,
    SYSZ_INS_LPXBR,
    SYSZ_INS_LR,
    SYSZ_INS_LRL,
    SYSZ_INS_LRV,
    SYSZ_INS_LRVG,
    SYSZ_INS_LRVGR,
    SYSZ_INS_LRVR,
    SYSZ_INS_LT,
    SYSZ_INS_LTDBR,
    SYSZ_INS_LTEBR,
    SYSZ_INS_LTG,
    SYSZ_INS_LTGF,
    SYSZ_INS_LTGFR,
    SYSZ_INS_LTGR,
    SYSZ_INS_LTR,
    SYSZ_INS_LTXBR,
    SYSZ_INS_LXDB,
    SYSZ_INS_LXDBR,
    SYSZ_INS_LXEB,
    SYSZ_INS_LXEBR,
    SYSZ_INS_LXR,
    SYSZ_INS_LY,
    SYSZ_INS_LZDR,
    SYSZ_INS_LZER,
    SYSZ_INS_LZXR,
    SYSZ_INS_MADB,
    SYSZ_INS_MADBR,
    SYSZ_INS_MAEB,
    SYSZ_INS_MAEBR,
    SYSZ_INS_MDB,
    SYSZ_INS_MDBR,
    SYSZ_INS_MDEB,
    SYSZ_INS_MDEBR,
    SYSZ_INS_MEEB,
    SYSZ_INS_MEEBR,
    SYSZ_INS_MGHI,
    SYSZ_INS_MH,
    SYSZ_INS_MHI,
    SYSZ_INS_MHY,
    SYSZ_INS_MLG,
    SYSZ_INS_MLGR,
    SYSZ_INS_MS,
    SYSZ_INS_MSDB,
    SYSZ_INS_MSDBR,
    SYSZ_INS_MSEB,
    SYSZ_INS_MSEBR,
    SYSZ_INS_MSFI,
    SYSZ_INS_MSG,
    SYSZ_INS_MSGF,
    SYSZ_INS_MSGFI,
    SYSZ_INS_MSGFR,
    SYSZ_INS_MSGR,
    SYSZ_INS_MSR,
    SYSZ_INS_MSY,
    SYSZ_INS_MVC,
    SYSZ_INS_MVGHI,
    SYSZ_INS_MVHHI,
    SYSZ_INS_MVHI,
    SYSZ_INS_MVI,
    SYSZ_INS_MVIY,
    SYSZ_INS_MVST,
    SYSZ_INS_MXBR,
    SYSZ_INS_MXDB,
    SYSZ_INS_MXDBR,
    SYSZ_INS_N,
    SYSZ_INS_NC,
    SYSZ_INS_NG,
    SYSZ_INS_NGR,
    SYSZ_INS_NGRK,
    SYSZ_INS_NI,
    SYSZ_INS_NIHF,
    SYSZ_INS_NIHH,
    SYSZ_INS_NIHL,
    SYSZ_INS_NILF,
    SYSZ_INS_NILH,
    SYSZ_INS_NILL,
    SYSZ_INS_NIY,
    SYSZ_INS_NR,
    SYSZ_INS_NRK,
    SYSZ_INS_NY,
    SYSZ_INS_O,
    SYSZ_INS_OC,
    SYSZ_INS_OG,
    SYSZ_INS_OGR,
    SYSZ_INS_OGRK,
    SYSZ_INS_OI,
    SYSZ_INS_OIHF,
    SYSZ_INS_OIHH,
    SYSZ_INS_OIHL,
    SYSZ_INS_OILF,
    SYSZ_INS_OILH,
    SYSZ_INS_OILL,
    SYSZ_INS_OIY,
    SYSZ_INS_OR,
    SYSZ_INS_ORK,
    SYSZ_INS_OY,
    SYSZ_INS_PFD,
    SYSZ_INS_PFDRL,
    SYSZ_INS_RISBG,
    SYSZ_INS_RISBHG,
    SYSZ_INS_RISBLG,
    SYSZ_INS_RLL,
    SYSZ_INS_RLLG,
    SYSZ_INS_RNSBG,
    SYSZ_INS_ROSBG,
    SYSZ_INS_RXSBG,
    SYSZ_INS_S,
    SYSZ_INS_SDB,
    SYSZ_INS_SDBR,
    SYSZ_INS_SEB,
    SYSZ_INS_SEBR,
    SYSZ_INS_SG,
    SYSZ_INS_SGF,
    SYSZ_INS_SGFR,
    SYSZ_INS_SGR,
    SYSZ_INS_SGRK,
    SYSZ_INS_SH,
    SYSZ_INS_SHY,
    SYSZ_INS_SL,
    SYSZ_INS_SLB,
    SYSZ_INS_SLBG,
    SYSZ_INS_SLBR,
    SYSZ_INS_SLFI,
    SYSZ_INS_SLG,
    SYSZ_INS_SLBGR,
    SYSZ_INS_SLGF,
    SYSZ_INS_SLGFI,
    SYSZ_INS_SLGFR,
    SYSZ_INS_SLGR,
    SYSZ_INS_SLGRK,
    SYSZ_INS_SLL,
    SYSZ_INS_SLLG,
    SYSZ_INS_SLLK,
    SYSZ_INS_SLR,
    SYSZ_INS_SLRK,
    SYSZ_INS_SLY,
    SYSZ_INS_SQDB,
    SYSZ_INS_SQDBR,
    SYSZ_INS_SQEB,
    SYSZ_INS_SQEBR,
    SYSZ_INS_SQXBR,
    SYSZ_INS_SR,
    SYSZ_INS_SRA,
    SYSZ_INS_SRAG,
    SYSZ_INS_SRAK,
    SYSZ_INS_SRK,
    SYSZ_INS_SRL,
    SYSZ_INS_SRLG,
    SYSZ_INS_SRLK,
    SYSZ_INS_SRST,
    SYSZ_INS_ST,
    SYSZ_INS_STC,
    SYSZ_INS_STCH,
    SYSZ_INS_STCY,
    SYSZ_INS_STD,
    SYSZ_INS_STDY,
    SYSZ_INS_STE,
    SYSZ_INS_STEY,
    SYSZ_INS_STFH,
    SYSZ_INS_STG,
    SYSZ_INS_STGRL,
    SYSZ_INS_STH,
    SYSZ_INS_STHH,
    SYSZ_INS_STHRL,
    SYSZ_INS_STHY,
    SYSZ_INS_STMG,
    SYSZ_INS_STRL,
    SYSZ_INS_STRV,
    SYSZ_INS_STRVG,
    SYSZ_INS_STY,
    SYSZ_INS_SXBR,
    SYSZ_INS_SY,
    SYSZ_INS_TM,
    SYSZ_INS_TMHH,
    SYSZ_INS_TMHL,
    SYSZ_INS_TMLH,
    SYSZ_INS_TMLL,
    SYSZ_INS_TMY,
    SYSZ_INS_X,
    SYSZ_INS_XC,
    SYSZ_INS_XG,
    SYSZ_INS_XGR,
    SYSZ_INS_XGRK,
    SYSZ_INS_XI,
    SYSZ_INS_XIHF,
    SYSZ_INS_XILF,
    SYSZ_INS_XIY,
    SYSZ_INS_XR,
    SYSZ_INS_XRK,
    SYSZ_INS_XY,

    SYSZ_INS_ENDING,   // <-- mark the end of the list of instructions
} sysz_insn;

//> Group of SystemZ instructions
typedef enum sysz_insn_group
{
    SYSZ_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    SYSZ_GRP_JUMP,  // = CS_GRP_JUMP

    //> Architecture-specific groups
    SYSZ_GRP_DISTINCTOPS = 128,
    SYSZ_GRP_FPEXTENSION,
    SYSZ_GRP_HIGHWORD,
    SYSZ_GRP_INTERLOCKEDACCESS1,
    SYSZ_GRP_LOADSTOREONCOND,

    SYSZ_GRP_ENDING,   // <-- mark the end of the list of groups
} sysz_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/x86.h
================================================
#ifndef CAPSTONE_X86_H
#define CAPSTONE_X86_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// Calculate relative address for X86-64, given cs_insn structure
#define X86_REL_ADDR(insn) (((insn).detail->x86.operands[0].type == X86_OP_IMM) \
    ? (uint64_t)((insn).detail->x86.operands[0].imm) \
    : (((insn).address + (insn).size) + (uint64_t)(insn).detail->x86.disp))

//> X86 registers
typedef enum x86_reg
{
    X86_REG_INVALID = 0,
    X86_REG_AH, X86_REG_AL, X86_REG_AX, X86_REG_BH, X86_REG_BL,
    X86_REG_BP, X86_REG_BPL, X86_REG_BX, X86_REG_CH, X86_REG_CL,
    X86_REG_CS, X86_REG_CX, X86_REG_DH, X86_REG_DI, X86_REG_DIL,
    X86_REG_DL, X86_REG_DS, X86_REG_DX, X86_REG_EAX, X86_REG_EBP,
    X86_REG_EBX, X86_REG_ECX, X86_REG_EDI, X86_REG_EDX, X86_REG_EFLAGS,
    X86_REG_EIP, X86_REG_EIZ, X86_REG_ES, X86_REG_ESI, X86_REG_ESP,
    X86_REG_FPSW, X86_REG_FS, X86_REG_GS, X86_REG_IP, X86_REG_RAX,
    X86_REG_RBP, X86_REG_RBX, X86_REG_RCX, X86_REG_RDI, X86_REG_RDX,
    X86_REG_RIP, X86_REG_RIZ, X86_REG_RSI, X86_REG_RSP, X86_REG_SI,
    X86_REG_SIL, X86_REG_SP, X86_REG_SPL, X86_REG_SS, X86_REG_CR0,
    X86_REG_CR1, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR5,
    X86_REG_CR6, X86_REG_CR7, X86_REG_CR8, X86_REG_CR9, X86_REG_CR10,
    X86_REG_CR11, X86_REG_CR12, X86_REG_CR13, X86_REG_CR14, X86_REG_CR15,
    X86_REG_DR0, X86_REG_DR1, X86_REG_DR2, X86_REG_DR3, X86_REG_DR4,
    X86_REG_DR5, X86_REG_DR6, X86_REG_DR7, X86_REG_DR8, X86_REG_DR9,
    X86_REG_DR10, X86_REG_DR11, X86_REG_DR12, X86_REG_DR13, X86_REG_DR14,
    X86_REG_DR15, X86_REG_FP0, X86_REG_FP1, X86_REG_FP2, X86_REG_FP3,
    X86_REG_FP4, X86_REG_FP5, X86_REG_FP6, X86_REG_FP7,
    X86_REG_K0, X86_REG_K1, X86_REG_K2, X86_REG_K3, X86_REG_K4,
    X86_REG_K5, X86_REG_K6, X86_REG_K7, X86_REG_MM0, X86_REG_MM1,
    X86_REG_MM2, X86_REG_MM3, X86_REG_MM4, X86_REG_MM5, X86_REG_MM6,
    X86_REG_MM7, X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
    X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
    X86_REG_ST0, X86_REG_ST1, X86_REG_ST2, X86_REG_ST3,
    X86_REG_ST4, X86_REG_ST5, X86_REG_ST6, X86_REG_ST7,
    X86_REG_XMM0, X86_REG_XMM1, X86_REG_XMM2, X86_REG_XMM3, X86_REG_XMM4,
    X86_REG_XMM5, X86_REG_XMM6, X86_REG_XMM7, X86_REG_XMM8, X86_REG_XMM9,
    X86_REG_XMM10, X86_REG_XMM11, X86_REG_XMM12, X86_REG_XMM13, X86_REG_XMM14,
    X86_REG_XMM15, X86_REG_XMM16, X86_REG_XMM17, X86_REG_XMM18, X86_REG_XMM19,
    X86_REG_XMM20, X86_REG_XMM21, X86_REG_XMM22, X86_REG_XMM23, X86_REG_XMM24,
    X86_REG_XMM25, X86_REG_XMM26, X86_REG_XMM27, X86_REG_XMM28, X86_REG_XMM29,
    X86_REG_XMM30, X86_REG_XMM31, X86_REG_YMM0, X86_REG_YMM1, X86_REG_YMM2,
    X86_REG_YMM3, X86_REG_YMM4, X86_REG_YMM5, X86_REG_YMM6, X86_REG_YMM7,
    X86_REG_YMM8, X86_REG_YMM9, X86_REG_YMM10, X86_REG_YMM11, X86_REG_YMM12,
    X86_REG_YMM13, X86_REG_YMM14, X86_REG_YMM15, X86_REG_YMM16, X86_REG_YMM17,
    X86_REG_YMM18, X86_REG_YMM19, X86_REG_YMM20, X86_REG_YMM21, X86_REG_YMM22,
    X86_REG_YMM23, X86_REG_YMM24, X86_REG_YMM25, X86_REG_YMM26, X86_REG_YMM27,
    X86_REG_YMM28, X86_REG_YMM29, X86_REG_YMM30, X86_REG_YMM31, X86_REG_ZMM0,
    X86_REG_ZMM1, X86_REG_ZMM2, X86_REG_ZMM3, X86_REG_ZMM4, X86_REG_ZMM5,
    X86_REG_ZMM6, X86_REG_ZMM7, X86_REG_ZMM8, X86_REG_ZMM9, X86_REG_ZMM10,
    X86_REG_ZMM11, X86_REG_ZMM12, X86_REG_ZMM13, X86_REG_ZMM14, X86_REG_ZMM15,
    X86_REG_ZMM16, X86_REG_ZMM17, X86_REG_ZMM18, X86_REG_ZMM19, X86_REG_ZMM20,
    X86_REG_ZMM21, X86_REG_ZMM22, X86_REG_ZMM23, X86_REG_ZMM24, X86_REG_ZMM25,
    X86_REG_ZMM26, X86_REG_ZMM27, X86_REG_ZMM28, X86_REG_ZMM29, X86_REG_ZMM30,
    X86_REG_ZMM31, X86_REG_R8B, X86_REG_R9B, X86_REG_R10B, X86_REG_R11B,
    X86_REG_R12B, X86_REG_R13B, X86_REG_R14B, X86_REG_R15B, X86_REG_R8D,
    X86_REG_R9D, X86_REG_R10D, X86_REG_R11D, X86_REG_R12D, X86_REG_R13D,
    X86_REG_R14D, X86_REG_R15D, X86_REG_R8W, X86_REG_R9W, X86_REG_R10W,
    X86_REG_R11W, X86_REG_R12W, X86_REG_R13W, X86_REG_R14W, X86_REG_R15W,

    X86_REG_ENDING      // <-- mark the end of the list of registers
} x86_reg;

//> Sub-flags of EFLAGS
#define X86_EFLAGS_MODIFY_AF (1ULL << 0)
#define X86_EFLAGS_MODIFY_CF (1ULL << 1)
#define X86_EFLAGS_MODIFY_SF (1ULL << 2)
#define X86_EFLAGS_MODIFY_ZF (1ULL << 3)
#define X86_EFLAGS_MODIFY_PF (1ULL << 4)
#define X86_EFLAGS_MODIFY_OF (1ULL << 5)
#define X86_EFLAGS_MODIFY_TF (1ULL << 6)
#define X86_EFLAGS_MODIFY_IF (1ULL << 7)
#define X86_EFLAGS_MODIFY_DF (1ULL << 8)
#define X86_EFLAGS_MODIFY_NT (1ULL << 9)
#define X86_EFLAGS_MODIFY_RF (1ULL << 10)
#define X86_EFLAGS_PRIOR_OF (1ULL << 11)
#define X86_EFLAGS_PRIOR_SF (1ULL << 12)
#define X86_EFLAGS_PRIOR_ZF (1ULL << 13)
#define X86_EFLAGS_PRIOR_AF (1ULL << 14)
#define X86_EFLAGS_PRIOR_PF (1ULL << 15)
#define X86_EFLAGS_PRIOR_CF (1ULL << 16)
#define X86_EFLAGS_PRIOR_TF (1ULL << 17)
#define X86_EFLAGS_PRIOR_IF (1ULL << 18)
#define X86_EFLAGS_PRIOR_DF (1ULL << 19)
#define X86_EFLAGS_PRIOR_NT (1ULL << 20)
#define X86_EFLAGS_RESET_OF (1ULL << 21)
#define X86_EFLAGS_RESET_CF (1ULL << 22)
#define X86_EFLAGS_RESET_DF (1ULL << 23)
#define X86_EFLAGS_RESET_IF (1ULL << 24)
#define X86_EFLAGS_RESET_SF (1ULL << 25)
#define X86_EFLAGS_RESET_AF (1ULL << 26)
#define X86_EFLAGS_RESET_TF (1ULL << 27)
#define X86_EFLAGS_RESET_NT (1ULL << 28)
#define X86_EFLAGS_RESET_PF (1ULL << 29)
#define X86_EFLAGS_SET_CF (1ULL << 30)
#define X86_EFLAGS_SET_DF (1ULL << 31)
#define X86_EFLAGS_SET_IF (1ULL << 32)
#define X86_EFLAGS_TEST_OF (1ULL << 33)
#define X86_EFLAGS_TEST_SF (1ULL << 34)
#define X86_EFLAGS_TEST_ZF (1ULL << 35)
#define X86_EFLAGS_TEST_PF (1ULL << 36)
#define X86_EFLAGS_TEST_CF (1ULL << 37)
#define X86_EFLAGS_TEST_NT (1ULL << 38)
#define X86_EFLAGS_TEST_DF (1ULL << 39)
#define X86_EFLAGS_UNDEFINED_OF (1ULL << 40)
#define X86_EFLAGS_UNDEFINED_SF (1ULL << 41)
#define X86_EFLAGS_UNDEFINED_ZF (1ULL << 42)
#define X86_EFLAGS_UNDEFINED_PF (1ULL << 43)
#define X86_EFLAGS_UNDEFINED_AF (1ULL << 44)
#define X86_EFLAGS_UNDEFINED_CF (1ULL << 45)

//> Operand type for instruction's operands
typedef enum x86_op_type
{
    X86_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    X86_OP_REG, // = CS_OP_REG (Register operand).
    X86_OP_IMM, // = CS_OP_IMM (Immediate operand).
    X86_OP_MEM, // = CS_OP_MEM (Memory operand).
} x86_op_type;

//> XOP Code Condition type
typedef enum x86_xop_cc
{
    X86_XOP_CC_INVALID = 0, // Uninitialized.
    X86_XOP_CC_LT,
    X86_XOP_CC_LE,
    X86_XOP_CC_GT,
    X86_XOP_CC_GE,
    X86_XOP_CC_EQ,
    X86_XOP_CC_NEQ,
    X86_XOP_CC_FALSE,
    X86_XOP_CC_TRUE,
} x86_xop_cc;

//> AVX broadcast type
typedef enum x86_avx_bcast
{
    X86_AVX_BCAST_INVALID = 0,  // Uninitialized.
    X86_AVX_BCAST_2,    // AVX512 broadcast type {1to2}
    X86_AVX_BCAST_4,    // AVX512 broadcast type {1to4}
    X86_AVX_BCAST_8,    // AVX512 broadcast type {1to8}
    X86_AVX_BCAST_16,   // AVX512 broadcast type {1to16}
} x86_avx_bcast;

//> SSE Code Condition type
typedef enum x86_sse_cc
{
    X86_SSE_CC_INVALID = 0, // Uninitialized.
    X86_SSE_CC_EQ,
    X86_SSE_CC_LT,
    X86_SSE_CC_LE,
    X86_SSE_CC_UNORD,
    X86_SSE_CC_NEQ,
    X86_SSE_CC_NLT,
    X86_SSE_CC_NLE,
    X86_SSE_CC_ORD,
} x86_sse_cc;

//> AVX Code Condition type
typedef enum x86_avx_cc
{
    X86_AVX_CC_INVALID = 0, // Uninitialized.
    X86_AVX_CC_EQ,
    X86_AVX_CC_LT,
    X86_AVX_CC_LE,
    X86_AVX_CC_UNORD,
    X86_AVX_CC_NEQ,
    X86_AVX_CC_NLT,
    X86_AVX_CC_NLE,
    X86_AVX_CC_ORD,
    X86_AVX_CC_EQ_UQ,
    X86_AVX_CC_NGE,
    X86_AVX_CC_NGT,
    X86_AVX_CC_FALSE,
    X86_AVX_CC_NEQ_OQ,
    X86_AVX_CC_GE,
    X86_AVX_CC_GT,
    X86_AVX_CC_TRUE,
    X86_AVX_CC_EQ_OS,
    X86_AVX_CC_LT_OQ,
    X86_AVX_CC_LE_OQ,
    X86_AVX_CC_UNORD_S,
    X86_AVX_CC_NEQ_US,
    X86_AVX_CC_NLT_UQ,
    X86_AVX_CC_NLE_UQ,
    X86_AVX_CC_ORD_S,
    X86_AVX_CC_EQ_US,
    X86_AVX_CC_NGE_UQ,
    X86_AVX_CC_NGT_UQ,
    X86_AVX_CC_FALSE_OS,
    X86_AVX_CC_NEQ_OS,
    X86_AVX_CC_GE_OQ,
    X86_AVX_CC_GT_OQ,
    X86_AVX_CC_TRUE_US,
} x86_avx_cc;

//> AVX static rounding mode type
typedef enum x86_avx_rm
{
    X86_AVX_RM_INVALID = 0, // Uninitialized.
    X86_AVX_RM_RN,  // Round to nearest
    X86_AVX_RM_RD,  // Round down
    X86_AVX_RM_RU,  // Round up
    X86_AVX_RM_RZ,  // Round toward zero
} x86_avx_rm;

//> Instruction prefixes - to be used in cs_x86.prefix[]
typedef enum x86_prefix
{
    X86_PREFIX_LOCK     =   0xf0,   // lock (cs_x86.prefix[0]
    X86_PREFIX_REP      =   0xf3,   // rep (cs_x86.prefix[0]
    X86_PREFIX_REPE     =   0xf3,   // repe/repz (cs_x86.prefix[0]
    X86_PREFIX_REPNE    =   0xf2,   // repne/repnz (cs_x86.prefix[0]

    X86_PREFIX_CS       =   0x2e,   // segment override CS (cs_x86.prefix[1]
    X86_PREFIX_SS       =   0x36,   // segment override SS (cs_x86.prefix[1]
    X86_PREFIX_DS       =   0x3e,   // segment override DS (cs_x86.prefix[1]
    X86_PREFIX_ES       =   0x26,   // segment override ES (cs_x86.prefix[1]
    X86_PREFIX_FS       =   0x64,   // segment override FS (cs_x86.prefix[1]
    X86_PREFIX_GS       =   0x65,   // segment override GS (cs_x86.prefix[1]

    X86_PREFIX_OPSIZE   =   0x66,   // operand-size override (cs_x86.prefix[2]
    X86_PREFIX_ADDRSIZE =   0x67,   // address-size override (cs_x86.prefix[3]
} x86_prefix;

// Instruction's operand referring to memory
// This is associated with X86_OP_MEM operand type above
typedef struct x86_op_mem
{
    x86_reg segment; // segment register (or X86_REG_INVALID if irrelevant)
    x86_reg base;   // base register (or X86_REG_INVALID if irrelevant)
    x86_reg index;  // index register (or X86_REG_INVALID if irrelevant)
    int scale;  // scale for index register
    int64_t disp;   // displacement value
} x86_op_mem;

// Instruction operand
typedef struct cs_x86_op
{
    x86_op_type type;   // operand type
    union
    {
        x86_reg reg;      // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        x86_op_mem mem;     // base/index/scale/disp value for MEM operand
    };

    // size of this operand (in bytes).
    uint8_t size;

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;

    // AVX broadcast type, or 0 if irrelevant
    x86_avx_bcast avx_bcast;

    // AVX zero opmask {z}
    bool avx_zero_opmask;
} cs_x86_op;

// Instruction structure
typedef struct cs_x86
{
    // Instruction prefix, which can be up to 4 bytes.
    // A prefix byte gets value 0 when irrelevant.
    // prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
    // prefix[1] indicates segment override (irrelevant for x86_64):
    // See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
    // prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
    // prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
    uint8_t prefix[4];

    // Instruction opcode, which can be from 1 to 4 bytes in size.
    // This contains VEX opcode as well.
    // An trailing opcode byte gets value 0 when irrelevant.
    uint8_t opcode[4];

    // REX prefix: only a non-zero value is relevant for x86_64
    uint8_t rex;

    // Address size, which can be overridden with above prefix[5].
    uint8_t addr_size;

    // ModR/M byte
    uint8_t modrm;

    // SIB value, or 0 when irrelevant.
    uint8_t sib;

    // Displacement value, or 0 when irrelevant.
    int32_t disp;

    /* SIB state */
    // SIB index register, or X86_REG_INVALID when irrelevant.
    x86_reg sib_index;
    // SIB scale. only applicable if sib_index is relevant.
    int8_t sib_scale;
    // SIB base register, or X86_REG_INVALID when irrelevant.
    x86_reg sib_base;

    // XOP Code Condition
    x86_xop_cc xop_cc;

    // SSE Code Condition
    x86_sse_cc sse_cc;

    // AVX Code Condition
    x86_avx_cc avx_cc;

    // AVX Suppress all Exception
    bool avx_sae;

    // AVX static rounding mode
    x86_avx_rm avx_rm;

    // EFLAGS updated by this instruction.
    // This can be formed from OR combination of X86_EFLAGS_* symbols in x86.h
    uint64_t eflags;

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_x86_op operands[8];  // operands for this instruction.
} cs_x86;

//> X86 instructions
typedef enum x86_insn
{
    X86_INS_INVALID = 0,

    X86_INS_AAA,
    X86_INS_AAD,
    X86_INS_AAM,
    X86_INS_AAS,
    X86_INS_FABS,
    X86_INS_ADC,
    X86_INS_ADCX,
    X86_INS_ADD,
    X86_INS_ADDPD,
    X86_INS_ADDPS,
    X86_INS_ADDSD,
    X86_INS_ADDSS,
    X86_INS_ADDSUBPD,
    X86_INS_ADDSUBPS,
    X86_INS_FADD,
    X86_INS_FIADD,
    X86_INS_FADDP,
    X86_INS_ADOX,
    X86_INS_AESDECLAST,
    X86_INS_AESDEC,
    X86_INS_AESENCLAST,
    X86_INS_AESENC,
    X86_INS_AESIMC,
    X86_INS_AESKEYGENASSIST,
    X86_INS_AND,
    X86_INS_ANDN,
    X86_INS_ANDNPD,
    X86_INS_ANDNPS,
    X86_INS_ANDPD,
    X86_INS_ANDPS,
    X86_INS_ARPL,
    X86_INS_BEXTR,
    X86_INS_BLCFILL,
    X86_INS_BLCI,
    X86_INS_BLCIC,
    X86_INS_BLCMSK,
    X86_INS_BLCS,
    X86_INS_BLENDPD,
    X86_INS_BLENDPS,
    X86_INS_BLENDVPD,
    X86_INS_BLENDVPS,
    X86_INS_BLSFILL,
    X86_INS_BLSI,
    X86_INS_BLSIC,
    X86_INS_BLSMSK,
    X86_INS_BLSR,
    X86_INS_BOUND,
    X86_INS_BSF,
    X86_INS_BSR,
    X86_INS_BSWAP,
    X86_INS_BT,
    X86_INS_BTC,
    X86_INS_BTR,
    X86_INS_BTS,
    X86_INS_BZHI,
    X86_INS_CALL,
    X86_INS_CBW,
    X86_INS_CDQ,
    X86_INS_CDQE,
    X86_INS_FCHS,
    X86_INS_CLAC,
    X86_INS_CLC,
    X86_INS_CLD,
    X86_INS_CLFLUSH,
    X86_INS_CLFLUSHOPT,
    X86_INS_CLGI,
    X86_INS_CLI,
    X86_INS_CLTS,
    X86_INS_CLWB,
    X86_INS_CMC,
    X86_INS_CMOVA,
    X86_INS_CMOVAE,
    X86_INS_CMOVB,
    X86_INS_CMOVBE,
    X86_INS_FCMOVBE,
    X86_INS_FCMOVB,
    X86_INS_CMOVE,
    X86_INS_FCMOVE,
    X86_INS_CMOVG,
    X86_INS_CMOVGE,
    X86_INS_CMOVL,
    X86_INS_CMOVLE,
    X86_INS_FCMOVNBE,
    X86_INS_FCMOVNB,
    X86_INS_CMOVNE,
    X86_INS_FCMOVNE,
    X86_INS_CMOVNO,
    X86_INS_CMOVNP,
    X86_INS_FCMOVNU,
    X86_INS_CMOVNS,
    X86_INS_CMOVO,
    X86_INS_CMOVP,
    X86_INS_FCMOVU,
    X86_INS_CMOVS,
    X86_INS_CMP,
    X86_INS_CMPSB,
    X86_INS_CMPSQ,
    X86_INS_CMPSW,
    X86_INS_CMPXCHG16B,
    X86_INS_CMPXCHG,
    X86_INS_CMPXCHG8B,
    X86_INS_COMISD,
    X86_INS_COMISS,
    X86_INS_FCOMP,
    X86_INS_FCOMIP,
    X86_INS_FCOMI,
    X86_INS_FCOM,
    X86_INS_FCOS,
    X86_INS_CPUID,
    X86_INS_CQO,
    X86_INS_CRC32,
    X86_INS_CVTDQ2PD,
    X86_INS_CVTDQ2PS,
    X86_INS_CVTPD2DQ,
    X86_INS_CVTPD2PS,
    X86_INS_CVTPS2DQ,
    X86_INS_CVTPS2PD,
    X86_INS_CVTSD2SI,
    X86_INS_CVTSD2SS,
    X86_INS_CVTSI2SD,
    X86_INS_CVTSI2SS,
    X86_INS_CVTSS2SD,
    X86_INS_CVTSS2SI,
    X86_INS_CVTTPD2DQ,
    X86_INS_CVTTPS2DQ,
    X86_INS_CVTTSD2SI,
    X86_INS_CVTTSS2SI,
    X86_INS_CWD,
    X86_INS_CWDE,
    X86_INS_DAA,
    X86_INS_DAS,
    X86_INS_DATA16,
    X86_INS_DEC,
    X86_INS_DIV,
    X86_INS_DIVPD,
    X86_INS_DIVPS,
    X86_INS_FDIVR,
    X86_INS_FIDIVR,
    X86_INS_FDIVRP,
    X86_INS_DIVSD,
    X86_INS_DIVSS,
    X86_INS_FDIV,
    X86_INS_FIDIV,
    X86_INS_FDIVP,
    X86_INS_DPPD,
    X86_INS_DPPS,
    X86_INS_RET,
    X86_INS_ENCLS,
    X86_INS_ENCLU,
    X86_INS_ENTER,
    X86_INS_EXTRACTPS,
    X86_INS_EXTRQ,
    X86_INS_F2XM1,
    X86_INS_LCALL,
    X86_INS_LJMP,
    X86_INS_FBLD,
    X86_INS_FBSTP,
    X86_INS_FCOMPP,
    X86_INS_FDECSTP,
    X86_INS_FEMMS,
    X86_INS_FFREE,
    X86_INS_FICOM,
    X86_INS_FICOMP,
    X86_INS_FINCSTP,
    X86_INS_FLDCW,
    X86_INS_FLDENV,
    X86_INS_FLDL2E,
    X86_INS_FLDL2T,
    X86_INS_FLDLG2,
    X86_INS_FLDLN2,
    X86_INS_FLDPI,
    X86_INS_FNCLEX,
    X86_INS_FNINIT,
    X86_INS_FNOP,
    X86_INS_FNSTCW,
    X86_INS_FNSTSW,
    X86_INS_FPATAN,
    X86_INS_FPREM,
    X86_INS_FPREM1,
    X86_INS_FPTAN,
    X86_INS_FFREEP,
    X86_INS_FRNDINT,
    X86_INS_FRSTOR,
    X86_INS_FNSAVE,
    X86_INS_FSCALE,
    X86_INS_FSETPM,
    X86_INS_FSINCOS,
    X86_INS_FNSTENV,
    X86_INS_FXAM,
    X86_INS_FXRSTOR,
    X86_INS_FXRSTOR64,
    X86_INS_FXSAVE,
    X86_INS_FXSAVE64,
    X86_INS_FXTRACT,
    X86_INS_FYL2X,
    X86_INS_FYL2XP1,
    X86_INS_MOVAPD,
    X86_INS_MOVAPS,
    X86_INS_ORPD,
    X86_INS_ORPS,
    X86_INS_VMOVAPD,
    X86_INS_VMOVAPS,
    X86_INS_XORPD,
    X86_INS_XORPS,
    X86_INS_GETSEC,
    X86_INS_HADDPD,
    X86_INS_HADDPS,
    X86_INS_HLT,
    X86_INS_HSUBPD,
    X86_INS_HSUBPS,
    X86_INS_IDIV,
    X86_INS_FILD,
    X86_INS_IMUL,
    X86_INS_IN,
    X86_INS_INC,
    X86_INS_INSB,
    X86_INS_INSERTPS,
    X86_INS_INSERTQ,
    X86_INS_INSD,
    X86_INS_INSW,
    X86_INS_INT,
    X86_INS_INT1,
    X86_INS_INT3,
    X86_INS_INTO,
    X86_INS_INVD,
    X86_INS_INVEPT,
    X86_INS_INVLPG,
    X86_INS_INVLPGA,
    X86_INS_INVPCID,
    X86_INS_INVVPID,
    X86_INS_IRET,
    X86_INS_IRETD,
    X86_INS_IRETQ,
    X86_INS_FISTTP,
    X86_INS_FIST,
    X86_INS_FISTP,
    X86_INS_UCOMISD,
    X86_INS_UCOMISS,
    X86_INS_VCOMISD,
    X86_INS_VCOMISS,
    X86_INS_VCVTSD2SS,
    X86_INS_VCVTSI2SD,
    X86_INS_VCVTSI2SS,
    X86_INS_VCVTSS2SD,
    X86_INS_VCVTTSD2SI,
    X86_INS_VCVTTSD2USI,
    X86_INS_VCVTTSS2SI,
    X86_INS_VCVTTSS2USI,
    X86_INS_VCVTUSI2SD,
    X86_INS_VCVTUSI2SS,
    X86_INS_VUCOMISD,
    X86_INS_VUCOMISS,
    X86_INS_JAE,
    X86_INS_JA,
    X86_INS_JBE,
    X86_INS_JB,
    X86_INS_JCXZ,
    X86_INS_JECXZ,
    X86_INS_JE,
    X86_INS_JGE,
    X86_INS_JG,
    X86_INS_JLE,
    X86_INS_JL,
    X86_INS_JMP,
    X86_INS_JNE,
    X86_INS_JNO,
    X86_INS_JNP,
    X86_INS_JNS,
    X86_INS_JO,
    X86_INS_JP,
    X86_INS_JRCXZ,
    X86_INS_JS,
    X86_INS_KANDB,
    X86_INS_KANDD,
    X86_INS_KANDNB,
    X86_INS_KANDND,
    X86_INS_KANDNQ,
    X86_INS_KANDNW,
    X86_INS_KANDQ,
    X86_INS_KANDW,
    X86_INS_KMOVB,
    X86_INS_KMOVD,
    X86_INS_KMOVQ,
    X86_INS_KMOVW,
    X86_INS_KNOTB,
    X86_INS_KNOTD,
    X86_INS_KNOTQ,
    X86_INS_KNOTW,
    X86_INS_KORB,
    X86_INS_KORD,
    X86_INS_KORQ,
    X86_INS_KORTESTB,
    X86_INS_KORTESTD,
    X86_INS_KORTESTQ,
    X86_INS_KORTESTW,
    X86_INS_KORW,
    X86_INS_KSHIFTLB,
    X86_INS_KSHIFTLD,
    X86_INS_KSHIFTLQ,
    X86_INS_KSHIFTLW,
    X86_INS_KSHIFTRB,
    X86_INS_KSHIFTRD,
    X86_INS_KSHIFTRQ,
    X86_INS_KSHIFTRW,
    X86_INS_KUNPCKBW,
    X86_INS_KXNORB,
    X86_INS_KXNORD,
    X86_INS_KXNORQ,
    X86_INS_KXNORW,
    X86_INS_KXORB,
    X86_INS_KXORD,
    X86_INS_KXORQ,
    X86_INS_KXORW,
    X86_INS_LAHF,
    X86_INS_LAR,
    X86_INS_LDDQU,
    X86_INS_LDMXCSR,
    X86_INS_LDS,
    X86_INS_FLDZ,
    X86_INS_FLD1,
    X86_INS_FLD,
    X86_INS_LEA,
    X86_INS_LEAVE,
    X86_INS_LES,
    X86_INS_LFENCE,
    X86_INS_LFS,
    X86_INS_LGDT,
    X86_INS_LGS,
    X86_INS_LIDT,
    X86_INS_LLDT,
    X86_INS_LMSW,
    X86_INS_OR,
    X86_INS_SUB,
    X86_INS_XOR,
    X86_INS_LODSB,
    X86_INS_LODSD,
    X86_INS_LODSQ,
    X86_INS_LODSW,
    X86_INS_LOOP,
    X86_INS_LOOPE,
    X86_INS_LOOPNE,
    X86_INS_RETF,
    X86_INS_RETFQ,
    X86_INS_LSL,
    X86_INS_LSS,
    X86_INS_LTR,
    X86_INS_XADD,
    X86_INS_LZCNT,
    X86_INS_MASKMOVDQU,
    X86_INS_MAXPD,
    X86_INS_MAXPS,
    X86_INS_MAXSD,
    X86_INS_MAXSS,
    X86_INS_MFENCE,
    X86_INS_MINPD,
    X86_INS_MINPS,
    X86_INS_MINSD,
    X86_INS_MINSS,
    X86_INS_CVTPD2PI,
    X86_INS_CVTPI2PD,
    X86_INS_CVTPI2PS,
    X86_INS_CVTPS2PI,
    X86_INS_CVTTPD2PI,
    X86_INS_CVTTPS2PI,
    X86_INS_EMMS,
    X86_INS_MASKMOVQ,
    X86_INS_MOVD,
    X86_INS_MOVDQ2Q,
    X86_INS_MOVNTQ,
    X86_INS_MOVQ2DQ,
    X86_INS_MOVQ,
    X86_INS_PABSB,
    X86_INS_PABSD,
    X86_INS_PABSW,
    X86_INS_PACKSSDW,
    X86_INS_PACKSSWB,
    X86_INS_PACKUSWB,
    X86_INS_PADDB,
    X86_INS_PADDD,
    X86_INS_PADDQ,
    X86_INS_PADDSB,
    X86_INS_PADDSW,
    X86_INS_PADDUSB,
    X86_INS_PADDUSW,
    X86_INS_PADDW,
    X86_INS_PALIGNR,
    X86_INS_PANDN,
    X86_INS_PAND,
    X86_INS_PAVGB,
    X86_INS_PAVGW,
    X86_INS_PCMPEQB,
    X86_INS_PCMPEQD,
    X86_INS_PCMPEQW,
    X86_INS_PCMPGTB,
    X86_INS_PCMPGTD,
    X86_INS_PCMPGTW,
    X86_INS_PEXTRW,
    X86_INS_PHADDSW,
    X86_INS_PHADDW,
    X86_INS_PHADDD,
    X86_INS_PHSUBD,
    X86_INS_PHSUBSW,
    X86_INS_PHSUBW,
    X86_INS_PINSRW,
    X86_INS_PMADDUBSW,
    X86_INS_PMADDWD,
    X86_INS_PMAXSW,
    X86_INS_PMAXUB,
    X86_INS_PMINSW,
    X86_INS_PMINUB,
    X86_INS_PMOVMSKB,
    X86_INS_PMULHRSW,
    X86_INS_PMULHUW,
    X86_INS_PMULHW,
    X86_INS_PMULLW,
    X86_INS_PMULUDQ,
    X86_INS_POR,
    X86_INS_PSADBW,
    X86_INS_PSHUFB,
    X86_INS_PSHUFW,
    X86_INS_PSIGNB,
    X86_INS_PSIGND,
    X86_INS_PSIGNW,
    X86_INS_PSLLD,
    X86_INS_PSLLQ,
    X86_INS_PSLLW,
    X86_INS_PSRAD,
    X86_INS_PSRAW,
    X86_INS_PSRLD,
    X86_INS_PSRLQ,
    X86_INS_PSRLW,
    X86_INS_PSUBB,
    X86_INS_PSUBD,
    X86_INS_PSUBQ,
    X86_INS_PSUBSB,
    X86_INS_PSUBSW,
    X86_INS_PSUBUSB,
    X86_INS_PSUBUSW,
    X86_INS_PSUBW,
    X86_INS_PUNPCKHBW,
    X86_INS_PUNPCKHDQ,
    X86_INS_PUNPCKHWD,
    X86_INS_PUNPCKLBW,
    X86_INS_PUNPCKLDQ,
    X86_INS_PUNPCKLWD,
    X86_INS_PXOR,
    X86_INS_MONITOR,
    X86_INS_MONTMUL,
    X86_INS_MOV,
    X86_INS_MOVABS,
    X86_INS_MOVBE,
    X86_INS_MOVDDUP,
    X86_INS_MOVDQA,
    X86_INS_MOVDQU,
    X86_INS_MOVHLPS,
    X86_INS_MOVHPD,
    X86_INS_MOVHPS,
    X86_INS_MOVLHPS,
    X86_INS_MOVLPD,
    X86_INS_MOVLPS,
    X86_INS_MOVMSKPD,
    X86_INS_MOVMSKPS,
    X86_INS_MOVNTDQA,
    X86_INS_MOVNTDQ,
    X86_INS_MOVNTI,
    X86_INS_MOVNTPD,
    X86_INS_MOVNTPS,
    X86_INS_MOVNTSD,
    X86_INS_MOVNTSS,
    X86_INS_MOVSB,
    X86_INS_MOVSD,
    X86_INS_MOVSHDUP,
    X86_INS_MOVSLDUP,
    X86_INS_MOVSQ,
    X86_INS_MOVSS,
    X86_INS_MOVSW,
    X86_INS_MOVSX,
    X86_INS_MOVSXD,
    X86_INS_MOVUPD,
    X86_INS_MOVUPS,
    X86_INS_MOVZX,
    X86_INS_MPSADBW,
    X86_INS_MUL,
    X86_INS_MULPD,
    X86_INS_MULPS,
    X86_INS_MULSD,
    X86_INS_MULSS,
    X86_INS_MULX,
    X86_INS_FMUL,
    X86_INS_FIMUL,
    X86_INS_FMULP,
    X86_INS_MWAIT,
    X86_INS_NEG,
    X86_INS_NOP,
    X86_INS_NOT,
    X86_INS_OUT,
    X86_INS_OUTSB,
    X86_INS_OUTSD,
    X86_INS_OUTSW,
    X86_INS_PACKUSDW,
    X86_INS_PAUSE,
    X86_INS_PAVGUSB,
    X86_INS_PBLENDVB,
    X86_INS_PBLENDW,
    X86_INS_PCLMULQDQ,
    X86_INS_PCMPEQQ,
    X86_INS_PCMPESTRI,
    X86_INS_PCMPESTRM,
    X86_INS_PCMPGTQ,
    X86_INS_PCMPISTRI,
    X86_INS_PCMPISTRM,
    X86_INS_PCOMMIT,
    X86_INS_PDEP,
    X86_INS_PEXT,
    X86_INS_PEXTRB,
    X86_INS_PEXTRD,
    X86_INS_PEXTRQ,
    X86_INS_PF2ID,
    X86_INS_PF2IW,
    X86_INS_PFACC,
    X86_INS_PFADD,
    X86_INS_PFCMPEQ,
    X86_INS_PFCMPGE,
    X86_INS_PFCMPGT,
    X86_INS_PFMAX,
    X86_INS_PFMIN,
    X86_INS_PFMUL,
    X86_INS_PFNACC,
    X86_INS_PFPNACC,
    X86_INS_PFRCPIT1,
    X86_INS_PFRCPIT2,
    X86_INS_PFRCP,
    X86_INS_PFRSQIT1,
    X86_INS_PFRSQRT,
    X86_INS_PFSUBR,
    X86_INS_PFSUB,
    X86_INS_PHMINPOSUW,
    X86_INS_PI2FD,
    X86_INS_PI2FW,
    X86_INS_PINSRB,
    X86_INS_PINSRD,
    X86_INS_PINSRQ,
    X86_INS_PMAXSB,
    X86_INS_PMAXSD,
    X86_INS_PMAXUD,
    X86_INS_PMAXUW,
    X86_INS_PMINSB,
    X86_INS_PMINSD,
    X86_INS_PMINUD,
    X86_INS_PMINUW,
    X86_INS_PMOVSXBD,
    X86_INS_PMOVSXBQ,
    X86_INS_PMOVSXBW,
    X86_INS_PMOVSXDQ,
    X86_INS_PMOVSXWD,
    X86_INS_PMOVSXWQ,
    X86_INS_PMOVZXBD,
    X86_INS_PMOVZXBQ,
    X86_INS_PMOVZXBW,
    X86_INS_PMOVZXDQ,
    X86_INS_PMOVZXWD,
    X86_INS_PMOVZXWQ,
    X86_INS_PMULDQ,
    X86_INS_PMULHRW,
    X86_INS_PMULLD,
    X86_INS_POP,
    X86_INS_POPAW,
    X86_INS_POPAL,
    X86_INS_POPCNT,
    X86_INS_POPF,
    X86_INS_POPFD,
    X86_INS_POPFQ,
    X86_INS_PREFETCH,
    X86_INS_PREFETCHNTA,
    X86_INS_PREFETCHT0,
    X86_INS_PREFETCHT1,
    X86_INS_PREFETCHT2,
    X86_INS_PREFETCHW,
    X86_INS_PSHUFD,
    X86_INS_PSHUFHW,
    X86_INS_PSHUFLW,
    X86_INS_PSLLDQ,
    X86_INS_PSRLDQ,
    X86_INS_PSWAPD,
    X86_INS_PTEST,
    X86_INS_PUNPCKHQDQ,
    X86_INS_PUNPCKLQDQ,
    X86_INS_PUSH,
    X86_INS_PUSHAW,
    X86_INS_PUSHAL,
    X86_INS_PUSHF,
    X86_INS_PUSHFD,
    X86_INS_PUSHFQ,
    X86_INS_RCL,
    X86_INS_RCPPS,
    X86_INS_RCPSS,
    X86_INS_RCR,
    X86_INS_RDFSBASE,
    X86_INS_RDGSBASE,
    X86_INS_RDMSR,
    X86_INS_RDPMC,
    X86_INS_RDRAND,
    X86_INS_RDSEED,
    X86_INS_RDTSC,
    X86_INS_RDTSCP,
    X86_INS_ROL,
    X86_INS_ROR,
    X86_INS_RORX,
    X86_INS_ROUNDPD,
    X86_INS_ROUNDPS,
    X86_INS_ROUNDSD,
    X86_INS_ROUNDSS,
    X86_INS_RSM,
    X86_INS_RSQRTPS,
    X86_INS_RSQRTSS,
    X86_INS_SAHF,
    X86_INS_SAL,
    X86_INS_SALC,
    X86_INS_SAR,
    X86_INS_SARX,
    X86_INS_SBB,
    X86_INS_SCASB,
    X86_INS_SCASD,
    X86_INS_SCASQ,
    X86_INS_SCASW,
    X86_INS_SETAE,
    X86_INS_SETA,
    X86_INS_SETBE,
    X86_INS_SETB,
    X86_INS_SETE,
    X86_INS_SETGE,
    X86_INS_SETG,
    X86_INS_SETLE,
    X86_INS_SETL,
    X86_INS_SETNE,
    X86_INS_SETNO,
    X86_INS_SETNP,
    X86_INS_SETNS,
    X86_INS_SETO,
    X86_INS_SETP,
    X86_INS_SETS,
    X86_INS_SFENCE,
    X86_INS_SGDT,
    X86_INS_SHA1MSG1,
    X86_INS_SHA1MSG2,
    X86_INS_SHA1NEXTE,
    X86_INS_SHA1RNDS4,
    X86_INS_SHA256MSG1,
    X86_INS_SHA256MSG2,
    X86_INS_SHA256RNDS2,
    X86_INS_SHL,
    X86_INS_SHLD,
    X86_INS_SHLX,
    X86_INS_SHR,
    X86_INS_SHRD,
    X86_INS_SHRX,
    X86_INS_SHUFPD,
    X86_INS_SHUFPS,
    X86_INS_SIDT,
    X86_INS_FSIN,
    X86_INS_SKINIT,
    X86_INS_SLDT,
    X86_INS_SMSW,
    X86_INS_SQRTPD,
    X86_INS_SQRTPS,
    X86_INS_SQRTSD,
    X86_INS_SQRTSS,
    X86_INS_FSQRT,
    X86_INS_STAC,
    X86_INS_STC,
    X86_INS_STD,
    X86_INS_STGI,
    X86_INS_STI,
    X86_INS_STMXCSR,
    X86_INS_STOSB,
    X86_INS_STOSD,
    X86_INS_STOSQ,
    X86_INS_STOSW,
    X86_INS_STR,
    X86_INS_FST,
    X86_INS_FSTP,
    X86_INS_FSTPNCE,
    X86_INS_FXCH,
    X86_INS_SUBPD,
    X86_INS_SUBPS,
    X86_INS_FSUBR,
    X86_INS_FISUBR,
    X86_INS_FSUBRP,
    X86_INS_SUBSD,
    X86_INS_SUBSS,
    X86_INS_FSUB,
    X86_INS_FISUB,
    X86_INS_FSUBP,
    X86_INS_SWAPGS,
    X86_INS_SYSCALL,
    X86_INS_SYSENTER,
    X86_INS_SYSEXIT,
    X86_INS_SYSRET,
    X86_INS_T1MSKC,
    X86_INS_TEST,
    X86_INS_UD2,
    X86_INS_FTST,
    X86_INS_TZCNT,
    X86_INS_TZMSK,
    X86_INS_FUCOMIP,
    X86_INS_FUCOMI,
    X86_INS_FUCOMPP,
    X86_INS_FUCOMP,
    X86_INS_FUCOM,
    X86_INS_UD2B,
    X86_INS_UNPCKHPD,
    X86_INS_UNPCKHPS,
    X86_INS_UNPCKLPD,
    X86_INS_UNPCKLPS,
    X86_INS_VADDPD,
    X86_INS_VADDPS,
    X86_INS_VADDSD,
    X86_INS_VADDSS,
    X86_INS_VADDSUBPD,
    X86_INS_VADDSUBPS,
    X86_INS_VAESDECLAST,
    X86_INS_VAESDEC,
    X86_INS_VAESENCLAST,
    X86_INS_VAESENC,
    X86_INS_VAESIMC,
    X86_INS_VAESKEYGENASSIST,
    X86_INS_VALIGND,
    X86_INS_VALIGNQ,
    X86_INS_VANDNPD,
    X86_INS_VANDNPS,
    X86_INS_VANDPD,
    X86_INS_VANDPS,
    X86_INS_VBLENDMPD,
    X86_INS_VBLENDMPS,
    X86_INS_VBLENDPD,
    X86_INS_VBLENDPS,
    X86_INS_VBLENDVPD,
    X86_INS_VBLENDVPS,
    X86_INS_VBROADCASTF128,
    X86_INS_VBROADCASTI32X4,
    X86_INS_VBROADCASTI64X4,
    X86_INS_VBROADCASTSD,
    X86_INS_VBROADCASTSS,
    X86_INS_VCOMPRESSPD,
    X86_INS_VCOMPRESSPS,
    X86_INS_VCVTDQ2PD,
    X86_INS_VCVTDQ2PS,
    X86_INS_VCVTPD2DQX,
    X86_INS_VCVTPD2DQ,
    X86_INS_VCVTPD2PSX,
    X86_INS_VCVTPD2PS,
    X86_INS_VCVTPD2UDQ,
    X86_INS_VCVTPH2PS,
    X86_INS_VCVTPS2DQ,
    X86_INS_VCVTPS2PD,
    X86_INS_VCVTPS2PH,
    X86_INS_VCVTPS2UDQ,
    X86_INS_VCVTSD2SI,
    X86_INS_VCVTSD2USI,
    X86_INS_VCVTSS2SI,
    X86_INS_VCVTSS2USI,
    X86_INS_VCVTTPD2DQX,
    X86_INS_VCVTTPD2DQ,
    X86_INS_VCVTTPD2UDQ,
    X86_INS_VCVTTPS2DQ,
    X86_INS_VCVTTPS2UDQ,
    X86_INS_VCVTUDQ2PD,
    X86_INS_VCVTUDQ2PS,
    X86_INS_VDIVPD,
    X86_INS_VDIVPS,
    X86_INS_VDIVSD,
    X86_INS_VDIVSS,
    X86_INS_VDPPD,
    X86_INS_VDPPS,
    X86_INS_VERR,
    X86_INS_VERW,
    X86_INS_VEXP2PD,
    X86_INS_VEXP2PS,
    X86_INS_VEXPANDPD,
    X86_INS_VEXPANDPS,
    X86_INS_VEXTRACTF128,
    X86_INS_VEXTRACTF32X4,
    X86_INS_VEXTRACTF64X4,
    X86_INS_VEXTRACTI128,
    X86_INS_VEXTRACTI32X4,
    X86_INS_VEXTRACTI64X4,
    X86_INS_VEXTRACTPS,
    X86_INS_VFMADD132PD,
    X86_INS_VFMADD132PS,
    X86_INS_VFMADDPD,
    X86_INS_VFMADD213PD,
    X86_INS_VFMADD231PD,
    X86_INS_VFMADDPS,
    X86_INS_VFMADD213PS,
    X86_INS_VFMADD231PS,
    X86_INS_VFMADDSD,
    X86_INS_VFMADD213SD,
    X86_INS_VFMADD132SD,
    X86_INS_VFMADD231SD,
    X86_INS_VFMADDSS,
    X86_INS_VFMADD213SS,
    X86_INS_VFMADD132SS,
    X86_INS_VFMADD231SS,
    X86_INS_VFMADDSUB132PD,
    X86_INS_VFMADDSUB132PS,
    X86_INS_VFMADDSUBPD,
    X86_INS_VFMADDSUB213PD,
    X86_INS_VFMADDSUB231PD,
    X86_INS_VFMADDSUBPS,
    X86_INS_VFMADDSUB213PS,
    X86_INS_VFMADDSUB231PS,
    X86_INS_VFMSUB132PD,
    X86_INS_VFMSUB132PS,
    X86_INS_VFMSUBADD132PD,
    X86_INS_VFMSUBADD132PS,
    X86_INS_VFMSUBADDPD,
    X86_INS_VFMSUBADD213PD,
    X86_INS_VFMSUBADD231PD,
    X86_INS_VFMSUBADDPS,
    X86_INS_VFMSUBADD213PS,
    X86_INS_VFMSUBADD231PS,
    X86_INS_VFMSUBPD,
    X86_INS_VFMSUB213PD,
    X86_INS_VFMSUB231PD,
    X86_INS_VFMSUBPS,
    X86_INS_VFMSUB213PS,
    X86_INS_VFMSUB231PS,
    X86_INS_VFMSUBSD,
    X86_INS_VFMSUB213SD,
    X86_INS_VFMSUB132SD,
    X86_INS_VFMSUB231SD,
    X86_INS_VFMSUBSS,
    X86_INS_VFMSUB213SS,
    X86_INS_VFMSUB132SS,
    X86_INS_VFMSUB231SS,
    X86_INS_VFNMADD132PD,
    X86_INS_VFNMADD132PS,
    X86_INS_VFNMADDPD,
    X86_INS_VFNMADD213PD,
    X86_INS_VFNMADD231PD,
    X86_INS_VFNMADDPS,
    X86_INS_VFNMADD213PS,
    X86_INS_VFNMADD231PS,
    X86_INS_VFNMADDSD,
    X86_INS_VFNMADD213SD,
    X86_INS_VFNMADD132SD,
    X86_INS_VFNMADD231SD,
    X86_INS_VFNMADDSS,
    X86_INS_VFNMADD213SS,
    X86_INS_VFNMADD132SS,
    X86_INS_VFNMADD231SS,
    X86_INS_VFNMSUB132PD,
    X86_INS_VFNMSUB132PS,
    X86_INS_VFNMSUBPD,
    X86_INS_VFNMSUB213PD,
    X86_INS_VFNMSUB231PD,
    X86_INS_VFNMSUBPS,
    X86_INS_VFNMSUB213PS,
    X86_INS_VFNMSUB231PS,
    X86_INS_VFNMSUBSD,
    X86_INS_VFNMSUB213SD,
    X86_INS_VFNMSUB132SD,
    X86_INS_VFNMSUB231SD,
    X86_INS_VFNMSUBSS,
    X86_INS_VFNMSUB213SS,
    X86_INS_VFNMSUB132SS,
    X86_INS_VFNMSUB231SS,
    X86_INS_VFRCZPD,
    X86_INS_VFRCZPS,
    X86_INS_VFRCZSD,
    X86_INS_VFRCZSS,
    X86_INS_VORPD,
    X86_INS_VORPS,
    X86_INS_VXORPD,
    X86_INS_VXORPS,
    X86_INS_VGATHERDPD,
    X86_INS_VGATHERDPS,
    X86_INS_VGATHERPF0DPD,
    X86_INS_VGATHERPF0DPS,
    X86_INS_VGATHERPF0QPD,
    X86_INS_VGATHERPF0QPS,
    X86_INS_VGATHERPF1DPD,
    X86_INS_VGATHERPF1DPS,
    X86_INS_VGATHERPF1QPD,
    X86_INS_VGATHERPF1QPS,
    X86_INS_VGATHERQPD,
    X86_INS_VGATHERQPS,
    X86_INS_VHADDPD,
    X86_INS_VHADDPS,
    X86_INS_VHSUBPD,
    X86_INS_VHSUBPS,
    X86_INS_VINSERTF128,
    X86_INS_VINSERTF32X4,
    X86_INS_VINSERTF32X8,
    X86_INS_VINSERTF64X2,
    X86_INS_VINSERTF64X4,
    X86_INS_VINSERTI128,
    X86_INS_VINSERTI32X4,
    X86_INS_VINSERTI32X8,
    X86_INS_VINSERTI64X2,
    X86_INS_VINSERTI64X4,
    X86_INS_VINSERTPS,
    X86_INS_VLDDQU,
    X86_INS_VLDMXCSR,
    X86_INS_VMASKMOVDQU,
    X86_INS_VMASKMOVPD,
    X86_INS_VMASKMOVPS,
    X86_INS_VMAXPD,
    X86_INS_VMAXPS,
    X86_INS_VMAXSD,
    X86_INS_VMAXSS,
    X86_INS_VMCALL,
    X86_INS_VMCLEAR,
    X86_INS_VMFUNC,
    X86_INS_VMINPD,
    X86_INS_VMINPS,
    X86_INS_VMINSD,
    X86_INS_VMINSS,
    X86_INS_VMLAUNCH,
    X86_INS_VMLOAD,
    X86_INS_VMMCALL,
    X86_INS_VMOVQ,
    X86_INS_VMOVDDUP,
    X86_INS_VMOVD,
    X86_INS_VMOVDQA32,
    X86_INS_VMOVDQA64,
    X86_INS_VMOVDQA,
    X86_INS_VMOVDQU16,
    X86_INS_VMOVDQU32,
    X86_INS_VMOVDQU64,
    X86_INS_VMOVDQU8,
    X86_INS_VMOVDQU,
    X86_INS_VMOVHLPS,
    X86_INS_VMOVHPD,
    X86_INS_VMOVHPS,
    X86_INS_VMOVLHPS,
    X86_INS_VMOVLPD,
    X86_INS_VMOVLPS,
    X86_INS_VMOVMSKPD,
    X86_INS_VMOVMSKPS,
    X86_INS_VMOVNTDQA,
    X86_INS_VMOVNTDQ,
    X86_INS_VMOVNTPD,
    X86_INS_VMOVNTPS,
    X86_INS_VMOVSD,
    X86_INS_VMOVSHDUP,
    X86_INS_VMOVSLDUP,
    X86_INS_VMOVSS,
    X86_INS_VMOVUPD,
    X86_INS_VMOVUPS,
    X86_INS_VMPSADBW,
    X86_INS_VMPTRLD,
    X86_INS_VMPTRST,
    X86_INS_VMREAD,
    X86_INS_VMRESUME,
    X86_INS_VMRUN,
    X86_INS_VMSAVE,
    X86_INS_VMULPD,
    X86_INS_VMULPS,
    X86_INS_VMULSD,
    X86_INS_VMULSS,
    X86_INS_VMWRITE,
    X86_INS_VMXOFF,
    X86_INS_VMXON,
    X86_INS_VPABSB,
    X86_INS_VPABSD,
    X86_INS_VPABSQ,
    X86_INS_VPABSW,
    X86_INS_VPACKSSDW,
    X86_INS_VPACKSSWB,
    X86_INS_VPACKUSDW,
    X86_INS_VPACKUSWB,
    X86_INS_VPADDB,
    X86_INS_VPADDD,
    X86_INS_VPADDQ,
    X86_INS_VPADDSB,
    X86_INS_VPADDSW,
    X86_INS_VPADDUSB,
    X86_INS_VPADDUSW,
    X86_INS_VPADDW,
    X86_INS_VPALIGNR,
    X86_INS_VPANDD,
    X86_INS_VPANDND,
    X86_INS_VPANDNQ,
    X86_INS_VPANDN,
    X86_INS_VPANDQ,
    X86_INS_VPAND,
    X86_INS_VPAVGB,
    X86_INS_VPAVGW,
    X86_INS_VPBLENDD,
    X86_INS_VPBLENDMB,
    X86_INS_VPBLENDMD,
    X86_INS_VPBLENDMQ,
    X86_INS_VPBLENDMW,
    X86_INS_VPBLENDVB,
    X86_INS_VPBLENDW,
    X86_INS_VPBROADCASTB,
    X86_INS_VPBROADCASTD,
    X86_INS_VPBROADCASTMB2Q,
    X86_INS_VPBROADCASTMW2D,
    X86_INS_VPBROADCASTQ,
    X86_INS_VPBROADCASTW,
    X86_INS_VPCLMULQDQ,
    X86_INS_VPCMOV,
    X86_INS_VPCMPB,
    X86_INS_VPCMPD,
    X86_INS_VPCMPEQB,
    X86_INS_VPCMPEQD,
    X86_INS_VPCMPEQQ,
    X86_INS_VPCMPEQW,
    X86_INS_VPCMPESTRI,
    X86_INS_VPCMPESTRM,
    X86_INS_VPCMPGTB,
    X86_INS_VPCMPGTD,
    X86_INS_VPCMPGTQ,
    X86_INS_VPCMPGTW,
    X86_INS_VPCMPISTRI,
    X86_INS_VPCMPISTRM,
    X86_INS_VPCMPQ,
    X86_INS_VPCMPUB,
    X86_INS_VPCMPUD,
    X86_INS_VPCMPUQ,
    X86_INS_VPCMPUW,
    X86_INS_VPCMPW,
    X86_INS_VPCOMB,
    X86_INS_VPCOMD,
    X86_INS_VPCOMPRESSD,
    X86_INS_VPCOMPRESSQ,
    X86_INS_VPCOMQ,
    X86_INS_VPCOMUB,
    X86_INS_VPCOMUD,
    X86_INS_VPCOMUQ,
    X86_INS_VPCOMUW,
    X86_INS_VPCOMW,
    X86_INS_VPCONFLICTD,
    X86_INS_VPCONFLICTQ,
    X86_INS_VPERM2F128,
    X86_INS_VPERM2I128,
    X86_INS_VPERMD,
    X86_INS_VPERMI2D,
    X86_INS_VPERMI2PD,
    X86_INS_VPERMI2PS,
    X86_INS_VPERMI2Q,
    X86_INS_VPERMIL2PD,
    X86_INS_VPERMIL2PS,
    X86_INS_VPERMILPD,
    X86_INS_VPERMILPS,
    X86_INS_VPERMPD,
    X86_INS_VPERMPS,
    X86_INS_VPERMQ,
    X86_INS_VPERMT2D,
    X86_INS_VPERMT2PD,
    X86_INS_VPERMT2PS,
    X86_INS_VPERMT2Q,
    X86_INS_VPEXPANDD,
    X86_INS_VPEXPANDQ,
    X86_INS_VPEXTRB,
    X86_INS_VPEXTRD,
    X86_INS_VPEXTRQ,
    X86_INS_VPEXTRW,
    X86_INS_VPGATHERDD,
    X86_INS_VPGATHERDQ,
    X86_INS_VPGATHERQD,
    X86_INS_VPGATHERQQ,
    X86_INS_VPHADDBD,
    X86_INS_VPHADDBQ,
    X86_INS_VPHADDBW,
    X86_INS_VPHADDDQ,
    X86_INS_VPHADDD,
    X86_INS_VPHADDSW,
    X86_INS_VPHADDUBD,
    X86_INS_VPHADDUBQ,
    X86_INS_VPHADDUBW,
    X86_INS_VPHADDUDQ,
    X86_INS_VPHADDUWD,
    X86_INS_VPHADDUWQ,
    X86_INS_VPHADDWD,
    X86_INS_VPHADDWQ,
    X86_INS_VPHADDW,
    X86_INS_VPHMINPOSUW,
    X86_INS_VPHSUBBW,
    X86_INS_VPHSUBDQ,
    X86_INS_VPHSUBD,
    X86_INS_VPHSUBSW,
    X86_INS_VPHSUBWD,
    X86_INS_VPHSUBW,
    X86_INS_VPINSRB,
    X86_INS_VPINSRD,
    X86_INS_VPINSRQ,
    X86_INS_VPINSRW,
    X86_INS_VPLZCNTD,
    X86_INS_VPLZCNTQ,
    X86_INS_VPMACSDD,
    X86_INS_VPMACSDQH,
    X86_INS_VPMACSDQL,
    X86_INS_VPMACSSDD,
    X86_INS_VPMACSSDQH,
    X86_INS_VPMACSSDQL,
    X86_INS_VPMACSSWD,
    X86_INS_VPMACSSWW,
    X86_INS_VPMACSWD,
    X86_INS_VPMACSWW,
    X86_INS_VPMADCSSWD,
    X86_INS_VPMADCSWD,
    X86_INS_VPMADDUBSW,
    X86_INS_VPMADDWD,
    X86_INS_VPMASKMOVD,
    X86_INS_VPMASKMOVQ,
    X86_INS_VPMAXSB,
    X86_INS_VPMAXSD,
    X86_INS_VPMAXSQ,
    X86_INS_VPMAXSW,
    X86_INS_VPMAXUB,
    X86_INS_VPMAXUD,
    X86_INS_VPMAXUQ,
    X86_INS_VPMAXUW,
    X86_INS_VPMINSB,
    X86_INS_VPMINSD,
    X86_INS_VPMINSQ,
    X86_INS_VPMINSW,
    X86_INS_VPMINUB,
    X86_INS_VPMINUD,
    X86_INS_VPMINUQ,
    X86_INS_VPMINUW,
    X86_INS_VPMOVDB,
    X86_INS_VPMOVDW,
    X86_INS_VPMOVM2B,
    X86_INS_VPMOVM2D,
    X86_INS_VPMOVM2Q,
    X86_INS_VPMOVM2W,
    X86_INS_VPMOVMSKB,
    X86_INS_VPMOVQB,
    X86_INS_VPMOVQD,
    X86_INS_VPMOVQW,
    X86_INS_VPMOVSDB,
    X86_INS_VPMOVSDW,
    X86_INS_VPMOVSQB,
    X86_INS_VPMOVSQD,
    X86_INS_VPMOVSQW,
    X86_INS_VPMOVSXBD,
    X86_INS_VPMOVSXBQ,
    X86_INS_VPMOVSXBW,
    X86_INS_VPMOVSXDQ,
    X86_INS_VPMOVSXWD,
    X86_INS_VPMOVSXWQ,
    X86_INS_VPMOVUSDB,
    X86_INS_VPMOVUSDW,
    X86_INS_VPMOVUSQB,
    X86_INS_VPMOVUSQD,
    X86_INS_VPMOVUSQW,
    X86_INS_VPMOVZXBD,
    X86_INS_VPMOVZXBQ,
    X86_INS_VPMOVZXBW,
    X86_INS_VPMOVZXDQ,
    X86_INS_VPMOVZXWD,
    X86_INS_VPMOVZXWQ,
    X86_INS_VPMULDQ,
    X86_INS_VPMULHRSW,
    X86_INS_VPMULHUW,
    X86_INS_VPMULHW,
    X86_INS_VPMULLD,
    X86_INS_VPMULLQ,
    X86_INS_VPMULLW,
    X86_INS_VPMULUDQ,
    X86_INS_VPORD,
    X86_INS_VPORQ,
    X86_INS_VPOR,
    X86_INS_VPPERM,
    X86_INS_VPROTB,
    X86_INS_VPROTD,
    X86_INS_VPROTQ,
    X86_INS_VPROTW,
    X86_INS_VPSADBW,
    X86_INS_VPSCATTERDD,
    X86_INS_VPSCATTERDQ,
    X86_INS_VPSCATTERQD,
    X86_INS_VPSCATTERQQ,
    X86_INS_VPSHAB,
    X86_INS_VPSHAD,
    X86_INS_VPSHAQ,
    X86_INS_VPSHAW,
    X86_INS_VPSHLB,
    X86_INS_VPSHLD,
    X86_INS_VPSHLQ,
    X86_INS_VPSHLW,
    X86_INS_VPSHUFB,
    X86_INS_VPSHUFD,
    X86_INS_VPSHUFHW,
    X86_INS_VPSHUFLW,
    X86_INS_VPSIGNB,
    X86_INS_VPSIGND,
    X86_INS_VPSIGNW,
    X86_INS_VPSLLDQ,
    X86_INS_VPSLLD,
    X86_INS_VPSLLQ,
    X86_INS_VPSLLVD,
    X86_INS_VPSLLVQ,
    X86_INS_VPSLLW,
    X86_INS_VPSRAD,
    X86_INS_VPSRAQ,
    X86_INS_VPSRAVD,
    X86_INS_VPSRAVQ,
    X86_INS_VPSRAW,
    X86_INS_VPSRLDQ,
    X86_INS_VPSRLD,
    X86_INS_VPSRLQ,
    X86_INS_VPSRLVD,
    X86_INS_VPSRLVQ,
    X86_INS_VPSRLW,
    X86_INS_VPSUBB,
    X86_INS_VPSUBD,
    X86_INS_VPSUBQ,
    X86_INS_VPSUBSB,
    X86_INS_VPSUBSW,
    X86_INS_VPSUBUSB,
    X86_INS_VPSUBUSW,
    X86_INS_VPSUBW,
    X86_INS_VPTESTMD,
    X86_INS_VPTESTMQ,
    X86_INS_VPTESTNMD,
    X86_INS_VPTESTNMQ,
    X86_INS_VPTEST,
    X86_INS_VPUNPCKHBW,
    X86_INS_VPUNPCKHDQ,
    X86_INS_VPUNPCKHQDQ,
    X86_INS_VPUNPCKHWD,
    X86_INS_VPUNPCKLBW,
    X86_INS_VPUNPCKLDQ,
    X86_INS_VPUNPCKLQDQ,
    X86_INS_VPUNPCKLWD,
    X86_INS_VPXORD,
    X86_INS_VPXORQ,
    X86_INS_VPXOR,
    X86_INS_VRCP14PD,
    X86_INS_VRCP14PS,
    X86_INS_VRCP14SD,
    X86_INS_VRCP14SS,
    X86_INS_VRCP28PD,
    X86_INS_VRCP28PS,
    X86_INS_VRCP28SD,
    X86_INS_VRCP28SS,
    X86_INS_VRCPPS,
    X86_INS_VRCPSS,
    X86_INS_VRNDSCALEPD,
    X86_INS_VRNDSCALEPS,
    X86_INS_VRNDSCALESD,
    X86_INS_VRNDSCALESS,
    X86_INS_VROUNDPD,
    X86_INS_VROUNDPS,
    X86_INS_VROUNDSD,
    X86_INS_VROUNDSS,
    X86_INS_VRSQRT14PD,
    X86_INS_VRSQRT14PS,
    X86_INS_VRSQRT14SD,
    X86_INS_VRSQRT14SS,
    X86_INS_VRSQRT28PD,
    X86_INS_VRSQRT28PS,
    X86_INS_VRSQRT28SD,
    X86_INS_VRSQRT28SS,
    X86_INS_VRSQRTPS,
    X86_INS_VRSQRTSS,
    X86_INS_VSCATTERDPD,
    X86_INS_VSCATTERDPS,
    X86_INS_VSCATTERPF0DPD,
    X86_INS_VSCATTERPF0DPS,
    X86_INS_VSCATTERPF0QPD,
    X86_INS_VSCATTERPF0QPS,
    X86_INS_VSCATTERPF1DPD,
    X86_INS_VSCATTERPF1DPS,
    X86_INS_VSCATTERPF1QPD,
    X86_INS_VSCATTERPF1QPS,
    X86_INS_VSCATTERQPD,
    X86_INS_VSCATTERQPS,
    X86_INS_VSHUFPD,
    X86_INS_VSHUFPS,
    X86_INS_VSQRTPD,
    X86_INS_VSQRTPS,
    X86_INS_VSQRTSD,
    X86_INS_VSQRTSS,
    X86_INS_VSTMXCSR,
    X86_INS_VSUBPD,
    X86_INS_VSUBPS,
    X86_INS_VSUBSD,
    X86_INS_VSUBSS,
    X86_INS_VTESTPD,
    X86_INS_VTESTPS,
    X86_INS_VUNPCKHPD,
    X86_INS_VUNPCKHPS,
    X86_INS_VUNPCKLPD,
    X86_INS_VUNPCKLPS,
    X86_INS_VZEROALL,
    X86_INS_VZEROUPPER,
    X86_INS_WAIT,
    X86_INS_WBINVD,
    X86_INS_WRFSBASE,
    X86_INS_WRGSBASE,
    X86_INS_WRMSR,
    X86_INS_XABORT,
    X86_INS_XACQUIRE,
    X86_INS_XBEGIN,
    X86_INS_XCHG,
    X86_INS_XCRYPTCBC,
    X86_INS_XCRYPTCFB,
    X86_INS_XCRYPTCTR,
    X86_INS_XCRYPTECB,
    X86_INS_XCRYPTOFB,
    X86_INS_XEND,
    X86_INS_XGETBV,
    X86_INS_XLATB,
    X86_INS_XRELEASE,
    X86_INS_XRSTOR,
    X86_INS_XRSTOR64,
    X86_INS_XRSTORS,
    X86_INS_XRSTORS64,
    X86_INS_XSAVE,
    X86_INS_XSAVE64,
    X86_INS_XSAVEC,
    X86_INS_XSAVEC64,
    X86_INS_XSAVEOPT,
    X86_INS_XSAVEOPT64,
    X86_INS_XSAVES,
    X86_INS_XSAVES64,
    X86_INS_XSETBV,
    X86_INS_XSHA1,
    X86_INS_XSHA256,
    X86_INS_XSTORE,
    X86_INS_XTEST,
    X86_INS_FDISI8087_NOP,
    X86_INS_FENI8087_NOP,

    // pseudo instructions
    X86_INS_CMPSS,
    X86_INS_CMPEQSS,
    X86_INS_CMPLTSS,
    X86_INS_CMPLESS,
    X86_INS_CMPUNORDSS,
    X86_INS_CMPNEQSS,
    X86_INS_CMPNLTSS,
    X86_INS_CMPNLESS,
    X86_INS_CMPORDSS,

    X86_INS_CMPSD,
    X86_INS_CMPEQSD,
    X86_INS_CMPLTSD,
    X86_INS_CMPLESD,
    X86_INS_CMPUNORDSD,
    X86_INS_CMPNEQSD,
    X86_INS_CMPNLTSD,
    X86_INS_CMPNLESD,
    X86_INS_CMPORDSD,

    X86_INS_CMPPS,
    X86_INS_CMPEQPS,
    X86_INS_CMPLTPS,
    X86_INS_CMPLEPS,
    X86_INS_CMPUNORDPS,
    X86_INS_CMPNEQPS,
    X86_INS_CMPNLTPS,
    X86_INS_CMPNLEPS,
    X86_INS_CMPORDPS,

    X86_INS_CMPPD,
    X86_INS_CMPEQPD,
    X86_INS_CMPLTPD,
    X86_INS_CMPLEPD,
    X86_INS_CMPUNORDPD,
    X86_INS_CMPNEQPD,
    X86_INS_CMPNLTPD,
    X86_INS_CMPNLEPD,
    X86_INS_CMPORDPD,

    X86_INS_VCMPSS,
    X86_INS_VCMPEQSS,
    X86_INS_VCMPLTSS,
    X86_INS_VCMPLESS,
    X86_INS_VCMPUNORDSS,
    X86_INS_VCMPNEQSS,
    X86_INS_VCMPNLTSS,
    X86_INS_VCMPNLESS,
    X86_INS_VCMPORDSS,
    X86_INS_VCMPEQ_UQSS,
    X86_INS_VCMPNGESS,
    X86_INS_VCMPNGTSS,
    X86_INS_VCMPFALSESS,
    X86_INS_VCMPNEQ_OQSS,
    X86_INS_VCMPGESS,
    X86_INS_VCMPGTSS,
    X86_INS_VCMPTRUESS,
    X86_INS_VCMPEQ_OSSS,
    X86_INS_VCMPLT_OQSS,
    X86_INS_VCMPLE_OQSS,
    X86_INS_VCMPUNORD_SSS,
    X86_INS_VCMPNEQ_USSS,
    X86_INS_VCMPNLT_UQSS,
    X86_INS_VCMPNLE_UQSS,
    X86_INS_VCMPORD_SSS,
    X86_INS_VCMPEQ_USSS,
    X86_INS_VCMPNGE_UQSS,
    X86_INS_VCMPNGT_UQSS,
    X86_INS_VCMPFALSE_OSSS,
    X86_INS_VCMPNEQ_OSSS,
    X86_INS_VCMPGE_OQSS,
    X86_INS_VCMPGT_OQSS,
    X86_INS_VCMPTRUE_USSS,

    X86_INS_VCMPSD,
    X86_INS_VCMPEQSD,
    X86_INS_VCMPLTSD,
    X86_INS_VCMPLESD,
    X86_INS_VCMPUNORDSD,
    X86_INS_VCMPNEQSD,
    X86_INS_VCMPNLTSD,
    X86_INS_VCMPNLESD,
    X86_INS_VCMPORDSD,
    X86_INS_VCMPEQ_UQSD,
    X86_INS_VCMPNGESD,
    X86_INS_VCMPNGTSD,
    X86_INS_VCMPFALSESD,
    X86_INS_VCMPNEQ_OQSD,
    X86_INS_VCMPGESD,
    X86_INS_VCMPGTSD,
    X86_INS_VCMPTRUESD,
    X86_INS_VCMPEQ_OSSD,
    X86_INS_VCMPLT_OQSD,
    X86_INS_VCMPLE_OQSD,
    X86_INS_VCMPUNORD_SSD,
    X86_INS_VCMPNEQ_USSD,
    X86_INS_VCMPNLT_UQSD,
    X86_INS_VCMPNLE_UQSD,
    X86_INS_VCMPORD_SSD,
    X86_INS_VCMPEQ_USSD,
    X86_INS_VCMPNGE_UQSD,
    X86_INS_VCMPNGT_UQSD,
    X86_INS_VCMPFALSE_OSSD,
    X86_INS_VCMPNEQ_OSSD,
    X86_INS_VCMPGE_OQSD,
    X86_INS_VCMPGT_OQSD,
    X86_INS_VCMPTRUE_USSD,

    X86_INS_VCMPPS,
    X86_INS_VCMPEQPS,
    X86_INS_VCMPLTPS,
    X86_INS_VCMPLEPS,
    X86_INS_VCMPUNORDPS,
    X86_INS_VCMPNEQPS,
    X86_INS_VCMPNLTPS,
    X86_INS_VCMPNLEPS,
    X86_INS_VCMPORDPS,
    X86_INS_VCMPEQ_UQPS,
    X86_INS_VCMPNGEPS,
    X86_INS_VCMPNGTPS,
    X86_INS_VCMPFALSEPS,
    X86_INS_VCMPNEQ_OQPS,
    X86_INS_VCMPGEPS,
    X86_INS_VCMPGTPS,
    X86_INS_VCMPTRUEPS,
    X86_INS_VCMPEQ_OSPS,
    X86_INS_VCMPLT_OQPS,
    X86_INS_VCMPLE_OQPS,
    X86_INS_VCMPUNORD_SPS,
    X86_INS_VCMPNEQ_USPS,
    X86_INS_VCMPNLT_UQPS,
    X86_INS_VCMPNLE_UQPS,
    X86_INS_VCMPORD_SPS,
    X86_INS_VCMPEQ_USPS,
    X86_INS_VCMPNGE_UQPS,
    X86_INS_VCMPNGT_UQPS,
    X86_INS_VCMPFALSE_OSPS,
    X86_INS_VCMPNEQ_OSPS,
    X86_INS_VCMPGE_OQPS,
    X86_INS_VCMPGT_OQPS,
    X86_INS_VCMPTRUE_USPS,

    X86_INS_VCMPPD,
    X86_INS_VCMPEQPD,
    X86_INS_VCMPLTPD,
    X86_INS_VCMPLEPD,
    X86_INS_VCMPUNORDPD,
    X86_INS_VCMPNEQPD,
    X86_INS_VCMPNLTPD,
    X86_INS_VCMPNLEPD,
    X86_INS_VCMPORDPD,
    X86_INS_VCMPEQ_UQPD,
    X86_INS_VCMPNGEPD,
    X86_INS_VCMPNGTPD,
    X86_INS_VCMPFALSEPD,
    X86_INS_VCMPNEQ_OQPD,
    X86_INS_VCMPGEPD,
    X86_INS_VCMPGTPD,
    X86_INS_VCMPTRUEPD,
    X86_INS_VCMPEQ_OSPD,
    X86_INS_VCMPLT_OQPD,
    X86_INS_VCMPLE_OQPD,
    X86_INS_VCMPUNORD_SPD,
    X86_INS_VCMPNEQ_USPD,
    X86_INS_VCMPNLT_UQPD,
    X86_INS_VCMPNLE_UQPD,
    X86_INS_VCMPORD_SPD,
    X86_INS_VCMPEQ_USPD,
    X86_INS_VCMPNGE_UQPD,
    X86_INS_VCMPNGT_UQPD,
    X86_INS_VCMPFALSE_OSPD,
    X86_INS_VCMPNEQ_OSPD,
    X86_INS_VCMPGE_OQPD,
    X86_INS_VCMPGT_OQPD,
    X86_INS_VCMPTRUE_USPD,

    X86_INS_ENDING, // mark the end of the list of insn
} x86_insn;

//> Group of X86 instructions
typedef enum  x86_insn_group
{
    X86_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    X86_GRP_JUMP,   // = CS_GRP_JUMP
    // all call instructions
    X86_GRP_CALL,   // = CS_GRP_CALL
    // all return instructions
    X86_GRP_RET,    // = CS_GRP_RET
    // all interrupt instructions (int+syscall)
    X86_GRP_INT,    // = CS_GRP_INT
    // all interrupt return instructions
    X86_GRP_IRET,   // = CS_GRP_IRET
    // all privileged instructions
    X86_GRP_PRIVILEGE,  // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    X86_GRP_VM = 128,   // all virtualization instructions (VT-x + AMD-V)
    X86_GRP_3DNOW,
    X86_GRP_AES,
    X86_GRP_ADX,
    X86_GRP_AVX,
    X86_GRP_AVX2,
    X86_GRP_AVX512,
    X86_GRP_BMI,
    X86_GRP_BMI2,
    X86_GRP_CMOV,
    X86_GRP_F16C,
    X86_GRP_FMA,
    X86_GRP_FMA4,
    X86_GRP_FSGSBASE,
    X86_GRP_HLE,
    X86_GRP_MMX,
    X86_GRP_MODE32,
    X86_GRP_MODE64,
    X86_GRP_RTM,
    X86_GRP_SHA,
    X86_GRP_SSE1,
    X86_GRP_SSE2,
    X86_GRP_SSE3,
    X86_GRP_SSE41,
    X86_GRP_SSE42,
    X86_GRP_SSE4A,
    X86_GRP_SSSE3,
    X86_GRP_PCLMUL,
    X86_GRP_XOP,
    X86_GRP_CDI,
    X86_GRP_ERI,
    X86_GRP_TBM,
    X86_GRP_16BITMODE,
    X86_GRP_NOT64BITMODE,
    X86_GRP_SGX,
    X86_GRP_DQI,
    X86_GRP_BWI,
    X86_GRP_PFI,
    X86_GRP_VLX,
    X86_GRP_SMAP,
    X86_GRP_NOVLX,

    X86_GRP_ENDING
} x86_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/capstone/xcore.h
================================================
#ifndef CAPSTONE_XCORE_H
#define CAPSTONE_XCORE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum xcore_op_type
{
    XCORE_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    XCORE_OP_REG, // = CS_OP_REG (Register operand).
    XCORE_OP_IMM, // = CS_OP_IMM (Immediate operand).
    XCORE_OP_MEM, // = CS_OP_MEM (Memory operand).
} xcore_op_type;

//> XCore registers
typedef enum xcore_reg
{
    XCORE_REG_INVALID = 0,

    XCORE_REG_CP,
    XCORE_REG_DP,
    XCORE_REG_LR,
    XCORE_REG_SP,
    XCORE_REG_R0,
    XCORE_REG_R1,
    XCORE_REG_R2,
    XCORE_REG_R3,
    XCORE_REG_R4,
    XCORE_REG_R5,
    XCORE_REG_R6,
    XCORE_REG_R7,
    XCORE_REG_R8,
    XCORE_REG_R9,
    XCORE_REG_R10,
    XCORE_REG_R11,

    //> pseudo registers
    XCORE_REG_PC,   // pc

    // internal thread registers
    // see The-XMOS-XS1-Architecture(X7879A).pdf
    XCORE_REG_SCP,  // save pc
    XCORE_REG_SSR,  // save status
    XCORE_REG_ET,   // exception type
    XCORE_REG_ED,   // exception data
    XCORE_REG_SED,  // save exception data
    XCORE_REG_KEP,  // kernel entry pointer
    XCORE_REG_KSP,  // kernel stack pointer
    XCORE_REG_ID,   // thread ID

    XCORE_REG_ENDING,   // <-- mark the end of the list of registers
} xcore_reg;

// Instruction's operand referring to memory
// This is associated with XCORE_OP_MEM operand type above
typedef struct xcore_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `xcore_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    int32_t disp;   // displacement/offset value
    int     direct; // +1: forward, -1: backward
} xcore_op_mem;

// Instruction operand
typedef struct cs_xcore_op
{
    xcore_op_type type; // operand type
    union
    {
        xcore_reg reg;  // register value for REG operand
        int32_t imm;        // immediate value for IMM operand
        xcore_op_mem mem;       // base/disp value for MEM operand
    };
} cs_xcore_op;

// Instruction structure
typedef struct cs_xcore
{
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_xcore_op operands[8]; // operands for this instruction.
} cs_xcore;

//> XCore instruction
typedef enum xcore_insn
{
    XCORE_INS_INVALID = 0,

    XCORE_INS_ADD,
    XCORE_INS_ANDNOT,
    XCORE_INS_AND,
    XCORE_INS_ASHR,
    XCORE_INS_BAU,
    XCORE_INS_BITREV,
    XCORE_INS_BLA,
    XCORE_INS_BLAT,
    XCORE_INS_BL,
    XCORE_INS_BF,
    XCORE_INS_BT,
    XCORE_INS_BU,
    XCORE_INS_BRU,
    XCORE_INS_BYTEREV,
    XCORE_INS_CHKCT,
    XCORE_INS_CLRE,
    XCORE_INS_CLRPT,
    XCORE_INS_CLRSR,
    XCORE_INS_CLZ,
    XCORE_INS_CRC8,
    XCORE_INS_CRC32,
    XCORE_INS_DCALL,
    XCORE_INS_DENTSP,
    XCORE_INS_DGETREG,
    XCORE_INS_DIVS,
    XCORE_INS_DIVU,
    XCORE_INS_DRESTSP,
    XCORE_INS_DRET,
    XCORE_INS_ECALLF,
    XCORE_INS_ECALLT,
    XCORE_INS_EDU,
    XCORE_INS_EEF,
    XCORE_INS_EET,
    XCORE_INS_EEU,
    XCORE_INS_ENDIN,
    XCORE_INS_ENTSP,
    XCORE_INS_EQ,
    XCORE_INS_EXTDP,
    XCORE_INS_EXTSP,
    XCORE_INS_FREER,
    XCORE_INS_FREET,
    XCORE_INS_GETD,
    XCORE_INS_GET,
    XCORE_INS_GETN,
    XCORE_INS_GETR,
    XCORE_INS_GETSR,
    XCORE_INS_GETST,
    XCORE_INS_GETTS,
    XCORE_INS_INCT,
    XCORE_INS_INIT,
    XCORE_INS_INPW,
    XCORE_INS_INSHR,
    XCORE_INS_INT,
    XCORE_INS_IN,
    XCORE_INS_KCALL,
    XCORE_INS_KENTSP,
    XCORE_INS_KRESTSP,
    XCORE_INS_KRET,
    XCORE_INS_LADD,
    XCORE_INS_LD16S,
    XCORE_INS_LD8U,
    XCORE_INS_LDA16,
    XCORE_INS_LDAP,
    XCORE_INS_LDAW,
    XCORE_INS_LDC,
    XCORE_INS_LDW,
    XCORE_INS_LDIVU,
    XCORE_INS_LMUL,
    XCORE_INS_LSS,
    XCORE_INS_LSUB,
    XCORE_INS_LSU,
    XCORE_INS_MACCS,
    XCORE_INS_MACCU,
    XCORE_INS_MJOIN,
    XCORE_INS_MKMSK,
    XCORE_INS_MSYNC,
    XCORE_INS_MUL,
    XCORE_INS_NEG,
    XCORE_INS_NOT,
    XCORE_INS_OR,
    XCORE_INS_OUTCT,
    XCORE_INS_OUTPW,
    XCORE_INS_OUTSHR,
    XCORE_INS_OUTT,
    XCORE_INS_OUT,
    XCORE_INS_PEEK,
    XCORE_INS_REMS,
    XCORE_INS_REMU,
    XCORE_INS_RETSP,
    XCORE_INS_SETCLK,
    XCORE_INS_SET,
    XCORE_INS_SETC,
    XCORE_INS_SETD,
    XCORE_INS_SETEV,
    XCORE_INS_SETN,
    XCORE_INS_SETPSC,
    XCORE_INS_SETPT,
    XCORE_INS_SETRDY,
    XCORE_INS_SETSR,
    XCORE_INS_SETTW,
    XCORE_INS_SETV,
    XCORE_INS_SEXT,
    XCORE_INS_SHL,
    XCORE_INS_SHR,
    XCORE_INS_SSYNC,
    XCORE_INS_ST16,
    XCORE_INS_ST8,
    XCORE_INS_STW,
    XCORE_INS_SUB,
    XCORE_INS_SYNCR,
    XCORE_INS_TESTCT,
    XCORE_INS_TESTLCL,
    XCORE_INS_TESTWCT,
    XCORE_INS_TSETMR,
    XCORE_INS_START,
    XCORE_INS_WAITEF,
    XCORE_INS_WAITET,
    XCORE_INS_WAITEU,
    XCORE_INS_XOR,
    XCORE_INS_ZEXT,

    XCORE_INS_ENDING,   // <-- mark the end of the list of instructions
} xcore_insn;

//> Group of XCore instructions
typedef enum xcore_insn_group
{
    XCORE_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    XCORE_GRP_JUMP, // = CS_GRP_JUMP

    XCORE_GRP_ENDING,   // <-- mark the end of the list of groups
} xcore_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/dbghelp/dbghelp.h
================================================
#ifndef _DBGHELP_
#define _DBGHELP_


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif

#pragma pack(push,8)

// For those without specstrings.h
// Since there are different versions of this header, I need to
// individually test each item and define it if it is not around.

#ifndef __in
#define __in
#endif
#ifndef __out
#define __out
#endif
#ifndef __inout
#define __inout
#endif
#ifndef __in_opt
#define __in_opt
#endif
#ifndef __out_opt
#define __out_opt
#endif
#ifndef __inout_opt
#define __inout_opt
#endif
#ifndef __in_ecount
#define __in_ecount(x)
#endif
#ifndef __out_ecount
#define __out_ecount(x)
#endif
#ifndef __inout_ecount
#define __inout_ecount(x)
#endif
#ifndef __in_bcount
#define __in_bcount(x)
#endif
#ifndef __out_bcount
#define __out_bcount(x)
#endif
#ifndef __inout_bcount
#define __inout_bcount(x)
#endif
#ifndef __out_xcount
#define __out_xcount(x)
#endif
#ifndef __deref_opt_out
#define __deref_opt_out
#endif
#ifndef __deref_out
#define __deref_out
#endif
#ifndef __out_ecount_opt
#define __out_ecount_opt(x)
#endif
#ifndef __in_bcount_opt
#define __in_bcount_opt(x)
#endif
#ifndef __out_bcount_opt
#define __out_bcount_opt(x)
#endif
#ifndef __deref_out_opt
#define __deref_out_opt
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DBHLP_DEPRECIATED   __declspec(deprecated)
#else
#define DBHLP_DEPRECIATED
#endif
#endif

#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

// Observant readers may notice that 2 new fields,
// 'fReadOnly' and 'Version' have been added to
// the LOADED_IMAGE structure after 'fDOSImage'.
// This does not change the size of the structure
// from previous headers.  That is because while
// 'fDOSImage' is a byte, it is padded by the
// compiler to 4 bytes.  So the 2 new fields are
// slipped into the extra space.

typedef struct _LOADED_IMAGE
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

#define MAX_SYM_NAME            2000


// Error codes set by dbghelp functions.  Call GetLastError
// to see them.
// Dbghelp also sets error codes found in winerror.h

#define ERROR_IMAGE_NOT_STRIPPED    0x8800  // the image is not stripped.  No dbg file available.
#define ERROR_NO_DBG_POINTER        0x8801  // image is stripped but there is no pointer to a dbg file
#define ERROR_NO_PDB_POINTER        0x8802  // image does not point to a pdb file

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFile(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in PVOID  CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFileW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFile(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath
);

HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR  DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFileExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACK)(
    __in PCSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPath(
    __in HANDLE hprocess,
    __in_opt PCSTR SearchPath,
    __in PCSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACK callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACKW)(
    __in PCWSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPathW(
    __in HANDLE hprocess,
    __in_opt PCWSTR SearchPath,
    __in PCWSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PWSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACKW callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImage(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACK Callback,
    __in PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImageW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImage(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath
);

HANDLE
IMAGEAPI
FindExecutableImageEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImageExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader(
    __in PVOID Base
);

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size,
    __out_opt PIMAGE_SECTION_HEADER* FoundHeader
);

PVOID
IMAGEAPI
ImageDirectoryEntryToData(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size
);

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva
);

PVOID
IMAGEAPI
ImageRvaToVa(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva,
    __in_opt OUT PIMAGE_SECTION_HEADER* LastRvaSection
);

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION
{
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    __in_opt HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PCSTR SymbolPath,
    __in ULONG ImageBase
);

BOOL
IMAGEAPI
UnmapDebugInformation(
    __out_xcount(unknown) PIMAGE_DEBUG_INFORMATION DebugInfo
);

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PSTR OutputPathBuffer
);

BOOL
IMAGEAPI
SearchTreeForFileW(
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PWSTR OutputPathBuffer
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACK)(
    __in PCSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTree(
    __in_opt HANDLE hProcess,
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACK cb,
    __in_opt PVOID data
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACKW)(
    __in PCWSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTreeW(
    __in_opt HANDLE hProcess,
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PWSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACKW cb,
    __in_opt PVOID data
);

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    __in PCSTR DirPath
);

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
//  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    __in PCSTR name,
    __out_ecount(maxStringLength) PSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolNameW(
    __in PCWSTR name,
    __out_ecount(maxStringLength) PWSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1
#define DBHHEADER_CVMISC        0x2
#define DBHHEADER_PDBGUID       0x3
typedef struct _MODLOAD_DATA
{
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

typedef struct _MODLOAD_CVMISC
{
    DWORD   oCV;                    // ofset to the codeview record
    size_t  cCV;                    // size of the codeview record
    DWORD   oMisc;                  // offset to the misc record
    size_t  cMisc;                  // size of the misc record
    DWORD   dtImage;                // datetime stamp of the image
    DWORD   cImage;                 // size of the image
} MODLOAD_CVMISC, *PMODLOAD_CVMISC;

typedef struct _MODLOAD_PDBGUID_PDBAGE
{
    GUID    PdbGuid;                // Pdb Guid
    DWORD   PdbAge;                 // Pdb Age
} MODLOAD_PDBGUID_PDBAGE, *PMODLOAD_PDBGUID_PDBAGE;

//
// StackWalking API
//

typedef enum
{
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64
{
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS
{
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    __in LPADDRESS a32,
    __out LPADDRESS64 a64
)
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    __in LPADDRESS64 a64,
    __out LPADDRESS a32
)
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD64   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD64   StackBase;
    DWORD64   StackLimit;

    DWORD64   Reserved[5];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD   StackBase;
    DWORD   StackLimit;

    DWORD   Reserved[5];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    __in PKDHELP p32,
    __out PKDHELP64 p64
)
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
    p64->KiUserExceptionDispatcher = p32->KiUserExceptionDispatcher;
    p64->StackBase = p32->StackBase;
    p64->StackLimit = p32->StackLimit;
}
#endif

typedef struct _tagSTACKFRAME64
{
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME
{
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 qwBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out LPDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    __in HANDLE ahProcess,
    __in DWORD64 AddrBase
);

typedef
DWORD64
(__stdcall* PGET_MODULE_BASE_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 Address
);

typedef
DWORD64
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE64)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __in LPADDRESS64 lpaddr
);

BOOL
IMAGEAPI
StackWalk64(
    __in DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME64 StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD lpBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out PDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);

typedef
DWORD
(__stdcall* PGET_MODULE_BASE_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD Address
);

typedef
DWORD
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __out LPADDRESS lpaddr
);

BOOL
IMAGEAPI
StackWalk(
    DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE TranslateAddress
);

#endif


#define API_VERSION_NUMBER 11

typedef struct API_VERSION
{
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
);

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    __in LPAPI_VERSION AppVersion
);

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    __in HMODULE Module
);

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64)(
    __in PCSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64W)(
    __in PCWSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt ULONG64 CallbackData,
    __in_opt ULONG64 UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK)(
    __in HANDLE hProcess,
    __in DWORD AddrBase,
    __in_opt PVOID UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG64 AddrBase,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK)(
    __in PCSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACKW)(
    __in PCWSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt PVOID CallbackData,
    __in_opt PVOID UserContext
);

#endif


// values found in SYMBOL_INFO.Tag
//
// This was taken from cvconst.h and should
// not override any values found there.
//
// #define _NO_CVCONST_H_ if you don't
// have access to that file...

#ifdef _NO_CVCONST_H

// DIA enums

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

#endif

//
// flags found in SYMBOL_INFO.Flags
//

#define SYMFLAG_VALUEPRESENT     0x00000001
#define SYMFLAG_REGISTER         0x00000008
#define SYMFLAG_REGREL           0x00000010
#define SYMFLAG_FRAMEREL         0x00000020
#define SYMFLAG_PARAMETER        0x00000040
#define SYMFLAG_LOCAL            0x00000080
#define SYMFLAG_CONSTANT         0x00000100
#define SYMFLAG_EXPORT           0x00000200
#define SYMFLAG_FORWARDER        0x00000400
#define SYMFLAG_FUNCTION         0x00000800
#define SYMFLAG_VIRTUAL          0x00001000
#define SYMFLAG_THUNK            0x00002000
#define SYMFLAG_TLSREL           0x00004000
#define SYMFLAG_SLOT             0x00008000
#define SYMFLAG_ILREL            0x00010000
#define SYMFLAG_METADATA         0x00020000
#define SYMFLAG_CLR_TOKEN        0x00040000

// this resets SymNext/Prev to the beginning
// of the module passed in the address field

#define SYMFLAG_RESET            0x80000000

//
// symbol type enumeration
//
typedef enum
{
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    SymVirtual,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR    Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

typedef struct _IMAGEHLP_SYMBOL64_PACKAGE
{
    IMAGEHLP_SYMBOL64 sym;
    CHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL64_PACKAGE, *PIMAGEHLP_SYMBOL64_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR   Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW64, *PIMAGEHLP_SYMBOLW64;

typedef struct _IMAGEHLP_SYMBOLW64_PACKAGE
{
    IMAGEHLP_SYMBOLW64 sym;
    WCHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW64_PACKAGE, *PIMAGEHLP_SYMBOLW64_PACKAGE;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#define IMAGEHLP_SYMBOL_PACKAGE IMAGEHLP_SYMBOL64_PACKAGE
#define PIMAGEHLP_SYMBOL_PACKAGE PIMAGEHLP_SYMBOL64_PACKAGE
#define IMAGEHLP_SYMBOLW IMAGEHLP_SYMBOLW64
#define PIMAGEHLP_SYMBOLW PIMAGEHLP_SYMBOLW64
#define IMAGEHLP_SYMBOLW_PACKAGE IMAGEHLP_SYMBOLW64_PACKAGE
#define PIMAGEHLP_SYMBOLW_PACKAGE PIMAGEHLP_SYMBOLW64_PACKAGE

#else

typedef struct _IMAGEHLP_SYMBOL
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef struct _IMAGEHLP_SYMBOL_PACKAGE
{
    IMAGEHLP_SYMBOL sym;
    CHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL_PACKAGE, *PIMAGEHLP_SYMBOL_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR                       Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW, *PIMAGEHLP_SYMBOLW;

typedef struct _IMAGEHLP_SYMBOLW_PACKAGE
{
    IMAGEHLP_SYMBOLW sym;
    WCHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW_PACKAGE, *PIMAGEHLP_SYMBOLW_PACKAGE;

#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
    // new elements: 07-Jun-2002
    CHAR     LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    // new elements: 07-Jun-2002
    WCHAR    LoadedImageName[256];   // symbol file name
    WCHAR    LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    WCHAR        CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    WCHAR    LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

typedef struct _IMAGEHLP_LINEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PWSTR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW64, *PIMAGEHLP_LINEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD    Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;

typedef struct _IMAGEHLP_LINEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW, *PIMAGEHLP_LINEW;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE
{
    DWORD64  ModBase;                // base address of loaded module
    PCHAR    FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

typedef struct _SOURCEFILEW
{
    DWORD64  ModBase;                // base address of loaded module
    PWSTR    FileName;               // full filename of source
} SOURCEFILEW, *PSOURCEFILEW;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000
#define CBA_SRCSRV_INFO                         0x20000000
#define CBA_SRCSRV_EVENT                        0x40000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY
{
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD*    bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum
{
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

#define EVENT_SRCSPEW_START 100
#define EVENT_SRCSPEW       100
#define EVENT_SRCSPEW_END   199

typedef struct _IMAGEHLP_CBA_EVENT
{
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_CBA_EVENTW
{
    DWORD  severity;                                     // values from sevInfo to sevFatal
    DWORD  code;                                         // numerical code IDs the error
    PCWSTR desc;                                         // may contain a text description of the error
    PVOID  object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENTW, *PIMAGEHLP_CBA_EVENTW;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;                     //
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOADW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOADW64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    WCHAR    FileName[MAX_PATH + 1]; // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;         //
} IMAGEHLP_DEFERRED_SYMBOL_LOADW64, *PIMAGEHLP_DEFERRED_SYMBOL_LOADW64;

#define DSLFLAG_MISMATCHED_PDB  0x1
#define DSLFLAG_MISMATCHED_DBG  0x2

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64
{
    DWORD              SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD              NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64 Symbol;                 // array of duplicate symbols
    DWORD              SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL
{
    DWORD            SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD            NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL Symbol;                 // array of duplicate symbols
    DWORD            SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
IMAGEAPI
SymSetParentWindow(
    __in HWND hwnd
);

PCHAR
IMAGEAPI
SymSetHomeDirectory(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR dir
);

PWSTR
IMAGEAPI
SymSetHomeDirectoryW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR dir
);

PCHAR
IMAGEAPI
SymGetHomeDirectory(
    __in DWORD type,
    __out_ecount(size) PSTR dir,
    __in size_t size
);

PWSTR
IMAGEAPI
SymGetHomeDirectoryW(
    __in DWORD type,
    __out_ecount(size) PWSTR dir,
    __in size_t size
);

enum
{
    hdBase = 0, // root directory for dbghelp
    hdSym,      // where symbols are stored
    hdSrc,      // where source is stored
    hdMax       // end marker
};

typedef struct _OMAP
{
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

BOOL
IMAGEAPI
SymGetOmaps(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll,
    __out POMAP* OmapTo,
    __out PDWORD64 cOmapTo,
    __out POMAP* OmapFrom,
    __out PDWORD64 cOmapFrom
);

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE          0x00000001
#define SYMOPT_UNDNAME                   0x00000002
#define SYMOPT_DEFERRED_LOADS            0x00000004
#define SYMOPT_NO_CPP                    0x00000008
#define SYMOPT_LOAD_LINES                0x00000010
#define SYMOPT_OMAP_FIND_NEAREST         0x00000020
#define SYMOPT_LOAD_ANYTHING             0x00000040
#define SYMOPT_IGNORE_CVREC              0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS      0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS      0x00000200
#define SYMOPT_EXACT_SYMBOLS             0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS    0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH         0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES     0x00002000
#define SYMOPT_PUBLICS_ONLY              0x00004000
#define SYMOPT_NO_PUBLICS                0x00008000
#define SYMOPT_AUTO_PUBLICS              0x00010000
#define SYMOPT_NO_IMAGE_SEARCH           0x00020000
#define SYMOPT_SECURE                    0x00040000
#define SYMOPT_NO_PROMPTS                0x00080000
#define SYMOPT_OVERWRITE                 0x00100000
#define SYMOPT_IGNORE_IMAGEDIR           0x00200000
#define SYMOPT_FLAT_DIRECTORY            0x00400000
#define SYMOPT_FAVOR_COMPRESSED          0x00800000
#define SYMOPT_ALLOW_ZERO_ADDRESS        0x01000000
#define SYMOPT_DISABLE_SYMSRV_AUTODETECT 0x02000000

#define SYMOPT_DEBUG                     0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    __in DWORD   SymOptions
);

DWORD
IMAGEAPI
SymGetOptions(
    VOID
);

BOOL
IMAGEAPI
SymCleanup(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymMatchString(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringA(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringW(
    __in PCWSTR string,
    __in PCWSTR expression,
    __in BOOL fCase
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACK)(
    __in PSOURCEFILE pSourceFile,
    __in_opt PVOID UserContext
);

// for backwards compatibility - don't use this
#define PSYM_ENUMSOURCFILES_CALLBACK PSYM_ENUMSOURCEFILES_CALLBACK

BOOL
IMAGEAPI
SymEnumSourceFiles(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACKW)(
    __in PSOURCEFILEW pSourceFile,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceFilesW(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModules64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModulesW64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    __in_opt PVOID UserContext
);
#endif

BOOL
IMAGEAPI
EnumerateLoadedModulesEx(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesExW(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesW64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    __in HANDLE hProcess,
    __in DWORD64 AddrBase
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);
#endif

BOOL
IMAGEAPI
SymGetUnwindInfo(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_bcount_opt(*Size) PVOID Buffer,
    __inout PULONG Size
);

BOOL
IMAGEAPI
SymGetModuleInfo64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULE64 ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULEW64 ModuleInfo
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULE ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULEW ModuleInfo
);
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    __in HANDLE hProcess,
    __in DWORD dwAddr
);
#endif

typedef struct _SRCCODEINFO
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    CHAR    Obj[MAX_PATH + 1];      // the object file within the module
    CHAR    FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFO, *PSRCCODEINFO;

typedef struct _SRCCODEINFOW
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    WCHAR   Obj[MAX_PATH + 1];      // the object file within the module
    WCHAR   FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFOW, *PSRCCODEINFOW;

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACK)(
    __in PSRCCODEINFO LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACKW)(
    __in PSRCCODEINFOW LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE64 Line64
);

BOOL
IMAGEAPI
SymGetLineFromAddrW64(
    __in HANDLE hProcess,
    __in DWORD64 dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW64 Line
);

BOOL
IMAGEAPI
SymEnumSourceLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

// flags for SymEnumSourceLines

#define ESLFLAG_FULLPATH        0x1
#define ESLFLAG_NEAREST         0x2
#define ESLFLAG_PREV            0x4
#define ESLFLAG_NEXT            0x8

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#define SymGetLineFromAddrW SymGetLineFromAddrW64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineFromAddrW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineFromNameW64(
    __in HANDLE hProcess,
    __in_opt PCWSTR ModuleName,
    __in_opt PCWSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE Line
);
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLinePrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLinePrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in PCSTR FileName,
    __out_ecount(BufferLines) PDWORD64 Buffer,
    __in ULONG BufferLines
);

BOOL
IMAGEAPI
SymMatchFileName(
    __in PCSTR FileName,
    __in PCSTR Match,
    __deref_opt_out PSTR* FileNameStop,
    __deref_opt_out PSTR* MatchStop
);

BOOL
IMAGEAPI
SymMatchFileNameW(
    __in PCWSTR FileName,
    __in PCWSTR Match,
    __deref_opt_out PWSTR* FileNameStop,
    __deref_opt_out PWSTR* MatchStop
);

BOOL
IMAGEAPI
SymGetSourceFile(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Params,
    __in PCSTR FileSpec,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Params,
    __in PCWSTR FileSpec,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileToken(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileTokenW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __in PCSTR VarName,
    __out_ecount(Size) PSTR Value,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __in PCWSTR VarName,
    __out_ecount(Size) PWSTR Value,
    __in DWORD Size
);

typedef BOOL (CALLBACK* PENUMSOURCEFILETOKENSCALLBACK)(__in PVOID token,  __in size_t size);

BOOL
IMAGEAPI
SymEnumSourceFileTokens(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PENUMSOURCEFILETOKENSCALLBACK Callback
);

BOOL
IMAGEAPI
SymInitialize(
    __in HANDLE hProcess,
    __in_opt PCSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymInitializeW(
    __in HANDLE hProcess,
    __in_opt PCWSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymGetSearchPath(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymGetSearchPathW(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PWSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymSetSearchPath(
    __in HANDLE hProcess,
    __in_opt PCSTR SearchPath
);

BOOL
IMAGEAPI
SymSetSearchPathW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SearchPath
);

#define SLMFLAG_VIRTUAL     0x1
#define SLMFLAG_ALT_INDEX   0x2
#define SLMFLAG_NO_SYMBOLS  0x4

DWORD64
IMAGEAPI
SymLoadModuleEx(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

DWORD64
IMAGEAPI
SymLoadModuleExW(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCWSTR ImageName,
    __in_opt PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

BOOL
IMAGEAPI
SymUnloadModule64(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    __in HANDLE hProcess,
    __in DWORD BaseOfDll
);
#endif

BOOL
IMAGEAPI
SymUnDName64(
    __in PIMAGEHLP_SYMBOL64 sym,            // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    __in PIMAGEHLP_SYMBOL sym,              // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterCallbackW64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC
{
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO   // AKA TYPTYP
{
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef struct _SYMBOL_INFO
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _SYMBOL_INFO_PACKAGE
{
    SYMBOL_INFO si;
    CHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGE, *PSYMBOL_INFO_PACKAGE;

typedef struct _SYMBOL_INFOW
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    WCHAR       Name[1];          // Name of symbol
} SYMBOL_INFOW, *PSYMBOL_INFOW;

typedef struct _SYMBOL_INFO_PACKAGEW
{
    SYMBOL_INFOW si;
    WCHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGEW, *PSYMBOL_INFO_PACKAGEW;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


BOOL
IMAGEAPI
SymSetContext(
    __in HANDLE hProcess,
    __in PIMAGEHLP_STACK_FRAME StackFrame,
    __in_opt PIMAGEHLP_CONTEXT Context
);

BOOL
IMAGEAPI
SymSetScopeFromAddr(
    __in HANDLE hProcess,
    __in ULONG64 Address
);

BOOL
IMAGEAPI
SymSetScopeFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index
);

typedef BOOL
(CALLBACK* PSYM_ENUMPROCESSES_CALLBACK)(
    __in HANDLE hProcess,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumProcesses(
    __in PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymFromAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromToken(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromTokenW(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymNext(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymNextW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

BOOL
IMAGEAPI
SymPrev(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymPrevW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromNameW(
    __in HANDLE hProcess,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACK)(
    __in PSYMBOL_INFO pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbols(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACKW)(
    __in PSYMBOL_INFOW pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

#define SYMSEARCH_MASKOBJS      0x01    // used internally to implement other APIs
#define SYMSEARCH_RECURSE       0X02    // recurse scopes
#define SYMSEARCH_GLOBALSONLY   0X04    // search only for global symbols
#define SYMSEARCH_ALLITEMS      0X08    // search for everything in the pdb, not just normal scoped symbols

BOOL
IMAGEAPI
SymSearch(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymSearchW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCWSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymGetScope(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetScopeW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromIndexW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO
{
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
    TI_GET_UDTKIND,
    TI_IS_EQUIV_TO,
    TI_GET_CALLING_CONVENTION,
    TI_IS_CLOSE_EQUIV_TO,
    TI_GTIEX_REQS_VALID,
    TI_GET_VIRTUALBASEOFFSET,
    TI_GET_VIRTUALBASEDISPINDEX,
    TI_GET_IS_REFERENCE,
    TI_GET_INDIRECTVIRTUALBASECLASS,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS
{
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __in ULONG TypeId,
    __in IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    __out PVOID pInfo
);

#define IMAGEHLP_GET_TYPE_INFO_UNCACHED 0x00000001
#define IMAGEHLP_GET_TYPE_INFO_CHILDREN 0x00000002

typedef struct _IMAGEHLP_GET_TYPE_INFO_PARAMS
{
    IN  ULONG    SizeOfStruct;
    IN  ULONG    Flags;
    IN  ULONG    NumIds;
    IN  PULONG   TypeIds;
    IN  ULONG64  TagFilter;
    IN  ULONG    NumReqs;
    IN  IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
    IN  PULONG_PTR ReqOffsets;
    IN  PULONG   ReqSizes;
    IN  ULONG_PTR ReqStride;
    IN  ULONG_PTR BufferSize;
    OUT PVOID    Buffer;
    OUT ULONG    EntriesMatched;
    OUT ULONG    EntriesFilled;
    OUT ULONG64  TagsFound;
    OUT ULONG64  AllReqsValid;
    IN  ULONG    NumReqsValid;
    OUT PULONG64 ReqsValid OPTIONAL;
} IMAGEHLP_GET_TYPE_INFO_PARAMS, *PIMAGEHLP_GET_TYPE_INFO_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfoEx(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __inout PIMAGEHLP_GET_TYPE_INFO_PARAMS Params
);

BOOL
IMAGEAPI
SymEnumTypes(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetTypeFromName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetTypeFromNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymAddSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymAddSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymRefreshModuleList(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymAddSourceStream(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAM)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamA(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAMA)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR FileSpec,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

BOOL
IMAGEAPI
SymSrvIsStoreW(
    __in_opt HANDLE hProcess,
    __in PCWSTR path
);

BOOL
IMAGEAPI
SymSrvIsStore(
    __in_opt HANDLE hProcess,
    __in PCSTR path
);

PCSTR
IMAGEAPI
SymSrvDeltaName(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Type,
    __in PCSTR File1,
    __in PCSTR File2
);

PCWSTR
IMAGEAPI
SymSrvDeltaNameW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Type,
    __in PCWSTR File1,
    __in PCWSTR File2
);

PCSTR
IMAGEAPI
SymSrvGetSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Node,
    __in PCSTR File
);

PCWSTR
IMAGEAPI
SymSrvGetSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File
);

BOOL
IMAGEAPI
SymSrvGetFileIndexes(
    __in PCSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexesW(
    __in PCWSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexStringW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __out_ecount(Size) PWSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexString(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __out_ecount(Size) PSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

typedef struct
{
    DWORD sizeofstruct;
    char file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    char dbgfile[MAX_PATH + 1];
    char pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFO, *PSYMSRV_INDEX_INFO;

typedef struct
{
    DWORD sizeofstruct;
    WCHAR file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    WCHAR dbgfile[MAX_PATH + 1];
    WCHAR pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFOW, *PSYMSRV_INDEX_INFOW;

BOOL
IMAGEAPI
SymSrvGetFileIndexInfo(
    __in PCSTR File,
    __out PSYMSRV_INDEX_INFO Info,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexInfoW(
    __in PCWSTR File,
    __out PSYMSRV_INDEX_INFOW Info,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR Node,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __in DWORD Flags
);

// used by SymGetSymbolFile's "Type" parameter

enum
{
    sfImage = 0,
    sfDbg,
    sfPdb,
    sfMpd,
    sfMax
};

BOOL
IMAGEAPI
SymGetSymbolFile(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
);

BOOL
IMAGEAPI
SymGetSymbolFileW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PWSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PWSTR DbgFile,
    __in size_t cDbgFile
);

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI* PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    __in DWORD DataType,
    __in PVOID* Data,
    __out LPDWORD DataLength,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDump(
    __in_opt LPCSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    __in_opt LPCWSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out_opt PDWORD64 pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL64  Symbol
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out_opt PDWORD pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif


// Symbol server exports

typedef BOOL (WINAPI* PSYMBOLSERVERPROC)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCA)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROC)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCA)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCW)(PCWSTR, PCWSTR, PCWSTR, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSWPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR(WINAPI* PSYMBOLSERVERGETOPTIONSPROC)();
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROC)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCA)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCW)(PCWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERGETVERSION)(LPAPI_VERSION);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAME)(PCSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAMEW)(PCWSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRING)(PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRINGW)(PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILE)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILEW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTORE)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTOREW)(PCWSTR);
typedef DWORD (WINAPI* PSYMBOLSERVERVERSION)();
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERMESSAGEPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);

#define SYMSRV_VERSION              2

#define SSRVOPT_CALLBACK            0x00000001
#define SSRVOPT_DWORD               0x00000002
#define SSRVOPT_DWORDPTR            0x00000004
#define SSRVOPT_GUIDPTR             0x00000008
#define SSRVOPT_OLDGUIDPTR          0x00000010
#define SSRVOPT_UNATTENDED          0x00000020
#define SSRVOPT_NOCOPY              0x00000040
#define SSRVOPT_GETPATH             0x00000040
#define SSRVOPT_PARENTWIN           0x00000080
#define SSRVOPT_PARAMTYPE           0x00000100
#define SSRVOPT_SECURE              0x00000200
#define SSRVOPT_TRACE               0x00000400
#define SSRVOPT_SETCONTEXT          0x00000800
#define SSRVOPT_PROXY               0x00001000
#define SSRVOPT_DOWNSTREAM_STORE    0x00002000
#define SSRVOPT_OVERWRITE           0x00004000
#define SSRVOPT_RESETTOU            0x00008000
#define SSRVOPT_CALLBACKW           0x00010000
#define SSRVOPT_FLAT_DEFAULT_STORE  0x00020000
#define SSRVOPT_PROXYW              0x00040000
#define SSRVOPT_MESSAGE             0x00080000
#define SSRVOPT_SERVICE             0x00100000   // deprecated
#define SSRVOPT_FAVOR_COMPRESSED    0x00200000
#define SSRVOPT_STRING              0x00400000
#define SSRVOPT_WINHTTP             0x00800000
#define SSRVOPT_WININET             0x01000000

#define SSRVOPT_MAX                 0x0100000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#define SSRVACTION_SIZE         5

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
#define SymInitialize                     SymInitializeW
#define SymAddSymbol                      SymAddSymbolW
#define SymDeleteSymbol                   SymDeleteSymbolW
#define SearchTreeForFile                 SearchTreeForFileW
#define UnDecorateSymbolName              UnDecorateSymbolNameW
#define SymGetLineFromName64              SymGetLineFromNameW64
#define SymGetLineFromAddr64              SymGetLineFromAddrW64
#define SymGetLineNext64                  SymGetLineNextW64
#define SymGetLinePrev64                  SymGetLinePrevW64
#define SymFromName                       SymFromNameW
#define SymFindExecutableImage            SymFindExecutableImageW
#define FindExecutableImageEx             FindExecutableImageExW
#define SymSearch                         SymSearchW
#define SymEnumLines                      SymEnumLinesW
#define SymEnumSourceLines                SymEnumSourceLinesW
#define SymGetTypeFromName                SymGetTypeFromNameW
#define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
#define SymFromAddr                       SymFromAddrW
#define SymMatchString                    SymMatchStringW
#define SymEnumSourceFiles                SymEnumSourceFilesW
#define SymEnumSymbols                    SymEnumSymbolsW
#define SymLoadModuleEx                   SymLoadModuleExW
#define SymSetSearchPath                  SymSetSearchPathW
#define SymGetSearchPath                  SymGetSearchPathW
#define EnumDirTree                       EnumDirTreeW
#define SymFromToken                      SymFromTokenW
#define SymFromIndex                      SymFromIndexW
#define SymGetScope                       SymGetScopeW
#define SymNext                           SymNextW
#define SymPrev                           SymPrevW
#define SymEnumTypes                      SymEnumTypesW
#define SymEnumTypesByName                SymEnumTypesByNameW
#define SymRegisterCallback64             SymRegisterCallbackW64
#define SymFindDebugInfoFile              SymFindDebugInfoFileW
#define FindDebugInfoFileEx               FindDebugInfoFileExW
#define SymFindFileInPath                 SymFindFileInPathW
#define SymEnumerateModules64             SymEnumerateModulesW64
#define SymSetHomeDirectory               SymSetHomeDirectoryW
#define SymGetHomeDirectory               SymGetHomeDirectoryW
#define SymGetSourceFile                  SymGetSourceFileW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
#define SymFindFileInPath                 SymFindFileInPathW
#define SymMatchFileName                  SymMatchFileNameW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetModuleInfo64                SymGetModuleInfoW64
#define SymSrvIsStore                     SymSrvIsStoreW
#define SymSrvDeltaName                   SymSrvDeltaNameW
#define SymSrvGetSupplement               SymSrvGetSupplementW
#define SymSrvStoreSupplement             SymSrvStoreSupplementW
#define SymSrvGetFileIndexes              SymSrvGetFileIndexes
#define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
#define SymSrvStoreFile                   SymSrvStoreFileW
#define SymGetSymbolFile                  SymGetSymbolFileW
#define EnumerateLoadedModules64          EnumerateLoadedModulesW64
#define EnumerateLoadedModulesEx          EnumerateLoadedModulesExW
#define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW

#define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
#define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
#define SYMBOL_INFO                       SYMBOL_INFOW
#define PSYMBOL_INFO                      PSYMBOL_INFOW
#define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
#define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
#define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
#define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
#define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
#define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
#define SRCCODEINFO                       SRCCODEINFOW
#define PSRCCODEINFO                      PSRCCODEINFOW
#define SOURCEFILE                        SOURCEFILEW
#define PSOURCEFILE                       PSOURCEFILEW
#define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
#define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
#define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
#define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
#define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
#define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
#define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
#define SYMSRV_INDEX_INFO                 SYMSRV_INDEX_INFOW
#define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

#define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
#define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
);
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000

#pragma pack(pop)


#pragma pack(push,4)

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR
{
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64
{
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR
{
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64
{
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER
{
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union
    {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY
{
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING
{
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE
{

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,
    TokenStream                 = 19,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005,
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,
    ceStreamProcessModuleMap    = 0x800B,
    ceStreamDiagnosisList       = 0x800C,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
//

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION
{

    //
    // X86 platforms use CPUID function to obtain processor information.
    //

    struct
    {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //

        ULONG32 VendorId [ 3 ];

        //
        // CPUID Subfunction 1, register EAX
        //

        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //

        ULONG32 FeatureInformation;


        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //

        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //

    struct
    {

        ULONG64 ProcessorFeatures [ 2 ];

    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;

typedef struct _MINIDUMP_SYSTEM_INFO
{

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //

    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union
    {
        USHORT Reserved0;
        struct
        {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //

    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //

    RVA CSDVersionRva;

    union
    {
        ULONG32 Reserved1;
        struct
        {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT(sizeof(((PPROCESS_INFORMATION)0)->dwThreadId) == 4);

typedef struct _MINIDUMP_THREAD
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION
{
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM
{
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST
{
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST
{
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST
{
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION
{
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64
{
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE
{
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION
{
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N* PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
{
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID            0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES         0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO  0x00000004
#define MINIDUMP_MISC3_PROCESS_INTEGRITY     0x00000010
#define MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS 0x00000020
#define MINIDUMP_MISC3_TIMEZONE              0x00000040
#define MINIDUMP_MISC3_PROTECTED_PROCESS     0x00000080

typedef struct _MINIDUMP_MISC_INFO
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

typedef struct _MINIDUMP_MISC_INFO_3
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
    ULONG32 ProcessIntegrityLevel;
    ULONG32 ProcessExecuteFlags;
    ULONG32 ProtectedProcess;
    ULONG32 TimeZoneId;
    TIME_ZONE_INFORMATION TimeZone;
} MINIDUMP_MISC_INFO_3, *PMINIDUMP_MISC_INFO_3;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_3 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO
{
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO
{
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;

//
// Support for token information.
//
typedef struct _MINIDUMP_TOKEN_INFO_HEADER
{
    ULONG   TokenSize;   // The size of the token structure.
    ULONG   TokenId;     // The PID in NtOpenProcessToken() call or TID in NtOpenThreadToken() call.
    ULONG64 TokenHandle; // The handle value returned.
} MINIDUMP_TOKEN_INFO_HEADER, *PMINIDUMP_TOKEN_INFO_HEADER;

typedef struct _MINIDUMP_TOKEN_INFO_LIST
{
    ULONG TokenListSize;
    ULONG TokenListEntries;
    ULONG ListHeaderSize;
    ULONG ElementHeaderSize;
} MINIDUMP_TOKEN_INFO_LIST, *PMINIDUMP_TOKEN_INFO_LIST;

//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD
{
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM
{
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION
{
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE
{
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK
{
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS
{
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK
{
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord;
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK
{
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS
{
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK
{
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
*PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT
{
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union
    {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT
{
    union
    {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct
        {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct
        {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct
        {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;


//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE
{
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    MiniDumpWithPrivateWriteCopyMemory     = 0x00010000,
    MiniDumpIgnoreInaccessibleMemory       = 0x00020000,
    MiniDumpWithTokenInformation           = 0x00040000,
    MiniDumpValidTypeFlags                 = 0x0007ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//

typedef enum _MINIDUMP_SECONDARY_FLAGS
{
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI* MINIDUMP_CALLBACK_ROUTINE)(
    __inout PVOID CallbackParam,
    __in    PMINIDUMP_CALLBACK_INPUT CallbackInput,
    __inout PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
);

typedef struct _MINIDUMP_CALLBACK_INFORMATION
{
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    __in HANDLE hProcess,
    __in DWORD ProcessId,
    __in HANDLE hFile,
    __in MINIDUMP_TYPE DumpType,
    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
);

BOOL
WINAPI
MiniDumpReadDumpStream(
    __in PVOID BaseOfDump,
    __in ULONG StreamNumber,
    __deref_out_opt PMINIDUMP_DIRECTORY* Dir,
    __deref_out_opt PVOID* StreamPointer,
    __out_opt ULONG* StreamSize
);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_




================================================
File: pluginsdk/jansson/jansson.h
================================================
/*
 * Copyright (c) 2009-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  9
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.9"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}

#if defined(__GNUC__) || defined(__clang__)
static JSON_INLINE
void json_decrefp(json_t** json)
{
    if(json)
    {
        json_decref(*json);
        *json = NULL;
    }
}

#define json_auto_t json_t __attribute__((cleanup(json_decrefp)))
#endif


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_object_foreach_safe(object, n, key, value)     \
    for(key = json_object_iter_key(json_object_iter(object)), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(n), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
__declspec(dllimport) void json_get_alloc_funcs(json_malloc_t* malloc_fn, json_free_t* free_fn);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: pluginsdk/jansson/jansson_config.h
================================================
/*
 * Copyright (c) 2010-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint strtoll
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1


/* Maximum recursion depth for parsing JSON input.
   This limits the depth of e.g. array-within-array constructions. */
#define JSON_PARSER_MAX_DEPTH 2048


#endif



================================================
File: pluginsdk/jansson/jansson_x64dbg.h
================================================
#pragma once

#include "jansson.h"

typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
    sprintf(hexvalue, "0x%llX", value);
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
    sscanf(hexvalue, "0x%llX", &ret);
    return ret;
}


================================================
File: pluginsdk/lz4/lz4.h
================================================
/*
   LZ4 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4_H
#define _LZ4_H

#if defined (__cplusplus)
extern "C"
{
#endif


/**************************************
   Version
**************************************/
#define LZ4_VERSION_MAJOR    1    /* for major interface/format changes  */
#define LZ4_VERSION_MINOR    1    /* for minor interface/format changes  */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */


/**************************************
   Compiler Options
**************************************/
#if (defined(__GNUC__) && defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__cplusplus))   /* Visual Studio */
#  define inline __inline           /* Visual C is not C99, but supports some kind of inline */
#endif


/**************************************
   Simple Functions
**************************************/

__declspec(dllimport) int LZ4_compress(const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_decompress_safe(const char* source, char* dest, int inputSize, int maxOutputSize);

/*
LZ4_compress() :
    Compresses 'inputSize' bytes from 'source' into 'dest'.
    Destination buffer must be already allocated,
    and must be sized to handle worst cases situations (input data not compressible)
    Worst case size evaluation is provided by function LZ4_compressBound()
    inputSize : Max supported value is LZ4_MAX_INPUT_VALUE
    return : the number of bytes written in buffer dest
             or 0 if the compression fails

LZ4_decompress_safe() :
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits (never writes outside of output buffer, and never reads outside of input buffer). Therefore, it is protected against malicious data packets
*/


/**************************************
   Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*
LZ4_compressBound() :
    Provides the maximum size that LZ4 may output in a "worst case" scenario (input data not compressible)
    primarily useful for memory allocation of output buffer.
    inline function is recommended for the general case,
    macro is also provided when result needs to be evaluated at compilation (such as stack memory allocation).

    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE
    return : maximum output size in a "worst case" scenario
             or 0, if input size is too large ( > LZ4_MAX_INPUT_SIZE)
*/
__declspec(dllimport) int LZ4_compressBound(int isize);


/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is LZ4_MAX_INPUT_VALUE
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes written in buffer 'dest'
             or 0 if the compression fails
*/
__declspec(dllimport) int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);


/*
LZ4_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is malformed, the function will stop decoding and return a negative result.
    note : This function is a bit faster than LZ4_decompress_safe()
           This function never writes outside of output buffers, but may read beyond input buffer in case of malicious data packet.
           Use this function preferably into a trusted environment (data to decode comes from a trusted source).
           Destination buffer must be already allocated. Its size must be a minimum of 'outputSize' bytes.
*/
__declspec(dllimport) int LZ4_decompress_fast(const char* source, char* dest, int originalSize);


/*
LZ4_decompress_safe_partial() :
    This function decompress a compressed block of size 'inputSize' at position 'source'
    into output buffer 'dest' of size 'maxOutputSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*/
__declspec(dllimport) int LZ4_decompress_safe_partial(const char* source, char* dest, int inputSize, int targetOutputSize, int maxOutputSize);


/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofState();

Note that tables must be aligned on 4-bytes boundaries, otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withState() and LZ4_compress_limitedOutput_withState() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/
__declspec(dllimport) int LZ4_sizeofState(void);
__declspec(dllimport) int LZ4_compress_withState(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compress_limitedOutput_withState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_create(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compress_continue(void* LZ4_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compress_limitedOutput_continue(void* LZ4_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBuffer(void* LZ4_Data);
__declspec(dllimport) int   LZ4_free(void* LZ4_Data);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4 Data Structure, thanks to the function :

void* LZ4_create (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4 Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compress_continue() or LZ4_compress_limitedOutput_continue().
Their behavior are identical to LZ4_compress() or LZ4_compress_limitedOutput(),
but require the LZ4 Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBuffer(void* LZ4_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compress_continue() or LZ4_compress_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_free() will release the memory used by the LZ4 Data Structure.
*/


__declspec(dllimport) int LZ4_sizeofStreamState(void);
__declspec(dllimport) int LZ4_resetStreamState(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_create (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamState();
Note also that space must be 4-bytes aligned.

Once space is allocated, you must initialize it using : LZ4_resetStreamState(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned on 4-bytes boundaries, and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamState() must be 0 is OK.
Any other value means there was an error (typically, pointer is not aligned on 4-bytes boundaries).
*/


__declspec(dllimport) int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int outputSize);

/*
*_withPrefix64k() :
    These decoding functions work the same as their "normal name" versions,
    but can use up to 64KB of data in front of 'char* dest'.
    These functions are necessary to decode inter-dependant blocks.
*/


/**************************************
   Obsolete Functions
**************************************/
/*
These functions are deprecated and should no longer be used.
They are provided here for compatibility with existing user programs.
*/
__declspec(dllimport) int LZ4_uncompress(const char* source, char* dest, int outputSize);
__declspec(dllimport) int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int isize, int maxOutputSize);


#if defined (__cplusplus)
}
#endif

#endif //_LZ4_H


================================================
File: pluginsdk/lz4/lz4file.h
================================================
#ifndef _LZ4FILE_H
#define _LZ4FILE_H

typedef enum _LZ4_STATUS
{
    LZ4_SUCCESS,
    LZ4_FAILED_OPEN_INPUT,
    LZ4_FAILED_OPEN_OUTPUT,
    LZ4_NOT_ENOUGH_MEMORY,
    LZ4_INVALID_ARCHIVE,
    LZ4_CORRUPTED_ARCHIVE
} LZ4_STATUS;

#if defined (__cplusplus)
extern "C"
{
#endif

__declspec(dllimport) LZ4_STATUS LZ4_compress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_compress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);

#if defined (__cplusplus)
}
#endif

#endif //_LZ4FILE_H


================================================
File: pluginsdk/lz4/lz4hc.h
================================================
/*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4HC_H
#define _LZ4HC_H

#if defined (__cplusplus)
extern "C"
{
#endif


__declspec(dllimport) int LZ4_compressHC(const char* source, char* dest, int inputSize);
/*
LZ4_compressHC :
    return : the number of bytes in compressed buffer dest
             or 0 if compression fails.
    note : destination buffer must be already allocated.
        To avoid any problem, size it to handle worst cases situations (input data not compressible)
        Worst case size evaluation is provided by function LZ4_compressBound() (see "lz4.h")
*/

__declspec(dllimport) int LZ4_compressHC_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);
/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is 1 GB
    maxOutputSize : is maximum allowed size into the destination buffer (which must be already allocated)
    return : the number of output bytes written in buffer 'dest'
             or 0 if compression fails.
*/


__declspec(dllimport) int LZ4_compressHC2(const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);
/*
    Same functions as above, but with programmable 'compressionLevel'.
    Recommended values are between 4 and 9, although any value between 0 and 16 will work.
    'compressionLevel'==0 means use default 'compressionLevel' value.
    Values above 16 behave the same as 16.
    Equivalent variants exist for all other compression functions below.
*/

/* Note :
Decompression functions are provided within LZ4 source code (see "lz4.h") (BSD license)
*/


/**************************************
   Using an external allocation
**************************************/
__declspec(dllimport) int LZ4_sizeofStateHC(void);
__declspec(dllimport) int LZ4_compressHC_withStateHC(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compressHC_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);

__declspec(dllimport) int LZ4_compressHC2_withStateHC(void* state, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofStateHC();

Note that tables must be aligned for pointer (32 or 64 bits), otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withStateHC() and LZ4_compress_limitedOutput_withStateHC() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_createHC(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compressHC_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compressHC_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
__declspec(dllimport) int   LZ4_freeHC(void* LZ4HC_Data);

__declspec(dllimport) int   LZ4_compressHC2_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int   LZ4_compressHC2_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4HC Data Structure, thanks to the function :

void* LZ4_createHC (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4HC Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue().
Their behavior are identical to LZ4_compressHC() or LZ4_compressHC_limitedOutput(),
but require the LZ4HC Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_freeHC() will release the memory used by the LZ4HC Data Structure.
*/

__declspec(dllimport) int LZ4_sizeofStreamStateHC(void);
__declspec(dllimport) int LZ4_resetStreamStateHC(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_createHC (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamStateHC();
Note also that space must be aligned for pointers (32 or 64 bits).

Once space is allocated, you must initialize it using : LZ4_resetStreamStateHC(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned for pointers (32 or 64 bits), and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamStateHC() must be 0 is OK.
Any other value means there was an error (typically, state is not aligned for pointers (32 or 64 bits)).
*/


#if defined (__cplusplus)
}
#endif

#endif //_LZ4HC_H



================================================
File: pluginsdk/yara/yara.h
================================================
/*
Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_YARA_H
#define YR_YARA_H

#include "yara/utils.h"
#include "yara/filemap.h"
#include "yara/compiler.h"
#include "yara/modules.h"
#include "yara/object.h"
#include "yara/libyara.h"
#include "yara/error.h"
#include "yara/stream.h"
#include "yara/hash.h"

#endif



================================================
File: pluginsdk/yara/yara/ahocorasick.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _AHOCORASICK_H
#define _AHOCORASICK_H

#include "limits.h"
#include "atoms.h"
#include "types.h"


#define YR_AC_ROOT_STATE                0
#define YR_AC_NEXT_STATE(t)             (t >> 32)
#define YR_AC_INVALID_TRANSITION(t, c)  (((t) & 0xFFFF) != c)

#define YR_AC_MAKE_TRANSITION(state, code, flags) \
  ((uint64_t)((((uint64_t) state) << 32) | ((flags) << 16) | (code)))

#define YR_AC_USED_FLAG    0x1

#define YR_AC_USED_TRANSITION_SLOT(x)   ((x) & (YR_AC_USED_FLAG << 16))
#define YR_AC_UNUSED_TRANSITION_SLOT(x) (!YR_AC_USED_TRANSITION_SLOT(x))


typedef struct _YR_AC_TABLES
{
    YR_AC_TRANSITION* transitions;
    YR_AC_MATCH_TABLE_ENTRY* matches;

} YR_AC_TABLES;


int yr_ac_automaton_create(
    YR_AC_AUTOMATON** automaton);


int yr_ac_automaton_destroy(
    YR_AC_AUTOMATON* automaton);


int yr_ac_add_string(
    YR_AC_AUTOMATON* automaton,
    YR_STRING* string,
    YR_ATOM_LIST_ITEM* atom,
    YR_ARENA* matches_arena);


int yr_ac_compile(
    YR_AC_AUTOMATON* automaton,
    YR_ARENA* arena,
    YR_AC_TABLES* tables);


void yr_ac_print_automaton(
    YR_AC_AUTOMATON* automaton);


#endif



================================================
File: pluginsdk/yara/yara/arena.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ARENA_H
#define YR_ARENA_H

#include <stddef.h>

#include "integers.h"
#include "stream.h"

#define ARENA_FLAGS_FIXED_SIZE   1
#define ARENA_FLAGS_COALESCED    2
#define ARENA_FILE_VERSION       ((13 << 16) | MAX_THREADS)

#define EOL ((size_t) -1)


typedef struct _YR_RELOC
{
    uint32_t offset;
    struct _YR_RELOC* next;

} YR_RELOC;


typedef struct _YR_ARENA_PAGE
{

    uint8_t* new_address;
    uint8_t* address;

    size_t size;
    size_t used;

    YR_RELOC* reloc_list_head;
    YR_RELOC* reloc_list_tail;

    struct _YR_ARENA_PAGE* next;
    struct _YR_ARENA_PAGE* prev;

} YR_ARENA_PAGE;


typedef struct _YR_ARENA
{
    int flags;

    YR_ARENA_PAGE* page_list_head;
    YR_ARENA_PAGE* current_page;

} YR_ARENA;


int yr_arena_create(
    size_t initial_size,
    int flags,
    YR_ARENA** arena);


void yr_arena_destroy(
    YR_ARENA* arena);


void* yr_arena_base_address(
    YR_ARENA* arena);


void* yr_arena_next_address(
    YR_ARENA* arena,
    void* address,
    size_t offset);


int yr_arena_coalesce(
    YR_ARENA* arena);


int yr_arena_reserve_memory(
    YR_ARENA* arena,
    size_t size);


int yr_arena_allocate_memory(
    YR_ARENA* arena,
    size_t size,
    void** allocated_memory);


int yr_arena_allocate_struct(
    YR_ARENA* arena,
    size_t size,
    void** allocated_memory,
    ...);


int yr_arena_make_relocatable(
    YR_ARENA* arena,
    void* base,
    ...);


int yr_arena_write_data(
    YR_ARENA* arena,
    void* data,
    size_t size,
    void** written_data);


int yr_arena_write_string(
    YR_ARENA* arena,
    const char* string,
    char** written_string);


int yr_arena_append(
    YR_ARENA* target_arena,
    YR_ARENA* source_arena);


int yr_arena_load_stream(
    YR_STREAM* stream,
    YR_ARENA** arena);


int yr_arena_save_stream(
    YR_ARENA* arena,
    YR_STREAM* stream);


int yr_arena_duplicate(
    YR_ARENA* arena,
    YR_ARENA** duplicated);


void yr_arena_print(
    YR_ARENA* arena);

#endif



================================================
File: pluginsdk/yara/yara/atoms.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ATOMS_H
#define YR_ATOMS_H

#include "limits.h"
#include "re.h"

#define ATOM_TREE_LEAF  1
#define ATOM_TREE_AND   2
#define ATOM_TREE_OR    3


typedef struct _ATOM_TREE_NODE
{
    uint8_t type;
    uint8_t atom_length;
    uint8_t atom[MAX_ATOM_LENGTH];

    uint8_t* forward_code;
    uint8_t* backward_code;

    RE_NODE* recent_nodes[MAX_ATOM_LENGTH];

    struct _ATOM_TREE_NODE* children_head;
    struct _ATOM_TREE_NODE* children_tail;
    struct _ATOM_TREE_NODE* next_sibling;

} ATOM_TREE_NODE;


typedef struct _ATOM_TREE
{
    ATOM_TREE_NODE* current_leaf;
    ATOM_TREE_NODE* root_node;

} ATOM_TREE;


typedef struct _YR_ATOM_LIST_ITEM
{
    uint8_t atom_length;
    uint8_t atom[MAX_ATOM_LENGTH];

    uint16_t backtrack;

    uint8_t* forward_code;
    uint8_t* backward_code;

    struct _YR_ATOM_LIST_ITEM* next;

} YR_ATOM_LIST_ITEM;


int yr_atoms_extract_from_re(
    RE_AST* re_ast,
    int flags,
    YR_ATOM_LIST_ITEM** atoms);


int yr_atoms_extract_from_string(
    uint8_t* string,
    int string_length,
    int flags,
    YR_ATOM_LIST_ITEM** atoms);


int yr_atoms_min_quality(
    YR_ATOM_LIST_ITEM* atom_list);


void yr_atoms_list_destroy(
    YR_ATOM_LIST_ITEM* list_head);

#endif



================================================
File: pluginsdk/yara/yara/compiler.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_COMPILER_H
#define YR_COMPILER_H

#include <stdio.h>
#include <setjmp.h>

#include "ahocorasick.h"
#include "arena.h"
#include "hash.h"
#include "utils.h"
#include "filemap.h"


#define YARA_ERROR_LEVEL_ERROR   0
#define YARA_ERROR_LEVEL_WARNING 1


typedef void (*YR_COMPILER_CALLBACK_FUNC)(
    int error_level,
    const char* file_name,
    int line_number,
    const char* message,
    void* user_data);


typedef struct _YR_FIXUP
{
    void* address;
    struct _YR_FIXUP* next;

} YR_FIXUP;


typedef struct _YR_COMPILER
{
    int               errors;
    int               current_line;
    int               last_error;
    int               last_error_line;
    int               last_result;

    jmp_buf           error_recovery;

    YR_ARENA*         sz_arena;
    YR_ARENA*         rules_arena;
    YR_ARENA*         strings_arena;
    YR_ARENA*         code_arena;
    YR_ARENA*         re_code_arena;
    YR_ARENA*         compiled_rules_arena;
    YR_ARENA*         externals_arena;
    YR_ARENA*         namespaces_arena;
    YR_ARENA*         metas_arena;
    YR_ARENA*         matches_arena;
    YR_ARENA*         automaton_arena;

    YR_AC_AUTOMATON*  automaton;
    YR_HASH_TABLE*    rules_table;
    YR_HASH_TABLE*    objects_table;
    YR_HASH_TABLE*    strings_table;
    YR_NAMESPACE*     current_namespace;
    YR_RULE*          current_rule;

    YR_FIXUP*         fixup_stack_head;

    int               namespaces_count;

    uint8_t*          loop_address[MAX_LOOP_NESTING];
    char*             loop_identifier[MAX_LOOP_NESTING];
    int               loop_depth;
    int               loop_for_of_mem_offset;

    int               allow_includes;

    char*             file_name_stack[MAX_INCLUDE_DEPTH];
    int               file_name_stack_ptr;

    FILE*             file_stack[MAX_INCLUDE_DEPTH];
    int               file_stack_ptr;

    char              last_error_extra_info[MAX_COMPILER_ERROR_EXTRA_INFO];

    char              lex_buf[LEX_BUF_SIZE];
    char*             lex_buf_ptr;
    unsigned short    lex_buf_len;

    char              include_base_dir[MAX_PATH];
    void*             user_data;

    YR_COMPILER_CALLBACK_FUNC  callback;

} YR_COMPILER;


#define yr_compiler_set_error_extra_info(compiler, info) \
    strlcpy( \
        compiler->last_error_extra_info, \
        info, \
        sizeof(compiler->last_error_extra_info)); \
 

#define yr_compiler_set_error_extra_info_fmt(compiler, fmt, ...) \
    snprintf( \
        compiler->last_error_extra_info, \
        sizeof(compiler->last_error_extra_info), \
        fmt, __VA_ARGS__);


int _yr_compiler_push_file(
    YR_COMPILER* compiler,
    FILE* fh);


FILE* _yr_compiler_pop_file(
    YR_COMPILER* compiler);


int _yr_compiler_push_file_name(
    YR_COMPILER* compiler,
    const char* file_name);


void _yr_compiler_pop_file_name(
    YR_COMPILER* compiler);


YR_API int yr_compiler_create(
    YR_COMPILER** compiler);


YR_API void yr_compiler_destroy(
    YR_COMPILER* compiler);


YR_API void yr_compiler_set_callback(
    YR_COMPILER* compiler,
    YR_COMPILER_CALLBACK_FUNC callback,
    void* user_data);


YR_API int yr_compiler_add_file(
    YR_COMPILER* compiler,
    FILE* rules_file,
    const char* namespace_,
    const char* file_name);


YR_API int yr_compiler_add_fd(
    YR_COMPILER* compiler,
    YR_FILE_DESCRIPTOR rules_fd,
    const char* namespace_,
    const char* file_name);


YR_API int yr_compiler_add_string(
    YR_COMPILER* compiler,
    const char* rules_string,
    const char* namespace_);


YR_API char* yr_compiler_get_error_message(
    YR_COMPILER* compiler,
    char* buffer,
    int buffer_size);


YR_API char* yr_compiler_get_current_file_name(
    YR_COMPILER* context);


YR_API int yr_compiler_define_integer_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    int64_t value);


YR_API int yr_compiler_define_boolean_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    int value);


YR_API int yr_compiler_define_float_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    double value);


YR_API int yr_compiler_define_string_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    const char* value);


YR_API int yr_compiler_get_rules(
    YR_COMPILER* compiler,
    YR_RULES** rules);


#endif



================================================
File: pluginsdk/yara/yara/dotnet.h
================================================
#ifndef YR_DOTNET_H
#define YR_DOTNET_H


//
// CLI header.
// ECMA-335 Section II.25.3.3
//
typedef struct _CLI_HEADER
{
    DWORD Size; // Called "Cb" in documentation.
    WORD MajorRuntimeVersion;
    WORD MinorRuntimeVersion;
    IMAGE_DATA_DIRECTORY MetaData;
    DWORD Flags;
    DWORD EntryPointToken;
    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;
    ULONGLONG CodeManagerTable;
    IMAGE_DATA_DIRECTORY VTableFixups;
    ULONGLONG ExportAddressTableJumps;
    ULONGLONG ManagedNativeHeader;
} CLI_HEADER, *PCLI_HEADER;

#define NET_METADATA_MAGIC 0x424a5342

//
// CLI MetaData
// ECMA-335 Section II.24.2.1
//
// Note: This is only part of the struct, as the rest of it is variable length.
//
typedef struct _NET_METADATA
{
    DWORD Magic;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Reserved;
    DWORD Length;
    char Version[0];
} NET_METADATA, *PNET_METADATA;

#define DOTNET_STREAM_NAME_SIZE 32

//
// CLI Stream Header
// ECMA-335 Section II.24.2.2
//
typedef struct _STREAM_HEADER
{
    DWORD Offset;
    DWORD Size;
    char Name[0];
} STREAM_HEADER, *PSTREAM_HEADER;


//
// CLI #~ Stream Header
// ECMA-335 Section II.24.2.6
//
typedef struct _TILDE_HEADER
{
    DWORD Reserved1;
    BYTE MajorVersion;
    BYTE MinorVersion;
    BYTE HeapSizes;
    BYTE Reserved2;
    ULONGLONG Valid;
    ULONGLONG Sorted;
} TILDE_HEADER, *PTILDE_HEADER;

// These are the bit positions in Valid which will be set if the table
// exists.
#define BIT_MODULE                   0x00
#define BIT_TYPEREF                  0x01
#define BIT_TYPEDEF                  0x02
#define BIT_FIELDPTR                 0x03 // Not documented in ECMA-335
#define BIT_FIELD                    0x04
#define BIT_METHODDEFPTR             0x05 // Not documented in ECMA-335
#define BIT_METHODDEF                0x06
#define BIT_PARAMPTR                 0x07 // Not documented in ECMA-335
#define BIT_PARAM                    0x08
#define BIT_INTERFACEIMPL            0x09
#define BIT_MEMBERREF                0x0A
#define BIT_CONSTANT                 0x0B
#define BIT_CUSTOMATTRIBUTE          0x0C
#define BIT_FIELDMARSHAL             0x0D
#define BIT_DECLSECURITY             0x0E
#define BIT_CLASSLAYOUT              0x0F
#define BIT_FIELDLAYOUT              0x10
#define BIT_STANDALONESIG            0x11
#define BIT_EVENTMAP                 0x12
#define BIT_EVENTPTR                 0x13 // Not documented in ECMA-335
#define BIT_EVENT                    0x14
#define BIT_PROPERTYMAP              0x15
#define BIT_PROPERTYPTR              0x16 // Not documented in ECMA-335
#define BIT_PROPERTY                 0x17
#define BIT_METHODSEMANTICS          0x18
#define BIT_METHODIMPL               0x19
#define BIT_MODULEREF                0x1A
#define BIT_TYPESPEC                 0x1B
#define BIT_IMPLMAP                  0x1C
#define BIT_FIELDRVA                 0x1D
#define BIT_ENCLOG                   0x1E // Not documented in ECMA-335
#define BIT_ENCMAP                   0x1F // Not documented in ECMA-335
#define BIT_ASSEMBLY                 0x20
#define BIT_ASSEMBLYPROCESSOR        0x21
#define BIT_ASSEMBLYOS               0x22
#define BIT_ASSEMBLYREF              0x23
#define BIT_ASSEMBLYREFPROCESSOR     0x24
#define BIT_ASSEMBLYREFOS            0x25
#define BIT_FILE                     0x26
#define BIT_EXPORTEDTYPE             0x27
#define BIT_MANIFESTRESOURCE         0x28
#define BIT_NESTEDCLASS              0x29
#define BIT_GENERICPARAM             0x2A
#define BIT_METHODSPEC               0x2B
#define BIT_GENERICPARAMCONSTRAINT   0x2C
// These are not documented in ECMA-335 nor is it clear what the format is.
// They are for debugging information as far as I can tell.
//#define BIT_DOCUMENT               0x30
//#define BIT_METHODDEBUGINFORMATION 0x31
//#define BIT_LOCALSCOPE             0x32
//#define BIT_LOCALVARIABLE          0x33
//#define BIT_LOCALCONSTANT          0x34
//#define BIT_IMPORTSCOPE            0x35
//#define BIT_STATEMACHINEMETHOD     0x36


//
// Element types. Note this is not a complete list as we aren't parsing all of
// them. This only includes the ones we care about.
// ECMA-335 Section II.23.1.16
//
#define ELEMENT_TYPE_STRING 0x0E


// The string length of a typelib attribute is at most 0xFF.
#define MAX_TYPELIB_SIZE 0xFF

//
// Module table
// ECMA-335 Section II.22.30
//
typedef struct _MODULE_TABLE
{
    WORD Generation;
    union
    {
        WORD Name_Short;
        DWORD Name_Long;
    } Name;
    union
    {
        WORD Mvid_Short;
        DWORD Mvid_Long;
    } Mvid;
    union
    {
        WORD EncId_Short;
        DWORD EncId_Long;
    } EncId;
    union
    {
        WORD EncBaseId_Short;
        DWORD EncBaseId_Long;
    } EncBaseId;
} MODULE_TABLE, *PMODULE_TABLE;

//
// Assembly Table
// ECMA-335 Section II.22.2
//
typedef struct _ASSEMBLY_TABLE
{
    DWORD HashAlgId;
    WORD MajorVersion;
    WORD MinorVersion;
    WORD BuildNumber;
    WORD RevisionNumber;
    DWORD Flags;
    union
    {
        WORD PublicKey_Short;
        DWORD PublicKey_Long;
    } PublicKey;
    union
    {
        WORD Name_Short;
        DWORD Name_Long;
    } Name;
} ASSEMBLY_TABLE, *PASSEMBLY_TABLE;


//
// Assembly Reference Table
// ECMA-335 Section II.22.5
//
typedef struct _ASSEMBLYREF_TABLE
{
    WORD MajorVersion;
    WORD MinorVersion;
    WORD BuildNumber;
    WORD RevisionNumber;
    DWORD Flags;
    union
    {
        WORD PublicKeyOrToken_Short;
        DWORD PublicKeyOrToken_Long;
    } PublicKeyOrToken;
    union
    {
        WORD Name_Short;
        DWORD Name_Long;
    } Name;
} ASSEMBLYREF_TABLE, *PASSEMBLYREF_TABLE;


//
// Manifest Resource Table
// ECMA-335 Section II.22.24
//
typedef struct _MANIFESTRESOURCE_TABLE
{
    DWORD Offset;
    DWORD Flags;
    union
    {
        WORD Name_Short;
        DWORD Name_Long;
    } Name;
    union
    {
        WORD Implementation_Short;
        DWORD Implementation_Long;
    } Implementation;
} MANIFESTRESOURCE_TABLE, *PMANIFESTRESOURCE_TABLE;

//
// ModuleRef Table
// ECMA-335 Section II.22.31
//
// This is a short table, but necessary because the field size can change.
//
typedef struct _MODULEREF_TABLE
{
    union
    {
        WORD Name_Short;
        DWORD Name_Long;
    } Name;
} MODULEREF_TABLE, *PMODULEREF_TABLE;


//
// CustomAttribute Table
// ECMA-335 Section II.22.10
//
typedef struct _CUSTOMATTRIBUTE_TABLE
{
    union
    {
        WORD Parent_Short;
        DWORD Parent_Long;
    } Parent;
    union
    {
        WORD Type_Short;
        DWORD Type_Long;
    } Type;
    union
    {
        WORD Value_Short;
        DWORD Value_Long;
    } Value;
} CUSTOMATTRIBUTE_TABLE, *PCUSTOMATTRIBUTE_TABLE;


//
// Constant TAble
// ECMA-335 Section II.22.9
//
typedef struct _CONSTANT_TABLE
{
    WORD Type;
    union
    {
        WORD Parent_Short;
        DWORD Parent_Long;
    } Parent;
    union
    {
        WORD Value_Short;
        DWORD Value_Long;
    } Value;
} CONSTANT_TABLE, *PCONSTANT_TABLE;


// Used to return offsets to the various headers.
typedef struct _STREAMS
{
    PSTREAM_HEADER guid;
    PSTREAM_HEADER tilde;
    PSTREAM_HEADER string;
    PSTREAM_HEADER blob;
    PSTREAM_HEADER us;
} STREAMS, *PSTREAMS;


// Used to return the value of parsing a #US or #Blob entry.
// ECMA-335 Section II.24.2.4
typedef struct _BLOB_PARSE_RESULT
{
    uint8_t size; // Number of bytes parsed. This is the new offset.
    DWORD length; // Value of the bytes parsed. This is the blob length.
} BLOB_PARSE_RESULT, *PBLOB_PARSE_RESULT;


// Used to store the number of rows of each table.
typedef struct _ROWS
{
    uint32_t module;
    uint32_t moduleref;
    uint32_t assemblyref;
    uint32_t typeref;
    uint32_t methoddef;
    uint32_t memberref;
    uint32_t typedef_;
    uint32_t typespec;
    uint32_t field;
    uint32_t param;
    uint32_t property;
    uint32_t interfaceimpl;
    uint32_t event;
    uint32_t standalonesig;
    uint32_t assembly;
    uint32_t file;
    uint32_t exportedtype;
    uint32_t manifestresource;
    uint32_t genericparam;
    uint32_t genericparamconstraint;
    uint32_t methodspec;
    uint32_t assemblyrefprocessor;
} ROWS, *PROWS;


// Used to store the index sizes for the various tables.
typedef struct _INDEX_SIZES
{
    uint8_t string;
    uint8_t guid;
    uint8_t blob;
    uint8_t field;
    uint8_t methoddef;
    uint8_t memberref;
    uint8_t param;
    uint8_t event;
    uint8_t typedef_;
    uint8_t property;
    uint8_t moduleref;
    uint8_t assemblyrefprocessor;
    uint8_t assemblyref;
    uint8_t genericparam;
} INDEX_SIZES, *PINDEX_SIZES;
#endif



================================================
File: pluginsdk/yara/yara/elf.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _ELF_H
#define _ELF_H

#include "integers.h"


// 32-bit ELF base types

typedef uint32_t elf32_addr_t;
typedef uint16_t elf32_half_t;
typedef uint32_t elf32_off_t;
typedef uint32_t elf32_word_t;

// 64-bit ELF base types

typedef uint64_t elf64_addr_t;
typedef uint16_t elf64_half_t;
typedef uint64_t elf64_off_t;
typedef uint32_t elf64_word_t;
typedef uint64_t elf64_xword_t;

#define ELF_MAGIC       0x464C457F

#define ELF_ET_NONE     0x0000  // no type
#define ELF_ET_REL      0x0001  // relocatable
#define ELF_ET_EXEC     0x0002  // executable
#define ELF_ET_DYN      0x0003  // Shared-Object-File
#define ELF_ET_CORE     0x0004  // Corefile
#define ELF_ET_LOPROC   0xFF00  // Processor-specific
#define ELF_ET_HIPROC   0x00FF  // Processor-specific

#define ELF_EM_NONE         0x0000  // no type
#define ELF_EM_M32          0x0001  // AT&T WE 32100
#define ELF_EM_SPARC        0x0002  // SPARC
#define ELF_EM_386          0x0003  // Intel 80386
#define ELF_EM_68K          0x0004  // Motorola 68000
#define ELF_EM_88K          0x0005  // Motorola 88000
#define ELF_EM_860          0x0007  // Intel 80860
#define ELF_EM_MIPS         0x0008  // MIPS I Architecture
#define ELF_EM_MIPS_RS3_LE  0x000A  // MIPS RS3000 Little-endian
#define ELF_EM_PPC          0x0014  // PowerPC
#define ELF_EM_PPC64        0x0015  // 64-bit PowerPC
#define ELF_EM_ARM          0x0028  // ARM
#define ELF_EM_X86_64       0x003E  // AMD/Intel x86_64
#define ELF_EM_AARCH64      0x00B7  // 64-bit ARM

#define ELF_CLASS_NONE  0x0000
#define ELF_CLASS_32    0x0001  // 32bit file
#define ELF_CLASS_64    0x0002  // 64bit file

#define ELF_DATA_NONE   0x0000
#define ELF_DATA_2LSB   0x0001
#define ELF_DATA_2MSB   0x002


#define ELF_SHT_NULL         0     // Section header table entry unused
#define ELF_SHT_PROGBITS     1     // Program data
#define ELF_SHT_SYMTAB       2     // Symbol table
#define ELF_SHT_STRTAB       3     // String table
#define ELF_SHT_RELA         4     // Relocation entries with addends
#define ELF_SHT_HASH         5     // Symbol hash table
#define ELF_SHT_DYNAMIC      6     // Dynamic linking information
#define ELF_SHT_NOTE         7     // Notes
#define ELF_SHT_NOBITS       8     // Program space with no data (bss)
#define ELF_SHT_REL          9     // Relocation entries, no addends
#define ELF_SHT_SHLIB        10    // Reserved
#define ELF_SHT_DYNSYM       11    // Dynamic linker symbol table
#define ELF_SHT_NUM          12    // Number of defined types

#define ELF_SHF_WRITE        0x1   // Section is writable
#define ELF_SHF_ALLOC        0x2   // Section is present during execution
#define ELF_SHF_EXECINSTR    0x4   // Section contains executable instructions

#define ELF_SHN_LORESERVE    0xFF00

#define ELF_PT_NULL          0     // The array element is unused
#define ELF_PT_LOAD          1     // Loadable segment
#define ELF_PT_DYNAMIC       2     // Segment contains dynamic linking info
#define ELF_PT_INTERP        3     // Contains interpreter pathname
#define ELF_PT_NOTE          4     // Location & size of auxiliary info
#define ELF_PT_SHLIB         5     // Reserved, unspecified semantics
#define ELF_PT_PHDR          6     // Location and size of program header table
#define ELF_PT_TLS           7     // Thread-Local Storage
#define ELF_PT_GNU_EH_FRAME  0x6474e550
#define ELF_PT_GNU_STACK     0x6474e551

#define ELF_DT_NULL          0     // End of the dynamic entries
#define ELF_DT_NEEDED        1     // Name of needed library
#define ELF_DT_PLTRELSZ      2     // Size in bytes of PLT relocs
#define ELF_DT_PLTGOT        3     // Processor defined value */
#define ELF_DT_HASH          4     // Address of symbol hash table
#define ELF_DT_STRTAB        5     // Address of string table
#define ELF_DT_SYMTAB        6     // Address of symbol table
#define ELF_DT_RELA          7     // Address of Rela relocs
#define ELF_DT_RELASZ        8     // Total size of Rela relocs
#define ELF_DT_RELAENT       9     // Size of one Rela reloc
#define ELF_DT_STRSZ         10    // Size of string table
#define ELF_DT_SYMENT        11    // Size of one symbol table entry
#define ELF_DT_INIT          12    // Address of init function
#define ELF_DT_FINI          13    // Address of termination function
#define ELF_DT_SONAME        14    // Name of shared object
#define ELF_DT_RPATH         15    // Library search path (deprecated)
#define ELF_DT_SYMBOLIC      16    // Start symbol search here
#define ELF_DT_REL           17    // Address of Rel relocs
#define ELF_DT_RELSZ         18    // Total size of Rel relocs
#define ELF_DT_RELENT        19    // Size of one Rel reloc
#define ELF_DT_PLTREL        20    // Type of reloc in PLT
#define ELF_DT_DEBUG         21    // For debugging; unspecified
#define ELF_DT_TEXTREL       22    // Reloc might modify .text
#define ELF_DT_JMPREL        23    // Address of PLT relocs
#define ELF_DT_BIND_NOW      24    // Process relocations of object
#define ELF_DT_INIT_ARRAY    25    // Array with addresses of init fct
#define ELF_DT_FINI_ARRAY    26    // Array with addresses of fini fct
#define ELF_DT_INIT_ARRAYSZ  27    // Size in bytes of DT_INIT_ARRAY
#define ELF_DT_FINI_ARRAYSZ  28    // Size in bytes of DT_FINI_ARRAY
#define ELF_DT_RUNPATH       29    // Library search path
#define ELF_DT_FLAGS         30    // Flags for the object being loaded
#define ELF_DT_ENCODING      32    // Start of encoded range

#define ELF_STT_NOTYPE       0     // Symbol type is unspecified
#define ELF_STT_OBJECT       1     // Symbol is a data object
#define ELF_STT_FUNC         2     // Symbol is a code object
#define ELF_STT_SECTION      3     // Symbol associated with a section
#define ELF_STT_FILE         4     // Symbol's name is file name
#define ELF_STT_COMMON       5     // Symbol is a common data object
#define ELF_STT_TLS          6     // Symbol is thread-local data object

#define ELF_STB_LOCAL        0     // Local symbol
#define ELF_STB_GLOBAL       1     // Global symbol
#define ELF_STB_WEAK         2     // Weak symbol

#define ELF_PF_X             0x1   // Segment is executable
#define ELF_PF_W             0x2   // Segment is writable
#define ELF_PF_R             0x4   // Segment is readable

#define ELF_PN_XNUM          0xffff

#pragma pack(push,1)

typedef struct
{
    uint32_t magic;
    uint8_t _class;
    uint8_t data;
    uint8_t version;
    uint8_t pad[8];
    uint8_t nident;

} elf_ident_t;


typedef struct
{
    elf_ident_t     ident;
    elf32_half_t    type;
    elf32_half_t    machine;
    elf32_word_t    version;
    elf32_addr_t    entry;
    elf32_off_t     ph_offset;
    elf32_off_t     sh_offset;
    elf32_word_t    flags;
    elf32_half_t    header_size;
    elf32_half_t    ph_entry_size;
    elf32_half_t    ph_entry_count;
    elf32_half_t    sh_entry_size;
    elf32_half_t    sh_entry_count;
    elf32_half_t    sh_str_table_index;

} elf32_header_t;


typedef struct
{
    elf_ident_t     ident;
    elf64_half_t    type;
    elf64_half_t    machine;
    elf64_word_t    version;
    elf64_addr_t    entry;
    elf64_off_t     ph_offset;
    elf64_off_t     sh_offset;
    elf64_word_t    flags;
    elf64_half_t    header_size;
    elf64_half_t    ph_entry_size;
    elf64_half_t    ph_entry_count;
    elf64_half_t    sh_entry_size;
    elf64_half_t    sh_entry_count;
    elf64_half_t    sh_str_table_index;

} elf64_header_t;


typedef struct
{
    elf32_word_t    type;
    elf32_off_t     offset;
    elf32_addr_t    virt_addr;
    elf32_addr_t    phys_addr;
    elf32_word_t    file_size;
    elf32_word_t    mem_size;
    elf32_word_t    flags;
    elf32_word_t    alignment;

} elf32_program_header_t;


typedef struct
{
    elf64_word_t    type;
    elf64_word_t    flags;
    elf64_off_t     offset;
    elf64_addr_t    virt_addr;
    elf64_addr_t    phys_addr;
    elf64_xword_t   file_size;
    elf64_xword_t   mem_size;
    elf64_xword_t   alignment;

} elf64_program_header_t;


typedef struct
{
    elf32_word_t    name;
    elf32_word_t    type;
    elf32_word_t    flags;
    elf32_addr_t    addr;
    elf32_off_t     offset;
    elf32_word_t    size;
    elf32_word_t    link;
    elf32_word_t    info;
    elf32_word_t    align;
    elf32_word_t    entry_size;

} elf32_section_header_t;


typedef struct
{
    elf64_word_t    name;
    elf64_word_t    type;
    elf64_xword_t   flags;
    elf64_addr_t    addr;
    elf64_off_t     offset;
    elf64_xword_t   size;
    elf64_word_t    link;
    elf64_word_t    info;
    elf64_xword_t   align;
    elf64_xword_t   entry_size;

} elf64_section_header_t;


typedef struct
{
    elf32_word_t    tag;
    elf32_word_t    val;

} elf32_dyn_t;


typedef struct
{
    elf64_xword_t   tag;
    elf64_xword_t   val;

} elf64_dyn_t;


typedef struct
{
    elf32_word_t    name;
    elf32_addr_t    value;
    elf32_word_t    size;
    unsigned char   info;
    unsigned char   other;
    elf32_half_t    shndx;

} elf32_sym_t;


typedef struct
{
    elf32_word_t    name;
    unsigned char   info;
    unsigned char   other;
    elf32_half_t    shndx;
    elf64_addr_t    value;
    elf64_xword_t   size;

} elf64_sym_t;


#pragma pack(pop)

#endif



================================================
File: pluginsdk/yara/yara/endian.h
================================================
/*
Copyright (c) 2016. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ENDIAN_H
#define YR_ENDIAN_H

#include <yara/integers.h>


#if defined(__has_builtin)
#  if __has_builtin(__builtin_bswap16)
#    define yr_bswap16(x) __builtin_bswap16(x)
#  endif
#endif

#if !defined(yr_bswap16) && defined(_MSC_VER)
#  define yr_bswap16(x) _byteswap_ushort(x)
#endif

#if !defined(yr_bswap16)
uint16_t _yr_bswap16(uint16_t x);
# define yr_bswap16(x) _yr_bswap16(x)
#endif


#if defined(__has_builtin)
#  if __has_builtin(__builtin_bswap32)
#    define yr_bswap32(x) __builtin_bswap32(x)
#  endif
#endif

#if !defined(yr_bswap32) && defined(_MSC_VER)
#  define yr_bswap32(x) _byteswap_ulong(x)
#endif

#if !defined(yr_bswap32)
uint32_t _yr_bswap32(uint32_t x);
#define yr_bswap32(x) _yr_bswap32(x)
#endif


#if defined(__has_builtin)
#  if __has_builtin(__builtin_bswap64)
#    define yr_bswap64(x) __builtin_bswap64(x)
#  endif
#endif

#if !defined(yr_bswap64) && defined(_MSC_VER)
#  define yr_bswap64(x) _byteswap_uint64(x)
#endif

#if !defined(yr_bswap64)
uint64_t _yr_bswap64(uint64_t x);
#define yr_bswap64(x) _yr_bswap64(x)
#endif


#if defined(WORDS_BIGENDIAN)
#define yr_le16toh(x) yr_bswap16(x)
#define yr_le32toh(x) yr_bswap32(x)
#define yr_le64toh(x) yr_bswap64(x)
#define yr_be16toh(x) (x)
#define yr_be32toh(x) (x)
#define yr_be64toh(x) (x)
#else
#define yr_le16toh(x) (x)
#define yr_le32toh(x) (x)
#define yr_le64toh(x) (x)
#define yr_be16toh(x) yr_bswap16(x)
#define yr_be32toh(x) yr_bswap32(x)
#define yr_be64toh(x) yr_bswap64(x)
#endif

#endif



================================================
File: pluginsdk/yara/yara/error.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ERROR_H
#define YR_ERROR_H

#include <string.h>

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#endif

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS                           0
#endif

// ERROR_INSUFICIENT_MEMORY is misspelled but it's kept for backward
// compatibility, as some other programs can be using it in this form.
#define ERROR_INSUFICIENT_MEMORY                1

#define ERROR_INSUFFICIENT_MEMORY               1
#define ERROR_COULD_NOT_ATTACH_TO_PROCESS       2
#define ERROR_COULD_NOT_OPEN_FILE               3
#define ERROR_COULD_NOT_MAP_FILE                4
#define ERROR_INVALID_FILE                      6
#define ERROR_CORRUPT_FILE                      7
#define ERROR_UNSUPPORTED_FILE_VERSION          8
#define ERROR_INVALID_REGULAR_EXPRESSION        9
#define ERROR_INVALID_HEX_STRING                10
#define ERROR_SYNTAX_ERROR                      11
#define ERROR_LOOP_NESTING_LIMIT_EXCEEDED       12
#define ERROR_DUPLICATED_LOOP_IDENTIFIER        13
#define ERROR_DUPLICATED_IDENTIFIER             14
#define ERROR_DUPLICATED_TAG_IDENTIFIER         15
#define ERROR_DUPLICATED_META_IDENTIFIER        16
#define ERROR_DUPLICATED_STRING_IDENTIFIER      17
#define ERROR_UNREFERENCED_STRING               18
#define ERROR_UNDEFINED_STRING                  19
#define ERROR_UNDEFINED_IDENTIFIER              20
#define ERROR_MISPLACED_ANONYMOUS_STRING        21
#define ERROR_INCLUDES_CIRCULAR_REFERENCE       22
#define ERROR_INCLUDE_DEPTH_EXCEEDED            23
#define ERROR_WRONG_TYPE                        24
#define ERROR_EXEC_STACK_OVERFLOW               25
#define ERROR_SCAN_TIMEOUT                      26
#define ERROR_TOO_MANY_SCAN_THREADS             27
#define ERROR_CALLBACK_ERROR                    28
#define ERROR_INVALID_ARGUMENT                  29
#define ERROR_TOO_MANY_MATCHES                  30
#define ERROR_INTERNAL_FATAL_ERROR              31
#define ERROR_NESTED_FOR_OF_LOOP                32
#define ERROR_INVALID_FIELD_NAME                33
#define ERROR_UNKNOWN_MODULE                    34
#define ERROR_NOT_A_STRUCTURE                   35
#define ERROR_NOT_INDEXABLE                     36
#define ERROR_NOT_A_FUNCTION                    37
#define ERROR_INVALID_FORMAT                    38
#define ERROR_TOO_MANY_ARGUMENTS                39
#define ERROR_WRONG_ARGUMENTS                   40
#define ERROR_WRONG_RETURN_TYPE                 41
#define ERROR_DUPLICATED_STRUCTURE_MEMBER       42
#define ERROR_EMPTY_STRING                      43
#define ERROR_DIVISION_BY_ZERO                  44
#define ERROR_REGULAR_EXPRESSION_TOO_LARGE      45
#define ERROR_TOO_MANY_RE_FIBERS                46
#define ERROR_COULD_NOT_READ_PROCESS_MEMORY     47
#define ERROR_INVALID_EXTERNAL_VARIABLE_TYPE    48
#define ERROR_REGULAR_EXPRESSION_TOO_COMPLEX    49
#define ERROR_INVALID_MODULE_NAME               50


#define FAIL_ON_ERROR(x) { \
  int result = (x); \
  if (result != ERROR_SUCCESS) \
    return result; \
}

#define FAIL_ON_ERROR_WITH_CLEANUP(x, cleanup) { \
  int result = (x); \
  if (result != ERROR_SUCCESS) { \
    cleanup; \
    return result; \
  } \
}

#define FAIL_ON_COMPILER_ERROR(x) { \
  compiler->last_result = (x); \
  if (compiler->last_result != ERROR_SUCCESS) \
    return compiler->last_result; \
}


#ifdef NDEBUG
#define assertf(expr, msg, ...)  ((void)0)
#else
#define assertf(expr, msg, ...) \
    if(!(expr)) { \
      fprintf(stderr, "%s:%d: " msg "\n", __FILE__, __LINE__, ##__VA_ARGS__); \
      abort(); \
    }
#endif

#endif



================================================
File: pluginsdk/yara/yara/exec.h
================================================
/*
Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_EXEC_H
#define YR_EXEC_H

#include "hash.h"
#include "scan.h"
#include "types.h"
#include "rules.h"


#define UNDEFINED           0xFFFABADAFABADAFFLL
#define IS_UNDEFINED(x)     ((size_t)(x) == (size_t) UNDEFINED)

#define OP_ERROR          0
#define OP_HALT           255
#define OP_NOP            254

#define OP_AND            1
#define OP_OR             2
#define OP_NOT            3
#define OP_BITWISE_NOT    4
#define OP_BITWISE_AND    5
#define OP_BITWISE_OR     6
#define OP_BITWISE_XOR    7
#define OP_SHL            8
#define OP_SHR            9
#define OP_MOD            10
#define OP_INT_TO_DBL     11
#define OP_STR_TO_BOOL    12
#define OP_PUSH           13
#define OP_POP            14
#define OP_CALL           15
#define OP_OBJ_LOAD       16
#define OP_OBJ_VALUE      17
#define OP_OBJ_FIELD      18
#define OP_INDEX_ARRAY    19
#define OP_COUNT          20
#define OP_LENGTH         21
#define OP_FOUND          22
#define OP_FOUND_AT       23
#define OP_FOUND_IN       24
#define OP_OFFSET         25
#define OP_OF             26
#define OP_PUSH_RULE      27
#define OP_INIT_RULE      28
#define OP_MATCH_RULE     29
#define OP_INCR_M         30
#define OP_CLEAR_M        31
#define OP_ADD_M          32
#define OP_POP_M          33
#define OP_PUSH_M         34
#define OP_SWAPUNDEF      35
#define OP_JNUNDEF        36
#define OP_JLE            37
#define OP_FILESIZE       38
#define OP_ENTRYPOINT     39
#define OP_CONTAINS       40
#define OP_MATCHES        41
#define OP_IMPORT         42
#define OP_LOOKUP_DICT    43
#define OP_JFALSE         44
#define OP_JTRUE          45


#define _OP_EQ            0
#define _OP_NEQ           1
#define _OP_LT            2
#define _OP_GT            3
#define _OP_LE            4
#define _OP_GE            5
#define _OP_ADD           6
#define _OP_SUB           7
#define _OP_MUL           8
#define _OP_DIV           9
#define _OP_MINUS         10


#define OP_INT_BEGIN      100
#define OP_INT_EQ         (OP_INT_BEGIN + _OP_EQ)
#define OP_INT_NEQ        (OP_INT_BEGIN + _OP_NEQ)
#define OP_INT_LT         (OP_INT_BEGIN + _OP_LT)
#define OP_INT_GT         (OP_INT_BEGIN + _OP_GT)
#define OP_INT_LE         (OP_INT_BEGIN + _OP_LE)
#define OP_INT_GE         (OP_INT_BEGIN + _OP_GE)
#define OP_INT_ADD        (OP_INT_BEGIN + _OP_ADD)
#define OP_INT_SUB        (OP_INT_BEGIN + _OP_SUB)
#define OP_INT_MUL        (OP_INT_BEGIN + _OP_MUL)
#define OP_INT_DIV        (OP_INT_BEGIN + _OP_DIV)
#define OP_INT_MINUS      (OP_INT_BEGIN + _OP_MINUS)
#define OP_INT_END        OP_INT_MINUS

#define OP_DBL_BEGIN      120
#define OP_DBL_EQ         (OP_DBL_BEGIN + _OP_EQ)
#define OP_DBL_NEQ        (OP_DBL_BEGIN + _OP_NEQ)
#define OP_DBL_LT         (OP_DBL_BEGIN + _OP_LT)
#define OP_DBL_GT         (OP_DBL_BEGIN + _OP_GT)
#define OP_DBL_LE         (OP_DBL_BEGIN + _OP_LE)
#define OP_DBL_GE         (OP_DBL_BEGIN + _OP_GE)
#define OP_DBL_ADD        (OP_DBL_BEGIN + _OP_ADD)
#define OP_DBL_SUB        (OP_DBL_BEGIN + _OP_SUB)
#define OP_DBL_MUL        (OP_DBL_BEGIN + _OP_MUL)
#define OP_DBL_DIV        (OP_DBL_BEGIN + _OP_DIV)
#define OP_DBL_MINUS      (OP_DBL_BEGIN + _OP_MINUS)
#define OP_DBL_END        OP_DBL_MINUS

#define OP_STR_BEGIN      140
#define OP_STR_EQ         (OP_STR_BEGIN + _OP_EQ)
#define OP_STR_NEQ        (OP_STR_BEGIN + _OP_NEQ)
#define OP_STR_LT         (OP_STR_BEGIN + _OP_LT)
#define OP_STR_GT         (OP_STR_BEGIN + _OP_GT)
#define OP_STR_LE         (OP_STR_BEGIN + _OP_LE)
#define OP_STR_GE         (OP_STR_BEGIN + _OP_GE)
#define OP_STR_END        OP_STR_GE

#define IS_INT_OP(x)      ((x) >= OP_INT_BEGIN && (x) <= OP_INT_END)
#define IS_DBL_OP(x)      ((x) >= OP_DBL_BEGIN && (x) <= OP_DBL_END)
#define IS_STR_OP(x)      ((x) >= OP_STR_BEGIN && (x) <= OP_STR_END)

#define OP_READ_INT       240
#define OP_INT8           (OP_READ_INT + 0)
#define OP_INT16          (OP_READ_INT + 1)
#define OP_INT32          (OP_READ_INT + 2)
#define OP_UINT8          (OP_READ_INT + 3)
#define OP_UINT16         (OP_READ_INT + 4)
#define OP_UINT32         (OP_READ_INT + 5)
#define OP_INT8BE         (OP_READ_INT + 6)
#define OP_INT16BE        (OP_READ_INT + 7)
#define OP_INT32BE        (OP_READ_INT + 8)
#define OP_UINT8BE        (OP_READ_INT + 9)
#define OP_UINT16BE       (OP_READ_INT + 10)
#define OP_UINT32BE       (OP_READ_INT + 11)


#define OPERATION(operator, op1, op2) \
    (IS_UNDEFINED(op1) || IS_UNDEFINED(op2)) ? (UNDEFINED) : (op1 operator op2)


#define COMPARISON(operator, op1, op2) \
    (IS_UNDEFINED(op1) || IS_UNDEFINED(op2)) ? (0) : (op1 operator op2)


int yr_execute_code(
    YR_RULES* rules,
    YR_SCAN_CONTEXT* context,
    int timeout,
    time_t start_time);

#endif



================================================
File: pluginsdk/yara/yara/exefiles.h
================================================
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_EXEFILES_H
#define YR_EXEFILES_H

uint64_t yr_get_entry_point_offset(
    uint8_t* buffer,
    size_t buffer_length);


uint64_t yr_get_entry_point_address(
    uint8_t* buffer,
    size_t buffer_length,
    size_t base_address);

#endif



================================================
File: pluginsdk/yara/yara/filemap.h
================================================
/*
Copyright (c) 2007-2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_FILEMAP_H
#define YR_FILEMAP_H

#ifdef _MSC_VER
#define off_t              int64_t
#else
#include <sys/types.h>
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#define YR_FILE_DESCRIPTOR    HANDLE
#else
#define YR_FILE_DESCRIPTOR    int
#endif

#include <stdlib.h>

#include "integers.h"
#include "utils.h"


typedef struct _YR_MAPPED_FILE
{
    YR_FILE_DESCRIPTOR  file;
    size_t              size;
    uint8_t*            data;
#if defined(_WIN32) || defined(__CYGWIN__)
    HANDLE              mapping;
#endif

} YR_MAPPED_FILE;


YR_API int yr_filemap_map(
    const char* file_path,
    YR_MAPPED_FILE* pmapped_file);


YR_API int yr_filemap_map_fd(
    YR_FILE_DESCRIPTOR file,
    off_t offset,
    size_t size,
    YR_MAPPED_FILE* pmapped_file);


YR_API int yr_filemap_map_ex(
    const char* file_path,
    off_t offset,
    size_t size,
    YR_MAPPED_FILE* pmapped_file);


YR_API void yr_filemap_unmap(
    YR_MAPPED_FILE* pmapped_file);


YR_API void yr_filemap_unmap_fd(
    YR_MAPPED_FILE* pmapped_file);

#endif



================================================
File: pluginsdk/yara/yara/globals.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_GLOBALS_H
#define YR_GLOBALS_H

#include "threading.h"

extern char yr_lowercase[256];
extern char yr_altercase[256];

extern YR_THREAD_STORAGE_KEY yr_tidx_key;
extern YR_THREAD_STORAGE_KEY yr_recovery_state_key;

#endif



================================================
File: pluginsdk/yara/yara/hash.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_HASH_H
#define YR_HASH_H

#include <stddef.h>

#include "utils.h"

typedef struct _YR_HASH_TABLE_ENTRY
{
    void* key;
    size_t key_length;
    char* ns;
    void* value;

    struct _YR_HASH_TABLE_ENTRY* next;

} YR_HASH_TABLE_ENTRY;


typedef struct _YR_HASH_TABLE
{
    int size;

    YR_HASH_TABLE_ENTRY* buckets[1];

} YR_HASH_TABLE;


typedef int (*YR_HASH_TABLE_FREE_VALUE_FUNC)(void* value);


YR_API int yr_hash_table_create(
    int size,
    YR_HASH_TABLE** table);


YR_API void yr_hash_table_clean(
    YR_HASH_TABLE* table,
    YR_HASH_TABLE_FREE_VALUE_FUNC free_value);


YR_API void yr_hash_table_destroy(
    YR_HASH_TABLE* table,
    YR_HASH_TABLE_FREE_VALUE_FUNC free_value);


YR_API void* yr_hash_table_lookup(
    YR_HASH_TABLE* table,
    const char* key,
    const char* ns);


YR_API int yr_hash_table_add(
    YR_HASH_TABLE* table,
    const char* key,
    const char* ns,
    void* value);


YR_API void* yr_hash_table_lookup_raw_key(
    YR_HASH_TABLE* table,
    const void* key,
    size_t key_length,
    const char* ns);


YR_API int yr_hash_table_add_raw_key(
    YR_HASH_TABLE* table,
    const void* key,
    size_t key_length,
    const char* ns,
    void* value);

#endif



================================================
File: pluginsdk/yara/yara/hex_lexer.h
================================================
/*
Copyright (c) 2007. Victor M. Alvarez [plusvic@gmail.com].

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "re.h"

#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_FATAL_ERROR
#undef YY_DECL
#undef LEX_ENV

#define yyparse         hex_yyparse
#define yylex           hex_yylex
#define yyerror         hex_yyerror
#define yyfatal         hex_yyfatal
#define yychar          hex_yychar
#define yydebug         hex_yydebug
#define yynerrs         hex_yynerrs
#define yyget_extra     hex_yyget_extra
#define yyget_lineno    hex_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#define YY_EXTRA_TYPE RE_AST*
#define YY_USE_CONST


typedef struct _HEX_LEX_ENVIRONMENT
{
    int token_count;
    int inside_or;
    int last_error_code;
    char last_error_message[256];

} HEX_LEX_ENVIRONMENT;


#define YY_FATAL_ERROR(msg) hex_yyfatal(yyscanner, msg)

#define LEX_ENV  ((HEX_LEX_ENVIRONMENT*) lex_env)

#include <hex_grammar.h>

#define YY_DECL int hex_yylex \
    (YYSTYPE * yylval_param , yyscan_t yyscanner, HEX_LEX_ENVIRONMENT* lex_env)


YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yylex(
    YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env);

int yyparse(
    void* yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env);

void yyerror(
    yyscan_t yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env,
    const char* error_message);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

int yr_parse_hex_string(
    const char* hex_string,
    RE_AST** re_ast,
    RE_ERROR* error);



================================================
File: pluginsdk/yara/yara/integers.h
================================================
/*
Copyright (c) 2007-2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_INTEGERS_H
#define YR_INTEGERS_H

/* Integer type definitions
 */
#if ( defined( _MSC_VER ) && ( _MSC_VER < 1600 ) ) || ( defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 ) )

#ifdef __cplusplus
extern "C" {
#endif

/* Microsoft Visual Studio C++ before Visual Studio 2010 or earlier versions of the Borland C++ Builder
 * do not support the (u)int#_t type definitions but have __int# definitions instead
 */
typedef __int8 int8_t;
typedef unsigned __int8 uint8_t;
typedef __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;

#ifdef __cplusplus
}
#endif

#else

/* Other "compilers" and later versions of Microsoft Visual Studio C++ and
 * Borland C/C++ define the types in <stdint.h>
 */
#include <stdint.h>

#endif

#endif



================================================
File: pluginsdk/yara/yara/lexer.h
================================================
/*
Copyright (c) 2007. Victor M. Alvarez [plusvic@gmail.com].

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "compiler.h"


#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_DECL
#undef YY_FATAL_ERROR
#undef YY_EXTRA_TYPE

#define yyparse       yara_yyparse
#define yylex         yara_yylex
#define yyerror       yara_yyerror
#define yyfatal       yara_yyfatal
#define yywarning     yara_yywarning
#define yychar        yara_yychar
#define yydebug       yara_yydebug
#define yynerrs       yara_yynerrs
#define yyget_extra   yara_yyget_extra
#define yyget_lineno  yara_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#ifndef YY_TYPEDEF_EXPRESSION_T
#define YY_TYPEDEF_EXPRESSION_T


// Expression type constants are powers of two because they are used as flags.
// For example:
//   CHECK_TYPE(whatever, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT)
// The expression above is used to ensure that the type of "whatever" is either
// integer or float.

#define EXPRESSION_TYPE_BOOLEAN   1
#define EXPRESSION_TYPE_INTEGER   2
#define EXPRESSION_TYPE_STRING    4
#define EXPRESSION_TYPE_REGEXP    8
#define EXPRESSION_TYPE_OBJECT    16
#define EXPRESSION_TYPE_FLOAT     32

typedef struct _EXPRESSION
{
    int type;

    union
    {
        int64_t integer;
        YR_OBJECT* object;
        SIZED_STRING* sized_string;
    } value;

    const char* identifier;

} EXPRESSION;

union YYSTYPE;

#endif


#define YY_DECL int yylex( \
    union YYSTYPE* yylval_param, yyscan_t yyscanner, YR_COMPILER* compiler)


#define YY_FATAL_ERROR(msg) yara_yyfatal(yyscanner, msg)


#define YY_EXTRA_TYPE YR_COMPILER*
#define YY_USE_CONST


int yyget_lineno(yyscan_t yyscanner);

int yylex(
    union YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    YR_COMPILER* compiler);

int yyparse(
    void* yyscanner,
    YR_COMPILER* compiler);

void yyerror(
    yyscan_t yyscanner,
    YR_COMPILER* compiler,
    const char* error_message);

void yywarning(
    yyscan_t yyscanner,
    const char* message_fmt,
    ...);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yr_lex_parse_rules_string(
    const char* rules_string,
    YR_COMPILER* compiler);

int yr_lex_parse_rules_file(
    FILE* rules_file,
    YR_COMPILER* compiler);

int yr_lex_parse_rules_fd(
    YR_FILE_DESCRIPTOR rules_fd,
    YR_COMPILER* compiler);



================================================
File: pluginsdk/yara/yara/libyara.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_LIBYARA_H
#define YR_LIBYARA_H

#include "utils.h"

#define YR_MAJOR_VERSION   3
#define YR_MINOR_VERSION   6
#define YR_MICRO_VERSION   0

#define version_str(s) _version_str(s)
#define _version_str(s) #s

// Version as a string
#define YR_VERSION version_str(YR_MAJOR_VERSION) \
    "." version_str(YR_MINOR_VERSION) \
    "." version_str(YR_MICRO_VERSION)

// Version as a single 4-byte hex number, e.g. 0x030401 == 3.4.1.
#define YR_VERSION_HEX ((YR_MAJOR_VERSION << 16) | \
    (YR_MINOR_VERSION << 8) | \
    (YR_MICRO_VERSION << 0))


// Enumerated type listing configuration options
typedef enum _YR_CONFIG_NAME
{
    YR_CONFIG_STACK_SIZE,
    YR_CONFIG_MAX

} YR_CONFIG_NAME;


#define DEFAULT_STACK_SIZE 16384


YR_API int yr_initialize(void);


YR_API int yr_finalize(void);


YR_API void yr_finalize_thread(void);


YR_API int yr_get_tidx(void);


YR_API void yr_set_tidx(int);


YR_API int yr_set_configuration(YR_CONFIG_NAME, void*);


YR_API int yr_get_configuration(YR_CONFIG_NAME, void*);

#endif



================================================
File: pluginsdk/yara/yara/limits.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_LIMITS_H
#define YR_LIMITS_H

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#endif

#include "utils.h"

// MAX_THREADS is the number of threads that can use a YR_RULES
// object simultaneously.

#ifndef MAX_THREADS
#define MAX_THREADS 32
#endif


#ifndef MAX_PATH
#define MAX_PATH 1024
#endif

#define MAX_COMPILER_ERROR_EXTRA_INFO   256
#define MAX_ATOM_LENGTH                 4
#define MAX_LOOP_NESTING                4
#define MAX_ARENA_PAGES                 32
#define MAX_INCLUDE_DEPTH               16
#define MAX_STRING_MATCHES              1000000
#define MAX_FUNCTION_ARGS               128
#define MAX_FAST_RE_STACK               300
#define MAX_OVERLOADED_FUNCTIONS        10
#define MAX_HEX_STRING_TOKENS           10000
#define MAX_MATCH_DATA                  4096

#define LOOP_LOCAL_VARS                 4
#define STRING_CHAINING_THRESHOLD       200
#define LEX_BUF_SIZE                    8192


#endif



================================================
File: pluginsdk/yara/yara/mem.h
================================================
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MEM_H
#define YR_MEM_H

#include <stdio.h>

#ifdef DMALLOC

#define yr_malloc malloc
#define yr_calloc calloc
#define yr_realloc realloc
#define yr_free free
#define yr_strdup strdup
#define yr_strndup strndup

#include <dmalloc.h>

#else

void* yr_calloc(
    size_t count,
    size_t size);

void* yr_malloc(
    size_t size);

void* yr_realloc(
    void* ptr,
    size_t size);

void yr_free(
    void* ptr);

char* yr_strdup(
    const char* str);

char* yr_strndup(
    const char* str, size_t n);

#endif

int yr_heap_alloc(void);

int yr_heap_free(void);

#endif



================================================
File: pluginsdk/yara/yara/modules.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MODULES_H
#define YR_MODULES_H

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "limits.h"
#include "error.h"
#include "exec.h"
#include "types.h"
#include "object.h"
#include "libyara.h"

// Concatenation that macro-expands its arguments.

#define YR_CONCAT(arg1, arg2) _YR_CONCAT(arg1, arg2) // expands the arguments.
#define _YR_CONCAT(arg1, arg2) arg1 ## arg2  // do the actual concatenation.


#define module_declarations YR_CONCAT(MODULE_NAME, __declarations)
#define module_load YR_CONCAT(MODULE_NAME, __load)
#define module_unload YR_CONCAT(MODULE_NAME, __unload)
#define module_initialize YR_CONCAT(MODULE_NAME, __initialize)
#define module_finalize YR_CONCAT(MODULE_NAME, __finalize)

#define begin_declarations \
    int module_declarations(YR_OBJECT* module) { \
      YR_OBJECT* stack[64]; \
      int stack_top = 0; \
      stack[stack_top] = module;


#define end_declarations \
    return ERROR_SUCCESS; }


#define begin_struct(name) { \
    YR_OBJECT* structure; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        stack[stack_top], \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define begin_struct_array(name) { \
    YR_OBJECT* structure; \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        array, \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define begin_struct_dictionary(name) { \
    YR_OBJECT* structure; \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        array, \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define end_struct(name) { \
    assert(stack[stack_top]->type == OBJECT_TYPE_STRUCTURE); \
    assertf( \
        strcmp(stack[stack_top]->identifier, name) == 0, \
        "unbalanced begin_struct/end_struct"); \
    stack_top--; \
  }


#define end_struct_array(name) end_struct(name)


#define end_struct_dictionary(name) end_struct(name)


#define declare_integer(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_integer_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        array, \
        NULL)); \
  }


#define declare_integer_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_float(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_float_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        array, \
        NULL)); \
  }


#define declare_float_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_string(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_string_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        array, \
        NULL)); \
  }


#define declare_string_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_function(name, args_fmt, ret_fmt, func) { \
    YR_OBJECT* function; \
    FAIL_ON_ERROR(yr_object_function_create( \
        name, \
        args_fmt, \
        ret_fmt, \
        func, \
        stack[stack_top], \
        &function)); \
    }


#define define_function(func) \
    int func ( \
        YR_VALUE* __args, \
        YR_SCAN_CONTEXT* __context, \
        YR_OBJECT_FUNCTION* __function_obj)


#define sized_string_argument(n) \
    (__args[n-1].ss)

#define string_argument(n) \
    (sized_string_argument(n)->c_string)

#define integer_argument(n) \
    (__args[n-1].i)

#define float_argument(n) \
    (__args[n-1].d)

#define regexp_argument(n) \
    ((RE*)(__args[n-1].re))


#define module()        yr_object_get_root((YR_OBJECT*) __function_obj)
#define parent()        (__function_obj->parent)
#define scan_context()  (__context)


#define foreach_memory_block(iterator, block) \
  for (block = iterator->first(iterator); \
       block != NULL; \
       block = iterator->next(iterator)) \
 

#define first_memory_block(context) \
      (context)->iterator->first((context)->iterator)


#define is_undefined(object, ...) \
    yr_object_has_undefined_value(object, __VA_ARGS__)


#define get_object(object, ...) \
    yr_object_lookup(object, 0, __VA_ARGS__)


#define get_integer(object, ...) \
    yr_object_get_integer(object, __VA_ARGS__)


#define get_float(object, ...) \
    yr_object_get_float(object, __VA_ARGS__)


#define get_string(object, ...) \
    yr_object_get_string(object, __VA_ARGS__)


#define set_integer(value, object, ...) \
    yr_object_set_integer(value, object, __VA_ARGS__)


#define set_float(value, object, ...) \
    yr_object_set_float(value, object, __VA_ARGS__)


#define set_sized_string(value, len, object, ...) \
    yr_object_set_string(value, len, object, __VA_ARGS__)


#define set_string(value, object, ...) \
    set_sized_string(value, strlen(value), object, __VA_ARGS__)


#define return_integer(integer) { \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_INTEGER, \
          "return type differs from function declaration"); \
      yr_object_set_integer( \
          (integer), \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


#define return_float(double_) { \
      double d = (double) (double_); \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_FLOAT, \
          "return type differs from function declaration"); \
      yr_object_set_float( \
          (d != (double) UNDEFINED) ? d : NAN, \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


#define return_string(string) { \
      char* s = (char*) (string); \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_STRING, \
          "return type differs from function declaration"); \
      yr_object_set_string( \
          (s != (char*) UNDEFINED) ? s : NULL, \
          (s != (char*) UNDEFINED) ? strlen(s) : 0, \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


struct _YR_MODULE;


typedef int (*YR_EXT_INITIALIZE_FUNC)(
    struct _YR_MODULE* module);


typedef int (*YR_EXT_FINALIZE_FUNC)(
    struct _YR_MODULE* module);


typedef int (*YR_EXT_DECLARATIONS_FUNC)(
    YR_OBJECT* module_object);


typedef int (*YR_EXT_LOAD_FUNC)(
    YR_SCAN_CONTEXT* context,
    YR_OBJECT* module_object,
    void* module_data,
    size_t module_data_size);


typedef int (*YR_EXT_UNLOAD_FUNC)(
    YR_OBJECT* module_object);


typedef struct _YR_MODULE
{
    char* name;

    YR_EXT_DECLARATIONS_FUNC declarations;
    YR_EXT_LOAD_FUNC load;
    YR_EXT_UNLOAD_FUNC unload;
    YR_EXT_INITIALIZE_FUNC initialize;
    YR_EXT_FINALIZE_FUNC finalize;

} YR_MODULE;


typedef struct _YR_MODULE_IMPORT
{
    const char* module_name;
    void* module_data;
    size_t module_data_size;

} YR_MODULE_IMPORT;


int yr_modules_initialize(void);


int yr_modules_finalize(void);


int yr_modules_do_declarations(
    const char* module_name,
    YR_OBJECT* main_structure);


int yr_modules_load(
    const char* module_name,
    YR_SCAN_CONTEXT* context);


int yr_modules_unload_all(
    YR_SCAN_CONTEXT* context);

#endif



================================================
File: pluginsdk/yara/yara/object.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_OBJECT_H
#define YR_OBJECT_H

#ifdef _MSC_VER

#include <float.h>
#ifndef isnan
#define isnan _isnan
#endif

#ifndef INFINITY
#define INFINITY (DBL_MAX + DBL_MAX)
#endif

#ifndef NAN
#define NAN (INFINITY-INFINITY)
#endif

#endif

#include "types.h"


#define OBJECT_CREATE           1

#define OBJECT_TYPE_INTEGER     1
#define OBJECT_TYPE_STRING      2
#define OBJECT_TYPE_STRUCTURE   3
#define OBJECT_TYPE_ARRAY       4
#define OBJECT_TYPE_FUNCTION    5
#define OBJECT_TYPE_DICTIONARY  6
#define OBJECT_TYPE_FLOAT       7


int yr_object_create(
    int8_t type,
    const char* identifier,
    YR_OBJECT* parent,
    YR_OBJECT** object);


int yr_object_function_create(
    const char* identifier,
    const char* arguments_fmt,
    const char* return_fmt,
    YR_MODULE_FUNC func,
    YR_OBJECT* parent,
    YR_OBJECT** function);


int yr_object_from_external_variable(
    YR_EXTERNAL_VARIABLE* external,
    YR_OBJECT** object);


void yr_object_destroy(
    YR_OBJECT* object);


int yr_object_copy(
    YR_OBJECT* object,
    YR_OBJECT** object_copy);


YR_OBJECT* yr_object_lookup_field(
    YR_OBJECT* object,
    const char* field_name);


YR_OBJECT* yr_object_lookup(
    YR_OBJECT* root,
    int flags,
    const char* pattern,
    ...);


int yr_object_has_undefined_value(
    YR_OBJECT* object,
    const char* field,
    ...);

int64_t yr_object_get_integer(
    YR_OBJECT* object,
    const char* field,
    ...);


SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_integer(
    int64_t value,
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_float(
    double value,
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...);


YR_OBJECT* yr_object_array_get_item(
    YR_OBJECT* object,
    int flags,
    int index);


int yr_object_array_set_item(
    YR_OBJECT* object,
    YR_OBJECT* item,
    int index);


YR_OBJECT* yr_object_dict_get_item(
    YR_OBJECT* object,
    int flags,
    const char* key);


int yr_object_dict_set_item(
    YR_OBJECT* object,
    YR_OBJECT* item,
    const char* key);


int yr_object_structure_set_member(
    YR_OBJECT* object,
    YR_OBJECT* member);


YR_OBJECT* yr_object_get_root(
    YR_OBJECT* object);


YR_API void yr_object_print_data(
    YR_OBJECT* object,
    int indent,
    int print_identifier);


#endif



================================================
File: pluginsdk/yara/yara/parser.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PARSER_H
#define YR_PARSER_H


#include "lexer.h"


int yr_parser_emit(
    yyscan_t yyscanner,
    uint8_t instruction,
    uint8_t** instruction_address);


int yr_parser_emit_with_arg(
    yyscan_t yyscanner,
    uint8_t instruction,
    int64_t argument,
    uint8_t** instruction_address,
    int64_t** argument_address);


int yr_parser_emit_with_arg_double(
    yyscan_t yyscanner,
    uint8_t instruction,
    double argument,
    uint8_t** instruction_address,
    double** argument_address);


int yr_parser_emit_with_arg_reloc(
    yyscan_t yyscanner,
    uint8_t instruction,
    void* argument,
    uint8_t** instruction_address,
    void** argument_address);


int yr_parser_check_types(
    YR_COMPILER* compiler,
    YR_OBJECT_FUNCTION* function,
    const char* actual_args_fmt);


YR_STRING* yr_parser_lookup_string(
    yyscan_t yyscanner,
    const char* identifier);


int yr_parser_lookup_loop_variable(
    yyscan_t yyscanner,
    const char* identifier);


YR_RULE* yr_parser_reduce_rule_declaration_phase_1(
    yyscan_t yyscanner,
    int32_t flags,
    const char* identifier);


int yr_parser_reduce_rule_declaration_phase_2(
    yyscan_t yyscanner,
    YR_RULE* rule);


YR_STRING* yr_parser_reduce_string_declaration(
    yyscan_t yyscanner,
    int32_t flags,
    const char* identifier,
    SIZED_STRING* str);


YR_META* yr_parser_reduce_meta_declaration(
    yyscan_t yyscanner,
    int32_t type,
    const char* identifier,
    const char* string,
    int64_t integer);


int yr_parser_reduce_string_identifier(
    yyscan_t yyscanner,
    const char* identifier,
    uint8_t instruction,
    uint64_t at_offset);


int yr_parser_emit_pushes_for_strings(
    yyscan_t yyscanner,
    const char* identifier);


int yr_parser_reduce_external(
    yyscan_t yyscanner,
    const char* identifier,
    uint8_t instruction);


int yr_parser_reduce_import(
    yyscan_t yyscanner,
    SIZED_STRING* module_name);


int yr_parser_reduce_operation(
    yyscan_t yyscanner,
    const char* operation,
    EXPRESSION left_operand,
    EXPRESSION right_operand);

#endif



================================================
File: pluginsdk/yara/yara/pe.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PE_H
#define YR_PE_H

#include "endian.h"
#include "types.h"

#pragma pack(push, 1)

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>

// These definitions are not present in older Windows headers.

#ifndef IMAGE_FILE_MACHINE_ARMNT
#define IMAGE_FILE_MACHINE_ARMNT             0x01c4
#endif

#ifndef IMAGE_FILE_MACHINE_ARM64
#define IMAGE_FILE_MACHINE_ARM64             0xaa64
#endif

#else

#include <stdlib.h>

#include "integers.h"

typedef uint8_t   BYTE;
typedef uint16_t  WORD;
typedef uint32_t  DWORD;
typedef int32_t   LONG;
typedef uint32_t  ULONG;
typedef uint64_t  ULONGLONG;


#define FIELD_OFFSET(type, field)    ((size_t)&(((type *)0)->field))

#ifndef _MAC

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_VXD_SIGNATURE                 0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

#else

#define IMAGE_DOS_SIGNATURE                 0x4D5A      // MZ
#define IMAGE_OS2_SIGNATURE                 0x4E45      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x4C45      // LE
#define IMAGE_NT_SIGNATURE                  0x50450000  // PE00

#endif

#pragma pack(push, 2)

typedef struct _IMAGE_DOS_HEADER        // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

#pragma pack(pop)

//
// File header format.
//

#pragma pack(push,4)

typedef struct _IMAGE_FILE_HEADER
{
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;



#define IMAGE_SIZEOF_FILE_HEADER             20


#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved external references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line numbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Aggressively trim working set
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle >2gb addresses
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.


#define IMAGE_FILE_MACHINE_UNKNOWN           0x0000
#define IMAGE_FILE_MACHINE_AM33              0x01d3
#define IMAGE_FILE_MACHINE_AMD64             0x8664
#define IMAGE_FILE_MACHINE_ARM               0x01c0
#define IMAGE_FILE_MACHINE_ARMNT             0x01c4
#define IMAGE_FILE_MACHINE_ARM64             0xaa64
#define IMAGE_FILE_MACHINE_EBC               0x0ebc
#define IMAGE_FILE_MACHINE_I386              0x014c
#define IMAGE_FILE_MACHINE_IA64              0x0200
#define IMAGE_FILE_MACHINE_M32R              0x9041
#define IMAGE_FILE_MACHINE_MIPS16            0x0266
#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366
#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466
#define IMAGE_FILE_MACHINE_POWERPC           0x01f0
#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1
#define IMAGE_FILE_MACHINE_R4000             0x0166
#define IMAGE_FILE_MACHINE_SH3               0x01a2
#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3
#define IMAGE_FILE_MACHINE_SH4               0x01a6
#define IMAGE_FILE_MACHINE_SH5               0x01a8
#define IMAGE_FILE_MACHINE_THUMB             0x01c2
#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169

// Section characteristics
#define IMAGE_SCN_CNT_CODE                   0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080
#define IMAGE_SCN_GPREL                      0x00008000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000
#define IMAGE_SCN_MEM_SHARED                 0x10000000
#define IMAGE_SCN_MEM_EXECUTE                0x20000000
#define IMAGE_SCN_MEM_READ                   0x40000000
#define IMAGE_SCN_MEM_WRITE                  0x80000000

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY
{
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16


#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER32
{
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;


typedef struct _IMAGE_OPTIONAL_HEADER64
{
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;


#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b


typedef struct _IMAGE_NT_HEADERS32
{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;

} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;


typedef struct _IMAGE_NT_HEADERS64
{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;

} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is
// the same either way.

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER) \
    ((BYTE*)ntheader + \
     FIELD_OFFSET( IMAGE_NT_HEADERS32, OptionalHeader ) + \
     yr_le16toh(((PIMAGE_NT_HEADERS32)(ntheader))->FileHeader.SizeOfOptionalHeader) \
    ))

// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN                          0
#define IMAGE_SUBSYSTEM_NATIVE                           1
#define IMAGE_SUBSYSTEM_WINDOWS_GUI                      2
#define IMAGE_SUBSYSTEM_WINDOWS_CUI                      3
#define IMAGE_SUBSYSTEM_OS2_CUI                          5
#define IMAGE_SUBSYSTEM_POSIX_CUI                        7
#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS                   8
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI                   9
#define IMAGE_SUBSYSTEM_EFI_APPLICATION                 10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER         11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER              12
#define IMAGE_SUBSYSTEM_EFI_ROM_IMAGE                   13
#define IMAGE_SUBSYSTEM_XBOX                            14
#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION        16

// DllCharacteristics values

#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE           0x0040
#define IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY        0x0080
#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT              0x0100
#define IMAGE_DLLCHARACTERISTICS_NO_ISOLATION           0x0200
#define IMAGE_DLLCHARACTERISTICS_NO_SEH                 0x0400
#define IMAGE_DLLCHARACTERISTICS_NO_BIND                0x0800
#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER             0x2000
#define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE  0x8000

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER
{
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;

} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40


typedef struct _IMAGE_EXPORT_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;


typedef struct _IMAGE_IMPORT_DESCRIPTOR
{
    union
    {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    } ;
    DWORD TimeDateStamp;
    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;

} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;


typedef struct _IMAGE_IMPORT_BY_NAME
{
    WORD Hint;
    BYTE Name[1];

} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA32
{
    union
    {
        DWORD ForwarderString;
        DWORD Function;
        DWORD Ordinal;
        DWORD AddressOfData;
    } u1;

} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;


#define IMAGE_ORDINAL_FLAG32  0x80000000
#define IMAGE_ORDINAL_FLAG64  0x8000000000000000L

typedef struct _IMAGE_THUNK_DATA64
{
    union
    {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    } u1;

} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;


typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY
{
    DWORD Name;
    DWORD OffsetToData;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;


typedef struct _IMAGE_RESOURCE_DATA_ENTRY
{
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;


typedef struct _IMAGE_RESOURCE_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    WORD  NumberOfNamedEntries;
    WORD  NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#pragma pack(pop)

#endif  // _WIN32

typedef struct _VERSION_INFO
{
    WORD   Length;
    WORD   ValueLength;
    WORD   Type;
    char   Key[0];
} VERSION_INFO, *PVERSION_INFO;


#define WIN_CERT_REVISION_1_0 0x0100
#define WIN_CERT_REVISION_2_0 0x0200

#define WIN_CERT_TYPE_X509             0x0001
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA 0x0002
#define WIN_CERT_TYPE_RESERVED_1       0x0003
#define WIN_CERT_TYPE_TS_STACK_SIGNED  0x0004

typedef struct _WIN_CERTIFICATE
{
    DWORD Length;
    WORD  Revision;
    WORD  CertificateType;
    BYTE  Certificate[0];
} WIN_CERTIFICATE, *PWIN_CERTIFICATE;


//
// Rich signature.
// http://www.ntcore.com/files/richsign.htm
//

#define RICH_VERSION_ID(id_version) (id_version >> 16)
#define RICH_VERSION_VERSION(id_version) (id_version & 0xFFFF)

typedef struct _RICH_VERSION_INFO
{
    DWORD id_version; //tool id and version (use RICH_VERSION_ID and RICH_VERSION_VERSION macros)
    DWORD times; //number of times this tool was used
} RICH_VERSION_INFO, *PRICH_VERSION_INFO;

typedef struct _RICH_SIGNATURE
{
    DWORD dans;
    DWORD key1;
    DWORD key2;
    DWORD key3;
    RICH_VERSION_INFO versions[0];
} RICH_SIGNATURE, *PRICH_SIGNATURE;

#define RICH_DANS 0x536e6144 // "DanS"
#define RICH_RICH 0x68636952 // "Rich"


#pragma pack(pop)
#endif



================================================
File: pluginsdk/yara/yara/pe_utils.h
================================================
#ifndef YR_PE_UTILS_H
#define YR_PE_UTILS_H

#include <yara/pe.h>

#define MAX_PE_SECTIONS              96


#define IS_64BITS_PE(pe) \
    (yr_le16toh(pe->header64->OptionalHeader.Magic) == IMAGE_NT_OPTIONAL_HDR64_MAGIC)


#define OptionalHeader(pe,field)                \
  (IS_64BITS_PE(pe) ?                           \
   pe->header64->OptionalHeader.field :         \
   pe->header->OptionalHeader.field)


//
// Imports are stored in a linked list. Each node (IMPORTED_DLL) contains the
// name of the DLL and a pointer to another linked list of
// IMPORT_EXPORT_FUNCTION structures containing the details of imported
// functions.
//

typedef struct _IMPORTED_DLL
{
    char* name;

    struct _IMPORT_EXPORT_FUNCTION* functions;
    struct _IMPORTED_DLL* next;

} IMPORTED_DLL, *PIMPORTED_DLL;


//
// This is used to track imported and exported functions. The "has_ordinal"
// field is only used in the case of imports as those are optional. Every export
// has an ordinal so we don't need the field there, but in the interest of
// keeping duplicate code to a minimum we use this function for both imports and
// exports.
//

typedef struct _IMPORT_EXPORT_FUNCTION
{
    char* name;
    uint8_t has_ordinal;
    uint16_t ordinal;

    struct _IMPORT_EXPORT_FUNCTION* next;

} IMPORT_EXPORT_FUNCTION, *PIMPORT_EXPORT_FUNCTION;


typedef struct _PE
{
    uint8_t* data;
    size_t data_size;

    union
    {
        PIMAGE_NT_HEADERS32 header;
        PIMAGE_NT_HEADERS64 header64;
    };

    YR_OBJECT* object;
    IMPORTED_DLL* imported_dlls;
    IMPORT_EXPORT_FUNCTION* exported_functions;

    uint32_t resources;

} PE;


#define fits_in_pe(pe, pointer, size) \
    ((size_t) size <= pe->data_size && \
     (uint8_t*) (pointer) >= pe->data && \
     (uint8_t*) (pointer) <= pe->data + pe->data_size - size)

#define struct_fits_in_pe(pe, pointer, struct_type) \
    fits_in_pe(pe, pointer, sizeof(struct_type))


PIMAGE_NT_HEADERS32 pe_get_header(
    uint8_t* data,
    size_t data_size);


PIMAGE_DATA_DIRECTORY pe_get_directory_entry(
    PE* pe,
    int entry);


PIMAGE_DATA_DIRECTORY pe_get_directory_entry(
    PE* pe,
    int entry);


int64_t pe_rva_to_offset(
    PE* pe,
    uint64_t rva);


char* ord_lookup(
    char* dll,
    uint16_t ord);


#if HAVE_LIBCRYPTO
#include <openssl/asn1.h>
time_t ASN1_get_time_t(ASN1_TIME* time);
#endif

#endif



================================================
File: pluginsdk/yara/yara/proc.h
================================================
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PROC_H
#define YR_PROC_H

#include "types.h"

int yr_process_open_iterator(
    int pid,
    YR_MEMORY_BLOCK_ITERATOR* iterator);

int yr_process_close_iterator(
    YR_MEMORY_BLOCK_ITERATOR* iterator);

#endif



================================================
File: pluginsdk/yara/yara/re.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_RE_H
#define YR_RE_H

#include <ctype.h>

#include "arena.h"
#include "sizedstr.h"

#define RE_NODE_LITERAL             1
#define RE_NODE_MASKED_LITERAL      2
#define RE_NODE_ANY                 3
#define RE_NODE_CONCAT              4
#define RE_NODE_ALT                 5
#define RE_NODE_RANGE               6
#define RE_NODE_STAR                7
#define RE_NODE_PLUS                8
#define RE_NODE_CLASS               9
#define RE_NODE_WORD_CHAR           10
#define RE_NODE_NON_WORD_CHAR       11
#define RE_NODE_SPACE               12
#define RE_NODE_NON_SPACE           13
#define RE_NODE_DIGIT               14
#define RE_NODE_NON_DIGIT           15
#define RE_NODE_EMPTY               16
#define RE_NODE_ANCHOR_START        17
#define RE_NODE_ANCHOR_END          18
#define RE_NODE_WORD_BOUNDARY       19
#define RE_NODE_NON_WORD_BOUNDARY   20
#define RE_NODE_RANGE_ANY           21


#define RE_OPCODE_ANY                   0xA0
#define RE_OPCODE_ANY_EXCEPT_NEW_LINE   0xA1
#define RE_OPCODE_LITERAL               0xA2
#define RE_OPCODE_MASKED_LITERAL        0xA4
#define RE_OPCODE_CLASS                 0xA5
#define RE_OPCODE_WORD_CHAR             0xA7
#define RE_OPCODE_NON_WORD_CHAR         0xA8
#define RE_OPCODE_SPACE                 0xA9
#define RE_OPCODE_NON_SPACE             0xAA
#define RE_OPCODE_DIGIT                 0xAB
#define RE_OPCODE_NON_DIGIT             0xAC
#define RE_OPCODE_MATCH                 0xAD

#define RE_OPCODE_MATCH_AT_END          0xB0
#define RE_OPCODE_MATCH_AT_START        0xB1
#define RE_OPCODE_WORD_BOUNDARY         0xB2
#define RE_OPCODE_NON_WORD_BOUNDARY     0xB3
#define RE_OPCODE_REPEAT_ANY_GREEDY     0xB4
#define RE_OPCODE_REPEAT_ANY_UNGREEDY   0xB5

#define RE_OPCODE_SPLIT_A               0xC0
#define RE_OPCODE_SPLIT_B               0xC1
#define RE_OPCODE_JUMP                  0xC2
#define RE_OPCODE_REPEAT_START_GREEDY   0xC3
#define RE_OPCODE_REPEAT_END_GREEDY     0xC4
#define RE_OPCODE_REPEAT_START_UNGREEDY 0xC5
#define RE_OPCODE_REPEAT_END_UNGREEDY   0xC6


#define RE_FLAGS_FAST_REGEXP            0x02
#define RE_FLAGS_BACKWARDS              0x04
#define RE_FLAGS_EXHAUSTIVE             0x08
#define RE_FLAGS_WIDE                   0x10
#define RE_FLAGS_NO_CASE                0x20
#define RE_FLAGS_SCAN                   0x40
#define RE_FLAGS_DOT_ALL                0x80
#define RE_FLAGS_GREEDY                0x400
#define RE_FLAGS_UNGREEDY              0x800


typedef struct RE RE;
typedef struct RE_AST RE_AST;
typedef struct RE_NODE RE_NODE;
typedef struct RE_ERROR RE_ERROR;

typedef uint8_t RE_SPLIT_ID_TYPE;


struct RE_NODE
{
    int type;

    union
    {
        int value;
        int count;
        int start;
    };

    union
    {
        int mask;
        int end;
    };

    int greedy;

    uint8_t* class_vector;

    RE_NODE* left;
    RE_NODE* right;

    uint8_t* forward_code;
    uint8_t* backward_code;
};


struct RE_AST
{
    uint32_t flags;
    RE_NODE* root_node;
};


// Disable warning due to zero length array in Microsoft's compiler

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4200)
#endif

struct RE
{
    uint32_t flags;
    uint8_t code[0];
};

#ifdef _MSC_VER
#pragma warning(pop)
#endif


struct RE_ERROR
{
    char message[512];
};


typedef int RE_MATCH_CALLBACK_FUNC(
    uint8_t* match,
    int match_length,
    int flags,
    void* args);


int yr_re_ast_create(
    RE_AST** re_ast);

void yr_re_ast_destroy(
    RE_AST* re_ast);

void yr_re_ast_print(
    RE_AST* re_ast);

SIZED_STRING* yr_re_ast_extract_literal(
    RE_AST* re_ast);


int yr_re_ast_contains_dot_star(
    RE_AST* re_ast);


int yr_re_ast_split_at_chaining_point(
    RE_AST* re_ast,
    RE_AST** result_re_ast,
    RE_AST** remainder_re_ast,
    int32_t* min_gap,
    int32_t* max_gap);


int yr_re_ast_emit_code(
    RE_AST* re_ast,
    YR_ARENA* arena,
    int backwards_code);


RE_NODE* yr_re_node_create(
    int type,
    RE_NODE* left,
    RE_NODE* right);


void yr_re_node_destroy(
    RE_NODE* node);


int yr_re_exec(
    uint8_t* re_code,
    uint8_t* input,
    size_t input_forwards_size,
    size_t input_backwards_size,
    int flags,
    RE_MATCH_CALLBACK_FUNC callback,
    void* callback_args,
    int* matches);


int yr_re_fast_exec(
    uint8_t* code,
    uint8_t* input_data,
    size_t input_forwards_size,
    size_t input_backwards_size,
    int flags,
    RE_MATCH_CALLBACK_FUNC callback,
    void* callback_args,
    int* matches);


int yr_re_parse(
    const char* re_string,
    RE_AST** re_ast,
    RE_ERROR* error);


int yr_re_parse_hex(
    const char* hex_string,
    RE_AST** re_ast,
    RE_ERROR* error);


int yr_re_compile(
    const char* re_string,
    int flags,
    YR_ARENA* code_arena,
    RE** re,
    RE_ERROR* error);


int yr_re_match(
    RE* re,
    const char* target);


int yr_re_initialize(void);


int yr_re_finalize(void);


int yr_re_finalize_thread(void);

#endif



================================================
File: pluginsdk/yara/yara/re_lexer.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_FATAL_ERROR
#undef YY_DECL
#undef LEX_ENV


#define yyparse         re_yyparse
#define yylex           re_yylex
#define yyerror         re_yyerror
#define yyfatal         re_yyfatal
#define yychar          re_yychar
#define yydebug         re_yydebug
#define yynerrs         re_yynerrs
#define yyget_extra     re_yyget_extra
#define yyget_lineno    re_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#define YY_EXTRA_TYPE RE_AST*
#define YY_USE_CONST


typedef struct _RE_LEX_ENVIRONMENT
{
    int negated_class;
    uint8_t class_vector[32];
    int last_error_code;
    char last_error_message[256];

} RE_LEX_ENVIRONMENT;


#define LEX_ENV  ((RE_LEX_ENVIRONMENT*) lex_env)

#define YY_FATAL_ERROR(msg) re_yyfatal(yyscanner, msg)

#include <re_grammar.h>

#define YY_DECL int re_yylex \
    (YYSTYPE * yylval_param , yyscan_t yyscanner, RE_LEX_ENVIRONMENT* lex_env)


YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yylex(
    YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    RE_LEX_ENVIRONMENT* lex_env);

int yyparse(
    void* yyscanner,
    RE_LEX_ENVIRONMENT* lex_env);

void yyerror(
    yyscan_t yyscanner,
    RE_LEX_ENVIRONMENT* lex_env,
    const char* error_message);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

int yr_parse_re_string(
    const char* re_string,
    RE_AST** re_ast,
    RE_ERROR* error);



================================================
File: pluginsdk/yara/yara/rules.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_RULES_H
#define YR_RULES_H

#include "types.h"
#include "utils.h"
#include "filemap.h"


#define CALLBACK_MSG_RULE_MATCHING              1
#define CALLBACK_MSG_RULE_NOT_MATCHING          2
#define CALLBACK_MSG_SCAN_FINISHED              3
#define CALLBACK_MSG_IMPORT_MODULE              4
#define CALLBACK_MSG_MODULE_IMPORTED            5

#define CALLBACK_CONTINUE   0
#define CALLBACK_ABORT      1
#define CALLBACK_ERROR      2


#define yr_rule_tags_foreach(rule, tag_name) \
    for (tag_name = rule->tags; \
         tag_name != NULL && *tag_name != '\0'; \
         tag_name += strlen(tag_name) + 1)


#define yr_rule_metas_foreach(rule, meta) \
    for (meta = rule->metas; !META_IS_NULL(meta); meta++)


#define yr_rule_strings_foreach(rule, string) \
    for (string = rule->strings; !STRING_IS_NULL(string); string++)


#define yr_string_matches_foreach(string, match) \
    for (match = STRING_MATCHES(string).head; match != NULL; match = match->next)


#define yr_rules_foreach(rules, rule) \
    for (rule = rules->rules_list_head; !RULE_IS_NULL(rule); rule++)



YR_API int yr_rules_scan_mem(
    YR_RULES* rules,
    uint8_t* buffer,
    size_t buffer_size,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_file(
    YR_RULES* rules,
    const char* filename,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_fd(
    YR_RULES* rules,
    YR_FILE_DESCRIPTOR fd,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_proc(
    YR_RULES* rules,
    int pid,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);

YR_API int yr_rules_save(
    YR_RULES* rules,
    const char* filename);


YR_API int yr_rules_save_stream(
    YR_RULES* rules,
    YR_STREAM* stream);


YR_API int yr_rules_load(
    const char* filename,
    YR_RULES** rules);


YR_API int yr_rules_load_stream(
    YR_STREAM* stream,
    YR_RULES** rules);


YR_API int yr_rules_destroy(
    YR_RULES* rules);


YR_API int yr_rules_define_integer_variable(
    YR_RULES* rules,
    const char* identifier,
    int64_t value);


YR_API int yr_rules_define_boolean_variable(
    YR_RULES* rules,
    const char* identifier,
    int value);


YR_API int yr_rules_define_float_variable(
    YR_RULES* rules,
    const char* identifier,
    double value);


YR_API int yr_rules_define_string_variable(
    YR_RULES* rules,
    const char* identifier,
    const char* value);


YR_API void yr_rules_print_profiling_info(
    YR_RULES* rules);

#endif



================================================
File: pluginsdk/yara/yara/scan.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_SCAN_H
#define YR_SCAN_H

#include "types.h"

// Bitmasks for flags.
#define SCAN_FLAGS_FAST_MODE         1
#define SCAN_FLAGS_PROCESS_MEMORY    2
#define SCAN_FLAGS_NO_TRYCATCH       4


int yr_scan_verify_match(
    YR_SCAN_CONTEXT* context,
    YR_AC_MATCH* ac_match,
    uint8_t* data,
    size_t data_size,
    size_t data_base,
    size_t offset);

#endif



================================================
File: pluginsdk/yara/yara/sizedstr.h
================================================
/*
Copyright (c) 2007-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _SIZEDSTR_H
#define _SIZEDSTR_H

#include <stddef.h>

#include "integers.h"

//
// This struct is used to support strings containing null chars. The length of
// the string is stored along the string data. However the string data is also
// terminated with a null char.
//

#define SIZED_STRING_FLAGS_NO_CASE  1
#define SIZED_STRING_FLAGS_DOT_ALL  2

#pragma pack(push)
#pragma pack(8)


typedef struct _SIZED_STRING
{
    uint32_t length;
    uint32_t flags;

    char c_string[1];

} SIZED_STRING;

#pragma pack(pop)


int sized_string_cmp(
    SIZED_STRING* s1,
    SIZED_STRING* s2);


SIZED_STRING* sized_string_dup(
    SIZED_STRING* s);

#endif



================================================
File: pluginsdk/yara/yara/stream.h
================================================
/*
Copyright (c) 2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_STREAM_H
#define YR_STREAM_H

#include <stddef.h>

typedef size_t (*YR_STREAM_READ_FUNC)(
    void* ptr,
    size_t size,
    size_t count,
    void* user_data);


typedef size_t (*YR_STREAM_WRITE_FUNC)(
    const void* ptr,
    size_t size,
    size_t count,
    void* user_data);


typedef struct _YR_STREAM
{
    void* user_data;

    YR_STREAM_READ_FUNC read;
    YR_STREAM_WRITE_FUNC write;

} YR_STREAM;


size_t yr_stream_read(
    void* ptr,
    size_t size,
    size_t count,
    YR_STREAM* stream);


size_t yr_stream_write(
    const void* ptr,
    size_t size,
    size_t count,
    YR_STREAM* stream);

#endif



================================================
File: pluginsdk/yara/yara/strutils.h
================================================
/*
Copyright (c) 2007-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_STRUTILS_H
#define YR_STRUTILS_H

#include <assert.h>
#include <stdlib.h>

#include "integers.h"

// Cygwin already has these functions.
#if defined(_WIN32) && !defined(__CYGWIN__)
#if defined(_MSC_VER) && _MSC_VER < 1900
#define snprintf _snprintf
#endif
#define strcasecmp _stricmp
#define strncasecmp _strnicmp
#endif


uint64_t xtoi(
    const char* hexstr);


#if !HAVE_STRLCPY && !defined(strlcpy)
size_t strlcpy(
    char* dst,
    const char* src,
    size_t size);
#endif


#if !HAVE_STRLCAT && !defined(strlcat)
size_t strlcat(
    char* dst,
    const char* src,
    size_t size);
#endif


#if !HAVE_MEMMEM && !defined(memmem)
void* memmem(
    const void* haystack,
    size_t haystack_size,
    const void* needle,
    size_t needle_size);
#endif


int strnlen_w(
    const char* w_str);


int strcmp_w(
    const char* w_str,
    const char* str);


size_t strlcpy_w(
    char* dst,
    const char* w_src,
    size_t n);

#endif



================================================
File: pluginsdk/yara/yara/threading.h
================================================
/*
Copyright (c) 2016. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MUTEX_H
#define YR_MUTEX_H



#if defined(_WIN32) || defined(__CYGWIN__)

#include <windows.h>

typedef DWORD YR_THREAD_ID;
typedef DWORD YR_THREAD_STORAGE_KEY;
typedef HANDLE YR_MUTEX;

#else

#include <pthread.h>

typedef pthread_t YR_THREAD_ID;
typedef pthread_key_t YR_THREAD_STORAGE_KEY;
typedef pthread_mutex_t YR_MUTEX;

#endif

YR_THREAD_ID yr_current_thread_id(void);

int yr_mutex_create(YR_MUTEX*);
int yr_mutex_destroy(YR_MUTEX*);
int yr_mutex_lock(YR_MUTEX*);
int yr_mutex_unlock(YR_MUTEX*);

int yr_thread_storage_create(YR_THREAD_STORAGE_KEY*);
int yr_thread_storage_destroy(YR_THREAD_STORAGE_KEY*);
int yr_thread_storage_set_value(YR_THREAD_STORAGE_KEY*, void*);
void* yr_thread_storage_get_value(YR_THREAD_STORAGE_KEY*);

#endif



================================================
File: pluginsdk/yara/yara/types.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_TYPES_H
#define YR_TYPES_H


#include "arena.h"
#include "re.h"
#include "limits.h"
#include "hash.h"
#include "utils.h"
#include "threading.h"



#ifdef PROFILING_ENABLED
#include <time.h>
#endif


#define DECLARE_REFERENCE(type, name) \
    union { type name; int64_t name##_; } YR_ALIGN(8)



#define NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL      0x01


#define STRING_GFLAGS_REFERENCED        0x01
#define STRING_GFLAGS_HEXADECIMAL       0x02
#define STRING_GFLAGS_NO_CASE           0x04
#define STRING_GFLAGS_ASCII             0x08
#define STRING_GFLAGS_WIDE              0x10
#define STRING_GFLAGS_REGEXP            0x20
#define STRING_GFLAGS_FAST_REGEXP       0x40
#define STRING_GFLAGS_FULL_WORD         0x80
#define STRING_GFLAGS_ANONYMOUS         0x100
#define STRING_GFLAGS_SINGLE_MATCH      0x200
#define STRING_GFLAGS_LITERAL           0x400
#define STRING_GFLAGS_FITS_IN_ATOM      0x800
#define STRING_GFLAGS_NULL              0x1000
#define STRING_GFLAGS_CHAIN_PART        0x2000
#define STRING_GFLAGS_CHAIN_TAIL        0x4000
#define STRING_GFLAGS_FIXED_OFFSET      0x8000
#define STRING_GFLAGS_GREEDY_REGEXP     0x10000
#define STRING_GFLAGS_DOT_ALL           0x20000

#define STRING_IS_HEX(x) \
    (((x)->g_flags) & STRING_GFLAGS_HEXADECIMAL)

#define STRING_IS_NO_CASE(x) \
    (((x)->g_flags) & STRING_GFLAGS_NO_CASE)

#define STRING_IS_DOT_ALL(x) \
    (((x)->g_flags) & STRING_GFLAGS_DOT_ALL)

#define STRING_IS_ASCII(x) \
    (((x)->g_flags) & STRING_GFLAGS_ASCII)

#define STRING_IS_WIDE(x) \
    (((x)->g_flags) & STRING_GFLAGS_WIDE)

#define STRING_IS_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_REGEXP)

#define STRING_IS_GREEDY_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_GREEDY_REGEXP)

#define STRING_IS_FULL_WORD(x) \
    (((x)->g_flags) & STRING_GFLAGS_FULL_WORD)

#define STRING_IS_ANONYMOUS(x) \
    (((x)->g_flags) & STRING_GFLAGS_ANONYMOUS)

#define STRING_IS_REFERENCED(x) \
    (((x)->g_flags) & STRING_GFLAGS_REFERENCED)

#define STRING_IS_SINGLE_MATCH(x) \
    (((x)->g_flags) & STRING_GFLAGS_SINGLE_MATCH)

#define STRING_IS_FIXED_OFFSET(x) \
    (((x)->g_flags) & STRING_GFLAGS_FIXED_OFFSET)

#define STRING_IS_LITERAL(x) \
    (((x)->g_flags) & STRING_GFLAGS_LITERAL)

#define STRING_IS_FAST_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_FAST_REGEXP)

#define STRING_IS_CHAIN_PART(x) \
    (((x)->g_flags) & STRING_GFLAGS_CHAIN_PART)

#define STRING_IS_CHAIN_TAIL(x) \
    (((x)->g_flags) & STRING_GFLAGS_CHAIN_TAIL)

#define STRING_IS_NULL(x) \
    ((x) == NULL || ((x)->g_flags) & STRING_GFLAGS_NULL)

#define STRING_FITS_IN_ATOM(x) \
    (((x)->g_flags) & STRING_GFLAGS_FITS_IN_ATOM)

#define STRING_FOUND(x) \
    ((x)->matches[yr_get_tidx()].tail != NULL)

#define STRING_MATCHES(x) \
    ((x)->matches[yr_get_tidx()])


#define RULE_TFLAGS_MATCH                0x01

#define RULE_GFLAGS_PRIVATE              0x01
#define RULE_GFLAGS_GLOBAL               0x02
#define RULE_GFLAGS_REQUIRE_EXECUTABLE   0x04
#define RULE_GFLAGS_REQUIRE_FILE         0x08
#define RULE_GFLAGS_NULL                 0x1000

#define RULE_IS_PRIVATE(x) \
    (((x)->g_flags) & RULE_GFLAGS_PRIVATE)

#define RULE_IS_GLOBAL(x) \
    (((x)->g_flags) & RULE_GFLAGS_GLOBAL)

#define RULE_IS_NULL(x) \
    (((x)->g_flags) & RULE_GFLAGS_NULL)

#define RULE_MATCHES(x) \
    ((x)->t_flags[yr_get_tidx()] & RULE_TFLAGS_MATCH)


#define META_TYPE_NULL      0
#define META_TYPE_INTEGER   1
#define META_TYPE_STRING    2
#define META_TYPE_BOOLEAN   3

#define META_IS_NULL(x) \
    ((x) != NULL ? (x)->type == META_TYPE_NULL : TRUE)


#define EXTERNAL_VARIABLE_TYPE_NULL           0
#define EXTERNAL_VARIABLE_TYPE_FLOAT          1
#define EXTERNAL_VARIABLE_TYPE_INTEGER        2
#define EXTERNAL_VARIABLE_TYPE_BOOLEAN        3
#define EXTERNAL_VARIABLE_TYPE_STRING         4
#define EXTERNAL_VARIABLE_TYPE_MALLOC_STRING  5

#define EXTERNAL_VARIABLE_IS_NULL(x) \
    ((x) != NULL ? (x)->type == EXTERNAL_VARIABLE_TYPE_NULL : TRUE)


#pragma pack(push)
#pragma pack(8)


typedef struct _YR_NAMESPACE
{
    int32_t t_flags[MAX_THREADS];     // Thread-specific flags
    DECLARE_REFERENCE(char*, name);

} YR_NAMESPACE;


typedef struct _YR_META
{
    int32_t type;
    YR_ALIGN(8) int64_t integer;

    DECLARE_REFERENCE(const char*, identifier);
    DECLARE_REFERENCE(char*, string);

} YR_META;


struct _YR_MATCH;


typedef struct _YR_MATCHES
{
    int32_t count;

    DECLARE_REFERENCE(struct _YR_MATCH*, head);
    DECLARE_REFERENCE(struct _YR_MATCH*, tail);

} YR_MATCHES;


typedef struct _YR_STRING
{
    int32_t g_flags;
    int32_t length;

    DECLARE_REFERENCE(char*, identifier);
    DECLARE_REFERENCE(uint8_t*, string);
    DECLARE_REFERENCE(struct _YR_STRING*, chained_to);

    int32_t chain_gap_min;
    int32_t chain_gap_max;

    int64_t fixed_offset;

    YR_MATCHES matches[MAX_THREADS];
    YR_MATCHES unconfirmed_matches[MAX_THREADS];

#ifdef PROFILING_ENABLED
    clock_t clock_ticks;
#endif

} YR_STRING;


typedef struct _YR_RULE
{
    int32_t g_flags;               // Global flags
    int32_t t_flags[MAX_THREADS];  // Thread-specific flags

    DECLARE_REFERENCE(const char*, identifier);
    DECLARE_REFERENCE(const char*, tags);
    DECLARE_REFERENCE(YR_META*, metas);
    DECLARE_REFERENCE(YR_STRING*, strings);
    DECLARE_REFERENCE(YR_NAMESPACE*, ns);

#ifdef PROFILING_ENABLED
    clock_t clock_ticks;
#endif

} YR_RULE;


typedef struct _YR_EXTERNAL_VARIABLE
{
    int32_t type;

    YR_ALIGN(8) union
    {
        int64_t i;
        double f;
        char* s;
    } value;

    DECLARE_REFERENCE(char*, identifier);

} YR_EXTERNAL_VARIABLE;


typedef struct _YR_AC_MATCH
{
    uint16_t backtrack;

    DECLARE_REFERENCE(YR_STRING*, string);
    DECLARE_REFERENCE(uint8_t*, forward_code);
    DECLARE_REFERENCE(uint8_t*, backward_code);
    DECLARE_REFERENCE(struct _YR_AC_MATCH*, next);

} YR_AC_MATCH;


typedef struct _YR_AC_MATCH_TABLE_ENTRY
{
    DECLARE_REFERENCE(YR_AC_MATCH*, match);

} YR_AC_MATCH_TABLE_ENTRY;


typedef uint64_t                  YR_AC_TRANSITION;
typedef YR_AC_TRANSITION*         YR_AC_TRANSITION_TABLE;
typedef YR_AC_MATCH_TABLE_ENTRY*  YR_AC_MATCH_TABLE;


typedef struct _YARA_RULES_FILE_HEADER
{
    DECLARE_REFERENCE(YR_RULE*, rules_list_head);
    DECLARE_REFERENCE(YR_EXTERNAL_VARIABLE*, externals_list_head);
    DECLARE_REFERENCE(uint8_t*, code_start);
    DECLARE_REFERENCE(YR_AC_MATCH_TABLE, match_table);
    DECLARE_REFERENCE(YR_AC_TRANSITION_TABLE, transition_table);

} YARA_RULES_FILE_HEADER;

#pragma pack(pop)


//
// Structs defined below are never stored in the compiled rules file
//

typedef struct _YR_MATCH
{
    int64_t base;              // Base address for the match
    int64_t offset;            // Offset relative to base for the match
    int32_t match_length;      // Match length
    int32_t data_length;

    // Pointer to a buffer containing a portion of the matched data. The size of
    // the buffer is data_length. data_length is always <= length and is limited
    // to MAX_MATCH_DATA bytes.

    uint8_t* data;

    // If the match belongs to a chained string chain_length contains the
    // length of the chain. This field is used only in unconfirmed matches.

    int32_t chain_length;

    struct _YR_MATCH* prev;
    struct _YR_MATCH* next;

} YR_MATCH;


struct _YR_AC_STATE;


typedef struct _YR_AC_STATE
{
    uint8_t depth;
    uint8_t input;

    uint32_t t_table_slot;

    struct _YR_AC_STATE* failure;
    struct _YR_AC_STATE* first_child;
    struct _YR_AC_STATE* siblings;

    YR_AC_MATCH* matches;

} YR_AC_STATE;


typedef struct _YR_AC_AUTOMATON
{
    // Both m_table and t_table have the same number of elements, which is
    // stored in tables_size.

    uint32_t tables_size;
    uint32_t t_table_unused_candidate;

    YR_AC_TRANSITION_TABLE t_table;
    YR_AC_MATCH_TABLE m_table;

    YR_AC_STATE* root;

} YR_AC_AUTOMATON;


typedef struct _YR_RULES
{

    unsigned char tidx_mask[YR_BITARRAY_NCHARS(MAX_THREADS)];
    uint8_t* code_start;

    YR_MUTEX mutex;
    YR_ARENA* arena;
    YR_RULE* rules_list_head;
    YR_EXTERNAL_VARIABLE* externals_list_head;
    YR_AC_TRANSITION_TABLE transition_table;
    YR_AC_MATCH_TABLE match_table;

} YR_RULES;


struct _YR_MEMORY_BLOCK;
struct _YR_MEMORY_BLOCK_ITERATOR;


typedef uint8_t* (*YR_MEMORY_BLOCK_FETCH_DATA_FUNC)(
    struct _YR_MEMORY_BLOCK* self);


typedef struct _YR_MEMORY_BLOCK* (*YR_MEMORY_BLOCK_ITERATOR_FUNC)(
    struct _YR_MEMORY_BLOCK_ITERATOR* self);


typedef struct _YR_MEMORY_BLOCK
{
    size_t size;
    size_t base;

    void* context;

    YR_MEMORY_BLOCK_FETCH_DATA_FUNC fetch_data;

} YR_MEMORY_BLOCK;


typedef struct _YR_MEMORY_BLOCK_ITERATOR
{
    void* context;

    YR_MEMORY_BLOCK_ITERATOR_FUNC  first;
    YR_MEMORY_BLOCK_ITERATOR_FUNC  next;

} YR_MEMORY_BLOCK_ITERATOR;


typedef int (*YR_CALLBACK_FUNC)(
    int message,
    void* message_data,
    void* user_data);


typedef struct _YR_SCAN_CONTEXT
{
    uint64_t  file_size;
    uint64_t  entry_point;

    int flags;
    int tidx;

    void* user_data;

    YR_MEMORY_BLOCK_ITERATOR*  iterator;
    YR_HASH_TABLE*  objects_table;
    YR_CALLBACK_FUNC  callback;

    YR_ARENA* matches_arena;
    YR_ARENA* matching_strings_arena;

} YR_SCAN_CONTEXT;


struct _YR_OBJECT;


typedef union _YR_VALUE
{
    int64_t i;
    double d;
    void* p;
    struct _YR_OBJECT* o;
    YR_STRING* s;
    SIZED_STRING* ss;
    RE* re;

} YR_VALUE;


#define OBJECT_COMMON_FIELDS \
    int8_t type; \
    const char* identifier; \
    struct _YR_OBJECT* parent; \
    void* data;


typedef struct _YR_OBJECT
{
    OBJECT_COMMON_FIELDS
    YR_VALUE value;

} YR_OBJECT;


typedef struct _YR_OBJECT_STRUCTURE
{
    OBJECT_COMMON_FIELDS
    struct _YR_STRUCTURE_MEMBER* members;

} YR_OBJECT_STRUCTURE;


typedef struct _YR_OBJECT_ARRAY
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* prototype_item;
    struct _YR_ARRAY_ITEMS* items;

} YR_OBJECT_ARRAY;


typedef struct _YR_OBJECT_DICTIONARY
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* prototype_item;
    struct _YR_DICTIONARY_ITEMS* items;

} YR_OBJECT_DICTIONARY;


struct _YR_OBJECT_FUNCTION;


typedef int (*YR_MODULE_FUNC)(
    YR_VALUE* args,
    YR_SCAN_CONTEXT* context,
    struct _YR_OBJECT_FUNCTION* function_obj);


typedef struct _YR_OBJECT_FUNCTION
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* return_obj;

    struct
    {
        const char* arguments_fmt;
        YR_MODULE_FUNC code;

    } prototypes[MAX_OVERLOADED_FUNCTIONS];

} YR_OBJECT_FUNCTION;


#define object_as_structure(obj)  ((YR_OBJECT_STRUCTURE*) (obj))
#define object_as_array(obj)      ((YR_OBJECT_ARRAY*) (obj))
#define object_as_dictionary(obj) ((YR_OBJECT_DICTIONARY*) (obj))
#define object_as_function(obj)   ((YR_OBJECT_FUNCTION*) (obj))


typedef struct _YR_STRUCTURE_MEMBER
{
    YR_OBJECT* object;
    struct _YR_STRUCTURE_MEMBER* next;

} YR_STRUCTURE_MEMBER;


typedef struct _YR_ARRAY_ITEMS
{
    int count;
    YR_OBJECT* objects[1];

} YR_ARRAY_ITEMS;


typedef struct _YR_DICTIONARY_ITEMS
{
    int used;
    int free;

    struct
    {

        char* key;
        YR_OBJECT* obj;

    } objects[1];

} YR_DICTIONARY_ITEMS;


#endif



================================================
File: pluginsdk/yara/yara/utils.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef YR_UTILS_H
#define YR_UTILS_H

#include <limits.h>

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define YR_API EXTERNC __attribute__((visibility("default")))
#elif defined(_MSC_VER)
#define YR_API EXTERNC __declspec(dllexport)
#else
#define YR_API EXTERNC
#endif

#if defined(__GNUC__)
#define YR_ALIGN(n) __attribute__((aligned(n)))
#elif defined(_MSC_VER)
#define YR_ALIGN(n) __declspec(align(n))
#else
#define YR_ALIGN(n)
#endif

#define yr_min(x, y) ((x < y) ? (x) : (y))
#define yr_max(x, y) ((x > y) ? (x) : (y))

#define yr_swap(x, y, T) do { T temp = x; x = y; y = temp; } while (0)

#ifdef NDEBUG

#define assertf(expr, msg, ...)  ((void)0)

#else

#include <stdlib.h>

#define assertf(expr, msg, ...) \
    if(!(expr)) { \
      fprintf(stderr, "%s:%d: " msg "\n", __FILE__, __LINE__, ##__VA_ARGS__); \
      abort(); \
    }

#endif

// Set, unset, and test bits in an array of unsigned characters by integer
// index. The underlying array must be of type char or unsigned char to
// ensure compatibility with the CHAR_BIT constant used in these definitions.

#define YR_BITARRAY_SET(uchar_array_base, bitnum) \
          (((uchar_array_base)[(bitnum)/CHAR_BIT]) = \
            ((uchar_array_base)[(bitnum)/CHAR_BIT] | (1 << ((bitnum) % CHAR_BIT))))

#define YR_BITARRAY_UNSET(uchar_array_base, bitnum) \
          (((uchar_array_base)[(bitnum)/CHAR_BIT]) = \
            ((uchar_array_base)[(bitnum)/CHAR_BIT] & (~(1 << ((bitnum) % CHAR_BIT)))))

#define YR_BITARRAY_TEST(uchar_array_base, bitnum) \
          (((uchar_array_base)[(bitnum)/CHAR_BIT] & (1 << ((bitnum) % CHAR_BIT))) != 0)

#define YR_BITARRAY_NCHARS(bitnum) \
          (((bitnum)+(CHAR_BIT-1))/CHAR_BIT)

#endif





================================================
File: scriptapi/scriptapi.cpp
================================================
#pragma warning(disable:4091)
#include <windows.h>
#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>

#include "../pluginsdk/_plugins.h"

#include "../pluginsdk/_scriptapi_argument.h"
#include "../pluginsdk/_scriptapi_assembler.h"
#include "../pluginsdk/_scriptapi_bookmark.h"
#include "../pluginsdk/_scriptapi_comment.h"
#include "../pluginsdk/_scriptapi_debug.h"
#include "../pluginsdk/_scriptapi_flag.h"
#include "../pluginsdk/_scriptapi_function.h"
#include "../pluginsdk/_scriptapi_gui.h"
#include "../pluginsdk/_scriptapi_label.h"
#include "../pluginsdk/_scriptapi_memory.h"
#include "../pluginsdk/_scriptapi_misc.h"
#include "../pluginsdk/_scriptapi_module.h"
#include "../pluginsdk/_scriptapi_pattern.h"
#include "../pluginsdk/_scriptapi_register.h"
#include "../pluginsdk/_scriptapi_stack.h"
#include "../pluginsdk/_scriptapi_symbol.h"

#define PLUGIN_NAME "scriptapi"
#define dprintf(x, ...) _plugin_logprintf("[" PLUGIN_NAME "] " x, __VA_ARGS__)
#define dputs(x) _plugin_logprintf("[" PLUGIN_NAME "] %s\n", x)

#include "../pluginsdk/capstone/capstone.h"
#include "../pluginsdk/DeviceNameResolver/DeviceNameResolver.h"
#include "../pluginsdk/jansson/jansson.h"
#include "../pluginsdk/lz4/lz4file.h"
#include "../pluginsdk/TitanEngine/TitanEngine.h"
#include "../pluginsdk/XEDParse/XEDParse.h"

#ifdef _WIN64
#pragma comment(lib, "../pluginsdk/x64dbg.lib")
#pragma comment(lib, "../pluginsdk/x64bridge.lib")
#pragma comment(lib, "../pluginsdk/capstone/capstone_x64.lib")
#pragma comment(lib, "../pluginsdk/DeviceNameResolver/DeviceNameResolver_x64.lib")
#pragma comment(lib, "../pluginsdk/jansson/jansson_x64.lib")
#pragma comment(lib, "../pluginsdk/lz4/lz4_x64.lib")
#pragma comment(lib, "../pluginsdk/TitanEngine/TitanEngine_x64.lib")
#pragma comment(lib, "../pluginsdk/XEDParse/XEDParse_x64.lib")
#pragma comment(lib, "../pluginsdk/yara/yara_x64.lib")
#else
#pragma comment(lib, "../pluginsdk/x32dbg.lib")
#pragma comment(lib, "../pluginsdk/x32bridge.lib")
#pragma comment(lib, "../pluginsdk/capstone/capstone_x86.lib")
#pragma comment(lib, "../pluginsdk/DeviceNameResolver/DeviceNameResolver_x86.lib")
#pragma comment(lib, "../pluginsdk/jansson/jansson_x86.lib")
#pragma comment(lib, "../pluginsdk/lz4/lz4_x86.lib")
#pragma comment(lib, "../pluginsdk/TitanEngine/TitanEngine_x86.lib")
#pragma comment(lib, "../pluginsdk/XEDParse/XEDParse_x86.lib")
#pragma comment(lib, "../pluginsdk/yara/yara_x86.lib")
#endif //_WIN64

using namespace Script;
namespace py = pybind11;

struct PyMemoryPage
{
    MEMPAGE page;

    PyMemoryPage() = default;

    PyMemoryPage(duint addr)
    {
        memset(&page, 0, sizeof(page));
        auto base = Memory::GetBase(addr, true);
        if(!base)
            throw std::invalid_argument("Invalid memory base.");
        if(!VirtualQueryEx(DbgGetProcessHandle(), (PVOID)base, &page.mbi, sizeof(MEMORY_BASIC_INFORMATION)))
            throw std::invalid_argument("Failed to query page information.");
        page.mbi.BaseAddress = (PVOID)base;
        page.mbi.RegionSize = Memory::GetSize(base, true);
        strcpy_s(page.info, "MemoryPage constructed from address, might not match memory map.");
    }

    std::string Str() const
    {
        char result[256] = "";
        sprintf_s(result, "base: 0x%llX, size: 0x%llX", uint64_t(Base()), uint64_t(Size()));
        return result;
    }

    duint Base() const { return (duint)page.mbi.BaseAddress; }
    duint Size() const { return (duint)page.mbi.RegionSize; }
    duint Protect() const { return (duint)page.mbi.Protect; }
    duint AllocBase() const { return (duint)page.mbi.AllocationBase; }
    duint AllocProtect() const { return (duint)page.mbi.AllocationProtect; }
    duint State() const { return (duint)page.mbi.State; }
    duint Type() const { return (duint)page.mbi.Type; }
    std::string Info() const { return page.info; }

    bool InRange(duint addr) const
    {
        auto base = Base();
        return addr >= base && addr < base + Size();
    }

    duint Find(const std::string & pattern, duint start = 0) const
    {
        auto base = Base();
        auto size = Size();

        if(start == 0)
            start = base;

        if(start < base || start >= base + size)
            throw std::invalid_argument("Start address not in page.");

        auto result = Pattern::FindMem(start, Size() - (start - base), pattern.c_str());
        if(result == -1) // to compensate for a bug/weirdness in x64dbg
            result = 0;
        return result;
    }

    std::vector<duint> FindAll(const std::string & pattern, duint start = 0) const
    {
        auto base = Base();
        auto size = Size();

        if(start == 0)
            start = base;

        if(start < base || start >= base + size)
            throw std::invalid_argument("Start address not in page.");

        std::vector<unsigned char> data;
        data.resize(size);
        if(!Memory::Read(base, data.data(), size, nullptr))
            return {};

        std::vector<duint> results;
        auto found = start - base;
        while(true)
        {
            auto foundoffset = Pattern::Find(data.data() + found, data.size() - found, pattern.c_str());
            if(foundoffset == -1)
                break;
            found += foundoffset;
            results.push_back(base + found);
            found++;
        }
        return results;
    }
};

struct PyMemory
{
    static py::bytes Read(duint addr, duint size)
    {
        auto data = std::unique_ptr<char[]>(new char[size]);
        duint sizeRead = 0;
        Memory::Read(addr, data.get(), size, &sizeRead);
        return py::bytes(data.get(), sizeRead);
    }

    static bool Write(duint addr, py::bytes data)
    {
        char* ptr;
        ssize_t size;
        PYBIND11_BYTES_AS_STRING_AND_SIZE(data.ptr(), &ptr, &size);
        return Memory::Write(addr, ptr, size, nullptr);
    }

    static duint RemoteAlloc(duint size)
    {
        return Memory::RemoteAlloc(0, size);
    }

    static unsigned int GetProtect(duint addr)
    {
        return Memory::GetProtect(addr);
    }

    static duint GetBase(duint addr)
    {
        return Memory::GetBase(addr);
    }

    static duint GetSize(duint addr)
    {
        return Memory::GetSize(addr);
    }

    static std::vector<PyMemoryPage> Map()
    {
        MEMMAP memmap = { 0 };
        if(!DbgMemMap(&memmap))
            throw std::invalid_argument("Failed to retrieve memory map.");
        std::vector<PyMemoryPage> result;
        if(memmap.count)
        {
            result.resize(memmap.count);
            for(int i = 0; i < memmap.count; i++)
                result[i].page = memmap.page[i];
            BridgeFree(memmap.page);
        }
        return result;
    }

    static duint Find(const std::string & pattern, duint start = 0)
    {
        auto map = Map();
        if(map.empty())
            throw std::invalid_argument("Cannot find in empty memory map.");

        if(start == 0)
            start = map[0].Base();

        auto startPage = std::find_if(map.begin(), map.end(), [start](const PyMemoryPage & page)
        {
            return page.InRange(start);
        });
        if(startPage == map.end())
            throw std::invalid_argument("Cannot find start address in memory map.");

        for(auto it = startPage; it != map.end(); ++it)
        {
            auto found = it->Find(pattern);
            if(found)
                return found;
        }

        return 0;
    }

    static std::vector<duint> FindAll(const std::string & pattern, duint start = 0)
    {
        auto map = Map();
        if(map.empty())
            throw std::invalid_argument("Cannot find in empty memory map.");

        if(start == 0)
            start = map[0].Base();

        auto startPage = std::find_if(map.begin(), map.end(), [start](const PyMemoryPage & page)
        {
            return page.InRange(start);
        });
        if(startPage == map.end())
            throw std::invalid_argument("Cannot find start address in memory map.");

        std::vector<duint> results;
        for(auto it = startPage; it != map.end(); ++it)
        {
            auto found = it->FindAll(pattern);
            results.insert(results.end(), found.begin(), found.end());
        }
        return results;
    }
};

struct PyRegister
{
};

struct PyDebugger
{
};

namespace
{
    using namespace Script::Module;

    struct PyModule
    {
        ModuleInfo info;
        std::vector<ModuleSectionInfo> sections;

        PyModule(duint base)
        {
            if(InfoFromAddr(base, &info))
            {
                ListInfo sectionList;
                if(SectionListFromAddr(info.base, &sectionList))
                    BridgeList<ModuleSectionInfo>::ToVector(&sectionList, sections);
            }
            else
                throw std::invalid_argument("Invalid module base.");
        }

        PyModule(std::string name)
        {
            if(InfoFromName(name.c_str(), &info))
            {
                ListInfo sectionList;
                if(SectionListFromAddr(info.base, &sectionList))
                    BridgeList<ModuleSectionInfo>::ToVector(&sectionList, sections);
            }
            else
                throw std::invalid_argument("Invalid module name.");
        }

        duint Base() const { return info.base; }
        duint Size() const { return info.size; }
        duint Entry() const { return info.entry; }
        std::string Name() const { return info.name; }
        std::string Path() const { return info.path; }
        std::vector<ModuleSectionInfo> Sections() const { return sections; }

        static PyModule Main()
        {
            return PyModule(GetMainModuleBase());
        }
    };
}

//https://stackoverflow.com/a/43526890/1806760
template <typename> struct FirstArgument;

template <typename R, typename A, typename... Args>
struct FirstArgument<R(A, Args...)>
{
    using type = A;
};

template <typename T>
using first_agument_t = typename FirstArgument<T>::type;

PYBIND11_MODULE(scriptapi, m)
{
#define arg(x) py::arg(#x)
#define pget(x) [](py::object) { return x(); }
#define pset(x) [](py::object, duint value) { return x(first_agument_t<decltype(x)>(value)); }

    m.doc() = "Python module to wrap the x64dbg script api.";
    m.def("main_module", []() {return PyModule(Script::Module::GetMainModuleBase()); }, "The main module object.");

    py::class_<PyMemoryPage>(m, "MemoryPage")
    .def(py::init<duint>()) //page = scriptapi.MemoryPage(0x400000)
    .def("__str__", &PyMemoryPage::Str)
    .def_property_readonly("base", &PyMemoryPage::Base, "MEMORY_BASIC_INFORMATION.BaseAddress")
    .def_property_readonly("size", &PyMemoryPage::Size, "MEMORY_BASIC_INFORMATION.RegionSize")
    .def_property_readonly("protect", &PyMemoryPage::Protect, "MEMORY_BASIC_INFORMATION.Protect")
    .def_property_readonly("alloc_base", &PyMemoryPage::AllocBase, "MEMORY_BASIC_INFORMATION.AllocationBase")
    .def_property_readonly("alloc_protect", &PyMemoryPage::AllocProtect, "MEMORY_BASIC_INFORMATION.AllocationProtect")
    .def_property_readonly("state", &PyMemoryPage::State, "MEMORY_BASIC_INFORMATION.State")
    .def_property_readonly("type", &PyMemoryPage::Type, "MEMORY_BASIC_INFORMATION.Type")
    .def_property_readonly("info", &PyMemoryPage::Info, "Additional information (module/section name).")
    .def("in_range", &PyMemoryPage::InRange, arg(addr), "Check if address in in range of the page.")
    .def("find", &PyMemoryPage::Find, arg(pattern), arg(start) = 0, "Find occurrence of pattern in page.")
    .def("find_all", &PyMemoryPage::FindAll, arg(pattern), arg(start) = 0, "Find all occurrences of pattern in page.");

    py::class_<PyMemory>(m, "Memory")
    .def(py::init<>()) //it's the pythonic way: mem = scriptapi.Memory()
    .def_static("read", PyMemory::Read, arg(addr), arg(size), "Read `size` bytes at `addr`.")
    .def_static("write", PyMemory::Write, arg(addr), arg(data), "Write `data` to `addr`.")
    .def_static("valid", Memory::IsValidPtr, arg(addr), "Returns if `addr` is a valid pointer.")
    .def_static("alloc", PyMemory::RemoteAlloc, arg(size), "Allocates `size` memory in the process.")
    .def_static("free", Memory::RemoteFree, arg(addr), "Frees memory at `addr` in the process.")
    .def_static("protection", PyMemory::GetProtect, arg(addr), "Get the page protection constant from `addr`.")
    .def_static("base", PyMemory::GetBase, arg(addr), "Get the base address of the page at `addr`.")
    .def_static("size", PyMemory::GetSize, arg(addr), "Get the size of the page at `addr`.")
    .def_static("read_byte", Memory::ReadByte, arg(addr), "Read a byte at `addr`.")
    .def_static("write_byte", Memory::WriteByte, arg(addr), arg(value), "Write `value` as a byte to `addr`.")
    .def_static("read_word", Memory::ReadWord, arg(addr), "Read a word at `addr`.")
    .def_static("write_word", Memory::WriteWord, arg(addr), arg(value), "Write `value` as a word to `addr`.")
    .def_static("read_dword", Memory::ReadDword, arg(addr), "Read a dword at `addr`.")
    .def_static("write_dword", Memory::WriteDword, arg(addr), arg(value), "Write `value` as a dword to `addr`.")
    .def_static("read_qword", Memory::ReadQword, arg(addr), "Read a qword at `addr`.")
    .def_static("write_qword", Memory::WriteQword, arg(addr), arg(value), "Write `value` as a qword to `addr`.")
    .def_static("read_ptr", Memory::ReadPtr, arg(addr), "Read a pointer at `addr`.")
    .def_static("write_ptr", Memory::WritePtr, arg(addr), arg(value), "Write `value` as a pointer to `addr`.")
    .def_property_readonly_static("map", pget(PyMemory::Map), "Get list of MemoryPages forming the memory map.")
    .def_static("find", PyMemory::Find, arg(pattern), arg(start) = 0, "Find single occurence of a pattern in memory.")
    .def_static("find_all", PyMemory::FindAll, arg(pattern), arg(start) = 0, "Find all occurences of a pattern in memory.");

    py::class_<PyRegister>(m, "Registers")
    .def(py::init<>()) //it's the pythonic way: regs = scriptapi.Registers()
    .def_property_static("dr0", pget(Register::GetDR0), pset(Register::SetDR0))
    .def_property_static("dr1", pget(Register::GetDR1), pset(Register::SetDR1))
    .def_property_static("dr2", pget(Register::GetDR2), pset(Register::SetDR2))
    .def_property_static("dr3", pget(Register::GetDR3), pset(Register::SetDR3))
    .def_property_static("dr6", pget(Register::GetDR6), pset(Register::SetDR6))
    .def_property_static("dr7", pget(Register::GetDR7), pset(Register::SetDR7))

    .def_property_static("eax", pget(Register::GetEAX), pset(Register::SetEAX))
    .def_property_static("ax", pget(Register::GetAX), pset(Register::SetAX))
    .def_property_static("ah", pget(Register::GetAH), pset(Register::SetAH))
    .def_property_static("al", pget(Register::GetAL), pset(Register::SetAL))
    .def_property_static("ebx", pget(Register::GetEBX), pset(Register::SetEBX))
    .def_property_static("bx", pget(Register::GetBX), pset(Register::SetBX))
    .def_property_static("bh", pget(Register::GetBH), pset(Register::SetBH))
    .def_property_static("bl", pget(Register::GetBL), pset(Register::SetBL))
    .def_property_static("ecx", pget(Register::GetECX), pset(Register::SetECX))
    .def_property_static("cx", pget(Register::GetCX), pset(Register::SetCX))
    .def_property_static("ch", pget(Register::GetCH), pset(Register::SetCH))
    .def_property_static("cl", pget(Register::GetCL), pset(Register::SetCL))
    .def_property_static("edx", pget(Register::GetEDX), pset(Register::SetEDX))
    .def_property_static("dx", pget(Register::GetDX), pset(Register::SetDX))
    .def_property_static("dh", pget(Register::GetDH), pset(Register::SetDH))
    .def_property_static("dl", pget(Register::GetDL), pset(Register::SetDL))
    .def_property_static("edi", pget(Register::GetEDI), pset(Register::SetEDI))
    .def_property_static("di", pget(Register::GetDI), pset(Register::SetDI))
    .def_property_static("esi", pget(Register::GetESI), pset(Register::SetESI))
    .def_property_static("si", pget(Register::GetSI), pset(Register::SetSI))
    .def_property_static("ebp", pget(Register::GetEBP), pset(Register::SetEBP))
    .def_property_static("bp", pget(Register::GetBP), pset(Register::SetBP))
    .def_property_static("esp", pget(Register::GetESP), pset(Register::SetESP))
    .def_property_static("sp", pget(Register::GetSP), pset(Register::SetSP))
    .def_property_static("eip", pget(Register::GetEIP), pset(Register::SetEIP))
    .def_property_static("eflags", pget(Register::GetCFLAGS), pset(Register::SetCFLAGS))

#ifdef _WIN64
    .def_property_static("rax", pget(Register::GetRAX), pset(Register::SetRAX))
    .def_property_static("rbx", pget(Register::GetRBX), pset(Register::SetRBX))
    .def_property_static("rcx", pget(Register::GetRCX), pset(Register::SetRCX))
    .def_property_static("rdx", pget(Register::GetRDX), pset(Register::SetRDX))
    .def_property_static("rsi", pget(Register::GetRSI), pset(Register::SetRSI))
    .def_property_static("sil", pget(Register::GetSIL), pset(Register::SetSIL))
    .def_property_static("rdi", pget(Register::GetRDI), pset(Register::SetRDI))
    .def_property_static("dil", pget(Register::GetDIL), pset(Register::SetDIL))
    .def_property_static("rbp", pget(Register::GetRBP), pset(Register::SetRBP))
    .def_property_static("bpl", pget(Register::GetBPL), pset(Register::SetBPL))
    .def_property_static("rsp", pget(Register::GetRSP), pset(Register::SetRSP))
    .def_property_static("spl", pget(Register::GetSPL), pset(Register::SetSPL))
    .def_property_static("rip", pget(Register::GetRIP), pset(Register::SetRIP))
    .def_property_static("r8", pget(Register::GetR8), pset(Register::SetR8))
    .def_property_static("r8d", pget(Register::GetR8D), pset(Register::SetR8D))
    .def_property_static("r8w", pget(Register::GetR8W), pset(Register::SetR8W))
    .def_property_static("r8b", pget(Register::GetR8B), pset(Register::SetR8B))
    .def_property_static("r9", pget(Register::GetR9), pset(Register::SetR9))
    .def_property_static("r9d", pget(Register::GetR9D), pset(Register::SetR9D))
    .def_property_static("r9w", pget(Register::GetR9W), pset(Register::SetR9W))
    .def_property_static("r9b", pget(Register::GetR9B), pset(Register::SetR9B))
    .def_property_static("r10", pget(Register::GetR10), pset(Register::SetR10))
    .def_property_static("r10d", pget(Register::GetR10D), pset(Register::SetR10D))
    .def_property_static("r10w", pget(Register::GetR10W), pset(Register::SetR10W))
    .def_property_static("r10b", pget(Register::GetR10B), pset(Register::SetR10B))
    .def_property_static("r11", pget(Register::GetR11), pset(Register::SetR11))
    .def_property_static("r11d", pget(Register::GetR11D), pset(Register::SetR11D))
    .def_property_static("r11w", pget(Register::GetR11W), pset(Register::SetR11W))
    .def_property_static("r11b", pget(Register::GetR11B), pset(Register::SetR11B))
    .def_property_static("r12", pget(Register::GetR12), pset(Register::SetR12))
    .def_property_static("r12d", pget(Register::GetR12D), pset(Register::SetR12D))
    .def_property_static("r12w", pget(Register::GetR12W), pset(Register::SetR12W))
    .def_property_static("r12b", pget(Register::GetR12B), pset(Register::SetR12B))
    .def_property_static("r13", pget(Register::GetR13), pset(Register::SetR13))
    .def_property_static("r13d", pget(Register::GetR13D), pset(Register::SetR13D))
    .def_property_static("r13w", pget(Register::GetR13W), pset(Register::SetR13W))
    .def_property_static("r13b", pget(Register::GetR13B), pset(Register::SetR13B))
    .def_property_static("r14", pget(Register::GetR14), pset(Register::SetR14))
    .def_property_static("r14d", pget(Register::GetR14D), pset(Register::SetR14D))
    .def_property_static("r14w", pget(Register::GetR14W), pset(Register::SetR14W))
    .def_property_static("r14b", pget(Register::GetR14B), pset(Register::SetR14B))
    .def_property_static("r15", pget(Register::GetR15), pset(Register::SetR15))
    .def_property_static("r15d", pget(Register::GetR15D), pset(Register::SetR15D))
    .def_property_static("r15w", pget(Register::GetR15W), pset(Register::SetR15W))
    .def_property_static("r15b", pget(Register::GetR15B), pset(Register::SetR15B))
    .def_property_static("rflags", pget(Register::GetCFLAGS), pset(Register::SetCFLAGS))
#endif //_WIN64

    .def_property_static("cax", pget(Register::GetCAX), pset(Register::SetCAX))
    .def_property_static("cbx", pget(Register::GetCBX), pset(Register::SetCBX))
    .def_property_static("ccx", pget(Register::GetCCX), pset(Register::SetCCX))
    .def_property_static("cdx", pget(Register::GetCDX), pset(Register::SetCDX))
    .def_property_static("cdi", pget(Register::GetCDI), pset(Register::SetCDI))
    .def_property_static("csi", pget(Register::GetCSI), pset(Register::SetCSI))
    .def_property_static("cbp", pget(Register::GetCBP), pset(Register::SetCBP))
    .def_property_static("csp", pget(Register::GetCSP), pset(Register::SetCSP))
    .def_property_static("cip", pget(Register::GetCIP), pset(Register::SetCIP))
    .def_property_static("cflags", pget(Register::GetCFLAGS), pset(Register::SetCFLAGS));

    py::class_<PyDebugger>(m, "Debugger")
    .def(py::init<>()); //it's the pythonic way: dbg = scriptapi.Debugger()

    py::class_<Script::Module::ModuleSectionInfo>(m, "ModuleSection")
    .def_property_readonly("addr", [](const Script::Module::ModuleSectionInfo & info) { return info.addr; }, "Start of the section.")
    .def_property_readonly("size", [](const Script::Module::ModuleSectionInfo & info) { return info.size; }, "Size of the section.")
    .def_property_readonly("name", [](const Script::Module::ModuleSectionInfo & info) { return info.name; }, "Name of the section.");

    py::class_<PyModule>(m, "Module")
    .def(py::init<duint>()) //mod = scriptapi.Module(0x400000)
    .def(py::init<std::string>()) //mod = scriptapi.Module("ntdll.dll")
    .def_property_readonly("base", &PyModule::Base, "Base address of the module.")
    .def_property_readonly("size", &PyModule::Size, "Size of the module.")
    .def_property_readonly("entry", &PyModule::Entry, "Entry point of the module.")
    .def_property_readonly("name", &PyModule::Name, "Full filename of the module.")
    .def_property_readonly("path", &PyModule::Path, "Full path of the module.")
    .def_property_readonly("sections", &PyModule::Sections, "Sections of the module.");
}


================================================
File: scriptapi/scriptapi.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{6E9A40BD-80E1-4C24-92BD-A402D9BE1419}</ProjectGuid>
    <RootNamespace>scriptapi</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetExt>.pyd</TargetExt>
    <IncludePath>$(SolutionDir)pybind11\include;$(Python27x86)\include;$(VC_IncludePath);$(WindowsSdk_71A_IncludePath);</IncludePath>
    <LibraryPath>$(Python27x86)\libs;$(VC_LibraryPath_x86);$(WindowsSdk_71A_LibraryPath_x86);</LibraryPath>
    <OutDir>$(SolutionDir)bin\x32\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetExt>.pyd</TargetExt>
    <IncludePath>$(SolutionDir)pybind11\include;$(Python27x64)\include;$(VC_IncludePath);$(WindowsSdk_71A_IncludePath);</IncludePath>
    <LibraryPath>$(Python27x64)\libs;$(VC_LibraryPath_x64);$(WindowsSdk_71A_LibraryPath_x64);</LibraryPath>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="scriptapi.cpp">
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NOMINMAX;_CRT_SECURE_NO_WARNINGS;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NOMINMAX;_CRT_SECURE_NO_WARNINGS;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: scriptapi/scriptapi.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="scriptapi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>


================================================
File: swig/_plugins.i
================================================
%module _plugins
%{
#include <windows.h>
#include "_plugins.h"
%}

%include <windows.i>
%include "..\pluginsdk\_plugins.h"


================================================
File: swig/_scriptapi.i
================================================
%module _scriptapi
%{
#include <windows.h>
#include "_scriptapi.h"
%}

%include <windows.i>
%include "..\pluginsdk\_scriptapi.h"

%include "_scriptapi_argument.i"
%include "_scriptapi_bookmark.i"
%include "_scriptapi_comment.i"
%include "_scriptapi_debug.i"
%include "_scriptapi_function.i"
%include "_scriptapi_label.i"
%include "_scriptapi_symbol.i"
%include "_scriptapi_memory.i"
%include "_scriptapi_register.i"
%include "_scriptapi_pattern.i"
%include "_scriptapi_gui.i"
%include "_scriptapi_misc.i"
%include "_scriptapi_stack.i"
%include "_scriptapi_assembler.i"
%include "_scriptapi_module.i"
%include "_scriptapi_flag.i"



================================================
File: swig/_scriptapi_argument.i
================================================
%module _scriptapi_argument
%{
#include "_scriptapi_argument.h"
%}

%rename(Argument_Add) Script::Argument::Add;
%rename(Argument_Get) Script::Argument::Get;
%rename(Argument_GetInfo) Script::Argument::GetInfo;
%rename(Argument_Overlaps) Script::Argument::Overlaps;
%rename(Argument_Delete) Script::Argument::Delete;
%rename(Argument_DeleteRange) Script::Argument::DeleteRange;
%rename(Argument_Clear) Script::Argument::Clear;
%rename(Argument_GetList) Script::Argument::GetList;

%apply duint *INOUT { duint *start };
%apply duint *INOUT { duint *end };
%apply duint *INOUT { duint *instructionCount };

%include "..\pluginsdk\_scriptapi_argument.h"

%ListInfo_func(Script::Argument::ArgumentInfo,GetArgumentInfoList)



================================================
File: swig/_scriptapi_assembler.i
================================================
%module _scriptapi_assembler
%{
#include "_scriptapi_assembler.h"
%}

// Type Maps
%pybuffer_string(char *error);
%pybuffer_string(unsigned char *dest)

%apply int *OUTPUT { int *size };

%include "..\pluginsdk\_scriptapi_assembler.h"



================================================
File: swig/_scriptapi_bookmark.i
================================================
%module _scriptapi_bookmark
%{
#include "_scriptapi_bookmark.h"
%}

%rename(Bookmark_Get) Script::Bookmark::Get;
%rename(Bookmark_Set) Script::Bookmark::Set;
%rename(Bookmark_GetInfo) Script::Bookmark::GetInfo;
%rename(Bookmark_Delete) Script::Bookmark::Delete;
%rename(Bookmark_DeleteRange) Script::Bookmark::DeleteRange;
%rename(Bookmark_Clear) Script::Bookmark::Clear;
%rename(Bookmark_GetList) Script::Bookmark::GetList;

%include "..\pluginsdk\_scriptapi_bookmark.h"

%ListInfo_func(Script::Bookmark::BookmarkInfo,GetBookmarkInfoList)



================================================
File: swig/_scriptapi_comment.i
================================================
%module _scriptapi_comment
%{
#include "_scriptapi_comment.h"
%}

%rename(Comment_Get) Script::Comment::Get;
%rename(Comment_Set) Script::Comment::Set;
%rename(Comment_GetInfo) Script::Comment::GetInfo;
%rename(Comment_Delete) Script::Comment::Delete;
%rename(Comment_DeleteRange) Script::Comment::DeleteRange;
%rename(Comment_Clear) Script::Comment::Clear;
%rename(Comment_GetList) Script::Comment::GetList;

%include "..\pluginsdk\_scriptapi_comment.h"

%ListInfo_func(Script::Comment::CommentInfo,GetCommentInfoList)



================================================
File: swig/_scriptapi_debug.i
================================================
%module _scriptapi_debug
%{
#include "_scriptapi_debug.h"
%}

%include "..\pluginsdk\_scriptapi_debug.h"



================================================
File: swig/_scriptapi_flag.i
================================================
%module _scriptapi_flag
%{
#include "_scriptapi_flag.h"
%}

%rename(Flag_Get) Script::Flag::Get;
%rename(Flag_Set) Script::Flag::Set;

%include "..\pluginsdk\_scriptapi_flag.h"



================================================
File: swig/_scriptapi_function.i
================================================
%module _scriptapi_function
%{
#include "_scriptapi_function.h"
%}

%rename(Function_Add) Script::Function::Add;
%rename(Function_Get) Script::Function::Get;
%rename(Function_GetInfo) Script::Function::GetInfo;
%rename(Function_Overlaps) Script::Function::Overlaps;
%rename(Function_Delete) Script::Function::Delete;
%rename(Function_DeleteRange) Script::Function::DeleteRange;
%rename(Function_Clear) Script::Function::Clear;
%rename(Function_GetList) Script::Function::GetList;

%apply duint *INOUT { duint *start };
%apply duint *INOUT { duint *end };
%apply duint *INOUT { duint *instructionCount };

%include "..\pluginsdk\_scriptapi_function.h"

%ListInfo_func(Script::Function::FunctionInfo,GetFunctionInfoList)



================================================
File: swig/_scriptapi_gui.i
================================================
%module _scriptapi_gui
%{
#include "_scriptapi_gui.h"
%}

%rename(Gui_SelectionGet) Script::Gui::SelectionGet;
%rename(Gui_SelectionSet) Script::Gui::SelectionSet;
%rename(Gui_SelectionGetStart) Script::Gui::SelectionGetStart;
%rename(Gui_SelectionGetEnd) Script::Gui::SelectionGetEnd;

%rename(Disassembly_SelectionGet) Script::Gui::Disassembly::SelectionGet;
%rename(Disassembly_SelectionSet) Script::Gui::Disassembly::SelectionSet;
%rename(Disassembly_SelectionGetStart) Script::Gui::Disassembly::SelectionGetStart;
%rename(Disassembly_SelectionGetEnd) Script::Gui::Disassembly::SelectionGetEnd;

%rename(Dump_SelectionGet) Script::Gui::Dump::SelectionGet;
%rename(Dump_SelectionSet) Script::Gui::Dump::SelectionSet;
%rename(Dump_SelectionGetStart) Script::Gui::Dump::SelectionGetStart;
%rename(Dump_SelectionGetEnd) Script::Gui::Dump::SelectionGetEnd;

%rename(Stack_SelectionGet) Script::Gui::Stack::SelectionGet;
%rename(Stack_SelectionSet) Script::Gui::Stack::SelectionSet;
%rename(Stack_SelectionGetStart) Script::Gui::Stack::SelectionGetStart;
%rename(Stack_SelectionGetEnd) Script::Gui::Stack::SelectionGetEnd;

%rename(Graph_SelectionGetStart) Script::Gui::Graph::SelectionGetStart;
%rename(MemMap_SelectionGetStart) Script::Gui::MemMap::SelectionGetStart;
%rename(SymMod_SelectionGetStart) Script::Gui::SymMod::SelectionGetStart;

%apply duint *OUTPUT { duint *value };
%apply duint *OUTPUT { duint *start };
%apply duint *OUTPUT { duint *end };

%include "..\pluginsdk\_scriptapi_gui.h"



================================================
File: swig/_scriptapi_label.i
================================================
%module _scriptapi_label
%{
#include "_scriptapi_label.h"
%}

%rename(Label_Get) Script::Label::Get;
%rename(Label_Set) Script::Label::Set;
%rename(Label_GetInfo) Script::Label::GetInfo;
%rename(Label_Delete) Script::Label::Delete;
%rename(Label_DeleteRange) Script::Label::DeleteRange;
%rename(Label_Clear) Script::Label::Clear;
%rename(Label_GetList) Script::Label::GetList;

%apply duint *OUTPUT { duint *addr };

%include "..\pluginsdk\_scriptapi_label.h"

%ListInfo_func(Script::Label::LabelInfo,GetLabelInfoList)



================================================
File: swig/_scriptapi_memory.i
================================================
%module _scriptapi_memory
%{
#include "_scriptapi_memory.h"
%}

// Type Maps
%include <pybuffer.i>
%pybuffer_string(void* data);
%apply duint *OUTPUT { duint *sizeRead };
%apply duint *OUTPUT { duint *sizeWritten };
%pybuffer_binary(parm, size_parm)

%rename(Memory_Read) Script::Memory::Read;
%rename(Memory_Write) Script::Memory::Write;

%include "..\pluginsdk\_scriptapi_memory.h"



================================================
File: swig/_scriptapi_misc.i
================================================
%module _scriptapi_misc
%{
#include "_scriptapi_misc.h"
%}

%apply duint *OUTPUT { duint *value };

%include "..\pluginsdk\_scriptapi_misc.h"



================================================
File: swig/_scriptapi_module.i
================================================
%module _scriptapi_module
%{
#include "_scriptapi_module.h"
%}

// Type Maps
%include <pybuffer.i>
%pybuffer_string(char* name);
%pybuffer_string(char* path);

%ListInfo_func(Script::Module::ModuleInfo,GetModuleInfoList)
%ListInfo_func(Script::Module::ModuleSectionInfo,GetModuleSectionInfoList)

%include "..\pluginsdk\_scriptapi_module.h"



================================================
File: swig/_scriptapi_pattern.i
================================================
%module _scriptapi_pattern
%{
#include "_scriptapi_pattern.h"
%}

%pybuffer_mutable_binary(unsigned char* data, duint datasize)

%rename(Pattern_Write) Script::Pattern::Write;
%rename(Pattern_WriteMem) Script::Pattern::WriteMem;

%include "..\pluginsdk\_scriptapi_pattern.h"



================================================
File: swig/_scriptapi_register.i
================================================
%module _scriptapi_register
%{
#include "_scriptapi_register.h"
%}

%include "..\pluginsdk\_scriptapi_register.h"



================================================
File: swig/_scriptapi_stack.i
================================================
%module _scriptapi_stack
%{
#include "_scriptapi_stack.h"
%}

%include "..\pluginsdk\_scriptapi_stack.h"



================================================
File: swig/_scriptapi_symbol.i
================================================
%module _scriptapi_symbol
%{
#include "_scriptapi_symbol.h"
%}

%rename(Symbol_GetList) Script::Symbol::GetList;

%include "..\pluginsdk\_scriptapi_symbol.h"

%ListInfo_func(Script::Symbol::SymbolInfo,GetSymbolInfoList)



================================================
File: swig/bridgelist.i
================================================
%module bridgemain
%{
#include "bridgelist.h"
%}

%include "..\pluginsdk\bridgelist.h"

%include "std_vector.i"

%define %ListInfo_func(TYPE,NAME)

%template(vector##NAME) std::vector<TYPE>;

%inline %{
std::vector<TYPE> NAME(ListInfo* l)
{
    std::vector<TYPE> vec(
        (TYPE*)l->data,
        (TYPE*)((byte*)l->data + l->size));
    BridgeFree(l->data);
    return vec;
}
%}

%enddef



================================================
File: swig/bridgemain.i
================================================
%module bridgemain
%{
#include "bridgemain.h"
#define nullptr 0
%}

// Allow Python Buffers
%include <pybuffer.i>

// Type Maps
%pybuffer_string(char* text);

%typemap(out) HWND {
    $result = PyInt_FromLong((long)$1);
}

%include "std_vector.i"

%template(ThreadVector) std::vector<THREADALLINFO>;

%inline %{
std::vector<THREADALLINFO> GetThreadInfoList(THREADLIST* l)
{
    std::vector<THREADALLINFO> vec(
        l->list,
        l->list + l->count
    );
    BridgeFree(l->list);
    return vec;
}
%}

%template(BpVector) std::vector<BRIDGEBP>;

%inline %{
std::vector<BRIDGEBP> GetBpList(BPMAP* bm)
{
    std::vector<BRIDGEBP> vec(
        bm->bp,
        bm->bp + bm->count
    );
    BridgeFree(bm->bp);
    return vec;
}
%}

%include <windows.i>
#define DECLSPEC_ALIGN(x) __declspec(align(x))
%include "..\pluginsdk\bridgemain.h"


================================================
File: swig/clean.bat
================================================
@echo off
del /Q x64dbg_wrap.cpp
del /Q x64dbgpy\pluginsdk\x64dbg.py
rmdir /S /Q build


================================================
File: swig/setup.py
================================================
#!/usr/bin/env python
import sys
from distutils.core import setup, Extension
from distutils.command.build import build


def is_64bit():
    return sys.maxsize > 2 ** 32


class SwigBuild(build):
    def run(self):
        self.run_command('build_ext')
        build.run(self)


setup(
    name='x64dbgpy',
    version='1.0',
    description='Python x64dbg SDK Library',
    author='Tomer Zait (RealGame)',
    author_email='realgam3@gmail.com',
    packages=[
        'x64dbgpy',
        'x64dbgpy.pluginsdk',
        'x64dbgpy.pluginsdk._scriptapi'
    ],
    package_data={
        'x64dbgpy': ['autorun/*']
    },
    ext_modules=[Extension(
        r'x64dbgpy.pluginsdk._x64dbg', [r'x64dbg.i'],
        swig_opts=['-Wall', '-c++', '-outputtuple',
                   '-outdir', r'x64dbgpy\pluginsdk',
                   '-D"_WIN64"' if is_64bit() else ''],
        language='c++',
        include_dirs=[r'..\pluginsdk', r'include'],
        library_dirs=[r'..\pluginsdk'],
        libraries=['x64bridge', 'x64dbg'] if is_64bit() else ['x32bridge', 'x32dbg'],
        extra_compile_args=['/EHsc', '/MT'],
    )],
    py_modules=['x64dbgpy.pluginsdk.x64dbg'],
    cmdclass={'build': SwigBuild},
)



================================================
File: swig/x64dbg.i
================================================
%module x64dbg

// bridgelist.h
%include "bridgelist.i"

// bridgemain.h
%include "bridgemain.i"

// _plugins.h
%include "_plugins.i"

//_scriptapi.h
%include "_scriptapi.i"



================================================
File: swig/include/stdint.h
================================================
/* stdint.h standard header */
#pragma once
#ifndef _STDINT
#define _STDINT
#ifndef RC_INVOKED
#include <crtdefs.h>

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

#ifndef _INTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#ifdef _WIN64
typedef long long          intptr_t;
#else /* _WIN64 */
typedef _W64 int           intptr_t;
#endif /* _WIN64 */
#endif /* _INTPTR_T_DEFINED */

#ifndef _UINTPTR_T_DEFINED
#define _UINTPTR_T_DEFINED
#ifdef _WIN64
typedef unsigned long long uintptr_t;
#else /* _WIN64 */
typedef _W64 unsigned int  uintptr_t;
#endif /* _WIN64 */
#endif /* _UINTPTR_T_DEFINED */

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

/* These macros must exactly match those in the Windows SDK's intsafe.h */
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64

#define INT_LEAST8_MIN   INT8_MIN
#define INT_LEAST16_MIN  INT16_MIN
#define INT_LEAST32_MIN  INT32_MIN
#define INT_LEAST64_MIN  INT64_MIN
#define INT_LEAST8_MAX   INT8_MAX
#define INT_LEAST16_MAX  INT16_MAX
#define INT_LEAST32_MAX  INT32_MAX
#define INT_LEAST64_MAX  INT64_MAX
#define UINT_LEAST8_MAX  UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INT_FAST8_MIN    INT8_MIN
#define INT_FAST16_MIN   INT32_MIN
#define INT_FAST32_MIN   INT32_MIN
#define INT_FAST64_MIN   INT64_MIN
#define INT_FAST8_MAX    INT8_MAX
#define INT_FAST16_MAX   INT32_MAX
#define INT_FAST32_MAX   INT32_MAX
#define INT_FAST64_MAX   INT64_MAX
#define UINT_FAST8_MAX   UINT8_MAX
#define UINT_FAST16_MAX  UINT32_MAX
#define UINT_FAST32_MAX  UINT32_MAX
#define UINT_FAST64_MAX  UINT64_MAX

#ifdef _WIN64
#define INTPTR_MIN      INT64_MIN
#define INTPTR_MAX      INT64_MAX
#define UINTPTR_MAX     UINT64_MAX
#else /* _WIN64 */
#define INTPTR_MIN      INT32_MIN
#define INTPTR_MAX      INT32_MAX
#define UINTPTR_MAX     UINT32_MAX
#endif /* _WIN64 */

#define INTMAX_MIN       INT64_MIN
#define INTMAX_MAX       INT64_MAX
#define UINTMAX_MAX      UINT64_MAX

#define PTRDIFF_MIN      INTPTR_MIN
#define PTRDIFF_MAX      INTPTR_MAX

#ifndef SIZE_MAX
#define SIZE_MAX        UINTPTR_MAX
#endif /* SIZE_MAX */

#define SIG_ATOMIC_MIN   INT32_MIN
#define SIG_ATOMIC_MAX   INT32_MAX

#ifndef WCHAR_MIN
#define WCHAR_MIN        0x0000
#endif //WCHAR_MIN
#ifndef WCHAR_MAX
#define WCHAR_MAX        0xffff
#endif //WCHAR_MAX

#define WINT_MIN         0x0000
#define WINT_MAX         0xffff

#define INT8_C(x)    (x)
#define INT16_C(x)   (x)
#define INT32_C(x)   (x)
#define INT64_C(x)   (x ## LL)

#define UINT8_C(x)   (x)
#define UINT16_C(x)  (x)
#define UINT32_C(x)  (x ## U)
#define UINT64_C(x)  (x ## ULL)

#define INTMAX_C(x)  INT64_C(x)
#define UINTMAX_C(x) UINT64_C(x)
#endif /* RC_INVOKED */
#endif /* _STDINT */

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V6.00:0009 */



================================================
File: swig/swigwin-3.0.8/Lib/allkw.swg
================================================
#ifndef __Lib_allkw_swg__
#define __Lib_allkw_swg__


/*  
  Include all the known keyword warnings.  Very useful for adding test
  files to the test-suite, or checking if your own library is ok for all
  the swig supported languages.

  Use as 

    swig -Wallkw ...

  If you add a new language, remember to create a separate languagekw.swg
  file, and add it here.
  
*/

%include <chicken/chickenkw.swg>
%include <csharp/csharpkw.swg>
%include <d/dkw.swg>
%include <go/gokw.swg>
%include <java/javakw.swg>
%include <lua/luakw.swg>
%include <ocaml/ocamlkw.swg>
%include <perl5/perlkw.swg>
%include <php/phpkw.swg>
%include <pike/pikekw.swg>
%include <python/pythonkw.swg>
%include <r/rkw.swg>
%include <ruby/rubykw.swg>
%include <tcl/tclkw.swg>


#endif //__Lib_allkw_swg__



================================================
File: swig/swigwin-3.0.8/Lib/attribute.i
================================================
/* -----------------------------------------------------------------------------
 * attribute.i
 *
 * SWIG library file for implementing attributes.
 * ----------------------------------------------------------------------------- */

/* we use a simple exception warning here */
%{
#include <stdio.h>
%}
#define %attribute_exception(code,msg) printf("%s\n",msg)

#ifndef %arg
#define %arg(x...) x
#endif

#ifndef %mangle
#define %mangle(Type...)  #@Type
#endif

%include <typemaps/attribute.swg>



================================================
File: swig/swigwin-3.0.8/Lib/carrays.i
================================================
/* -----------------------------------------------------------------------------
 * carrays.i
 *
 * SWIG library file containing macros that can be used to manipulate simple
 * pointers as arrays.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * %array_functions(TYPE,NAME)
 *
 * Generates functions for creating and accessing elements of a C array
 * (as pointers).  Creates the following functions:
 *
 *        TYPE *new_NAME(int nelements)
 *        void delete_NAME(TYPE *);
 *        TYPE NAME_getitem(TYPE *, int index);
 *        void NAME_setitem(TYPE *, int index, TYPE value);
 * 
 * ----------------------------------------------------------------------------- */

%define %array_functions(TYPE,NAME)
%{
static TYPE *new_##NAME(int nelements) { %}
#ifdef __cplusplus
%{  return new TYPE[nelements](); %}
#else
%{  return (TYPE *) calloc(nelements,sizeof(TYPE)); %}
#endif
%{}

static void delete_##NAME(TYPE *ary) { %}
#ifdef __cplusplus
%{  delete [] ary; %}
#else
%{  free(ary); %}
#endif
%{}

static TYPE NAME##_getitem(TYPE *ary, int index) {
    return ary[index];
}
static void NAME##_setitem(TYPE *ary, int index, TYPE value) {
    ary[index] = value;
}
%}

TYPE *new_##NAME(int nelements);
void delete_##NAME(TYPE *ary);
TYPE NAME##_getitem(TYPE *ary, int index);
void NAME##_setitem(TYPE *ary, int index, TYPE value);

%enddef


/* -----------------------------------------------------------------------------
 * %array_class(TYPE,NAME)
 *
 * Generates a class wrapper around a C array.  The class has the following
 * interface:
 *
 *          struct NAME {
 *              NAME(int nelements);
 *             ~NAME();
 *              TYPE getitem(int index);
 *              void setitem(int index, TYPE value);
 *              TYPE * cast();
 *              static NAME *frompointer(TYPE *t);
  *         }
 *
 * ----------------------------------------------------------------------------- */

%define %array_class(TYPE,NAME)
%{
typedef TYPE NAME;
%}
typedef struct {
  /* Put language specific enhancements here */
} NAME;

%extend NAME {

#ifdef __cplusplus
NAME(int nelements) {
  return new TYPE[nelements]();
}
~NAME() {
  delete [] self;
}
#else
NAME(int nelements) {
  return (TYPE *) calloc(nelements,sizeof(TYPE));
}
~NAME() {
  free(self);
}
#endif

TYPE getitem(int index) {
  return self[index];
}
void setitem(int index, TYPE value) {
  self[index] = value;
}
TYPE * cast() {
  return self;
}
static NAME *frompointer(TYPE *t) {
  return (NAME *) t;
}

};

%types(NAME = TYPE);

%enddef




================================================
File: swig/swigwin-3.0.8/Lib/cdata.i
================================================
/* -----------------------------------------------------------------------------
 * cdata.i
 *
 * SWIG library file containing macros for manipulating raw C data as strings.
 * ----------------------------------------------------------------------------- */

%{
typedef struct SWIGCDATA {
    char *data;
    int   len;
} SWIGCDATA;
%}

/* -----------------------------------------------------------------------------
 * Typemaps for returning binary data
 * ----------------------------------------------------------------------------- */

#if SWIGGUILE
%typemap(out) SWIGCDATA {
   $result = scm_from_locale_stringn($1.data,$1.len);
}
%typemap(in) (const void *indata, int inlen) = (char *STRING, int LENGTH);

#elif SWIGCHICKEN

%typemap(out) SWIGCDATA {
  C_word *string_space = C_alloc(C_SIZEOF_STRING($1.len));
  $result = C_string(&string_space, $1.len, $1.data);
}
%typemap(in) (const void *indata, int inlen) = (char *STRING, int LENGTH);

#elif SWIGPHP

%typemap(out) SWIGCDATA {
  ZVAL_STRINGL($result, $1.data, $1.len, 1);
}
%typemap(in) (const void *indata, int inlen) = (char *STRING, int LENGTH);

#elif SWIGJAVA

%apply (char *STRING, int LENGTH) { (const void *indata, int inlen) }
%typemap(jni) SWIGCDATA "jbyteArray"
%typemap(jtype) SWIGCDATA "byte[]"
%typemap(jstype) SWIGCDATA "byte[]"
%fragment("SWIG_JavaArrayOutCDATA", "header") {
static jbyteArray SWIG_JavaArrayOutCDATA(JNIEnv *jenv, char *result, jsize sz) {
  jbyte *arr;
  int i;
  jbyteArray jresult = JCALL1(NewByteArray, jenv, sz);
  if (!jresult)
    return NULL;
  arr = JCALL2(GetByteArrayElements, jenv, jresult, 0);
  if (!arr)
    return NULL;
  for (i=0; i<sz; i++)
    arr[i] = (jbyte)result[i];
  JCALL3(ReleaseByteArrayElements, jenv, jresult, arr, 0);
  return jresult;
}
}
%typemap(out, fragment="SWIG_JavaArrayOutCDATA") SWIGCDATA
%{$result = SWIG_JavaArrayOutCDATA(jenv, (char *)$1.data, $1.len); %}
%typemap(javaout) SWIGCDATA {
    return $jnicall;
  }

#else
%echo "cdata.i module not supported."
#endif


/* -----------------------------------------------------------------------------
 * %cdata(TYPE [, NAME]) 
 *
 * Convert raw C data to a binary string.
 * ----------------------------------------------------------------------------- */

%define %cdata(TYPE,NAME...)

%insert("header") {
#if #NAME == ""
static SWIGCDATA cdata_##TYPE(TYPE *ptr, int nelements) {
#else
static SWIGCDATA cdata_##NAME(TYPE *ptr, int nelements) {
#endif
   SWIGCDATA d;
   d.data = (char *) ptr;
#if #TYPE != "void"
   d.len  = nelements*sizeof(TYPE);
#else
   d.len  = nelements;
#endif
   return d;
}
}

%typemap(default) int nelements "$1 = 1;"

#if #NAME == ""
SWIGCDATA cdata_##TYPE(TYPE *ptr, int nelements);
#else
SWIGCDATA cdata_##NAME(TYPE *ptr, int nelements);
#endif
%enddef

%typemap(default) int nelements;

%rename(cdata) ::cdata_void(void *ptr, int nelements);

%cdata(void);

/* Memory move function. Due to multi-argument typemaps this appears to be wrapped as
void memmove(void *data, const char *s); */
void memmove(void *data, const void *indata, int inlen);



================================================
File: swig/swigwin-3.0.8/Lib/cmalloc.i
================================================
/* -----------------------------------------------------------------------------
 * cmalloc.i
 *
 * SWIG library file containing macros that can be used to create objects using
 * the C malloc function.
 * ----------------------------------------------------------------------------- */

%{
#include <stdlib.h>
%}

/* %malloc(TYPE [, NAME = TYPE])
   %calloc(TYPE [, NAME = TYPE])
   %realloc(TYPE [, NAME = TYPE])
   %free(TYPE [, NAME = TYPE])
   %allocators(TYPE [,NAME = TYPE])

   Creates functions for allocating/reallocating memory.

   TYPE *malloc_NAME(int nbytes = sizeof(TYPE);
   TYPE *calloc_NAME(int nobj=1, int size=sizeof(TYPE));
   TYPE *realloc_NAME(TYPE *ptr, int nbytes);
   void free_NAME(TYPE *ptr);

*/

%define %malloc(TYPE,NAME...)
#if #NAME != ""
%rename(malloc_##NAME) ::malloc(int nbytes);
#else
%rename(malloc_##TYPE) ::malloc(int nbytes);
#endif

#if #TYPE != "void"
%typemap(default) int nbytes "$1 = (int) sizeof(TYPE);"
#endif
TYPE *malloc(int nbytes);
%typemap(default) int nbytes;
%enddef

%define %calloc(TYPE,NAME...)
#if #NAME != ""
%rename(calloc_##NAME) ::calloc(int nobj, int sz);
#else
%rename(calloc_##TYPE) ::calloc(int nobj, int sz);
#endif
#if #TYPE != "void"
%typemap(default) int sz "$1 = (int) sizeof(TYPE);"
#else
%typemap(default) int sz "$1 = 1;"
#endif
%typemap(default) int nobj "$1 = 1;"
TYPE *calloc(int nobj, int sz);
%typemap(default) int sz;
%typemap(default) int nobj;
%enddef

%define %realloc(TYPE,NAME...)
%insert("header") {
#if #NAME != ""
TYPE *realloc_##NAME(TYPE *ptr, int nitems)
#else
TYPE *realloc_##TYPE(TYPE *ptr, int nitems)
#endif
{
#if #TYPE != "void"
return (TYPE *) realloc(ptr, nitems*sizeof(TYPE));
#else
return (TYPE *) realloc(ptr, nitems);
#endif
}
}
#if #NAME != ""
TYPE *realloc_##NAME(TYPE *ptr, int nitems);
#else
TYPE *realloc_##TYPE(TYPE *ptr, int nitems);
#endif
%enddef

%define %free(TYPE,NAME...)
#if #NAME != ""
%rename(free_##NAME) ::free(TYPE *ptr);
#else
%rename(free_##TYPE) ::free(TYPE *ptr);
#endif
void free(TYPE *ptr);
%enddef

%define %sizeof(TYPE,NAME...)
#if #NAME != ""
%constant int sizeof_##NAME = sizeof(TYPE);
#else
%constant int sizeof_##TYPE = sizeof(TYPE);
#endif
%enddef

%define %allocators(TYPE,NAME...)
%malloc(TYPE,NAME)
%calloc(TYPE,NAME)
%realloc(TYPE,NAME)
%free(TYPE,NAME)
#if #TYPE != "void"
%sizeof(TYPE,NAME)
#endif
%enddef








================================================
File: swig/swigwin-3.0.8/Lib/constraints.i
================================================
/* -----------------------------------------------------------------------------
 * constraints.i
 *
 * SWIG constraints library.
 *
 * SWIG library file containing typemaps for implementing various kinds of 
 * constraints.  Depends upon the SWIG exception library for generating
 * errors in a language-independent manner.
 * ----------------------------------------------------------------------------- */

#ifdef AUTODOC
%text %{
%include <constraints.i>

This library provides support for applying constraints to function
arguments.  Using a constraint, you can restrict arguments to be
positive numbers, non-NULL pointers, and so on.   The following
constraints are available :

      Number  POSITIVE        - Positive number (not zero)
      Number  NEGATIVE        - Negative number (not zero)
      Number  NONZERO         - Nonzero number
      Number  NONNEGATIVE     - Positive number (including zero)
      Number  NONPOSITIVE     - Negative number (including zero)
      Pointer NONNULL         - Non-NULL pointer
      Pointer ALIGN8          - 8-byte aligned pointer
      Pointer ALIGN4          - 4-byte aligned pointer
      Pointer ALIGN2          - 2-byte aligned pointer

To use the constraints, you need to "apply" them to specific
function arguments in your code.  This is done using the %apply
directive.   For example :

  %apply Number NONNEGATIVE { double nonneg };
  double sqrt(double nonneg);         // Name of argument must match
  
  %apply Pointer NONNULL { void *ptr };
  void *malloc(int POSITIVE);       // May return a NULL pointer
  void free(void *ptr);             // May not accept a NULL pointer

Any function argument of the type you specify with the %apply directive
will be checked with the appropriate constraint.   Multiple types may
be specified as follows :

  %apply Pointer NONNULL { void *, Vector *, List *, double *};

In this case, all of the types listed would be checked for non-NULL 
pointers.

The common datatypes of int, short, long, unsigned int, unsigned long,
unsigned short, unsigned char, signed char, float, and double can be
checked without using the %apply directive by simply using the 
constraint name as the parameter name. For example :

  double sqrt(double NONNEGATIVE);
  double log(double POSITIVE);

If you have used typedef to change type-names, you can also do this :

  %apply double { Real };       // Make everything defined for doubles
                                // work for Reals.
  Real sqrt(Real NONNEGATIVE);
  Real log(Real POSITIVE);

%}
#endif

%include <exception.i>

#ifdef SWIGCSHARP
// Required attribute for C# exception handling
#define SWIGCSHARPCANTHROW , canthrow=1
#else
#define SWIGCSHARPCANTHROW
#endif


// Positive numbers

%typemap(check SWIGCSHARPCANTHROW) 
                int               POSITIVE,
                short             POSITIVE,
                long              POSITIVE,
                unsigned int      POSITIVE,
                unsigned short    POSITIVE,
                unsigned long     POSITIVE,
                signed char       POSITIVE,
                unsigned char     POSITIVE,
                float             POSITIVE,
                double            POSITIVE,
                Number            POSITIVE
{
  if ($1 <= 0) {
    SWIG_exception(SWIG_ValueError,"Expected a positive value.");
  }
}

// Negative numbers

%typemap(check SWIGCSHARPCANTHROW) 
                int               NEGATIVE,
                short             NEGATIVE,
                long              NEGATIVE,
                unsigned int      NEGATIVE,
                unsigned short    NEGATIVE,
                unsigned long     NEGATIVE,
                signed char       NEGATIVE,
                unsigned char     NEGATIVE,
                float             NEGATIVE,
                double            NEGATIVE,
                Number            NEGATIVE
{
  if ($1 >= 0) {
    SWIG_exception(SWIG_ValueError,"Expected a negative value.");
  }
}

// Nonzero numbers

%typemap(check SWIGCSHARPCANTHROW) 
                int               NONZERO,
                short             NONZERO,
                long              NONZERO,
                unsigned int      NONZERO,
                unsigned short    NONZERO,
                unsigned long     NONZERO,
                signed char       NONZERO,
                unsigned char     NONZERO,
                float             NONZERO,
                double            NONZERO,
                Number            NONZERO
{
  if ($1 == 0) {
    SWIG_exception(SWIG_ValueError,"Expected a nonzero value.");
  }
}

// Nonnegative numbers

%typemap(check SWIGCSHARPCANTHROW) 
                int               NONNEGATIVE,
                short             NONNEGATIVE,
                long              NONNEGATIVE,
                unsigned int      NONNEGATIVE,
                unsigned short    NONNEGATIVE,
                unsigned long     NONNEGATIVE,
                signed char       NONNEGATIVE,
                unsigned char     NONNEGATIVE,
                float             NONNEGATIVE,
                double            NONNEGATIVE,
                Number            NONNEGATIVE
{
  if ($1 < 0) {
    SWIG_exception(SWIG_ValueError,"Expected a non-negative value.");
  }
}

// Nonpositive numbers

%typemap(check SWIGCSHARPCANTHROW) 
                int               NONPOSITIVE,
                short             NONPOSITIVE,
                long              NONPOSITIVE,
                unsigned int      NONPOSITIVE,
                unsigned short    NONPOSITIVE,
                unsigned long     NONPOSITIVE,
                signed char       NONPOSITIVE,
                unsigned char     NONPOSITIVE,
                float             NONPOSITIVE,
                double            NONPOSITIVE,
                Number            NONPOSITIVE
{
  if ($1 > 0) {
    SWIG_exception(SWIG_ValueError,"Expected a non-positive value.");
  }
}
                
// Non-NULL pointer

%typemap(check SWIGCSHARPCANTHROW) 
                void *            NONNULL,
                Pointer           NONNULL
{
  if (!$1) {
    SWIG_exception(SWIG_ValueError,"Received a NULL pointer.");
  }
}

// Aligned pointers

%typemap(check SWIGCSHARPCANTHROW) 
                void *            ALIGN8,
                Pointer           ALIGN8
{
   unsigned long long tmp;
   tmp = (unsigned long long) $1;
   if (tmp & 7) {
     SWIG_exception(SWIG_ValueError,"Pointer must be 8-byte aligned.");
   }
}

%typemap(check SWIGCSHARPCANTHROW) 
                void *            ALIGN4,
                Pointer           ALIGN4
{
   unsigned long long tmp;
   tmp = (unsigned long long) $1;
   if (tmp & 3) {
     SWIG_exception(SWIG_ValueError,"Pointer must be 4-byte aligned.");
   }
}

%typemap(check SWIGCSHARPCANTHROW) 
                void *            ALIGN2,
                Pointer           ALIGN2
{
   unsigned long long tmp;
   tmp = (unsigned long long) $1;
   if (tmp & 1) {
     SWIG_exception(SWIG_ValueError,"Pointer must be 2-byte aligned.");
   }
}





================================================
File: swig/swigwin-3.0.8/Lib/cpointer.i
================================================
/* -----------------------------------------------------------------------------
 * cpointer.i
 *
 * SWIG library file containing macros that can be used to manipulate simple
 * pointer objects.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * %pointer_class(type,name)
 *
 * Places a simple proxy around a simple type like 'int', 'float', or whatever.
 * The proxy provides this interface:
 *
 *       class type {
 *       public:
 *           type();
 *          ~type();
 *           type value();
 *           void assign(type value);
 *       };
 *         
 * Example:
 *
 *    %pointer_class(int, intp);
 *
 *    int add(int *x, int *y) { return *x + *y; }
 *
 * In python (with proxies)
 *
 *    >>> a = intp()
 *    >>> a.assign(10)
 *    >>> a.value()
 *    10
 *    >>> b = intp()
 *    >>> b.assign(20)
 *    >>> print add(a,b)
 *    30
 *
 * As a general rule, this macro should not be used on class/structures that
 * are already defined in the interface.
 * ----------------------------------------------------------------------------- */


%define %pointer_class(TYPE, NAME)
%{
typedef TYPE NAME;
%}

typedef struct {
} NAME;

%extend NAME {
#ifdef __cplusplus
NAME() {
  return new TYPE();
}
~NAME() {
  if ($self) delete $self;
}
#else
NAME() {
  return (TYPE *) calloc(1,sizeof(TYPE));
}
~NAME() {
  if ($self) free($self);
}
#endif
}

%extend NAME {

void assign(TYPE value) {
  *$self = value;
}
TYPE value() {
  return *$self;
}
TYPE * cast() {
  return $self;
}
static NAME * frompointer(TYPE *t) {
  return (NAME *) t;
}

}

%types(NAME = TYPE);

%enddef

/* ----------------------------------------------------------------------------- 
 * %pointer_functions(type,name)
 *
 * Create functions for allocating/deallocating pointers.   This can be used
 * if you don't want to create a proxy class or if the pointer is complex.
 *
 *    %pointer_functions(int, intp)
 *
 *    int add(int *x, int *y) { return *x + *y; }
 *
 * In python (with proxies)
 *
 *    >>> a = copy_intp(10)
 *    >>> intp_value(a)
 *    10
 *    >>> b = new_intp()
 *    >>> intp_assign(b,20)
 *    >>> print add(a,b)
 *    30
 *    >>> delete_intp(a)
 *    >>> delete_intp(b)
 * 
 * ----------------------------------------------------------------------------- */

%define %pointer_functions(TYPE,NAME)
%{
static TYPE *new_##NAME() { %}
#ifdef __cplusplus
%{  return new TYPE(); %}
#else
%{  return (TYPE *) calloc(1,sizeof(TYPE)); %}
#endif
%{}

static TYPE *copy_##NAME(TYPE value) { %}
#ifdef __cplusplus
%{  return new TYPE(value); %}
#else
%{  TYPE *obj = (TYPE *) calloc(1,sizeof(TYPE));
  *obj = value;
  return obj; %}
#endif
%{}

static void delete_##NAME(TYPE *obj) { %}
#ifdef __cplusplus
%{  if (obj) delete obj; %}
#else
%{  if (obj) free(obj); %}
#endif
%{}

static void NAME ##_assign(TYPE *obj, TYPE value) {
  *obj = value;
}

static TYPE NAME ##_value(TYPE *obj) {
  return *obj;
}
%}

TYPE *new_##NAME();
TYPE *copy_##NAME(TYPE value);
void  delete_##NAME(TYPE *obj);
void  NAME##_assign(TYPE *obj, TYPE value);
TYPE  NAME##_value(TYPE *obj);

%enddef

/* -----------------------------------------------------------------------------
 * %pointer_cast(type1,type2,name)
 *
 * Generates a pointer casting function.
 * ----------------------------------------------------------------------------- */

%define %pointer_cast(TYPE1,TYPE2,NAME)
%inline %{
TYPE2 NAME(TYPE1 x) {
   return (TYPE2) x;
}
%}
%enddef











================================================
File: swig/swigwin-3.0.8/Lib/cstring.i
================================================
/* -----------------------------------------------------------------------------
 * cstring.i
 * ----------------------------------------------------------------------------- */

%echo "cstring.i not implemented for this target"
#define SWIG_CSTRING_UNIMPL

/* old name keep for compatibility */
#define _CSTRING_UNIMPL 






================================================
File: swig/swigwin-3.0.8/Lib/cwstring.i
================================================
/* -----------------------------------------------------------------------------
 * cwstring.i
 * ----------------------------------------------------------------------------- */

%echo "cwstring.i not implemented for this target"
#define SWIG_CWSTRING_UNIMPL








================================================
File: swig/swigwin-3.0.8/Lib/director_common.swg
================================================
/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif



================================================
File: swig/swigwin-3.0.8/Lib/exception.i
================================================
/* -----------------------------------------------------------------------------
 * exception.i
 *
 * SWIG library file providing language independent exception handling
 * ----------------------------------------------------------------------------- */

#if defined(SWIGUTL)
#error "This version of exception.i should not be used"
#endif


%insert("runtime") "swigerrors.swg"


#ifdef SWIGPHP
%{
#include "zend_exceptions.h"
#define SWIG_exception(code, msg) zend_throw_exception(NULL, (char*)msg, code TSRMLS_CC)
%}
#endif

#ifdef SWIGGUILE
%{
  SWIGINTERN void SWIG_exception_ (int code, const char *msg,
                               const char *subr) {
#define ERROR(scmerr)					\
	scm_error(scm_from_locale_string((char *) (scmerr)),	\
		  (char *) subr, (char *) msg,		\
		  SCM_EOL, SCM_BOOL_F)
#define MAP(swigerr, scmerr)			\
	case swigerr:				\
	  ERROR(scmerr);			\
	  break
    switch (code) {
      MAP(SWIG_MemoryError,	"swig-memory-error");
      MAP(SWIG_IOError,		"swig-io-error");
      MAP(SWIG_RuntimeError,	"swig-runtime-error");
      MAP(SWIG_IndexError,	"swig-index-error");
      MAP(SWIG_TypeError,	"swig-type-error");
      MAP(SWIG_DivisionByZero,	"swig-division-by-zero");
      MAP(SWIG_OverflowError,	"swig-overflow-error");
      MAP(SWIG_SyntaxError,	"swig-syntax-error");
      MAP(SWIG_ValueError,	"swig-value-error");
      MAP(SWIG_SystemError,	"swig-system-error");
    default:
      ERROR("swig-error");
    }
#undef ERROR
#undef MAP
  }

#define SWIG_exception(a,b) SWIG_exception_(a, b, FUNC_NAME)
%}
#endif

#ifdef SWIGMZSCHEME

%{
SWIGINTERN void SWIG_exception_ (int code, const char *msg) {
#define ERROR(errname)				\
	scheme_signal_error(errname " (%s)", msg);
#define MAP(swigerr, errname)			\
	case swigerr:				\
	  ERROR(errname);			\
	  break
    switch (code) {
      MAP(SWIG_MemoryError,	"swig-memory-error");
      MAP(SWIG_IOError,		"swig-io-error");
      MAP(SWIG_RuntimeError,	"swig-runtime-error");
      MAP(SWIG_IndexError,	"swig-index-error");
      MAP(SWIG_TypeError,	"swig-type-error");
      MAP(SWIG_DivisionByZero,	"swig-division-by-zero");
      MAP(SWIG_OverflowError,	"swig-overflow-error");
      MAP(SWIG_SyntaxError,	"swig-syntax-error");
      MAP(SWIG_ValueError,	"swig-value-error");
      MAP(SWIG_SystemError,	"swig-system-error");
    default:
      ERROR("swig-error");
    }
#undef ERROR
#undef MAP
  }

#define SWIG_exception(a,b) SWIG_exception_(a, b)
%}
#endif

#ifdef SWIGJAVA
%{
SWIGINTERN void SWIG_JavaException(JNIEnv *jenv, int code, const char *msg) {
  SWIG_JavaExceptionCodes exception_code = SWIG_JavaUnknownError;
  switch(code) {
  case SWIG_MemoryError:
    exception_code = SWIG_JavaOutOfMemoryError;
    break;
  case SWIG_IOError:
    exception_code = SWIG_JavaIOException;
    break;
  case SWIG_SystemError:
  case SWIG_RuntimeError:
    exception_code = SWIG_JavaRuntimeException;
    break;
  case SWIG_OverflowError:
  case SWIG_IndexError:
    exception_code = SWIG_JavaIndexOutOfBoundsException;
    break;
  case SWIG_DivisionByZero:
    exception_code = SWIG_JavaArithmeticException;
    break;
  case SWIG_SyntaxError:
  case SWIG_ValueError:
  case SWIG_TypeError:
    exception_code = SWIG_JavaIllegalArgumentException;
    break;
  case SWIG_UnknownError:
  default:
    exception_code = SWIG_JavaUnknownError;
    break;
  }
  SWIG_JavaThrowException(jenv, exception_code, msg);
}
%}

#define SWIG_exception(code, msg)\
{ SWIG_JavaException(jenv, code, msg); return $null; }
#endif // SWIGJAVA

#ifdef SWIGOCAML
%{
#define OCAML_MSG_BUF_LEN 1024
SWIGINTERN void SWIG_exception_(int code, const char *msg) {
  char msg_buf[OCAML_MSG_BUF_LEN];
  sprintf( msg_buf, "Exception(%d): %s\n", code, msg );
  failwith( msg_buf );
}
#define SWIG_exception(a,b) SWIG_exception_((a),(b))
%}
#endif


#ifdef SWIGCHICKEN
%{
SWIGINTERN void SWIG_exception_(int code, const char *msg) {
  C_word *a;
  C_word scmmsg;
  C_word list;

  a = C_alloc (C_SIZEOF_STRING (strlen (msg)) + C_SIZEOF_LIST(2));
  scmmsg = C_string2 (&a, (char *) msg);
  list = C_list(&a, 2, C_fix(code), scmmsg);
  SWIG_ThrowException(list);
}
#define SWIG_exception(a,b) SWIG_exception_((a),(b))
%}
#endif

#ifdef SWIGCSHARP
%{
SWIGINTERN void SWIG_CSharpException(int code, const char *msg) {
  if (code == SWIG_ValueError) {
    SWIG_CSharpExceptionArgumentCodes exception_code = SWIG_CSharpArgumentOutOfRangeException;
    SWIG_CSharpSetPendingExceptionArgument(exception_code, msg, 0);
  } else {
    SWIG_CSharpExceptionCodes exception_code = SWIG_CSharpApplicationException;
    switch(code) {
    case SWIG_MemoryError:
      exception_code = SWIG_CSharpOutOfMemoryException;
      break;
    case SWIG_IndexError:
      exception_code = SWIG_CSharpIndexOutOfRangeException;
      break;
    case SWIG_DivisionByZero:
      exception_code = SWIG_CSharpDivideByZeroException;
      break;
    case SWIG_IOError:
      exception_code = SWIG_CSharpIOException;
      break;
    case SWIG_OverflowError:
      exception_code = SWIG_CSharpOverflowException;
      break;
    case SWIG_RuntimeError:
    case SWIG_TypeError:
    case SWIG_SyntaxError:
    case SWIG_SystemError:
    case SWIG_UnknownError:
    default:
      exception_code = SWIG_CSharpApplicationException;
      break;
    }
    SWIG_CSharpSetPendingException(exception_code, msg);
  }
}
%}

#define SWIG_exception(code, msg)\
{ SWIG_CSharpException(code, msg); return $null; }
#endif // SWIGCSHARP

#ifdef SWIGLUA

%{
#define SWIG_exception(a,b)\
{ lua_pushfstring(L,"%s:%s",#a,b);SWIG_fail; }
%}

#endif // SWIGLUA

#ifdef SWIGD
%{
SWIGINTERN void SWIG_DThrowException(int code, const char *msg) {
  SWIG_DExceptionCodes exception_code;
  switch(code) {
  case SWIG_IndexError:
    exception_code = SWIG_DNoSuchElementException;
    break;
  case SWIG_IOError:
    exception_code = SWIG_DIOException;
    break;
  case SWIG_ValueError:
    exception_code = SWIG_DIllegalArgumentException;
    break;
  case SWIG_DivisionByZero:
  case SWIG_MemoryError:
  case SWIG_OverflowError:
  case SWIG_RuntimeError:
  case SWIG_TypeError:
  case SWIG_SyntaxError:
  case SWIG_SystemError:
  case SWIG_UnknownError:
  default:
    exception_code = SWIG_DException;
    break;
  }
  SWIG_DSetPendingException(exception_code, msg);
}
%}

#define SWIG_exception(code, msg)\
{ SWIG_DThrowException(code, msg); return $null; }
#endif // SWIGD

#ifdef __cplusplus
/*
  You can use the SWIG_CATCH_STDEXCEPT macro with the %exception
  directive as follows:

  %exception {
    try {
      $action
    }
    catch (my_except& e) {
      ...
    }
    SWIG_CATCH_STDEXCEPT // catch std::exception
    catch (...) {
     SWIG_exception(SWIG_UnknownError, "Unknown exception");
    }
  }
*/
%{
#include <stdexcept>
%}
%define SWIG_CATCH_STDEXCEPT
  /* catching std::exception  */
  catch (std::invalid_argument& e) {
    SWIG_exception(SWIG_ValueError, e.what() );
  } catch (std::domain_error& e) {
    SWIG_exception(SWIG_ValueError, e.what() );
  } catch (std::overflow_error& e) {
    SWIG_exception(SWIG_OverflowError, e.what() );
  } catch (std::out_of_range& e) {
    SWIG_exception(SWIG_IndexError, e.what() );
  } catch (std::length_error& e) {
    SWIG_exception(SWIG_IndexError, e.what() );
  } catch (std::runtime_error& e) {
    SWIG_exception(SWIG_RuntimeError, e.what() );
  } catch (std::exception& e) {
    SWIG_exception(SWIG_SystemError, e.what() );
  }
%enddef
%define SWIG_CATCH_UNKNOWN
  catch (std::exception& e) {
    SWIG_exception(SWIG_SystemError, e.what() );
  }
  catch (...) {
    SWIG_exception(SWIG_UnknownError, "unknown exception");
  }
%enddef

/* rethrow the unknown exception */

#if defined(SWIGCSHARP) || defined(SWIGD)
%typemap(throws,noblock=1, canthrow=1) (...) {
  SWIG_exception(SWIG_RuntimeError,"unknown exception");
}
#else
%typemap(throws,noblock=1) (...) {
  SWIG_exception(SWIG_RuntimeError,"unknown exception");
}
#endif

#endif /* __cplusplus */

/* exception.i ends here */



================================================
File: swig/swigwin-3.0.8/Lib/intrusive_ptr.i
================================================
// Allow for different namespaces for shared_ptr / intrusive_ptr - they could be boost or std or std::tr1
// For example for std::tr1, use:
// #define SWIG_SHARED_PTR_NAMESPACE std
// #define SWIG_SHARED_PTR_SUBNAMESPACE tr1
// #define SWIG_INTRUSIVE_PTR_NAMESPACE boost
// #define SWIG_INTRUSIVE_PTR_SUBNAMESPACE 

#if !defined(SWIG_INTRUSIVE_PTR_NAMESPACE)
# define SWIG_INTRUSIVE_PTR_NAMESPACE boost
#endif

#if defined(SWIG_INTRUSIVE_PTR_SUBNAMESPACE)
# define SWIG_INTRUSIVE_PTR_QNAMESPACE SWIG_INTRUSIVE_PTR_NAMESPACE::SWIG_INTRUSIVE_PTR_SUBNAMESPACE
#else
# define SWIG_INTRUSIVE_PTR_QNAMESPACE SWIG_INTRUSIVE_PTR_NAMESPACE
#endif

namespace SWIG_INTRUSIVE_PTR_NAMESPACE {
#if defined(SWIG_INTRUSIVE_PTR_SUBNAMESPACE)
  namespace SWIG_INTRUSIVE_PTR_SUBNAMESPACE {
#endif
    template <class T> class intrusive_ptr {
    };
#if defined(SWIG_INTRUSIVE_PTR_SUBNAMESPACE)
  }
#endif
}

%fragment("SWIG_intrusive_deleter", "header") {
template<class T> struct SWIG_intrusive_deleter {
    void operator()(T *p) {
        if (p) 
          intrusive_ptr_release(p);
    }
};
}

%fragment("SWIG_null_deleter", "header") {
struct SWIG_null_deleter {
  void operator() (void const *) const {
  }
};
%#define SWIG_NO_NULL_DELETER_0 , SWIG_null_deleter()
%#define SWIG_NO_NULL_DELETER_1
}

// Workaround empty first macro argument bug
#define SWIGEMPTYHACK
// Main user macro for defining intrusive_ptr typemaps for both const and non-const pointer types
%define %intrusive_ptr(TYPE...)
%feature("smartptr", noblock=1) TYPE { SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > }
SWIG_INTRUSIVE_PTR_TYPEMAPS(SWIGEMPTYHACK, TYPE)
SWIG_INTRUSIVE_PTR_TYPEMAPS(const, TYPE)
%enddef

%define %intrusive_ptr_no_wrap(TYPE...)
%feature("smartptr", noblock=1) TYPE { SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > }
SWIG_INTRUSIVE_PTR_TYPEMAPS_NO_WRAP(SWIGEMPTYHACK, TYPE)
SWIG_INTRUSIVE_PTR_TYPEMAPS_NO_WRAP(const, TYPE)
%enddef

// Legacy macros
%define SWIG_INTRUSIVE_PTR(PROXYCLASS, TYPE...)
#warning "SWIG_INTRUSIVE_PTR(PROXYCLASS, TYPE) is deprecated. Please use %intrusive_ptr(TYPE) instead."
%intrusive_ptr(TYPE)
%enddef

%define SWIG_INTRUSIVE_PTR_DERIVED(PROXYCLASS, BASECLASSTYPE, TYPE...)
#warning "SWIG_INTRUSIVE_PTR_DERIVED(PROXYCLASS, BASECLASSTYPE, TYPE) is deprecated. Please use %intrusive_ptr(TYPE) instead."
%intrusive_ptr(TYPE)
%enddef

%define SWIG_INTRUSIVE_PTR_NO_WRAP(PROXYCLASS, TYPE...)
#warning "SWIG_INTRUSIVE_PTR_NO_WRAP(PROXYCLASS, TYPE) is deprecated. Please use %intrusive_ptr_no_wrap(TYPE) instead."
%intrusive_ptr_no_wrap(TYPE)
%enddef

%define SWIG_INTRUSIVE_PTR_DERIVED_NO_WRAP(PROXYCLASS, BASECLASSTYPE, TYPE...)
#warning "SWIG_INTRUSIVE_PTR_DERIVED_NO_WRAP(PROXYCLASS, BASECLASSTYPE, TYPE) is deprecated. Please use %intrusive_ptr_no_wrap(TYPE) instead."
%intrusive_ptr_no_wrap(TYPE)
%enddef




================================================
File: swig/swigwin-3.0.8/Lib/inttypes.i
================================================
/* -----------------------------------------------------------------------------
 * inttypes.i
 *
 * SWIG library file  for ISO C99 types: 7.8 Format conversion of integer types <inttypes.h>
 * ----------------------------------------------------------------------------- */

%{
#include <inttypes.h>
%}

%include <stdint.i>
%include <wchar.i>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIGWORDSIZE64
  
  /* We have to define the `uintmax_t' type using `ldiv_t'.  */
  typedef struct
  {
    long int quot;		/* Quotient.  */
    long int rem;		/* Remainder.  */
  } imaxdiv_t;
  
#else
  
  /* We have to define the `uintmax_t' type using `lldiv_t'.  */
  typedef struct
  {
    long long int quot;		/* Quotient.  */
    long long int rem;		/* Remainder.  */
  } imaxdiv_t;

#endif

  /* Compute absolute value of N.  */
  extern intmax_t imaxabs (intmax_t n);

  /* Return the `imaxdiv_t' representation of the value of NUMER over DENOM. */
  extern imaxdiv_t imaxdiv (intmax_t numer, intmax_t denom);
  
#ifdef SWIG_WCHAR
  /* Like `wcstol' but convert to `intmax_t'.  */
  extern intmax_t wcstoimax (const wchar_t *nptr, wchar_t **endptr, int base);
  
  /* Like `wcstoul' but convert to `uintmax_t'.  */
  extern uintmax_t wcstoumax (const wchar_t *nptr, wchar_t ** endptr, int base);
#endif

#ifdef SWIGWORDSIZE64
  
  /* Like `strtol' but convert to `intmax_t'.  */
  extern  intmax_t strtoimax (const char *nptr, char **endptr, int base);
  
  /* Like `strtoul' but convert to `uintmax_t'.  */
  extern  uintmax_t strtoumax (const char *nptr, char **endptr,int base);
  
#ifdef SWIG_WCHAR
  /* Like `wcstol' but convert to `intmax_t'.  */
  extern  intmax_t wcstoimax (const wchar_t *nptr, wchar_t **endptr, int base);
  
  /* Like `wcstoul' but convert to `uintmax_t'.  */
  extern  uintmax_t wcstoumax (const wchar_t *nptr, wchar_t **endptr, int base);
#endif
  
#else /* SWIGWORDSIZE32 */
  
  /* Like `strtol' but convert to `intmax_t'.  */
  extern  intmax_t strtoimax (const char *nptr, char **endptr, int base);
  
  /* Like `strtoul' but convert to `uintmax_t'.  */
  extern  uintmax_t strtoumax (const char *nptr, char **endptr, int base);
  
#ifdef SWIG_WCHAR
  /* Like `wcstol' but convert to `intmax_t'.  */
  extern  uintmax_t wcstoumax (const wchar_t *nptr, wchar_t **endptr, int base);
#endif

#endif /* SWIGWORDSIZE64 */

#ifdef __cplusplus
}
#endif



================================================
File: swig/swigwin-3.0.8/Lib/linkruntime.c
================================================
#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

static void* ptr = 0;
SWIGEXPORT void*
SWIG_ReturnGlobalTypeList(void* t)
{
    if(!ptr && !t) ptr = t;
    return ptr;
}



================================================
File: swig/swigwin-3.0.8/Lib/math.i
================================================
/* -----------------------------------------------------------------------------
 * math.i
 *
 * SWIG library file for floating point operations.
 * ----------------------------------------------------------------------------- */

%module math
%{
#include <math.h>
%}

extern double	cos(double x);
/* Cosine of x */

extern double	sin(double x);
/* Sine of x */

extern double	tan(double x);
/* Tangent of x */

extern double	acos(double x);
/* Inverse cosine in range [-PI/2,PI/2], x in [-1,1]. */

extern double	asin(double x);
/* Inverse sine in range [0,PI], x in [-1,1]. */

extern double	atan(double x);
/* Inverse tangent in range [-PI/2,PI/2]. */

extern double	atan2(double y, double x);
/* Inverse tangent of y/x in range [-PI,PI]. */

extern double	cosh(double x);
/* Hyperbolic cosine of x */

extern double	sinh(double x);
/* Hyperbolic sine of x */

extern double	tanh(double x);
/* Hyperbolic tangent of x */

extern double	exp(double x);
/* Natural exponential function e^x */

extern double	log(double x);
/* Natural logarithm ln(x), x > 0 */

extern double	log10(double x);
/* Base 10 logarithm, x > 0 */

extern double	pow(double x, double y);
/* Power function x^y. */

extern double	sqrt(double x);
/* Square root. x >= 0 */

extern double	fabs(double x);
/* Absolute value of x */

extern double	ceil(double x);
/* Smallest integer not less than x, as a double */

extern double	floor(double x);
/* Largest integer not greater than x, as a double */

extern double	fmod(double x, double y);
/* Floating-point remainder of x/y, with the same sign as x. */

#define M_E		2.7182818284590452354
#define M_LOG2E		1.4426950408889634074
#define M_LOG10E	0.43429448190325182765
#define M_LN2		0.69314718055994530942
#define M_LN10		2.30258509299404568402
#define M_PI		3.14159265358979323846
#define M_PI_2		1.57079632679489661923
#define M_PI_4		0.78539816339744830962
#define M_1_PI		0.31830988618379067154
#define M_2_PI		0.63661977236758134308
#define M_2_SQRTPI	1.12837916709551257390
#define M_SQRT2		1.41421356237309504880
#define M_SQRT1_2	0.70710678118654752440




================================================
File: swig/swigwin-3.0.8/Lib/pointer.i
================================================
/* -----------------------------------------------------------------------------
 * pointer.i
 * ----------------------------------------------------------------------------- */


%echo "pointer.i is deprecated.  Use cpointer.i instead."
%echo "See http://www.swig.org/Doc3.0/Library.html"







================================================
File: swig/swigwin-3.0.8/Lib/runtime.swg
================================================
/* -----------------------------------------------------------------------------*
   Standard SWIG API for use inside user code.
 
   Don't include this file directly, run the command
   swig -python -external-runtime
   Also, read the Modules chapter of the SWIG Manual.
 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_MODULE_CLIENTDATA_TYPE

SWIGRUNTIMEINLINE swig_type_info *
SWIG_TypeQuery(SWIG_MODULE_CLIENTDATA_TYPE clientdata, const char *name) {
  swig_module_info *module = SWIG_GetModule(clientdata);
  return SWIG_TypeQueryModule(module, module, name);
}

SWIGRUNTIMEINLINE swig_type_info *
SWIG_MangledTypeQuery(SWIG_MODULE_CLIENTDATA_TYPE clientdata, const char *name) {
  swig_module_info *module = SWIG_GetModule(clientdata);
  return SWIG_MangledTypeQueryModule(module, module, name);
}

#else

SWIGRUNTIMEINLINE swig_type_info *
SWIG_TypeQuery(const char *name) {
  swig_module_info *module = SWIG_GetModule(NULL);
  return SWIG_TypeQueryModule(module, module, name);
}

SWIGRUNTIMEINLINE swig_type_info *
SWIG_MangledTypeQuery(const char *name) {
  swig_module_info *module = SWIG_GetModule(NULL);
  return SWIG_MangledTypeQueryModule(module, module, name);
}

#endif



================================================
File: swig/swigwin-3.0.8/Lib/shared_ptr.i
================================================
// This is a helper file for shared_ptr and should not be included directly.

// The main implementation detail in using this smart pointer of a type is to customise the code generated
// to use a pointer to the smart pointer of the type, rather than the usual pointer to the underlying type.
// So for some type T, shared_ptr<T> * is used rather than T *.

// shared_ptr namespaces could be boost or std or std::tr1
// For example for std::tr1, use:
// #define SWIG_SHARED_PTR_NAMESPACE std
// #define SWIG_SHARED_PTR_SUBNAMESPACE tr1

#if !defined(SWIG_SHARED_PTR_NAMESPACE)
# define SWIG_SHARED_PTR_NAMESPACE boost
#endif

#if defined(SWIG_SHARED_PTR_SUBNAMESPACE)
# define SWIG_SHARED_PTR_QNAMESPACE SWIG_SHARED_PTR_NAMESPACE::SWIG_SHARED_PTR_SUBNAMESPACE
#else
# define SWIG_SHARED_PTR_QNAMESPACE SWIG_SHARED_PTR_NAMESPACE
#endif

namespace SWIG_SHARED_PTR_NAMESPACE {
#if defined(SWIG_SHARED_PTR_SUBNAMESPACE)
  namespace SWIG_SHARED_PTR_SUBNAMESPACE {
#endif
    template <class T> class shared_ptr {
    };
#if defined(SWIG_SHARED_PTR_SUBNAMESPACE)
  }
#endif
}

%fragment("SWIG_null_deleter", "header") {
struct SWIG_null_deleter {
  void operator() (void const *) const {
  }
};
%#define SWIG_NO_NULL_DELETER_0 , SWIG_null_deleter()
%#define SWIG_NO_NULL_DELETER_1
%#define SWIG_NO_NULL_DELETER_SWIG_POINTER_NEW
%#define SWIG_NO_NULL_DELETER_SWIG_POINTER_OWN
}


// Workaround empty first macro argument bug
#define SWIGEMPTYHACK
// Main user macro for defining shared_ptr typemaps for both const and non-const pointer types
%define %shared_ptr(TYPE...)
%feature("smartptr", noblock=1) TYPE { SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > }
SWIG_SHARED_PTR_TYPEMAPS(SWIGEMPTYHACK, TYPE)
SWIG_SHARED_PTR_TYPEMAPS(const, TYPE)
%enddef

// Legacy macros
%define SWIG_SHARED_PTR(PROXYCLASS, TYPE...)
#warning "SWIG_SHARED_PTR(PROXYCLASS, TYPE) is deprecated. Please use %shared_ptr(TYPE) instead."
%shared_ptr(TYPE)
%enddef

%define SWIG_SHARED_PTR_DERIVED(PROXYCLASS, BASECLASSTYPE, TYPE...)
#warning "SWIG_SHARED_PTR_DERIVED(PROXYCLASS, BASECLASSTYPE, TYPE) is deprecated. Please use %shared_ptr(TYPE) instead."
%shared_ptr(TYPE)
%enddef




================================================
File: swig/swigwin-3.0.8/Lib/std_except.i
================================================
/* -----------------------------------------------------------------------------
 * std_except.i
 *
 * SWIG library file with typemaps to handle and throw STD exceptions in a
 * language and STL independent way, i.e., the target language doesn't
 * require to support STL but only the 'exception.i' mechanism.
 *
 * These typemaps are used when methods are declared with an STD
 * exception specification, such as
 *
 *   size_t at() const throw (std::out_of_range);
 *
 * The typemaps here are based on the language independent
 * 'exception.i' library. If that is working in your target language,
 * this file will work.
 * 
 * If the target language doesn't implement a robust 'exception.i'
 * mechanism, or you prefer other ways to map the STD exceptions, write
 * a new std_except.i file in the target library directory.
 * ----------------------------------------------------------------------------- */

#if defined(SWIGJAVA) || defined(SWIGCSHARP) || defined(SWIGGUILE) || defined(SWIGUTL) || defined(SWIGD)
#error "This version of std_except.i should not be used"
#endif

%{
#include <stdexcept>
%}

%include <exception.i>


%define %std_exception_map(Exception, Code)
  %typemap(throws,noblock=1) Exception {
    SWIG_exception(Code, $1.what());
  }
  %ignore Exception;
  struct Exception {
  };
%enddef

namespace std {
  %std_exception_map(bad_exception,      SWIG_SystemError);
  %std_exception_map(domain_error,       SWIG_ValueError);
  %std_exception_map(exception,          SWIG_SystemError);
  %std_exception_map(invalid_argument,   SWIG_ValueError);
  %std_exception_map(length_error,       SWIG_IndexError);
  %std_exception_map(logic_error,        SWIG_RuntimeError);
  %std_exception_map(out_of_range,       SWIG_IndexError);
  %std_exception_map(overflow_error,     SWIG_OverflowError);
  %std_exception_map(range_error,        SWIG_OverflowError);
  %std_exception_map(runtime_error,      SWIG_RuntimeError);
  %std_exception_map(underflow_error,    SWIG_OverflowError);
}




================================================
File: swig/swigwin-3.0.8/Lib/stdint.i
================================================
/* -----------------------------------------------------------------------------
 * stdint.i
 *
 * SWIG library file for ISO C99 types: 7.18 Integer types <stdint.h>
 * ----------------------------------------------------------------------------- */

%{
#include <stdint.h>		// Use the C99 official header
%}

%include <swigarch.i>

/* Exact integral types.  */

/* Signed.  */

typedef signed char		int8_t;
typedef short int		int16_t;
typedef int			int32_t;
#if defined(SWIGWORDSIZE64)
typedef long int		int64_t;
#else
typedef long long int		int64_t;
#endif

/* Unsigned.  */
typedef unsigned char		uint8_t;
typedef unsigned short int	uint16_t;
typedef unsigned int		uint32_t;
#if defined(SWIGWORDSIZE64)
typedef unsigned long int	uint64_t;
#else
typedef unsigned long long int	uint64_t;
#endif


/* Small types.  */

/* Signed.  */
typedef signed char		int_least8_t;
typedef short int		int_least16_t;
typedef int			int_least32_t;
#if defined(SWIGWORDSIZE64)
typedef long int		int_least64_t;
#else
typedef long long int		int_least64_t;
#endif

/* Unsigned.  */
typedef unsigned char		uint_least8_t;
typedef unsigned short int	uint_least16_t;
typedef unsigned int		uint_least32_t;
#if defined(SWIGWORDSIZE64)
typedef unsigned long int	uint_least64_t;
#else
typedef unsigned long long int	uint_least64_t;
#endif


/* Fast types.  */

/* Signed.  */
typedef signed char		int_fast8_t;
#if defined(SWIGWORDSIZE64)
typedef long int		int_fast16_t;
typedef long int		int_fast32_t;
typedef long int		int_fast64_t;
#else
typedef int			int_fast16_t;
typedef int			int_fast32_t;
typedef long long int		int_fast64_t;
#endif

/* Unsigned.  */
typedef unsigned char		uint_fast8_t;
#if defined(SWIGWORDSIZE64)
typedef unsigned long int	uint_fast16_t;
typedef unsigned long int	uint_fast32_t;
typedef unsigned long int	uint_fast64_t;
#else
typedef unsigned int		uint_fast16_t;
typedef unsigned int		uint_fast32_t;
typedef unsigned long long int	uint_fast64_t;
#endif


/* Types for `void *' pointers.  */
#if defined(SWIGWORDSIZE64)
typedef long int		intptr_t;
typedef unsigned long int	uintptr_t;
#else
typedef int			intptr_t;
typedef unsigned int		uintptr_t;
#endif


/* Largest integral types.  */
#if defined(SWIGWORDSIZE64)
typedef long int		intmax_t;
typedef unsigned long int	uintmax_t;
#else
typedef long long int		intmax_t;
typedef unsigned long long int	uintmax_t;
#endif





================================================
File: swig/swigwin-3.0.8/Lib/stl.i
================================================
/* -----------------------------------------------------------------------------
 * stl.i
 * ----------------------------------------------------------------------------- */

#warning "stl.i not implemented for this target"
#define SWIG_STL_UNIMPL




================================================
File: swig/swigwin-3.0.8/Lib/swig.swg
================================================
/* -----------------------------------------------------------------------------
 * swig.swg
 *
 * Common macro definitions for various SWIG directives.  This file is always 
 * included at the top of each input file.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * User Directives 
 * ----------------------------------------------------------------------------- */

/* Deprecated SWIG-1.1 directives */

#define %disabledoc     %warn "104:%disabledoc is deprecated"
#define %enabledoc      %warn "105:%enabledoc is deprecated"
#define %doconly        %warn "106:%doconly is deprecated"
#define %style          %warn "107:%style is deprecated" /##/
#define %localstyle     %warn "108:%localstyle is deprecated" /##/
#define %title          %warn "109:%title is deprecated" /##/
#define %section        %warn "110:%section is deprecated" /##/
#define %subsection     %warn "111:%subsection is deprecated" /##/
#define %subsubsection  %warn "112:%subsubsection is deprecated" /##/
#define %new            %warn "117:%new is deprecated. Use %newobject"
#define %text           %insert("null")

/* Code insertion directives such as %wrapper %{ ... %} */

#define %begin       %insert("begin")
#define %runtime     %insert("runtime")
#define %header      %insert("header")
#define %wrapper     %insert("wrapper")
#define %init        %insert("init")

/* Class extension */

#define %addmethods  %warn "113:%addmethods is now %extend" %extend

/* %ignore directive */

#define %ignore         %rename($ignore)
#define %ignorewarn(x)  %rename("$ignore:" x)

/* Access control directives */

#define %readonly    %warn "114:%readonly is deprecated. Use %immutable; " %feature("immutable");
#define %readwrite   %warn "115:%readwrite is deprecated. Use %mutable; " %feature("immutable","");

#define %immutable       %feature("immutable")
#define %noimmutable     %feature("immutable","0")
#define %clearimmutable  %feature("immutable","")
#define %mutable         %clearimmutable

/* Generation of default constructors/destructors (old form, don't use) */
#define %nodefault       %feature("nodefault","1")
#define %default         %feature("nodefault","0")
#define %clearnodefault  %feature("nodefault","")
#define %makedefault     %clearnodefault

/* Disable the generation of implicit default constructor */
#define %nodefaultctor       %feature("nodefaultctor","1")
#define %defaultctor         %feature("nodefaultctor","0")
#define %clearnodefaultctor  %feature("nodefaultctor","")

/* Disable the generation of implicit default destructor (dangerous) */
#define %nodefaultdtor       %feature("nodefaultdtor","1")
#define %defaultdtor         %feature("nodefaultdtor","0")
#define %clearnodefaultdtor  %feature("nodefaultdtor","")

/* Enable the generation of copy constructor */
#define %copyctor       %feature("copyctor","1")
#define %nocopyctor     %feature("copyctor","0")
#define %clearcopyctor  %feature("copyctor","")

/* Force the old nodefault behavior, ie disable both constructor and destructor */
#define %oldnodefault       %feature("oldnodefault","1")
#define %nooldnodefault     %feature("oldnodefault","0")
#define %clearoldnodefault  %feature("oldnodefault","")

/* the %exception directive */
#if defined(SWIGCSHARP) || defined(SWIGD)
#define %exception      %feature("except", canthrow=1)
#else
#define %exception      %feature("except")
#endif
#define %noexception    %feature("except","0")
#define %clearexception %feature("except","")

/* the %allowexception directive allows the %exception feature to
   be applied to set/get variable methods */
#define %allowexception      %feature("allowexcept")
#define %noallowexception    %feature("allowexcept","0")
#define %clearallowexception %feature("allowexcept","")

/* the %exceptionvar directive, as %exception but it is only applied
   to set/get variable methods. You don't need to use the
   %allowexception directive when using %exceptionvar.
*/
#if defined(SWIGCSHARP) || defined(SWIGD)
#define %exceptionvar      %feature("exceptvar", canthrow=1)
#else
#define %exceptionvar      %feature("exceptvar")
#endif
#define %noexceptionvar    %feature("exceptvar","0")
#define %clearexceptionvar %feature("exceptvar","")

/* the %catches directive */
#define %catches(tlist...)    %feature("catches","("`tlist`")")
#define %clearcatches         %feature("catches","")

/* the %exceptionclass directive */
#define %exceptionclass      %feature("exceptionclass")
#define %noexceptionclass    %feature("exceptionclass","0")
#define %clearexceptionclass %feature("exceptionclass","")

/* the %newobject directive */
#define %newobject        %feature("new")
#define %nonewobject      %feature("new","0")
#define %clearnewobject   %feature("new","")

/* the %delobject directive */
#define %delobject        %feature("del")
#define %nodelobject      %feature("del","0")
#define %cleardelobject   %feature("del","")

/* the %refobject/%unrefobject directives */
#define %refobject         %feature("ref")
#define %norefobject       %feature("ref","0")
#define %clearrefobject    %feature("ref","")

#define %unrefobject       %feature("unref")
#define %nounrefobject     %feature("unref","0")
#define %clearunrefobject  %feature("unref","")

/* Directives for callback functions (experimental) */
#define %callback(x)    %feature("callback",`x`)
#define %nocallback     %feature("callback","0")
#define %clearcallback  %feature("callback","")

/* the %nestedworkaround directive (deprecated) */
#define %nestedworkaround       %feature("nestedworkaround")
#define %nonestedworkaround     %feature("nestedworkaround","0")
#define %clearnestedworkaround  %feature("nestedworkaround","")

/* the %flatnested directive */
#define %flatnested       %feature("flatnested")
#define %noflatnested     %feature("flatnested","0")
#define %clearflatnested  %feature("flatnested","")

/* the %fastdispatch directive */
#define %fastdispatch        %feature("fastdispatch")
#define %nofastdispatch      %feature("fastdispatch","0")
#define %clearfastdispatch   %feature("fastdispatch","")

/* directors directives */
#define %director      %feature("director")
#define %nodirector    %feature("director","0")
#define %cleardirector %feature("director","")

/* naturalvar directives */
#define %naturalvar      %feature("naturalvar")
#define %nonaturalvar    %feature("naturalvar","0")
#define %clearnaturalvar %feature("naturalvar","")

/* nspace directives */
#define %nspace      %feature("nspace")
#define %nonspace    %feature("nspace","0")
#define %clearnspace %feature("nspace","")

/* valuewrapper directives */
#define %valuewrapper        %feature("valuewrapper")
#define %clearvaluewrapper   %feature("valuewrapper","")
#define %novaluewrapper      %feature("novaluewrapper")
#define %clearnovaluewrapper %feature("novaluewrapper","")

/* Contract support - Experimental and undocumented */
#define %contract      %feature("contract")
#define %nocontract    %feature("contract","0")
#define %clearcontract %feature("contract","")

/* Macro for setting a dynamic cast function */
%define DYNAMIC_CAST(mangle,func)
%init %{
   mangle->dcast = (swig_dycast_func) func;
%}
%enddef

/* aggregation support */
/*
  This macro performs constant aggregation.  Basically the idea of
  constant aggregation is that you can group a collection of constants
  together.  For example, suppose you have some code like this:

       #define UP  1
       #define DOWN 2
       #define LEFT 3
       #define RIGHT 4

  Now, suppose you had a function like this:

       int move(int direction)

  In this case, you might want to restrict the direction argument to
  one of the supplied constant names. To do this, you could write some
  typemap code by hand.  Alternatively, you can use the
  %aggregate_check macro defined here to create a simple check
  function for you.  Here is an example:

    %aggregate_check(int, check_direction, UP, DOWN, LEFT, RIGHT);

  Now, using a typemap

    %typemap(check) int direction {
      if (!check_direction($1)) SWIG_exception(SWIG_ValueError,"Bad direction.");
    }

  or a contract (better)

    %contract move(int x) {
    require:
        check_direction(x);
    }

*/
   
%define %aggregate_check(TYPE, NAME, FIRST, ...)
%wrapper %{
static int NAME(TYPE x) {
    static  TYPE values[] = { FIRST, ##__VA_ARGS__ };
    static  int size = sizeof(values);
    int     i,j;
    for (i = 0, j = 0; i < size; i+=sizeof(TYPE),j++) {
        if (x == values[j]) return 1; 
    }
    return 0;
}
%}
%enddef


/* -----------------------------------------------------------------------------
 * %rename predicates
 * ----------------------------------------------------------------------------- */
/* 
   Predicates to be used with %rename, for example:

   - to rename all the functions:

     %rename("%(utitle)s", %$isfunction) "";

   - to rename only the member methods:

     %rename("m_%(utitle)s", %$isfunction, %$ismember) "";

   - to rename only the global functions:

      %rename("m_%(utitle)s", %$isfunction, %$not %$ismember) "";

     or

      %rename("g_%(utitle)s", %$isfunction, %$isglobal) "";

   - to ignore the enumitems in a given class:

     %rename("$ignore", %$isenumitem, %$classname="MyClass") "";

   we use the prefix '%$' to avoid clashes with other swig
   macros/directives.

*/

%define %$not            "not" %enddef 
%define %$isenum         "match"="enum"  %enddef
%define %$isenumitem     "match"="enumitem"  %enddef
%define %$isaccess       "match"="access"   %enddef
%define %$isclass        "match"="class","notmatch$template$templatetype"="class"   %enddef
%define %$isextend       "match"="extend"  %enddef
%define %$isconstructor  "match"="constructor"  %enddef
%define %$isdestructor   "match"="destructor"  %enddef
%define %$isnamespace    "match"="namespace"  %enddef
%define %$istemplate     "match"="template"  %enddef
%define %$isconstant     "match"="constant"  %enddef  /* %constant definition */

%define %$isunion        "match$kind"="union"  %enddef
%define %$isfunction     "match$kind"="function"  %enddef
%define %$isvariable     "match$kind"="variable"  %enddef
%define %$isimmutable    "match$feature:immutable"="1"  %enddef
%define %$hasconsttype   "match$hasconsttype"="1"  %enddef
%define %$hasvalue       "match$hasvalue"="1"  %enddef
%define %$isextension    "match$isextension"="1"  %enddef

%define %$isstatic       "match$storage"="static"  %enddef
%define %$isfriend       "match$storage"="friend"  %enddef
%define %$istypedef      "match$storage"="typedef"  %enddef
%define %$isvirtual      "match$storage"="virtual"  %enddef
%define %$isexplicit     "match$storage"="explicit"  %enddef
%define %$isextern       "match$storage"="extern"  %enddef

%define %$ismember       "match$ismember"="1"  %enddef
%define %$isglobal       %$not %$ismember  %enddef
%define %$isextendmember "match$isextendmember"="1"  %enddef
%define %$innamespace    "match$parentNode$nodeType"="namespace"  %enddef

%define %$ispublic       "match$access"="public"  %enddef
%define %$isprotected    "match$access"="protected"  %enddef
%define %$isprivate      "match$access"="private"  %enddef

%define %$ismemberget    "match$memberget"="1"  %enddef
%define %$ismemberset    "match$memberset"="1"  %enddef

%define %$classname      %$ismember,"match$parentNode$name"  %enddef
%define %$isnested       "match$nested"="1"  %enddef
/* -----------------------------------------------------------------------------
 * Include all the warnings labels and macros 
 * ----------------------------------------------------------------------------- */

%include <swigwarnings.swg>

/* -----------------------------------------------------------------------------
 * Overloading support
 * ----------------------------------------------------------------------------- */

/*
 * Function/method overloading support.   This is done through typemaps,
 * but also involves a precedence level.
 */

/* Macro for overload resolution */

%define %typecheck(_x...) %typemap(typecheck, precedence=_x) %enddef

/* Macros for precedence levels */

%define SWIG_TYPECHECK_POINTER       0     %enddef
%define SWIG_TYPECHECK_ITERATOR      5     %enddef
%define SWIG_TYPECHECK_VOIDPTR       10    %enddef
%define SWIG_TYPECHECK_BOOL          15    %enddef
%define SWIG_TYPECHECK_UINT8         20    %enddef
%define SWIG_TYPECHECK_INT8          25    %enddef
%define SWIG_TYPECHECK_UINT16        30    %enddef
%define SWIG_TYPECHECK_INT16         35    %enddef
%define SWIG_TYPECHECK_UINT32        40    %enddef
%define SWIG_TYPECHECK_INT32         45    %enddef
%define SWIG_TYPECHECK_SIZE          47    %enddef
%define SWIG_TYPECHECK_PTRDIFF       48    %enddef
%define SWIG_TYPECHECK_UINT64        50    %enddef
%define SWIG_TYPECHECK_INT64         55    %enddef
%define SWIG_TYPECHECK_UINT128       60    %enddef
%define SWIG_TYPECHECK_INT128        65    %enddef
%define SWIG_TYPECHECK_INTEGER       70    %enddef
%define SWIG_TYPECHECK_FLOAT         80    %enddef
%define SWIG_TYPECHECK_DOUBLE        90    %enddef
%define SWIG_TYPECHECK_CPLXFLT       95    %enddef
%define SWIG_TYPECHECK_CPLXDBL      100    %enddef
%define SWIG_TYPECHECK_COMPLEX      105    %enddef
%define SWIG_TYPECHECK_UNICHAR      110    %enddef
%define SWIG_TYPECHECK_STDUNISTRING 115    %enddef
%define SWIG_TYPECHECK_UNISTRING    120    %enddef
%define SWIG_TYPECHECK_CHAR         130    %enddef
%define SWIG_TYPECHECK_STDSTRING    135    %enddef
%define SWIG_TYPECHECK_STRING       140    %enddef
%define SWIG_TYPECHECK_PAIR         150    %enddef
%define SWIG_TYPECHECK_STDARRAY     155    %enddef
%define SWIG_TYPECHECK_VECTOR       160    %enddef
%define SWIG_TYPECHECK_DEQUE        170    %enddef
%define SWIG_TYPECHECK_LIST         180    %enddef
%define SWIG_TYPECHECK_SET          190    %enddef
%define SWIG_TYPECHECK_MULTISET     200    %enddef
%define SWIG_TYPECHECK_MAP          210    %enddef
%define SWIG_TYPECHECK_MULTIMAP     220    %enddef
%define SWIG_TYPECHECK_STACK        230    %enddef
%define SWIG_TYPECHECK_QUEUE        240    %enddef

%define SWIG_TYPECHECK_BOOL_ARRAY        1015    %enddef
%define SWIG_TYPECHECK_INT8_ARRAY        1025    %enddef
%define SWIG_TYPECHECK_INT16_ARRAY       1035    %enddef
%define SWIG_TYPECHECK_INT32_ARRAY       1045    %enddef
%define SWIG_TYPECHECK_INT64_ARRAY       1055    %enddef
%define SWIG_TYPECHECK_INT128_ARRAY      1065    %enddef
%define SWIG_TYPECHECK_FLOAT_ARRAY       1080    %enddef
%define SWIG_TYPECHECK_DOUBLE_ARRAY      1090    %enddef
%define SWIG_TYPECHECK_CHAR_ARRAY        1130    %enddef
%define SWIG_TYPECHECK_STRING_ARRAY      1140    %enddef
%define SWIG_TYPECHECK_OBJECT_ARRAY      1150    %enddef

%define SWIG_TYPECHECK_BOOL_PTR          2015    %enddef
%define SWIG_TYPECHECK_UINT8_PTR         2020    %enddef
%define SWIG_TYPECHECK_INT8_PTR          2025    %enddef
%define SWIG_TYPECHECK_UINT16_PTR        2030    %enddef
%define SWIG_TYPECHECK_INT16_PTR         2035    %enddef
%define SWIG_TYPECHECK_UINT32_PTR        2040    %enddef
%define SWIG_TYPECHECK_INT32_PTR         2045    %enddef
%define SWIG_TYPECHECK_UINT64_PTR        2050    %enddef
%define SWIG_TYPECHECK_INT64_PTR         2055    %enddef
%define SWIG_TYPECHECK_FLOAT_PTR         2080    %enddef
%define SWIG_TYPECHECK_DOUBLE_PTR        2090    %enddef
%define SWIG_TYPECHECK_CHAR_PTR          2130    %enddef

%define SWIG_TYPECHECK_SWIGOBJECT        5000    %enddef


/* -----------------------------------------------------------------------------
 * Default handling of certain overloaded operators 
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
%ignoreoperator(NEW)     operator new;
%ignoreoperator(DELETE)  operator delete;
%ignoreoperator(NEWARR)  operator new[];
%ignoreoperator(DELARR)  operator delete[];

/* add C++ operator aliases */
%rename("operator &&") operator and;    // `and'    `&&'
%rename("operator ||") operator or;     // `or'     `||'
%rename("operator !")  operator not;    // `not'     `!'
%rename("operator &=") operator and_eq; // `and_eq'  `&='
%rename("operator &")  operator bitand; // `bitand'  `&'
%rename("operator |")  operator bitor;  // `bitor'   `|'
%rename("operator ~")  operator compl;  // `compl'   `~'
%rename("operator !=") operator not_eq; // `not_eq'  `!='
%rename("operator |=") operator or_eq;  // `or_eq'   `|='
%rename("operator ^")  operator xor;    // `xor'     `^'
%rename("operator ^=") operator xor_eq; // `xor_eq'  `^='

/* Smart pointer handling */

%rename(__deref__) *::operator->;
%rename(__ref__)   *::operator*();
%rename(__ref__)   *::operator*() const;

/* Define std namespace */
namespace std {
  /* Warn about std::initializer_list usage. The constructor/method where used should probably be ignored. See docs. */
  template<typename T> class initializer_list {};
  %typemap(in, warning=SWIGWARN_TYPEMAP_INITIALIZER_LIST_MSG) initializer_list<T> ""
  %typemap(typecheck, precedence=SWIG_TYPECHECK_POINTER) initializer_list<T> ""
}
#endif

/* -----------------------------------------------------------------------------
 * Default char * and C array typemaps
 * ----------------------------------------------------------------------------- */

/* Set up the typemap for handling new return strings */

#ifdef __cplusplus
%typemap(newfree) char * "delete [] $1;";
#else
%typemap(newfree) char * "free($1);";
#endif

/* Default typemap for handling char * members */

#ifdef __cplusplus
%typemap(memberin) char * {
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(memberin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin) char * {
  delete [] $1;
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) const char * {
  if ($input) {
     $1 = ($1_type) (new char[strlen((const char *)$input)+1]);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
#else
%typemap(memberin) char * {
  free($1);
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(memberin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) const char * {
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin) char * {
  free($1);
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}
%typemap(globalin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) const char * {
  if ($input) {
     $1 = ($1_type) malloc(strlen((const char *)$input)+1);
     strcpy((char *)$1, (const char *)$input);
  } else {
     $1 = 0;
  }
}

#endif

/* Character array handling */

%typemap(memberin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(globalin) char [ANY] {
  if($input) {
    strncpy((char*)$1, (const char *)$input, $1_dim0-1);
    $1[$1_dim0-1] = 0;
  } else {
    $1[0] = 0;
  }
}

%typemap(memberin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

%typemap(globalin) char [] {
  if ($input) strcpy((char *)$1, (const char *)$input);
  else $1[0] = 0;
}

/* memberin/globalin typemap for arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

%typemap(globalin) SWIGTYPE [ANY] {
  size_t ii;
  $1_basetype *b = ($1_basetype *) $1;
  for (ii = 0; ii < (size_t)$1_size; ii++) b[ii] = *(($1_basetype *) $input + ii);
}

/* memberin/globalin typemap for double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = ($basetype (*)[$1_dim1])($input);
  $basetype (*dest)[$1_dim1] = ($basetype (*)[$1_dim1])($1);
  size_t ii = 0;
  for (; ii < $1_dim0; ++ii) {
    $basetype *ip = inp[ii];
    $basetype *dp = dest[ii];
    size_t jj = 0;
    for (; jj < $1_dim1; ++jj) dp[jj] = ip[jj];
  }
}

/* -----------------------------------------------------------------------------
 *  Runtime code
 * ----------------------------------------------------------------------------- */

/*  The SwigValueWrapper class  */

/*  
 * This template wrapper is used to handle C++ objects that are passed or 
 * returned by value.   This is necessary to handle objects that define
 * no default-constructor (making it difficult for SWIG to properly declare
 * local variables).
 *
 * The wrapper is used as follows.  First consider a function like this:
 *
 *      Vector cross_product(Vector a, Vector b)
 *
 * Now, if Vector is defined as a C++ class with no default constructor, 
 * code is generated as follows:
 *
 *     Vector *wrap_cross_product(Vector *inarg1, Vector *inarg2) {
 *          SwigValueWrapper<Vector>  arg1;
 *          SwigValueWrapper<Vector>  arg2;
 *          SwigValueWrapper<Vector> result;
 *
 *          arg1 = *inarg1;
 *          arg2 = *inarg2;
 *          ...            
 *          result = cross_product(arg1,arg2);
 *          ...
 *          return new Vector(result);
 *    }
 *         
 * In the wrappers, the template SwigValueWrapper simply provides a thin
 * layer around a Vector *.  However, it does this in a way that allows
 * the object to be bound after the variable declaration (which is not possible
 * with the bare object when it lacks a default constructor).  
 *
 * An observant reader will notice that the code after the variable declarations
 * is *identical* to the code used for classes that do define default constructors.
 * Thus, this neat trick allows us to fix this special case without having to
 * make massive changes to typemaps and other parts of the SWIG code generator.
 *
 * Note: this code is not included when SWIG runs in C-mode, when classes
 * define default constructors, or when pointers and references are used.
 * SWIG tries to avoid doing this except in very special circumstances.
 *
 * Note: This solution suffers from making a large number of copies
 * of the underlying object.  However, this is needed in the interest of
 * safety and in order to cover all of the possible ways in which a value
 * might be assigned.  For example:
 *
 *       arg1 = *inarg1;       // Assignment from a pointer
 *       arg1 = Vector(1,2,3); // Assignment from a value  
 *
 * The class offers a strong guarantee of exception safety.
 * With regards to the implementation, the private SwigMovePointer nested class is 
 * a simple smart pointer with move semantics, much like std::auto_ptr.
 *
 * This wrapping technique was suggested by William Fulton and is henceforth
 * known as the "Fulton Transform" :-).
 */

#ifdef __cplusplus
%insert("runtime") %{
#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};%}

/*
 * SwigValueInit() is a generic initialisation solution as the following approach:
 * 
 *       T c_result = T();
 * 
 * doesn't compile for all types for example:
 * 
 *       unsigned int c_result = unsigned int();
 */
%insert("runtime") %{
template <typename T> T SwigValueInit() {
  return T();
}
#endif
%}
#endif

/*  The swiglabels  */

%insert("runtime") "swiglabels.swg"





================================================
File: swig/swigwin-3.0.8/Lib/swigarch.i
================================================
/* -----------------------------------------------------------------------------
 * swigarch.i
 *
 * SWIG library file for 32bit/64bit code specialization and checking.
 *
 * Use only in extreme cases, when no arch. independent code can be
 * generated
 * 
 * To activate architecture specific code, use
 *
 *     swig -DSWIGWORDSIZE32
 *
 * or
 *
 *     swig -DSWIGWORDSIZE64
 *
 * Note that extra checking code will be added to the wrapped code,
 * which will prevent the compilation in a different architecture.
 *
 * If you don't specify the SWIGWORDSIZE (the default case), swig will
 * generate architecture independent and/or 32bits code, with no extra
 * checking code added.
 * ----------------------------------------------------------------------------- */

#if !defined(SWIGWORDSIZE32) &&  !defined(SWIGWORDSIZE64)
# if (__WORDSIZE == 32)
#  define SWIGWORDSIZE32
# endif
#endif
  
#if !defined(SWIGWORDSIZE64) &&  !defined(SWIGWORDSIZE32) 
# if defined(__x86_64) || defined(__x86_64__) || (__WORDSIZE == 64)
#  define SWIGWORDSIZE64
# endif
#endif


#ifdef SWIGWORDSIZE32
%{
#define SWIGWORDSIZE32
#ifndef LONG_MAX
#include <limits.h>
#endif
#if (__WORDSIZE == 64) || (LONG_MAX != INT_MAX)
# error "SWIG wrapped code invalid in 64 bit architecture, regenerate code using -DSWIGWORDSIZE64"
#endif
%}
#endif

#ifdef SWIGWORDSIZE64
%{
#define SWIGWORDSIZE64
#ifndef LONG_MAX
#include <limits.h>
#endif
#if (__WORDSIZE == 32) || (LONG_MAX == INT_MAX)
# error "SWIG wrapped code invalid in 32 bit architecture, regenerate code using -DSWIGWORDSIZE32"
#endif
%}
#endif
  




================================================
File: swig/swigwin-3.0.8/Lib/swigerrors.swg
================================================
/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13





================================================
File: swig/swigwin-3.0.8/Lib/swiginit.swg
================================================
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpreters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;

#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {

      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



================================================
File: swig/swigwin-3.0.8/Lib/swiglabels.swg
================================================
/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif



================================================
File: swig/swigwin-3.0.8/Lib/swigrun.i
================================================
/* -----------------------------------------------------------------------------
 * swigrun.i
 *
 * Empty module (for now).  Placeholder for runtime libs
 * ----------------------------------------------------------------------------- */

%module swigrun




================================================
File: swig/swigwin-3.0.8/Lib/swigrun.swg
================================================
/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif



================================================
File: swig/swigwin-3.0.8/Lib/swigwarn.swg
================================================
/* SWIG warning codes */


%define SWIGWARN_NONE                     0 %enddef

/* -- Deprecated features -- */

%define SWIGWARN_DEPRECATED_EXTERN        101 %enddef
%define SWIGWARN_DEPRECATED_VAL           102 %enddef
%define SWIGWARN_DEPRECATED_OUT           103 %enddef
%define SWIGWARN_DEPRECATED_DISABLEDOC    104 %enddef
%define SWIGWARN_DEPRECATED_ENABLEDOC     105 %enddef
%define SWIGWARN_DEPRECATED_DOCONLY       106 %enddef
%define SWIGWARN_DEPRECATED_STYLE         107 %enddef
%define SWIGWARN_DEPRECATED_LOCALSTYLE    108 %enddef
%define SWIGWARN_DEPRECATED_TITLE         109 %enddef
%define SWIGWARN_DEPRECATED_SECTION       110 %enddef
%define SWIGWARN_DEPRECATED_SUBSECTION    111 %enddef
%define SWIGWARN_DEPRECATED_SUBSUBSECTION 112 %enddef
%define SWIGWARN_DEPRECATED_ADDMETHODS    113 %enddef
%define SWIGWARN_DEPRECATED_READONLY      114 %enddef
%define SWIGWARN_DEPRECATED_READWRITE     115 %enddef
%define SWIGWARN_DEPRECATED_EXCEPT        116 %enddef
%define SWIGWARN_DEPRECATED_NEW           117 %enddef
%define SWIGWARN_DEPRECATED_EXCEPT_TM     118 %enddef
%define SWIGWARN_DEPRECATED_IGNORE_TM     119 %enddef
%define SWIGWARN_DEPRECATED_OPTC          120 %enddef
%define SWIGWARN_DEPRECATED_NAME          121 %enddef
%define SWIGWARN_DEPRECATED_NOEXTERN      122 %enddef
%define SWIGWARN_DEPRECATED_NODEFAULT     123 %enddef
%define SWIGWARN_DEPRECATED_TYPEMAP_LANG  124 %enddef
%define SWIGWARN_DEPRECATED_INPUT_FILE    125 %enddef
%define SWIGWARN_DEPRECATED_NESTED_WORKAROUND 126 %enddef

/* -- Preprocessor -- */

%define SWIGWARN_PP_MISSING_FILE          201 %enddef
%define SWIGWARN_PP_EVALUATION            202 %enddef
%define SWIGWARN_PP_INCLUDEALL_IMPORTALL  203 %enddef
%define SWIGWARN_PP_CPP_WARNING           204 %enddef
%define SWIGWARN_PP_CPP_ERROR             205 %enddef
%define SWIGWARN_PP_UNEXPECTED_TOKENS     206 %enddef

/* -- C/C++ Parser -- */

%define SWIGWARN_PARSE_CLASS_KEYWORD      301 %enddef
%define SWIGWARN_PARSE_REDEFINED          302 %enddef
%define SWIGWARN_PARSE_EXTEND_UNDEF       303 %enddef
%define SWIGWARN_PARSE_UNSUPPORTED_VALUE  304 %enddef
%define SWIGWARN_PARSE_BAD_VALUE          305 %enddef
%define SWIGWARN_PARSE_PRIVATE            306 %enddef
%define SWIGWARN_PARSE_BAD_DEFAULT        307 %enddef
%define SWIGWARN_PARSE_NAMESPACE_ALIAS    308 %enddef
%define SWIGWARN_PARSE_PRIVATE_INHERIT    309 %enddef
%define SWIGWARN_PARSE_TEMPLATE_REPEAT    310 %enddef
%define SWIGWARN_PARSE_TEMPLATE_PARTIAL   311 %enddef
%define SWIGWARN_PARSE_UNNAMED_NESTED_CLASS 312 %enddef
%define SWIGWARN_PARSE_UNDEFINED_EXTERN   313 %enddef
%define SWIGWARN_PARSE_KEYWORD            314 %enddef
%define SWIGWARN_PARSE_USING_UNDEF        315 %enddef
%define SWIGWARN_PARSE_MODULE_REPEAT      316 %enddef
%define SWIGWARN_PARSE_TEMPLATE_SP_UNDEF  317 %enddef
%define SWIGWARN_PARSE_TEMPLATE_AMBIG     318 %enddef
%define SWIGWARN_PARSE_NO_ACCESS          319 %enddef
%define SWIGWARN_PARSE_EXPLICIT_TEMPLATE  320 %enddef
%define SWIGWARN_PARSE_BUILTIN_NAME       321 %enddef
%define SWIGWARN_PARSE_REDUNDANT          322 %enddef
%define SWIGWARN_PARSE_REC_INHERITANCE    323 %enddef
%define SWIGWARN_PARSE_NESTED_TEMPLATE    324 %enddef
%define SWIGWARN_PARSE_NAMED_NESTED_CLASS 325 %enddef
%define SWIGWARN_PARSE_EXTEND_NAME        326 %enddef

%define SWIGWARN_CPP11_LAMBDA             340 %enddef
%define SWIGWARN_CPP11_ALIAS_DECLARATION  341 %enddef
%define SWIGWARN_CPP11_ALIAS_TEMPLATE     342 %enddef
%define SWIGWARN_CPP11_VARIADIC_TEMPLATE  343 %enddef

%define SWIGWARN_IGNORE_OPERATOR_NEW        350 %enddef	/* new */
%define SWIGWARN_IGNORE_OPERATOR_DELETE     351 %enddef	/* delete */
%define SWIGWARN_IGNORE_OPERATOR_PLUS       352 %enddef	/* + */
%define SWIGWARN_IGNORE_OPERATOR_MINUS      353 %enddef	/* - */
%define SWIGWARN_IGNORE_OPERATOR_MUL        354 %enddef	/* * */
%define SWIGWARN_IGNORE_OPERATOR_DIV        355 %enddef	/* / */
%define SWIGWARN_IGNORE_OPERATOR_MOD        356 %enddef	/* % */
%define SWIGWARN_IGNORE_OPERATOR_XOR        357 %enddef	/* ^ */
%define SWIGWARN_IGNORE_OPERATOR_AND        358 %enddef	/* & */
%define SWIGWARN_IGNORE_OPERATOR_OR         359 %enddef	/* | */
%define SWIGWARN_IGNORE_OPERATOR_NOT        360 %enddef	/* ~ */
%define SWIGWARN_IGNORE_OPERATOR_LNOT       361 %enddef	/* ! */
%define SWIGWARN_IGNORE_OPERATOR_EQ         362 %enddef	/* = */
%define SWIGWARN_IGNORE_OPERATOR_LT         363 %enddef	/* < */
%define SWIGWARN_IGNORE_OPERATOR_GT         364 %enddef	/* > */
%define SWIGWARN_IGNORE_OPERATOR_PLUSEQ     365 %enddef	/* += */
%define SWIGWARN_IGNORE_OPERATOR_MINUSEQ    366 %enddef	/* -= */
%define SWIGWARN_IGNORE_OPERATOR_MULEQ      367 %enddef	/* *= */
%define SWIGWARN_IGNORE_OPERATOR_DIVEQ      368 %enddef	/* /= */
%define SWIGWARN_IGNORE_OPERATOR_MODEQ      369 %enddef	/* %= */
%define SWIGWARN_IGNORE_OPERATOR_XOREQ      370 %enddef	/* ^= */
%define SWIGWARN_IGNORE_OPERATOR_ANDEQ      371 %enddef	/* &= */
%define SWIGWARN_IGNORE_OPERATOR_OREQ       372 %enddef	/* |= */
%define SWIGWARN_IGNORE_OPERATOR_LSHIFT     373 %enddef	/* << */
%define SWIGWARN_IGNORE_OPERATOR_RSHIFT     374 %enddef	/* >> */
%define SWIGWARN_IGNORE_OPERATOR_LSHIFTEQ   375 %enddef	/* <<= */
%define SWIGWARN_IGNORE_OPERATOR_RSHIFTEQ   376 %enddef	/* >>= */
%define SWIGWARN_IGNORE_OPERATOR_EQUALTO    377 %enddef	/* == */
%define SWIGWARN_IGNORE_OPERATOR_NOTEQUAL   378 %enddef	/* != */
%define SWIGWARN_IGNORE_OPERATOR_LTEQUAL    379 %enddef	/* <= */
%define SWIGWARN_IGNORE_OPERATOR_GTEQUAL    380 %enddef	/* >= */
%define SWIGWARN_IGNORE_OPERATOR_LAND       381 %enddef	/* && */
%define SWIGWARN_IGNORE_OPERATOR_LOR        382 %enddef	/* || */
%define SWIGWARN_IGNORE_OPERATOR_PLUSPLUS   383 %enddef	/* ++ */
%define SWIGWARN_IGNORE_OPERATOR_MINUSMINUS 384 %enddef	/* -- */
%define SWIGWARN_IGNORE_OPERATOR_COMMA      385 %enddef	/* , */
%define SWIGWARN_IGNORE_OPERATOR_ARROWSTAR  386 %enddef	/* ->* */
%define SWIGWARN_IGNORE_OPERATOR_ARROW      387 %enddef	/* -> */
%define SWIGWARN_IGNORE_OPERATOR_CALL       388 %enddef	/* () */
%define SWIGWARN_IGNORE_OPERATOR_INDEX      389 %enddef	/* [] */
%define SWIGWARN_IGNORE_OPERATOR_UPLUS      390 %enddef	/* + */
%define SWIGWARN_IGNORE_OPERATOR_UMINUS     391 %enddef	/* - */
%define SWIGWARN_IGNORE_OPERATOR_UMUL       392 %enddef	/* * */
%define SWIGWARN_IGNORE_OPERATOR_UAND       393 %enddef	/* & */
%define SWIGWARN_IGNORE_OPERATOR_NEWARR     394 %enddef	/* new [] */
%define SWIGWARN_IGNORE_OPERATOR_DELARR     395 %enddef	/* delete [] */
%define SWIGWARN_IGNORE_OPERATOR_REF        396 %enddef	/* operator *() */

/* 394-399 are reserved */

/* -- Type system and typemaps -- */

%define SWIGWARN_TYPE_UNDEFINED_CLASS     401 %enddef
%define SWIGWARN_TYPE_INCOMPLETE          402 %enddef
%define SWIGWARN_TYPE_ABSTRACT            403 %enddef
%define SWIGWARN_TYPE_REDEFINED           404 %enddef

%define SWIGWARN_TYPEMAP_SOURCETARGET     450 %enddef
%define SWIGWARN_TYPEMAP_CHARLEAK         451 %enddef
%define SWIGWARN_TYPEMAP_SWIGTYPE         452 %enddef
%define SWIGWARN_TYPEMAP_APPLY_UNDEF      453 %enddef
%define SWIGWARN_TYPEMAP_SWIGTYPELEAK     454 %enddef

%define SWIGWARN_TYPEMAP_IN_UNDEF         460 %enddef
%define SWIGWARN_TYPEMAP_OUT_UNDEF        461 %enddef
%define SWIGWARN_TYPEMAP_VARIN_UNDEF      462 %enddef
%define SWIGWARN_TYPEMAP_VAROUT_UNDEF     463 %enddef
%define SWIGWARN_TYPEMAP_CONST_UNDEF      464 %enddef
%define SWIGWARN_TYPEMAP_UNDEF            465 %enddef
%define SWIGWARN_TYPEMAP_VAR_UNDEF        466 %enddef
%define SWIGWARN_TYPEMAP_TYPECHECK        467 %enddef
%define SWIGWARN_TYPEMAP_THROW            468 %enddef
%define SWIGWARN_TYPEMAP_DIRECTORIN_UNDEF  469 %enddef
%define SWIGWARN_TYPEMAP_THREAD_UNSAFE     470 %enddef	/* mostly used in directorout typemaps */
%define SWIGWARN_TYPEMAP_DIRECTOROUT_UNDEF 471 %enddef
%define SWIGWARN_TYPEMAP_TYPECHECK_UNDEF   472 %enddef
%define SWIGWARN_TYPEMAP_DIRECTOROUT_PTR   473 %enddef
%define SWIGWARN_TYPEMAP_OUT_OPTIMAL_IGNORED  474 %enddef
%define SWIGWARN_TYPEMAP_OUT_OPTIMAL_MULTIPLE 475 %enddef
%define SWIGWARN_TYPEMAP_INITIALIZER_LIST  476 %enddef
%define SWIGWARN_TYPEMAP_DIRECTORTHROWS_UNDEF 477 %enddef

/* -- Fragments -- */
%define SWIGWARN_FRAGMENT_NOT_FOUND       490 %enddef

/* -- General code generation -- */

%define SWIGWARN_LANG_OVERLOAD_DECL       501 %enddef
%define SWIGWARN_LANG_OVERLOAD_CONSTRUCT  502 %enddef
%define SWIGWARN_LANG_IDENTIFIER          503 %enddef
%define SWIGWARN_LANG_RETURN_TYPE         504 %enddef
%define SWIGWARN_LANG_VARARGS             505 %enddef
%define SWIGWARN_LANG_VARARGS_KEYWORD     506 %enddef
%define SWIGWARN_LANG_NATIVE_UNIMPL       507 %enddef
%define SWIGWARN_LANG_DEREF_SHADOW        508 %enddef
%define SWIGWARN_LANG_OVERLOAD_SHADOW     509 %enddef
%define SWIGWARN_LANG_FRIEND_IGNORE       510 %enddef
%define SWIGWARN_LANG_OVERLOAD_KEYWORD    511 %enddef
%define SWIGWARN_LANG_OVERLOAD_CONST      512 %enddef
%define SWIGWARN_LANG_CLASS_UNNAMED       513 %enddef
%define SWIGWARN_LANG_DIRECTOR_VDESTRUCT  514 %enddef
%define SWIGWARN_LANG_DISCARD_CONST       515 %enddef
%define SWIGWARN_LANG_OVERLOAD_IGNORED    516 %enddef
%define SWIGWARN_LANG_DIRECTOR_ABSTRACT   517 %enddef
%define SWIGWARN_LANG_PORTABILITY_FILENAME 518 %enddef
%define SWIGWARN_LANG_TEMPLATE_METHOD_IGNORE 519 %enddef
%define SWIGWARN_LANG_SMARTPTR_MISSING    520 %enddef
%define SWIGWARN_LANG_ILLEGAL_DESTRUCTOR  521 %enddef
%define SWIGWARN_LANG_EXTEND_CONSTRUCTOR  522 %enddef
%define SWIGWARN_LANG_EXTEND_DESTRUCTOR   523 %enddef

/* -- Reserved (600-799) -- */

/* -- Language module specific warnings (700 - 899) -- */


%define SWIGWARN_D_TYPEMAP_CTYPE_UNDEF           700 %enddef
%define SWIGWARN_D_TYPEMAP_IMTYPE_UNDEF           701 %enddef
%define SWIGWARN_D_TYPEMAP_DTYPE_UNDEF           702 %enddef
%define SWIGWARN_D_MULTIPLE_INHERITANCE           703 %enddef
%define SWIGWARN_D_TYPEMAP_CLASSMOD_UNDEF         704 %enddef
%define SWIGWARN_D_TYPEMAP_DBODY_UNDEF            705 %enddef
%define SWIGWARN_D_TYPEMAP_DOUT_UNDEF             706 %enddef
%define SWIGWARN_D_TYPEMAP_DIN_UNDEF              707 %enddef
%define SWIGWARN_D_TYPEMAP_DDIRECTORIN_UNDEF      708 %enddef
%define SWIGWARN_D_TYPEMAP_DCONSTRUCTOR_UNDEF     709 %enddef
%define SWIGWARN_D_EXCODE_MISSING                 710 %enddef
%define SWIGWARN_D_CANTHROW_MISSING               711 %enddef
%define SWIGWARN_D_NO_DIRECTORCONNECT_ATTR        712 %enddef
%define SWIGWARN_D_NAME_COLLISION                 713 %enddef

/* please leave 700-719 free for D */

%define SWIGWARN_SCILAB_TRUNCATED_NAME            720 %enddef

/* please leave 720-739 free for Scilab */

%define SWIGWARN_PYTHON_INDENT_MISMATCH           740 %enddef

/* please leave 740-759 free for Python */

%define SWIGWARN_RUBY_WRONG_NAME                  801 %enddef
%define SWIGWARN_RUBY_MULTIPLE_INHERITANCE        802 %enddef

/* please leave 800-809 free for Ruby */

%define SWIGWARN_JAVA_TYPEMAP_JNI_UNDEF           810 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JTYPE_UNDEF         811 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JSTYPE_UNDEF        812 %enddef
%define SWIGWARN_JAVA_MULTIPLE_INHERITANCE        813 %enddef
%define SWIGWARN_JAVA_TYPEMAP_GETCPTR_UNDEF       814 %enddef
%define SWIGWARN_JAVA_TYPEMAP_CLASSMOD_UNDEF      815 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JAVABODY_UNDEF      816 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JAVAOUT_UNDEF       817 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JAVAIN_UNDEF        818 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JAVADIRECTORIN_UNDEF    819 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JAVADIRECTOROUT_UNDEF   820 %enddef
%define SWIGWARN_JAVA_COVARIANT_RET               822 %enddef
%define SWIGWARN_JAVA_TYPEMAP_JAVACONSTRUCT_UNDEF 823 %enddef
%define SWIGWARN_JAVA_TYPEMAP_DIRECTORIN_NODESC   824 %enddef
%define SWIGWARN_JAVA_NO_DIRECTORCONNECT_ATTR     825 %enddef
%define SWIGWARN_JAVA_NSPACE_WITHOUT_PACKAGE      826 %enddef

/* please leave 810-829 free for Java */

%define SWIGWARN_CSHARP_TYPEMAP_CTYPE_UNDEF       830 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSTYPE_UNDEF      831 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSWTYPE_UNDEF     832 %enddef
%define SWIGWARN_CSHARP_MULTIPLE_INHERITANCE      833 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_GETCPTR_UNDEF     834 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CLASSMOD_UNDEF    835 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSBODY_UNDEF      836 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSOUT_UNDEF       837 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSIN_UNDEF        838 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSDIRECTORIN_UNDEF    839 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSDIRECTOROUT_UNDEF   840 %enddef
%define SWIGWARN_CSHARP_COVARIANT_RET             842 %enddef
%define SWIGWARN_CSHARP_TYPEMAP_CSCONSTRUCT_UNDEF 843 %enddef
%define SWIGWARN_CSHARP_EXCODE                    844 %enddef
%define SWIGWARN_CSHARP_CANTHROW                  845 %enddef
%define SWIGWARN_CSHARP_NO_DIRECTORCONNECT_ATTR   846 %enddef

/* please leave 830-849 free for C# */

%define SWIGWARN_MODULA3_TYPEMAP_TYPE_UNDEF        850 %enddef
%define SWIGWARN_MODULA3_TYPEMAP_GETCPTR_UNDEF     851 %enddef
%define SWIGWARN_MODULA3_TYPEMAP_CLASSMOD_UNDEF    852 %enddef
%define SWIGWARN_MODULA3_TYPEMAP_PTRCONSTMOD_UNDEF 853 %enddef
%define SWIGWARN_MODULA3_TYPEMAP_MULTIPLE_RETURN   854 %enddef
%define SWIGWARN_MODULA3_MULTIPLE_INHERITANCE      855 %enddef
%define SWIGWARN_MODULA3_TYPECONSTRUCTOR_UNKNOWN   856 %enddef
%define SWIGWARN_MODULA3_UNKNOWN_PRAGMA            857 %enddef
%define SWIGWARN_MODULA3_BAD_ENUMERATION           858 %enddef
%define SWIGWARN_MODULA3_DOUBLE_ID                 859 %enddef
%define SWIGWARN_MODULA3_BAD_IMPORT                860 %enddef

/* please leave 850-869 free for Modula 3 */

%define SWIGWARN_PHP_MULTIPLE_INHERITANCE         870 %enddef
%define SWIGWARN_PHP_UNKNOWN_PRAGMA               871 %enddef
%define SWIGWARN_PHP_PUBLIC_BASE                  872 %enddef

/* please leave 870-889 free for PHP */

%define SWIGWARN_GO_NAME_CONFLICT                 890 %enddef

/* please leave 890-899 free for Go */

/* -- User defined warnings (900 - 999) -- */




================================================
File: swig/swigwin-3.0.8/Lib/swigwarnings.swg
================================================
/*
  Include the internal swig macro codes. These macros correspond to
  the one found in Source/Include/swigwarn.h plus the 'SWIG' prefix.
  
  For example, in the include file 'swigwarn.h' you will find

    #define WARN_TYPEMAP_CHARLEAK ...

  and in the 'swigwarn.swg' interface, you will see

    %define SWIGWARN_TYPEMAP_CHARLEAK ...

  This code can be used in warning filters as follows:

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  Warnings messages used in typemaps. Message names will be the same
  as those in Lib/swigwarn.swg but with the suffix _MSG.
   
  For example, for the code SWIGWARN_TYPEMAP_CHARLEAK, once you use

    %typemapmsg(CHARLEAK,<msg>);

  you use the message in your typemap as

    %typemap(varin,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) char * 

  while you suppress the warning using

    %warnfilter(SWIGWARN_TYPEMAP_CHARLEAK);

  as described above.
*/

/* -----------------------------------------------------------------------------
 * SWIG warning codes
 * ----------------------------------------------------------------------------- */

%include <swigwarn.swg>

/* -----------------------------------------------------------------------------
 * Auxiliary macros
 * ----------------------------------------------------------------------------- */

/* Macro to define warning messages */
#define %_warningmsg(Val, Msg...) `Val`":"Msg 
#define %warningmsg(Val, Msg...) %_warningmsg(Val, Msg)

/* -----------------------------------------------------------------------------
 *  Typemap related warning messages
 * ----------------------------------------------------------------------------- */

%define SWIGWARN_TYPEMAP_CHARLEAK_MSG         "451:Setting a const char * variable may leak memory." %enddef
%define SWIGWARN_TYPEMAP_SWIGTYPELEAK_MSG     "454:Setting a pointer/reference variable may leak memory." %enddef
%define SWIGWARN_TYPEMAP_THREAD_UNSAFE_MSG    "470:Thread/reentrant unsafe wrapping, consider returning by value instead." %enddef
%define SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG  "473:Returning a pointer or reference in a director method is not recommended." %enddef
%define SWIGWARN_TYPEMAP_INITIALIZER_LIST_MSG "476:Initialization using std::initializer_list." %enddef

/* -----------------------------------------------------------------------------
 * Operator related warning messages 
 * ----------------------------------------------------------------------------- */

%define SWIGWARN_IGNORE_OPERATOR_NEW_MSG        "350:operator new ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_DELETE_MSG     "351:operator delete ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_PLUS_MSG       "352:operator+ ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_MINUS_MSG      "353:operator- ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_MUL_MSG        "354:operator* ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_DIV_MSG        "355:operator/ ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_MOD_MSG        "356:operator% ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_XOR_MSG        "357:operator^ ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_AND_MSG        "358:operator& ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_OR_MSG         "359:operator| ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_NOT_MSG        "360:operator~ ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_LNOT_MSG       "361:operator! ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_EQ_MSG         "362:operator= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_LT_MSG         "363:operator< ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_GT_MSG         "364:operator> ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_PLUSEQ_MSG     "365:operator+= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_MINUSEQ_MSG    "366:operator-= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_MULEQ_MSG      "367:operator*= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_DIVEQ_MSG      "368:operator/= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_MODEQ_MSG      "369:operator%= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_XOREQ_MSG      "370:operator^= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_ANDEQ_MSG      "371:operator&= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_OREQ_MSG       "372:operator|= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_LSHIFT_MSG     "373:operator<< ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_RSHIFT_MSG     "374:operator>> ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_LSHIFTEQ_MSG   "375:operator<<= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_RSHIFTEQ_MSG   "376:operator>>= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_EQUALTO_MSG    "377:operator== ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_NOTEQUAL_MSG   "378:operator!= ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_LTEQUAL_MSG    "379:operator<= ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_GTEQUAL_MSG    "380:operator>= ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_LAND_MSG       "381:operator&& ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_LOR_MSG        "382:operator|| ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_PLUSPLUS_MSG   "383:operator++ ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_MINUSMINUS_MSG "384:operator-- ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_COMMA_MSG      "385:operator-- ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_ARROWSTAR_MSG  "386:operator->* ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_ARROW_MSG      "387:operator-> ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_CALL_MSG       "388:operator() ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_INDEX_MSG      "389:operator[] ignored (consider using %%extend)"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_UPLUS_MSG      "390:operator+ ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_UMINUS_MSG     "391:operator- ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_UMUL_MSG       "392:operator* ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_UAND_MSG       "393:operator& ignored" %enddef
%define SWIGWARN_IGNORE_OPERATOR_NEWARR_MSG     "394:operator new[] ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_DELARR_MSG     "395:operator delete[] ignored"  %enddef
%define SWIGWARN_IGNORE_OPERATOR_REF_MSG        "396:operator*() ignored" %enddef

#define %ignoreoperator(Oper) %ignorewarn(SWIGWARN_IGNORE_OPERATOR_##Oper##_MSG)

/* -----------------------------------------------------------------------------
 * Macros for keyword and built-in names 
 * ----------------------------------------------------------------------------- */

#define %keywordwarn(msg...) %namewarn(%warningmsg(SWIGWARN_PARSE_KEYWORD, msg)) 
#define %builtinwarn(msg...) %namewarn(%warningmsg(SWIGWARN_PARSE_BUILTIN_NAME, msg), %$isfunction)


/* -----------------------------------------------------------------------------
 * Warning filter feature
 * ----------------------------------------------------------------------------- */

#define %_warnfilter(filter...) %feature("warnfilter",`filter`)
#define %warnfilter(filter...) %_warnfilter(filter)






================================================
File: swig/swigwin-3.0.8/Lib/wchar.i
================================================
/* -----------------------------------------------------------------------------
 * wchar.i
 * ----------------------------------------------------------------------------- */

/*
  wchar_t not supported, unless otherwise specified in the target language.
*/

#if defined(SWIG_WCHAR)
#undef SWIG_WCHAR
#endif



================================================
File: swig/swigwin-3.0.8/Lib/windows.i
================================================
/* -----------------------------------------------------------------------------
 * windows.i
 *
 * SWIG library file to support types found in windows.h as well as Microsoft
 * integral type extensions. The types are set for 32 bit Windows.
 * ----------------------------------------------------------------------------- */

// Support for non ISO (Windows) integral types
%apply unsigned char { unsigned __int8 };
%apply const unsigned char& { const unsigned __int8& };

%apply signed char { __int8 };
%apply const signed char& { const __int8& };

%apply unsigned short { unsigned __int16 };
%apply const unsigned short& { const unsigned __int16& };

%apply short { __int16 };
%apply const short& { const __int16& };

%apply unsigned int { unsigned __int32 };
%apply const unsigned int& { const unsigned __int32& };

%apply int { __int32 };
%apply const int& { const __int32& };

%apply unsigned long long { unsigned __int64 };
%apply const unsigned long long& { const unsigned __int64& };

%apply long long { __int64 };
%apply const long long& { const __int64& };


// Workaround Microsoft calling conventions
#define __cdecl
#define __fastcall
#define __far
#define __forceinline
#define __fortran
#define __inline
#define __pascal
#define __stdcall
#define __syscall
#define _cdecl
#define _fastcall
#define _inline
#define _pascal
#define _stdcall
#define WINAPI
#define __declspec(WINDOWS_EXTENDED_ATTRIBUTE)

#define __w64

// Types from windef.h
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
typedef unsigned long DWORD;
typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef float FLOAT;
typedef FLOAT *PFLOAT;
typedef BOOL *PBOOL;
typedef BOOL *LPBOOL;
typedef BYTE *PBYTE;
typedef BYTE *LPBYTE;
typedef int *PINT;
typedef int *LPINT;
typedef WORD *PWORD;
typedef WORD *LPWORD;
typedef long *LPLONG;
typedef DWORD *PDWORD;
typedef DWORD *LPDWORD;
typedef void *LPVOID;
typedef const void *LPCVOID;
typedef int INT;
typedef unsigned int UINT;
typedef unsigned int *PUINT;

// Types from basetsd.h
typedef signed char INT8, *PINT8;
typedef signed short INT16, *PINT16;
typedef signed int INT32, *PINT32;
typedef signed __int64 INT64, *PINT64;
typedef unsigned char UINT8, *PUINT8;
typedef unsigned short UINT16, *PUINT16;
typedef unsigned int UINT32, *PUINT32;
typedef unsigned __int64 UINT64, *PUINT64;
typedef signed int LONG32, *PLONG32;
typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
typedef __w64 int INT_PTR, *PINT_PTR;
typedef __w64 unsigned int UINT_PTR, *PUINT_PTR;
typedef __w64 long LONG_PTR, *PLONG_PTR;
typedef __w64 unsigned long ULONG_PTR, *PULONG_PTR;
typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef __w64 long SHANDLE_PTR;
typedef __w64 unsigned long HANDLE_PTR;
typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
typedef __int64 LONG64, *PLONG64;
typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;

// Types from winnt.h
typedef void *PVOID;
typedef void *PVOID64;
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef const CHAR *LPCSTR, *PCSTR;
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;
typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef SHORT *PSHORT;
typedef LONG *PLONG;
typedef void *HANDLE;
typedef HANDLE *PHANDLE;
typedef BYTE FCHAR;
typedef WORD FSHORT;
typedef DWORD FLONG;
typedef LONG HRESULT;
typedef char CCHAR;
typedef DWORD LCID;
typedef PDWORD PLCID;
typedef WORD LANGID;
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;
typedef ULONGLONG DWORDLONG;
typedef DWORDLONG *PDWORDLONG;
typedef BYTE BOOLEAN;
typedef BOOLEAN *PBOOLEAN;




================================================
File: swig/swigwin-3.0.8/Lib/cffi/cffi.swg
================================================
/* Define a C preprocessor symbol that can be used in interface files
   to distinguish between the SWIG language modules. */ 

#define SWIG_CFFI

/* Typespecs for basic types. */

%typemap(cin) void ":void";

%typemap(cin) char ":char";
%typemap(cin) char * ":string";
%typemap(cin) unsigned char ":unsigned-char";
%typemap(cin) signed char ":char";

%typemap(cin) short ":short";
%typemap(cin) signed short ":short";
%typemap(cin) unsigned short ":unsigned-short";

%typemap(cin) int ":int";
%typemap(cin) signed int ":int";
%typemap(cin) unsigned int ":unsigned-int";

%typemap(cin) long ":long";
%typemap(cin) signed long ":long";
%typemap(cin) unsigned long ":unsigned-long";

%typemap(cin) long long ":long-long";
%typemap(cin) signed long long ":long-long";
%typemap(cin) unsigned long long ":unsigned-long-long";

%typemap(cin) float ":float";
%typemap(cin) double ":double";
%typemap(cin) SWIGTYPE ":pointer";

%typemap(cout) void ":void";

%typemap(cout) char ":char";
%typemap(cout) char * ":string";
%typemap(cout) unsigned char ":unsigned-char";
%typemap(cout) signed char ":char";

%typemap(cout) short ":short";
%typemap(cout) signed short ":short";
%typemap(cout) unsigned short ":unsigned-short";

%typemap(cout) int ":int";
%typemap(cout) signed int ":int";
%typemap(cout) unsigned int ":unsigned-int";

%typemap(cout) long ":long";
%typemap(cout) signed long ":long";
%typemap(cout) unsigned long ":unsigned-long";

%typemap(cout) long long ":long-long";
%typemap(cout) signed long long ":long-long";
%typemap(cout) unsigned long long ":unsigned-long-long";

%typemap(cout) float ":float";
%typemap(cout) double ":double";
%typemap(cout) SWIGTYPE ":pointer";


%typemap(ctype) bool                       "int";
%typemap(ctype) char, unsigned char, signed char,
                short, signed short, unsigned short,
                int, signed int, unsigned int,
                long, signed long, unsigned long,
                float, double, long double, char *, void *, void,
                enum SWIGTYPE, SWIGTYPE *,
                SWIGTYPE[ANY], SWIGTYPE &, SWIGTYPE && "$1_ltype";
%typemap(ctype) SWIGTYPE                   "$&1_type";

%typemap(in) bool                          "$1 = (bool)$input;";
%typemap(in) char, unsigned char, signed char,
             short, signed short, unsigned short,
             int, signed int, unsigned int,
             long, signed long, unsigned long,
             float, double, long double, char *, void *, void,
             enum SWIGTYPE, SWIGTYPE *,
             SWIGTYPE[ANY], SWIGTYPE &, SWIGTYPE && "$1 = $input;";
%typemap(in) SWIGTYPE                      "$1 = *$input;";

%typemap(out) void                         "";
%typemap(out) bool                          "$result = (int)$1;";
%typemap(out) char, unsigned char, signed char,
              short, signed short, unsigned short,
              int, signed int, unsigned int,
              long, signed long, unsigned long,
              float, double, long double, char *, void *,
              enum SWIGTYPE, SWIGTYPE *,
              SWIGTYPE[ANY], SWIGTYPE &, SWIGTYPE && "$result = $1;";
#ifdef __cplusplus
%typemap(out) SWIGTYPE                     "$result = new $1_type($1);";
#else
%typemap(out) SWIGTYPE {
  $result = ($&1_ltype) malloc(sizeof($1_type));
  memmove($result, &$1, sizeof($1_type));
}
#endif

%typecheck(SWIG_TYPECHECK_BOOL) bool { $1 = 1; };
%typecheck(SWIG_TYPECHECK_CHAR) char { $1 = 1; };
%typecheck(SWIG_TYPECHECK_FLOAT) float { $1 = 1; };
%typecheck(SWIG_TYPECHECK_DOUBLE) double { $1 = 1; };
%typecheck(SWIG_TYPECHECK_STRING) char * { $1 = 1; };
%typecheck(SWIG_TYPECHECK_INTEGER)
                    unsigned char, signed char,
                    short, signed short, unsigned short,
                    int, signed int, unsigned int,
                    long, signed long, unsigned long,
                    enum SWIGTYPE { $1 = 1; };
%typecheck(SWIG_TYPECHECK_POINTER) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&,
                                   SWIGTYPE[ANY], SWIGTYPE { $1 = 1; };
/* This maps C/C++ types to Lisp classes for overload dispatch */

%typemap(lisptype) bool "cl:boolean";
%typemap(lisptype) char "cl:character";
%typemap(lisptype) unsigned char "cl:integer";
%typemap(lisptype) signed char "cl:integer";

%typemap(lispclass) bool "t";
%typemap(lispclass) char "cl:character";
%typemap(lispclass) unsigned char, signed char,
                    short, signed short, unsigned short,
                    int, signed int, unsigned int,
                    long, signed long, unsigned long,
                    enum SWIGTYPE       "cl:integer";
/* CLOS methods can't be specialized on single-float or double-float */
%typemap(lispclass) float "cl:number";
%typemap(lispclass) double "cl:number";
%typemap(lispclass) char * "cl:string";

/* Array reference typemaps */
%apply SWIGTYPE & { SWIGTYPE ((&)[ANY]) }
%apply SWIGTYPE && { SWIGTYPE ((&&)[ANY]) }

/* const pointers */
%apply SWIGTYPE * { SWIGTYPE *const }

%{

#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>
%}

%insert("swiglisp") %{
;;;SWIG wrapper code starts here

(cl:defmacro defanonenum (cl:&body enums)
   "Converts anonymous enums to defconstants."
  `(cl:progn ,@(cl:loop for value in enums
                        for index = 0 then (cl:1+ index)
                        when (cl:listp value) do (cl:setf index (cl:second value)
                                                          value (cl:first value))
                        collect `(cl:defconstant ,value ,index))))

(cl:eval-when (:compile-toplevel :load-toplevel)
  (cl:unless (cl:fboundp 'swig-lispify)
    (cl:defun swig-lispify (name flag cl:&optional (package cl:*package*))
      (cl:labels ((helper (lst last rest cl:&aux (c (cl:car lst)))
                    (cl:cond
                      ((cl:null lst)
                       rest)
                      ((cl:upper-case-p c)
                       (helper (cl:cdr lst) 'upper
                               (cl:case last
                                 ((lower digit) (cl:list* c #\- rest))
                                 (cl:t (cl:cons c rest)))))
                      ((cl:lower-case-p c)
                       (helper (cl:cdr lst) 'lower (cl:cons (cl:char-upcase c) rest)))
                      ((cl:digit-char-p c)
                       (helper (cl:cdr lst) 'digit 
                               (cl:case last
                                 ((upper lower) (cl:list* c #\- rest))
                                 (cl:t (cl:cons c rest)))))
                      ((cl:char-equal c #\_)
                       (helper (cl:cdr lst) '_ (cl:cons #\- rest)))
                      (cl:t
                       (cl:error "Invalid character: ~A" c)))))
        (cl:let ((fix (cl:case flag
                        ((constant enumvalue) "+")
                        (variable "*")
                        (cl:t ""))))
          (cl:intern
           (cl:concatenate
            'cl:string
            fix
            (cl:nreverse (helper (cl:concatenate 'cl:list name) cl:nil cl:nil))
            fix)
           package))))))

;;;SWIG wrapper code ends here
%}

#ifdef __cplusplus
%typemap(out) SWIGTYPE                     "$result = new $1_type($1);";
#else
%typemap(out) SWIGTYPE {
  $result = ($&1_ltype) malloc(sizeof($1_type));
  memmove($result, &$1, sizeof($1_type));
}
#endif

//////////////////////////////////////////////////////////////

/* name conversion for overloaded operators. */
#ifdef __cplusplus
%rename(__add__)	     *::operator+;
%rename(__pos__)	     *::operator+();
%rename(__pos__)	     *::operator+() const;

%rename(__sub__)	     *::operator-;
%rename(__neg__)	     *::operator-() const;
%rename(__neg__)	     *::operator-();

%rename(__mul__)	     *::operator*;
%rename(__deref__)	     *::operator*();
%rename(__deref__)	     *::operator*() const;

%rename(__div__)	     *::operator/;
%rename(__mod__)	     *::operator%;
%rename(__logxor__)	     *::operator^;
%rename(__logand__)	     *::operator&;
%rename(__logior__)	     *::operator|;
%rename(__lognot__)	     *::operator~();
%rename(__lognot__)	     *::operator~() const;

%rename(__not__)	     *::operator!();
%rename(__not__)	     *::operator!() const;

%rename(__assign__)	     *::operator=;

%rename(__add_assign__)      *::operator+=;
%rename(__sub_assign__)	     *::operator-=;
%rename(__mul_assign__)	     *::operator*=;
%rename(__div_assign__)	     *::operator/=;
%rename(__mod_assign__)	     *::operator%=;
%rename(__logxor_assign__)   *::operator^=;
%rename(__logand_assign__)   *::operator&=;
%rename(__logior_assign__)   *::operator|=;

%rename(__lshift__)	     *::operator<<;
%rename(__lshift_assign__)   *::operator<<=;
%rename(__rshift__)	     *::operator>>;
%rename(__rshift_assign__)   *::operator>>=;

%rename(__eq__)		     *::operator==;
%rename(__ne__)		     *::operator!=;
%rename(__lt__)		     *::operator<;
%rename(__gt__)		     *::operator>;
%rename(__lte__)	     *::operator<=;
%rename(__gte__)	     *::operator>=;

%rename(__and__)	     *::operator&&;
%rename(__or__)		     *::operator||;

%rename(__preincr__)	     *::operator++();
%rename(__postincr__)	     *::operator++(int);
%rename(__predecr__)	     *::operator--();
%rename(__postdecr__)	     *::operator--(int);

%rename(__comma__)	     *::operator,();
%rename(__comma__)	     *::operator,() const;

%rename(__member_ref__)      *::operator->;
%rename(__member_func_ref__) *::operator->*;

%rename(__funcall__)	     *::operator();
%rename(__aref__)	     *::operator[];
#endif


%{

#ifdef __cplusplus
#  define EXTERN   extern "C"
#else
#  define EXTERN   extern
#endif

#define EXPORT   EXTERN SWIGEXPORT

#include <string.h>
#include <stdlib.h>
%}



================================================
File: swig/swigwin-3.0.8/Lib/python/Makefile.in
================================================
# ---------------------------------------------------------------
# SWIG Python Makefile
#
# This file can be used to build various Python extensions with SWIG.
# By default this file is set up for dynamic loading, but it can
# be easily customized for static extensions by modifying various
# portions of the file.
#
#        SRCS       = C source files
#        CXXSRCS    = C++ source files
#        OBJCSRCS   = Objective-C source files
#        OBJS       = Additional .o files (compiled previously)
#        INTERFACE  = SWIG interface file
#        TARGET     = Name of target module or executable
#
# Many portions of this file were created by the SWIG configure
# script and should already reflect your machine.
#----------------------------------------------------------------

SRCS          =
CXXSRCS       =
OBJCSRCS      =
OBJS          =
INTERFACE     =
WRAPFILE      = $(INTERFACE:.i=_wrap.c)
WRAPOBJ       = $(INTERFACE:.i=_wrap.o)
TARGET        = module@SO@ # Use this kind of target for dynamic loading
#TARGET        = mypython  # Use this target for static linking

prefix        = @prefix@
exec_prefix   = @exec_prefix@

CC            = @CC@
CXX           = @CXX@
OBJC          = @CC@ -Wno-import # -Wno-import needed for gcc
CFLAGS        =
INCLUDES      =
LIBS          =

# SWIG Options
#     SWIG      = location of the SWIG executable
#     SWIGOPT   = SWIG compiler options
#     SWIGCC    = Compiler used to compile the wrapper file

SWIG          = $(exec_prefix)/bin/swig
SWIGOPT       = -python
SWIGCC        = $(CC)

# SWIG Library files.  Uncomment if rebuilding the Python interpreter
#SWIGLIBS      = -lembed.i

# Rules for creating .o files from source.

COBJS         = $(SRCS:.c=.o)
CXXOBJS       = $(CXXSRCS:.cxx=.o)
OBJCOBJS      = $(OBJCSRCS:.m=.o)
ALLOBJS       = $(COBJS) $(CXXOBJS) $(OBJCOBJS) $(OBJS)

# Command that will be used to build the final extension.
BUILD         = $(SWIGCC)

# Uncomment the following if you are using dynamic loading
CCSHARED      = @CCSHARED@
BUILD         = @LDSHARED@

# Uncomment the following if you are using dynamic loading with C++ and
# need to provide additional link libraries (this is not always required).

#DLL_LIBS      = -L/usr/local/lib/gcc-lib/sparc-sun-solaris2.5.1/2.7.2 \
	     -L/usr/local/lib -lg++ -lstdc++ -lgcc

# Python installation

PY_INCLUDE    = -DHAVE_CONFIG_H @PYINCLUDE@
PY_LIB        = @PYLIB@

# Build libraries (needed for static builds)

LIBM          = @LIBM@
LIBC          = @LIBC@
SYSLIBS       = $(LIBM) $(LIBC) @LIBS@

# Build options

BUILD_LIBS    = $(LIBS) # Dynamic loading

# Compilation rules for non-SWIG components

.SUFFIXES: .c .cxx .m

.c.o:
	$(CC) $(CCSHARED) $(CFLAGS) $(INCLUDES) -c $<

.cxx.o:
	$(CXX) $(CCSHARED) $(CXXFLAGS) $(INCLUDES) -c $<

.m.o:
	$(OBJC) $(CCSHARED) $(CFLAGS) $(INCLUDES) -c $<


# ----------------------------------------------------------------------
# Rules for building the extension
# ----------------------------------------------------------------------

all: $(TARGET)

# Convert the wrapper file into an object file

$(WRAPOBJ) : $(WRAPFILE)
	$(SWIGCC) -c $(CCSHARED) $(CFLAGS) $(WRAPFILE) $(INCLUDES) $(PY_INCLUDE)

$(WRAPFILE) : $(INTERFACE)
	$(SWIG) $(SWIGOPT) -o $(WRAPFILE) $(SWIGLIBS) $(INTERFACE)

$(TARGET): $(WRAPOBJ) $(ALLOBJS)
	$(BUILD) $(WRAPOBJ) $(ALLOBJS) $(BUILD_LIBS) -o $(TARGET)

clean:
	rm -f $(COBJS) $(CXXOBJS) $(OBJCOBJS) $(WRAPOBJ) $(WRAPFILE) $(TARGET)



================================================
File: swig/swigwin-3.0.8/Lib/python/README
================================================
/* -----------------------------------------------------------------------------
 *
 *  User interfaces: include these ones as needed
 *
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 *  Special types and user helpers 
 * ----------------------------------------------------------------------------- */

argcargv.i		Handler for (int argc, char **argv)
attribute.i		Convert a pair of set/get methods into a "native" python attribute
ccomplex.i		C99 complex type
complex.i		C99 or C++ complex type
cstring.i		Various forms of C character string handling
cwstring.i		Various forms of C wchar_t string handling
embed.i			embedding the Python interpreter in something else
embed15.i		embedding the Python interpreter in something else
file.i			FILE C type
implicit.i		Allow the use of implicit C++ constructors
wchar.i			wchar_t C type

/* -----------------------------------------------------------------------------
 *  C++ STD + STL
 * ----------------------------------------------------------------------------- */

std_alloc.i		allocator 
std_basic_string.i	basic string
std_char_traits.i	char traits
std_complex.i		complex
std_deque.i		deque	
std_except.i		exceptions
std_ios.i		ios
std_iostream.i		istream/ostream
std_list.i		list
std_map.i		map
std_multimap.i		multimap
std_multiset.i		multiset
std_pair.i		pair
std_set.i		set
std_sstream.i		string stream
std_streambuf.i		streambuf
std_string.i		string
std_vector.i		vector
std_wios.i		wios
std_wiostream.i		wistream/wostream
std_wsstream.i		wstring stream
std_wstreambuf.i	wstreambuf
std_wstring.i		wstring



/* -----------------------------------------------------------------------------
/* 
 *  Implementation files: don't look at them unless you are really drunk
 *
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 *  Basic files
 * ----------------------------------------------------------------------------- */

python.swg		Main language file, it just includes what is needed.
pyuserdir.swg		User visible directives (%pythonnondynamic, etc)
pymacros.swg		Internal macros used for typemaps
pyfragments.swg		Allow the user to overload the default fragments
pyopers.swg		Python operations (+=, *=, etc)
pythonkw.swg		Python keywords and special names
pyinit.swg		Python Init method

/* -----------------------------------------------------------------------------
 *  The runtime part
 * ----------------------------------------------------------------------------- */

pyruntime.swg		Main runtime file definition
pyapi.swg		SWIG/Python API declarations
pyrun.swg		Python run-time code 

/* -----------------------------------------------------------------------------
 *  Internal typemap specializations
 * ----------------------------------------------------------------------------- */

pyswigtype.swg		SWIGTYPE
pystrings.swg		Char strings (char *)
pywstrings.swg		Wchar Strings (wchar_t *)
pyprimtypes.swg		Primitive types (shot,int,double,etc)
pycomplex.swg		PyComplex and helper for C/C++ complex types
pydocs.swg		Typemaps documentation

/* -----------------------------------------------------------------------------
 *  C++ STD + STL
 * ----------------------------------------------------------------------------- */

pycontainer.swg		python container iterators
std_common.i		general common code for the STD/STL implementation
std_container.i		general common code for the STD/STL containers


/*-----------------------------------------------------------------------------
 *  Backward compatibility and deprecated
 * ----------------------------------------------------------------------------- */

std_vectora.i		vector + allocator (allocators are now supported in STD/STL)
typemaps.i		old in/out typemaps (doesn't need to be included)
defarg.swg		for processing default arguments with shadow classes



================================================
File: swig/swigwin-3.0.8/Lib/python/argcargv.i
================================================
/* ------------------------------------------------------------
 * --- Argc & Argv ---
 * ------------------------------------------------------------ */

%fragment("SWIG_AsArgcArgv","header",fragment="SWIG_AsCharPtrAndSize") {
SWIGINTERN int
SWIG_AsArgcArgv(PyObject *input,
		swig_type_info *ppchar_info,
		size_t *argc, char ***argv, int *owner)
{  
  void *vptr;
  int res = SWIG_ConvertPtr(input, &vptr, ppchar_info, 0);
  if (!SWIG_IsOK(res)) {
    int list = 0;
    PyErr_Clear();
    list = PyList_Check(input);
    if (list || PyTuple_Check(input)) {
      size_t i = 0;
      size_t size = list ? PyList_Size(input) : PyTuple_Size(input);
      if (argc) *argc = size;
      if (argv) {
	*argv = %new_array(size + 1, char*);
	for (; i < size; ++i) {
	  PyObject *obj = list ? PyList_GetItem(input,i) : PyTuple_GetItem(input,i);
	  char *cptr = 0; size_t sz = 0; int alloc = 0;
	  res = SWIG_AsCharPtrAndSize(obj, &cptr, &sz, &alloc);
	  if (SWIG_IsOK(res)) {
	    if (cptr && sz) {
	      (*argv)[i] = (alloc == SWIG_NEWOBJ) ? cptr : %new_copy_array(cptr, sz, char);
	    } else {
	      (*argv)[i] = 0;
	    }
	  } else {
	    return SWIG_TypeError;
	  }
	}
	(*argv)[i] = 0;
	if (owner) *owner = 1;
      } else {
	for (; i < size; ++i) {
	  PyObject *obj = list ? PyList_GetItem(input,i) : PyTuple_GetItem(input,i);
	  res = SWIG_AsCharPtrAndSize(obj, 0, 0, 0);
	  if (!SWIG_IsOK(res)) return SWIG_TypeError;
	}
	if (owner) *owner = 0;
      }
      return SWIG_OK;
    } else {
      return SWIG_TypeError;
    }
  } else {
    /* seems dangerous, but the user asked for it... */
    size_t i = 0;
    if (argv) { while (*argv[i] != 0) ++i;}    
    if (argc) *argc = i;
    if (owner) *owner = 0;
    return SWIG_OK;
  }
}
}

/*
  This typemap works with either a char **, a python list or a python
  tuple
 */

%typemap(in,noblock=0,fragment="SWIG_AsArgcArgv") (int ARGC, char **ARGV) (int res,char **argv = 0, size_t argc = 0, int owner= 0) {
  res = SWIG_AsArgcArgv($input, $descriptor(char**), &argc, &argv, &owner);
  if (!SWIG_IsOK(res)) { 
    $1 = 0; $2 = 0;
    %argument_fail(SWIG_TypeError, "int ARGC, char **ARGV", $symname, $argnum);
  } else {  
    $1 = %static_cast(argc,$1_ltype);
    $2 = %static_cast(argv, $2_ltype);
  }
}

%typemap(typecheck, precedence=SWIG_TYPECHECK_STRING_ARRAY) (int ARGC, char **ARGV) {
  int res = SWIG_AsArgcArgv($input, $descriptor(char**), 0, 0, 0);
  $1 = SWIG_IsOK(res);
}

%typemap(freearg,noblock=1) (int ARGC, char **ARGV)  {
  if (owner$argnum) {
    size_t i = argc$argnum;
    while (i) {
      %delete_array(argv$argnum[--i]);
    }
    %delete_array(argv$argnum);
  }
}




================================================
File: swig/swigwin-3.0.8/Lib/python/attribute.i
================================================
%include <typemaps/attribute.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/boost_shared_ptr.i
================================================
%include <shared_ptr.i>

// Set SHARED_PTR_DISOWN to $disown if required, for example
// #define SHARED_PTR_DISOWN $disown
#if !defined(SHARED_PTR_DISOWN)
#define SHARED_PTR_DISOWN 0
#endif

%fragment("SWIG_null_deleter_python", "header", fragment="SWIG_null_deleter") {
%#define SWIG_NO_NULL_DELETER_SWIG_BUILTIN_INIT
}

// Language specific macro implementing all the customisations for handling the smart pointer
%define SWIG_SHARED_PTR_TYPEMAPS(CONST, TYPE...)

// %naturalvar is as documented for member variables
%naturalvar TYPE;
%naturalvar SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >;

// destructor wrapper customisation
%feature("unref") TYPE 
//"if (debug_shared) { cout << \"deleting use_count: \" << (*smartarg1).use_count() << \" [\" << (boost::get_deleter<SWIG_null_deleter>(*smartarg1) ? std::string(\"CANNOT BE DETERMINED SAFELY\") : ( (*smartarg1).get() ? (*smartarg1)->getValue() : std::string(\"NULL PTR\") )) << \"]\" << endl << flush; }\n"
                               "(void)arg1; delete smartarg1;"

// Typemap customisations...

// plain value
%typemap(in) CONST TYPE (void *argp, int res = 0) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) {
    %argument_nullref("$type", $symname, $argnum);
  } else {
    $1 = *(%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *)->get());
    if (newmem & SWIG_CAST_NEW_MEMORY) delete %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
  }
}
%typemap(out) CONST TYPE {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >(new $1_ltype(($1_ltype &)$1));
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

%typemap(varin) CONST TYPE {
  void *argp = 0;
  int newmem = 0;
  int res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  if (!argp) {
    %variable_nullref("$type", "$name");
  } else {
    $1 = *(%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *)->get());
    if (newmem & SWIG_CAST_NEW_MEMORY) delete %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
  }
}
%typemap(varout) CONST TYPE {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >(new $1_ltype(($1_ltype &)$1));
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

// plain pointer
// Note: $disown not implemented by default as it will lead to a memory leak of the shared_ptr instance
%typemap(in) CONST TYPE * (void  *argp = 0, int res = 0, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > tempshared, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartarg = 0) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SHARED_PTR_DISOWN | %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (newmem & SWIG_CAST_NEW_MEMORY) {
    tempshared = *%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    delete %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    $1 = %const_cast(tempshared.get(), $1_ltype);
  } else {
    smartarg = %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    $1 = %const_cast((smartarg ? smartarg->get() : 0), $1_ltype);
  }
}

%typemap(out, fragment="SWIG_null_deleter_python") CONST TYPE * {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = $1 ? new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >($1 SWIG_NO_NULL_DELETER_$owner) : 0;
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), $owner | SWIG_POINTER_OWN));
}

%typemap(varin) CONST TYPE * {
  void *argp = 0;
  int newmem = 0;
  int res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > tempshared;
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartarg = 0;
  if (newmem & SWIG_CAST_NEW_MEMORY) {
    tempshared = *%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    delete %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    $1 = %const_cast(tempshared.get(), $1_ltype);
  } else {
    smartarg = %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    $1 = %const_cast((smartarg ? smartarg->get() : 0), $1_ltype);
  }
}
%typemap(varout, fragment="SWIG_null_deleter_python") CONST TYPE * {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = $1 ? new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >($1 SWIG_NO_NULL_DELETER_0) : 0;
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

// plain reference
%typemap(in) CONST TYPE & (void  *argp = 0, int res = 0, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > tempshared) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) { %argument_nullref("$type", $symname, $argnum); }
  if (newmem & SWIG_CAST_NEW_MEMORY) {
    tempshared = *%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    delete %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    $1 = %const_cast(tempshared.get(), $1_ltype);
  } else {
    $1 = %const_cast(%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *)->get(), $1_ltype);
  }
}
%typemap(out, fragment="SWIG_null_deleter_python") CONST TYPE & {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >($1 SWIG_NO_NULL_DELETER_$owner);
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

%typemap(varin) CONST TYPE & {
  void *argp = 0;
  int newmem = 0;
  int res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > tempshared;
  if (!argp) {
    %variable_nullref("$type", "$name");
  }
  if (newmem & SWIG_CAST_NEW_MEMORY) {
    tempshared = *%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    delete %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    $1 = *%const_cast(tempshared.get(), $1_ltype);
  } else {
    $1 = *%const_cast(%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *)->get(), $1_ltype);
  }
}
%typemap(varout, fragment="SWIG_null_deleter_python") CONST TYPE & {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >(&$1 SWIG_NO_NULL_DELETER_0);
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

// plain pointer by reference
// Note: $disown not implemented by default as it will lead to a memory leak of the shared_ptr instance
%typemap(in) TYPE *CONST& (void  *argp = 0, int res = 0, $*1_ltype temp = 0, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > tempshared) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SHARED_PTR_DISOWN | %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (newmem & SWIG_CAST_NEW_MEMORY) {
    tempshared = *%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    delete %reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *);
    temp = %const_cast(tempshared.get(), $*1_ltype);
  } else {
    temp = %const_cast(%reinterpret_cast(argp, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *)->get(), $*1_ltype);
  }
  $1 = &temp;
}
%typemap(out, fragment="SWIG_null_deleter_python") TYPE *CONST& {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >(*$1 SWIG_NO_NULL_DELETER_$owner);
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

%typemap(varin) TYPE *CONST& %{
#error "varin typemap not implemented"
%}
%typemap(varout) TYPE *CONST& %{
#error "varout typemap not implemented"
%}

// shared_ptr by value
%typemap(in) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > (void *argp, int res = 0) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (argp) $1 = *(%reinterpret_cast(argp, $&ltype));
  if (newmem & SWIG_CAST_NEW_MEMORY) delete %reinterpret_cast(argp, $&ltype);
}
%typemap(out) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = $1 ? new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >($1) : 0;
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

%typemap(varin) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > {
  int newmem = 0;
  void *argp = 0;
  int res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  $1 = argp ? *(%reinterpret_cast(argp, $&ltype)) : SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE >();
  if (newmem & SWIG_CAST_NEW_MEMORY) delete %reinterpret_cast(argp, $&ltype);
}
%typemap(varout) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = $1 ? new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >($1) : 0;
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

// shared_ptr by reference
%typemap(in) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > & (void *argp, int res = 0, $*1_ltype tempshared) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (newmem & SWIG_CAST_NEW_MEMORY) {
    if (argp) tempshared = *%reinterpret_cast(argp, $ltype);
    delete %reinterpret_cast(argp, $ltype);
    $1 = &tempshared;
  } else {
    $1 = (argp) ? %reinterpret_cast(argp, $ltype) : &tempshared;
  }
}
%typemap(out) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > & {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = *$1 ? new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >(*$1) : 0;
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

%typemap(varin) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > & %{
#error "varin typemap not implemented"
%}
%typemap(varout) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > & %{
#error "varout typemap not implemented"
%}

// shared_ptr by pointer
%typemap(in) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > * (void *argp, int res = 0, $*1_ltype tempshared) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (newmem & SWIG_CAST_NEW_MEMORY) {
    if (argp) tempshared = *%reinterpret_cast(argp, $ltype);
    delete %reinterpret_cast(argp, $ltype);
    $1 = &tempshared;
  } else {
    $1 = (argp) ? %reinterpret_cast(argp, $ltype) : &tempshared;
  }
}
%typemap(out) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > * {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = $1 && *$1 ? new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >(*$1) : 0;
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
  if ($owner) delete $1;
}

%typemap(varin) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > * %{
#error "varin typemap not implemented"
%}
%typemap(varout) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > * %{
#error "varout typemap not implemented"
%}

// shared_ptr by pointer reference
%typemap(in) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *& (void *argp, int res = 0, SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > tempshared, $*1_ltype temp = 0) {
  int newmem = 0;
  res = SWIG_ConvertPtrAndOwn($input, &argp, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), %convertptr_flags, &newmem);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (argp) tempshared = *%reinterpret_cast(argp, $*ltype);
  if (newmem & SWIG_CAST_NEW_MEMORY) delete %reinterpret_cast(argp, $*ltype);
  temp = &tempshared;
  $1 = &temp;
}
%typemap(out) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *& {
  SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *smartresult = *$1 && **$1 ? new SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >(**$1) : 0;
  %set_output(SWIG_NewPointerObj(%as_voidptr(smartresult), $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), SWIG_POINTER_OWN));
}

%typemap(varin) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *& %{
#error "varin typemap not implemented"
%}
%typemap(varout) SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *& %{
#error "varout typemap not implemented"
%}

// Typecheck typemaps
// Note: SWIG_ConvertPtr with void ** parameter set to 0 instead of using SWIG_ConvertPtrAndOwn, so that the casting 
// function is not called thereby avoiding a possible smart pointer copy constructor call when casting up the inheritance chain.
%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) 
                      TYPE CONST,
                      TYPE CONST &,
                      TYPE CONST *,
                      TYPE *CONST&,
                      SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >,
                      SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > &,
                      SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *,
                      SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE > *& {
  int res = SWIG_ConvertPtr($input, 0, $descriptor(SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< TYPE > *), 0);
  $1 = SWIG_CheckState(res);
}


// various missing typemaps - If ever used (unlikely) ensure compilation error rather than runtime bug
%typemap(in) CONST TYPE[], CONST TYPE[ANY], CONST TYPE (CLASS::*) %{
#error "typemaps for $1_type not available"
%}
%typemap(out) CONST TYPE[], CONST TYPE[ANY], CONST TYPE (CLASS::*) %{
#error "typemaps for $1_type not available"
%}


%template() SWIG_SHARED_PTR_QNAMESPACE::shared_ptr< CONST TYPE >;


%enddef




================================================
File: swig/swigwin-3.0.8/Lib/python/builtin.swg
================================================
#define SWIGPY_UNARYFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a) {		\
  return wrapper(a, NULL);			\
}

#define SWIGPY_DESTRUCTOR_CLOSURE(wrapper)	\
SWIGINTERN void					\
wrapper##_closure(PyObject *a) {		\
    SwigPyObject *sobj;				\
    sobj = (SwigPyObject *)a;			\
    Py_XDECREF(sobj->dict);			\
    if (sobj->own) {				\
	PyObject *o;				\
	PyObject *val = 0, *type = 0, *tb = 0;	\
	PyErr_Fetch(&val, &type, &tb);		\
	o = wrapper(a, NULL);			\
	if (!o) {				\
	    PyObject *deallocname = PyString_FromString(#wrapper); \
	    PyErr_WriteUnraisable(deallocname);	\
	    Py_DECREF(deallocname);		\
	}					\
	PyErr_Restore(val, type, tb);		\
	Py_XDECREF(o);				\
    }						\
    if (PyType_IS_GC(a->ob_type)) {		\
	PyObject_GC_Del(a);			\
    } else {					\
	PyObject_Del(a);			\
    }						\
}

#define SWIGPY_INQUIRY_CLOSURE(wrapper)				\
SWIGINTERN int							\
wrapper##_closure(PyObject *a) {				\
    PyObject *pyresult;						\
    int result;							\
    pyresult = wrapper(a, NULL);				\
    result = pyresult && PyObject_IsTrue(pyresult) ? 1 : 0;	\
    Py_XDECREF(pyresult);					\
    return result;						\
}

#define SWIGPY_BINARYFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a, PyObject *b) {	\
    PyObject *tuple, *result;			\
    tuple = PyTuple_New(1);			\
    assert(tuple);				\
    PyTuple_SET_ITEM(tuple, 0, b);		\
    Py_XINCREF(b);				\
    result = wrapper(a, tuple);			\
    Py_DECREF(tuple);				\
    return result;				\
}

typedef ternaryfunc ternarycallfunc;

#define SWIGPY_TERNARYFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *						\
wrapper##_closure(PyObject *a, PyObject *b, PyObject *c) {	\
    PyObject *tuple, *result;					\
    tuple = PyTuple_New(2);					\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, b);				\
    PyTuple_SET_ITEM(tuple, 1, c);				\
    Py_XINCREF(b);						\
    Py_XINCREF(c);						\
    result = wrapper(a, tuple);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_TERNARYCALLFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *						\
wrapper##_closure(PyObject *callable_object, PyObject *args, PyObject *) { \
    return wrapper(callable_object, args);			\
}

#define SWIGPY_LENFUNC_CLOSURE(wrapper)			\
SWIGINTERN Py_ssize_t					\
wrapper##_closure(PyObject *a) {			\
    PyObject *resultobj;				\
    Py_ssize_t result;					\
    resultobj = wrapper(a, NULL);			\
    result = PyNumber_AsSsize_t(resultobj, NULL);	\
    Py_DECREF(resultobj);				\
    return result;					\
}

#define SWIGPY_SSIZESSIZEARGFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *						\
wrapper##_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c) {	\
    PyObject *tuple, *result;					\
    tuple = PyTuple_New(2);					\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));		\
    PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));		\
    result = wrapper(a, tuple);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_SSIZESSIZEOBJARGPROC_CLOSURE(wrapper)			\
SWIGINTERN int								\
wrapper##_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c, PyObject *d) { \
    PyObject *tuple, *resultobj;					\
    int result;								\
    tuple = PyTuple_New(d ? 3 : 2);					\
    assert(tuple);							\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));			\
    PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));			\
    if (d) {								\
        PyTuple_SET_ITEM(tuple, 2, d);					\
        Py_INCREF(d);							\
    }									\
    resultobj = wrapper(a, tuple);					\
    result = resultobj ? 0 : -1;					\
    Py_DECREF(tuple);							\
    Py_XDECREF(resultobj);						\
    return result;							\
}

#define SWIGPY_SSIZEARGFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_closure(PyObject *a, Py_ssize_t b) {		\
    PyObject *tuple, *result;				\
    tuple = PyTuple_New(1);				\
    assert(tuple);					\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));	\
    result = wrapper(a, tuple);				\
    Py_DECREF(tuple);					\
    return result;					\
}

#define SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *					\
wrapper##_closure(PyObject *a, Py_ssize_t b) {		\
    PyObject *arg, *result;				\
    arg = _PyLong_FromSsize_t(b);			\
    result = wrapper(a, arg);				\
    Py_DECREF(arg);					\
    return result;					\
}

#define SWIGPY_SSIZEOBJARGPROC_CLOSURE(wrapper)			\
SWIGINTERN int							\
wrapper##_closure(PyObject *a, Py_ssize_t b, PyObject *c) {	\
    PyObject *tuple, *resultobj;				\
    int result;							\
    tuple = PyTuple_New(2);					\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));		\
    PyTuple_SET_ITEM(tuple, 1, c);				\
    Py_XINCREF(c);						\
    resultobj = wrapper(a, tuple);				\
    result = resultobj ? 0 : -1;				\
    Py_XDECREF(resultobj);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_OBJOBJARGPROC_CLOSURE(wrapper)			\
SWIGINTERN int							\
wrapper##_closure(PyObject *a, PyObject *b, PyObject *c) {	\
    PyObject *tuple, *resultobj;				\
    int result;							\
    tuple = PyTuple_New(c ? 2 : 1);				\
    assert(tuple);						\
    PyTuple_SET_ITEM(tuple, 0, b);				\
    Py_XINCREF(b);						\
    if (c) {							\
        PyTuple_SET_ITEM(tuple, 1, c);				\
        Py_XINCREF(c);						\
    }								\
    resultobj = wrapper(a, tuple);				\
    result = resultobj ? 0 : -1;				\
    Py_XDECREF(resultobj);					\
    Py_DECREF(tuple);						\
    return result;						\
}

#define SWIGPY_REPRFUNC_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a) {		\
    return wrapper(a, NULL);			\
}

#define SWIGPY_HASHFUNC_CLOSURE(wrapper)	\
SWIGINTERN long					\
wrapper##_closure(PyObject *a) {		\
    PyObject *pyresult;				\
    long result;				\
    pyresult = wrapper(a, NULL);		\
    if (!pyresult || !PyLong_Check(pyresult))	\
	return -1;				\
    result = PyLong_AsLong(pyresult);		\
    Py_DECREF(pyresult);			\
    return result;				\
}

#define SWIGPY_ITERNEXT_CLOSURE(wrapper)	\
SWIGINTERN PyObject *				\
wrapper##_closure(PyObject *a) {		\
    PyObject *result;				\
    result = wrapper(a, NULL);			\
    if (result && result == Py_None) {		\
	Py_DECREF(result);			\
	result = NULL;				\
    }						\
    return result;				\
}

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN int
SwigPyBuiltin_BadInit(PyObject *self, PyObject *SWIGUNUSEDPARM(args), PyObject *SWIGUNUSEDPARM(kwds)) {
  PyErr_Format(PyExc_TypeError, "Cannot create new instances of type '%.300s'", self->ob_type->tp_name);
  return -1;
}

SWIGINTERN void
SwigPyBuiltin_BadDealloc(PyObject *pyobj) {
  SwigPyObject *sobj;
  sobj = (SwigPyObject *)pyobj;
  if (sobj->own) {
    PyErr_Format(PyExc_TypeError, "Swig detected a memory leak in type '%.300s': no callable destructor found.", pyobj->ob_type->tp_name);
  }
}

typedef struct {
  PyCFunction get;
  PyCFunction set;
} SwigPyGetSet;

SWIGINTERN PyObject *
SwigPyBuiltin_GetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  tuple = PyTuple_New(0);
  assert(tuple);
  result = (*getset->get)(obj, tuple);
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyObject *
SwigPyBuiltin_FunpackGetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  result = (*getset->get)(obj, NULL);
  return result;
}

SWIGINTERN int
SwigPyBuiltin_SetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, val);
  Py_XINCREF(val);
  result = (*getset->set)(obj, tuple);
  Py_DECREF(tuple);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN int
SwigPyBuiltin_FunpackSetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  result = (*getset->set)(obj, val);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN void
SwigPyStaticVar_dealloc(PyDescrObject *descr) {
  _PyObject_GC_UNTRACK(descr);
  Py_XDECREF(PyDescr_TYPE(descr));
  Py_XDECREF(PyDescr_NAME(descr));
  PyObject_GC_Del(descr);
}

SWIGINTERN PyObject *
SwigPyStaticVar_repr(PyGetSetDescrObject *descr) {
#if PY_VERSION_HEX >= 0x03000000

  return PyUnicode_FromFormat("<class attribute '%S' of type '%s'>", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  return PyString_FromFormat("<class attribute '%s' of type '%s'>", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
}

SWIGINTERN int
SwigPyStaticVar_traverse(PyObject *self, visitproc visit, void *arg) {
  PyDescrObject *descr;
  descr = (PyDescrObject *)self;
  Py_VISIT((PyObject*) PyDescr_TYPE(descr));
  return 0;
}

SWIGINTERN PyObject *
SwigPyStaticVar_get(PyGetSetDescrObject *descr, PyObject *obj, PyObject *SWIGUNUSEDPARM(type)) {
  if (descr->d_getset->get != NULL)
    return descr->d_getset->get(obj, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not readable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not readable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return NULL;
}

SWIGINTERN int
SwigPyStaticVar_set(PyGetSetDescrObject *descr, PyObject *obj, PyObject *value) {
  if (descr->d_getset->set != NULL)
    return descr->d_getset->set(obj, value, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not writable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not writable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return -1;
}

SWIGINTERN int
SwigPyObjectType_setattro(PyTypeObject *type, PyObject *name, PyObject *value) {
  PyObject *attribute;
  descrsetfunc local_set;
  attribute = _PyType_Lookup(type, name);
  if (attribute != NULL) {
    /* Implement descriptor functionality, if any */
    local_set = attribute->ob_type->tp_descr_set;
    if (local_set != NULL)
      return local_set(attribute, (PyObject *)type, value);
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400S'", type->tp_name, name);
#else 
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400S'", type->tp_name, name);
#else
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  }

  return -1;
}

SWIGINTERN PyTypeObject*
SwigPyStaticVar_Type(void) {
  static PyTypeObject staticvar_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
      PyObject_HEAD_INIT(&PyType_Type)
      0,
#endif
      "swig_static_var_getset_descriptor",
      sizeof(PyGetSetDescrObject),
      0,
      (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
      0,                                        /* tp_print */
      0,                                        /* tp_getattr */
      0,                                        /* tp_setattr */
      0,                                        /* tp_compare */
      (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
      0,                                        /* tp_as_number */
      0,                                        /* tp_as_sequence */
      0,                                        /* tp_as_mapping */
      0,                                        /* tp_hash */
      0,                                        /* tp_call */
      0,                                        /* tp_str */
      PyObject_GenericGetAttr,                  /* tp_getattro */
      0,                                        /* tp_setattro */
      0,                                        /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_HAVE_CLASS, /* tp_flags */
      0,                                        /* tp_doc */
      SwigPyStaticVar_traverse,                 /* tp_traverse */
      0,                                        /* tp_clear */
      0,                                        /* tp_richcompare */
      0,                                        /* tp_weaklistoffset */
      0,                                        /* tp_iter */
      0,                                        /* tp_iternext */
      0,                                        /* tp_methods */
      0,                                        /* tp_members */
      0,                                        /* tp_getset */
      0,                                        /* tp_base */
      0,                                        /* tp_dict */
      (descrgetfunc)SwigPyStaticVar_get,        /* tp_descr_get */
      (descrsetfunc)SwigPyStaticVar_set,        /* tp_descr_set */
      0,                                        /* tp_dictoffset */
      0,                                        /* tp_init */
      0,                                        /* tp_alloc */
      0,                                        /* tp_new */
      0,                                        /* tp_free */
      0,                                        /* tp_is_gc */
      0,                                        /* tp_bases */
      0,                                        /* tp_mro */
      0,                                        /* tp_cache */
      0,                                        /* tp_subclasses */
      0,                                        /* tp_weaklist */
#if PY_VERSION_HEX >= 0x02030000
      0,                                        /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                        /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                        /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                        /* tp_allocs */
      0,                                        /* tp_frees */
      0,                                        /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                        /* tp_prev */
#endif
      0                                         /* tp_next */
#endif
    };
    staticvar_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    staticvar_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&staticvar_type) < 0)
      return NULL;
#endif
  }
  return &staticvar_type;
}

SWIGINTERN PyGetSetDescrObject *
SwigPyStaticVar_new_getset(PyTypeObject *type, PyGetSetDef *getset) {

  PyGetSetDescrObject *descr;
  descr = (PyGetSetDescrObject *)PyType_GenericAlloc(SwigPyStaticVar_Type(), 0);
  assert(descr);
  Py_XINCREF(type);
  PyDescr_TYPE(descr) = type;
  PyDescr_NAME(descr) = PyString_InternFromString(getset->name);
  descr->d_getset = getset;
  if (PyDescr_NAME(descr) == NULL) {
    Py_DECREF(descr);
    descr = NULL;
  }
  return descr;
}

SWIGINTERN void
SwigPyBuiltin_InitBases (PyTypeObject *type, PyTypeObject **bases) {
  int base_count = 0;
  PyTypeObject **b;
  PyObject *tuple;
  int i;

  if (!bases[0]) {
    bases[0] = SwigPyObject_type();
    bases[1] = NULL;
  }
  type->tp_base = bases[0];
  Py_INCREF((PyObject *)bases[0]);
  for (b = bases; *b != NULL; ++b)
    ++base_count;
  tuple = PyTuple_New(base_count);
  for (i = 0; i < base_count; ++i) {
    PyTuple_SET_ITEM(tuple, i, (PyObject *)bases[i]);
    Py_INCREF((PyObject *)bases[i]);
  }
  type->tp_bases = tuple;
}

SWIGINTERN PyObject *
SwigPyBuiltin_ThisClosure (PyObject *self, void *SWIGUNUSEDPARM(closure)) {
  PyObject *result;
  result = (PyObject *)SWIG_Python_GetSwigThis(self);
  Py_XINCREF(result);
  return result;
}

SWIGINTERN void
SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
{
#if PY_VERSION_HEX >= 0x03000000
    type->ob_base.ob_base.ob_type = metatype;
#else
    type->ob_type = metatype;
#endif
}

#ifdef __cplusplus
}
#endif




================================================
File: swig/swigwin-3.0.8/Lib/python/carrays.i
================================================
%define %array_class(TYPE,NAME)
#if defined(SWIGPYTHON_BUILTIN)
  %feature("python:slot", "sq_item", functype="ssizeargfunc") NAME::__getitem__;
  %feature("python:slot", "sq_ass_item", functype="ssizeobjargproc") NAME::__setitem__;

%inline %{
typedef struct {
    TYPE *el;
} NAME;
%}

%extend NAME {

  NAME(size_t nelements) {
      NAME *arr = %new_instance(NAME);
      arr->el = %new_array(nelements, TYPE);
      return arr;
  }

  ~NAME() {
      %delete_array(self->el);
      %delete(self);
  }
  
  TYPE __getitem__(size_t index) {
      return self->el[index];
  }

  void __setitem__(size_t index, TYPE value) {
      self->el[index] = value;
  }

  TYPE * cast() {
      return self->el;
  }

  static NAME *frompointer(TYPE *t) {
      return %reinterpret_cast(t, NAME *);
  }
};

%types(NAME = TYPE);

#else
  %array_class_wrap(TYPE,NAME,__getitem__,__setitem__)
#endif
%enddef

%include <typemaps/carrays.swg>







================================================
File: swig/swigwin-3.0.8/Lib/python/ccomplex.i
================================================
/* -----------------------------------------------------------------------------
 * ccomplex.i
 *
 * C complex typemaps
 * ISO C99:  7.3 Complex arithmetic <complex.h>
 * ----------------------------------------------------------------------------- */


%include <pycomplex.swg>

%{
#include <complex.h>
%}


/* C complex constructor */
#define CCplxConst(r, i) ((r) + I*(i))

%swig_cplxflt_convn(float complex, CCplxConst, creal, cimag);
%swig_cplxdbl_convn(double complex, CCplxConst, creal, cimag);
%swig_cplxdbl_convn(complex, CCplxConst, creal, cimag);

/* declaring the typemaps */
%typemaps_primitive(SWIG_TYPECHECK_CPLXFLT, float complex);
%typemaps_primitive(SWIG_TYPECHECK_CPLXDBL, double complex);
%typemaps_primitive(SWIG_TYPECHECK_CPLXDBL, complex);



================================================
File: swig/swigwin-3.0.8/Lib/python/cdata.i
================================================
%include <typemaps/cdata.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/cmalloc.i
================================================
%include <typemaps/cmalloc.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/cni.i
================================================
%include <gcj/cni.i>
%include <jstring.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/complex.i
================================================
#ifdef __cplusplus
%include <std_complex.i>
#else
%include <ccomplex.i>
#endif




================================================
File: swig/swigwin-3.0.8/Lib/python/cpointer.i
================================================
%include <typemaps/cpointer.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/cstring.i
================================================
%include <typemaps/cstring.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/cwstring.i
================================================
%include <pywstrings.swg>
%include <typemaps/cwstring.swg>




================================================
File: swig/swigwin-3.0.8/Lib/python/defarg.swg
================================================
/* This file defines an internal function for processing default arguments
   with proxy classes.

   There seems to be no straightforward way to write proxy functions
   involving default arguments. For example :

             def foo(arg1,arg2,*args):
                     proxyc.foo(arg1,arg2,args)

   This fails because args is now a tuple and SWIG doesn't know what to
   do with it.

   This file allows a different approach :

            def foo(arg1,arg2,*args):
                    proxyc.__call_defarg(proxyc.foo,(arg1,arg2,)+args)

   Basically, we form a new tuple from the object, call this special
   __call_defarg method and it passes control to the real wrapper function.
   An ugly hack, but it works.
*/

SWIGINTERN PyObject *swig_call_defargs(PyObject *self, PyObject *args) {
  PyObject *func;
  PyObject *parms;
  
  if (!PyArg_ParseTuple(args,"OO",&func,&parms))
    return NULL;
  
  if (!PyCallable_Check(func)) {
    SWIG_PYTHON_THREAD_BEGIN_BLOCK;
    PyErr_SetString(PyExc_TypeError, "__call_defarg : Need a callable object!");
    SWIG_PYTHON_THREAD_END_BLOCK;
    return NULL;
  }
  return PyEval_CallObject(func,parms);
}



================================================
File: swig/swigwin-3.0.8/Lib/python/director.swg
================================================
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Python proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DIRECTOR_PYTHON_HEADER_
#define SWIG_DIRECTOR_PYTHON_HEADER_

#include <string>
#include <iostream>
#include <exception>
#include <vector>
#include <map>


/*
  Use -DSWIG_PYTHON_DIRECTOR_NO_VTABLE if you don't want to generate a 'virtual
  table', and avoid multiple GetAttr calls to retrieve the python
  methods.
*/

#ifndef SWIG_PYTHON_DIRECTOR_NO_VTABLE
#ifndef SWIG_PYTHON_DIRECTOR_VTABLE
#define SWIG_PYTHON_DIRECTOR_VTABLE
#endif
#endif



/*
  Use -DSWIG_DIRECTOR_NO_UEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swig.
*/
#ifndef SWIG_DIRECTOR_NO_UEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif


/*
  Use -DSWIG_DIRECTOR_NORTTI if you prefer to avoid the use of the
  native C++ RTTI and dynamic_cast<>. But be aware that directors
  could stop working when using this option.
*/
#ifdef SWIG_DIRECTOR_NORTTI
/*
   When we don't use the native C++ RTTI, we implement a minimal one
   only for Directors.
*/
# ifndef SWIG_DIRECTOR_RTDIR
# define SWIG_DIRECTOR_RTDIR

namespace Swig {
  class Director;
  SWIGINTERN std::map<void *, Director *>& get_rtdir_map() {
    static std::map<void *, Director *> rtdir_map;
    return rtdir_map;
  }

  SWIGINTERNINLINE void set_rtdir(void *vptr, Director *rtdir) {
    get_rtdir_map()[vptr] = rtdir;
  }

  SWIGINTERNINLINE Director *get_rtdir(void *vptr) {
    std::map<void *, Director *>::const_iterator pos = get_rtdir_map().find(vptr);
    Director *rtdir = (pos != get_rtdir_map().end()) ? pos->second : 0;
    return rtdir;
  }
}
# endif /* SWIG_DIRECTOR_RTDIR */

# define SWIG_DIRECTOR_CAST(ARG) Swig::get_rtdir(static_cast<void *>(ARG))
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2) Swig::set_rtdir(static_cast<void *>(ARG1), ARG2)

#else

# define SWIG_DIRECTOR_CAST(ARG) dynamic_cast<Swig::Director *>(ARG)
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2)

#endif /* SWIG_DIRECTOR_NORTTI */

extern "C" {
  struct swig_type_info;
}

namespace Swig {

  /* memory handler */
  struct GCItem {
    virtual ~GCItem() {}

    virtual int get_own() const {
      return 0;
    }
  };

  struct GCItem_var {
    GCItem_var(GCItem *item = 0) : _item(item) {
    }

    GCItem_var& operator=(GCItem *item) {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }

    ~GCItem_var() {
      delete _item;
    }

    GCItem * operator->() const {
      return _item;
    }

  private:
    GCItem *_item;
  };

  struct GCItem_Object : GCItem {
    GCItem_Object(int own) : _own(own) {
    }

    virtual ~GCItem_Object() {
    }

    int get_own() const {
      return _own;
    }

  private:
    int _own;
  };

  template <typename Type>
  struct GCItem_T : GCItem {
    GCItem_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCItem_T() {
      delete _ptr;
    }

  private:
    Type *_ptr;
  };

  template <typename Type>
  struct GCArray_T : GCItem {
    GCArray_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCArray_T() {
      delete[] _ptr;
    }

  private:
    Type *_ptr;
  };

  /* base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;
  public:
    DirectorException(PyObject *error, const char *hdr ="", const char *msg ="") : swig_msg(hdr) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (msg[0]) {
        swig_msg += " ";
        swig_msg += msg;
      }
      if (!PyErr_Occurred()) {
        PyErr_SetString(error, what());
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
    }

    virtual ~DirectorException() throw() {
    }

    /* Deprecated, use what() instead */
    const char *getMessage() const {
      return what();
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorException(error, msg);
    }

    static void raise(const char *msg) {
      raise(PyExc_RuntimeError, msg);
    }
  };

  /* unknown exception handler  */
  class UnknownExceptionHandler {
#ifdef SWIG_DIRECTOR_UEH
    static void handler() {
      try {
        throw;
      } catch (DirectorException& e) {
        std::cerr << "SWIG Director exception caught:" << std::endl
                  << e.what() << std::endl;
      } catch (std::exception& e) {
        std::cerr << "std::exception caught: "<< e.what() << std::endl;
      } catch (...) {
        std::cerr << "Unknown exception caught." << std::endl;
      }

      std::cerr << std::endl
                << "Python interpreter traceback:" << std::endl;
      PyErr_Print();
      std::cerr << std::endl;

      std::cerr << "This exception was caught by the SWIG unexpected exception handler." << std::endl
                << "Try using %feature(\"director:except\") to avoid reaching this point." << std::endl
                << std::endl
                << "Exception is being re-thrown, program will likely abort/terminate." << std::endl;
      throw;
    }

  public:

    std::unexpected_handler old;
    UnknownExceptionHandler(std::unexpected_handler nh = handler) {
      old = std::set_unexpected(nh);
    }

    ~UnknownExceptionHandler() {
      std::set_unexpected(old);
    }
#endif
  };

  /* type mismatch in the return value from a python method call */
  class DirectorTypeMismatchException : public DirectorException {
  public:
    DirectorTypeMismatchException(PyObject *error, const char *msg="")
      : DirectorException(error, "SWIG director type mismatch", msg) {
    }

    DirectorTypeMismatchException(const char *msg="")
      : DirectorException(PyExc_TypeError, "SWIG director type mismatch", msg) {
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* any python exception that occurs during a director method call */
  class DirectorMethodException : public DirectorException {
  public:
    DirectorMethodException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director method error.", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorMethodException(msg);
    }
  };

  /* attempt to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director pure virtual method called", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };


#if defined(SWIG_PYTHON_THREADS)
/*  __THREAD__ is the old macro to activate some thread support */
# if !defined(__THREAD__)
#   define __THREAD__ 1
# endif
#endif

#ifdef __THREAD__
# include "pythread.h"
  class Guard {
    PyThread_type_lock &mutex_;

  public:
    Guard(PyThread_type_lock & mutex) : mutex_(mutex) {
      PyThread_acquire_lock(mutex_, WAIT_LOCK);
    }

    ~Guard() {
      PyThread_release_lock(mutex_);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex)
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped python object */
    PyObject *swig_self;
    /* flag indicating whether the object is owned by python or c++ */
    mutable bool swig_disown_flag;

    /* decrement the reference count of the wrapped python object */
    void swig_decref() const {
      if (swig_disown_flag) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_DECREF(swig_self);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }

  public:
    /* wrap a python object. */
    Director(PyObject *self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
      swig_decref();
    }

    /* return a pointer to the wrapped python object */
    PyObject *swig_get_self() const {
      return swig_self;
    }

    /* acquire ownership of the wrapped python object (the sense of "disown" is from python) */
    void swig_disown() const {
      if (!swig_disown_flag) {
        swig_disown_flag=true;
        swig_incref();
      }
    }

    /* increase the reference count of the wrapped python object */
    void swig_incref() const {
      if (swig_disown_flag) {
        Py_INCREF(swig_self);
      }
    }

    /* methods to implement pseudo protected director members */
    virtual bool swig_get_inner(const char * /* swig_protected_method_name */) const {
      return true;
    }

    virtual void swig_set_inner(const char * /* swig_protected_method_name */, bool /* swig_val */) const {
    }

  /* ownership management */
  private:
    typedef std::map<void *, GCItem_var> swig_ownership_map;
    mutable swig_ownership_map swig_owner;
#ifdef __THREAD__
    static PyThread_type_lock swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }

    template <typename Type>
    void swig_acquire_ownership(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, int own) const {
      if (vptr && own) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_Object(own);
      }
    }

    int swig_release_ownership(void *vptr) const {
      int own = 0;
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_ownership_map::iterator iter = swig_owner.find(vptr);
        if (iter != swig_owner.end()) {
          own = iter->second->get_own();
          swig_owner.erase(iter);
        }
      }
      return own;
    }

    template <typename Type>
    static PyObject *swig_pyobj_disown(PyObject *pyobj, PyObject *SWIGUNUSEDPARM(args)) {
      SwigPyObject *sobj = (SwigPyObject *)pyobj;
      sobj->own = 0;
      Director *d = SWIG_DIRECTOR_CAST(reinterpret_cast<Type *>(sobj->ptr));
      if (d)
        d->swig_disown();
      return PyWeakref_NewProxy(pyobj, NULL);
    }
  };

#ifdef __THREAD__
  PyThread_type_lock Director::swig_mutex_own = PyThread_allocate_lock();
#endif
}

#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/embed.i
================================================
//
// embed.i
// SWIG file embedding the Python interpreter in something else.
// This file is based on Python-1.5.  It will not work with
// earlier versions.
//
// This file makes it possible to extend Python and all of its
// built-in functions without having to hack its setup script.
//


#ifdef AUTODOC
%subsection "embed.i"
%text %{
This module provides support for building a new version of the
Python executable.  This will be necessary on systems that do
not support shared libraries and may be necessary with C++
extensions.  This file contains everything you need to build
a new version of Python from include files and libraries normally
installed with the Python language.

This module will automatically grab all of the Python modules
present in your current Python executable (including any special
purpose modules you have enabled such as Tkinter).   Thus, you
may need to provide additional link libraries when compiling.

This library file only works with Python 1.5.  A version 
compatible with Python 1.4 is available as embed14.i and
a Python1.3 version is available as embed13.i.    As far as
I know, this module is C++ safe.
%}
#else
%echo "embed.i : Using Python 1.5"
#endif

%wrapper %{

#include <Python.h>

#ifdef __cplusplus
extern "C"
#endif
void SWIG_init();  /* Forward reference */

#define _PyImport_Inittab swig_inittab

/* Grab Python's inittab[] structure */

#ifdef __cplusplus
extern "C" {
#endif
#include <config.c>

#undef _PyImport_Inittab 

/* Now define our own version of it.
   Hopefully someone does not have more than 1000 built-in modules */

struct _inittab SWIG_Import_Inittab[1000];       

static int  swig_num_modules = 0;

/* Function for adding modules to Python */

static void swig_add_module(char *name, void (*initfunc)()) {
	SWIG_Import_Inittab[swig_num_modules].name = name;
	SWIG_Import_Inittab[swig_num_modules].initfunc = initfunc;
	swig_num_modules++;
	SWIG_Import_Inittab[swig_num_modules].name = (char *) 0;
	SWIG_Import_Inittab[swig_num_modules].initfunc = 0;
}				

/* Function to add all of Python's build in modules to our interpreter */

static void swig_add_builtin() {
	int i = 0;
	while (swig_inittab[i].name) {
		swig_add_module(swig_inittab[i].name, swig_inittab[i].initfunc);
  	        i++;
 	}
#ifdef SWIGMODINIT
	SWIGMODINIT	
#endif
	/* Add SWIG builtin function */
	swig_add_module(SWIG_name, SWIG_init);
}

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern int Py_Main(int, char **);

#ifdef __cplusplus
}
#endif

extern struct _inittab *PyImport_Inittab;

int
main(int argc, char **argv) {
	swig_add_builtin();
	PyImport_Inittab = SWIG_Import_Inittab;
	return Py_Main(argc,argv);
}

%}


  




================================================
File: swig/swigwin-3.0.8/Lib/python/embed15.i
================================================
/* -----------------------------------------------------------------------------
 * embed15.i
 *
 * SWIG file embedding the Python interpreter in something else.
 * This file is based on Python-1.5.  It will not work with
 * earlier versions.
 *
 * This file makes it possible to extend Python and all of its
 * built-in functions without having to hack its setup script.
 * ----------------------------------------------------------------------------- */

#ifdef AUTODOC
%subsection "embed.i"
%text %{
This module provides support for building a new version of the
Python executable.  This will be necessary on systems that do
not support shared libraries and may be necessary with C++
extensions.  This file contains everything you need to build
a new version of Python from include files and libraries normally
installed with the Python language.

This module will automatically grab all of the Python modules
present in your current Python executable (including any special
purpose modules you have enabled such as Tkinter).   Thus, you
may need to provide additional link libraries when compiling.

This library file only works with Python 1.5.  A version 
compatible with Python 1.4 is available as embed14.i and
a Python1.3 version is available as embed13.i.    As far as
I know, this module is C++ safe.
%}
#else
%echo "embed.i : Using Python 1.5"
#endif

%wrapper %{

#include <Python.h>

#ifdef __cplusplus
extern "C"
#endif
void SWIG_init();  /* Forward reference */

#define _PyImport_Inittab swig_inittab

/* Grab Python's inittab[] structure */

#ifdef __cplusplus
extern "C" {
#endif
#include <config.c>

#undef _PyImport_Inittab 

/* Now define our own version of it.
   Hopefully someone does not have more than 1000 built-in modules */

struct _inittab SWIG_Import_Inittab[1000];       

static int  swig_num_modules = 0;

/* Function for adding modules to Python */

static void swig_add_module(char *name, void (*initfunc)()) {
	SWIG_Import_Inittab[swig_num_modules].name = name;
	SWIG_Import_Inittab[swig_num_modules].initfunc = initfunc;
	swig_num_modules++;
	SWIG_Import_Inittab[swig_num_modules].name = (char *) 0;
	SWIG_Import_Inittab[swig_num_modules].initfunc = 0;
}				

/* Function to add all of Python's build in modules to our interpreter */

static void swig_add_builtin() {
	int i = 0;
	while (swig_inittab[i].name) {
		swig_add_module(swig_inittab[i].name, swig_inittab[i].initfunc);
  	        i++;
 	}
#ifdef SWIGMODINIT
	SWIGMODINIT	
#endif
	/* Add SWIG builtin function */
	swig_add_module(SWIG_name, SWIG_init);
}

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern int Py_Main(int, char **);

#ifdef __cplusplus
}
#endif

extern struct _inittab *PyImport_Inittab;

int
main(int argc, char **argv) {
	swig_add_builtin();
	PyImport_Inittab = SWIG_Import_Inittab;
	return Py_Main(argc,argv);
}

%}


  




================================================
File: swig/swigwin-3.0.8/Lib/python/exception.i
================================================
%include <typemaps/exception.swg>


%insert("runtime") {
  %define_as(SWIG_exception(code, msg), %block(%error(code, msg); SWIG_fail; ))
}



================================================
File: swig/swigwin-3.0.8/Lib/python/factory.i
================================================
%include <typemaps/factory.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/file.i
================================================
/* -----------------------------------------------------------------------------
 * file.i
 *
 * Typemaps for FILE*
 * ----------------------------------------------------------------------------- */

%types(FILE *);

/* defining basic methods */
%fragment("SWIG_AsValFilePtr","header") {
SWIGINTERN int
SWIG_AsValFilePtr(PyObject *obj, FILE **val) {
  static swig_type_info* desc = 0;
  void *vptr = 0;
  if (!desc) desc = SWIG_TypeQuery("FILE *");
  if ((SWIG_ConvertPtr(obj, &vptr, desc, 0)) == SWIG_OK) {
    if (val) *val = (FILE *)vptr;
    return SWIG_OK;
  }
%#if PY_VERSION_HEX < 0x03000000
  if (PyFile_Check(obj)) {
    if (val) *val =  PyFile_AsFile(obj);
    return SWIG_OK;
  }
%#endif
  return SWIG_TypeError;
}
}


%fragment("SWIG_AsFilePtr","header",fragment="SWIG_AsValFilePtr") {
SWIGINTERNINLINE FILE*
SWIG_AsFilePtr(PyObject *obj) {
  FILE *val = 0;
  SWIG_AsValFilePtr(obj, &val);
  return val;
}
}

/* defining the typemaps */
%typemaps_asval(%checkcode(POINTER), SWIG_AsValFilePtr, "SWIG_AsValFilePtr", FILE*);



================================================
File: swig/swigwin-3.0.8/Lib/python/implicit.i
================================================
%include <std_common.i>
%include <typemaps/implicit.swg>

#warning "This file provides the %implicit directive, which is an old and fragile"
#warning "way to implement the C++ implicit conversion mechanism."
#warning "Try using the more robust '%implicitconv Type;' directive instead."




================================================
File: swig/swigwin-3.0.8/Lib/python/jstring.i
================================================
%include <typemaps/valtypes.swg>

%fragment(SWIG_AsVal_frag(jstring),"header") {
SWIGINTERN int
SWIG_AsVal(jstring)(PyObject *obj, jstring *val)
{
  if (obj == Py_None) {
    if (val) *val = 0;
    return SWIG_OK;
  }
  
  PyObject *tmp = 0;
  int isunicode = PyUnicode_Check(obj);
  if (!isunicode && PyString_Check(obj)) {
    if (val) {
      obj = tmp = PyUnicode_FromObject(obj);
    }
    isunicode = 1;
  }
  if (isunicode) {
    if (val) {
      if (sizeof(Py_UNICODE) == sizeof(jchar)) {
	*val = JvNewString((const jchar *) PyUnicode_AS_UNICODE(obj),PyUnicode_GET_SIZE(obj));
	return SWIG_NEWOBJ;
      } else {
	int len = PyUnicode_GET_SIZE(obj);
	Py_UNICODE *pchars = PyUnicode_AS_UNICODE(obj);
	*val = JvAllocString (len);
	jchar *jchars = JvGetStringChars (*val);	
	for (int i = 0; i < len; ++i) {
	  jchars[i] = pchars[i];
	}
	return SWIG_NEWOBJ;
      }
    }
    Py_XDECREF(tmp);
    return SWIG_OK;
  }
  return SWIG_TypeError;
}
}

%fragment(SWIG_From_frag(jstring),"header") {
SWIGINTERNINLINE PyObject *
SWIG_From(jstring)(jstring val)
{
  if (!val) {
    return SWIG_Py_Void();
  } 
  if (sizeof(Py_UNICODE) == sizeof(jchar)) {    
    return PyUnicode_FromUnicode((const Py_UNICODE *) JvGetStringChars(val),
				 JvGetStringUTFLength(val));
  } else {
    int len = JvGetStringUTFLength(val);
    Py_UNICODE pchars[len];
    jchar *jchars = JvGetStringChars(val);
    
    for (int i = 0; i < len; i++) {      
      pchars[i] = jchars[i];
    }
    return PyUnicode_FromUnicode((const Py_UNICODE *) pchars, len);
  }
}
}

%typemaps_asvalfrom(%checkcode(STRING),
		    %arg(SWIG_AsVal(jstring)), 
		    %arg(SWIG_From(jstring)), 
		    %arg(SWIG_AsVal_frag(jstring)), 
		    %arg(SWIG_From_frag(jstring)), 
		    java::lang::String *);




================================================
File: swig/swigwin-3.0.8/Lib/python/pyabc.i
================================================
%define %pythonabc(Type, Abc)
  %feature("python:abc", #Abc) Type;
%enddef
%pythoncode %{import collections%}
%pythonabc(std::vector, collections.MutableSequence);
%pythonabc(std::list, collections.MutableSequence);
%pythonabc(std::map, collections.MutableMapping);
%pythonabc(std::multimap, collections.MutableMapping);
%pythonabc(std::set, collections.MutableSet);
%pythonabc(std::multiset, collections.MutableSet);



================================================
File: swig/swigwin-3.0.8/Lib/python/pyapi.swg
================================================
/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
#if PY_VERSION_HEX >= 0x03000000
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
{
  return PyInstanceMethod_New(func);
}
#else
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
{
  return NULL;
}
#endif

#ifdef __cplusplus
}
#endif




================================================
File: swig/swigwin-3.0.8/Lib/python/pybackward.swg
================================================
/* 
   adding backward compatibility macros
*/

#define SWIG_arg(x...)     %arg(x)
#define SWIG_Mangle(x...)  %mangle(x)

#define SWIG_As_frag(Type...)      %fragment_name(As, Type)
#define SWIG_As_name(Type...)      %symbol_name(As, Type) 
#define SWIG_As(Type...)     	   SWIG_As_name(Type) SWIG_AS_CALL_ARGS 

#define SWIG_Check_frag(Type...)   %fragment_name(Check, Type)
#define SWIG_Check_name(Type...)   %symbol_name(Check, Type) 
#define SWIG_Check(Type...)        SWIG_Check_name(Type) SWIG_AS_CALL_ARGS 

%define %ascheck_methods(Code, Type...)
%fragment(SWIG_As_frag(Type),"header", fragment=SWIG_AsVal_frag(Type)) {
SWIGINTERNINLINE Type
SWIG_As(Type)(PyObject* obj)
{
  Type v;
  int res = SWIG_AsVal(Type)(obj, &v);
  if (!SWIG_IsOK(res)) {
    /*
      this is needed to make valgrind/purify happier. 
     */
    memset((void*)&v, 0, sizeof(Type));
    SWIG_Error(res, "");
  }
  return v;
}
}

%fragment(SWIG_Check_frag(Type),"header",fragment=SWIG_AsVal_frag(Type)) {
SWIGINTERNINLINE int
SWIG_Check(Type)(PyObject* obj)
{
  int res = SWIG_AsVal(Type)(obj, (Type*)0);
  return SWIG_IsOK(res);
}
}
%enddef

%apply_checkctypes(%ascheck_methods)




================================================
File: swig/swigwin-3.0.8/Lib/python/pybuffer.i
================================================
/* Implementing buffer protocol typemaps */

/* %pybuffer_mutable_binary(TYPEMAP, SIZE)
 *
 * Macro for functions accept mutable buffer pointer with a size.
 * This can be used for both input and output. For example:
 * 
 *      %pybuffer_mutable_binary(char *buff, int size);
 *      void foo(char *buff, int size) {
 *        for(int i=0; i<size; ++i)
 *          buff[i]++;  
 *      }
 */

%define %pybuffer_mutable_binary(TYPEMAP, SIZE)
%typemap(in) (TYPEMAP, SIZE)
  (int res, Py_ssize_t size = 0, void *buf = 0) {
  res = PyObject_AsWriteBuffer($input, &buf, &size);
  if (res<0) {
    PyErr_Clear();
    %argument_fail(res, "(TYPEMAP, SIZE)", $symname, $argnum);
  }
  $1 = ($1_ltype) buf;
  $2 = ($2_ltype) (size/sizeof($*1_type));
}
%enddef

/* %pybuffer_mutable_string(TYPEMAP, SIZE)
 *
 * Macro for functions accept mutable zero terminated string pointer.
 * This can be used for both input and output. For example:
 * 
 *      %pybuffer_mutable_string(char *str);
 *      void foo(char *str) {
 *        while(*str) {
 *          *str = toupper(*str);
 *          str++;
 *      }
 */

%define %pybuffer_mutable_string(TYPEMAP)
%typemap(in) (TYPEMAP)
  (int res, Py_ssize_t size = 0, void *buf = 0) {
  res = PyObject_AsWriteBuffer($input, &buf, &size);
  if (res<0) {
    PyErr_Clear();
    %argument_fail(res, "(TYPEMAP, SIZE)", $symname, $argnum);
  }
  $1 = ($1_ltype) buf;
}
%enddef

/* pybuffer_binary(TYPEMAP, SIZE)
 *
 * Macro for functions accept read only buffer pointer with a size.
 * This must be used for input. For example:
 * 
 *      %pybuffer_binary(char *buff, int size);
 *      int foo(char *buff, int size) {
 *        int count = 0;
 *        for(int i=0; i<size; ++i)
 *          if (0==buff[i]) count++;
 *        return count;
 *      }
 */

%define %pybuffer_binary(TYPEMAP, SIZE)
%typemap(in) (TYPEMAP, SIZE)
  (int res, Py_ssize_t size = 0, const void *buf = 0) {
  res = PyObject_AsReadBuffer($input, &buf, &size);
  if (res<0) {
    PyErr_Clear();
    %argument_fail(res, "(TYPEMAP, SIZE)", $symname, $argnum);
  }
  $1 = ($1_ltype) buf;
  $2 = ($2_ltype) (size / sizeof($*1_type));
}
%enddef

/* %pybuffer_string(TYPEMAP, SIZE)
 *
 * Macro for functions accept read only zero terminated string pointer.
 * This can be used for input. For example:
 * 
 *      %pybuffer_string(char *str);
 *      int foo(char *str) {
 *        int count = 0;
 *        while(*str) {
 *          if (isalnum(*str))
 *            count++;
 *          str++;
 *      }
 */

%define %pybuffer_string(TYPEMAP)
%typemap(in) (TYPEMAP)
  (int res, Py_ssize_t size = 0, const void *buf = 0) {
  res = PyObject_AsReadBuffer($input, &buf, &size);
  if (res<0) {
    %argument_fail(res, "(TYPEMAP, SIZE)", $symname, $argnum);
  }
  $1 = ($1_ltype) buf;
}
%enddef






================================================
File: swig/swigwin-3.0.8/Lib/python/pyclasses.swg
================================================
#ifdef __cplusplus

/*
  SwigPtr_PyObject is used as a replacement of PyObject *, where
  the INCREF/DECREF are applied as needed.

  You can use SwigPtr_PyObject in a container, such as
  
     std::vector<SwigPtr_PyObject>;

  or as a member variable:
  
     struct A {
       SwigPtr_PyObject obj;
       A(PyObject *o) : _obj(o) {
       }
     };

   or as a input/output value 

     SwigPtr_PyObject func(SwigPtr_PyObject obj) {     
       SwigPtr_PyObject out = PyString_FromFormat("hello %s", PyObject_AsString(obj));
       Py_DECREF(out);
       return out;
     }

   just remember to pair the object creation with the proper DECREF,
   the same as with plain PyObject *ptr, since SwigPtr_PyObject always add
   one reference at construction.

   SwigPtr_PyObject is 'visible' at the wrapped side, so you can do:


      %template(pyvector) std::vector<swig::SwigPtr_PyObject>;

   and all the proper typemaps will be used.
   
*/

namespace swig {
  %ignore SwigPtr_PyObject;
  struct SwigPtr_PyObject {};
  %apply PyObject * {SwigPtr_PyObject};
  %apply PyObject * const& {SwigPtr_PyObject const&};

  %typemap(typecheck,precedence=SWIG_TYPECHECK_SWIGOBJECT,noblock=1) SwigPtr_PyObject const& "$1 = ($input != 0);";


  /* For output */
  %typemap(out,noblock=1)  SwigPtr_PyObject {
    $result = (PyObject *)$1;
    Py_INCREF($result);
  }
  
  %typemap(out,noblock=1)  SwigPtr_PyObject const & {
    $result = (PyObject *)*$1;
    Py_INCREF($result);
  }
  
}

%{
namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}
%}

/*
  SwigVar_PyObject is used to manage 'in the scope' PyObject * variables,
  as in

  int func () {
    SwigVar_PyObject obj = PyString_FromString("hello");
  }

  ie, 'obj' is created and destructed in the same scope from
  a python object that carries at least one reference value.
  
  SwigVar_PyObject just take care of applying the proper Py_DECREF.

  Hence, this class is purely internal and not visible at the wrapped side.
 */
namespace swig {
  %ignore SwigVar_PyObject;
  struct SwigVar_PyObject {};
  %apply PyObject * {SwigVar_PyObject};
  %apply PyObject * const& {SwigVar_PyObject const&};
}

%{
namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}
%}


#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/pycomplex.swg
================================================
/*
  Defines the As/From converters for double/float complex, you need to
  provide complex Type, the Name you want to use in the converters,
  the complex Constructor method, and the Real and Imag complex
  accessor methods.

  See the std_complex.i and ccomplex.i for concrete examples.
*/

/* the common from converter */
%define %swig_fromcplx_conv(Type, Real, Imag)
%fragment(SWIG_From_frag(Type),"header")
{
SWIGINTERNINLINE PyObject*
SWIG_From(Type)(%ifcplusplus(const Type&, Type) c)
{
  return PyComplex_FromDoubles(Real(c), Imag(c));
}
}
%enddef

/* the double case */
%define %swig_cplxdbl_conv(Type, Constructor, Real, Imag)
%fragment(SWIG_AsVal_frag(Type),"header",
	  fragment=SWIG_AsVal_frag(double))
{
SWIGINTERN int
SWIG_AsVal(Type) (PyObject *o, Type* val)
{
  if (PyComplex_Check(o)) {
    if (val) *val = Constructor(PyComplex_RealAsDouble(o), PyComplex_ImagAsDouble(o));
    return SWIG_OK;
  } else {
    double d;    
    int res = SWIG_AddCast(SWIG_AsVal(double)(o, &d));
    if (SWIG_IsOK(res)) {
      if (val) *val = Constructor(d, 0.0);
      return res;
    }
  }
  return SWIG_TypeError;
}
}
%swig_fromcplx_conv(Type, Real, Imag);
%enddef

/* the float case */
%define %swig_cplxflt_conv(Type, Constructor, Real, Imag)
%fragment(SWIG_AsVal_frag(Type),"header",
          fragment=SWIG_AsVal_frag(float)) {
SWIGINTERN int
SWIG_AsVal(Type)(PyObject *o, Type *val)
{
  if (PyComplex_Check(o)) {
    double re = PyComplex_RealAsDouble(o);
    double im = PyComplex_ImagAsDouble(o);
    if ((-FLT_MAX <= re && re <= FLT_MAX) && (-FLT_MAX <= im && im <= FLT_MAX)) {
      if (val) *val = Constructor(%numeric_cast(re, float),
				  %numeric_cast(im, float));
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }    
  } else {
    float re;
    int res = SWIG_AddCast(SWIG_AsVal(float)(o, &re));
    if (SWIG_IsOK(res)) {
      if (val) *val = Constructor(re, 0.0);
      return res;
    }
  }
  return SWIG_TypeError;
}
}

%swig_fromcplx_conv(Type, Real, Imag);
%enddef

#define %swig_cplxflt_convn(Type, Constructor, Real, Imag) \
%swig_cplxflt_conv(Type, Constructor, Real, Imag)


#define %swig_cplxdbl_convn(Type, Constructor, Real, Imag) \
%swig_cplxdbl_conv(Type, Constructor, Real, Imag)





================================================
File: swig/swigwin-3.0.8/Lib/python/pycontainer.swg
================================================
/* -----------------------------------------------------------------------------
 * pycontainer.swg
 *
 * Python sequence <-> C++ container wrapper
 *
 * This wrapper, and its iterator, allows a general use (and reuse) of
 * the mapping between C++ and Python, thanks to the C++ templates.
 *
 * Of course, it needs the C++ compiler to support templates, but
 * since we will use this wrapper with the STL containers, that should
 * be the case.
 * ----------------------------------------------------------------------------- */

%{
#include <iostream>

#if PY_VERSION_HEX >= 0x03020000
# define SWIGPY_SLICE_ARG(obj) ((PyObject*) (obj))
#else
# define SWIGPY_SLICE_ARG(obj) ((PySliceObject*) (obj))
#endif
%}


#if !defined(SWIG_NO_EXPORT_ITERATOR_METHODS)
# if !defined(SWIG_EXPORT_ITERATOR_METHODS)
#  define SWIG_EXPORT_ITERATOR_METHODS SWIG_EXPORT_ITERATOR_METHODS
# endif
#endif

%include <pyiterators.swg>

/**** The PySequence C++ Wrap ***/

%fragment("<stdexcept>");

%include <std_except.i>

%fragment(SWIG_Traits_frag(swig::SwigPtr_PyObject),"header",fragment="StdTraits") {
namespace swig {
  template <>  struct traits<SwigPtr_PyObject > {
    typedef value_category category;
    static const char* type_name() { return  "SwigPtr_PyObject"; }
  };
  
  template <>  struct traits_from<SwigPtr_PyObject> {
    typedef SwigPtr_PyObject value_type;
    static PyObject *from(const value_type& val) {
      PyObject *obj = static_cast<PyObject *>(val);
      Py_XINCREF(obj);
      return obj;
    }
  };
  
  template <> 
  struct traits_check<SwigPtr_PyObject, value_category> {
    static bool check(SwigPtr_PyObject) {
      return true;
    }
  };
  
  template <>  struct traits_asval<SwigPtr_PyObject > {   
    typedef SwigPtr_PyObject value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };
}
}

%fragment(SWIG_Traits_frag(swig::SwigVar_PyObject),"header",fragment="StdTraits") {
namespace swig {
  template <>  struct traits<SwigVar_PyObject > {
    typedef value_category category;
    static const char* type_name() { return  "SwigVar_PyObject"; }
  };
  
  template <>  struct traits_from<SwigVar_PyObject> {
    typedef SwigVar_PyObject value_type;
    static PyObject *from(const value_type& val) {
      PyObject *obj = static_cast<PyObject *>(val);
      Py_XINCREF(obj);
      return obj;
    }
  };
  
  template <> 
  struct traits_check<SwigVar_PyObject, value_category> {
    static bool check(SwigVar_PyObject) {
      return true;
    }
  };
  
  template <>  struct traits_asval<SwigVar_PyObject > {   
    typedef SwigVar_PyObject value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };
} 
}

%fragment("SwigPySequence_Base","header",fragment="<stddef.h>")
{
%#include <functional>

namespace std {
  template <>
  struct less <PyObject *>: public binary_function<PyObject *, PyObject *, bool>
  {
    bool
    operator()(PyObject * v, PyObject *w) const
    { 
      bool res;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      res = PyObject_RichCompareBool(v, w, Py_LT) ? true : false;
      /* This may fall into a case of inconsistent
               eg. ObjA > ObjX > ObjB
               but ObjA < ObjB
      */
      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
      {
        /* Objects can't be compared, this mostly occurred in Python 3.0 */
        /* Compare their ptr directly for a workaround */
        res = (v < w);
        PyErr_Clear();
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return res;
    }
  };

  template <>
  struct less <swig::SwigPtr_PyObject>: public binary_function<swig::SwigPtr_PyObject, swig::SwigPtr_PyObject, bool>
  {
    bool
    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

  template <>
  struct less <swig::SwigVar_PyObject>: public binary_function<swig::SwigVar_PyObject, swig::SwigVar_PyObject, bool>
  {
    bool
    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

}

namespace swig {
  template <> struct traits<PyObject *> {
    typedef value_category category;
    static const char* type_name() { return "PyObject *"; }
  };  

  template <>  struct traits_asval<PyObject * > {   
    typedef PyObject * value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };

  template <> 
  struct traits_check<PyObject *, value_category> {
    static bool check(PyObject *) {
      return true;
    }
  };

  template <>  struct traits_from<PyObject *> {
    typedef PyObject * value_type;
    static PyObject *from(const value_type& val) {
      Py_XINCREF(val);
      return val;
    }
  };
  
}

namespace swig {
  template <class Difference>
  inline size_t
  check_index(Difference i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    throw std::out_of_range("index out of range");
  }

  template <class Difference>
  void
  slice_adjust(Difference i, Difference j, Py_ssize_t step, size_t size, Difference &ii, Difference &jj, bool insert = false) {
    if (step == 0) {
      throw std::invalid_argument("slice step cannot be zero");
    } else if (step > 0) {
      // Required range: 0 <= i < size, 0 <= j < size
      if (i < 0) {
        ii = 0;
      } else if (i < (Difference)size) {
        ii = i;
      } else if (insert && (i >= (Difference)size)) {
        ii = (Difference)size;
      }
      if ( j < 0 ) {
        jj = 0;
      } else {
        jj = (j < (Difference)size) ? j : (Difference)size;
      }
    } else {
      // Required range: -1 <= i < size-1, -1 <= j < size-1
      if (i < -1) {
        ii = -1;
      } else if (i < (Difference) size) {
        ii = i;
      } else if (i >= (Difference)(size-1)) {
        ii = (Difference)(size-1);
      }
      if (j < -1) {
        jj = -1;
      } else {
        jj = (j < (Difference)size ) ? j : (Difference)(size-1);
      }
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence>
  inline void
  erase(Sequence* seq, const typename Sequence::iterator& position) {
    seq->erase(position);
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j, Py_ssize_t step) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj);

    if (step > 0) {
      typename Sequence::const_iterator sb = self->begin();
      typename Sequence::const_iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      if (step == 1) {
        return new Sequence(sb, se);
      } else {
        Sequence *sequence = new Sequence();
        typename Sequence::const_iterator it = sb;
        while (it!=se) {
          sequence->push_back(*it);
          for (Py_ssize_t c=0; c<step && it!=se; ++c)
            it++;
        }
        return sequence;
      } 
    } else {
      Sequence *sequence = new Sequence();
      if (ii > jj) {
        typename Sequence::const_reverse_iterator sb = self->rbegin();
        typename Sequence::const_reverse_iterator se = self->rbegin();
        std::advance(sb,size-ii-1);
        std::advance(se,size-jj-1);
        typename Sequence::const_reverse_iterator it = sb;
        while (it!=se) {
          sequence->push_back(*it);
          for (Py_ssize_t c=0; c<-step && it!=se; ++c)
            it++;
        }
      }
      return sequence;
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, Py_ssize_t step, const InputSeq& is = InputSeq()) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj, true);
    if (step > 0) {
      if (jj < ii)
        jj = ii;
      if (step == 1) {
        size_t ssize = jj - ii;
        if (ssize <= is.size()) {
          // expanding/staying the same size
          typename Sequence::iterator sb = self->begin();
          typename InputSeq::const_iterator isit = is.begin();
          std::advance(sb,ii);
          std::advance(isit, jj - ii);
          self->insert(std::copy(is.begin(), isit, sb), isit, is.end());
        } else {
          // shrinking
          typename Sequence::iterator sb = self->begin();
          typename Sequence::iterator se = self->begin();
          std::advance(sb,ii);
          std::advance(se,jj);
          self->erase(sb,se);
          sb = self->begin();
          std::advance(sb,ii);
          self->insert(sb, is.begin(), is.end());
        }
      } else {
        size_t replacecount = (jj - ii + step - 1) / step;
        if (is.size() != replacecount) {
          char msg[1024];
          sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
          throw std::invalid_argument(msg);
        }
        typename Sequence::const_iterator isit = is.begin();
        typename Sequence::iterator it = self->begin();
        std::advance(it,ii);
        for (size_t rc=0; rc<replacecount; ++rc) {
          *it++ = *isit++;
          for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
            it++;
        }
      }
    } else {
      if (jj > ii)
        jj = ii;
      size_t replacecount = (ii - jj - step - 1) / -step;
      if (is.size() != replacecount) {
        char msg[1024];
        sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
        throw std::invalid_argument(msg);
      }
      typename Sequence::const_iterator isit = is.begin();
      typename Sequence::reverse_iterator it = self->rbegin();
      std::advance(it,size-ii-1);
      for (size_t rc=0; rc<replacecount; ++rc) {
        *it++ = *isit++;
        for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
          it++;
      }
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j, Py_ssize_t step) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj, true);
    if (step > 0) {
      if (jj > ii) {
        typename Sequence::iterator sb = self->begin();
        std::advance(sb,ii);
        if (step == 1) {
          typename Sequence::iterator se = self->begin();
          std::advance(se,jj);
          self->erase(sb,se);
        } else {
          typename Sequence::iterator it = sb;
          size_t delcount = (jj - ii + step - 1) / step;
          while (delcount) {
            it = self->erase(it);
            for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
              it++;
            delcount--;
          }
        }
      }
    } else {
      if (ii > jj) {
        typename Sequence::reverse_iterator sb = self->rbegin();
        std::advance(sb,size-ii-1);
        typename Sequence::reverse_iterator it = sb;
        size_t delcount = (ii - jj - step - 1) / -step;
        while (delcount) {
          it = typename Sequence::reverse_iterator(self->erase((++it).base()));
          for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
            it++;
          delcount--;
        }
      }
    }
  }
}
}

%fragment("SwigPySequence_Cont","header",
	  fragment="StdTraits",
	  fragment="SwigPySequence_Base",
	  fragment="SwigPyIterator_T")
{
namespace swig
{
  template <class T>
  struct SwigPySequence_Ref
  {
    SwigPySequence_Ref(PyObject* seq, Py_ssize_t index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", (int)_index);
	if (!PyErr_Occurred()) {
	  ::%type_error(swig::type_name<T>());
	}
	SWIG_Python_AddErrorMsg(msg);
	SWIG_Python_AddErrorMsg(e.what());
	throw;
      }
    }

    SwigPySequence_Ref& operator=(const T& v)
    {
      PySequence_SetItem(_seq, _index, swig::from<T>(v));
      return *this;
    }

  private:
    PyObject* _seq;
    Py_ssize_t _index;
  };

  template <class T>
  struct SwigPySequence_ArrowProxy
  {
    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };

  template <class T, class Reference >
  struct SwigPySequence_InputIterator
  {
    typedef SwigPySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef Py_ssize_t difference_type;

    SwigPySequence_InputIterator()
    {
    }

    SwigPySequence_InputIterator(PyObject* seq, Py_ssize_t index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    SwigPySequence_ArrowProxy<T>
    operator->() const {
      return SwigPySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    PyObject* _seq;
    difference_type _index;
  };

  // STL container wrapper around a Python sequence
  template <class T>
  struct SwigPySequence_Cont
  {
    typedef SwigPySequence_Ref<T> reference;
    typedef const SwigPySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef Py_ssize_t difference_type;
    typedef size_t size_type;
    typedef const pointer const_pointer;
    typedef SwigPySequence_InputIterator<T, reference> iterator;
    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;

    SwigPySequence_Cont(PyObject* seq) : _seq(0)
    {
      if (!PySequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
    }

    ~SwigPySequence_Cont()
    {
      Py_XDECREF(_seq);
    }

    size_type size() const
    {
      return static_cast<size_type>(PySequence_Size(_seq));
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = true) const
    {
      Py_ssize_t s = size();
      for (Py_ssize_t i = 0; i < s; ++i) {
	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", (int)i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    PyObject* _seq;
  };

}
}

%define %swig_sequence_iterator(Sequence...)
#if defined(SWIG_EXPORT_ITERATOR_METHODS)
  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    $result = SWIG_NewPointerObj(swig::make_output_iterator(%static_cast($1,const $type &)),
				 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  }
  %typemap(out,noblock=1,fragment="SwigPySequence_Cont")
    std::pair<iterator, iterator>, std::pair<const_iterator, const_iterator> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(%static_cast($1,const $type &).first),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));
    PyTuple_SetItem($result,1,SWIG_NewPointerObj(swig::make_output_iterator(%static_cast($1,const $type &).second),
						 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
  }

  %fragment("SwigPyPairBoolOutputIterator","header",fragment=SWIG_From_frag(bool),fragment="SwigPySequence_Cont") {}

  %typemap(out,noblock=1,fragment="SwigPyPairBoolOutputIterator")
    std::pair<iterator, bool>, std::pair<const_iterator, bool> {
    $result = PyTuple_New(2);
    PyTuple_SetItem($result,0,SWIG_NewPointerObj(swig::make_output_iterator(%static_cast($1,const $type &).first),
					       swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN));    
    PyTuple_SetItem($result,1,SWIG_From(bool)(%static_cast($1,const $type &).second));
  }

  %typemap(in,noblock=1,fragment="SwigPySequence_Cont")
    iterator(swig::SwigPyIterator *iter = 0, int res),
    reverse_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_iterator(swig::SwigPyIterator *iter = 0, int res),
    const_reverse_iterator(swig::SwigPyIterator *iter = 0, int res) {
    res = SWIG_ConvertPtr($input, %as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    if (!SWIG_IsOK(res) || !iter) {
      %argument_fail(SWIG_TypeError, "$type", $symname, $argnum);
    } else {
      swig::SwigPyIterator_T<$type > *iter_t = dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter);
      if (iter_t) {
	$1 = iter_t->get_current();
      } else {
	%argument_fail(SWIG_TypeError, "$type", $symname, $argnum);
      }
    }
  }

  %typecheck(%checkcode(ITERATOR),noblock=1,fragment="SwigPySequence_Cont")
    iterator, reverse_iterator, const_iterator, const_reverse_iterator {
    swig::SwigPyIterator *iter = 0;
    int res = SWIG_ConvertPtr($input, %as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
    $1 = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<$type > *>(iter) != 0));
  }

  %fragment("SwigPySequence_Cont");

  %newobject iterator(PyObject **PYTHON_SELF);
  %extend  {
    swig::SwigPyIterator* iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

#if defined(SWIGPYTHON_BUILTIN)
  %feature("python:slot", "tp_iter", functype="getiterfunc") iterator;
#else
  %pythoncode %{def __iter__(self):
    return self.iterator()%}
#endif
  }

#endif //SWIG_EXPORT_ITERATOR_METHODS
%enddef


/**** The python container methods  ****/

%define %swig_container_methods(Container...)

/* deprecated in Python 2 */
#if 1
  %newobject __getslice__;
#endif
  %newobject __getitem__(PySliceObject *slice);

#if defined(SWIGPYTHON_BUILTIN)
  %feature("python:slot", "nb_nonzero", functype="inquiry") __nonzero__;
  %feature("python:slot", "sq_length", functype="lenfunc") __len__;
#endif // SWIGPYTHON_BUILTIN

  %extend {
    bool __nonzero__() const {
      return !(self->empty());
    }

    /* Alias for Python 3 compatibility */
    bool __bool__() const {
      return !(self->empty());
    }

    size_type __len__() const {
      return self->size();
    }
  }
%enddef



%define %swig_sequence_methods_common(Sequence...)
  %swig_sequence_iterator(%arg(Sequence))
  %swig_container_methods(%arg(Sequence))

  %fragment("SwigPySequence_Base");

#if defined(SWIGPYTHON_BUILTIN)
  //%feature("python:slot", "sq_item", functype="ssizeargfunc") __getitem__;
  //%feature("python:slot", "sq_slice", functype="ssizessizeargfunc") __getslice__;
  //%feature("python:slot", "sq_ass_item", functype="ssizeobjargproc") __setitem__;
  //%feature("python:slot", "sq_ass_slice", functype="ssizessizeobjargproc") __setslice__;
  %feature("python:slot", "mp_subscript", functype="binaryfunc") __getitem__;
  %feature("python:slot", "mp_ass_subscript", functype="objobjargproc") __setitem__;
#endif // SWIGPYTHON_BUILTIN

  %extend {
    /* typemap for slice object support */
    %typemap(in) PySliceObject* {
      if (!PySlice_Check($input)) {
        %argument_fail(SWIG_TypeError, "$type", $symname, $argnum);
      }
      $1 = (PySliceObject *) $input;
    }
    %typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER) PySliceObject* {
      $1 = PySlice_Check($input);
    }

/* deprecated in Python 2 */
#if 1
    Sequence* __getslice__(difference_type i, difference_type j) throw (std::out_of_range, std::invalid_argument) {
      return swig::getslice(self, i, j, 1);
    }

    void __setslice__(difference_type i, difference_type j) throw (std::out_of_range, std::invalid_argument) {
      swig::setslice(self, i, j, 1, Sequence());
    }

    void __setslice__(difference_type i, difference_type j, const Sequence& v) throw (std::out_of_range, std::invalid_argument) {
      swig::setslice(self, i, j, 1, v);
    }

    void __delslice__(difference_type i, difference_type j) throw (std::out_of_range, std::invalid_argument) {
      swig::delslice(self, i, j, 1);
    }
#endif

    void __delitem__(difference_type i) throw (std::out_of_range, std::invalid_argument) {
      swig::erase(self, swig::getpos(self, i));
    }

    /* Overloaded methods for Python 3 compatibility 
     * (Also useful in Python 2.x)
     */
    Sequence* __getitem__(PySliceObject *slice) throw (std::out_of_range, std::invalid_argument) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return NULL;
      }
      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
      Sequence::difference_type id = i;
      Sequence::difference_type jd = j;
      return swig::getslice(self, id, jd, step);
    }

    void __setitem__(PySliceObject *slice, const Sequence& v) throw (std::out_of_range, std::invalid_argument) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
      Sequence::difference_type id = i;
      Sequence::difference_type jd = j;
      swig::setslice(self, id, jd, step, v);
    }

    void __setitem__(PySliceObject *slice) throw (std::out_of_range, std::invalid_argument) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
      Sequence::difference_type id = i;
      Sequence::difference_type jd = j;
      swig::delslice(self, id, jd, step);
    }

    void __delitem__(PySliceObject *slice) throw (std::out_of_range, std::invalid_argument) {
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(SWIGPY_SLICE_ARG(slice), (Py_ssize_t)self->size(), &i, &j, &step);
      Sequence::difference_type id = i;
      Sequence::difference_type jd = j;
      swig::delslice(self, id, jd, step);
    }

  }
%enddef

%define %swig_sequence_methods_non_resizable(Sequence...)
  %swig_sequence_methods_common(%arg(Sequence))
  %extend {
    const value_type& __getitem__(difference_type i) const throw (std::out_of_range) {
      return *(swig::cgetpos(self, i));
    }

    void __setitem__(difference_type i, const value_type& x) throw (std::out_of_range) {
      *(swig::getpos(self,i)) = x;
    }

#if defined(SWIGPYTHON_BUILTIN)
    // This will be called through the mp_ass_subscript slot to delete an entry.
    void __setitem__(difference_type i) throw (std::out_of_range, std::invalid_argument) {
      swig::erase(self, swig::getpos(self, i));
    }
#endif

  }
%enddef

%define %swig_sequence_methods(Sequence...)
  %swig_sequence_methods_non_resizable(%arg(Sequence))
  %extend {
    value_type pop() throw (std::out_of_range) {
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      Sequence::value_type x = self->back();
      self->pop_back();
      return x;
    }

    void append(const value_type& x) {
      self->push_back(x);
    }
  }
%enddef

%define %swig_sequence_methods_non_resizable_val(Sequence...)
  %swig_sequence_methods_common(%arg(Sequence))
  %extend {
    value_type __getitem__(difference_type i) throw (std::out_of_range) {
      return *(swig::cgetpos(self, i));
    }

    void __setitem__(difference_type i, value_type x) throw (std::out_of_range) {
      *(swig::getpos(self,i)) = x;
    }

#if defined(SWIGPYTHON_BUILTIN)
    // This will be called through the mp_ass_subscript slot to delete an entry.
    void __setitem__(difference_type i) throw (std::out_of_range, std::invalid_argument) {
      swig::erase(self, swig::getpos(self, i));
    }
#endif
  }
%enddef

%define %swig_sequence_methods_val(Sequence...)
  %swig_sequence_methods_non_resizable_val(%arg(Sequence))
  %extend {
    value_type pop() throw (std::out_of_range) {
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      Sequence::value_type x = self->back();
      self->pop_back();
      return x;
    }

    void append(value_type x) {
      self->push_back(x);
    }
  }
%enddef



//
// Common fragments
//

%fragment("StdSequenceTraits","header",
	  fragment="StdTraits",
	  fragment="SwigPySequence_Cont")
{
namespace swig {
  template <class SwigPySeq, class Seq>
  inline void
  assign(const SwigPySeq& swigpyseq, Seq* seq) {
    // seq->assign(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
    typedef typename SwigPySeq::value_type value_type;
    typename SwigPySeq::const_iterator it = swigpyseq.begin();
    for (;it != swigpyseq.end(); ++it) {
      seq->insert(seq->end(),(value_type)(*it));
    }
  }

  template <class Seq, class T = typename Seq::value_type >
  struct traits_asptr_stdseq {
    typedef Seq sequence;
    typedef T value_type;

    static int asptr(PyObject *obj, sequence **seq) {
      if (obj == Py_None || SWIG_Python_GetSwigThis(obj)) {
	sequence *p;
	if (::SWIG_ConvertPtr(obj,(void**)&p,
			      swig::type_info<sequence>(),0) == SWIG_OK) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      } else if (PySequence_Check(obj)) {
	try {
	  SwigPySequence_Cont<value_type> swigpyseq(obj);
	  if (seq) {
	    sequence *pseq = new sequence();
	    assign(swigpyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return swigpyseq.check() ? SWIG_OK : SWIG_ERROR;
	  }
	} catch (std::exception& e) {
	  if (seq) {
	    if (!PyErr_Occurred()) {
	      PyErr_SetString(PyExc_TypeError, e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      }
      return SWIG_ERROR;
    }
  };

  template <class Seq, class T = typename Seq::value_type >
  struct traits_from_stdseq {
    typedef Seq sequence;
    typedef T value_type;
    typedef typename Seq::size_type size_type;
    typedef typename sequence::const_iterator const_iterator;

    static PyObject *from(const sequence& seq) {
%#ifdef SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
      swig_type_info *desc = swig::type_info<sequence>();
      if (desc && desc->clientdata) {
	return SWIG_NewPointerObj(new sequence(seq), desc, SWIG_POINTER_OWN);
      }
%#endif
      size_type size = seq.size();
      if (size <= (size_type)INT_MAX) {
	PyObject *obj = PyTuple_New((Py_ssize_t)size);
	Py_ssize_t i = 0;
	for (const_iterator it = seq.begin(); it != seq.end(); ++it, ++i) {
	  PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
	}
	return obj;
      } else {
	PyErr_SetString(PyExc_OverflowError,"sequence size not valid in python");
	return NULL;
      }
    }
  };
}
}



================================================
File: swig/swigwin-3.0.8/Lib/python/pydocs.swg
================================================

// Documentation for use with the autodoc feature.

#ifdef SWIG_DOC_DOXYGEN_STYLE
%typemap(doc) SWIGTYPE "@param $1_name $1_type";
%typemap(doc) SWIGTYPE * "@param $1_name $1_type";
%typemap(doc) const SWIGTYPE & "@param $1_name $1_type";
%typemap(doc) const SWIGTYPE && "@param $1_name $1_type";
%typemap(doc) enum SWIGTYPE "@param $1_name enum $1_type";

%typemap(doc) SWIGTYPE *INOUT, SWIGTYPE &INOUT "@param $1_name $1_type (input/output)";
%typemap(doc) SWIGTYPE *INPUT, SWIGTYPE &INPUT "@param $1_name $1_type (input)";
%typemap(doc) SWIGTYPE *OUTPUT, SWIGTYPE &OUTPUT "@param $1_name $1_type (output)";
#else
%typemap(doc) SWIGTYPE "$1_name: $1_type";
%typemap(doc) SWIGTYPE * "$1_name: $1_type";
%typemap(doc) const SWIGTYPE & "$1_name: $1_type";
%typemap(doc) const SWIGTYPE && "$1_name: $1_type";
%typemap(doc) enum SWIGTYPE "$1_name: enum $1_type";

%typemap(doc) SWIGTYPE *INOUT, SWIGTYPE &INOUT "$1_name: $1_type (input/output)";
%typemap(doc) SWIGTYPE *INPUT, SWIGTYPE &INPUT "$1_name: $1_type (input)";
%typemap(doc) SWIGTYPE *OUTPUT, SWIGTYPE &OUTPUT "$1_name: $1_type (output)";
#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/pyerrors.swg
================================================
/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}



================================================
File: swig/swigwin-3.0.8/Lib/python/pyfragments.swg
================================================
/*

  Create a file with this name, 'pyfragments.swg', in your working
  directory and add all the %fragments you want to take precedence
  over the default ones defined by swig.

  For example, if you add:
  
  %fragment(SWIG_AsVal_frag(int),"header") {
   SWIGINTERNINLINE int
   SWIG_AsVal(int)(PyObject *obj, int *val)
   { 
     <your code here>;
   }
  }
  
  this will replace the code used to retrieve an integer value for all
  the typemaps that need it, including:
  
    int, std::vector<int>, std::list<std::pair<int,int> >, etc.

    
*/



================================================
File: swig/swigwin-3.0.8/Lib/python/pyhead.swg
================================================
/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

/* Add PyObject_Del for old Pythons */
#if PY_VERSION_HEX < 0x01060000
# define PyObject_Del(op) PyMem_DEL((op))
#endif
#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intintargfunc ssizessizeargfunc;
typedef intobjargproc ssizeobjargproc;
typedef intintobjargproc ssizessizeobjargproc;
typedef getreadbufferproc readbufferproc;
typedef getwritebufferproc writebufferproc;
typedef getsegcountproc segcountproc;
typedef getcharbufferproc charbufferproc;
static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
{
  long result = 0;
  PyObject *i = PyNumber_Int(x);
  if (i) {
    result = PyInt_AsLong(i);
    Py_DECREF(i);
  }
  return result;
}
#endif

#if PY_VERSION_HEX < 0x02050000
#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
#endif

#if PY_VERSION_HEX < 0x02040000
#define Py_VISIT(op)				\
  do { 						\
    if (op) {					\
      int vret = visit((op), arg);		\
      if (vret)					\
        return vret;				\
    }						\
  } while (0)
#endif

#if PY_VERSION_HEX < 0x02030000
typedef struct {
  PyTypeObject type;
  PyNumberMethods as_number;
  PyMappingMethods as_mapping;
  PySequenceMethods as_sequence;
  PyBufferProcs as_buffer;
  PyObject *name, *slots;
} PyHeapTypeObject;
#endif

#if PY_VERSION_HEX < 0x02030000
typedef destructor freefunc;
#endif

#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
     (PY_MAJOR_VERSION > 3))
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
#endif

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/pyinit.swg
================================================
/* ------------------------------------------------------------
 * The start of the Python initialization function 
 * ------------------------------------------------------------ */

%insert(init) "swiginit.swg"

#if defined(SWIGPYTHON_BUILTIN)
%fragment("<stddef.h>"); // For offsetof
#endif

%init %{

#ifdef __cplusplus
extern "C" {
#endif

/* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
 
/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */
 
typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

SWIGINTERN PyObject *
swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_InternFromString("<Swig global variables>");
#else
  return PyString_FromString("<Swig global variables>");
#endif
}

SWIGINTERN PyObject *
swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
  PyObject *str = PyUnicode_InternFromString("(");
  PyObject *tail;
  PyObject *joined;
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    tail = PyUnicode_FromString(var->name);
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
    if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
    }
  }
  tail = PyUnicode_InternFromString(")");
  joined = PyUnicode_Concat(str, tail);
  Py_DecRef(str);
  Py_DecRef(tail);
  str = joined;
#else
  PyObject *str = PyString_FromString("(");
  swig_globalvar *var;
  for (var = v->vars; var; var=var->next) {
    PyString_ConcatAndDel(&str,PyString_FromString(var->name));
    if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
  }
  PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
  return str;
}

SWIGINTERN int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
  char *tmp;
  PyObject *str = swig_varlink_str(v);
  fprintf(fp,"Swig global variables ");
  fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
  SWIG_Python_str_DelForPy3(tmp);
  Py_DECREF(str);
  return 0;
}

SWIGINTERN void
swig_varlink_dealloc(swig_varlinkobject *v) {
  swig_globalvar *var = v->vars;
  while (var) {
    swig_globalvar *n = var->next;
    free(var->name);
    free(var);
    var = n;
  }
}

SWIGINTERN PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  PyObject *res = NULL;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->get_attr)();
      break;
    }
    var = var->next;
  }
  if (res == NULL && !PyErr_Occurred()) {
    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
  }
  return res;
}

SWIGINTERN int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  int res = 1;
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      res = (*var->set_attr)(p);
      break;
    }
    var = var->next;
  }
  if (res == 1 && !PyErr_Occurred()) {
    PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
  }
  return res;
}

SWIGINTERN PyTypeObject*
swig_varlink_type(void) {
  static char varlink__doc__[] = "Swig var link object";
  static PyTypeObject varlink_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                  /* ob_size */
#endif
      (char *)"swigvarlink",              /* tp_name */
      sizeof(swig_varlinkobject),         /* tp_basicsize */
      0,                                  /* tp_itemsize */
      (destructor) swig_varlink_dealloc,  /* tp_dealloc */
      (printfunc) swig_varlink_print,     /* tp_print */
      (getattrfunc) swig_varlink_getattr, /* tp_getattr */
      (setattrfunc) swig_varlink_setattr, /* tp_setattr */
      0,                                  /* tp_compare */
      (reprfunc) swig_varlink_repr,       /* tp_repr */
      0,                                  /* tp_as_number */
      0,                                  /* tp_as_sequence */
      0,                                  /* tp_as_mapping */
      0,                                  /* tp_hash */
      0,                                  /* tp_call */
      (reprfunc) swig_varlink_str,        /* tp_str */
      0,                                  /* tp_getattro */
      0,                                  /* tp_setattro */
      0,                                  /* tp_as_buffer */
      0,                                  /* tp_flags */
      varlink__doc__,                     /* tp_doc */
      0,                                  /* tp_traverse */
      0,                                  /* tp_clear */
      0,                                  /* tp_richcompare */
      0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                  /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                  /* tp_allocs */
      0,                                  /* tp_frees */
      0,                                  /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                  /* tp_prev */
#endif
      0                                   /* tp_next */
#endif
    };
    varlink_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    varlink_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&varlink_type) < 0)
      return NULL;
#endif
  }
  return &varlink_type;
}

/* Create a variable linking object for use later */
SWIGINTERN PyObject *
SWIG_Python_newvarlink(void) {
  swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
  if (result) {
    result->vars = 0;
  }
  return ((PyObject*) result);
}

SWIGINTERN void 
SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v = (swig_varlinkobject *) p;
  swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  if (gv) {
    size_t size = strlen(name)+1;
    gv->name = (char *)malloc(size);
    if (gv->name) {
      strncpy(gv->name,name,size);
      gv->get_attr = get_attr;
      gv->set_attr = set_attr;
      gv->next = v->vars;
    }
  }
  v->vars = gv;
}

SWIGINTERN PyObject *
SWIG_globals(void) {
  static PyObject *_SWIG_globals = 0; 
  if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
  return _SWIG_globals;
}

/* -----------------------------------------------------------------------------
 * constants/methods manipulation
 * ----------------------------------------------------------------------------- */

/* Install Constants */
SWIGINTERN void
SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
  PyObject *obj = 0;
  size_t i;
  for (i = 0; constants[i].type; ++i) {
    switch(constants[i].type) {
    case SWIG_PY_POINTER:
      obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d, constants[i].name, obj);
      Py_DECREF(obj);
    }
  }
}

/* -----------------------------------------------------------------------------*/
/* Fix SwigMethods to carry the callback ptrs when needed */
/* -----------------------------------------------------------------------------*/

SWIGINTERN void
SWIG_Python_FixMethods(PyMethodDef *methods,
		       swig_const_info *const_table,
		       swig_type_info **types,
		       swig_type_info **types_initial) {
  size_t i;
  for (i = 0; methods[i].ml_name; ++i) {
    const char *c = methods[i].ml_doc;
    if (!c) continue;
    c = strstr(c, "swig_ptr: ");
    if (c) {
      int j;
      swig_const_info *ci = 0;
      const char *name = c + 10;
      for (j = 0; const_table[j].type; ++j) {
	if (strncmp(const_table[j].name, name, 
		    strlen(const_table[j].name)) == 0) {
	  ci = &(const_table[j]);
	  break;
	}
      }
      if (ci) {
	void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
	if (ptr) {
	  size_t shift = (ci->ptype) - types;
	  swig_type_info *ty = types_initial[shift];
	  size_t ldoc = (c - methods[i].ml_doc);
	  size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
	  char *ndoc = (char*)malloc(ldoc + lptr + 10);
	  if (ndoc) {
	    char *buff = ndoc;
	    strncpy(buff, methods[i].ml_doc, ldoc);
	    buff += ldoc;
	    strncpy(buff, "swig_ptr: ", 10);
	    buff += 10;
	    SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
	    methods[i].ml_doc = ndoc;
	  }
	}
      }
    }
  }
} 

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
  PyObject*
#else
  void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md;
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
# if PY_VERSION_HEX >= 0x03020000
    PyModuleDef_HEAD_INIT,
# else
    {
      PyObject_HEAD_INIT(NULL)
      NULL, /* m_init */
      0,    /* m_index */
      NULL, /* m_copy */
    },
# endif
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif

#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {0, 0, 0, 0, 0, 0, 0};
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    (PyCFunction) SwigPyObject_own,
    (PyCFunction) SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyObject *metatype_args;
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;

  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;

  /* metatype is used to implement static member variables. */
  metatype_args = Py_BuildValue("(s(O){})", "SwigPyObjectType", &PyType_Type);
  assert(metatype_args);
  metatype = (PyTypeObject *) PyType_Type.tp_call((PyObject *) &PyType_Type, metatype_args, NULL);
  assert(metatype);
  Py_DECREF(metatype_args);
  metatype->tp_setattro = (setattrofunc) &SwigPyObjectType_setattro;
  assert(PyType_Ready(metatype) >= 0);
#endif

  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);

#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif

  md = d = PyModule_GetDict(m);
  (void)md;

  SWIG_InitializeModule(0);

#ifdef SWIGPYTHON_BUILTIN
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = SwigPyObject_TypeOnce();
  } else if (SwigPyObject_TypeOnce()->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }

  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;

  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;

  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;

  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
    SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
    SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif

  SWIG_InstallConstants(d,swig_const_table);
%}




================================================
File: swig/swigwin-3.0.8/Lib/python/pyiterators.swg
================================================
/* -----------------------------------------------------------------------------
 * pyiterators.swg
 *
 * Implement a python 'output' iterator for Python 2.2 or higher.
 *
 * Users can derive form the SwigPyIterator to implement their
 * own iterators. As an example (real one since we use it for STL/STD
 * containers), the template SwigPyIterator_T does the
 * implementation for generic C++ iterators.
 * ----------------------------------------------------------------------------- */

%include <std_common.i>

%fragment("SwigPyIterator","header",fragment="<stddef.h>") {
namespace swig {
  struct stop_iteration {
  };

  struct SwigPyIterator {
  private:
    SwigPtr_PyObject _seq;

  protected:
    SwigPyIterator(PyObject *seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~SwigPyIterator() {}

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
    {
      throw stop_iteration();
    }

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next()     
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      PyObject *obj = value();
      incr();       
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
      return obj;     
    }

    /* Make an alias for Python 3.x */
    PyObject *__next__()
    {
      return next();
    }

    PyObject *previous()
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      decr();
      PyObject *obj = value();
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
      return obj;
    }

    SwigPyIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const SwigPyIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const SwigPyIterator& x) const
    {
      return ! operator==(x);
    }
      
    SwigPyIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    SwigPyIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    SwigPyIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    SwigPyIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const SwigPyIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
	init = 1;
      }	
      return desc;
    }    
  };

%#if defined(SWIGPYTHON_BUILTIN)
  inline PyObject* make_output_iterator_builtin (PyObject *pyself)
  {
    Py_INCREF(pyself);
    return pyself;
  }
%#endif
}
}

%fragment("SwigPyIterator_T","header",fragment="<stddef.h>",fragment="SwigPyIterator",fragment="StdTraits",fragment="StdIteratorTraits") {
namespace swig {
  template<typename OutIterator>
  class SwigPyIterator_T :  public SwigPyIterator
  {
  public:
    typedef OutIterator out_iterator;
    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
    typedef SwigPyIterator_T<out_iterator> self_type;

    SwigPyIterator_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator(seq), current(curr)
    {
    }

    const out_iterator& get_current() const
    {
      return current;
    }

    
    bool equal (const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    ptrdiff_t distance(const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }    
    
  protected:
    out_iterator current;
  };
  
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef PyObject *result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq)
    {
    }
    
    PyObject *value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	++base::current;
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	--base::current;
      }
      return this;
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;    
    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    PyObject *value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  ++base::current;
	}
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	if (base::current == begin) {
	  throw stop_iteration();
	} else {
	  --base::current;
	}
      }
      return this;
    }

  private:
    out_iterator begin;
    out_iterator end;
  };

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
  {
    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, PyObject *seq = 0)
  {
    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
  }

}
}


%fragment("SwigPyIterator");
namespace swig 
{
  /*
    Throw a StopIteration exception
  */
  %ignore stop_iteration;
  struct stop_iteration {};
  
  %typemap(throws) stop_iteration {
    (void)$1;
    SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
    SWIG_fail;
  }

  /* 
     Mark methods that return new objects
  */
  %newobject SwigPyIterator::copy;
  %newobject SwigPyIterator::operator + (ptrdiff_t n) const;
  %newobject SwigPyIterator::operator - (ptrdiff_t n) const;

  %nodirector SwigPyIterator;

#if defined(SWIGPYTHON_BUILTIN)
  %feature("python:tp_iter") SwigPyIterator "&swig::make_output_iterator_builtin";
  %feature("python:slot", "tp_iternext", functype="iternextfunc") SwigPyIterator::__next__;
#else
  %extend SwigPyIterator {
  %pythoncode %{def __iter__(self):
    return self%}
  }
#endif

  %catches(swig::stop_iteration) SwigPyIterator::value() const;
  %catches(swig::stop_iteration) SwigPyIterator::incr(size_t n = 1);
  %catches(swig::stop_iteration) SwigPyIterator::decr(size_t n = 1);
  %catches(std::invalid_argument) SwigPyIterator::distance(const SwigPyIterator &x) const;
  %catches(std::invalid_argument) SwigPyIterator::equal (const SwigPyIterator &x) const;
  %catches(swig::stop_iteration) SwigPyIterator::__next__();
  %catches(swig::stop_iteration) SwigPyIterator::next();
  %catches(swig::stop_iteration) SwigPyIterator::previous();
  %catches(swig::stop_iteration) SwigPyIterator::advance(ptrdiff_t n);
  %catches(swig::stop_iteration) SwigPyIterator::operator += (ptrdiff_t n);
  %catches(swig::stop_iteration) SwigPyIterator::operator -= (ptrdiff_t n);
  %catches(swig::stop_iteration) SwigPyIterator::operator + (ptrdiff_t n) const;
  %catches(swig::stop_iteration) SwigPyIterator::operator - (ptrdiff_t n) const;

  struct SwigPyIterator
  {
  protected:
    SwigPyIterator(PyObject *seq);

  public:
    virtual ~SwigPyIterator();

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t n = 1);

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &x) const;

    virtual bool equal (const SwigPyIterator &x) const;
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next();
    PyObject *__next__();
    PyObject *previous();
    SwigPyIterator *advance(ptrdiff_t n);

    bool operator == (const SwigPyIterator& x)  const;
    bool operator != (const SwigPyIterator& x) const;
    SwigPyIterator& operator += (ptrdiff_t n);
    SwigPyIterator& operator -= (ptrdiff_t n);
    SwigPyIterator* operator + (ptrdiff_t n) const;
    SwigPyIterator* operator - (ptrdiff_t n) const;
    ptrdiff_t operator - (const SwigPyIterator& x) const;
  };
}




================================================
File: swig/swigwin-3.0.8/Lib/python/pymacros.swg
================================================
%include <typemaps/swigmacros.swg>






================================================
File: swig/swigwin-3.0.8/Lib/python/pyname_compat.i
================================================
/* 
* From SWIG 1.3.37 we deprecated all SWIG symbols that start with Py,
* since they are inappropriate and discouraged in Python documentation
* (from http://www.python.org/doc/2.5.2/api/includes.html):
*
* "All user visible names defined by Python.h (except those defined by the included
* standard headers) have one of the prefixes "Py" or "_Py". Names beginning with
* "_Py" are for internal use by the Python implementation and should not be used
* by extension writers. Structure member names do not have a reserved prefix.
*
* Important: user code should never define names that begin with "Py" or "_Py".
* This confuses the reader, and jeopardizes the portability of the user code to
* future Python versions, which may define additional names beginning with one
* of these prefixes."
*
* This file defined macros to provide backward compatibility for these deprecated
* symbols. In the case you have these symbols in your interface file, you can simply
* include this file at beginning of it.
*
* However, this file may be removed in future release of SWIG, so using this file to
* keep these inappropriate names in your SWIG interface file is also not recommended.
* Instead, we provide a simple tool for converting your interface files to
* the new naming convention. You can get the tool from the SWIG distribution:
* Tools/pyname_patch.py
*/

%fragment("PySequence_Base", "header", fragment="SwigPySequence_Base") {}
%fragment("PySequence_Cont", "header", fragment="SwigPySequence_Cont") {}
%fragment("PySwigIterator_T", "header", fragment="SwigPyIterator_T") {}
%fragment("PyPairBoolOutputIterator", "header", fragment="SwigPyPairBoolOutputIterator") {}
%fragment("PySwigIterator", "header", fragment="SwigPyIterator") {}
%fragment("PySwigIterator_T", "header", fragment="SwigPyIterator_T") {}

%inline %{
#define PyMapIterator_T SwigPyMapIterator_T
#define PyMapKeyIterator_T SwigPyMapKeyIterator_T
#define PyMapValueIterator_T SwigPyMapValueITerator_T
#define PyObject_ptr SwigPtr_PyObject
#define PyObject_var SwigVar_PyObject
#define PyOper SwigPyOper
#define PySeq SwigPySeq
#define PySequence_ArrowProxy SwigPySequence_ArrowProxy
#define PySequence_Cont SwigPySequence_Cont
#define PySequence_InputIterator SwigPySequence_InputIterator
#define PySequence_Ref SwigPySequence_Ref
#define PySwigClientData SwigPyClientData
#define PySwigClientData_Del SwigPyClientData_Del
#define PySwigClientData_New SwigPyClientData_New
#define PySwigIterator SwigPyIterator
#define PySwigIteratorClosed_T SwigPyIteratorClosed_T
#define PySwigIteratorOpen_T SwigPyIteratorOpen_T
#define PySwigIterator_T SwigPyIterator_T
#define PySwigObject SwigPyObject
#define PySwigObject_Check SwigPyObject_Check
#define PySwigObject_GetDesc SwigPyObject_GetDesc
#define PySwigObject_New SwigPyObject_New
#define PySwigObject_acquire SwigPyObject_acquire
#define PySwigObject_append SwigPyObject_append
#define PySwigObject_as_number SwigPyObject_as_number
#define PySwigObject_compare SwigPyObject_compare
#define PySwigObject_dealloc SwigPyObject_dealloc
#define PySwigObject_disown SwigPyObject_disown
#define PySwigObject_format SwigPyObject_format
#define PySwigObject_getattr SwigPyObject_getattr
#define PySwigObject_hex SwigPyObject_hex
#define PySwigObject_long SwigPyObject_long
#define PySwigObject_next SwigPyObject_next
#define PySwigObject_oct SwigPyObject_oct
#define PySwigObject_own SwigPyObject_own
#define PySwigObject_repr SwigPyObject_repr
#define PySwigObject_richcompare SwigPyObject_richcompare
#define PySwigObject_type SwigPyObject_type
#define PySwigPacked SwigPyPacked
#define PySwigPacked_Check SwigPyPacked_Check
#define PySwigPacked_New SwigPyPacked_New
#define PySwigPacked_UnpackData SwigPyPacked_UnpackData
#define PySwigPacked_compare SwigPyPacked_compare
#define PySwigPacked_dealloc SwigPyPacked_dealloc
#define PySwigPacked_print SwigPyPacked_print
#define PySwigPacked_repr SwigPyPacked_repr
#define PySwigPacked_str SwigPyPacked_str
#define PySwigPacked_type SwigPyPacked_type
#define pyseq swigpyseq
#define pyswigobject_type swigpyobject_type
#define pyswigpacked_type swigpypacked_type
%}



================================================
File: swig/swigwin-3.0.8/Lib/python/pyopers.swg
================================================
/* ------------------------------------------------------------
 * Overloaded operator support

 The directives in this file apply whether or not you use the
 -builtin option to SWIG, but operator overloads are particularly
 attractive when using -builtin, because they are much faster
 than named methods.

 If you're using the -builtin option to SWIG, and you want to define
 python operator overloads beyond the defaults defined in this file,
 here's what you need to know:

 There are two ways to define a python slot function: dispatch to a
 statically defined function; or dispatch to a method defined on the
 operand.

 To dispatch to a statically defined function, use %feature("python:<slot>"),
 where <slot> is the name of a field in a PyTypeObject, PyNumberMethods,
 PyMappingMethods, PySequenceMethods, or PyBufferProcs.  For example:

   %{
   
   static long myHashFunc (PyObject *pyobj) {
     MyClass *cobj;
     // Convert pyobj to cobj
     return (cobj->field1 * (cobj->field2 << 7));
   }
   
   %}

   %feature("python:tp_hash") MyClass "myHashFunc";

 NOTE: It is the responsibility of the programmer (that's you) to ensure
 that a statically defined slot function has the correct signature.

 If, instead, you want to dispatch to an instance method, you can
 use %feature("python:slot").  For example:

   class MyClass {
     public:
       long myHashFunc () const;
       ...
   };
   
   %feature("python:slot", "tp_hash", functype="hashfunc") MyClass::myHashFunc;

 NOTE: Some python slots use a method signature which does not
 match the signature of SWIG-wrapped methods.  For those slots,
 SWIG will automatically generate a "closure" function to re-marshall
 the arguments before dispatching to the wrapped method.  Setting
 the "functype" attribute of the feature enables SWIG to generate
 a correct closure function.

 --------------------------------------------------------------

 The tp_richcompare slot is a special case: SWIG automatically generates
 a rich compare function for all wrapped types.  If a type defines C++
 operator overloads for comparison (operator==, operator<, etc.), they
 will be called from the generated rich compare function.  If you
 want to explicitly choose a method to handle a certain comparison
 operation, you may use %feature("python:slot") like this:

   class MyClass {
     public:
       bool lessThan (const MyClass& x) const;
       ...
   };
   
   %feature("python:slot", "Py_LT") MyClass::lessThan;

 ... where "Py_LT" is one of the rich comparison opcodes defined in the
 python header file object.h.

 If there's no method defined to handle a particular comparsion operation,
 the default behavior is to compare pointer values of the wrapped
 C++ objects.

 --------------------------------------------------------------


 For more information about python slots, including their names and
 signatures, you may refer to the python documentation :

   http://docs.python.org/c-api/typeobj.html

 * ------------------------------------------------------------ */


#ifdef __cplusplus

#if defined(SWIGPYTHON_BUILTIN)
#define %pybinoperator(pyname,oper,functp,slt) %rename(pyname) oper; %pythonmaybecall oper; %feature("python:slot", #slt, functype=#functp) oper; %feature("python:slot", #slt, functype=#functp) pyname;
#define %pycompare(pyname,oper,comptype) %rename(pyname) oper; %pythonmaybecall oper; %feature("python:compare", #comptype) oper; %feature("python:compare", #comptype) pyname;
#else
#define %pybinoperator(pyname,oper,functp,slt) %rename(pyname) oper; %pythonmaybecall oper
#define %pycompare(pyname,oper,comptype) %pybinoperator(pyname,oper,,comptype)
#endif

%pybinoperator(__add__,      *::operator+,		binaryfunc, nb_add);
%pybinoperator(__pos__,      *::operator+(),		unaryfunc, nb_positive);
%pybinoperator(__pos__,      *::operator+() const,	unaryfunc, nb_positive);
%pybinoperator(__sub__,      *::operator-,		binaryfunc, nb_subtract);
%pybinoperator(__neg__,      *::operator-(),		unaryfunc, nb_negative);
%pybinoperator(__neg__,      *::operator-() const,	unaryfunc, nb_negative);
%pybinoperator(__mul__,      *::operator*,		binaryfunc, nb_multiply);
%pybinoperator(__div__,      *::operator/,		binaryfunc, nb_div);
%pybinoperator(__mod__,      *::operator%,		binaryfunc, nb_remainder);
%pybinoperator(__lshift__,   *::operator<<,		binaryfunc, nb_lshift);
%pybinoperator(__rshift__,   *::operator>>,		binaryfunc, nb_rshift);
%pybinoperator(__and__,      *::operator&,		binaryfunc, nb_and);
%pybinoperator(__or__,       *::operator|,		binaryfunc, nb_or);
%pybinoperator(__xor__,      *::operator^,		binaryfunc, nb_xor);
%pycompare(__lt__,           *::operator<,		Py_LT);
%pycompare(__le__,           *::operator<=,		Py_LE);
%pycompare(__gt__,           *::operator>,		Py_GT);
%pycompare(__ge__,           *::operator>=,		Py_GE);
%pycompare(__eq__,           *::operator==,		Py_EQ);
%pycompare(__ne__,           *::operator!=,		Py_NE);

%feature("python:slot", "nb_truediv", functype="binaryfunc") *::operator/;

/* Special cases */
%rename(__invert__)     *::operator~;
%feature("python:slot", "nb_invert", functype="unaryfunc") *::operator~;
%rename(__call__)       *::operator();
%feature("python:slot", "tp_call", functype="ternarycallfunc") *::operator();

#if defined(SWIGPYTHON_BUILTIN)
%pybinoperator(__nonzero__,   *::operator bool,		inquiry, nb_nonzero);
#else
%feature("shadow")      *::operator bool %{
def __nonzero__(self):
    return $action(self)
__bool__ = __nonzero__
%};
%rename(__nonzero__)    *::operator bool;
#endif

/* Ignored operators */
%ignoreoperator(LNOT)       operator!;
%ignoreoperator(LAND)       operator&&;
%ignoreoperator(LOR)        operator||;
%ignoreoperator(EQ)         *::operator=;
%ignoreoperator(PLUSPLUS)   *::operator++;
%ignoreoperator(MINUSMINUS) *::operator--;
%ignoreoperator(ARROWSTAR)  *::operator->*;
%ignoreoperator(INDEX)      *::operator[];

/*
  Inplace operator declarations.

  They translate the inplace C++ operators (+=, -=, ...)  into the
  corresponding python equivalents(__iadd__,__isub__), etc,
  disabling the ownership of the input 'this' pointer, and assigning
  it to the returning object:  

     %feature("del") *::Operator; // disables ownership by generating SWIG_POINTER_DISOWN
     %feature("new") *::Operator; // claims ownership by generating SWIG_POINTER_OWN
  
  This makes the most common case safe, ie:

     A&  A::operator+=(int i) { ...; return *this; }
    ^^^^                                    ^^^^^^

  will work fine, even when the resulting python object shares the
  'this' pointer with the input one. The input object is usually
  deleted after the operation, including the shared 'this' pointer,
  producing 'strange' seg faults, as reported by Lucriz
  (lucriz@sitilandia.it).

  If you have an interface that already takes care of that, ie, you
  already are using inplace operators and you are not getting
  seg. faults, with the new scheme you could end with 'free' elements
  that never get deleted (maybe, not sure, it depends). But if that is
  the case, you could recover the old behaviour using

     %feature("del","0") A::operator+=;
     %feature("new","0") A::operator+=;

  which recovers the old behaviour for the class 'A', or if you are
  100% sure your entire system works fine in the old way, use:

    %feature("del","") *::operator+=;
    %feature("new","") *::operator+=;

  The default behaviour assumes that the 'this' pointer's memory is
  already owned by the SWIG object; it relinquishes ownership then
  takes it back. This may not be the case though as the SWIG object
  might be owned by memory managed elsewhere, eg after calling a
  function that returns a C++ reference. In such case you will need
  to use the features above to recover the old behaviour too.
*/

#if defined(SWIGPYTHON_BUILTIN)
#define %pyinplaceoper(SwigPyOper, Oper, functp, slt) %delobject Oper; %newobject Oper; %feature("python:slot", #slt, functype=#functp) Oper; %rename(SwigPyOper) Oper
#else
#define %pyinplaceoper(SwigPyOper, Oper, functp, slt) %delobject Oper; %newobject Oper; %rename(SwigPyOper) Oper
#endif

%pyinplaceoper(__iadd__   , *::operator +=,	binaryfunc, nb_inplace_add);
%pyinplaceoper(__isub__   , *::operator -=,	binaryfunc, nb_inplace_subtract);
%pyinplaceoper(__imul__   , *::operator *=,	binaryfunc, nb_inplace_multiply);
%pyinplaceoper(__idiv__   , *::operator /=,	binaryfunc, nb_inplace_divide);
%pyinplaceoper(__imod__   , *::operator %=,	binaryfunc, nb_inplace_remainder);
%pyinplaceoper(__iand__   , *::operator &=,	binaryfunc, nb_inplace_and);
%pyinplaceoper(__ior__    , *::operator |=,	binaryfunc, nb_inplace_or);
%pyinplaceoper(__ixor__   , *::operator ^=,	binaryfunc, nb_inplace_xor);
%pyinplaceoper(__ilshift__, *::operator <<=,	binaryfunc, nb_inplace_lshift);
%pyinplaceoper(__irshift__, *::operator >>=,	binaryfunc, nb_inplace_rshift);


/* Finally, in python we need to mark the binary operations to fail as
 'maybecall' methods */

#define %pybinopermaybecall(oper) %pythonmaybecall __ ## oper ## __;  %pythonmaybecall __r ## oper ## __

%pybinopermaybecall(add);
%pybinopermaybecall(pos);
%pybinopermaybecall(pos);
%pybinopermaybecall(sub);
%pybinopermaybecall(neg);
%pybinopermaybecall(neg);
%pybinopermaybecall(mul);
%pybinopermaybecall(div);
%pybinopermaybecall(mod);
%pybinopermaybecall(lshift);
%pybinopermaybecall(rshift);
%pybinopermaybecall(and);
%pybinopermaybecall(or);
%pybinopermaybecall(xor);
%pybinopermaybecall(lt);
%pybinopermaybecall(le);
%pybinopermaybecall(gt);
%pybinopermaybecall(ge);
%pybinopermaybecall(eq);
%pybinopermaybecall(ne);

#endif






================================================
File: swig/swigwin-3.0.8/Lib/python/pyprimtypes.swg
================================================
/* ------------------------------------------------------------
 * Primitive Types
 * ------------------------------------------------------------ */

/* boolean */

%fragment(SWIG_From_frag(bool),"header") {
SWIGINTERNINLINE PyObject*
  SWIG_From_dec(bool)(bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}
}

#ifdef SWIG_PYTHON_LEGACY_BOOL
// Default prior to SWIG 3.0.0
%fragment(SWIG_AsVal_frag(bool),"header",
	  fragment=SWIG_AsVal_frag(long)) {
SWIGINTERN int
SWIG_AsVal_dec(bool)(PyObject *obj, bool *val)
{
  int r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}
}
#else
%fragment(SWIG_AsVal_frag(bool),"header",
	  fragment=SWIG_AsVal_frag(long)) {
SWIGINTERN int
SWIG_AsVal_dec(bool)(PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}
}
#endif

/* int */

%fragment(SWIG_From_frag(int),"header") {
SWIGINTERNINLINE PyObject*
  SWIG_From_dec(int)(int value)
{
  return PyInt_FromLong((long) value);
}
}

/* unsigned int */

%fragment(SWIG_From_frag(unsigned int),"header") {
SWIGINTERNINLINE PyObject*
  SWIG_From_dec(unsigned int)(unsigned int value)
{
  return PyInt_FromSize_t((size_t) value);
}
}

/* long */

%fragment(SWIG_From_frag(long),"header") {
  %define_as(SWIG_From_dec(long),           PyLong_FromLong)
}

%fragment(SWIG_AsVal_frag(long),"header",
	  fragment="SWIG_CanCastAsInteger") {
SWIGINTERN int
SWIG_AsVal_dec(long)(PyObject *obj, long* val)
{
%#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
%#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
%#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal(double)(obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
%#endif
  return SWIG_TypeError;
}
}

/* unsigned long */

%fragment(SWIG_From_frag(unsigned long),"header",
	  fragment=SWIG_From_frag(long)) {
SWIGINTERNINLINE PyObject* 
SWIG_From_dec(unsigned long)(unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyLong_FromLong(%numeric_cast(value,long)); 
}
}

%fragment(SWIG_AsVal_frag(unsigned long),"header",
	  fragment="SWIG_CanCastAsInteger") {
SWIGINTERN int
SWIG_AsVal_dec(unsigned long)(PyObject *obj, unsigned long *val) 
{
%#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
%#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
%#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal(double)(obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
%#endif
  return SWIG_TypeError;
}
}

/* long long */

%fragment(SWIG_From_frag(long long),"header",
	  fragment=SWIG_From_frag(long),
	  fragment="<limits.h>") {
SWIGINTERNINLINE PyObject* 
SWIG_From_dec(long long)(long long value)
{
  return ((value < LONG_MIN) || (value > LONG_MAX)) ?
    PyLong_FromLongLong(value) : PyLong_FromLong(%numeric_cast(value,long)); 
}
}

%fragment(SWIG_AsVal_frag(long long),"header",
	  fragment=SWIG_AsVal_frag(long),
	  fragment="SWIG_CanCastAsInteger",
	  fragment="<limits.h>") {
SWIGINTERN int
SWIG_AsVal_dec(long long)(PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    long v;
    res = SWIG_AsVal(long)(obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
%#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal(double)(obj,&d);
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
%#endif
  return res;
}
}

/* unsigned long long */

%fragment(SWIG_From_frag(unsigned long long),"header",
	  fragment=SWIG_From_frag(long long),
	  fragment="<limits.h>") {
SWIGINTERNINLINE PyObject* 
SWIG_From_dec(unsigned long long)(unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyLong_FromLong(%numeric_cast(value,long)); 
}
}

%fragment(SWIG_AsVal_frag(unsigned long long),"header",
	  fragment=SWIG_AsVal_frag(unsigned long),
	  fragment="SWIG_CanCastAsInteger",
	  fragment="<limits.h>") {
SWIGINTERN int
SWIG_AsVal_dec(unsigned long long)(PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal(unsigned long)(obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
%#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal(double)(obj,&d);
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
%#endif
  return res;
}
}

/* double */

%fragment(SWIG_From_frag(double),"header") {
  %define_as(SWIG_From_dec(double),          PyFloat_FromDouble)
}

%fragment(SWIG_AsVal_frag(double),"header") {
SWIGINTERN int
SWIG_AsVal_dec(double)(PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
%#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
%#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
%#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
%#endif
  return res;
}
}






================================================
File: swig/swigwin-3.0.8/Lib/python/pyrun.swg
================================================
/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
# ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
# endif
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *val = NULL, *type = NULL, *tb = NULL;
      PyErr_Fetch(&val, &type, &tb);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(val, type, tb);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#elif (PY_VERSION_HEX < 0x02050000)
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#else
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyObject",               /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,				    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
#else
      (getattrfunc)0,                       /* tp_getattr */
#endif
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,				    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpyobject_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
#endif
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
      /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyPacked",               /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      (printfunc)SwigPyPacked_print,        /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpypacked_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
#endif
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

static PyObject *swig_this = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (swig_this == NULL)
    swig_this = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
    }
    if (!SWIG_IsOK(res) && obj == Py_None) {
      if (ptr)
        *ptr = 0;
      if (PyErr_Occurred())
        PyErr_Clear();
      res = SWIG_OK;
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    if (inst) {
      PyObject_SetAttr(inst, SWIG_This(), swig_this);
      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst = 0;
  PyObject *dict = PyDict_New();
  if (dict) {
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
  }
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
# ifdef SWIGPY_USE_CAPSULE
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
# else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
# endif
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
#ifdef SWIGPY_USE_CAPSULE
SWIG_Python_DestroyModule(PyObject *obj)
#else
SWIG_Python_DestroyModule(void *vptr)
#endif
{
#ifdef SWIGPY_USE_CAPSULE
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
#else
  swig_module_info *swig_module = (swig_module_info *) vptr;
#endif
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  swig_this = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
#ifdef SWIGPY_USE_CAPSULE
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#else
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#endif
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
#ifdef SWIGPY_USE_CAPSULE
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
#else
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
#endif
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
#ifdef SWIGPY_USE_CAPSULE
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
#else
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
#endif
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/pyruntime.swg
================================================
%insert(runtime) %{
#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG
#else
# include <Python.h>
#endif
%}

%insert(runtime) "swigrun.swg";         /* SWIG API */
%insert(runtime) "swigerrors.swg";      /* SWIG errors */   
%insert(runtime) "pyhead.swg";          /* Python includes and fixes */
%insert(runtime) "pyerrors.swg";        /* Python errors */
%insert(runtime) "pythreads.swg";       /* Python thread code */
%insert(runtime) "pyapi.swg";           /* Python API */
%insert(runtime) "pyrun.swg";           /* Python run-time code */

#if defined(SWIGPYTHON_BUILTIN)
%insert(runtime) "builtin.swg";		/* Specialization for classes with single inheritance */
#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/pystdcommon.swg
================================================
%fragment("StdTraits","header",fragment="StdTraitsCommon")
{
namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static PyObject *from(Type *val, int owner = 0) {
      return SWIG_InternalNewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static PyObject *from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static PyObject *from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static PyObject *from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline PyObject *from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline PyObject *from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(PyObject *obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(PyObject *obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(PyObject *obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    %delete(p);
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(PyObject *obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(PyObject *obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (!PyErr_Occurred()) {
	  ::%type_error(swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  %delete(v);
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	static Type *v_def = (Type*) malloc(sizeof(Type));
	if (!PyErr_Occurred()) {
	  %type_error(swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (!PyErr_Occurred()) {
	  %type_error(swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(PyObject *obj, bool te = false) {
    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(PyObject *obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}
}

//
// Backward compatibility
//

#ifdef SWIG_PYTHON_BACKWARD_COMP
%fragment("<string>");
%{
PyObject* SwigInt_FromBool(bool b) {
    return PyInt_FromLong(b ? 1L : 0L);
}
double SwigNumber_Check(PyObject* o) {
    return PyFloat_Check(o) || PyInt_Check(o) || PyLong_Check(o);
}
double SwigNumber_AsDouble(PyObject* o) {
    return PyFloat_Check(o) ? PyFloat_AsDouble(o)
        : (PyInt_Check(o) ?   double(PyInt_AsLong(o))
                            : double(PyLong_AsLong(o)));
}
PyObject* SwigString_FromString(const std::string& s) {
    return PyString_FromStringAndSize(s.data(),s.size());
}
std::string SwigString_AsString(PyObject* o) {
    return std::string(PyString_AsString(o));
}
%}

#endif


%define %specialize_std_container(Type,Check,As,From)
%{
namespace swig {
  template <>  struct traits_asval<Type > {   
    typedef Type value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (Check(obj)) {
	if (val) *val = As(obj);
	return SWIG_OK;
      }
      return SWIG_ERROR;
    }
  };
  template <>  struct traits_from<Type > {
    typedef Type value_type;
    static PyObject *from(const value_type& val) {
      return From(val);
    }
  };

  template <> 
  struct traits_check<Type, value_category> {
    static int check(PyObject *obj) {
      int res = Check(obj);
      return obj && res ? res : 0;
    }
  };
}
%}
%enddef


#define specialize_std_vector(Type,Check,As,From) %specialize_std_container(%arg(Type),Check,As,From)
#define specialize_std_list(Type,Check,As,From) %specialize_std_container(%arg(Type),Check,As,From)
#define specialize_std_deque(Type,Check,As,From) %specialize_std_container(%arg(Type),Check,As,From)
#define specialize_std_set(Type,Check,As,From) %specialize_std_container(%arg(Type),Check,As,From)
#define specialize_std_multiset(Type,Check,As,From) %specialize_std_container(%arg(Type),Check,As,From)
#define specialize_std_unordered_set(Type,Check,As,From) %specialize_std_container(%arg(Type),Check,As,From)
#define specialize_std_unordered_multiset(Type,Check,As,From) %specialize_std_container(%arg(Type),Check,As,From)



================================================
File: swig/swigwin-3.0.8/Lib/python/pystrings.swg
================================================
/* ------------------------------------------------------------
 *  utility methods for char strings 
 * ------------------------------------------------------------ */
%fragment("SWIG_AsCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
%#if PY_VERSION_HEX>=0x03000000
  if (PyUnicode_Check(obj))
%#else  
  if (PyString_Check(obj))
%#endif
  {
    char *cstr; Py_ssize_t len;
%#if PY_VERSION_HEX>=0x03000000
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    PyBytes_AsStringAndSize(obj, &cstr, &len);
    if(alloc) *alloc = SWIG_NEWOBJ;
%#else
    PyString_AsStringAndSize(obj, &cstr, &len);
%#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
%#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
%#else
	if (*alloc == SWIG_NEWOBJ) 
%#endif
	{
	  *cptr = %new_copy_array(cstr, len + 1, char);
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
	%#if PY_VERSION_HEX>=0x03000000
	assert(0); /* Should never reach here in Python 3 */
	%#endif
	*cptr = SWIG_Python_str_AsChar(obj);
      }
    }
    if (psize) *psize = len + 1;
%#if PY_VERSION_HEX>=0x03000000
    Py_XDECREF(obj);
%#endif
    return SWIG_OK;
  } else {
%#if defined(SWIG_PYTHON_2_UNICODE)
%#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = %new_copy_array(cstr, len + 1, char);
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
%#endif
%#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}
}

%fragment("SWIG_FromCharPtrAndSize","header",fragment="SWIG_pchar_descriptor") {
SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj(%const_cast(carray,char *), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
%#if PY_VERSION_HEX >= 0x03000000
%#if PY_VERSION_HEX >= 0x03010000
      return PyUnicode_DecodeUTF8(carray, %numeric_cast(size, Py_ssize_t), "surrogateescape");
%#else
      return PyUnicode_FromStringAndSize(carray, %numeric_cast(size, Py_ssize_t));
%#endif
%#else
      return PyString_FromStringAndSize(carray, %numeric_cast(size, Py_ssize_t));
%#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}
}




================================================
File: swig/swigwin-3.0.8/Lib/python/python.swg
================================================
/* ------------------------------------------------------------
 * python.swg
 *
 * Python configuration module.
 * ------------------------------------------------------------ */

/* ------------------------------------------------------------
 *  Inner macros
 * ------------------------------------------------------------ */
%include <pymacros.swg>


/* ------------------------------------------------------------
 *  The runtime part
 * ------------------------------------------------------------ */
%include <pyruntime.swg>

/* ------------------------------------------------------------
 *  Special user directives
 * ------------------------------------------------------------ */
%include <pyuserdir.swg>

/* ------------------------------------------------------------
 *  Typemap specializations
 * ------------------------------------------------------------ */
%include <pytypemaps.swg>

/* ------------------------------------------------------------
 *  Overloaded operator support
 * ------------------------------------------------------------ */
%include <pyopers.swg>

/* ------------------------------------------------------------
 * Warnings for Python keywords 
 * ------------------------------------------------------------ */
%include <pythonkw.swg>

/* ------------------------------------------------------------
 * The Python autodoc support
 * ------------------------------------------------------------ */
%include <pydocs.swg>

/* ------------------------------------------------------------
 * The Python classes, for C++
 * ------------------------------------------------------------ */
%include <pyclasses.swg>

/* ------------------------------------------------------------
 * The Python initialization function 
 * ------------------------------------------------------------ */
%include <pyinit.swg>


/* ------------------------------------------------------------
 * For backward compatibility
 * ------------------------------------------------------------ */
%include <pybackward.swg>





================================================
File: swig/swigwin-3.0.8/Lib/python/pythonkw.swg
================================================
/*
  Warnings for Python keywords, built-in names and bad names.
*/

#define PYTHONKW(x) %keywordwarn("'" `x` "' is a python keyword, renaming to '_" `x` "'", rename="_%s")  `x`
#define PYTHONBN(x) %builtinwarn("'" `x` "' conflicts with a built-in name in python")  `x`


/*
  Warnings for Python keywords 
  http://www.fnorb.org/docs/1.2/Fnorb-Guide/node62.html
*/

PYTHONKW(and);
PYTHONKW(assert);
PYTHONKW(break);
PYTHONKW(class);
PYTHONKW(continue);
PYTHONKW(def);
PYTHONKW(del);
PYTHONKW(elif);
PYTHONKW(else);
PYTHONKW(except);
PYTHONKW(exec);
PYTHONKW(finally);
PYTHONKW(for);
PYTHONKW(from);
PYTHONKW(global);
PYTHONKW(if);
PYTHONKW(import);
PYTHONKW(in);
PYTHONKW(is);
PYTHONKW(lambda);
PYTHONKW(not);
PYTHONKW(or);
PYTHONKW(pass);
PYTHONKW(print);
PYTHONKW(raise);
PYTHONKW(return);
PYTHONKW(try);
PYTHONKW(while);
PYTHONKW(yield);

/*
  built-in functions
  http://www.zvon.org/other/python/doc21/lib/built-in-funcs.html
 */ 

PYTHONBN(abs);
PYTHONBN(apply);
PYTHONBN(bool);
PYTHONBN(buffer);
PYTHONBN(callable);
PYTHONBN(chr);
PYTHONBN(classmethod);
PYTHONBN(cmp);
PYTHONBN(coerce);
PYTHONBN(compile);
PYTHONBN(complex);
PYTHONBN(delattr);
PYTHONBN(dict);
PYTHONBN(dir);
PYTHONBN(divmod);
PYTHONBN(enumerate);
PYTHONBN(eval);
PYTHONBN(execfile);
PYTHONBN(file);
PYTHONBN(filter);
PYTHONBN(float);
PYTHONBN(frozenset);
PYTHONBN(getattr);
PYTHONBN(globals);
PYTHONBN(hasattr);
PYTHONBN(hash);
PYTHONBN(hex);
PYTHONBN(id);
PYTHONBN(input);
PYTHONBN(int);
PYTHONBN(intern);
PYTHONBN(isinstance);
PYTHONBN(issubclass);
PYTHONBN(iter);
PYTHONBN(len);
PYTHONBN(list);
PYTHONBN(locals);
PYTHONBN(long);
PYTHONBN(map);
PYTHONBN(max);
PYTHONBN(min);
PYTHONBN(object);
PYTHONBN(oct);
PYTHONBN(open);
PYTHONBN(ord);
PYTHONBN(pow);
PYTHONBN(property);
PYTHONBN(range);
PYTHONBN(raw_input);
PYTHONBN(reduce);
PYTHONBN(reload);
PYTHONBN(repr);
PYTHONBN(reversed);
PYTHONBN(round);
PYTHONBN(set);
PYTHONBN(setattr);
PYTHONBN(slice);
PYTHONBN(sorted);
PYTHONBN(staticmethod);
PYTHONBN(str);
PYTHONBN(sum);
PYTHONBN(super);
PYTHONBN(tuple);
PYTHONBN(type);
PYTHONBN(unichr);
PYTHONBN(unicode);
PYTHONBN(vars);
PYTHONBN(xrange);
PYTHONBN(zip);


/* 
   built-in names
   boolean type and None
*/
PYTHONBN(True);
PYTHONBN(False);

PYTHONKW(None);


/* 
   'self' is also a bad Name
*/
PYTHONKW(self);

#undef PYTHONBN
#undef PYTHONKW



================================================
File: swig/swigwin-3.0.8/Lib/python/pythreads.swg
================================================
#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/pytuplehlp.swg
================================================
/*
  Helper function to return output types, now we need to use a list
  instead of a tuple since all the other types
  (std::pair,std::vector,std::list,etc) return tuples.
*/

#warning "Deprecated file: Don't use t_output_helper anymore,"
#warning "use SWIG_Python_AppendOutput  or %append_output instead."



================================================
File: swig/swigwin-3.0.8/Lib/python/pytypemaps.swg
================================================
/* ------------------------------------------------------------
 *  Typemap specializations for Python
 * ------------------------------------------------------------ */

/* ------------------------------------------------------------
 *  Fragment section
 * ------------------------------------------------------------ */
#ifdef SWIG_PYTHON_LEGACY_BOOL
// Default prior to SWIG 3.0.0
#undef SWIG_TYPECHECK_BOOL
%define SWIG_TYPECHECK_BOOL             10000 %enddef
#endif

/* Include fundamental fragment definitions */
%include <typemaps/fragments.swg>

/* Look for user fragments file. */
%include <pyfragments.swg>

/* Python fragments for fundamental types */
%include <pyprimtypes.swg>

/* Python fragments for char* strings */
%include <pystrings.swg>

/* Backward compatibility output helper */
%fragment("t_output_helper","header") %{
#define t_output_helper SWIG_Python_AppendOutput
%}


/* ------------------------------------------------------------
 *  Unified typemap section
 * ------------------------------------------------------------ */

/* directors are supported in Python */
#ifndef SWIG_DIRECTOR_TYPEMAPS
#define SWIG_DIRECTOR_TYPEMAPS
#endif


/* Python types */
#define SWIG_Object                     PyObject *
#define VOID_Object                     SWIG_Py_Void()

/* Python allows implicit conversion */
#define %implicitconv_flag              $implicitconv 


/* Overload of the output/constant/exception/dirout handling */

/* append output */
#define SWIG_AppendOutput(result, obj)  SWIG_Python_AppendOutput(result, obj)

/* set constant */
#if defined(SWIGPYTHON_BUILTIN)
#define SWIG_SetConstant(name, obj) SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, name,obj) 
#else
#define SWIG_SetConstant(name, obj) SWIG_Python_SetConstant(d, name,obj) 
#endif

/* raise */
#define SWIG_Raise(obj, type, desc)     SWIG_Python_Raise(obj, type, desc)

/* Include the unified typemap library */
%include <typemaps/swigtypemaps.swg>


/*  ------------------------------------------------------------
 *  Python extra typemaps / typemap overrides
 * ------------------------------------------------------------ */

/* Get the address of the 'python self' object */

%typemap(in,numinputs=0,noblock=1) PyObject **PYTHON_SELF {
  $1 = &$self;
}


/* Consttab, needed for callbacks, it should be removed later */

%typemap(consttab) SWIGTYPE ((*)(ANY))  
{ SWIG_PY_POINTER, (char*)"$symname", 0, 0, (void *)($value), &$descriptor }

%typemap(constcode) SWIGTYPE ((*)(ANY)) "";


/* Smart Pointers */
%typemap(out,noblock=1) const SWIGTYPE & SMARTPOINTER  {
  $result = SWIG_NewPointerObj(%new_copy(*$1, $*ltype), $descriptor, SWIG_POINTER_OWN | %newpointer_flags);
}

%typemap(ret,noblock=1) const SWIGTYPE & SMARTPOINTER, SWIGTYPE SMARTPOINTER {
  if ($result) {
    PyObject *robj = PyObject_CallMethod($result, (char *)"__deref__", NULL);
    if (robj && !PyErr_Occurred()) {
      SwigPyObject_append((PyObject *) SWIG_Python_GetSwigThis($result), 
			  (PyObject *) SWIG_Python_GetSwigThis(robj));
      Py_DECREF(robj);
    }
  }
}




================================================
File: swig/swigwin-3.0.8/Lib/python/pyuserdir.swg
================================================
/* -------------------------------------------------------------------------
 *  Special user directives
 * ------------------------------------------------------------------------- */

/* ------------------------------------------------------------------------- */

/* shadow code */
#define %shadow      %insert("shadow")
#define %pythoncode  %insert("python")
#define %pythonbegin %insert("pythonbegin")


/* ------------------------------------------------------------------------- */
/* 
Use the "nondynamic" feature to make a wrapped class behave as a "nondynamic"
one, ie, a python class that doesn't dynamically add new attributes.

For example, for the class

%pythonnondynamic A;
struct A
{
  int a;
  int b;
};

you will get:

 aa = A()
 aa.a = 1  # Ok
 aa.b = 1  # Ok
 aa.c = 3  # error

Since nondynamic is a feature, if you use it like

 %pythonnondynamic;

it will make all the wrapped classes nondynamic ones.

The implementation is based on this recipe:

   http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252158

and works for modern (-modern) and plain python. We do not use __slots__, 
so, it works with old python versions.

*/

#define %pythonnondynamic      %feature("python:nondynamic", "1")
#define %nopythonnondynamic    %feature("python:nondynamic", "0")
#define %clearpythonnondynamic %feature("python:nondynamic", "")
#define %pythondynamic         %nopythonnondynamic


/* ------------------------------------------------------------------------- */
/*

Use %pythonmaybecall to flag a method like __add__ or __radd__.  These
don't produce an error when called, they just return NotImplemented.

These methods "may be called" if needed.

*/

#define %pythonmaybecall      %feature("python:maybecall", "1") 
#define %nopythonmaybecall    %feature("python:maybecall", "0")
#define %clearpythonmaybecall %feature("python:maybecall", "")

/* ------------------------------------------------------------------------- */
/*
  The %pythoncallback feature produce a more natural callback wrapper
  than the %callback mechanism, ie, it uses the original name for
  the callback and callable objects. 

  Just use it as

    %pythoncallback(1) foo;
    int foo(int a);

    %pythoncallback(1) A::foo;
    struct A {
     static int foo(int a);
    };

    int bar(int, int (*pf)(int));

  then, you can use it as:

   a = foo(1)
   b = bar(2, foo)

   c = A.foo(3)
   d = bar(4, A.foo)


   If you use it with a member method
   %pythoncallback(1) A::foom;
   struct A {
      int foom(int a);
   };

   then you can use it as

     r = a.foom(3)             # eval the method
     mptr = A.foom_cb_ptr      # returns the callback pointer

   where the '_cb_ptr' suffix is added for the callback pointer.

*/

#define %pythoncallback      %feature("python:callback")
#define %nopythoncallback    %feature("python:callback","0")
#define %clearpythoncallback %feature("python:callback","")

/* ------------------------------------------------------------------------- */
/*
  Support for the old %callback directive name
*/
#ifdef %callback
#undef %callback
#endif

#ifdef %nocallback
#undef %nocallback
#endif

#ifdef %clearcallback
#undef %clearcallback
#endif

#define %callback(x)     %feature("python:callback",`x`)
#define %nocallback      %nopythoncallback
#define %clearcallback   %clearpythoncallback

/* ------------------------------------------------------------------------- */
/*
  Thread support - Advance control
  
*/

#define %nothread           %feature("nothread")
#define %thread             %feature("nothread","0")
#define %clearnothread      %feature("nothread","")

#define %nothreadblock      %feature("nothreadblock")
#define %threadblock        %feature("nothreadblock","0")
#define %clearnothreadblock %feature("nothreadblock","")

#define %nothreadallow      %feature("nothreadallow")
#define %threadallow        %feature("nothreadallow","0")
#define %clearnothreadallow %feature("nothreadallow","")


/* ------------------------------------------------------------------------- */
/*
  Implicit Conversion using the C++ constructor mechanism
*/

#define %implicitconv      %feature("implicitconv") 
#define %noimplicitconv    %feature("implicitconv", "0")
#define %clearimplicitconv %feature("implicitconv", "")


/* ------------------------------------------------------------------------- */
/*
  Enable keywords paramaters
*/

#define %kwargs      %feature("kwargs") 
#define %nokwargs    %feature("kwargs", "0")
#define %clearkwargs %feature("kwargs", "")

/* ------------------------------------------------------------------------- */
/*
  Add python code to the proxy/shadow code 
  
   %pythonprepend   - Add code before the C++ function is called
   %pythonappend    - Add code after the C++ function is called
*/

#define %pythonprepend       %feature("pythonprepend") 
#define %clearpythonprepend  %feature("pythonprepend","")

#define %pythonappend         %feature("pythonappend") 
#define %clearpythonappend    %feature("pythonappend","")


/* ------------------------------------------------------------------------- */
/* 
   %extend_smart_pointer extend the smart pointer support.

   For example, if you have a smart pointer as:
	    
     template <class Type> class RCPtr {
     public:
       ...
       RCPtr(Type *p);
   	Type * operator->() const;
   	...
     };
     
   you use the %extend_smart_pointer directive as:
   
     %extend_smart_pointer(RCPtr<A>);
     %template(RCPtr_A)  RCPtr<A>;
   
   then, if you have something like:

     RCPtr<A> make_ptr();
     int foo(A *);

   you can do the following:

     a = make_ptr();
     b = foo(a);

   ie, swig will accept a RCPtr<A> object where a 'A *' is
   expected.

   Also, when using vectors
   
     %extend_smart_pointer(RCPtr<A>);
     %template(RCPtr_A) RCPtr<A>;
     %template(vector_A) std::vector<RCPtr<A> >;
   	
   you can type

     a = A();
     v = vector_A(2)
     v[0] = a

   ie, an 'A *' object is accepted, via implicit conversion, 
   where a RCPtr<A> object is expected. Additionally

     x = v[0]

   returns (and sets 'x' as) a copy of v[0], making reference
   counting possible and consistent.
*/

%define %extend_smart_pointer(Type...)
%implicitconv Type;
%apply const SWIGTYPE& SMARTPOINTER { const Type& };
%apply SWIGTYPE SMARTPOINTER { Type };
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/python/pywstrings.swg
================================================
/* ------------------------------------------------------------
 *  utility methods for wchar_t strings 
 * ------------------------------------------------------------ */

%{
#if PY_VERSION_HEX >= 0x03020000
# define SWIGPY_UNICODE_ARG(obj) ((PyObject*) (obj))
#else
# define SWIGPY_UNICODE_ARG(obj) ((PyUnicodeObject*) (obj))
#endif
%}

%fragment("SWIG_AsWCharPtrAndSize","header",fragment="<wchar.h>",fragment="SWIG_pwchar_descriptor") {
SWIGINTERN int
SWIG_AsWCharPtrAndSize(PyObject *obj, wchar_t **cptr, size_t *psize, int *alloc)
{
  PyObject *tmp = 0;
  int isunicode = PyUnicode_Check(obj);
%#if PY_VERSION_HEX < 0x03000000
  if (!isunicode && PyString_Check(obj)) {
    obj = tmp = PyUnicode_FromObject(obj);
    isunicode = 1;
  }
%#endif
  if (isunicode) {
    Py_ssize_t len = PyUnicode_GetSize(obj);
    if (cptr) {
      *cptr = %new_array(len + 1, wchar_t);
      PyUnicode_AsWideChar(SWIGPY_UNICODE_ARG(obj), *cptr, len);
      (*cptr)[len] = 0;
    }
    if (psize) *psize = (size_t) len + 1;
    if (alloc) *alloc = cptr ? SWIG_NEWOBJ : 0;
    Py_XDECREF(tmp);
    return SWIG_OK;
  } else {
    swig_type_info* pwchar_descriptor = SWIG_pwchar_descriptor();
    if (pwchar_descriptor) {
      void * vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pwchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (wchar_t *)vptr;
	if (psize) *psize = vptr ? (wcslen((wchar_t *)vptr) + 1) : 0;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}
}

%fragment("SWIG_FromWCharPtrAndSize","header",fragment="<wchar.h>",fragment="SWIG_pwchar_descriptor") {
SWIGINTERNINLINE PyObject *
SWIG_FromWCharPtrAndSize(const wchar_t * carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pwchar_descriptor = SWIG_pwchar_descriptor();
      return pwchar_descriptor ? 
	SWIG_InternalNewPointerObj(%const_cast(carray,wchar_t *), pwchar_descriptor, 0) : SWIG_Py_Void();
    } else {
      return PyUnicode_FromWideChar(carray, %numeric_cast(size, Py_ssize_t));
    }
  } else {
    return SWIG_Py_Void();
  }
}
}





================================================
File: swig/swigwin-3.0.8/Lib/python/std_alloc.i
================================================
%include <std/std_alloc.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_array.i
================================================
/*
  std::array
*/

%fragment("StdArrayTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class T, size_t N>
    struct traits_asptr<std::array<T, N> >  {
      static int asptr(PyObject *obj, std::array<T, N> **vec) {
	return traits_asptr_stdseq<std::array<T, N> >::asptr(obj, vec);
      }
    };

    template <class T, size_t N>
    struct traits_from<std::array<T, N> > {
      static PyObject *from(const std::array<T, N>& vec) {
	return traits_from_stdseq<std::array<T, N> >::from(vec);
      }
    };

    template <class SwigPySeq, class T, size_t N>
    inline void
    assign(const SwigPySeq& swigpyseq, std::array<T, N>* seq) {
      if (swigpyseq.size() < seq->size())
        throw std::invalid_argument("std::array cannot be expanded in size");
      else if (swigpyseq.size() > seq->size())
        throw std::invalid_argument("std::array cannot be reduced in size");
      std::copy(swigpyseq.begin(), swigpyseq.end(), seq->begin());
    }

    template <class T, size_t N>
    inline void
    erase(std::array<T, N>* SWIGUNUSEDPARM(seq), const typename std::array<T, N>::iterator& SWIGUNUSEDPARM(position)) {
      throw std::invalid_argument("std::array object does not support item deletion");
    }

    // Only limited slicing is supported as std::array is fixed in size
    template <class T, size_t N, class Difference>
    inline std::array<T, N>*
    getslice(const std::array<T, N>* self, Difference i, Difference j, Py_ssize_t step) {
      typedef std::array<T, N> Sequence;
      typename Sequence::size_type size = self->size();
      Difference ii = 0;
      Difference jj = 0;
      swig::slice_adjust(i, j, step, size, ii, jj);

      if (step == 1 && ii == 0 && jj == size) {
        Sequence *sequence = new Sequence();
        std::copy(self->begin(), self->end(), sequence->begin());
        return sequence;
      } else if (step == -1 && ii == (size - 1) && jj == -1) {
        Sequence *sequence = new Sequence();
        std::copy(self->rbegin(), self->rend(), sequence->begin());
        return sequence;
      } else {
        throw std::invalid_argument("std::array object only supports getting a slice that is the size of the array");
      }
    }

    template <class T, size_t N, class Difference, class InputSeq>
    inline void
    setslice(std::array<T, N>* self, Difference i, Difference j, Py_ssize_t step, const InputSeq& is = InputSeq()) {
      typedef std::array<T, N> Sequence;
      typename Sequence::size_type size = self->size();
      Difference ii = 0;
      Difference jj = 0;
      swig::slice_adjust(i, j, step, size, ii, jj, true);

      if (step == 1 && ii == 0 && jj == size) {
        std::copy(is.begin(), is.end(), self->begin());
      } else if (step == -1 && ii == (size - 1) && jj == -1) {
        std::copy(is.rbegin(), is.rend(), self->begin());
      } else {
        throw std::invalid_argument("std::array object only supports setting a slice that is the size of the array");
      }
    }

    template <class T, size_t N, class Difference>
    inline void
    delslice(std::array<T, N>* SWIGUNUSEDPARM(self), Difference SWIGUNUSEDPARM(i), Difference SWIGUNUSEDPARM(j), Py_ssize_t SWIGUNUSEDPARM(step)) {
      throw std::invalid_argument("std::array object does not support item deletion");
    }
  }
%}

#define %swig_array_methods(Type...) %swig_sequence_methods_non_resizable(Type)
#define %swig_array_methods_val(Type...) %swig_sequence_methods_non_resizable_val(Type);

%include <std/std_array.i>




================================================
File: swig/swigwin-3.0.8/Lib/python/std_auto_ptr.i
================================================
/*
    The typemaps here allow to handle functions returning std::auto_ptr<>,
    which is the most common use of this type. If you have functions taking it
    as parameter, these typemaps can't be used for them and you need to do
    something else (e.g. use shared_ptr<> which SWIG supports fully).
 */

%define %auto_ptr(TYPE)
%typemap (out) std::auto_ptr<TYPE > %{
   %set_output(SWIG_NewPointerObj($1.release(), $descriptor(TYPE *), SWIG_POINTER_OWN | %newpointer_flags));
%}
%template() std::auto_ptr<TYPE >;
%enddef

namespace std {
   template <class T> class auto_ptr {};
} 



================================================
File: swig/swigwin-3.0.8/Lib/python/std_basic_string.i
================================================
#if !defined(SWIG_STD_STRING) 
#define SWIG_STD_BASIC_STRING

%include <pycontainer.swg>

#define %swig_basic_string(Type...)  %swig_sequence_methods_val(Type)


%fragment(SWIG_AsPtr_frag(std::basic_string<char>),"header",
	  fragment="SWIG_AsCharPtrAndSize") {
SWIGINTERN int
SWIG_AsPtr(std::basic_string<char>)(PyObject* obj, std::string **val)
{
  static swig_type_info* string_info = 
    SWIG_TypeQuery("std::basic_string<char> *");
  std::string *vptr;    
  if (SWIG_ConvertPtr(obj, (void**)&vptr, string_info, 0) == SWIG_OK) {
    if (val) *val = vptr;
    return SWIG_OLDOBJ;
  } else {
    PyErr_Clear();
    char* buf = 0 ; size_t size = 0; int alloc = 0;
    if (SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc) == SWIG_OK) {
      if (buf) {
	if (val) *val = new std::string(buf, size - 1);
	if (alloc == SWIG_NEWOBJ) %delete_array(buf);
	return SWIG_NEWOBJ;
      }
    } else {
      PyErr_Clear();
    }  
    if (val) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      PyErr_SetString(PyExc_TypeError,"a string is expected");
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    return 0;
  }
}  
}

%fragment(SWIG_From_frag(std::basic_string<char>),"header",
	  fragment="SWIG_FromCharPtrAndSize") {
SWIGINTERNINLINE PyObject*
  SWIG_From(std::basic_string<char>)(const std::string& s)
  {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  }
}

%include <std/std_basic_string.i>
%typemaps_asptrfromn(%checkcode(STRING), std::basic_string<char>);

#endif


#if !defined(SWIG_STD_WSTRING)

%fragment(SWIG_AsPtr_frag(std::basic_string<wchar_t>),"header",
	  fragment="SWIG_AsWCharPtrAndSize") {
SWIGINTERN int
  SWIG_AsPtr(std::basic_string<wchar_t>)(PyObject* obj, std::wstring **val)
  {
    static swig_type_info* string_info = 
      SWIG_TypeQuery("std::basic_string<wchar_t> *");
    std::wstring *vptr;    
    if (SWIG_ConvertPtr(obj, (void**)&vptr, string_info, 0) == SWIG_OK) {
      if (val) *val = vptr;
      return SWIG_OLDOBJ;
    } else {
      PyErr_Clear();
      wchar_t *buf = 0 ; size_t size = 0; int alloc = 0;
      if (SWIG_AsWCharPtrAndSize(obj, &buf, &size, &alloc) == SWIG_OK) {
	if (buf) {
	  if (val) *val = new std::wstring(buf, size - 1);
	  if (alloc == SWIG_NEWOBJ) %delete_array(buf);
	  return SWIG_NEWOBJ;
	}
      } else {
	PyErr_Clear();
      }  
      if (val) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	PyErr_SetString(PyExc_TypeError,"a wstring is expected");
	SWIG_PYTHON_THREAD_END_BLOCK;
      }
      return 0;
    }
  }
}

%fragment(SWIG_From_frag(std::basic_string<wchar_t>),"header",
	  fragment="SWIG_FromWCharPtrAndSize") {
SWIGINTERNINLINE PyObject*
  SWIG_From(std::basic_string<wchar_t>)(const std::wstring& s)
  {
    return SWIG_FromWCharPtrAndSize(s.data(), s.size());
  }
}

%typemaps_asptrfromn(%checkcode(UNISTRING), std::basic_string<wchar_t>);

#endif



================================================
File: swig/swigwin-3.0.8/Lib/python/std_carray.i
================================================
%include <pycontainer.swg>


%fragment("StdCarrayTraits","header",fragment="StdSequenceTraits")
{
namespace swig {
  template <class T, size_t S>
  struct traits_asptr<std::carray<T, S> >  {
    static int asptr(PyObject *obj, std::carray<T, S> **array) {
      return traits_asptr_stdseq<std::carray<T, S> >::asptr(obj, array);
    }
  };
}
}

%warnfilter(SWIGWARN_IGNORE_OPERATOR_INDEX) std::carray::operator[];

%extend std::carray {
  %fragment(SWIG_Traits_frag(std::carray<_Type, _Size >), "header",
	    fragment="SwigPyIterator_T",
	    fragment=SWIG_Traits_frag(_Type),
	    fragment="StdCarrayTraits") {
    namespace swig {
      template <>  struct traits<std::carray<_Type, _Size > > {
	typedef pointer_category category;
	static const char* type_name() {
	  return "std::carray<" #_Type "," #_Size " >";
	}
      };
    }
  }
  
  %typemaps_asptr(SWIG_TYPECHECK_VECTOR, swig::asptr,
		  SWIG_Traits_frag(std::carray<_Type, _Size >),
		  std::carray<_Type, _Size >);

  %typemap(out,noblock=1) iterator, const_iterator {
    $result = SWIG_NewPointerObj(swig::make_output_iterator((const $type &)$1),
				 swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  }
  
  inline size_t __len__() const { return self->size(); }
  
  inline const _Type& __getitem__(size_t i) const { return (*self)[i]; }
  
  inline void __setitem__(size_t i, const _Type& v) { (*self)[i] = v; }

  
  swig::SwigPyIterator* __iter__(PyObject **PYTHON_SELF) {
    return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
  }
}

%include <std/std_carray.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_char_traits.i
================================================
%include <std/std_char_traits.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_common.i
================================================
%include <std/std_except.i>
%include <pystdcommon.swg>


/*
  Generate the traits for a 'primitive' type, such as 'double',
  for which the SWIG_AsVal and SWIG_From methods are already defined.
*/

%define %traits_ptypen(Type...)
  %fragment(SWIG_Traits_frag(Type),"header",
	    fragment=SWIG_AsVal_frag(Type),
	    fragment=SWIG_From_frag(Type),
	    fragment="StdTraits") {
namespace swig {
  template <> struct traits< Type > {
    typedef value_category category;
    static const char* type_name() { return  #Type; }
  };
  template <>  struct traits_asval< Type > {
    typedef Type value_type;
    static int asval(PyObject *obj, value_type *val) {
      return SWIG_AsVal(Type)(obj, val);
    }
  };
  template <>  struct traits_from< Type > {
    typedef Type value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From(Type)(val);
    }
  };
}
}
%enddef

/* Traits for enums. This is bit of a sneaky trick needed because a generic template specialization of enums
   is not possible (unless using template meta-programming which SWIG doesn't support because of the explicit
   instantiations required using %template). The STL containers define the 'front' method and the typemap
   below is used whenever the front method is wrapped returning an enum. This typemap simply picks up the
   standard enum typemap, but additionally drags in a fragment containing the traits_asval and traits_from
   required in the generated code for enums. */

%define %traits_enum(Type...)
  %fragment("SWIG_Traits_enum_"{Type},"header",
	    fragment=SWIG_AsVal_frag(int),
	    fragment=SWIG_From_frag(int),
	    fragment="StdTraits") {
namespace swig {
  template <>  struct traits_asval< Type > {
    typedef Type value_type;
    static int asval(PyObject *obj, value_type *val) {
      return SWIG_AsVal(int)(obj, (int *)val);
    }
  };
  template <>  struct traits_from< Type > {
    typedef Type value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From(int)((int)val);
    }
  };
}
}
%typemap(out, fragment="SWIG_Traits_enum_"{Type}) const enum SWIGTYPE& front %{$typemap(out, const enum SWIGTYPE&)%}
%enddef


%include <std/std_common.i>

//
// Generates the traits for all the known primitive
// C++ types (int, double, ...)
//
%apply_cpptypes(%traits_ptypen);




================================================
File: swig/swigwin-3.0.8/Lib/python/std_complex.i
================================================
/*
 *  STD C++ complex typemaps
 */

%include <pycomplex.swg>

%{
#include <complex> 
%}

/* defining the complex as/from converters */

%swig_cplxdbl_convn(std::complex<double>, std::complex<double>, std::real, std::imag)
%swig_cplxflt_convn(std::complex<float>,  std::complex<float>,  std::real, std::imag)

/* defining the typemaps */

%typemaps_primitive(%checkcode(CPLXDBL), std::complex<double>);
%typemaps_primitive(%checkcode(CPLXFLT), std::complex<float>);






================================================
File: swig/swigwin-3.0.8/Lib/python/std_container.i
================================================
%include <pycontainer.swg>
%include <std/std_container.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_deque.i
================================================
/*
  Deques
*/

%fragment("StdDequeTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class T>
    struct traits_asptr<std::deque<T> >  {
      static int asptr(PyObject *obj, std::deque<T>  **vec) {
	return traits_asptr_stdseq<std::deque<T> >::asptr(obj, vec);
      }
    };

    template <class T>
    struct traits_from<std::deque<T> > {
      static PyObject *from(const std::deque<T> & vec) {
	return traits_from_stdseq<std::deque<T> >::from(vec);
      }
    };
  }
%}

#define %swig_deque_methods(Type...) %swig_sequence_methods(Type)
#define %swig_deque_methods_val(Type...) %swig_sequence_methods_val(Type);

%include <std/std_deque.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_except.i
================================================
%include <typemaps/std_except.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_ios.i
================================================
%rename(ios_base_in) std::ios_base::in;

%include <std/std_ios.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_iostream.i
================================================
namespace std
{
%callback(1) endl;
%callback(1) ends;
%callback(1) flush;
}

%include <std/std_iostream.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_list.i
================================================
/*
  Lists
*/

%fragment("StdListTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class T >
    struct traits_asptr<std::list<T> >  {
      static int asptr(PyObject *obj, std::list<T> **lis) {
	return traits_asptr_stdseq<std::list<T> >::asptr(obj, lis);
      }
    };

    template <class T>
    struct traits_from<std::list<T> > {
      static PyObject *from(const std::list<T> & vec) {
	return traits_from_stdseq<std::list<T> >::from(vec);
      }
    };
  }
%}

#define %swig_list_methods(Type...) %swig_sequence_methods(Type)
#define %swig_list_methods_val(Type...) %swig_sequence_methods_val(Type);

%include <std/std_list.i>




================================================
File: swig/swigwin-3.0.8/Lib/python/std_map.i
================================================
/*
  Maps
*/

%fragment("StdMapCommonTraits","header",fragment="StdSequenceTraits")
{
  namespace swig {
    template <class ValueType>
    struct from_key_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.first);
      }
    };

    template <class ValueType>
    struct from_value_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.second);
      }
    };

    template<class OutIterator, class FromOper, class ValueType = typename OutIterator::value_type>
    struct SwigPyMapIterator_T : SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper>
    {
      SwigPyMapIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyIteratorClosed_T<OutIterator,ValueType,FromOper>(curr, first, last, seq)
      {
      }
    };


    template<class OutIterator,
	     class FromOper = from_key_oper<typename OutIterator::value_type> >
    struct SwigPyMapKeyIterator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapKeyIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_key_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapKeyIterator_T<OutIter>(current, begin, end, seq);
    }

    template<class OutIterator,
	     class FromOper = from_value_oper<typename OutIterator::value_type> >
    struct SwigPyMapValueITerator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapValueITerator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };
    

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_value_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapValueITerator_T<OutIter>(current, begin, end, seq);
    }
  }
}

%fragment("StdMapTraits","header",fragment="StdMapCommonTraits")
{
  namespace swig {
    template <class SwigPySeq, class K, class T, class Compare, class Alloc >
    inline void
    assign(const SwigPySeq& swigpyseq, std::map<K,T,Compare,Alloc > *map) {
      typedef typename std::map<K,T,Compare,Alloc >::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	map->insert(value_type(it->first, it->second));
      }
    }

    template <class K, class T, class Compare, class Alloc>
    struct traits_asptr<std::map<K,T,Compare,Alloc > >  {
      typedef std::map<K,T,Compare,Alloc > map_type;
      static int asptr(PyObject *obj, map_type **val) {
	int res = SWIG_ERROR;
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	if (PyDict_Check(obj)) {
	  SwigVar_PyObject items = PyObject_CallMethod(obj,(char *)"items",NULL);
%#if PY_VERSION_HEX >= 0x03000000
          /* In Python 3.x the ".items()" method returns a dict_items object */
          items = PySequence_Fast(items, ".items() didn't return a sequence!");
%#endif
	  res = traits_asptr_stdseq<map_type, std::pair<K, T> >::asptr(items, val);
	} else {
	  map_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<map_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	SWIG_PYTHON_THREAD_END_BLOCK;
	return res;
      }      
    };
      
    template <class K, class T, class Compare, class Alloc >
    struct traits_from<std::map<K,T,Compare,Alloc > >  {
      typedef std::map<K,T,Compare,Alloc > map_type;
      typedef typename map_type::const_iterator const_iterator;
      typedef typename map_type::size_type size_type;

      static PyObject *asdict(const map_type& map) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	size_type size = map.size();
	Py_ssize_t pysize = (size <= (size_type) INT_MAX) ? (Py_ssize_t) size : -1;
	if (pysize < 0) {
	  PyErr_SetString(PyExc_OverflowError, "map size not valid in python");
	  SWIG_PYTHON_THREAD_END_BLOCK;
	  return NULL;
	}
	PyObject *obj = PyDict_New();
	for (const_iterator i= map.begin(); i!= map.end(); ++i) {
	  swig::SwigVar_PyObject key = swig::from(i->first);
	  swig::SwigVar_PyObject val = swig::from(i->second);
	  PyDict_SetItem(obj, key, val);
	}
	SWIG_PYTHON_THREAD_END_BLOCK;
	return obj;
      }
                
      static PyObject *from(const map_type& map) {
	swig_type_info *desc = swig::type_info<map_type>();
	if (desc && desc->clientdata) {
	  return SWIG_InternalNewPointerObj(new map_type(map), desc, SWIG_POINTER_OWN);
	} else {
	  return asdict(map);
	}
      }
    };
  }
}

%define %swig_map_common(Map...)
  %swig_sequence_iterator(Map);
  %swig_container_methods(Map)

#if defined(SWIGPYTHON_BUILTIN)
  %feature("python:slot", "mp_length", functype="lenfunc") __len__;
  %feature("python:slot", "mp_subscript", functype="binaryfunc") __getitem__;
  %feature("python:slot", "tp_iter", functype="getiterfunc") key_iterator;

  %extend {
    %newobject iterkeys(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* iterkeys(PyObject **PYTHON_SELF) {
      return swig::make_output_key_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }
      
    %newobject itervalues(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* itervalues(PyObject **PYTHON_SELF) {
      return swig::make_output_value_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %newobject iteritems(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* iteritems(PyObject **PYTHON_SELF) {
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }
  }

#else
  %extend {
    %pythoncode %{def __iter__(self):
    return self.key_iterator()%}
    %pythoncode %{def iterkeys(self):
    return self.key_iterator()%}
    %pythoncode %{def itervalues(self):
    return self.value_iterator()%}
    %pythoncode %{def iteritems(self):
    return self.iterator()%}
  }
#endif

  %extend {
    mapped_type const & __getitem__(const key_type& key) throw (std::out_of_range) {
      Map::const_iterator i = self->find(key);
      if (i != self->end())
	return i->second;
      else
	throw std::out_of_range("key not found");
    }

    void __delitem__(const key_type& key) throw (std::out_of_range) {
      Map::iterator i = self->find(key);
      if (i != self->end())
	self->erase(i);
      else
	throw std::out_of_range("key not found");
    }
    
    bool has_key(const key_type& key) const {
      Map::const_iterator i = self->find(key);
      return i != self->end();
    }
    
    PyObject* keys() {
      Map::size_type size = self->size();
      Py_ssize_t pysize = (size <= (Map::size_type) INT_MAX) ? (Py_ssize_t) size : -1;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (pysize < 0) {
	PyErr_SetString(PyExc_OverflowError, "map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }
      PyObject* keyList = PyList_New(pysize);
      Map::const_iterator i = self->begin();
      for (Py_ssize_t j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(keyList, j, swig::from(i->first));
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return keyList;
    }
    
    PyObject* values() {
      Map::size_type size = self->size();
      Py_ssize_t pysize = (size <= (Map::size_type) INT_MAX) ? (Py_ssize_t) size : -1;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (pysize < 0) {
	PyErr_SetString(PyExc_OverflowError, "map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }
      PyObject* valList = PyList_New(pysize);
      Map::const_iterator i = self->begin();
      for (Py_ssize_t j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(valList, j, swig::from(i->second));
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return valList;
    }
    
    PyObject* items() {
      Map::size_type size = self->size();
      Py_ssize_t pysize = (size <= (Map::size_type) INT_MAX) ? (Py_ssize_t) size : -1;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (pysize < 0) {
	PyErr_SetString(PyExc_OverflowError, "map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }    
      PyObject* itemList = PyList_New(pysize);
      Map::const_iterator i = self->begin();
      for (Py_ssize_t j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(itemList, j, swig::from(*i));
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return itemList;
    }
    
    // Python 2.2 methods
    bool __contains__(const key_type& key) {
      return self->find(key) != self->end();
    }

    %newobject key_iterator(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* key_iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_key_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %newobject value_iterator(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* value_iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_value_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }
  }

%enddef

%define %swig_map_methods(Map...)
  %swig_map_common(Map)

#if defined(SWIGPYTHON_BUILTIN)
  %feature("python:slot", "mp_ass_subscript", functype="objobjargproc") __setitem__;
#endif

  %extend {
    // This will be called through the mp_ass_subscript slot to delete an entry.
    void __setitem__(const key_type& key) {
      self->erase(key);
    }

    void __setitem__(const key_type& key, const mapped_type& x) throw (std::out_of_range) {
      (*self)[key] = x;
    }

    PyObject* asdict() {
      return swig::traits_from< Map >::asdict(*self);
    }
  }


%enddef


%include <std/std_map.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_multimap.i
================================================
/*
  Multimaps
*/
%include <std_map.i>

%fragment("StdMultimapTraits","header",fragment="StdMapCommonTraits")
{
  namespace swig {
    template <class SwigPySeq, class K, class T >
    inline void 
    assign(const SwigPySeq& swigpyseq, std::multimap<K,T > *multimap) {
      typedef typename std::multimap<K,T>::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	multimap->insert(value_type(it->first, it->second));
      }
    }

    template <class K, class T>
    struct traits_asptr<std::multimap<K,T> >  {
      typedef std::multimap<K,T> multimap_type;
      static int asptr(PyObject *obj, std::multimap<K,T> **val) {
	int res = SWIG_ERROR;
	if (PyDict_Check(obj)) {
	  SwigVar_PyObject items = PyObject_CallMethod(obj,(char *)"items",NULL);
	  return traits_asptr_stdseq<std::multimap<K,T>, std::pair<K, T> >::asptr(items, val);
	} else {
	  multimap_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<multimap_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }
    };
      
    template <class K, class T >
    struct traits_from<std::multimap<K,T> >  {
      typedef std::multimap<K,T> multimap_type;
      typedef typename multimap_type::const_iterator const_iterator;
      typedef typename multimap_type::size_type size_type;
            
      static PyObject *from(const multimap_type& multimap) {
	swig_type_info *desc = swig::type_info<multimap_type>();
	if (desc && desc->clientdata) {
	  return SWIG_InternalNewPointerObj(new multimap_type(multimap), desc, SWIG_POINTER_OWN);
	} else {
	  size_type size = multimap.size();
	  Py_ssize_t pysize = (size <= (size_type) INT_MAX) ? (Py_ssize_t) size : -1;
	  if (pysize < 0) {
	    SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	    PyErr_SetString(PyExc_OverflowError, "multimap size not valid in python");
	    SWIG_PYTHON_THREAD_END_BLOCK;
	    return NULL;
	  }
	  PyObject *obj = PyDict_New();
	  for (const_iterator i= multimap.begin(); i!= multimap.end(); ++i) {
	    swig::SwigVar_PyObject key = swig::from(i->first);
	    swig::SwigVar_PyObject val = swig::from(i->second);
	    PyDict_SetItem(obj, key, val);
	  }
	  return obj;
	}
      }
    };
  }
}

%define %swig_multimap_methods(Type...) 
  %swig_map_common(Type);
  %extend {
    void __setitem__(const key_type& key, const mapped_type& x) throw (std::out_of_range) {
      self->insert(Type::value_type(key,x));
    }
  }
%enddef

%include <std/std_multimap.i>




================================================
File: swig/swigwin-3.0.8/Lib/python/std_multiset.i
================================================
/*
  Multisets
*/

%include <std_set.i>

%fragment("StdMultisetTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class SwigPySeq, class T> 
    inline void
    assign(const SwigPySeq& swigpyseq, std::multiset<T>* seq) {
      // seq->insert(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
      typedef typename SwigPySeq::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	seq->insert(seq->end(),(value_type)(*it));
      }
    }

    template <class T>
    struct traits_asptr<std::multiset<T> >  {
      static int asptr(PyObject *obj, std::multiset<T> **m) {
	return traits_asptr_stdseq<std::multiset<T> >::asptr(obj, m);
      }
    };

    template <class T>
    struct traits_from<std::multiset<T> > {
      static PyObject *from(const std::multiset<T>& vec) {
	return traits_from_stdseq<std::multiset<T> >::from(vec);
      }
    };
  }
%}

#define %swig_multiset_methods(Set...) %swig_set_methods(Set)



%include <std/std_multiset.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_pair.i
================================================
/*
  Pairs
*/
%include <pystdcommon.swg>

//#define SWIG_STD_PAIR_ASVAL

%fragment("StdPairTraits","header",fragment="StdTraits") {
  namespace swig {
#ifdef SWIG_STD_PAIR_ASVAL
    template <class T, class U >
    struct traits_asval<std::pair<T,U> >  {
      typedef std::pair<T,U> value_type;

      static int get_pair(PyObject* first, PyObject* second,
			  std::pair<T,U> *val)
      {
	if (val) {
	  T *pfirst = &(val->first);
	  int res1 = swig::asval((PyObject*)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = &(val->second);
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	} else {
	  T *pfirst = 0;
	  int res1 = swig::asval((PyObject*)first, 0);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = 0;
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	}	
      }

      static int asval(PyObject *obj, std::pair<T,U> *val) {
	int res = SWIG_ERROR;
	if (PyTuple_Check(obj)) {
	  if (PyTuple_GET_SIZE(obj) == 2) {
	    res = get_pair(PyTuple_GET_ITEM(obj,0),PyTuple_GET_ITEM(obj,1), val);
	  }
	} else if (PySequence_Check(obj)) {
	  if (PySequence_Size(obj) == 2) {
	    swig::SwigVar_PyObject first = PySequence_GetItem(obj,0);
	    swig::SwigVar_PyObject second = PySequence_GetItem(obj,1);
	    res = get_pair(first, second, val);
	  }
	} else {
	  value_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<value_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = *p;
	}
	return res;
      }
    };

#else
    template <class T, class U >
    struct traits_asptr<std::pair<T,U> >  {
      typedef std::pair<T,U> value_type;

      static int get_pair(PyObject* first, PyObject* second,
			  std::pair<T,U> **val) 
      {
	if (val) {
	  value_type *vp = %new_instance(std::pair<T,U>);
	  T *pfirst = &(vp->first);
	  int res1 = swig::asval((PyObject*)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = &(vp->second);
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  *val = vp;
	  return SWIG_AddNewMask(res1 > res2 ? res1 : res2);
	} else {
	  T *pfirst = 0;
	  int res1 = swig::asval((PyObject*)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = 0;
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	}	
      }

      static int asptr(PyObject *obj, std::pair<T,U> **val) {
	int res = SWIG_ERROR;
	if (PyTuple_Check(obj)) {
	  if (PyTuple_GET_SIZE(obj) == 2) {
	    res = get_pair(PyTuple_GET_ITEM(obj,0),PyTuple_GET_ITEM(obj,1), val);
	  }
	} else if (PySequence_Check(obj)) {
	  if (PySequence_Size(obj) == 2) {
	    swig::SwigVar_PyObject first = PySequence_GetItem(obj,0);
	    swig::SwigVar_PyObject second = PySequence_GetItem(obj,1);
	    res = get_pair(first, second, val);
	  }
	} else {
	  value_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<value_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }
    };

#endif
    template <class T, class U >
    struct traits_from<std::pair<T,U> >   {
      static PyObject *from(const std::pair<T,U>& val) {
	PyObject* obj = PyTuple_New(2);
	PyTuple_SetItem(obj,0,swig::from(val.first));
	PyTuple_SetItem(obj,1,swig::from(val.second));
	return obj;
      }
    };
  }

#if defined(SWIGPYTHON_BUILTIN)
SWIGINTERN Py_ssize_t
SwigPython_std_pair_len (PyObject *a)
{
    return 2;
}

SWIGINTERN PyObject*
SwigPython_std_pair_repr (PyObject *o)
{
    PyObject *tuple = PyTuple_New(2);
    assert(tuple);
    PyTuple_SET_ITEM(tuple, 0, PyObject_GetAttrString(o, (char*) "first"));
    PyTuple_SET_ITEM(tuple, 1, PyObject_GetAttrString(o, (char*) "second"));
    PyObject *result = PyObject_Repr(tuple);
    Py_DECREF(tuple);
    return result;
}

SWIGINTERN PyObject*
SwigPython_std_pair_getitem (PyObject *a, Py_ssize_t b)
{
    PyObject *result = PyObject_GetAttrString(a, b % 2 ? (char*) "second" : (char*) "first");
    return result;
}

SWIGINTERN int
SwigPython_std_pair_setitem (PyObject *a, Py_ssize_t b, PyObject *c)
{
    int result = PyObject_SetAttrString(a, b % 2 ? (char*) "second" : (char*) "first", c);
    return result;
}
#endif

}

%feature("python:sq_length") std::pair "SwigPython_std_pair_len";
%feature("python:sq_length") std::pair<T*,U> "SwigPython_std_pair_len";
%feature("python:sq_length") std::pair<T,U*> "SwigPython_std_pair_len";
%feature("python:sq_length") std::pair<T*,U*> "SwigPython_std_pair_len";

%feature("python:tp_repr") std::pair "SwigPython_std_pair_repr";
%feature("python:tp_repr") std::pair<T*,U> "SwigPython_std_pair_repr";
%feature("python:tp_repr") std::pair<T,U*> "SwigPython_std_pair_repr";
%feature("python:tp_repr") std::pair<T*,U*> "SwigPython_std_pair_repr";

%feature("python:sq_item") std::pair "SwigPython_std_pair_getitem";
%feature("python:sq_item") std::pair<T*,U> "SwigPython_std_pair_getitem";
%feature("python:sq_item") std::pair<T,U*> "SwigPython_std_pair_getitem";
%feature("python:sq_item") std::pair<T*,U*> "SwigPython_std_pair_getitem";

%feature("python:sq_ass_item") std::pair "SwigPython_std_pair_setitem";
%feature("python:sq_ass_item") std::pair<T*,U> "SwigPython_std_pair_setitem";
%feature("python:sq_ass_item") std::pair<T,U*> "SwigPython_std_pair_setitem";
%feature("python:sq_ass_item") std::pair<T*,U*> "SwigPython_std_pair_setitem";

%define %swig_pair_methods(pair...)
#if !defined(SWIGPYTHON_BUILTIN)
%extend {      
%pythoncode %{def __len__(self):
    return 2
def __repr__(self):
    return str((self.first, self.second))
def __getitem__(self, index): 
    if not (index % 2):
        return self.first
    else:
        return self.second
def __setitem__(self, index, val):
    if not (index % 2):
        self.first = val
    else:
        self.second = val%}
}
#endif
%enddef

%include <std/std_pair.i>




================================================
File: swig/swigwin-3.0.8/Lib/python/std_set.i
================================================
/*
  Sets
*/

%fragment("StdSetTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class SwigPySeq, class T> 
    inline void 
    assign(const SwigPySeq& swigpyseq, std::set<T>* seq) {
      // seq->insert(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
      typedef typename SwigPySeq::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	seq->insert(seq->end(),(value_type)(*it));
      }
    }

    template <class T>
    struct traits_asptr<std::set<T> >  {
      static int asptr(PyObject *obj, std::set<T> **s) {
	return traits_asptr_stdseq<std::set<T> >::asptr(obj, s);
      }
    };

    template <class T>
    struct traits_from<std::set<T> > {
      static PyObject *from(const std::set<T>& vec) {
	return traits_from_stdseq<std::set<T> >::from(vec);
      }
    };
  }
%}

%define %swig_set_methods(set...)
  %swig_sequence_iterator(set);
  %swig_container_methods(set);

  %extend  {
     void append(value_type x) {
       self->insert(x);
     }
  
     bool __contains__(value_type x) {
       return self->find(x) != self->end();
     }

     value_type __getitem__(difference_type i) const throw (std::out_of_range) {
       return *(swig::cgetpos(self, i));
     }

     void add(value_type x) {
       self->insert(x);
     }

     void discard(value_type x) {
       self->erase(x);
     }

  };
%enddef

%include <std/std_set.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_shared_ptr.i
================================================
#define SWIG_SHARED_PTR_NAMESPACE std
%include <boost_shared_ptr.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_sstream.i
================================================
%include <std/std_sstream.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_streambuf.i
================================================
%include <std/std_streambuf.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_string.i
================================================
%include <typemaps/std_string.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_unordered_map.i
================================================
/*
  Unordered Maps
*/

%fragment("StdMapTraits","header",fragment="StdSequenceTraits")
{
  namespace swig {
    template <class SwigPySeq, class K, class T >
    inline void
    assign(const SwigPySeq& swigpyseq, std::unordered_map<K,T > *unordered_map) {
      typedef typename std::unordered_map<K,T>::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	unordered_map->insert(value_type(it->first, it->second));
      }
    }

    template <class K, class T>
    struct traits_asptr<std::unordered_map<K,T> >  {
      typedef std::unordered_map<K,T> unordered_map_type;
      static int asptr(PyObject *obj, unordered_map_type **val) {
	int res = SWIG_ERROR;
	if (PyDict_Check(obj)) {
	  SwigVar_PyObject items = PyObject_CallMethod(obj,(char *)"items",NULL);
%#if PY_VERSION_HEX >= 0x03000000
          /* In Python 3.x the ".items()" method return a dict_items object */
          items = PySequence_Fast(items, ".items() havn't returned a sequence!");
%#endif
	  res = traits_asptr_stdseq<std::unordered_map<K,T>, std::pair<K, T> >::asptr(items, val);
	} else {
	  unordered_map_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<unordered_map_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }      
    };
      
    template <class K, class T >
    struct traits_from<std::unordered_map<K,T> >  {
      typedef std::unordered_map<K,T> unordered_map_type;
      typedef typename unordered_map_type::const_iterator const_iterator;
      typedef typename unordered_map_type::size_type size_type;
            
      static PyObject *from(const unordered_map_type& unordered_map) {
	swig_type_info *desc = swig::type_info<unordered_map_type>();
	if (desc && desc->clientdata) {
	  return SWIG_NewPointerObj(new unordered_map_type(unordered_map), desc, SWIG_POINTER_OWN);
	} else {
	  size_type size = unordered_map.size();
	  Py_ssize_t pysize = (size <= (size_type) INT_MAX) ? (Py_ssize_t) size : -1;
	  if (pysize < 0) {
	    SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	    PyErr_SetString(PyExc_OverflowError, "unordered_map size not valid in python");
	    SWIG_PYTHON_THREAD_END_BLOCK;
	    return NULL;
	  }
	  PyObject *obj = PyDict_New();
	  for (const_iterator i= unordered_map.begin(); i!= unordered_map.end(); ++i) {
	    swig::SwigVar_PyObject key = swig::from(i->first);
	    swig::SwigVar_PyObject val = swig::from(i->second);
	    PyDict_SetItem(obj, key, val);
	  }
	  return obj;
	}
      }
    };

    template <class ValueType>
    struct from_key_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.first);
      }
    };

    template <class ValueType>
    struct from_value_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.second);
      }
    };

    template<class OutIterator, class FromOper, class ValueType = typename OutIterator::value_type>
    struct SwigPyMapIterator_T : SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper>
    {
      SwigPyMapIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyIteratorClosed_T<OutIterator,ValueType,FromOper>(curr, first, last, seq)
      {
      }
    };


    template<class OutIterator,
	     class FromOper = from_key_oper<typename OutIterator::value_type> >
    struct SwigPyMapKeyIterator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapKeyIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_key_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapKeyIterator_T<OutIter>(current, begin, end, seq);
    }

    template<class OutIterator,
	     class FromOper = from_value_oper<typename OutIterator::value_type> >
    struct SwigPyMapValueITerator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapValueITerator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };
    

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_value_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapValueITerator_T<OutIter>(current, begin, end, seq);
    }
  }
}

%define %swig_unordered_map_common(Map...)
  %swig_sequence_iterator(Map);
  %swig_container_methods(Map)

  %extend {
    mapped_type __getitem__(const key_type& key) const throw (std::out_of_range) {
      Map::const_iterator i = self->find(key);
      if (i != self->end())
	return i->second;
      else
	throw std::out_of_range("key not found");
    }
    
    void __delitem__(const key_type& key) throw (std::out_of_range) {
      Map::iterator i = self->find(key);
      if (i != self->end())
	self->erase(i);
      else
	throw std::out_of_range("key not found");
    }
    
    bool has_key(const key_type& key) const {
      Map::const_iterator i = self->find(key);
      return i != self->end();
    }
    
    PyObject* keys() {
      Map::size_type size = self->size();
      Py_ssize_t pysize = (size <= (Map::size_type) INT_MAX) ? (Py_ssize_t) size : -1;
      if (pysize < 0) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	PyErr_SetString(PyExc_OverflowError, "unordered_map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }
      PyObject* keyList = PyList_New(pysize);
      Map::const_iterator i = self->begin();
      for (Py_ssize_t j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(keyList, j, swig::from(i->first));
      }
      return keyList;
    }
    
    PyObject* values() {
      Map::size_type size = self->size();
      Py_ssize_t pysize = (size <= (Map::size_type) INT_MAX) ? (Py_ssize_t) size : -1;
      if (pysize < 0) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	PyErr_SetString(PyExc_OverflowError, "unordered_map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }
      PyObject* valList = PyList_New(pysize);
      Map::const_iterator i = self->begin();
      for (Py_ssize_t j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(valList, j, swig::from(i->second));
      }
      return valList;
    }
    
    PyObject* items() {
      Map::size_type size = self->size();
      Py_ssize_t pysize = (size <= (Map::size_type) INT_MAX) ? (Py_ssize_t) size : -1;
      if (pysize < 0) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	PyErr_SetString(PyExc_OverflowError, "unordered_map size not valid in python");
	SWIG_PYTHON_THREAD_END_BLOCK;
	return NULL;
      }    
      PyObject* itemList = PyList_New(pysize);
      Map::const_iterator i = self->begin();
      for (Py_ssize_t j = 0; j < pysize; ++i, ++j) {
	PyList_SET_ITEM(itemList, j, swig::from(*i));
      }
      return itemList;
    }
    
    // Python 2.2 methods
    bool __contains__(const key_type& key) {
      return self->find(key) != self->end();
    }

    %newobject key_iterator(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* key_iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_key_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %newobject value_iterator(PyObject **PYTHON_SELF);
    swig::SwigPyIterator* value_iterator(PyObject **PYTHON_SELF) {
      return swig::make_output_value_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }

    %pythoncode %{def __iter__(self):
    return self.key_iterator()%}
    %pythoncode %{def iterkeys(self):
    return self.key_iterator()%}
    %pythoncode %{def itervalues(self):
    return self.value_iterator()%}
    %pythoncode %{def iteritems(self):
    return self.iterator()%}
  }
%enddef

%define %swig_unordered_map_methods(Map...)
  %swig_unordered_map_common(Map)
  %extend {
    void __setitem__(const key_type& key, const mapped_type& x) throw (std::out_of_range) {
      (*self)[key] = x;
    }
  }
%enddef


%include <std/std_unordered_map.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_unordered_multimap.i
================================================
/*
  Unordered Multimaps
*/
%include <std_unordered_map.i>

%fragment("StdUnorderedMultimapTraits","header",fragment="StdSequenceTraits")
{
  namespace swig {
    template <class SwigPySeq, class K, class T >
    inline void 
    assign(const SwigPySeq& swigpyseq, std::unordered_multimap<K,T > *unordered_multimap) {
      typedef typename std::unordered_multimap<K,T>::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	unordered_multimap->insert(value_type(it->first, it->second));
      }
    }

    template <class K, class T>
    struct traits_asptr<std::unordered_multimap<K,T> >  {
      typedef std::unordered_multimap<K,T> unordered_multimap_type;
      static int asptr(PyObject *obj, std::unordered_multimap<K,T> **val) {
	int res = SWIG_ERROR;
	if (PyDict_Check(obj)) {
	  SwigVar_PyObject items = PyObject_CallMethod(obj,(char *)"items",NULL);
	  return traits_asptr_stdseq<std::unordered_multimap<K,T>, std::pair<K, T> >::asptr(items, val);
	} else {
	  unordered_multimap_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<unordered_multimap_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }
    };
      
    template <class K, class T >
    struct traits_from<std::unordered_multimap<K,T> >  {
      typedef std::unordered_multimap<K,T> unordered_multimap_type;
      typedef typename unordered_multimap_type::const_iterator const_iterator;
      typedef typename unordered_multimap_type::size_type size_type;
            
      static PyObject *from(const unordered_multimap_type& unordered_multimap) {
	swig_type_info *desc = swig::type_info<unordered_multimap_type>();
	if (desc && desc->clientdata) {
	  return SWIG_NewPointerObj(new unordered_multimap_type(unordered_multimap), desc, SWIG_POINTER_OWN);
	} else {
	  size_type size = unordered_multimap.size();
	  Py_ssize_t pysize = (size <= (size_type) INT_MAX) ? (Py_ssize_t) size : -1;
	  if (pysize < 0) {
	    SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	    PyErr_SetString(PyExc_OverflowError, "unordered_multimap size not valid in python");
	    SWIG_PYTHON_THREAD_END_BLOCK;
	    return NULL;
	  }
	  PyObject *obj = PyDict_New();
	  for (const_iterator i= unordered_multimap.begin(); i!= unordered_multimap.end(); ++i) {
	    swig::SwigVar_PyObject key = swig::from(i->first);
	    swig::SwigVar_PyObject val = swig::from(i->second);
	    PyDict_SetItem(obj, key, val);
	  }
	  return obj;
	}
      }
    };
  }
}

%define %swig_unordered_multimap_methods(Type...) 
  %swig_map_common(Type);
  %extend {
    void __setitem__(const key_type& key, const mapped_type& x) throw (std::out_of_range) {
      self->insert(Type::value_type(key,x));
    }
  }
%enddef

%include <std/std_unordered_multimap.i>




================================================
File: swig/swigwin-3.0.8/Lib/python/std_unordered_multiset.i
================================================
/*
  Unordered Multisets
*/

%include <std_unordered_set.i>

%fragment("StdUnorderedMultisetTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class SwigPySeq, class T> 
    inline void
    assign(const SwigPySeq& swigpyseq, std::unordered_multiset<T>* seq) {
      // seq->insert(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
      typedef typename SwigPySeq::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	seq->insert(seq->end(),(value_type)(*it));
      }
    }

    template <class T>
    struct traits_asptr<std::unordered_multiset<T> >  {
      static int asptr(PyObject *obj, std::unordered_multiset<T> **m) {
	return traits_asptr_stdseq<std::unordered_multiset<T> >::asptr(obj, m);
      }
    };

    template <class T>
    struct traits_from<std::unordered_multiset<T> > {
      static PyObject *from(const std::unordered_multiset<T>& vec) {
	return traits_from_stdseq<std::unordered_multiset<T> >::from(vec);
      }
    };
  }
%}

#define %swig_unordered_multiset_methods(Set...) %swig_set_methods(Set)



%include <std/std_unordered_multiset.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_unordered_set.i
================================================
/*
  Unordered Sets
*/

%fragment("StdUnorderedSetTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class SwigPySeq, class T> 
    inline void 
    assign(const SwigPySeq& swigpyseq, std::unordered_set<T>* seq) {
      // seq->insert(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
      typedef typename SwigPySeq::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	seq->insert(seq->end(),(value_type)(*it));
      }
    }

    template <class T>
    struct traits_asptr<std::unordered_set<T> >  {
      static int asptr(PyObject *obj, std::unordered_set<T> **s) {
	return traits_asptr_stdseq<std::unordered_set<T> >::asptr(obj, s);
      }
    };

    template <class T>
    struct traits_from<std::unordered_set<T> > {
      static PyObject *from(const std::unordered_set<T>& vec) {
	return traits_from_stdseq<std::unordered_set<T> >::from(vec);
      }
    };
  }
%}

%define %swig_unordered_set_methods(unordered_set...)
  %swig_sequence_iterator(unordered_set);
  %swig_container_methods(unordered_set);

  %extend  {
     void append(value_type x) {
       self->insert(x);
     }
  
     bool __contains__(value_type x) {
       return self->find(x) != self->end();
     }

     value_type __getitem__(difference_type i) const throw (std::out_of_range) {
       return *(swig::cgetpos(self, i));
     }

  };
%enddef

%include <std/std_unordered_set.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_vector.i
================================================
/*
  Vectors
*/

%fragment("StdVectorTraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class T>
    struct traits_asptr<std::vector<T> >  {
      static int asptr(PyObject *obj, std::vector<T> **vec) {
	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
      }
    };
    
    template <class T>
    struct traits_from<std::vector<T> > {
      static PyObject *from(const std::vector<T>& vec) {
	return traits_from_stdseq<std::vector<T> >::from(vec);
      }
    };
  }
%}

#define %swig_vector_methods(Type...) %swig_sequence_methods(Type)
#define %swig_vector_methods_val(Type...) %swig_sequence_methods_val(Type);

%include <std/std_vector.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_vectora.i
================================================
/*
  Vectors + allocators
*/

%fragment("StdVectorATraits","header",fragment="StdSequenceTraits")
%{
  namespace swig {
    template <class T, class A>
      struct traits_asptr<std::vector<T,A> >  {
      typedef std::vector<T,A> vector_type;
      typedef T value_type;
      static int asptr(PyObject *obj, vector_type **vec) {
	return traits_asptr_stdseq<vector_type>::asptr(obj, vec);
      }
    };

    template <class T, class A>
    struct traits_from<std::vector<T,A> > {
      typedef std::vector<T,A> vector_type;
      static PyObject *from(const vector_type& vec) {
	return traits_from_stdseq<vector_type>::from(vec);
      }
    };
  }
%}


#define %swig_vector_methods(Type...) %swig_sequence_methods(Type)
#define %swig_vector_methods_val(Type...) %swig_sequence_methods_val(Type);

%include <std/std_vectora.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_wios.i
================================================
%include <std/std_wios.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_wiostream.i
================================================
namespace std
{
%callback(1) wendl;
%callback(1) wends;
%callback(1) wflush;
}

%include <std_basic_string.i>
%include <std_wstring.i>
%include <std/std_wiostream.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_wsstream.i
================================================
%include <std/std_wsstream.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_wstreambuf.i
================================================
%include <std/std_wstreambuf.i>



================================================
File: swig/swigwin-3.0.8/Lib/python/std_wstring.i
================================================
%include <pywstrings.swg>
%include <typemaps/std_wstring.swg>




================================================
File: swig/swigwin-3.0.8/Lib/python/stl.i
================================================
/* initial STL definition. extended as needed in each language */
%include <std_common.i>
%include <std_string.i>
%include <std_vector.i>
%include <std_map.i>
%include <std_pair.i>




================================================
File: swig/swigwin-3.0.8/Lib/python/typemaps.i
================================================
/* -----------------------------------------------------------------------------
 * typemaps.i
 *
 * Pointer handling
 * These mappings provide support for input/output arguments and common
 * uses for C/C++ pointers.
 * ----------------------------------------------------------------------------- */

// INPUT typemaps.
// These remap a C pointer to be an "INPUT" value which is passed by value
// instead of reference.

/* 
The following methods can be applied to turn a pointer into a simple
"input" value.  That is, instead of passing a pointer to an object,
you would use a real value instead.

         int            *INPUT
         short          *INPUT
         long           *INPUT
	 long long      *INPUT
         unsigned int   *INPUT
         unsigned short *INPUT
         unsigned long  *INPUT
         unsigned long long *INPUT
         unsigned char  *INPUT
         bool           *INPUT
         float          *INPUT
         double         *INPUT
         
To use these, suppose you had a C function like this :

        double fadd(double *a, double *b) {
               return *a+*b;
        }

You could wrap it with SWIG as follows :
        
        %include <typemaps.i>
        double fadd(double *INPUT, double *INPUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *INPUT { double *a, double *b };
        double fadd(double *a, double *b);

*/

// OUTPUT typemaps.   These typemaps are used for parameters that
// are output only.   The output value is appended to the result as
// a list element.

/* 
The following methods can be applied to turn a pointer into an "output"
value.  When calling a function, no input value would be given for
a parameter, but an output value would be returned.  In the case of
multiple output values, they are returned in the form of a Python tuple.

         int            *OUTPUT
         short          *OUTPUT
         long           *OUTPUT
         long long      *OUTPUT
         unsigned int   *OUTPUT
         unsigned short *OUTPUT
         unsigned long  *OUTPUT
         unsigned long long *OUTPUT
         unsigned char  *OUTPUT
         bool           *OUTPUT
         float          *OUTPUT
         double         *OUTPUT
         
For example, suppose you were trying to wrap the modf() function in the
C math library which splits x into integral and fractional parts (and
returns the integer part in one of its parameters).K:

        double modf(double x, double *ip);

You could wrap it with SWIG as follows :

        %include <typemaps.i>
        double modf(double x, double *OUTPUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *OUTPUT { double *ip };
        double modf(double x, double *ip);

The Python output of the function would be a tuple containing both
output values. 

*/

// INOUT
// Mappings for an argument that is both an input and output
// parameter

/*
The following methods can be applied to make a function parameter both
an input and output value.  This combines the behavior of both the
"INPUT" and "OUTPUT" methods described earlier.  Output values are
returned in the form of a Python tuple.  

         int            *INOUT
         short          *INOUT
         long           *INOUT
         long long      *INOUT
         unsigned int   *INOUT
         unsigned short *INOUT
         unsigned long  *INOUT
         unsigned long long *INOUT
         unsigned char  *INOUT
         bool           *INOUT
         float          *INOUT
         double         *INOUT
         
For example, suppose you were trying to wrap the following function :

        void neg(double *x) {
             *x = -(*x);
        }

You could wrap it with SWIG as follows :

        %include <typemaps.i>
        void neg(double *INOUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *INOUT { double *x };
        void neg(double *x);

Unlike C, this mapping does not directly modify the input value (since
this makes no sense in Python).  Rather, the modified input value shows
up as the return value of the function.  Thus, to apply this function
to a Python variable you might do this :

       x = neg(x)

Note : previous versions of SWIG used the symbol 'BOTH' to mark
input/output arguments.   This is still supported, but will be slowly
phased out in future releases.

*/

%include <typemaps/typemaps.swg>



================================================
File: swig/swigwin-3.0.8/Lib/python/wchar.i
================================================
#ifdef __cplusplus

%{
#include <cwchar>
%}

#else

%{
#include <wchar.h>
%}

#endif

%types(wchar_t *);
%include <pywstrings.swg>

/*
  Enable swig wchar support.
*/
#define SWIG_WCHAR



================================================
File: swig/swigwin-3.0.8/Lib/std/README
================================================
/* -----------------------------------------------------------------------------
 *  C++ STD + STL 
 * ----------------------------------------------------------------------------- */

std_common.i		general common code 
std_container.i		general container code 
std_basic_string.i	basic string
std_char_traits.i	char traits
std_complex.i		complex
std_deque.i		deque	
std_except.i		exceptions
std_ios.i		ios
std_iostream.i		istream/ostream
std_list.i		list
std_map.i		map
std_multimap.i		multimap
std_multiset.i		multiset
std_pair.i		pair
std_set.i		set
std_streambuf.i		streambuf
std_vector.i		vector
std_vectora.i		vector + allocator



================================================
File: swig/swigwin-3.0.8/Lib/std/_std_deque.i
================================================
/* -----------------------------------------------------------------------------
 * _std_deque.i
 *
 * This file contains a generic definition of std::deque along with
 * some helper functions.  Specific language modules should include
 * this file to generate wrappers. 
 * ----------------------------------------------------------------------------- */

%include <std_except.i>

%{
#include <deque>
#include <stdexcept>
%}


/* This macro defines all of the standard methods for a deque.  This
   is defined as a macro to simplify the task of specialization.  For
   example,

         template<> class deque<int> {
         public:
             %std_deque_methods(int);
         };
*/

%define %std_deque_methods_noempty(T)
       typedef size_t size_type;
       typedef ptrdiff_t difference_type;
       typedef T value_type;
       typedef value_type* pointer;
       typedef const value_type* const_pointer;
       typedef value_type& reference;
       typedef const value_type& const_reference;

       deque();
       deque(unsigned int size, const T& value=T());
       deque(const deque< T > &);
      ~deque();

       void assign(unsigned int n, const T& value);
       void swap(deque< T > &x);
       unsigned int size() const;
       unsigned int max_size() const;
       void resize(unsigned int n, T c = T());
       const_reference front();
       const_reference back();
       void push_front(const T& x);
       void push_back(const T& x);
       void pop_front();
       void pop_back();
       void clear();

       /* Some useful extensions */
       %extend {
           const_reference getitem(int i) throw (std::out_of_range) {
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("deque index out of range");
           }
           void setitem(int i, const T& x) throw (std::out_of_range) {
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("deque index out of range");
           }
           void delitem(int i) throw (std::out_of_range) {
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size) {
                    self->erase(self->begin()+i);
                } else {
                    throw std::out_of_range("deque index out of range");
                }
           }
           std::deque< T > getslice(int i, int j) {
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                std::deque< T > tmp(j-i);
                std::copy(self->begin()+i,self->begin()+j,tmp.begin());
                return tmp;
            }
            void setslice(int i, int j, const std::deque< T >& v) {
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                if (int(v.size()) == j-i) {
                    std::copy(v.begin(),v.end(),self->begin()+i);
                } else {
                    self->erase(self->begin()+i,self->begin()+j);
                    if (i+1 <= size)
                        self->insert(self->begin()+i+1,v.begin(),v.end());
                    else
                        self->insert(self->end(),v.begin(),v.end());
                }
            }
            void delslice(int i, int j) {
                int size = int(self->size());
                if (i<0) i = size+i;
                if (j<0) j = size+j;
                if (i<0) i = 0;
                if (j>size) j = size;
                self->erase(self->begin()+i,self->begin()+j);
            }
       };
%enddef

#ifdef SWIGPHP
%define %std_deque_methods(T)
    %extend {
        bool is_empty() const {
            return self->empty();
        }
    };
    %std_deque_methods_noempty(T)
%enddef
#else
%define %std_deque_methods(T)
    bool empty() const;
    %std_deque_methods_noempty(T)
%enddef
#endif

namespace std {
    template<class T> class deque {
    public:
       %std_deque_methods(T);
    };
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_alloc.i
================================================
namespace std
{
  /**
   *  @brief  The "standard" allocator, as per [20.4].
   *
   *  The private _Alloc is "SGI" style.  (See comments at the top
   *  of stl_alloc.h.)
   *
   *  The underlying allocator behaves as follows.
   *    - __default_alloc_template is used via two typedefs
   *    - "__single_client_alloc" typedef does no locking for threads
   *    - "__alloc" typedef is threadsafe via the locks
   *    - __new_alloc is used for memory requests
   *
   *  (See @link Allocators allocators info @endlink for more.)
   */
  template<typename _Tp>
    class allocator
    {
    public:
      typedef size_t     size_type;
      typedef ptrdiff_t  difference_type;
      typedef _Tp*       pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp&       reference;
      typedef const _Tp& const_reference;
      typedef _Tp        value_type;

      template<typename _Tp1>
        struct rebind;

      allocator() throw();
      
      allocator(const allocator&) throw();
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw();
      ~allocator() throw();
      

      pointer
      address(reference __x) const;
      

      const_pointer
      address(const_reference __x) const;
      

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      _Tp*
      allocate(size_type __n, const void* = 0);

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type __n);

      size_type
      max_size() const throw();

      void construct(pointer __p, const _Tp& __val);
      void destroy(pointer __p);
    };

  template<>
    class allocator<void>
    {
    public:
      typedef size_t      size_type;
      typedef ptrdiff_t   difference_type;
      typedef void*       pointer;
      typedef const void* const_pointer;
      typedef void        value_type;

      template<typename _Tp1>
        struct rebind;
    };
} // namespace std



================================================
File: swig/swigwin-3.0.8/Lib/std/std_array.i
================================================
//
// std::array
//

%include <std_container.i>

%define %std_array_methods(array...)
  %std_sequence_methods_non_resizable(array)
  void fill(const value_type& u);
%enddef


%define %std_array_methods_val(array...)
  %std_sequence_methods_non_resizable_val(array)
  void fill(const value_type& u);
%enddef

// ------------------------------------------------------------------------
// std::array
// 
// The aim of all that follows would be to integrate std::array with 
// as much as possible, namely, to allow the user to pass and 
// be returned tuples or lists.
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::array<T, N>), f(const std::array<T, N>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::array<T, N> can be passed.
//   -- f(std::array<T, N>&), f(std::array<T, N>*):
//      the parameter may be modified; therefore, only a wrapped std::array
//      can be passed.
//   -- std::array<T, N> f(), const std::array<T, N>& f():
//      the array is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::array<T, N>& f(), std::array<T, N>* f():
//      the array is returned by reference; therefore, a wrapped std::array
//      is returned
//   -- const std::array<T, N>* f(), f(const std::array<T, N>*):
//      for consistency, they expect and return a plain array pointer.
// ------------------------------------------------------------------------


// exported classes

namespace std {

  template<class _Tp, size_t _Nm >
  class array {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;

    %traits_swigtype(_Tp);
    %traits_enum(_Tp);

    %fragment(SWIG_Traits_frag(std::array< _Tp, _Nm >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdArrayTraits") {
      namespace swig {
	template <>  struct traits<std::array< _Tp, _Nm > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::array<" #_Tp "," #_Nm " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_STDARRAY, std::array< _Tp, _Nm >);

#ifdef %swig_array_methods
    // Add swig/language extra methods
    %swig_array_methods(std::array< _Tp, _Nm >);
#endif

    %std_array_methods(array);
  };
}




================================================
File: swig/swigwin-3.0.8/Lib/std/std_basic_string.i
================================================
%include <exception.i>
%include <std_container.i>
%include <std_alloc.i>
%include <std_char_traits.i>

%fragment("<string>");

namespace std
{
  %naturalvar basic_string;
}


namespace std {

  template <class _CharT, class _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT> > 
  class basic_string
  {
#if !defined(SWIG_STD_MODERN_STL) || defined(SWIG_STD_NOMODERN_STL)
    %ignore push_back;
    %ignore clear;
    %ignore compare;
    %ignore append;
#endif

  public:
    typedef size_t size_type;    
    typedef ptrdiff_t difference_type;
    typedef _CharT value_type;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;
    
    static const size_type npos;

#ifdef SWIG_EXPORT_ITERATOR_METHODS
  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;
#endif


    %traits_swigtype(_CharT);
    %fragment(SWIG_Traits_frag(_CharT));
    

    basic_string(const _CharT* __s, size_type __n);

    // Capacity:

    size_type length() const;

    size_type max_size() const;

    size_type capacity() const;

    void reserve(size_type __res_arg = 0);


    // Modifiers:

    basic_string& 
    append(const basic_string& __str);

    basic_string& 
    append(const basic_string& __str, size_type __pos, size_type __n);

    basic_string& 
    append(const _CharT* __s, size_type __n);
    
    basic_string& 
    append(size_type __n, _CharT __c);

    basic_string& 
    assign(const basic_string& __str);

    basic_string& 
    assign(const basic_string& __str, size_type __pos, size_type __n);
    
    basic_string& 
    assign(const _CharT* __s, size_type __n);

    basic_string& 
    insert(size_type __pos1, const basic_string& __str);    

    basic_string& 
    insert(size_type __pos1, const basic_string& __str,
	   size_type __pos2, size_type __n);

    basic_string& 
    insert(size_type __pos, const _CharT* __s, size_type __n);

    basic_string& 
    insert(size_type __pos, size_type __n, _CharT __c);

    basic_string& 
    erase(size_type __pos = 0, size_type __n = npos);

    basic_string& 
    replace(size_type __pos, size_type __n, const basic_string& __str);

    basic_string& 
    replace(size_type __pos1, size_type __n1, const basic_string& __str,
	    size_type __pos2, size_type __n2);

    basic_string& 
    replace(size_type __pos, size_type __n1, const _CharT* __s,
	    size_type __n2);

    basic_string& 
    replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c);


    size_type 
    copy(_CharT* __s, size_type __n, size_type __pos = 0) const;    

    // String operations:
    const _CharT* c_str() const;

    size_type 
    find(const _CharT* __s, size_type __pos, size_type __n) const;
    
    size_type 
    find(const basic_string& __str, size_type __pos = 0) const;

    size_type 
    find(_CharT __c, size_type __pos = 0) const;

    size_type 
    rfind(const basic_string& __str, size_type __pos = npos) const;

    size_type 
    rfind(const _CharT* __s, size_type __pos, size_type __n) const;

    size_type 
    rfind(_CharT __c, size_type __pos = npos) const;

    size_type 
    find_first_of(const basic_string& __str, size_type __pos = 0) const;

    size_type 
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

    size_type 
    find_first_of(_CharT __c, size_type __pos = 0) const;

    size_type 
    find_last_of(const basic_string& __str, size_type __pos = npos) const;
    
    size_type 
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

    size_type 
    find_last_of(_CharT __c, size_type __pos = npos) const;
    
    size_type 
    find_first_not_of(const basic_string& __str, size_type __pos = 0) const;

    size_type 
    find_first_not_of(const _CharT* __s, size_type __pos, 
		      size_type __n) const;

    size_type 
    find_first_not_of(_CharT __c, size_type __pos = 0) const;

    size_type 
    find_last_not_of(const basic_string& __str, size_type __pos = npos) const;

    size_type 
    find_last_not_of(const _CharT* __s, size_type __pos, 
		     size_type __n) const;
    
    size_type 
    find_last_not_of(_CharT __c, size_type __pos = npos) const;

    basic_string 
    substr(size_type __pos = 0, size_type __n = npos) const;

    int 
    compare(const basic_string& __str) const;

    int 
    compare(size_type __pos, size_type __n, const basic_string& __str) const;

    int 
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
	    size_type __pos2, size_type __n2) const;


    %ignore pop_back();
    %ignore front() const;
    %ignore back() const;
    %ignore basic_string(size_type n);
    %std_sequence_methods_val(basic_string);    


    %ignore pop();


#ifdef %swig_basic_string
    // Add swig/language extra methods
    %swig_basic_string(std::basic_string< _CharT, _Traits, _Alloc >);
#endif

#ifdef SWIG_EXPORT_ITERATOR_METHODS

    
    class iterator;
    class reverse_iterator;
    class const_iterator;
    class const_reverse_iterator;


    void 
    insert(iterator __p, size_type __n, _CharT __c);

    basic_string& 
    replace(iterator __i1, iterator __i2, const basic_string& __str);

    basic_string& 
    replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n);

    basic_string& 
    replace(iterator __i1, iterator __i2, size_type __n, _CharT __c);


    basic_string& 
    replace(iterator __i1, iterator __i2, const _CharT* __k1, const _CharT* __k2);

    basic_string& 
    replace(iterator __i1, iterator __i2, const_iterator __k1, const_iterator __k2);
#endif

    basic_string& operator +=(const basic_string& v);

    %newobject __add__;   
    %newobject __radd__;
    %extend {

      std::basic_string< _CharT,_Traits,_Alloc >* __add__(const basic_string& v) {
	std::basic_string< _CharT,_Traits,_Alloc >* res = new std::basic_string< _CharT,_Traits,_Alloc >(*self);
	*res += v;      
	return res;
      }
      
      std::basic_string< _CharT,_Traits,_Alloc >* __radd__(const basic_string& v) {
	std::basic_string< _CharT,_Traits,_Alloc >* res = new std::basic_string< _CharT,_Traits,_Alloc >(v);
	*res += *self;      
	return res;
      }
      
      std::basic_string< _CharT,_Traits,_Alloc > __str__() {
	return *self;
      }

      std::basic_ostream<_CharT, std::char_traits<_CharT> >&
	__rlshift__(std::basic_ostream<_CharT, std::char_traits<_CharT> >& out) {
	out << *self;
	return out;
      }
    }

  };
}





================================================
File: swig/swigwin-3.0.8/Lib/std/std_carray.swg
================================================
%{
#include <algorithm>
%}

//
// std::carray - is really an extension to the 'std' namespace.
// 
// A simple fix C array wrapper, more or less as presented in
//
//   "The C++ Standarf Library", by Nicolai M. Josuttis
//
// which is also derived from the example in
//
//   "The C++ Programming Language", by Bjarne Stroustup.
//

%inline %{
namespace std {    
  template <class _Type, size_t _Size>
  class carray 
  {
  public:
    typedef _Type value_type;    
    typedef size_t size_type;
    
    typedef _Type * iterator;
    typedef const _Type * const_iterator;
    
    carray() { }
    
    carray(const carray& c) {
      std::copy(c.v, c.v + size(), v);
    }
    
    template <class _Iterator>
    carray(_Iterator first, _Iterator last) {
      assign(first, last);
    }

    iterator begin() { return v; }
    iterator end() { return v + _Size; }

    const_iterator begin() const { return v; }
    const_iterator end() const { return v + _Size; }
    
    _Type& operator[](size_t i) { return v[i]; }
    const _Type& operator[](size_t i) const { return v[i]; }

    static size_t size() { return _Size; }    

    template <class _Iterator>
    void assign(_Iterator first, _Iterator last)  {
      if (std::distance(first,last) == size()) {
	std::copy(first, last, v);
      } else {
	throw std::length_error("bad range length");
      }
    }
      
  private:
    _Type v[_Size];
  };
}
%}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_char_traits.i
================================================
%include <std_common.i>
#if defined(SWIG_WCHAR)
%include <wchar.i>
#endif

namespace std 
{
  
  /// 21.1.2 Basis for explicit _Traits specialization 
  /// NB: That for any given actual character type this definition is
  /// probably wrong.
  template<class _CharT>
  struct char_traits
  {
  };


  /// 21.1.4  char_traits specializations
  template<>
  struct char_traits<char> {
    typedef char 		char_type;
    typedef int 	        int_type;
    typedef streampos 	pos_type;
    typedef streamoff 	off_type;
    typedef mbstate_t 	state_type;

    static void 
    assign(char_type& __c1, const char_type& __c2);
    
    static bool 
    eq(const char_type& __c1, const char_type& __c2);

    static bool 
    lt(const char_type& __c1, const char_type& __c2);

    static int 
    compare(const char_type* __s1, const char_type* __s2, size_t __n);

    static size_t
    length(const char_type* __s);

    static const char_type* 
    find(const char_type* __s, size_t __n, const char_type& __a);

    static char_type* 
    move(char_type* __s1, const char_type* __s2, size_t __n);

    static char_type* 
    copy(char_type* __s1, const char_type* __s2, size_t __n);

    static char_type* 
    assign(char_type* __s, size_t __n, char_type __a);

    static char_type 
    to_char_type(const int_type& __c);

    // To keep both the byte 0xff and the eof symbol 0xffffffff
    // from ending up as 0xffffffff.
    static int_type 
    to_int_type(const char_type& __c);

    static bool 
    eq_int_type(const int_type& __c1, const int_type& __c2);

    static int_type 
    eof() ;

    static int_type 
    not_eof(const int_type& __c);
  };


#if defined(SWIG_WCHAR)
  template<>
  struct char_traits<wchar_t>
  {
    typedef wchar_t 		char_type;
    typedef wint_t 		int_type;
    typedef streamoff 	off_type;
    typedef wstreampos 	pos_type;
    typedef mbstate_t 	state_type;
      
    static void 
    assign(char_type& __c1, const char_type& __c2);

    static bool 
    eq(const char_type& __c1, const char_type& __c2);

    static bool 
    lt(const char_type& __c1, const char_type& __c2);

    static int 
    compare(const char_type* __s1, const char_type* __s2, size_t __n);

    static size_t
    length(const char_type* __s);

    static const char_type* 
    find(const char_type* __s, size_t __n, const char_type& __a);

    static char_type* 
    move(char_type* __s1, const char_type* __s2, int_type __n);

    static char_type* 
    copy(char_type* __s1, const char_type* __s2, size_t __n);

    static char_type* 
    assign(char_type* __s, size_t __n, char_type __a);

    static char_type 
    to_char_type(const int_type& __c) ;

    static int_type 
    to_int_type(const char_type& __c) ;

    static bool 
    eq_int_type(const int_type& __c1, const int_type& __c2);

    static int_type 
    eof() ;

    static int_type 
    not_eof(const int_type& __c);
  };
#endif
}

namespace std {
#ifndef SWIG_STL_WRAP_TRAITS
%template() char_traits<char>;
#if defined(SWIG_WCHAR)
%template() char_traits<wchar_t>;
#endif
#else
%template(char_traits_c) char_traits<char>;
#if defined(SWIG_WCHAR)
%template(char_traits_w) char_traits<wchar_t>;
#endif
#endif
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_common.i
================================================
%include <std/std_except.i>

//
// Use the following macro with modern STL implementations
//
//#define SWIG_STD_MODERN_STL
//
// Use this to deactive the previous definition, when using gcc-2.95
// or similar old compilers.
//
//#define SWIG_STD_NOMODERN_STL

// Here, we identify compilers we know have problems with STL.
%{
#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif
%}

//
// Common code for supporting the C++ std namespace
//

%fragment("<string>");
%fragment("<stdexcept>");
%fragment("<stddef.h>");


%fragment("StdIteratorTraits","header",fragment="<stddef.h>") %{
#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif
%}

%fragment("StdTraitsCommon","header",fragment="<string>") %{
namespace swig {
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type>
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category>
  struct traits_as { };

  template <class Type, class Category>
  struct traits_check { };

}
%}

/*
  Generate the traits for a swigtype
*/

%define %traits_swigtype(Type...)
%fragment(SWIG_Traits_frag(Type),"header",fragment="StdTraits") {
  namespace swig {
    template <>  struct traits< Type > {
      typedef pointer_category category;
      static const char* type_name() { return  #Type; }
    };
  }
}
%enddef



/*
  Generate the typemaps for a class that has 'value' traits
*/

%define %typemap_traits(Code,Type...)
  %typemaps_asvalfrom(%arg(Code),
		     %arg(swig::asval< Type >),
		     %arg(swig::from),
		     %arg(SWIG_Traits_frag(Type)),
		     %arg(SWIG_Traits_frag(Type)),
		     Type);
%enddef

/*
  Generate the typemaps for a class that behaves more like a 'pointer' or
  plain wrapped Swigtype.
*/

%define %typemap_traits_ptr(Code,Type...)
  %typemaps_asptrfrom(%arg(Code),
		     %arg(swig::asptr),
		     %arg(swig::from),
		     %arg(SWIG_Traits_frag(Type)),
		     %arg(SWIG_Traits_frag(Type)),
		     Type);
%enddef


/*
  Equality methods
*/
%define %std_equal_methods(Type...)
%extend Type {
  bool operator == (const Type& v) {
    return *self == v;
  }

  bool operator != (const Type& v) {
    return *self != v;
  }
}

%enddef

/*
  Order methods
*/

%define %std_order_methods(Type...)
%extend Type {
  bool operator > (const Type& v) {
    return *self > v;
  }

  bool operator < (const Type& v) {
    return *self < v;
  }

  bool operator >= (const Type& v) {
    return *self >= v;
  }

  bool operator <= (const Type& v) {
    return *self <= v;
  }
}
%enddef

/*
  Comparison methods
*/

%define %std_comp_methods(Type...)
%std_equal_methods(Type )
%std_order_methods(Type )
%enddef




================================================
File: swig/swigwin-3.0.8/Lib/std/std_container.i
================================================
%include <std_common.i>
%include <exception.i>
%include <std_alloc.i>

%{
#include <algorithm>
%}

// Common non-resizable container methods

%define %std_container_methods_non_resizable(container...)

  container();
  container(const container&);

  bool empty() const;
  size_type size() const;
  void swap(container& v);

  #ifdef SWIG_EXPORT_ITERATOR_METHODS
  class iterator;
  class reverse_iterator;
  class const_iterator;
  class const_reverse_iterator;

  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();
  #endif

%enddef

// Common container methods

%define %std_container_methods(container...)
  %std_container_methods_non_resizable(%arg(container))

  void clear();
  allocator_type get_allocator() const;

%enddef

// Common sequence

%define %std_sequence_methods_common(sequence)

  %std_container_methods(%arg(sequence));

  sequence(size_type size);
  void pop_back();

  void resize(size_type new_size);

  #ifdef SWIG_EXPORT_ITERATOR_METHODS
%extend {
  // %extend wrapper used for differing definitions of these methods introduced in C++11
  iterator erase(iterator pos) { return $self->erase(pos); }
  iterator erase(iterator first, iterator last) { return $self->erase(first, last); }
}
  #endif

%enddef

%define %std_sequence_methods_non_resizable(sequence)

  %std_container_methods_non_resizable(%arg(sequence))

  const value_type& front() const;
  const value_type& back() const;

%enddef

%define %std_sequence_methods(sequence)

  %std_sequence_methods_common(%arg(sequence));

  sequence(size_type size, const value_type& value);
  void push_back(const value_type& x);

  const value_type& front() const;
  const value_type& back() const;

  void assign(size_type n, const value_type& x);
  void resize(size_type new_size, const value_type& x);

  #ifdef SWIG_EXPORT_ITERATOR_METHODS
%extend {
  // %extend wrapper used for differing definitions of these methods introduced in C++11
  iterator insert(iterator pos, const value_type& x) { return $self->insert(pos, x); }
  void insert(iterator pos, size_type n, const value_type& x) { $self->insert(pos, n, x); }
}
  #endif

%enddef

%define %std_sequence_methods_non_resizable_val(sequence...)

  %std_container_methods_non_resizable(%arg(sequence))

  value_type front() const;
  value_type back() const;

#endif

%enddef

%define %std_sequence_methods_val(sequence...)

  %std_sequence_methods_common(%arg(sequence));

  sequence(size_type size, value_type value);
  void push_back(value_type x);

  value_type front() const;
  value_type back() const;

  void assign(size_type n, value_type x);
  void resize(size_type new_size, value_type x);

  #ifdef SWIG_EXPORT_ITERATOR_METHODS
%extend {
  // %extend wrapper used for differing definitions of these methods introduced in C++11
  iterator insert(iterator pos, value_type x) { return $self->insert(pos, x); }
  void insert(iterator pos, size_type n, value_type x) { $self->insert(pos, n, x); }
}
  #endif

%enddef


//
// Ignore member methods for Type with no default constructor
//
%define %std_nodefconst_type(Type...)
%feature("ignore") std::vector< Type >::vector(size_type size);
%feature("ignore") std::vector< Type >::resize(size_type size);
%feature("ignore") std::deque< Type >::deque(size_type size);
%feature("ignore") std::deque< Type >::resize(size_type size);
%feature("ignore") std::list< Type >::list(size_type size);
%feature("ignore") std::list< Type >::resize(size_type size);
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/std/std_deque.i
================================================
//
// std::deque

%include <std_container.i>

// Deque

%define %std_deque_methods(deque...)  
  %std_sequence_methods(deque)

  void pop_front();
  void push_front(const value_type& x);
%enddef

%define %std_deque_methods_val(deque...)
  %std_sequence_methods_val(deque)

  void pop_front();
  void push_front(value_type x);
%enddef

// ------------------------------------------------------------------------
// std::deque
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::deque<T>), f(const std::deque<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::deque<T> can be passed.
//   -- f(std::deque<T>&), f(std::deque<T>*):
//      the parameter may be modified; therefore, only a wrapped std::deque
//      can be passed.
//   -- std::deque<T> f(), const std::deque<T>& f():
//      the deque is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::deque<T>& f(), std::deque<T>* f():
//      the deque is returned by reference; therefore, a wrapped std::deque
//      is returned
//   -- const std::deque<T>* f(), f(const std::deque<T>*):
//      for consistency, they expect and return a plain deque pointer.
// ------------------------------------------------------------------------

%{
#include <deque>
%}

// exported classes

namespace std {

  template<class _Tp, class _Alloc = allocator< _Tp > >
  class deque {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::deque< _Tp, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdDequeTraits") {
      namespace swig {
	template <>  struct traits<std::deque< _Tp, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::deque<" #_Tp " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_DEQUE, std::deque< _Tp, _Alloc >);
  
#ifdef %swig_deque_methods
    // Add swig/language extra methods
    %swig_deque_methods(std::deque< _Tp, _Alloc >);
#endif

    %std_deque_methods(deque);
  };

  template<class _Tp, class _Alloc > 
  class deque< _Tp*, _Alloc > {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::deque< _Tp*, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdDequeTraits") {
      namespace swig {
	template <>  struct traits<std::deque< _Tp*, _Alloc > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::deque<" #_Tp " * >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_DEQUE, std::deque< _Tp*, _Alloc >);

#ifdef %swig_deque_methods_val
    // Add swig/language extra methods
    %swig_deque_methods_val(std::deque< _Tp*, _Alloc >);
#endif

    %std_deque_methods_val(std::deque< _Tp*, _Alloc >);
  };

}




================================================
File: swig/swigwin-3.0.8/Lib/std/std_except.i
================================================
#if defined(SWIGJAVA) || defined(SWIGCSHARP)
#error "do not use this version of std_except.i"
#endif

%{
#include <stdexcept>
%}

#if defined(SWIG_STD_EXCEPTIONS_AS_CLASSES)

namespace std {
  struct exception 
  {
    virtual ~exception() throw();
    virtual const char* what() const throw();
  };

  struct bad_exception : exception 
  {
  };

  struct logic_error : exception 
  {
    logic_error(const string& msg);
  };

  struct domain_error : logic_error 
  {
    domain_error(const string& msg);
  };

  struct invalid_argument : logic_error 
  {
    invalid_argument(const string& msg);
  };

  struct length_error : logic_error 
  {
    length_error(const string& msg);
  };

  struct out_of_range : logic_error 
  {
    out_of_range(const string& msg);
  };

  struct runtime_error : exception 
  {
    runtime_error(const string& msg);
  };

  struct range_error : runtime_error 
  {
    range_error(const string& msg);
  };

  struct overflow_error : runtime_error 
  {
    overflow_error(const string& msg);
  };

  struct underflow_error : runtime_error 
  {
    underflow_error(const string& msg);
  };
}

#endif



================================================
File: swig/swigwin-3.0.8/Lib/std/std_ios.i
================================================
%include <std_char_traits.i>
%include <std_basic_string.i>
%include <std_except.i>
%{
#ifndef SWIG_STD_NOMODERN_STL
# include <ios>
#else
# include <streambuf.h>
#endif
%}

namespace std {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_ostream;

  // 27.4.2  Class ios_base
  typedef size_t streamsize;

  class locale;
  
  
  class ios_base
  {
  public:
    
#ifdef SWIG_NESTED_CLASSES
    // 27.4.2.1.1  Class ios_base::failure
    class failure : public exception
    {
    public:
      explicit failure(const string& __str) throw();
    };
#endif

    // 27.4.2.1.2  Type ios_base::fmtflags
    typedef int fmtflags;
    // 27.4.2.1.2  Type fmtflags
    static const fmtflags boolalpha ;
    static const fmtflags dec ;
    static const fmtflags fixed ;
    static const fmtflags hex ;
    static const fmtflags internal ;
    static const fmtflags left ;
    static const fmtflags oct ;
    static const fmtflags right ;
    static const fmtflags scientific ;
    static const fmtflags showbase ;
    static const fmtflags showpoint ;
    static const fmtflags showpos ;
    static const fmtflags skipws ;
    static const fmtflags unitbuf ;
    static const fmtflags uppercase ;
    static const fmtflags adjustfield ;
    static const fmtflags basefield ;
    static const fmtflags floatfield ;

    // 27.4.2.1.3  Type ios_base::iostate
    typedef int iostate;
    static const iostate badbit ;
    static const iostate eofbit ;
    static const iostate failbit ;
    static const iostate goodbit ;

    // 27.4.2.1.4  Type openmode
    typedef int openmode;
    static const openmode app ;
    static const openmode ate ;
    static const openmode binary ;
    static const openmode in ;
    static const openmode out ;
    static const openmode trunc ;

    // 27.4.2.1.5  Type seekdir
    typedef int seekdir;
    static const seekdir beg ;
    static const seekdir cur ;
    static const seekdir end ;


    // Callbacks;
    enum event
      {
	erase_event,
	imbue_event,
	copyfmt_event
      };

    typedef void (*event_callback) (event, ios_base&, int);

    void 
    register_callback(event_callback __fn, int __index);

    // Fmtflags state:
    inline fmtflags 
    flags() const ;

    inline fmtflags 
    flags(fmtflags __fmtfl);

    inline fmtflags 
    setf(fmtflags __fmtfl);

    inline fmtflags 
    setf(fmtflags __fmtfl, fmtflags __mask);

    inline void 
    unsetf(fmtflags __mask) ;

    inline streamsize 
    precision() const ;

    inline streamsize 
    precision(streamsize __prec);

    inline streamsize 
    width() const ;

    inline streamsize 
    width(streamsize __wide);

    static bool 
    sync_with_stdio(bool __sync = true);

    // Locales:
    locale 
    imbue(const locale& __loc);

    inline locale 
    getloc() const { return _M_ios_locale; }

    // Storage:
    static int 
    xalloc() throw();

    inline long& 
    iword(int __ix);

    inline void*& 
    pword(int __ix);

    // Destructor
    ~ios_base();

  protected:
    ios_base();

  //50.  Copy constructor and assignment operator of ios_base
  private:
    ios_base(const ios_base&);

    ios_base& 
    operator=(const ios_base&);
  };

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_ios : public ios_base
  {
  public:
    // Types:
    typedef _CharT 				char_type;
    typedef typename _Traits::int_type 	int_type;
    typedef typename _Traits::pos_type 	pos_type;
    typedef typename _Traits::off_type 	off_type;
    typedef _Traits 				traits_type;
      
  public:

    iostate 
    rdstate() const;

    void 
    clear(iostate __state = goodbit);

    void 
    setstate(iostate __state);

    bool 
    good() const;

    bool 
    eof() const;

    bool 
    fail() const;

    bool 
    bad() const;

    iostate 
    exceptions() const;

    void 
    exceptions(iostate __except);

    // Constructor/destructor:
    explicit 
    basic_ios(basic_streambuf<_CharT, _Traits>* __sb) : ios_base();

    virtual 
    ~basic_ios() ;
      
    // Members:
    basic_ostream<_CharT, _Traits>*
    tie() const;

    basic_ostream<_CharT, _Traits>*
    tie(basic_ostream<_CharT, _Traits>* __tiestr);

    basic_streambuf<_CharT, _Traits>*
    rdbuf() const;

    basic_streambuf<_CharT, _Traits>* 
    rdbuf(basic_streambuf<_CharT, _Traits>* __sb);

    basic_ios&
    copyfmt(const basic_ios& __rhs);

    char_type 
    fill() const;

    char_type 
    fill(char_type __ch);

    // Locales:
    locale 
    imbue(const locale& __loc);

    char 
    narrow(char_type __c, char __dfault) const;

    char_type 
    widen(char __c) const;
     
  protected:
    // 27.4.5.1  basic_ios constructors
    basic_ios();
  private:
    basic_ios(const basic_ios&);

    basic_ios&
    operator=(const basic_ios&);
  };
  
}

namespace std {
  typedef basic_ios<char> ios;
  %template(ios) basic_ios<char>;
#if defined(SWIG_WCHAR)
 typedef basic_ios<wchar_t> wios;
  %template(wios) basic_ios<wchar_t>;
#endif
}

  



================================================
File: swig/swigwin-3.0.8/Lib/std/std_iostream.i
================================================
/* 
   For wchar support, you need to include the wchar.i file
   before this file, ie:
   
   %include <wchar.i>
   %include <std_iostream.i>

   or equivalently, just include

   %include <std_wiostream.i>
*/

%include <std_ios.i>
%include <std_basic_string.i>
%include <std_string.i>
#if defined(SWIG_WCHAR)
%include <std_wstring.i>
#endif

%{
#include <iostream>
%}


namespace std
{
  // 27.6.2.1 Template class basic_ostream
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_ostream : virtual public basic_ios<_CharT, _Traits>
  {
  public:
    // Types (inherited from basic_ios (27.4.4)):
    typedef _CharT                     		char_type;
    typedef typename _Traits::int_type 		int_type;
    typedef typename _Traits::pos_type 		pos_type;
    typedef typename _Traits::off_type 		off_type;
    typedef _Traits                    		traits_type;
      
    // 27.6.2.2 Constructor/destructor:
    explicit 
    basic_ostream(basic_streambuf<_CharT, _Traits>* __sb);

    virtual 
    ~basic_ostream();
    
    // 27.6.2.5 Formatted output:
    // 27.6.2.5.3  basic_ostream::operator<<
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& (*__pf)(basic_ostream<_CharT, _Traits>&));

      
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ios<_CharT, _Traits>& (*__pf)(basic_ios<_CharT, _Traits>&));


    basic_ostream<_CharT, _Traits>&
    operator<<(ios_base& (*__pf) (ios_base&));
    
    // 27.6.2.5.2 Arithmetic Inserters

    basic_ostream<_CharT, _Traits>& 
    operator<<(long __n);
    
    basic_ostream<_CharT, _Traits>& 
    operator<<(unsigned long __n);
    
    basic_ostream<_CharT, _Traits>& 
    operator<<(bool __n);
    
    basic_ostream<_CharT, _Traits>& 
    operator<<(short __n);

    basic_ostream<_CharT, _Traits>& 
    operator<<(unsigned short __n);

    basic_ostream<_CharT, _Traits>& 
    operator<<(int __n);

    basic_ostream<_CharT, _Traits>& 
    operator<<(unsigned int __n);

    basic_ostream<_CharT, _Traits>& 
    operator<<(long long __n);

    basic_ostream<_CharT, _Traits>& 
    operator<<(unsigned long long __n);

    basic_ostream<_CharT, _Traits>& 
    operator<<(double __f);

    basic_ostream<_CharT, _Traits>& 
    operator<<(float __f);

    basic_ostream<_CharT, _Traits>& 
    operator<<(long double __f);

    basic_ostream<_CharT, _Traits>& 
    operator<<(const void* __p);

    basic_ostream<_CharT, _Traits>& 
    operator<<(basic_streambuf<_CharT, _Traits>* __sb);

    %extend {
      std::basic_ostream<_CharT, _Traits >& 
	operator<<(const std::basic_string<_CharT,_Traits, std::allocator<_CharT> >& s)
	{
	  *self << s;
	  return *self;
	}
    }

    // Unformatted output:
    basic_ostream<_CharT, _Traits>& 
    put(char_type __c);

    basic_ostream<_CharT, _Traits>& 
    write(const char_type* __s, streamsize __n);

    basic_ostream<_CharT, _Traits>& 
    flush();

    // Seeks:
    pos_type 
    tellp();

    basic_ostream<_CharT, _Traits>& 
    seekp(pos_type);

    basic_ostream<_CharT, _Traits>& 
    seekp(off_type, ios_base::seekdir);

  };

  // 27.6.1.1 Template class basic_istream
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_istream : virtual public basic_ios<_CharT, _Traits>
  {
  public:
    // Types (inherited from basic_ios (27.4.4)):
    typedef _CharT                     		char_type;
    typedef typename _Traits::int_type 		int_type;
    typedef typename _Traits::pos_type 		pos_type;
    typedef typename _Traits::off_type 		off_type;
    typedef _Traits                    		traits_type;


  public:
    // 27.6.1.1.1 Constructor/destructor:
    explicit 
    basic_istream(basic_streambuf<_CharT, _Traits>* __sb);

    virtual 
    ~basic_istream();

    // 27.6.1.2.3 basic_istream::operator>>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& (*__pf)(basic_istream<_CharT, _Traits>&));
    
    basic_istream<_CharT, _Traits>&
    operator>>(basic_ios<_CharT, _Traits>& (*__pf)(basic_ios<_CharT, _Traits>&));
    
    basic_istream<_CharT, _Traits>&
    operator>>(ios_base& (*__pf)(ios_base&));
      
    // 27.6.1.2.2 Arithmetic Extractors
    basic_istream<_CharT, _Traits>& 
    operator>>(bool& __n);
      
    basic_istream<_CharT, _Traits>& 
    operator>>(short& __n);
      
    basic_istream<_CharT, _Traits>& 
    operator>>(unsigned short& __n);

    basic_istream<_CharT, _Traits>& 
    operator>>(int& __n);
      
    basic_istream<_CharT, _Traits>& 
    operator>>(unsigned int& __n);

    basic_istream<_CharT, _Traits>& 
    operator>>(long& __n);
      
    basic_istream<_CharT, _Traits>& 
    operator>>(unsigned long& __n);

    basic_istream<_CharT, _Traits>& 
    operator>>(long long& __n);

    basic_istream<_CharT, _Traits>& 
    operator>>(unsigned long long& __n);

    basic_istream<_CharT, _Traits>& 
    operator>>(float& __f);

    basic_istream<_CharT, _Traits>& 
    operator>>(double& __f);

    basic_istream<_CharT, _Traits>& 
    operator>>(long double& __f);

    basic_istream<_CharT, _Traits>& 
    operator>>(void*& __p);

    basic_istream<_CharT, _Traits>& 
    operator>>(basic_streambuf<_CharT, _Traits>* __sb);
      
    // 27.6.1.3 Unformatted input:
    inline streamsize 
    gcount(void) const;
      
    int_type 
    get(void);

    basic_istream<_CharT, _Traits>& 
    get(char_type& __c);

    basic_istream<_CharT, _Traits>& 
    get(char_type* __s, streamsize __n, char_type __delim);

    inline basic_istream<_CharT, _Traits>& 
    get(char_type* __s, streamsize __n);

    basic_istream<_CharT, _Traits>&
    get(basic_streambuf<_CharT, _Traits>& __sb, char_type __delim);

    inline basic_istream<_CharT, _Traits>&
    get(basic_streambuf<_CharT, _Traits>& __sb);

    basic_istream<_CharT, _Traits>& 
    getline(char_type* __s, streamsize __n, char_type __delim);

    inline basic_istream<_CharT, _Traits>& 
    getline(char_type* __s, streamsize __n);

    basic_istream<_CharT, _Traits>& 
    ignore(streamsize __n = 1, int_type __delim = _Traits::eof());
      
    int_type 
    peek(void);
      
    basic_istream<_CharT, _Traits>& 
    read(char_type* __s, streamsize __n);

    streamsize 
    readsome(char_type* __s, streamsize __n);
      
    basic_istream<_CharT, _Traits>& 
    putback(char_type __c);

    basic_istream<_CharT, _Traits>& 
    unget(void);

    int 
    sync(void);

    pos_type 
    tellg(void);

    basic_istream<_CharT, _Traits>& 
    seekg(pos_type);

    basic_istream<_CharT, _Traits>& 
    seekg(off_type, ios_base::seekdir);
  };  

  // 27.6.1.5 Template class basic_iostream
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_iostream
    : public basic_istream<_CharT, _Traits>, 
      public basic_ostream<_CharT, _Traits>
  {
  public:
    typedef _CharT                     		char_type;
    typedef typename _Traits::int_type 		int_type;
    typedef typename _Traits::pos_type 		pos_type;
    typedef typename _Traits::off_type 		off_type;
    typedef _Traits                    		traits_type;

    explicit 
    basic_iostream(basic_streambuf<_CharT, _Traits>* __sb);

    virtual 
    ~basic_iostream();    
  };

  typedef basic_ostream<char> ostream ;
  typedef basic_istream<char> istream;
  typedef basic_iostream<char> iostream;

  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;

#if defined(SWIG_WCHAR)
  typedef basic_ostream<wchar_t>  wostream;
  typedef basic_istream<wchar_t>  wistream;
  typedef basic_iostream<wchar_t> wiostream;

  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;
#endif

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  std::basic_ostream<_CharT, _Traits>& 
  endl(std::basic_ostream<_CharT, _Traits>&);

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  std::basic_ostream<_CharT, _Traits>& 
  ends(std::basic_ostream<_CharT, _Traits>&);

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  std::basic_ostream<_CharT, _Traits>& 
  flush(std::basic_ostream<_CharT, _Traits>&);
}

namespace std {
  %template(ostream) basic_ostream<char>;
  %template(istream) basic_istream<char>;
  %template(iostream) basic_iostream<char>;

  %template(endl) endl<char, std::char_traits<char> >;
  %template(ends) ends<char, std::char_traits<char> >;
  %template(flush) flush<char, std::char_traits<char> >;

#if defined(SWIG_WCHAR)
  %template(wostream) basic_ostream<wchar_t>;
  %template(wistream) basic_istream<wchar_t>;
  %template(wiostream) basic_iostream<wchar_t>;  

  %template(wendl) endl<wchar_t, std::char_traits<wchar_t> >;
  %template(wends) ends<wchar_t, std::char_traits<wchar_t> >;
  %template(wflush) flush<wchar_t, std::char_traits<wchar_t> >;  
#endif
}




================================================
File: swig/swigwin-3.0.8/Lib/std/std_list.i
================================================
//
// std::list
//

%include <std_container.i>

// List

%define %std_list_methods(list)
  %std_sequence_methods(list)
  
  void pop_front();
  void push_front(const value_type& x);
  		
  void reverse();
  
%enddef


%define %std_list_methods_val(list)
  %std_sequence_methods_val(list)
  
  void pop_front();
  void push_front(value_type x);
  		
  void remove(value_type x);
  void unique();
  void reverse();
  void sort();
  
  void merge(list& x);
%enddef

// ------------------------------------------------------------------------
// std::list
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::list<T>), f(const std::list<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::list<T> can be passed.
//   -- f(std::list<T>&), f(std::list<T>*):
//      the parameter may be modified; therefore, only a wrapped std::list
//      can be passed.
//   -- std::list<T> f(), const std::list<T>& f():
//      the list is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::list<T>& f(), std::list<T>* f():
//      the list is returned by reference; therefore, a wrapped std::list
//      is returned
//   -- const std::list<T>* f(), f(const std::list<T>*):
//      for consistency, they expect and return a plain list pointer.
// ------------------------------------------------------------------------

%{
#include <list>
%}

// exported classes

namespace std {

  template<class _Tp, class _Alloc = allocator< _Tp > >
  class list {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::list< _Tp, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdListTraits") {
      namespace swig {
	template <>  struct traits<std::list< _Tp, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::list<" #_Tp ", " #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_LIST, std::list< _Tp, _Alloc >);

#ifdef %swig_list_methods
    // Add swig/language extra methods
    %swig_list_methods(std::list< _Tp, _Alloc >);
#endif
  
    %std_list_methods(list);
  };

  template<class _Tp, class _Alloc >
  class list< _Tp*, _Alloc> {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::list< _Tp*, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdListTraits") {
      namespace swig {
	template <>  struct traits<std::list< _Tp*, _Alloc > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::list<" #_Tp " *," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_LIST, std::list< _Tp*, _Alloc >);

#ifdef %swig_list_methods_val
    // Add swig/language extra methods
    %swig_list_methods_val(std::list< _Tp*, _Alloc >);
#endif

    %std_list_methods_val(list);
  };

}

%define %std_extequal_list(...)
%extend std::list< __VA_ARGS__ > {
  void remove(const value_type& x) { self->remove(x); }  
  void merge(std::list< __VA_ARGS__ >& x){ self->merge(x); }
  void unique() { self->unique(); }  
  void sort() { self->sort(); }  
}
%enddef




================================================
File: swig/swigwin-3.0.8/Lib/std/std_map.i
================================================
//
// std::map
//

%include <std_pair.i>
%include <std_container.i>

%define %std_map_methods_common(map...)
  %std_container_methods(map);

  size_type erase(const key_type& x);
  size_type count(const key_type& x) const;

#ifdef SWIG_EXPORT_ITERATOR_METHODS
%extend {
  // %extend wrapper used for differing definitions of these methods introduced in C++11
  void erase(iterator position) { $self->erase(position); }
  void erase(iterator first, iterator last) { $self->erase(first, last); }
}

  iterator find(const key_type& x);
  iterator lower_bound(const key_type& x);
  iterator upper_bound(const key_type& x);
#endif
%enddef

%define %std_map_methods(map...)
  %std_map_methods_common(map);

  #ifdef SWIG_EXPORT_ITERATOR_METHODS
//  iterator insert(const value_type& x);
  #endif
%enddef


// ------------------------------------------------------------------------
// std::map
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::map<T>), f(const std::map<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::map<T> can be passed.
//   -- f(std::map<T>&), f(std::map<T>*):
//      the parameter may be modified; therefore, only a wrapped std::map
//      can be passed.
//   -- std::map<T> f(), const std::map<T>& f():
//      the map is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::map<T>& f(), std::map<T>* f():
//      the map is returned by reference; therefore, a wrapped std::map
//      is returned
//   -- const std::map<T>* f(), f(const std::map<T>*):
//      for consistency, they expect and return a plain map pointer.
// ------------------------------------------------------------------------

%{
#include <map>
%}
%fragment("<algorithm>");
%fragment("<stdexcept>");

// exported class

namespace std {

  template<class _Key, class _Tp, class _Compare = std::less<_Key >,
	   class _Alloc = allocator<std::pair< const _Key, _Tp > > >
  class map {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef std::pair< const _Key, _Tp > value_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);
    %traits_swigtype(_Tp);	    

    %fragment(SWIG_Traits_frag(std::pair< _Key, _Tp >), "header",
	      fragment=SWIG_Traits_frag(_Key),
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< _Key, _Tp > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #_Key "," #_Tp " >";
	  }
	};
      }
    }

    %fragment(SWIG_Traits_frag(std::map< _Key, _Tp, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(std::pair< _Key, _Tp >),
	      fragment="StdMapTraits") {
      namespace swig {
	template <>  struct traits<std::map< _Key, _Tp, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" #_Key "," #_Tp "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_MAP, std::map< _Key, _Tp, _Compare, _Alloc >);

    map( const _Compare& );

#ifdef %swig_map_methods
    // Add swig/language extra methods
    %swig_map_methods(std::map< _Key, _Tp, _Compare, _Alloc >);
#endif
  
    %std_map_methods(map);
  };

}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_multimap.i
================================================
//
// std::multimap
//

%include <std_map.i>


%define %std_multimap_methods(mmap...)
  %std_map_methods_common(mmap);

#ifdef SWIG_EXPORT_ITERATOR_METHODS
  std::pair<iterator,iterator> equal_range(const key_type& x);
  std::pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
#endif
%enddef

// ------------------------------------------------------------------------
// std::multimap
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::multimap<T>), f(const std::multimap<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::multimap<T> can be passed.
//   -- f(std::multimap<T>&), f(std::multimap<T>*):
//      the parameter may be modified; therefore, only a wrapped std::multimap
//      can be passed.
//   -- std::multimap<T> f(), const std::multimap<T>& f():
//      the map is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::multimap<T>& f(), std::multimap<T>* f():
//      the map is returned by reference; therefore, a wrapped std::multimap
//      is returned
//   -- const std::multimap<T>* f(), f(const std::multimap<T>*):
//      for consistency, they expect and return a plain map pointer.
// ------------------------------------------------------------------------


// exported class


namespace std {
  template<class _Key, class _Tp, class _Compare = std::less< _Key >,
	   class _Alloc = allocator<std::pair< const _Key, _Tp > > >
  class multimap {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef std::pair< const _Key, _Tp > value_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);
    %traits_swigtype(_Tp);	    

    %fragment(SWIG_Traits_frag(std::pair< _Key, _Tp >), "header",
	      fragment=SWIG_Traits_frag(_Key),
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< _Key, _Tp > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #_Key "," #_Tp " >";
	  }
	};
      }
    }

    %fragment(SWIG_Traits_frag(std::multimap< _Key, _Tp, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(std::pair< _Key, _Tp >),
	      fragment="StdMultimapTraits") {
      namespace swig {
	template <>  struct traits<std::multimap< _Key, _Tp, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::multimap<" #_Key "," #_Tp "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_MULTIMAP, std::multimap< _Key, _Tp, _Compare, _Alloc >);
  
    multimap( const _Compare& );

#ifdef %swig_multimap_methods
    // Add swig/language extra methods
    %swig_multimap_methods(std::multimap< _Key, _Tp, _Compare, _Alloc >);
#endif

    %std_multimap_methods(multimap);
  };
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_multiset.i
================================================
//
// std::multiset
//

%include <std_set.i>

// Multiset

%define %std_multiset_methods(multiset...)
  %std_set_methods_common(multiset);
%enddef


// ------------------------------------------------------------------------
// std::multiset
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::multiset<T>), f(const std::multiset<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::multiset<T> can be passed.
//   -- f(std::multiset<T>&), f(std::multiset<T>*):
//      the parameter may be modified; therefore, only a wrapped std::multiset
//      can be passed.
//   -- std::multiset<T> f(), const std::multiset<T>& f():
//      the set is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::multiset<T>& f(), std::multiset<T>* f():
//      the set is returned by reference; therefore, a wrapped std::multiset
//      is returned
//   -- const std::multiset<T>* f(), f(const std::multiset<T>*):
//      for consistency, they expect and return a plain set pointer.
// ------------------------------------------------------------------------


// exported classes

namespace std {

  //multiset

  template <class _Key, class _Compare = std::less< _Key >,
	    class _Alloc = allocator< _Key > >
  class multiset {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key value_type;
    typedef _Key key_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);

    %fragment(SWIG_Traits_frag(std::multiset< _Key, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Key),
	      fragment="StdMultisetTraits") {
      namespace swig {
	template <>  struct traits<std::multiset< _Key, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::multiset<" #_Key "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_MULTISET, std::multiset< _Key, _Compare, _Alloc >);

    multiset( const _Compare& );

#ifdef %swig_multiset_methods
    // Add swig/language extra methods
    %swig_multiset_methods(std::multiset< _Key, _Compare, _Alloc >);
#endif
  
    %std_multiset_methods(multiset);
  };
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_pair.i
================================================
%include <std_common.i>

%{
#include <utility>
%}


namespace std {
  template <class T, class U > struct pair {      
    typedef T first_type;
    typedef U second_type;
    
    %traits_swigtype(T);
    %traits_swigtype(U);

    %fragment(SWIG_Traits_frag(std::pair< T, U >), "header",
	      fragment=SWIG_Traits_frag(T),
	      fragment=SWIG_Traits_frag(U),
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< T, U > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T "," #U " >";
	  }
	};
      }
    }

#ifndef SWIG_STD_PAIR_ASVAL
    %typemap_traits_ptr(SWIG_TYPECHECK_PAIR, std::pair< T, U >);
#else
    %typemap_traits(SWIG_TYPECHECK_PAIR, std::pair< T, U >);
#endif

    pair();
    pair(T first, U second);
    pair(const pair& p);

    template <class U1, class U2> pair(const pair< U1, U2 > &p);

    T first;
    U second;

#ifdef %swig_pair_methods
    // Add swig/language extra methods
    %swig_pair_methods(std::pair< T, U >)
#endif
  };

  // ***
  // The following specializations should disappear or get
  // simplified when a 'const SWIGTYPE*&' can be defined
  // ***
  template <class T, class U > struct pair< T, U* > {
    typedef T first_type;
    typedef U* second_type;
    
    %traits_swigtype(T);
    %traits_swigtype(U);
      
    %fragment(SWIG_Traits_frag(std::pair< T, U* >), "header",
	      fragment=SWIG_Traits_frag(T),
	      fragment=SWIG_Traits_frag(U),
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< T, U* > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T "," #U " * >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_PAIR, std::pair< T, U* >);

    pair();
    pair(T __a, U* __b);
    pair(const pair& __p);

    T first;
    U* second;

#ifdef %swig_pair_methods
    // Add swig/language extra methods
    %swig_pair_methods(std::pair< T, U* >)
#endif
  };

  template <class T, class U > struct pair< T*, U > {
    typedef T* first_type;
    typedef U second_type;
    
    %traits_swigtype(T);
    %traits_swigtype(U);
      
    %fragment(SWIG_Traits_frag(std::pair< T*, U >), "header",
	      fragment=SWIG_Traits_frag(T),
	      fragment=SWIG_Traits_frag(U),
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< T*, U > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T " *," #U " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_PAIR, std::pair< T*, U >);

    pair();
    pair(T* __a, U __b);
    pair(const pair& __p);

    T* first;
    U second;

#ifdef %swig_pair_methods
    // Add swig/language extra methods
    %swig_pair_methods(std::pair< T*, U >)
#endif
  };

  template <class T, class U > struct pair< T*, U* > {
    typedef T* first_type;
    typedef U* second_type;

    %traits_swigtype(T);
    %traits_swigtype(U);
      
    %fragment(SWIG_Traits_frag(std::pair< T*, U* >), "header",
	      fragment=SWIG_Traits_frag(T),
	      fragment=SWIG_Traits_frag(U),
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< T*, U* > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #T " *," #U " * >";
	  }
	};
      }
    }

    %typemap_traits(SWIG_TYPECHECK_PAIR, std::pair< T*, U* >);

    pair();
    pair(T* __a, U* __b);
    pair(const pair& __p);

    T* first;
    U* second;
 
#ifdef %swig_pair_methods
    // Add swig/language extra methods
    %swig_pair_methods(std::pair< T*, U* >)
#endif
  };

}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_queue.i
================================================
/**
 * @file   std_queue.i
 * @date   Sun May  6 01:48:07 2007
 * 
 * @brief  A wrapping of std::queue for Ruby.
 * 
 * 
 */

%include <std_container.i>

// Queue

%define %std_queue_methods(queue...)
  queue();
  queue( const _Sequence& );

  bool empty() const;
  size_type size() const;
  const value_type& front() const;
  const value_type& back() const;
  void pop();
  void push( const value_type& );
%enddef

%define %std_queue_methods_val(queue...) 
  %std_queue_methods(queue)
%enddef

// ------------------------------------------------------------------------
// std::queue
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::queue<T>), f(const std::queue<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::queue<T> can be passed.
//   -- f(std::queue<T>&), f(std::queue<T>*):
//      the parameter may be modified; therefore, only a wrapped std::queue
//      can be passed.
//   -- std::queue<T> f(), const std::queue<T>& f():
//      the queue is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::queue<T>& f(), std::queue<T>* f():
//      the queue is returned by reference; therefore, a wrapped std::queue
//      is returned
//   -- const std::queue<T>* f(), f(const std::queue<T>*):
//      for consistency, they expect and return a plain queue pointer.
// ------------------------------------------------------------------------

%{
#include <queue>
%}

// exported classes

namespace std {

  template<class _Tp, class _Sequence = std::deque< _Tp > >
  class queue {
  public:
    typedef size_t size_type;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Sequence container_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::queue< _Tp, _Sequence >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdQueueTraits") {
      namespace swig {
	template <>  struct traits<std::queue< _Tp, _Sequence > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::queue<" #_Tp "," #_Sequence " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_QUEUE, std::queue< _Tp, _Sequence >);
  
#ifdef %swig_queue_methods
    // Add swig/language extra methods
    %swig_queue_methods(std::queue< _Tp, _Sequence >);
#endif

    %std_queue_methods(queue);
  };

  template<class _Tp, class _Sequence > 
  class queue< _Tp*, _Sequence > {
  public:
    typedef size_t size_type;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Sequence container_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::queue< _Tp*, _Sequence >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdQueueTraits") {
      namespace swig {
	template <>  struct traits<std::queue< _Tp*, _Sequence > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::queue<" #_Tp "," #_Sequence " * >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_QUEUE, std::queue< _Tp*, _Sequence >);

#ifdef %swig_queue_methods_val
    // Add swig/language extra methods
    %swig_queue_methods_val(std::queue< _Tp*, _Sequence >);
#endif

    %std_queue_methods_val(std::queue< _Tp*, _Sequence >);
  };

}




================================================
File: swig/swigwin-3.0.8/Lib/std/std_set.i
================================================
//
// std::set
//

%include <std_container.i>
%include <std_pair.i>

// Set
%define %std_set_methods_common(set...)
  set();
  set( const set& );

  bool empty() const;
  size_type size() const;
  void clear();

  void swap(set& v);


  size_type erase(const key_type& x);
  size_type count(const key_type& x) const;
  
#ifdef SWIG_EXPORT_ITERATOR_METHODS
  class iterator;
  class reverse_iterator;

  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();

%extend {
  // %extend wrapper used for differing definitions of these methods introduced in C++11
  void erase(iterator pos) { $self->erase(pos); }
  void erase(iterator first, iterator last) { $self->erase(first, last); }
}

  iterator find(const key_type& x);
  iterator lower_bound(const key_type& x);
  iterator upper_bound(const key_type& x);
  std::pair<iterator,iterator> equal_range(const key_type& x);
#endif
%enddef

%define %std_set_methods(set...)
  %std_set_methods_common(set);
#ifdef SWIG_EXPORT_ITERATOR_METHODS
  std::pair<iterator,bool> insert(const value_type& __x);
#endif
%enddef

// ------------------------------------------------------------------------
// std::set
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::set<T>), f(const std::set<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::set<T> can be passed.
//   -- f(std::set<T>&), f(std::set<T>*):
//      the parameter may be modified; therefore, only a wrapped std::set
//      can be passed.
//   -- std::set<T> f(), const std::set<T>& f():
//      the set is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::set<T>& f(), std::set<T>* f():
//      the set is returned by reference; therefore, a wrapped std::set
//      is returned
//   -- const std::set<T>* f(), f(const std::set<T>*):
//      for consistency, they expect and return a plain set pointer.
// ------------------------------------------------------------------------

%{
#include <set>
%}

// exported classes

namespace std {

  template <class _Key, class _Compare = std::less< _Key >,
	    class _Alloc = allocator< _Key > >
  class set {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key value_type;
    typedef _Key key_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);

    %fragment(SWIG_Traits_frag(std::set< _Key, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Key),
	      fragment="StdSetTraits") {
      namespace swig {
	template <>  struct traits<std::set< _Key, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::set<" #_Key "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_SET, std::set< _Key, _Compare, _Alloc >);

    set( const _Compare& );

#ifdef %swig_set_methods
    // Add swig/language extra methods
    %swig_set_methods(std::set< _Key, _Compare, _Alloc >);
#endif
  
    %std_set_methods(set);
  };
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_sstream.i
================================================
/* 
   For wchar support, you need to include the wchar.i file
   before this file, ie:
   
   %include <wchar.i>
   %include <std_sstream.i>

   or equivalently, just include

   %include <std_wsstream.i>
*/

%include <std_alloc.i>
%include <std_basic_string.i>
%include <std_string.i>
%include <std_ios.i>
#if defined(SWIG_WCHAR)
%include <std_wstring.i>
#endif
%include <std_streambuf.i>
%include <std_iostream.i>

%{
#include <sstream>
%}


namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	   typename _Alloc = allocator<_CharT> >
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:
      // Types:
      typedef _CharT 					char_type;
      typedef _Traits 					traits_type;
// 251. basic_stringbuf missing allocator_type
      typedef _Alloc				       	allocator_type;
      typedef typename traits_type::int_type 		int_type;
      typedef typename traits_type::pos_type 		pos_type;
      typedef typename traits_type::off_type 		off_type;

    public:
      // Constructors:
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out);

      explicit
      basic_stringbuf(const basic_string<_CharT, _Traits, _Alloc>& __str,
		      ios_base::openmode __mode = ios_base::in | ios_base::out);

      // Get and set:
      basic_string<_CharT, _Traits, _Alloc>
      str() const;

      void
      str(const basic_string<_CharT, _Traits, _Alloc>& __s);

    };


  // 27.7.2  Template class basic_istringstream
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	   typename _Alloc = allocator<_CharT> >
  class basic_istringstream : public basic_istream<_CharT, _Traits>
  {
    public:
      // Types:
      typedef _CharT 					char_type;
      typedef _Traits 					traits_type;
// 251. basic_stringbuf missing allocator_type
      typedef _Alloc				       	allocator_type;
      typedef typename traits_type::int_type 		int_type;
      typedef typename traits_type::pos_type 		pos_type;
      typedef typename traits_type::off_type 		off_type;


    public:
      // Constructors:
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in);

      explicit
      basic_istringstream(const basic_string<_CharT, _Traits, _Alloc>& __str,
			  ios_base::openmode __mode = ios_base::in);

      ~basic_istringstream();

      // Members:
      basic_stringbuf<_CharT, _Traits, _Alloc>*
      rdbuf() const;

      basic_string<_CharT, _Traits, _Alloc>
      str() const;

      void
      str(const basic_string<_CharT, _Traits, _Alloc>& __s);
    };


  // 27.7.3  Template class basic_ostringstream
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	   typename _Alloc = allocator<_CharT> >
  class basic_ostringstream : public basic_ostream<_CharT, _Traits>
  {
    public:
      // Types:
      typedef _CharT 					char_type;
      typedef _Traits 					traits_type;
// 251. basic_stringbuf missing allocator_type
      typedef _Alloc				       	allocator_type;
      typedef typename traits_type::int_type 		int_type;
      typedef typename traits_type::pos_type 		pos_type;
      typedef typename traits_type::off_type 		off_type;


    public:
     // Constructors/destructor:
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out);

      explicit
      basic_ostringstream(const basic_string<_CharT, _Traits, _Alloc>& __str,
			  ios_base::openmode __mode = ios_base::out);

      ~basic_ostringstream();

      // Members:
      basic_stringbuf<_CharT, _Traits, _Alloc>*
      rdbuf() const;

      basic_string<_CharT, _Traits, _Alloc>
      str() const;

#if 0
      void
      str(const basic_string<_CharT, _Traits, _Alloc>& __s);
#endif
    };


  // 27.7.4  Template class basic_stringstream
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	   typename _Alloc = allocator<_CharT> >
  class basic_stringstream : public basic_iostream<_CharT, _Traits>
  {
    public:
      // Types:
      typedef _CharT 					char_type;
      typedef _Traits 					traits_type;
// 251. basic_stringbuf missing allocator_type
      typedef _Alloc				       	allocator_type;
      typedef typename traits_type::int_type 		int_type;
      typedef typename traits_type::pos_type 		pos_type;
      typedef typename traits_type::off_type 		off_type;

    public:
      // Constructors/destructors
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in);

      explicit
      basic_stringstream(const basic_string<_CharT, _Traits, _Alloc>& __str,
			 ios_base::openmode __m = ios_base::out | ios_base::in);

      ~basic_stringstream();

      // Members:
      basic_stringbuf<_CharT, _Traits, _Alloc>*
      rdbuf() const;

      basic_string<_CharT, _Traits, _Alloc>
      str() const;

      void
      str(const basic_string<_CharT, _Traits, _Alloc>& __s);
    };


} // namespace std


namespace std {
  %template(istringstream) basic_istringstream<char>;
  %template(ostringstream) basic_ostringstream<char>;
  %template(stringstream)  basic_stringstream<char>;


#if defined(SWIG_WCHAR)
  %template(wistringstream) basic_istringstream<wchar_t>;
  %template(wostringstream) basic_ostringstream<wchar_t>;
  %template(wstringstream)  basic_stringstream<wchar_t>;
#endif
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_stack.i
================================================
/**
 * @file   std_stack.i
 * @date   Sun May  6 01:48:07 2007
 * 
 * @brief  A wrapping of std::stack for Ruby.
 * 
 * 
 */

%include <std_container.i>

// Stack

%define %std_stack_methods(stack...)
  stack();
  stack( const _Sequence& );

  bool empty() const;
  size_type size() const;
  const value_type& top() const;
  void pop();
  void push( const value_type& );
%enddef

%define %std_stack_methods_val(stack...) 
  %std_stack_methods(stack)
%enddef

// ------------------------------------------------------------------------
// std::stack
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::stack<T>), f(const std::stack<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::stack<T> can be passed.
//   -- f(std::stack<T>&), f(std::stack<T>*):
//      the parameter may be modified; therefore, only a wrapped std::stack
//      can be passed.
//   -- std::stack<T> f(), const std::stack<T>& f():
//      the stack is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::stack<T>& f(), std::stack<T>* f():
//      the stack is returned by reference; therefore, a wrapped std::stack
//      is returned
//   -- const std::stack<T>* f(), f(const std::stack<T>*):
//      for consistency, they expect and return a plain stack pointer.
// ------------------------------------------------------------------------

%{
#include <stack>
%}

// exported classes

namespace std {

  template<class _Tp, class _Sequence = std::deque< _Tp > >
  class stack {
  public:
    typedef size_t size_type;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Sequence container_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::stack< _Tp, _Sequence >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdStackTraits") {
      namespace swig {
	template <>  struct traits<std::stack< _Tp, _Sequence > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::stack<" #_Tp "," #_Sequence " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_STACK, std::stack< _Tp, _Sequence >);
  
#ifdef %swig_stack_methods
    // Add swig/language extra methods
    %swig_stack_methods(std::stack< _Tp, _Sequence >);
#endif

    %std_stack_methods(stack);
  };

  template<class _Tp, class _Sequence > 
  class stack< _Tp*, _Sequence > {
  public:
    typedef size_t size_type;
    typedef _Sequence::value_type value_type;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Sequence container_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::stack< _Tp*, _Sequence >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdStackTraits") {
      namespace swig {
	template <>  struct traits<std::stack< _Tp*, _Sequence > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::stack<" #_Tp "," #_Sequence " * >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_STACK, std::stack< _Tp*, _Sequence >);

#ifdef %swig_stack_methods_val
    // Add swig/language extra methods
    %swig_stack_methods_val(std::stack< _Tp*, _Sequence >);
#endif

    %std_stack_methods_val(std::stack< _Tp*, _Sequence >);
  };

}




================================================
File: swig/swigwin-3.0.8/Lib/std/std_streambuf.i
================================================
%include <std_ios.i>
%{
#ifndef SWIG_STD_NOMODERN_STL
#include <streambuf>
#else
#include <streambuf.h>
#endif
%}

namespace std {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
  class basic_streambuf 
  {
  public:
    // Types:
    typedef _CharT 					char_type;
    typedef _Traits 					traits_type;
    typedef typename traits_type::int_type 		int_type;
    typedef typename traits_type::pos_type 		pos_type;
    typedef typename traits_type::off_type 		off_type;

  public:
    virtual 
    ~basic_streambuf();

    // Locales:
    locale 
    pubimbue(const locale &__loc);

    locale   
    getloc() const; 

    // Buffer and positioning:
    basic_streambuf<_CharT, _Traits>* 
    pubsetbuf(char_type* __s, streamsize __n);

    pos_type 
    pubseekoff(off_type __off, ios_base::seekdir __way, 
	       ios_base::openmode __mode = std::ios_base::in | std::ios_base::out);

    pos_type 
    pubseekpos(pos_type __sp,
	       ios_base::openmode __mode = std::ios_base::in | std::ios_base::out);

    int 
    pubsync() ;

    // Get and put areas:
    // Get area:
    streamsize 
    in_avail();

    int_type 
    snextc();

    int_type 
    sbumpc();

    int_type 
    sgetc();

    streamsize 
    sgetn(char_type* __s, streamsize __n);

    // Putback:
    int_type 
    sputbackc(char_type __c);

    int_type 
    sungetc();

    // Put area:
    int_type 
    sputc(char_type __c);

    streamsize 
    sputn(const char_type* __s, streamsize __n);

  protected:
    basic_streambuf();

  private:
    basic_streambuf(const basic_streambuf&);

  }; 
}

namespace std {
  %template(streambuf) basic_streambuf<char>;
#if defined(SWIG_WCHAR)
  %template(wstreambuf) basic_streambuf<wchar_t>;
#endif
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_string.i
================================================
%include <std/std_basic_string.i>

/* plain strings */

namespace std
{
  %std_comp_methods(basic_string<char>);
  %naturalvar string;
  typedef basic_string<char> string;
}


%template(string) std::basic_string<char>;



================================================
File: swig/swigwin-3.0.8/Lib/std/std_unordered_map.i
================================================
//
// std::unordered_map
// Work in progress - the code is not compilable yet:
// operator--() and constructor(compare function) not available for unordered_
// types
//

%include <std_pair.i>
%include <std_container.i>

%define %std_unordered_map_methods_common(unordered_map...)
  %std_container_methods(unordered_map);

  size_type erase(const key_type& x);
  size_type count(const key_type& x) const;

#ifdef SWIG_EXPORT_ITERATOR_METHODS
%extend {
  // %extend wrapper used for differing definitions of these methods introduced in C++11
  void erase(iterator position) { $self->erase(position); }
  void erase(iterator first, iterator last) { $self->erase(first, last); }
}

  iterator find(const key_type& x);
  iterator lower_bound(const key_type& x);
  iterator upper_bound(const key_type& x);
#endif
%enddef

%define %std_unordered_map_methods(unordered_map...)
  %std_unordered_map_methods_common(unordered_map);

  #ifdef SWIG_EXPORT_ITERATOR_METHODS
//  iterator insert(const value_type& x);
  #endif
%enddef


// ------------------------------------------------------------------------
// std::unordered_map
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::unordered_map<T>), f(const std::unordered_map<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::unordered_map<T> can be passed.
//   -- f(std::unordered_map<T>&), f(std::unordered_map<T>*):
//      the parameter may be modified; therefore, only a wrapped std::unordered_map
//      can be passed.
//   -- std::unordered_map<T> f(), const std::unordered_map<T>& f():
//      the unordered_map is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::unordered_map<T>& f(), std::unordered_map<T>* f():
//      the unordered_map is returned by reference; therefore, a wrapped std::unordered_map
//      is returned
//   -- const std::unordered_map<T>* f(), f(const std::unordered_map<T>*):
//      for consistency, they expect and return a plain unordered_map pointer.
// ------------------------------------------------------------------------

%{
#include <unordered_map>
%}
%fragment("<algorithm>");
%fragment("<stdexcept>");

// exported class

namespace std {

  template<class _Key, class _Tp, class _Compare = std::less< _Key >,
	   class _Alloc = allocator<std::pair< const _Key, _Tp > > >
  class unordered_map {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef std::pair< const _Key, _Tp > value_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);
    %traits_swigtype(_Tp);	    

    %fragment(SWIG_Traits_frag(std::pair< _Key, _Tp >), "header",
	      fragment=SWIG_Traits_frag(_Key),
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdPairTraits") {
      namespace swig {
	template <>  struct traits<std::pair< _Key, _Tp > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" #_Key "," #_Tp " >";
	  }
	};
      }
    }

    %fragment(SWIG_Traits_frag(std::unordered_map< _Key, _Tp, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(std::pair< _Key, _Tp >),
	      fragment="StdMapTraits") {
      namespace swig {
	template <>  struct traits<std::unordered_map< _Key, _Tp, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::unordered_map<" #_Key "," #_Tp "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_MAP, std::unordered_map< _Key, _Tp, _Compare, _Alloc >);

    unordered_map( const _Compare& );

#ifdef %swig_unordered_map_methods
    // Add swig/language extra methods
    %swig_unordered_map_methods(std::unordered_map< _Key, _Tp, _Compare, _Alloc >);
#endif
  
    %std_unordered_map_methods(unordered_map);
  };

}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_unordered_multimap.i
================================================
//
// std::unordered_multimap
// Work in progress - the code is not compilable yet:
// operator--() and constructor(compare function) not available for unordered_
// types
//

%include <std_unordered_map.i>


%define %std_unordered_multimap_methods(mmap...)
  %std_map_methods_common(mmap);

#ifdef SWIG_EXPORT_ITERATOR_METHODS
  std::pair<iterator,iterator> equal_range(const key_type& x);
  std::pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
#endif
%enddef

// ------------------------------------------------------------------------
// std::unordered_multimap
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::unordered_multimap<T>), f(const std::unordered_multimap<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::unordered_multimap<T> can be passed.
//   -- f(std::unordered_multimap<T>&), f(std::unordered_multimap<T>*):
//      the parameter may be modified; therefore, only a wrapped std::unordered_multimap
//      can be passed.
//   -- std::unordered_multimap<T> f(), const std::unordered_multimap<T>& f():
//      the map is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::unordered_multimap<T>& f(), std::unordered_multimap<T>* f():
//      the map is returned by reference; therefore, a wrapped std::unordered_multimap
//      is returned
//   -- const std::unordered_multimap<T>* f(), f(const std::unordered_multimap<T>*):
//      for consistency, they expect and return a plain map pointer.
// ------------------------------------------------------------------------


// exported class


namespace std {
  template<class _Key, class _Tp, class _Compare = std::less< _Key >,
	   class _Alloc = allocator<std::pair< const _Key, _Tp > > >
  class unordered_multimap {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef std::pair< const _Key, _Tp > value_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);
    %traits_swigtype(_Tp);	    

    %fragment(SWIG_Traits_frag(std::unordered_multimap< _Key, _Tp, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(std::pair< _Key, _Tp >),
	      fragment="StdMultimapTraits") {
      namespace swig {
	template <>  struct traits<std::unordered_multimap< _Key, _Tp, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::unordered_multimap<" #_Key "," #_Tp "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_MULTIMAP, std::unordered_multimap< _Key, _Tp, _Compare, _Alloc >);
  
    unordered_multimap( const _Compare& );

#ifdef %swig_unordered_multimap_methods
    // Add swig/language extra methods
    %swig_unordered_multimap_methods(std::unordered_multimap< _Key, _Tp, _Compare, _Alloc >);
#endif

    %std_unordered_multimap_methods(unordered_multimap);
  };
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_unordered_multiset.i
================================================
//
// std::unordered_multiset
// Work in progress - the code is not compilable yet:
// operator--() and constructor(compare function) not available for unordered_
// types
//

%include <std_unordered_set.i>

// Unordered Multiset

%define %std_unordered_multiset_methods(unordered_multiset...)
  %std_unordered_set_methods_common(unordered_multiset);
%enddef


// ------------------------------------------------------------------------
// std::unordered_multiset
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::unordered_multiset<T>), f(const std::unordered_multiset<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::unordered_multiset<T> can be passed.
//   -- f(std::unordered_multiset<T>&), f(std::unordered_multiset<T>*):
//      the parameter may be modified; therefore, only a wrapped std::unordered_multiset
//      can be passed.
//   -- std::unordered_multiset<T> f(), const std::unordered_multiset<T>& f():
//      the set is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::unordered_multiset<T>& f(), std::unordered_multiset<T>* f():
//      the set is returned by reference; therefore, a wrapped std::unordered_multiset
//      is returned
//   -- const std::unordered_multiset<T>* f(), f(const std::unordered_multiset<T>*):
//      for consistency, they expect and return a plain set pointer.
// ------------------------------------------------------------------------


// exported classes

namespace std {

  //unordered_multiset

  template <class _Key, class _Compare = std::less< _Key >,
	    class _Alloc = allocator< _Key > >
  class unordered_multiset {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Key value_type;
    typedef _Key key_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);

    %fragment(SWIG_Traits_frag(std::unordered_multiset< _Key, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Key),
	      fragment="StdMultisetTraits") {
      namespace swig {
	template <>  struct traits<std::unordered_multiset< _Key, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::unordered_multiset<" #_Key "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_MULTISET, std::unordered_multiset< _Key, _Compare, _Alloc >);

    unordered_multiset( const _Compare& );

#ifdef %swig_unordered_multiset_methods
    // Add swig/language extra methods
    %swig_unordered_multiset_methods(std::unordered_multiset< _Key, _Compare, _Alloc >);
#endif
  
    %std_unordered_multiset_methods(unordered_multiset);
  };
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_unordered_set.i
================================================
//
// std::unordered_set
// Work in progress - the code is not compilable yet:
// operator--() and constructor(compare function) not available for unordered_
// types
//

%include <std_container.i>
%include <std_pair.i>

// Unordered Set
%define %std_unordered_set_methods_common(unordered_set...)
  unordered_set();
  unordered_set( const unordered_set& );

  bool empty() const;
  size_type size() const;
  void clear();

  void swap(unordered_set& v);


  size_type erase(const key_type& x);
  size_type count(const key_type& x) const;
  
#ifdef SWIG_EXPORT_ITERATOR_METHODS
  class iterator;

  iterator begin();
  iterator end();

%extend {
  // %extend wrapper used for differing definitions of these methods introduced in C++11
  void erase(iterator pos) { $self->erase(pos); }
  void erase(iterator first, iterator last) { $self->erase(first, last); }
}

  iterator find(const key_type& x);
  std::pair<iterator,iterator> equal_range(const key_type& x);
#endif
%enddef

%define %std_unordered_set_methods(unordered_set...)
  %std_unordered_set_methods_common(unordered_set);
#ifdef SWIG_EXPORT_ITERATOR_METHODS
  std::pair<iterator,bool> insert(const value_type& __x);
#endif
%enddef

// ------------------------------------------------------------------------
// std::unordered_set
// 
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::unordered_set<T>), f(const std::unordered_set<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::unordered_set<T> can be passed.
//   -- f(std::unordered_set<T>&), f(std::unordered_set<T>*):
//      the parameter may be modified; therefore, only a wrapped std::unordered_set
//      can be passed.
//   -- std::unordered_set<T> f(), const std::unordered_set<T>& f():
//      the unordered_set is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::unordered_set<T>& f(), std::unordered_set<T>* f():
//      the unordered_set is returned by reference; therefore, a wrapped std::unordered_set
//      is returned
//   -- const std::unordered_set<T>* f(), f(const std::unordered_set<T>*):
//      for consistency, they expect and return a plain unordered_set pointer.
// ------------------------------------------------------------------------

%{
#include <unordered_set>
%}

// exported classes

namespace std {

  template <class _Key, class _Hash = std::hash< _Key >,
            class _Compare = std::equal_to< _Key >,
	    class _Alloc = allocator< _Key > >
  class unordered_set {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Hash hasher;
    typedef _Key value_type;
    typedef _Key key_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Key);

    %fragment(SWIG_Traits_frag(std::unordered_set< _Key, _Hash, _Compare, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Key),
	      fragment="StdUnorderedSetTraits") {
      namespace swig {
	template <>  struct traits<std::unordered_set< _Key, _Hash, _Compare, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::unordered_set<" #_Key "," #_Hash "," #_Compare "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_SET, std::unordered_set< _Key, _Hash, _Compare, _Alloc >);

    unordered_set( const _Compare& );

#ifdef %swig_unordered_set_methods
    // Add swig/language extra methods
    %swig_unordered_set_methods(std::unordered_set< _Key, _Hash, _Compare, _Alloc >);
#endif
  
    %std_unordered_set_methods(unordered_set);
  };
}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_vector.i
================================================
//
// std::vector
//

%include <std_container.i>

// Vector

%define %std_vector_methods(vector...)
  %std_sequence_methods(vector)
  
  void reserve(size_type n);
  size_type capacity() const;
%enddef


%define %std_vector_methods_val(vector...)
  %std_sequence_methods_val(vector)
  
  void reserve(size_type n);
  size_type capacity() const;
%enddef


// ------------------------------------------------------------------------
// std::vector
// 
// The aim of all that follows would be to integrate std::vector with 
// as much as possible, namely, to allow the user to pass and 
// be returned tuples or lists.
// const declarations are used to guess the intent of the function being
// exported; therefore, the following rationale is applied:
// 
//   -- f(std::vector<T>), f(const std::vector<T>&):
//      the parameter being read-only, either a sequence or a
//      previously wrapped std::vector<T> can be passed.
//   -- f(std::vector<T>&), f(std::vector<T>*):
//      the parameter may be modified; therefore, only a wrapped std::vector
//      can be passed.
//   -- std::vector<T> f(), const std::vector<T>& f():
//      the vector is returned by copy; therefore, a sequence of T:s 
//      is returned which is most easily used in other functions
//   -- std::vector<T>& f(), std::vector<T>* f():
//      the vector is returned by reference; therefore, a wrapped std::vector
//      is returned
//   -- const std::vector<T>* f(), f(const std::vector<T>*):
//      for consistency, they expect and return a plain vector pointer.
// ------------------------------------------------------------------------

%{
#include <vector>
%}    

// exported classes


namespace std {

  template<class _Tp, class _Alloc = allocator< _Tp > >
  class vector {
  public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Tp);
    %traits_enum(_Tp);

    %fragment(SWIG_Traits_frag(std::vector< _Tp, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdVectorTraits") {
      namespace swig {
	template <>  struct traits<std::vector< _Tp, _Alloc > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" #_Tp "," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_VECTOR, std::vector< _Tp, _Alloc >);

#ifdef %swig_vector_methods
    // Add swig/language extra methods
    %swig_vector_methods(std::vector< _Tp, _Alloc >);
#endif
  
    %std_vector_methods(vector);
  };

  // ***
  // This specialization should disappear or get simplified when
  // a 'const SWIGTYPE*&' can be defined
  // ***
  template<class _Tp, class _Alloc >
  class vector< _Tp*, _Alloc > {
  public:
    typedef size_t size_type;    
    typedef ptrdiff_t difference_type;
    typedef _Tp* value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::vector< _Tp*, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdVectorTraits") {
      namespace swig {
	template <>  struct traits<std::vector< _Tp*, _Alloc > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<" #_Tp " *," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_VECTOR, std::vector< _Tp*, _Alloc >);

#ifdef %swig_vector_methods_val
    // Add swig/language extra methods
    %swig_vector_methods_val(std::vector< _Tp*, _Alloc >);
#endif

    %std_vector_methods_val(vector);
  };

  // ***
  // const pointer specialization
  // ***
  template<class _Tp, class _Alloc >
  class vector< _Tp const *, _Alloc > {
  public:
    typedef size_t size_type;    
    typedef ptrdiff_t difference_type;
    typedef _Tp const * value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(_Tp);

    %fragment(SWIG_Traits_frag(std::vector< _Tp const*, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(_Tp),
	      fragment="StdVectorTraits") {
      namespace swig {
	template <>  struct traits<std::vector< _Tp const*, _Alloc > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<" #_Tp " const*," #_Alloc " >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_VECTOR, std::vector< _Tp const*, _Alloc >);

#ifdef %swig_vector_methods_val
    // Add swig/language extra methods
    %swig_vector_methods_val(std::vector< _Tp const*, _Alloc >);
#endif

    %std_vector_methods_val(vector);
  };

  // ***
  // bool specialization
  // ***

  template<class _Alloc > 
  class vector<bool,_Alloc > {
  public:
    typedef size_t size_type;    
    typedef ptrdiff_t difference_type;
    typedef bool value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type reference;
    typedef value_type const_reference;
    typedef _Alloc allocator_type;

    %traits_swigtype(bool);

    %fragment(SWIG_Traits_frag(std::vector<bool, _Alloc >), "header",
	      fragment=SWIG_Traits_frag(bool),
	      fragment="StdVectorTraits") {
      namespace swig {
	template <>  struct traits<std::vector<bool, _Alloc > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<bool, _Alloc >";
	  }
	};
      }
    }

    %typemap_traits_ptr(SWIG_TYPECHECK_VECTOR, std::vector<bool, _Alloc >);


#ifdef %swig_vector_methods_val
    // Add swig/language extra methods
    %swig_vector_methods_val(std::vector<bool, _Alloc >);
#endif

    %std_vector_methods_val(vector);

#if defined(SWIG_STD_MODERN_STL) && !defined(SWIG_STD_NOMODERN_STL) 
    void flip();
#endif

  };

}



================================================
File: swig/swigwin-3.0.8/Lib/std/std_vectora.i
================================================
//
// We keep this file only for backward compatibility, since std_vector.i
// now uses the std::allocator parameter.
//

%include <std_vector.i>




================================================
File: swig/swigwin-3.0.8/Lib/std/std_wios.i
================================================
/*
  Provide 'std_ios.i' with wchar support.
*/

%include <wchar.i>
%include <std_ios.i>




================================================
File: swig/swigwin-3.0.8/Lib/std/std_wiostream.i
================================================
/*
  Provide 'std_iostream.i' with wchar support.
*/

%include <wchar.i>
%include <std_iostream.i>




================================================
File: swig/swigwin-3.0.8/Lib/std/std_wsstream.i
================================================
/*
  Provide 'std_sstream.i' with wchar support.
*/

%include <wchar.i>
%include <std_sstream.i>




================================================
File: swig/swigwin-3.0.8/Lib/std/std_wstreambuf.i
================================================
/*
  Provide 'std_streambuf.i' with wchar support.
*/

%include <wchar.i>
%include <std_streambuf.i>




================================================
File: swig/swigwin-3.0.8/Lib/std/std_wstring.i
================================================
%include <wchar.i>
%include <std/std_basic_string.i>

/* wide strings */

namespace std
{
  %std_comp_methods(basic_string<wchar_t>);
  %naturalvar wstring;
  typedef basic_string<wchar_t> wstring;
}

%template(wstring) std::basic_string<wchar_t>;




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/README
================================================
Still in development, but if you are interested into looking around,
start with


     swigtypemaps.swg

which is the head file. Also read the docs for %fragments in 

     fragments.swg 

and follow the definitions in one of the supported languages:

     python, perl, ruby, tcl




/* -----------------------------------------------------------------------------
 *  Internal typemap specializations
 * ----------------------------------------------------------------------------- */


carrays.swg		Implement the carrays.i library
cdata.swg		Implement the cdata.i library
cmalloc.swg		Implement the cmalloc.i library
cpointer.swg		Implement the cpointer.i library
cstring.swg		Implement the cstring.i library typemaps for char *
cwstring.swg		Implement the cstring.i library typemaps for wchar_t *
exception.swg		Implement the exception.i library
implicit.swg		Allow the use of implicit C++ constructors

string.swg		Typemaps for char * string
wstring.swg		Typemaps for wchar_t * string
std_string.swg		Typemaps for std::string
std_wstring.swg		Typemaps for std::wstring
swigtype.swg		Typemaps for the SWIGTYPE type
void.swg		Typemaps for the 'void' type
enumint.swg		Typemaps for enums treated as 'int' 
swigobject.swg		Typemaps for the SWIG_Object as in PyObject, Tcl_Obj, etc.
misctypes.swg		Typemaps for miscellaneos types (size_t, ptrdiff_t, etc)
ptrtypes.swg		Typemaps for types with a 'ptr' behavior
valtypes.swg		Typemaps for 'by value' types
inoutlist.swg		IN/OUTPUT/INOUT typemaps, where the OUTPUT values are returned in a list
primtypes.swg		Common macros to manage primitive types (short,int,double,etc)

cstrings.swg		Common macros to implemented the cstring/cwstring libraries
std_strings.swg		Common macros to implemented the std::string/std::wstring typemaps
strings.swg		Common macros and typemaps for string and wstring (char *, wchar_t *)

swigmacros.swg		Basic macros 
fragments.swg		Macros for fragment manipulations


typemaps.swg		The old typemaps.i library, not needed anymore



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/attribute.swg
================================================
/* -----------------------------------------------------------------------------
 * attribute.swg
 *
 * Attribute implementation
 * ----------------------------------------------------------------------------- */

/*
  The following macros convert a pair of set/get methods
  into a "native" attribute.

  Use %attribute when you have a pair of get/set methods to a primitive type
  like in:

      %attribute(A, int, a, get_a, set_a);

      struct A
      {
        int get_a() const;
        void set_a(int aa);
      };

  If you don't provide a 'set' method, a 'read-only' attribute
  is generated, ie, like in:

      %attribute(A, int, c, get_c);

  Use %attributeref when you have const/non-const reference access methods
  for primitive types or class/structs, like in:

      %attributeref(A, int, b);

      struct A
      {
        const int& b() const;
        int& b();
      };

      %attributeref(B, int, c);

      struct B
      {
        int& c();
      };

  You can also use

      %attributeref(Class, AttributeType, AttributeName, AccessorMethod)

  if the internal C++ reference methods have a different name from the
  attribute you want, so

      %attributeref(B, int, d, c);

  is the same as the last example, but instead of the attribute 'c' being
  called 'c', it is called 'd'.

  Now you can use the attributes like so:

      x = A()
      x.a = 3        # calls A::set_a
      print x.a      # calls A::get_a

      x.b = 3        # calls A::b()
      print x.b      # calls A::b() const

  Use %attribute2 instead of %attribute to indicate that reference-pointer
  translation is required. You use %attribute2 instead of %attribute in
  cases like this:
 
  %attribute2(MyClass, MyFoo, Foo, GetFoo, SetFoo);
  %inline %{
    struct MyFoo { 
      int x;
    };
    class MyClass {
      MyFoo foo;
    public:
      MyFoo& GetFoo() { return foo; }
      void SetFoo(const MyFoo& other) { foo = other; }
    };
  %}

  Here, the data type of the property is a wrapped type (MyFoo) and on the
  C++ side it is passed by reference. The problem is that the SWIG wrapper will
  pass around a pointer (MyFoo *) which is not compatible with the reference
  type of the accessors (MyFoo &). Therefore, if you use %attribute, you'll get
  an error from your C/C++ compiler. %attribute2 translates between a pointer
  and a reference to eliminate the error. In case you're confused, let's make it
  simple: just use %attribute at first, but if the C/C++ compiler gives an error
  while compiling the wrapper, try %attribute2 instead.

  NOTE: remember that if the type contains commas, such as 'std::pair<int,int>',
  you need to use the macro like:

  %attributeref(A, %arg(std::pair<int,int>), pval);

  where %arg() 'normalizes' the type to be understood as a single
  argument, otherwise the macro will get confused by the comma.

  The %attributeval is the same as %attribute, but should be used when the type
  is a class/struct (ie a non-primitive type) and when the get and set methods 
  return/pass by value. The following is very similar to the above example, but 
  note that the access is by value rather than reference.

    %attributeval(MyClassVal, MyFoo, ReadWriteFoo, GetFoo, SetFoo);
    %attributeval(MyClassVal, MyFoo, ReadOnlyFoo, GetFoo);
    %inline %{
      class MyClassVal {
	MyFoo foo;
      public:
	MyFoo GetFoo() { return foo; }
	void SetFoo(MyFoo other) { foo = other; }
      };
    %} 

  The %attributestring is the same as %attributeval, but should be used for string
  class types, which are unusual as they are a class on the C++ side, but normally an
  immutable/primitive type in the target language. Example usage for std::string:

    %include <std_string.i>
    %attributestring(MyStringyClass, std::string, ReadWriteString, GetString, SetString);
    %attributestring(MyStringyClass, std::string, ReadOnlyString, GetString);
    %inline %{
      class MyStringyClass {
	std::string str;
      public:
	MyStringyClass(const std::string &val) : str(val) {}
	std::string GetString() { return str; }
	void SetString(std::string other) { str = other; }
      };
    %} 

  The %attributestring also works for class types that have %naturalvar turned
  on and so is also useful for shared_ptr which has %naturalvar turned on in %shared_ptr.

*/

//
// Define SWIG_ATTRIBUTE_TEMPLATE if you want to use templates instead of macros for the C++ get and set wrapper methods
// Does not always generate compilable code, use at your peril!
//
//#define SWIG_ATTRIBUTE_TEMPLATE

%define %attribute_custom(Class, AttributeType, AttributeName, GetMethod, SetMethod, GetMethodCall, SetMethodCall)
  %ignore Class::GetMethod();
  %ignore Class::GetMethod() const;
  #if #SetMethod != #AttributeName
    %ignore Class::SetMethod;
  #endif
  %extend Class {
    AttributeType AttributeName;
  }
#if defined(__cplusplus) && defined(SWIG_ATTRIBUTE_TEMPLATE)
  %{
    template < class C > inline AttributeType %mangle(Class) ##_## AttributeName ## _get(const C* self_) {
      return GetMethodCall;
    }
    template < class C > inline AttributeType %mangle(Class) ##_## AttributeName ## _get(C* self_) {
      return GetMethodCall;
    }
    template < class C > inline void %mangle(Class) ##_## AttributeName ## _set(C* self_, AttributeType val_) {
      SetMethodCall;
    }
  %}
#else
  %{
    #define %mangle(Class) ##_## AttributeName ## _get(self_) GetMethodCall
    #define %mangle(Class) ##_## AttributeName ## _set(self_, val_) SetMethodCall
  %}
#endif
%enddef

%define %attribute_readonly(Class, AttributeType, AttributeName, GetMethod, GetMethodCall)
  %ignore Class::GetMethod();
  %ignore Class::GetMethod() const;
  %immutable Class::AttributeName;
  %extend Class {
    AttributeType AttributeName;
  }
#if defined(__cplusplus) && defined(SWIG_ATTRIBUTE_TEMPLATE)
  %{
    template < class C > inline AttributeType %mangle(Class) ##_## AttributeName ## _get(const C* self_) {
      return GetMethodCall;
    }
    template < class C > inline AttributeType %mangle(Class) ##_## AttributeName ## _get(C* self_) {
      return GetMethodCall;
    }
  %}
#else
  %{
    #define %mangle(Class) ##_## AttributeName ## _get(self_) GetMethodCall
  %}
#endif
%enddef


// User macros

%define %attribute(Class, AttributeType, AttributeName, GetMethod, SetMethod...)
  #if #SetMethod != ""
    %attribute_custom(%arg(Class), %arg(AttributeType), AttributeName, GetMethod, SetMethod, self_->GetMethod(), self_->SetMethod(val_))
  #else
    %attribute_readonly(%arg(Class), %arg(AttributeType), AttributeName, GetMethod, self_->GetMethod())
  #endif
%enddef

%define %attribute2(Class, AttributeType, AttributeName, GetMethod, SetMethod...)
  #if #SetMethod != ""
    %attribute_custom(%arg(Class), %arg(AttributeType), AttributeName, GetMethod, SetMethod, &self_->GetMethod(), self_->SetMethod(*val_))
  #else
    %attribute_readonly(%arg(Class), %arg(AttributeType), AttributeName, GetMethod, &self_->GetMethod())
  #endif
%enddef

%define %attributeref(Class, AttributeType, AttributeName, AccessorMethod...)
  #if #AccessorMethod != ""
    %attribute_custom(%arg(Class), %arg(AttributeType), AttributeName, AccessorMethod, AccessorMethod, self_->AccessorMethod(), self_->AccessorMethod() = val_)
  #else
    %attribute_custom(%arg(Class), %arg(AttributeType), AttributeName, AttributeName, AttributeName, self_->AttributeName(), self_->AttributeName() = val_)
  #endif
%enddef

%define %attribute2ref(Class, AttributeType, AttributeName, AccessorMethod...)
  #if #AccessorMethod != ""
    %attribute_custom(%arg(Class), %arg(AttributeType), AttributeName, AccessorMethod, AccessorMethod, &self_->AccessorMethod(), self_->AccessorMethod() = *val_)
  #else
    %attribute_custom(%arg(Class), %arg(AttributeType), AccessorName, AccessorName, AccessorName, &self_->AccessorName(), self_->AccessorName() = *val_)
  #endif
%enddef

// deprecated (same as %attributeref, but there is an argument order inconsistency)
%define %attribute_ref(Class, AttributeType, AccessorMethod, AttributeName...)
  #if #AttributeName != ""
    %attribute_custom(%arg(Class), %arg(AttributeType), AttributeName, AccessorMethod, AccessorMethod, self_->AccessorMethod(), self_->AccessorMethod() = val_)
  #else
    %attribute_custom(%arg(Class), %arg(AttributeType), AccessorMethod, AccessorMethod, AccessorMethod, self_->AccessorMethod(), self_->AccessorMethod() = val_)
  #endif
%enddef


%define %attributeval(Class, AttributeType, AttributeName, GetMethod, SetMethod...)
  %{
    #define %mangle(Class) ##_## AttributeName ## _get(self_) new AttributeType(self_->GetMethod())
  %}
  #if #SetMethod != ""
    %{
      #define %mangle(Class) ##_## AttributeName ## _set(self_, val_) self_->SetMethod(*val_)
    %}
    #if #SetMethod != #AttributeName
      %ignore Class::SetMethod;
    #endif
  #else
    %immutable Class::AttributeName;
  #endif
  %ignore Class::GetMethod();
  %ignore Class::GetMethod() const;
  %newobject Class::AttributeName;
  %extend Class {
    AttributeType AttributeName;
  }
%enddef


%define %attributestring(Class, AttributeType, AttributeName, GetMethod, SetMethod...)
  %{
    #define %mangle(Class) ##_## AttributeName ## _get(self_) *new AttributeType(self_->GetMethod())
  %}
  #if #SetMethod != ""
    %{
      #define %mangle(Class) ##_## AttributeName ## _set(self_, val_) self_->SetMethod(val_)
    %}
    #if #SetMethod != #AttributeName
      %ignore Class::SetMethod;
    #endif
  #else
    %immutable Class::AttributeName;
  #endif
  %ignore Class::GetMethod();
  %ignore Class::GetMethod() const;
  %newobject Class::AttributeName;
  %typemap(newfree) const AttributeType &AttributeName "delete $1;"
  %extend Class {
    AttributeType AttributeName;
  }
%enddef




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/carrays.swg
================================================
/* -----------------------------------------------------------------------------
 * carrays.swg
 *
 * This library file contains macros that can be used to manipulate simple
 * pointers as arrays.
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * %array_functions(TYPE,NAME)
 *
 * Generates functions for creating and accessing elements of a C array
 * (as pointers).  Creates the following functions:
 *
 *        TYPE *new_NAME(int nelements)
 *        void delete_NAME(TYPE *);
 *        TYPE NAME_getitem(TYPE *, int index);
 *        void NAME_setitem(TYPE *, int index, TYPE value);
 * 
 * ----------------------------------------------------------------------------- */

%define %array_functions(TYPE,NAME) 
%{
  static TYPE *new_##NAME(size_t nelements) { 
    return %new_array(nelements, TYPE);
  }

  static void delete_##NAME(TYPE *ary) {
    %delete_array(ary);
  }

  static TYPE NAME##_getitem(TYPE *ary, size_t index) {
    return ary[index];
  }
  static void NAME##_setitem(TYPE *ary, size_t index, TYPE value) {
    ary[index] = value;
  }
%}

TYPE *new_##NAME(size_t nelements);
void delete_##NAME(TYPE *ary);
TYPE NAME##_getitem(TYPE *ary, size_t index);
void NAME##_setitem(TYPE *ary, size_t index, TYPE value);

%enddef


/* -----------------------------------------------------------------------------
 * %array_class(TYPE,NAME)
 *
 * Generates a class wrapper around a C array.  The class has the following
 * interface:
 *
 *          struct NAME {
 *              NAME(int nelements);
 *             ~NAME();
 *              TYPE getitem(int index);
 *              void setitem(int index, TYPE value);
 *              TYPE * cast();
 *              static NAME *frompointer(TYPE *t);
 *         }
 *
 * Use
 *
 *    %array_class_wrap(TYPE,NAME,GET,SET) 
 *
 * if you want  different names for the get/set methods.
 * ----------------------------------------------------------------------------- */

%define %array_class_wrap(TYPE,NAME,getitem,setitem)
%{
typedef TYPE NAME;
%}


typedef struct {
} NAME;

%extend NAME {

  NAME(size_t nelements) {
    return %new_array(nelements, TYPE);
  }

  ~NAME() {
    %delete_array(self);
  }
  
  TYPE getitem(size_t index) {
    return self[index];
  }

  void setitem(size_t index, TYPE value) {
    self[index] = value;
  }

  TYPE * cast() {
    return self;
  }

  static NAME *frompointer(TYPE *t) {
    return %static_cast(t, NAME *);
  }
};

%types(NAME = TYPE);

%enddef


#ifndef %array_class
%define %array_class(TYPE,NAME)
  %array_class_wrap(TYPE,NAME,getitem,setitem)
%enddef
#endif



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/cdata.swg
================================================
/* -----------------------------------------------------------------------------
 * cdata.swg
 *
 * This library file contains macros for manipulating raw C data as strings.
 * ----------------------------------------------------------------------------- */

%{
typedef struct SWIGCDATA {
    char *data;
    size_t   len;
} SWIGCDATA;
%}

/* -----------------------------------------------------------------------------
 * Typemaps for returning binary data
 * ----------------------------------------------------------------------------- */

%typemap(out,noblock=1,fragment="SWIG_FromCharPtrAndSize") SWIGCDATA {
  %set_output(SWIG_FromCharPtrAndSize($1.data,$1.len));
}
%typemap(in) (const void *indata, size_t inlen) = (char *STRING, size_t SIZE);


/* -----------------------------------------------------------------------------
 * %cdata(TYPE [, NAME]) 
 *
 * Convert raw C data to a binary string.
 * ----------------------------------------------------------------------------- */

%define %cdata(TYPE,NAME...)

%insert("header") {
#ifdef __cplusplus
extern "C"  {    
#endif
#if #NAME == ""
static SWIGCDATA cdata_##TYPE(TYPE *ptr, size_t nelements)
#else
static SWIGCDATA cdata_##NAME(TYPE *ptr, size_t nelements)
#endif
{
  SWIGCDATA d;
  d.data = (char *) ptr;
#if #TYPE != "void"
  d.len  = nelements*sizeof(TYPE);
#else
  d.len  = nelements;
#endif
   return d;
}
#ifdef __cplusplus
}
#endif 
}

#ifdef __cplusplus
extern "C"
#endif
#if #NAME == ""
SWIGCDATA cdata_##TYPE(TYPE *ptr, size_t nelements = 1);
#else
SWIGCDATA cdata_##NAME(TYPE *ptr, size_t nelements = 1);
#endif
%enddef

%rename(cdata) ::cdata_void(void *ptr, size_t nelements = 1);

%cdata(void);

/* Memory move function. Due to multi-argument typemaps this appears to be wrapped as
void memmove(void *data, const char *s); */
void memmove(void *data, const void *indata, size_t inlen);







================================================
File: swig/swigwin-3.0.8/Lib/typemaps/cmalloc.swg
================================================
/* -----------------------------------------------------------------------------
 * cmalloc.swg
 *
 * This library file contains macros that can be used to create objects using
 * the C malloc function.
 * ----------------------------------------------------------------------------- */

%{
#include <stdlib.h>
%}

/* %malloc(TYPE [, NAME = TYPE])
   %calloc(TYPE [, NAME = TYPE])
   %realloc(TYPE [, NAME = TYPE])
   %free(TYPE [, NAME = TYPE])
   %allocators(TYPE [,NAME = TYPE])

   Creates functions for allocating/reallocating memory.

   TYPE *malloc_NAME(size_t nbytes = sizeof(TYPE);
   TYPE *calloc_NAME(size_t nobj=1, size_t size=sizeof(TYPE));
   TYPE *realloc_NAME(TYPE *ptr, size_t nbytes);
   void free_NAME(TYPE *ptr);

*/

%define %malloc(TYPE,NAME...)
#if #NAME != ""
%rename(malloc_##NAME) ::malloc(size_t nbytes);
#else
%rename(malloc_##TYPE) ::malloc(size_t nbytes);
#endif

#if #TYPE != "void"
%typemap(default) size_t nbytes "$1 = (size_t) sizeof(TYPE);"
#endif
TYPE *malloc(size_t nbytes);
%typemap(default) size_t nbytes;
%enddef

%define %calloc(TYPE,NAME...)
#if #NAME != ""
%rename(calloc_##NAME) ::calloc(size_t nobj, size_t sz);
#else
%rename(calloc_##TYPE) ::calloc(size_t nobj, size_t sz);
#endif
#if #TYPE != "void"
%typemap(default) size_t sz "$1 = (size_t) sizeof(TYPE);"
#else
%typemap(default) size_t sz "$1 = 1;"
#endif
%typemap(default) size_t nobj "$1 = 1;"
TYPE *calloc(size_t nobj, size_t sz);
%typemap(default) size_t sz;
%typemap(default) size_t nobj;
%enddef

%define %realloc(TYPE,NAME...)
%insert("header") {
#if #NAME != ""
TYPE *realloc_##NAME(TYPE *ptr, size_t nitems)
#else
TYPE *realloc_##TYPE(TYPE *ptr, size_t nitems)
#endif
{
#if #TYPE != "void"
return (TYPE *) realloc(ptr, nitems*sizeof(TYPE));
#else
return (TYPE *) realloc(ptr, nitems);
#endif
}
}
#if #NAME != ""
TYPE *realloc_##NAME(TYPE *ptr, size_t nitems);
#else
TYPE *realloc_##TYPE(TYPE *ptr, size_t nitems);
#endif
%enddef

%define %free(TYPE,NAME...)
#if #NAME != ""
%rename(free_##NAME) ::free(TYPE *ptr);
#else
%rename(free_##TYPE) ::free(TYPE *ptr);
#endif
void free(TYPE *ptr);
%enddef

%define %sizeof(TYPE,NAME...)
#if #NAME != ""
%constant size_t sizeof_##NAME = sizeof(TYPE);
#else
%constant size_t sizeof_##TYPE = sizeof(TYPE);
#endif
%enddef

%define %allocators(TYPE,NAME...)
%malloc(TYPE,NAME)
%calloc(TYPE,NAME)
%realloc(TYPE,NAME)
%free(TYPE,NAME)
#if #TYPE != "void"
%sizeof(TYPE,NAME)
#endif
%enddef








================================================
File: swig/swigwin-3.0.8/Lib/typemaps/cpointer.swg
================================================
/* -----------------------------------------------------------------------------
 * cpointer.swg
 *
 * This library file contains macros that can be used to manipulate simple
 * pointer objects.
 *
 * ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
 * %pointer_class(type,name)
 *
 * Places a simple proxy around a simple type like 'int', 'float', or whatever.
 * The proxy provides this interface:
 *
 *       class type {
 *       public:
 *           type();
 *          ~type();
 *           type value();
 *           void assign(type value);
 *       };
 *         
 * Example:
 *
 *    %pointer_class(int, intp);
 *
 *    int add(int *x, int *y) { return *x + *y; }
 *
 * In python (with proxies)
 *
 *    >>> a = intp()
 *    >>> a.assign(10)
 *    >>> a.value()
 *    10
 *    >>> b = intp()
 *    >>> b.assign(20)
 *    >>> print add(a,b)
 *    30
 *
 * As a general rule, this macro should not be used on class/structures that
 * are already defined in the interface.
 * ----------------------------------------------------------------------------- */


%define %pointer_class(TYPE, NAME)
%{
typedef TYPE NAME;
%}

typedef struct {
} NAME;

%extend NAME {
  NAME() {
    return %new_instance(TYPE);
  }
  ~NAME() {
    if ($self) %delete($self);
  }
}

%extend NAME {

  void assign(TYPE value) {
    *$self = value;
  }
  TYPE value() {
    return *$self;
  }
  TYPE * cast() {
    return $self;
  }
  static NAME * frompointer(TYPE *t) {
    return (NAME *) t;
  }
}

%types(NAME = TYPE);

%enddef

/* ----------------------------------------------------------------------------- 
 * %pointer_functions(type,name)
 *
 * Create functions for allocating/deallocating pointers.   This can be used
 * if you don't want to create a proxy class or if the pointer is complex.
 *
 *    %pointer_functions(int, intp)
 *
 *    int add(int *x, int *y) { return *x + *y; }
 *
 * In python (with proxies)
 *
 *    >>> a = copy_intp(10)
 *    >>> intp_value(a)
 *    10
 *    >>> b = new_intp()
 *    >>> intp_assign(b,20)
 *    >>> print add(a,b)
 *    30
 *    >>> delete_intp(a)
 *    >>> delete_intp(b)
 * 
 * ----------------------------------------------------------------------------- */

%define %pointer_functions(TYPE,NAME)
%{
  static TYPE *new_##NAME() { 
    return %new_instance(TYPE);
  }
  
  static TYPE *copy_##NAME(TYPE value) { 
    return %new_copy(value, TYPE);
  }

  static void delete_##NAME(TYPE *obj) { 
    if (obj) %delete(obj);
  }

  static void NAME ##_assign(TYPE *obj, TYPE value) {
    *obj = value;
  }

  static TYPE NAME ##_value(TYPE *obj) {
    return *obj;
  }
%}

TYPE *new_##NAME();
TYPE *copy_##NAME(TYPE value);
void  delete_##NAME(TYPE *obj);
void  NAME##_assign(TYPE *obj, TYPE value);
TYPE  NAME##_value(TYPE *obj);

%enddef

/* -----------------------------------------------------------------------------
 * %pointer_cast(type1,type2,name)
 *
 * Generates a pointer casting function.
 * ----------------------------------------------------------------------------- */

%define %pointer_cast(TYPE1,TYPE2,NAME)
%inline %{
TYPE2 NAME(TYPE1 x) {
   return %static_cast(x, TYPE2);
}
%}
%enddef











================================================
File: swig/swigwin-3.0.8/Lib/typemaps/cstring.swg
================================================
%include <typemaps/cstrings.swg>

%typemaps_cstring(%cstring,
		 char,
		 SWIG_AsCharPtr,
		 SWIG_AsCharPtrAndSize,
		 SWIG_FromCharPtr,
		 SWIG_FromCharPtrAndSize);




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/cstrings.swg
================================================
/* -----------------------------------------------------------------------------
 * cstrings.swg
 *
 * This file provides typemaps and macros for dealing with various forms
 * of C character string handling.   The primary use of this module
 * is in returning character data that has been allocated or changed in
 * some way.
 * ----------------------------------------------------------------------------- */

%define %typemaps_cstring(Name, Char,
			  SWIG_AsCharPtr,
			  SWIG_AsCharPtrAndSize,
			  SWIG_FromCharPtr,
			  SWIG_FromCharPtrAndSize)


/* %cstring_input_binary(TYPEMAP, SIZE)
 * 
 * Macro makes a function accept binary string data along with
 * a size.  For example:
 *
 *     %cstring_input_binary(Char *buff, int size);
 *     void foo(Char *buff, int size) {
 *     }
 *
 */

%define Name ## _input_binary(TYPEMAP, SIZE)                   
%typemap(in,noblock=1,fragment=#SWIG_AsCharPtrAndSize) (TYPEMAP, SIZE) 
  (int res, Char *buf = 0, size_t size = 0, int alloc = 0)  {
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "(TYPEMAP, SIZE)", $symname, $argnum);
  }
  $1 = ($1_ltype) buf;					       
  $2 = ($2_ltype) size - 1;				       
}
%typemap(freearg,noblock=1,match="in") (TYPEMAP, SIZE) {
  if (alloc$argnum == SWIG_NEWOBJ) %delete_array(buf$argnum);
}
%enddef								



/*
 * %cstring_bounded_output(TYPEMAP, MAX)
 *
 * This macro is used to return a NULL-terminated output string of
 * some maximum length.  For example:
 *
 *     %cstring_bounded_output(Char *outx, 512);
 *     void foo(Char *outx) {
 *         sprintf(outx,"blah blah\n");
 *     }
 *
 */

%define Name ## _bounded_output(TYPEMAP,MAX)        
%typemap(in,noblock=1,numinputs=0) TYPEMAP (Char temp[MAX+1])  {
  $1 = ($1_ltype) temp;
}
%typemap(freearg,match="in") TYPEMAP "";
%typemap(argout,noblock=1,fragment= #SWIG_FromCharPtr ) TYPEMAP {
  $1[MAX] = 0;  
  %append_output(SWIG_FromCharPtr($1));
}
%enddef



/*
 * %cstring_chunk_output(TYPEMAP, SIZE)
 *
 * This macro is used to return a chunk of binary string data.
 * Embedded NULLs are okay.  For example:
 *
 *     %cstring_chunk_output(Char *outx, 512);
 *     void foo(Char *outx) {
 *         memmove(outx, somedata, 512);
 *     }
 *
 */

%define Name ## _chunk_output(TYPEMAP,SIZE)           
%typemap(in,noblock=1,numinputs=0) TYPEMAP(Char temp[SIZE]) {
  $1 = ($1_ltype) temp;
}
%typemap(freearg,match="in") TYPEMAP "";
%typemap(argout,noblock=1,fragment= #SWIG_FromCharPtrAndSize) TYPEMAP {
  %append_output(SWIG_FromCharPtrAndSize($1,SIZE));
}
%enddef



/*
 * %cstring_bounded_mutable(TYPEMAP, SIZE)
 *
 * This macro is used to wrap a string that's going to mutate.
 *
 *     %cstring_bounded_mutable(Char *in, 512);
 *     void foo(in *x) {
 *         while (*x) {
 *            *x = toupper(*x);
 *            x++;
 *         }
 *     }
 *
 */


%define Name ## _bounded_mutable(TYPEMAP,MAX)                              
%typemap(in,noblock=1,fragment=#SWIG_AsCharPtrAndSize) TYPEMAP 
  (int res,Char temp[MAX+1], Char *t = 0, size_t n = 0, int alloc = 0) {  
  res = SWIG_AsCharPtrAndSize($input, &t, &n, &alloc);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "TYPEMAP", $symname, $argnum);
  }
  if ( n > (size_t) MAX ) n = (size_t) MAX;
  memcpy(temp, t, sizeof(Char)*n);
  if (alloc == SWIG_NEWOBJ) %delete_array(t);
  temp[n - 1] = 0;                                                             
  $1 = ($1_ltype) temp;                                                    
}
%typemap(freearg,match="in") TYPEMAP "";
%typemap(argout,noblock=1,fragment=#SWIG_FromCharPtr) TYPEMAP {
  $1[MAX] = 0;
  %append_output(SWIG_FromCharPtr($1));
}
%enddef


/*
 * %cstring_mutable(TYPEMAP [, expansion])
 *
 * This macro is used to wrap a string that will mutate in place.
 * It may change size up to a user-defined expansion. 
 *
 *     %cstring_mutable(Char *in);
 *     void foo(in *x) {
 *         while (*x) {
 *            *x = toupper(*x);
 *            x++;
 *         }
 *     }
 *
 */

%define Name ## _mutable(TYPEMAP,EXP...)                  
%typemap(in,noblock=1,fragment=#SWIG_AsCharPtrAndSize) TYPEMAP (int res, Char *t = 0, size_t n = 0, int alloc = 0, size_t expansion = 0) {
#if #EXP != ""
  expansion += EXP;
#endif
  res = SWIG_AsCharPtrAndSize($input, &t, &n, &alloc);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "TYPEMAP", $symname, $argnum);
  }
  $1 = %new_array(n+expansion, $*1_ltype);          
  memcpy($1,t,sizeof(Char)*n);
  if (alloc == SWIG_NEWOBJ) %delete_array(t);
  $1[n-1] = 0;
}
%typemap(freearg,match="in") TYPEMAP "";
%typemap(argout,noblock=1,fragment=#SWIG_FromCharPtr) TYPEMAP { 
  %append_output(SWIG_FromCharPtr($1));
  %delete_array($1);                                  
}
%enddef


/*
 * %cstring_output_maxsize(TYPEMAP, SIZE)
 *
 * This macro returns data in a string of some user-defined size.
 *
 *     %cstring_output_maxsize(Char *outx, int max) {
 *     void foo(Char *outx, int max) {
 *         sprintf(outx,"blah blah\n");
 *     }
 */

%define Name ## _output_maxsize(TYPEMAP, SIZE)                       
%typemap(in,noblock=1,fragment=SWIG_AsVal_frag(size_t)) (TYPEMAP, SIZE) (int res, size_t size, Char *buff = 0) {   
  res = SWIG_AsVal(size_t)($input, &size);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "(TYPEMAP, SIZE)", $symname, $argnum);
  }
  buff= %new_array(size+1, Char);
  $2 = %numeric_cast(size, $2_ltype);
  $1 = %static_cast(buff, $1_ltype);
}
%typemap(freearg,noblock=1,match="in") (TYPEMAP,SIZE) {
  if (buff$argnum) %delete_array(buff$argnum);
} 
%typemap(argout,noblock=1,fragment=#SWIG_FromCharPtr) (TYPEMAP,SIZE) { 
  %append_output(SWIG_FromCharPtr($1));
}
%enddef

/*
 * %cstring_output_withsize(TYPEMAP, SIZE)
 *
 * This macro is used to return Character data along with a size
 * parameter.
 *
 *     %cstring_output_maxsize(Char *outx, int *max) {
 *     void foo(Char *outx, int *max) {
 *         sprintf(outx,"blah blah\n");
 *         *max = strlen(outx);  
 *     }
 */

%define Name ## _output_withsize(TYPEMAP, SIZE)                        
%typemap(in,noblock=1,fragment=SWIG_AsVal_frag(size_t)) (TYPEMAP, SIZE) (int res, size_t n, Char *buff = 0, $*2_ltype size) {    
  res = SWIG_AsVal(size_t)($input, &n);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "(TYPEMAP, SIZE)", $symname, $argnum);
  }
  buff= %new_array(n+1, Char);
  $1 = %static_cast(buff, $1_ltype);
  size = %numeric_cast(n,$*2_ltype);
  $2 = &size;
}								       
%typemap(freearg,noblock=1,match="in")(TYPEMAP,SIZE) {
  if (buff$argnum) %delete_array(buff$argnum);
} 
%typemap(argout,noblock=1,fragment=#SWIG_FromCharPtrAndSize) (TYPEMAP,SIZE) { 
  %append_output(SWIG_FromCharPtrAndSize($1,*$2));
}
%enddef


/*
 * %cstring_output_allocate(TYPEMAP, RELEASE)
 *
 * This macro is used to return Character data that was
 * allocated with new or malloc.
 *
 *     %cstring_output_allocated(Char **outx, free($1));
 *     void foo(Char **outx) {
 *         *outx = (Char *) malloc(512);
 *         sprintf(outx,"blah blah\n");
 *     }
 */
 
%define Name ## _output_allocate(TYPEMAP, RELEASE)           
%typemap(in,noblock=1,numinputs=0) TYPEMAP($*1_ltype temp = 0) {
  $1 = &temp;
}
%typemap(freearg,match="in") TYPEMAP "";
%typemap(argout,noblock=1,fragment=#SWIG_FromCharPtr) TYPEMAP { 
  if (*$1) {
    %append_output(SWIG_FromCharPtr(*$1));
    RELEASE;					  	     
  }					  	     
}							     
%enddef


/*
 * %cstring_output_allocate_size(TYPEMAP, SIZE, RELEASE)
 *
 * This macro is used to return Character data that was
 * allocated with new or malloc.
 *
 *     %cstring_output_allocated(Char **outx, int *sz, free($1));
 *     void foo(Char **outx, int *sz) {
 *         *outx = (Char *) malloc(512);
 *         sprintf(outx,"blah blah\n");
 *         *sz = strlen(outx);
 *     }
 */

%define Name ## _output_allocate_size(TYPEMAP, SIZE, RELEASE)
%typemap(in,noblock=1,numinputs=0) (TYPEMAP, SIZE) ($*1_ltype temp = 0, $*2_ltype tempn) {
  $1 = &temp; $2 = &tempn;
}
%typemap(freearg,match="in") (TYPEMAP,SIZE) "";
%typemap(argout,noblock=1,fragment=#SWIG_FromCharPtrAndSize)(TYPEMAP,SIZE) {   
  if (*$1) {
    %append_output(SWIG_FromCharPtrAndSize(*$1,*$2));
    RELEASE;
  }
}
%enddef

%enddef




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/cwstring.swg
================================================
%include <typemaps/cstrings.swg>
%include <typemaps/wstring.swg>

%typemaps_cstring(%cwstring,
		 wchar_t,
		 SWIG_AsWCharPtr,
		 SWIG_AsWCharPtrAndSize,
		 SWIG_FromWCharPtr,
		 SWIG_FromWCharPtrAndSize);




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/enumint.swg
================================================
/* ------------------------------------------------------------
 *  Enums mapped as integer values
 * ------------------------------------------------------------ */

%apply int { enum SWIGTYPE };
%apply const int& { const enum SWIGTYPE & };
%apply const int& { const enum SWIGTYPE && };

%typemap(in,fragment=SWIG_AsVal_frag(int),noblock=1) const enum SWIGTYPE & (int val, int ecode, $basetype temp) {  
  ecode = SWIG_AsVal(int)($input, &val);
  if (!SWIG_IsOK(ecode)) {
    %argument_fail(ecode, "$type", $symname, $argnum);
  } else {
    temp = %static_cast(val,$basetype);
    $1 = &temp;
  }
}

%typemap(in,fragment=SWIG_AsVal_frag(int),noblock=1) const enum SWIGTYPE && (int val, int ecode, $basetype temp) {  
  ecode = SWIG_AsVal(int)($input, &val);
  if (!SWIG_IsOK(ecode)) {
    %argument_fail(ecode, "$type", $symname, $argnum);
  } else {
    temp = %static_cast(val,$basetype);
    $1 = &temp;
  }
}

%typemap(varin,fragment=SWIG_AsVal_frag(int),noblock=1) enum SWIGTYPE {
  if (sizeof(int) != sizeof($1)) {
    %variable_fail(SWIG_AttributeError,"$type", "arch, read-only $name");
  }  else {
    int ecode = SWIG_AsVal(int)($input, %reinterpret_cast(&$1,int*));
    if (!SWIG_IsOK(ecode)) {
      %variable_fail(ecode, "$type", "$name");
    }
  }
}




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/exception.swg
================================================
/* -----------------------------------------------------------------------------
 * exceptions.swg
 *
 * This SWIG library file provides language independent exception handling
 * ----------------------------------------------------------------------------- */

%include <typemaps/swigmacros.swg>


/* macros for error manipulation */
#define %nullref_fmt()                     "invalid null reference "		   
#define %varfail_fmt(_type,_name)          "in variable '"`_name`"' of type '"`_type`"'"
#ifndef %argfail_fmt
#define %argfail_fmt(_type,_name,_argn)    "in method '" `_name` "', argument " `_argn`" of type '" `_type`"'"
#endif
#define %outfail_fmt(_type)                "in output value of type '"_type"'"
#ifndef	%argnullref_fmt
#define %argnullref_fmt(_type,_name,_argn) %nullref_fmt() %argfail_fmt(_type, _name, _argn)
#endif  
#define %varnullref_fmt(_type,_name)       %nullref_fmt() %varfail_fmt(_type, _name)  		   
#define %outnullref_fmt(_type)             %nullref_fmt() %outfail_fmt(_type)         

/* setting an error */
#define %error(code,msg...)               SWIG_Error(code, msg)
#define %type_error(msg...)               SWIG_Error(SWIG_TypeError,  msg)



%insert("runtime") {

%define_as(SWIG_exception_fail(code, msg), %block(%error(code, msg); SWIG_fail))

%define_as(SWIG_contract_assert(expr, msg), if (!(expr)) { %error(SWIG_RuntimeError, msg); SWIG_fail; } else)

}

#ifdef __cplusplus
/*
  You can use the SWIG_CATCH_STDEXCEPT macro with the %exception
  directive as follows:

  %exception {
    try {
      $action
    }
    catch (my_except& e) {
      ...
    }
    SWIG_CATCH_STDEXCEPT // catch std::exception
    catch (...) {
     SWIG_exception_fail(SWIG_UnknownError, "Unknown exception");
    }
  }
*/

%fragment("<stdexcept>");

%define SWIG_CATCH_STDEXCEPT
  /* catching std::exception  */
  catch (std::invalid_argument& e) {
    SWIG_exception_fail(SWIG_ValueError, e.what() );
  } catch (std::domain_error& e) {
    SWIG_exception_fail(SWIG_ValueError, e.what() );
  } catch (std::overflow_error& e) {
    SWIG_exception_fail(SWIG_OverflowError, e.what() );
  } catch (std::out_of_range& e) {
    SWIG_exception_fail(SWIG_IndexError, e.what() );
  } catch (std::length_error& e) {
    SWIG_exception_fail(SWIG_IndexError, e.what() );
  } catch (std::runtime_error& e) {
    SWIG_exception_fail(SWIG_RuntimeError, e.what() );
  } catch (std::exception& e) {
    SWIG_exception_fail(SWIG_SystemError, e.what() );
  }
%enddef
%define SWIG_CATCH_UNKNOWN
  catch (std::exception& e) {
    SWIG_exception_fail(SWIG_SystemError, e.what() );
  }
  catch (...) {
    SWIG_exception_fail(SWIG_UnknownError, "unknown exception");
  }
%enddef


#endif /* __cplusplus */



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/factory.swg
================================================
/*
  Implement a more natural wrap for factory methods, for example, if
  you have:

  ----  geometry.h --------
       struct Geometry {                          
         enum GeomType{			     
           POINT,				     
           CIRCLE				     
         };					     
         					     
         virtual ~Geometry() {}    		     
         virtual int draw() = 0;
	 
	 //
	 // Factory method for all the Geometry objects
	 //
         static Geometry *create(GeomType i);     
       };					     
       					     
       struct Point : Geometry  {		     
         int draw() { return 1; }		     
         double width() { return 1.0; }    	     
       };					     
       					     
       struct Circle : Geometry  {		     
         int draw() { return 2; }		     
         double radius() { return 1.5; }          
       }; 					     
       
       //
       // Factory method for all the Geometry objects
       //
       Geometry *Geometry::create(GeomType type) {
         switch (type) {			     
         case POINT: return new Point();	     
         case CIRCLE: return new Circle(); 	     
         default: return 0;			     
         }					     
       }					    
  ----  geometry.h --------


  You can use the %factory with the Geometry::create method as follows:

    %newobject Geometry::create;
    %factory(Geometry *Geometry::create, Point, Circle);
    %include "geometry.h"

  and Geometry::create will return a 'Point' or 'Circle' instance
  instead of the plain 'Geometry' type. For example, in python:

    circle = Geometry.create(Geometry.CIRCLE)
    r = circle.radius()

  where circle is a Circle proxy instance.

  NOTES: remember to fully qualify all the type names and don't
  use %factory inside a namespace declaration, ie, instead of
  
     namespace Foo {
       %factory(Geometry *Geometry::create, Point, Circle);
     }

  use

     %factory(Foo::Geometry *Foo::Geometry::create, Foo::Point,  Foo::Circle);   

     
*/

%define %_factory_dispatch(Type) 
if (!dcast) {
  Type *dobj = dynamic_cast<Type *>($1);
  if (dobj) {
    dcast = 1;
    %set_output(SWIG_NewPointerObj(%as_voidptr(dobj),$descriptor(Type *), $owner | %newpointer_flags));
  }   
}%enddef

%define %factory(Method,Types...)
%typemap(out) Method {
  int dcast = 0;
  %formacro(%_factory_dispatch, Types)
  if (!dcast) {
    %set_output(SWIG_NewPointerObj(%as_voidptr($1),$descriptor, $owner | %newpointer_flags));
  }
}%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/fragments.swg
================================================
/*
  Fragments
  =========
  See the "Typemap fragments" section in the documentation for understanding
  fragments. Below is some info on how fragments and automatic type
  specialization is used.

  Macros that make the automatic generation of typemaps easier are provided.

  Consider the following code:

      %fragment(SWIG_From_frag(bool), "header") {     
      static PyObject*		      
      SWIG_From_dec(bool)(bool value)	       
      {					       
        PyObject *obj = value ? Py_True : Py_False;  
        Py_INCREF(obj);			       
        return obj;				       
      }					       
      }					       
      					 
      %typemap(out, fragment=SWIG_From_frag(bool)) bool {
        $result = SWIG_From(bool)($1));
      }

  Here the macros

      SWIG_From_frag  => fragment 
      SWIG_From_dec   => declaration 
      SWIG_From       => call 
      
  allow you to define/include a fragment, and declare and call the
  'from-bool' method as needed. In the simpler case, these macros 
  just return something like

      SWIG_From_frag(bool)  => "SWIG_From_bool"
      SWIG_From_dec(bool)   =>  SWIG_From_bool
      SWIG_From(bool)       =>  SWIG_From_bool

  But they are specialized for the different languages requirements,
  such as perl or tcl that requires passing the interpreter pointer,
  and also they can manage C++ ugly types, for example:
  
      SWIG_From_frag(std::complex<double>)  => "SWIG_From_std_complex_Sl_double_Sg_"
      SWIG_From_dec(std::complex<double>)   =>  SWIG_From_std_complex_Sl_double_Sg_
      SWIG_From(std::complex<double>)       =>  SWIG_From_std_complex_Sl_double_Sg_


  Hence, to declare methods to use with typemaps, always use the
  SWIG_From* macros. In the same way, the SWIG_AsVal* and SWIG_AsPtr*
  set of macros are provided.
    
*/


/* -----------------------------------------------------------------------------
 * Define the basic macros to 'normalize' the type fragments
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_AS_DECL_ARGS
#define SWIG_AS_DECL_ARGS
#endif

#ifndef SWIG_FROM_DECL_ARGS
#define SWIG_FROM_DECL_ARGS
#endif

#ifndef SWIG_AS_CALL_ARGS
#define SWIG_AS_CALL_ARGS
#endif

#ifndef SWIG_FROM_CALL_ARGS
#define SWIG_FROM_CALL_ARGS
#endif

#define %fragment_name(Name, Type...)     %string_name(Name) "_" {Type}

#define SWIG_Traits_frag(Type...) %fragment_name(Traits, Type) 
#define SWIG_AsPtr_frag(Type...)  %fragment_name(AsPtr, Type)	 
#define SWIG_AsVal_frag(Type...)  %fragment_name(AsVal, Type)	 
#define SWIG_From_frag(Type...)   %fragment_name(From, Type)	 

#define SWIG_AsVal_name(Type...)  %symbol_name(AsVal, Type) 
#define SWIG_AsPtr_name(Type...)  %symbol_name(AsPtr, Type) 
#define SWIG_From_name(Type...)   %symbol_name(From, Type)  

#define SWIG_AsVal_dec(Type...)   SWIG_AsVal_name(Type) SWIG_AS_DECL_ARGS
#define SWIG_AsPtr_dec(Type...)   SWIG_AsPtr_name(Type) SWIG_AS_DECL_ARGS
#define SWIG_From_dec(Type...)    SWIG_From_name(Type)  SWIG_FROM_DECL_ARGS 

#define SWIG_AsVal(Type...)       SWIG_AsVal_name(Type) SWIG_AS_CALL_ARGS 
#define SWIG_AsPtr(Type...)  	  SWIG_AsPtr_name(Type) SWIG_AS_CALL_ARGS 	 
#define SWIG_From(Type...)   	  SWIG_From_name(Type)  SWIG_FROM_CALL_ARGS 

/* ------------------------------------------------------------
 * common fragments 
 * ------------------------------------------------------------ */

/* Default compiler options for gcc allow long_long but not LLONG_MAX. 
 * Define SWIG_NO_LLONG_MAX if this added limits support is not wanted. */
%fragment("<limits.h>","header") %{
#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif
%}

%fragment("<math.h>","header") %{
#include <math.h>
%}

%fragment("<wchar.h>","header") %{
#include <wchar.h>
#include <limits.h>
#ifndef WCHAR_MIN
#  define WCHAR_MIN 0
#endif
#ifndef WCHAR_MAX
#  define WCHAR_MAX 65535
#endif
%}

%fragment("<float.h>","header") %{
#include <float.h>
%}

%fragment("<stdio.h>","header") %{
#include <stdio.h>
#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
# ifndef snprintf
#  define snprintf _snprintf
# endif
#endif
%}

%fragment("<stdlib.h>","header") %{
#include <stdlib.h>
#ifdef _MSC_VER
# ifndef strtoull
#  define strtoull _strtoui64
# endif
# ifndef strtoll
#  define strtoll _strtoi64
# endif
#endif
%}

%fragment("<stddef.h>", "header") %{
#include <stddef.h>
%}

%fragment("<string>", "header") %{
#include <string>
%}

%fragment("<stdexcept>", "header") %{
#include <stdexcept>
%}

%fragment("<algorithm>", "header") %{
#include <algorithm>
%}

%fragment("SWIG_isfinite","header",fragment="<math.h>,<float.h>") %{
/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif
%}

%fragment("SWIG_Float_Overflow_Check","header",fragment="<float.h>,SWIG_isfinite") %{
/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif
%}

/* -----------------------------------------------------------------------------
 * special macros for fragments
 * ----------------------------------------------------------------------------- */

/* Macros to derive numeric types */

%define %numeric_type_from(Type, Base)
%fragment(SWIG_From_frag(Type),"header",
	  fragment=SWIG_From_frag(Base)) {
SWIGINTERNINLINE SWIG_Object
SWIG_From_dec(Type)(Type value)
{    
  return SWIG_From(Base)(value);
}
}
%enddef

%define %numeric_type_asval(Type, Base, Frag, OverflowCond)
%fragment(SWIG_AsVal_frag(Type),"header",
	  fragment=Frag,
	  fragment=SWIG_AsVal_frag(Base)) {
SWIGINTERN int
SWIG_AsVal_dec(Type)(SWIG_Object obj, Type *val)
{
  Base v;
  int res = SWIG_AsVal(Base)(obj, &v);
  if (SWIG_IsOK(res)) {
    if (OverflowCond) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = %numeric_cast(v, Type);
    }
  }  
  return res;
}
}
%enddef

#define %numeric_signed_type_asval(Type, Base, Frag, Min, Max) \
%numeric_type_asval(Type, Base, Frag, (v < Min || v > Max))

#define %numeric_unsigned_type_asval(Type, Base, Frag, Max) \
%numeric_type_asval(Type, Base, Frag, (v > Max))


/* Macro for 'signed long' derived types */

%define %numeric_slong(Type, Frag, Min, Max)
%numeric_type_from(Type, long)
%numeric_signed_type_asval(Type, long, Frag , Min, Max)
%enddef

/* Macro for 'unsigned long' derived types */

%define %numeric_ulong(Type, Frag, Max)
%numeric_type_from(Type, unsigned long)
%numeric_unsigned_type_asval(Type, unsigned long, Frag, Max)
%enddef


/* Macro for floating point derived types (original macro) */

%define %numeric_double(Type, Frag, Min, Max)
%numeric_type_from(Type, double)
%numeric_signed_type_asval(Type, double, Frag , Min, Max)
%enddef

/* Macro for floating point derived types */

%define %numeric_float(Type, Frag, OverflowCond)
%numeric_type_from(Type, double)
%numeric_type_asval(Type, double, Frag, OverflowCond)
%enddef


/* Macros for missing fragments */

%define %ensure_fragment(Fragment)
%fragment(`Fragment`,"header") {
%#error "SWIG language implementation must provide the Fragment fragment"
}
%enddef

%define %ensure_type_fragments(Type)
%fragment(SWIG_From_frag(Type),"header") {
%#error "SWIG language implementation must provide a SWIG_From_frag(Type) fragment"
}
%fragment(SWIG_AsVal_frag(Type),"header") {
%#error "SWIG language implementation must provide a SWIG_AsVal_frag(Type) fragment"
}
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/implicit.swg
================================================
/*
  The %implicit macro allows a SwigType (Class) to be accepted
  as an input parameter and use its implicit constructors when needed.

  For example:


  %implicit(A, int, double, B);

  %inline 
  {
    struct B { };  
    struct A
    {
      int ii;
      A(int i) { ii = 1; }
      A(double d) { ii = 2; }
      A(const B& b) { ii = 3; }
    };
  
    int get(A a) { return a.ii; }
  }

  Here, you can call 'get' as 

    get(1)    ==> get(A(1))
    get(2.0)  ==> get(A(2.0))
    get(B())  ==> get(A(B()))

   and swig will construct an 'A' temporal variable using the
   corresponding implicit constructor.


  The plain implicit macro takes care of simple type list. If it doesn't
  work because you are passing template types with commas, then use
  the %implicit_{1,2,3} versions and/or the %arg macro.

*/

%define %implicit_type(Type...)
%traits_swigtype(Type);
%enddef

%define %implicit_frag(Type...) ,fragment=SWIG_Traits_frag(Type) %enddef

%define %implicit_code(Type...)
{
  Type _v;
  int res = swig::asval<Type >(obj, &_v);  
  if (SWIG_IsOK(res)) {
    if (val) *val = new value_type(static_cast<const Type& >(_v));
    return SWIG_AddNewMask(res);
  }
}
%enddef

/* implicit */

%define %implicit(Type, ...)

%formacro_1(%implicit_type,__VA_ARGS__);

%fragment(SWIG_Traits_frag(Type),"header",
	  fragment="StdTraits"
          %formacro_1(%implicit_frag,__VA_ARGS__)) %{
namespace swig {
  template <>  struct traits<Type > {   
    typedef pointer_category category;
    static const char* type_name() { return "Type"; }
  };
   
  template <> struct traits_asptr< Type > {
  typedef Type value_type;
  static int asptr(SWIG_Object obj, value_type **val) { 
    Type *vptr;
    static swig_type_info* desc = SWIG_TypeQuery("Type *");
    int res = SWIG_ConvertPtr(obj, (void **)&vptr, desc, 0);
    if (SWIG_IsOK(res)) {
      if (val) *val = vptr;
      return res;
    } else {
      %formacro_1(%implicit_code,__VA_ARGS__)
    }
    return SWIG_TypeError;
  }
 };
}
%}

%typemap_traits_ptr(%checkcode(POINTER),Type);
%enddef

/* implicit_1 */


%define %implicit_1(Type, Imp1)
%traits_swigtype(Imp1);

%fragment(SWIG_Traits_frag(Type),"header",
	  fragment="StdTraits",
	  fragment=SWIG_Traits_frag(Imp1)) %{
namespace swig {
  template <>  struct traits< Type > {   
    typedef pointer_category category;
    static const char* type_name() { return "Type"; }
  };
   
  template <> struct traits_asptr< Type > {   
  typedef Type value_type;
  static int asptr(SWIG_Object obj, value_type **val) { 
    Type *vptr;
    static swig_type_info* desc = SWIG_TypeQuery("Type *");
    int res = SWIG_ConvertPtr(obj, (void **)&vptr, desc, 0);
    if (SWIG_IsOK(res)) {
      if (val) *val = vptr;
      return res;
    } else {
      %implicit_code(Imp1);
    }
    return SWIG_TypeError;
  }
 };
}
%}

%typemap_traits_ptr(%checkcode(POINTER),Type);

%enddef

/* implicit_2 */

%define %implicit_2(Type, Imp1, Imp2)
%traits_swigtype(Imp1);
%traits_swigtype(Imp2);

%fragment(SWIG_Traits_frag(Type),"header",
	  fragment="StdTraits",
	  fragment=SWIG_Traits_frag(Imp1),
	  fragment=SWIG_Traits_frag(Imp2)) %{
namespace swig {
  template <>  struct traits< Type > {   
    typedef pointer_category category;
    static const char* type_name() { return "Type"; }
  };

  template <> struct traits_asptr< Type > {   
  typedef Type value_type;
  static int asptr(SWIG_Object obj, value_type **val) { 
    Type *vptr;
    static swig_type_info* desc = SWIG_TypeQuery("Type *");
    int res = SWIG_ConvertPtr(obj, (void **)&vptr, desc, 0);
    if (SWIG_IsOK(res)) {
      if (val) *val = vptr;
      return SWIG_OLDOBJ;
    } else {
      %implicit_code(Imp1);
      %implicit_code(Imp2);
    }
    return SWIG_TypeError;
  }
 };
}
%}

%typemap_traits_ptr(%checkcode(POINTER),Type);
%enddef


/* implicit_3 */

%define %implicit_3(Type, Imp1, Imp2, Imp3)
%traits_swigtype(Imp1);
%traits_swigtype(Imp2);
%traits_swigtype(Imp3);

%fragment(SWIG_Traits_frag(Type),"header",
	  fragment="StdTraits",
	  fragment=SWIG_Traits_frag(Imp1),
	  fragment=SWIG_Traits_frag(Imp2),
	  fragment=SWIG_Traits_frag(Imp3)) %{
namespace swig {
  template <>  struct traits< Type > {   
    typedef pointer_category category;
    static const char* type_name() { return "Type"; }
  };

  template <> struct traits_asptr< Type > {   
    typedef Type value_type;
    static int asptr(SWIG_Object obj, value_type **val) { 
    Type *vptr;
    static swig_type_info* desc = SWIG_TypeQuery("Type *");
    int res = SWIG_ConvertPtr(obj, (void **)&vptr, desc, 0);
    if (SWIG_IsOK(res)) {
      if (val) *val = vptr;
      return res;
    } else {
      %implicit_code(Imp1);
      %implicit_code(Imp2);
      %implicit_code(Imp3);
    }
    return SWIG_TypeError;
  }
 };
}
%}

%typemap_traits_ptr(%checkcode(POINTER),Type);
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/inoutlist.swg
================================================
/*  ------------------------------------------------------------
 *
 * Define the IN/OUTPUT typemaps assuming the output parameters are
 * returned in a list, i.e., they are not directly modified.
 *
 * The user should provide the %append_output(result, obj) method,
 * via a macro, which append a particular object to the result.
 *
 *
 * In Tcl, for example, the file is used as:
 *
 *   #define %append_output(obj) Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),obj);
 *   %include <typemaps/inoutlist.swg>
 *
 * while in Python it is used as:
 *
 *   #define %append_output(obj) $result = SWIG_Python_AppendResult($result, obj)
 *   %include <typemaps/inoutlist.swg>
 *
 * where the method SWIG_Python_AppendResult is defined inside the
 * %append_output fragment.
 *
 * If you forget to define %append_output, this file will generate
 * an error.
 *
 * ------------------------------------------------------------ */


//
// Uncomment the following definition if you don't want the in/out
// typemaps by default, ie, you prefer to use typemaps.i.
//
//#define SWIG_INOUT_NODEF

//
// Use the following definition to enable the INPUT parameters to
// accept both 'by value' and 'pointer' objects.
//
#define SWIG_INPUT_ACCEPT_PTRS

// ------------------------------------------------------------------------
// Pointer handling
//
// These mappings provide support for input/output arguments and common
// uses for C/C++ pointers.
// ------------------------------------------------------------------------

// INPUT typemaps.
// These remap a C pointer to be an "INPUT" value which is passed by value
// instead of reference.

/* 
The following methods can be applied to turn a pointer into a simple
"input" value.  That is, instead of passing a pointer to an object,
you would use a real value instead.
         
To use these, suppose you had a C function like this :

        double fadd(double *a, double *b) {
               return *a+*b;
        }

You could wrap it with SWIG as follows :

        double fadd(double *INPUT, double *INPUT);

or you can use the %apply directive :

        %apply double *INPUT { double *a, double *b };
        double fadd(double *a, double *b);

*/
#if defined(SWIG_INPUT_ACCEPT_PTRS)
#define %check_input_ptr(input,arg,desc,disown) (SWIG_IsOK((res = SWIG_ConvertPtr(input,%as_voidptrptr(arg),desc,disown))))
#else
#define %check_input_ptr(input,arg,desc,disown) (SWIG_IsOK((res = SWIG_ERROR)))
#endif

%define %_value_input_typemap(code, asval_meth, asval_frag, Type)
  %typemap(in,noblock=1,fragment=asval_frag) Type *INPUT ($*ltype temp, int res = 0) {
    if (!%check_input_ptr($input,&$1,$descriptor,$disown)) {
      Type val; 
      int ecode = asval_meth($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	%argument_fail(ecode, "$*ltype",$symname, $argnum);
      }
      temp = %static_cast(val, $*ltype);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(in,noblock=1,fragment=asval_frag) Type &INPUT($*ltype temp, int res = 0) {
    if (!%check_input_ptr($input,&$1,$descriptor,$disown)) {
      Type val;
      int ecode = asval_meth($input, &val);
      if (!SWIG_IsOK(ecode)) { 
	%argument_fail(ecode, "$*ltype",$symname, $argnum);
      }
      temp = %static_cast(val, $*ltype);
      $1 = &temp;
      res = SWIG_AddTmpMask(ecode);
    }
  }
  %typemap(freearg,noblock=1,match="in") Type *INPUT, Type &INPUT {
    if (SWIG_IsNewObj(res$argnum)) %delete($1);
  }
  %typemap(typecheck,noblock=1,precedence=code,fragment=asval_frag) Type *INPUT, Type &INPUT {
    void *ptr = 0;
    int res = asval_meth($input, 0);
    $1 = SWIG_CheckState(res);
    if (!$1) {
      $1 = %check_input_ptr($input,&ptr,$1_descriptor,0);
    }
  }
%enddef

%define %_ptr_input_typemap(code,asptr_meth,asptr_frag,Type)
  %typemap(in,noblock=1,fragment=asptr_frag) Type *INPUT(int res = 0) {  
    res = asptr_meth($input, &$1);
    if (!SWIG_IsOK(res)) {
      %argument_fail(res,"$type",$symname, $argnum);
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(in,noblock=1,fragment=asptr_frag) Type &INPUT(int res = 0) {  
    res = asptr_meth($input, &$1);
    if (!SWIG_IsOK(res)) { 
      %argument_fail(res,"$type",$symname, $argnum);
    }     
    if (!$1) { 
      %argument_nullref("$type",$symname, $argnum);
    }
    res = SWIG_AddTmpMask(res);
  }
  %typemap(freearg,noblock=1,match="in") Type *INPUT, Type &INPUT {
    if (SWIG_IsNewObj(res$argnum)) %delete($1);
  }
  %typemap(typecheck,noblock=1,precedence=code,fragment=asptr_frag) Type *INPUT, Type &INPUT {
    int res = asptr_meth($input, (Type**)0);
    $1 = SWIG_CheckState(res);
  }
%enddef

// OUTPUT typemaps.   These typemaps are used for parameters that
// are output only.   The output value is appended to the result as
// a list element.

/* 
The following methods can be applied to turn a pointer into an "output"
value.  When calling a function, no input value would be given for
a parameter, but an output value would be returned.  In the case of
multiple output values, they are returned in the form of a list.

         
For example, suppose you were trying to wrap the modf() function in the
C math library which splits x into integral and fractional parts (and
returns the integer part in one of its parameters):

        double modf(double x, double *ip);

You could wrap it with SWIG as follows :

        double modf(double x, double *OUTPUT);

or you can use the %apply directive :

        %apply double *OUTPUT { double *ip };
        double modf(double x, double *ip);

The output of the function would be a list containing both output
values.

*/

%define %_value_output_typemap(from_meth, from_frag, Type)
 %typemap(in,numinputs=0,noblock=1) 
   Type *OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ), 
   Type &OUTPUT ($*1_ltype temp, int res = SWIG_TMPOBJ) {
   $1 = &temp;
 }
 %typemap(argout,noblock=1,fragment=from_frag) Type *OUTPUT, Type &OUTPUT {
   if (SWIG_IsTmpObj(res$argnum)) {
     %append_output(from_meth((*$1)));
   } else {
     int new_flags = SWIG_IsNewObj(res$argnum) ? (SWIG_POINTER_OWN | %newpointer_flags) : %newpointer_flags;
     %append_output(SWIG_NewPointerObj((void*)($1), $1_descriptor, new_flags));
   }
 }
%enddef


// INOUT
// Mappings for an argument that is both an input and output
// parameter

/*
The following methods can be applied to make a function parameter both
an input and output value.  This combines the behavior of both the
"INPUT" and "OUTPUT" methods described earlier.  Output values are
returned in the form of a list.  
         
For example, suppose you were trying to wrap the following function :

        void neg(double *x) {
             *x = -(*x);
        }

You could wrap it with SWIG as follows :

        void neg(double *INOUT);

or you can use the %apply directive :

        %apply double *INOUT { double *x };
        void neg(double *x);

Unlike C, this mapping does not directly modify the input value.
Rather, the modified input value shows up as the return value of the
function.  Thus, to apply this function to a variable you might do
this :

       x = neg(x)

Note : previous versions of SWIG used the symbol 'BOTH' to mark
input/output arguments.   This is still supported, but will be slowly
phased out in future releases.

*/

%define %_value_inout_typemap(Type)
 %typemap(in) Type *INOUT = Type *INPUT;
 %typemap(in) Type &INOUT = Type &INPUT;
 %typemap(typecheck) Type *INOUT = Type *INPUT;
 %typemap(typecheck) Type &INOUT = Type &INPUT;
 %typemap(argout) Type *INOUT = Type *OUTPUT;
 %typemap(argout) Type &INOUT = Type &OUTPUT;
%enddef


%define %_ptr_inout_typemap(Type)
 %_value_inout_typemap(%arg(Type))
 %typemap(typecheck) Type *INOUT = Type *INPUT;
 %typemap(typecheck) Type &INOUT = Type &INPUT;
 %typemap(freearg) Type *INOUT = Type *INPUT;
 %typemap(freearg) Type &INOUT = Type &INPUT;
%enddef

#ifndef SWIG_INOUT_NODEF

%define %value_input_typemap(code,asval_meth, asval_frag, Type...)
  %_value_input_typemap(%arg(code),%arg(asval_meth),%arg(asval_frag),%arg(Type))
%enddef

%define %ptr_input_typemap(code,asval_meth,asval_frag,Type...)		
  %_ptr_input_typemap(%arg(code),%arg(asval_meth),%arg(asval_frag),%arg(Type))
%enddef

%define %value_output_typemap(from_meth,from_frag,Type...)		
  %_value_output_typemap(%arg(from_meth),%arg(from_frag),%arg(Type))
%enddef

#define %value_inout_typemap(Type...) %_value_inout_typemap(%arg(Type))
#define %ptr_inout_typemap(Type...) %_ptr_inout_typemap(%arg(Type))

#else /* You need to include typemaps.i */


#define %value_output_typemap(Type...)
#define %value_input_typemap(Type...)
#define %value_inout_typemap(Type...)
#define %ptr_input_typemap(Type...)
#define %ptr_inout_typemap(Type...)

#endif /* SWIG_INOUT_DEFAULT */

/*----------------------------------------------------------------------
  Front ends.
  
  use the following macros to define your own IN/OUTPUT/INOUT typemaps
  
  ------------------------------------------------------------------------*/
%define %typemaps_inout(Code, AsValMeth, FromMeth, AsValFrag, FromFrag, Type...)
  %_value_input_typemap(%arg(Code), %arg(AsValMeth), 
			    %arg(AsValFrag), %arg(Type));
  %_value_output_typemap(%arg(FromMeth), %arg(FromFrag), %arg(Type));
  %_value_inout_typemap(%arg(Type));
%enddef

%define %typemaps_inoutn(Code,Type...)
  %typemaps_inout(%arg(Code),
		 %arg(SWIG_AsVal(Type)), 
		 %arg(SWIG_From(Type)), 
		 %arg(SWIG_AsVal_frag(Type)), 
		 %arg(SWIG_From_frag(Type)), 
		 %arg(Type));
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/misctypes.swg
================================================

/* ------------------------------------------------------------
 * --- ANSI/Posix C/C++ types ---
 * ------------------------------------------------------------ */


#ifdef __cplusplus

%apply size_t { std::size_t };
%apply const size_t& { const std::size_t& };

%apply ptrdiff_t { std::ptrdiff_t };
%apply const ptrdiff_t& { const std::ptrdiff_t& };

#ifndef SWIG_INOUT_NODEF
%apply size_t& { std::size_t& };
%apply ptrdiff_t& { std::ptrdiff_t& };
#endif

#endif




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/primtypes.swg
================================================
/* ------------------------------------------------------------
 * Primitive type fragments and macros 
 * ------------------------------------------------------------ */

/*
  This file provide fragments and macros for the C/C++ primitive types. 

  The file defines default fragments for the following types:

    bool
    signed char
    unsigned char
    signed wchar_t     // in C++
    unsigned wchar_t   // in C++
    short
    unsigned short
    int
    unsigned int
    float
    size_t
    ptrdiff_t

  which can always be redefined in the swig target language if needed.
  
  The fragments for the following types, however, always need to be
  defined in the target language:

    long
    unsigned long
    long long
    unsigned long long
    double
 
  If they are not provided, an #error directive will appear in the
  wrapped code.

  --------------------------------------------------------------------
  
  This file provides the macro

    %typemaps_primitive(CheckCode, Type)

  which generates the typemaps for a primitive type with a given
  checkcode. It is assumed that the primitive type is 'normalized' and
  the corresponding SWIG_AsVal(Type) and SWIG_From(Type) methods are
  provided via fragments.
  
   
  The following auxiliary macros (explained with bash pseudo code) are
  also defined:

    %apply_ctypes(Macro)
      for i in C Type
      do
        Macro($i)
      done

    %apply_cpptypes(Macro)
      for i in C++ Type
      do
        Macro($i)
      done

    %apply_ctypes_2(Macro2)
       for i in C Type
       do
         for j in C Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_cpptypes_2(Macro2)
       for i in C++ Type
       do
         for j in C++ Type
         do
            Macro_2($i, $j)
         done
       done

    %apply_checkctypes(Macro2)
       for i in Check Type
       do
         Macro2(%checkcode($i), $i)
       done

*/


/* ------------------------------------------------------------
 * Primitive type fragments 
 * ------------------------------------------------------------ */
/* boolean */

%fragment(SWIG_From_frag(bool),"header",fragment=SWIG_From_frag(long)) {
SWIGINTERN SWIG_Object
SWIG_From_dec(bool)(bool value)
{    
  return SWIG_From(long)(value ? 1 : 0);
}
}

%fragment(SWIG_AsVal_frag(bool),"header",fragment=SWIG_AsVal_frag(long)) {
SWIGINTERN int
SWIG_AsVal_dec(bool)(SWIG_Object obj, bool *val)
{
  long v;
  int res = SWIG_AsVal(long)(obj, val ? &v : 0);
  if (SWIG_IsOK(res)) {    
    if (val) *val = v ? true : false;
    return res;
  }  
  return SWIG_TypeError;
}
}

/* signed/unsigned char */

%numeric_slong(signed char,     "<limits.h>", SCHAR_MIN, SCHAR_MAX)
%numeric_ulong(unsigned char,   "<limits.h>", UCHAR_MAX)

/* short/unsigned short */

%numeric_slong(short,           "<limits.h>", SHRT_MIN, SHRT_MAX)
%numeric_ulong(unsigned short,  "<limits.h>", USHRT_MAX)

/* int/unsigned int */

%numeric_slong(int,             "<limits.h>", INT_MIN, INT_MAX)
%numeric_ulong(unsigned int,    "<limits.h>", UINT_MAX)

/* signed/unsigned wchar_t */

#ifdef __cplusplus
%numeric_slong(signed wchar_t,   "<wchar.h>", WCHAR_MIN, WCHAR_MAX)
%numeric_ulong(unsigned wchar_t, "<wchar.h>", UWCHAR_MAX)
#endif

/* float */

%numeric_float(float,           "SWIG_Float_Overflow_Check", SWIG_Float_Overflow_Check(v))

/* long/unsigned long */

%ensure_type_fragments(long)
%ensure_type_fragments(unsigned long)

/* long long/unsigned long long */

%ensure_type_fragments(long long)
%ensure_type_fragments(unsigned long long)

/* double */

%ensure_type_fragments(double)

/* size_t */

%fragment(SWIG_From_frag(size_t),"header",fragment=SWIG_From_frag(unsigned long)) {
SWIGINTERNINLINE SWIG_Object
SWIG_From_dec(size_t)(size_t value)
{    
  return SWIG_From(unsigned long)(%numeric_cast(value, unsigned long));
}
}

%fragment(SWIG_AsVal_frag(size_t),"header",fragment=SWIG_AsVal_frag(unsigned long)) {
SWIGINTERNINLINE int
SWIG_AsVal_dec(size_t)(SWIG_Object obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal(unsigned long)(obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = %numeric_cast(v, size_t);
  return res;
}
}

/* ptrdiff_t */

%fragment(SWIG_From_frag(ptrdiff_t),"header",fragment=SWIG_From_frag(long)) {
SWIGINTERNINLINE SWIG_Object
SWIG_From_dec(ptrdiff_t)(ptrdiff_t value)
{    
  return SWIG_From(long)(%numeric_cast(value,long));
}
}

%fragment(SWIG_AsVal_frag(ptrdiff_t),"header",fragment=SWIG_AsVal_frag(long)) {
SWIGINTERNINLINE int
SWIG_AsVal_dec(ptrdiff_t)(SWIG_Object obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal(long)(obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = %numeric_cast(v, ptrdiff_t);
  return res;
}
}


%fragment("SWIG_CanCastAsInteger","header",
	  fragment=SWIG_AsVal_frag(double),
	  fragment="<float.h>",
	  fragment="<math.h>") {
SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}
}

/* ------------------------------------------------------------
 * Generate the typemaps for primitive type 
 * ------------------------------------------------------------ */

#define %typemaps_primitive(Code, Type) %typemaps_asvalfromn(%arg(Code), Type)

/* ------------------------------------------------------------
 * Primitive Type Macros
 * ------------------------------------------------------------ */

/* useful macros to derive typemap declarations from primitive types */

%define _apply_macro(macro, arg2, arg1...)
#if #arg1 != ""
macro(%arg(arg1),arg2);
#else
macro(arg2);
#endif
%enddef

/* Apply macro to the C-types */
%define %apply_ctypes(Macro, Arg2...)
_apply_macro(Macro, bool               , Arg2);
_apply_macro(Macro, signed char        , Arg2);
_apply_macro(Macro, unsigned char      , Arg2);
_apply_macro(Macro, short              , Arg2);
_apply_macro(Macro, unsigned short     , Arg2);
_apply_macro(Macro, int                , Arg2);
_apply_macro(Macro, unsigned int       , Arg2);
_apply_macro(Macro, long               , Arg2);
_apply_macro(Macro, unsigned long      , Arg2);
_apply_macro(Macro, long long          , Arg2);
_apply_macro(Macro, unsigned long long , Arg2);
_apply_macro(Macro, float              , Arg2);
_apply_macro(Macro, double             , Arg2);
_apply_macro(Macro, char               , Arg2);
_apply_macro(Macro, wchar_t            , Arg2);
_apply_macro(Macro, size_t             , Arg2);
_apply_macro(Macro, ptrdiff_t          , Arg2);
%enddef

/* apply the Macro2(Type1, Type2) to all  C types  */
#define %apply_ctypes_2(Macro2) %apply_ctypes(%apply_ctypes, Macro2)


/* apply the Macro(Type) to all  C++ types  */
%define %apply_cpptypes(Macro, Arg2...)
%apply_ctypes(Macro, Arg2)
_apply_macro(Macro, std::size_t, Arg2);
_apply_macro(Macro, std::ptrdiff_t, Arg2);
_apply_macro(Macro, std::string, Arg2);
_apply_macro(Macro, std::wstring, Arg2);
_apply_macro(Macro, std::complex<float>, Arg2);
_apply_macro(Macro, std::complex<double>, Arg2);
%enddef

/* apply the Macro2(Type1, Type2) to all  C++ types  */
#define %apply_cpptypes_2(Macro2) %apply_cpptypes(%apply_cpptypes, Macro2)

/* apply the Macro2(CheckCode,Type) to all  Checked Types */
%define %apply_checkctypes(Macro2)
Macro2(%checkcode(BOOL),    bool);
Macro2(%checkcode(INT8),    signed char);
Macro2(%checkcode(UINT8),   unsigned char);
Macro2(%checkcode(INT16),   short);
Macro2(%checkcode(UINT16),  unsigned short);
Macro2(%checkcode(INT32),   int);
Macro2(%checkcode(UINT32),  unsigned int);
Macro2(%checkcode(INT64),   long);
Macro2(%checkcode(UINT64),  unsigned long);
Macro2(%checkcode(INT128),  long long);
Macro2(%checkcode(UINT128), unsigned long long);
Macro2(%checkcode(FLOAT),   float);
Macro2(%checkcode(DOUBLE),  double);
Macro2(%checkcode(CHAR),    char);
Macro2(%checkcode(UNICHAR), wchar_t);
Macro2(%checkcode(SIZE),    size_t);
Macro2(%checkcode(PTRDIFF), ptrdiff_t);
%enddef


/* ------------------------------------------------------------
 * Generate the typemaps for all the primitive types with checkcode
 * ------------------------------------------------------------ */

%apply_checkctypes(%typemaps_primitive);




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/ptrtypes.swg
================================================
/* -----------------------------------------------------------------------------
 * ptrtypes.swg
 *
 * Value typemaps (Type, const Type&) for "Ptr" types, such as swig
 * wrapped classes, that define the AsPtr/From methods
 *
 * To apply them, just use one of the following macros:
 *
 *    %typemaps_asptr(CheckCode, AsPtrMeth, AsPtrFrag, Type)
 *    %typemaps_asptrfrom(CheckCode, AsPtrMeth, FromMeth, AsPtrFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *    %typemaps_asptrfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %ptr_in_typemap(asptr_meth,frag,Type)
 *    %ptr_varin_typemap(asptr_meth,frag,Type)
 *    %ptr_typecheck_typemap(check,asptr_meth,frag,Type)
 *    %ptr_directorout_typemap(asptr_meth,frag,Type)
 * ----------------------------------------------------------------------------- */

%include <typemaps/valtypes.swg>

/* in */

%define %ptr_in_typemap(asptr_meth,frag,Type...)
  %typemap(in,fragment=frag) Type {
    Type *ptr = (Type *)0;
    int res = asptr_meth($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      %argument_fail((ptr ? res : SWIG_TypeError), "$type", $symname, $argnum); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) %delete(ptr);
  }
  %typemap(freearg) Type "";
  %typemap(in,fragment=frag) const Type & (int res = SWIG_OLDOBJ) {
    Type *ptr = (Type *)0;
    res = asptr_meth($input, &ptr);
    if (!SWIG_IsOK(res)) { %argument_fail(res,"$type",$symname, $argnum); }
    if (!ptr) { %argument_nullref("$type",$symname, $argnum); }
    $1 = ptr;
  }
  %typemap(freearg,noblock=1) const Type &  {
    if (SWIG_IsNewObj(res$argnum)) %delete($1);
  }
%enddef

/* varin */

%define %ptr_varin_typemap(asptr_meth,frag,Type...)
  %typemap(varin,fragment=frag) Type {
    Type *ptr = (Type *)0;
    int res = asptr_meth($input, &ptr);
    if (!SWIG_IsOK(res) || !ptr) { 
      %variable_fail((ptr ? res : SWIG_TypeError), "$type", "$name"); 
    }
    $1 = *ptr;
    if (SWIG_IsNewObj(res)) %delete(ptr);
  }
%enddef

#if defined(SWIG_DIRECTOR_TYPEMAPS)
/* directorout */

%define %ptr_directorout_typemap(asptr_meth,frag,Type...)
  %typemap(directorargout,noblock=1,fragment=frag) Type *DIRECTOROUT ($*ltype temp, int swig_ores) {
    Type *swig_optr = 0;
    swig_ores = $result ? asptr_meth($result, &swig_optr) : 0;
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      %dirout_fail((swig_optr ? swig_ores : SWIG_TypeError),"$type");
    }
    temp = *swig_optr;
    $1 = &temp;
    if (SWIG_IsNewObj(swig_ores)) %delete(swig_optr);
  }

  %typemap(directorout,noblock=1,fragment=frag) Type {
    Type *swig_optr = 0;
    int swig_ores = asptr_meth($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores) || !swig_optr) { 
      %dirout_fail((swig_optr ? swig_ores : SWIG_TypeError),"$type");
    }
    $result = *swig_optr;
    if (SWIG_IsNewObj(swig_ores)) %delete(swig_optr);
  }

  %typemap(directorout,noblock=1,fragment=frag,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) Type* {
    Type *swig_optr = 0;
    int swig_ores = asptr_meth($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      %dirout_fail(swig_ores,"$type");
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) Type*
  {
    if (director)  {
      director->swig_release_ownership(%as_voidptr($input));
    }
  }

  %typemap(directorout,noblock=1,fragment=frag,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) Type& {
    Type *swig_optr = 0;
    int swig_ores = asptr_meth($input, &swig_optr);
    if (!SWIG_IsOK(swig_ores)) { 
      %dirout_fail(swig_ores,"$type");
    } else {
      if (!swig_optr) { 
	%dirout_nullref("$type");
      } 
    }    
    $result = swig_optr;
    if (SWIG_IsNewObj(swig_ores)) {
      swig_acquire_ownership(swig_optr);
    }
  }
  %typemap(directorfree,noblock=1) Type&
  {
    if (director) {
      director->swig_release_ownership(%as_voidptr($input));
    }
  }


  %typemap(directorout,fragment=frag) Type &DIRECTOROUT = Type

%enddef

#else

#define %ptr_directorout_typemap(asptr_meth,frag,Type...) 

#endif /* SWIG_DIRECTOR_TYPEMAPS */

/* typecheck */

%define %ptr_typecheck_typemap(check,asptr_meth,frag,Type...)
%typemap(typecheck,noblock=1,precedence=check,fragment=frag) Type * {
  int res = asptr_meth($input, (Type**)(0));
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,noblock=1,precedence=check,fragment=frag) Type, const Type& {  
  int res = asptr_meth($input, (Type**)(0));
  $1 = SWIG_CheckState(res);
}
%enddef


/*---------------------------------------------------------------------
 * typemap definition for types with asptr method
 *---------------------------------------------------------------------*/

%define %typemaps_asptr(CheckCode, AsPtrMeth, AsPtrFrag, Type...)
  %fragment(SWIG_AsVal_frag(Type),"header",fragment=SWIG_AsPtr_frag(Type)) {
    SWIGINTERNINLINE int
    SWIG_AsVal(Type)(SWIG_Object obj, Type *val)
    {
      Type *v = (Type *)0;
      int res = SWIG_AsPtr(Type)(obj, &v);
      if (!SWIG_IsOK(res)) return res;
      if (v) {
	if (val) *val = *v;
	if (SWIG_IsNewObj(res)) {
	  %delete(v);
	  res = SWIG_DelNewMask(res);
	}
	return res;
      }
      return SWIG_ERROR;
    }
  }
  %ptr_in_typemap(%arg(AsPtrMeth), %arg(AsPtrFrag), Type);
  %ptr_varin_typemap(%arg(AsPtrMeth), %arg(AsPtrFrag), Type);
  %ptr_directorout_typemap(%arg(AsPtrMeth), %arg(AsPtrFrag), Type);
  %ptr_typecheck_typemap(%arg(CheckCode), %arg(AsPtrMeth),%arg(AsPtrFrag), Type);
  %ptr_input_typemap(%arg(CheckCode),%arg(AsPtrMeth),%arg(AsPtrFrag),Type);
%enddef

/*---------------------------------------------------------------------
 * typemap definition for types with asptr/from methods
 *---------------------------------------------------------------------*/

%define %typemaps_asptrfrom(CheckCode, AsPtrMeth, FromMeth, AsPtrFrag, FromFrag, Type...)
  %typemaps_asptr(%arg(CheckCode), %arg(AsPtrMeth), %arg(AsPtrFrag), Type)
  %typemaps_from(%arg(FromMeth), %arg(FromFrag), Type);
  %value_output_typemap(%arg(FromMeth), %arg(FromFrag), Type);
  %ptr_inout_typemap(Type);
%enddef

/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asptr/from methods
 *---------------------------------------------------------------------*/

%define %typemaps_asptrfromn(CheckCode, Type...)
%typemaps_asptrfrom(%arg(CheckCode),
		   %arg(SWIG_AsPtr(Type)), 
		   %arg(SWIG_From(Type)), 
		   %arg(SWIG_AsPtr_frag(Type)), 
		   %arg(SWIG_From_frag(Type)), 
		   Type);
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/std_except.swg
================================================
%include <typemaps/exception.swg>

/* 
   Mark all of std exception classes as "exception classes" via
   the "exceptionclass" feature.
   
   If needed, you can disable it by using %noexceptionclass.
*/

%define %std_exception_map(Exception, Code)
  %exceptionclass  Exception; 
#if !defined(SWIG_STD_EXCEPTIONS_AS_CLASSES)
  %typemap(throws,noblock=1) Exception {
    SWIG_exception_fail(Code, $1.what());
  }
  %ignore Exception;
  struct Exception {
  };
#endif
%enddef

namespace std {
  %std_exception_map(bad_exception,      SWIG_SystemError);
  %std_exception_map(domain_error,       SWIG_ValueError);
  %std_exception_map(exception,          SWIG_SystemError);
  %std_exception_map(invalid_argument,   SWIG_ValueError);
  %std_exception_map(length_error,       SWIG_IndexError);
  %std_exception_map(logic_error,        SWIG_RuntimeError);
  %std_exception_map(out_of_range,       SWIG_IndexError);
  %std_exception_map(overflow_error,     SWIG_OverflowError);
  %std_exception_map(range_error,        SWIG_OverflowError);
  %std_exception_map(runtime_error,      SWIG_RuntimeError);
  %std_exception_map(underflow_error,    SWIG_OverflowError);
}

%include <std/std_except.i>



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/std_string.swg
================================================
//
// String
//


#ifndef SWIG_STD_BASIC_STRING
#define SWIG_STD_STRING

%include <typemaps/std_strings.swg>

%fragment("<string>");

namespace std
{
  %naturalvar string;
  class string;
}

%typemaps_std_string(std::string, char, SWIG_AsCharPtrAndSize, SWIG_FromCharPtrAndSize, %checkcode(STDSTRING));

#else

%include <std/std_string.i>

#endif



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/std_strings.swg
================================================

/* defining the String asptr/from methods */

%define %std_string_asptr(String, Char, SWIG_AsCharPtrAndSize, Frag)
%fragment(SWIG_AsPtr_frag(String),"header",fragment=Frag) {
SWIGINTERN int
SWIG_AsPtr_dec(String)(SWIG_Object obj, String **val) 
{
  Char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new String(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) %delete_array(buf);
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery(#String " *");
      init = 1;
    }
    if (descriptor) {
      String *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}
}
%enddef

%define %std_string_from(String, SWIG_FromCharPtrAndSize, Frag)
%fragment(SWIG_From_frag(String),"header",fragment=Frag) {
SWIGINTERNINLINE SWIG_Object
SWIG_From_dec(String)(const String& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}
}
%enddef

%define %std_string_asval(String)
%fragment(SWIG_AsVal_frag(String),"header", fragment=SWIG_AsPtr_frag(String)) {
SWIGINTERN int
SWIG_AsVal_dec(String)(SWIG_Object obj, String *val)
{
  String* v = (String *) 0;
  int res = SWIG_AsPtr(String)(obj, &v);
  if (!SWIG_IsOK(res)) return res;
  if (v) {
    if (val) *val = *v;
    if (SWIG_IsNewObj(res)) {
      %delete(v);
      res = SWIG_DelNewMask(res);
    }
    return res;
  }
  return SWIG_ERROR;
}
}
%enddef


%define %typemaps_std_string(String, Char, AsPtrMethod, FromMethod, CheckCode)

%std_string_asptr(String, Char, AsPtrMethod, #AsPtrMethod)
%std_string_asval(String)
%std_string_from(String, FromMethod, #FromMethod)

%typemaps_asptrfromn(%arg(CheckCode), String);

%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/std_wstring.swg
================================================
%include <typemaps/wstring.swg>

#ifndef SWIG_STD_BASIC_STRING
#define SWIG_STD_WSTRING

%include <typemaps/std_strings.swg>

%{
#include <cwchar>
%}
%fragment("<string>");

namespace std
{
  %naturalvar wstring;
  class wstring;
}

%typemaps_std_string(std::wstring, wchar_t, SWIG_AsWCharPtrAndSize, SWIG_FromWCharPtrAndSize, %checkcode(STDUNISTRING));


#else

%include <std/std_wstring.i>

#endif



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/string.swg
================================================
%ensure_fragment(SWIG_AsCharPtrAndSize)
%ensure_fragment(SWIG_FromCharPtrAndSize)

%types(char *);

%fragment("SWIG_pchar_descriptor","header") {
SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}
}

%fragment("SWIG_strnlen","header",fragment="SWIG_FromCharPtrAndSize") {
size_t
SWIG_strnlen(const char* s, size_t maxlen)
{
  const char *p;
  for (p = s; maxlen-- && *p; p++)
    ;
  return p - s;
}
}

%include <typemaps/strings.swg>
%typemaps_string(%checkcode(STRING), %checkcode(CHAR),
		 char, Char, SWIG_AsCharPtrAndSize, SWIG_FromCharPtrAndSize,
		 strlen, SWIG_strnlen,
		"<limits.h>", CHAR_MIN, CHAR_MAX)



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/strings.swg
================================================
//
// Use the macro SWIG_PRESERVE_CARRAY_SIZE if you prefer to preserve
// the size of char arrays, ie
//  ------------------------------------------
//       C Side             =>   Language Side
//  ------------------------------------------
//   char name[5] = "hola"  =>   'hola\0'
//
// the default behaviour is 
//
//   char name[5] = "hola"  =>   'hola'
//
//
//#define SWIG_PRESERVE_CARRAY_SIZE

/* ------------------------------------------------------------
 *  String typemaps for type Char (char or wchar_t)
 * ------------------------------------------------------------ */

%define %_typemap_string(StringCode, 
			 Char,
			 SWIG_AsCharPtrAndSize,
			 SWIG_FromCharPtrAndSize,
			 SWIG_CharPtrLen,
			 SWIG_CharBufLen,
			 SWIG_AsCharPtr,
			 SWIG_FromCharPtr,
			 SWIG_AsCharArray,
                         SWIG_NewCopyCharArray,
                         SWIG_DeleteCharArray)

/* in */

%typemap(in,noblock=1,fragment=#SWIG_AsCharPtr) 
  Char * (int res, Char *buf = 0, int alloc = 0),
  const Char * (int res, Char *buf = 0, int alloc = 0) {
  res = SWIG_AsCharPtr($input, &buf, &alloc);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type",$symname, $argnum);
  }
  $1 = %reinterpret_cast(buf, $1_ltype);
}
%typemap(freearg,noblock=1,match="in") Char *, const Char * {
  if (alloc$argnum == SWIG_NEWOBJ) SWIG_DeleteCharArray(buf$argnum);
}

%typemap(in,noblock=1,fragment=#SWIG_AsCharPtr) Char const*& (int res, Char *buf = 0, int alloc = 0) {
  res = SWIG_AsCharPtr($input, &buf, &alloc);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type",$symname, $argnum);
  }
  $1 = &buf;
}    
%typemap(freearg, noblock=1,match="in") Char const*& {
  if (alloc$argnum == SWIG_NEWOBJ) SWIG_DeleteCharArray(buf$argnum);
}

/* out */

%typemap(out,noblock=1,fragment=#SWIG_FromCharPtr) Char *, const Char * {
  %set_output(SWIG_FromCharPtr((const Char *)$1));
}


%typemap(out,noblock=1,fragment=#SWIG_FromCharPtr) Char const*& {
  %set_output(SWIG_FromCharPtr(*$1));
}

%typemap(newfree,noblock=1) Char * {
  SWIG_DeleteCharArray($1);
}

/* varin */

%typemap(varin,fragment=#SWIG_AsCharPtrAndSize) Char * {
  Char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res,"$type","$name");
  }
  if ($1) SWIG_DeleteCharArray($1);
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)SWIG_NewCopyCharArray(cptr, csize, Char) : 0;
  }
}

%typemap(varin,fragment=#SWIG_AsCharPtrAndSize,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) const Char * {
  Char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
  int res = SWIG_AsCharPtrAndSize($input, &cptr, &csize, &alloc);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  if (alloc == SWIG_NEWOBJ) {
    $1 = cptr;
  } else {
    $1 = csize ? ($1_type)SWIG_NewCopyCharArray(cptr, csize, Char) : 0;
  }
}

/* varout */

%typemap(varout,noblock=1,fragment=#SWIG_FromCharPtr) Char *, const Char * {
  %set_varoutput(SWIG_FromCharPtr($1));
}

/* memberin */

%typemap(memberin,noblock=1) Char * {
  if ($1) SWIG_DeleteCharArray($1);
  if ($input) {
    size_t size = SWIG_CharPtrLen(%reinterpret_cast($input, const Char *)) + 1;
    $1 = ($1_type)SWIG_NewCopyCharArray(%reinterpret_cast($input, const Char *), size, Char);
  } else {
    $1 = 0;
  }
}

%typemap(memberin,noblock=1,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) const Char * {
  if ($input) {
    size_t size = SWIG_CharPtrLen(%reinterpret_cast(%reinterpret_cast($input, const Char *), const Char *)) + 1;
    $1 = ($1_type)SWIG_NewCopyCharArray($input, size, Char);
  } else {
    $1 = 0;
  }
}

/* globalin */

%typemap(globalin,noblock=1) Char * {
  if ($1) SWIG_DeleteCharArray($1);
  if ($input) {
    size_t size = SWIG_CharPtrLen(%reinterpret_cast(%reinterpret_cast($input, const Char *), const Char *)) + 1;
    $1 = ($1_type)SWIG_NewCopyCharArray($input, size, Char);
  } else {
    $1 = 0;
  }
}

%typemap(globalin,noblock=1,warning=SWIGWARN_TYPEMAP_CHARLEAK_MSG) const Char * {
  if ($input) {
    size_t size = SWIG_CharPtrLen($input) + 1;
    $1 = ($1_type)SWIG_NewCopyCharArray($input, size, Char);
  } else {
    $1 = 0;
  }
}

/* constant */

%typemap(constcode,noblock=1,fragment=#SWIG_FromCharPtr)
  Char *, Char const*, Char * const, Char const* const {
  %set_constant("$symname", SWIG_FromCharPtr($value));
}


#if defined(SWIG_DIRECTOR_TYPEMAPS)

/* directorin */

%typemap(directorin,noblock=1,fragment=#SWIG_FromCharPtr)
  Char *, Char const*, Char *const, Char const *const, 
  Char const *&, Char *const &, Char const *const & {
  $input = SWIG_FromCharPtr((const Char *)$1);
}


/* directorout */

%typemap(directorout,noblock=1,fragment=#SWIG_AsCharPtr,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) Char * (int res, Char *buf = 0, int alloc = SWIG_NEWOBJ) {
  res = SWIG_AsCharPtr($input, &buf, &alloc);
  if (!SWIG_IsOK(res)) {
    %dirout_fail(res, "$type");
  }
  if (alloc == SWIG_NEWOBJ) {
    swig_acquire_ownership_array(buf);
  }
  $result = %reinterpret_cast(buf, $1_ltype);
}
%typemap(directorfree,noblock=1) Char *
{
  if (director) {
    director->swig_release_ownership(%as_voidptr($input));
  }
}


%typemap(directorout,noblock=1,fragment=#SWIG_AsCharPtr,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) Char *const& (int res, Char *buf = 0, int alloc = SWIG_NEWOBJ), Char const*const& (int res, Char *buf = 0, int alloc = SWIG_NEWOBJ) { 
  res = SWIG_AsCharPtr($input, &buf, &alloc);
  if (!SWIG_IsOK(res)) {
    %dirout_fail(res, "$type");
  }
  static $*1_ltype tmp = buf;
  $result = &tmp;
  if (alloc == SWIG_NEWOBJ) {
    swig_acquire_ownership_array(buf);
  }
}
%typemap(directorfree,noblock=1)
  Char * const&, Char const* const& {
  if (director) {
    director->swig_release_ownership(%as_voidptr(*$input));
  }
}

#endif /* SWIG_DIRECTOR_TYPEMAPS */

/* typecheck */

%typemap(typecheck,noblock=1,precedence=StringCode,
	 fragment=#SWIG_AsCharPtr) Char *, const Char *, Char const*& {
  int res = SWIG_AsCharPtr($input, 0, 0);
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,noblock=1,fragment=#SWIG_FromCharPtr) Char * {
  %raise(SWIG_FromCharPtr($1), "$type", 0);
}


/* ------------------------------------------------------------
 *  Unknown size const Character array Char[ANY] handling
 * ------------------------------------------------------------ */

%apply Char * { Char [] };
%apply const Char * { const Char [] };

%typemap(varin,noblock=1,warning="462:Unable to set variable of type Char []") Char []
{
  %variable_fail(SWIG_AttributeError, "$type", "read-only $name");
}


/* ------------------------------------------------------------
 *  Fixed size Character array Char[ANY] handling
 * ------------------------------------------------------------ */

/*  memberin and globalin typemaps  */

%typemap(memberin,noblock=1) Char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(Char));
  else memset($1,0,$1_dim0*sizeof(Char));
}

%typemap(globalin,noblock=1) Char [ANY]
{
  if ($input) memcpy($1,$input,$1_dim0*sizeof(Char));
  else memset($1,0,$1_dim0*sizeof(Char));
}

/* in */

%typemap(in,noblock=1,fragment=#SWIG_AsCharArray)
  Char [ANY] (Char temp[$1_dim0], int res), 
  const Char [ANY](Char temp[$1_dim0], int res)
{  
  res = SWIG_AsCharArray($input, temp, $1_dim0);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type",$symname, $argnum);
  }
  $1 = %reinterpret_cast(temp, $1_ltype);
}
%typemap(freearg) Char [ANY], const Char [ANY] "";

%typemap(in,noblock=1,fragment=#SWIG_AsCharArray) const Char (&)[ANY] (Char temp[$1_dim0], int res)
{  
  res = SWIG_AsCharArray($input, temp, $1_dim0);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type",$symname, $argnum);
  }
  $1 = &temp;
}
%typemap(freearg) const Char (&)[ANY] "";

%typemap(out,fragment=#SWIG_FromCharPtrAndSize,fragment=#SWIG_CharBufLen)
  Char [ANY], const Char[ANY] 
{
%#ifndef SWIG_PRESERVE_CARRAY_SIZE
  size_t size = SWIG_CharBufLen($1, $1_dim0);
%#else
  size_t size = $1_dim0;
%#endif
   %set_output(SWIG_FromCharPtrAndSize($1, size));
}

/* varin */

%typemap(varin,fragment=#SWIG_AsCharArray) Char [ANY]
{
  int res = SWIG_AsCharArray($input, $1, $1_dim0);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
}

/* varout */

%typemap(varout,fragment=#SWIG_CharBufLen)
  Char [ANY], const Char [ANY] {
%#ifndef SWIG_PRESERVE_CARRAY_SIZE
  size_t size = SWIG_CharBufLen($1, $1_dim0);
%#else
  size_t size = $1_dim0;
%#endif
  %set_varoutput(SWIG_FromCharPtrAndSize($1, size));
}

/* constant */

%typemap(constcode,fragment=#SWIG_CharBufLen)
  Char [ANY], const Char [ANY]
{
%#ifndef SWIG_PRESERVE_CARRAY_SIZE
  size_t size = SWIG_CharBufLen($1, $1_dim0);
%#else
  size_t size = $value_dim0;
%#endif
  %set_constant("$symname", SWIG_FromCharPtrAndSize($value,size));
}


#if defined(SWIG_DIRECTOR_TYPEMAPS)

/* directorin */
%typemap(directorin,fragment=#SWIG_CharBufLen)
  Char [ANY], const Char [ANY] 
{
%#ifndef SWIG_PRESERVE_CARRAY_SIZE
  size_t size = SWIG_CharBufLen($1, $1_dim0);
%#else
  size_t size = $1_dim0;
%#endif
  $input = SWIG_FromCharPtrAndSize($1, size);
}

/* directorout */

%typemap(directorout,noblock=1,fragment=#SWIG_AsCharArray)
  Char [ANY] (Char temp[$result_dim0]),
  const Char [ANY] (Char temp[$result_dim0], int res)
{ 
  res = SWIG_AsCharArray($input, temp, $result_dim0);
  if (!SWIG_IsOK(res)) {
    %dirout_fail(res, "$type");
  }
  $result = temp;
}

#endif /* SWIG_DIRECTOR_TYPEMAPS */

/* typecheck */

%typemap(typecheck,noblock=1,precedence=StringCode,
	 fragment=#SWIG_AsCharArray)  
  Char [ANY], const Char[ANY] {
  int res = SWIG_AsCharArray($input, (Char *)0, $1_dim0);
  $1 = SWIG_CheckState(res);
}


/* throws */

%typemap(throws,fragment=#SWIG_CharBufLen)
  Char [ANY], const Char[ANY]
{
%#ifndef SWIG_PRESERVE_CARRAY_SIZE
  size_t size = SWIG_CharBufLen($1, $1_dim0);
%#else
  size_t size = $1_dim0;
%#endif
  %raise(SWIG_FromCharPtrAndSize($1, size), "$type", 0); 
}

/* -------------------------------------------------------------------
 * --- Really fix size Char arrays, including '\0'chars at the end ---
 * ------------------------------------------------------------------- */

%typemap(varout,noblock=1,fragment=#SWIG_FromCharPtrAndSize)
  Char FIXSIZE[ANY], const Char FIXSIZE[ANY]
{
  %set_varoutput(SWIG_FromCharPtrAndSize($1, $1_dim0));
}

%typemap(out,noblock=1,fragment=#SWIG_FromCharPtrAndSize)
  Char FIXSIZE[ANY], const Char FIXSIZE[ANY]
{
  %set_output(SWIG_FromCharPtrAndSize($1, $1_dim0));
}

#if defined(SWIG_DIRECTOR_TYPEMAPS)

%typemap(directorin,noblock=1,fragment=#SWIG_FromCharPtrAndSize)
  Char FIXSIZE[ANY], const Char FIXSIZE[ANY]
{
  $input = SWIG_FromCharPtrAndSize($1, $1_dim0);
}

#endif /* SWIG_DIRECTOR_TYPEMAPS */

%typemap(throws,noblock=1,fragment=#SWIG_FromCharPtrAndSize)
  Char FIXSIZE[ANY], const Char FIXSIZE[ANY] {
  %raise(SWIG_FromCharPtrAndSize($1, $1_dim0), "$type", 0); 
}

/* ------------------------------------------------------------
 * --- String & length ---
 * ------------------------------------------------------------ */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment=#SWIG_AsCharPtrAndSize) 
  (Char *STRING, size_t LENGTH) (int res, Char *buf = 0, size_t size = 0, int alloc = 0),
  (const Char *STRING, size_t LENGTH) (int res, Char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) { 
    %argument_fail(res,"$type",$symname, $argnum);
  }  
  $1 = %reinterpret_cast(buf, $1_ltype);
  $2 = %numeric_cast(size - 1, $2_ltype);
}
%typemap(freearg,noblock=1,match="in") (Char *STRING, size_t LENGTH) {
  if (alloc$argnum == SWIG_NEWOBJ) SWIG_DeleteCharArray(buf$argnum);
}
/* old 'int' form */
%typemap(in) (Char *STRING, int LENGTH) = (Char *STRING, size_t LENGTH);
%typemap(freearg) (Char *STRING, int LENGTH) = (Char *STRING, size_t LENGTH);


/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment=#SWIG_AsCharPtrAndSize)
  (Char *STRING, size_t SIZE) (int res, Char *buf = 0, size_t size = 0, int alloc = 0),
  (const Char *STRING, size_t SIZE) (int res, Char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type",$symname, $argnum);
  }
  $1 = %reinterpret_cast(buf, $1_ltype);
  $2 = %numeric_cast(size, $2_ltype);
}
%typemap(freearg,noblock=1,match="in") (Char *STRING, size_t SIZE) {
  if (alloc$argnum == SWIG_NEWOBJ) SWIG_DeleteCharArray(buf$argnum);
}
/* old 'int' form */
%typemap(in) (Char *STRING, int SIZE) = (Char *STRING, size_t SIZE);
%typemap(freearg) (Char *STRING, int SIZE) = (Char *STRING, size_t SIZE);


/* reverse order versions */

/* Here len doesn't include the '0' terminator */
%typemap(in,noblock=1,fragment=#SWIG_AsCharPtrAndSize) 
  (size_t LENGTH, Char *STRING) (int res, Char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t LENGTH, const Char *STRING) (int res, Char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) { 
    %argument_fail(res,"$type",$symname, $argnum);
  }  
  $2 = %reinterpret_cast(buf, $2_ltype) ;
  $1 = %numeric_cast(size - 1, $1_ltype) ;
}
%typemap(freearg, noblock=1, match="in") (size_t LENGTH, Char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) SWIG_DeleteCharArray(buf$argnum);
}
/* old 'int' form */
%typemap(in) (int LENGTH, Char *STRING) = (size_t LENGTH, Char *STRING);
%typemap(freearg) (int LENGTH, Char *STRING) = (size_t LENGTH, Char *STRING);

/* Here size includes the '0' terminator */
%typemap(in,noblock=1,fragment=#SWIG_AsCharPtrAndSize)
  (size_t SIZE, Char *STRING) (int res, Char *buf = 0, size_t size = 0, int alloc = 0),
  (size_t SIZE, const Char *STRING) (int res, Char *buf = 0, size_t size = 0, int alloc = 0)
{
  res = SWIG_AsCharPtrAndSize($input, &buf, &size, &alloc);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type",$symname, $argnum);
  }
  $2 = %reinterpret_cast(buf, $2_ltype) ;
  $1 = %numeric_cast(size, $1_ltype) ;
}
%typemap(freearg, noblock=1, match="in") (size_t SIZE, Char *STRING) {
  if (alloc$argnum == SWIG_NEWOBJ) SWIG_DeleteCharArray(buf$argnum);
}
/* old 'int' form */
%typemap(in) (int SIZE, Char *STRING) = (size_t SIZE, Char *STRING);
%typemap(freearg) (int SIZE, Char *STRING) = (size_t SIZE, Char *STRING);


%enddef


/* ------------------------------------------------------------
 * --- String fragment methods ---
 * ------------------------------------------------------------ */

#ifndef %_typemap2_string
%define %_typemap2_string(StringCode, CharCode,
			 Char, CharName,
			 SWIG_AsCharPtrAndSize,
			 SWIG_FromCharPtrAndSize,
			 SWIG_CharPtrLen,
			 SWIG_CharBufLen,
			 SWIG_NewCopyCharArray,
			 SWIG_DeleteCharArray,
			 FragLimits, CHAR_MIN, CHAR_MAX)
  
%fragment("SWIG_From"#CharName"Ptr","header",fragment=#SWIG_FromCharPtrAndSize) {
SWIGINTERNINLINE SWIG_Object 
SWIG_From##CharName##Ptr(const Char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? SWIG_CharPtrLen(cptr) : 0));
}
}

%fragment("SWIG_From"#CharName"Array","header",fragment=#SWIG_FromCharPtrAndSize) {
SWIGINTERNINLINE SWIG_Object 
SWIG_From##CharName##Array(const Char *cptr, size_t size)
{ 
  return SWIG_FromCharPtrAndSize(cptr, size);
}
}

%fragment("SWIG_As" #CharName "Ptr","header",fragment=#SWIG_AsCharPtrAndSize) {
%define_as(SWIG_As##CharName##Ptr(obj, val, alloc), SWIG_AsCharPtrAndSize(obj, val, NULL, alloc))
}

%fragment("SWIG_As" #CharName "Array","header",fragment=#SWIG_AsCharPtrAndSize) {
SWIGINTERN int
SWIG_As##CharName##Array(SWIG_Object obj, Char *val, size_t size)
{ 
  Char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(Char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(Char));
      }
      if (alloc == SWIG_NEWOBJ) {
	SWIG_DeleteCharArray(cptr);
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) SWIG_DeleteCharArray(cptr);
  }
  return SWIG_TypeError;
}
}

/* Char */

%fragment(SWIG_From_frag(Char),"header",fragment=#SWIG_FromCharPtrAndSize) {
SWIGINTERNINLINE SWIG_Object
SWIG_From_dec(Char)(Char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}
}

%fragment(SWIG_AsVal_frag(Char),"header",
	  fragment="SWIG_As"#CharName"Array",
	  fragment=FragLimits,
	  fragment=SWIG_AsVal_frag(long)) {
SWIGINTERN int
SWIG_AsVal_dec(Char)(SWIG_Object obj, Char *val)
{    
  int res = SWIG_As##CharName##Array(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal(long)(obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = %numeric_cast(v, Char);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}
}

%_typemap_string(StringCode, 
		 Char,
		 SWIG_AsCharPtrAndSize,
		 SWIG_FromCharPtrAndSize,
		 SWIG_CharPtrLen,
		 SWIG_CharBufLen,
		 SWIG_As##CharName##Ptr,
		 SWIG_From##CharName##Ptr,
		 SWIG_As##CharName##Array,
		 SWIG_NewCopyCharArray,
		 SWIG_DeleteCharArray)

%enddef
#endif

/* ------------------------------------------------------------
 *  String typemaps and fragments, with default allocators
 * ------------------------------------------------------------ */

%define %typemaps_string(StringCode, CharCode,
			 Char, CharName,
			 SWIG_AsCharPtrAndSize,
			 SWIG_FromCharPtrAndSize,
			 SWIG_CharPtrLen,
			 SWIG_CharBufLen,
			 FragLimits, CHAR_MIN, CHAR_MAX)
%_typemap2_string(StringCode, CharCode,
		  Char, CharName,
		  SWIG_AsCharPtrAndSize,
		  SWIG_FromCharPtrAndSize,
		  SWIG_CharPtrLen,
		  SWIG_CharBufLen,
		  %new_copy_array,
		  %delete_array,
		  FragLimits, CHAR_MIN, CHAR_MAX)
%enddef

/* ------------------------------------------------------------
 *  String typemaps and fragments, with custom allocators
 * ------------------------------------------------------------ */

%define %typemaps_string_alloc(StringCode, CharCode,
			       Char, CharName,
			       SWIG_AsCharPtrAndSize,
			       SWIG_FromCharPtrAndSize,
			       SWIG_CharPtrLen,
			       SWIG_CharBufLen,
			       SWIG_NewCopyCharArray,
			       SWIG_DeleteCharArray,
			       FragLimits, CHAR_MIN, CHAR_MAX)
%_typemap2_string(StringCode, CharCode,
		  Char, CharName,
		  SWIG_AsCharPtrAndSize,
		  SWIG_FromCharPtrAndSize,
		  SWIG_CharPtrLen,
		  SWIG_CharBufLen,
		  SWIG_NewCopyCharArray,
		  SWIG_DeleteCharArray,
		  FragLimits, CHAR_MIN, CHAR_MAX)
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/swigmacros.swg
================================================
/* -----------------------------------------------------------------------------
 * SWIG API. Portion only visible from SWIG
 * ----------------------------------------------------------------------------- */
/*
  This file implements the internal macros of the 'SWIG API', which
  are useful to implement all the SWIG target languages.

  Basic preprocessor macros:
  --------------------------

    %arg(Arg)               Safe argument wrap
    %str(Arg)               Stringify the argument
    %begin_block            Begin an execution block
    %end_block              End an execution block
    %block(Block)           Execute Block as an execution block
    %define_as(Def, Val)    Define 'Def' as 'Val', expanding Def and Val first
    %ifcplusplus(V1, V2)    if C++ Mode; then V1; else V2; fi


  Casting Operations:
  -------------------

  SWIG provides the following casting macros, which implement the
  corresponding C++ casting operations:

    %const_cast(a, Type)         const_cast<Type >(a)
    %static_cast(a, Type)      	 static_cast<Type >(a)
    %reinterpret_cast(a, Type) 	 reinterpret_cast<Type >(a)
    %numeric_cast(a, Type)     	 static_cast<Type >(a)
    %as_voidptr(a)            	 const_cast<void *>(static_cast<const void *>(a))
    %as_voidptrptr(a)        	 reinterpret_cast<void **>(a)

  or their C unsafe versions. In C++ we use the safe version unless
  SWIG_NO_CPLUSPLUS_CAST is defined (usually via the -nocppcast swig flag).


  Memory allocation:
  ------------------

  These allocation/freeing macros are safe to use in C or C++ and
  dispatch the proper new/delete/delete[] or free/malloc calls as
  needed.

    %new_instance(Type)             Allocate a new instance of given Type
    %new_copy(value,Type)           Allocate and initialize a new instance with 'value'
    %new_array(size,Type)           Allocate a new array with given size and Type
    %new_copy_array(cptr,size,Type) Allocate and initialize a new array from 'cptr'
    %delete(cptr)                   Delete an instance
    %delete_array(cptr)             Delete an array


  Auxiliary loop macros:
  ----------------------

    %formacro(Macro, Args...) or %formacro_1(Macro, Args...)
       for i in Args
       do
          Macro($i)
       done

    %formacro_2(Macro2, Args...)
       for i,j in Args
       do
          Macro2($i, $j)
       done


  Flags and conditional macros:
  -----------------------------

     %mark_flag(flag)
       flag := True

     %evalif(flag,expr)
       if flag; then
         expr
       fi

     %evalif_2(flag1 flag2,expr)
       if flag1 and flag2; then
         expr
       fi


*/
/* -----------------------------------------------------------------------------
 * Basic preprocessor macros
 * ----------------------------------------------------------------------------- */

#define %arg(Arg...)        Arg
#define %str(Arg)           `Arg`
#ifndef %begin_block
#  define %begin_block      do {
#endif
#ifndef %end_block
#  define %end_block        } while(0)
#endif
#define %block(Block...)    %begin_block Block; %end_block

/* define a new macro */
%define %define_as(Def, Val...)%#define Def Val %enddef

/* include C++ or else value */
%define %ifcplusplus(cppval, nocppval)
#ifdef __cplusplus
cppval
#else
nocppval
#endif
%enddef

/* insert the SWIGVERSION in the interface and the wrapper code */
#if SWIG_VERSION
%insert("header") {
%define_as(SWIGVERSION,  SWIG_VERSION)
%#define SWIG_VERSION SWIGVERSION
}
#endif



/* -----------------------------------------------------------------------------
 * Casting operators
 * ----------------------------------------------------------------------------- */

#if defined(SWIG_NO_CPLUSPLUS_CAST)
/* Disable 'modern' cplusplus casting operators */
# if defined(SWIG_CPLUSPLUS_CAST)
#   undef SWIG_CPLUSPLUS_CAST
# endif
#endif

#if defined(__cplusplus) && defined(SWIG_CPLUSPLUS_CAST)
# define %const_cast(a,Type...)       const_cast< Type >(a)
# define %static_cast(a,Type...)      static_cast< Type >(a)
# define %reinterpret_cast(a,Type...) reinterpret_cast< Type >(a)
# define %numeric_cast(a,Type...)     static_cast< Type >(a)
#else /* C case */
# define %const_cast(a,Type...)       (Type)(a)
# define %static_cast(a,Type...)      (Type)(a)
# define %reinterpret_cast(a,Type...) (Type)(a)
# define %numeric_cast(a,Type...)     (Type)(a)
#endif /* __cplusplus */


#define %as_voidptr(a)               SWIG_as_voidptr(a)
#define %as_voidptrptr(a)            SWIG_as_voidptrptr(a)

%insert("header") {
%define_as(SWIG_as_voidptr(a),    %const_cast(%static_cast(a,const void *), void *))
%define_as(SWIG_as_voidptrptr(a), ((void)%as_voidptr(*a),%reinterpret_cast(a, void**)))
}


/* -----------------------------------------------------------------------------
 * Allocating/freeing elements
 * ----------------------------------------------------------------------------- */

#if defined(__cplusplus)
# define %new_instance(Type...)             (new Type)
# define %new_copy(val,Type...)             (new Type(%static_cast(val, const Type&)))
# define %new_array(size,Type...)           (new Type[size])
# define %new_copy_array(ptr,size,Type...)  %reinterpret_cast(memcpy(%new_array(size,Type), ptr, sizeof(Type)*(size)), Type*)
# define %delete(cptr)                      delete cptr
# define %delete_array(cptr)                delete[] cptr
#else /* C case */
# define %new_instance(Type...)             (Type *)malloc(sizeof(Type))
# define %new_copy(val,Type...)             (Type *)memcpy(%new_instance(Type),&val,sizeof(Type))
# define %new_array(size,Type...)           (Type *)malloc((size)*sizeof(Type))
# define %new_copy_array(ptr,size,Type...)  (Type *)memcpy(%new_array(size,Type), ptr, sizeof(Type)*(size))
# define %delete(cptr)                      free((char*)cptr)
# define %delete_array(cptr)                free((char*)cptr)
#endif /* __cplusplus */

/* -----------------------------------------------------------------------------
 * SWIG names and mangling
 * ----------------------------------------------------------------------------- */

#define %mangle(Type...)                  #@Type
#define %descriptor(Type...)               SWIGTYPE_ ## #@Type
#define %string_name(Name)                "SWIG_" %str(Name)
#define %symbol_name(Name, Type...)       SWIG_ ## Name ## _ #@Type
#define %checkcode(Code)           	  SWIG_TYPECHECK_ ## Code


/* -----------------------------------------------------------------------------
 * Auxiliary loop macros
 * ----------------------------------------------------------------------------- */


/* for loop for macro with one argument */
%define %_formacro_1(macro, arg1,...)macro(arg1)
#if #__VA_ARGS__ != "__fordone__"
%_formacro_1(macro, __VA_ARGS__)
#endif
%enddef

/* for loop for macro with one argument */
%define %formacro_1(macro,...)%_formacro_1(macro,__VA_ARGS__,__fordone__)%enddef
%define %formacro(macro,...)%_formacro_1(macro,__VA_ARGS__,__fordone__)%enddef

/* for loop for macro with two arguments */
%define %_formacro_2(macro, arg1, arg2, ...)macro(arg1, arg2)
#if #__VA_ARGS__ != "__fordone__"
%_formacro_2(macro, __VA_ARGS__)
#endif
%enddef

/* for loop for macro with two arguments */
%define %formacro_2(macro,...)%_formacro_2(macro, __VA_ARGS__, __fordone__)%enddef

/* -----------------------------------------------------------------------------
 * SWIG flags
 * ----------------------------------------------------------------------------- */

/*
  mark a flag, ie, define a macro name but ignore it in
  the interface.

  the flag can be later used with %evalif
*/

%define %mark_flag(x) %define x 1 %enddef %enddef


/*
  %evalif and %evalif_2 are use to evaluate or process
  an expression if the given predicate is 'true' (1).
*/
%define %_evalif(_x,_expr)
#if _x == 1
_expr
#endif
%enddef

%define %_evalif_2(_x,_y,_expr)
#if _x == 1 && _y == 1
_expr
#endif
%enddef

%define %evalif(_x,_expr...) %_evalif(%arg(_x),%arg(_expr)) %enddef

%define %evalif_2(_x,_y,_expr...) %_evalif_2(%arg(_x),%arg(_y),%arg(_expr)) %enddef




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/swigobject.swg
================================================
/* ------------------------------------------------------------
 * Language Object *  - Just pass straight through unmodified
 * ------------------------------------------------------------ */

%typemap(in)   SWIG_Object "$1 = $input;";

%typemap(in,noblock=1)   SWIG_Object const & ($*ltype temp)
{
  temp = %static_cast($input, $*ltype);
  $1 = &temp;
}

%typemap(out,noblock=1) SWIG_Object {
  %set_output($1);
}

%typemap(out,noblock=1)  SWIG_Object const & {
  %set_output(*$1);
}

%typecheck(SWIG_TYPECHECK_SWIGOBJECT) SWIG_Object "$1 = ($input != 0);";

%typemap(throws,noblock=1) SWIG_Object {
  %raise($1, "$type", 0);
}

%typemap(constcode,noblock=1) SWIG_Object {
  %set_constant("$symname", $value);
}

#if defined(SWIG_DIRECTOR_TYPEMAPS)

%typemap(directorin) SWIG_Object "$input = $1;";
%typemap(directorout) SWIG_Object "$result = $input;";

#endif /* SWIG_DIRECTOR_TYPEMAPS */




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/swigtype.swg
================================================
/* -----------------------------------------------------------------------------
 * --- Input arguments --- 
 * ----------------------------------------------------------------------------- */
/* Pointers and arrays */
%typemap(in, noblock=1) SWIGTYPE *(void  *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown | %convertptr_flags);
  if (!SWIG_IsOK(res)) { 
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  $1 = %reinterpret_cast(argp, $ltype);
}
%typemap(freearg) SWIGTYPE * "";

%typemap(in, noblock=1) SWIGTYPE [] (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp,$descriptor, $disown | %convertptr_flags);
  if (!SWIG_IsOK(res)) { 
    %argument_fail(res, "$type", $symname, $argnum); 
  } 
  $1 = %reinterpret_cast(argp, $ltype);
}
%typemap(freearg) SWIGTYPE [] "";


%typemap(in, noblock=1) SWIGTYPE *const&  (void *argp = 0, int res = 0, $*1_ltype temp) {
  res = SWIG_ConvertPtr($input, &argp, $*descriptor, $disown | %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$*ltype", $symname, $argnum); 
  }
  temp = %reinterpret_cast(argp, $*ltype);
  $1 = %reinterpret_cast(&temp, $1_ltype);
}
%typemap(freearg) SWIGTYPE *const& "";


/* Reference */
%typemap(in, noblock=1) SWIGTYPE & (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) { %argument_nullref("$type", $symname, $argnum); }
  $1 = %reinterpret_cast(argp, $ltype);
}
%typemap(freearg) SWIGTYPE & "";

#if defined(__cplusplus) && defined(%implicitconv_flag)
%typemap(in,noblock=1,implicitconv=1) const SWIGTYPE & (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags | %implicitconv_flag);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) { %argument_nullref("$type", $symname, $argnum); }
  $1 = %reinterpret_cast(argp, $ltype);
}
%typemap(freearg,noblock=1,match="in",implicitconv=1) const SWIGTYPE &
{
  if (SWIG_IsNewObj(res$argnum)) %delete($1);
}
#else
%typemap(in,noblock=1) const SWIGTYPE & (void *argp, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) { %argument_nullref("$type", $symname, $argnum); }
  $1 = %reinterpret_cast(argp, $ltype);
}
#endif

/* Rvalue reference */
%typemap(in, noblock=1) SWIGTYPE && (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) { %argument_nullref("$type", $symname, $argnum); }
  $1 = %reinterpret_cast(argp, $ltype);
}
%typemap(freearg) SWIGTYPE && "";

#if defined(__cplusplus) && defined(%implicitconv_flag)
%typemap(in,noblock=1,implicitconv=1) const SWIGTYPE && (void *argp = 0, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags | %implicitconv_flag);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) { %argument_nullref("$type", $symname, $argnum); }
  $1 = %reinterpret_cast(argp, $ltype);
}
%typemap(freearg,noblock=1,match="in",implicitconv=1) const SWIGTYPE &&
{
  if (SWIG_IsNewObj(res$argnum)) %delete($1);
}
#else
%typemap(in,noblock=1) const SWIGTYPE && (void *argp, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }
  if (!argp) { %argument_nullref("$type", $symname, $argnum); }
  $1 = %reinterpret_cast(argp, $ltype);
}
#endif

/* By value */
#if defined(__cplusplus) && defined(%implicitconv_flag)
%typemap(in,implicitconv=1) SWIGTYPE (void *argp, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $&descriptor, %convertptr_flags | %implicitconv_flag);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }  
  if (!argp) { 
    %argument_nullref("$type", $symname, $argnum);
  } else {
    $&ltype temp = %reinterpret_cast(argp, $&ltype);
    $1 = *temp;
    if (SWIG_IsNewObj(res)) %delete(temp);
  }
}
#else
%typemap(in) SWIGTYPE (void *argp, int res = 0) {
  res = SWIG_ConvertPtr($input, &argp, $&descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res, "$type", $symname, $argnum); 
  }  
  if (!argp) { 
    %argument_nullref("$type", $symname, $argnum);
  } else {
    $1 = *(%reinterpret_cast(argp, $&ltype));
  }
}
#endif


/* -----------------------------------------------------------------------------
 * --- Output arguments --- 
 * ----------------------------------------------------------------------------- */

/* Pointers, references */
%typemap(out,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE[] {
  %set_output(SWIG_NewPointerObj(%as_voidptr($1), $descriptor, $owner | %newpointer_flags));
}

%typemap(out, noblock=1) SWIGTYPE *const& {
  %set_output(SWIG_NewPointerObj(%as_voidptr(*$1), $*descriptor, $owner | %newpointer_flags));
}

/* Return by value */
%typemap(out, noblock=1) SWIGTYPE {
  %set_output(SWIG_NewPointerObj(%new_copy($1, $ltype), $&descriptor, SWIG_POINTER_OWN | %newpointer_flags));
}

/* -----------------------------------------------------------------------------
 * --- Variable input --- 
 * ----------------------------------------------------------------------------- */

/* memberin/globalin/varin, for fix arrays. */

%typemap(memberin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
  } else {
    %variable_nullref("$type","$name");
  }
}

%typemap(globalin) SWIGTYPE [ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)$input + ii);
  } else {
    %variable_nullref("$type","$name");
  }
}

%typemap(varin) SWIGTYPE [ANY] {
  $basetype *inp = 0;
  int res = SWIG_ConvertPtr($input, %as_voidptrptr(&inp), $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) *($1_basetype *)&$1[ii] = *(($1_basetype *)inp + ii);
  } else {
    %variable_nullref("$type", "$name");
  }
}


/* memberin/globalin/varin, for fix double arrays. */

%typemap(memberin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	%variable_nullref("$type","$name");
      }
    }
  } else {
    %variable_nullref("$type","$name");
  }
}

%typemap(globalin) SWIGTYPE [ANY][ANY] {
  if ($input) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if ($input[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = $input[ii][jj];
      } else {
	%variable_nullref("$type","$name");
      }
    }
  } else {
    %variable_nullref("$type","$name");
  }
}

%typemap(varin) SWIGTYPE [ANY][ANY] {
  $basetype (*inp)[$1_dim1] = 0;
  int res = SWIG_ConvertPtr($input, %as_voidptrptr(&inp), $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  } else if (inp) {
    size_t ii = 0;
    for (; ii < (size_t)$1_dim0; ++ii) {
      if (inp[ii]) {
	size_t jj = 0;
	for (; jj < (size_t)$1_dim1; ++jj) $1[ii][jj] = inp[ii][jj];
      } else {
	%variable_nullref("$type", "$name");
      }
    }
  } else {
    %variable_nullref("$type", "$name");
  }
}

/* Pointers, references, and variable size arrays */

%typemap(varin,warning=SWIGWARN_TYPEMAP_SWIGTYPELEAK_MSG) SWIGTYPE * {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags);  
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  $1 = %reinterpret_cast(argp, $ltype);
}

%typemap(varin,noblock=1,warning="462:Unable to set dimensionless array variable") SWIGTYPE []
{
  %variable_fail(SWIG_AttributeError, "$type", "read-only $name");
}

%typemap(varin,warning=SWIGWARN_TYPEMAP_SWIGTYPELEAK_MSG) SWIGTYPE & {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  if (!argp) {
    %variable_nullref("$type", "$name");
  }
  $1 = *(%reinterpret_cast(argp, $ltype));
}

%typemap(varin,warning=SWIGWARN_TYPEMAP_SWIGTYPELEAK_MSG) SWIGTYPE && {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  if (!argp) {
    %variable_nullref("$type", "$name");
  }
  $1 = *(%reinterpret_cast(argp, $ltype));
}

#if defined(__cplusplus) && defined(%implicitconv_flag)
%typemap(varin,implicitconv=1) SWIGTYPE {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $&descriptor, %convertptr_flags | %implicitconv_flag);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  if (!argp) {
    %variable_nullref("$type", "$name");
  } else {
    $&type temp;
    temp  = %reinterpret_cast(argp, $&type);
    $1 = *temp;
    if (SWIG_IsNewObj(res)) %delete(temp);
  }
}
#else
%typemap(varin) SWIGTYPE {
  void *argp = 0;
  int res = SWIG_ConvertPtr($input, &argp, $&descriptor, %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  if (!argp) {
    %variable_nullref("$type", "$name");
  } else {
    $1 = *(%reinterpret_cast(argp, $&type));
  }
}
#endif

/* -----------------------------------------------------------------------------
 * --- Variable output --- 
 * ----------------------------------------------------------------------------- */

/* Pointers and arrays */
%typemap(varout, noblock=1) SWIGTYPE * {
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr($1), $descriptor, %newpointer_flags));
}

%typemap(varout, noblock=1) SWIGTYPE [] {
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr($1), $descriptor, %newpointer_flags));
}

/* References */
%typemap(varout, noblock=1) SWIGTYPE & {
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr(&$1), $descriptor, %newpointer_flags));
}

%typemap(varout, noblock=1) SWIGTYPE && {
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr(&$1), $descriptor, %newpointer_flags));
}

/* Value */
%typemap(varout, noblock=1) SWIGTYPE {
  %set_varoutput(SWIG_NewPointerObj(%as_voidptr(&$1), $&descriptor, %newpointer_flags));
}

/* ------------------------------------------------------------
 * --- Typechecking rules ---
 * ------------------------------------------------------------ */

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) SWIGTYPE * {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) SWIGTYPE *const& {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $*descriptor, 0);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) SWIGTYPE & {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) SWIGTYPE && {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}

#if defined(__cplusplus) && defined(%implicitconv_flag)
%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1,implicitconv=1) const SWIGTYPE & {
  int res = SWIG_ConvertPtr($input, 0, $descriptor, %implicitconv_flag);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1,implicitconv=1) const SWIGTYPE && {
  int res = SWIG_ConvertPtr($input, 0, $descriptor, %implicitconv_flag);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1,implicitconv=1) SWIGTYPE {
  int res = SWIG_ConvertPtr($input, 0, $&descriptor, %implicitconv_flag);
  $1 = SWIG_CheckState(res);
}
#else
%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) const SWIGTYPE & {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}
%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) const SWIGTYPE && {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $descriptor, 0);
  $1 = SWIG_CheckState(res);
}

%typemap(typecheck,precedence=SWIG_TYPECHECK_POINTER,noblock=1) SWIGTYPE {
  void *vptr = 0;
  int res = SWIG_ConvertPtr($input, &vptr, $&descriptor, 0);
  $1 = SWIG_CheckState(res);
}
#endif

/* -----------------------------------------------------------------------------
 * --- Director typemaps --- *  
 * ----------------------------------------------------------------------------- */

#if defined(SWIG_DIRECTOR_TYPEMAPS)

/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE *, SWIGTYPE *const& {
  $input = SWIG_NewPointerObj(%as_voidptr($1), $descriptor, %newpointer_flags);
}

%typemap(directorin,noblock=1) SWIGTYPE {
  $input = SWIG_NewPointerObj(%as_voidptr(&$1), $&descriptor, %newpointer_flags);
}

%typemap(directorin,noblock=1) SWIGTYPE & {
  $input = SWIG_NewPointerObj(%as_voidptr(&$1), $descriptor, %newpointer_flags);
}

%typemap(directorin,noblock=1) SWIGTYPE && {
  $input = SWIG_NewPointerObj(%as_voidptr(&$1_name), $descriptor, %newpointer_flags);
}

/* directorout */
#if defined(__cplusplus) && defined(%implicitconv_flag)
%typemap(directorout,noblock=1,implicitconv=1) SWIGTYPE (void * swig_argp, int swig_res = 0) {
  swig_res = SWIG_ConvertPtr($input,&swig_argp,$&descriptor, %convertptr_flags | %implicitconv_flag);
  if (!SWIG_IsOK(swig_res)) {
    %dirout_fail(swig_res,"$type");
  }
  $result = *(%reinterpret_cast(swig_argp, $&ltype));
  if (SWIG_IsNewObj(swig_res)) %delete(%reinterpret_cast(swig_argp, $&ltype));
}
#else
%typemap(directorout,noblock=1) SWIGTYPE (void * swig_argp, int swig_res = 0) {
  swig_res = SWIG_ConvertPtr($input,&swig_argp,$&descriptor, %convertptr_flags);
  if (!SWIG_IsOK(swig_res)) {
    %dirout_fail(swig_res,"$type");
  }
  $result = *(%reinterpret_cast(swig_argp, $&ltype));
}
#endif

%typemap(directorout,noblock=1,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) 
  SWIGTYPE *(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor, %convertptr_flags | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    %dirout_fail(swig_res,"$type");
  }
  $result = %reinterpret_cast(swig_argp, $ltype);
  swig_acquire_ownership_obj(%as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE * {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(%as_voidptr($input)));
  }
}

%typemap(directorout,noblock=1,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) 
  SWIGTYPE &(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor, %convertptr_flags | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    %dirout_fail(swig_res,"$type");
  }
  if (!swig_argp) { %dirout_nullref("$type"); }
  $result = %reinterpret_cast(swig_argp, $ltype);
  swig_acquire_ownership_obj(%as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE & {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(%as_voidptr($input)));
  }
}

%typemap(directorout,noblock=1,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) 
  SWIGTYPE &&(void *swig_argp, int swig_res, swig_owntype own) {
  swig_res = SWIG_ConvertPtrAndOwn($input, &swig_argp, $descriptor, %convertptr_flags | SWIG_POINTER_DISOWN, &own);
  if (!SWIG_IsOK(swig_res)) {
    %dirout_fail(swig_res,"$type");
  }
  if (!swig_argp) { %dirout_nullref("$type"); }
  $result = %reinterpret_cast(swig_argp, $ltype);
  swig_acquire_ownership_obj(%as_voidptr($result), own /* & TODO: SWIG_POINTER_OWN */);
}
%typemap(directorfree,noblock=1,match="directorout") SWIGTYPE && {
  if (director) {
    SWIG_AcquirePtr($result, director->swig_release_ownership(%as_voidptr($input)));
  }
}

#endif /* SWIG_DIRECTOR_TYPEMAPS */


/* ------------------------------------------------------------
 * --- Constants ---
 * ------------------------------------------------------------ */

%typemap(constcode,noblock=1) SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE [] {
  %set_constant("$symname", SWIG_NewPointerObj(%as_voidptr($value),$descriptor,%newpointer_flags));
}

%typemap(constcode,noblock=1) SWIGTYPE {
  %set_constant("$symname", SWIG_NewPointerObj(%as_voidptr(&$value),$&descriptor,%newpointer_flags));
}

/* ------------------------------------------------------------
 * --- Exception handling ---
 * ------------------------------------------------------------ */

%typemap(throws,noblock=1) SWIGTYPE {
  %raise(SWIG_NewPointerObj(%new_copy($1, $ltype),$&descriptor,SWIG_POINTER_OWN), "$type", $&descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE * {
  %raise(SWIG_NewPointerObj(%as_voidptr($1),$descriptor,0), "$type", $descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE [ANY] {
  %raise(SWIG_NewPointerObj(%as_voidptr($1),$descriptor,0), "$type", $descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE & {
  %raise(SWIG_NewPointerObj(%as_voidptr(&$1),$descriptor,0), "$type", $descriptor);
}

%typemap(throws,noblock=1) SWIGTYPE && {
  %raise(SWIG_NewPointerObj(%as_voidptr(&$1),$descriptor,0), "$type", $descriptor);
}

%typemap(throws,noblock=1) (...) {
  SWIG_exception_fail(SWIG_RuntimeError,"unknown exception");
}

/* ------------------------------------------------------------
 * --- CLASS::* typemaps --- 
 * ------------------------------------------------------------ */

%typemap(in) SWIGTYPE (CLASS::*) {  
  int res = SWIG_ConvertMember($input, %as_voidptr(&$1), sizeof($type),$descriptor);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type",$symname, $argnum); 
  }
}

%typemap(out,noblock=1) SWIGTYPE (CLASS::*) {
  %set_output(SWIG_NewMemberObj(%as_voidptr(&$1), sizeof($type), $descriptor));
}

%typemap(varin) SWIGTYPE (CLASS::*) {
  int res = SWIG_ConvertMember($input,%as_voidptr(&$1), sizeof($type), $descriptor);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE (CLASS::*) {
  %set_varoutput(SWIG_NewMemberObj(%as_voidptr(&$1), sizeof($type), $descriptor));
}

%typemap(constcode,noblock=1) SWIGTYPE (CLASS::*) {
  %set_constant("$symname", SWIG_NewMemberObj(%as_voidptr(&$value), sizeof($type), $descriptor));
}

#if defined(SWIG_DIRECTOR_TYPEMAPS)

/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE (CLASS::*) {
  $input = SWIG_NewMemberObj(%as_voidptr(&$1), sizeof($type), $descriptor);
}

/* directorout */

%typemap(directorout) SWIGTYPE (CLASS::*) {
  int swig_res = SWIG_ConvertMember($input,%as_voidptr(&$result), sizeof($type), $descriptor);
  if (!SWIG_IsOK(swig_res)) {
    %dirout_fail(swig_res,"$type");
  }
}
#endif

/* ------------------------------------------------------------
 * --- function ptr typemaps --- 
 * ------------------------------------------------------------ */

/*
  ISO C++ doesn't allow direct casting of a function ptr to a object
  ptr. So, maybe the ptr sizes are not the same, and we need to take
  some providences.
 */
%typemap(in) SWIGTYPE ((*)(ANY)) {
  int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type",$symname, $argnum); 
  }
}

%typecheck(SWIG_TYPECHECK_POINTER,noblock=1) SWIGTYPE ((*)(ANY)) {
  void *ptr = 0;
  int res = SWIG_ConvertFunctionPtr($input, &ptr, $descriptor);
  $1 = SWIG_CheckState(res);
}


%typemap(out, noblock=1) SWIGTYPE ((*)(ANY)) {
  %set_output(SWIG_NewFunctionPtrObj((void *)($1), $descriptor));
}

%typemap(varin) SWIGTYPE ((*)(ANY)) {
  int res = SWIG_ConvertFunctionPtr($input, (void**)(&$1), $descriptor);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name"); 
  }
}

%typemap(varout,noblock=1) SWIGTYPE ((*)(ANY)) {  
  %set_varoutput(SWIG_NewFunctionPtrObj((void *)($1), $descriptor));
}

%typemap(constcode, noblock=1) SWIGTYPE ((*)(ANY)){
  %set_constant("$symname", SWIG_NewFunctionPtrObj((void *)$value, $descriptor));
}

#if defined(SWIG_DIRECTOR_TYPEMAPS)

/* directorin */

%typemap(directorin,noblock=1) SWIGTYPE ((*)(ANY)) {
  $input = SWIG_NewFunctionPtrObj((void*)($1), $descriptor);
}

/* directorout */

%typemap(directorout) SWIGTYPE ((*)(ANY)) {
  int swig_res = SWIG_ConvertFunctionPtr($input,(void**)(&$result),$descriptor);
  if (!SWIG_IsOK(swig_res)) {
    %dirout_fail(swig_res,"$type");
  }
}
#endif

%apply SWIGTYPE * { SWIGTYPE *const }

/* ------------------------------------------------------------
 * --- Special typemaps ---
 * ------------------------------------------------------------ */

/* DISOWN typemap */

%typemap(in, noblock=1) SWIGTYPE *DISOWN (int res = 0) {
  res = SWIG_ConvertPtr($input, %as_voidptrptr(&$1), $descriptor, SWIG_POINTER_DISOWN | %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %argument_fail(res,"$type", $symname, $argnum);
  }
}

%typemap(varin) SWIGTYPE *DISOWN {
  void *temp = 0;
  int res = SWIG_ConvertPtr($input, &temp, $descriptor, SWIG_POINTER_DISOWN | %convertptr_flags);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  $1 = ($ltype) temp;
}

/* DYNAMIC typemap */

%typemap(out,noblock=1) SWIGTYPE *DYNAMIC, SWIGTYPE &DYNAMIC {
  %set_output(SWIG_NewPointerObj(%as_voidptr($1), SWIG_TypeDynamicCast($descriptor, %as_voidptrptr(&$1)), $owner | %newpointer_flags));
}

/* INSTANCE typemap */

%typemap(out,noblock=1) SWIGTYPE INSTANCE {
  %set_output(SWIG_NewInstanceObj(%new_copy($1, $1_ltype), $&1_descriptor, SWIG_POINTER_OWN | %newinstance_flags));
}

%typemap(out,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE &INSTANCE, SWIGTYPE INSTANCE[] {
  %set_output(SWIG_NewInstanceObj(%as_voidptr($1), $1_descriptor, $owner | %newinstance_flags));
}

%typemap(varout,noblock=1) SWIGTYPE *INSTANCE, SWIGTYPE INSTANCE[] {
  %set_varoutput(SWIG_NewInstanceObj(%as_voidptr($1), $1_descriptor, %newinstance_flags));
}

%typemap(varout,noblock=1) SWIGTYPE &INSTANCE {
  %set_varoutput(SWIG_NewInstanceObj(%as_voidptr($1), $1_descriptor, %newinstance_flags));
}

%typemap(varout,noblock=1) SWIGTYPE INSTANCE {
  %set_varoutput(SWIG_NewInstanceObj(%as_voidptr(&$1), $&1_descriptor, %newinstance_flags));
}




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/swigtypemaps.swg
================================================
/* -----------------------------------------------------------------------------
 * swigtypemaps.swg
 *
 * Unified Typemap Library frontend
 * ----------------------------------------------------------------------------- */

/*
  This file provides the frontend to the Unified Typemap Library.

  When using this library in a SWIG target language, you need to
  define a minimum set of fragments, specialize a couple of macros,
  and then include this file.

  Typically you will create a 'mytypemaps.swg' file in each target
  language, where you will have the following sections:

    === mytypemaps.swg ===

    //  Fragment section 
    %include <typemaps/fragments.swg>
    <include target language fragments>

    // Unified typemap section 
    <specialized the typemap library macros>
    %include <typemaps/swigtypemaps.swg>

    // Local typemap section 
    <add/replace extra target language typemaps>

    === mytypemaps.swg ===

  While we add more docs, please take a look at the following cases
  to see how you specialized the unified typemap library for a new
  target language:

      Lib/python/pytypemaps.swg
      Lib/tcl/tcltypemaps.swg
      Lib/ruby/rubytypemaps.swg
      Lib/perl5/perltypemaps.swg
    
*/

#define SWIGUTL SWIGUTL

/* -----------------------------------------------------------------------------
 *   Language specialization section. 
 *
 *   Tune these macros for each language as needed.
 * ----------------------------------------------------------------------------- */

/*
  The SWIG target language object must be provided.
  For example in python you define:

    #define SWIG_Object PyObject *
*/

#if !defined(SWIG_Object) 
#error "SWIG_Object must be defined as the SWIG target language object"
#endif

/*==== flags for new/convert methods ====*/


#ifndef %convertptr_flags
%define %convertptr_flags  0 %enddef
#endif

#ifndef %newpointer_flags
%define %newpointer_flags  0 %enddef
#endif

#ifndef %newinstance_flags
%define %newinstance_flags 0 %enddef
#endif

/*==== set output ====*/

#ifndef %set_output
/* simple set output operation */
#define %set_output(obj)                  $result = obj
#endif

/*==== set variable output  ====*/

#ifndef %set_varoutput
/* simple set varoutput operation */
#define %set_varoutput(obj)               $result = obj
#endif

/*==== append output ====*/

#ifndef %append_output
#if defined(SWIG_AppendOutput)
/* simple append operation */
#define %append_output(obj)               $result = SWIG_AppendOutput($result,obj) 
#else
#error "Language must define SWIG_AppendOutput or %append_output"
#endif
#endif

/*==== set constant ====*/

#ifndef %set_constant
#if defined(SWIG_SetConstant)
/* simple set constant operation */
#define %set_constant(name,value)         SWIG_SetConstant(name,value)
#else
#error "Language must define SWIG_SetConstant or %set_constant"
#endif
#endif

/*==== raise an exception ====*/

#ifndef %raise
#if defined(SWIG_Raise)
/* simple raise operation */
#define %raise(obj, type, desc)           SWIG_Raise(obj, type, desc); SWIG_fail
#else
#error "Language must define SWIG_Raise or %raise"
#endif
#endif

/*==== director output exception ====*/

#if defined(SWIG_DIRECTOR_TYPEMAPS)
#ifndef SWIG_DirOutFail
#define SWIG_DirOutFail(code, msg)        Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(code), msg)
#endif
#endif


/* -----------------------------------------------------------------------------
 *  Language independent definitions
 * ----------------------------------------------------------------------------- */

#define %error_block(Block...)                 %block(Block)
#define %default_code(code)                    SWIG_ArgError(code)  
#define %argument_fail(code, type, name, argn) SWIG_exception_fail(%default_code(code), %argfail_fmt(type, name, argn))
#define %argument_nullref(type, name, argn)    SWIG_exception_fail(SWIG_ValueError, %argnullref_fmt(type, name, argn))
#define %variable_fail(code, type, name)       SWIG_exception_fail(%default_code(code), %varfail_fmt(type, name))
#define %variable_nullref(type, name)          SWIG_exception_fail(SWIG_ValueError, %varnullref_fmt(type, name))

#if defined(SWIG_DIRECTOR_TYPEMAPS)
#define %dirout_fail(code, type)          SWIG_DirOutFail(%default_code(code), %outfail_fmt(type))
#define %dirout_nullref(type)             SWIG_DirOutFail(SWIG_ValueError, %outnullref_fmt(type))
#endif

/* -----------------------------------------------------------------------------
 *  All the typemaps
 * ----------------------------------------------------------------------------- */


%include <typemaps/fragments.swg>
%include <typemaps/exception.swg>
%include <typemaps/swigtype.swg>
%include <typemaps/void.swg>
%include <typemaps/swigobject.swg>
%include <typemaps/valtypes.swg>
%include <typemaps/ptrtypes.swg>
%include <typemaps/inoutlist.swg>
%include <typemaps/primtypes.swg>
%include <typemaps/string.swg>
%include <typemaps/misctypes.swg>
%include <typemaps/enumint.swg>





================================================
File: swig/swigwin-3.0.8/Lib/typemaps/traits.swg
================================================
//
// Use the following macro with modern STL implementations
//
//#define SWIG_STD_MODERN_STL
//
// Use this to deactive the previous definition, when using gcc-2.95
// or similar old compilers.
//
//#define SWIG_STD_NOMODERN_STL

// Here, we identify compilers we now have problems with STL.
%{
#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif
%}

//
// Common code for supporting the STD C++ namespace
//

%fragment("<string>");
%fragment("<stdexcept>");

%fragment("Traits","header",fragment="<string>")
{
namespace swig {  
  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<Type>::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

 
  template <class Type, class Category = typename traits<Type>::category > 
  struct traits_check { };

  /*
    Traits that provides the from method for an unknown type
  */
  template <int flags, class Type> struct traits_from_ptr {
    static SWIG_Object from SWIG_FROM_DECL_ARGS(Type *val) {
      return SWIG_NewPointerObj(val, type_info<Type>(), flags);
    }
  };

  template <class Type> struct traits_from {
    static SWIG_Object from SWIG_FROM_DECL_ARGS(const Type& val) {
      return traits_from_ptr<SWIG_POINTER_OWN, Type>::from(new Type(val));
    }
  };

  template <class Type> struct traits_from<Type *> {
    static SWIG_Object from SWIG_FROM_DECL_ARGS(Type* val) {
      return traits_from_ptr<0, Type>::from(val);
    }
  };

  template <class Type>
  inline SWIG_Object from SWIG_FROM_DECL_ARGS(const Type& val) {
    return traits_from<Type>::from(val);
  }

  /*
    Traits that provides the asptr/asval method for an unknown type
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr SWIG_AS_DECL_ARGS (SWIG_Object obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, %as_voidptrptr(&p), type_info<Type>(), 0);
      if (SWIG_IsOK(res) && val) *val = p;
      return res;
    }
  }; 

  template <class Type>
  inline int asptr SWIG_AS_DECL_ARGS(SWIG_Object obj, Type **vptr) {
    return traits_asptr<Type>::asptr SWIG_AS_CALL_ARGS(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval SWIG_AS_DECL_ARGS(SWIG_Object obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr SWIG_AS_CALL_ARGS(obj, &p);
	if (SWIG_IsOK(res) && p) {
	  *val = *p;
	  if (SWIG_IsNewObj(res)) {
	    %delete(p);
	    res = SWIG_DelNewMask(res);
	  }
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr SWIG_AS_CALL_ARGS(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval SWIG_AS_DECL_ARGS (SWIG_Object obj, Type *val) {
    return traits_asval<Type>::asval SWIG_AS_CALL_ARGS(obj, val);
  }

  /*
    Traits that provides the check method for an unknown type
  */
#define SWIG_CHECK_DECL_ARGS(obj) SWIG_AS_DECL_ARGS(obj, void * = 0)
#define SWIG_CHECK_CALL_ARGS(obj) SWIG_AS_CALL_ARGS(obj, 0)

  template <class Type> 
  struct traits_checkval {
    static int check SWIG_CHECK_DECL_ARGS(SWIG_Object obj) {
      if (obj) {
	int res = asval SWIG_AS_CALL_ARGS(obj, (Type *)(0));
	return SWIG_CheckState(res);
      } else {
	return 0;
      }
    }
  };

  template <class Type> 
  struct traits_checkptr {
    static int check SWIG_CHECK_DECL_ARGS(SWIG_Object obj) {
      if (obj) {
	int res = asptr SWIG_AS_CALL_ARGS(obj, (Type **)(0));
	return SWIG_CheckState(res);
      } else {
	return 0;
      }
    }
  };

  template <class Type> 
  struct traits_check<Type, value_category> : traits_checkval<Type> {
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> : traits_checkptr<Type> {
  };

  template <class Type>
  inline int check SWIG_CHECK_DECL_ARGS(SWIG_Object obj) {
    return traits_check<Type>::check SWIG_CHECK_CALL_ARGS(obj);
  }

}
}
 
/*
  Generate the traits for an unknown SWIGTYPE
*/

%define %traits_swigtype(Type...)
%fragment(SWIG_Traits_frag(Type),"header",fragment="Traits") {
  namespace swig {
    template <>  struct traits<Type > {
      typedef pointer_category category;
      static const char* type_name() { return  #Type; }
    };
  }
}
%enddef


/*
  Generate the traits for a 'value' type, such as 'double',
  for which the SWIG_AsVal and SWIG_From methods are already defined.
*/

%define %traits_value(Type...)
%fragment(SWIG_Traits_frag(Type),"header",
	  fragment=SWIG_AsVal_frag(Type),
	  fragment=SWIG_From_frag(Type),
	  fragment="Traits") {
namespace swig {
  template <> struct traits<Type > {
    typedef value_category category;
    static const char* type_name() { return  #Type; }
  };  

  template <>  struct traits_asval<Type > {   
    typedef Type value_type;
    static int asval SWIG_AS_DECL_ARGS (SWIG_Object obj, value_type *val) {
      return SWIG_AsVal(Type)(obj, val);
    }
  };

  template <>  struct traits_from<Type > {
    typedef Type value_type;
    static SWIG_Object from SWIG_FROM_DECL_ARGS (const value_type& val) {
      return SWIG_From(Type)(val);
    }
  };
}
}
%enddef

/*
  Generate the traits for a 'pointer' type, such as 'std::string',
  for which the SWIG_AsPtr and SWIG_From methods are already defined.
*/

%define %traits_pointer(Type...)
%fragment(SWIG_Traits_frag(Type),"header",
	  fragment=SWIG_AsVal_frag(Type),
	  fragment=SWIG_From_frag(Type),
	  fragment="Traits") {
namespace swig {
  template <> struct traits<Type > {
    typedef pointer_category category;
    static const char* type_name() { return  #Type; }
  };  
    
  template <>  struct traits_asptr<Type > {   
    typedef Type value_type;
    static int asptr SWIG_AS_DECL_ARGS (SWIG_Object obj, value_type **val) {
      return SWIG_AsPtr(Type)(obj, val);
    }
  };

  template <>  struct traits_from<Type > {
    typedef Type value_type;
    static SWIG_Object from SWIG_FROM_DECL_ARGS (const value_type& val) {
      return SWIG_From(Type)(val);
    }
  };
}
}
%enddef

/*
  Generate the typemaps for a class that has 'value' traits
*/

%define %typemap_traits_value(Code,Type...)
  %typemaps_asvalfrom(%arg(Code),
		      %arg(swig::asval),
		      %arg(swig::from),
		      %arg(SWIG_Traits_frag(Type)),
		      %arg(SWIG_Traits_frag(Type)),
		      Type);
%enddef

/*
  Generate the typemaps for a class that has 'pointer' traits
*/

%define %typemap_traits_pointer(Code,Type...)
  %typemaps_asptrfrom(%arg(Code),
		      %arg(swig::asptr),
		      %arg(swig::from),
		      %arg(SWIG_Traits_frag(Type)),
		      %arg(SWIG_Traits_frag(Type)),
		      Type);
%enddef




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/typemaps.swg
================================================
/* -----------------------------------------------------------------------------
 * typemaps.swg
 *
 * Tcl Pointer handling
 *
 * These mappings provide support for input/output arguments and common
 * uses for C/C++ pointers.
 * ----------------------------------------------------------------------------- */

// INPUT typemaps.
// These remap a C pointer to be an "INPUT" value which is passed by value
// instead of reference.

/* 
The following methods can be applied to turn a pointer into a simple
"input" value.  That is, instead of passing a pointer to an object,
you would use a real value instead.

         int            *INPUT
         short          *INPUT
         long           *INPUT
	 long long      *INPUT
         unsigned int   *INPUT
         unsigned short *INPUT
         unsigned long  *INPUT
         unsigned long long *INPUT
         unsigned char  *INPUT
         bool           *INPUT
         float          *INPUT
         double         *INPUT
         
To use these, suppose you had a C function like this :

        double fadd(double *a, double *b) {
               return *a+*b;
        }

You could wrap it with SWIG as follows :
        
        %include <typemaps.i>
        double fadd(double *INPUT, double *INPUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *INPUT { double *a, double *b };
        double fadd(double *a, double *b);

*/

// OUTPUT typemaps.   These typemaps are used for parameters that
// are output only.   The output value is appended to the result as
// a list element.

/* 
The following methods can be applied to turn a pointer into an "output"
value.  When calling a function, no input value would be given for
a parameter, but an output value would be returned.  In the case of
multiple output values, they are returned in the form of a Tcl tuple.

         int            *OUTPUT
         short          *OUTPUT
         long           *OUTPUT
         long long      *OUTPUT
         unsigned int   *OUTPUT
         unsigned short *OUTPUT
         unsigned long  *OUTPUT
         unsigned long long *OUTPUT
         unsigned char  *OUTPUT
         bool           *OUTPUT
         float          *OUTPUT
         double         *OUTPUT
         
For example, suppose you were trying to wrap the modf() function in the
C math library which splits x into integral and fractional parts (and
returns the integer part in one of its parameters).K:

        double modf(double x, double *ip);

You could wrap it with SWIG as follows :

        %include <typemaps.i>
        double modf(double x, double *OUTPUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *OUTPUT { double *ip };
        double modf(double x, double *ip);

The Tcl output of the function would be a tuple containing both
output values. 

*/

// INOUT
// Mappings for an argument that is both an input and output
// parameter

/*
The following methods can be applied to make a function parameter both
an input and output value.  This combines the behavior of both the
"INPUT" and "OUTPUT" methods described earlier.  Output values are
returned in the form of a Tcl tuple.  

         int            *INOUT
         short          *INOUT
         long           *INOUT
         long long      *INOUT
         unsigned int   *INOUT
         unsigned short *INOUT
         unsigned long  *INOUT
         unsigned long long *INOUT
         unsigned char  *INOUT
         bool           *INOUT
         float          *INOUT
         double         *INOUT
         
For example, suppose you were trying to wrap the following function :

        void neg(double *x) {
             *x = -(*x);
        }

You could wrap it with SWIG as follows :

        %include <typemaps.i>
        void neg(double *INOUT);

or you can use the %apply directive :

        %include <typemaps.i>
        %apply double *INOUT { double *x };
        void neg(double *x);

Unlike C, this mapping does not directly modify the input value (since
this makes no sense in Tcl).  Rather, the modified input value shows
up as the return value of the function.  Thus, to apply this function
to a Tcl variable you might do this :

       x = neg(x)

Note : previous versions of SWIG used the symbol 'BOTH' to mark
input/output arguments.   This is still supported, but will be slowly
phased out in future releases.

*/


#if defined(SWIG_INOUT_NODEF)

%apply_checkctypes(%typemaps_inoutn)

%apply size_t& { std::size_t& };
%apply ptrdiff_t& { std::ptrdiff_t& };

#endif



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/valtypes.swg
================================================
/*---------------------------------------------------------------------
 * Value typemaps (Type, const Type&) for value types, such as
 * fundamental types (int, double), that define the AsVal/From
 * methods.
 *
 * To apply them, just use one of the following macros:
 *
 *   %typemaps_from(FromMeth, FromFrag, Type)
 *   %typemaps_asval(CheckCode, AsValMeth, AsValFrag, Type)
 *   %typemaps_asvalfrom(CheckCode, AsValMeth, FromMeth, AsValFrag, FromFrag, Type)
 *
 * or the simpler and normalize form:
 *
 *   %typemaps_asvalfromn(CheckCode, Type)
 *
 * Also, you can use the individual typemap definitions:
 *
 *    %value_in_typemap(asval_meth,frag,Type)
 *    %value_varin_typemap(asval_meth,frag,Type)
 *    %value_typecheck_typemap(checkcode,asval_meth,frag,Type)
 *    %value_directorout_typemap(asval_meth,frag,Type)
 *
 *    %value_out_typemap(from_meth,frag,Type)
 *    %value_varout_typemap(from_meth,frag,Type)
 *    %value_constcode_typemap(from_meth,frag,Type)
 *    %value_directorin_typemap(from_meth,frag,Type)
 *    %value_throws_typemap(from_meth,frag,Type)
 *
 *---------------------------------------------------------------------*/

/* in */

%define %value_in_typemap(asval_meth,frag,Type...)
  %typemap(in,noblock=1,fragment=frag) Type (Type val, int ecode = 0) {
    ecode = asval_meth($input, &val);
    if (!SWIG_IsOK(ecode)) {
      %argument_fail(ecode, "$ltype", $symname, $argnum);
    } 
    $1 = %static_cast(val,$ltype);
  }
  %typemap(freearg) Type "";
  %typemap(in,noblock=1,fragment=frag) const Type & ($*ltype temp, Type val, int ecode = 0) {  
    ecode = asval_meth($input, &val);
    if (!SWIG_IsOK(ecode)) {
      %argument_fail(ecode, "$*ltype", $symname, $argnum);
    } 
    temp = %static_cast(val, $*ltype);
    $1 = &temp;
  }
  %typemap(freearg) const Type& "";
%enddef

/* out */

%define %value_out_typemap(from_meth,frag,Type...)
  %typemap(out,noblock=1,fragment=frag) Type, const Type {
    %set_output(from_meth(%static_cast($1,Type))); 
  }
  %typemap(out,noblock=1,fragment=frag) const Type& {
    %set_output(from_meth(%static_cast(*$1,Type))); 
  }
%enddef

/* varin */

%define %value_varin_typemap(asval_meth,frag,Type...)
  %typemap(varin,fragment=frag) Type {
    Type val;
    int res = asval_meth($input, &val);
    if (!SWIG_IsOK(res)) {
      %variable_fail(res, "$type", "$name");
    }
    $1 = %static_cast(val,$ltype);
  }
%enddef

/* varout */

%define %value_varout_typemap(from_meth,frag,Type...)
  %typemap(varout,noblock=1,fragment=frag) Type, const Type&  {
    %set_varoutput(from_meth(%static_cast($1,Type)));
  }
%enddef

/* constant installation code */

%define %value_constcode_typemap(from_meth,frag,Type...)
  %typemap(constcode,noblock=1,fragment=frag) Type {
    %set_constant("$symname", from_meth(%static_cast($value,Type)));
  }
%enddef


#if defined(SWIG_DIRECTOR_TYPEMAPS)

/* directorin */

%define %value_directorin_typemap(from_meth,frag,Type...)
  %typemap(directorin,noblock=1,fragment=frag) Type *DIRECTORIN {
    $input = from_meth(%static_cast(*$1,Type)); 
  }
  %typemap(directorin,noblock=1,fragment=frag) Type, const Type& {
    $input = from_meth(%static_cast($1,Type)); 
  }
%enddef

/* directorout */

%define %value_directorout_typemap(asval_meth,frag,Type...)
  %typemap(directorargout,noblock=1,fragment=frag) Type *DIRECTOROUT(Type swig_val, int swig_res) {
    swig_res = asval_meth($result, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      %dirout_fail(swig_res, "$type");
    } 
    *$1 = swig_val;
  }
  %typemap(directorout,noblock=1,fragment=frag) Type {
    Type swig_val;
    int swig_res = asval_meth($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      %dirout_fail(swig_res, "$type");
    }
    $result = %static_cast(swig_val,$type);
  }
  %typemap(directorout,noblock=1,fragment=frag,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) const Type& {  
    Type swig_val;
    int swig_res = asval_meth($input, &swig_val);
    if (!SWIG_IsOK(swig_res)) {
      %dirout_fail(swig_res, "$type");
    } 
    $basetype *temp = new $basetype(($basetype)swig_val);
    swig_acquire_ownership(temp);
    $result = temp;
  }
  %typemap(directorfree,noblock=1) const Type & {
    if (director) {
      director->swig_release_ownership(%as_voidptr($input));
    }
  }
  %typemap(directorout,fragment=frag) Type &DIRECTOROUT = Type
%enddef

#else

#define %value_directorin_typemap(from_meth,frag,Type...)
#define %value_directorout_typemap(asval_meth,frag,Type...)

#endif /* SWIG_DIRECTOR_TYPEMAPS */


/* throws */

%define %value_throws_typemap(from_meth,frag,Type...)
  %typemap(throws,noblock=1,fragment=frag) Type {
    %raise(from_meth(%static_cast($1,Type)), "$type", 0);
  }
%enddef

/* typecheck */

%define %value_typecheck_typemap(check,asval_meth,frag,Type...)
  %typemap(typecheck,precedence=check,fragment=frag) Type, const Type& {
    int res = asval_meth($input, NULL);
    $1 = SWIG_CheckState(res);
  }
%enddef

/*---------------------------------------------------------------------
 * typemap definition for types with AsVal methods
 *---------------------------------------------------------------------*/
%define %typemaps_asval(CheckCode, AsValMeth, AsValFrag, Type...)
  %value_in_typemap(%arg(AsValMeth), %arg(AsValFrag), Type);
  %value_varin_typemap(%arg(AsValMeth), %arg(AsValFrag), Type);
  %value_directorout_typemap(%arg(AsValMeth), %arg(AsValFrag), Type);
  %value_typecheck_typemap(%arg(CheckCode), %arg(AsValMeth), %arg(AsValFrag), Type);
  %value_input_typemap(%arg(CheckCode), %arg(AsValMeth), %arg(AsValFrag), Type);
%enddef


/*---------------------------------------------------------------------
 * typemap definition for types with from method
 *---------------------------------------------------------------------*/
%define %typemaps_from(FromMeth, FromFrag, Type...)
  %value_out_typemap(%arg(FromMeth), %arg(FromFrag), Type);
  %value_varout_typemap(%arg(FromMeth), %arg(FromFrag), Type);
  %value_constcode_typemap(%arg(FromMeth), %arg(FromFrag), Type);
  %value_directorin_typemap(%arg(FromMeth), %arg(FromFrag), Type);
  %value_throws_typemap(%arg(FromMeth), %arg(FromFrag), Type);
  %value_output_typemap(%arg(FromMeth), %arg(FromFrag), Type);
%enddef


/*---------------------------------------------------------------------
 * typemap definition for types with alval/from method
 *---------------------------------------------------------------------*/

%define %typemaps_asvalfrom(CheckCode, AsValMeth, FromMeth,
			   AsValFrag, FromFrag, Type...)
  %typemaps_asval(%arg(CheckCode), %arg(AsValMeth), %arg(AsValFrag), Type);
  %typemaps_from(%arg(FromMeth), %arg(FromFrag), Type);
  %value_inout_typemap(Type);
%enddef


/*---------------------------------------------------------------------
 * typemap definition for types  with for 'normalized' asval/from methods
 *---------------------------------------------------------------------*/
%define %typemaps_asvalfromn(CheckCode, Type...)
  %typemaps_asvalfrom(%arg(CheckCode),
		     SWIG_AsVal(Type), 
		     SWIG_From(Type), 
		     %arg(SWIG_AsVal_frag(Type)),
		     %arg(SWIG_From_frag(Type)), 
		     Type);
%enddef



================================================
File: swig/swigwin-3.0.8/Lib/typemaps/void.swg
================================================
/* ------------------------------------------------------------
 * Void * -  Accepts any kind of pointer
 * ------------------------------------------------------------ */

/* in */

%typemap(in,noblock=1) void * (int res) {
  res = SWIG_ConvertPtr($input,%as_voidptrptr(&$1), 0, $disown);
  if (!SWIG_IsOK(res)) { 
    %argument_fail(res, "$type", $symname, $argnum); 
  }
}
%typemap(freearg) void * "";

%typemap(in,noblock=1) void * const& ($*ltype temp = 0, int res) {
  res = SWIG_ConvertPtr($input, %as_voidptrptr(&temp), 0, $disown);
  if (!SWIG_IsOK(res)) { 
    %argument_fail(res, "Stype", $symname, $argnum); 
  }
  $1 =  &temp;
}
%typemap(freearg) void * const& "";


/* out */

#if defined(VOID_Object)
%typemap(out,noblock=1) void { $result = VOID_Object; }
#else
%typemap(out,noblock=1) void {}
#endif

/* varin */

%typemap(varin) void * {
  void *temp = 0;
  int res = SWIG_ConvertPtr($input, &temp, 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res)) {
    %variable_fail(res, "$type", "$name");
  }
  $1 = ($1_ltype) temp;
}

/* typecheck */

%typecheck(SWIG_TYPECHECK_VOIDPTR, noblock=1) void *
{
  void *ptr = 0;
  int res = SWIG_ConvertPtr($input, &ptr, 0, 0);
  $1 = SWIG_CheckState(res);
}

#if defined(SWIG_DIRECTOR_TYPEMAPS)

/* directorin */

%typemap(directorin,noblock=1) void *, void const*, void *const, void const *const, 
  void const *&, void *const &, void const *const & {
  $input = SWIG_NewPointerObj(%as_voidptr($1), $descriptor, %newpointer_flags);
}

/* directorout */

%typemap(directorout,noblock=1) void * (void *argp, int res) {
  res = SWIG_ConvertPtr($input, &argp, 0, 0);
  if (!SWIG_IsOK(res)) {
    %dirout_fail(res,"$type");
  }
  $result = %reinterpret_cast(argp, $ltype);
}

%typemap(directorout,noblock=1,warning=SWIGWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) void * const& (void *argp, int res) {
  res = SWIG_ConvertPtr($input, &argp, 0, $disown);
  if (!SWIG_IsOK(res)) { 
    %dirout_fail(res,"$type");
  }
  static $*ltype temp = %reinterpret_cast(argp, $*ltype);
  $result =  &temp;
}



#endif /* SWIG_DIRECTOR_TYPEMAPS */




================================================
File: swig/swigwin-3.0.8/Lib/typemaps/wstring.swg
================================================
%ensure_fragment(SWIG_AsWCharPtrAndSize)
%ensure_fragment(SWIG_FromWCharPtrAndSize)


%types(wchar_t *);

%fragment("SWIG_pwchar_descriptor","header") {
SWIGINTERN swig_type_info*
SWIG_pwchar_descriptor()
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_wchar_t");
    init = 1;
  }
  return info;
}
}

%fragment("SWIG_wcsnlen","header",fragment="SWIG_FromWCharPtrAndSize") {
size_t
SWIG_wcsnlen(const wchar_t* s, size_t maxlen)
{
  const wchar_t *p;
  for (p = s; maxlen-- && *p; p++)
    ;
  return p - s;
}
}

%include <typemaps/strings.swg>
%typemaps_string(%checkcode(UNISTRING), %checkcode(UNICHAR),
		 wchar_t, WChar, SWIG_AsWCharPtrAndSize, SWIG_FromWCharPtrAndSize,
		 wcslen, SWIG_wcsnlen,
		"<wchar.h>", WCHAR_MIN, WCHAR_MAX)




================================================
File: swig/x64dbgpy/__breakpoints.py
================================================
from collections import defaultdict
from utils import Singleton
from pluginsdk._scriptapi.debug import SetBreakpoint, DeleteBreakpoint, \
    SetHardwareBreakpoint, DeleteHardwareBreakpoint, HardwareType

NONE = 0
NORMAL = 1
HARDWARE = 2
MEMORY = 4

ACCESS = HardwareType.HardwareAccess
WRITE = HardwareType.HardwareWrite
EXECUTE = HardwareType.HardwareExecute


class Breakpoint(object):
    __metaclass__ = Singleton

    BP_NONE = NONE
    BP_NORMAL = NORMAL
    BP_HARDWARE = HARDWARE
    BP_MEMORY = MEMORY

    HW_ACCESS = ACCESS
    HW_WRITE = WRITE
    HW_EXECUTE = EXECUTE

    def __init__(self, event_object):
        self.__breakpoints = defaultdict(dict)
        self.__event_object = event_object

        self.enable()

    def __breakpoint_function(self, **kwargs):
        address = kwargs['addr']
        if address in self.__breakpoints:
            if not (kwargs['enabled'] and kwargs['active']):
                return

            arg_keys = self.__breakpoints[address]['callback_args']
            self.__breakpoints[address]['callback'](
                **{key: value for key, value in kwargs.iteritems() if key in arg_keys}
            )

    def enable(self):
        self.__event_object.listen('breakpoint', self.__breakpoint_function)

    def disable(self):
        self.__event_object.listen('breakpoint', None)

    def add(self, address, callback, bp_type=NORMAL, hw_type=EXECUTE, callback_args=()):
        if bp_type == self.BP_NORMAL:
            SetBreakpoint(address)
        elif bp_type == self.BP_HARDWARE:
            SetHardwareBreakpoint(address, hw_type)

        self.__breakpoints[address]['callback'] = callback
        self.__breakpoints[address]['type'] = bp_type
        self.__breakpoints[address]['callback_args'] = callback_args

    def remove(self, address):
        if address not in self.__breakpoints:
            return

        bp_type = self.__breakpoints[address]['type']
        if bp_type == self.BP_NORMAL:
            DeleteBreakpoint(address)
        elif bp_type == self.BP_HARDWARE:
            DeleteHardwareBreakpoint(address)

        del self.__breakpoints[address]

    def list(self):
        return self.__breakpoints.keys()



================================================
File: swig/x64dbgpy/__events.py
================================================
# import os
# from os import path
# import runpy
# import glob
from utils import Singleton

EVENTS = [
    # 'init_debug',
    'stop_debug',
    'breakpoint',
    'create_process',
    'exit_process',
    'create_thread',
    'exit_thread',
    'system_breakpoint',
    'load_dll',
    'unload_dll',
    'trace_execute'
]

class Event(object):
    __metaclass__ = Singleton

    def __init__(self):
        # Keys: type, addr, enabled, singleshoot, active, name, mod, slot
        # typedef struct
        # {
        #     BPXTYPE type;
        #     duint addr;
        #     bool enabled;
        #     bool singleshoot;
        #     bool active;
        #     char name[MAX_BREAKPOINT_SIZE];
        #     char mod[MAX_MODULE_SIZE];
        #     unsigned short slot;
        # } BRIDGEBP;
        #
        # typedef enum
        # {
        #     bp_none = 0,
        #     bp_normal = 1,
        #     bp_hardware = 2,
        #     bp_memory = 4
        # } BPXTYPE;
        self.breakpoint = None
        # Keys: None
        self.stop_debug = None
        # Keys: CreateProcessInfo, modInfo, DebugFileName, fdProcessInfo
        # typedef struct
        # {
        #     CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
        #     IMAGEHLP_MODULE64* modInfo;
        #     const char* DebugFileName;
        #     PROCESS_INFORMATION* fdProcessInfo;
        # } PLUG_CB_CREATEPROCESS;
        self.create_process = None
        # Keys: dwExitCode
        # typedef struct _EXIT_PROCESS_DEBUG_INFO {
        #   DWORD dwExitCode;
        # } EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;
        self.exit_process = None
        # Keys: CreateThread, dwThreadId
        # typedef struct
        # {
        #     CREATE_THREAD_DEBUG_INFO* CreateThread;
        #     DWORD dwThreadId;
        # } PLUG_CB_CREATETHREAD;
        self.create_thread = None
        # Keys: dwThreadId, dwExitCode
        # typedef struct
        # {
        #     EXIT_THREAD_DEBUG_INFO* ExitThread;
        #     DWORD dwThreadId;
        # } PLUG_CB_EXITTHREAD;
        self.exit_thread = None
        # Keys: None
        self.system_breakpoint = None
        # Keys: LoadDll, modInfo, modname
        # typedef LoadDll, modInfo, modname
        # {
        #     LOAD_DLL_DEBUG_INFO* LoadDll;
        #     IMAGEHLP_MODULE64* modInfo;
        #     const char* modname;
        # } PLUG_CB_LOADDLL;
        self.load_dll = None
        # Keys: lpBaseOfDll
        # typedef struct
        # {
        #     UNLOAD_DLL_DEBUG_INFO* UnloadDll;
        # } PLUG_CB_UNLOADDLL;
        self.unload_dll = None
        # Keys: trace
        # typedef struct
        # {
        #     duint cip;
        #     bool stop;
        # } PLUG_CB_TRACEEXECUTE;
        self.trace_execute = None

    def listen(self, event_name, callback):
        """
        Listen to event with a callback,
        Callback should always get key word arguments(kwargs).

        For example:
        def callback(**kwargs):
            print kwargs
        """
        event_name_lower = event_name.lower()
        if event_name_lower not in EVENTS:
            raise Exception("%s Is not a valid event." % event_name_lower)

        setattr(self, event_name_lower, callback)

    # @staticmethod
    # def init_debug():
    #     old_path = os.getcwdu()
    #     os.chdir(path.join(path.dirname(__file__), 'autorun'))
    #     for file_path in glob.glob("*.py"):
    #         print "[PYTHON] Executing autorun file: '%s'." % file_path
    #         runpy.run_path(
    #             path_name=file_path,
    #             run_name='__main__',
    #         )
    #         os.chdir(old_path)



================================================
File: swig/x64dbgpy/__flags.py
================================================
import functools
import pluginsdk._scriptapi
from utils import Singleton
from pluginsdk.bridgemain import GuiUpdateAllViews


FLAGS = (
    'ZF', 'OF', 'CF',
    'PF', 'SF', 'TF',
    'AF', 'DF', 'IF'
)


class Flag(object):
    __metaclass__ = Singleton

    def __init__(self, refresh_gui=True):
        self.refresh_gui = refresh_gui

        for flag in FLAGS:
            setattr(self.__class__, flag, property(
                fget=functools.partial(self._get_func, register=flag),
                fset=functools.partial(self._set_func, register=flag)
            ))

    @staticmethod
    def __get_flag_function(flag, get=True):
        flag_name = flag.upper()
        if flag_name not in FLAGS:
            raise Exception("'%s' is not a valid flag." % flag)

        return getattr(
            pluginsdk._scriptapi.flag,
            '{method}{flag}'.format(
                method='Get' if get else 'Set',
                flag=flag_name
            )
        )

    @staticmethod
    def _get_func(self, register):
        return self.__get_flag_function(register)()

    @staticmethod    
    def _set_func(self, value, flag):
        self.__get_flag_function(flag, get=False)(value)
        if self.refresh_gui:
            GuiUpdateAllViews()



================================================
File: swig/x64dbgpy/__init__.py
================================================
__author__ = 'Tomer Zait (RealGame)'
__version__ = '1.0.0'

import hooks
import pluginsdk
import __registers
import __events
import __flags
import __breakpoints

Register = __registers.Register()
Event = __events.Event()
Flag = __flags.Flag()
Breakpoint = __breakpoints.Breakpoint(Event)



================================================
File: swig/x64dbgpy/__registers.py
================================================
import functools
from utils import is_64bit, Singleton
import pluginsdk._scriptapi
from pluginsdk.bridgemain import GuiUpdateAllViews


X86_DEBUG_REGISTERS = (
    'DR0', 'DR1', 'DR2', 'DR3', 'DR6', 'DR7'
)
X86_REGISTERS = (
    'EAX', 'AX', 'AH', 'AL',
    'EBX', 'BX', 'BH', 'BL',
    'ECX', 'CX', 'CH', 'CL',
    'EDX', 'DX', 'DH', 'DL',
    'EDI', 'DI', 'ESI', 'SI',
    'EBP', 'BP', 'ESP', 'SP',
    'EIP',
) + X86_DEBUG_REGISTERS

X64_REGISTERS = (
    'RAX', 'RBX', 'RCX', 'RDX',
    'RSI', 'SIL', 'RDI', 'DIL',
    'RBP', 'BPL', 'RSP', 'SPL', 'RIP',
    'R8', 'R8D', 'R8W', 'R8B',
    'R9', 'R9D', 'R9W', 'R9B',
    'R10', 'R10D', 'R10W', 'R10B',
    'R11', 'R11D', 'R11W', 'R11B',
    'R12', 'R12D', 'R12W', 'R12B',
    'R13', 'R13D', 'R13W', 'R13B',
    'R14', 'R14D', 'R14W', 'R14B',
    'R15', 'R15D', 'R15W', 'R15B',
) + X86_REGISTERS

GEN_REGISTERS = (
    'CIP',  # Generic EIP/RIP register
    'CSP'   # Generic ESP/RSP register
)

REGISTERS = (X64_REGISTERS if is_64bit() else X86_REGISTERS) + GEN_REGISTERS


class Register(object):
    __metaclass__ = Singleton

    def __init__(self, refresh_gui=True):
        self.refresh_gui = refresh_gui

        for register in REGISTERS:
            setattr(self.__class__, register, property(
                fget=functools.partial(self._get_func, register=register),
                fset=functools.partial(self._set_func, register=register)
            ))

    @staticmethod
    def __get_reg_function(register, get=True):
        register_name = register.upper()
        if register_name not in REGISTERS:
            raise Exception("'{reg}' is not a valid {platform} register.".format(
                reg=register_name, platform='x64' if is_64bit() else 'x86'
            ))

        return getattr(
            pluginsdk._scriptapi.register,
            '{method}{register}'.format(
                method='Get' if get else 'Set',
                register=register_name
            )
        )

    @staticmethod
    def _get_func(self, register):
        return self.__get_reg_function(register)()

    @staticmethod    
    def _set_func(self, value, register):
        self.__get_reg_function(register, get=False)(value)
        if self.refresh_gui:
            GuiUpdateAllViews()




================================================
File: swig/x64dbgpy/hooks.py
================================================
import sys
import signal
import warnings
import __builtin__
from os import path
import multiprocessing
from pluginsdk import bridgemain, _plugins


def __raw_input(prompt=''):
    return bridgemain.GuiGetLineWindow(prompt)


def __input(prompt=''):
    return eval(__raw_input(prompt))


def __signal(sig, action):
    warnings.warn('Cannot use signals in x64dbgpy...', UserWarning, stacklevel=2)


class OutputHook(object):
    def __init__(self, stream_name='stdout', callback=_plugins._plugin_logprint):
        self.is_hooking = False
        self.callback = callback

        self.stream_name = stream_name
        if self.stream_name not in ['stderr', 'stdout']:
            raise Exception('Cannot hook %s stream.' % self.stream_name)
        elif self.__is_hooked():
            raise Exception('Do not hook the hooker!')

        self.__original_stream = getattr(sys, self.stream_name)

    def __getattr__(self, name):
        return getattr(self.__original_stream, name)

    def __is_hooked(self):
        stream = getattr(sys, self.stream_name)
        return hasattr(stream, 'is_hooking')

    def write(self, text):
        self.callback(text)

        # Hack to workaround a Windows 10 specific error.
        # IOError (errno=0 OR errno=9) occurs when writing to stderr or stdout after an exception occurs.
        # Issue: https://github.com/x64dbg/x64dbgpy/issues/31
        # See:
        #    https://bugs.python.org/issue32245
        #    https://github.com/Microsoft/console/issues/40
        #    https://github.com/Microsoft/vscode/issues/36630
        # Further issue discussion:
        #    https://github.com/x64dbg/x64dbgpy/pull/32
        try:
            self.__original_stream.write(text)
        except IOError as e:
            pass

    def start(self):
        if not self.is_hooking:
            setattr(sys, self.stream_name, self)
            self.is_hooking = True

    def stop(self):
        if self.is_hooking:
            setattr(sys, self.stream_name, self.__original_stream)
            self.is_hooking = False


# Hook sys.stdout
STDOUT_HOOK = OutputHook('stdout')
STDOUT_HOOK.start()

# Hook sys.stderr
STDERR_HOOK = OutputHook('stderr')
STDERR_HOOK.start()

# Hook raw_input, input (stdin)
setattr(__builtin__, 'original_raw_input', __builtin__.raw_input)
setattr(__builtin__, 'raw_input', __raw_input)
setattr(__builtin__, 'original_input', __builtin__.input)
setattr(__builtin__, 'input', __input)

# Set arguments
sys.argv = [path.join(path.dirname(__file__), '__init__.py')]

# Hook Signals (for pip and other signal based programs)
setattr(signal, 'original_signal', signal.signal)
setattr(signal, 'signal', __signal)

# Fix Multiprocessing (Will not be able to use x64dbgpy lib for now...)
multiprocessing.set_executable(path.join(sys.exec_prefix, 'pythonw.exe'))

# Print Message That The Hooks Worked!
print '[PYTHON] stdout, stderr, raw_input hooked!'



================================================
File: swig/x64dbgpy/utils.py
================================================
import sys
import runpy
import shlex
from os import path
from ctypes import *


class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


def __OpenFileDialog():
    MAX_PATH = 260
    OFN_PATHMUSTEXIST = 0x00000800
    OFN_FILEMUSTEXIST = 0x00001000

    class OPENFILENAME(Structure):
        _fields_ = (("lStructSize", c_int),
                    ("hwndOwner", c_int),
                    ("hInstance", c_int),
                    ("lpstrFilter", c_wchar_p),
                    ("lpstrCustomFilter", c_char_p),
                    ("nMaxCustFilter", c_int),
                    ("nFilterIndex", c_int),
                    ("lpstrFile", c_wchar_p),
                    ("nMaxFile", c_int),
                    ("lpstrFileTitle", c_wchar_p),
                    ("nMaxFileTitle", c_int),
                    ("lpstrInitialDir", c_wchar_p),
                    ("lpstrTitle", c_wchar_p),
                    ("flags", c_int),
                    ("nFileOffset", c_ushort),
                    ("nFileExtension", c_ushort),
                    ("lpstrDefExt", c_char_p),
                    ("lCustData", c_int),
                    ("lpfnHook", c_char_p),
                    ("lpTemplateName", c_char_p),
                    ("pvReserved", c_char_p),
                    ("dwReserved", c_int),
                    ("flagsEx", c_int))

    opath = create_unicode_buffer(MAX_PATH)

    ofx = OPENFILENAME()
    ofx.lStructSize = sizeof(OPENFILENAME)
    ofx.nMaxFile = MAX_PATH
    ofx.hwndOwner = 0
    ofx.lpstrTitle = u"Select script file..."
    ofx.lpstrFile = cast(opath, c_wchar_p)
    ofx.lpstrFilter = u"Python files (*.py; *.pyw)\0*.py; *.pyw\0\0"
    ofx.flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST
    is_ok = windll.comdlg32.GetOpenFileNameW(byref(ofx))
    if is_ok:
        return opath.value


def is_64bit():
    return sys.maxsize > 2**32


def open_python_file(run_file=False):
    file_path = __OpenFileDialog()
    if not file_path:
        return

    if run_file:
        sys.path.insert(0, path.dirname(file_path))
        runpy.run_path(
            path_name=file_path,
            init_globals=globals(),
            run_name='__main__',
        )

    return file_path


def get_plugins_dir():
    current_dir = path.dirname(__file__)
    return path.dirname(current_dir)


def x64dbg_pip(args=list()):
    try:
        import pip
        # Split arguments
        arg_list = shlex.split(args, comments=False, posix=False)
        return pip.main(args=arg_list[1:])
    except ImportError:
        print "Pip is not installed: Please install pip from 'https://pip.readthedocs.org/en/stable/installing/'"



================================================
File: swig/x64dbgpy/autorun/README.md
================================================



================================================
File: swig/x64dbgpy/pluginsdk/__init__.py
================================================
from . import x64dbg
from .bridgemain import *
from ._plugins import *
from ._scriptapi import *



================================================
File: swig/x64dbgpy/pluginsdk/_plugins.py
================================================
from . import x64dbg

def _encode(text):
    try:
        return text.encode()
    except Exception:
        return repr(text)


def _plugin_logprint(text=''):
    x64dbg._plugin_logprint(_encode(text))


def _plugin_logputs(text=''):
    x64dbg._plugin_logputs(_encode(text))



================================================
File: swig/x64dbgpy/pluginsdk/bridgemain.py
================================================
import ctypes
from . import x64dbg


GUI_MAX_LINE_SIZE = 65536


def DbgIsDebugging():
    return x64dbg.DbgIsDebugging()

def GuiGetLineWindow(title=''):
    line = ctypes.create_string_buffer(GUI_MAX_LINE_SIZE)
    return_value = x64dbg.GuiGetLineWindow("%s" % title, line)
    if return_value:
        return line.value

def GuiGetWindowHandle():
    return x64dbg.GuiGetWindowHandle()

def GuiLogClear():
    x64dbg.GuiLogClear()

def GuiUpdateAllViews():
    x64dbg.GuiUpdateAllViews()



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/__init__.py
================================================
from .argument import *
from .bookmark import *
from .comment import *
from .debug import *
from .function import *
from .label import *
from .symbol import *
from .memory import *
from .register import *
from .gui import *
from .pattern import *
from .stack import *
from .assembler import *
from .misc import *
from .module import *
from .flag import *



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/argument.py
================================================
import ctypes
from .. import x64dbg


def Add(start, end, manual, instructionCount = 0):
    return x64dbg.Argument_Add(start, end, manual, instructionCount)

def AddInfo(info):
    return x64dbg.Argument_Add(info)

def Get(addr):
    res, start, end, instructionCount = x64dbg.Argument_Get(addr, 0, 0, 0)
    return start, end, instructionCount if res else None

def GetInfo(addr):
    info = x64dbg.ArgumentInfo()
    res = x64dbg.Argument_GetInfo(addr, info)
    if res:
        return info

def Overlaps(start, end):
    return x64dbg.Argument_Overlaps(start, end)

def Delete(addr):
    return x64dbg.Argument_Delete(addr)

def DeleteRange(start, end, deleteManual = False):
    return x64dbg.Argument_DeleteRange(start, end, deleteManual)

def Clear():
    x64dbg.Argument_Clear()

def GetList():
    l = x64dbg.ListInfo()
    res = x64dbg.Argument_GetList(l)
    if res:
        return x64dbg.GetArgumentInfoList(l)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/assembler.py
================================================
import ctypes
from .. import x64dbg


MAX_ERROR_SIZE = 512
MAX_STRING = 512


def Assemble(addr, instruction):
    dest = ctypes.create_string_buffer(MAX_STRING)
    result, size = x64dbg.Assemble(addr, dest, instruction)
    if result:
        return dest[:size].encode('hex')

def AssembleEx(addr, instruction):
    error = ctypes.create_string_buffer(MAX_ERROR_SIZE)
    dest = ctypes.create_string_buffer(MAX_STRING)
    result, size = x64dbg.AssembleEx(addr, dest, instruction, error)
    if not result:
        raise Exception(error.value)
    return dest[:size].encode('hex')

def AssembleMem(addr, instruction):
    return x64dbg.AssembleMem(addr, instruction)

def AssembleMemEx(addr, instruction, fillnop):
    error = ctypes.create_string_buffer(MAX_ERROR_SIZE)
    result, size = x64dbg.AssembleMemEx(addr, instruction, error, fillnop)
    if not result:
        raise Exception(error.value)
    return result



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/bookmark.py
================================================
import ctypes
from .. import x64dbg


def Set(addr, manual = False):
    return x64dbg.Bookmark_Set(addr, manual)

def SetInfo(info):
    return x64dbg.Bookmark_Set(info)

def Get(addr):
    return x64dbg.Bookmark_Get(addr)

def GetInfo(addr):
    info = x64dbg.BookmarkInfo()
    res = x64dbg.Bookmark_GetInfo(addr, info)
    if res:
        return info

def Delete(addr):
    return x64dbg.Bookmark_Delete(addr)

def DeleteRange(start, end):
    return x64dbg.Bookmark_DeleteRange(start, end)

def Clear():
    x64dbg.Bookmark_Clear()

def GetList():
    l = x64dbg.ListInfo()
    res = x64dbg.Bookmark_GetList(l)
    if res:
        return x64dbg.GetBookmarkInfoList(l)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/comment.py
================================================
import ctypes
from .. import x64dbg


MAX_COMMENT_SIZE = 512


def Set(addr, text, manual = False):
    return x64dbg.Comment_Set(addr, text, manual)

def SetInfo(info):
    return x64dbg.Comment_Set(info)

def Get(addr):
    text = ctypes.create_string_buffer(MAX_COMMENT_SIZE)
    res =  x64dbg.Comment_Get(addr, text)
    if res:
        return text.value

def GetInfo(addr):
    info = x64dbg.CommentInfo()
    res = x64dbg.Comment_GetInfo(addr, info)
    if res:
        return info

def Delete(addr):
    return x64dbg.Comment_Delete(addr)

def DeleteRange(start, end):
    return x64dbg.Comment_DeleteRange(start, end)

def Clear():
    x64dbg.Comment_Clear()

def GetList():
    l = x64dbg.ListInfo()
    res = x64dbg.Comment_GetList(l)
    if res:
        return x64dbg.GetCommentInfoList(l)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/debug.py
================================================
from .. import x64dbg


class HardwareType:
    HardwareAccess = x64dbg.HardwareAccess
    HardwareWrite = x64dbg.HardwareWrite
    HardwareExecute = x64dbg.HardwareExecute


def Wait():
    x64dbg.Wait()

def Run():
    x64dbg.Run()

def Stop():
    x64dbg.Stop()

def StepIn():
    x64dbg.StepIn()

def StepOver():
    x64dbg.StepOver()

def StepOut():
    x64dbg.StepOut()

def SetBreakpoint(address):
    return x64dbg.SetBreakpoint(address)

def DeleteBreakpoint(address):
    return x64dbg.DeleteBreakpoint(address)

def SetHardwareBreakpoint(address, type = HardwareType.HardwareExecute):
    return x64dbg.SetHardwareBreakpoint(address, type)

def DeleteHardwareBreakpoint(address):
    return x64dbg.DeleteHardwareBreakpoint(address)




================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/flag.py
================================================
from .. import x64dbg


class FlagEnum:
    ZF = x64dbg.ZF
    OF = x64dbg.OF
    CF = x64dbg.CF
    PF = x64dbg.PF
    SF = x64dbg.SF
    TF = x64dbg.TF
    AF = x64dbg.AF
    DF = x64dbg.DF
    IF = x64dbg.IF


def Flag_Get(flag):
    return x64dbg.Flag_Get(flag)

def Flag_Set(flag, value):
    return x64dbg.Flag_Set(flag, value)


def GetZF():
    return x64dbg.GetZF()

def SetZF(value):
    return x64dbg.SetZF(value)

def GetOF():
    return x64dbg.GetOF()

def SetOF(value):
    return x64dbg.SetOF(value)

def GetCF():
    return x64dbg.GetCF()

def SetCF(value):
    return x64dbg.SetCF(value)

def GetPF():
    return x64dbg.GetPF()

def SetPF(value):
    return x64dbg.SetPF(value)

def GetSF():
    return x64dbg.GetSF()

def SetSF(value):
    return x64dbg.SetSF(value)

def GetTF():
    return x64dbg.GetTF()

def SetTF(value):
    return x64dbg.SetTF(value)

def GetAF():
    return x64dbg.GetAF()

def SetAF(value):
    return x64dbg.SetAF(value)

def GetDF():
    return x64dbg.GetDF()

def SetDF(value):
    return x64dbg.SetDF(value)

def GetIF():
    return x64dbg.GetIF()

def SetIF(value):
    return x64dbg.SetIF(value)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/function.py
================================================
import ctypes
from .. import x64dbg


def Add(start, end, manual, instructionCount = 0):
    return x64dbg.Function_Add(start, end, manual, instructionCount)

def AddInfo(info):
    return x64dbg.Function_Add(info)

def Get(addr):
    res, start, end, instructionCount = x64dbg.Function_Get(addr, 0, 0, 0)
    return start, end, instructionCount if res else None

def GetInfo(addr):
    info = x64dbg.FunctionInfo()
    res = x64dbg.Function_GetInfo(addr, info)
    if res:
        return info

def Overlaps(start, end):
    return x64dbg.Function_Overlaps(start, end)

def Delete(addr):
    return x64dbg.Function_Delete(addr)

def DeleteRange(start, end, deleteManual = False):
    return x64dbg.Function_DeleteRange(start, end, deleteManual)

def Clear():
    x64dbg.Function_Clear()

def GetList():
    l = x64dbg.ListInfo()
    res = x64dbg.Function_GetList(l)
    if res:
        return x64dbg.GetFunctionInfoList(l)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/gui.py
================================================
import ctypes
from .. import x64dbg


GUI_MAX_LINE_SIZE = 65536


# Script::Gui
def Gui_SelectionGet(window):
    result, start, end = x64dbg.Gui_SelectionGet(window)
    if result:
        return start, end

def Gui_SelectionSet(window, start, end):
    return x64dbg.Gui_SelectionSet(window, start, end)

def Gui_SelectionGetStart(window):
    return x64dbg.Gui_SelectionGetStart(window)

def Gui_SelectionGetEnd(window):
    return x64dbg.Gui_SelectionGetEnd(window)

def Message(message):
    x64dbg.Message(message)

def MessageYesNo(message):
    return x64dbg.MessageYesNo(message)

def InputLine(title):
    text = ctypes.create_string_buffer(GUI_MAX_LINE_SIZE)
    res =  x64dbg.InputLine(title, text)
    if res:
        return text.value

def InputValue(title):
    res, value =  x64dbg.InputValue(title)
    if res:
        return value

def Refresh():
    x64dbg.Refresh()


# Script::Gui::Disassembly
def Disassembly_SelectionGet():
    result, start, end = x64dbg.Disassembly_SelectionGet()
    if result:
        return start, end

def Disassembly_SelectionSet(start, end):
    return x64dbg.Disassembly_SelectionSet(start, end)

def Disassembly_SelectionGetStart():
    return x64dbg.Disassembly_SelectionGetStart()

def Disassembly_SelectionGetEnd():
    return x64dbg.Disassembly_SelectionGetEnd()


# Script::Gui::Dump
def Dump_SelectionGet():
    result, start, end = x64dbg.Dump_SelectionGet()
    if result:
        return start, end

def Dump_SelectionSet(start, end):
    return x64dbg.Dump_SelectionSet(start, end)

def Dump_SelectionGetStart():
    return x64dbg.Dump_SelectionGetStart()

def Dump_SelectionGetEnd():
    return x64dbg.Dump_SelectionGetEnd()


# Script::Gui::Stack
def Stack_SelectionGet():
    result, start, end = x64dbg.Stack_SelectionGet()
    if result:
        return start, end

def Stack_SelectionSet(start, end):
    return x64dbg.Stack_SelectionSet(start, end)

def Stack_SelectionGetStart():
    return x64dbg.Stack_SelectionGetStart()

def Stack_SelectionGetEnd():
    return x64dbg.Stack_SelectionGetEnd()



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/label.py
================================================
import ctypes
from .. import x64dbg


MAX_LABEL_SIZE = 256


def Set(addr, text, manual = False):
    return x64dbg.Label_Set(addr, text, manual)

def SetInfo(info):
    return x64dbg.Label_Set(info)

def FromString(label):
    res, addr = x64dbg.FromString(label)
    if res:
        return addr

def Get(addr):
    text = ctypes.create_string_buffer(MAX_LABEL_SIZE)
    res =  x64dbg.Label_Get(addr, text)
    if res:
        return text.value

def GetInfo(addr):
    info = x64dbg.LabelInfo()
    res = x64dbg.Label_GetInfo(addr, info)
    if res:
        return info

def Delete(addr):
    return x64dbg.Label_Delete(addr)

def DeleteRange(start, end):
    return x64dbg.Label_DeleteRange(start, end)

def Clear():
    x64dbg.Label_Clear()

def GetList():
    l = x64dbg.ListInfo()
    res = x64dbg.Label_GetList(l)
    if res:
        return x64dbg.GetLabelInfoList(l)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/memory.py
================================================
from x64dbgpy.utils import is_64bit
from .. import x64dbg


def Read(addr, size):
    read_bytes = bytearray(size)
    result, read_size = x64dbg.Memory_Read(addr, read_bytes, size)
    return bytes(read_bytes[:read_size])

def Write(addr, data):
    result, write_size = x64dbg.Memory_Write(addr, data, len(data))
    return result

def IsValidPtr(addr):
    return x64dbg.IsValidPtr(addr)

def RemoteAlloc(size, addr=0):
    return x64dbg.RemoteAlloc(addr, size)

def RemoteFree(addr):
    return x64dbg.RemoteFree(addr)

def GetProtect(addr, reserved=False, cache=True):
    return x64dbg.GetProtect(addr, reserved, cache)

def GetBase(addr, reserved=False, cache=True):
    return x64dbg.GetBase(addr, reserved, cache)

def GetSize(addr, reserved=False, cache=True):
    return x64dbg.GetSize(addr, reserved, cache)

def ReadByte(addr):
    return x64dbg.ReadByte(addr)

def WriteByte(addr, data):
    return x64dbg.WriteByte(addr, data)

def ReadWord(addr):
    return x64dbg.ReadWord(addr)

def WriteWord(addr, data):
    return x64dbg.WriteWord(addr, data)

def ReadDword(addr):
    return x64dbg.ReadDword(addr)

def WriteDword(addr, data):
    return x64dbg.WriteDword(addr, data)

if is_64bit():
    def ReadQword(addr):
        return x64dbg.ReadQword(addr)

    def WriteQword(addr, data):
        return x64dbg.WriteQword(addr, data)

def ReadPtr(addr):
    return x64dbg.ReadPtr(addr)

def WritePtr(addr, data):
    return x64dbg.WritePtr(addr, data)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/misc.py
================================================
from .. import x64dbg


def ParseExpression(expression):
    res, value = x64dbg.ParseExpression(expression)
    if res:
        return value

def RemoteGetProcAddress(module, api):
    return x64dbg.RemoteGetProcAddress(module, api)

def ResolveLabel(label):
    return x64dbg.ResolveLabel(label)

def Alloc(size):
    return x64dbg.Alloc(size)

def Free(ptr):
    return x64dbg.Free(ptr)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/module.py
================================================
import ctypes
from .. import x64dbg


MAX_MODULE_SIZE = 256
MAX_PATH = 260


def InfoFromAddr(addr):
    info = x64dbg.ModuleInfo()
    res = x64dbg.InfoFromAddr(addr, info)
    if res:
        return info

def InfoFromName(name):
    info = x64dbg.ModuleInfo()
    result = x64dbg.InfoFromName(name, info)
    if result:
        return info

def BaseFromAddr(addr):
    return x64dbg.BaseFromAddr(addr)

def BaseFromName(name):
    return x64dbg.BaseFromName(name)

def SizeFromAddr(addr):
    return x64dbg.SizeFromAddr(addr)

def SizeFromName(name):
    return x64dbg.SizeFromName(name)

def NameFromAddr(addr):
    name = ctypes.create_string_buffer(MAX_MODULE_SIZE)
    result = x64dbg.NameFromAddr(addr, name)
    if result:
        return name.value

def PathFromAddr(addr):
    path = ctypes.create_string_buffer(MAX_PATH)
    result = x64dbg.PathFromAddr(addr, path)
    if result:
        return path.value

def PathFromName(name):
    path = ctypes.create_string_buffer(MAX_PATH)
    result = x64dbg.PathFromName(name, path)
    if result:
        return path.value

def EntryFromAddr(addr):
    return x64dbg.EntryFromAddr(addr)

def EntryFromName(name):
    return x64dbg.EntryFromName(name)

def SectionCountFromAddr(addr):
    return x64dbg.SectionCountFromAddr(addr)

def SectionCountFromName(name):
    return x64dbg.SectionCountFromName(name)

def SectionFromAddr(addr, number):
    section = x64dbg.ModuleSectionInfo()
    result = x64dbg.SectionFromAddr(addr, number, section)
    if result:
        return section

def SectionFromName(name, number):
    section = x64dbg.ModuleSectionInfo()
    result = x64dbg.SectionFromName(name, number, section)
    if result:
        return section

def SectionListFromAddr(addr):
    l = x64dbg.ListInfo()
    res = x64dbg.SectionListFromAddr(addr, l)
    if res:
        return x64dbg.GetModuleSectionInfoList(l)

def SectionListFromName(name):
    l = x64dbg.ListInfo()
    res = x64dbg.SectionListFromName(addr, l)
    if res:
        return x64dbg.GetModuleSectionInfoList(l)

def GetMainModuleInfo():
    info = x64dbg.ModuleInfo()
    result = x64dbg.GetMainModuleInfo(info)
    if result:
        return info

def GetMainModuleBase():
    return x64dbg.GetMainModuleBase()

def GetMainModuleSize():
    return x64dbg.GetMainModuleSize()

def GetMainModuleEntry():
    return x64dbg.GetMainModuleEntry()

def GetMainModuleSectionCount():
    return x64dbg.GetMainModuleSectionCount()

def GetMainModuleName():
    name = ctypes.create_string_buffer(MAX_MODULE_SIZE)
    result = x64dbg.GetMainModuleName(name)
    if result:
        return name.value

def GetMainModulePath():
    path = ctypes.create_string_buffer(MAX_PATH)
    result = x64dbg.GetMainModulePath(path)
    if result:
        return path.value

def GetMainModuleSectionList():
    l = x64dbg.ListInfo()
    res = x64dbg.GetMainModuleSectionList(l)
    if res:
        return x64dbg.GetModuleSectionInfoList(l)

def GetList():
    l = x64dbg.ListInfo()
    res = x64dbg.GetList(l)
    if res:
        return x64dbg.GetModuleInfoList(l)


================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/pattern.py
================================================
from .. import x64dbg


def Find(data, pattern):
    return x64dbg.Find(data, pattern)

def FindMem(start, size, pattern):
    return x64dbg.FindMem(start, size, pattern)

def PatternWrite(data, pattern):
    x64dbg.Pattern_Write(data, pattern)

def PatternWriteMem(start, size, pattern):
    x64dbg.Pattern_WriteMem(start, size, pattern)

def SearchAndReplace(data, searchpattern, replacepattern):
    return x64dbg.SearchAndReplace(data, searchpattern, replacepattern)

def SearchAndReplaceMem(start, size, searchpattern, replacepattern):
    return x64dbg.SearchAndReplaceMem(start, size, searchpattern, replacepattern)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/register.py
================================================
from x64dbgpy.utils import is_64bit
from .. import x64dbg


def Size():
    return x64dbg.Size()


# x86 Registers
def GetEAX():
    return x64dbg.GetEAX()

def SetEAX(value):
    return x64dbg.SetEAX(value)

def GetAX():
    return x64dbg.GetAX()

def SetAX(value):
    return x64dbg.SetAX(value)

def GetAH():
    return x64dbg.GetAH()

def SetAH(value):
    return x64dbg.SetAH(value)

def GetAL():
    return x64dbg.GetAL()

def SetAL(value):
    return x64dbg.SetAL(value)

def GetEBX():
    return x64dbg.GetEBX()

def SetEBX(value):
    return x64dbg.SetEBX(value)

def GetBX():
    return x64dbg.GetBX()

def SetBX(value):
    return x64dbg.SetBX(value)

def GetBH():
    return x64dbg.GetBH()

def SetBH(value):
    return x64dbg.SetBH(value)

def GetBL():
    return x64dbg.GetBL()

def SetBL(value):
    return x64dbg.SetBL(value)

def GetECX():
    return x64dbg.GetECX()

def SetECX(value):
    return x64dbg.SetECX(value)

def GetCX():
    return x64dbg.GetCX()

def SetCX(value):
    return x64dbg.SetCX(value)

def GetCH():
    return x64dbg.GetCH()

def SetCH(value):
    return x64dbg.SetCH(value)

def GetCL():
    return x64dbg.GetCL()

def SetCL(value):
    return x64dbg.SetCL(value)

def GetEDX():
    return x64dbg.GetEDX()

def SetEDX(value):
    return x64dbg.SetEDX(value)

def GetDX():
    return x64dbg.GetDX()

def SetDX(value):
    return x64dbg.SetDX(value)

def GetDH():
    return x64dbg.GetDH()

def SetDH(value):
    return x64dbg.SetDH(value)

def GetDL():
    return x64dbg.GetDL()

def SetDL(value):
    return x64dbg.SetDL(value)

def GetEDI():
    return x64dbg.GetEDI()

def SetEDI(value):
    return x64dbg.SetEDI(value)

def GetDI():
    return x64dbg.GetDI()

def SetDI(value):
    return x64dbg.SetDI(value)

def GetESI():
    return x64dbg.GetESI()

def SetESI(value):
    return x64dbg.SetESI(value)

def GetSI():
    return x64dbg.GetSI()

def SetSI(value):
    return x64dbg.SetSI(value)

def GetEBP():
    return x64dbg.GetEBP()

def SetEBP(value):
    return x64dbg.SetEBP(value)

def GetBP():
    return x64dbg.GetBP()

def SetBP(value):
    return x64dbg.SetBP(value)

def GetESP():
    return x64dbg.GetESP()

def SetESP(value):
    return x64dbg.SetESP(value)

def GetSP():
    return x64dbg.GetSP()

def SetSP(value):
    return x64dbg.SetSP(value)

def GetEIP():
    return x64dbg.GetEIP()

def SetEIP(value):
    return x64dbg.SetEIP(value)


# x86 Debug Registers
def GetDR0():
    return x64dbg.GetDR0()

def SetDR0(value):
    return x64dbg.SetDR0(value)

def GetDR1():
    return x64dbg.GetDR1()

def SetDR1(value):
    return x64dbg.SetDR1(value)

def GetDR2():
    return x64dbg.GetDR2()

def SetDR2(value):
    return x64dbg.SetDR2(value)

def GetDR3():
    return x64dbg.GetDR3()

def SetDR3(value):
    return x64dbg.SetDR3(value)

def GetDR6():
    return x64dbg.GetDR6()

def SetDR6(value):
    return x64dbg.SetDR6(value)

def GetDR7():
    return x64dbg.GetDR7()

def SetDR7(value):
    return x64dbg.SetDR7(value)


# x64 Registers
if is_64bit():
    def GetRAX():
        return x64dbg.GetRAX()

    def SetRAX(value):
        return x64dbg.SetRAX(value)

    def GetRBX():
        return x64dbg.GetRBX()

    def SetRBX(value):
        return x64dbg.SetRBX(value)

    def GetRCX():
        return x64dbg.GetRCX()

    def SetRCX(value):
        return x64dbg.SetRCX(value)

    def GetRDX():
        return x64dbg.GetRDX()

    def SetRDX(value):
        return x64dbg.SetRDX(value)

    def GetRSI():
        return x64dbg.GetRSI()

    def SetRSI(value):
        return x64dbg.SetRSI(value)

    def GetSIL():
        return x64dbg.GetSIL()

    def SetSIL(value):
        return x64dbg.SetSIL(value)

    def GetRDI():
        return x64dbg.GetRDI()

    def SetRDI(value):
        return x64dbg.SetRDI(value)

    def GetDIL():
        return x64dbg.GetDIL()

    def SetDIL(value):
        return x64dbg.SetDIL(value)

    def GetRBP():
        return x64dbg.GetRBP()

    def SetRBP(value):
        return x64dbg.SetRBP(value)

    def GetBPL():
        return x64dbg.GetBPL()

    def SetBPL(value):
        return x64dbg.SetBPL(value)

    def GetRSP():
        return x64dbg.GetRSP()

    def SetRSP(value):
        return x64dbg.SetRSP(value)

    def GetSPL():
        return x64dbg.GetSPL()

    def SetSPL(value):
        return x64dbg.SetSPL(value)

    def GetRIP():
        return x64dbg.GetRIP()

    def SetRIP(value):
        return x64dbg.SetRIP(value)

    def GetR8():
        return x64dbg.GetR8()

    def SetR8(value):
        return x64dbg.SetR8(value)

    def GetR8D():
        return x64dbg.GetR8D()

    def SetR8D(value):
        return x64dbg.SetR8D(value)

    def GetR8W():
        return x64dbg.GetR8W()

    def SetR8W(value):
        return x64dbg.SetR8W(value)

    def GetR8B():
        return x64dbg.GetR8B()

    def SetR8B(value):
        return x64dbg.SetR8B(value)

    def GetR9():
        return x64dbg.GetR9()

    def SetR9(value):
        return x64dbg.SetR9(value)

    def GetR9D():
        return x64dbg.GetR9D()

    def SetR9D(value):
        return x64dbg.SetR9D(value)

    def GetR9W():
        return x64dbg.GetR9W()

    def SetR9W(value):
        return x64dbg.SetR9W(value)

    def GetR9B():
        return x64dbg.GetR9B()

    def SetR9B(value):
        return x64dbg.SetR9B(value)

    def GetR10():
        return x64dbg.GetR10()

    def SetR10(value):
        return x64dbg.SetR10(value)

    def GetR10D():
        return x64dbg.GetR10D()

    def SetR10D(value):
        return x64dbg.SetR10D(value)

    def GetR10W():
        return x64dbg.GetR10W()

    def SetR10W(value):
        return x64dbg.SetR10W(value)

    def GetR10B():
        return x64dbg.GetR10B()

    def SetR10B(value):
        return x64dbg.SetR10B(value)

    def GetR11():
        return x64dbg.GetR11()

    def SetR11(value):
        return x64dbg.SetR11(value)

    def GetR11D():
        return x64dbg.GetR11D()

    def SetR11D(value):
        return x64dbg.SetR11D(value)

    def GetR11W():
        return x64dbg.GetR11W()

    def SetR11W(value):
        return x64dbg.SetR11W(value)

    def GetR11B():
        return x64dbg.GetR11B()

    def SetR11B(value):
        return x64dbg.SetR11B(value)

    def GetR12():
        return x64dbg.GetR12()

    def SetR12(value):
        return x64dbg.SetR12(value)

    def GetR12D():
        return x64dbg.GetR12D()

    def SetR12D(value):
        return x64dbg.SetR12D(value)

    def GetR12W():
        return x64dbg.GetR12W()

    def SetR12W(value):
        return x64dbg.SetR12W(value)

    def GetR12B():
        return x64dbg.GetR12B()

    def SetR12B(value):
        return x64dbg.SetR12B(value)

    def GetR13():
        return x64dbg.GetR13()

    def SetR13(value):
        return x64dbg.SetR13(value)

    def GetR13D():
        return x64dbg.GetR13D()

    def SetR13D(value):
        return x64dbg.SetR13D(value)

    def GetR13W():
        return x64dbg.GetR13W()

    def SetR13W(value):
        return x64dbg.SetR13W(value)

    def GetR13B():
        return x64dbg.GetR13B()

    def SetR13B(value):
        return x64dbg.SetR13B(value)

    def GetR14():
        return x64dbg.GetR14()

    def SetR14(value):
        return x64dbg.SetR14(value)

    def GetR14D():
        return x64dbg.GetR14D()

    def SetR14D(value):
        return x64dbg.SetR14D(value)

    def GetR14W():
        return x64dbg.GetR14W()

    def SetR14W(value):
        return x64dbg.SetR14W(value)

    def GetR14B():
        return x64dbg.GetR14B()

    def SetR14B(value):
        return x64dbg.SetR14B(value)

    def GetR15():
        return x64dbg.GetR15()

    def SetR15(value):
        return x64dbg.SetR15(value)

    def GetR15D():
        return x64dbg.GetR15D()

    def SetR15D(value):
        return x64dbg.SetR15D(value)

    def GetR15W():
        return x64dbg.GetR15W()

    def SetR15W(value):
        return x64dbg.SetR15W(value)

    def GetR15B():
        return x64dbg.GetR15B()

    def SetR15B(value):
        return x64dbg.SetR15B(value)


# Generic Registers
def GetCIP():
    return x64dbg.GetCIP()

def SetCIP(value):
    return x64dbg.SetCIP(value)

def GetCSP():
    return x64dbg.GetCSP()

def SetCSP(value):
    return x64dbg.SetCSP(value)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/stack.py
================================================
from .. import x64dbg


def Pop():
    return x64dbg.Pop()

def Push(value):
    # returns the previous top, equal to Peek(1)
    return x64dbg.Push(value)

def Peek(offset=0):
    # offset is in multiples of Register::Size(), for easy x32/x64 portability
    return x64dbg.Peek(offset)



================================================
File: swig/x64dbgpy/pluginsdk/_scriptapi/symbol.py
================================================
import ctypes
from .. import x64dbg


class SymbolType:
    Function = x64dbg.Function
    Import = x64dbg.Import
    Export = x64dbg.Export


def GetList():
    l = x64dbg.ListInfo()
    res = x64dbg.Symbol_GetList(l)
    if res:
        return x64dbg.GetSymbolInfoList(l)



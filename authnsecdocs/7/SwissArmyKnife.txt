Directory structure:
└── nukem9-swissarmyknife/
    ├── README.md
    ├── SwissArmyKnife.sln
    ├── release.bat
    ├── .editorconfig
    └── src/
        ├── SwissArmyKnife/
        │   ├── Commands.cpp
        │   ├── Commands.h
        │   ├── Plugin.cpp
        │   ├── Plugin.h
        │   ├── SwissArmyKnife.vcxproj
        │   ├── SwissArmyKnife.vcxproj.filters
        │   ├── Util.cpp
        │   ├── Util.h
        │   ├── stdafx.h
        │   ├── Release/
        │   │   └── sigmake.res
        │   └── x64/
        │       └── Release/
        │           └── sigmake.res
        ├── aes-finder/
        │   ├── aes-finder-test.h
        │   ├── aes-finder.cpp
        │   └── aes-finder.h
        ├── findcrypt/
        │   ├── consts.cpp
        │   ├── findcrypt.cpp
        │   ├── findcrypt.h
        │   └── sparse.cpp
        ├── idaldr/
        │   ├── Ldr.cpp
        │   ├── Ldr.h
        │   ├── sig.sig
        │   ├── stdafx.cpp
        │   ├── stdafx.h
        │   ├── IDA/
        │   │   ├── Crc16.cpp
        │   │   ├── Crc16.h
        │   │   ├── Diff.h
        │   │   ├── DiffReader.cpp
        │   │   ├── DiffWriter.cpp
        │   │   ├── Sig.cpp
        │   │   └── Sig.h
        │   └── Map/
        │       ├── Map.h
        │       ├── MapReader.cpp
        │       └── MapWriter.cpp
        ├── peid/
        │   ├── peid.cpp
        │   └── peid.h
        ├── pluginsdk/
        │   ├── _dbgfunctions.h
        │   ├── _plugin_types.h
        │   ├── _plugins.h
        │   ├── _scriptapi.h
        │   ├── _scriptapi_argument.h
        │   ├── _scriptapi_assembler.h
        │   ├── _scriptapi_bookmark.h
        │   ├── _scriptapi_comment.h
        │   ├── _scriptapi_debug.h
        │   ├── _scriptapi_flag.h
        │   ├── _scriptapi_function.h
        │   ├── _scriptapi_gui.h
        │   ├── _scriptapi_label.h
        │   ├── _scriptapi_memory.h
        │   ├── _scriptapi_misc.h
        │   ├── _scriptapi_module.h
        │   ├── _scriptapi_pattern.h
        │   ├── _scriptapi_register.h
        │   ├── _scriptapi_stack.h
        │   ├── _scriptapi_symbol.h
        │   ├── bridgegraph.h
        │   ├── bridgelist.h
        │   ├── bridgemain.h
        │   ├── DeviceNameResolver/
        │   │   └── DeviceNameResolver.h
        │   ├── TitanEngine/
        │   │   └── TitanEngine.h
        │   ├── XEDParse/
        │   │   └── XEDParse.h
        │   ├── dbghelp/
        │   │   └── dbghelp.h
        │   ├── jansson/
        │   │   ├── jansson.h
        │   │   ├── jansson_config.h
        │   │   └── jansson_x64dbg.h
        │   └── lz4/
        │       ├── lz4.h
        │       ├── lz4file.h
        │       └── lz4hc.h
        ├── sigmake/
        │   ├── Descriptor.cpp
        │   ├── Descriptor.h
        │   ├── SigMake.cpp
        │   ├── SigMake.h
        │   ├── resource.h
        │   ├── sigmake.rc
        │   ├── stdafx.cpp
        │   ├── stdafx.h
        │   ├── Dialog/
        │   │   ├── BatchSigDialog.cpp
        │   │   ├── Settings.cpp
        │   │   ├── Settings.h
        │   │   ├── SettingsDialog.cpp
        │   │   ├── SettingsDialog.h
        │   │   ├── SigMakeDialog.cpp
        │   │   └── SigMakeDialog.h
        │   └── distorm/
        │       ├── config.h
        │       ├── decoder.c
        │       ├── decoder.h
        │       ├── distorm.c
        │       ├── distorm.h
        │       ├── instructions.c
        │       ├── instructions.h
        │       ├── insts.c
        │       ├── insts.h
        │       ├── mnemonics.c
        │       ├── mnemonics.h
        │       ├── operands.c
        │       ├── operands.h
        │       ├── prefix.c
        │       ├── prefix.h
        │       ├── textdefs.c
        │       ├── textdefs.h
        │       ├── wstring.c
        │       ├── wstring.h
        │       └── x86defs.h
        └── zlib/
            ├── LICENSE
            ├── adler32.c
            ├── compress.c
            ├── crc32.c
            ├── crc32.h
            ├── deflate.c
            ├── deflate.h
            ├── gzclose.c
            ├── gzguts.h
            ├── gzlib.c
            ├── gzread.c
            ├── gzwrite.c
            ├── infback.c
            ├── inffast.c
            ├── inffast.h
            ├── inffixed.h
            ├── inflate.c
            ├── inflate.h
            ├── inftrees.c
            ├── inftrees.h
            ├── trees.c
            ├── trees.h
            ├── uncompr.c
            ├── zconf.h
            ├── zlib.h
            ├── zutil.c
            └── zutil.h

================================================
File: README.md
================================================
# SwissArmyKnife
Various utilities for extending functionality in [x64dbg](https://github.com/x64dbg/x64dbg).

### IDA Imports
------
* Allows loading and exporting of binary patches (*.dif)
* Allows loading of signature files (*.sig) up to IDA version 6.1

### Linker MAP Symbols
------
* Allows for loading linker map files (*.map) produced by many compilers. Some information is located [here](http://www.codeproject.com/Articles/3472/Finding-crash-information-using-the-MAP-file). At the moment, exporting such files is not possible with the plugin API.

### PEiD
------
* Parses and loads [PEiD](https://www.aldeid.com/wiki/PEiD) signature databases.

### Code Signatures
------
Four different signature styles are supported:
    
1. Code style
    `\x33\xC0\x33\xF6\x48\x89\x44\x24\x42\x89\x44\x24\x4A\x66\x89\x44\x24\x4E\x00\x00\x00\x00\x00\x00\x00\x48\x8B\xF9\xC7\x44\x00\x00\x00\x00\x00\x00\x48\x89\x44\x24\x60\x48`
    `xxxxxxxxxxxxxxxxxx???????xxxxx??????xxxxxxxxxxx??????x????xxxxxxxxxxx??????xxxxxxxx`
2. IDA Style
    `33 C0 33 F6 48 89 44 24 42 89 44 24 4A 66 89 44 24 4E ? ? ? ? ? ? ? 48 8B F9 C7 44 ? ? ? ? ? ? 48 89 44 24 60 48`
3. PEiD Style
    `33 C0 33 F6 48 89 44 24 42 89 44 24 4A 66 89 44 24 4E ?? ?? ?? ?? ?? ?? ?? 48 8B F9 C7 44 ?? ?? ?? ?? ?? ?? 48 89 44 24 60 48`

        
        
### Cipher Detection
------
##### Findcrypt v2 with AES-NI
* Support for finding [AES-NI instructions](https://en.wikipedia.org/wiki/AES_instruction_set#New_instructions).
* Support for finding constants from: Blowfish, Camellia, CAST, CAST256, CRC32, DES, GOST, HAVAL, MARS, MD2, MD5, PKCS_MD2, PKCS_MD5, PKCS_RIPEMD160, PKCS_SHA256, PKCS_SHA384, PKCS_SHA512, PKCS_Tiger, RawDES, RC2, Rijndael, SAFER, SHA256, SHA512, SHARK, SKIPJACK, Square/SHARK, Square, Tiger,Twofish, WAKE, Whirlpool, zlib, SHA-1, RC5_RC6, MD5, MD4, HAVAL

##### AES-Finder
* Searches for 128, 192 and 256-bit AES cipher keys



================================================
File: SwissArmyKnife.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.23107.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwissArmyKnife", "src\SwissArmyKnife\SwissArmyKnife.vcxproj", "{9462CC2A-C442-4BC2-B70A-8514AD0164D2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Debug|x64.ActiveCfg = Debug|x64
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Debug|x64.Build.0 = Debug|x64
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Debug|x86.ActiveCfg = Debug|Win32
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Debug|x86.Build.0 = Debug|Win32
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Release|x64.ActiveCfg = Release|x64
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Release|x64.Build.0 = Release|x64
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Release|x86.ActiveCfg = Release|Win32
		{9462CC2A-C442-4BC2-B70A-8514AD0164D2}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: release.bat
================================================
@echo off
set RELEASEDIR=.\release
rmdir /S /Q %RELEASEDIR%
mkdir %RELEASEDIR%\x32\plugins
mkdir %RELEASEDIR%\x64\plugins

copy bin\x32\SwissArmyKnife.dp32 %RELEASEDIR%\x32\plugins\
copy bin\x64\SwissArmyKnife.dp64 %RELEASEDIR%\x64\plugins\

exit 0


================================================
File: .editorconfig
================================================
; Top-most EditorConfig file
root = true

; Windows-style newlines
[*]
end_of_line = CRLF

; Tab indentation
[*.{cpp,h}]
indent_style = tab
tab_width = 4


================================================
File: src/SwissArmyKnife/Commands.cpp
================================================
#include "stdafx.h"

void Cmd_RegisterCommands()
{
	//
	// FINDCRYPT
	//
	_plugin_registercommand(g_PluginHandle, "findcrypt", [](int argc, char **argv)
	{
		// Exclude the command itself
		argc--;

		if (argc == 0)
		{
			// Scan entire memory range
			FindcryptScanAll();
			return true;
		}
		else if (argc == 2)
		{
			// Scan a specific memory range
			duint rangeStart	= DbgValFromString(argv[1]);
			duint rangeEnd		= DbgValFromString(argv[2]);

			FindcryptScanRange(rangeStart, rangeEnd);
			return true;
		}

		// Fail if the wrong number of arguments was used
		dprintf("Command requires 0 or 2 arguments only\n");
		return false;
	}, true);

	_plugin_registercommand(g_PluginHandle, "findcrypt_mod", [](int argc, char **argv)
	{
		// Scan the current module only
		FindcryptScanModule();
		return true;
	}, true);

	//
	// AES-FINDER
	//
	_plugin_registercommand(g_PluginHandle, "aesfinder", [](int argc, char **argv)
	{
		// Exclude the command itself
		argc--;

		if (argc == 0)
		{
			// Scan entire memory range
			AESFinderScanAll();
			return true;
		}
		else if (argc == 2)
		{
			// Scan a specific memory range
			duint rangeStart = DbgValFromString(argv[1]);
			duint rangeEnd = DbgValFromString(argv[2]);

			AESFinderScanRange(rangeStart, rangeEnd);
			return true;
		}

		// Fail if the wrong number of arguments was used
		dprintf("Command requires 0 or 2 arguments only\n");
		return false;
	}, true);

	_plugin_registercommand(g_PluginHandle, "aesfinder_mod", [](int argc, char **argv)
	{
		// Scan the current module only
		AESFinderScanModule();
		return true;
	}, true);
}


================================================
File: src/SwissArmyKnife/Commands.h
================================================
#pragma once

void Cmd_RegisterCommands();


================================================
File: src/SwissArmyKnife/Plugin.cpp
================================================
#include "stdafx.h"

int g_MenuHandle;
int g_PluginHandle;

HMODULE g_LocalDllHandle;

void MenuEntryCallback(CBTYPE Type, PLUG_CB_MENUENTRY *Info)
{
	switch (Info->hEntry)
	{
	case PLUGIN_MENU_LOADSIG:
		OpenSelectionDialog("Open an IDA signature file", "Signatures (*.sig)\0*.sig\0\0", false, ApplySignatureSymbols);
		break;

	case PLUGIN_MENU_LOADDIF:
		OpenSelectionDialog("Open an IDA DIF file", "Diff files (*.dif)\0*.dif\0\0", false, ApplyDiffSymbols);
		break;

	case PLUGIN_MENU_LOADMAP:
		OpenSelectionDialog("Open a linker map file", "Map files (*.map)\0*.map\0\0", false, ApplyMapSymbols);
		break;

	case PLUGIN_MENU_LOADPEID:
		OpenSelectionDialog("Open a PEiD database", "Any file (*.*)\0*.*\0\0", false, ApplyPEiDSymbols);
		break;

	case PLUGIN_MENU_EXPORTDIF:
		OpenSelectionDialog("Save a DIF file", "Diff files (*.dif)\0*.dif\0\0", true, ExportDiffSymbols);
		break;

	case PLUGIN_MENU_EXPORTMAP:
		OpenSelectionDialog("Save a MAP file", "Map files (*.map)\0*.map\0\0", true, ExportMapSymbols);
		break;

	case PLUGIN_MENU_FINDCRYPTO:
		FindcryptScanModule();
		break;

	case PLUGIN_MENU_AESFINDER:
		AESFinderScanModule();
		break;

	case PLUGIN_MENU_MAKESIG:
		OpenSigMakeDialog();
		break;

	case PLUGIN_MENU_BATCHSIG:
		OpenBatchSigDialog();
		break;

	case PLUGIN_MENU_SETTINGS:
		OpenSettingsDialog();
		break;

	case PLUGIN_MENU_ABOUT:
		MessageBoxA(GuiGetWindowHandle(),
			"Plugin created by Nukem.\n\n"
			"Source code at:\n"
			"https://github.com/Nukem9/SwissArmyKnife"
			"\n\nFindcrypt2-with-MMX:\n"
			"https://github.com/vlad902/findcrypt2-with-mmx"
			"\n\nAES-Finder:\n"
			"https://github.com/mmozeiko/aes-finder"
			"\n\nZLIB:\n"
			"http://www.zlib.net/"
			, "About", 0);
		break;
	}

	//
	// Update GUI
	//
	GuiUpdateAllViews();
}

DLL_EXPORT bool pluginit(PLUG_INITSTRUCT *InitStruct)
{
	InitStruct->pluginVersion = PLUGIN_VERSION;
	InitStruct->sdkVersion = PLUG_SDKVERSION;
	g_PluginHandle = InitStruct->pluginHandle;
	strcpy_s(InitStruct->pluginName, PLUGIN_NAME);

	// Add any of the callbacks
	_plugin_registercallback(g_PluginHandle, CB_MENUENTRY, (CBPLUGIN)MenuEntryCallback);

	// Update all check box settings
	Settings::InitIni();
	Settings::Load();

	// Commands
	Cmd_RegisterCommands();

	// Initialization messages
	Plugin_FindcryptLogo();
	Plugin_AESFinderLogo();

	return true;
}

DLL_EXPORT bool plugstop()
{
	// Close dialogs
	DestroySigMakeDialog();
	DestroySettingsDialog();

	// Clear the menu
	_plugin_menuclear(g_MenuHandle);

	// Remove callbacks
	_plugin_unregistercallback(g_PluginHandle, CB_MENUENTRY);
	return true;
}

DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT *SetupStruct)
{
	g_MenuHandle = SetupStruct->hMenu;

	// Initialize the menu
	int loadMenu = _plugin_menuadd(g_MenuHandle, "Load");
	_plugin_menuaddentry(loadMenu, PLUGIN_MENU_LOADSIG, "&SIG file");
	_plugin_menuaddentry(loadMenu, PLUGIN_MENU_LOADDIF, "&DIF file");
	_plugin_menuaddentry(loadMenu, PLUGIN_MENU_LOADMAP, "&MAP file");
	_plugin_menuaddentry(loadMenu, PLUGIN_MENU_LOADPEID, "&PEiD signatures");

	int exportMenu = _plugin_menuadd(g_MenuHandle, "Export");
	_plugin_menuaddentry(exportMenu, PLUGIN_MENU_EXPORTDIF, "&DIF file");
	_plugin_menuaddentry(exportMenu, PLUGIN_MENU_EXPORTMAP, "&MAP file");
	_plugin_menuaddseparator(g_MenuHandle);

	// Crypto
	_plugin_menuaddentry(g_MenuHandle, PLUGIN_MENU_FINDCRYPTO, "&Findcrypt2 with AES-NI");
	_plugin_menuaddentry(g_MenuHandle, PLUGIN_MENU_AESFINDER, "&AES-Finder");
	_plugin_menuaddseparator(g_MenuHandle);

	// Signature
	_plugin_menuaddentry(g_MenuHandle, PLUGIN_MENU_MAKESIG, "&Create Signature");
	_plugin_menuaddentry(g_MenuHandle, PLUGIN_MENU_BATCHSIG, "&Batch Create Signatures");
	_plugin_menuaddseparator(g_MenuHandle);

	// Misc
	_plugin_menuaddentry(g_MenuHandle, PLUGIN_MENU_SETTINGS, "&Options");
	_plugin_menuaddentry(g_MenuHandle, PLUGIN_MENU_ABOUT, "&About");
}

BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_LocalDllHandle = hinstDLL;

	return TRUE;
}


================================================
File: src/SwissArmyKnife/Plugin.h
================================================
#pragma once

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif // DLL_EXPORT

extern int g_MenuHandle;
extern int g_PluginHandle;

extern HMODULE g_LocalDllHandle;

enum
{
	PLUGIN_MENU_LOADSIG,
	PLUGIN_MENU_LOADDIF,
	PLUGIN_MENU_LOADMAP,
	PLUGIN_MENU_LOADPEID,
	PLUGIN_MENU_EXPORTDIF,
	PLUGIN_MENU_EXPORTMAP,

	PLUGIN_MENU_FINDCRYPTO,
	PLUGIN_MENU_AESFINDER,

	PLUGIN_MENU_MAKESIG,
	PLUGIN_MENU_BATCHSIG,
	PLUGIN_MENU_CONVERTSIG,
	PLUGIN_MENU_SETTINGS,

	PLUGIN_MENU_ABOUT,
};

#ifdef __cplusplus
extern "C"
{
#endif

	DLL_EXPORT bool pluginit(PLUG_INITSTRUCT *InitStruct);
	DLL_EXPORT bool plugstop();
	DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT *SetupStruct);

#ifdef __cplusplus
}
#endif


================================================
File: src/SwissArmyKnife/SwissArmyKnife.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9462CC2A-C442-4BC2-B70A-8514AD0164D2}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>SwissArmyKnife</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
    <OutDir>$(SolutionDir)bin\x32\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
    <OutDir>$(SolutionDir)bin\x32\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;SWISSARMYKNIFE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;SWISSARMYKNIFE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;SWISSARMYKNIFE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;SWISSARMYKNIFE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\aes-finder\aes-finder.cpp" />
    <ClCompile Include="..\findcrypt\consts.cpp" />
    <ClCompile Include="..\findcrypt\findcrypt.cpp" />
    <ClCompile Include="..\findcrypt\sparse.cpp" />
    <ClCompile Include="..\idaldr\IDA\Crc16.cpp" />
    <ClCompile Include="..\idaldr\IDA\DiffReader.cpp" />
    <ClCompile Include="..\idaldr\IDA\DiffWriter.cpp" />
    <ClCompile Include="..\idaldr\IDA\Sig.cpp" />
    <ClCompile Include="..\idaldr\Ldr.cpp" />
    <ClCompile Include="..\idaldr\Map\MapReader.cpp" />
    <ClCompile Include="..\idaldr\Map\MapWriter.cpp" />
    <ClCompile Include="..\peid\peid.cpp" />
    <ClCompile Include="..\sigmake\Descriptor.cpp" />
    <ClCompile Include="..\sigmake\Dialog\BatchSigDialog.cpp" />
    <ClCompile Include="..\sigmake\Dialog\Settings.cpp" />
    <ClCompile Include="..\sigmake\Dialog\SettingsDialog.cpp" />
    <ClCompile Include="..\sigmake\Dialog\SigMakeDialog.cpp" />
    <ClCompile Include="..\sigmake\distorm\decoder.c" />
    <ClCompile Include="..\sigmake\distorm\distorm.c" />
    <ClCompile Include="..\sigmake\distorm\instructions.c" />
    <ClCompile Include="..\sigmake\distorm\insts.c" />
    <ClCompile Include="..\sigmake\distorm\mnemonics.c" />
    <ClCompile Include="..\sigmake\distorm\operands.c" />
    <ClCompile Include="..\sigmake\distorm\prefix.c" />
    <ClCompile Include="..\sigmake\distorm\textdefs.c" />
    <ClCompile Include="..\sigmake\distorm\wstring.c" />
    <ClCompile Include="..\sigmake\SigMake.cpp" />
    <ClCompile Include="..\zlib\adler32.c" />
    <ClCompile Include="..\zlib\compress.c" />
    <ClCompile Include="..\zlib\crc32.c" />
    <ClCompile Include="..\zlib\deflate.c" />
    <ClCompile Include="..\zlib\gzclose.c" />
    <ClCompile Include="..\zlib\gzlib.c" />
    <ClCompile Include="..\zlib\gzread.c" />
    <ClCompile Include="..\zlib\gzwrite.c" />
    <ClCompile Include="..\zlib\infback.c" />
    <ClCompile Include="..\zlib\inffast.c" />
    <ClCompile Include="..\zlib\inflate.c" />
    <ClCompile Include="..\zlib\inftrees.c" />
    <ClCompile Include="..\zlib\trees.c" />
    <ClCompile Include="..\zlib\uncompr.c" />
    <ClCompile Include="..\zlib\zutil.c" />
    <ClCompile Include="Commands.cpp" />
    <ClCompile Include="Plugin.cpp" />
    <ClCompile Include="Util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\aes-finder\aes-finder-test.h" />
    <ClInclude Include="..\aes-finder\aes-finder.h" />
    <ClInclude Include="..\findcrypt\findcrypt.h" />
    <ClInclude Include="..\idaldr\IDA\Crc16.h" />
    <ClInclude Include="..\idaldr\IDA\Diff.h" />
    <ClInclude Include="..\idaldr\IDA\Sig.h" />
    <ClInclude Include="..\idaldr\Ldr.h" />
    <ClInclude Include="..\idaldr\Map\Map.h" />
    <ClInclude Include="..\idaldr\stdafx.h" />
    <ClInclude Include="..\peid\peid.h" />
    <ClInclude Include="..\sigmake\Descriptor.h" />
    <ClInclude Include="..\sigmake\Dialog\Settings.h" />
    <ClInclude Include="..\sigmake\Dialog\SettingsDialog.h" />
    <ClInclude Include="..\sigmake\Dialog\SigMakeDialog.h" />
    <ClInclude Include="..\sigmake\distorm\config.h" />
    <ClInclude Include="..\sigmake\distorm\decoder.h" />
    <ClInclude Include="..\sigmake\distorm\distorm.h" />
    <ClInclude Include="..\sigmake\distorm\instructions.h" />
    <ClInclude Include="..\sigmake\distorm\insts.h" />
    <ClInclude Include="..\sigmake\distorm\mnemonics.h" />
    <ClInclude Include="..\sigmake\distorm\operands.h" />
    <ClInclude Include="..\sigmake\distorm\prefix.h" />
    <ClInclude Include="..\sigmake\distorm\textdefs.h" />
    <ClInclude Include="..\sigmake\distorm\wstring.h" />
    <ClInclude Include="..\sigmake\distorm\x86defs.h" />
    <ClInclude Include="..\sigmake\resource.h" />
    <ClInclude Include="..\sigmake\SigMake.h" />
    <ClInclude Include="..\sigmake\stdafx.h" />
    <ClInclude Include="..\zlib\crc32.h" />
    <ClInclude Include="..\zlib\deflate.h" />
    <ClInclude Include="..\zlib\gzguts.h" />
    <ClInclude Include="..\zlib\inffast.h" />
    <ClInclude Include="..\zlib\inffixed.h" />
    <ClInclude Include="..\zlib\inflate.h" />
    <ClInclude Include="..\zlib\inftrees.h" />
    <ClInclude Include="..\zlib\trees.h" />
    <ClInclude Include="..\zlib\zconf.h" />
    <ClInclude Include="..\zlib\zlib.h" />
    <ClInclude Include="..\zlib\zutil.h" />
    <ClInclude Include="Commands.h" />
    <ClInclude Include="Plugin.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="Util.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\sigmake\sigmake.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\zlib\LICENSE" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: src/SwissArmyKnife/SwissArmyKnife.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\idaldr">
      <UniqueIdentifier>{0e4232bd-0c05-4053-b64f-39246fd741bd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\sigmake">
      <UniqueIdentifier>{cfcb9d08-23fb-4f2d-91c3-ae2fda874a84}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\idaldr">
      <UniqueIdentifier>{b8224815-0b93-4791-a881-c0ef2ee5eb34}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\sigmake">
      <UniqueIdentifier>{2cacb0b7-b99f-4a2d-82e3-c4e52b9f8705}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\sigmake\distorm">
      <UniqueIdentifier>{5e1fb1f4-c148-46ec-a84e-38a18e4c8300}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\sigmake\distorm">
      <UniqueIdentifier>{ae947c99-f0d5-40d3-a132-7d66ac5906ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\peid">
      <UniqueIdentifier>{2af90c9e-13be-4ab3-b61c-93b031f07bd9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\peid">
      <UniqueIdentifier>{edfe7dab-8db6-43f6-9a44-e0018c814b41}</UniqueIdentifier>
    </Filter>
    <Filter Include="zlib">
      <UniqueIdentifier>{d1106870-7021-4754-98d8-262b748e1467}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\findcrypt">
      <UniqueIdentifier>{efa1ebcf-65cb-4e97-bda9-8ef88e0a9b48}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\findcrypt">
      <UniqueIdentifier>{79862f04-90af-4f86-a58c-284db79b1a7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\aes-finder">
      <UniqueIdentifier>{47015d2c-09c1-40be-bd68-19929e0c5bdb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\aes-finder">
      <UniqueIdentifier>{5a29eb48-8a02-4d5f-883d-8d32b3df7c92}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\idaldr\IDA\Crc16.cpp">
      <Filter>Source Files\idaldr</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\Descriptor.cpp">
      <Filter>Source Files\sigmake</Filter>
    </ClCompile>
    <ClCompile Include="..\idaldr\IDA\DiffReader.cpp">
      <Filter>Source Files\idaldr</Filter>
    </ClCompile>
    <ClCompile Include="..\idaldr\IDA\DiffWriter.cpp">
      <Filter>Source Files\idaldr</Filter>
    </ClCompile>
    <ClCompile Include="..\idaldr\Ldr.cpp">
      <Filter>Source Files\idaldr</Filter>
    </ClCompile>
    <ClCompile Include="..\idaldr\Map\MapReader.cpp">
      <Filter>Source Files\idaldr</Filter>
    </ClCompile>
    <ClCompile Include="..\idaldr\Map\MapWriter.cpp">
      <Filter>Source Files\idaldr</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\SigMake.cpp">
      <Filter>Source Files\sigmake</Filter>
    </ClCompile>
    <ClCompile Include="Plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\decoder.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\distorm.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\instructions.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\insts.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\mnemonics.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\operands.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\prefix.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\textdefs.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\distorm\wstring.c">
      <Filter>Source Files\sigmake\distorm</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\Dialog\SettingsDialog.cpp">
      <Filter>Source Files\sigmake</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\Dialog\Settings.cpp">
      <Filter>Source Files\sigmake</Filter>
    </ClCompile>
    <ClCompile Include="..\peid\peid.cpp">
      <Filter>Source Files\peid</Filter>
    </ClCompile>
    <ClCompile Include="..\idaldr\IDA\Sig.cpp">
      <Filter>Source Files\idaldr</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\adler32.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\compress.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\crc32.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\deflate.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\gzclose.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\gzlib.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\gzread.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\gzwrite.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\infback.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\inffast.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\inflate.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\inftrees.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\trees.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\uncompr.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\zlib\zutil.c">
      <Filter>zlib</Filter>
    </ClCompile>
    <ClCompile Include="..\findcrypt\consts.cpp">
      <Filter>Source Files\findcrypt</Filter>
    </ClCompile>
    <ClCompile Include="..\findcrypt\findcrypt.cpp">
      <Filter>Source Files\findcrypt</Filter>
    </ClCompile>
    <ClCompile Include="..\findcrypt\sparse.cpp">
      <Filter>Source Files\findcrypt</Filter>
    </ClCompile>
    <ClCompile Include="..\aes-finder\aes-finder.cpp">
      <Filter>Source Files\aes-finder</Filter>
    </ClCompile>
    <ClCompile Include="Commands.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\Dialog\BatchSigDialog.cpp">
      <Filter>Source Files\sigmake</Filter>
    </ClCompile>
    <ClCompile Include="..\sigmake\Dialog\SigMakeDialog.cpp">
      <Filter>Source Files\sigmake</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\sigmake\resource.h">
      <Filter>Header Files\sigmake</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\SigMake.h">
      <Filter>Header Files\sigmake</Filter>
    </ClInclude>
    <ClInclude Include="..\idaldr\Map\Map.h">
      <Filter>Header Files\idaldr</Filter>
    </ClInclude>
    <ClInclude Include="..\idaldr\IDA\Diff.h">
      <Filter>Header Files\idaldr</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\Descriptor.h">
      <Filter>Header Files\sigmake</Filter>
    </ClInclude>
    <ClInclude Include="..\idaldr\IDA\Crc16.h">
      <Filter>Header Files\idaldr</Filter>
    </ClInclude>
    <ClInclude Include="..\idaldr\stdafx.h">
      <Filter>Header Files\idaldr</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\stdafx.h">
      <Filter>Header Files\sigmake</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Plugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\idaldr\Ldr.h">
      <Filter>Header Files\idaldr</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\config.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\decoder.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\distorm.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\instructions.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\insts.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\mnemonics.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\operands.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\prefix.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\textdefs.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\wstring.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\distorm\x86defs.h">
      <Filter>Header Files\sigmake\distorm</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\Dialog\Settings.h">
      <Filter>Header Files\sigmake</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\Dialog\SettingsDialog.h">
      <Filter>Header Files\sigmake</Filter>
    </ClInclude>
    <ClInclude Include="..\sigmake\Dialog\SigMakeDialog.h">
      <Filter>Header Files\sigmake</Filter>
    </ClInclude>
    <ClInclude Include="..\peid\peid.h">
      <Filter>Header Files\peid</Filter>
    </ClInclude>
    <ClInclude Include="..\idaldr\IDA\Sig.h">
      <Filter>Header Files\idaldr</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\crc32.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\deflate.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\gzguts.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\inffast.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\inffixed.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\inflate.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\inftrees.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\trees.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\zconf.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\zlib.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\zlib\zutil.h">
      <Filter>zlib</Filter>
    </ClInclude>
    <ClInclude Include="..\findcrypt\findcrypt.h">
      <Filter>Header Files\findcrypt</Filter>
    </ClInclude>
    <ClInclude Include="..\aes-finder\aes-finder.h">
      <Filter>Header Files\aes-finder</Filter>
    </ClInclude>
    <ClInclude Include="..\aes-finder\aes-finder-test.h">
      <Filter>Header Files\aes-finder</Filter>
    </ClInclude>
    <ClInclude Include="Commands.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\sigmake\sigmake.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\zlib\LICENSE">
      <Filter>zlib</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: src/SwissArmyKnife/Util.cpp
================================================
#include "stdafx.h"

duint DbgGetCurrentModule()
{
	if (!DbgIsDebugging())
	{
		_plugin_logprintf("The debugger is not running!\n");
		return 0;
	}

	// First get the current code location
	SELECTIONDATA selection;

	if (!GuiSelectionGet(GUI_DISASSEMBLY, &selection))
	{
		_plugin_logprintf("GuiSelectionGet(GUI_DISASSEMBLY) failed\n");
		return 0;
	}

	// Convert the selected address to a module base
	duint moduleBase = DbgFunctions()->ModBaseFromAddr(selection.start);

	if (moduleBase <= 0)
	{
		_plugin_logprintf("Failed to resolve module base at address '0x%llX'\n", (ULONGLONG)selection.start);
		return 0;
	}

	return moduleBase;
}

bool DbgEnumMemoryRanges(std::function<bool(duint Start, duint End)> Callback)
{
	// Request all registered memory ranges from debugger
	MEMMAP map;

	if (!DbgMemMap(&map))
		return false;

	// No memory ranges listed
	if (map.count <= 0)
		return false;

	for (int i = 0; i < map.count; i++)
	{
		duint base	= (duint)map.page[i].mbi.BaseAddress;
		duint end	= base + map.page[i].mbi.RegionSize;

		if (!Callback(base, end))
			return false;
	}

	return true;
}

bool OpenSelectionDialog(const char *Title, const char *Filter, bool Save, bool(*Callback)(char *, duint))
{
	duint moduleBase = DbgGetCurrentModule();

	if (moduleBase <= 0)
		return false;

	// Open a file dialog to select the map or sig
	char buffer[MAX_PATH];
	memset(buffer, 0, sizeof(buffer));

	OPENFILENAMEA ofn;
	memset(&ofn, 0, sizeof(OPENFILENAMEA));

	ofn.lStructSize = sizeof(OPENFILENAMEA);
	ofn.hwndOwner = GuiGetWindowHandle();
	ofn.lpstrFilter = Filter;
	ofn.lpstrFile = buffer;
	ofn.nMaxFile = ARRAYSIZE(buffer);
	ofn.lpstrTitle = Title;
	ofn.Flags = OFN_FILEMUSTEXIST;

	if (Save)
	{
		ofn.lpstrDefExt = strchr(Filter, '\0') + 3;
		ofn.Flags = OFN_OVERWRITEPROMPT;

		if (!GetSaveFileNameA(&ofn))
			return false;
	}
	else
	{
		if (!GetOpenFileNameA(&ofn))
			return false;
	}

	if (!Callback(buffer, moduleBase))
	{
		_plugin_logprintf("An error occurred while applying the file\n");
		return false;
	}

	return true;
}

void StringReplace(std::string& Subject, const std::string& Search, const std::string& Replace)
{
	size_t pos = 0;

	while ((pos = Subject.find(Search, pos)) != std::string::npos)
	{
		Subject.replace(pos, Search.length(), Replace);
		pos += Replace.length();
	}
}


================================================
File: src/SwissArmyKnife/Util.h
================================================
#pragma once

duint DbgGetCurrentModule();
bool DbgEnumMemoryRanges(std::function<bool(duint Start, duint End)> Callback);
bool OpenSelectionDialog(const char *Title, const char *Filter, bool Save, bool(*Callback)(char *, duint));
void StringReplace(std::string& Subject, const std::string& Search, const std::string& Replace);


================================================
File: src/SwissArmyKnife/stdafx.h
================================================
#pragma once

#define PLUGIN_NAME		"SwissArmyKnife"
#define PLUGIN_VERSION	001

//
// WINDOWS
//
#include <windows.h>
#include <functional>

//
// X64DBG
//
#define dprintf _plugin_logprintf

#ifdef _WIN64
#pragma comment(lib, "../pluginsdk/x64dbg.lib")
#pragma comment(lib, "../pluginsdk/x64bridge.lib")
#pragma comment(lib, "../pluginsdk/TitanEngine/TitanEngine_x64.lib")
#pragma comment(lib, "../pluginsdk/dbghelp/dbghelp_x64.lib")
#else
#pragma comment(lib, "../pluginsdk/x32dbg.lib")
#pragma comment(lib, "../pluginsdk/x32bridge.lib")
#pragma comment(lib, "../pluginsdk/TitanEngine/TitanEngine_x86.lib")
#pragma comment(lib, "../pluginsdk/dbghelp/dbghelp_x86.lib")
#endif // _WIN64

// warning C4091: 'typedef ': ignored on left of '' when no variable is declared
#pragma warning(disable: 4091)

#include "../pluginsdk/_plugins.h"
#include "../pluginsdk/bridgemain.h"
#include "../pluginsdk/_dbgfunctions.h"
#include "../pluginsdk/TitanEngine/TitanEngine.h"

//
// EVERYTHING ELSE
//
#include "../idaldr/stdafx.h"
#include "../sigmake/stdafx.h"
#include "../peid/peid.h"
#include "../findcrypt/findcrypt.h"
#include "../aes-finder/aes-finder.h"

#include "Util.h"
#include "Plugin.h"
#include "Commands.h"


================================================
File: src/SwissArmyKnife/Release/sigmake.res
================================================
[Non-text file]


================================================
File: src/SwissArmyKnife/x64/Release/sigmake.res
================================================
[Non-text file]


================================================
File: src/aes-finder/aes-finder-test.h
================================================
#pragma once

#include <stdint.h>
#include <string.h>

static void self_test()
{
	static const uint32_t aes128_encB[] = {
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
		0xd6aa74fd, 0xd2af72fa, 0xdaa678f1, 0xd6ab76fe,
		0xb692cf0b, 0x643dbdf1, 0xbe9bc500, 0x6830b3fe,
		0xb6ff744e, 0xd2c2c9bf, 0x6c590cbf, 0x0469bf41,
		0x47f7f7bc, 0x95353e03, 0xf96c32bc, 0xfd058dfd,
		0x3caaa3e8, 0xa99f9deb, 0x50f3af57, 0xadf622aa,
		0x5e390f7d, 0xf7a69296, 0xa7553dc1, 0x0aa31f6b,
		0x14f9701a, 0xe35fe28c, 0x440adf4d, 0x4ea9c026,
		0x47438735, 0xa41c65b9, 0xe016baf4, 0xaebf7ad2,
		0x549932d1, 0xf0855768, 0x1093ed9c, 0xbe2c974e,
		0x13111d7f, 0xe3944a17, 0xf307a78b, 0x4d2b30c5,
	};
	static const uint32_t aes128_encL[] = {
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0xfd74aad6, 0xfa72afd2, 0xf178a6da, 0xfe76abd6,
		0x0bcf92b6, 0xf1bd3d64, 0x00c59bbe, 0xfeb33068,
		0x4e74ffb6, 0xbfc9c2d2, 0xbf0c596c, 0x41bf6904,
		0xbcf7f747, 0x033e3595, 0xbc326cf9, 0xfd8d05fd,
		0xe8a3aa3c, 0xeb9d9fa9, 0x57aff350, 0xaa22f6ad,
		0x7d0f395e, 0x9692a6f7, 0xc13d55a7, 0x6b1fa30a,
		0x1a70f914, 0x8ce25fe3, 0x4ddf0a44, 0x26c0a94e,
		0x35874347, 0xb9651ca4, 0xf4ba16e0, 0xd27abfae,
		0xd1329954, 0x685785f0, 0x9ced9310, 0x4e972cbe,
		0x7f1d1113, 0x174a94e3, 0x8ba707f3, 0xc5302b4d,
	};
	static const uint32_t aes192_encB[] = {
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
		0x10111213, 0x14151617, 0x5846f2f9, 0x5c43f4fe,
		0x544afef5, 0x5847f0fa, 0x4856e2e9, 0x5c43f4fe,
		0x40f949b3, 0x1cbabd4d, 0x48f043b8, 0x10b7b342,
		0x58e151ab, 0x04a2a555, 0x7effb541, 0x6245080c,
		0x2ab54bb4, 0x3a02f8f6, 0x62e3a95d, 0x66410c08,
		0xf5018572, 0x97448d7e, 0xbdf1c6ca, 0x87f33e3c,
		0xe5109761, 0x83519b69, 0x34157c9e, 0xa351f1e0,
		0x1ea0372a, 0x99530916, 0x7c439e77, 0xff12051e,
		0xdd7e0e88, 0x7e2fff68, 0x608fc842, 0xf9dcc154,
		0x859f5f23, 0x7a8d5a3d, 0xc0c02952, 0xbeefd63a,
		0xde601e78, 0x27bcdf2c, 0xa223800f, 0xd8aeda32,
		0xa4970a33, 0x1a78dc09, 0xc418c271, 0xe3a41d5d,
	};
	static const uint32_t aes192_encL[] = {
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0x13121110, 0x17161514, 0xf9f24658, 0xfef4435c,
		0xf5fe4a54, 0xfaf04758, 0xe9e25648, 0xfef4435c,
		0xb349f940, 0x4dbdba1c, 0xb843f048, 0x42b3b710,
		0xab51e158, 0x55a5a204, 0x41b5ff7e, 0x0c084562,
		0xb44bb52a, 0xf6f8023a, 0x5da9e362, 0x080c4166,
		0x728501f5, 0x7e8d4497, 0xcac6f1bd, 0x3c3ef387,
		0x619710e5, 0x699b5183, 0x9e7c1534, 0xe0f151a3,
		0x2a37a01e, 0x16095399, 0x779e437c, 0x1e0512ff,
		0x880e7edd, 0x68ff2f7e, 0x42c88f60, 0x54c1dcf9,
		0x235f9f85, 0x3d5a8d7a, 0x5229c0c0, 0x3ad6efbe,
		0x781e60de, 0x2cdfbc27, 0x0f8023a2, 0x32daaed8,
		0x330a97a4, 0x09dc781a, 0x71c218c4, 0x5d1da4e3,

	};
	static const uint32_t aes256_encB[] = {
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
		0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f,
		0xa573c29f, 0xa176c498, 0xa97fce93, 0xa572c09c,
		0x1651a8cd, 0x0244beda, 0x1a5da4c1, 0x0640bade,
		0xae87dff0, 0x0ff11b68, 0xa68ed5fb, 0x03fc1567,
		0x6de1f148, 0x6fa54f92, 0x75f8eb53, 0x73b8518d,
		0xc656827f, 0xc9a79917, 0x6f294cec, 0x6cd5598b,
		0x3de23a75, 0x524775e7, 0x27bf9eb4, 0x5407cf39,
		0x0bdc905f, 0xc27b0948, 0xad5245a4, 0xc1871c2f,
		0x45f5a660, 0x17b2d387, 0x300d4d33, 0x640a820a,
		0x7ccff71c, 0xbeb4fe54, 0x13e6bbf0, 0xd261a7df,
		0xf01afafe, 0xe7a82979, 0xd7a5644a, 0xb3afe640,
		0x2541fe71, 0x9bf50025, 0x8813bbd5, 0x5a721c0a,
		0x4e5a6699, 0xa9f24fe0, 0x7e572baa, 0xcdf8cdea,
		0x24fc79cc, 0xbf0979e9, 0x371ac23c, 0x6d68de36,
	};
	static const uint32_t aes256_encL[] = {
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,
		0x9fc273a5, 0x98c476a1, 0x93ce7fa9, 0x9cc072a5,
		0xcda85116, 0xdabe4402, 0xc1a45d1a, 0xdeba4006,
		0xf0df87ae, 0x681bf10f, 0xfbd58ea6, 0x6715fc03,
		0x48f1e16d, 0x924fa56f, 0x53ebf875, 0x8d51b873,
		0x7f8256c6, 0x1799a7c9, 0xec4c296f, 0x8b59d56c,
		0x753ae23d, 0xe7754752, 0xb49ebf27, 0x39cf0754,
		0x5f90dc0b, 0x48097bc2, 0xa44552ad, 0x2f1c87c1,
		0x60a6f545, 0x87d3b217, 0x334d0d30, 0x0a820a64,
		0x1cf7cf7c, 0x54feb4be, 0xf0bbe613, 0xdfa761d2,
		0xfefa1af0, 0x7929a8e7, 0x4a64a5d7, 0x40e6afb3,
		0x71fe4125, 0x2500f59b, 0xd5bb1388, 0x0a1c725a,
		0x99665a4e, 0xe04ff2a9, 0xaa2b577e, 0xeacdf8cd,
		0xcc79fc24, 0xe97909bf, 0x3cc21a37, 0x36de686d,
	};

	static const uint32_t aes128_decBF[] = {
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
		0x8c56dff0, 0x825dd3f9, 0x805ad3fc, 0x8659d7fd,
		0xa0db0299, 0x2286d160, 0xa2dc029c, 0x2485d561,
		0xc7c6e391, 0xe54032f1, 0x479c306d, 0x6319e50c,
		0xa8a2f504, 0x4de2c7f5, 0x0a7ef798, 0x69671294,
		0x2ec41027, 0x6326d7d2, 0x6958204a, 0x003f32de,
		0x72e3098d, 0x11c5de5f, 0x789dfe15, 0x78a2cccb,
		0x8d82fc74, 0x9c47222b, 0xe4dadc3e, 0x9c7810f5,
		0x1362a463, 0x8f258648, 0x6bff5a76, 0xf7874a83,
		0x13aa29be, 0x9c8faff6, 0xf770f580, 0x00f7bf03,
		0x13111d7f, 0xe3944a17, 0xf307a78b, 0x4d2b30c5,
	};
	static const uint32_t aes128_decBB[] = {
		0x13111d7f, 0xe3944a17, 0xf307a78b, 0x4d2b30c5,
		0x13aa29be, 0x9c8faff6, 0xf770f580, 0x00f7bf03,
		0x1362a463, 0x8f258648, 0x6bff5a76, 0xf7874a83,
		0x8d82fc74, 0x9c47222b, 0xe4dadc3e, 0x9c7810f5,
		0x72e3098d, 0x11c5de5f, 0x789dfe15, 0x78a2cccb,
		0x2ec41027, 0x6326d7d2, 0x6958204a, 0x003f32de,
		0xa8a2f504, 0x4de2c7f5, 0x0a7ef798, 0x69671294,
		0xc7c6e391, 0xe54032f1, 0x479c306d, 0x6319e50c,
		0xa0db0299, 0x2286d160, 0xa2dc029c, 0x2485d561,
		0x8c56dff0, 0x825dd3f9, 0x805ad3fc, 0x8659d7fd,
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
	};
	static const uint32_t aes128_decLF[] = {
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0xf0df568c, 0xf9d35d82, 0xfcd35a80, 0xfdd75986,
		0x9902dba0, 0x60d18622, 0x9c02dca2, 0x61d58524,
		0x91e3c6c7, 0xf13240e5, 0x6d309c47, 0x0ce51963,
		0x04f5a2a8, 0xf5c7e24d, 0x98f77e0a, 0x94126769,
		0x2710c42e, 0xd2d72663, 0x4a205869, 0xde323f00,
		0x8d09e372, 0x5fdec511, 0x15fe9d78, 0xcbcca278,
		0x74fc828d, 0x2b22479c, 0x3edcdae4, 0xf510789c,
		0x63a46213, 0x4886258f, 0x765aff6b, 0x834a87f7,
		0xbe29aa13, 0xf6af8f9c, 0x80f570f7, 0x03bff700,
		0x7f1d1113, 0x174a94e3, 0x8ba707f3, 0xc5302b4d,
	};
	static const uint32_t aes128_decLB[] = {
		0x7f1d1113, 0x174a94e3, 0x8ba707f3, 0xc5302b4d,
		0xbe29aa13, 0xf6af8f9c, 0x80f570f7, 0x03bff700,
		0x63a46213, 0x4886258f, 0x765aff6b, 0x834a87f7,
		0x74fc828d, 0x2b22479c, 0x3edcdae4, 0xf510789c,
		0x8d09e372, 0x5fdec511, 0x15fe9d78, 0xcbcca278,
		0x2710c42e, 0xd2d72663, 0x4a205869, 0xde323f00,
		0x04f5a2a8, 0xf5c7e24d, 0x98f77e0a, 0x94126769,
		0x91e3c6c7, 0xf13240e5, 0x6d309c47, 0x0ce51963,
		0x9902dba0, 0x60d18622, 0x9c02dca2, 0x61d58524,
		0xf0df568c, 0xf9d35d82, 0xfcd35a80, 0xfdd75986,
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
	};
	static const uint32_t aes192_decBF[] = {
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
		0x1a1f181d, 0x1e1b1c19, 0x4742c7d7, 0x4949cbde,
		0x4b4ecbdb, 0x4d4dcfda, 0x5752d7c7, 0x4949cbde,
		0x60dcef10, 0x299524ce, 0x62dbef15, 0x2f9620cf,
		0x78c4f708, 0x318d3cd6, 0x9655b701, 0xbfc093cf,
		0xdd1b7cda, 0xf28d5c15, 0x8a49ab1d, 0xbbc497cb,
		0xc6deb0ab, 0x791e2364, 0xa4055fbe, 0x568803ab,
		0xdcc1a8b6, 0x67053f7d, 0xcc5c194a, 0xb5423a2e,
		0x11476590, 0x47cf663b, 0x9b0ece8d, 0xfc0bf1f0,
		0xf77d6ec1, 0x423f54ef, 0x5378317f, 0x14b75744,
		0x8fb999c9, 0x73b26839, 0xc7f9d89d, 0x85c68c72,
		0xd6bebd0d, 0xc209ea49, 0x4db07380, 0x3e021bb9,
		0xa4970a33, 0x1a78dc09, 0xc418c271, 0xe3a41d5d,
	};
	static const uint32_t aes192_decBB[] = {
		0xa4970a33, 0x1a78dc09, 0xc418c271, 0xe3a41d5d,
		0xd6bebd0d, 0xc209ea49, 0x4db07380, 0x3e021bb9,
		0x8fb999c9, 0x73b26839, 0xc7f9d89d, 0x85c68c72,
		0xf77d6ec1, 0x423f54ef, 0x5378317f, 0x14b75744,
		0x11476590, 0x47cf663b, 0x9b0ece8d, 0xfc0bf1f0,
		0xdcc1a8b6, 0x67053f7d, 0xcc5c194a, 0xb5423a2e,
		0xc6deb0ab, 0x791e2364, 0xa4055fbe, 0x568803ab,
		0xdd1b7cda, 0xf28d5c15, 0x8a49ab1d, 0xbbc497cb,
		0x78c4f708, 0x318d3cd6, 0x9655b701, 0xbfc093cf,
		0x60dcef10, 0x299524ce, 0x62dbef15, 0x2f9620cf,
		0x4b4ecbdb, 0x4d4dcfda, 0x5752d7c7, 0x4949cbde,
		0x1a1f181d, 0x1e1b1c19, 0x4742c7d7, 0x4949cbde,
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
	};
	static const uint32_t aes192_decLF[] = {
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0x1d181f1a, 0x191c1b1e, 0xd7c74247, 0xdecb4949,
		0xdbcb4e4b, 0xdacf4d4d, 0xc7d75257, 0xdecb4949,
		0x10efdc60, 0xce249529, 0x15efdb62, 0xcf20962f,
		0x08f7c478, 0xd63c8d31, 0x01b75596, 0xcf93c0bf,
		0xda7c1bdd, 0x155c8df2, 0x1dab498a, 0xcb97c4bb,
		0xabb0dec6, 0x64231e79, 0xbe5f05a4, 0xab038856,
		0xb6a8c1dc, 0x7d3f0567, 0x4a195ccc, 0x2e3a42b5,
		0x90654711, 0x3b66cf47, 0x8dce0e9b, 0xf0f10bfc,
		0xc16e7df7, 0xef543f42, 0x7f317853, 0x4457b714,
		0xc999b98f, 0x3968b273, 0x9dd8f9c7, 0x728cc685,
		0x0dbdbed6, 0x49ea09c2, 0x8073b04d, 0xb91b023e,
		0x330a97a4, 0x09dc781a, 0x71c218c4, 0x5d1da4e3,
	};
	static const uint32_t aes192_decLB[] = {
		0x330a97a4, 0x09dc781a, 0x71c218c4, 0x5d1da4e3,
		0x0dbdbed6, 0x49ea09c2, 0x8073b04d, 0xb91b023e,
		0xc999b98f, 0x3968b273, 0x9dd8f9c7, 0x728cc685,
		0xc16e7df7, 0xef543f42, 0x7f317853, 0x4457b714,
		0x90654711, 0x3b66cf47, 0x8dce0e9b, 0xf0f10bfc,
		0xb6a8c1dc, 0x7d3f0567, 0x4a195ccc, 0x2e3a42b5,
		0xabb0dec6, 0x64231e79, 0xbe5f05a4, 0xab038856,
		0xda7c1bdd, 0x155c8df2, 0x1dab498a, 0xcb97c4bb,
		0x08f7c478, 0xd63c8d31, 0x01b75596, 0xcf93c0bf,
		0x10efdc60, 0xce249529, 0x15efdb62, 0xcf20962f,
		0xdbcb4e4b, 0xdacf4d4d, 0xc7d75257, 0xdecb4949,
		0x1d181f1a, 0x191c1b1e, 0xd7c74247, 0xdecb4949,
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
	};
	static const uint32_t aes256_decBF[] = {
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
		0x1a1f181d, 0x1e1b1c19, 0x12171015, 0x16131411,
		0x2a2840c9, 0x24234cc0, 0x26244cc5, 0x202748c4,
		0x7fd7850f, 0x61cc9916, 0x73db8903, 0x65c89d12,
		0x15c668bd, 0x31e5247d, 0x17c168b8, 0x37e6207c,
		0xaed55816, 0xcf19c100, 0xbcc24803, 0xd90ad511,
		0xde69409a, 0xef8c64e7, 0xf84d0c5f, 0xcfab2c23,
		0xf85fc4f3, 0x374605f3, 0x8b844df0, 0x528e98e1,
		0x3ca69715, 0xd32af3f2, 0x2b67ffad, 0xe4ccd38e,
		0x74da7ba3, 0x439c7e50, 0xc81833a0, 0x9a96ab41,
		0xb5708e13, 0x665a7de1, 0x4d3d824c, 0xa9f151c2,
		0xc8a30580, 0x8b3f7bd0, 0x43274870, 0xd9b1e331,
		0x5e1648eb, 0x384c350a, 0x7571b746, 0xdc80e684,
		0x34f1d1ff, 0xbfceaa2f, 0xfce9e25f, 0x2558016e,
		0x24fc79cc, 0xbf0979e9, 0x371ac23c, 0x6d68de36,
	};
	static const uint32_t aes256_decBB[] = {
		0x24fc79cc, 0xbf0979e9, 0x371ac23c, 0x6d68de36,
		0x34f1d1ff, 0xbfceaa2f, 0xfce9e25f, 0x2558016e,
		0x5e1648eb, 0x384c350a, 0x7571b746, 0xdc80e684,
		0xc8a30580, 0x8b3f7bd0, 0x43274870, 0xd9b1e331,
		0xb5708e13, 0x665a7de1, 0x4d3d824c, 0xa9f151c2,
		0x74da7ba3, 0x439c7e50, 0xc81833a0, 0x9a96ab41,
		0x3ca69715, 0xd32af3f2, 0x2b67ffad, 0xe4ccd38e,
		0xf85fc4f3, 0x374605f3, 0x8b844df0, 0x528e98e1,
		0xde69409a, 0xef8c64e7, 0xf84d0c5f, 0xcfab2c23,
		0xaed55816, 0xcf19c100, 0xbcc24803, 0xd90ad511,
		0x15c668bd, 0x31e5247d, 0x17c168b8, 0x37e6207c,
		0x7fd7850f, 0x61cc9916, 0x73db8903, 0x65c89d12,
		0x2a2840c9, 0x24234cc0, 0x26244cc5, 0x202748c4,
		0x1a1f181d, 0x1e1b1c19, 0x12171015, 0x16131411,
		0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f,
	};
	static const uint32_t aes256_decLF[] = {
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0x1d181f1a, 0x191c1b1e, 0x15101712, 0x11141316,
		0xc940282a, 0xc04c2324, 0xc54c2426, 0xc4482720,
		0x0f85d77f, 0x1699cc61, 0x0389db73, 0x129dc865,
		0xbd68c615, 0x7d24e531, 0xb868c117, 0x7c20e637,
		0x1658d5ae, 0x00c119cf, 0x0348c2bc, 0x11d50ad9,
		0x9a4069de, 0xe7648cef, 0x5f0c4df8, 0x232cabcf,
		0xf3c45ff8, 0xf3054637, 0xf04d848b, 0xe1988e52,
		0x1597a63c, 0xf2f32ad3, 0xadff672b, 0x8ed3cce4,
		0xa37bda74, 0x507e9c43, 0xa03318c8, 0x41ab969a,
		0x138e70b5, 0xe17d5a66, 0x4c823d4d, 0xc251f1a9,
		0x8005a3c8, 0xd07b3f8b, 0x70482743, 0x31e3b1d9,
		0xeb48165e, 0x0a354c38, 0x46b77175, 0x84e680dc,
		0xffd1f134, 0x2faacebf, 0x5fe2e9fc, 0x6e015825,
		0xcc79fc24, 0xe97909bf, 0x3cc21a37, 0x36de686d,
	};
	static const uint32_t aes256_decLB[] = {
		0xcc79fc24, 0xe97909bf, 0x3cc21a37, 0x36de686d,
		0xffd1f134, 0x2faacebf, 0x5fe2e9fc, 0x6e015825,
		0xeb48165e, 0x0a354c38, 0x46b77175, 0x84e680dc,
		0x8005a3c8, 0xd07b3f8b, 0x70482743, 0x31e3b1d9,
		0x138e70b5, 0xe17d5a66, 0x4c823d4d, 0xc251f1a9,
		0xa37bda74, 0x507e9c43, 0xa03318c8, 0x41ab969a,
		0x1597a63c, 0xf2f32ad3, 0xadff672b, 0x8ed3cce4,
		0xf3c45ff8, 0xf3054637, 0xf04d848b, 0xe1988e52,
		0x9a4069de, 0xe7648cef, 0x5f0c4df8, 0x232cabcf,
		0x1658d5ae, 0x00c119cf, 0x0348c2bc, 0x11d50ad9,
		0xbd68c615, 0x7d24e531, 0xb868c117, 0x7c20e637,
		0x0f85d77f, 0x1699cc61, 0x0389db73, 0x129dc865,
		0xc940282a, 0xc04c2324, 0xc54c2426, 0xc4482720,
		0x1d181f1a, 0x191c1b1e, 0x15101712, 0x11141316,
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
	};

	static const uint8_t aes_key[] = {
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	};

	uint8_t tmp[32];

#define AES_CHECK(fun, reverse, arr, len)                              \
    if (!fun<reverse>(arr, tmp) || memcmp(aes_key, tmp, len) != 0)     \
    {                                                                  \
        dprintf("Self-test %s<%s>(%s) failed\n", #fun, #reverse, #arr);\
        abort();                                                       \
    }                                                                  \
    else                                                               \
    {                                                                  \
        memset(tmp, 0, sizeof(tmp));                                   \
    }                                                                  \

	AES_CHECK(aes128_detect_enc, true, aes128_encB, 16);
	AES_CHECK(aes128_detect_enc, false, aes128_encL, 16);

	AES_CHECK(aes192_detect_enc, true, aes192_encB, 24);
	AES_CHECK(aes192_detect_enc, false, aes192_encL, 24);

	AES_CHECK(aes256_detect_enc, true, aes256_encB, 32);
	AES_CHECK(aes256_detect_enc, false, aes256_encL, 32);

	AES_CHECK(aes128_detect_decF, true, aes128_decBF, 16);
	AES_CHECK(aes128_detect_decF, false, aes128_decLF, 16);

	AES_CHECK(aes128_detect_decB, true, aes128_decBB, 16);
	AES_CHECK(aes128_detect_decB, false, aes128_decLB, 16);

	AES_CHECK(aes192_detect_decF, true, aes192_decBF, 24);
	AES_CHECK(aes192_detect_decF, false, aes192_decLF, 24);

	AES_CHECK(aes192_detect_decB, true, aes192_decBB, 24);
	AES_CHECK(aes192_detect_decB, false, aes192_decLB, 24);

	AES_CHECK(aes256_detect_decF, true, aes256_decBF, 32);
	AES_CHECK(aes256_detect_decF, false, aes256_decLF, 32);

	AES_CHECK(aes256_detect_decB, true, aes256_decBB, 32);
	AES_CHECK(aes256_detect_decB, false, aes256_decLB, 32);

#undef AES_CHECK
}


================================================
File: src/aes-finder/aes-finder.cpp
================================================
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include "aes-finder.h"

#if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_AMD64))
// _rotr is in <stdlib.h>
#elif defined(__clang__) && (defined(__i386__) || defined(__x86_64__))
static uint32_t _rotr(uint32_t x, int n)
{
    __asm__ __volatile__("rorl %2, %0" : "=r"(x) : "0"(x), "Nc"(n));
    return x;
}
#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
// _rotr is in <ia32intrin.h>
#include <x86intrin.h>
#else
static uint32_t _rotr(uint32_t x, int n)
{
    return (x >> n) | (x << (32 - n));
}
#endif

#if 0
#if defined(WIN32)
#include "os_windows.h"
#elif defined(__linux__)
#include "os_linux.h"
#elif defined(__APPLE__)
#include "os_osx.h"
#else
#error Unknown OS!
#endif
#endif

static const uint32_t rcon[] = {
    0x01000000, 0x02000000, 0x04000000, 0x08000000,
    0x10000000, 0x20000000, 0x40000000, 0x80000000,
    0x1B000000, 0x36000000,
};

static const uint8_t Te[256] = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
};

static const uint8_t Td[256] = {
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
};

static const uint32_t TE[256] = {
    0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554,
    0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a,
    0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b,
    0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b,
    0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f,
    0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f,
    0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5,
    0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f,
    0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb,
    0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497,
    0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed,
    0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a,
    0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594,
    0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3,
    0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504,
    0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d,
    0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739,
    0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395,
    0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883,
    0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76,
    0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4,
    0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b,
    0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0,
    0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818,
    0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651,
    0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85,
    0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12,
    0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9,
    0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7,
    0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a,
    0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8,
    0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a,
};

static uint8_t _byte(uint32_t x, int n)
{
    return (uint8_t)(x >> (8 * n));
}

static uint32_t rotr32(uint32_t x, int n)
{
    return _rotr(x, n);
}

static uint32_t setup_mix(uint32_t temp)
{
    return (Te[_byte(temp, 2)] << 24)
         ^ (Te[_byte(temp, 1)] << 16)
         ^ (Te[_byte(temp, 0)] << 8)
         ^  Te[_byte(temp, 3)];
}

static uint32_t setup_mix2(uint32_t temp)
{
    return rotr32(TE[Td[_byte(temp, 3)]], 0)
         ^ rotr32(TE[Td[_byte(temp, 2)]], 8)
         ^ rotr32(TE[Td[_byte(temp, 1)]], 16)
         ^ rotr32(TE[Td[_byte(temp, 0)]], 24);
}

template <bool reversed>
uint32_t load(uint32_t x);

template <>
uint32_t load<true>(uint32_t x)
{
    return x;
}

template <>
uint32_t load<false>(uint32_t x)
{
#ifdef _MSC_VER
    return _byteswap_ulong(x);
#else
    return __builtin_bswap32(x);
#endif
}

template <bool reversed>
void store(uint32_t x, uint8_t* ptr);

template <>
void store<true>(uint32_t x, uint8_t* ptr)
{
    (uint32_t&)*ptr = x;
}

template <>
void store<false>(uint32_t x, uint8_t* ptr)
{
#ifdef _MSC_VER
    (uint32_t&)*ptr = _byteswap_ulong(x);
#else
    (uint32_t&)*ptr = __builtin_bswap32(x);
#endif
}

template <bool reversed>
static bool aes128_detect_enc(const uint32_t* ctx, uint8_t* key)
{
    const uint32_t* ptr = ctx;

    uint32_t tmp[8];
    tmp[0] = load<reversed>(ctx[0]);
    tmp[1] = load<reversed>(ctx[1]);
    tmp[2] = load<reversed>(ctx[2]);
    tmp[3] = load<reversed>(ctx[3]);

    for (int i = 0; ctx += 4, i < 10; i++)
    {
        tmp[4] = tmp[0] ^ setup_mix(tmp[3]) ^ rcon[i];
        if (tmp[4] != load<reversed>(ctx[0])) return false;

        tmp[5] = tmp[1] ^ tmp[4];
        if (tmp[5] != load<reversed>(ctx[1])) return false;

        tmp[6] = tmp[2] ^ tmp[5];
        if (tmp[6] != load<reversed>(ctx[2])) return false;

        tmp[7] = tmp[3] ^ tmp[6];
        if (tmp[7] != load<reversed>(ctx[3])) return false;

        tmp[0] = tmp[4];
        tmp[1] = tmp[5];
        tmp[2] = tmp[6];
        tmp[3] = tmp[7];
    }

    store<false>(load<reversed>(ptr[0]), key + 0);
    store<false>(load<reversed>(ptr[1]), key + 4);
    store<false>(load<reversed>(ptr[2]), key + 8);
    store<false>(load<reversed>(ptr[3]), key + 12);

    return true;
}

template <bool reversed>
static bool aes192_detect_enc(const uint32_t* ctx, uint8_t* key)
{
    const uint32_t* ptr = ctx;

    uint32_t tmp[12];
    for (int k = 0; k < 6; k++)
    {
        tmp[k] = load<reversed>(ctx[k]);
    }
 
    int i = 0;
    for (;;)
    {
        ctx += 6;

        tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[i];
        if (tmp[6] != load<reversed>(ctx[0])) return false;

        tmp[7] = tmp[1] ^ tmp[6];
        if (tmp[7] != load<reversed>(ctx[1])) return false;

        tmp[8] = tmp[2] ^ tmp[7];
        if (tmp[8] != load<reversed>(ctx[2])) return false;

        tmp[9] = tmp[3] ^ tmp[8];
        if (tmp[9] != load<reversed>(ctx[3])) return false;

        if (++i == 8)
        {
            break;
        }

        tmp[10] = tmp[4] ^ tmp[9];
        if (tmp[10] != load<reversed>(ctx[4])) return false;

        tmp[11] = tmp[5] ^ tmp[10];
        if (tmp[11] != load<reversed>(ctx[5])) return false;
        
        for (int k = 0; k < 6; k++)
        {
            tmp[k] = tmp[6 + k];
        }
    }

    for (int k = 0; k < 6; k++)
    {
        store<false>(load<reversed>(ptr[k]), key + 4 * k);
    }

    return true;
}

template <bool reversed>
static bool aes256_detect_enc(const uint32_t* ctx, uint8_t* key)
{
    const uint32_t* ptr = ctx;
 
    uint32_t tmp[16];
    for (int k = 0; k < 8; k++)
    {
        tmp[k] = load<reversed>(ctx[k]);
    }

    int i = 0;
    for (;;)
    {
        ctx += 8;

        tmp[8] = tmp[0] ^ setup_mix(tmp[7]) ^ rcon[i];
        if (tmp[8] != load<reversed>(ctx[0])) return false;

        tmp[9] = tmp[1] ^ tmp[8];
        if (tmp[9] != load<reversed>(ctx[1])) return false;

        tmp[10] = tmp[2] ^ tmp[9];
        if (tmp[10] != load<reversed>(ctx[2])) return false;

        tmp[11] = tmp[3] ^ tmp[10];
        if (tmp[11] != load<reversed>(ctx[3])) return false;

        if (++i == 7)
        {
            break;
        }

        tmp[12] = tmp[4] ^ setup_mix(rotr32(tmp[11], 8));
        if (tmp[12] != load<reversed>(ctx[4])) return false;

        tmp[13] = tmp[5] ^ tmp[12];
        if (tmp[13] != load<reversed>(ctx[5])) return false;

        tmp[14] = tmp[6] ^ tmp[13];
        if (tmp[14] != load<reversed>(ctx[6])) return false;

        tmp[15] = tmp[7] ^ tmp[14];
        if (tmp[15] != load<reversed>(ctx[7])) return false;

        for (int k = 0; k < 8; k++)
        {
            tmp[k] = tmp[8 + k];
        }
    }

    for (int k = 0; k < 8; k++)
    {
        store<false>(load<reversed>(ptr[k]), key + 4 * k);
    }

    return true;
}

static int aes_detect_enc(const uint32_t* ctx, uint8_t* key)
{
    if (aes128_detect_enc<true>(ctx, key) || aes128_detect_enc<false>(ctx, key))
    {
        return 16;
    }
    else if (aes192_detect_enc<true>(ctx, key) || aes192_detect_enc<false>(ctx, key))
    {
        return 24;
    }
    else if (aes256_detect_enc<true>(ctx, key) || aes256_detect_enc<false>(ctx, key))
    {
        return 32;
    }

    return 0;
}

template <bool reversed>
static bool aes128_detect_decF(const uint32_t* ctx, uint8_t* key)
{
    const uint32_t* ptr = ctx;

    uint32_t tmp[8];
    tmp[0] = load<reversed>(ctx[0]);
    tmp[1] = load<reversed>(ctx[1]);
    tmp[2] = load<reversed>(ctx[2]);
    tmp[3] = load<reversed>(ctx[3]);

    for (int i = 0; ctx += 4, i < 9; i++)
    {
        tmp[4] = tmp[0] ^ setup_mix(tmp[3]) ^ rcon[i];
        if (tmp[4] != setup_mix2(load<reversed>(ctx[0]))) return false;

        tmp[5] = tmp[1] ^ tmp[4];
        if (tmp[5] != setup_mix2(load<reversed>(ctx[1]))) return false;

        tmp[6] = tmp[2] ^ tmp[5];
        if (tmp[6] != setup_mix2(load<reversed>(ctx[2]))) return false;

        tmp[7] = tmp[3] ^ tmp[6];
        if (tmp[7] != setup_mix2(load<reversed>(ctx[3]))) return false;

        tmp[0] = tmp[4];
        tmp[1] = tmp[5];
        tmp[2] = tmp[6];
        tmp[3] = tmp[7];
    }

    tmp[4] = tmp[0] ^ setup_mix(tmp[3]) ^ rcon[9];
    if (tmp[4] != load<reversed>(ctx[0])) return false;

    tmp[5] = tmp[1] ^ tmp[4];
    if (tmp[5] != load<reversed>(ctx[1])) return false;

    tmp[6] = tmp[2] ^ tmp[5];
    if (tmp[6] != load<reversed>(ctx[2])) return false;

    tmp[7] = tmp[3] ^ tmp[6];
    if (tmp[7] != load<reversed>(ctx[3])) return false;

    store<false>(load<reversed>(ptr[0]), key + 0);
    store<false>(load<reversed>(ptr[1]), key + 4);
    store<false>(load<reversed>(ptr[2]), key + 8);
    store<false>(load<reversed>(ptr[3]), key + 12);

    return true;
}

template <bool reversed>
static bool aes128_detect_decB(const uint32_t* ctx, uint8_t* key)
{
    uint32_t tmp[8];
    tmp[0] = load<reversed>(ctx[40]);
    tmp[1] = load<reversed>(ctx[41]);
    tmp[2] = load<reversed>(ctx[42]);
    tmp[3] = load<reversed>(ctx[43]);

    for (int i = 0; i < 9; i++)
    {
        tmp[4] = tmp[0] ^ setup_mix(tmp[3]) ^ rcon[i];
        if (tmp[4] != setup_mix2(load<reversed>(ctx[36 - 4 * i]))) return false;

        tmp[5] = tmp[1] ^ tmp[4];
        if (tmp[5] != setup_mix2(load<reversed>(ctx[37 - 4 * i]))) return false;

        tmp[6] = tmp[2] ^ tmp[5];
        if (tmp[6] != setup_mix2(load<reversed>(ctx[38 - 4 * i]))) return false;

        tmp[7] = tmp[3] ^ tmp[6];
        if (tmp[7] != setup_mix2(load<reversed>(ctx[39 - 4 * i]))) return false;

        tmp[0] = tmp[4];
        tmp[1] = tmp[5];
        tmp[2] = tmp[6];
        tmp[3] = tmp[7];
    }

    tmp[4] = tmp[0] ^ setup_mix(tmp[3]) ^ rcon[9];
    if (tmp[4] != load<reversed>(ctx[0])) return false;

    tmp[5] = tmp[1] ^ tmp[4];
    if (tmp[5] != load<reversed>(ctx[1])) return false;

    tmp[6] = tmp[2] ^ tmp[5];
    if (tmp[6] != load<reversed>(ctx[2])) return false;

    tmp[7] = tmp[3] ^ tmp[6];
    if (tmp[7] != load<reversed>(ctx[3])) return false;

    store<false>(load<reversed>(ctx[40]), key + 0);
    store<false>(load<reversed>(ctx[41]), key + 4);
    store<false>(load<reversed>(ctx[42]), key + 8);
    store<false>(load<reversed>(ctx[43]), key + 12);

    return true;
}

template <bool reversed>
static bool aes192_detect_decF(const uint32_t* ctx, uint8_t* key)
{
    const uint32_t* ptr = ctx;

    uint32_t tmp[12];
    tmp[0] = load<reversed>(ctx[0]);
    tmp[1] = load<reversed>(ctx[1]);
    tmp[2] = load<reversed>(ctx[2]);
    tmp[3] = load<reversed>(ctx[3]);
    tmp[4] = setup_mix2(load<reversed>(ctx[4]));
    tmp[5] = setup_mix2(load<reversed>(ctx[5]));

    for (int i = 0; ctx += 6, i < 7; i++)
    {
        tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[i];
        if (tmp[6] != setup_mix2(load<reversed>(ctx[0]))) return false;

        tmp[7] = tmp[1] ^ tmp[6];
        if (tmp[7] != setup_mix2(load<reversed>(ctx[1]))) return false;

        tmp[8] = tmp[2] ^ tmp[7];
        if (tmp[8] != setup_mix2(load<reversed>(ctx[2]))) return false;

        tmp[9] = tmp[3] ^ tmp[8];
        if (tmp[9] != setup_mix2(load<reversed>(ctx[3]))) return false;

        tmp[10] = tmp[4] ^ tmp[9];
        if (tmp[10] != setup_mix2(load<reversed>(ctx[4]))) return false;

        tmp[11] = tmp[5] ^ tmp[10];
        if (tmp[11] != setup_mix2(load<reversed>(ctx[5]))) return false;

        for (int k = 0; k < 6; k++)
        {
            tmp[k] = tmp[6 + k];
        }
    }

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[7];
    if (tmp[6] != load<reversed>(ctx[0])) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != load<reversed>(ctx[1])) return false;

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != load<reversed>(ctx[2])) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != load<reversed>(ctx[3])) return false;

    store<false>(load<reversed>(ptr[0]), key + 0);
    store<false>(load<reversed>(ptr[1]), key + 4);
    store<false>(load<reversed>(ptr[2]), key + 8);
    store<false>(load<reversed>(ptr[3]), key + 12);
    store<false>(setup_mix2(load<reversed>(ptr[4])), key + 16);
    store<false>(setup_mix2(load<reversed>(ptr[5])), key + 20);

    return true;
}

template <bool reversed>
static bool aes192_detect_decB(const uint32_t* ctx, uint8_t* key)
{
    uint32_t tmp[12];

    tmp[0] = load<reversed>(ctx[48]);
    tmp[1] = load<reversed>(ctx[49]);
    tmp[2] = load<reversed>(ctx[50]);
    tmp[3] = load<reversed>(ctx[51]);

    //

    tmp[4] = setup_mix2(load<reversed>(ctx[44]));
    tmp[5] = setup_mix2(load<reversed>(ctx[45]));

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[0];
    if (tmp[6] != setup_mix2(load<reversed>(ctx[46]))) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != setup_mix2(load<reversed>(ctx[47]))) return false;

    //

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != setup_mix2(load<reversed>(ctx[40]))) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != setup_mix2(load<reversed>(ctx[41]))) return false;

    tmp[10] = tmp[4] ^ tmp[9];
    if (tmp[10] != setup_mix2(load<reversed>(ctx[42]))) return false;

    tmp[11] = tmp[5] ^ tmp[10];
    if (tmp[11] != setup_mix2(load<reversed>(ctx[43]))) return false;

    for (int k = 0; k < 6; k++)
    {
        tmp[k] = tmp[6 + k];
    }

    //

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[1];
    if (tmp[6] != setup_mix2(load<reversed>(ctx[36]))) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != setup_mix2(load<reversed>(ctx[37]))) return false;

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != setup_mix2(load<reversed>(ctx[38]))) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != setup_mix2(load<reversed>(ctx[39]))) return false;

    //

    tmp[10] = tmp[4] ^ tmp[9];
    if (tmp[10] != setup_mix2(load<reversed>(ctx[32]))) return false;

    tmp[11] = tmp[5] ^ tmp[10];
    if (tmp[11] != setup_mix2(load<reversed>(ctx[33]))) return false;

    for (int k = 0; k < 6; k++)
    {
        tmp[k] = tmp[6 + k];
    }

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[2];
    if (tmp[6] != setup_mix2(load<reversed>(ctx[34]))) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != setup_mix2(load<reversed>(ctx[35]))) return false;

    //

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != setup_mix2(load<reversed>(ctx[28]))) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != setup_mix2(load<reversed>(ctx[29]))) return false;

    tmp[10] = tmp[4] ^ tmp[9];
    if (tmp[10] != setup_mix2(load<reversed>(ctx[30]))) return false;

    tmp[11] = tmp[5] ^ tmp[10];
    if (tmp[11] != setup_mix2(load<reversed>(ctx[31]))) return false;

    for (int k = 0; k < 6; k++)
    {
        tmp[k] = tmp[6 + k];
    }

    //

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[3];
    if (tmp[6] != setup_mix2(load<reversed>(ctx[24]))) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != setup_mix2(load<reversed>(ctx[25]))) return false;

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != setup_mix2(load<reversed>(ctx[26]))) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != setup_mix2(load<reversed>(ctx[27]))) return false;

    //

    tmp[10] = tmp[4] ^ tmp[9];
    if (tmp[10] != setup_mix2(load<reversed>(ctx[20]))) return false;

    tmp[11] = tmp[5] ^ tmp[10];
    if (tmp[11] != setup_mix2(load<reversed>(ctx[21]))) return false;

    for (int k = 0; k < 6; k++)
    {
        tmp[k] = tmp[6 + k];
    }

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[4];
    if (tmp[6] != setup_mix2(load<reversed>(ctx[22]))) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != setup_mix2(load<reversed>(ctx[23]))) return false;

    //

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != setup_mix2(load<reversed>(ctx[16]))) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != setup_mix2(load<reversed>(ctx[17]))) return false;

    tmp[10] = tmp[4] ^ tmp[9];
    if (tmp[10] != setup_mix2(load<reversed>(ctx[18]))) return false;

    tmp[11] = tmp[5] ^ tmp[10];
    if (tmp[11] != setup_mix2(load<reversed>(ctx[19]))) return false;

    for (int k = 0; k < 6; k++)
    {
        tmp[k] = tmp[6 + k];
    }

    //

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[5];
    if (tmp[6] != setup_mix2(load<reversed>(ctx[12]))) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != setup_mix2(load<reversed>(ctx[13]))) return false;

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != setup_mix2(load<reversed>(ctx[14]))) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != setup_mix2(load<reversed>(ctx[15]))) return false;

    //

    tmp[10] = tmp[4] ^ tmp[9];
    if (tmp[10] != setup_mix2(load<reversed>(ctx[8]))) return false;

    tmp[11] = tmp[5] ^ tmp[10];
    if (tmp[11] != setup_mix2(load<reversed>(ctx[9]))) return false;

    for (int k = 0; k < 6; k++)
    {
        tmp[k] = tmp[6 + k];
    }

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[6];
    if (tmp[6] != setup_mix2(load<reversed>(ctx[10]))) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != setup_mix2(load<reversed>(ctx[11]))) return false;

    //

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != setup_mix2(load<reversed>(ctx[4]))) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != setup_mix2(load<reversed>(ctx[5]))) return false;

    tmp[10] = tmp[4] ^ tmp[9];
    if (tmp[10] != setup_mix2(load<reversed>(ctx[6]))) return false;

    tmp[11] = tmp[5] ^ tmp[10];
    if (tmp[11] != setup_mix2(load<reversed>(ctx[7]))) return false;

    for (int k = 0; k < 6; k++)
    {
        tmp[k] = tmp[6 + k];
    }

    //

    tmp[6] = tmp[0] ^ setup_mix(tmp[5]) ^ rcon[7];
    if (tmp[6] != load<reversed>(ctx[0])) return false;

    tmp[7] = tmp[1] ^ tmp[6];
    if (tmp[7] != load<reversed>(ctx[1])) return false;

    tmp[8] = tmp[2] ^ tmp[7];
    if (tmp[8] != load<reversed>(ctx[2])) return false;

    tmp[9] = tmp[3] ^ tmp[8];
    if (tmp[9] != load<reversed>(ctx[3])) return false;

    store<false>(load<reversed>(ctx[48]), key + 0);
    store<false>(load<reversed>(ctx[49]), key + 4);
    store<false>(load<reversed>(ctx[50]), key + 8);
    store<false>(load<reversed>(ctx[51]), key + 12);
    store<false>(setup_mix2(load<reversed>(ctx[44])), key + 16);
    store<false>(setup_mix2(load<reversed>(ctx[45])), key + 20);

    return true;
}

template <bool reversed>
static bool aes256_detect_decF(const uint32_t* ctx, uint8_t* key)
{
    const uint32_t* ptr = ctx;

    uint32_t tmp[16];
    tmp[0] = load<reversed>(ctx[0]);
    tmp[1] = load<reversed>(ctx[1]);
    tmp[2] = load<reversed>(ctx[2]);
    tmp[3] = load<reversed>(ctx[3]);
    tmp[4] = setup_mix2(load<reversed>(ctx[4]));
    tmp[5] = setup_mix2(load<reversed>(ctx[5]));
    tmp[6] = setup_mix2(load<reversed>(ctx[6]));
    tmp[7] = setup_mix2(load<reversed>(ctx[7]));

    for (int i = 0; ctx += 8, i < 6; i++)
    {
        tmp[8] = tmp[0] ^ setup_mix(tmp[7]) ^ rcon[i];
        if (tmp[8] != setup_mix2(load<reversed>(ctx[0]))) return false;

        tmp[9] = tmp[1] ^ tmp[8];
        if (tmp[9] != setup_mix2(load<reversed>(ctx[1]))) return false;

        tmp[10] = tmp[2] ^ tmp[9];
        if (tmp[10] != setup_mix2(load<reversed>(ctx[2]))) return false;

        tmp[11] = tmp[3] ^ tmp[10];
        if (tmp[11] != setup_mix2(load<reversed>(ctx[3]))) return false;

        tmp[12] = tmp[4] ^ setup_mix(rotr32(tmp[11], 8));
        if (tmp[12] != setup_mix2(load<reversed>(ctx[4]))) return false;

        tmp[13] = tmp[5] ^ tmp[12];
        if (tmp[13] != setup_mix2(load<reversed>(ctx[5]))) return false;

        tmp[14] = tmp[6] ^ tmp[13];
        if (tmp[14] != setup_mix2(load<reversed>(ctx[6]))) return false;

        tmp[15] = tmp[7] ^ tmp[14];
        if (tmp[15] != setup_mix2(load<reversed>(ctx[7]))) return false;

        for (int k = 0; k < 8; k++)
        {
            tmp[k] = tmp[8 + k];
        }
    }

    tmp[8] = tmp[0] ^ setup_mix(tmp[7]) ^ rcon[6];
    if (tmp[8] != load<reversed>(ctx[0])) return false;

    tmp[9] = tmp[1] ^ tmp[8];
    if (tmp[9] != load<reversed>(ctx[1])) return false;

    tmp[10] = tmp[2] ^ tmp[9];
    if (tmp[10] != load<reversed>(ctx[2])) return false;

    tmp[11] = tmp[3] ^ tmp[10];
    if (tmp[11] != load<reversed>(ctx[3])) return false;

    store<false>(load<reversed>(ptr[0]), key + 0);
    store<false>(load<reversed>(ptr[1]), key + 4);
    store<false>(load<reversed>(ptr[2]), key + 8);
    store<false>(load<reversed>(ptr[3]), key + 12);
    store<false>(setup_mix2(load<reversed>(ptr[4])), key + 16);
    store<false>(setup_mix2(load<reversed>(ptr[5])), key + 20);
    store<false>(setup_mix2(load<reversed>(ptr[6])), key + 24);
    store<false>(setup_mix2(load<reversed>(ptr[7])), key + 28);

    return true;
}

template <bool reversed>
static bool aes256_detect_decB(const uint32_t* ctx, uint8_t* key)
{
    uint32_t tmp[16];
    tmp[0] = load<reversed>(ctx[56]);
    tmp[1] = load<reversed>(ctx[57]);
    tmp[2] = load<reversed>(ctx[58]);
    tmp[3] = load<reversed>(ctx[59]);
    tmp[4] = setup_mix2(load<reversed>(ctx[52]));
    tmp[5] = setup_mix2(load<reversed>(ctx[53]));
    tmp[6] = setup_mix2(load<reversed>(ctx[54]));
    tmp[7] = setup_mix2(load<reversed>(ctx[55]));

    for (int i = 0; i < 6; i++)
    {
        tmp[8] = tmp[0] ^ setup_mix(tmp[7]) ^ rcon[i];
        if (tmp[8] != setup_mix2(load<reversed>(ctx[48 - 8 * i]))) return false;

        tmp[9] = tmp[1] ^ tmp[8];
        if (tmp[9] != setup_mix2(load<reversed>(ctx[49 - 8 * i]))) return false;

        tmp[10] = tmp[2] ^ tmp[9];
        if (tmp[10] != setup_mix2(load<reversed>(ctx[50 - 8 * i]))) return false;

        tmp[11] = tmp[3] ^ tmp[10];
        if (tmp[11] != setup_mix2(load<reversed>(ctx[51 - 8 * i]))) return false;

        tmp[12] = tmp[4] ^ setup_mix(rotr32(tmp[11], 8));
        if (tmp[12] != setup_mix2(load<reversed>(ctx[44 - 8 * i]))) return false;

        tmp[13] = tmp[5] ^ tmp[12];
        if (tmp[13] != setup_mix2(load<reversed>(ctx[45 - 8 * i]))) return false;

        tmp[14] = tmp[6] ^ tmp[13];
        if (tmp[14] != setup_mix2(load<reversed>(ctx[46 - 8 * i]))) return false;

        tmp[15] = tmp[7] ^ tmp[14];
        if (tmp[15] != setup_mix2(load<reversed>(ctx[47 - 8 * i]))) return false;

        for (int k = 0; k < 8; k++)
        {
            tmp[k] = tmp[8 + k];
        }
    }

    tmp[8] = tmp[0] ^ setup_mix(tmp[7]) ^ rcon[6];
    if (tmp[8] != load<reversed>(ctx[0])) return false;

    tmp[9] = tmp[1] ^ tmp[8];
    if (tmp[9] != load<reversed>(ctx[1])) return false;

    tmp[10] = tmp[2] ^ tmp[9];
    if (tmp[10] != load<reversed>(ctx[2])) return false;

    tmp[11] = tmp[3] ^ tmp[10];
    if (tmp[11] != load<reversed>(ctx[3])) return false;

    store<false>(load<reversed>(ctx[56]), key + 0);
    store<false>(load<reversed>(ctx[57]), key + 4);
    store<false>(load<reversed>(ctx[58]), key + 8);
    store<false>(load<reversed>(ctx[59]), key + 12);
    store<false>(setup_mix2(load<reversed>(ctx[52])), key + 16);
    store<false>(setup_mix2(load<reversed>(ctx[53])), key + 20);
    store<false>(setup_mix2(load<reversed>(ctx[54])), key + 24);
    store<false>(setup_mix2(load<reversed>(ctx[55])), key + 28);

    return true;
}

template <bool reversed>
static int aes_detect_dec(const uint32_t* ctx, uint8_t* key)
{
    if (aes128_detect_decF<reversed>(ctx, key) || aes128_detect_decB<reversed>(ctx, key))
    {
        return 16;
    }

    if (aes192_detect_decF<reversed>(ctx, key) || aes192_detect_decB<reversed>(ctx, key))
    {
        return 24;
    }

    if (aes256_detect_decF<reversed>(ctx, key) || aes256_detect_decB<reversed>(ctx, key))
    {
        return 32;
    }

    return 0;
}

static int aes_detect_dec(const uint32_t* ctx, uint8_t* key)
{
    if (int len = aes_detect_dec<true>(ctx, key))
    {
        return len;
    }

    if (int len = aes_detect_dec<false>(ctx, key))
    {
        return len;
    }

    return 0;
}

int find_keys(duint Start, duint End)
{
	// Counter
	int keysFound = 0;

	// Get a copy of the virtual memory
	uint64_t total = End - Start;
	uint8_t *buffer = (uint8_t *)malloc(total);

	// Read the remote memory into the local buffer
	if (!DbgMemRead(Start, buffer, total))
		memset(buffer, 0, total);

	uint64_t avail = total;
	uint64_t addr = Start;
	uint32_t offset = 0;

	if (avail >= 60)
	{
		while (offset <= avail - 60)
		{
			uint8_t key[32];
			if (int len = aes_detect_enc((const uint32_t*)&buffer[offset], key))
			{
				dprintf("[%p] Found AES-%d encryption key: ", (void*)addr, len * 8);
				for (int i = 0; i < len; i++)
				{
					dprintf("%02x", key[i]);
				}
				dprintf("\n");

				offset += 28 + len;
				addr += 28 + len;
				keysFound++;
			}
			else if (int len = aes_detect_dec((const uint32_t*)&buffer[offset], key))
			{
				dprintf("[%p] Found AES-%d decryption key: ", (void*)addr, len * 8);
				for (int i = 0; i < len; i++)
				{
					dprintf("%02x", key[i]);
				}
				dprintf("\n");

				offset += 28 + len;
				addr += 28 + len;
				keysFound++;
			}
			else
			{
				offset += 4;
				addr += 4;
			}
		}

		avail -= offset;
	}

	// Free buffer
	free(buffer);

	return keysFound;
}

void AESFinderScanRange(duint Start, duint End)
{
	dprintf("Starting an AES key scan of range %p to %p...\n", Start, End);
	int keyCount = find_keys(Start, End);
	dprintf("Found %d possible AES encryption or decryption keys.\n", keyCount);
}

void AESFinderScanModule()
{
	duint moduleStart = DbgGetCurrentModule();
	duint moduleEnd = moduleStart + DbgFunctions()->ModSizeFromAddr(moduleStart);

	AESFinderScanRange(moduleStart, moduleEnd);
}

void AESFinderScanAll()
{
	// Performance counting
	clock_t startTime	= clock();
	duint totalSize		= 0;
	int totalKeys		= 0;

	dprintf("Starting an AES key scan for all memory ranges...\n");

	DbgEnumMemoryRanges([&](duint Start, duint End)
	{
		// Increment number of bytes read
		totalSize += (End - Start);

		// Run scan
		totalKeys += find_keys(Start, End);
		return true;
	});

	// Number of keys found
	dprintf("Found %d possible AES encryption or decryption keys.\n", totalKeys);

	// Tell the user how long it took
	clock_t endTime = clock();
	double time = double(endTime - startTime) / CLOCKS_PER_SEC;
	const double MB = 1024.0 * 1024.0;
	dprintf("Processed %.2f MB, speed = %.2f MB/s.\n", totalSize / MB, totalSize / MB / time);
}

#include "aes-finder-test.h"
void Plugin_AESFinderLogo()
{
	dprintf("---- AES-Finder ----\n");
	dprintf("Executing self test...\n");
	self_test();
	dprintf("Available cipher key checking:\n\t");
	dprintf("128, 192 and 256-bit keys\n");
}


================================================
File: src/aes-finder/aes-finder.h
================================================
#pragma once

#include "../idaldr/stdafx.h"

void AESFinderScanRange(duint Start, duint End);
void AESFinderScanModule();
void AESFinderScanAll();

void Plugin_AESFinderLogo();


================================================
File: src/findcrypt/consts.cpp
================================================
#include "findcrypt.h"

// Various constants used in crypto algorithms
// They were copied from public domain codes

//-----------------
static const unsigned int zinflate_lengthStarts[] = {
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};
static const unsigned int zinflate_lengthExtraBits[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
static const unsigned int zinflate_distanceStarts[] = {
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
static const unsigned int zinflate_distanceExtraBits[] = {
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};
//-----------------
static const unsigned int zdeflate_lengthCodes[] = {
        257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,
        269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,
        273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274,
        275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,
        277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,
        278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
        279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,
        280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,
        281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
        281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
        282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
        282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
        283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
        283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
        284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,
        284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};

//-----------------
static const word64 Whirlpool_C0[256] = {
        W64LIT(0x1818281878c0d878), W64LIT(0x23236523af0526af),
        W64LIT(0xc6c657c6f97eb8f9), W64LIT(0xe8e825e86f13fb6f),
        W64LIT(0x87879487a14ccba1), W64LIT(0xb8b8d5b862a91162),
        W64LIT(0x0101030105080905), W64LIT(0x4f4fd14f6e420d6e),
        W64LIT(0x36365a36eead9bee), W64LIT(0xa6a6f7a60459ff04),
        W64LIT(0xd2d26bd2bdde0cbd), W64LIT(0xf5f502f506fb0e06),
        W64LIT(0x79798b7980ef9680), W64LIT(0x6f6fb16fce5f30ce),
        W64LIT(0x9191ae91effc6def), W64LIT(0x5252f65207aaf807),
        W64LIT(0x6060a060fd2747fd), W64LIT(0xbcbcd9bc76893576),
        W64LIT(0x9b9bb09bcdac37cd), W64LIT(0x8e8e8f8e8c048a8c),
        W64LIT(0xa3a3f8a31571d215), W64LIT(0x0c0c140c3c606c3c),
        W64LIT(0x7b7b8d7b8aff848a), W64LIT(0x35355f35e1b580e1),
        W64LIT(0x1d1d271d69e8f569), W64LIT(0xe0e03de04753b347),
        W64LIT(0xd7d764d7acf621ac), W64LIT(0xc2c25bc2ed5e9ced),
        W64LIT(0x2e2e722e966d4396), W64LIT(0x4b4bdd4b7a62297a),
        W64LIT(0xfefe1ffe21a35d21), W64LIT(0x5757f9571682d516),
        W64LIT(0x15153f1541a8bd41), W64LIT(0x77779977b69fe8b6),
        W64LIT(0x37375937eba592eb), W64LIT(0xe5e532e5567b9e56),
        W64LIT(0x9f9fbc9fd98c13d9), W64LIT(0xf0f00df017d32317),
        W64LIT(0x4a4ade4a7f6a207f), W64LIT(0xdada73da959e4495),
        W64LIT(0x5858e85825faa225), W64LIT(0xc9c946c9ca06cfca),
        W64LIT(0x29297b298d557c8d), W64LIT(0x0a0a1e0a22505a22),
        W64LIT(0xb1b1ceb14fe1504f), W64LIT(0xa0a0fda01a69c91a),
        W64LIT(0x6b6bbd6bda7f14da), W64LIT(0x85859285ab5cd9ab),
        W64LIT(0xbdbddabd73813c73), W64LIT(0x5d5de75d34d28f34),
        W64LIT(0x1010301050809050), W64LIT(0xf4f401f403f30703),
        W64LIT(0xcbcb40cbc016ddc0), W64LIT(0x3e3e423ec6edd3c6),
        W64LIT(0x05050f0511282d11), W64LIT(0x6767a967e61f78e6),
        W64LIT(0xe4e431e453739753), W64LIT(0x27276927bb2502bb),
        W64LIT(0x4141c34158327358), W64LIT(0x8b8b808b9d2ca79d),
        W64LIT(0xa7a7f4a70151f601), W64LIT(0x7d7d877d94cfb294),
        W64LIT(0x9595a295fbdc49fb), W64LIT(0xd8d875d89f8e569f),
        W64LIT(0xfbfb10fb308b7030), W64LIT(0xeeee2fee7123cd71),
        W64LIT(0x7c7c847c91c7bb91), W64LIT(0x6666aa66e31771e3),
        W64LIT(0xdddd7add8ea67b8e), W64LIT(0x171739174bb8af4b),
        W64LIT(0x4747c94746024546), W64LIT(0x9e9ebf9edc841adc),
        W64LIT(0xcaca43cac51ed4c5), W64LIT(0x2d2d772d99755899),
        W64LIT(0xbfbfdcbf79912e79), W64LIT(0x070709071b383f1b),
        W64LIT(0xadadeaad2301ac23), W64LIT(0x5a5aee5a2feab02f),
        W64LIT(0x83839883b56cefb5), W64LIT(0x33335533ff85b6ff),
        W64LIT(0x6363a563f23f5cf2), W64LIT(0x020206020a10120a),
        W64LIT(0xaaaae3aa38399338), W64LIT(0x71719371a8afdea8),
        W64LIT(0xc8c845c8cf0ec6cf), W64LIT(0x19192b197dc8d17d),
        W64LIT(0x4949db4970723b70), W64LIT(0xd9d976d99a865f9a),
        W64LIT(0xf2f20bf21dc3311d), W64LIT(0xe3e338e3484ba848),
        W64LIT(0x5b5bed5b2ae2b92a), W64LIT(0x888885889234bc92),
        W64LIT(0x9a9ab39ac8a43ec8), W64LIT(0x26266a26be2d0bbe),
        W64LIT(0x32325632fa8dbffa), W64LIT(0xb0b0cdb04ae9594a),
        W64LIT(0xe9e926e96a1bf26a), W64LIT(0x0f0f110f33787733),
        W64LIT(0xd5d562d5a6e633a6), W64LIT(0x80809d80ba74f4ba),
        W64LIT(0xbebedfbe7c99277c), W64LIT(0xcdcd4acdde26ebde),
        W64LIT(0x34345c34e4bd89e4), W64LIT(0x4848d848757a3275),
        W64LIT(0xffff1cff24ab5424), W64LIT(0x7a7a8e7a8ff78d8f),
        W64LIT(0x9090ad90eaf464ea), W64LIT(0x5f5fe15f3ec29d3e),
        W64LIT(0x20206020a01d3da0), W64LIT(0x6868b868d5670fd5),
        W64LIT(0x1a1a2e1a72d0ca72), W64LIT(0xaeaeefae2c19b72c),
        W64LIT(0xb4b4c1b45ec97d5e), W64LIT(0x5454fc54199ace19),
        W64LIT(0x9393a893e5ec7fe5), W64LIT(0x22226622aa0d2faa),
        W64LIT(0x6464ac64e90763e9), W64LIT(0xf1f10ef112db2a12),
        W64LIT(0x73739573a2bfcca2), W64LIT(0x121236125a90825a),
        W64LIT(0x4040c0405d3a7a5d), W64LIT(0x0808180828404828),
        W64LIT(0xc3c358c3e85695e8), W64LIT(0xecec29ec7b33df7b),
        W64LIT(0xdbdb70db90964d90), W64LIT(0xa1a1fea11f61c01f),
        W64LIT(0x8d8d8a8d831c9183), W64LIT(0x3d3d473dc9f5c8c9),
        W64LIT(0x9797a497f1cc5bf1), W64LIT(0x0000000000000000),
        W64LIT(0xcfcf4ccfd436f9d4), W64LIT(0x2b2b7d2b87456e87),
        W64LIT(0x76769a76b397e1b3), W64LIT(0x82829b82b064e6b0),
        W64LIT(0xd6d667d6a9fe28a9), W64LIT(0x1b1b2d1b77d8c377),
        W64LIT(0xb5b5c2b55bc1745b), W64LIT(0xafafecaf2911be29),
        W64LIT(0x6a6abe6adf771ddf), W64LIT(0x5050f0500dbaea0d),
        W64LIT(0x4545cf454c12574c), W64LIT(0xf3f308f318cb3818),
        W64LIT(0x30305030f09dadf0), W64LIT(0xefef2cef742bc474),
        W64LIT(0x3f3f413fc3e5dac3), W64LIT(0x5555ff551c92c71c),
        W64LIT(0xa2a2fba21079db10), W64LIT(0xeaea23ea6503e965),
        W64LIT(0x6565af65ec0f6aec), W64LIT(0xbabad3ba68b90368),
        W64LIT(0x2f2f712f93654a93), W64LIT(0xc0c05dc0e74e8ee7),
        W64LIT(0xdede7fde81be6081), W64LIT(0x1c1c241c6ce0fc6c),
        W64LIT(0xfdfd1afd2ebb462e), W64LIT(0x4d4dd74d64521f64),
        W64LIT(0x9292ab92e0e476e0), W64LIT(0x75759f75bc8ffabc),
        W64LIT(0x06060a061e30361e), W64LIT(0x8a8a838a9824ae98),
        W64LIT(0xb2b2cbb240f94b40), W64LIT(0xe6e637e659638559),
        W64LIT(0x0e0e120e36707e36), W64LIT(0x1f1f211f63f8e763),
        W64LIT(0x6262a662f73755f7), W64LIT(0xd4d461d4a3ee3aa3),
        W64LIT(0xa8a8e5a832298132), W64LIT(0x9696a796f4c452f4),
        W64LIT(0xf9f916f93a9b623a), W64LIT(0xc5c552c5f666a3f6),
        W64LIT(0x25256f25b13510b1), W64LIT(0x5959eb5920f2ab20),
        W64LIT(0x84849184ae54d0ae), W64LIT(0x72729672a7b7c5a7),
        W64LIT(0x39394b39ddd5ecdd), W64LIT(0x4c4cd44c615a1661),
        W64LIT(0x5e5ee25e3bca943b), W64LIT(0x7878887885e79f85),
        W64LIT(0x38384838d8dde5d8), W64LIT(0x8c8c898c86149886),
        W64LIT(0xd1d16ed1b2c617b2), W64LIT(0xa5a5f2a50b41e40b),
        W64LIT(0xe2e23be24d43a14d), W64LIT(0x6161a361f82f4ef8),
        W64LIT(0xb3b3c8b345f14245), W64LIT(0x21216321a51534a5),
        W64LIT(0x9c9cb99cd69408d6), W64LIT(0x1e1e221e66f0ee66),
        W64LIT(0x4343c54352226152), W64LIT(0xc7c754c7fc76b1fc),
        W64LIT(0xfcfc19fc2bb34f2b), W64LIT(0x04040c0414202414),
        W64LIT(0x5151f35108b2e308), W64LIT(0x9999b699c7bc25c7),
        W64LIT(0x6d6db76dc44f22c4), W64LIT(0x0d0d170d39686539),
        W64LIT(0xfafa13fa35837935), W64LIT(0xdfdf7cdf84b66984),
        W64LIT(0x7e7e827e9bd7a99b), W64LIT(0x24246c24b43d19b4),
        W64LIT(0x3b3b4d3bd7c5fed7), W64LIT(0xababe0ab3d319a3d),
        W64LIT(0xcece4fced13ef0d1), W64LIT(0x1111331155889955),
        W64LIT(0x8f8f8c8f890c8389), W64LIT(0x4e4ed24e6b4a046b),
        W64LIT(0xb7b7c4b751d16651), W64LIT(0xebeb20eb600be060),
        W64LIT(0x3c3c443cccfdc1cc), W64LIT(0x81819e81bf7cfdbf),
        W64LIT(0x9494a194fed440fe), W64LIT(0xf7f704f70ceb1c0c),
        W64LIT(0xb9b9d6b967a11867), W64LIT(0x131335135f988b5f),
        W64LIT(0x2c2c742c9c7d519c), W64LIT(0xd3d368d3b8d605b8),
        W64LIT(0xe7e734e75c6b8c5c), W64LIT(0x6e6eb26ecb5739cb),
        W64LIT(0xc4c451c4f36eaaf3), W64LIT(0x030305030f181b0f),
        W64LIT(0x5656fa56138adc13), W64LIT(0x4444cc44491a5e49),
        W64LIT(0x7f7f817f9edfa09e), W64LIT(0xa9a9e6a937218837),
        W64LIT(0x2a2a7e2a824d6782), W64LIT(0xbbbbd0bb6db10a6d),
        W64LIT(0xc1c15ec1e24687e2), W64LIT(0x5353f55302a2f102),
        W64LIT(0xdcdc79dc8bae728b), W64LIT(0x0b0b1d0b27585327),
        W64LIT(0x9d9dba9dd39c01d3), W64LIT(0x6c6cb46cc1472bc1),
        W64LIT(0x31315331f595a4f5), W64LIT(0x74749c74b987f3b9),
        W64LIT(0xf6f607f609e31509), W64LIT(0x4646ca46430a4c43),
        W64LIT(0xacace9ac2609a526), W64LIT(0x89898689973cb597),
        W64LIT(0x14143c1444a0b444), W64LIT(0xe1e13ee1425bba42),
        W64LIT(0x16163a164eb0a64e), W64LIT(0x3a3a4e3ad2cdf7d2),
        W64LIT(0x6969bb69d06f06d0), W64LIT(0x09091b092d48412d),
        W64LIT(0x70709070ada7d7ad), W64LIT(0xb6b6c7b654d96f54),
        W64LIT(0xd0d06dd0b7ce1eb7), W64LIT(0xeded2aed7e3bd67e),
        W64LIT(0xcccc49ccdb2ee2db), W64LIT(0x4242c642572a6857),
        W64LIT(0x9898b598c2b42cc2), W64LIT(0xa4a4f1a40e49ed0e),
        W64LIT(0x28287828885d7588), W64LIT(0x5c5ce45c31da8631),
        W64LIT(0xf8f815f83f936b3f), W64LIT(0x86869786a444c2a4),
};

static const word64 Whirlpool_C1[256] = {
        W64LIT(0x781818281878c0d8), W64LIT(0xaf23236523af0526),
        W64LIT(0xf9c6c657c6f97eb8), W64LIT(0x6fe8e825e86f13fb),
        W64LIT(0xa187879487a14ccb), W64LIT(0x62b8b8d5b862a911),
        W64LIT(0x0501010301050809), W64LIT(0x6e4f4fd14f6e420d),
        W64LIT(0xee36365a36eead9b), W64LIT(0x04a6a6f7a60459ff),
        W64LIT(0xbdd2d26bd2bdde0c), W64LIT(0x06f5f502f506fb0e),
        W64LIT(0x8079798b7980ef96), W64LIT(0xce6f6fb16fce5f30),
        W64LIT(0xef9191ae91effc6d), W64LIT(0x075252f65207aaf8),
        W64LIT(0xfd6060a060fd2747), W64LIT(0x76bcbcd9bc768935),
        W64LIT(0xcd9b9bb09bcdac37), W64LIT(0x8c8e8e8f8e8c048a),
        W64LIT(0x15a3a3f8a31571d2), W64LIT(0x3c0c0c140c3c606c),
        W64LIT(0x8a7b7b8d7b8aff84), W64LIT(0xe135355f35e1b580),
        W64LIT(0x691d1d271d69e8f5), W64LIT(0x47e0e03de04753b3),
        W64LIT(0xacd7d764d7acf621), W64LIT(0xedc2c25bc2ed5e9c),
        W64LIT(0x962e2e722e966d43), W64LIT(0x7a4b4bdd4b7a6229),
        W64LIT(0x21fefe1ffe21a35d), W64LIT(0x165757f9571682d5),
        W64LIT(0x4115153f1541a8bd), W64LIT(0xb677779977b69fe8),
        W64LIT(0xeb37375937eba592), W64LIT(0x56e5e532e5567b9e),
        W64LIT(0xd99f9fbc9fd98c13), W64LIT(0x17f0f00df017d323),
        W64LIT(0x7f4a4ade4a7f6a20), W64LIT(0x95dada73da959e44),
        W64LIT(0x255858e85825faa2), W64LIT(0xcac9c946c9ca06cf),
        W64LIT(0x8d29297b298d557c), W64LIT(0x220a0a1e0a22505a),
        W64LIT(0x4fb1b1ceb14fe150), W64LIT(0x1aa0a0fda01a69c9),
        W64LIT(0xda6b6bbd6bda7f14), W64LIT(0xab85859285ab5cd9),
        W64LIT(0x73bdbddabd73813c), W64LIT(0x345d5de75d34d28f),
        W64LIT(0x5010103010508090), W64LIT(0x03f4f401f403f307),
        W64LIT(0xc0cbcb40cbc016dd), W64LIT(0xc63e3e423ec6edd3),
        W64LIT(0x1105050f0511282d), W64LIT(0xe66767a967e61f78),
        W64LIT(0x53e4e431e4537397), W64LIT(0xbb27276927bb2502),
        W64LIT(0x584141c341583273), W64LIT(0x9d8b8b808b9d2ca7),
        W64LIT(0x01a7a7f4a70151f6), W64LIT(0x947d7d877d94cfb2),
        W64LIT(0xfb9595a295fbdc49), W64LIT(0x9fd8d875d89f8e56),
        W64LIT(0x30fbfb10fb308b70), W64LIT(0x71eeee2fee7123cd),
        W64LIT(0x917c7c847c91c7bb), W64LIT(0xe36666aa66e31771),
        W64LIT(0x8edddd7add8ea67b), W64LIT(0x4b171739174bb8af),
        W64LIT(0x464747c947460245), W64LIT(0xdc9e9ebf9edc841a),
        W64LIT(0xc5caca43cac51ed4), W64LIT(0x992d2d772d997558),
        W64LIT(0x79bfbfdcbf79912e), W64LIT(0x1b070709071b383f),
        W64LIT(0x23adadeaad2301ac), W64LIT(0x2f5a5aee5a2feab0),
        W64LIT(0xb583839883b56cef), W64LIT(0xff33335533ff85b6),
        W64LIT(0xf26363a563f23f5c), W64LIT(0x0a020206020a1012),
        W64LIT(0x38aaaae3aa383993), W64LIT(0xa871719371a8afde),
        W64LIT(0xcfc8c845c8cf0ec6), W64LIT(0x7d19192b197dc8d1),
        W64LIT(0x704949db4970723b), W64LIT(0x9ad9d976d99a865f),
        W64LIT(0x1df2f20bf21dc331), W64LIT(0x48e3e338e3484ba8),
        W64LIT(0x2a5b5bed5b2ae2b9), W64LIT(0x92888885889234bc),
        W64LIT(0xc89a9ab39ac8a43e), W64LIT(0xbe26266a26be2d0b),
        W64LIT(0xfa32325632fa8dbf), W64LIT(0x4ab0b0cdb04ae959),
        W64LIT(0x6ae9e926e96a1bf2), W64LIT(0x330f0f110f337877),
        W64LIT(0xa6d5d562d5a6e633), W64LIT(0xba80809d80ba74f4),
        W64LIT(0x7cbebedfbe7c9927), W64LIT(0xdecdcd4acdde26eb),
        W64LIT(0xe434345c34e4bd89), W64LIT(0x754848d848757a32),
        W64LIT(0x24ffff1cff24ab54), W64LIT(0x8f7a7a8e7a8ff78d),
        W64LIT(0xea9090ad90eaf464), W64LIT(0x3e5f5fe15f3ec29d),
        W64LIT(0xa020206020a01d3d), W64LIT(0xd56868b868d5670f),
        W64LIT(0x721a1a2e1a72d0ca), W64LIT(0x2caeaeefae2c19b7),
        W64LIT(0x5eb4b4c1b45ec97d), W64LIT(0x195454fc54199ace),
        W64LIT(0xe59393a893e5ec7f), W64LIT(0xaa22226622aa0d2f),
        W64LIT(0xe96464ac64e90763), W64LIT(0x12f1f10ef112db2a),
        W64LIT(0xa273739573a2bfcc), W64LIT(0x5a121236125a9082),
        W64LIT(0x5d4040c0405d3a7a), W64LIT(0x2808081808284048),
        W64LIT(0xe8c3c358c3e85695), W64LIT(0x7becec29ec7b33df),
        W64LIT(0x90dbdb70db90964d), W64LIT(0x1fa1a1fea11f61c0),
        W64LIT(0x838d8d8a8d831c91), W64LIT(0xc93d3d473dc9f5c8),
        W64LIT(0xf19797a497f1cc5b), W64LIT(0x0000000000000000),
        W64LIT(0xd4cfcf4ccfd436f9), W64LIT(0x872b2b7d2b87456e),
        W64LIT(0xb376769a76b397e1), W64LIT(0xb082829b82b064e6),
        W64LIT(0xa9d6d667d6a9fe28), W64LIT(0x771b1b2d1b77d8c3),
        W64LIT(0x5bb5b5c2b55bc174), W64LIT(0x29afafecaf2911be),
        W64LIT(0xdf6a6abe6adf771d), W64LIT(0x0d5050f0500dbaea),
        W64LIT(0x4c4545cf454c1257), W64LIT(0x18f3f308f318cb38),
        W64LIT(0xf030305030f09dad), W64LIT(0x74efef2cef742bc4),
        W64LIT(0xc33f3f413fc3e5da), W64LIT(0x1c5555ff551c92c7),
        W64LIT(0x10a2a2fba21079db), W64LIT(0x65eaea23ea6503e9),
        W64LIT(0xec6565af65ec0f6a), W64LIT(0x68babad3ba68b903),
        W64LIT(0x932f2f712f93654a), W64LIT(0xe7c0c05dc0e74e8e),
        W64LIT(0x81dede7fde81be60), W64LIT(0x6c1c1c241c6ce0fc),
        W64LIT(0x2efdfd1afd2ebb46), W64LIT(0x644d4dd74d64521f),
        W64LIT(0xe09292ab92e0e476), W64LIT(0xbc75759f75bc8ffa),
        W64LIT(0x1e06060a061e3036), W64LIT(0x988a8a838a9824ae),
        W64LIT(0x40b2b2cbb240f94b), W64LIT(0x59e6e637e6596385),
        W64LIT(0x360e0e120e36707e), W64LIT(0x631f1f211f63f8e7),
        W64LIT(0xf76262a662f73755), W64LIT(0xa3d4d461d4a3ee3a),
        W64LIT(0x32a8a8e5a8322981), W64LIT(0xf49696a796f4c452),
        W64LIT(0x3af9f916f93a9b62), W64LIT(0xf6c5c552c5f666a3),
        W64LIT(0xb125256f25b13510), W64LIT(0x205959eb5920f2ab),
        W64LIT(0xae84849184ae54d0), W64LIT(0xa772729672a7b7c5),
        W64LIT(0xdd39394b39ddd5ec), W64LIT(0x614c4cd44c615a16),
        W64LIT(0x3b5e5ee25e3bca94), W64LIT(0x857878887885e79f),
        W64LIT(0xd838384838d8dde5), W64LIT(0x868c8c898c861498),
        W64LIT(0xb2d1d16ed1b2c617), W64LIT(0x0ba5a5f2a50b41e4),
        W64LIT(0x4de2e23be24d43a1), W64LIT(0xf86161a361f82f4e),
        W64LIT(0x45b3b3c8b345f142), W64LIT(0xa521216321a51534),
        W64LIT(0xd69c9cb99cd69408), W64LIT(0x661e1e221e66f0ee),
        W64LIT(0x524343c543522261), W64LIT(0xfcc7c754c7fc76b1),
        W64LIT(0x2bfcfc19fc2bb34f), W64LIT(0x1404040c04142024),
        W64LIT(0x085151f35108b2e3), W64LIT(0xc79999b699c7bc25),
        W64LIT(0xc46d6db76dc44f22), W64LIT(0x390d0d170d396865),
        W64LIT(0x35fafa13fa358379), W64LIT(0x84dfdf7cdf84b669),
        W64LIT(0x9b7e7e827e9bd7a9), W64LIT(0xb424246c24b43d19),
        W64LIT(0xd73b3b4d3bd7c5fe), W64LIT(0x3dababe0ab3d319a),
        W64LIT(0xd1cece4fced13ef0), W64LIT(0x5511113311558899),
        W64LIT(0x898f8f8c8f890c83), W64LIT(0x6b4e4ed24e6b4a04),
        W64LIT(0x51b7b7c4b751d166), W64LIT(0x60ebeb20eb600be0),
        W64LIT(0xcc3c3c443cccfdc1), W64LIT(0xbf81819e81bf7cfd),
        W64LIT(0xfe9494a194fed440), W64LIT(0x0cf7f704f70ceb1c),
        W64LIT(0x67b9b9d6b967a118), W64LIT(0x5f131335135f988b),
        W64LIT(0x9c2c2c742c9c7d51), W64LIT(0xb8d3d368d3b8d605),
        W64LIT(0x5ce7e734e75c6b8c), W64LIT(0xcb6e6eb26ecb5739),
        W64LIT(0xf3c4c451c4f36eaa), W64LIT(0x0f030305030f181b),
        W64LIT(0x135656fa56138adc), W64LIT(0x494444cc44491a5e),
        W64LIT(0x9e7f7f817f9edfa0), W64LIT(0x37a9a9e6a9372188),
        W64LIT(0x822a2a7e2a824d67), W64LIT(0x6dbbbbd0bb6db10a),
        W64LIT(0xe2c1c15ec1e24687), W64LIT(0x025353f55302a2f1),
        W64LIT(0x8bdcdc79dc8bae72), W64LIT(0x270b0b1d0b275853),
        W64LIT(0xd39d9dba9dd39c01), W64LIT(0xc16c6cb46cc1472b),
        W64LIT(0xf531315331f595a4), W64LIT(0xb974749c74b987f3),
        W64LIT(0x09f6f607f609e315), W64LIT(0x434646ca46430a4c),
        W64LIT(0x26acace9ac2609a5), W64LIT(0x9789898689973cb5),
        W64LIT(0x4414143c1444a0b4), W64LIT(0x42e1e13ee1425bba),
        W64LIT(0x4e16163a164eb0a6), W64LIT(0xd23a3a4e3ad2cdf7),
        W64LIT(0xd06969bb69d06f06), W64LIT(0x2d09091b092d4841),
        W64LIT(0xad70709070ada7d7), W64LIT(0x54b6b6c7b654d96f),
        W64LIT(0xb7d0d06dd0b7ce1e), W64LIT(0x7eeded2aed7e3bd6),
        W64LIT(0xdbcccc49ccdb2ee2), W64LIT(0x574242c642572a68),
        W64LIT(0xc29898b598c2b42c), W64LIT(0x0ea4a4f1a40e49ed),
        W64LIT(0x8828287828885d75), W64LIT(0x315c5ce45c31da86),
        W64LIT(0x3ff8f815f83f936b), W64LIT(0xa486869786a444c2),
};

static const word64 Whirlpool_C2[256] = {
        W64LIT(0xd8781818281878c0), W64LIT(0x26af23236523af05),
        W64LIT(0xb8f9c6c657c6f97e), W64LIT(0xfb6fe8e825e86f13),
        W64LIT(0xcba187879487a14c), W64LIT(0x1162b8b8d5b862a9),
        W64LIT(0x0905010103010508), W64LIT(0x0d6e4f4fd14f6e42),
        W64LIT(0x9bee36365a36eead), W64LIT(0xff04a6a6f7a60459),
        W64LIT(0x0cbdd2d26bd2bdde), W64LIT(0x0e06f5f502f506fb),
        W64LIT(0x968079798b7980ef), W64LIT(0x30ce6f6fb16fce5f),
        W64LIT(0x6def9191ae91effc), W64LIT(0xf8075252f65207aa),
        W64LIT(0x47fd6060a060fd27), W64LIT(0x3576bcbcd9bc7689),
        W64LIT(0x37cd9b9bb09bcdac), W64LIT(0x8a8c8e8e8f8e8c04),
        W64LIT(0xd215a3a3f8a31571), W64LIT(0x6c3c0c0c140c3c60),
        W64LIT(0x848a7b7b8d7b8aff), W64LIT(0x80e135355f35e1b5),
        W64LIT(0xf5691d1d271d69e8), W64LIT(0xb347e0e03de04753),
        W64LIT(0x21acd7d764d7acf6), W64LIT(0x9cedc2c25bc2ed5e),
        W64LIT(0x43962e2e722e966d), W64LIT(0x297a4b4bdd4b7a62),
        W64LIT(0x5d21fefe1ffe21a3), W64LIT(0xd5165757f9571682),
        W64LIT(0xbd4115153f1541a8), W64LIT(0xe8b677779977b69f),
        W64LIT(0x92eb37375937eba5), W64LIT(0x9e56e5e532e5567b),
        W64LIT(0x13d99f9fbc9fd98c), W64LIT(0x2317f0f00df017d3),
        W64LIT(0x207f4a4ade4a7f6a), W64LIT(0x4495dada73da959e),
        W64LIT(0xa2255858e85825fa), W64LIT(0xcfcac9c946c9ca06),
        W64LIT(0x7c8d29297b298d55), W64LIT(0x5a220a0a1e0a2250),
        W64LIT(0x504fb1b1ceb14fe1), W64LIT(0xc91aa0a0fda01a69),
        W64LIT(0x14da6b6bbd6bda7f), W64LIT(0xd9ab85859285ab5c),
        W64LIT(0x3c73bdbddabd7381), W64LIT(0x8f345d5de75d34d2),
        W64LIT(0x9050101030105080), W64LIT(0x0703f4f401f403f3),
        W64LIT(0xddc0cbcb40cbc016), W64LIT(0xd3c63e3e423ec6ed),
        W64LIT(0x2d1105050f051128), W64LIT(0x78e66767a967e61f),
        W64LIT(0x9753e4e431e45373), W64LIT(0x02bb27276927bb25),
        W64LIT(0x73584141c3415832), W64LIT(0xa79d8b8b808b9d2c),
        W64LIT(0xf601a7a7f4a70151), W64LIT(0xb2947d7d877d94cf),
        W64LIT(0x49fb9595a295fbdc), W64LIT(0x569fd8d875d89f8e),
        W64LIT(0x7030fbfb10fb308b), W64LIT(0xcd71eeee2fee7123),
        W64LIT(0xbb917c7c847c91c7), W64LIT(0x71e36666aa66e317),
        W64LIT(0x7b8edddd7add8ea6), W64LIT(0xaf4b171739174bb8),
        W64LIT(0x45464747c9474602), W64LIT(0x1adc9e9ebf9edc84),
        W64LIT(0xd4c5caca43cac51e), W64LIT(0x58992d2d772d9975),
        W64LIT(0x2e79bfbfdcbf7991), W64LIT(0x3f1b070709071b38),
        W64LIT(0xac23adadeaad2301), W64LIT(0xb02f5a5aee5a2fea),
        W64LIT(0xefb583839883b56c), W64LIT(0xb6ff33335533ff85),
        W64LIT(0x5cf26363a563f23f), W64LIT(0x120a020206020a10),
        W64LIT(0x9338aaaae3aa3839), W64LIT(0xdea871719371a8af),
        W64LIT(0xc6cfc8c845c8cf0e), W64LIT(0xd17d19192b197dc8),
        W64LIT(0x3b704949db497072), W64LIT(0x5f9ad9d976d99a86),
        W64LIT(0x311df2f20bf21dc3), W64LIT(0xa848e3e338e3484b),
        W64LIT(0xb92a5b5bed5b2ae2), W64LIT(0xbc92888885889234),
        W64LIT(0x3ec89a9ab39ac8a4), W64LIT(0x0bbe26266a26be2d),
        W64LIT(0xbffa32325632fa8d), W64LIT(0x594ab0b0cdb04ae9),
        W64LIT(0xf26ae9e926e96a1b), W64LIT(0x77330f0f110f3378),
        W64LIT(0x33a6d5d562d5a6e6), W64LIT(0xf4ba80809d80ba74),
        W64LIT(0x277cbebedfbe7c99), W64LIT(0xebdecdcd4acdde26),
        W64LIT(0x89e434345c34e4bd), W64LIT(0x32754848d848757a),
        W64LIT(0x5424ffff1cff24ab), W64LIT(0x8d8f7a7a8e7a8ff7),
        W64LIT(0x64ea9090ad90eaf4), W64LIT(0x9d3e5f5fe15f3ec2),
        W64LIT(0x3da020206020a01d), W64LIT(0x0fd56868b868d567),
        W64LIT(0xca721a1a2e1a72d0), W64LIT(0xb72caeaeefae2c19),
        W64LIT(0x7d5eb4b4c1b45ec9), W64LIT(0xce195454fc54199a),
        W64LIT(0x7fe59393a893e5ec), W64LIT(0x2faa22226622aa0d),
        W64LIT(0x63e96464ac64e907), W64LIT(0x2a12f1f10ef112db),
        W64LIT(0xcca273739573a2bf), W64LIT(0x825a121236125a90),
        W64LIT(0x7a5d4040c0405d3a), W64LIT(0x4828080818082840),
        W64LIT(0x95e8c3c358c3e856), W64LIT(0xdf7becec29ec7b33),
        W64LIT(0x4d90dbdb70db9096), W64LIT(0xc01fa1a1fea11f61),
        W64LIT(0x91838d8d8a8d831c), W64LIT(0xc8c93d3d473dc9f5),
        W64LIT(0x5bf19797a497f1cc), W64LIT(0x0000000000000000),
        W64LIT(0xf9d4cfcf4ccfd436), W64LIT(0x6e872b2b7d2b8745),
        W64LIT(0xe1b376769a76b397), W64LIT(0xe6b082829b82b064),
        W64LIT(0x28a9d6d667d6a9fe), W64LIT(0xc3771b1b2d1b77d8),
        W64LIT(0x745bb5b5c2b55bc1), W64LIT(0xbe29afafecaf2911),
        W64LIT(0x1ddf6a6abe6adf77), W64LIT(0xea0d5050f0500dba),
        W64LIT(0x574c4545cf454c12), W64LIT(0x3818f3f308f318cb),
        W64LIT(0xadf030305030f09d), W64LIT(0xc474efef2cef742b),
        W64LIT(0xdac33f3f413fc3e5), W64LIT(0xc71c5555ff551c92),
        W64LIT(0xdb10a2a2fba21079), W64LIT(0xe965eaea23ea6503),
        W64LIT(0x6aec6565af65ec0f), W64LIT(0x0368babad3ba68b9),
        W64LIT(0x4a932f2f712f9365), W64LIT(0x8ee7c0c05dc0e74e),
        W64LIT(0x6081dede7fde81be), W64LIT(0xfc6c1c1c241c6ce0),
        W64LIT(0x462efdfd1afd2ebb), W64LIT(0x1f644d4dd74d6452),
        W64LIT(0x76e09292ab92e0e4), W64LIT(0xfabc75759f75bc8f),
        W64LIT(0x361e06060a061e30), W64LIT(0xae988a8a838a9824),
        W64LIT(0x4b40b2b2cbb240f9), W64LIT(0x8559e6e637e65963),
        W64LIT(0x7e360e0e120e3670), W64LIT(0xe7631f1f211f63f8),
        W64LIT(0x55f76262a662f737), W64LIT(0x3aa3d4d461d4a3ee),
        W64LIT(0x8132a8a8e5a83229), W64LIT(0x52f49696a796f4c4),
        W64LIT(0x623af9f916f93a9b), W64LIT(0xa3f6c5c552c5f666),
        W64LIT(0x10b125256f25b135), W64LIT(0xab205959eb5920f2),
        W64LIT(0xd0ae84849184ae54), W64LIT(0xc5a772729672a7b7),
        W64LIT(0xecdd39394b39ddd5), W64LIT(0x16614c4cd44c615a),
        W64LIT(0x943b5e5ee25e3bca), W64LIT(0x9f857878887885e7),
        W64LIT(0xe5d838384838d8dd), W64LIT(0x98868c8c898c8614),
        W64LIT(0x17b2d1d16ed1b2c6), W64LIT(0xe40ba5a5f2a50b41),
        W64LIT(0xa14de2e23be24d43), W64LIT(0x4ef86161a361f82f),
        W64LIT(0x4245b3b3c8b345f1), W64LIT(0x34a521216321a515),
        W64LIT(0x08d69c9cb99cd694), W64LIT(0xee661e1e221e66f0),
        W64LIT(0x61524343c5435222), W64LIT(0xb1fcc7c754c7fc76),
        W64LIT(0x4f2bfcfc19fc2bb3), W64LIT(0x241404040c041420),
        W64LIT(0xe3085151f35108b2), W64LIT(0x25c79999b699c7bc),
        W64LIT(0x22c46d6db76dc44f), W64LIT(0x65390d0d170d3968),
        W64LIT(0x7935fafa13fa3583), W64LIT(0x6984dfdf7cdf84b6),
        W64LIT(0xa99b7e7e827e9bd7), W64LIT(0x19b424246c24b43d),
        W64LIT(0xfed73b3b4d3bd7c5), W64LIT(0x9a3dababe0ab3d31),
        W64LIT(0xf0d1cece4fced13e), W64LIT(0x9955111133115588),
        W64LIT(0x83898f8f8c8f890c), W64LIT(0x046b4e4ed24e6b4a),
        W64LIT(0x6651b7b7c4b751d1), W64LIT(0xe060ebeb20eb600b),
        W64LIT(0xc1cc3c3c443cccfd), W64LIT(0xfdbf81819e81bf7c),
        W64LIT(0x40fe9494a194fed4), W64LIT(0x1c0cf7f704f70ceb),
        W64LIT(0x1867b9b9d6b967a1), W64LIT(0x8b5f131335135f98),
        W64LIT(0x519c2c2c742c9c7d), W64LIT(0x05b8d3d368d3b8d6),
        W64LIT(0x8c5ce7e734e75c6b), W64LIT(0x39cb6e6eb26ecb57),
        W64LIT(0xaaf3c4c451c4f36e), W64LIT(0x1b0f030305030f18),
        W64LIT(0xdc135656fa56138a), W64LIT(0x5e494444cc44491a),
        W64LIT(0xa09e7f7f817f9edf), W64LIT(0x8837a9a9e6a93721),
        W64LIT(0x67822a2a7e2a824d), W64LIT(0x0a6dbbbbd0bb6db1),
        W64LIT(0x87e2c1c15ec1e246), W64LIT(0xf1025353f55302a2),
        W64LIT(0x728bdcdc79dc8bae), W64LIT(0x53270b0b1d0b2758),
        W64LIT(0x01d39d9dba9dd39c), W64LIT(0x2bc16c6cb46cc147),
        W64LIT(0xa4f531315331f595), W64LIT(0xf3b974749c74b987),
        W64LIT(0x1509f6f607f609e3), W64LIT(0x4c434646ca46430a),
        W64LIT(0xa526acace9ac2609), W64LIT(0xb59789898689973c),
        W64LIT(0xb44414143c1444a0), W64LIT(0xba42e1e13ee1425b),
        W64LIT(0xa64e16163a164eb0), W64LIT(0xf7d23a3a4e3ad2cd),
        W64LIT(0x06d06969bb69d06f), W64LIT(0x412d09091b092d48),
        W64LIT(0xd7ad70709070ada7), W64LIT(0x6f54b6b6c7b654d9),
        W64LIT(0x1eb7d0d06dd0b7ce), W64LIT(0xd67eeded2aed7e3b),
        W64LIT(0xe2dbcccc49ccdb2e), W64LIT(0x68574242c642572a),
        W64LIT(0x2cc29898b598c2b4), W64LIT(0xed0ea4a4f1a40e49),
        W64LIT(0x758828287828885d), W64LIT(0x86315c5ce45c31da),
        W64LIT(0x6b3ff8f815f83f93), W64LIT(0xc2a486869786a444),
};

static const word64 Whirlpool_C3[256] = {
        W64LIT(0xc0d8781818281878), W64LIT(0x0526af23236523af),
        W64LIT(0x7eb8f9c6c657c6f9), W64LIT(0x13fb6fe8e825e86f),
        W64LIT(0x4ccba187879487a1), W64LIT(0xa91162b8b8d5b862),
        W64LIT(0x0809050101030105), W64LIT(0x420d6e4f4fd14f6e),
        W64LIT(0xad9bee36365a36ee), W64LIT(0x59ff04a6a6f7a604),
        W64LIT(0xde0cbdd2d26bd2bd), W64LIT(0xfb0e06f5f502f506),
        W64LIT(0xef968079798b7980), W64LIT(0x5f30ce6f6fb16fce),
        W64LIT(0xfc6def9191ae91ef), W64LIT(0xaaf8075252f65207),
        W64LIT(0x2747fd6060a060fd), W64LIT(0x893576bcbcd9bc76),
        W64LIT(0xac37cd9b9bb09bcd), W64LIT(0x048a8c8e8e8f8e8c),
        W64LIT(0x71d215a3a3f8a315), W64LIT(0x606c3c0c0c140c3c),
        W64LIT(0xff848a7b7b8d7b8a), W64LIT(0xb580e135355f35e1),
        W64LIT(0xe8f5691d1d271d69), W64LIT(0x53b347e0e03de047),
        W64LIT(0xf621acd7d764d7ac), W64LIT(0x5e9cedc2c25bc2ed),
        W64LIT(0x6d43962e2e722e96), W64LIT(0x62297a4b4bdd4b7a),
        W64LIT(0xa35d21fefe1ffe21), W64LIT(0x82d5165757f95716),
        W64LIT(0xa8bd4115153f1541), W64LIT(0x9fe8b677779977b6),
        W64LIT(0xa592eb37375937eb), W64LIT(0x7b9e56e5e532e556),
        W64LIT(0x8c13d99f9fbc9fd9), W64LIT(0xd32317f0f00df017),
        W64LIT(0x6a207f4a4ade4a7f), W64LIT(0x9e4495dada73da95),
        W64LIT(0xfaa2255858e85825), W64LIT(0x06cfcac9c946c9ca),
        W64LIT(0x557c8d29297b298d), W64LIT(0x505a220a0a1e0a22),
        W64LIT(0xe1504fb1b1ceb14f), W64LIT(0x69c91aa0a0fda01a),
        W64LIT(0x7f14da6b6bbd6bda), W64LIT(0x5cd9ab85859285ab),
        W64LIT(0x813c73bdbddabd73), W64LIT(0xd28f345d5de75d34),
        W64LIT(0x8090501010301050), W64LIT(0xf30703f4f401f403),
        W64LIT(0x16ddc0cbcb40cbc0), W64LIT(0xedd3c63e3e423ec6),
        W64LIT(0x282d1105050f0511), W64LIT(0x1f78e66767a967e6),
        W64LIT(0x739753e4e431e453), W64LIT(0x2502bb27276927bb),
        W64LIT(0x3273584141c34158), W64LIT(0x2ca79d8b8b808b9d),
        W64LIT(0x51f601a7a7f4a701), W64LIT(0xcfb2947d7d877d94),
        W64LIT(0xdc49fb9595a295fb), W64LIT(0x8e569fd8d875d89f),
        W64LIT(0x8b7030fbfb10fb30), W64LIT(0x23cd71eeee2fee71),
        W64LIT(0xc7bb917c7c847c91), W64LIT(0x1771e36666aa66e3),
        W64LIT(0xa67b8edddd7add8e), W64LIT(0xb8af4b171739174b),
        W64LIT(0x0245464747c94746), W64LIT(0x841adc9e9ebf9edc),
        W64LIT(0x1ed4c5caca43cac5), W64LIT(0x7558992d2d772d99),
        W64LIT(0x912e79bfbfdcbf79), W64LIT(0x383f1b070709071b),
        W64LIT(0x01ac23adadeaad23), W64LIT(0xeab02f5a5aee5a2f),
        W64LIT(0x6cefb583839883b5), W64LIT(0x85b6ff33335533ff),
        W64LIT(0x3f5cf26363a563f2), W64LIT(0x10120a020206020a),
        W64LIT(0x399338aaaae3aa38), W64LIT(0xafdea871719371a8),
        W64LIT(0x0ec6cfc8c845c8cf), W64LIT(0xc8d17d19192b197d),
        W64LIT(0x723b704949db4970), W64LIT(0x865f9ad9d976d99a),
        W64LIT(0xc3311df2f20bf21d), W64LIT(0x4ba848e3e338e348),
        W64LIT(0xe2b92a5b5bed5b2a), W64LIT(0x34bc928888858892),
        W64LIT(0xa43ec89a9ab39ac8), W64LIT(0x2d0bbe26266a26be),
        W64LIT(0x8dbffa32325632fa), W64LIT(0xe9594ab0b0cdb04a),
        W64LIT(0x1bf26ae9e926e96a), W64LIT(0x7877330f0f110f33),
        W64LIT(0xe633a6d5d562d5a6), W64LIT(0x74f4ba80809d80ba),
        W64LIT(0x99277cbebedfbe7c), W64LIT(0x26ebdecdcd4acdde),
        W64LIT(0xbd89e434345c34e4), W64LIT(0x7a32754848d84875),
        W64LIT(0xab5424ffff1cff24), W64LIT(0xf78d8f7a7a8e7a8f),
        W64LIT(0xf464ea9090ad90ea), W64LIT(0xc29d3e5f5fe15f3e),
        W64LIT(0x1d3da020206020a0), W64LIT(0x670fd56868b868d5),
        W64LIT(0xd0ca721a1a2e1a72), W64LIT(0x19b72caeaeefae2c),
        W64LIT(0xc97d5eb4b4c1b45e), W64LIT(0x9ace195454fc5419),
        W64LIT(0xec7fe59393a893e5), W64LIT(0x0d2faa22226622aa),
        W64LIT(0x0763e96464ac64e9), W64LIT(0xdb2a12f1f10ef112),
        W64LIT(0xbfcca273739573a2), W64LIT(0x90825a121236125a),
        W64LIT(0x3a7a5d4040c0405d), W64LIT(0x4048280808180828),
        W64LIT(0x5695e8c3c358c3e8), W64LIT(0x33df7becec29ec7b),
        W64LIT(0x964d90dbdb70db90), W64LIT(0x61c01fa1a1fea11f),
        W64LIT(0x1c91838d8d8a8d83), W64LIT(0xf5c8c93d3d473dc9),
        W64LIT(0xcc5bf19797a497f1), W64LIT(0x0000000000000000),
        W64LIT(0x36f9d4cfcf4ccfd4), W64LIT(0x456e872b2b7d2b87),
        W64LIT(0x97e1b376769a76b3), W64LIT(0x64e6b082829b82b0),
        W64LIT(0xfe28a9d6d667d6a9), W64LIT(0xd8c3771b1b2d1b77),
        W64LIT(0xc1745bb5b5c2b55b), W64LIT(0x11be29afafecaf29),
        W64LIT(0x771ddf6a6abe6adf), W64LIT(0xbaea0d5050f0500d),
        W64LIT(0x12574c4545cf454c), W64LIT(0xcb3818f3f308f318),
        W64LIT(0x9dadf030305030f0), W64LIT(0x2bc474efef2cef74),
        W64LIT(0xe5dac33f3f413fc3), W64LIT(0x92c71c5555ff551c),
        W64LIT(0x79db10a2a2fba210), W64LIT(0x03e965eaea23ea65),
        W64LIT(0x0f6aec6565af65ec), W64LIT(0xb90368babad3ba68),
        W64LIT(0x654a932f2f712f93), W64LIT(0x4e8ee7c0c05dc0e7),
        W64LIT(0xbe6081dede7fde81), W64LIT(0xe0fc6c1c1c241c6c),
        W64LIT(0xbb462efdfd1afd2e), W64LIT(0x521f644d4dd74d64),
        W64LIT(0xe476e09292ab92e0), W64LIT(0x8ffabc75759f75bc),
        W64LIT(0x30361e06060a061e), W64LIT(0x24ae988a8a838a98),
        W64LIT(0xf94b40b2b2cbb240), W64LIT(0x638559e6e637e659),
        W64LIT(0x707e360e0e120e36), W64LIT(0xf8e7631f1f211f63),
        W64LIT(0x3755f76262a662f7), W64LIT(0xee3aa3d4d461d4a3),
        W64LIT(0x298132a8a8e5a832), W64LIT(0xc452f49696a796f4),
        W64LIT(0x9b623af9f916f93a), W64LIT(0x66a3f6c5c552c5f6),
        W64LIT(0x3510b125256f25b1), W64LIT(0xf2ab205959eb5920),
        W64LIT(0x54d0ae84849184ae), W64LIT(0xb7c5a772729672a7),
        W64LIT(0xd5ecdd39394b39dd), W64LIT(0x5a16614c4cd44c61),
        W64LIT(0xca943b5e5ee25e3b), W64LIT(0xe79f857878887885),
        W64LIT(0xdde5d838384838d8), W64LIT(0x1498868c8c898c86),
        W64LIT(0xc617b2d1d16ed1b2), W64LIT(0x41e40ba5a5f2a50b),
        W64LIT(0x43a14de2e23be24d), W64LIT(0x2f4ef86161a361f8),
        W64LIT(0xf14245b3b3c8b345), W64LIT(0x1534a521216321a5),
        W64LIT(0x9408d69c9cb99cd6), W64LIT(0xf0ee661e1e221e66),
        W64LIT(0x2261524343c54352), W64LIT(0x76b1fcc7c754c7fc),
        W64LIT(0xb34f2bfcfc19fc2b), W64LIT(0x20241404040c0414),
        W64LIT(0xb2e3085151f35108), W64LIT(0xbc25c79999b699c7),
        W64LIT(0x4f22c46d6db76dc4), W64LIT(0x6865390d0d170d39),
        W64LIT(0x837935fafa13fa35), W64LIT(0xb66984dfdf7cdf84),
        W64LIT(0xd7a99b7e7e827e9b), W64LIT(0x3d19b424246c24b4),
        W64LIT(0xc5fed73b3b4d3bd7), W64LIT(0x319a3dababe0ab3d),
        W64LIT(0x3ef0d1cece4fced1), W64LIT(0x8899551111331155),
        W64LIT(0x0c83898f8f8c8f89), W64LIT(0x4a046b4e4ed24e6b),
        W64LIT(0xd16651b7b7c4b751), W64LIT(0x0be060ebeb20eb60),
        W64LIT(0xfdc1cc3c3c443ccc), W64LIT(0x7cfdbf81819e81bf),
        W64LIT(0xd440fe9494a194fe), W64LIT(0xeb1c0cf7f704f70c),
        W64LIT(0xa11867b9b9d6b967), W64LIT(0x988b5f131335135f),
        W64LIT(0x7d519c2c2c742c9c), W64LIT(0xd605b8d3d368d3b8),
        W64LIT(0x6b8c5ce7e734e75c), W64LIT(0x5739cb6e6eb26ecb),
        W64LIT(0x6eaaf3c4c451c4f3), W64LIT(0x181b0f030305030f),
        W64LIT(0x8adc135656fa5613), W64LIT(0x1a5e494444cc4449),
        W64LIT(0xdfa09e7f7f817f9e), W64LIT(0x218837a9a9e6a937),
        W64LIT(0x4d67822a2a7e2a82), W64LIT(0xb10a6dbbbbd0bb6d),
        W64LIT(0x4687e2c1c15ec1e2), W64LIT(0xa2f1025353f55302),
        W64LIT(0xae728bdcdc79dc8b), W64LIT(0x5853270b0b1d0b27),
        W64LIT(0x9c01d39d9dba9dd3), W64LIT(0x472bc16c6cb46cc1),
        W64LIT(0x95a4f531315331f5), W64LIT(0x87f3b974749c74b9),
        W64LIT(0xe31509f6f607f609), W64LIT(0x0a4c434646ca4643),
        W64LIT(0x09a526acace9ac26), W64LIT(0x3cb5978989868997),
        W64LIT(0xa0b44414143c1444), W64LIT(0x5bba42e1e13ee142),
        W64LIT(0xb0a64e16163a164e), W64LIT(0xcdf7d23a3a4e3ad2),
        W64LIT(0x6f06d06969bb69d0), W64LIT(0x48412d09091b092d),
        W64LIT(0xa7d7ad70709070ad), W64LIT(0xd96f54b6b6c7b654),
        W64LIT(0xce1eb7d0d06dd0b7), W64LIT(0x3bd67eeded2aed7e),
        W64LIT(0x2ee2dbcccc49ccdb), W64LIT(0x2a68574242c64257),
        W64LIT(0xb42cc29898b598c2), W64LIT(0x49ed0ea4a4f1a40e),
        W64LIT(0x5d75882828782888), W64LIT(0xda86315c5ce45c31),
        W64LIT(0x936b3ff8f815f83f), W64LIT(0x44c2a486869786a4),
};

static const word64 Whirlpool_rc[] = {
        W64LIT(0x1823c6e887b8014f),
        W64LIT(0x36a6d2f5796f9152),
        W64LIT(0x60bc9b8ea30c7b35),
        W64LIT(0x1de0d7c22e4bfe57),
        W64LIT(0x157737e59ff04ada),
        W64LIT(0x58c9290ab1a06b85),
        W64LIT(0xbd5d10f4cb3e0567),
        W64LIT(0xe427418ba77d95d8),
        W64LIT(0xfbee7c66dd17479e),
        W64LIT(0xca2dbf07ad5a8333)
};
//-----------------
static const long WAKE_tt[10]= {
        0x726a8f3bL,
        0xe69a3b5cL,
        0xd3c71fe5L,
        0xab3c73d2L,
        0x4d3a8eb3L,
        0x0396d6e8L,
        0x3d4c2f7aL,
        0x9ee27cf3L, } ;
//-----------------
static const word64 Tiger_table[4*256] =
{
        W64LIT(0x02AAB17CF7E90C5E)   /*    0 */,    W64LIT(0xAC424B03E243A8EC)   /*    1 */,
        W64LIT(0x72CD5BE30DD5FCD3)   /*    2 */,    W64LIT(0x6D019B93F6F97F3A)   /*    3 */,
        W64LIT(0xCD9978FFD21F9193)   /*    4 */,    W64LIT(0x7573A1C9708029E2)   /*    5 */,
        W64LIT(0xB164326B922A83C3)   /*    6 */,    W64LIT(0x46883EEE04915870)   /*    7 */,
        W64LIT(0xEAACE3057103ECE6)   /*    8 */,    W64LIT(0xC54169B808A3535C)   /*    9 */,
        W64LIT(0x4CE754918DDEC47C)   /*   10 */,    W64LIT(0x0AA2F4DFDC0DF40C)   /*   11 */,
        W64LIT(0x10B76F18A74DBEFA)   /*   12 */,    W64LIT(0xC6CCB6235AD1AB6A)   /*   13 */,
        W64LIT(0x13726121572FE2FF)   /*   14 */,    W64LIT(0x1A488C6F199D921E)   /*   15 */,
        W64LIT(0x4BC9F9F4DA0007CA)   /*   16 */,    W64LIT(0x26F5E6F6E85241C7)   /*   17 */,
        W64LIT(0x859079DBEA5947B6)   /*   18 */,    W64LIT(0x4F1885C5C99E8C92)   /*   19 */,
        W64LIT(0xD78E761EA96F864B)   /*   20 */,    W64LIT(0x8E36428C52B5C17D)   /*   21 */,
        W64LIT(0x69CF6827373063C1)   /*   22 */,    W64LIT(0xB607C93D9BB4C56E)   /*   23 */,
        W64LIT(0x7D820E760E76B5EA)   /*   24 */,    W64LIT(0x645C9CC6F07FDC42)   /*   25 */,
        W64LIT(0xBF38A078243342E0)   /*   26 */,    W64LIT(0x5F6B343C9D2E7D04)   /*   27 */,
        W64LIT(0xF2C28AEB600B0EC6)   /*   28 */,    W64LIT(0x6C0ED85F7254BCAC)   /*   29 */,
        W64LIT(0x71592281A4DB4FE5)   /*   30 */,    W64LIT(0x1967FA69CE0FED9F)   /*   31 */,
        W64LIT(0xFD5293F8B96545DB)   /*   32 */,    W64LIT(0xC879E9D7F2A7600B)   /*   33 */,
        W64LIT(0x860248920193194E)   /*   34 */,    W64LIT(0xA4F9533B2D9CC0B3)   /*   35 */,
        W64LIT(0x9053836C15957613)   /*   36 */,    W64LIT(0xDB6DCF8AFC357BF1)   /*   37 */,
        W64LIT(0x18BEEA7A7A370F57)   /*   38 */,    W64LIT(0x037117CA50B99066)   /*   39 */,
        W64LIT(0x6AB30A9774424A35)   /*   40 */,    W64LIT(0xF4E92F02E325249B)   /*   41 */,
        W64LIT(0x7739DB07061CCAE1)   /*   42 */,    W64LIT(0xD8F3B49CECA42A05)   /*   43 */,
        W64LIT(0xBD56BE3F51382F73)   /*   44 */,    W64LIT(0x45FAED5843B0BB28)   /*   45 */,
        W64LIT(0x1C813D5C11BF1F83)   /*   46 */,    W64LIT(0x8AF0E4B6D75FA169)   /*   47 */,
        W64LIT(0x33EE18A487AD9999)   /*   48 */,    W64LIT(0x3C26E8EAB1C94410)   /*   49 */,
        W64LIT(0xB510102BC0A822F9)   /*   50 */,    W64LIT(0x141EEF310CE6123B)   /*   51 */,
        W64LIT(0xFC65B90059DDB154)   /*   52 */,    W64LIT(0xE0158640C5E0E607)   /*   53 */,
        W64LIT(0x884E079826C3A3CF)   /*   54 */,    W64LIT(0x930D0D9523C535FD)   /*   55 */,
        W64LIT(0x35638D754E9A2B00)   /*   56 */,    W64LIT(0x4085FCCF40469DD5)   /*   57 */,
        W64LIT(0xC4B17AD28BE23A4C)   /*   58 */,    W64LIT(0xCAB2F0FC6A3E6A2E)   /*   59 */,
        W64LIT(0x2860971A6B943FCD)   /*   60 */,    W64LIT(0x3DDE6EE212E30446)   /*   61 */,
        W64LIT(0x6222F32AE01765AE)   /*   62 */,    W64LIT(0x5D550BB5478308FE)   /*   63 */,
        W64LIT(0xA9EFA98DA0EDA22A)   /*   64 */,    W64LIT(0xC351A71686C40DA7)   /*   65 */,
        W64LIT(0x1105586D9C867C84)   /*   66 */,    W64LIT(0xDCFFEE85FDA22853)   /*   67 */,
        W64LIT(0xCCFBD0262C5EEF76)   /*   68 */,    W64LIT(0xBAF294CB8990D201)   /*   69 */,
        W64LIT(0xE69464F52AFAD975)   /*   70 */,    W64LIT(0x94B013AFDF133E14)   /*   71 */,
        W64LIT(0x06A7D1A32823C958)   /*   72 */,    W64LIT(0x6F95FE5130F61119)   /*   73 */,
        W64LIT(0xD92AB34E462C06C0)   /*   74 */,    W64LIT(0xED7BDE33887C71D2)   /*   75 */,
        W64LIT(0x79746D6E6518393E)   /*   76 */,    W64LIT(0x5BA419385D713329)   /*   77 */,
        W64LIT(0x7C1BA6B948A97564)   /*   78 */,    W64LIT(0x31987C197BFDAC67)   /*   79 */,
        W64LIT(0xDE6C23C44B053D02)   /*   80 */,    W64LIT(0x581C49FED002D64D)   /*   81 */,
        W64LIT(0xDD474D6338261571)   /*   82 */,    W64LIT(0xAA4546C3E473D062)   /*   83 */,
        W64LIT(0x928FCE349455F860)   /*   84 */,    W64LIT(0x48161BBACAAB94D9)   /*   85 */,
        W64LIT(0x63912430770E6F68)   /*   86 */,    W64LIT(0x6EC8A5E602C6641C)   /*   87 */,
        W64LIT(0x87282515337DDD2B)   /*   88 */,    W64LIT(0x2CDA6B42034B701B)   /*   89 */,
        W64LIT(0xB03D37C181CB096D)   /*   90 */,    W64LIT(0xE108438266C71C6F)   /*   91 */,
        W64LIT(0x2B3180C7EB51B255)   /*   92 */,    W64LIT(0xDF92B82F96C08BBC)   /*   93 */,
        W64LIT(0x5C68C8C0A632F3BA)   /*   94 */,    W64LIT(0x5504CC861C3D0556)   /*   95 */,
        W64LIT(0xABBFA4E55FB26B8F)   /*   96 */,    W64LIT(0x41848B0AB3BACEB4)   /*   97 */,
        W64LIT(0xB334A273AA445D32)   /*   98 */,    W64LIT(0xBCA696F0A85AD881)   /*   99 */,
        W64LIT(0x24F6EC65B528D56C)   /*  100 */,    W64LIT(0x0CE1512E90F4524A)   /*  101 */,
        W64LIT(0x4E9DD79D5506D35A)   /*  102 */,    W64LIT(0x258905FAC6CE9779)   /*  103 */,
        W64LIT(0x2019295B3E109B33)   /*  104 */,    W64LIT(0xF8A9478B73A054CC)   /*  105 */,
        W64LIT(0x2924F2F934417EB0)   /*  106 */,    W64LIT(0x3993357D536D1BC4)   /*  107 */,
        W64LIT(0x38A81AC21DB6FF8B)   /*  108 */,    W64LIT(0x47C4FBF17D6016BF)   /*  109 */,
        W64LIT(0x1E0FAADD7667E3F5)   /*  110 */,    W64LIT(0x7ABCFF62938BEB96)   /*  111 */,
        W64LIT(0xA78DAD948FC179C9)   /*  112 */,    W64LIT(0x8F1F98B72911E50D)   /*  113 */,
        W64LIT(0x61E48EAE27121A91)   /*  114 */,    W64LIT(0x4D62F7AD31859808)   /*  115 */,
        W64LIT(0xECEBA345EF5CEAEB)   /*  116 */,    W64LIT(0xF5CEB25EBC9684CE)   /*  117 */,
        W64LIT(0xF633E20CB7F76221)   /*  118 */,    W64LIT(0xA32CDF06AB8293E4)   /*  119 */,
        W64LIT(0x985A202CA5EE2CA4)   /*  120 */,    W64LIT(0xCF0B8447CC8A8FB1)   /*  121 */,
        W64LIT(0x9F765244979859A3)   /*  122 */,    W64LIT(0xA8D516B1A1240017)   /*  123 */,
        W64LIT(0x0BD7BA3EBB5DC726)   /*  124 */,    W64LIT(0xE54BCA55B86ADB39)   /*  125 */,
        W64LIT(0x1D7A3AFD6C478063)   /*  126 */,    W64LIT(0x519EC608E7669EDD)   /*  127 */,
        W64LIT(0x0E5715A2D149AA23)   /*  128 */,    W64LIT(0x177D4571848FF194)   /*  129 */,
        W64LIT(0xEEB55F3241014C22)   /*  130 */,    W64LIT(0x0F5E5CA13A6E2EC2)   /*  131 */,
        W64LIT(0x8029927B75F5C361)   /*  132 */,    W64LIT(0xAD139FABC3D6E436)   /*  133 */,
        W64LIT(0x0D5DF1A94CCF402F)   /*  134 */,    W64LIT(0x3E8BD948BEA5DFC8)   /*  135 */,
        W64LIT(0xA5A0D357BD3FF77E)   /*  136 */,    W64LIT(0xA2D12E251F74F645)   /*  137 */,
        W64LIT(0x66FD9E525E81A082)   /*  138 */,    W64LIT(0x2E0C90CE7F687A49)   /*  139 */,
        W64LIT(0xC2E8BCBEBA973BC5)   /*  140 */,    W64LIT(0x000001BCE509745F)   /*  141 */,
        W64LIT(0x423777BBE6DAB3D6)   /*  142 */,    W64LIT(0xD1661C7EAEF06EB5)   /*  143 */,
        W64LIT(0xA1781F354DAACFD8)   /*  144 */,    W64LIT(0x2D11284A2B16AFFC)   /*  145 */,
        W64LIT(0xF1FC4F67FA891D1F)   /*  146 */,    W64LIT(0x73ECC25DCB920ADA)   /*  147 */,
        W64LIT(0xAE610C22C2A12651)   /*  148 */,    W64LIT(0x96E0A810D356B78A)   /*  149 */,
        W64LIT(0x5A9A381F2FE7870F)   /*  150 */,    W64LIT(0xD5AD62EDE94E5530)   /*  151 */,
        W64LIT(0xD225E5E8368D1427)   /*  152 */,    W64LIT(0x65977B70C7AF4631)   /*  153 */,
        W64LIT(0x99F889B2DE39D74F)   /*  154 */,    W64LIT(0x233F30BF54E1D143)   /*  155 */,
        W64LIT(0x9A9675D3D9A63C97)   /*  156 */,    W64LIT(0x5470554FF334F9A8)   /*  157 */,
        W64LIT(0x166ACB744A4F5688)   /*  158 */,    W64LIT(0x70C74CAAB2E4AEAD)   /*  159 */,
        W64LIT(0xF0D091646F294D12)   /*  160 */,    W64LIT(0x57B82A89684031D1)   /*  161 */,
        W64LIT(0xEFD95A5A61BE0B6B)   /*  162 */,    W64LIT(0x2FBD12E969F2F29A)   /*  163 */,
        W64LIT(0x9BD37013FEFF9FE8)   /*  164 */,    W64LIT(0x3F9B0404D6085A06)   /*  165 */,
        W64LIT(0x4940C1F3166CFE15)   /*  166 */,    W64LIT(0x09542C4DCDF3DEFB)   /*  167 */,
        W64LIT(0xB4C5218385CD5CE3)   /*  168 */,    W64LIT(0xC935B7DC4462A641)   /*  169 */,
        W64LIT(0x3417F8A68ED3B63F)   /*  170 */,    W64LIT(0xB80959295B215B40)   /*  171 */,
        W64LIT(0xF99CDAEF3B8C8572)   /*  172 */,    W64LIT(0x018C0614F8FCB95D)   /*  173 */,
        W64LIT(0x1B14ACCD1A3ACDF3)   /*  174 */,    W64LIT(0x84D471F200BB732D)   /*  175 */,
        W64LIT(0xC1A3110E95E8DA16)   /*  176 */,    W64LIT(0x430A7220BF1A82B8)   /*  177 */,
        W64LIT(0xB77E090D39DF210E)   /*  178 */,    W64LIT(0x5EF4BD9F3CD05E9D)   /*  179 */,
        W64LIT(0x9D4FF6DA7E57A444)   /*  180 */,    W64LIT(0xDA1D60E183D4A5F8)   /*  181 */,
        W64LIT(0xB287C38417998E47)   /*  182 */,    W64LIT(0xFE3EDC121BB31886)   /*  183 */,
        W64LIT(0xC7FE3CCC980CCBEF)   /*  184 */,    W64LIT(0xE46FB590189BFD03)   /*  185 */,
        W64LIT(0x3732FD469A4C57DC)   /*  186 */,    W64LIT(0x7EF700A07CF1AD65)   /*  187 */,
        W64LIT(0x59C64468A31D8859)   /*  188 */,    W64LIT(0x762FB0B4D45B61F6)   /*  189 */,
        W64LIT(0x155BAED099047718)   /*  190 */,    W64LIT(0x68755E4C3D50BAA6)   /*  191 */,
        W64LIT(0xE9214E7F22D8B4DF)   /*  192 */,    W64LIT(0x2ADDBF532EAC95F4)   /*  193 */,
        W64LIT(0x32AE3909B4BD0109)   /*  194 */,    W64LIT(0x834DF537B08E3450)   /*  195 */,
        W64LIT(0xFA209DA84220728D)   /*  196 */,    W64LIT(0x9E691D9B9EFE23F7)   /*  197 */,
        W64LIT(0x0446D288C4AE8D7F)   /*  198 */,    W64LIT(0x7B4CC524E169785B)   /*  199 */,
        W64LIT(0x21D87F0135CA1385)   /*  200 */,    W64LIT(0xCEBB400F137B8AA5)   /*  201 */,
        W64LIT(0x272E2B66580796BE)   /*  202 */,    W64LIT(0x3612264125C2B0DE)   /*  203 */,
        W64LIT(0x057702BDAD1EFBB2)   /*  204 */,    W64LIT(0xD4BABB8EACF84BE9)   /*  205 */,
        W64LIT(0x91583139641BC67B)   /*  206 */,    W64LIT(0x8BDC2DE08036E024)   /*  207 */,
        W64LIT(0x603C8156F49F68ED)   /*  208 */,    W64LIT(0xF7D236F7DBEF5111)   /*  209 */,
        W64LIT(0x9727C4598AD21E80)   /*  210 */,    W64LIT(0xA08A0896670A5FD7)   /*  211 */,
        W64LIT(0xCB4A8F4309EBA9CB)   /*  212 */,    W64LIT(0x81AF564B0F7036A1)   /*  213 */,
        W64LIT(0xC0B99AA778199ABD)   /*  214 */,    W64LIT(0x959F1EC83FC8E952)   /*  215 */,
        W64LIT(0x8C505077794A81B9)   /*  216 */,    W64LIT(0x3ACAAF8F056338F0)   /*  217 */,
        W64LIT(0x07B43F50627A6778)   /*  218 */,    W64LIT(0x4A44AB49F5ECCC77)   /*  219 */,
        W64LIT(0x3BC3D6E4B679EE98)   /*  220 */,    W64LIT(0x9CC0D4D1CF14108C)   /*  221 */,
        W64LIT(0x4406C00B206BC8A0)   /*  222 */,    W64LIT(0x82A18854C8D72D89)   /*  223 */,
        W64LIT(0x67E366B35C3C432C)   /*  224 */,    W64LIT(0xB923DD61102B37F2)   /*  225 */,
        W64LIT(0x56AB2779D884271D)   /*  226 */,    W64LIT(0xBE83E1B0FF1525AF)   /*  227 */,
        W64LIT(0xFB7C65D4217E49A9)   /*  228 */,    W64LIT(0x6BDBE0E76D48E7D4)   /*  229 */,
        W64LIT(0x08DF828745D9179E)   /*  230 */,    W64LIT(0x22EA6A9ADD53BD34)   /*  231 */,
        W64LIT(0xE36E141C5622200A)   /*  232 */,    W64LIT(0x7F805D1B8CB750EE)   /*  233 */,
        W64LIT(0xAFE5C7A59F58E837)   /*  234 */,    W64LIT(0xE27F996A4FB1C23C)   /*  235 */,
        W64LIT(0xD3867DFB0775F0D0)   /*  236 */,    W64LIT(0xD0E673DE6E88891A)   /*  237 */,
        W64LIT(0x123AEB9EAFB86C25)   /*  238 */,    W64LIT(0x30F1D5D5C145B895)   /*  239 */,
        W64LIT(0xBB434A2DEE7269E7)   /*  240 */,    W64LIT(0x78CB67ECF931FA38)   /*  241 */,
        W64LIT(0xF33B0372323BBF9C)   /*  242 */,    W64LIT(0x52D66336FB279C74)   /*  243 */,
        W64LIT(0x505F33AC0AFB4EAA)   /*  244 */,    W64LIT(0xE8A5CD99A2CCE187)   /*  245 */,
        W64LIT(0x534974801E2D30BB)   /*  246 */,    W64LIT(0x8D2D5711D5876D90)   /*  247 */,
        W64LIT(0x1F1A412891BC038E)   /*  248 */,    W64LIT(0xD6E2E71D82E56648)   /*  249 */,
        W64LIT(0x74036C3A497732B7)   /*  250 */,    W64LIT(0x89B67ED96361F5AB)   /*  251 */,
        W64LIT(0xFFED95D8F1EA02A2)   /*  252 */,    W64LIT(0xE72B3BD61464D43D)   /*  253 */,
        W64LIT(0xA6300F170BDC4820)   /*  254 */,    W64LIT(0xEBC18760ED78A77A)   /*  255 */,
        W64LIT(0xE6A6BE5A05A12138)   /*  256 */,    W64LIT(0xB5A122A5B4F87C98)   /*  257 */,
        W64LIT(0x563C6089140B6990)   /*  258 */,    W64LIT(0x4C46CB2E391F5DD5)   /*  259 */,
        W64LIT(0xD932ADDBC9B79434)   /*  260 */,    W64LIT(0x08EA70E42015AFF5)   /*  261 */,
        W64LIT(0xD765A6673E478CF1)   /*  262 */,    W64LIT(0xC4FB757EAB278D99)   /*  263 */,
        W64LIT(0xDF11C6862D6E0692)   /*  264 */,    W64LIT(0xDDEB84F10D7F3B16)   /*  265 */,
        W64LIT(0x6F2EF604A665EA04)   /*  266 */,    W64LIT(0x4A8E0F0FF0E0DFB3)   /*  267 */,
        W64LIT(0xA5EDEEF83DBCBA51)   /*  268 */,    W64LIT(0xFC4F0A2A0EA4371E)   /*  269 */,
        W64LIT(0xE83E1DA85CB38429)   /*  270 */,    W64LIT(0xDC8FF882BA1B1CE2)   /*  271 */,
        W64LIT(0xCD45505E8353E80D)   /*  272 */,    W64LIT(0x18D19A00D4DB0717)   /*  273 */,
        W64LIT(0x34A0CFEDA5F38101)   /*  274 */,    W64LIT(0x0BE77E518887CAF2)   /*  275 */,
        W64LIT(0x1E341438B3C45136)   /*  276 */,    W64LIT(0xE05797F49089CCF9)   /*  277 */,
        W64LIT(0xFFD23F9DF2591D14)   /*  278 */,    W64LIT(0x543DDA228595C5CD)   /*  279 */,
        W64LIT(0x661F81FD99052A33)   /*  280 */,    W64LIT(0x8736E641DB0F7B76)   /*  281 */,
        W64LIT(0x15227725418E5307)   /*  282 */,    W64LIT(0xE25F7F46162EB2FA)   /*  283 */,
        W64LIT(0x48A8B2126C13D9FE)   /*  284 */,    W64LIT(0xAFDC541792E76EEA)   /*  285 */,
        W64LIT(0x03D912BFC6D1898F)   /*  286 */,    W64LIT(0x31B1AAFA1B83F51B)   /*  287 */,
        W64LIT(0xF1AC2796E42AB7D9)   /*  288 */,    W64LIT(0x40A3A7D7FCD2EBAC)   /*  289 */,
        W64LIT(0x1056136D0AFBBCC5)   /*  290 */,    W64LIT(0x7889E1DD9A6D0C85)   /*  291 */,
        W64LIT(0xD33525782A7974AA)   /*  292 */,    W64LIT(0xA7E25D09078AC09B)   /*  293 */,
        W64LIT(0xBD4138B3EAC6EDD0)   /*  294 */,    W64LIT(0x920ABFBE71EB9E70)   /*  295 */,
        W64LIT(0xA2A5D0F54FC2625C)   /*  296 */,    W64LIT(0xC054E36B0B1290A3)   /*  297 */,
        W64LIT(0xF6DD59FF62FE932B)   /*  298 */,    W64LIT(0x3537354511A8AC7D)   /*  299 */,
        W64LIT(0xCA845E9172FADCD4)   /*  300 */,    W64LIT(0x84F82B60329D20DC)   /*  301 */,
        W64LIT(0x79C62CE1CD672F18)   /*  302 */,    W64LIT(0x8B09A2ADD124642C)   /*  303 */,
        W64LIT(0xD0C1E96A19D9E726)   /*  304 */,    W64LIT(0x5A786A9B4BA9500C)   /*  305 */,
        W64LIT(0x0E020336634C43F3)   /*  306 */,    W64LIT(0xC17B474AEB66D822)   /*  307 */,
        W64LIT(0x6A731AE3EC9BAAC2)   /*  308 */,    W64LIT(0x8226667AE0840258)   /*  309 */,
        W64LIT(0x67D4567691CAECA5)   /*  310 */,    W64LIT(0x1D94155C4875ADB5)   /*  311 */,
        W64LIT(0x6D00FD985B813FDF)   /*  312 */,    W64LIT(0x51286EFCB774CD06)   /*  313 */,
        W64LIT(0x5E8834471FA744AF)   /*  314 */,    W64LIT(0xF72CA0AEE761AE2E)   /*  315 */,
        W64LIT(0xBE40E4CDAEE8E09A)   /*  316 */,    W64LIT(0xE9970BBB5118F665)   /*  317 */,
        W64LIT(0x726E4BEB33DF1964)   /*  318 */,    W64LIT(0x703B000729199762)   /*  319 */,
        W64LIT(0x4631D816F5EF30A7)   /*  320 */,    W64LIT(0xB880B5B51504A6BE)   /*  321 */,
        W64LIT(0x641793C37ED84B6C)   /*  322 */,    W64LIT(0x7B21ED77F6E97D96)   /*  323 */,
        W64LIT(0x776306312EF96B73)   /*  324 */,    W64LIT(0xAE528948E86FF3F4)   /*  325 */,
        W64LIT(0x53DBD7F286A3F8F8)   /*  326 */,    W64LIT(0x16CADCE74CFC1063)   /*  327 */,
        W64LIT(0x005C19BDFA52C6DD)   /*  328 */,    W64LIT(0x68868F5D64D46AD3)   /*  329 */,
        W64LIT(0x3A9D512CCF1E186A)   /*  330 */,    W64LIT(0x367E62C2385660AE)   /*  331 */,
        W64LIT(0xE359E7EA77DCB1D7)   /*  332 */,    W64LIT(0x526C0773749ABE6E)   /*  333 */,
        W64LIT(0x735AE5F9D09F734B)   /*  334 */,    W64LIT(0x493FC7CC8A558BA8)   /*  335 */,
        W64LIT(0xB0B9C1533041AB45)   /*  336 */,    W64LIT(0x321958BA470A59BD)   /*  337 */,
        W64LIT(0x852DB00B5F46C393)   /*  338 */,    W64LIT(0x91209B2BD336B0E5)   /*  339 */,
        W64LIT(0x6E604F7D659EF19F)   /*  340 */,    W64LIT(0xB99A8AE2782CCB24)   /*  341 */,
        W64LIT(0xCCF52AB6C814C4C7)   /*  342 */,    W64LIT(0x4727D9AFBE11727B)   /*  343 */,
        W64LIT(0x7E950D0C0121B34D)   /*  344 */,    W64LIT(0x756F435670AD471F)   /*  345 */,
        W64LIT(0xF5ADD442615A6849)   /*  346 */,    W64LIT(0x4E87E09980B9957A)   /*  347 */,
        W64LIT(0x2ACFA1DF50AEE355)   /*  348 */,    W64LIT(0xD898263AFD2FD556)   /*  349 */,
        W64LIT(0xC8F4924DD80C8FD6)   /*  350 */,    W64LIT(0xCF99CA3D754A173A)   /*  351 */,
        W64LIT(0xFE477BACAF91BF3C)   /*  352 */,    W64LIT(0xED5371F6D690C12D)   /*  353 */,
        W64LIT(0x831A5C285E687094)   /*  354 */,    W64LIT(0xC5D3C90A3708A0A4)   /*  355 */,
        W64LIT(0x0F7F903717D06580)   /*  356 */,    W64LIT(0x19F9BB13B8FDF27F)   /*  357 */,
        W64LIT(0xB1BD6F1B4D502843)   /*  358 */,    W64LIT(0x1C761BA38FFF4012)   /*  359 */,
        W64LIT(0x0D1530C4E2E21F3B)   /*  360 */,    W64LIT(0x8943CE69A7372C8A)   /*  361 */,
        W64LIT(0xE5184E11FEB5CE66)   /*  362 */,    W64LIT(0x618BDB80BD736621)   /*  363 */,
        W64LIT(0x7D29BAD68B574D0B)   /*  364 */,    W64LIT(0x81BB613E25E6FE5B)   /*  365 */,
        W64LIT(0x071C9C10BC07913F)   /*  366 */,    W64LIT(0xC7BEEB7909AC2D97)   /*  367 */,
        W64LIT(0xC3E58D353BC5D757)   /*  368 */,    W64LIT(0xEB017892F38F61E8)   /*  369 */,
        W64LIT(0xD4EFFB9C9B1CC21A)   /*  370 */,    W64LIT(0x99727D26F494F7AB)   /*  371 */,
        W64LIT(0xA3E063A2956B3E03)   /*  372 */,    W64LIT(0x9D4A8B9A4AA09C30)   /*  373 */,
        W64LIT(0x3F6AB7D500090FB4)   /*  374 */,    W64LIT(0x9CC0F2A057268AC0)   /*  375 */,
        W64LIT(0x3DEE9D2DEDBF42D1)   /*  376 */,    W64LIT(0x330F49C87960A972)   /*  377 */,
        W64LIT(0xC6B2720287421B41)   /*  378 */,    W64LIT(0x0AC59EC07C00369C)   /*  379 */,
        W64LIT(0xEF4EAC49CB353425)   /*  380 */,    W64LIT(0xF450244EEF0129D8)   /*  381 */,
        W64LIT(0x8ACC46E5CAF4DEB6)   /*  382 */,    W64LIT(0x2FFEAB63989263F7)   /*  383 */,
        W64LIT(0x8F7CB9FE5D7A4578)   /*  384 */,    W64LIT(0x5BD8F7644E634635)   /*  385 */,
        W64LIT(0x427A7315BF2DC900)   /*  386 */,    W64LIT(0x17D0C4AA2125261C)   /*  387 */,
        W64LIT(0x3992486C93518E50)   /*  388 */,    W64LIT(0xB4CBFEE0A2D7D4C3)   /*  389 */,
        W64LIT(0x7C75D6202C5DDD8D)   /*  390 */,    W64LIT(0xDBC295D8E35B6C61)   /*  391 */,
        W64LIT(0x60B369D302032B19)   /*  392 */,    W64LIT(0xCE42685FDCE44132)   /*  393 */,
        W64LIT(0x06F3DDB9DDF65610)   /*  394 */,    W64LIT(0x8EA4D21DB5E148F0)   /*  395 */,
        W64LIT(0x20B0FCE62FCD496F)   /*  396 */,    W64LIT(0x2C1B912358B0EE31)   /*  397 */,
        W64LIT(0xB28317B818F5A308)   /*  398 */,    W64LIT(0xA89C1E189CA6D2CF)   /*  399 */,
        W64LIT(0x0C6B18576AAADBC8)   /*  400 */,    W64LIT(0xB65DEAA91299FAE3)   /*  401 */,
        W64LIT(0xFB2B794B7F1027E7)   /*  402 */,    W64LIT(0x04E4317F443B5BEB)   /*  403 */,
        W64LIT(0x4B852D325939D0A6)   /*  404 */,    W64LIT(0xD5AE6BEEFB207FFC)   /*  405 */,
        W64LIT(0x309682B281C7D374)   /*  406 */,    W64LIT(0xBAE309A194C3B475)   /*  407 */,
        W64LIT(0x8CC3F97B13B49F05)   /*  408 */,    W64LIT(0x98A9422FF8293967)   /*  409 */,
        W64LIT(0x244B16B01076FF7C)   /*  410 */,    W64LIT(0xF8BF571C663D67EE)   /*  411 */,
        W64LIT(0x1F0D6758EEE30DA1)   /*  412 */,    W64LIT(0xC9B611D97ADEB9B7)   /*  413 */,
        W64LIT(0xB7AFD5887B6C57A2)   /*  414 */,    W64LIT(0x6290AE846B984FE1)   /*  415 */,
        W64LIT(0x94DF4CDEACC1A5FD)   /*  416 */,    W64LIT(0x058A5BD1C5483AFF)   /*  417 */,
        W64LIT(0x63166CC142BA3C37)   /*  418 */,    W64LIT(0x8DB8526EB2F76F40)   /*  419 */,
        W64LIT(0xE10880036F0D6D4E)   /*  420 */,    W64LIT(0x9E0523C9971D311D)   /*  421 */,
        W64LIT(0x45EC2824CC7CD691)   /*  422 */,    W64LIT(0x575B8359E62382C9)   /*  423 */,
        W64LIT(0xFA9E400DC4889995)   /*  424 */,    W64LIT(0xD1823ECB45721568)   /*  425 */,
        W64LIT(0xDAFD983B8206082F)   /*  426 */,    W64LIT(0xAA7D29082386A8CB)   /*  427 */,
        W64LIT(0x269FCD4403B87588)   /*  428 */,    W64LIT(0x1B91F5F728BDD1E0)   /*  429 */,
        W64LIT(0xE4669F39040201F6)   /*  430 */,    W64LIT(0x7A1D7C218CF04ADE)   /*  431 */,
        W64LIT(0x65623C29D79CE5CE)   /*  432 */,    W64LIT(0x2368449096C00BB1)   /*  433 */,
        W64LIT(0xAB9BF1879DA503BA)   /*  434 */,    W64LIT(0xBC23ECB1A458058E)   /*  435 */,
        W64LIT(0x9A58DF01BB401ECC)   /*  436 */,    W64LIT(0xA070E868A85F143D)   /*  437 */,
        W64LIT(0x4FF188307DF2239E)   /*  438 */,    W64LIT(0x14D565B41A641183)   /*  439 */,
        W64LIT(0xEE13337452701602)   /*  440 */,    W64LIT(0x950E3DCF3F285E09)   /*  441 */,
        W64LIT(0x59930254B9C80953)   /*  442 */,    W64LIT(0x3BF299408930DA6D)   /*  443 */,
        W64LIT(0xA955943F53691387)   /*  444 */,    W64LIT(0xA15EDECAA9CB8784)   /*  445 */,
        W64LIT(0x29142127352BE9A0)   /*  446 */,    W64LIT(0x76F0371FFF4E7AFB)   /*  447 */,
        W64LIT(0x0239F450274F2228)   /*  448 */,    W64LIT(0xBB073AF01D5E868B)   /*  449 */,
        W64LIT(0xBFC80571C10E96C1)   /*  450 */,    W64LIT(0xD267088568222E23)   /*  451 */,
        W64LIT(0x9671A3D48E80B5B0)   /*  452 */,    W64LIT(0x55B5D38AE193BB81)   /*  453 */,
        W64LIT(0x693AE2D0A18B04B8)   /*  454 */,    W64LIT(0x5C48B4ECADD5335F)   /*  455 */,
        W64LIT(0xFD743B194916A1CA)   /*  456 */,    W64LIT(0x2577018134BE98C4)   /*  457 */,
        W64LIT(0xE77987E83C54A4AD)   /*  458 */,    W64LIT(0x28E11014DA33E1B9)   /*  459 */,
        W64LIT(0x270CC59E226AA213)   /*  460 */,    W64LIT(0x71495F756D1A5F60)   /*  461 */,
        W64LIT(0x9BE853FB60AFEF77)   /*  462 */,    W64LIT(0xADC786A7F7443DBF)   /*  463 */,
        W64LIT(0x0904456173B29A82)   /*  464 */,    W64LIT(0x58BC7A66C232BD5E)   /*  465 */,
        W64LIT(0xF306558C673AC8B2)   /*  466 */,    W64LIT(0x41F639C6B6C9772A)   /*  467 */,
        W64LIT(0x216DEFE99FDA35DA)   /*  468 */,    W64LIT(0x11640CC71C7BE615)   /*  469 */,
        W64LIT(0x93C43694565C5527)   /*  470 */,    W64LIT(0xEA038E6246777839)   /*  471 */,
        W64LIT(0xF9ABF3CE5A3E2469)   /*  472 */,    W64LIT(0x741E768D0FD312D2)   /*  473 */,
        W64LIT(0x0144B883CED652C6)   /*  474 */,    W64LIT(0xC20B5A5BA33F8552)   /*  475 */,
        W64LIT(0x1AE69633C3435A9D)   /*  476 */,    W64LIT(0x97A28CA4088CFDEC)   /*  477 */,
        W64LIT(0x8824A43C1E96F420)   /*  478 */,    W64LIT(0x37612FA66EEEA746)   /*  479 */,
        W64LIT(0x6B4CB165F9CF0E5A)   /*  480 */,    W64LIT(0x43AA1C06A0ABFB4A)   /*  481 */,
        W64LIT(0x7F4DC26FF162796B)   /*  482 */,    W64LIT(0x6CBACC8E54ED9B0F)   /*  483 */,
        W64LIT(0xA6B7FFEFD2BB253E)   /*  484 */,    W64LIT(0x2E25BC95B0A29D4F)   /*  485 */,
        W64LIT(0x86D6A58BDEF1388C)   /*  486 */,    W64LIT(0xDED74AC576B6F054)   /*  487 */,
        W64LIT(0x8030BDBC2B45805D)   /*  488 */,    W64LIT(0x3C81AF70E94D9289)   /*  489 */,
        W64LIT(0x3EFF6DDA9E3100DB)   /*  490 */,    W64LIT(0xB38DC39FDFCC8847)   /*  491 */,
        W64LIT(0x123885528D17B87E)   /*  492 */,    W64LIT(0xF2DA0ED240B1B642)   /*  493 */,
        W64LIT(0x44CEFADCD54BF9A9)   /*  494 */,    W64LIT(0x1312200E433C7EE6)   /*  495 */,
        W64LIT(0x9FFCC84F3A78C748)   /*  496 */,    W64LIT(0xF0CD1F72248576BB)   /*  497 */,
        W64LIT(0xEC6974053638CFE4)   /*  498 */,    W64LIT(0x2BA7B67C0CEC4E4C)   /*  499 */,
        W64LIT(0xAC2F4DF3E5CE32ED)   /*  500 */,    W64LIT(0xCB33D14326EA4C11)   /*  501 */,
        W64LIT(0xA4E9044CC77E58BC)   /*  502 */,    W64LIT(0x5F513293D934FCEF)   /*  503 */,
        W64LIT(0x5DC9645506E55444)   /*  504 */,    W64LIT(0x50DE418F317DE40A)   /*  505 */,
        W64LIT(0x388CB31A69DDE259)   /*  506 */,    W64LIT(0x2DB4A83455820A86)   /*  507 */,
        W64LIT(0x9010A91E84711AE9)   /*  508 */,    W64LIT(0x4DF7F0B7B1498371)   /*  509 */,
        W64LIT(0xD62A2EABC0977179)   /*  510 */,    W64LIT(0x22FAC097AA8D5C0E)   /*  511 */,
        W64LIT(0xF49FCC2FF1DAF39B)   /*  512 */,    W64LIT(0x487FD5C66FF29281)   /*  513 */,
        W64LIT(0xE8A30667FCDCA83F)   /*  514 */,    W64LIT(0x2C9B4BE3D2FCCE63)   /*  515 */,
        W64LIT(0xDA3FF74B93FBBBC2)   /*  516 */,    W64LIT(0x2FA165D2FE70BA66)   /*  517 */,
        W64LIT(0xA103E279970E93D4)   /*  518 */,    W64LIT(0xBECDEC77B0E45E71)   /*  519 */,
        W64LIT(0xCFB41E723985E497)   /*  520 */,    W64LIT(0xB70AAA025EF75017)   /*  521 */,
        W64LIT(0xD42309F03840B8E0)   /*  522 */,    W64LIT(0x8EFC1AD035898579)   /*  523 */,
        W64LIT(0x96C6920BE2B2ABC5)   /*  524 */,    W64LIT(0x66AF4163375A9172)   /*  525 */,
        W64LIT(0x2174ABDCCA7127FB)   /*  526 */,    W64LIT(0xB33CCEA64A72FF41)   /*  527 */,
        W64LIT(0xF04A4933083066A5)   /*  528 */,    W64LIT(0x8D970ACDD7289AF5)   /*  529 */,
        W64LIT(0x8F96E8E031C8C25E)   /*  530 */,    W64LIT(0xF3FEC02276875D47)   /*  531 */,
        W64LIT(0xEC7BF310056190DD)   /*  532 */,    W64LIT(0xF5ADB0AEBB0F1491)   /*  533 */,
        W64LIT(0x9B50F8850FD58892)   /*  534 */,    W64LIT(0x4975488358B74DE8)   /*  535 */,
        W64LIT(0xA3354FF691531C61)   /*  536 */,    W64LIT(0x0702BBE481D2C6EE)   /*  537 */,
        W64LIT(0x89FB24057DEDED98)   /*  538 */,    W64LIT(0xAC3075138596E902)   /*  539 */,
        W64LIT(0x1D2D3580172772ED)   /*  540 */,    W64LIT(0xEB738FC28E6BC30D)   /*  541 */,
        W64LIT(0x5854EF8F63044326)   /*  542 */,    W64LIT(0x9E5C52325ADD3BBE)   /*  543 */,
        W64LIT(0x90AA53CF325C4623)   /*  544 */,    W64LIT(0xC1D24D51349DD067)   /*  545 */,
        W64LIT(0x2051CFEEA69EA624)   /*  546 */,    W64LIT(0x13220F0A862E7E4F)   /*  547 */,
        W64LIT(0xCE39399404E04864)   /*  548 */,    W64LIT(0xD9C42CA47086FCB7)   /*  549 */,
        W64LIT(0x685AD2238A03E7CC)   /*  550 */,    W64LIT(0x066484B2AB2FF1DB)   /*  551 */,
        W64LIT(0xFE9D5D70EFBF79EC)   /*  552 */,    W64LIT(0x5B13B9DD9C481854)   /*  553 */,
        W64LIT(0x15F0D475ED1509AD)   /*  554 */,    W64LIT(0x0BEBCD060EC79851)   /*  555 */,
        W64LIT(0xD58C6791183AB7F8)   /*  556 */,    W64LIT(0xD1187C5052F3EEE4)   /*  557 */,
        W64LIT(0xC95D1192E54E82FF)   /*  558 */,    W64LIT(0x86EEA14CB9AC6CA2)   /*  559 */,
        W64LIT(0x3485BEB153677D5D)   /*  560 */,    W64LIT(0xDD191D781F8C492A)   /*  561 */,
        W64LIT(0xF60866BAA784EBF9)   /*  562 */,    W64LIT(0x518F643BA2D08C74)   /*  563 */,
        W64LIT(0x8852E956E1087C22)   /*  564 */,    W64LIT(0xA768CB8DC410AE8D)   /*  565 */,
        W64LIT(0x38047726BFEC8E1A)   /*  566 */,    W64LIT(0xA67738B4CD3B45AA)   /*  567 */,
        W64LIT(0xAD16691CEC0DDE19)   /*  568 */,    W64LIT(0xC6D4319380462E07)   /*  569 */,
        W64LIT(0xC5A5876D0BA61938)   /*  570 */,    W64LIT(0x16B9FA1FA58FD840)   /*  571 */,
        W64LIT(0x188AB1173CA74F18)   /*  572 */,    W64LIT(0xABDA2F98C99C021F)   /*  573 */,
        W64LIT(0x3E0580AB134AE816)   /*  574 */,    W64LIT(0x5F3B05B773645ABB)   /*  575 */,
        W64LIT(0x2501A2BE5575F2F6)   /*  576 */,    W64LIT(0x1B2F74004E7E8BA9)   /*  577 */,
        W64LIT(0x1CD7580371E8D953)   /*  578 */,    W64LIT(0x7F6ED89562764E30)   /*  579 */,
        W64LIT(0xB15926FF596F003D)   /*  580 */,    W64LIT(0x9F65293DA8C5D6B9)   /*  581 */,
        W64LIT(0x6ECEF04DD690F84C)   /*  582 */,    W64LIT(0x4782275FFF33AF88)   /*  583 */,
        W64LIT(0xE41433083F820801)   /*  584 */,    W64LIT(0xFD0DFE409A1AF9B5)   /*  585 */,
        W64LIT(0x4325A3342CDB396B)   /*  586 */,    W64LIT(0x8AE77E62B301B252)   /*  587 */,
        W64LIT(0xC36F9E9F6655615A)   /*  588 */,    W64LIT(0x85455A2D92D32C09)   /*  589 */,
        W64LIT(0xF2C7DEA949477485)   /*  590 */,    W64LIT(0x63CFB4C133A39EBA)   /*  591 */,
        W64LIT(0x83B040CC6EBC5462)   /*  592 */,    W64LIT(0x3B9454C8FDB326B0)   /*  593 */,
        W64LIT(0x56F56A9E87FFD78C)   /*  594 */,    W64LIT(0x2DC2940D99F42BC6)   /*  595 */,
        W64LIT(0x98F7DF096B096E2D)   /*  596 */,    W64LIT(0x19A6E01E3AD852BF)   /*  597 */,
        W64LIT(0x42A99CCBDBD4B40B)   /*  598 */,    W64LIT(0xA59998AF45E9C559)   /*  599 */,
        W64LIT(0x366295E807D93186)   /*  600 */,    W64LIT(0x6B48181BFAA1F773)   /*  601 */,
        W64LIT(0x1FEC57E2157A0A1D)   /*  602 */,    W64LIT(0x4667446AF6201AD5)   /*  603 */,
        W64LIT(0xE615EBCACFB0F075)   /*  604 */,    W64LIT(0xB8F31F4F68290778)   /*  605 */,
        W64LIT(0x22713ED6CE22D11E)   /*  606 */,    W64LIT(0x3057C1A72EC3C93B)   /*  607 */,
        W64LIT(0xCB46ACC37C3F1F2F)   /*  608 */,    W64LIT(0xDBB893FD02AAF50E)   /*  609 */,
        W64LIT(0x331FD92E600B9FCF)   /*  610 */,    W64LIT(0xA498F96148EA3AD6)   /*  611 */,
        W64LIT(0xA8D8426E8B6A83EA)   /*  612 */,    W64LIT(0xA089B274B7735CDC)   /*  613 */,
        W64LIT(0x87F6B3731E524A11)   /*  614 */,    W64LIT(0x118808E5CBC96749)   /*  615 */,
        W64LIT(0x9906E4C7B19BD394)   /*  616 */,    W64LIT(0xAFED7F7E9B24A20C)   /*  617 */,
        W64LIT(0x6509EADEEB3644A7)   /*  618 */,    W64LIT(0x6C1EF1D3E8EF0EDE)   /*  619 */,
        W64LIT(0xB9C97D43E9798FB4)   /*  620 */,    W64LIT(0xA2F2D784740C28A3)   /*  621 */,
        W64LIT(0x7B8496476197566F)   /*  622 */,    W64LIT(0x7A5BE3E6B65F069D)   /*  623 */,
        W64LIT(0xF96330ED78BE6F10)   /*  624 */,    W64LIT(0xEEE60DE77A076A15)   /*  625 */,
        W64LIT(0x2B4BEE4AA08B9BD0)   /*  626 */,    W64LIT(0x6A56A63EC7B8894E)   /*  627 */,
        W64LIT(0x02121359BA34FEF4)   /*  628 */,    W64LIT(0x4CBF99F8283703FC)   /*  629 */,
        W64LIT(0x398071350CAF30C8)   /*  630 */,    W64LIT(0xD0A77A89F017687A)   /*  631 */,
        W64LIT(0xF1C1A9EB9E423569)   /*  632 */,    W64LIT(0x8C7976282DEE8199)   /*  633 */,
        W64LIT(0x5D1737A5DD1F7ABD)   /*  634 */,    W64LIT(0x4F53433C09A9FA80)   /*  635 */,
        W64LIT(0xFA8B0C53DF7CA1D9)   /*  636 */,    W64LIT(0x3FD9DCBC886CCB77)   /*  637 */,
        W64LIT(0xC040917CA91B4720)   /*  638 */,    W64LIT(0x7DD00142F9D1DCDF)   /*  639 */,
        W64LIT(0x8476FC1D4F387B58)   /*  640 */,    W64LIT(0x23F8E7C5F3316503)   /*  641 */,
        W64LIT(0x032A2244E7E37339)   /*  642 */,    W64LIT(0x5C87A5D750F5A74B)   /*  643 */,
        W64LIT(0x082B4CC43698992E)   /*  644 */,    W64LIT(0xDF917BECB858F63C)   /*  645 */,
        W64LIT(0x3270B8FC5BF86DDA)   /*  646 */,    W64LIT(0x10AE72BB29B5DD76)   /*  647 */,
        W64LIT(0x576AC94E7700362B)   /*  648 */,    W64LIT(0x1AD112DAC61EFB8F)   /*  649 */,
        W64LIT(0x691BC30EC5FAA427)   /*  650 */,    W64LIT(0xFF246311CC327143)   /*  651 */,
        W64LIT(0x3142368E30E53206)   /*  652 */,    W64LIT(0x71380E31E02CA396)   /*  653 */,
        W64LIT(0x958D5C960AAD76F1)   /*  654 */,    W64LIT(0xF8D6F430C16DA536)   /*  655 */,
        W64LIT(0xC8FFD13F1BE7E1D2)   /*  656 */,    W64LIT(0x7578AE66004DDBE1)   /*  657 */,
        W64LIT(0x05833F01067BE646)   /*  658 */,    W64LIT(0xBB34B5AD3BFE586D)   /*  659 */,
        W64LIT(0x095F34C9A12B97F0)   /*  660 */,    W64LIT(0x247AB64525D60CA8)   /*  661 */,
        W64LIT(0xDCDBC6F3017477D1)   /*  662 */,    W64LIT(0x4A2E14D4DECAD24D)   /*  663 */,
        W64LIT(0xBDB5E6D9BE0A1EEB)   /*  664 */,    W64LIT(0x2A7E70F7794301AB)   /*  665 */,
        W64LIT(0xDEF42D8A270540FD)   /*  666 */,    W64LIT(0x01078EC0A34C22C1)   /*  667 */,
        W64LIT(0xE5DE511AF4C16387)   /*  668 */,    W64LIT(0x7EBB3A52BD9A330A)   /*  669 */,
        W64LIT(0x77697857AA7D6435)   /*  670 */,    W64LIT(0x004E831603AE4C32)   /*  671 */,
        W64LIT(0xE7A21020AD78E312)   /*  672 */,    W64LIT(0x9D41A70C6AB420F2)   /*  673 */,
        W64LIT(0x28E06C18EA1141E6)   /*  674 */,    W64LIT(0xD2B28CBD984F6B28)   /*  675 */,
        W64LIT(0x26B75F6C446E9D83)   /*  676 */,    W64LIT(0xBA47568C4D418D7F)   /*  677 */,
        W64LIT(0xD80BADBFE6183D8E)   /*  678 */,    W64LIT(0x0E206D7F5F166044)   /*  679 */,
        W64LIT(0xE258A43911CBCA3E)   /*  680 */,    W64LIT(0x723A1746B21DC0BC)   /*  681 */,
        W64LIT(0xC7CAA854F5D7CDD3)   /*  682 */,    W64LIT(0x7CAC32883D261D9C)   /*  683 */,
        W64LIT(0x7690C26423BA942C)   /*  684 */,    W64LIT(0x17E55524478042B8)   /*  685 */,
        W64LIT(0xE0BE477656A2389F)   /*  686 */,    W64LIT(0x4D289B5E67AB2DA0)   /*  687 */,
        W64LIT(0x44862B9C8FBBFD31)   /*  688 */,    W64LIT(0xB47CC8049D141365)   /*  689 */,
        W64LIT(0x822C1B362B91C793)   /*  690 */,    W64LIT(0x4EB14655FB13DFD8)   /*  691 */,
        W64LIT(0x1ECBBA0714E2A97B)   /*  692 */,    W64LIT(0x6143459D5CDE5F14)   /*  693 */,
        W64LIT(0x53A8FBF1D5F0AC89)   /*  694 */,    W64LIT(0x97EA04D81C5E5B00)   /*  695 */,
        W64LIT(0x622181A8D4FDB3F3)   /*  696 */,    W64LIT(0xE9BCD341572A1208)   /*  697 */,
        W64LIT(0x1411258643CCE58A)   /*  698 */,    W64LIT(0x9144C5FEA4C6E0A4)   /*  699 */,
        W64LIT(0x0D33D06565CF620F)   /*  700 */,    W64LIT(0x54A48D489F219CA1)   /*  701 */,
        W64LIT(0xC43E5EAC6D63C821)   /*  702 */,    W64LIT(0xA9728B3A72770DAF)   /*  703 */,
        W64LIT(0xD7934E7B20DF87EF)   /*  704 */,    W64LIT(0xE35503B61A3E86E5)   /*  705 */,
        W64LIT(0xCAE321FBC819D504)   /*  706 */,    W64LIT(0x129A50B3AC60BFA6)   /*  707 */,
        W64LIT(0xCD5E68EA7E9FB6C3)   /*  708 */,    W64LIT(0xB01C90199483B1C7)   /*  709 */,
        W64LIT(0x3DE93CD5C295376C)   /*  710 */,    W64LIT(0xAED52EDF2AB9AD13)   /*  711 */,
        W64LIT(0x2E60F512C0A07884)   /*  712 */,    W64LIT(0xBC3D86A3E36210C9)   /*  713 */,
        W64LIT(0x35269D9B163951CE)   /*  714 */,    W64LIT(0x0C7D6E2AD0CDB5FA)   /*  715 */,
        W64LIT(0x59E86297D87F5733)   /*  716 */,    W64LIT(0x298EF221898DB0E7)   /*  717 */,
        W64LIT(0x55000029D1A5AA7E)   /*  718 */,    W64LIT(0x8BC08AE1B5061B45)   /*  719 */,
        W64LIT(0xC2C31C2B6C92703A)   /*  720 */,    W64LIT(0x94CC596BAF25EF42)   /*  721 */,
        W64LIT(0x0A1D73DB22540456)   /*  722 */,    W64LIT(0x04B6A0F9D9C4179A)   /*  723 */,
        W64LIT(0xEFFDAFA2AE3D3C60)   /*  724 */,    W64LIT(0xF7C8075BB49496C4)   /*  725 */,
        W64LIT(0x9CC5C7141D1CD4E3)   /*  726 */,    W64LIT(0x78BD1638218E5534)   /*  727 */,
        W64LIT(0xB2F11568F850246A)   /*  728 */,    W64LIT(0xEDFABCFA9502BC29)   /*  729 */,
        W64LIT(0x796CE5F2DA23051B)   /*  730 */,    W64LIT(0xAAE128B0DC93537C)   /*  731 */,
        W64LIT(0x3A493DA0EE4B29AE)   /*  732 */,    W64LIT(0xB5DF6B2C416895D7)   /*  733 */,
        W64LIT(0xFCABBD25122D7F37)   /*  734 */,    W64LIT(0x70810B58105DC4B1)   /*  735 */,
        W64LIT(0xE10FDD37F7882A90)   /*  736 */,    W64LIT(0x524DCAB5518A3F5C)   /*  737 */,
        W64LIT(0x3C9E85878451255B)   /*  738 */,    W64LIT(0x4029828119BD34E2)   /*  739 */,
        W64LIT(0x74A05B6F5D3CECCB)   /*  740 */,    W64LIT(0xB610021542E13ECA)   /*  741 */,
        W64LIT(0x0FF979D12F59E2AC)   /*  742 */,    W64LIT(0x6037DA27E4F9CC50)   /*  743 */,
        W64LIT(0x5E92975A0DF1847D)   /*  744 */,    W64LIT(0xD66DE190D3E623FE)   /*  745 */,
        W64LIT(0x5032D6B87B568048)   /*  746 */,    W64LIT(0x9A36B7CE8235216E)   /*  747 */,
        W64LIT(0x80272A7A24F64B4A)   /*  748 */,    W64LIT(0x93EFED8B8C6916F7)   /*  749 */,
        W64LIT(0x37DDBFF44CCE1555)   /*  750 */,    W64LIT(0x4B95DB5D4B99BD25)   /*  751 */,
        W64LIT(0x92D3FDA169812FC0)   /*  752 */,    W64LIT(0xFB1A4A9A90660BB6)   /*  753 */,
        W64LIT(0x730C196946A4B9B2)   /*  754 */,    W64LIT(0x81E289AA7F49DA68)   /*  755 */,
        W64LIT(0x64669A0F83B1A05F)   /*  756 */,    W64LIT(0x27B3FF7D9644F48B)   /*  757 */,
        W64LIT(0xCC6B615C8DB675B3)   /*  758 */,    W64LIT(0x674F20B9BCEBBE95)   /*  759 */,
        W64LIT(0x6F31238275655982)   /*  760 */,    W64LIT(0x5AE488713E45CF05)   /*  761 */,
        W64LIT(0xBF619F9954C21157)   /*  762 */,    W64LIT(0xEABAC46040A8EAE9)   /*  763 */,
        W64LIT(0x454C6FE9F2C0C1CD)   /*  764 */,    W64LIT(0x419CF6496412691C)   /*  765 */,
        W64LIT(0xD3DC3BEF265B0F70)   /*  766 */,    W64LIT(0x6D0E60F5C3578A9E)   /*  767 */,
        W64LIT(0x5B0E608526323C55)   /*  768 */,    W64LIT(0x1A46C1A9FA1B59F5)   /*  769 */,
        W64LIT(0xA9E245A17C4C8FFA)   /*  770 */,    W64LIT(0x65CA5159DB2955D7)   /*  771 */,
        W64LIT(0x05DB0A76CE35AFC2)   /*  772 */,    W64LIT(0x81EAC77EA9113D45)   /*  773 */,
        W64LIT(0x528EF88AB6AC0A0D)   /*  774 */,    W64LIT(0xA09EA253597BE3FF)   /*  775 */,
        W64LIT(0x430DDFB3AC48CD56)   /*  776 */,    W64LIT(0xC4B3A67AF45CE46F)   /*  777 */,
        W64LIT(0x4ECECFD8FBE2D05E)   /*  778 */,    W64LIT(0x3EF56F10B39935F0)   /*  779 */,
        W64LIT(0x0B22D6829CD619C6)   /*  780 */,    W64LIT(0x17FD460A74DF2069)   /*  781 */,
        W64LIT(0x6CF8CC8E8510ED40)   /*  782 */,    W64LIT(0xD6C824BF3A6ECAA7)   /*  783 */,
        W64LIT(0x61243D581A817049)   /*  784 */,    W64LIT(0x048BACB6BBC163A2)   /*  785 */,
        W64LIT(0xD9A38AC27D44CC32)   /*  786 */,    W64LIT(0x7FDDFF5BAAF410AB)   /*  787 */,
        W64LIT(0xAD6D495AA804824B)   /*  788 */,    W64LIT(0xE1A6A74F2D8C9F94)   /*  789 */,
        W64LIT(0xD4F7851235DEE8E3)   /*  790 */,    W64LIT(0xFD4B7F886540D893)   /*  791 */,
        W64LIT(0x247C20042AA4BFDA)   /*  792 */,    W64LIT(0x096EA1C517D1327C)   /*  793 */,
        W64LIT(0xD56966B4361A6685)   /*  794 */,    W64LIT(0x277DA5C31221057D)   /*  795 */,
        W64LIT(0x94D59893A43ACFF7)   /*  796 */,    W64LIT(0x64F0C51CCDC02281)   /*  797 */,
        W64LIT(0x3D33BCC4FF6189DB)   /*  798 */,    W64LIT(0xE005CB184CE66AF1)   /*  799 */,
        W64LIT(0xFF5CCD1D1DB99BEA)   /*  800 */,    W64LIT(0xB0B854A7FE42980F)   /*  801 */,
        W64LIT(0x7BD46A6A718D4B9F)   /*  802 */,    W64LIT(0xD10FA8CC22A5FD8C)   /*  803 */,
        W64LIT(0xD31484952BE4BD31)   /*  804 */,    W64LIT(0xC7FA975FCB243847)   /*  805 */,
        W64LIT(0x4886ED1E5846C407)   /*  806 */,    W64LIT(0x28CDDB791EB70B04)   /*  807 */,
        W64LIT(0xC2B00BE2F573417F)   /*  808 */,    W64LIT(0x5C9590452180F877)   /*  809 */,
        W64LIT(0x7A6BDDFFF370EB00)   /*  810 */,    W64LIT(0xCE509E38D6D9D6A4)   /*  811 */,
        W64LIT(0xEBEB0F00647FA702)   /*  812 */,    W64LIT(0x1DCC06CF76606F06)   /*  813 */,
        W64LIT(0xE4D9F28BA286FF0A)   /*  814 */,    W64LIT(0xD85A305DC918C262)   /*  815 */,
        W64LIT(0x475B1D8732225F54)   /*  816 */,    W64LIT(0x2D4FB51668CCB5FE)   /*  817 */,
        W64LIT(0xA679B9D9D72BBA20)   /*  818 */,    W64LIT(0x53841C0D912D43A5)   /*  819 */,
        W64LIT(0x3B7EAA48BF12A4E8)   /*  820 */,    W64LIT(0x781E0E47F22F1DDF)   /*  821 */,
        W64LIT(0xEFF20CE60AB50973)   /*  822 */,    W64LIT(0x20D261D19DFFB742)   /*  823 */,
        W64LIT(0x16A12B03062A2E39)   /*  824 */,    W64LIT(0x1960EB2239650495)   /*  825 */,
        W64LIT(0x251C16FED50EB8B8)   /*  826 */,    W64LIT(0x9AC0C330F826016E)   /*  827 */,
        W64LIT(0xED152665953E7671)   /*  828 */,    W64LIT(0x02D63194A6369570)   /*  829 */,
        W64LIT(0x5074F08394B1C987)   /*  830 */,    W64LIT(0x70BA598C90B25CE1)   /*  831 */,
        W64LIT(0x794A15810B9742F6)   /*  832 */,    W64LIT(0x0D5925E9FCAF8C6C)   /*  833 */,
        W64LIT(0x3067716CD868744E)   /*  834 */,    W64LIT(0x910AB077E8D7731B)   /*  835 */,
        W64LIT(0x6A61BBDB5AC42F61)   /*  836 */,    W64LIT(0x93513EFBF0851567)   /*  837 */,
        W64LIT(0xF494724B9E83E9D5)   /*  838 */,    W64LIT(0xE887E1985C09648D)   /*  839 */,
        W64LIT(0x34B1D3C675370CFD)   /*  840 */,    W64LIT(0xDC35E433BC0D255D)   /*  841 */,
        W64LIT(0xD0AAB84234131BE0)   /*  842 */,    W64LIT(0x08042A50B48B7EAF)   /*  843 */,
        W64LIT(0x9997C4EE44A3AB35)   /*  844 */,    W64LIT(0x829A7B49201799D0)   /*  845 */,
        W64LIT(0x263B8307B7C54441)   /*  846 */,    W64LIT(0x752F95F4FD6A6CA6)   /*  847 */,
        W64LIT(0x927217402C08C6E5)   /*  848 */,    W64LIT(0x2A8AB754A795D9EE)   /*  849 */,
        W64LIT(0xA442F7552F72943D)   /*  850 */,    W64LIT(0x2C31334E19781208)   /*  851 */,
        W64LIT(0x4FA98D7CEAEE6291)   /*  852 */,    W64LIT(0x55C3862F665DB309)   /*  853 */,
        W64LIT(0xBD0610175D53B1F3)   /*  854 */,    W64LIT(0x46FE6CB840413F27)   /*  855 */,
        W64LIT(0x3FE03792DF0CFA59)   /*  856 */,    W64LIT(0xCFE700372EB85E8F)   /*  857 */,
        W64LIT(0xA7BE29E7ADBCE118)   /*  858 */,    W64LIT(0xE544EE5CDE8431DD)   /*  859 */,
        W64LIT(0x8A781B1B41F1873E)   /*  860 */,    W64LIT(0xA5C94C78A0D2F0E7)   /*  861 */,
        W64LIT(0x39412E2877B60728)   /*  862 */,    W64LIT(0xA1265EF3AFC9A62C)   /*  863 */,
        W64LIT(0xBCC2770C6A2506C5)   /*  864 */,    W64LIT(0x3AB66DD5DCE1CE12)   /*  865 */,
        W64LIT(0xE65499D04A675B37)   /*  866 */,    W64LIT(0x7D8F523481BFD216)   /*  867 */,
        W64LIT(0x0F6F64FCEC15F389)   /*  868 */,    W64LIT(0x74EFBE618B5B13C8)   /*  869 */,
        W64LIT(0xACDC82B714273E1D)   /*  870 */,    W64LIT(0xDD40BFE003199D17)   /*  871 */,
        W64LIT(0x37E99257E7E061F8)   /*  872 */,    W64LIT(0xFA52626904775AAA)   /*  873 */,
        W64LIT(0x8BBBF63A463D56F9)   /*  874 */,    W64LIT(0xF0013F1543A26E64)   /*  875 */,
        W64LIT(0xA8307E9F879EC898)   /*  876 */,    W64LIT(0xCC4C27A4150177CC)   /*  877 */,
        W64LIT(0x1B432F2CCA1D3348)   /*  878 */,    W64LIT(0xDE1D1F8F9F6FA013)   /*  879 */,
        W64LIT(0x606602A047A7DDD6)   /*  880 */,    W64LIT(0xD237AB64CC1CB2C7)   /*  881 */,
        W64LIT(0x9B938E7225FCD1D3)   /*  882 */,    W64LIT(0xEC4E03708E0FF476)   /*  883 */,
        W64LIT(0xFEB2FBDA3D03C12D)   /*  884 */,    W64LIT(0xAE0BCED2EE43889A)   /*  885 */,
        W64LIT(0x22CB8923EBFB4F43)   /*  886 */,    W64LIT(0x69360D013CF7396D)   /*  887 */,
        W64LIT(0x855E3602D2D4E022)   /*  888 */,    W64LIT(0x073805BAD01F784C)   /*  889 */,
        W64LIT(0x33E17A133852F546)   /*  890 */,    W64LIT(0xDF4874058AC7B638)   /*  891 */,
        W64LIT(0xBA92B29C678AA14A)   /*  892 */,    W64LIT(0x0CE89FC76CFAADCD)   /*  893 */,
        W64LIT(0x5F9D4E0908339E34)   /*  894 */,    W64LIT(0xF1AFE9291F5923B9)   /*  895 */,
        W64LIT(0x6E3480F60F4A265F)   /*  896 */,    W64LIT(0xEEBF3A2AB29B841C)   /*  897 */,
        W64LIT(0xE21938A88F91B4AD)   /*  898 */,    W64LIT(0x57DFEFF845C6D3C3)   /*  899 */,
        W64LIT(0x2F006B0BF62CAAF2)   /*  900 */,    W64LIT(0x62F479EF6F75EE78)   /*  901 */,
        W64LIT(0x11A55AD41C8916A9)   /*  902 */,    W64LIT(0xF229D29084FED453)   /*  903 */,
        W64LIT(0x42F1C27B16B000E6)   /*  904 */,    W64LIT(0x2B1F76749823C074)   /*  905 */,
        W64LIT(0x4B76ECA3C2745360)   /*  906 */,    W64LIT(0x8C98F463B91691BD)   /*  907 */,
        W64LIT(0x14BCC93CF1ADE66A)   /*  908 */,    W64LIT(0x8885213E6D458397)   /*  909 */,
        W64LIT(0x8E177DF0274D4711)   /*  910 */,    W64LIT(0xB49B73B5503F2951)   /*  911 */,
        W64LIT(0x10168168C3F96B6B)   /*  912 */,    W64LIT(0x0E3D963B63CAB0AE)   /*  913 */,
        W64LIT(0x8DFC4B5655A1DB14)   /*  914 */,    W64LIT(0xF789F1356E14DE5C)   /*  915 */,
        W64LIT(0x683E68AF4E51DAC1)   /*  916 */,    W64LIT(0xC9A84F9D8D4B0FD9)   /*  917 */,
        W64LIT(0x3691E03F52A0F9D1)   /*  918 */,    W64LIT(0x5ED86E46E1878E80)   /*  919 */,
        W64LIT(0x3C711A0E99D07150)   /*  920 */,    W64LIT(0x5A0865B20C4E9310)   /*  921 */,
        W64LIT(0x56FBFC1FE4F0682E)   /*  922 */,    W64LIT(0xEA8D5DE3105EDF9B)   /*  923 */,
        W64LIT(0x71ABFDB12379187A)   /*  924 */,    W64LIT(0x2EB99DE1BEE77B9C)   /*  925 */,
        W64LIT(0x21ECC0EA33CF4523)   /*  926 */,    W64LIT(0x59A4D7521805C7A1)   /*  927 */,
        W64LIT(0x3896F5EB56AE7C72)   /*  928 */,    W64LIT(0xAA638F3DB18F75DC)   /*  929 */,
        W64LIT(0x9F39358DABE9808E)   /*  930 */,    W64LIT(0xB7DEFA91C00B72AC)   /*  931 */,
        W64LIT(0x6B5541FD62492D92)   /*  932 */,    W64LIT(0x6DC6DEE8F92E4D5B)   /*  933 */,
        W64LIT(0x353F57ABC4BEEA7E)   /*  934 */,    W64LIT(0x735769D6DA5690CE)   /*  935 */,
        W64LIT(0x0A234AA642391484)   /*  936 */,    W64LIT(0xF6F9508028F80D9D)   /*  937 */,
        W64LIT(0xB8E319A27AB3F215)   /*  938 */,    W64LIT(0x31AD9C1151341A4D)   /*  939 */,
        W64LIT(0x773C22A57BEF5805)   /*  940 */,    W64LIT(0x45C7561A07968633)   /*  941 */,
        W64LIT(0xF913DA9E249DBE36)   /*  942 */,    W64LIT(0xDA652D9B78A64C68)   /*  943 */,
        W64LIT(0x4C27A97F3BC334EF)   /*  944 */,    W64LIT(0x76621220E66B17F4)   /*  945 */,
        W64LIT(0x967743899ACD7D0B)   /*  946 */,    W64LIT(0xF3EE5BCAE0ED6782)   /*  947 */,
        W64LIT(0x409F753600C879FC)   /*  948 */,    W64LIT(0x06D09A39B5926DB6)   /*  949 */,
        W64LIT(0x6F83AEB0317AC588)   /*  950 */,    W64LIT(0x01E6CA4A86381F21)   /*  951 */,
        W64LIT(0x66FF3462D19F3025)   /*  952 */,    W64LIT(0x72207C24DDFD3BFB)   /*  953 */,
        W64LIT(0x4AF6B6D3E2ECE2EB)   /*  954 */,    W64LIT(0x9C994DBEC7EA08DE)   /*  955 */,
        W64LIT(0x49ACE597B09A8BC4)   /*  956 */,    W64LIT(0xB38C4766CF0797BA)   /*  957 */,
        W64LIT(0x131B9373C57C2A75)   /*  958 */,    W64LIT(0xB1822CCE61931E58)   /*  959 */,
        W64LIT(0x9D7555B909BA1C0C)   /*  960 */,    W64LIT(0x127FAFDD937D11D2)   /*  961 */,
        W64LIT(0x29DA3BADC66D92E4)   /*  962 */,    W64LIT(0xA2C1D57154C2ECBC)   /*  963 */,
        W64LIT(0x58C5134D82F6FE24)   /*  964 */,    W64LIT(0x1C3AE3515B62274F)   /*  965 */,
        W64LIT(0xE907C82E01CB8126)   /*  966 */,    W64LIT(0xF8ED091913E37FCB)   /*  967 */,
        W64LIT(0x3249D8F9C80046C9)   /*  968 */,    W64LIT(0x80CF9BEDE388FB63)   /*  969 */,
        W64LIT(0x1881539A116CF19E)   /*  970 */,    W64LIT(0x5103F3F76BD52457)   /*  971 */,
        W64LIT(0x15B7E6F5AE47F7A8)   /*  972 */,    W64LIT(0xDBD7C6DED47E9CCF)   /*  973 */,
        W64LIT(0x44E55C410228BB1A)   /*  974 */,    W64LIT(0xB647D4255EDB4E99)   /*  975 */,
        W64LIT(0x5D11882BB8AAFC30)   /*  976 */,    W64LIT(0xF5098BBB29D3212A)   /*  977 */,
        W64LIT(0x8FB5EA14E90296B3)   /*  978 */,    W64LIT(0x677B942157DD025A)   /*  979 */,
        W64LIT(0xFB58E7C0A390ACB5)   /*  980 */,    W64LIT(0x89D3674C83BD4A01)   /*  981 */,
        W64LIT(0x9E2DA4DF4BF3B93B)   /*  982 */,    W64LIT(0xFCC41E328CAB4829)   /*  983 */,
        W64LIT(0x03F38C96BA582C52)   /*  984 */,    W64LIT(0xCAD1BDBD7FD85DB2)   /*  985 */,
        W64LIT(0xBBB442C16082AE83)   /*  986 */,    W64LIT(0xB95FE86BA5DA9AB0)   /*  987 */,
        W64LIT(0xB22E04673771A93F)   /*  988 */,    W64LIT(0x845358C9493152D8)   /*  989 */,
        W64LIT(0xBE2A488697B4541E)   /*  990 */,    W64LIT(0x95A2DC2DD38E6966)   /*  991 */,
        W64LIT(0xC02C11AC923C852B)   /*  992 */,    W64LIT(0x2388B1990DF2A87B)   /*  993 */,
        W64LIT(0x7C8008FA1B4F37BE)   /*  994 */,    W64LIT(0x1F70D0C84D54E503)   /*  995 */,
        W64LIT(0x5490ADEC7ECE57D4)   /*  996 */,    W64LIT(0x002B3C27D9063A3A)   /*  997 */,
        W64LIT(0x7EAEA3848030A2BF)   /*  998 */,    W64LIT(0xC602326DED2003C0)   /*  999 */,
        W64LIT(0x83A7287D69A94086)   /* 1000 */,    W64LIT(0xC57A5FCB30F57A8A)   /* 1001 */,
        W64LIT(0xB56844E479EBE779)   /* 1002 */,    W64LIT(0xA373B40F05DCBCE9)   /* 1003 */,
        W64LIT(0xD71A786E88570EE2)   /* 1004 */,    W64LIT(0x879CBACDBDE8F6A0)   /* 1005 */,
        W64LIT(0x976AD1BCC164A32F)   /* 1006 */,    W64LIT(0xAB21E25E9666D78B)   /* 1007 */,
        W64LIT(0x901063AAE5E5C33C)   /* 1008 */,    W64LIT(0x9818B34448698D90)   /* 1009 */,
        W64LIT(0xE36487AE3E1E8ABB)   /* 1010 */,    W64LIT(0xAFBDF931893BDCB4)   /* 1011 */,
        W64LIT(0x6345A0DC5FBBD519)   /* 1012 */,    W64LIT(0x8628FE269B9465CA)   /* 1013 */,
        W64LIT(0x1E5D01603F9C51EC)   /* 1014 */,    W64LIT(0x4DE44006A15049B7)   /* 1015 */,
        W64LIT(0xBF6C70E5F776CBB1)   /* 1016 */,    W64LIT(0x411218F2EF552BED)   /* 1017 */,
        W64LIT(0xCB0C0708705A36A3)   /* 1018 */,    W64LIT(0xE74D14754F986044)   /* 1019 */,
        W64LIT(0xCD56D9430EA8280E)   /* 1020 */,    W64LIT(0xC12591D7535F5065)   /* 1021 */,
        W64LIT(0xC83223F1720AEF96)   /* 1022 */,    W64LIT(0xC3A0396F7363A51F)   /* 1023 */
};

//-----------------
static const byte Twofish_q[2*256] = {
   0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78,
   0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C,
   0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30,
   0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82,
   0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE,
   0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B,
   0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45,
   0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7,
   0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF,
   0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8,
   0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED,
   0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90,
   0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B,
   0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B,
   0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F,
   0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A,
   0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17,
   0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72,
   0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68,
   0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4,
   0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42,
   0x4A, 0x5E, 0xC1, 0xE0,

   0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B,
   0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1,
   0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B,
   0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5,
   0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54,
   0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96,
   0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7,
   0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8,
   0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF,
   0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9,
   0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D,
   0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E,
   0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21,
   0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01,
   0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E,
   0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64,
   0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44,
   0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E,
   0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B,
   0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9,
   0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56,
   0x55, 0x09, 0xBE, 0x91
};

static const word32 Twofish_mds[4*256] = {
        0xbcbc3275, 0xecec21f3, 0x202043c6, 0xb3b3c9f4,
        0xdada03db, 0x02028b7b, 0xe2e22bfb, 0x9e9efac8,
        0xc9c9ec4a, 0xd4d409d3, 0x18186be6, 0x1e1e9f6b,
        0x98980e45, 0xb2b2387d, 0xa6a6d2e8, 0x2626b74b,
        0x3c3c57d6, 0x93938a32, 0x8282eed8, 0x525298fd,
        0x7b7bd437, 0xbbbb3771, 0x5b5b97f1, 0x474783e1,
        0x24243c30, 0x5151e20f, 0xbabac6f8, 0x4a4af31b,
        0xbfbf4887, 0x0d0d70fa, 0xb0b0b306, 0x7575de3f,
        0xd2d2fd5e, 0x7d7d20ba, 0x666631ae, 0x3a3aa35b,
        0x59591c8a, 0x00000000, 0xcdcd93bc, 0x1a1ae09d,
        0xaeae2c6d, 0x7f7fabc1, 0x2b2bc7b1, 0xbebeb90e,
        0xe0e0a080, 0x8a8a105d, 0x3b3b52d2, 0x6464bad5,
        0xd8d888a0, 0xe7e7a584, 0x5f5fe807, 0x1b1b1114,
        0x2c2cc2b5, 0xfcfcb490, 0x3131272c, 0x808065a3,
        0x73732ab2, 0x0c0c8173, 0x79795f4c, 0x6b6b4154,
        0x4b4b0292, 0x53536974, 0x94948f36, 0x83831f51,
        0x2a2a3638, 0xc4c49cb0, 0x2222c8bd, 0xd5d5f85a,
        0xbdbdc3fc, 0x48487860, 0xffffce62, 0x4c4c0796,
        0x4141776c, 0xc7c7e642, 0xebeb24f7, 0x1c1c1410,
        0x5d5d637c, 0x36362228, 0x6767c027, 0xe9e9af8c,
        0x4444f913, 0x1414ea95, 0xf5f5bb9c, 0xcfcf18c7,
        0x3f3f2d24, 0xc0c0e346, 0x7272db3b, 0x54546c70,
        0x29294cca, 0xf0f035e3, 0x0808fe85, 0xc6c617cb,
        0xf3f34f11, 0x8c8ce4d0, 0xa4a45993, 0xcaca96b8,
        0x68683ba6, 0xb8b84d83, 0x38382820, 0xe5e52eff,
        0xadad569f, 0x0b0b8477, 0xc8c81dc3, 0x9999ffcc,
        0x5858ed03, 0x19199a6f, 0x0e0e0a08, 0x95957ebf,
        0x70705040, 0xf7f730e7, 0x6e6ecf2b, 0x1f1f6ee2,
        0xb5b53d79, 0x09090f0c, 0x616134aa, 0x57571682,
        0x9f9f0b41, 0x9d9d803a, 0x111164ea, 0x2525cdb9,
        0xafafdde4, 0x4545089a, 0xdfdf8da4, 0xa3a35c97,
        0xeaead57e, 0x353558da, 0xededd07a, 0x4343fc17,
        0xf8f8cb66, 0xfbfbb194, 0x3737d3a1, 0xfafa401d,
        0xc2c2683d, 0xb4b4ccf0, 0x32325dde, 0x9c9c71b3,
        0x5656e70b, 0xe3e3da72, 0x878760a7, 0x15151b1c,
        0xf9f93aef, 0x6363bfd1, 0x3434a953, 0x9a9a853e,
        0xb1b1428f, 0x7c7cd133, 0x88889b26, 0x3d3da65f,
        0xa1a1d7ec, 0xe4e4df76, 0x8181942a, 0x91910149,
        0x0f0ffb81, 0xeeeeaa88, 0x161661ee, 0xd7d77321,
        0x9797f5c4, 0xa5a5a81a, 0xfefe3feb, 0x6d6db5d9,
        0x7878aec5, 0xc5c56d39, 0x1d1de599, 0x7676a4cd,
        0x3e3edcad, 0xcbcb6731, 0xb6b6478b, 0xefef5b01,
        0x12121e18, 0x6060c523, 0x6a6ab0dd, 0x4d4df61f,
        0xcecee94e, 0xdede7c2d, 0x55559df9, 0x7e7e5a48,
        0x2121b24f, 0x03037af2, 0xa0a02665, 0x5e5e198e,
        0x5a5a6678, 0x65654b5c, 0x62624e58, 0xfdfd4519,
        0x0606f48d, 0x404086e5, 0xf2f2be98, 0x3333ac57,
        0x17179067, 0x05058e7f, 0xe8e85e05, 0x4f4f7d64,
        0x89896aaf, 0x10109563, 0x74742fb6, 0x0a0a75fe,
        0x5c5c92f5, 0x9b9b74b7, 0x2d2d333c, 0x3030d6a5,
        0x2e2e49ce, 0x494989e9, 0x46467268, 0x77775544,
        0xa8a8d8e0, 0x9696044d, 0x2828bd43, 0xa9a92969,
        0xd9d97929, 0x8686912e, 0xd1d187ac, 0xf4f44a15,
        0x8d8d1559, 0xd6d682a8, 0xb9b9bc0a, 0x42420d9e,
        0xf6f6c16e, 0x2f2fb847, 0xdddd06df, 0x23233934,
        0xcccc6235, 0xf1f1c46a, 0xc1c112cf, 0x8585ebdc,
        0x8f8f9e22, 0x7171a1c9, 0x9090f0c0, 0xaaaa539b,
        0x0101f189, 0x8b8be1d4, 0x4e4e8ced, 0x8e8e6fab,
        0xababa212, 0x6f6f3ea2, 0xe6e6540d, 0xdbdbf252,
        0x92927bbb, 0xb7b7b602, 0x6969ca2f, 0x3939d9a9,
        0xd3d30cd7, 0xa7a72361, 0xa2a2ad1e, 0xc3c399b4,
        0x6c6c4450, 0x07070504, 0x04047ff6, 0x272746c2,
        0xacaca716, 0xd0d07625, 0x50501386, 0xdcdcf756,
        0x84841a55, 0xe1e15109, 0x7a7a25be, 0x1313ef91,

        0xa9d93939, 0x67901717, 0xb3719c9c, 0xe8d2a6a6,
        0x04050707, 0xfd985252, 0xa3658080, 0x76dfe4e4,
        0x9a084545, 0x92024b4b, 0x80a0e0e0, 0x78665a5a,
        0xe4ddafaf, 0xddb06a6a, 0xd1bf6363, 0x38362a2a,
        0x0d54e6e6, 0xc6432020, 0x3562cccc, 0x98bef2f2,
        0x181e1212, 0xf724ebeb, 0xecd7a1a1, 0x6c774141,
        0x43bd2828, 0x7532bcbc, 0x37d47b7b, 0x269b8888,
        0xfa700d0d, 0x13f94444, 0x94b1fbfb, 0x485a7e7e,
        0xf27a0303, 0xd0e48c8c, 0x8b47b6b6, 0x303c2424,
        0x84a5e7e7, 0x54416b6b, 0xdf06dddd, 0x23c56060,
        0x1945fdfd, 0x5ba33a3a, 0x3d68c2c2, 0x59158d8d,
        0xf321ecec, 0xae316666, 0xa23e6f6f, 0x82165757,
        0x63951010, 0x015befef, 0x834db8b8, 0x2e918686,
        0xd9b56d6d, 0x511f8383, 0x9b53aaaa, 0x7c635d5d,
        0xa63b6868, 0xeb3ffefe, 0xa5d63030, 0xbe257a7a,
        0x16a7acac, 0x0c0f0909, 0xe335f0f0, 0x6123a7a7,
        0xc0f09090, 0x8cafe9e9, 0x3a809d9d, 0xf5925c5c,
        0x73810c0c, 0x2c273131, 0x2576d0d0, 0x0be75656,
        0xbb7b9292, 0x4ee9cece, 0x89f10101, 0x6b9f1e1e,
        0x53a93434, 0x6ac4f1f1, 0xb499c3c3, 0xf1975b5b,
        0xe1834747, 0xe66b1818, 0xbdc82222, 0x450e9898,
        0xe26e1f1f, 0xf4c9b3b3, 0xb62f7474, 0x66cbf8f8,
        0xccff9999, 0x95ea1414, 0x03ed5858, 0x56f7dcdc,
        0xd4e18b8b, 0x1c1b1515, 0x1eada2a2, 0xd70cd3d3,
        0xfb2be2e2, 0xc31dc8c8, 0x8e195e5e, 0xb5c22c2c,
        0xe9894949, 0xcf12c1c1, 0xbf7e9595, 0xba207d7d,
        0xea641111, 0x77840b0b, 0x396dc5c5, 0xaf6a8989,
        0x33d17c7c, 0xc9a17171, 0x62ceffff, 0x7137bbbb,
        0x81fb0f0f, 0x793db5b5, 0x0951e1e1, 0xaddc3e3e,
        0x242d3f3f, 0xcda47676, 0xf99d5555, 0xd8ee8282,
        0xe5864040, 0xc5ae7878, 0xb9cd2525, 0x4d049696,
        0x44557777, 0x080a0e0e, 0x86135050, 0xe730f7f7,
        0xa1d33737, 0x1d40fafa, 0xaa346161, 0xed8c4e4e,
        0x06b3b0b0, 0x706c5454, 0xb22a7373, 0xd2523b3b,
        0x410b9f9f, 0x7b8b0202, 0xa088d8d8, 0x114ff3f3,
        0x3167cbcb, 0xc2462727, 0x27c06767, 0x90b4fcfc,
        0x20283838, 0xf67f0404, 0x60784848, 0xff2ee5e5,
        0x96074c4c, 0x5c4b6565, 0xb1c72b2b, 0xab6f8e8e,
        0x9e0d4242, 0x9cbbf5f5, 0x52f2dbdb, 0x1bf34a4a,
        0x5fa63d3d, 0x9359a4a4, 0x0abcb9b9, 0xef3af9f9,
        0x91ef1313, 0x85fe0808, 0x49019191, 0xee611616,
        0x2d7cdede, 0x4fb22121, 0x8f42b1b1, 0x3bdb7272,
        0x47b82f2f, 0x8748bfbf, 0x6d2caeae, 0x46e3c0c0,
        0xd6573c3c, 0x3e859a9a, 0x6929a9a9, 0x647d4f4f,
        0x2a948181, 0xce492e2e, 0xcb17c6c6, 0x2fca6969,
        0xfcc3bdbd, 0x975ca3a3, 0x055ee8e8, 0x7ad0eded,
        0xac87d1d1, 0x7f8e0505, 0xd5ba6464, 0x1aa8a5a5,
        0x4bb72626, 0x0eb9bebe, 0xa7608787, 0x5af8d5d5,
        0x28223636, 0x14111b1b, 0x3fde7575, 0x2979d9d9,
        0x88aaeeee, 0x3c332d2d, 0x4c5f7979, 0x02b6b7b7,
        0xb896caca, 0xda583535, 0xb09cc4c4, 0x17fc4343,
        0x551a8484, 0x1ff64d4d, 0x8a1c5959, 0x7d38b2b2,
        0x57ac3333, 0xc718cfcf, 0x8df40606, 0x74695353,
        0xb7749b9b, 0xc4f59797, 0x9f56adad, 0x72dae3e3,
        0x7ed5eaea, 0x154af4f4, 0x229e8f8f, 0x12a2abab,
        0x584e6262, 0x07e85f5f, 0x99e51d1d, 0x34392323,
        0x6ec1f6f6, 0x50446c6c, 0xde5d3232, 0x68724646,
        0x6526a0a0, 0xbc93cdcd, 0xdb03dada, 0xf8c6baba,
        0xc8fa9e9e, 0xa882d6d6, 0x2bcf6e6e, 0x40507070,
        0xdceb8585, 0xfe750a0a, 0x328a9393, 0xa48ddfdf,
        0xca4c2929, 0x10141c1c, 0x2173d7d7, 0xf0ccb4b4,
        0xd309d4d4, 0x5d108a8a, 0x0fe25151, 0x00000000,
        0x6f9a1919, 0x9de01a1a, 0x368f9494, 0x42e6c7c7,
        0x4aecc9c9, 0x5efdd2d2, 0xc1ab7f7f, 0xe0d8a8a8,

        0xbc75bc32, 0xecf3ec21, 0x20c62043, 0xb3f4b3c9,
        0xdadbda03, 0x027b028b, 0xe2fbe22b, 0x9ec89efa,
        0xc94ac9ec, 0xd4d3d409, 0x18e6186b, 0x1e6b1e9f,
        0x9845980e, 0xb27db238, 0xa6e8a6d2, 0x264b26b7,
        0x3cd63c57, 0x9332938a, 0x82d882ee, 0x52fd5298,
        0x7b377bd4, 0xbb71bb37, 0x5bf15b97, 0x47e14783,
        0x2430243c, 0x510f51e2, 0xbaf8bac6, 0x4a1b4af3,
        0xbf87bf48, 0x0dfa0d70, 0xb006b0b3, 0x753f75de,
        0xd25ed2fd, 0x7dba7d20, 0x66ae6631, 0x3a5b3aa3,
        0x598a591c, 0x00000000, 0xcdbccd93, 0x1a9d1ae0,
        0xae6dae2c, 0x7fc17fab, 0x2bb12bc7, 0xbe0ebeb9,
        0xe080e0a0, 0x8a5d8a10, 0x3bd23b52, 0x64d564ba,
        0xd8a0d888, 0xe784e7a5, 0x5f075fe8, 0x1b141b11,
        0x2cb52cc2, 0xfc90fcb4, 0x312c3127, 0x80a38065,
        0x73b2732a, 0x0c730c81, 0x794c795f, 0x6b546b41,
        0x4b924b02, 0x53745369, 0x9436948f, 0x8351831f,
        0x2a382a36, 0xc4b0c49c, 0x22bd22c8, 0xd55ad5f8,
        0xbdfcbdc3, 0x48604878, 0xff62ffce, 0x4c964c07,
        0x416c4177, 0xc742c7e6, 0xebf7eb24, 0x1c101c14,
        0x5d7c5d63, 0x36283622, 0x672767c0, 0xe98ce9af,
        0x441344f9, 0x149514ea, 0xf59cf5bb, 0xcfc7cf18,
        0x3f243f2d, 0xc046c0e3, 0x723b72db, 0x5470546c,
        0x29ca294c, 0xf0e3f035, 0x088508fe, 0xc6cbc617,
        0xf311f34f, 0x8cd08ce4, 0xa493a459, 0xcab8ca96,
        0x68a6683b, 0xb883b84d, 0x38203828, 0xe5ffe52e,
        0xad9fad56, 0x0b770b84, 0xc8c3c81d, 0x99cc99ff,
        0x580358ed, 0x196f199a, 0x0e080e0a, 0x95bf957e,
        0x70407050, 0xf7e7f730, 0x6e2b6ecf, 0x1fe21f6e,
        0xb579b53d, 0x090c090f, 0x61aa6134, 0x57825716,
        0x9f419f0b, 0x9d3a9d80, 0x11ea1164, 0x25b925cd,
        0xafe4afdd, 0x459a4508, 0xdfa4df8d, 0xa397a35c,
        0xea7eead5, 0x35da3558, 0xed7aedd0, 0x431743fc,
        0xf866f8cb, 0xfb94fbb1, 0x37a137d3, 0xfa1dfa40,
        0xc23dc268, 0xb4f0b4cc, 0x32de325d, 0x9cb39c71,
        0x560b56e7, 0xe372e3da, 0x87a78760, 0x151c151b,
        0xf9eff93a, 0x63d163bf, 0x345334a9, 0x9a3e9a85,
        0xb18fb142, 0x7c337cd1, 0x8826889b, 0x3d5f3da6,
        0xa1eca1d7, 0xe476e4df, 0x812a8194, 0x91499101,
        0x0f810ffb, 0xee88eeaa, 0x16ee1661, 0xd721d773,
        0x97c497f5, 0xa51aa5a8, 0xfeebfe3f, 0x6dd96db5,
        0x78c578ae, 0xc539c56d, 0x1d991de5, 0x76cd76a4,
        0x3ead3edc, 0xcb31cb67, 0xb68bb647, 0xef01ef5b,
        0x1218121e, 0x602360c5, 0x6add6ab0, 0x4d1f4df6,
        0xce4ecee9, 0xde2dde7c, 0x55f9559d, 0x7e487e5a,
        0x214f21b2, 0x03f2037a, 0xa065a026, 0x5e8e5e19,
        0x5a785a66, 0x655c654b, 0x6258624e, 0xfd19fd45,
        0x068d06f4, 0x40e54086, 0xf298f2be, 0x335733ac,
        0x17671790, 0x057f058e, 0xe805e85e, 0x4f644f7d,
        0x89af896a, 0x10631095, 0x74b6742f, 0x0afe0a75,
        0x5cf55c92, 0x9bb79b74, 0x2d3c2d33, 0x30a530d6,
        0x2ece2e49, 0x49e94989, 0x46684672, 0x77447755,
        0xa8e0a8d8, 0x964d9604, 0x284328bd, 0xa969a929,
        0xd929d979, 0x862e8691, 0xd1acd187, 0xf415f44a,
        0x8d598d15, 0xd6a8d682, 0xb90ab9bc, 0x429e420d,
        0xf66ef6c1, 0x2f472fb8, 0xdddfdd06, 0x23342339,
        0xcc35cc62, 0xf16af1c4, 0xc1cfc112, 0x85dc85eb,
        0x8f228f9e, 0x71c971a1, 0x90c090f0, 0xaa9baa53,
        0x018901f1, 0x8bd48be1, 0x4eed4e8c, 0x8eab8e6f,
        0xab12aba2, 0x6fa26f3e, 0xe60de654, 0xdb52dbf2,
        0x92bb927b, 0xb702b7b6, 0x692f69ca, 0x39a939d9,
        0xd3d7d30c, 0xa761a723, 0xa21ea2ad, 0xc3b4c399,
        0x6c506c44, 0x07040705, 0x04f6047f, 0x27c22746,
        0xac16aca7, 0xd025d076, 0x50865013, 0xdc56dcf7,
        0x8455841a, 0xe109e151, 0x7abe7a25, 0x139113ef,

        0xd939a9d9, 0x90176790, 0x719cb371, 0xd2a6e8d2,
        0x05070405, 0x9852fd98, 0x6580a365, 0xdfe476df,
        0x08459a08, 0x024b9202, 0xa0e080a0, 0x665a7866,
        0xddafe4dd, 0xb06addb0, 0xbf63d1bf, 0x362a3836,
        0x54e60d54, 0x4320c643, 0x62cc3562, 0xbef298be,
        0x1e12181e, 0x24ebf724, 0xd7a1ecd7, 0x77416c77,
        0xbd2843bd, 0x32bc7532, 0xd47b37d4, 0x9b88269b,
        0x700dfa70, 0xf94413f9, 0xb1fb94b1, 0x5a7e485a,
        0x7a03f27a, 0xe48cd0e4, 0x47b68b47, 0x3c24303c,
        0xa5e784a5, 0x416b5441, 0x06dddf06, 0xc56023c5,
        0x45fd1945, 0xa33a5ba3, 0x68c23d68, 0x158d5915,
        0x21ecf321, 0x3166ae31, 0x3e6fa23e, 0x16578216,
        0x95106395, 0x5bef015b, 0x4db8834d, 0x91862e91,
        0xb56dd9b5, 0x1f83511f, 0x53aa9b53, 0x635d7c63,
        0x3b68a63b, 0x3ffeeb3f, 0xd630a5d6, 0x257abe25,
        0xa7ac16a7, 0x0f090c0f, 0x35f0e335, 0x23a76123,
        0xf090c0f0, 0xafe98caf, 0x809d3a80, 0x925cf592,
        0x810c7381, 0x27312c27, 0x76d02576, 0xe7560be7,
        0x7b92bb7b, 0xe9ce4ee9, 0xf10189f1, 0x9f1e6b9f,
        0xa93453a9, 0xc4f16ac4, 0x99c3b499, 0x975bf197,
        0x8347e183, 0x6b18e66b, 0xc822bdc8, 0x0e98450e,
        0x6e1fe26e, 0xc9b3f4c9, 0x2f74b62f, 0xcbf866cb,
        0xff99ccff, 0xea1495ea, 0xed5803ed, 0xf7dc56f7,
        0xe18bd4e1, 0x1b151c1b, 0xada21ead, 0x0cd3d70c,
        0x2be2fb2b, 0x1dc8c31d, 0x195e8e19, 0xc22cb5c2,
        0x8949e989, 0x12c1cf12, 0x7e95bf7e, 0x207dba20,
        0x6411ea64, 0x840b7784, 0x6dc5396d, 0x6a89af6a,
        0xd17c33d1, 0xa171c9a1, 0xceff62ce, 0x37bb7137,
        0xfb0f81fb, 0x3db5793d, 0x51e10951, 0xdc3eaddc,
        0x2d3f242d, 0xa476cda4, 0x9d55f99d, 0xee82d8ee,
        0x8640e586, 0xae78c5ae, 0xcd25b9cd, 0x04964d04,
        0x55774455, 0x0a0e080a, 0x13508613, 0x30f7e730,
        0xd337a1d3, 0x40fa1d40, 0x3461aa34, 0x8c4eed8c,
        0xb3b006b3, 0x6c54706c, 0x2a73b22a, 0x523bd252,
        0x0b9f410b, 0x8b027b8b, 0x88d8a088, 0x4ff3114f,
        0x67cb3167, 0x4627c246, 0xc06727c0, 0xb4fc90b4,
        0x28382028, 0x7f04f67f, 0x78486078, 0x2ee5ff2e,
        0x074c9607, 0x4b655c4b, 0xc72bb1c7, 0x6f8eab6f,
        0x0d429e0d, 0xbbf59cbb, 0xf2db52f2, 0xf34a1bf3,
        0xa63d5fa6, 0x59a49359, 0xbcb90abc, 0x3af9ef3a,
        0xef1391ef, 0xfe0885fe, 0x01914901, 0x6116ee61,
        0x7cde2d7c, 0xb2214fb2, 0x42b18f42, 0xdb723bdb,
        0xb82f47b8, 0x48bf8748, 0x2cae6d2c, 0xe3c046e3,
        0x573cd657, 0x859a3e85, 0x29a96929, 0x7d4f647d,
        0x94812a94, 0x492ece49, 0x17c6cb17, 0xca692fca,
        0xc3bdfcc3, 0x5ca3975c, 0x5ee8055e, 0xd0ed7ad0,
        0x87d1ac87, 0x8e057f8e, 0xba64d5ba, 0xa8a51aa8,
        0xb7264bb7, 0xb9be0eb9, 0x6087a760, 0xf8d55af8,
        0x22362822, 0x111b1411, 0xde753fde, 0x79d92979,
        0xaaee88aa, 0x332d3c33, 0x5f794c5f, 0xb6b702b6,
        0x96cab896, 0x5835da58, 0x9cc4b09c, 0xfc4317fc,
        0x1a84551a, 0xf64d1ff6, 0x1c598a1c, 0x38b27d38,
        0xac3357ac, 0x18cfc718, 0xf4068df4, 0x69537469,
        0x749bb774, 0xf597c4f5, 0x56ad9f56, 0xdae372da,
        0xd5ea7ed5, 0x4af4154a, 0x9e8f229e, 0xa2ab12a2,
        0x4e62584e, 0xe85f07e8, 0xe51d99e5, 0x39233439,
        0xc1f66ec1, 0x446c5044, 0x5d32de5d, 0x72466872,
        0x26a06526, 0x93cdbc93, 0x03dadb03, 0xc6baf8c6,
        0xfa9ec8fa, 0x82d6a882, 0xcf6e2bcf, 0x50704050,
        0xeb85dceb, 0x750afe75, 0x8a93328a, 0x8ddfa48d,
        0x4c29ca4c, 0x141c1014, 0x73d72173, 0xccb4f0cc,
        0x09d4d309, 0x108a5d10, 0xe2510fe2, 0x00000000,
        0x9a196f9a, 0xe01a9de0, 0x8f94368f, 0xe6c742e6,
        0xecc94aec, 0xfdd25efd, 0xab7fc1ab, 0xd8a8e0d8};
//-----------------
static const word32 Square_Te[4*256] = {

0x97b1b126UL, 0x69cecea7UL, 0x73c3c3b0UL, 0xdf95954aUL,
0xb45a5aeeUL, 0xafadad02UL, 0x3be7e7dcUL, 0x04020206UL,
0x9a4d4dd7UL, 0x884444ccUL, 0x03fbfbf8UL, 0xd7919146UL,
0x180c0c14UL, 0xfb87877cUL, 0xb7a1a116UL, 0xa05050f0UL,
0x63cbcba8UL, 0xce6767a9UL, 0xa85454fcUL, 0x4fdddd92UL,
0x8c4646caUL, 0xeb8f8f64UL, 0x37e1e1d6UL, 0x9c4e4ed2UL,
0x15f0f0e5UL, 0x0ffdfdf2UL, 0x0dfcfcf1UL, 0x23ebebc8UL,
0x07f9f9feUL, 0x7dc4c4b9UL, 0x341a1a2eUL, 0xdc6e6eb2UL,
0xbc5e5ee2UL, 0x1ff5f5eaUL, 0x6dcccca1UL, 0xef8d8d62UL,
0x381c1c24UL, 0xac5656faUL, 0x864343c5UL, 0x09fefef7UL,
0x0e070709UL, 0xc26161a3UL, 0x05f8f8fdUL, 0xea75759fUL,
0xb25959ebUL, 0x0bfffff4UL, 0x06030305UL, 0x44222266UL,
0xe18a8a6bUL, 0x57d1d186UL, 0x26131335UL, 0x29eeeec7UL,
0xe588886dUL, 0x00000000UL, 0x1c0e0e12UL, 0x6834345cUL,
0x2a15153fUL, 0xf5808075UL, 0xdd949449UL, 0x33e3e3d0UL,
0x2fededc2UL, 0x9fb5b52aUL, 0xa65353f5UL, 0x46232365UL,
0x964b4bddUL, 0x8e4747c9UL, 0x2e171739UL, 0xbba7a71cUL,
0xd5909045UL, 0x6a35355fUL, 0xa3abab08UL, 0x45d8d89dUL,
0x85b8b83dUL, 0x4bdfdf94UL, 0x9e4f4fd1UL, 0xae5757f9UL,
0xc19a9a5bUL, 0xd1929243UL, 0x43dbdb98UL, 0x361b1b2dUL,
0x783c3c44UL, 0x65c8c8adUL, 0xc799995eUL, 0x0804040cUL,
0xe98e8e67UL, 0x35e0e0d5UL, 0x5bd7d78cUL, 0xfa7d7d87UL,
0xff85857aUL, 0x83bbbb38UL, 0x804040c0UL, 0x582c2c74UL,
0x743a3a4eUL, 0x8a4545cfUL, 0x17f1f1e6UL, 0x844242c6UL,
0xca6565afUL, 0x40202060UL, 0x824141c3UL, 0x30181828UL,
0xe4727296UL, 0x4a25256fUL, 0xd3939340UL, 0xe0707090UL,
0x6c36365aUL, 0x0a05050fUL, 0x11f2f2e3UL, 0x160b0b1dUL,
0xb3a3a310UL, 0xf279798bUL, 0x2dececc1UL, 0x10080818UL,
0x4e272769UL, 0x62313153UL, 0x64323256UL, 0x99b6b62fUL,
0xf87c7c84UL, 0x95b0b025UL, 0x140a0a1eUL, 0xe6737395UL,
0xb65b5bedUL, 0xf67b7b8dUL, 0x9bb7b72cUL, 0xf7818176UL,
0x51d2d283UL, 0x1a0d0d17UL, 0xd46a6abeUL, 0x4c26266aUL,
0xc99e9e57UL, 0xb05858e8UL, 0xcd9c9c51UL, 0xf3838370UL,
0xe874749cUL, 0x93b3b320UL, 0xadacac01UL, 0x60303050UL,
0xf47a7a8eUL, 0xd26969bbUL, 0xee777799UL, 0x1e0f0f11UL,
0xa9aeae07UL, 0x42212163UL, 0x49dede97UL, 0x55d0d085UL,
0x5c2e2e72UL, 0xdb97974cUL, 0x20101030UL, 0xbda4a419UL,
0xc598985dUL, 0xa5a8a80dUL, 0x5dd4d489UL, 0xd06868b8UL,
0x5a2d2d77UL, 0xc46262a6UL, 0x5229297bUL, 0xda6d6db7UL,
0x2c16163aUL, 0x924949dbUL, 0xec76769aUL, 0x7bc7c7bcUL,
0x25e8e8cdUL, 0x77c1c1b6UL, 0xd996964fUL, 0x6e373759UL,
0x3fe5e5daUL, 0x61cacaabUL, 0x1df4f4e9UL, 0x27e9e9ceUL,
0xc66363a5UL, 0x24121236UL, 0x71c2c2b3UL, 0xb9a6a61fUL,
0x2814143cUL, 0x8dbcbc31UL, 0x53d3d380UL, 0x50282878UL,
0xabafaf04UL, 0x5e2f2f71UL, 0x39e6e6dfUL, 0x4824246cUL,
0xa45252f6UL, 0x79c6c6bfUL, 0xb5a0a015UL, 0x1209091bUL,
0x8fbdbd32UL, 0xed8c8c61UL, 0x6bcfcfa4UL, 0xba5d5de7UL,
0x22111133UL, 0xbe5f5fe1UL, 0x02010103UL, 0x7fc5c5baUL,
0xcb9f9f54UL, 0x7a3d3d47UL, 0xb1a2a213UL, 0xc39b9b58UL,
0x67c9c9aeUL, 0x763b3b4dUL, 0x89bebe37UL, 0xa25151f3UL,
0x3219192bUL, 0x3e1f1f21UL, 0x7e3f3f41UL, 0xb85c5ce4UL,
0x91b2b223UL, 0x2befefc4UL, 0x944a4adeUL, 0x6fcdcda2UL,
0x8bbfbf34UL, 0x81baba3bUL, 0xde6f6fb1UL, 0xc86464acUL,
0x47d9d99eUL, 0x13f3f3e0UL, 0x7c3e3e42UL, 0x9db4b429UL,
0xa1aaaa0bUL, 0x4ddcdc91UL, 0x5fd5d58aUL, 0x0c06060aUL,
0x75c0c0b5UL, 0xfc7e7e82UL, 0x19f6f6efUL, 0xcc6666aaUL,
0xd86c6cb4UL, 0xfd848479UL, 0xe2717193UL, 0x70383848UL,
0x87b9b93eUL, 0x3a1d1d27UL, 0xfe7f7f81UL, 0xcf9d9d52UL,
0x904848d8UL, 0xe38b8b68UL, 0x542a2a7eUL, 0x41dada9bUL,
0xbfa5a51aUL, 0x66333355UL, 0xf1828273UL, 0x7239394bUL,
0x59d6d68fUL, 0xf0787888UL, 0xf986867fUL, 0x01fafafbUL,
0x3de4e4d9UL, 0x562b2b7dUL, 0xa7a9a90eUL, 0x3c1e1e22UL,
0xe789896eUL, 0xc06060a0UL, 0xd66b6bbdUL, 0x21eaeacbUL,
0xaa5555ffUL, 0x984c4cd4UL, 0x1bf7f7ecUL, 0x31e2e2d3UL,



0x2697b1b1UL, 0xa769ceceUL, 0xb073c3c3UL, 0x4adf9595UL,
0xeeb45a5aUL, 0x02afadadUL, 0xdc3be7e7UL, 0x06040202UL,
0xd79a4d4dUL, 0xcc884444UL, 0xf803fbfbUL, 0x46d79191UL,
0x14180c0cUL, 0x7cfb8787UL, 0x16b7a1a1UL, 0xf0a05050UL,
0xa863cbcbUL, 0xa9ce6767UL, 0xfca85454UL, 0x924fddddUL,
0xca8c4646UL, 0x64eb8f8fUL, 0xd637e1e1UL, 0xd29c4e4eUL,
0xe515f0f0UL, 0xf20ffdfdUL, 0xf10dfcfcUL, 0xc823ebebUL,
0xfe07f9f9UL, 0xb97dc4c4UL, 0x2e341a1aUL, 0xb2dc6e6eUL,
0xe2bc5e5eUL, 0xea1ff5f5UL, 0xa16dccccUL, 0x62ef8d8dUL,
0x24381c1cUL, 0xfaac5656UL, 0xc5864343UL, 0xf709fefeUL,
0x090e0707UL, 0xa3c26161UL, 0xfd05f8f8UL, 0x9fea7575UL,
0xebb25959UL, 0xf40bffffUL, 0x05060303UL, 0x66442222UL,
0x6be18a8aUL, 0x8657d1d1UL, 0x35261313UL, 0xc729eeeeUL,
0x6de58888UL, 0x00000000UL, 0x121c0e0eUL, 0x5c683434UL,
0x3f2a1515UL, 0x75f58080UL, 0x49dd9494UL, 0xd033e3e3UL,
0xc22fededUL, 0x2a9fb5b5UL, 0xf5a65353UL, 0x65462323UL,
0xdd964b4bUL, 0xc98e4747UL, 0x392e1717UL, 0x1cbba7a7UL,
0x45d59090UL, 0x5f6a3535UL, 0x08a3ababUL, 0x9d45d8d8UL,
0x3d85b8b8UL, 0x944bdfdfUL, 0xd19e4f4fUL, 0xf9ae5757UL,
0x5bc19a9aUL, 0x43d19292UL, 0x9843dbdbUL, 0x2d361b1bUL,
0x44783c3cUL, 0xad65c8c8UL, 0x5ec79999UL, 0x0c080404UL,
0x67e98e8eUL, 0xd535e0e0UL, 0x8c5bd7d7UL, 0x87fa7d7dUL,
0x7aff8585UL, 0x3883bbbbUL, 0xc0804040UL, 0x74582c2cUL,
0x4e743a3aUL, 0xcf8a4545UL, 0xe617f1f1UL, 0xc6844242UL,
0xafca6565UL, 0x60402020UL, 0xc3824141UL, 0x28301818UL,
0x96e47272UL, 0x6f4a2525UL, 0x40d39393UL, 0x90e07070UL,
0x5a6c3636UL, 0x0f0a0505UL, 0xe311f2f2UL, 0x1d160b0bUL,
0x10b3a3a3UL, 0x8bf27979UL, 0xc12dececUL, 0x18100808UL,
0x694e2727UL, 0x53623131UL, 0x56643232UL, 0x2f99b6b6UL,
0x84f87c7cUL, 0x2595b0b0UL, 0x1e140a0aUL, 0x95e67373UL,
0xedb65b5bUL, 0x8df67b7bUL, 0x2c9bb7b7UL, 0x76f78181UL,
0x8351d2d2UL, 0x171a0d0dUL, 0xbed46a6aUL, 0x6a4c2626UL,
0x57c99e9eUL, 0xe8b05858UL, 0x51cd9c9cUL, 0x70f38383UL,
0x9ce87474UL, 0x2093b3b3UL, 0x01adacacUL, 0x50603030UL,
0x8ef47a7aUL, 0xbbd26969UL, 0x99ee7777UL, 0x111e0f0fUL,
0x07a9aeaeUL, 0x63422121UL, 0x9749dedeUL, 0x8555d0d0UL,
0x725c2e2eUL, 0x4cdb9797UL, 0x30201010UL, 0x19bda4a4UL,
0x5dc59898UL, 0x0da5a8a8UL, 0x895dd4d4UL, 0xb8d06868UL,
0x775a2d2dUL, 0xa6c46262UL, 0x7b522929UL, 0xb7da6d6dUL,
0x3a2c1616UL, 0xdb924949UL, 0x9aec7676UL, 0xbc7bc7c7UL,
0xcd25e8e8UL, 0xb677c1c1UL, 0x4fd99696UL, 0x596e3737UL,
0xda3fe5e5UL, 0xab61cacaUL, 0xe91df4f4UL, 0xce27e9e9UL,
0xa5c66363UL, 0x36241212UL, 0xb371c2c2UL, 0x1fb9a6a6UL,
0x3c281414UL, 0x318dbcbcUL, 0x8053d3d3UL, 0x78502828UL,
0x04abafafUL, 0x715e2f2fUL, 0xdf39e6e6UL, 0x6c482424UL,
0xf6a45252UL, 0xbf79c6c6UL, 0x15b5a0a0UL, 0x1b120909UL,
0x328fbdbdUL, 0x61ed8c8cUL, 0xa46bcfcfUL, 0xe7ba5d5dUL,
0x33221111UL, 0xe1be5f5fUL, 0x03020101UL, 0xba7fc5c5UL,
0x54cb9f9fUL, 0x477a3d3dUL, 0x13b1a2a2UL, 0x58c39b9bUL,
0xae67c9c9UL, 0x4d763b3bUL, 0x3789bebeUL, 0xf3a25151UL,
0x2b321919UL, 0x213e1f1fUL, 0x417e3f3fUL, 0xe4b85c5cUL,
0x2391b2b2UL, 0xc42befefUL, 0xde944a4aUL, 0xa26fcdcdUL,
0x348bbfbfUL, 0x3b81babaUL, 0xb1de6f6fUL, 0xacc86464UL,
0x9e47d9d9UL, 0xe013f3f3UL, 0x427c3e3eUL, 0x299db4b4UL,
0x0ba1aaaaUL, 0x914ddcdcUL, 0x8a5fd5d5UL, 0x0a0c0606UL,
0xb575c0c0UL, 0x82fc7e7eUL, 0xef19f6f6UL, 0xaacc6666UL,
0xb4d86c6cUL, 0x79fd8484UL, 0x93e27171UL, 0x48703838UL,
0x3e87b9b9UL, 0x273a1d1dUL, 0x81fe7f7fUL, 0x52cf9d9dUL,
0xd8904848UL, 0x68e38b8bUL, 0x7e542a2aUL, 0x9b41dadaUL,
0x1abfa5a5UL, 0x55663333UL, 0x73f18282UL, 0x4b723939UL,
0x8f59d6d6UL, 0x88f07878UL, 0x7ff98686UL, 0xfb01fafaUL,
0xd93de4e4UL, 0x7d562b2bUL, 0x0ea7a9a9UL, 0x223c1e1eUL,
0x6ee78989UL, 0xa0c06060UL, 0xbdd66b6bUL, 0xcb21eaeaUL,
0xffaa5555UL, 0xd4984c4cUL, 0xec1bf7f7UL, 0xd331e2e2UL,



0xb12697b1UL, 0xcea769ceUL, 0xc3b073c3UL, 0x954adf95UL,
0x5aeeb45aUL, 0xad02afadUL, 0xe7dc3be7UL, 0x02060402UL,
0x4dd79a4dUL, 0x44cc8844UL, 0xfbf803fbUL, 0x9146d791UL,
0x0c14180cUL, 0x877cfb87UL, 0xa116b7a1UL, 0x50f0a050UL,
0xcba863cbUL, 0x67a9ce67UL, 0x54fca854UL, 0xdd924fddUL,
0x46ca8c46UL, 0x8f64eb8fUL, 0xe1d637e1UL, 0x4ed29c4eUL,
0xf0e515f0UL, 0xfdf20ffdUL, 0xfcf10dfcUL, 0xebc823ebUL,
0xf9fe07f9UL, 0xc4b97dc4UL, 0x1a2e341aUL, 0x6eb2dc6eUL,
0x5ee2bc5eUL, 0xf5ea1ff5UL, 0xcca16dccUL, 0x8d62ef8dUL,
0x1c24381cUL, 0x56faac56UL, 0x43c58643UL, 0xfef709feUL,
0x07090e07UL, 0x61a3c261UL, 0xf8fd05f8UL, 0x759fea75UL,
0x59ebb259UL, 0xfff40bffUL, 0x03050603UL, 0x22664422UL,
0x8a6be18aUL, 0xd18657d1UL, 0x13352613UL, 0xeec729eeUL,
0x886de588UL, 0x00000000UL, 0x0e121c0eUL, 0x345c6834UL,
0x153f2a15UL, 0x8075f580UL, 0x9449dd94UL, 0xe3d033e3UL,
0xedc22fedUL, 0xb52a9fb5UL, 0x53f5a653UL, 0x23654623UL,
0x4bdd964bUL, 0x47c98e47UL, 0x17392e17UL, 0xa71cbba7UL,
0x9045d590UL, 0x355f6a35UL, 0xab08a3abUL, 0xd89d45d8UL,
0xb83d85b8UL, 0xdf944bdfUL, 0x4fd19e4fUL, 0x57f9ae57UL,
0x9a5bc19aUL, 0x9243d192UL, 0xdb9843dbUL, 0x1b2d361bUL,
0x3c44783cUL, 0xc8ad65c8UL, 0x995ec799UL, 0x040c0804UL,
0x8e67e98eUL, 0xe0d535e0UL, 0xd78c5bd7UL, 0x7d87fa7dUL,
0x857aff85UL, 0xbb3883bbUL, 0x40c08040UL, 0x2c74582cUL,
0x3a4e743aUL, 0x45cf8a45UL, 0xf1e617f1UL, 0x42c68442UL,
0x65afca65UL, 0x20604020UL, 0x41c38241UL, 0x18283018UL,
0x7296e472UL, 0x256f4a25UL, 0x9340d393UL, 0x7090e070UL,
0x365a6c36UL, 0x050f0a05UL, 0xf2e311f2UL, 0x0b1d160bUL,
0xa310b3a3UL, 0x798bf279UL, 0xecc12decUL, 0x08181008UL,
0x27694e27UL, 0x31536231UL, 0x32566432UL, 0xb62f99b6UL,
0x7c84f87cUL, 0xb02595b0UL, 0x0a1e140aUL, 0x7395e673UL,
0x5bedb65bUL, 0x7b8df67bUL, 0xb72c9bb7UL, 0x8176f781UL,
0xd28351d2UL, 0x0d171a0dUL, 0x6abed46aUL, 0x266a4c26UL,
0x9e57c99eUL, 0x58e8b058UL, 0x9c51cd9cUL, 0x8370f383UL,
0x749ce874UL, 0xb32093b3UL, 0xac01adacUL, 0x30506030UL,
0x7a8ef47aUL, 0x69bbd269UL, 0x7799ee77UL, 0x0f111e0fUL,
0xae07a9aeUL, 0x21634221UL, 0xde9749deUL, 0xd08555d0UL,
0x2e725c2eUL, 0x974cdb97UL, 0x10302010UL, 0xa419bda4UL,
0x985dc598UL, 0xa80da5a8UL, 0xd4895dd4UL, 0x68b8d068UL,
0x2d775a2dUL, 0x62a6c462UL, 0x297b5229UL, 0x6db7da6dUL,
0x163a2c16UL, 0x49db9249UL, 0x769aec76UL, 0xc7bc7bc7UL,
0xe8cd25e8UL, 0xc1b677c1UL, 0x964fd996UL, 0x37596e37UL,
0xe5da3fe5UL, 0xcaab61caUL, 0xf4e91df4UL, 0xe9ce27e9UL,
0x63a5c663UL, 0x12362412UL, 0xc2b371c2UL, 0xa61fb9a6UL,
0x143c2814UL, 0xbc318dbcUL, 0xd38053d3UL, 0x28785028UL,
0xaf04abafUL, 0x2f715e2fUL, 0xe6df39e6UL, 0x246c4824UL,
0x52f6a452UL, 0xc6bf79c6UL, 0xa015b5a0UL, 0x091b1209UL,
0xbd328fbdUL, 0x8c61ed8cUL, 0xcfa46bcfUL, 0x5de7ba5dUL,
0x11332211UL, 0x5fe1be5fUL, 0x01030201UL, 0xc5ba7fc5UL,
0x9f54cb9fUL, 0x3d477a3dUL, 0xa213b1a2UL, 0x9b58c39bUL,
0xc9ae67c9UL, 0x3b4d763bUL, 0xbe3789beUL, 0x51f3a251UL,
0x192b3219UL, 0x1f213e1fUL, 0x3f417e3fUL, 0x5ce4b85cUL,
0xb22391b2UL, 0xefc42befUL, 0x4ade944aUL, 0xcda26fcdUL,
0xbf348bbfUL, 0xba3b81baUL, 0x6fb1de6fUL, 0x64acc864UL,
0xd99e47d9UL, 0xf3e013f3UL, 0x3e427c3eUL, 0xb4299db4UL,
0xaa0ba1aaUL, 0xdc914ddcUL, 0xd58a5fd5UL, 0x060a0c06UL,
0xc0b575c0UL, 0x7e82fc7eUL, 0xf6ef19f6UL, 0x66aacc66UL,
0x6cb4d86cUL, 0x8479fd84UL, 0x7193e271UL, 0x38487038UL,
0xb93e87b9UL, 0x1d273a1dUL, 0x7f81fe7fUL, 0x9d52cf9dUL,
0x48d89048UL, 0x8b68e38bUL, 0x2a7e542aUL, 0xda9b41daUL,
0xa51abfa5UL, 0x33556633UL, 0x8273f182UL, 0x394b7239UL,
0xd68f59d6UL, 0x7888f078UL, 0x867ff986UL, 0xfafb01faUL,
0xe4d93de4UL, 0x2b7d562bUL, 0xa90ea7a9UL, 0x1e223c1eUL,
0x896ee789UL, 0x60a0c060UL, 0x6bbdd66bUL, 0xeacb21eaUL,
0x55ffaa55UL, 0x4cd4984cUL, 0xf7ec1bf7UL, 0xe2d331e2UL,



0xb1b12697UL, 0xcecea769UL, 0xc3c3b073UL, 0x95954adfUL,
0x5a5aeeb4UL, 0xadad02afUL, 0xe7e7dc3bUL, 0x02020604UL,
0x4d4dd79aUL, 0x4444cc88UL, 0xfbfbf803UL, 0x919146d7UL,
0x0c0c1418UL, 0x87877cfbUL, 0xa1a116b7UL, 0x5050f0a0UL,
0xcbcba863UL, 0x6767a9ceUL, 0x5454fca8UL, 0xdddd924fUL,
0x4646ca8cUL, 0x8f8f64ebUL, 0xe1e1d637UL, 0x4e4ed29cUL,
0xf0f0e515UL, 0xfdfdf20fUL, 0xfcfcf10dUL, 0xebebc823UL,
0xf9f9fe07UL, 0xc4c4b97dUL, 0x1a1a2e34UL, 0x6e6eb2dcUL,
0x5e5ee2bcUL, 0xf5f5ea1fUL, 0xcccca16dUL, 0x8d8d62efUL,
0x1c1c2438UL, 0x5656faacUL, 0x4343c586UL, 0xfefef709UL,
0x0707090eUL, 0x6161a3c2UL, 0xf8f8fd05UL, 0x75759feaUL,
0x5959ebb2UL, 0xfffff40bUL, 0x03030506UL, 0x22226644UL,
0x8a8a6be1UL, 0xd1d18657UL, 0x13133526UL, 0xeeeec729UL,
0x88886de5UL, 0x00000000UL, 0x0e0e121cUL, 0x34345c68UL,
0x15153f2aUL, 0x808075f5UL, 0x949449ddUL, 0xe3e3d033UL,
0xededc22fUL, 0xb5b52a9fUL, 0x5353f5a6UL, 0x23236546UL,
0x4b4bdd96UL, 0x4747c98eUL, 0x1717392eUL, 0xa7a71cbbUL,
0x909045d5UL, 0x35355f6aUL, 0xabab08a3UL, 0xd8d89d45UL,
0xb8b83d85UL, 0xdfdf944bUL, 0x4f4fd19eUL, 0x5757f9aeUL,
0x9a9a5bc1UL, 0x929243d1UL, 0xdbdb9843UL, 0x1b1b2d36UL,
0x3c3c4478UL, 0xc8c8ad65UL, 0x99995ec7UL, 0x04040c08UL,
0x8e8e67e9UL, 0xe0e0d535UL, 0xd7d78c5bUL, 0x7d7d87faUL,
0x85857affUL, 0xbbbb3883UL, 0x4040c080UL, 0x2c2c7458UL,
0x3a3a4e74UL, 0x4545cf8aUL, 0xf1f1e617UL, 0x4242c684UL,
0x6565afcaUL, 0x20206040UL, 0x4141c382UL, 0x18182830UL,
0x727296e4UL, 0x25256f4aUL, 0x939340d3UL, 0x707090e0UL,
0x36365a6cUL, 0x05050f0aUL, 0xf2f2e311UL, 0x0b0b1d16UL,
0xa3a310b3UL, 0x79798bf2UL, 0xececc12dUL, 0x08081810UL,
0x2727694eUL, 0x31315362UL, 0x32325664UL, 0xb6b62f99UL,
0x7c7c84f8UL, 0xb0b02595UL, 0x0a0a1e14UL, 0x737395e6UL,
0x5b5bedb6UL, 0x7b7b8df6UL, 0xb7b72c9bUL, 0x818176f7UL,
0xd2d28351UL, 0x0d0d171aUL, 0x6a6abed4UL, 0x26266a4cUL,
0x9e9e57c9UL, 0x5858e8b0UL, 0x9c9c51cdUL, 0x838370f3UL,
0x74749ce8UL, 0xb3b32093UL, 0xacac01adUL, 0x30305060UL,
0x7a7a8ef4UL, 0x6969bbd2UL, 0x777799eeUL, 0x0f0f111eUL,
0xaeae07a9UL, 0x21216342UL, 0xdede9749UL, 0xd0d08555UL,
0x2e2e725cUL, 0x97974cdbUL, 0x10103020UL, 0xa4a419bdUL,
0x98985dc5UL, 0xa8a80da5UL, 0xd4d4895dUL, 0x6868b8d0UL,
0x2d2d775aUL, 0x6262a6c4UL, 0x29297b52UL, 0x6d6db7daUL,
0x16163a2cUL, 0x4949db92UL, 0x76769aecUL, 0xc7c7bc7bUL,
0xe8e8cd25UL, 0xc1c1b677UL, 0x96964fd9UL, 0x3737596eUL,
0xe5e5da3fUL, 0xcacaab61UL, 0xf4f4e91dUL, 0xe9e9ce27UL,
0x6363a5c6UL, 0x12123624UL, 0xc2c2b371UL, 0xa6a61fb9UL,
0x14143c28UL, 0xbcbc318dUL, 0xd3d38053UL, 0x28287850UL,
0xafaf04abUL, 0x2f2f715eUL, 0xe6e6df39UL, 0x24246c48UL,
0x5252f6a4UL, 0xc6c6bf79UL, 0xa0a015b5UL, 0x09091b12UL,
0xbdbd328fUL, 0x8c8c61edUL, 0xcfcfa46bUL, 0x5d5de7baUL,
0x11113322UL, 0x5f5fe1beUL, 0x01010302UL, 0xc5c5ba7fUL,
0x9f9f54cbUL, 0x3d3d477aUL, 0xa2a213b1UL, 0x9b9b58c3UL,
0xc9c9ae67UL, 0x3b3b4d76UL, 0xbebe3789UL, 0x5151f3a2UL,
0x19192b32UL, 0x1f1f213eUL, 0x3f3f417eUL, 0x5c5ce4b8UL,
0xb2b22391UL, 0xefefc42bUL, 0x4a4ade94UL, 0xcdcda26fUL,
0xbfbf348bUL, 0xbaba3b81UL, 0x6f6fb1deUL, 0x6464acc8UL,
0xd9d99e47UL, 0xf3f3e013UL, 0x3e3e427cUL, 0xb4b4299dUL,
0xaaaa0ba1UL, 0xdcdc914dUL, 0xd5d58a5fUL, 0x06060a0cUL,
0xc0c0b575UL, 0x7e7e82fcUL, 0xf6f6ef19UL, 0x6666aaccUL,
0x6c6cb4d8UL, 0x848479fdUL, 0x717193e2UL, 0x38384870UL,
0xb9b93e87UL, 0x1d1d273aUL, 0x7f7f81feUL, 0x9d9d52cfUL,
0x4848d890UL, 0x8b8b68e3UL, 0x2a2a7e54UL, 0xdada9b41UL,
0xa5a51abfUL, 0x33335566UL, 0x828273f1UL, 0x39394b72UL,
0xd6d68f59UL, 0x787888f0UL, 0x86867ff9UL, 0xfafafb01UL,
0xe4e4d93dUL, 0x2b2b7d56UL, 0xa9a90ea7UL, 0x1e1e223cUL,
0x89896ee7UL, 0x6060a0c0UL, 0x6b6bbdd6UL, 0xeaeacb21UL,
0x5555ffaaUL, 0x4c4cd498UL, 0xf7f7ec1bUL, 0xe2e2d331UL,
};

static const word32 Square_Td[4*256] = {

0xe368bc02UL, 0x5585620cUL, 0x2a3f2331UL, 0x61ab13f7UL,
0x98d46d72UL, 0x21cb9a19UL, 0x3c22a461UL, 0x459d3dcdUL,
0x05fdb423UL, 0x2bc4075fUL, 0x9b2c01c0UL, 0x3dd9800fUL,
0x486c5c74UL, 0xf97f7e85UL, 0xf173ab1fUL, 0xb6edde0eUL,
0x283c6bedUL, 0x4997781aUL, 0x9f2a918dUL, 0xc9579f33UL,
0xa907a8aaUL, 0xa50ded7dUL, 0x7c422d8fUL, 0x764db0c9UL,
0x4d91e857UL, 0xcea963ccUL, 0xb4ee96d2UL, 0x3028e1b6UL,
0x0df161b9UL, 0xbd196726UL, 0x419bad80UL, 0xc0a06ec7UL,
0x5183f241UL, 0x92dbf034UL, 0x6fa21efcUL, 0x8f32ce4cUL,
0x13e03373UL, 0x69a7c66dUL, 0xe56d6493UL, 0xbf1a2ffaUL,
0xbb1cbfb7UL, 0x587403b5UL, 0xe76e2c4fUL, 0x5d89b796UL,
0xe89c052aUL, 0x446619a3UL, 0x342e71fbUL, 0x0ff22965UL,
0xfe81827aUL, 0xb11322f1UL, 0xa30835ecUL, 0xcd510f7eUL,
0xff7aa614UL, 0x5c7293f8UL, 0x2fc29712UL, 0xf370e3c3UL,
0x992f491cUL, 0xd1431568UL, 0xc2a3261bUL, 0x88cc32b3UL,
0x8acf7a6fUL, 0xb0e8069fUL, 0x7a47f51eUL, 0xd2bb79daUL,
0xe6950821UL, 0x4398e55cUL, 0xd0b83106UL, 0x11e37bafUL,
0x7e416553UL, 0xccaa2b10UL, 0xd8b4e49cUL, 0x6456a7d4UL,
0xfb7c3659UL, 0x724b2084UL, 0xea9f4df6UL, 0x6a5faadfUL,
0x2dc1dfceUL, 0x70486858UL, 0xcaaff381UL, 0x0605d891UL,
0x5a774b69UL, 0x94de28a5UL, 0x39df1042UL, 0x813bc347UL,
0xfc82caa6UL, 0x23c8d2c5UL, 0x03f86cb2UL, 0x080cd59aUL,
0xdab7ac40UL, 0x7db909e1UL, 0x3824342cUL, 0xcf5247a2UL,
0xdcb274d1UL, 0x63a85b2bUL, 0x35d55595UL, 0x479e7511UL,
0x15e5ebe2UL, 0x4b9430c6UL, 0x4a6f14a8UL, 0x91239c86UL,
0x4c6acc39UL, 0x5f8aff4aUL, 0x0406904dUL, 0xee99ddbbUL,
0x1e1152caUL, 0xaaffc418UL, 0xeb646998UL, 0x07fefcffUL,
0x8b345e01UL, 0x567d0ebeUL, 0xbae79bd9UL, 0x4263c132UL,
0x75b5dc7bUL, 0x97264417UL, 0x67aecb66UL, 0x95250ccbUL,
0xec9a9567UL, 0x57862ad0UL, 0x60503799UL, 0xb8e4d305UL,
0x65ad83baUL, 0x19efae35UL, 0xa4f6c913UL, 0xc15b4aa9UL,
0x873e1bd6UL, 0xa0f0595eUL, 0x18148a5bUL, 0xaf02703bUL,
0xab04e076UL, 0xdd4950bfUL, 0xdf4a1863UL, 0xc6a5b656UL,
0x853d530aUL, 0xfa871237UL, 0x77b694a7UL, 0x4665517fUL,
0xed61b109UL, 0x1bece6e9UL, 0xd5458525UL, 0xf5753b52UL,
0x7fba413dUL, 0x27ce4288UL, 0xb2eb4e43UL, 0xd6bde997UL,
0x527b9ef3UL, 0x62537f45UL, 0x2c3afba0UL, 0x7bbcd170UL,
0xb91ff76bUL, 0x121b171dUL, 0xfd79eec8UL, 0x3a277cf0UL,
0x0c0a45d7UL, 0x96dd6079UL, 0x2233f6abUL, 0xacfa1c89UL,
0xc8acbb5dUL, 0xa10b7d30UL, 0xd4bea14bUL, 0xbee10b94UL,
0x25cd0a54UL, 0x547e4662UL, 0xa2f31182UL, 0x17e6a33eUL,
0x263566e6UL, 0xc3580275UL, 0x83388b9bUL, 0x7844bdc2UL,
0x020348dcUL, 0x4f92a08bUL, 0x2e39b37cUL, 0x4e6984e5UL,
0xf0888f71UL, 0x362d3927UL, 0x9cd2fd3fUL, 0x01fb246eUL,
0x893716ddUL, 0x00000000UL, 0xf68d57e0UL, 0xe293986cUL,
0x744ef815UL, 0x9320d45aUL, 0xad0138e7UL, 0xd3405db4UL,
0x1a17c287UL, 0xb3106a2dUL, 0x5078d62fUL, 0xf48e1f3cUL,
0xa70ea5a1UL, 0x71b34c36UL, 0x9ad725aeUL, 0x5e71db24UL,
0x161d8750UL, 0xef62f9d5UL, 0x8d318690UL, 0x1c121a16UL,
0xa6f581cfUL, 0x5b8c6f07UL, 0x37d61d49UL, 0x6e593a92UL,
0x84c67764UL, 0x86c53fb8UL, 0xd746cdf9UL, 0xe090d0b0UL,
0x29c74f83UL, 0xe49640fdUL, 0x0e090d0bUL, 0x6da15620UL,
0x8ec9ea22UL, 0xdb4c882eUL, 0xf776738eUL, 0xb515b2bcUL,
0x10185fc1UL, 0x322ba96aUL, 0x6ba48eb1UL, 0xaef95455UL,
0x406089eeUL, 0x6655ef08UL, 0xe9672144UL, 0x3e21ecbdUL,
0x2030be77UL, 0xf28bc7adUL, 0x80c0e729UL, 0x141ecf8cUL,
0xbce24348UL, 0xc4a6fe8aUL, 0x31d3c5d8UL, 0xb716fa60UL,
0x5380ba9dUL, 0xd94fc0f2UL, 0x1de93e78UL, 0x24362e3aUL,
0xe16bf4deUL, 0xcb54d7efUL, 0x09f7f1f4UL, 0x82c3aff5UL,
0x0bf4b928UL, 0x9d29d951UL, 0xc75e9238UL, 0xf8845aebUL,
0x90d8b8e8UL, 0xdeb13c0dUL, 0x33d08d04UL, 0x685ce203UL,
0xc55ddae4UL, 0x3bdc589eUL, 0x0a0f9d46UL, 0x3fdac8d3UL,
0x598f27dbUL, 0xa8fc8cc4UL, 0x79bf99acUL, 0x6c5a724eUL,
0x8ccaa2feUL, 0x9ed1b5e3UL, 0x1fea76a4UL, 0x73b004eaUL,



0x02e368bcUL, 0x0c558562UL, 0x312a3f23UL, 0xf761ab13UL,
0x7298d46dUL, 0x1921cb9aUL, 0x613c22a4UL, 0xcd459d3dUL,
0x2305fdb4UL, 0x5f2bc407UL, 0xc09b2c01UL, 0x0f3dd980UL,
0x74486c5cUL, 0x85f97f7eUL, 0x1ff173abUL, 0x0eb6eddeUL,
0xed283c6bUL, 0x1a499778UL, 0x8d9f2a91UL, 0x33c9579fUL,
0xaaa907a8UL, 0x7da50dedUL, 0x8f7c422dUL, 0xc9764db0UL,
0x574d91e8UL, 0xcccea963UL, 0xd2b4ee96UL, 0xb63028e1UL,
0xb90df161UL, 0x26bd1967UL, 0x80419badUL, 0xc7c0a06eUL,
0x415183f2UL, 0x3492dbf0UL, 0xfc6fa21eUL, 0x4c8f32ceUL,
0x7313e033UL, 0x6d69a7c6UL, 0x93e56d64UL, 0xfabf1a2fUL,
0xb7bb1cbfUL, 0xb5587403UL, 0x4fe76e2cUL, 0x965d89b7UL,
0x2ae89c05UL, 0xa3446619UL, 0xfb342e71UL, 0x650ff229UL,
0x7afe8182UL, 0xf1b11322UL, 0xeca30835UL, 0x7ecd510fUL,
0x14ff7aa6UL, 0xf85c7293UL, 0x122fc297UL, 0xc3f370e3UL,
0x1c992f49UL, 0x68d14315UL, 0x1bc2a326UL, 0xb388cc32UL,
0x6f8acf7aUL, 0x9fb0e806UL, 0x1e7a47f5UL, 0xdad2bb79UL,
0x21e69508UL, 0x5c4398e5UL, 0x06d0b831UL, 0xaf11e37bUL,
0x537e4165UL, 0x10ccaa2bUL, 0x9cd8b4e4UL, 0xd46456a7UL,
0x59fb7c36UL, 0x84724b20UL, 0xf6ea9f4dUL, 0xdf6a5faaUL,
0xce2dc1dfUL, 0x58704868UL, 0x81caaff3UL, 0x910605d8UL,
0x695a774bUL, 0xa594de28UL, 0x4239df10UL, 0x47813bc3UL,
0xa6fc82caUL, 0xc523c8d2UL, 0xb203f86cUL, 0x9a080cd5UL,
0x40dab7acUL, 0xe17db909UL, 0x2c382434UL, 0xa2cf5247UL,
0xd1dcb274UL, 0x2b63a85bUL, 0x9535d555UL, 0x11479e75UL,
0xe215e5ebUL, 0xc64b9430UL, 0xa84a6f14UL, 0x8691239cUL,
0x394c6accUL, 0x4a5f8affUL, 0x4d040690UL, 0xbbee99ddUL,
0xca1e1152UL, 0x18aaffc4UL, 0x98eb6469UL, 0xff07fefcUL,
0x018b345eUL, 0xbe567d0eUL, 0xd9bae79bUL, 0x324263c1UL,
0x7b75b5dcUL, 0x17972644UL, 0x6667aecbUL, 0xcb95250cUL,
0x67ec9a95UL, 0xd057862aUL, 0x99605037UL, 0x05b8e4d3UL,
0xba65ad83UL, 0x3519efaeUL, 0x13a4f6c9UL, 0xa9c15b4aUL,
0xd6873e1bUL, 0x5ea0f059UL, 0x5b18148aUL, 0x3baf0270UL,
0x76ab04e0UL, 0xbfdd4950UL, 0x63df4a18UL, 0x56c6a5b6UL,
0x0a853d53UL, 0x37fa8712UL, 0xa777b694UL, 0x7f466551UL,
0x09ed61b1UL, 0xe91bece6UL, 0x25d54585UL, 0x52f5753bUL,
0x3d7fba41UL, 0x8827ce42UL, 0x43b2eb4eUL, 0x97d6bde9UL,
0xf3527b9eUL, 0x4562537fUL, 0xa02c3afbUL, 0x707bbcd1UL,
0x6bb91ff7UL, 0x1d121b17UL, 0xc8fd79eeUL, 0xf03a277cUL,
0xd70c0a45UL, 0x7996dd60UL, 0xab2233f6UL, 0x89acfa1cUL,
0x5dc8acbbUL, 0x30a10b7dUL, 0x4bd4bea1UL, 0x94bee10bUL,
0x5425cd0aUL, 0x62547e46UL, 0x82a2f311UL, 0x3e17e6a3UL,
0xe6263566UL, 0x75c35802UL, 0x9b83388bUL, 0xc27844bdUL,
0xdc020348UL, 0x8b4f92a0UL, 0x7c2e39b3UL, 0xe54e6984UL,
0x71f0888fUL, 0x27362d39UL, 0x3f9cd2fdUL, 0x6e01fb24UL,
0xdd893716UL, 0x00000000UL, 0xe0f68d57UL, 0x6ce29398UL,
0x15744ef8UL, 0x5a9320d4UL, 0xe7ad0138UL, 0xb4d3405dUL,
0x871a17c2UL, 0x2db3106aUL, 0x2f5078d6UL, 0x3cf48e1fUL,
0xa1a70ea5UL, 0x3671b34cUL, 0xae9ad725UL, 0x245e71dbUL,
0x50161d87UL, 0xd5ef62f9UL, 0x908d3186UL, 0x161c121aUL,
0xcfa6f581UL, 0x075b8c6fUL, 0x4937d61dUL, 0x926e593aUL,
0x6484c677UL, 0xb886c53fUL, 0xf9d746cdUL, 0xb0e090d0UL,
0x8329c74fUL, 0xfde49640UL, 0x0b0e090dUL, 0x206da156UL,
0x228ec9eaUL, 0x2edb4c88UL, 0x8ef77673UL, 0xbcb515b2UL,
0xc110185fUL, 0x6a322ba9UL, 0xb16ba48eUL, 0x55aef954UL,
0xee406089UL, 0x086655efUL, 0x44e96721UL, 0xbd3e21ecUL,
0x772030beUL, 0xadf28bc7UL, 0x2980c0e7UL, 0x8c141ecfUL,
0x48bce243UL, 0x8ac4a6feUL, 0xd831d3c5UL, 0x60b716faUL,
0x9d5380baUL, 0xf2d94fc0UL, 0x781de93eUL, 0x3a24362eUL,
0xdee16bf4UL, 0xefcb54d7UL, 0xf409f7f1UL, 0xf582c3afUL,
0x280bf4b9UL, 0x519d29d9UL, 0x38c75e92UL, 0xebf8845aUL,
0xe890d8b8UL, 0x0ddeb13cUL, 0x0433d08dUL, 0x03685ce2UL,
0xe4c55ddaUL, 0x9e3bdc58UL, 0x460a0f9dUL, 0xd33fdac8UL,
0xdb598f27UL, 0xc4a8fc8cUL, 0xac79bf99UL, 0x4e6c5a72UL,
0xfe8ccaa2UL, 0xe39ed1b5UL, 0xa41fea76UL, 0xea73b004UL,



0xbc02e368UL, 0x620c5585UL, 0x23312a3fUL, 0x13f761abUL,
0x6d7298d4UL, 0x9a1921cbUL, 0xa4613c22UL, 0x3dcd459dUL,
0xb42305fdUL, 0x075f2bc4UL, 0x01c09b2cUL, 0x800f3dd9UL,
0x5c74486cUL, 0x7e85f97fUL, 0xab1ff173UL, 0xde0eb6edUL,
0x6bed283cUL, 0x781a4997UL, 0x918d9f2aUL, 0x9f33c957UL,
0xa8aaa907UL, 0xed7da50dUL, 0x2d8f7c42UL, 0xb0c9764dUL,
0xe8574d91UL, 0x63cccea9UL, 0x96d2b4eeUL, 0xe1b63028UL,
0x61b90df1UL, 0x6726bd19UL, 0xad80419bUL, 0x6ec7c0a0UL,
0xf2415183UL, 0xf03492dbUL, 0x1efc6fa2UL, 0xce4c8f32UL,
0x337313e0UL, 0xc66d69a7UL, 0x6493e56dUL, 0x2ffabf1aUL,
0xbfb7bb1cUL, 0x03b55874UL, 0x2c4fe76eUL, 0xb7965d89UL,
0x052ae89cUL, 0x19a34466UL, 0x71fb342eUL, 0x29650ff2UL,
0x827afe81UL, 0x22f1b113UL, 0x35eca308UL, 0x0f7ecd51UL,
0xa614ff7aUL, 0x93f85c72UL, 0x97122fc2UL, 0xe3c3f370UL,
0x491c992fUL, 0x1568d143UL, 0x261bc2a3UL, 0x32b388ccUL,
0x7a6f8acfUL, 0x069fb0e8UL, 0xf51e7a47UL, 0x79dad2bbUL,
0x0821e695UL, 0xe55c4398UL, 0x3106d0b8UL, 0x7baf11e3UL,
0x65537e41UL, 0x2b10ccaaUL, 0xe49cd8b4UL, 0xa7d46456UL,
0x3659fb7cUL, 0x2084724bUL, 0x4df6ea9fUL, 0xaadf6a5fUL,
0xdfce2dc1UL, 0x68587048UL, 0xf381caafUL, 0xd8910605UL,
0x4b695a77UL, 0x28a594deUL, 0x104239dfUL, 0xc347813bUL,
0xcaa6fc82UL, 0xd2c523c8UL, 0x6cb203f8UL, 0xd59a080cUL,
0xac40dab7UL, 0x09e17db9UL, 0x342c3824UL, 0x47a2cf52UL,
0x74d1dcb2UL, 0x5b2b63a8UL, 0x559535d5UL, 0x7511479eUL,
0xebe215e5UL, 0x30c64b94UL, 0x14a84a6fUL, 0x9c869123UL,
0xcc394c6aUL, 0xff4a5f8aUL, 0x904d0406UL, 0xddbbee99UL,
0x52ca1e11UL, 0xc418aaffUL, 0x6998eb64UL, 0xfcff07feUL,
0x5e018b34UL, 0x0ebe567dUL, 0x9bd9bae7UL, 0xc1324263UL,
0xdc7b75b5UL, 0x44179726UL, 0xcb6667aeUL, 0x0ccb9525UL,
0x9567ec9aUL, 0x2ad05786UL, 0x37996050UL, 0xd305b8e4UL,
0x83ba65adUL, 0xae3519efUL, 0xc913a4f6UL, 0x4aa9c15bUL,
0x1bd6873eUL, 0x595ea0f0UL, 0x8a5b1814UL, 0x703baf02UL,
0xe076ab04UL, 0x50bfdd49UL, 0x1863df4aUL, 0xb656c6a5UL,
0x530a853dUL, 0x1237fa87UL, 0x94a777b6UL, 0x517f4665UL,
0xb109ed61UL, 0xe6e91becUL, 0x8525d545UL, 0x3b52f575UL,
0x413d7fbaUL, 0x428827ceUL, 0x4e43b2ebUL, 0xe997d6bdUL,
0x9ef3527bUL, 0x7f456253UL, 0xfba02c3aUL, 0xd1707bbcUL,
0xf76bb91fUL, 0x171d121bUL, 0xeec8fd79UL, 0x7cf03a27UL,
0x45d70c0aUL, 0x607996ddUL, 0xf6ab2233UL, 0x1c89acfaUL,
0xbb5dc8acUL, 0x7d30a10bUL, 0xa14bd4beUL, 0x0b94bee1UL,
0x0a5425cdUL, 0x4662547eUL, 0x1182a2f3UL, 0xa33e17e6UL,
0x66e62635UL, 0x0275c358UL, 0x8b9b8338UL, 0xbdc27844UL,
0x48dc0203UL, 0xa08b4f92UL, 0xb37c2e39UL, 0x84e54e69UL,
0x8f71f088UL, 0x3927362dUL, 0xfd3f9cd2UL, 0x246e01fbUL,
0x16dd8937UL, 0x00000000UL, 0x57e0f68dUL, 0x986ce293UL,
0xf815744eUL, 0xd45a9320UL, 0x38e7ad01UL, 0x5db4d340UL,
0xc2871a17UL, 0x6a2db310UL, 0xd62f5078UL, 0x1f3cf48eUL,
0xa5a1a70eUL, 0x4c3671b3UL, 0x25ae9ad7UL, 0xdb245e71UL,
0x8750161dUL, 0xf9d5ef62UL, 0x86908d31UL, 0x1a161c12UL,
0x81cfa6f5UL, 0x6f075b8cUL, 0x1d4937d6UL, 0x3a926e59UL,
0x776484c6UL, 0x3fb886c5UL, 0xcdf9d746UL, 0xd0b0e090UL,
0x4f8329c7UL, 0x40fde496UL, 0x0d0b0e09UL, 0x56206da1UL,
0xea228ec9UL, 0x882edb4cUL, 0x738ef776UL, 0xb2bcb515UL,
0x5fc11018UL, 0xa96a322bUL, 0x8eb16ba4UL, 0x5455aef9UL,
0x89ee4060UL, 0xef086655UL, 0x2144e967UL, 0xecbd3e21UL,
0xbe772030UL, 0xc7adf28bUL, 0xe72980c0UL, 0xcf8c141eUL,
0x4348bce2UL, 0xfe8ac4a6UL, 0xc5d831d3UL, 0xfa60b716UL,
0xba9d5380UL, 0xc0f2d94fUL, 0x3e781de9UL, 0x2e3a2436UL,
0xf4dee16bUL, 0xd7efcb54UL, 0xf1f409f7UL, 0xaff582c3UL,
0xb9280bf4UL, 0xd9519d29UL, 0x9238c75eUL, 0x5aebf884UL,
0xb8e890d8UL, 0x3c0ddeb1UL, 0x8d0433d0UL, 0xe203685cUL,
0xdae4c55dUL, 0x589e3bdcUL, 0x9d460a0fUL, 0xc8d33fdaUL,
0x27db598fUL, 0x8cc4a8fcUL, 0x99ac79bfUL, 0x724e6c5aUL,
0xa2fe8ccaUL, 0xb5e39ed1UL, 0x76a41feaUL, 0x04ea73b0UL,



0x68bc02e3UL, 0x85620c55UL, 0x3f23312aUL, 0xab13f761UL,
0xd46d7298UL, 0xcb9a1921UL, 0x22a4613cUL, 0x9d3dcd45UL,
0xfdb42305UL, 0xc4075f2bUL, 0x2c01c09bUL, 0xd9800f3dUL,
0x6c5c7448UL, 0x7f7e85f9UL, 0x73ab1ff1UL, 0xedde0eb6UL,
0x3c6bed28UL, 0x97781a49UL, 0x2a918d9fUL, 0x579f33c9UL,
0x07a8aaa9UL, 0x0ded7da5UL, 0x422d8f7cUL, 0x4db0c976UL,
0x91e8574dUL, 0xa963ccceUL, 0xee96d2b4UL, 0x28e1b630UL,
0xf161b90dUL, 0x196726bdUL, 0x9bad8041UL, 0xa06ec7c0UL,
0x83f24151UL, 0xdbf03492UL, 0xa21efc6fUL, 0x32ce4c8fUL,
0xe0337313UL, 0xa7c66d69UL, 0x6d6493e5UL, 0x1a2ffabfUL,
0x1cbfb7bbUL, 0x7403b558UL, 0x6e2c4fe7UL, 0x89b7965dUL,
0x9c052ae8UL, 0x6619a344UL, 0x2e71fb34UL, 0xf229650fUL,
0x81827afeUL, 0x1322f1b1UL, 0x0835eca3UL, 0x510f7ecdUL,
0x7aa614ffUL, 0x7293f85cUL, 0xc297122fUL, 0x70e3c3f3UL,
0x2f491c99UL, 0x431568d1UL, 0xa3261bc2UL, 0xcc32b388UL,
0xcf7a6f8aUL, 0xe8069fb0UL, 0x47f51e7aUL, 0xbb79dad2UL,
0x950821e6UL, 0x98e55c43UL, 0xb83106d0UL, 0xe37baf11UL,
0x4165537eUL, 0xaa2b10ccUL, 0xb4e49cd8UL, 0x56a7d464UL,
0x7c3659fbUL, 0x4b208472UL, 0x9f4df6eaUL, 0x5faadf6aUL,
0xc1dfce2dUL, 0x48685870UL, 0xaff381caUL, 0x05d89106UL,
0x774b695aUL, 0xde28a594UL, 0xdf104239UL, 0x3bc34781UL,
0x82caa6fcUL, 0xc8d2c523UL, 0xf86cb203UL, 0x0cd59a08UL,
0xb7ac40daUL, 0xb909e17dUL, 0x24342c38UL, 0x5247a2cfUL,
0xb274d1dcUL, 0xa85b2b63UL, 0xd5559535UL, 0x9e751147UL,
0xe5ebe215UL, 0x9430c64bUL, 0x6f14a84aUL, 0x239c8691UL,
0x6acc394cUL, 0x8aff4a5fUL, 0x06904d04UL, 0x99ddbbeeUL,
0x1152ca1eUL, 0xffc418aaUL, 0x646998ebUL, 0xfefcff07UL,
0x345e018bUL, 0x7d0ebe56UL, 0xe79bd9baUL, 0x63c13242UL,
0xb5dc7b75UL, 0x26441797UL, 0xaecb6667UL, 0x250ccb95UL,
0x9a9567ecUL, 0x862ad057UL, 0x50379960UL, 0xe4d305b8UL,
0xad83ba65UL, 0xefae3519UL, 0xf6c913a4UL, 0x5b4aa9c1UL,
0x3e1bd687UL, 0xf0595ea0UL, 0x148a5b18UL, 0x02703bafUL,
0x04e076abUL, 0x4950bfddUL, 0x4a1863dfUL, 0xa5b656c6UL,
0x3d530a85UL, 0x871237faUL, 0xb694a777UL, 0x65517f46UL,
0x61b109edUL, 0xece6e91bUL, 0x458525d5UL, 0x753b52f5UL,
0xba413d7fUL, 0xce428827UL, 0xeb4e43b2UL, 0xbde997d6UL,
0x7b9ef352UL, 0x537f4562UL, 0x3afba02cUL, 0xbcd1707bUL,
0x1ff76bb9UL, 0x1b171d12UL, 0x79eec8fdUL, 0x277cf03aUL,
0x0a45d70cUL, 0xdd607996UL, 0x33f6ab22UL, 0xfa1c89acUL,
0xacbb5dc8UL, 0x0b7d30a1UL, 0xbea14bd4UL, 0xe10b94beUL,
0xcd0a5425UL, 0x7e466254UL, 0xf31182a2UL, 0xe6a33e17UL,
0x3566e626UL, 0x580275c3UL, 0x388b9b83UL, 0x44bdc278UL,
0x0348dc02UL, 0x92a08b4fUL, 0x39b37c2eUL, 0x6984e54eUL,
0x888f71f0UL, 0x2d392736UL, 0xd2fd3f9cUL, 0xfb246e01UL,
0x3716dd89UL, 0x00000000UL, 0x8d57e0f6UL, 0x93986ce2UL,
0x4ef81574UL, 0x20d45a93UL, 0x0138e7adUL, 0x405db4d3UL,
0x17c2871aUL, 0x106a2db3UL, 0x78d62f50UL, 0x8e1f3cf4UL,
0x0ea5a1a7UL, 0xb34c3671UL, 0xd725ae9aUL, 0x71db245eUL,
0x1d875016UL, 0x62f9d5efUL, 0x3186908dUL, 0x121a161cUL,
0xf581cfa6UL, 0x8c6f075bUL, 0xd61d4937UL, 0x593a926eUL,
0xc6776484UL, 0xc53fb886UL, 0x46cdf9d7UL, 0x90d0b0e0UL,
0xc74f8329UL, 0x9640fde4UL, 0x090d0b0eUL, 0xa156206dUL,
0xc9ea228eUL, 0x4c882edbUL, 0x76738ef7UL, 0x15b2bcb5UL,
0x185fc110UL, 0x2ba96a32UL, 0xa48eb16bUL, 0xf95455aeUL,
0x6089ee40UL, 0x55ef0866UL, 0x672144e9UL, 0x21ecbd3eUL,
0x30be7720UL, 0x8bc7adf2UL, 0xc0e72980UL, 0x1ecf8c14UL,
0xe24348bcUL, 0xa6fe8ac4UL, 0xd3c5d831UL, 0x16fa60b7UL,
0x80ba9d53UL, 0x4fc0f2d9UL, 0xe93e781dUL, 0x362e3a24UL,
0x6bf4dee1UL, 0x54d7efcbUL, 0xf7f1f409UL, 0xc3aff582UL,
0xf4b9280bUL, 0x29d9519dUL, 0x5e9238c7UL, 0x845aebf8UL,
0xd8b8e890UL, 0xb13c0ddeUL, 0xd08d0433UL, 0x5ce20368UL,
0x5ddae4c5UL, 0xdc589e3bUL, 0x0f9d460aUL, 0xdac8d33fUL,
0x8f27db59UL, 0xfc8cc4a8UL, 0xbf99ac79UL, 0x5a724e6cUL,
0xcaa2fe8cUL, 0xd1b5e39eUL, 0xea76a41fUL, 0xb004ea73UL,
};
//-----------------
static const byte SKIPJACK_fTable[256] = {
        0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,0x99,0xb1,0xaf,0xf9,
        0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,
        0x0a,0xdf,0x02,0xa0,0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,
        0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,0xf7,0x16,0x6a,0xa2,
        0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,
        0x55,0xb9,0xda,0x85,0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,
        0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,0x6d,0x98,0x9b,0x76,
        0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,
        0x42,0xed,0x9e,0x6e,0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,
        0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,0x5d,0x5c,0x31,0xa4,
        0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,
        0x34,0x4b,0x1c,0x73,0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,
        0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,0xff,0x8c,0x0e,0xe2,
        0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,
        0x08,0x77,0x11,0xbe,0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,
        0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,0x05,0x59,0x2a,0x46
};
//-----------------
static const byte Square_Se_or_SHARK_enc_sbox[256] = {
177, 206, 195, 149,  90, 173, 231,   2,  77,  68, 251, 145,  12, 135, 161,  80,
203, 103,  84, 221,  70, 143, 225,  78, 240, 253, 252, 235, 249, 196,  26, 110,
 94, 245, 204, 141,  28,  86,  67, 254,   7,  97, 248, 117,  89, 255,   3,  34,
138, 209,  19, 238, 136,   0,  14,  52,  21, 128, 148, 227, 237, 181,  83,  35,
 75,  71,  23, 167, 144,  53, 171, 216, 184, 223,  79,  87, 154, 146, 219,  27,
 60, 200, 153,   4, 142, 224, 215, 125, 133, 187,  64,  44,  58,  69, 241,  66,
101,  32,  65,  24, 114,  37, 147, 112,  54,   5, 242,  11, 163, 121, 236,   8,
 39,  49,  50, 182, 124, 176,  10, 115,  91, 123, 183, 129, 210,  13, 106,  38,
158,  88, 156, 131, 116, 179, 172,  48, 122, 105, 119,  15, 174,  33, 222, 208,
 46, 151,  16, 164, 152, 168, 212, 104,  45,  98,  41, 109,  22,  73, 118, 199,
232, 193, 150,  55, 229, 202, 244, 233,  99,  18, 194, 166,  20, 188, 211,  40,
175,  47, 230,  36,  82, 198, 160,   9, 189, 140, 207,  93,  17,  95,   1, 197,
159,  61, 162, 155, 201,  59, 190,  81,  25,  31,  63,  92, 178, 239,  74, 205,
191, 186, 111, 100, 217, 243,  62, 180, 170, 220, 213,   6, 192, 126, 246, 102,
108, 132, 113,  56, 185,  29, 127, 157,  72, 139,  42, 218, 165,  51, 130,  57,
214, 120, 134, 250, 228,  43, 169,  30, 137,  96, 107, 234,  85,  76, 247, 226,
};

static const byte Square_Sd_or_SHARK_dec_sbox[256] = {
 53, 190,   7,  46,  83, 105, 219,  40, 111, 183, 118, 107,  12, 125,  54, 139,
146, 188, 169,  50, 172,  56, 156,  66,  99, 200,  30,  79,  36, 229, 247, 201,
 97, 141,  47,  63, 179, 101, 127, 112, 175, 154, 234, 245,  91, 152, 144, 177,
135, 113, 114, 237,  55,  69, 104, 163, 227, 239,  92, 197,  80, 193, 214, 202,
 90,  98,  95,  38,   9,  93,  20,  65, 232, 157, 206,  64, 253,   8,  23,  74,
 15, 199, 180,  62,  18, 252,  37,  75, 129,  44,   4, 120, 203, 187,  32, 189,
249,  41, 153, 168, 211,  96, 223,  17, 151, 137, 126, 250, 224, 155,  31, 210,
103, 226, 100, 119, 132,  43, 158, 138, 241, 109, 136, 121, 116,  87, 221, 230,
 57, 123, 238, 131, 225,  88, 242,  13,  52, 248,  48, 233, 185,  35,  84,  21,
 68,  11,  77, 102,  58,   3, 162, 145, 148,  82,  76, 195, 130, 231, 128, 192,
182,  14, 194, 108, 147, 236, 171,  67, 149, 246, 216,  70, 134,   5, 140, 176,
117,   0, 204, 133, 215,  61, 115, 122,  72, 228, 209,  89, 173, 184, 198, 208,
220, 161, 170,   2,  29, 191, 181, 159,  81, 196, 165,  16,  34, 207,   1, 186,
143,  49, 124, 174, 150, 218, 240,  86,  71, 212, 235,  78, 217,  19, 142,  73,
 85,  22, 255,  59, 244, 164, 178,   6, 160, 167, 251,  27, 110,  60,  51, 205,
 24,  94, 106, 213, 166,  33, 222, 254,  42,  28, 243,  10,  26,  25,  39,  45,
};

static const word64 SHARK_enc_cbox[8*256] = {
/* box 0 */
W64LIT(0x060d838f16f3a365),
W64LIT(0xa68857ee5cae56f6),
W64LIT(0xebf516353c2c4d89),
W64LIT(0x652174be88e85bdc),
W64LIT(0x0d4e9a8086c17921),
W64LIT(0x27ba7d33cffa58a1),
W64LIT(0x88d9e104a237b530),
W64LIT(0x693b8755a4fbe816),
W64LIT(0xdac9591826b254a0),
W64LIT(0x45c2e369fb336af3),
W64LIT(0xa96e1fb87b3e4ef4),
W64LIT(0xb7578f1435eb7ef0),
W64LIT(0x839af80b32056f74),
W64LIT(0xae37f55cc71f277a),
W64LIT(0xa4208538fdff37d5),
W64LIT(0x35991e74ad3cdb6f),
W64LIT(0xba191594b32a07d1),
W64LIT(0x5344d1772e572b7b),
W64LIT(0xe7efe5de103ffe43),
W64LIT(0xa3796fdc41de5e5b),
W64LIT(0x2cf9643c5fc882e5),
W64LIT(0xffdbf6fd48196d22),
W64LIT(0x33949dfbbbcf780a),
W64LIT(0x7d15679dd0cec8bd),
W64LIT(0x5f5e229c024498b1),
W64LIT(0x1223634762c683ce),
W64LIT(0xdcc4da973041f7c5),
W64LIT(0x0b43190f9032da44),
W64LIT(0xc05598eddfc5a6e2),
W64LIT(0x9e5fd31a7753f4b8),
W64LIT(0x9afa8243c0f136fe),
W64LIT(0xcc4f6b06f3d61528),
W64LIT(0xdf38612a3bc25c0d),
W64LIT(0x43cf60e6edc0c996),
W64LIT(0xcfb3d0bbf855bee0),
W64LIT(0x96e071a8ece28534),
W64LIT(0x21b7febcd909fbc4),
W64LIT(0x8ed4628bb4c41655),
W64LIT(0x30682646b04cd3c2),
W64LIT(0xb5ff5dc294ba1fd3),
W64LIT(0x75aac52f4b7fb931),
W64LIT(0xe809ad8837afe641),
W64LIT(0x0eb2213d8d42d2e9),
W64LIT(0x9852509561a057dd),
W64LIT(0xaa92a40570bde53c),
W64LIT(0x7b18e412c63d6bd8),
W64LIT(0xa7dc3e85f67c9c1d),
W64LIT(0xd8618bce87e33583),
W64LIT(0xe34ab487a79d3c05),
W64LIT(0x20e397d773db312f),
W64LIT(0x05f138321d7008ad),
W64LIT(0x17d25b757fb68b63),
W64LIT(0x8a7133d20366d413),
W64LIT(0x0000000000000000),
W64LIT(0xeaa17f5e96fe8762),
W64LIT(0xc101f18675176c09),
W64LIT(0xbebc44cd0488c597),
W64LIT(0xdb9d30738c609e4b),
W64LIT(0xabc6cd6eda6f2fd7),
W64LIT(0x5aaf1aae1f34901c),
W64LIT(0xb00e65f089ca177e),
W64LIT(0xd47b7825abf08649),
W64LIT(0x924520f15b404772),
W64LIT(0x1686321ed5644188),
W64LIT(0x618425e73f4a999a),
W64LIT(0xe21eddec0d4ff6ee),
W64LIT(0xd787c398a0732d81),
W64LIT(0x1f6df9c7e407faef),
W64LIT(0x79b036c4676c0afb),
W64LIT(0x0fe6485627901802),
W64LIT(0x9cf701ccd602959b),
W64LIT(0xbfe82da6ae5a0f7c),
W64LIT(0x990639fecb729d36),
W64LIT(0xca42e889e525b64d),
W64LIT(0xb3f2de4d8249bcb6),
W64LIT(0x4033db5be643625e),
W64LIT(0x4167b2304c91a8b5),
W64LIT(0x108bb191c397e2ed),
W64LIT(0x1834132358269361),
W64LIT(0x541d3b93927642f5),
W64LIT(0x90edf227fa112651),
W64LIT(0x1dc52b1145569bcc),
W64LIT(0xe6bb8cb5baed34a8),
W64LIT(0xd276fbaabd03252c),
W64LIT(0x313c4f2d1a9e1929),
W64LIT(0xfd73242be9480c01),
W64LIT(0x9baeeb286a23fc15),
W64LIT(0xc9be5334eea61d85),
W64LIT(0xc70c720963e4cf6c),
W64LIT(0x3eda077b3d0e012b),
W64LIT(0x97b418c346304fdf),
W64LIT(0x32c0f490111db2e1),
W64LIT(0x2ba08ed8e3e9eb6b),
W64LIT(0x8b255ab9a9b41ef8),
W64LIT(0x91b99b4c50c3ecba),
W64LIT(0xfe8f9f96e2cba7c9),
W64LIT(0x3a7f56228aacc36d),
W64LIT(0xb15a0c9b2318dd95),
W64LIT(0x5953a11314b73bd4),
W64LIT(0xf3c10516640adee8),
W64LIT(0xedf895ba2adfeeec),
W64LIT(0xadcb4ee1cc9c8cb2),
W64LIT(0xde6c0841911096e6),
W64LIT(0x84c312ef8e2406fa),
W64LIT(0xa83a76d3d1ec841f),
W64LIT(0x1c91427aef845127),
W64LIT(0x3665a5c9a6bf70a7),
W64LIT(0xf6303d24797ad645),
W64LIT(0xcd1b026d5904dfc3),
W64LIT(0x1bc8a89e53a538a9),
W64LIT(0x7ee9dc20db4d6375),
W64LIT(0x51ec03a18f064a58),
W64LIT(0xc4f0c9b4686764a4),
W64LIT(0xdd90b3fc9a933d2e),
W64LIT(0x7a4c8d796cefa133),
W64LIT(0x73a746a05d8c1a54),
W64LIT(0x0759eae4bc21698e),
W64LIT(0xc8ea3a5f4474d76e),
W64LIT(0x38d784f42bfda24e),
W64LIT(0x231f2c6a78589ae7),
W64LIT(0xc3a92350d4460d2a),
W64LIT(0x72f32fcbf75ed0bf),
W64LIT(0xbd40ff700f0b6e5f),
W64LIT(0x157a89a3dee7ea40),
W64LIT(0x873fa95285a7ad32),
W64LIT(0x4d7d41db60821b7f),
W64LIT(0x1e3990ac4ed53004),
W64LIT(0x0a1770643ae010af),
W64LIT(0x9311499af1928d99),
W64LIT(0x64751dd5223a9137),
W64LIT(0xfa2acecf5569658f),
W64LIT(0x7c410ef67a1c0256),
W64LIT(0x56b5e945332723d6),
W64LIT(0x6f3604dab2084b73),
W64LIT(0xe95dc4e39d7d2caa),
W64LIT(0x13770a2cc8144925),
W64LIT(0xbc14961ba5d9a4b4),
W64LIT(0xb9e5ae29b8a9ac19),
W64LIT(0xf169d7c0c55bbfcb),
W64LIT(0x2446c68ec479f369),
W64LIT(0x806643b63986c4bc),
W64LIT(0x7fbdb54b719fa99e),
W64LIT(0x04a55159b7a2c246),
W64LIT(0xee042e07215c4524),
W64LIT(0x5bfb73c5b5e65af7),
W64LIT(0x0c1af3eb2c13b3ca),
W64LIT(0xa22d06b7eb0c94b0),
W64LIT(0xb8b1c742127b66f2),
W64LIT(0x285c3565e86a40a3),
W64LIT(0x3b2b3f49207e0986),
W64LIT(0x3c72d5ad9c5f6008),
W64LIT(0x770217f9ea2ed812),
W64LIT(0xfc274d40439ac6ea),
W64LIT(0x4fd5930dc1d37a5c),
W64LIT(0x2e51b6eafe99e3c6),
W64LIT(0x6b93558305aa8935),
W64LIT(0x19607a48f2f4598a),
W64LIT(0x08bfa2b29bb1718c),
W64LIT(0x3f8e6e1097dccbc0),
W64LIT(0x3983ed9f812f68a5),
W64LIT(0xac9f278a664e4659),
W64LIT(0x82ce916098d7a59f),
W64LIT(0xc2fd4a3b7e94c7c1),
W64LIT(0x66ddcf03836bf014),
W64LIT(0xe1e2665106cc5d26),
W64LIT(0x74feac44e1ad73da),
W64LIT(0x8d28d936bf47bd9d),
W64LIT(0x62789e5a34c93252),
W64LIT(0x81322add93540e57),
W64LIT(0xcb1681e24ff77ca6),
W64LIT(0x2512afe56eab3982),
W64LIT(0xd18a4017b6808ee4),
W64LIT(0x705bfd1d560fb19c),
W64LIT(0x4b70c2547671b81a),
W64LIT(0x49d81082d720d939),
W64LIT(0xe0b60f3aac1e97cd),
W64LIT(0x4e81fa666b01b0b7),
W64LIT(0x951cca15e7612efc),
W64LIT(0x463e58d4f0b0c13b),
W64LIT(0x632cf7319e1bf8b9),
W64LIT(0x5ca2992109c73379),
W64LIT(0xf764544fd3a81cae),
W64LIT(0x6ac73ce8af7843de),
W64LIT(0x9f0bba71dd813e53),
W64LIT(0x85977b8424f6cc11),
W64LIT(0x5807c878be65f13f),
W64LIT(0x686fee3e0e2922fd),
W64LIT(0x78e45fafcdbec010),
W64LIT(0x6ccabf67b98be0bb),
W64LIT(0x11dfd8fa69452806),
W64LIT(0xcee7b9d05287740b),
W64LIT(0x50b86aca25d480b3),
W64LIT(0x5df6f04aa315f992),
W64LIT(0x5e0a4bf7a896525a),
W64LIT(0x03fcbbbd0b83abc8),
W64LIT(0x8f800be01e16dcbe),
W64LIT(0xd32292c117d1efc7),
W64LIT(0xe5473708b16e9f60),
W64LIT(0x224b4501d28a500c),
W64LIT(0xfb7ea7a4ffbbaf64),
W64LIT(0x3d26bcc6368daae3),
W64LIT(0x866bc0392f7567d9),
W64LIT(0x3731cca20c6dba4c),
W64LIT(0xb603e67f9f39b41b),
W64LIT(0xa1d1bd0ae08f3f78),
W64LIT(0xd935e2a52d31ff68),
W64LIT(0xaf639c376dcded91),
W64LIT(0x0154696baad2caeb),
W64LIT(0xecacfcd1800d2407),
W64LIT(0xf03dbeab6f897520),
W64LIT(0x02a8d2d6a1516123),
W64LIT(0xf498eff2d82bb766),
W64LIT(0x710f9476fcdd7b77),
W64LIT(0xf8821c19f43804ac),
W64LIT(0xf9d675725eeace47),
W64LIT(0x1a9cc1f5f977f242),
W64LIT(0x5210b81c8485e190),
W64LIT(0x6d9ed60c13592a50),
W64LIT(0xf2956c7dced81403),
W64LIT(0xbb4d7cff19f8cd3a),
W64LIT(0x4c2928b0ca50d194),
W64LIT(0x6e626db118da8198),
W64LIT(0xe4135e631bbc558b),
W64LIT(0x9da368a77cd05f70),
W64LIT(0xa574ec53572dfd3e),
W64LIT(0x09ebcbd93163bb67),
W64LIT(0x4a24ab3fdca372f1),
W64LIT(0x429b098d4712037d),
W64LIT(0x57e1802e99f5e93d),
W64LIT(0xef50476c8b8e8fcf),
W64LIT(0xa085d4614a5df593),
W64LIT(0x34cd771f07ee1184),
W64LIT(0xc6581b62c9360587),
W64LIT(0x2dad0d57f51a480e),
W64LIT(0x898d886f08e57fdb),
W64LIT(0xd6d3aaf30aa1e76a),
W64LIT(0x76567e9240fc12f9),
W64LIT(0xb4ab34a93e68d538),
W64LIT(0xb2a6b726289b765d),
W64LIT(0x8c7cb05d15957776),
W64LIT(0x554952f838a4881e),
W64LIT(0xd52f114e01224ca2),
W64LIT(0x60d04c8c95985371),
W64LIT(0x6789a66829b93aff),
W64LIT(0x2f05df81544b292d),
W64LIT(0x476a31bf5a620bd0),
W64LIT(0xf5cc869972f97d8d),
W64LIT(0x488c79e97df213d2),
W64LIT(0x44968a0251e1a018),
W64LIT(0x26ee14586528924a),
W64LIT(0xd0de297c1c52440f),
W64LIT(0xc5a4a0dfc2b5ae4f),
W64LIT(0x29085c0e42b88a48),
W64LIT(0x142ee0c8743520ab),
W64LIT(0x2af4e7b3493b2180),
W64LIT(0x9448a37e4db3e417),
/* box 1 */
W64LIT(0xe2795ba105ba30ce),
W64LIT(0x65b5d634f5e0fbdd),
W64LIT(0x2d7d7f1464dd8c55),
W64LIT(0xeefbf778add1c20b),
W64LIT(0x1eb0fbd1f11968e7),
W64LIT(0xe6073f45ce30cd8d),
W64LIT(0x21ffd3cdccb67e90),
W64LIT(0xdf0941cfa750a262),
W64LIT(0xc61df5b1b75ef18a),
W64LIT(0xc5c7defa9dc337c6),
W64LIT(0x2581b729073c83d3),
W64LIT(0xa5e97513167173cf),
W64LIT(0xdd3673bd381526b9),
W64LIT(0xe8baa1eef91ebb93),
W64LIT(0x3b314cf8f625eb34),
W64LIT(0x579d4bc8d5fc5df8),
W64LIT(0xbb598ec2e7681b28),
W64LIT(0xc8a06b1a80708794),
W64LIT(0x1c8fc9a36e5cec3c),
W64LIT(0xf60a5a3f0807d374),
W64LIT(0x1ace9f353a9395a4),
W64LIT(0x7e9e50387aab2cee),
W64LIT(0xb5e41069d0466d36),
W64LIT(0x8cea6ee3b92602d9),
W64LIT(0xf952ddad8af1e7fd),
W64LIT(0xb19a748d1bcc9075),
W64LIT(0x2464ae10b2e4c144),
W64LIT(0xfcc9a070f4a35829),
W64LIT(0xfa88f6e6a06c21b1),
W64LIT(0x2c98662dd105cec2),
W64LIT(0x9065a740d77aeee5),
W64LIT(0xcb7a4051aaed41d8),
W64LIT(0x55a279ba4ab9d923),
W64LIT(0x27be855b98790708),
W64LIT(0xbabc97fb52b059bf),
W64LIT(0xa19711f7ddfb8e8c),
W64LIT(0x047e64e4cb8afd43),
W64LIT(0xc386886cc90c4e5e),
W64LIT(0xc422c7c3281b7551),
W64LIT(0xfb6defdf15b46326),
W64LIT(0x01e51939b5d84297),
W64LIT(0x5cbba8be9c809432),
W64LIT(0x6f762c7b09447080),
W64LIT(0xcee13d8cd4bffe0c),
W64LIT(0x54476083ff619bb4),
W64LIT(0x6e933542bc9c3217),
W64LIT(0x4af79b520e78f353),
W64LIT(0x98996f7db49be163),
W64LIT(0xa07208ce6823cc1b),
W64LIT(0x2b3c29823012f5cd),
W64LIT(0x93bf8c0bfde728a9),
W64LIT(0x2225f886e62bb8dc),
W64LIT(0x7f7b4901cf736e79),
W64LIT(0x0000000000000000),
W64LIT(0x023f32729f4584db),
W64LIT(0xd5cabb805bf4293f),
W64LIT(0x07a44fafe1173b0f),
W64LIT(0xe95fb8d74cc6f904),
W64LIT(0x7b052de504f9933a),
W64LIT(0x6aed51a67716cf54),
W64LIT(0x68d263d4e8534b8f),
W64LIT(0xa96bd9cabe1a810a),
W64LIT(0x1d6ad09adb84aeab),
W64LIT(0x0d67b5e01db3b052),
W64LIT(0x52063615abaee22c),
W64LIT(0x8f3045a893bbc495),
W64LIT(0xd8ad0e604647996d),
W64LIT(0xaf2a8f5cead5f892),
W64LIT(0x3017af8ebf5922fe),
W64LIT(0x4034611df2dc780e),
W64LIT(0x721cfce1d2c0de2b),
W64LIT(0x28e602c91a8f3381),
W64LIT(0xe1a370ea2f27f682),
W64LIT(0x29031bf0af577116),
W64LIT(0x1914b47e100e53e8),
W64LIT(0x567852f160241f6f),
W64LIT(0x793a1f979bbc17e1),
W64LIT(0xef1eee411809809c),
W64LIT(0x6211999b14f7c0d2),
W64LIT(0x059b7ddd7e52bfd4),
W64LIT(0x43ee4a56d841be42),
W64LIT(0xf1ae1590e910e87b),
W64LIT(0x33cd84c595c4e4b2),
W64LIT(0x4b12826bbba0b1c4),
W64LIT(0xeb608aa5d3837ddf),
W64LIT(0x201acaf4796e3c07),
W64LIT(0xbf27ea262ce2e66b),
W64LIT(0x58c5cc5a570a6971),
W64LIT(0x37b3e0215e4e19f1),
W64LIT(0xab54ebb8215f05d1),
W64LIT(0x8ed55c9126638602),
W64LIT(0x9aa65d0f2bde65b8),
W64LIT(0xd7f589f2c4b1ade4),
W64LIT(0x5039046734eb66f7),
W64LIT(0x6cac073023d9b6cc),
W64LIT(0x51dc1d5e81332460),
W64LIT(0x17a92ad5272025f6),
W64LIT(0x47902eb213cb4301),
W64LIT(0x1b2b860c8f4bd733),
W64LIT(0x4f6ce68f702a4c87),
W64LIT(0xcf0424b56167bc9b),
W64LIT(0x997c76440143a3f4),
W64LIT(0x7ae034dcb121d1ad),
W64LIT(0x100d657ac6371ef9),
W64LIT(0x0ac3fa4ffca48b5d),
W64LIT(0xdeec58f61288e0f5),
W64LIT(0x265b9c622da1459f),
W64LIT(0xdcd36a848dcd642e),
W64LIT(0xe4380d3751754956),
W64LIT(0x13d74e31ecaad8b5),
W64LIT(0xfd2cb949417b1abe),
W64LIT(0x9624f1d683b5977d),
W64LIT(0x4675378ba6130196),
W64LIT(0x0b26e376497cc9ca),
W64LIT(0x41d1782447043a99),
W64LIT(0xe39c4298b0627259),
W64LIT(0xcd3b16c7fe223840),
W64LIT(0x7787813cac9261ff),
W64LIT(0x492db01924e5351f),
W64LIT(0x5afafe28c84fedaa),
W64LIT(0x8b4e214c583139d6),
W64LIT(0xccde0ffe4bfa7ad7),
W64LIT(0x76629805194a2368),
W64LIT(0x7ca1624ae5eea835),
W64LIT(0x61cbb2d03e6a069e),
W64LIT(0x48c8a920913d7788),
W64LIT(0x8068c23a114df01c),
W64LIT(0xd38bed160f3b50a7),
W64LIT(0x32289dfc201ca625),
W64LIT(0xc1b9ba1e5649ca85),
W64LIT(0xed21dc33874c0447),
W64LIT(0xa3a8238542be0a57),
W64LIT(0x5b1fe7117d97af3d),
W64LIT(0x3d701a6ea2ea92ac),
W64LIT(0x73f9e5d867189cbc),
W64LIT(0x9ed839ebe05498fb),
W64LIT(0x5920d563e2d22be6),
W64LIT(0xca9f59681f35034f),
W64LIT(0x11e87c4373ef5c6e),
W64LIT(0x97c1e8ef366dd5ea),
W64LIT(0xacf0a417c0483ede),
W64LIT(0xd26ef42fbae31230),
W64LIT(0xbcfdc16d067f2027),
W64LIT(0xbec2f31f993aa4fc),
W64LIT(0x45af1cc08c8ec7da),
W64LIT(0x31f2b6b70a816069),
W64LIT(0xd9481759f39fdbfa),
W64LIT(0xe5dd140ee4ad0bc1),
W64LIT(0xa6335e583cecb583),
W64LIT(0x38eb67b3dcb82d78),
W64LIT(0xf5d07174229a1538),
W64LIT(0x5f6183f5b61d527e),
W64LIT(0x0f58879282f63489),
W64LIT(0x164c33ec92f86761),
W64LIT(0x444a05f93956854d),
W64LIT(0x818ddb03a495b28b),
W64LIT(0x4d53d4fdef6fc85c),
W64LIT(0x8d0f77da0cfe404e),
W64LIT(0x8416a6dedac70d5f),
W64LIT(0x666ffd7fdf7d3d91),
W64LIT(0xb63e3b22fadbab7a),
W64LIT(0xf2743edbc38d2e37),
W64LIT(0xa40c6c2aa3a93158),
W64LIT(0x9f3d20d2558cda6c),
W64LIT(0xfef692026be6dcf2),
W64LIT(0x2ea7545f4e404a19),
W64LIT(0xb2405fc631515639),
W64LIT(0x23c0e1bf53f3fa4b),
W64LIT(0x83b2e9713bd03650),
W64LIT(0x0641569654cf7998),
W64LIT(0xb883a589cdf5dd64),
W64LIT(0x3ad455c143fda9a3),
W64LIT(0x925a9532483f6a3e),
W64LIT(0xaab1f28194874746),
W64LIT(0xf435684d974257af),
W64LIT(0xd1b4df64907ed47c),
W64LIT(0x390e7e8a69606fef),
W64LIT(0xd051c65d25a696eb),
W64LIT(0xb4010950659e2fa1),
W64LIT(0x0c82acd9a86bf2c5),
W64LIT(0x88940a0772acff9a),
W64LIT(0xf39127e276556ca0),
W64LIT(0xaecf96655f0dba05),
W64LIT(0x03da2b4b2a9dc64c),
W64LIT(0x3f4f281c3daf1677),
W64LIT(0x3469cb6a74d3dfbd),
W64LIT(0xf04b0ca95cc8aaec),
W64LIT(0x1f55e2e844c12a70),
W64LIT(0x4cb6cdc45ab78acb),
W64LIT(0xc05ca327e3918812),
W64LIT(0x95feda9da9285131),
W64LIT(0xb966bcb0782d9ff3),
W64LIT(0xa7d647618934f714),
W64LIT(0xd61090cb7169ef73),
W64LIT(0x71c6d7aaf85d1867),
W64LIT(0xecc4c50a329446d0),
W64LIT(0x6450cf0d4038b94a),
W64LIT(0x420b536f6d99fcd5),
W64LIT(0x75b8b34e33d7e524),
W64LIT(0xc26391557cd40cc9),
W64LIT(0xda923c12d9021db6),
W64LIT(0x4e89ffb6c5f20e10),
W64LIT(0x0919d104d6394d11),
W64LIT(0x8aab3875ede97b41),
W64LIT(0xa88ec0f30bc2c39d),
W64LIT(0xb7db221b4f03e9ed),
W64LIT(0xc7f8ec880286b31d),
W64LIT(0x2f424d66fb98088e),
W64LIT(0xe04669d39affb415),
W64LIT(0x3eaa3125887754e0),
W64LIT(0x5e849acc03c510e9),
W64LIT(0x8257f0488e0874c7),
W64LIT(0xbd18d854b3a762b0),
W64LIT(0xb3a546ff848914ae),
W64LIT(0x9ce70b997f111c20),
W64LIT(0x3c9503571732d03b),
W64LIT(0xe7e2267c7be88f1a),
W64LIT(0x63f480a2a12f8245),
W64LIT(0x602eabe98bb24409),
W64LIT(0x941bc3a41cf013a6),
W64LIT(0x678ae4466aa57f06),
W64LIT(0x1232570859729a22),
W64LIT(0x6d491e099601f45b),
W64LIT(0x5d5eb1872958d6a5),
W64LIT(0x1473019e0dbde3ba),
W64LIT(0xa24d3abcf76648c0),
W64LIT(0x85f3bfe76f1f4fc8),
W64LIT(0x08fcc83d63e10f86),
W64LIT(0x745daa77860fa7b3),
W64LIT(0x9180be7962a2ac72),
W64LIT(0x87cc8d95f05acb13),
W64LIT(0x78df06ae2e645576),
W64LIT(0x18f1ad47a5d6117f),
W64LIT(0x358cd253c10b9d2a),
W64LIT(0x0ebd9eab372e761e),
W64LIT(0xf7ef4306bddf91e3),
W64LIT(0x7023ce934d855af0),
W64LIT(0xd42fa2b9ee2c6ba8),
W64LIT(0x3656f918eb965b66),
W64LIT(0x9d0212a0cac95eb7),
W64LIT(0x2ad930bb85cab75a),
W64LIT(0x862994ac45828984),
W64LIT(0x7d447b735036eaa2),
W64LIT(0xb07f6db4ae14d2e2),
W64LIT(0x6b08489fc2ce8dc3),
W64LIT(0x9b4344369e06272f),
W64LIT(0xad15bd2e75907c49),
W64LIT(0xdb77252b6cda5f21),
W64LIT(0xea85939c665b3f48),
W64LIT(0xc945722335a8c503),
W64LIT(0x159618a7b865a12d),
W64LIT(0x69377aed5d8b0918),
W64LIT(0x8971133ec774bd0d),
W64LIT(0x53e32f2c1e76a0bb),
W64LIT(0xf8b7c4943f29a56a),
W64LIT(0xff138b3bde3e9e65),
/* box 2 */
W64LIT(0x7c6a2eb5fdabecc6),
W64LIT(0x401cda0a752bbea0),
W64LIT(0x1925217156dc57c4),
W64LIT(0x56dec6d301d70787),
W64LIT(0x41c751ff73c6ac58),
W64LIT(0xc9067697a92cb5f9),
W64LIT(0x3391c917aaa0bc85),
W64LIT(0xae0a9a4c0e742afe),
W64LIT(0xaa8ca972162a62f4),
W64LIT(0x5aa193912935df99),
W64LIT(0x86fd9135fe27e5ba),
W64LIT(0xffca074b1d3f538e),
W64LIT(0x0e3cb65d24cdfc1b),
W64LIT(0x4384b2e07fe9885d),
W64LIT(0xc73ac0ca8de149e2),
W64LIT(0x48e5bc7645972eb4),
W64LIT(0xbe0d56b46ef9ffd6),
W64LIT(0x200e6d05c0ef5f50),
W64LIT(0xe1f17dee597f7abd),
W64LIT(0x0243e31f0c2f2405),
W64LIT(0xf4ab09dd2741f567),
W64LIT(0xe4acc52547cc204f),
W64LIT(0x348f92c3b83cc272),
W64LIT(0x53837e181f645d75),
W64LIT(0xd8da319acf4c7229),
W64LIT(0x81e3cae1ecbb9b4d),
W64LIT(0xd6e687c7eb818e32),
W64LIT(0x3dad7f4a8e6d409e),
W64LIT(0x28f70b79f053cf44),
W64LIT(0x493e3783437a3c4c),
W64LIT(0xb27203f6461b27c8),
W64LIT(0xd02357e6fff0e23d),
W64LIT(0xe8d390676f2ef851),
W64LIT(0x26cbbd24d49e335f),
W64LIT(0xee1640467b5f945e),
W64LIT(0x4aa65f6949b80ab1),
W64LIT(0xb56c58225487593f),
W64LIT(0x4ffbe7a2570b5043),
W64LIT(0x0aba85633c93b411),
W64LIT(0x78ec1d8be5f5a4cc),
W64LIT(0x501b16f215a66b88),
W64LIT(0x271036d1d27321a7),
W64LIT(0x7ff2465ff769da3b),
W64LIT(0x35541936bed1d08a),
W64LIT(0xb8c886957a8893d9),
W64LIT(0x2fe950ade2cfb1b3),
W64LIT(0xf90fd76a094e3f81),
W64LIT(0x2daab3b2eee095b6),
W64LIT(0x1abd499b5c1e6139),
W64LIT(0x0c7f554228e2d81e),
W64LIT(0x425f391579049aa5),
W64LIT(0xc3bcf3f495bf01e8),
W64LIT(0xb4b7d3d7526a4bc7),
W64LIT(0x0000000000000000),
W64LIT(0xa0362c112ab9d6e5),
W64LIT(0x91e406198c364e65),
W64LIT(0x454162c16b98e452),
W64LIT(0x139fa4126a4fe3d5),
W64LIT(0x01db8bf506ed12f8),
W64LIT(0x9a85088fb648e88c),
W64LIT(0x3ab3249e9cf13e69),
W64LIT(0xd57eef2de143b8cf),
W64LIT(0xb1ea6b1c4cd91135),
W64LIT(0x7aaffe94e9da80c9),
W64LIT(0xad92f2a604b61c03),
W64LIT(0xa3ae44fb207be018),
W64LIT(0xeb4bf88d65ecceac),
W64LIT(0xc0249b1e9f7d3715),
W64LIT(0xa8cf4a6d1a0546f1),
W64LIT(0xc6e14b3f8b0c5b1a),
W64LIT(0xce182d43bbb0cb0e),
W64LIT(0xfc526fa117fd6573),
W64LIT(0x8c471456c2b451ab),
W64LIT(0xac497953025b0efb),
W64LIT(0x0486333e185e480a),
W64LIT(0x18feaa845031453c),
W64LIT(0xa1eda7e42c54c41d),
W64LIT(0x06c5d02114716c0f),
W64LIT(0x055db8cb1eb35af2),
W64LIT(0xe5774ed0412132b7),
W64LIT(0x36cc71dcb413e677),
W64LIT(0x470281de67b7c057),
W64LIT(0x58e2708e251afb9c),
W64LIT(0xa914c1981ce85409),
W64LIT(0xb3a9880340f63530),
W64LIT(0x638adfe5bf06d70d),
W64LIT(0x0b610e963a7ea6e9),
W64LIT(0x927c6ef386f47898),
W64LIT(0xed8e28ac719da2a3),
W64LIT(0x7548c33ccbfa6e2a),
W64LIT(0xf3b5520935dd8b90),
W64LIT(0x8d9c9fa3c4594353),
W64LIT(0x31d22a08a68f9880),
W64LIT(0x0da4deb72e0fcae6),
W64LIT(0x8fdf7cbcc8766756),
W64LIT(0x5dbfc8453ba9a16e),
W64LIT(0x8e04f749ce9b75ae),
W64LIT(0x83a029fee094bf48),
W64LIT(0xa4b01f2f32e79eef),
W64LIT(0x1c7899ba486f0d36),
W64LIT(0x654f0fc4ab77bb02),
W64LIT(0x7db1a540fb46fe3e),
W64LIT(0x51c09d07134b7970),
W64LIT(0xcb459588a50391fc),
W64LIT(0x3fee9c558242649b),
W64LIT(0xfe118cbe1bd24176),
W64LIT(0x76d0abd6c13858d7),
W64LIT(0x5e27a0af316b9793),
W64LIT(0x69305a868395631c),
W64LIT(0x3b68af6b9a1c2c91),
W64LIT(0x6db669b89bcb2b16),
W64LIT(0xa72877c53825a812),
W64LIT(0xd3bb3f0cf532d4c0),
W64LIT(0x6ff58aa797e40f13),
W64LIT(0x96fa5dcd9eaa3092),
W64LIT(0x2c713847e80d874e),
W64LIT(0xc57923d581ce6de7),
W64LIT(0x2b6f6393fa91f9b9),
W64LIT(0x0922ed89365182ec),
W64LIT(0x324a42e2ac4dae7d),
W64LIT(0x16c21cd974fcb927),
W64LIT(0x956235279468066f),
W64LIT(0x7b747561ef379231),
W64LIT(0x449ae9346d75f6aa),
W64LIT(0xf570822821ace79f),
W64LIT(0x5939fb7b23f7e964),
W64LIT(0x7937967ee318b634),
W64LIT(0x84be722af208c1bf),
W64LIT(0x08f9667c30bc9014),
W64LIT(0xefcdcbb37db286a6),
W64LIT(0xa6f3fc303ec8baea),
W64LIT(0xea9073786301dc54),
W64LIT(0x62515410b9ebc5f5),
W64LIT(0xd260b4f9f3dfc638),
W64LIT(0x9e033bb1ae16a086),
W64LIT(0x38f0c78190de1a6c),
W64LIT(0xc267780193521310),
W64LIT(0x80384114ea5689b5),
W64LIT(0x9b5e837ab0a5fa74),
W64LIT(0xf73361372d83c39a),
W64LIT(0x3009a1fda0628a78),
W64LIT(0xd4a564d8e7aeaa37),
W64LIT(0xfb4c347505611b84),
W64LIT(0x5b7a18642fd8cd61),
W64LIT(0x239605efca2d69ad),
W64LIT(0xf8d45c9f0fa32d79),
W64LIT(0xbb50ee7f704aa524),
W64LIT(0x392b4c7496330894),
W64LIT(0x0fe73da82220eee3),
W64LIT(0x3717fa29b2fef48f),
W64LIT(0xf26ed9fc33309968),
W64LIT(0xd73d0c32ed6c9cca),
W64LIT(0xda99d285c363562c),
W64LIT(0xde1fe1bbdb3d1e26),
W64LIT(0x738d131ddf8b0225),
W64LIT(0x292c808cf6beddbc),
W64LIT(0xbc4eb5ab62d6dbd3),
W64LIT(0x039868ea0ac236fd),
W64LIT(0xcc5bce5cb79fef0b),
W64LIT(0xb031e0e94a3403cd),
W64LIT(0xc4a2a82087237f1f),
W64LIT(0xb72fbb3d58a87d3a),
W64LIT(0xafd111b908993806),
W64LIT(0x68ebd173857871e4),
W64LIT(0x9d9b535ba4d4967b),
W64LIT(0xe9081b9269c3eaa9),
W64LIT(0x71cef002d3a42620),
W64LIT(0x93a7e50680196a60),
W64LIT(0x891aac9ddc070b59),
W64LIT(0x155a74337e3e8fda),
W64LIT(0x4e206c5751e642bb),
W64LIT(0x9721d6389847226a),
W64LIT(0x12442fe76ca2f12d),
W64LIT(0x2553d5cede5c05a2),
W64LIT(0xa275cf0e2696f2e0),
W64LIT(0x24885e3bd8b1175a),
W64LIT(0x670cecdba7589f07),
W64LIT(0x749348c9cd177cd2),
W64LIT(0x64948431ad9aa9fa),
W64LIT(0x2ab4e866fc7ceb41),
W64LIT(0xe6ef263a4be3044a),
W64LIT(0xe734adcf4d0e16b2),
W64LIT(0x903f8dec8adb5c9d),
W64LIT(0xf02d3ae33f1fbd6d),
W64LIT(0x725698e8d96610dd),
W64LIT(0x1da3124f4e821fce),
W64LIT(0x1719972c7211abdf),
W64LIT(0x11dc470d6660c7d0),
W64LIT(0xec55a3597770b05b),
W64LIT(0xbfd6dd416814ed2e),
W64LIT(0x57054d26073a157f),
W64LIT(0x1e3b7aa544402933),
W64LIT(0x5ffc2b5a3786856b),
W64LIT(0x61c93cfab329f308),
W64LIT(0x3e3517a084af7663),
W64LIT(0xf6e8eac22b6ed162),
W64LIT(0x1007ccf8608dd528),
W64LIT(0x66d7672ea1b58dff),
W64LIT(0x8b594f82d0282f5c),
W64LIT(0x1fe0f15042ad3bcb),
W64LIT(0x4b7dd49c4f551849),
W64LIT(0x4c638f485dc966be),
W64LIT(0xcfc3a6b6bd5dd9f6),
W64LIT(0x46d90a2b615ad2af),
W64LIT(0x8565f9dff4e5d347),
W64LIT(0x94b9bed292851497),
W64LIT(0xfa97bf80038c097c),
W64LIT(0xb9130d607c658121),
W64LIT(0xdc5c02a4d7123a23),
W64LIT(0x224d8e1accc07b55),
W64LIT(0x87261ac0f8caf742),
W64LIT(0xd901ba6fc9a160d1),
W64LIT(0xab57228710c7700c),
W64LIT(0x21d5e6f0c6024da8),
W64LIT(0x98c6eb90ba67cc89),
W64LIT(0x827ba20be679adb0),
W64LIT(0x991d6065bc8ade71),
W64LIT(0x5546ae390b15317a),
W64LIT(0xa56b94da340a8c17),
W64LIT(0x071e5bd4129c7ef7),
W64LIT(0xe02af61b5f926845),
W64LIT(0x6b73b9998fba4719),
W64LIT(0xdfc46a4eddd00cde),
W64LIT(0x770b2023c7d54a2f),
W64LIT(0x7e29cdaaf184c8c3),
W64LIT(0xba8b658a76a7b7dc),
W64LIT(0x9c40d8aea2398483),
W64LIT(0x9fd8b044a8fbb27e),
W64LIT(0xdb425970c58e44d4),
W64LIT(0xe269150453bd4c40),
W64LIT(0x3c76f4bf88805266),
W64LIT(0xf1f6b11639f2af95),
W64LIT(0x549d25cc0df82382),
W64LIT(0x4db804bd5b247446),
W64LIT(0x8a82c477d6c53da4),
W64LIT(0x5258f5ed19894f8d),
W64LIT(0x6e2e015291091deb),
W64LIT(0xc1ff10eb999025ed),
W64LIT(0xbd953e5e643bc92b),
W64LIT(0xc8ddfd62afc1a701),
W64LIT(0x5c6443b03d44b396),
W64LIT(0x6c6de24d9d2639ee),
W64LIT(0x1481ffc678d39d22),
W64LIT(0xd1f8dc13f91df0c5),
W64LIT(0xca9e1e7da3ee8304),
W64LIT(0xdd878951d1ff28db),
W64LIT(0x6012b70fb5c4e1f0),
W64LIT(0x1b66c26e5af373c1),
W64LIT(0xe3b29ef155505eb8),
W64LIT(0x70157bf7d54934d8),
W64LIT(0x2e32db58e422a34b),
W64LIT(0x6aa8326c895755e1),
W64LIT(0xb6f430c85e456fc2),
W64LIT(0xfd89e4541110778b),
W64LIT(0x88c12768daea19a1),
W64LIT(0xcd8045a9b172fdf3),
/* box 3 */
W64LIT(0x99183e616655b742),
W64LIT(0xb2872032a50d6860),
W64LIT(0x0946f63b060528ef),
W64LIT(0x36612b9a141ef07d),
W64LIT(0x0634da84dd49579b),
W64LIT(0xfc9c9e9b486c8a57),
W64LIT(0xa63fe3c0744e6fd0),
W64LIT(0xf1515758d8b46bf9),
W64LIT(0x3e82559fcd5197ff),
W64LIT(0x92e12d262bc40177),
W64LIT(0xc3bb433a5a7752c5),
W64LIT(0x21c3852a5183267a),
W64LIT(0x39130725cf528f09),
W64LIT(0x9ba7db1d2dc12998),
W64LIT(0xc58f99be873e055e),
W64LIT(0xd9d424498f32656c),
W64LIT(0x27f75fae8cca71e1),
W64LIT(0x59b91019a8fc3430),
W64LIT(0xce768af9caafb36b),
W64LIT(0x9d930199f0887e03),
W64LIT(0x63b07a7ef3706a8e),
W64LIT(0xb5167288a70e7096),
W64LIT(0x40cc1a28e967d22e),
W64LIT(0x4d01d3eb79bf3380),
W64LIT(0x9e896cdb6456afb4),
W64LIT(0x2548bad2c75eef3b),
W64LIT(0xa79a6bfeab0420bd),
W64LIT(0x9f2ce4e5bb1ce0d9),
W64LIT(0x32ea146282c3393c),
W64LIT(0x6d67defff7765a97),
W64LIT(0x83775912b31080eb),
W64LIT(0xf5da68a04e69a2b8),
W64LIT(0x1196743498d4819c),
W64LIT(0x0bf913474d91b635),
W64LIT(0x43d6776a7db90399),
W64LIT(0x444725d07fba1b6f),
W64LIT(0x6584a0fa2e393d15),
W64LIT(0x3f27dda1121bd892),
W64LIT(0xf6c005e2dab7730f),
W64LIT(0x56cb3ca673b04b44),
W64LIT(0x642128c4f1737278),
W64LIT(0xbf4ae9f135d589ce),
W64LIT(0xb038c54eee99f6ba),
W64LIT(0xf47fe09e9123edd5),
W64LIT(0x75b75cf069a7f3e4),
W64LIT(0xd419ed8a1fea84c2),
W64LIT(0x73838674b4eea47f),
W64LIT(0x498aec13ef62fac1),
W64LIT(0x20660d148ec96917),
W64LIT(0xa48006bc3fdaf10a),
W64LIT(0x2f1421ab55851663),
W64LIT(0x0a5c9b7992dbf958),
W64LIT(0xd1375a4c567d02ee),
W64LIT(0x0000000000000000),
W64LIT(0xc842507d17e6e4f0),
W64LIT(0xf3eeb2249320f523),
W64LIT(0xc9e7d843c8acab9d),
W64LIT(0xff86f3d9dcb25be0),
W64LIT(0xb4b3fab678443ffb),
W64LIT(0xb19d4d7031d3b9d7),
W64LIT(0x79df1d0d26355d27),
W64LIT(0x8eba90d123c86145),
W64LIT(0xaa57a23d3bdcc113),
W64LIT(0xcb583d3f83383547),
W64LIT(0xd871ac7750782a01),
W64LIT(0xe162ab529f2aa508),
W64LIT(0x38b68f1b1018c064),
W64LIT(0x237c60561a17b8a0),
W64LIT(0xa31154063dd9e9fc),
W64LIT(0x713c6308ff7a3aa5),
W64LIT(0x1a6f6773d54537a9),
W64LIT(0x08e37e05d94f6782),
W64LIT(0x357b46d880c021ca),
W64LIT(0x6cc256c1283c15fa),
W64LIT(0xcfd302c715e5fc06),
W64LIT(0xbdf50c8d7e411714),
W64LIT(0x7cf1aacb6fa2db0b),
W64LIT(0x5240035ee56d8205),
W64LIT(0x7b60f8716da1c3fd),
W64LIT(0x01a5883edf4a4f6d),
W64LIT(0xdd5f1bb119efac2d),
W64LIT(0x5474d9da3824d59e),
W64LIT(0x0f722cbfdb4c7f74),
W64LIT(0x17a2aeb0459dd607),
W64LIT(0x37c4a3a4cb54bf10),
W64LIT(0xc21ecb04853d1da8),
W64LIT(0x4273ff54a2f34cf4),
W64LIT(0xdace490b1becb4db),
W64LIT(0x6af68c45f5754261),
W64LIT(0x46f8c0ac342e85b5),
W64LIT(0x854383966e59d770),
W64LIT(0x81c8bc6ef8841e31),
W64LIT(0x3bace25984c611d3),
W64LIT(0x1033fc0a479ecef1),
W64LIT(0x1c5bbdf7080c6032),
W64LIT(0x7412d4ceb6edbc89),
W64LIT(0xa8e8474170485fc9),
W64LIT(0xb8dbbb4b37d69138),
W64LIT(0x079152ba020318f6),
W64LIT(0x72260e4a6ba4eb12),
W64LIT(0x905ec85a60509fad),
W64LIT(0x2dabc4d71e1188b9),
W64LIT(0xd092d27289374d83),
W64LIT(0x610f9f02b8e4f454),
W64LIT(0x02bfe57c4b949eda),
W64LIT(0x95707f9c29c71981),
W64LIT(0x6fd83b83bce2c44d),
W64LIT(0x5d322fe13e21fd71),
W64LIT(0x34decee65f8a6ea7),
W64LIT(0xcd6ce7bb5e7162dc),
W64LIT(0xfb0dcc214a6f92a1),
W64LIT(0x2eb1a9958acf590e),
W64LIT(0xdcfa938fc6a5e340),
W64LIT(0x669ecdb8bae7eca2),
W64LIT(0x151d4bcc0e0948dd),
W64LIT(0xfd3916a59726c53a),
W64LIT(0x581c982777b67b5d),
W64LIT(0x1bcaef4d0a0f78c4),
W64LIT(0xdfe0fecd527b32f7),
W64LIT(0x128c19760c0a502b),
W64LIT(0x84e60ba8b113981d),
W64LIT(0x3c3db0e386c50925),
W64LIT(0x7febc789fb7c0abc),
W64LIT(0x7d5422f5b0e89466),
W64LIT(0xd70380c88b345575),
W64LIT(0xbbc1d609a308408f),
W64LIT(0xe278c6100bf474bf),
W64LIT(0x5e2842a3aaff2cc6),
W64LIT(0x6b53047b2a3f0d0c),
W64LIT(0xf7658ddc05fd3c62),
W64LIT(0x9a025323f28b66f5),
W64LIT(0x8c0575ad685cff9f),
W64LIT(0x76ad31b2fd792253),
W64LIT(0x68496939bee1dcbb),
W64LIT(0x7e4e4fb7243645d1),
W64LIT(0xe44c1c94d6bd2324),
W64LIT(0xbeef61cfea9fc6a3),
W64LIT(0x91fb4064bf1ad0c0),
W64LIT(0x052eb7c64997862c),
W64LIT(0x4a9081517bbc2b76),
W64LIT(0x8f1f18effc822e28),
W64LIT(0x3a096a675b8c5ebe),
W64LIT(0xee1087ed4466da7c),
W64LIT(0x2652d79053803e8c),
W64LIT(0x7099eb36203075c8),
W64LIT(0xc7307cc2ccaa9b84),
W64LIT(0x5c97a7dfe16bb21c),
W64LIT(0x50ffe622aef91cdf),
W64LIT(0x8da0fd93b716b0f2),
W64LIT(0x69ece10761ab93d6),
W64LIT(0x31f07920161de88b),
W64LIT(0x13299148d3401f46),
W64LIT(0x031a6d4294ded1b7),
W64LIT(0xccc96f85813b2db1),
W64LIT(0x14b8c3f2d14307b0),
W64LIT(0x8659eed4fa8706c7),
W64LIT(0xba645e377c420fe2),
W64LIT(0x2920fb2f88cc41f8),
W64LIT(0x87fc66ea25cd49aa),
W64LIT(0x1ee4588b4398fee8),
W64LIT(0xecaf62910ff244a6),
W64LIT(0xf817a163deb14316),
W64LIT(0x45e2adeea0f05402),
W64LIT(0x806d345027ce515c),
W64LIT(0x576eb498acfa0429),
W64LIT(0xa5258e82e090be67),
W64LIT(0x892bc26b21cb79b3),
W64LIT(0x6e7db3bd63a88b20),
W64LIT(0x4e1bbea9ed61e237),
W64LIT(0xadc6f08739dfd9e5),
W64LIT(0x8b9427176a5fe769),
W64LIT(0xa1aeb17a764d7726),
W64LIT(0x4b35096fa4f6641b),
W64LIT(0x22d9e868c55df7cd),
W64LIT(0x55d151e4e76e9af3),
W64LIT(0x966a12debd19c836),
W64LIT(0x0dcdc9c390d8e1ae),
W64LIT(0xf24b3a1a4c6aba4e),
W64LIT(0x24ed32ec1814a056),
W64LIT(0xaf7915fb724b473f),
W64LIT(0x2885731157860e95),
W64LIT(0x9c3689a72fc2316e),
W64LIT(0x475d4892eb64cad8),
W64LIT(0xac6378b9e6959688),
W64LIT(0xa00b3944a907384b),
W64LIT(0xc695f4fc13e0d4e9),
W64LIT(0x3055f11ec957a7e6),
W64LIT(0x6215f2402c3a25e3),
W64LIT(0xde4576f38d317d9a),
W64LIT(0x9344a518f48e4e1a),
W64LIT(0x82d2d12c6c5acf86),
W64LIT(0xefb50fd39b2c9511),
W64LIT(0xe981d5574665c28a),
W64LIT(0x5f8dca9d75b563ab),
W64LIT(0xb60c1fca33d0a121),
W64LIT(0xfe237be703f8148d),
W64LIT(0xd6a608f6547e1a18),
W64LIT(0xb97e3375e89cde55),
W64LIT(0xd388bf301de99c34),
W64LIT(0x5b06f565e368aaea),
W64LIT(0xf0f4df6607fe2494),
W64LIT(0x1607268e9ad7996a),
W64LIT(0xaedc9dc5ad010852),
W64LIT(0xe0c7236c4060ea65),
W64LIT(0xea9bb815d2bb133d),
W64LIT(0x888e4a55fe8136de),
W64LIT(0x5aa37d5b3c22e587),
W64LIT(0xc104a64611e3cc1f),
W64LIT(0x515a6e1c71b353b2),
W64LIT(0xc42a118058744a33),
W64LIT(0x7708b98c22336d3e),
W64LIT(0x2a3a966d1c12904f),
W64LIT(0x8a31af29b515a804),
W64LIT(0xed0aeaafd0b80bcb),
W64LIT(0x2c0e4ce9c15bc7d4),
W64LIT(0x0c6841fd4f92aec3),
W64LIT(0x98bdb65fb91ff82f),
W64LIT(0x1f41d0b59cd2b185),
W64LIT(0xb322a80c7a47270d),
W64LIT(0xe6f3f9e89d29bdfe),
W64LIT(0x7ac5704fb2eb8c90),
W64LIT(0xa94dcf7faf0210a4),
W64LIT(0x787a9533f97f124a),
W64LIT(0xdb6bc135c4a6fbb6),
W64LIT(0x048b3ff896ddc941),
W64LIT(0xe8245d69992f8de7),
W64LIT(0xe3dd4e2ed4be3bd2),
W64LIT(0xcafdb5015c727a2a),
W64LIT(0xb7a997f4ec9aee4c),
W64LIT(0xe75671d64263f293),
W64LIT(0x2b9f1e53c358df22),
W64LIT(0x18d0820f9ed1a973),
W64LIT(0xabf22a03e4968e7e),
W64LIT(0xa2b4dc38e293a691),
W64LIT(0x673b458665ada3cf),
W64LIT(0xf9b2295d01fb0c7b),
W64LIT(0xd22d370ec2a3d359),
W64LIT(0x97cf9ae06253875b),
W64LIT(0x0ed7a48104063019),
W64LIT(0x482f642d3028b5ac),
W64LIT(0xc0a12e78cea98372),
W64LIT(0x4fbe3697322bad5a),
W64LIT(0x19750a31419be61e),
W64LIT(0x41699216362d9d43),
W64LIT(0xd5bc65b4c0a0cbaf),
W64LIT(0xe5e994aa09f76c49),
W64LIT(0xeb3e302b0df15c50),
W64LIT(0x94d5f7a2f68d56ec),
W64LIT(0x53e58b603a27cd68),
W64LIT(0x3d9838dd598f4648),
W64LIT(0x60aa173c67aebb39),
W64LIT(0x1dfe35c9d7462f5f),
W64LIT(0x4ca45bd5a6f57ced),
W64LIT(0xbc5084b3a10b5879),
W64LIT(0xfaa8441f9525ddcc),
W64LIT(0x334f9c5c5d897651),
/* box 4 */
W64LIT(0xda1687a883adf27e),
W64LIT(0xe35c9378578d9f22),
W64LIT(0x303ca4531637fa40),
W64LIT(0xa088321f74b20375),
W64LIT(0xc9863f3a9acb95e9),
W64LIT(0x5fcf47c57d0b0ed4),
W64LIT(0x4aa211e4e1280b4b),
W64LIT(0xe1a4c9ba871d1289),
W64LIT(0x4926664759f03a4f),
W64LIT(0xadfb36ede3707bca),
W64LIT(0xcf7bd1891f8ef7e1),
W64LIT(0x9735559e8f882792),
W64LIT(0x5932a976f84e6cdc),
W64LIT(0x9dc792bef547818a),
W64LIT(0x06fdeeb385456208),
W64LIT(0x46ad38771ea2cf5b),
W64LIT(0x5eb36aa41543b27b),
W64LIT(0x8b2eb33cd1bcb511),
W64LIT(0x71105ff6e598ebbc),
W64LIT(0x5441ad846f8c1463),
W64LIT(0x4c5fff57646d6943),
W64LIT(0xf3485c49f633c9b1),
W64LIT(0x9cbbbfdf9d0f3d25),
W64LIT(0x22d031a067192178),
W64LIT(0xca0248992213a4ed),
W64LIT(0x19627fb263a9c18f),
W64LIT(0x9330e1efda5dc831),
W64LIT(0x1390b89219666797),
W64LIT(0x2edf18339893e568),
W64LIT(0x6c779435d3e4c590),
W64LIT(0x53c06e568281cac4),
W64LIT(0x6ff3e3966b3cf494),
W64LIT(0xfe3b58bb61f1b10e),
W64LIT(0x77edb14560dd89b4),
W64LIT(0x02f85ac2d0908dab),
W64LIT(0x12ec95f3712edb38),
W64LIT(0x85d9c06dfea6fcaa),
W64LIT(0x90b4964c6285f935),
W64LIT(0xf1b0068b26a3441a),
W64LIT(0x729428555d40dab8),
W64LIT(0x5c4b3066c5d33fd0),
W64LIT(0x5d371d07ad9b837f),
W64LIT(0xa48d866e2167ecd6),
W64LIT(0xb661139d504937ee),
W64LIT(0xa27068dda4228ede),
W64LIT(0xf8c6b608e4b4d306),
W64LIT(0x6bf657e73ee91b37),
W64LIT(0xac871b8c8b38c765),
W64LIT(0x4ea7a595b4fde4e8),
W64LIT(0x0d7304f297c278bf),
W64LIT(0xb71d3efc38018b41),
W64LIT(0xae7f414e5ba84ace),
W64LIT(0xaf036c2f33e0f661),
W64LIT(0x0000000000000000),
W64LIT(0xb89660cc7f537e55),
W64LIT(0xa675dcacf1f7617d),
W64LIT(0x610490c74426bd2f),
W64LIT(0xc18ca2d83094be5a),
W64LIT(0x2adaac42cd460acb),
W64LIT(0x7d1f76651a122fac),
W64LIT(0xc58916a9654151f9),
W64LIT(0xedabe0297897d699),
W64LIT(0x2d5b6f90204bd46c),
W64LIT(0x26d585d132cccedb),
W64LIT(0x9f3fc87c25d70c21),
W64LIT(0xc60d610add9960fd),
W64LIT(0x80a0597dc33bafa6),
W64LIT(0xd0e44088f9625466),
W64LIT(0x1d67cbc3367c2e2c),
W64LIT(0x2c2742f1480368c3),
W64LIT(0x89d6e9fe012c38ba),
W64LIT(0xe9ae54582d42393a),
W64LIT(0x3ecbd702392db3fb),
W64LIT(0xb5e5643ee89106ea),
W64LIT(0xa882affddeed28c6),
W64LIT(0x1ae60811db71f08b),
W64LIT(0x924ccc8eb215749e),
W64LIT(0xfcc30279b1613ca5),
W64LIT(0x825803bf13ab220d),
W64LIT(0xd992f00b3b75c37a),
W64LIT(0xc8fa125bf2832946),
W64LIT(0x35453d432baaa94c),
W64LIT(0xf9ba9b698cfc6fa9),
W64LIT(0x37bd6781fb3a24e7),
W64LIT(0x791ac2144fc7c00f),
W64LIT(0x16e9218224fb349b),
W64LIT(0xdb6aaac9ebe54ed1),
W64LIT(0xd8eedd6a533d7fd5),
W64LIT(0x7c635b04725a9303),
W64LIT(0x553d80e507c4a8cc),
W64LIT(0x9a46516c184a5f2d),
W64LIT(0x14117b40f46bb930),
W64LIT(0x1ee3bc608ea41f28),
W64LIT(0x27a9a8b05a847274),
W64LIT(0x4050d6c49be7ad53),
W64LIT(0x7be298d69f574da4),
W64LIT(0x6a8a7a8656a1a798),
W64LIT(0x4d23d2360c25d5ec),
W64LIT(0x1014cf31a1be5693),
W64LIT(0xb264a7ec059cd84d),
W64LIT(0xea2a23fb959a083e),
W64LIT(0xf0cc2bea4eebf8b5),
W64LIT(0x76919c240895351b),
W64LIT(0x0b8eea4112871ab7),
W64LIT(0x47d1151676ea73f4),
W64LIT(0xbdeff9dc42ce2d59),
W64LIT(0x2ba68123a50eb664),
W64LIT(0x057999103d9d530c),
W64LIT(0xe759270902587081),
W64LIT(0xef53baeba8075b32),
W64LIT(0x4fdb88f4dcb55847),
W64LIT(0x6e8fcef70374483b),
W64LIT(0x1168e250c9f6ea3c),
W64LIT(0x1b9a2570b3394c24),
W64LIT(0x706c72978dd05713),
W64LIT(0x865db7ce467ecdae),
W64LIT(0x52bc4337eac9766b),
W64LIT(0x504419f53a59fbc0),
W64LIT(0x8f2b074d84695ab2),
W64LIT(0x6078bda62c6e0180),
W64LIT(0x43d4a167233f9c57),
W64LIT(0x0ef773512f1a49bb),
W64LIT(0x0c0f2993ff8ac410),
W64LIT(0x4bde3c858960b7e4),
W64LIT(0x66855315a92b6388),
W64LIT(0xd360372b41ba6562),
W64LIT(0x584e84179006d073),
W64LIT(0x9b3a7c0d7002e382),
W64LIT(0xa5f1ab0f492f5079),
W64LIT(0x2822f6801dd68760),
W64LIT(0x445562b5ce3242f0),
W64LIT(0xaa7af53f0e7da56d),
W64LIT(0x3c338dc0e9bd3e50),
W64LIT(0x3bb24e1204b0e0f7),
W64LIT(0xd59dd998c4ff076a),
W64LIT(0x91c8bb2d0acd459a),
W64LIT(0x84a5ed0c96ee4005),
W64LIT(0x33b8d3f0aeefcb44),
W64LIT(0x57c5da27d7542567),
W64LIT(0x32c4fe91c6a777eb),
W64LIT(0x3439102243e215e3),
W64LIT(0xc7714c6bb5d1dc52),
W64LIT(0x3fb7fa6351650f54),
W64LIT(0x87219aaf2e367101),
W64LIT(0xf5b5b2fa7376abb9),
W64LIT(0x412cfba5f3af11fc),
W64LIT(0xdceb691b06e89076),
W64LIT(0xbb12176fc78b4f51),
W64LIT(0x73e8053435086617),
W64LIT(0xe220be193fc5238d),
W64LIT(0xb09cfd2ed50c55e6),
W64LIT(0xb9ea4dad171bc2fa),
W64LIT(0x9e43e51d4d9fb08e),
W64LIT(0x36c14ae093729848),
W64LIT(0xa9fe829cb6a59469),
W64LIT(0x0405b47155d5efa3),
W64LIT(0x0af2c7207acfa618),
W64LIT(0x7e9b01c6a2ca1ea8),
W64LIT(0xdd97447a6ea02cd9),
W64LIT(0x0781c3d2ed0ddea7),
W64LIT(0x7866ef75278f7ca0),
W64LIT(0xd1986de9912ae8c9),
W64LIT(0xcb7e65f84a5b1842),
W64LIT(0xcd838b4bcf1e7a4a),
W64LIT(0xab06d85e663519c2),
W64LIT(0xd4e1f4f9acb7bbc5),
W64LIT(0xfdbf2f18d929800a),
W64LIT(0xf23471289e7b751e),
W64LIT(0xbc93d4bd2a8691f6),
W64LIT(0x3d4fa0a181f582ff),
W64LIT(0xba6e3a0eafc3f3fe),
W64LIT(0x5ab6ded540965dd8),
W64LIT(0xeb560e9afdd2b491),
W64LIT(0x0976b083c217971c),
W64LIT(0xecd7cd4810df6a36),
W64LIT(0x23ac1cc10f519dd7),
W64LIT(0xbe6b8e7ffa161c5d),
W64LIT(0x7fe72ca7ca82a207),
W64LIT(0xc0f08fb958dc02f5),
W64LIT(0x7a9eb5b7f71ff10b),
W64LIT(0xa709f1cd99bfddd2),
W64LIT(0x8dd35d8f54f9d719),
W64LIT(0x8caf70ee3cb16bb6),
W64LIT(0xe4dd50aaba804185),
W64LIT(0x83242ede7be39ea2),
W64LIT(0x98be0baec8dad286),
W64LIT(0x690e0d25ee79969c),
W64LIT(0x95cd0f5c5f18aa39),
W64LIT(0x56b9f746bf1c99c8),
W64LIT(0x7469c6e6d805b8b0),
W64LIT(0x8a529e5db9f409be),
W64LIT(0xe6250a686a10cc2e),
W64LIT(0x2fa33552f0db59c7),
W64LIT(0x42a88c064b7720f8),
W64LIT(0x6d0bb954bbac793f),
W64LIT(0x181e52d30be17d20),
W64LIT(0xbf17a31e925ea0f2),
W64LIT(0x94b1223d37501696),
W64LIT(0xe8d27939450a8595),
W64LIT(0xccffa62aa756c6e5),
W64LIT(0x383639b1bc68d1f3),
W64LIT(0xee2f978ac04fe79d),
W64LIT(0xa30c45bccc6a3271),
W64LIT(0x1f9f9101e6eca387),
W64LIT(0xb1e0d04fbd44e949),
W64LIT(0x242ddf13e25c4370),
W64LIT(0x156d56219c23059f),
W64LIT(0x88aac49f69648415),
W64LIT(0x6280e764fcfe8c2b),
W64LIT(0xdf6f1eb8be30a172),
W64LIT(0xe5a17dcbd2c8fd2a),
W64LIT(0xe0d8e4dbef55ae26),
W64LIT(0x63fcca0594b63084),
W64LIT(0xa1f41f7e1cfabfda),
W64LIT(0x295edbe1759e3bcf),
W64LIT(0x67f97e74c163df27),
W64LIT(0x038477a3b8d83104),
W64LIT(0xde1333d9d6781ddd),
W64LIT(0x3ace63736cf85c58),
W64LIT(0xd619ae3b7c27366e),
W64LIT(0x5bcaf3b428dee177),
W64LIT(0xb3188a8d6dd464e2),
W64LIT(0x1c1be6a25e349283),
W64LIT(0x017c2d616848bcaf),
W64LIT(0x8e572a2cec21e61d),
W64LIT(0xf631c559cbae9abd),
W64LIT(0x81dc741cab731309),
W64LIT(0xff4775da09b90da1),
W64LIT(0xb499495f80d9ba45),
W64LIT(0x0f8b5e304752f514),
W64LIT(0x394a14d0d4206d5c),
W64LIT(0xce07fce877c64b4e),
W64LIT(0xf4c99f9b1b3e1716),
W64LIT(0xc4f53bc80d09ed56),
W64LIT(0xc208d57b884c8f5e),
W64LIT(0x080a9de2aa5f2bb3),
W64LIT(0x314089327e7f46ef),
W64LIT(0xfa3eecca34245ead),
W64LIT(0x20286b62b789acd3),
W64LIT(0x7515eb87b04d041f),
W64LIT(0x513834945211476f),
W64LIT(0x650124b611f3528c),
W64LIT(0x17950ce34cb38834),
W64LIT(0x45294fd4a67afe5f),
W64LIT(0x21544603dfc1107c),
W64LIT(0x485a4b2631b886e0),
W64LIT(0x6872204486312a33),
W64LIT(0x647d09d779bbee23),
W64LIT(0x2551f2728a14ffdf),
W64LIT(0xd765835a146f8ac1),
W64LIT(0xd21c1a4a29f2d9cd),
W64LIT(0x99c226cfa0926e29),
W64LIT(0xfb42c1ab5c6ce202),
W64LIT(0xc374f81ae00433f1),
W64LIT(0x964978ffe7c09b3d),
W64LIT(0xf74de838a3e62612),
/* box 5 */
W64LIT(0x74b87b36b0592c6a),
W64LIT(0x3d82d75dffb4b81c),
W64LIT(0x8884246715267825),
W64LIT(0xdaf2d8a77ed4e5de),
W64LIT(0xfeb118650e53f9c7),
W64LIT(0xbd2d1aea59226b06),
W64LIT(0x26ce87f6dbabb191),
W64LIT(0x32772ecbeb66bd0a),
W64LIT(0xd4bbf82bc5104c8c),
W64LIT(0x055357720c4e03a1),
W64LIT(0xef5be62a32d0f6fd),
W64LIT(0xbe1c84c45d186aca),
W64LIT(0xacc7e4a565a1643c),
W64LIT(0x8dd7731519687b84),
W64LIT(0x11eafe4f3c830f3a),
W64LIT(0x04ef8e68a358afe5),
W64LIT(0x40ad9ca1534b930d),
W64LIT(0xe44191d4855a5c0e),
W64LIT(0x6001d20b809420f1),
W64LIT(0x73666b70173b8243),
W64LIT(0x372479b9e728beab),
W64LIT(0x45fecbd35f0590ac),
W64LIT(0x7057f55e1301838f),
W64LIT(0xff0dc17fa1455583),
W64LIT(0x0cc467b810e804da),
W64LIT(0xb9c29482fa7ac4e3),
W64LIT(0xa003831d754960e6),
W64LIT(0x8a096353be0ad5ad),
W64LIT(0xdd2cc8e1d9b64bf7),
W64LIT(0xc7dc415052bfee3e),
W64LIT(0x9f0c137421d17572),
W64LIT(0x35a93e8d4c041323),
W64LIT(0x9a5f44062d9f76d3),
W64LIT(0x71eb2c44bc172fcb),
W64LIT(0x0ff5f99614d20516),
W64LIT(0x7789e518b4632da6),
W64LIT(0xc99561dce97b476c),
W64LIT(0x5276fcc06bf29dfb),
W64LIT(0x4a0b32454bd795ba),
W64LIT(0x9274add69e2fddec),
W64LIT(0x4f5865374799961b),
W64LIT(0xb2d8e37c4df06e10),
W64LIT(0xc4eddf7e5685eff2),
W64LIT(0xb3643a66e2e6c254),
W64LIT(0xd50721316a06e0c8),
W64LIT(0x8bb5ba49111c79e9),
W64LIT(0x2bb639546455190f),
W64LIT(0xf8d3d1390627fbaa),
W64LIT(0x38d1802ff3fabbbd),
W64LIT(0xdfa18fd5729ae67f),
W64LIT(0x4ee4bc2de88f3a5f),
W64LIT(0xf72628af12f5febc),
W64LIT(0x0aa6aee4189c06b7),
W64LIT(0x0000000000000000),
W64LIT(0x9eb0ca6e8ec7d936),
W64LIT(0xcb1826e84257eae4),
W64LIT(0x187dce8520250841),
W64LIT(0xc28f16225ef1ed9f),
W64LIT(0xc333cf38f1e741db),
W64LIT(0x4220db95f8673e85),
W64LIT(0xdc9011fb76a0e7b3),
W64LIT(0x105627559395a37e),
W64LIT(0x2f59b73cc70db6ea),
W64LIT(0xe112c6a689145faf),
W64LIT(0x82228a830dba7e92),
W64LIT(0x2ee56e26681b1aae),
W64LIT(0x2a0ae04ecb43b54b),
W64LIT(0x47738ce7f4293d24),
W64LIT(0xa7dd935bd22bcecf),
W64LIT(0xd2d93177cd644ee1),
W64LIT(0xebb4684291885918),
W64LIT(0x0e49208cbbc4a952),
W64LIT(0xa550d46f79076347),
W64LIT(0x411145bbfc5d3f49),
W64LIT(0xe6ccd6e02e76f186),
W64LIT(0x4bb7eb5fe4c139fe),
W64LIT(0x5d8305567f2098ed),
W64LIT(0x95aabd90394d73c5),
W64LIT(0x25ff19d8df91b05d),
W64LIT(0x86cd04ebaee2d177),
W64LIT(0x03319e2e043a01cc),
W64LIT(0x6b1ba5f5371e8a02),
W64LIT(0x76353c021b7581e2),
W64LIT(0x64ee5c6323cc8f14),
W64LIT(0x5c3fdc4cd03634a9),
W64LIT(0x6996e2c19c32278a),
W64LIT(0x8938fd7dba30d461),
W64LIT(0x7b4d82a0a48b297c),
W64LIT(0xbfa05ddef20ec68e),
W64LIT(0x8ee6ed3b1d527a48),
W64LIT(0x61bd0b112f828cb5),
W64LIT(0x66631b5788e0229c),
W64LIT(0x55a8ec86cc9033d2),
W64LIT(0x1c9240ed837da7a4),
W64LIT(0x150570279fdba0df),
W64LIT(0x53ca25dac4e431bf),
W64LIT(0xd636bf1f6e3ce104),
W64LIT(0xcaa4fff2ed4146a0),
W64LIT(0x787c1c8ea0b128b0),
W64LIT(0xad7b3dbfcab7c878),
W64LIT(0xfc3c5f51a57f544f),
W64LIT(0xb78bb40e41be6db1),
W64LIT(0x8c6baa0fb67ed7c0),
W64LIT(0xce4b719a4e19e945),
W64LIT(0xf96f0823a93157ee),
W64LIT(0x7d2f4bfcacff2b11),
W64LIT(0x3eb34973fb8eb9d0),
W64LIT(0xe39f81922238f227),
W64LIT(0x239dd084d7e5b230),
W64LIT(0x1fa3dec38747a668),
W64LIT(0xc5510664f99343b6),
W64LIT(0xc829b8c6466deb28),
W64LIT(0x85fc9ac5aad8d0bb),
W64LIT(0xb6376d14eea8c1f5),
W64LIT(0x9d8154408afdd8fa),
W64LIT(0x3be01e01f7c0ba71),
W64LIT(0x628c953f2bb88d79),
W64LIT(0x6d796ca93f6a886f),
W64LIT(0xfa5e960dad0b5622),
W64LIT(0xe5fd48ce2a4cf04a),
W64LIT(0xe7700ffa81605dc2),
W64LIT(0x2dd4f0086c211b62),
W64LIT(0x2221099e78f31e74),
W64LIT(0xdb4e01bdd1c2499a),
W64LIT(0xf417b68116cfff70),
W64LIT(0xb506f33aea92c039),
W64LIT(0x514762ee6fc89c37),
W64LIT(0x9c3d8d5a25eb74be),
W64LIT(0x396d59355cec17f9),
W64LIT(0xccc636aee53544cd),
W64LIT(0x0b1a77feb78aaaf3),
W64LIT(0xe9392f763aa4f490),
W64LIT(0xaaa52df96dd56651),
W64LIT(0x46cf55fd5b3f9160),
W64LIT(0xa4ec0d75d611cf03),
W64LIT(0xaff67a8b619b65f0),
W64LIT(0x3415e797e312bf67),
W64LIT(0x7af15bba0b9d8538),
W64LIT(0x811314ad09807f5e),
W64LIT(0x8771ddf101f47d33),
W64LIT(0x969b23be3d777209),
W64LIT(0xd365e86d6272e2a5),
W64LIT(0x58d05224736e9b4c),
W64LIT(0xc660984afda9427a),
W64LIT(0x5414359c63869f96),
W64LIT(0xe885f66c95b258d4),
W64LIT(0x655285798cda2350),
W64LIT(0x6cc5b5b3907c242b),
W64LIT(0x6ff42b9d944625e7),
W64LIT(0xc0025116f5dd4017),
W64LIT(0xa28ec429de65cd6e),
W64LIT(0x63304c2584ae213d),
W64LIT(0x7fa20cc807d38699),
W64LIT(0x996eda2829a5771f),
W64LIT(0x1b4c50ab241f098d),
W64LIT(0x1e1f07d928510a2c),
W64LIT(0x33cbf7d14470114e),
W64LIT(0xb055a448e6dcc398),
W64LIT(0x98d2033286b3db5b),
W64LIT(0xec6a780436eaf731),
W64LIT(0xa1bf5a07da5fcca2),
W64LIT(0xbaf30aacfe40c52f),
W64LIT(0xf144e1f31a81fcd1),
W64LIT(0xe0ae1fbc2602f3eb),
W64LIT(0x14b9a93d30cd0c9b),
W64LIT(0x596c8b3edc783708),
W64LIT(0x682a3bdb33248bce),
W64LIT(0xb87e4d98556c68a7),
W64LIT(0x80afcdb7a696d31a),
W64LIT(0x5725abb267bc9e5a),
W64LIT(0x914533f89a15dc20),
W64LIT(0x5eb29b787b1a9921),
W64LIT(0x01bcd91aaf16ac44),
W64LIT(0xc1be880c5acbec53),
W64LIT(0xedd6a11e99fc5b75),
W64LIT(0x028d4734ab2cad88),
W64LIT(0x8f5a3421b244d60c),
W64LIT(0x4dd52203ecb53b93),
W64LIT(0x3f0f906954981594),
W64LIT(0xae4aa391ce8dc9b4),
W64LIT(0x3698a0a3483e12ef),
W64LIT(0xf5ab6f9bb9d95334),
W64LIT(0x082be9d0b3b0ab3f),
W64LIT(0xd1e8af59c95e4f2d),
W64LIT(0xd87f9f93d5f84856),
W64LIT(0x6e48f2873b5089a3),
W64LIT(0x2443c0c270871c19),
W64LIT(0xb1e97d5249ca6fdc),
W64LIT(0x7c9392e603e98755),
W64LIT(0x839e5399a2acd2d6),
W64LIT(0x19c1179f8f33a405),
W64LIT(0xde1d56cfdd8c4a3b),
W64LIT(0x20ac4eaad3dfb3fc),
W64LIT(0x1af089b18b09a5c9),
W64LIT(0x3a5cc71b58d61635),
W64LIT(0x444212c9f0133ce8),
W64LIT(0x72dab26ab82d2e07),
W64LIT(0x4c69fb1943a397d7),
W64LIT(0xf3c9a6c7b1ad5159),
W64LIT(0x1d2e99f72c6b0be0),
W64LIT(0xb4ba2a2045846c7d),
W64LIT(0xe22358888d2e5e63),
W64LIT(0x2887a77a606f18c3),
W64LIT(0xa8286acdc6f9cbd9),
W64LIT(0x5f0e4262d40c3565),
W64LIT(0xeee73f309dc65ab9),
W64LIT(0x9be39d1c8289da97),
W64LIT(0x1634ee099be1a113),
W64LIT(0xea08b1583e9ef55c),
W64LIT(0x9727faa49261de4d),
W64LIT(0x2c682912c337b726),
W64LIT(0xcff7a880e10f4501),
W64LIT(0x1788371334f70d57),
W64LIT(0x27725eec74bd1dd5),
W64LIT(0x3146b0e5ef5cbcc6),
W64LIT(0x099730ca1ca6077b),
W64LIT(0xf2757fdd1ebbfd1d),
W64LIT(0x6aa77cef98082646),
W64LIT(0xbb4fd3b65156696b),
W64LIT(0x569972a8c8aa321e),
W64LIT(0xa3321d337173612a),
W64LIT(0x50fbbbf4c0de3073),
W64LIT(0x5a5d1510d84236c4),
W64LIT(0xfd80864b0a69f80b),
W64LIT(0x07de1046a762ae29),
W64LIT(0xa6614a417d3d628b),
W64LIT(0xd78a6605c12a4d40),
W64LIT(0x67dfc24d27f68ed8),
W64LIT(0xbc91c3f0f634c742),
W64LIT(0xd05476436648e369),
W64LIT(0x493aac6b4fed9476),
W64LIT(0x12db606138b90ef6),
W64LIT(0xa994b3d769ef679d),
W64LIT(0x211097b07cc91fb8),
W64LIT(0x30fa69ff404a1082),
W64LIT(0x3c3e0e4750a21458),
W64LIT(0x7504a22c1f4f802e),
W64LIT(0x844043df05ce7cff),
W64LIT(0xf0f838e9b5975095),
W64LIT(0x7e1ed5d2a8c52add),
W64LIT(0x90f9eae235037064),
W64LIT(0x0662c95c0874026d),
W64LIT(0x9416648a965bdf81),
W64LIT(0xf69af1b5bde352f8),
W64LIT(0x0d78bea2bffea89e),
W64LIT(0x293b7e60cf79b487),
W64LIT(0xd9c346897aeee412),
W64LIT(0xfbe24f17021dfa66),
W64LIT(0x1367b97b97afa2b2),
W64LIT(0xab19f4e3c2c3ca15),
W64LIT(0x48867571e0fb3832),
W64LIT(0x93c874cc313971a8),
W64LIT(0x79c0c5940fa784f4),
W64LIT(0xcd7aefb44a23e889),
W64LIT(0x439c028f577192c1),
W64LIT(0x5be1cc0a77549a80),
/* box 6 */
W64LIT(0x714d28d778656928),
W64LIT(0xc88a7c6b84f64f7c),
W64LIT(0xec43cac5ab89aaca),
W64LIT(0x777fa38110dc16a3),
W64LIT(0x0f7d5c87e4213b5c),
W64LIT(0x73f051e5f3a1ef51),
W64LIT(0xea714193c330d541),
W64LIT(0x95e5f3dae016c4f3),
W64LIT(0x63d3738095a0e173),
W64LIT(0x9825d66f8ff379d6),
W64LIT(0xe8cc38a148f45338),
W64LIT(0xa840b0c025f06bb0),
W64LIT(0x944135c35f748735),
W64LIT(0x74661caa247ad31c),
W64LIT(0xe7b16426acd56864),
W64LIT(0xd1e689df6e6f0589),
W64LIT(0xa73dec47c1d150ec),
W64LIT(0x64453ecf427bdd3e),
W64LIT(0x0ed99a9e5b43789a),
W64LIT(0x7b1b402dc05be840),
W64LIT(0x0dc025b56fe5bd25),
W64LIT(0x3f183a284e22293a),
W64LIT(0xa0aba108160a6ca1),
W64LIT(0x46be033705bd4703),
W64LIT(0x86df6e94b2b10f6e),
W64LIT(0xa216d83a9dceead8),
W64LIT(0x129e5b57edc5885b),
W64LIT(0x7e3074509c445274),
W64LIT(0x7d29cb7ba8e297cb),
W64LIT(0x1611a9330eb871a9),
W64LIT(0x486799a95efe3f99),
W64LIT(0x9fb39b205828459b),
W64LIT(0xd0424fc6d10d464f),
W64LIT(0xe968feb8f79610fe),
W64LIT(0x5d6f8fb164e08b8f),
W64LIT(0xaafdc9f2ae34edc9),
W64LIT(0x02bd79328bc48679),
W64LIT(0x9b3c6944bb55bc69),
W64LIT(0x6277b5992ac2a2b5),
W64LIT(0x877ba88d0dd34ca8),
W64LIT(0xfa5263f6a531db63),
W64LIT(0x2e9fde54974164de),
W64LIT(0xcda14816d8e9f548),
W64LIT(0x675c81e476dd1881),
W64LIT(0x2a102c30743c9d2c),
W64LIT(0x37f32be07dd82e2b),
W64LIT(0x256d70b7901da670),
W64LIT(0x4ce86bcdbd83c66b),
W64LIT(0x50afaa040b0536aa),
W64LIT(0xef5a75ee9f2f6f75),
W64LIT(0xb3913c4644ada73c),
W64LIT(0x1187e47cd9634de4),
W64LIT(0xc54a59deeb13f259),
W64LIT(0x0000000000000000),
W64LIT(0x01a4c619bf6243c6),
W64LIT(0x90cec7a7bc097ec7),
W64LIT(0xf94bdcdd91971edc),
W64LIT(0x8e347f5c814b087f),
W64LIT(0xc7f720ec60d77420),
W64LIT(0x354e52d2f61ca852),
W64LIT(0x34ea94cb497eeb94),
W64LIT(0xae723b964d49143b),
W64LIT(0xf48bf968fe72a3f9),
W64LIT(0xfc60e8a0cd88a4e8),
W64LIT(0x2909931b409a5893),
W64LIT(0xbd48a6d81feedfa6),
W64LIT(0x6cae2f077181da2f),
W64LIT(0xad6b84bd79efd184),
W64LIT(0x18c833ad55fb0933),
W64LIT(0x204644cacc021c44),
W64LIT(0x392ab17e269b56b1),
W64LIT(0x14acd001857cf7d0),
W64LIT(0x8abb8d386236f18d),
W64LIT(0xeefeb3f7204d2cb3),
W64LIT(0xf636805a75b62580),
W64LIT(0x2bb4ea29cb5edeea),
W64LIT(0xc653e6f5dfb537e6),
W64LIT(0x8d2dc077b5edcdc0),
W64LIT(0x31c1a0b6156151a0),
W64LIT(0xf8ef1ac42ef55d1a),
W64LIT(0xdbb0e125d65184e1),
W64LIT(0x82509cf051ccf69c),
W64LIT(0xe33e96424fa89196),
W64LIT(0xdf3f1341352c7d13),
W64LIT(0x8f90b9453e294bb9),
W64LIT(0x1023226566010e22),
W64LIT(0xa58095754a15d695),
W64LIT(0x2c22a7661c85e2a7),
W64LIT(0xe183ef70c46c17ef),
W64LIT(0xafd6fd8ff22b57fd),
W64LIT(0x471ac52ebadf04c5),
W64LIT(0x4d4cadd402e185ad),
W64LIT(0x916a01be036b3d01),
W64LIT(0x28ad5502fff81b55),
W64LIT(0x3657edf9c2ba6ded),
W64LIT(0xd2ff36f45ac9c036),
W64LIT(0xf1a0cd15a26d19cd),
W64LIT(0xd90d98175d950298),
W64LIT(0xf7924643cad46646),
W64LIT(0xdd826a73bee8fb6a),
W64LIT(0x9d0ee212d3ecc3e2),
W64LIT(0xb6ba083b18b21d08),
W64LIT(0x3da5431ac5e6af43),
W64LIT(0x08eb11c833fa0711),
W64LIT(0x052b347d5c1fba34),
W64LIT(0x6fb7902c45271f90),
W64LIT(0x133a9d4e52a7cb9d),
W64LIT(0x6e135635fa455c56),
W64LIT(0x725497fc4cc3ac97),
W64LIT(0xf31db42729a99fb4),
W64LIT(0x846217a639758917),
W64LIT(0x4b7e26826a58fa26),
W64LIT(0x235ffbe1f8a4d9fb),
W64LIT(0xff79578bf92e6157),
W64LIT(0xda14273c6933c727),
W64LIT(0x8b1f4b21dd54b24b),
W64LIT(0x9caa240b6c8e8024),
W64LIT(0xc1c5abba086e0bab),
W64LIT(0xde9bd5588a4e3ed5),
W64LIT(0x2d86617fa3e7a161),
W64LIT(0xbff5dfea942a59df),
W64LIT(0x66f847fdc9bf5b47),
W64LIT(0x3b97c84cad5fd0c8),
W64LIT(0x3ebcfc31f1406afc),
W64LIT(0xca3705590f32c905),
W64LIT(0x24c9b6ae2f7fe5b6),
W64LIT(0x408c88616d043888),
W64LIT(0x93d7788c88afbb78),
W64LIT(0x196cf5b4ea994af5),
W64LIT(0x9a98af5d0437ffaf),
W64LIT(0x8c89066e0a8f8e06),
W64LIT(0xab590feb1156ae0f),
W64LIT(0xd7d4028906d67a02),
W64LIT(0xe4a8db0d9873addb),
W64LIT(0xc378d28883aa8dd2),
W64LIT(0x4ff1d4e6892503d4),
W64LIT(0xd670c490b9b439c4),
W64LIT(0x65e1f8d6fd199ef8),
W64LIT(0xf2b9723e96cbdc72),
W64LIT(0xb12c4574cf692145),
W64LIT(0x569d215263bc4921),
W64LIT(0x69851b7a2d9e601b),
W64LIT(0x5e76309a50464e30),
W64LIT(0x5fd2f683ef240df6),
W64LIT(0xd8a95e0ee2f7415e),
W64LIT(0xe29a505bf0cad250),
W64LIT(0x96fc4cf1d4b0014c),
W64LIT(0x8806f40ae9f277f4),
W64LIT(0x53b6152f3fa3f315),
W64LIT(0x1c47c1c9b686f0c1),
W64LIT(0x80ede5c2da0870e5),
W64LIT(0xd5697bbb8d12fc7b),
W64LIT(0xfdc42eb972eae72e),
W64LIT(0x0bf2aee3075cc2ae),
W64LIT(0x22fb3df847c69a3d),
W64LIT(0xbadeeb97c835e3eb),
W64LIT(0xdc26ac6a018ab8ac),
W64LIT(0xbcec60c1a08c9c60),
W64LIT(0x4231f153e6c0bef1),
W64LIT(0x337cd9849ea5d7d9),
W64LIT(0x5b5d04e70c59f404),
W64LIT(0x79a6391f4b9f6e39),
W64LIT(0x5212d33680c1b0d3),
W64LIT(0xb5a3b7102c14d8b7),
W64LIT(0x7f94b249232611b2),
W64LIT(0x17b56f2ab1da326f),
W64LIT(0x59e07dd5879d727d),
W64LIT(0xebd5878a7c529687),
W64LIT(0xbb7a2d8e7757a02d),
W64LIT(0x0319bf2b34a6c5bf),
W64LIT(0x5ccb49a8db82c849),
W64LIT(0x1de307d009e4b307),
W64LIT(0x49c35fb0e19c7c5f),
W64LIT(0x55849e79571a8c9e),
W64LIT(0x7abf86347f39ab86),
W64LIT(0x9273be9537cdf8be),
W64LIT(0xe615a23f13b72ba2),
W64LIT(0x6821dd6392fc23dd),
W64LIT(0x5af9c2feb33bb7c2),
W64LIT(0x06328b5668b97f8b),
W64LIT(0x44037a058e79c17a),
W64LIT(0x83f45ae9eeaeb55a),
W64LIT(0x5739e74bdcde0ae7),
W64LIT(0xfbf6a5ef1a5398a5),
W64LIT(0xe50c1d142711ee1d),
W64LIT(0x1a754a9fde3f8f4a),
W64LIT(0x7802ff06f4fd2dff),
W64LIT(0xf52f3f714110e03f),
W64LIT(0x2674cf9ca4bb63cf),
W64LIT(0x60caccaba10624cc),
W64LIT(0xb088836d700b6283),
W64LIT(0xa6992a5e7eb3132a),
W64LIT(0xa9e476d99a922876),
W64LIT(0x6b386248a65ae662),
W64LIT(0xc2dc14913cc8ce14),
W64LIT(0x76db6598afbe5565),
W64LIT(0x32d81f9d21c7941f),
W64LIT(0x21e282d373605f82),
W64LIT(0xc0616da3b70c486d),
W64LIT(0x616e0ab21e64670a),
W64LIT(0x6d0ae91ecee399e9),
W64LIT(0x27d009851bd92009),
W64LIT(0xfedd9192464c2291),
W64LIT(0x45a7bc1c311b82bc),
W64LIT(0x54205860e878cf58),
W64LIT(0xa10f6711a9682f67),
W64LIT(0x9981107630913a10),
W64LIT(0xede70cdc14ebe90c),
W64LIT(0x70e9eecec7072aee),
W64LIT(0x1f5e7ee28220357e),
W64LIT(0x2f3b184d28232718),
W64LIT(0x41284e78d2667b4e),
W64LIT(0xa424536cf5779553),
W64LIT(0xa3b21e2322aca91e),
W64LIT(0x4e5512ff36474012),
W64LIT(0x1efab8fb3d4276b8),
W64LIT(0x89a2321356903432),
W64LIT(0xcb93c340b0508ac3),
W64LIT(0x306566afaa031266),
W64LIT(0x4adae09bd53ab9e0),
W64LIT(0xc92eba723b940cba),
W64LIT(0x094fd7d18c9844d7),
W64LIT(0xcc058e0f678bb68e),
W64LIT(0xd4cdbda23270bfbd),
W64LIT(0x0a5668fab83e8168),
W64LIT(0x510b6c1db467756c),
W64LIT(0xb86392a543f16592),
W64LIT(0x048ff264e37df9f2),
W64LIT(0x3a330e55123d930e),
W64LIT(0xb235fa5ffbcfe4fa),
W64LIT(0xb9c754bcfc932654),
W64LIT(0x3c0185037a84ec85),
W64LIT(0x0c64e3acd087fee3),
W64LIT(0xe02729697b0e5429),
W64LIT(0x07964d4fd7db3c4d),
W64LIT(0x814923db656a3323),
W64LIT(0x388e776799f91577),
W64LIT(0x6a9ca4511938a5a4),
W64LIT(0x1bd18c86615dcc8c),
W64LIT(0xb407710993769b71),
W64LIT(0x150816183a1eb416),
W64LIT(0x4395374a59a2fd37),
W64LIT(0xc4ee9fc75471b19f),
W64LIT(0x5844bbcc38ff31bb),
W64LIT(0xcf1c3124532d7331),
W64LIT(0xb71ece22a7d05ece),
W64LIT(0xaccf42a4c68d9242),
W64LIT(0x97588ae86bd2428a),
W64LIT(0x75c2dab39b1890da),
W64LIT(0x9e175d39e74a065d),
W64LIT(0xf0040b0c1d0f5a0b),
W64LIT(0xceb8f73dec4f30f7),
W64LIT(0xbe5119f32b481a19),
W64LIT(0xd35bf0ede5ab83f0),
W64LIT(0x7c8d0d621780d40d),
W64LIT(0x85c6d1bf8617cad1),
/* box 7 */
W64LIT(0xb1c742127b66f2a4),
W64LIT(0xce916098d7a59fc1),
W64LIT(0xc312ef8e2406fa70),
W64LIT(0x956c7dced81403d5),
W64LIT(0x5a0c9b2318dd9520),
W64LIT(0xad0d57f51a480e8b),
W64LIT(0xe7b9d05287740b01),
W64LIT(0x0217f9ea2ed81268),
W64LIT(0x4d7cff19f8cd3a06),
W64LIT(0x44d1772e572b7b67),
W64LIT(0xfb73c5b5e65af72e),
W64LIT(0x91427aef84512705),
W64LIT(0x0c720963e4cf6c85),
W64LIT(0x87c398a0732d8117),
W64LIT(0xa17f5e96fe87620e),
W64LIT(0x50476c8b8e8fcf1d),
W64LIT(0xcb4ee1cc9c8cb225),
W64LIT(0x67b2304c91a8b59a),
W64LIT(0x54696baad2caebcd),
W64LIT(0xddcf03836bf01437),
W64LIT(0x46c68ec479f3690f),
W64LIT(0x8f9f96e2cba7c942),
W64LIT(0xe1802e99f5e93db9),
W64LIT(0x4e9a8086c179215a),
W64LIT(0xf0c9b4686764a427),
W64LIT(0xfd4a3b7e94c7c196),
W64LIT(0xfcbbbd0b83abc8a2),
W64LIT(0xebcbd93163bb6784),
W64LIT(0xf9643c5fc882e546),
W64LIT(0xc4da973041f7c5fc),
W64LIT(0x1af3eb2c13b3ca97),
W64LIT(0x6e1fb87b3e4ef4fb),
W64LIT(0x5e229c024498b1f0),
W64LIT(0xf516353c2c4d89c3),
W64LIT(0xcc869972f97d8da9),
W64LIT(0x8d886f08e57fdb2a),
W64LIT(0x1cca15e7612efc2f),
W64LIT(0x567e9240fc12f9a5),
W64LIT(0x43190f9032da44eb),
W64LIT(0xfeac44e1ad73daca),
W64LIT(0x07c878be65f13f8c),
W64LIT(0x618bce87e3358322),
W64LIT(0xf895ba2adfeeec72),
W64LIT(0x751dd5223a913758),
W64LIT(0x59eae4bc21698e7c),
W64LIT(0xff5dc294ba1fd3fe),
W64LIT(0x03e67f9f39b41b5c),
W64LIT(0x2292c117d1efc7c9),
W64LIT(0x8a4017b6808ee4a6),
W64LIT(0xd1bd0ae08f3f78b2),
W64LIT(0x135e631bbc558bf6),
W64LIT(0xee14586528924a60),
W64LIT(0x8857ee5cae56f6ce),
W64LIT(0x0000000000000000),
W64LIT(0x0e65f089ca177eed),
W64LIT(0x34132358269361db),
W64LIT(0x15679dd0cec8bd4e),
W64LIT(0x800be01e16dcbe9b),
W64LIT(0x949dfbbbcf780ae1),
W64LIT(0xe397d773db312fd1),
W64LIT(0xedf227fa1126513c),
W64LIT(0xb5e945332723d674),
W64LIT(0x53a11314b73bd441),
W64LIT(0x23634762c683cefd),
W64LIT(0x4b4501d28a500cbe),
W64LIT(0x473708b16e9f603b),
W64LIT(0x1770643ae010af26),
W64LIT(0xa746a05d8c1a54b6),
W64LIT(0x90b3fc9a933d2e31),
W64LIT(0x35e2a52d31ff68ef),
W64LIT(0xab34a93e68d53833),
W64LIT(0xd81082d720d939d3),
W64LIT(0xb86aca25d480b3c5),
W64LIT(0xdfd8fa694528065f),
W64LIT(0x4f6b06f3d615286e),
W64LIT(0x578f1435eb7ef091),
W64LIT(0x9af80b32056f740c),
W64LIT(0x92a40570bde53c59),
W64LIT(0xdbf6fd48196d228f),
W64LIT(0x1b026d5904dfc3a3),
W64LIT(0x3c4f2d1a9e19298e),
W64LIT(0xc8a89e53a538a979),
W64LIT(0x991e74ad3cdb6f50),
W64LIT(0x042e07215c4524d0),
W64LIT(0x8e6e1097dccbc076),
W64LIT(0xe071a8ece285348d),
W64LIT(0xd784f42bfda24e0a),
W64LIT(0x7d41db60821b7f0d),
W64LIT(0x85d4614a5df5937f),
W64LIT(0xbb8cb5baed34a899),
W64LIT(0x40ff700f0b6e5fb7),
W64LIT(0x2cf7319e1bf8b924),
W64LIT(0x3a76d3d1ec841f36),
W64LIT(0x4520f15b40477253),
W64LIT(0xf138321d7008ad13),
W64LIT(0x42e889e525b64ddf),
W64LIT(0x65a5c9a6bf70a7f2),
W64LIT(0x208538fdff37d5a1),
W64LIT(0x410ef67a1c025683),
W64LIT(0x18e412c63d6bd8ff),
W64LIT(0x72d5ad9c5f6008d4),
W64LIT(0x255ab9a9b41ef845),
W64LIT(0x93558305aa89356d),
W64LIT(0x70c2547671b81abc),
W64LIT(0x3604dab2084b73b3),
W64LIT(0x05df81544b292de4),
W64LIT(0xf2de4d8249bcb64f),
W64LIT(0x0bba71dd813e5309),
W64LIT(0xa368a77cd05f7066),
W64LIT(0x796fdc41de5e5bdd),
W64LIT(0xec03a18f064a5808),
W64LIT(0x085c0e42b88a4855),
W64LIT(0x274d40439ac6ea2d),
W64LIT(0x31cca20c6dba4c3f),
W64LIT(0x322add93540e5763),
W64LIT(0xb60f3aac1e97cd28),
W64LIT(0x7cb05d1595777639),
W64LIT(0xb036c4676c0afb90),
W64LIT(0x0a4bf7a896525a3d),
W64LIT(0x73242be9480c01e0),
W64LIT(0x5bfd1d560fb19c14),
W64LIT(0x7b7825abf08649b5),
W64LIT(0xb7febcd909fbc41c),
W64LIT(0x81fa666b01b0b7af),
W64LIT(0xd25b757fb68b63ee),
W64LIT(0x0d838f16f3a365b1),
W64LIT(0x6a31bf5a620bd02b),
W64LIT(0x26bcc6368daae319),
W64LIT(0x9ed60c13592a50dc),
W64LIT(0x581b62c936058748),
W64LIT(0x9cc1f5f977f242b4),
W64LIT(0x83ed9f812f68a5c7),
W64LIT(0x74ec53572dfd3e6c),
W64LIT(0xb3d0bbf855bee0cc),
W64LIT(0xacfcd1800d2407bf),
W64LIT(0x303d24797ad6450b),
W64LIT(0x7a89a3dee7ea4081),
W64LIT(0x69d7c0c55bbfcb77),
W64LIT(0x770a2cc814492530),
W64LIT(0x0f9476fcdd7b77d9),
W64LIT(0xaeeb286a23fc15d7),
W64LIT(0x2174be88e85bdc95),
W64LIT(0xde297c1c52440f6b),
W64LIT(0xd04c8c9598537186),
W64LIT(0x2ee0c8743520ab4c),
W64LIT(0x977b8424f6cc11bd),
W64LIT(0x10b81c8485e190aa),
W64LIT(0xa4a0dfc2b5ae4fea),
W64LIT(0x98eff2d82bb76664),
W64LIT(0xa8d2d6a15161236f),
W64LIT(0xd4628bb4c4165556),
W64LIT(0x682646b04cd3c243),
W64LIT(0x2d06b7eb0c94b010),
W64LIT(0x626db118da81987e),
W64LIT(0x2928b0ca50d194c0),
W64LIT(0x6df9c7e407faefa7),
W64LIT(0x1681e24ff77ca612),
W64LIT(0x4952f838a4881ed6),
W64LIT(0x76fbaabd03252c04),
W64LIT(0xc73ce8af7843dea0),
W64LIT(0xe82da6ae5a0f7cd8),
W64LIT(0xc10516640adee818),
W64LIT(0x968a0251e1a01889),
W64LIT(0x37f55cc71f277a87),
W64LIT(0xe5ae29b8a9ac1969),
W64LIT(0xcabf67b98be0bb11),
W64LIT(0xf4e7b3493b2180f7),
W64LIT(0xe9dc20db4d6375ec),
W64LIT(0x639c376dcded914a),
W64LIT(0x12afe56eab3982c2),
W64LIT(0xc2e369fb336af344),
W64LIT(0xa6b726289b765d82),
W64LIT(0x14961ba5d9a4b47a),
W64LIT(0xbc44cd0488c59715),
W64LIT(0xd3aaf30aa1e76ada),
W64LIT(0x28d936bf47bd9df4),
W64LIT(0xaf1aae1f34901ce3),
W64LIT(0x2f114e01224ca278),
W64LIT(0xe648562790180235),
W64LIT(0x24ab3fdca372f171),
W64LIT(0x52509561a057dd75),
W64LIT(0xc6cd6eda6f2fd794),
W64LIT(0xa08ed8e3e9eb6b3a),
W64LIT(0x09ad8837afe64161),
W64LIT(0xbdb54b719fa99e21),
W64LIT(0x8c79e97df213d21e),
W64LIT(0xcf60e6edc0c996f5),
W64LIT(0x5dc4e39d7d2caaac),
W64LIT(0x11499af1928d999e),
W64LIT(0x5fd31a7753f4b8c4),
W64LIT(0x01f18675176c0934),
W64LIT(0xc52b1145569bccc8),
W64LIT(0x9f278a664e4659e8),
W64LIT(0x3dbeab6f897520ba),
W64LIT(0xa2992109c7337952),
W64LIT(0x9b098d4712037d38),
W64LIT(0xc9591826b254a04d),
W64LIT(0x3b8755a4fbe81602),
W64LIT(0xbe5334eea61d857d),
W64LIT(0x51b6eafe99e3c629),
W64LIT(0x191594b32a07d1cb),
W64LIT(0x1f2c6a78589ae773),
W64LIT(0x3fa95285a7ad32d2),
W64LIT(0x5c3565e86a40a398),
W64LIT(0xb2213d8d42d2e9f8),
W64LIT(0xefe5de103ffe4354),
W64LIT(0x4ab487a79d3c058a),
W64LIT(0xcd771f07ee11849d),
W64LIT(0xbfa2b29bb1718c49),
W64LIT(0xba7d33cffa58a1ad),
W64LIT(0x6fee3e0e2922fdcf),
W64LIT(0x64544fd3a81caec6),
W64LIT(0xd9e104a237b530e7),
W64LIT(0xf32fcbf75ed0bf7b),
W64LIT(0x3e58d4f0b0c13be6),
W64LIT(0xb418c346304fdf40),
W64LIT(0xaac52f4b7fb93107),
W64LIT(0xdc3e85f67c9c1d03),
W64LIT(0xd5930dc1d37a5c62),
W64LIT(0x0639fecb729d36b8),
W64LIT(0xc0f490111db2e12c),
W64LIT(0x7ea7a4ffbbaf6451),
W64LIT(0xf6f04aa315f9929f),
W64LIT(0x6643b63986c4bcae),
W64LIT(0x6c0841911096e693),
W64LIT(0x8425e73f4a999a4b),
W64LIT(0x7133d20366d41388),
W64LIT(0x38612a3bc25c0d5e),
W64LIT(0xb99b4c50c3ecbaf1),
W64LIT(0x1d3b93927642f51b),
W64LIT(0x7f56228aacc36d65),
W64LIT(0x9d30738c609e4b80),
W64LIT(0x48a37e4db3e417e2),
W64LIT(0x8bb191c397e2ed92),
W64LIT(0x2acecf5569658f9c),
W64LIT(0xda077b3d0e012bbb),
W64LIT(0xa55159b7a2c246de),
W64LIT(0x33db5be643625e57),
W64LIT(0x821c19f43804acf3),
W64LIT(0x3990ac4ed530046a),
W64LIT(0xd675725eeace473e),
W64LIT(0x789e5a34c93252e9),
W64LIT(0x86321ed564418823),
W64LIT(0xfa8243c0f136fe1a),
W64LIT(0xe45fafcdbec0105d),
W64LIT(0x2b3f49207e0986a8),
W64LIT(0xa92350d4460d2a5b),
W64LIT(0x1eddec0d4ff6ee47),
W64LIT(0x89a66829b93afffa),
W64LIT(0x607a48f2f4598a16),
W64LIT(0x6bc0392f7567d91f),
W64LIT(0xea3a5f4474d76eb0),
W64LIT(0x5598eddfc5a6e2f9),
W64LIT(0x4c8d796cefa13332),
W64LIT(0xf701ccd602959bab),
W64LIT(0xe2665106cc5d26e5),
};

static const word64 SHARK_dec_cbox[8*256] = {
/* box 0 */
W64LIT(0xe6126af05e55aff3),
W64LIT(0x4b6c893f310b0835),
W64LIT(0xaa4c0e84ebfc8d57),
W64LIT(0xfb9b5c7bf3b3090d),
W64LIT(0x4508a6a9ccba5ce2),
W64LIT(0xe5d1d2064dc6bde9),
W64LIT(0x348343755288edde),
W64LIT(0xb684505de46b250c),
W64LIT(0xa8cede205a1e91e8),
W64LIT(0x40b89b46f9fa6acc),
W64LIT(0x8ee1ec1afab080ba),
W64LIT(0xde77d6b7408e0a45),
W64LIT(0x9a3e184c2e455802),
W64LIT(0xbe93fad23f0955ef),
W64LIT(0x3ae76ce3af39b909),
W64LIT(0xad7ee3cf6f5ea7c6),
W64LIT(0x8b51d1f5cff0b694),
W64LIT(0x70ca8d8e3c43bf99),
W64LIT(0xccdba7f8b2a8f6c9),
W64LIT(0x4c5e6474b5a922a4),
W64LIT(0x5d31adcd541ccc32),
W64LIT(0x9b7f701e8c3456a7),
W64LIT(0x2ac9cd08ecfd593a),
W64LIT(0x8fa0844858c18e1f),
W64LIT(0x32f0c66c745bc9ea),
W64LIT(0xc58d6525cbbb888f),
W64LIT(0x8c633cbe4b529c05),
W64LIT(0xf2cd9ea68aa0774b),
W64LIT(0x2cba4811ca2e7d0e),
W64LIT(0xe2e33f4dc9649778),
W64LIT(0xf4be1bbfac73537f),
W64LIT(0x22de6787379f29d9),
W64LIT(0x0956c2dd79137e46),
W64LIT(0xe061efe978868bc7),
W64LIT(0x1cc85ed90f97a85b),
W64LIT(0x31337e9a67c8dbf0),
W64LIT(0x360193d1e36af161),
W64LIT(0x7fefca4a6383e5eb),
W64LIT(0x8535fe633241e243),
W64LIT(0xc3fee03ced68acbb),
W64LIT(0x81c4abdea570dac8),
W64LIT(0x67d6c12efb25753b),
W64LIT(0xa4282112164dd980),
W64LIT(0xcf181f0ea13be4d3),
W64LIT(0xa98fb672f86f9f4d),
W64LIT(0x5c70c59ff66dc297),
W64LIT(0xb0f7d544c2b80138),
W64LIT(0x0da79760ee2246cd),
W64LIT(0x3740fb83411bffc4),
W64LIT(0x24ade29e114c0ded),
W64LIT(0xf858e48de0201b17),
W64LIT(0x0e642f96fdb154d7),
W64LIT(0xddb46e41531d185f),
W64LIT(0x25ec8accb33d0348),
W64LIT(0x0282d0a4b1e21cbf),
W64LIT(0x1bfab3928b3582ca),
W64LIT(0xaffc336bdebcbb79),
W64LIT(0x35c22b27f0f9e37b),
W64LIT(0x03c3b8f61393121a),
W64LIT(0xb8e07fcb19da71db),
W64LIT(0x99fda0ba3dd64a18),
W64LIT(0xce59775c034aea76),
W64LIT(0x49ee599b80e9148a),
W64LIT(0xfe2b6194c6f33f23),
W64LIT(0x4edcb4d0044b3e1b),
W64LIT(0xd5a3c4ce887f68bc),
W64LIT(0xdf36bee5e2ff04e0),
W64LIT(0x171c4ca0c766caa2),
W64LIT(0x0bd41279c8f162f9),
W64LIT(0xe490ba54efb7b34c),
W64LIT(0x5b4228d472cfe806),
W64LIT(0x5355825ba9ad98e5),
W64LIT(0x9f8e25a31b056e2c),
W64LIT(0xcd9acfaa10d9f86c),
W64LIT(0x88926903dc63a48e),
W64LIT(0xb40680f9558939b3),
W64LIT(0x239f0fd595ee277c),
W64LIT(0xec8710db34d5c3af),
W64LIT(0x87b72ec783a3fefc),
W64LIT(0x632794936c144db0),
W64LIT(0x46cb1e5fdf294ef8),
W64LIT(0x83467b7a1492c677),
W64LIT(0x9c4d9d5508967c36),
W64LIT(0xd6607c389bec7aa6),
W64LIT(0x165d24f26517c407),
W64LIT(0xc4cc0d7769ca862a),
W64LIT(0xcbe94ab3360adc58),
W64LIT(0x847496319030ece6),
W64LIT(0x7a5ff7a556c3d3c5),
W64LIT(0xc03d58cafefbbea1),
W64LIT(0x76b908971a909bad),
W64LIT(0x2f79f0e7d9bd6f14),
W64LIT(0x197863363ad79e75),
W64LIT(0xda86830ad7bf32ce),
W64LIT(0x5a034086d0bee6a3),
W64LIT(0x97998f2cc0671ecf),
W64LIT(0x552607428f7ebcd1),
W64LIT(0x51d752ff184f845a),
W64LIT(0xbb23c73d0a4963c1),
W64LIT(0x2b88a55a4e8c579f),
W64LIT(0xd80453ae665d2e71),
W64LIT(0xee05c07f8537df10),
W64LIT(0x423a4be248187673),
W64LIT(0xcaa822e1947bd2fd),
W64LIT(0x1abbdbc029448c6f),
W64LIT(0x96d8e77e6216106a),
W64LIT(0x6266fcc1ce654315),
W64LIT(0x89d301517e12aa2b),
W64LIT(0x730935782fd0ad83),
W64LIT(0x8085c38c0701d46d),
W64LIT(0x6b303e1cb7763d53),
W64LIT(0x3f57510c9a798f27),
W64LIT(0x4449cefb6ecb5247),
W64LIT(0x48af31c922981a2f),
W64LIT(0x98bcc8e89fa744bd),
W64LIT(0x69b2eeb8069421ec),
W64LIT(0xebb5fd90b077e93e),
W64LIT(0x6a71564e150733f6),
W64LIT(0x116fc9b9e1b5ee96),
W64LIT(0x4a2de16d937a0690),
W64LIT(0xb9a11799bbab7f7e),
W64LIT(0x9368da9157562644),
W64LIT(0x718be5dc9e32b13c),
W64LIT(0xc82af2452599ce42),
W64LIT(0xb547e8abf7f83716),
W64LIT(0x33b1ae3ed62ac74f),
W64LIT(0x799c4f534550c1df),
W64LIT(0x3e16395e38088182),
W64LIT(0x7c2c72bc7010f7f1),
W64LIT(0xf38cf6f428d179ee),
W64LIT(0xd29129850cdd422d),
W64LIT(0x41f9f3145b8b6469),
W64LIT(0x945a37dad3f40cd5),
W64LIT(0x757ab061090389b7),
W64LIT(0x6554118a4ac76984),
W64LIT(0x7d6d1aeed261f954),
W64LIT(0x01416852a2710ea5),
W64LIT(0xb27505e0735a1d87),
W64LIT(0x77f860c5b8e19508),
W64LIT(0x78dd2701e721cf7a),
W64LIT(0xe12087bbdaf78562),
W64LIT(0x86f6469521d2f059),
W64LIT(0xef44a82d2746d1b5),
W64LIT(0xbc112a768eeb4950),
W64LIT(0xc2bf886e4f19a21e),
W64LIT(0x307216c8c5b9d555),
W64LIT(0xc96b9a1787e8c0e7),
W64LIT(0xa31acc5992eff311),
W64LIT(0xa0d974af817ce10b),
W64LIT(0xdcf50613f16c16fa),
W64LIT(0xfca9b1307711239c),
W64LIT(0x57a4d7e63e9ca06e),
W64LIT(0xc64eddd3d8289a95),
W64LIT(0xa25ba40b309efdb4),
W64LIT(0x2e3898b57bcc61b1),
W64LIT(0xf5ff73ed0e025dda),
W64LIT(0xa6aaf1b6a7afc53f),
W64LIT(0xd9453bfcc42c20d4),
W64LIT(0x9d0cf507aae77293),
W64LIT(0x290a75feff6e4b20),
W64LIT(0xa7eb99e405decb9a),
W64LIT(0xa1981cfd230defae),
W64LIT(0x12ac714ff226fc8c),
W64LIT(0x743bd833ab728712),
W64LIT(0x6c02d35733d417c2),
W64LIT(0xe9372d340195f581),
W64LIT(0xf77da349bfe04165),
W64LIT(0x68f386eaa4e52f49),
W64LIT(0x211ddf71240c3bc3),
W64LIT(0x13ed191d5057f229),
W64LIT(0xe8764566a3e4fb24),
W64LIT(0xf9198cdf425115b2),
W64LIT(0xd013f921bd3f5e92),
W64LIT(0x91ea0a35e6b43afb),
W64LIT(0x0732ed4b84a22a91),
W64LIT(0xeaf495c21206e79b),
W64LIT(0x5214ea090bdc9640),
W64LIT(0x0000000000000000),
W64LIT(0xb3346db2d12b1322),
W64LIT(0x0ce6ff324c534868),
W64LIT(0xaebd5b397ccdb5dc),
W64LIT(0x0a957a2b6a806c5c),
W64LIT(0x1f0be62f1c04ba41),
W64LIT(0x14dff456d4f5d8b8),
W64LIT(0x58819022615cfa1c),
W64LIT(0x05b03def3540362e),
W64LIT(0xe3a2571f6b1599dd),
W64LIT(0x9229b2c3f52728e1),
W64LIT(0xba62af6fa8386d64),
W64LIT(0x0673851926d32434),
W64LIT(0x641579d8e8b66721),
W64LIT(0x04f155bd9731388b),
W64LIT(0x9ecf4df1b9746089),
W64LIT(0x205cb723867d3566),
W64LIT(0x102ea1eb43c4e033),
W64LIT(0x3ba604b10d48b7ac),
W64LIT(0x50963aadba3e8aff),
W64LIT(0xac3f8b9dcd2fa963),
W64LIT(0x7b1e9ff7f4b2dd60),
W64LIT(0xf63ccb1b1d914fc0),
W64LIT(0x7eaea218c1f2eb4e),
W64LIT(0x5fb37d69e5fed08d),
W64LIT(0x56e5bfb49cedaecb),
W64LIT(0x2dfb2043685f73ab),
W64LIT(0x61a54437ddf6510f),
W64LIT(0x6fc16ba1204705d8),
W64LIT(0xe75302a2fc24a156),
W64LIT(0x3dd581a82b9b9398),
W64LIT(0xdbc7eb5875ce3c6b),
W64LIT(0x90ab626744c5345e),
W64LIT(0x59c0f870c32df4b9),
W64LIT(0x6697a97c59547b9e),
W64LIT(0xfde8d962d5602d39),
W64LIT(0xd3d041d7aeac4c88),
W64LIT(0x5ef2153b478fde28),
W64LIT(0xd4e2ac9c2a0e6619),
W64LIT(0x1e4a8e7dbe75b4e4),
W64LIT(0x72485d2a8da1a326),
W64LIT(0x437b23b0ea6978d6),
W64LIT(0x159e9c047684d61d),
W64LIT(0x0f2547c45fc05a72),
W64LIT(0xf10e265099336551),
W64LIT(0x3c94e9fa89ea9d3d),
W64LIT(0xbfd292809d785b4a),
W64LIT(0x0817aa8fdb6270e3),
W64LIT(0x60e42c657f875faa),
W64LIT(0x18390b6498a690d0),
W64LIT(0x478a760d7d58405d),
W64LIT(0x284b1dac5d1f4585),
W64LIT(0xb1b6bd1660c90f9d),
W64LIT(0xd15291731f4e5037),
W64LIT(0x4d1f0c2617d82c01),
W64LIT(0xc70fb5817a599430),
W64LIT(0x6d43bb0591a51967),
W64LIT(0x6e8003f382360b7d),
W64LIT(0x1d89368bade6a6fe),
W64LIT(0x4f9ddc82a63a30be),
W64LIT(0xedc6788996a4cd0a),
W64LIT(0xab0d66d6498d83f2),
W64LIT(0x54676f102d0fb274),
W64LIT(0xc17c30985c8ab004),
W64LIT(0x3865bc471edba5b6),
W64LIT(0x3924d415bcaaab13),
W64LIT(0x951b5f8871850270),
W64LIT(0x8a10b9a76d81b831),
W64LIT(0xbd5042242c9a47f5),
W64LIT(0xa5694940b43cd725),
W64LIT(0xff6a09c664823186),
W64LIT(0x8d2254ece92392a0),
W64LIT(0xb7c5380f461a2ba9),
W64LIT(0x82071328b6e3c8d2),
W64LIT(0xd721146a399d7403),
W64LIT(0xfada342951c207a8),
W64LIT(0x262f323aa0ae1152),
W64LIT(0xf04f4e023b426bf4),
W64LIT(0x276e5a6802df1ff7),
/* box 1 */
W64LIT(0x3b4016dbfd16e203),
W64LIT(0x9a7574c51174530a),
W64LIT(0x90012e69c02ec8d3),
W64LIT(0xf44580e3d780e076),
W64LIT(0xf81dec2b49eca14b),
W64LIT(0x26cae3e8a6e3d7ef),
W64LIT(0x0962419e0c41f6ab),
W64LIT(0x54d1eb4070ebd951),
W64LIT(0x865e884b0188eec8),
W64LIT(0xdf76067ea406fe8a),
W64LIT(0x29849412e594fba0),
W64LIT(0x461569896869c0f2),
W64LIT(0xb5ddd6b3bbd6724e),
W64LIT(0x0c586cc89e6c413d),
W64LIT(0x6b0ad97054d904ea),
W64LIT(0xa135621eec62b109),
W64LIT(0x0eef7e47087ea461),
W64LIT(0xfaaafea4dffe4417),
W64LIT(0xe0ad344e80342331),
W64LIT(0xab4138b23d382ad0),
W64LIT(0x107390468e90fcff),
W64LIT(0xbe0885a2218561b9),
W64LIT(0xdbed22957d22c132),
W64LIT(0x2251c7037fc7e857),
W64LIT(0x33835ef8ba5e9c86),
W64LIT(0xb3f1e0d7f4e0a8aa),
W64LIT(0x3fdb32302432ddbb),
W64LIT(0xa719547aa3546bed),
W64LIT(0xe10c3df3cb3dab1f),
W64LIT(0x17feaf9f8aafae35),
W64LIT(0x9df84b1c154b01c0),
W64LIT(0x8364a51d93a5595e),
W64LIT(0x535cd49974d48b9b),
W64LIT(0x01a109bd4b09882e),
W64LIT(0xc4d0c529b0c51182),
W64LIT(0x2e09abcbe1aba96a),
W64LIT(0x1f3de7bccde7d0b0),
W64LIT(0x9317355b1d35a5a1),
W64LIT(0x6c87e6a950e65620),
W64LIT(0x8910ffb142ffc287),
W64LIT(0x40395fed275f1a16),
W64LIT(0x7b794936da49f815),
W64LIT(0xf269b68798b63a92),
W64LIT(0xfd27c17ddbc116dd),
W64LIT(0x8d8bdb5a9bdbfd3f),
W64LIT(0x1ba6c35714c3ef08),
W64LIT(0x6e30f426c6f4b37c),
W64LIT(0x7fe26ddd036dc7ad),
W64LIT(0x14e8b4ad57b4c347),
W64LIT(0xb985ba7b25ba3373),
W64LIT(0xe9cf75d08c75d59a),
W64LIT(0x626898ee5898f241),
W64LIT(0x5b9f9cba339cf51e),
W64LIT(0xb250e96abfe92084),
W64LIT(0x165fa622c1a6261b),
W64LIT(0xf5e4895e9c896858),
W64LIT(0xb76ac43c2dc49712),
W64LIT(0x02b7128f9612e55c),
W64LIT(0x1d8af5335bf535ec),
W64LIT(0x36b973ae28732b10),
W64LIT(0xa8572380e02347a2),
W64LIT(0xf6f2926c4192052a),
W64LIT(0x8c2ad2e7d0d27511),
W64LIT(0xd32e6ab63a6abfb7),
W64LIT(0xbd1e9e90fc9e0ccb),
W64LIT(0x03161b32dd1b6d72),
W64LIT(0x4dc03a98f23ad305),
W64LIT(0x81d3b79205b7bc02),
W64LIT(0x450372bbb572ad80),
W64LIT(0x2d1fb0f93cb0c418),
W64LIT(0x2a928f20388f96d2),
W64LIT(0x721b08a8d6080ebe),
W64LIT(0x92b63ce6563c2d8f),
W64LIT(0xeb78675f1a6730c6),
W64LIT(0x13658b74538b918d),
W64LIT(0x428e4d62b14dff4a),
W64LIT(0x88b1f60c09f64aa9),
W64LIT(0x75963771d2375c74),
W64LIT(0x7ad8408b9140703b),
W64LIT(0x57c7f072adf0b423),
W64LIT(0xe5971918121994a7),
W64LIT(0x5666f9cfe6f93c0d),
W64LIT(0x8f3cc9d50dc91863),
W64LIT(0x1e9cee0186ee589e),
W64LIT(0x8a06e4839fe4aff5),
W64LIT(0xb824b3c66eb3bb5d),
W64LIT(0xd1997839ac785aeb),
W64LIT(0x6752b5b8cab545d7),
W64LIT(0xb47cdf0ef0dffa60),
W64LIT(0x949a0a82190af76b),
W64LIT(0xc04be1c269e12e3a),
W64LIT(0xfc86c8c090c89ef3),
W64LIT(0xe3bb2f7c5d2f4e43),
W64LIT(0x6aabd0cd1fd08cc4),
W64LIT(0x2147dc31a2dc8525),
W64LIT(0xca3fbb6eb8bbb5e3),
W64LIT(0x48fa17ce60176493),
W64LIT(0x6444ae8a17ae28a5),
W64LIT(0x2b33869d73861efc),
W64LIT(0xd0387184e771d2c5),
W64LIT(0x7cf476efde76aadf),
W64LIT(0x63c9915313917a6f),
W64LIT(0xc929a05c65a0d891),
W64LIT(0xda4c2b28362b491c),
W64LIT(0xfe31da4f06da7baf),
W64LIT(0xc1eae87f22e8a614),
W64LIT(0x5c12a36337a3a7d4),
W64LIT(0x18b0d865c9d8827a),
W64LIT(0xe7200b97840b71fb),
W64LIT(0x4bec0cfcbd0c09e1),
W64LIT(0x0f4e77fa43772c4f),
W64LIT(0x4c613325b9335b2b),
W64LIT(0xf3c8bf3ad3bfb2bc),
W64LIT(0x87ff81f64a8166e6),
W64LIT(0xa38270917a705455),
W64LIT(0x1911d1d882d10a54),
W64LIT(0x44a27b06fe7b25ae),
W64LIT(0x049b24ebd9243fb8),
W64LIT(0xbb32a8f4b3a8d62f),
W64LIT(0x91a027d48b2740fd),
W64LIT(0x3d6c20bfb22038e7),
W64LIT(0xe681022acf02f9d5),
W64LIT(0xf17fadb545ad57e0),
W64LIT(0xcc138d0af78d6f07),
W64LIT(0x495b1e732b1eecbd),
W64LIT(0x38560de9200d8f71),
W64LIT(0xa9f62a3dab2acf8c),
W64LIT(0x47b46034236048dc),
W64LIT(0x8e9dc06846c0904d),
W64LIT(0xaccc076b3907781a),
W64LIT(0x32225745f15714a8),
W64LIT(0xd4a3556f3e55ed7d),
W64LIT(0xd7b54e5de34e800f),
W64LIT(0xddc114f132141bd6),
W64LIT(0x6d26ef141befde0e),
W64LIT(0x85489379dc9383ba),
W64LIT(0x0bd553119a5313f7),
W64LIT(0x786f520407529567),
W64LIT(0xcb9eb2d3f3b23dcd),
W64LIT(0xa223792c3179dc7b),
W64LIT(0x0a745aacd15a9bd9),
W64LIT(0x710d139a0b1363cc),
W64LIT(0x681cc24289c26998),
W64LIT(0x1a07caea5fca6726),
W64LIT(0x82c5aca0d8acd170),
W64LIT(0x25dcf8da7bf8ba9d),
W64LIT(0xc7c6de1b6dde7cf0),
W64LIT(0xc35dfaf0b4fa4348),
W64LIT(0xded70fc3ef0f76a4),
W64LIT(0x504acfaba9cfe6e9),
W64LIT(0xc571cc94fbcc99ac),
W64LIT(0x5ea5b1eca1b14288),
W64LIT(0xae7b15e4af159d46),
W64LIT(0xc888a9e12ea950bf),
W64LIT(0xf7539bd10a9b8d04),
W64LIT(0x962d180d8f181237),
W64LIT(0xe43610a559101c89),
W64LIT(0x772125fe4425b928),
W64LIT(0x84e99ac4979a0b94),
W64LIT(0xc667d7a626d7f4de),
W64LIT(0xefe343b4c3430f7e),
W64LIT(0xd5025cd2755c6553),
W64LIT(0xa6b85dc7e85de3c3),
W64LIT(0xd61447e0a8470821),
W64LIT(0x3e7a3b8d6f3b5595),
W64LIT(0x52fddd243fdd03b5),
W64LIT(0x8072be2f4ebe342c),
W64LIT(0x12c482c9188219a3),
W64LIT(0x9eee502ec8506cb2),
W64LIT(0xad6d0ed6720ef034),
W64LIT(0x59288e35a58e1042),
W64LIT(0xe21a26c11626c66d),
W64LIT(0x247df16730f132b3),
W64LIT(0xf0dea4080ea4dfce),
W64LIT(0x31344c772c4c79da),
W64LIT(0x4f77281764283659),
W64LIT(0x79ce5bb94c5b1d49),
W64LIT(0x0000000000000000),
W64LIT(0x73ba01159d018690),
W64LIT(0x74373ecc993ed45a),
W64LIT(0xbcbf972db79784e5),
W64LIT(0x4ed621aa2f21be77),
W64LIT(0xd95a301aeb30246e),
W64LIT(0x9c5942a15e4289ee),
W64LIT(0x37187a13637aa33e),
W64LIT(0x276bea55edea5fc1),
W64LIT(0x1c2bfc8e10fcbdc2),
W64LIT(0xed54513b5551ea22),
W64LIT(0x20e6d58ce9d50d0b),
W64LIT(0x3ae11f66b61f6a2d),
W64LIT(0x66f3bc0581bccdf9),
W64LIT(0x2cbeb94477b94c36),
W64LIT(0x99636ff7cc6f3e78),
W64LIT(0x953b033f52037f45),
W64LIT(0xb0e7fbe529fbc5d8),
W64LIT(0x60df8a61ce8a171d),
W64LIT(0x6f91fd9b8dfd3b52),
W64LIT(0xaae0310f7631a2fe),
W64LIT(0xbfa98c1f6a8ce997),
W64LIT(0x8ba7ed3ed4ed27db),
W64LIT(0x98c2664a8766b656),
W64LIT(0x062c36644f36dae4),
W64LIT(0x5570e2fd3be2517f),
W64LIT(0xead96ee2516eb8e8),
W64LIT(0x419856506c569238),
W64LIT(0x23f0cebe34ce6079),
W64LIT(0x309545ca6745f1f4),
W64LIT(0x5a3e950778957d30),
W64LIT(0x617e83dc85839f33),
W64LIT(0xfb0bf71994f7cc39),
W64LIT(0x3ccd2902f929b0c9),
W64LIT(0x70ac1a27401aebe2),
W64LIT(0xcea49f85619f8a5b),
W64LIT(0x39f704546b04075f),
W64LIT(0x0df96575d565c913),
W64LIT(0x08c3482347487e85),
W64LIT(0xd28f630b71633799),
W64LIT(0xecf558861e58620c),
W64LIT(0xc2fcf34dfff3cb66),
W64LIT(0x978c11b0c4119a19),
W64LIT(0x69bdcbffc2cbe1b6),
W64LIT(0xba93a149f8a15e01),
W64LIT(0x51ebc616e2c66ec7),
W64LIT(0x078d3fd9043f52ca),
W64LIT(0x58898788ee87986c),
W64LIT(0x4a4d0541f60581cf),
W64LIT(0xe86e7c6dc77c5db4),
W64LIT(0xee424a09884a8750),
W64LIT(0xcdb284b7bc84e729),
W64LIT(0x65e5a7375ca7a08b),
W64LIT(0x2fa8a276aaa22144),
W64LIT(0xa0946ba3a76b3927),
W64LIT(0xa5ae46f535468eb1),
W64LIT(0x35af689cf5684662),
W64LIT(0x28259dafae9d738e),
W64LIT(0xcf0596382a960275),
W64LIT(0xb6cbcd8166cd1f3c),
W64LIT(0x7e43646048644f83),
W64LIT(0x9bd47d785a7ddb24),
W64LIT(0x432f44dffa447764),
W64LIT(0x9f4f59938359e49c),
W64LIT(0x7d557f52957f22f1),
W64LIT(0x76802c430f2c3106),
W64LIT(0xdc601d4c791d93f8),
W64LIT(0x053a2d56922db796),
W64LIT(0x11d299fbc59974d1),
W64LIT(0xf9bce59602e52965),
W64LIT(0xd8fb39a7a039ac40),
W64LIT(0x340e6121be61ce4c),
W64LIT(0x5f04b851eab8caa6),
W64LIT(0x5db3aade7caa2ffa),
W64LIT(0x1549bd101cbd4b69),
W64LIT(0xff90d3f24dd3f381),
W64LIT(0xafda1c59e41c1568),
W64LIT(0xb146f25862f24df6),
W64LIT(0xa40f4f487e4f069f),
/* box 2 */
W64LIT(0xa1a35cebf8f0f94c),
W64LIT(0x2c203d650f3f095d),
W64LIT(0x1a2bdaee4084a2a7),
W64LIT(0xd32404574d7bcc68),
W64LIT(0xf785bea594a9adc4),
W64LIT(0xf2eb54456206949c),
W64LIT(0x3f5e334d0475ced1),
W64LIT(0x5994299b835d1f60),
W64LIT(0x785b7989ac204794),
W64LIT(0x025da6a2cf461a41),
W64LIT(0xdf1f3a71f01a901b),
W64LIT(0x27284f018bb77637),
W64LIT(0xe1955a6d694c5310),
W64LIT(0x24a1baf2d9d261ac),
W64LIT(0xe4fbb08d9fe36a48),
W64LIT(0x8d83618ef7cff011),
W64LIT(0x2ac72276abf5279e),
W64LIT(0xf9e32621e68eebf6),
W64LIT(0xbf323fb4d3f86f69),
W64LIT(0xbb888605b8745beb),
W64LIT(0x70dafe1e7acd2f65),
W64LIT(0xd0adf1a41f1edbf3),
W64LIT(0x1e91635f2b089625),
W64LIT(0xee2791b8864818f8),
W64LIT(0x99ce23e4c56c1484),
W64LIT(0xf33f0714ff259946),
W64LIT(0xbd6f99161cbe7528),
W64LIT(0x9f293cf761a63a47),
W64LIT(0xb80173f6ea114c70),
W64LIT(0x6543ef25d54dc62a),
W64LIT(0x39b92c5ea0bfe012),
W64LIT(0x63a4f0367187e8e9),
W64LIT(0x4c0d38a02cddf62f),
W64LIT(0x07334c4239e92319),
W64LIT(0x43bff375c3d9bdc7),
W64LIT(0xca862b4a5f9a7954),
W64LIT(0x5d2e902ae8d12be2),
W64LIT(0x137e0e280b4ac78c),
W64LIT(0xf162a1b630638307),
W64LIT(0x55af17bd3e3c4313),
W64LIT(0x358212781ddebc61),
W64LIT(0x94214e93e52e452d),
W64LIT(0xc18e592edb12063e),
W64LIT(0xec7a371a490e02b9),
W64LIT(0x4963d240da72cf77),
W64LIT(0x41e255d70c9fa786),
W64LIT(0xff0439324244c535),
W64LIT(0x88ed8b6e0160c949),
W64LIT(0x6c163be39e83a301),
W64LIT(0xc534e09fb09e32bc),
W64LIT(0x806c0cf9d78da1b8),
W64LIT(0xdba583c09b96a499),
W64LIT(0x746047af11411be7),
W64LIT(0xf40c4b56c6ccba5f),
W64LIT(0x6270a367eca4e533),
W64LIT(0xd41748157492ef71),
W64LIT(0xeff3c2e91b6b1522),
W64LIT(0x0e66988472274632),
W64LIT(0x534808ae9af66dd0),
W64LIT(0x8231aa5b18cbbbf9),
W64LIT(0xb2dd52c3f3ba3ec0),
W64LIT(0xdd429cd33f5c8a5a),
W64LIT(0x4e509e02e39bec6e),
W64LIT(0x26fc1c5016947bed),
W64LIT(0xd9f8256254d0bed8),
W64LIT(0x0955d4c64bce652b),
W64LIT(0x1610e4c8fde5fed4),
W64LIT(0x6dc268b203a0aedb),
W64LIT(0x2e7d9bc7c079131c),
W64LIT(0xc3d3ff8c14541c7f),
W64LIT(0xd64aeeb7bbd4f530),
W64LIT(0xab7f7ddee15b8bfc),
W64LIT(0x144d426a32a3e495),
W64LIT(0x8e0a947da5aae78a),
W64LIT(0x798f2ad831034a4e),
W64LIT(0x3be48afc6ff9fa53),
W64LIT(0x529c5bff07d5600a),
W64LIT(0xbee66ce54edb62b3),
W64LIT(0x931202d1dcc76634),
W64LIT(0x50c1fd5dc8937a4b),
W64LIT(0xa4cdb60b0e5fc014),
W64LIT(0x57f2b11ff17a5952),
W64LIT(0x47054ac4a8558945),
W64LIT(0x5a1ddc68d13808fb),
W64LIT(0x5cfac37b75f22638),
W64LIT(0xc207acdd897711a5),
W64LIT(0x289a84d464b33ddf),
W64LIT(0xc05a0a7f46310be4),
W64LIT(0xe6a6162f50a57009),
W64LIT(0x06e71f13a4ca2ec3),
W64LIT(0x5f733688279731a3),
W64LIT(0xeb497b5870e721a0),
W64LIT(0xb667eb7298360a42),
W64LIT(0xe3c8fccfa60a4951),
W64LIT(0xe772457ecd867dd3),
W64LIT(0x6978d103682c9a59),
W64LIT(0x0def6d77204251a9),
W64LIT(0xc90fdeb90dff6ecf),
W64LIT(0xd179a2f5823dd629),
W64LIT(0x2fa9c8965d5a1ec6),
W64LIT(0x81b85fa84aaeac62),
W64LIT(0xdc96cf82a27f8780),
W64LIT(0x602d05c523e2ff72),
W64LIT(0x19a22f1d12e1b53c),
W64LIT(0xe52fe3dc02c06792),
W64LIT(0x58407aca1e7e12ba),
W64LIT(0x61f95694bec1f2a8),
W64LIT(0x48b781114751c2ad),
W64LIT(0xaaab2e8f7c788626),
W64LIT(0x04bab9b16b8c3482),
W64LIT(0x2df46e34921c0487),
W64LIT(0x1123a88ac40cddcd),
W64LIT(0xc6bd156ce2fb2527),
W64LIT(0x7f6835cb95c9648d),
W64LIT(0x83e5f90a85e8b623),
W64LIT(0x4f84cd537eb8e1b4),
W64LIT(0x294ed785f9903005),
W64LIT(0x1cccc5fde44e8c64),
W64LIT(0xcb52781bc2b9748e),
W64LIT(0x1d1896ac796d81be),
W64LIT(0xb30901926e99331a),
W64LIT(0xad9862cd4591a53f),
W64LIT(0xc8db8de890dc6315),
W64LIT(0x7bd28c7afe45500f),
W64LIT(0x0adc213519ab72b0),
W64LIT(0xa8f6882db33e9c67),
W64LIT(0xb5ee1e81ca531dd9),
W64LIT(0x201b0343b25e552e),
W64LIT(0x4036068691bcaa5c),
W64LIT(0xae11973e17f4b2a4),
W64LIT(0x9efd6fa6fc85379d),
W64LIT(0x33650d6bb91492a2),
W64LIT(0x3a30d9adf2daf789),
W64LIT(0x0c3b3e26bd615c73),
W64LIT(0xf651edf4098aa01e),
W64LIT(0x710ead4fe7ee22bf),
W64LIT(0x3138abc9765288e3),
W64LIT(0x9d749a55aee02006),
W64LIT(0x6e4b9d4151c5b940),
W64LIT(0x84d6b548bc01953a),
W64LIT(0x360be78b4fbbabfa),
W64LIT(0xa22aa918aa95eed7),
W64LIT(0xedae644bd42d0f63),
W64LIT(0x46d119953576849f),
W64LIT(0x6497bc74486ecbf0),
W64LIT(0xfbbe808329c8f1b7),
W64LIT(0x4aea27b38817d8ec),
W64LIT(0x5626e24e6c595488),
W64LIT(0x056eeae0f6af3958),
W64LIT(0x4558ec6667139304),
W64LIT(0x448cbf37fa309ede),
W64LIT(0x6f9fce10cce6b49a),
W64LIT(0xa0770fba65d3f496),
W64LIT(0x671e49871a0bdc6b),
W64LIT(0xda71d09106b5a943),
W64LIT(0x08818797d6ed68f1),
W64LIT(0xa3fefa4937b6e30d),
W64LIT(0xb080f4613cfc2481),
W64LIT(0x763de10dde0701a6),
W64LIT(0x4dd96bf1b1fefbf5),
W64LIT(0x92c6518041e46bee),
W64LIT(0x3456412980fdb1bb),
W64LIT(0x981a70b5584f195e),
W64LIT(0x3d0395efcb33d490),
W64LIT(0xba5cd55425575631),
W64LIT(0x4b3e74e21534d536),
W64LIT(0x6af124f03a498dc2),
W64LIT(0x7ebc669a08ea6957),
W64LIT(0x30ecf898eb718539),
W64LIT(0xa922db7c2e1d91bd),
W64LIT(0x7a06df2b63665dd5),
W64LIT(0xb154a730a1df295b),
W64LIT(0xfc8dccc11021d2ae),
W64LIT(0xcfe8c1aaa935400c),
W64LIT(0x97a8bb60b74b52b6),
W64LIT(0x18767c4c8fc2b8e6),
W64LIT(0x9a47d6179709031f),
W64LIT(0x0000000000000000),
W64LIT(0xac4c319cd8b2a8e5),
W64LIT(0xb9d520a7773241aa),
W64LIT(0xdecb69206d399dc1),
W64LIT(0x1f45300eb62b9bff),
W64LIT(0x10f7fbdb592fd017),
W64LIT(0x3e8a601c9956c30b),
W64LIT(0x8502e619212298e0),
W64LIT(0xf5d818075befb785),
W64LIT(0x547b44eca31f4ec9),
W64LIT(0x9ca0c90433c32ddc),
W64LIT(0xe041093cf46f5eca),
W64LIT(0xa69010a9c119da55),
W64LIT(0xc769463d7fd828fd),
W64LIT(0xc4e0b3ce2dbd3f66),
W64LIT(0x2575e9a344f16c76),
W64LIT(0x01d453519d230dda),
W64LIT(0xfa6ad3d2b4ebfc6d),
W64LIT(0xd5c31b44e9b1e2ab),
W64LIT(0xf83775707bade62c),
W64LIT(0xbcbbca47819d78f2),
W64LIT(0xd79ebde626f7f8ea),
W64LIT(0x5bc98f394c1b0521),
W64LIT(0x2246a5e17d184f6f),
W64LIT(0x12aa5d799669ca56),
W64LIT(0x5ea765d9bab43c79),
W64LIT(0x8939d83f9c43c493),
W64LIT(0x32b15e3a24379f78),
W64LIT(0xe914ddfabfa13be1),
W64LIT(0x909bf7228ea271af),
W64LIT(0x73530bed28a838fe),
W64LIT(0xd2f05706d058c1b2),
W64LIT(0xfed06a63df67c8ef),
W64LIT(0xb43a4dd057701003),
W64LIT(0xa519e55a937ccdce),
W64LIT(0x75b414fe8c62163d),
W64LIT(0xafc5c46f8ad7bf7e),
W64LIT(0x2392f6b0e03b42b5),
W64LIT(0x386d7f0f3d9cedc8),
W64LIT(0x21cf50122f7d58f4),
W64LIT(0x9b9385460a2a0ec5),
W64LIT(0x5115ae0c55b07791),
W64LIT(0x0fb2cbd5ef044be8),
W64LIT(0xea9d2809edc42c7a),
W64LIT(0xcc613459fb505797),
W64LIT(0x426ba0245efab01d),
W64LIT(0x1599113baf80e94f),
W64LIT(0x7d3593695a8f7ecc),
W64LIT(0x0389f5f35265179b),
W64LIT(0x875f40bbee6482a1),
W64LIT(0x95f51dc2780d48f7),
W64LIT(0x7ce1c038c7ac7316),
W64LIT(0xce3c92fb34164dd6),
W64LIT(0xcdb5670866735a4d),
W64LIT(0x8ab02dccce26d308),
W64LIT(0x914fa47313817c75),
W64LIT(0x8b647e9d5305ded2),
W64LIT(0xd82c7633c9f3b302),
W64LIT(0x728758bcb58b3524),
W64LIT(0xe8c08eab2282363b),
W64LIT(0x8fdec72c3889ea50),
W64LIT(0x2b13712736d62a44),
W64LIT(0x3cd7c6be5610d94a),
W64LIT(0x37dfb4dad298a620),
W64LIT(0x868b13ea73478f7b),
W64LIT(0xb7b3b82305150798),
W64LIT(0x0b08726484887f6a),
W64LIT(0x1bff89bfdda7af7d),
W64LIT(0x77e9b25c43240c7c),
W64LIT(0xf0b6f2e7ad408edd),
W64LIT(0x17c4b79960c6f30e),
W64LIT(0x8c5732df6aecfdcb),
W64LIT(0x68ac8252f50f9783),
W64LIT(0x66ca1ad68728d1b1),
W64LIT(0x6b2577a1a76a8018),
W64LIT(0xe21caf9e3b29448b),
W64LIT(0xa74443f85c3ad78f),
W64LIT(0xfd599f908d02df74),
W64LIT(0x967ce8312a685f6c),
/* box 3 */
W64LIT(0xfa7b9775ba3af751),
W64LIT(0x03ef98cb769c2d13),
W64LIT(0x7191ce067072359e),
W64LIT(0xbab18b6bff7516a8),
W64LIT(0xe6e5ef4efbc1065e),
W64LIT(0x7bec74a3b1d0dbf4),
W64LIT(0x656b4fb907c31c4a),
W64LIT(0x4e8520f99fc86304),
W64LIT(0x8fd8df31d16dae58),
W64LIT(0x90a93fc1e60a7244),
W64LIT(0x30ad09f2b449cfc5),
W64LIT(0x8453be7e91bb5b90),
W64LIT(0x1d68a3d1c08feaad),
W64LIT(0x5c54642504b410f6),
W64LIT(0x8061383c8a9e3707),
W64LIT(0xf9940fbecca6da42),
W64LIT(0x46e1d97da982bbdf),
W64LIT(0xfc50521656f7ad77),
W64LIT(0x5e4d2704f35c2647),
W64LIT(0x8bea5973ca48c2cf),
W64LIT(0xd06323dfa34593bd),
W64LIT(0x62b651306a7a5dce),
W64LIT(0xa436b0714966d116),
W64LIT(0x4f73fb131ebc78a6),
W64LIT(0x92b07ce011e244f5),
W64LIT(0x33429139c2d5e2d6),
W64LIT(0xcee418c515565403),
W64LIT(0xd7be3d56cefcd239),
W64LIT(0x53ed83285f4789a9),
W64LIT(0xf3e9b51b0d043428),
W64LIT(0x20650e0fd8dd8a86),
W64LIT(0xb6e7f4add21aa2e4),
W64LIT(0x6d0fb63d3189c491),
W64LIT(0x0da0a42cac1bafee),
W64LIT(0x3f14eeffefba569a),
W64LIT(0x13279f361a086850),
W64LIT(0x9b225e8ea6dc878c),
W64LIT(0x6684d772715f3159),
W64LIT(0xa3ebaef824df9092),
W64LIT(0xc499a260d4f4ba69),
W64LIT(0xaa798c9693e153eb),
W64LIT(0x50021be329dba4ba),
W64LIT(0x949bb983fd2f1ed3),
W64LIT(0xdfdac4d2f8b60ae2),
W64LIT(0xf0062dd07b98193b),
W64LIT(0xafbdd13e09b024de),
W64LIT(0xb95e13a089e93bbb),
W64LIT(0x649d945386b707e8),
W64LIT(0xe4fcac6f0c2930ef),
W64LIT(0x413cc7f4c43bfa5b),
W64LIT(0x3b2668bdf49f3a0d),
W64LIT(0xe50a77858d5d2b4d),
W64LIT(0x05c45da89a517735),
W64LIT(0x3ee235156ece4d38),
W64LIT(0xfe491137a11f9bc6),
W64LIT(0xb7112f47536eb946),
W64LIT(0x07dd1e896db94184),
W64LIT(0x1ab5bd58ad36ab29),
W64LIT(0x8197e3d60bea2ca5),
W64LIT(0xab8f577c12954849),
W64LIT(0x9cff4007cb65c608),
W64LIT(0xa00436335243bd81),
W64LIT(0xfda689fcd783b6d5),
W64LIT(0xccfd5be4e2be62b2),
W64LIT(0x75a348446b575909),
W64LIT(0x17151974012d04c7),
W64LIT(0xfb8d4c9f3b4eecf3),
W64LIT(0xac5249f57f2c09cd),
W64LIT(0x9346a70a90965f57),
W64LIT(0x043286421b256c97),
W64LIT(0x27b81086b564cb02),
W64LIT(0x3569545a2e18b8f0),
W64LIT(0x6b24735edd449eb7),
W64LIT(0x2193d5e559a99124),
W64LIT(0xc7763aaba268977a),
W64LIT(0xb0cc31ce3ed7f8c2),
W64LIT(0xc939064c78ef1587),
W64LIT(0x16e3c29e80591f65),
W64LIT(0x5da2bfcf85c00b54),
W64LIT(0x5990398d9ee567c3),
W64LIT(0x67720c98f02b2afb),
W64LIT(0x54309da132fec82d),
W64LIT(0xeab39088d6aeb212),
W64LIT(0x9682faa20ac72862),
W64LIT(0xd38cbb14d5d9beae),
W64LIT(0x4c9c63d8682055b5),
W64LIT(0xd648e6bc4f88c99b),
W64LIT(0xdc355c198e2a27f1),
W64LIT(0x10c807fd6c944543),
W64LIT(0x450e41b6df1e96cc),
W64LIT(0x0b8b614f40d6f5c8),
W64LIT(0xd27a60fe54ada50c),
W64LIT(0x49583e70f2712280),
W64LIT(0x8dc19c10268598e9),
W64LIT(0x5866e2671f917c61),
W64LIT(0x79f537824638ed45),
W64LIT(0xc2b267033839e04f),
W64LIT(0xcb20456d8f072336),
W64LIT(0x2a18b4aa197f64ec),
W64LIT(0xdbe84290e3936675),
W64LIT(0x73888d27879a032f),
W64LIT(0xe8aad3a9214684a3),
W64LIT(0x6ee02ef64715e982),
W64LIT(0xa996145de57d7ef8),
W64LIT(0xc8cfdda6f99b0e25),
W64LIT(0x062bc563eccd5a26),
W64LIT(0x264ecb6c3410d0a0),
W64LIT(0xb8a8c84a089d2019),
W64LIT(0x7dc7b1c05d1d81d2),
W64LIT(0xd5a77e773914e488),
W64LIT(0x4b417d5105991431),
W64LIT(0xf62de8b39755431d),
W64LIT(0x993b1daf5134b13d),
W64LIT(0x82787b1d7d7601b6),
W64LIT(0xe321b2e66190716b),
W64LIT(0xb5086c66a4868ff7),
W64LIT(0x9ee603263c8df0b9),
W64LIT(0x349f8fb0af6ca352),
W64LIT(0x5b897aac690d5172),
W64LIT(0x7c316a2adc699a70),
W64LIT(0xd451a59db860ff2a),
W64LIT(0x706715ecf1062e3c),
W64LIT(0x838ea0f7fc021a14),
W64LIT(0x57df056a4462e53e),
W64LIT(0xcf12c32f94224fa1),
W64LIT(0xed6e8e01bb17f396),
W64LIT(0x915fe42b677e69e6),
W64LIT(0x89f31a523da0f47e),
W64LIT(0xe71334a47ab51dfc),
W64LIT(0xa860cfb76409655a),
W64LIT(0x9f10d8ccbdf9eb1b),
W64LIT(0xef77cd204cffc527),
W64LIT(0xf862d4544dd2c1e0),
W64LIT(0x8a1c82994b3cd96d),
W64LIT(0xae4b0ad488c43f7c),
W64LIT(0x98cdc645d040aa9f),
W64LIT(0x7fdef2e1aaf5b763),
W64LIT(0x4717029728f6a07d),
W64LIT(0x745593aeea2342ab),
W64LIT(0xee8116cacd8bde85),
W64LIT(0x727e56cd06ee188d),
W64LIT(0x227c4d2e2f35bc37),
W64LIT(0x977421488bb333c0),
W64LIT(0xa21d7512a5ab8b30),
W64LIT(0xbb4750817e010d0a),
W64LIT(0x6cf96dd7b0fddf33),
W64LIT(0x2801f78bee97525d),
W64LIT(0x1c9e783b41fbf10f),
W64LIT(0x9d099bed4a11ddaa),
W64LIT(0x7a1aaf4930a4c056),
W64LIT(0x32b44ad343a1f974),
W64LIT(0x3cfb763499267b89),
W64LIT(0xb2d572efc93fce73),
W64LIT(0x63408adaeb0e466c),
W64LIT(0xada4921ffe58126f),
W64LIT(0x5fbbfcee72283de5),
W64LIT(0x6ad2a8b45c308515),
W64LIT(0x0c567fc62d6fb44c),
W64LIT(0x956d62697c5b0571),
W64LIT(0x25a153a7428cfdb3),
W64LIT(0x150c5a55f6c53276),
W64LIT(0xe2d7690ce0e46ac9),
W64LIT(0xda1e997a62e77dd7),
W64LIT(0xf5c27078e1c96e0e),
W64LIT(0xc344bce9b94dfbed),
W64LIT(0x60af12119d926b7f),
W64LIT(0xa1f2edd9d337a623),
W64LIT(0xcad69e870e733894),
W64LIT(0x3770177bd9f08e41),
W64LIT(0xa5c06b9bc812cab4),
W64LIT(0x1f71e0f03767dc1c),
W64LIT(0x44f89a5c5e6a8d6e),
W64LIT(0x6159c9fb1ce670dd),
W64LIT(0x8e2e04db5019b5fa),
W64LIT(0x8805c1b8bcd4efdc),
W64LIT(0xe138f1c7967847da),
W64LIT(0x4ab7a6bb84ed0f93),
W64LIT(0x0000000000000000),
W64LIT(0x38c9f0768203171e),
W64LIT(0x1b4366b22c42b08b),
W64LIT(0x7803ec68c74cf6e7),
W64LIT(0xec9855eb3a63e834),
W64LIT(0xbe830d29e4507a3f),
W64LIT(0x2dc5aa2374c62568),
W64LIT(0xa62ff350be8ee7a7),
W64LIT(0x764cd08f1dcb741a),
W64LIT(0x8c3747faa7f1834b),
W64LIT(0x0fb9e70d5bf3995f),
W64LIT(0x55c6464bb38ad38f),
W64LIT(0xf7db3359162158bf),
W64LIT(0xd195f8352231881f),
W64LIT(0x0992226eb73ec379),
W64LIT(0x14fa81bf77b129d4),
W64LIT(0x48aee59a73053922),
W64LIT(0x2457884dc3f8e611),
W64LIT(0xffbfcadd206b8064),
W64LIT(0xb4feb78c25f29455),
W64LIT(0x864afd5f66536d21),
W64LIT(0x6f16f51cc661f220),
W64LIT(0xde2c1f3879c21140),
W64LIT(0x195a2593dbaa863a),
W64LIT(0x2e2a32e8025a087b),
W64LIT(0x432584d533d3ccea),
W64LIT(0x2c3371c9f5b23eca),
W64LIT(0xa7d928ba3ffafc05),
W64LIT(0x42d35f3fb2a7d748),
W64LIT(0x85a5659410cf4032),
W64LIT(0x0864f984364ad8db),
W64LIT(0xf21f6ef18c702f8a),
W64LIT(0xf1f0f63afaec0299),
W64LIT(0xd9f101b1147b50c4),
W64LIT(0x2fdce902832e13d9),
W64LIT(0x4d6ab832e9544e17),
W64LIT(0xe0ce2a2d170c5c78),
W64LIT(0x51f4c009a8afbf18),
W64LIT(0x68cbeb95abd8b3a4),
W64LIT(0xc15dffc84ea5cd5c),
W64LIT(0x02194321f7e836b1),
W64LIT(0x113edc17ede05ee1),
W64LIT(0x521b58c2de33920b),
W64LIT(0x9ad4856427a89c2e),
W64LIT(0x5629de80c516fe9c),
W64LIT(0x77ba0b659cbf6fb8),
W64LIT(0x238a96c4ae41a795),
W64LIT(0x12d144dc9b7c73f2),
W64LIT(0xd807da5b950f4b66),
W64LIT(0x3686cc91588495e3),
W64LIT(0x18acfe795ade9d98),
W64LIT(0x5a7fa146e8794ad0),
W64LIT(0xc680e141231c8cd8),
W64LIT(0x1e873b1ab613c7be),
W64LIT(0xf434ab9260bd75ac),
W64LIT(0xcd0b800e63ca7910),
W64LIT(0xbc9a4e0813b84c8e),
W64LIT(0x3d0dadde1852602b),
W64LIT(0x40ca1c1e454fe1f9),
W64LIT(0x0a7dbaa5c1a2ee6a),
W64LIT(0x693d307f2aaca806),
W64LIT(0x0e4f3ce7da8782fd),
W64LIT(0xbd6c95e292cc572c),
W64LIT(0x3ad0b35775eb21af),
W64LIT(0x7e28290b2b81acc1),
W64LIT(0x01f6dbea81741ba2),
W64LIT(0x87bc26b5e7277683),
W64LIT(0x393f2b9c03770cbc),
W64LIT(0xddc387f30f5e3c53),
W64LIT(0xeb454b6257daa9b0),
W64LIT(0xb323a905484bd5d1),
W64LIT(0xb13aea24bfa3e360),
W64LIT(0x315bd218353dd467),
W64LIT(0x2bee6f40980b7f4e),
W64LIT(0xe95c0843a0329f01),
W64LIT(0xc56f798a5580a1cb),
W64LIT(0xbf75d6c36524619d),
W64LIT(0x29f72c616fe349ff),
W64LIT(0xc0ab2422cfd1d6fe),
/* box 4 */
W64LIT(0x561fc423e957943c),
W64LIT(0x014287ca69079288),
W64LIT(0x2f086129dfcd1d21),
W64LIT(0xc537d4aea044fd99),
W64LIT(0xf1e8c3bfd7c8a457),
W64LIT(0x2971998a5cdf9bfb),
W64LIT(0x23fa649a2ce9e460),
W64LIT(0x3aa9e9c356a6716a),
W64LIT(0xd6efa4e7aa3d1708),
W64LIT(0x705a24b1fda5b5eb),
W64LIT(0x101e0ce2b170a9fc),
W64LIT(0x7ca821020e814caa),
W64LIT(0x0bc97ada1931ed13),
W64LIT(0x34df1711778c59ce),
W64LIT(0xd35020ef9226d2bf),
W64LIT(0x575d43e9805006b4),
W64LIT(0x91acebec9b1db840),
W64LIT(0x549b3f423b5945d9),
W64LIT(0x99a3ed9d3925163e),
W64LIT(0x7917a50a369a891d),
W64LIT(0xe372343cb4b6dc4e),
W64LIT(0x8d40e2bdd949e8fd),
W64LIT(0xcfbc29bed0728202),
W64LIT(0x969794857108ac12),
W64LIT(0xdd26de3db30cfa1b),
W64LIT(0x115c8b28d8773b74),
W64LIT(0xe9f9c92cc480a3d5),
W64LIT(0x4dc8b21b4116d0d3),
W64LIT(0x316093194f979c79),
W64LIT(0x5124bb4a0342806e),
W64LIT(0xb31408bcdef3cea8),
W64LIT(0xc1cad76cf158aaa6),
W64LIT(0x88ff66b5e1522d4a),
W64LIT(0xa8c37e8476b28a47),
W64LIT(0x15a188ea896b6c4b),
W64LIT(0xa24883940684f5dc),
W64LIT(0xda1da1545919ee49),
W64LIT(0x22b8e35045ee76e8),
W64LIT(0x6106af9925d28e9f),
W64LIT(0xef80318f4792250f),
W64LIT(0x663dd0f0cfc79acd),
W64LIT(0x302214d326900ef1),
W64LIT(0xdfa2255c61022bfe),
W64LIT(0xe6cdb0348cad19f9),
W64LIT(0x50663c806a4512e6),
W64LIT(0x65fbac5b74ced9a0),
W64LIT(0xc4755364c9436f11),
W64LIT(0x8fc419dc0b473918),
W64LIT(0x5c9439339961eba7),
W64LIT(0x3f166dcb6ebdb4dd),
W64LIT(0xba59890715ccf25e),
W64LIT(0xf0aa4475becf36df),
W64LIT(0x03c67cabbb09436d),
W64LIT(0xb99ff5acaec5b133),
W64LIT(0xf9e7c5ce75f00a29),
W64LIT(0x6df4aa2ad6f677de),
W64LIT(0xaeba8627f5a00c9d),
W64LIT(0xa573fcfdec91e18e),
W64LIT(0x7f6e5da9b5880fc7),
W64LIT(0xca03adb6e86947b5),
W64LIT(0x74a72773acb9e2d4),
W64LIT(0x604428534cd51c17),
W64LIT(0xf8a542041cf798a1),
W64LIT(0x448533a08a29ec25),
W64LIT(0x80f060c4436a8334),
W64LIT(0x0db082799a236bc9),
W64LIT(0xfa21b965cef94944),
W64LIT(0x64b92b911dc94b28),
W64LIT(0x7118a37b94a22763),
W64LIT(0xaff801ed9ca79e15),
W64LIT(0x1dae8e9b2b53c235),
W64LIT(0x13d870490a79ea91),
W64LIT(0x8a7b9dd4335cfcaf),
W64LIT(0x1f2a75faf95d13d0),
W64LIT(0xeec2b6452e95b787),
W64LIT(0xc34e2c0d23567b43),
W64LIT(0x47434f0b3120af48),
W64LIT(0xa18eff3fbd8db6b1),
W64LIT(0x98e16a57502284b6),
W64LIT(0x37196bbacc851aa3),
W64LIT(0x8e869e166240ab90),
W64LIT(0x9fda153eba3790e4),
W64LIT(0xf515c07d86d4f368),
W64LIT(0x72dedfd02fab640e),
W64LIT(0xe230b3f6ddb14ec6),
W64LIT(0x97d5134f180f3e9a),
W64LIT(0xe1f6cf5d66b80dab),
W64LIT(0xe78f37fee5aa8b71),
W64LIT(0xa30a045e6f836754),
W64LIT(0x90ee6c26f21a2ac8),
W64LIT(0xaa4785e5a4bc5ba2),
W64LIT(0x4e0eceb0fa1f93be),
W64LIT(0x94136fe4a3067df7),
W64LIT(0x7b935e6be49458f8),
W64LIT(0x9b2716fceb2bc7db),
W64LIT(0x840d63061276d40b),
W64LIT(0xed04caee959cf4ea),
W64LIT(0xea3fb5877f89e0b8),
W64LIT(0xb56df01f5de14872),
W64LIT(0x4935b1d9100a87ec),
W64LIT(0x82749ba5916452d1),
W64LIT(0x58693af1c87dbc98),
W64LIT(0x89bde17f8855bfc2),
W64LIT(0x677f573aa6c00845),
W64LIT(0xeb7d324d168e7230),
W64LIT(0x0284fb61d20ed1e5),
W64LIT(0xb190f3dd0cfd1f4d),
W64LIT(0x684b2e22eeedb269),
W64LIT(0x2bf562eb8ed14a1e),
W64LIT(0xe0b448970fbf9f23),
W64LIT(0x396f9568edaf3207),
W64LIT(0x52e2c7e1b84bc303),
W64LIT(0x77615bd817b0a1b9),
W64LIT(0x7e2cda63dc8f9d4f),
W64LIT(0xf22ebf146cc1e73a),
W64LIT(0xc08850a6985f382e),
W64LIT(0xd9dbddffe210ad24),
W64LIT(0xbfe60d0f2dd737e9),
W64LIT(0x9a659136822c5553),
W64LIT(0x87cb1fada97f9766),
W64LIT(0x4c8a35d12811425b),
W64LIT(0x83361c6ff863c059),
W64LIT(0xd212a725fb214037),
W64LIT(0x9e9892f4d330026c),
W64LIT(0x45c7b46ae32e7ead),
W64LIT(0x5baf465a7374fff5),
W64LIT(0xdc6459f7da0b6893),
W64LIT(0xd46b5f867833c6ed),
W64LIT(0x5dd6bef9f066792f),
W64LIT(0xcb412a7c816ed53d),
W64LIT(0x75e5a0b9c5be705c),
W64LIT(0xf6d3bcd63dddb005),
W64LIT(0xfb633eafa7fedbcc),
W64LIT(0xd529d84c11345465),
W64LIT(0xc9c5d11d536004d8),
W64LIT(0xdb5f269e301e7cc1),
W64LIT(0x86899867c07805ee),
W64LIT(0x3d9296aabcb36538),
W64LIT(0x2cce1d8264c45e4c),
W64LIT(0x5aedc1901a736d7d),
W64LIT(0x2e4ae6e3b6ca8fa9),
W64LIT(0x1e68f230905a8158),
W64LIT(0xdee0a2960805b976),
W64LIT(0xcd38d2df027c53e7),
W64LIT(0x6909a9e887ea20e1),
W64LIT(0x24c11bf3c6fcf032),
W64LIT(0x18110a9313480782),
W64LIT(0xa7f7079c3e9f306b),
W64LIT(0xd8995a358b173fac),
W64LIT(0x854fe4cc7b714683),
W64LIT(0xbd62f66effd9e60c),
W64LIT(0x14e30f20e06cfec3),
W64LIT(0x6e32d6816dff34b3),
W64LIT(0x217e9ffbfee73585),
W64LIT(0xc88756d73a679650),
W64LIT(0x359d90db1e8bcb46),
W64LIT(0x2645e09214f221d7),
W64LIT(0x04fd03c2511c573f),
W64LIT(0x739c581a46acf686),
W64LIT(0xb0d2741765fa8dc5),
W64LIT(0xa0cc78f5d48a2439),
W64LIT(0x5e10c2524b6f3a42),
W64LIT(0xe50bcc9f37a45a94),
W64LIT(0x53a0402bd14c518b),
W64LIT(0x413ab7a8b2322992),
W64LIT(0x203c183197e0a70d),
W64LIT(0xcc7a55156b7bc16f),
W64LIT(0x4601c8c158273dc0),
W64LIT(0xbea48ac544d0a561),
W64LIT(0x638254f8f7dc5f7a),
W64LIT(0xa6b580565798a2e3),
W64LIT(0x3cd01160d5b4f7b0),
W64LIT(0x8c026577b04e7a75),
W64LIT(0x7ad1d9a18d93ca70),
W64LIT(0x785522c05f9d1b95),
W64LIT(0x5f5245982268a8ca),
W64LIT(0x9551e82eca01ef7f),
W64LIT(0x0000000000000000),
W64LIT(0xbb1b0ecd7ccb60d6),
W64LIT(0x094d81bbcb3f3cf6),
W64LIT(0x28331e4035d80973),
W64LIT(0xf7913b1c54da228d),
W64LIT(0x6acfd5433ce3638c),
W64LIT(0x1bd77638a84144ef),
W64LIT(0x62c0d3329edbcdf2),
W64LIT(0x81b2e70e2a6d11bc),
W64LIT(0xd7ad232dc33a8580),
W64LIT(0x05bf8408381bc5b7),
W64LIT(0x33e468789d994d9c),
W64LIT(0xfedcbaa79fe51e7b),
W64LIT(0x4f4c497a93180136),
W64LIT(0x073b7f69ea151452),
W64LIT(0x0cf205b3f324f941),
W64LIT(0x382d12a284a8a08f),
W64LIT(0x1cec0951425450bd),
W64LIT(0x55d9b888525ed751),
W64LIT(0x6cb62de0bff1e556),
W64LIT(0xd1d4db8e4028035a),
W64LIT(0x25839c39affb62ba),
W64LIT(0x4af3cd72ab03c481),
W64LIT(0xa4317b3785967306),
W64LIT(0x1a95f1f2c146d667),
W64LIT(0x926a97472014fb2d),
W64LIT(0xb7e90b7e8fef9997),
W64LIT(0xcefeae74b975108a),
W64LIT(0x3e54ea0107ba2655),
W64LIT(0xd0965c44292f91d2),
W64LIT(0xab05022fcdbbc92a),
W64LIT(0xfd1ac60c24ec5d16),
W64LIT(0xfc5841c64debcf9e),
W64LIT(0xe4494b555ea3c81c),
W64LIT(0xb6ab8cb4e6e80b1f),
W64LIT(0x3beb6e093fa1e3e2),
W64LIT(0xf36c38de05c675b2),
W64LIT(0x9c1c6995013ed389),
W64LIT(0x8b391a1e5a5b6e27),
W64LIT(0xec464d24fc9b6662),
W64LIT(0xad7cfa8c4ea94ff0),
W64LIT(0x0f347918482dba2c),
W64LIT(0x9d5eee5f68394101),
W64LIT(0x7623dc127eb73331),
W64LIT(0x32a6efb2f49edf14),
W64LIT(0x2d8c9a480dc3ccc4),
W64LIT(0xb2568f76b7f45c20),
W64LIT(0x0e76fed2212a28a4),
W64LIT(0x48773613790d1564),
W64LIT(0x129af783637e7819),
W64LIT(0x080f0671a238ae7e),
W64LIT(0x365bec70a582882b),
W64LIT(0x42fccb03093b6aff),
W64LIT(0x0a8bfd1070367f9b),
W64LIT(0xff9e3d6df6e28cf3),
W64LIT(0xe8bb4ee6ad87315d),
W64LIT(0xc7b32fcf724a2c7c),
W64LIT(0xb8dd7266c7c223bb),
W64LIT(0x9328108d491369a5),
W64LIT(0x0679f8a3831286da),
W64LIT(0x270767587df5b35f),
W64LIT(0xa981f94e1fb518cf),
W64LIT(0x6b8d528955e4f104),
W64LIT(0x1667f44132622f26),
W64LIT(0x2ab7e521e7d6d896),
W64LIT(0xac3e7d4627aedd78),
W64LIT(0x7deaa6c86786de22),
W64LIT(0x1725738b5b65bdae),
W64LIT(0x4bb14ab8c2045609),
W64LIT(0x592bbd3ba17a2e10),
W64LIT(0xc20cabc74a51e9cb),
W64LIT(0x6f70514b04f8a63b),
W64LIT(0xbc2071a496de7484),
W64LIT(0x19538d597a4f950a),
W64LIT(0xf45747b7efd361e0),
W64LIT(0x43be4cc9603cf877),
W64LIT(0xc6f1a8051b4dbef4),
W64LIT(0xb42f77d534e6dafa),
W64LIT(0x40783062db35bb1a),
/* box 5 */
W64LIT(0xf5a96c292deb0a4e),
W64LIT(0x211c9df6ee653c51),
W64LIT(0x04de5ddcbeeef596),
W64LIT(0xe1e5b06f7457c19f),
W64LIT(0x74ca30f014a54fb6),
W64LIT(0xc296f9f7c5457d85),
W64LIT(0x7d4ee08a484d10b0),
W64LIT(0xae87f2d0bf9b13ad),
W64LIT(0x8df4bb480e89afb7),
W64LIT(0x2d8b7a67d9a2d61e),
W64LIT(0x0f3559c8bd712adb),
W64LIT(0x541bc7312f013338),
W64LIT(0x9ec4848b636d5164),
W64LIT(0x952f809f60f28e29),
W64LIT(0x28984d8cb28d6357),
W64LIT(0xd4b5f1dfc38e361f),
W64LIT(0x5674135f7076b373),
W64LIT(0xb791a330042172ec),
W64LIT(0xab94c53bd4b4a6e4),
W64LIT(0xf17731f59305ffd8),
W64LIT(0x39c7a621801e1dcf),
W64LIT(0x20d1f7c13ba47c8e),
W64LIT(0x5e3da912f95facaa),
W64LIT(0xb1202a82e5b80731),
W64LIT(0x13303fc36de4fed3),
W64LIT(0x2e29c43e5314168a),
W64LIT(0x861fbf5c0d1670fa),
W64LIT(0x6458b16af3f771f1),
W64LIT(0x3043765bdcf642c9),
W64LIT(0x12fd55f4b825be0c),
W64LIT(0x0a266e23d65e9f92),
W64LIT(0x6595db5d2636312e),
W64LIT(0x85bd010587a0b06e),
W64LIT(0x9bd7b3600842e42d),
W64LIT(0xaa59af0c0175e63b),
W64LIT(0x240faa1d854a8918),
W64LIT(0xf464061ef82a4a91),
W64LIT(0x5c527d7ca6282ce1),
W64LIT(0x03a2be598ab6c094),
W64LIT(0x40571b7776bdf8e9),
W64LIT(0xe4f687841f7874d6),
W64LIT(0x115febad32937e98),
W64LIT(0x5108f0da442e8671),
W64LIT(0x9cab50e53c1ad12f),
W64LIT(0x33e1c8025640825d),
W64LIT(0x87d2d56bd8d73025),
W64LIT(0xc0f92d999a32fdce),
W64LIT(0x62e938d8126e042c),
W64LIT(0x4a717554a0e3677b),
W64LIT(0x0beb0414039fdf4d),
W64LIT(0xd6da25b19cf9b654),
W64LIT(0x55d6ad06fac073e7),
W64LIT(0x632452efc7af44f3),
W64LIT(0xb5fe775e5b56f2a7),
W64LIT(0x892ae694b0675a21),
W64LIT(0x7a32030f7c1525b2),
W64LIT(0x5d9f174b73e96c3e),
W64LIT(0xc35b93c010843d5a),
W64LIT(0x373f95dee8ae77cb),
W64LIT(0xfb515fd6455b604a),
W64LIT(0xa9fb11558bc326af),
W64LIT(0x22be23af64d3fcc5),
W64LIT(0xa8367b625e026670),
W64LIT(0xb8a4faf8b9505837),
W64LIT(0x785dd7612362a5f9),
W64LIT(0x588c20a018c6d977),
W64LIT(0xea0eb47b77c81ed2),
W64LIT(0xa6ce489d36b20c74),
W64LIT(0x0c97e79137c7ea4f),
W64LIT(0x7c838abd9d8c506f),
W64LIT(0x57b97968a5b7f3ac),
W64LIT(0x6c110b277ade6e28),
W64LIT(0xc785ce1cae6ac8cc),
W64LIT(0x1581b6718c7d8b0e),
W64LIT(0x614b868198d8c4b8),
W64LIT(0x27ad14440ffc498c),
W64LIT(0xdb80a8177eff1cc4),
W64LIT(0x472bf8f242e5cdeb),
W64LIT(0x8a8858cd3ad19ab5),
W64LIT(0xf60bd270a75dcada),
W64LIT(0x43f5a52efc0b387d),
W64LIT(0x6ddc6110af1f2ef7),
W64LIT(0xf0ba5bc246c4bf07),
W64LIT(0x6fb3b57ef068aebc),
W64LIT(0x18db3bd76e7b219e),
W64LIT(0x903cb7740bdd3b60),
W64LIT(0x7bff6938a9d4656d),
W64LIT(0xbdb7cd13d27fed7e),
W64LIT(0x051337eb6b2fb549),
W64LIT(0x77688ea99e138f22),
W64LIT(0xd9ef7c7921889c8f),
W64LIT(0x077ce38534583502),
W64LIT(0xf318e59bcc727f93),
W64LIT(0xb34ffeecbacf877a),
W64LIT(0xe9ac0a22fd7ede46),
W64LIT(0xfc2dbc5371035548),
W64LIT(0x026fd46e5f77804b),
W64LIT(0xe53bedb3cab93409),
W64LIT(0xcc6eca08adf51781),
W64LIT(0xe028da58a1968140),
W64LIT(0x3a6518780aa8dd5b),
W64LIT(0xce011e66f28297ca),
W64LIT(0xa4a19cf369c58c3f),
W64LIT(0xc5ea1a72f11d4887),
W64LIT(0xc427704524dc0858),
W64LIT(0x4238cf1929ca78a2),
W64LIT(0x481ea13aff94e730),
W64LIT(0xdf5ef5cbc011e952),
W64LIT(0x80ae36eeec8f0527),
W64LIT(0x5ae3f4ce47b1593c),
W64LIT(0xcda3a03f7834575e),
W64LIT(0x71d9071b7f8afaff),
W64LIT(0xcadf43ba4c6c625c),
W64LIT(0x1623082806cb4b9a),
W64LIT(0x17ee621fd30a0b45),
W64LIT(0x448946abc8530d7f),
W64LIT(0x974054f13f850e62),
W64LIT(0x73b6d37520fd7ab4),
W64LIT(0xc8b097d4131be217),
W64LIT(0x9f09eebcb6ac11bb),
W64LIT(0x45442c9c1d924da0),
W64LIT(0x1b79858ee4cde10a),
W64LIT(0x0984d07a5ce85f06),
W64LIT(0x4cc0fce6417a12a6),
W64LIT(0x99b8670e57356466),
W64LIT(0xad254c89352dd339),
W64LIT(0x322ca2358381c282),
W64LIT(0xcfcc74512743d715),
W64LIT(0x6b6de8a24e865b2a),
W64LIT(0xda4dc220ab3e5c1b),
W64LIT(0x88e78ca365a61afe),
W64LIT(0x939e092d816bfbf4),
W64LIT(0xcb12298d99ad2283),
W64LIT(0xeed0e9a7c926eb44),
W64LIT(0x98750d3982f424b9),
W64LIT(0xd5789be8164f76c0),
W64LIT(0xbe15734a58c92dea),
W64LIT(0x49d3cb0d2a55a7ef),
W64LIT(0x67fa0f337941b165),
W64LIT(0x8c39d17fdb48ef68),
W64LIT(0x25c2c02a508bc9c7),
W64LIT(0x349d2b876218b75f),
W64LIT(0x70146d2caa4bba20),
W64LIT(0x1c05660bd095d408),
W64LIT(0xfe42683d2e74d503),
W64LIT(0x9a1ad957dd83a4f2),
W64LIT(0xf2d58fac19b33f4c),
W64LIT(0x81635cd9394e45f8),
W64LIT(0xb65cc907d1e03233),
W64LIT(0xdd3121a59f666919),
W64LIT(0x318e1c6c09370216),
W64LIT(0x8b4532faef10da6a),
W64LIT(0x191651e0bbba6141),
W64LIT(0x3f762f9361876812),
W64LIT(0xb96990cf6c9118e8),
W64LIT(0xb4331d698e97b278),
W64LIT(0xd822164ef449dc50),
W64LIT(0x84706b325261f0b1),
W64LIT(0x4eaf28881e0d92ed),
W64LIT(0x69023ccc11f1db61),
W64LIT(0x66376504ac80f1ba),
W64LIT(0x0849ba4d89291fd9),
W64LIT(0xff8f020afbb595dc),
W64LIT(0x50c59aed91efc6ae),
W64LIT(0x1dc80c3c055494d7),
W64LIT(0x1e6ab2658fe25443),
W64LIT(0x3d19fbfd3ef0e859),
W64LIT(0xfa9c35e1909a2095),
W64LIT(0x52aa4e83ce9846e5),
W64LIT(0x419a7140a37cb836),
W64LIT(0xa07fc12fd72b79a9),
W64LIT(0x68cf56fbc4309bbe),
W64LIT(0x01cd6a37d5c140df),
W64LIT(0x9253631a54aabb2b),
W64LIT(0xd06bac037d60c389),
W64LIT(0x295527bb674c2388),
W64LIT(0xd204786d221743c2),
W64LIT(0x0000000000000000),
W64LIT(0xf7c6b847729c8a05),
W64LIT(0xdcfc4b924aa729c6),
W64LIT(0xe38a64012b2041d4),
W64LIT(0xb28294db6f0ec7a5),
W64LIT(0x9d663ad2e9db91f0),
W64LIT(0x91f1dd43de1c7bbf),
W64LIT(0x6086ecb64d198467),
W64LIT(0x59414a97cd0799a8),
W64LIT(0xace826bee0ec93e6),
W64LIT(0xa56cf6c4bc04cce0),
W64LIT(0x727bb942f53c3a6b),
W64LIT(0x6e7edf4925a9ee63),
W64LIT(0x26607e73da3d0953),
W64LIT(0xe75439dd95ceb442),
W64LIT(0x7990bd56f6a3e526),
W64LIT(0xecbf3dc996516b0f),
W64LIT(0x76a5e49e4bd2cffd),
W64LIT(0x968d3ec6ea444ebd),
W64LIT(0x5b2e9ef9927019e3),
W64LIT(0x6aa082959b471bf5),
W64LIT(0xbb0644a133e698a3),
W64LIT(0x830c88b76639c5b3),
W64LIT(0xe2470e36fee1010b),
W64LIT(0xb0ed40b5307947ee),
W64LIT(0x355041b0b7d9f780),
W64LIT(0x8e560511843f6f23),
W64LIT(0x7f2134e4173a90fb),
W64LIT(0x2af799e2edfae31c),
W64LIT(0x4bbc1f63752227a4),
W64LIT(0xf8f3e18fcfeda0de),
W64LIT(0x0d5a8da6e206aa90),
W64LIT(0x2c4610500c6396c1),
W64LIT(0xde939ffc15d0a98d),
W64LIT(0xaf4a98e76a5a5372),
W64LIT(0x8f9b6f2651fe2ffc),
W64LIT(0x36f2ffe93d6f3714),
W64LIT(0x0ef833ff68b06a04),
W64LIT(0xe69953ea400ff49d),
W64LIT(0x23734998b112bc1a),
W64LIT(0x3ebb45a4b44628cd),
W64LIT(0x1ab4efb9310ca1d5),
W64LIT(0x2fe4ae0986d55655),
W64LIT(0xebc3de4ca2095e0d),
W64LIT(0x536724b41b59063a),
W64LIT(0x46e692c597248d34),
W64LIT(0x2b3af3d5383ba3c3),
W64LIT(0x3ba8724fdf699d84),
W64LIT(0xc13447ae4ff3bd11),
W64LIT(0x4d0d96d194bb5279),
W64LIT(0xfde0d664a4c21597),
W64LIT(0xd7174f864938f68b),
W64LIT(0x7eec5ed3c2fbd024),
W64LIT(0xbfd8197d8d086d35),
W64LIT(0x4f6242bfcbccd232),
W64LIT(0xa70322aae3734cab),
W64LIT(0xa3dd7f765d9db93d),
W64LIT(0x94e2eaa8b533cef6),
W64LIT(0x144cdc4659bccbd1),
W64LIT(0xc648a42b7bab8813),
W64LIT(0xf93e8bb81a2ce001),
W64LIT(0xbacb2e96e627d87c),
W64LIT(0xbc7aa72407beada1),
W64LIT(0xc97dfde3c6daa2c8),
W64LIT(0xa1b2ab1802ea3976),
W64LIT(0x1fa7d8525a23149c),
W64LIT(0x75075ac7c1640f69),
W64LIT(0xe861601528bf9e99),
W64LIT(0xa2101541885cf9e2),
W64LIT(0xef1d83901ce7ab9b),
W64LIT(0x06b189b2e19975dd),
W64LIT(0x380acc1655df5d10),
W64LIT(0x1092819ae7523e47),
W64LIT(0xd3c9125af7d6031d),
W64LIT(0xd1a6c634a8a18356),
W64LIT(0x5ff0c3252c9eec75),
W64LIT(0x82c1e280b3f8856c),
W64LIT(0xed7257fe43902bd0),
W64LIT(0x3cd491caeb31a886),
/* box 6 */
W64LIT(0x94af9eb6fad9e7df),
W64LIT(0x9208ae5e03c94ddd),
W64LIT(0x1d8de8d67158480b),
W64LIT(0xfd093cd2ba147af8),
W64LIT(0xa45ceb22e6597ccf),
W64LIT(0x9bbde6e77bf113da),
W64LIT(0xe4edf4b465fffe5c),
W64LIT(0x7125622e4e8d2a2f),
W64LIT(0x1791b81b8f68430d),
W64LIT(0xb56a63d1902195c0),
W64LIT(0xa980832b30d2ee67),
W64LIT(0x4c0a7fb384862397),
W64LIT(0xed58bc0d1dc7a05b),
W64LIT(0x5955d7f05c4d0637),
W64LIT(0xd2b9b1c8806fcf4e),
W64LIT(0x06a730e8f910aa02),
W64LIT(0xb8b60bd846aa0768),
W64LIT(0x45bf370afcbe7d90),
W64LIT(0x16f6b0375ec370a1),
W64LIT(0x892276608b81afd4),
W64LIT(0xdcccc1b5d0ec08e7),
W64LIT(0xe856949162df5f58),
W64LIT(0x82592e81a41a977e),
W64LIT(0xac8eabb74fca1164),
W64LIT(0xfac9041692afe356),
W64LIT(0x3b882d75331ba3ba),
W64LIT(0xa39cd3e6cee2e561),
W64LIT(0xd077a190d7cca9e3),
W64LIT(0x9c7dde23534a8a74),
W64LIT(0x80973ed9f3b9f1d3),
W64LIT(0xce535132209cb4e9),
W64LIT(0xaa299b5fb6dabb66),
W64LIT(0x2d7e9d426dd8d31b),
W64LIT(0x8a8b6e140d89fad5),
W64LIT(0x6ca88af83fd56224),
W64LIT(0xf5db7c4713871753),
W64LIT(0xeef1a4799bcff55a),
W64LIT(0x76e55aea6636b381),
W64LIT(0x8ee24ea4a33a367a),
W64LIT(0x25acddd7c44bbeb0),
W64LIT(0x9adaeecbaa5a2076),
W64LIT(0x0e75707d5083c7a9),
W64LIT(0x2bd9adaa94c87919),
W64LIT(0x19e4c866dfeb84a4),
W64LIT(0x129f9087f070bc0e),
W64LIT(0xd9c2e929aff4f7e4),
W64LIT(0x6f01928cb9dd3725),
W64LIT(0x39463d2d64b8c517),
W64LIT(0xebff8ce5e4d70a59),
W64LIT(0xb40d6bfd418aa66c),
W64LIT(0xf21b44833b3c8efd),
W64LIT(0x3654457ce5903112),
W64LIT(0x431807e205aed792),
W64LIT(0xb10343613e92596f),
W64LIT(0x0a1c50cdfe300b06),
W64LIT(0x778252c6b79d802d),
W64LIT(0x0cbb60250720a104),
W64LIT(0xe1e3dc281ae7015f),
W64LIT(0x0f1278518128f405),
W64LIT(0x47712752ab1d1b3d),
W64LIT(0xe24ac45c9cef545e),
W64LIT(0x1ceae0faa0f37ba7),
W64LIT(0x9814fe93fdf946db),
W64LIT(0xec3fb421cc6c93f7),
W64LIT(0x833e26ad75b1a4d2),
W64LIT(0x6b68b23c176efb8a),
W64LIT(0x4904572ffb9edc94),
W64LIT(0x4bca4777ac3dba39),
W64LIT(0x2762cd8f93e8d81d),
W64LIT(0x9eb3ce7b04e9ecd9),
W64LIT(0xc2e8311727bc15ed),
W64LIT(0xea9884c9357c39f5),
W64LIT(0xfc6e34fe6bbf4954),
W64LIT(0x13f898ab21db8fa2),
W64LIT(0xb7a47389c782f36d),
W64LIT(0x7b3932e3b0bd2129),
W64LIT(0xaf27b3c3c9c24465),
W64LIT(0xb6c37ba51629c0c1),
W64LIT(0x84fe1e695d0a3d7c),
W64LIT(0x1a4dd01259e3d1a5),
W64LIT(0xab4e9373677188ca),
W64LIT(0x90c6be06546a2b70),
W64LIT(0xf37c4cafea97bd51),
W64LIT(0x647aca6d96460f8f),
W64LIT(0x4ec46febd325453a),
W64LIT(0x3e8605e94c035cb9),
W64LIT(0x0ddc6809d68b92a8),
W64LIT(0x8bec6638dc22c979),
W64LIT(0x67d3d219104e5a8e),
W64LIT(0x2abea58645634ab5),
W64LIT(0x5b9bc7a80bee609a),
W64LIT(0x936fa672d2627e71),
W64LIT(0x7d9e020b49ad8b2b),
W64LIT(0x5832dfdc8de6359b),
W64LIT(0xc7e6198b58a4eaee),
W64LIT(0xd41e8120797f654c),
W64LIT(0xf4bc746bc22c24ff),
W64LIT(0xe084d404cb4c32f3),
W64LIT(0x48635f032a35ef38),
W64LIT(0x8757061ddb02687d),
W64LIT(0x522e8f1173d63e9d),
W64LIT(0xbcdf2b68e819cbc7),
W64LIT(0xbf76331c6e119ec6),
W64LIT(0x08d24095a9936dab),
W64LIT(0x728c7a5ac8857f2e),
W64LIT(0xd110a9bc06679a4f),
W64LIT(0x1f43f88e26fb2ea6),
W64LIT(0xb2aa5b15b89a0c6e),
W64LIT(0x4aad4f5b7d968995),
W64LIT(0x9fd4c657d542df75),
W64LIT(0x323d65cc4b23fdbd),
W64LIT(0xc38f393bf6172641),
W64LIT(0xa152c3be994183cc),
W64LIT(0x9d1ad60f82e1b9d8),
W64LIT(0xe744ecc0e3f7ab5d),
W64LIT(0x38213501b513f6bb),
W64LIT(0xade9a39b9e6122c8),
W64LIT(0x37334d50343b02be),
W64LIT(0x55eeb7d55b6da733),
W64LIT(0x970686c27cd1b2de),
W64LIT(0x427f0fced405e43e),
W64LIT(0xc026214f701f7340),
W64LIT(0x40b11f9683a68293),
W64LIT(0x02ce105857a366ad),
W64LIT(0x7e371a7fcfa5de2a),
W64LIT(0xffc72c8aedb71c55),
W64LIT(0x68c1aa489166ae8b),
W64LIT(0xc68111a7890fd942),
W64LIT(0x79f722bbe71e4784),
W64LIT(0xd579890ca8d456e0),
W64LIT(0x70426a029f261983),
W64LIT(0xb0644b4def396ac3),
W64LIT(0xdb0cf971f8579149),
W64LIT(0x5489bff98ac6949f),
W64LIT(0x046920b0aeb3ccaf),
W64LIT(0x7cf90a279806b887),
W64LIT(0x050e289c7f18ff03),
W64LIT(0x651dc24147ed3c23),
W64LIT(0x5e95ef3474f69f99),
W64LIT(0x6dcf82d4ee7e5188),
W64LIT(0x8f854688729105d6),
W64LIT(0x81f036f52212c27f),
W64LIT(0xb9d103f4970134c4),
W64LIT(0x5349873da27d0d31),
W64LIT(0x20a2f54bbb5341b3),
W64LIT(0xf0d554db6c9fe850),
W64LIT(0x07c038c428bb99ae),
W64LIT(0x30f375941c809b10),
W64LIT(0x3fe10dc59da86f15),
W64LIT(0x46162f7e7ab62891),
W64LIT(0xe623e4ec325c98f1),
W64LIT(0xfea024a63c1c2ff9),
W64LIT(0x349a5524b23357bf),
W64LIT(0x35fd5d0863986413),
W64LIT(0x96618eeead7a8172),
W64LIT(0xcb5d79ae5f844bea),
W64LIT(0x21c5fd676af8721f),
W64LIT(0x5720a78d0ccec19e),
W64LIT(0xf6726433958f4252),
W64LIT(0x8d4b56d02532637b),
W64LIT(0x24cbd5fb15e08d1c),
W64LIT(0x3aef2559e2b09016),
W64LIT(0x5afccf84da455336),
W64LIT(0x51879765f5de6b9c),
W64LIT(0x2917bdf2c36b1fb4),
W64LIT(0xa7f5f356605129ce),
W64LIT(0xc1412963a1b440ec),
W64LIT(0x3d2f1d9dca0b09b8),
W64LIT(0xa53be30e37f24f63),
W64LIT(0x5ff2e718a55dac35),
W64LIT(0xa2fbdbca1f49d6cd),
W64LIT(0xf7156c1f442471fe),
W64LIT(0x7a5e3acf61161285),
W64LIT(0xca3a71828e2f7846),
W64LIT(0x1b2ad83e8848e209),
W64LIT(0xa8e78b07e179ddcb),
W64LIT(0xef96ac554a64c6f6),
W64LIT(0x0000000000000000),
W64LIT(0x6013eadd38f5c320),
W64LIT(0x3c4815b11ba03a14),
W64LIT(0x09b548b978385e07),
W64LIT(0x226ce513ecf0271e),
W64LIT(0x63baf2a9befd9621),
W64LIT(0x44d83f262d154e3c),
W64LIT(0xcdfa4946a694e1e8),
W64LIT(0x113688f37678e90f),
W64LIT(0x859916458ca10ed0),
W64LIT(0xc52809d30f078c43),
W64LIT(0x4d6d779f552d103b),
W64LIT(0x1e24f0a2f7501d0a),
W64LIT(0x0167082cd1ab33ac),
W64LIT(0x1438a06f0960160c),
W64LIT(0xf9601c6214a7b657),
W64LIT(0xa035cb9248eab060),
W64LIT(0x50e09f4924755830),
W64LIT(0xd7b79954ff77304d),
W64LIT(0xe58afc98b454cdf0),
W64LIT(0x03a9187486085501),
W64LIT(0x62ddfa856f56a58d),
W64LIT(0xc44f01ffdeacbfef),
W64LIT(0x73eb7276192e4c82),
W64LIT(0xd6d091782edc03e1),
W64LIT(0xfbae0c3a4304d0fa),
W64LIT(0x9973f6bf2c527577),
W64LIT(0x105180dfa7d3daa3),
W64LIT(0x2605c5a34243ebb1),
W64LIT(0x91a1b62a85c118dc),
W64LIT(0xc99369f608272d47),
W64LIT(0x5d3cf740f2feca98),
W64LIT(0xcf34591ef1378745),
W64LIT(0xc8f461dad98c1eeb),
W64LIT(0x0b7b58e12f9b38aa),
W64LIT(0xe32dcc704d4467f2),
W64LIT(0x754c429ee03ee680),
W64LIT(0xd3deb9e451c4fce2),
W64LIT(0x6e669aa068760489),
W64LIT(0x66b4da35c1e56922),
W64LIT(0x4fa367c7028e7696),
W64LIT(0xba781b80110961c5),
W64LIT(0x41d617ba520db13f),
W64LIT(0x335a6de09a88ce11),
W64LIT(0xdf65d9c156e45de6),
W64LIT(0xcc9d416a773fd244),
W64LIT(0x5c5bff6c2355f934),
W64LIT(0x2870b5de12c02c18),
W64LIT(0x155fa843d8cb25a0),
W64LIT(0x78902a9736b57428),
W64LIT(0xae40bbef186977c9),
W64LIT(0x88457e4c5a2a9c78),
W64LIT(0x6a0fba10c6c5c826),
W64LIT(0x7f5012531e0eed86),
W64LIT(0x8c2c5efcf49950d7),
W64LIT(0x31947db8cd2ba8bc),
W64LIT(0x2c19956ebc73e0b7),
W64LIT(0x230bed3f3d5b14b2),
W64LIT(0x69a6a26440cd9d27),
W64LIT(0x86300e310aa95bd1),
W64LIT(0xb3cd533969313fc2),
W64LIT(0x1883c04a0e40b708),
W64LIT(0xf1b25cf7bd34dbfc),
W64LIT(0x2fb08d1a3a7bb5b6),
W64LIT(0xd8a5e1057e5fc448),
W64LIT(0xddabc99901473b4b),
W64LIT(0xde02d1ed874f6e4a),
W64LIT(0xbdb8234439b2f86b),
W64LIT(0x5647afa1dd65f232),
W64LIT(0x2ed78536ebd0861a),
W64LIT(0xe9319cbdb3746cf4),
W64LIT(0xa692fb7ab1fa1a62),
W64LIT(0x742b4ab23195d52c),
W64LIT(0x95c8969a2b72d473),
W64LIT(0x6174e2f1e95ef08c),
W64LIT(0xf807144ec50c85fb),
W64LIT(0xbe113b30bfbaad6a),
W64LIT(0xda6bf15d29fca2e5),
W64LIT(0xbb1f13acc0a25269),
/* box 7 */
W64LIT(0xc22b27f0f9e37bf9),
W64LIT(0x93fad23f0955ef09),
W64LIT(0x32ed4b84a22a91a2),
W64LIT(0x3898b57bcc61b1cc),
W64LIT(0x55825ba9ad98e5ad),
W64LIT(0xb2eeb8069421ec94),
W64LIT(0xc7eb5875ce3c6bce),
W64LIT(0x4b1dac5d1f45851f),
W64LIT(0xc16ba1204705d847),
W64LIT(0xc5380f461a2ba91a),
W64LIT(0xb908971a909bad90),
W64LIT(0x303e1cb7763d5376),
W64LIT(0xe6ff324c53486853),
W64LIT(0x6d1aeed261f95461),
W64LIT(0x0193d1e36af1616a),
W64LIT(0x51d1f5cff0b694f0),
W64LIT(0x29b2c3f52728e127),
W64LIT(0x112a768eeb4950eb),
W64LIT(0x8fb672f86f9f4d6f),
W64LIT(0xf0c66c745bc9ea5b),
W64LIT(0x3f8b9dcd2fa9632f),
W64LIT(0x65bc471edba5b6db),
W64LIT(0x4d9d5508967c3696),
W64LIT(0x3a4be24818767318),
W64LIT(0x2794936c144db014),
W64LIT(0x2af2452599ce4299),
W64LIT(0x4a8e7dbe75b4e475),
W64LIT(0x9ddc82a63a30be3a),
W64LIT(0xade29e114c0ded4c),
W64LIT(0xd1d2064dc6bde9c6),
W64LIT(0x7da349bfe04165e0),
W64LIT(0x6b9a1787e8c0e7e8),
W64LIT(0xa54437ddf6510ff6),
W64LIT(0x2254ece92392a023),
W64LIT(0x79f0e7d9bd6f14bd),
W64LIT(0x57510c9a798f2779),
W64LIT(0x346db2d12b13222b),
W64LIT(0x54118a4ac76984c7),
W64LIT(0xefca4a6383e5eb83),
W64LIT(0xca8d8e3c43bf9943),
W64LIT(0xfc336bdebcbb79bc),
W64LIT(0x3e184c2e45580245),
W64LIT(0xf495c21206e79b06),
W64LIT(0xff73ed0e025dda02),
W64LIT(0x4228d472cfe806cf),
W64LIT(0xbcc8e89fa744bda7),
W64LIT(0xab626744c5345ec5),
W64LIT(0xb6bd1660c90f9dc9),
W64LIT(0xb72ec783a3fefca3),
W64LIT(0x8be5dc9e32b13c32),
W64LIT(0x485d2a8da1a326a1),
W64LIT(0xc6788996a4cd0aa4),
W64LIT(0x40fb83411bffc41b),
W64LIT(0x08a6a9ccba5ce2ba),
W64LIT(0xf386eaa4e52f49e5),
W64LIT(0x1acc5992eff311ef),
W64LIT(0xa2571f6b1599dd15),
W64LIT(0x44a82d2746d1b546),
W64LIT(0x70c59ff66dc2976d),
W64LIT(0x8d6525cbbb888fbb),
W64LIT(0x963aadba3e8aff3e),
W64LIT(0x7c30985c8ab0048a),
W64LIT(0x607c389bec7aa6ec),
W64LIT(0xa822e1947bd2fd7b),
W64LIT(0x034086d0bee6a3be),
W64LIT(0x66fcc1ce65431565),
W64LIT(0xb37d69e5fed08dfe),
W64LIT(0x2f323aa0ae1152ae),
W64LIT(0x56c2dd79137e4613),
W64LIT(0x31adcd541ccc321c),
W64LIT(0xdff456d4f5d8b8f5),
W64LIT(0xf9f3145b8b64698b),
W64LIT(0x764566a3e4fb24e4),
W64LIT(0x0cf507aae77293e7),
W64LIT(0x59775c034aea764a),
W64LIT(0xb89b46f9fa6accfa),
W64LIT(0xe8d962d5602d3960),
W64LIT(0x17aa8fdb6270e362),
W64LIT(0x1c4ca0c766caa266),
W64LIT(0x2de16d937a06907a),
W64LIT(0x2547c45fc05a72c0),
W64LIT(0x0fb5817a59943059),
W64LIT(0x0680f9558939b389),
W64LIT(0x16395e3808818208),
W64LIT(0xac714ff226fc8c26),
W64LIT(0xa9b1307711239c11),
W64LIT(0xec8accb33d03483d),
W64LIT(0x6c893f310b08350b),
W64LIT(0xc4abdea570dac870),
W64LIT(0xba4811ca2e7d0e2e),
W64LIT(0xf155bd9731388b31),
W64LIT(0xdd2701e721cf7a21),
W64LIT(0xe94ab3360adc580a),
W64LIT(0x23c73d0a4963c149),
W64LIT(0x5cb723867d35667d),
W64LIT(0x5042242c9a47f59a),
W64LIT(0x198cdf425115b251),
W64LIT(0x0a75feff6e4b206e),
W64LIT(0xfda0ba3dd64a18d6),
W64LIT(0xcede205a1e91e81e),
W64LIT(0xd041d7aeac4c88ac),
W64LIT(0xe42c657f875faa87),
W64LIT(0x36bee5e2ff04e0ff),
W64LIT(0x6fc9b9e1b5ee96b5),
W64LIT(0x998f2cc0671ecf67),
W64LIT(0xd301517e12aa2b12),
W64LIT(0xaea218c1f2eb4ef2),
W64LIT(0xda342951c207a8c2),
W64LIT(0x61efe978868bc786),
W64LIT(0x7f701e8c3456a734),
W64LIT(0x0be62f1c04ba4104),
W64LIT(0x9129850cdd422ddd),
W64LIT(0xd6c12efb25753b25),
W64LIT(0xe33f4dc964977864),
W64LIT(0x1579d8e8b66721b6),
W64LIT(0xf860c5b8e19508e1),
W64LIT(0x7496319030ece630),
W64LIT(0x88a55a4e8c579f8c),
W64LIT(0xcf4df1b974608974),
W64LIT(0x10b9a76d81b83181),
W64LIT(0x0e26509933655133),
W64LIT(0x43bb0591a51967a5),
W64LIT(0x926903dc63a48e63),
W64LIT(0x9c4f534550c1df50),
W64LIT(0x3bd833ab72871272),
W64LIT(0xa4d7e63e9ca06e9c),
W64LIT(0xb46e41531d185f1d),
W64LIT(0x126af05e55aff355),
W64LIT(0x24d415bcaaab13aa),
W64LIT(0x1e9ff7f4b2dd60b2),
W64LIT(0x05c07f8537df1037),
W64LIT(0x467b7a1492c67792),
W64LIT(0x2087bbdaf78562f7),
W64LIT(0x819022615cfa1c5c),
W64LIT(0xcd9ea68aa0774ba0),
W64LIT(0xa79760ee2246cd22),
W64LIT(0x8343755288edde88),
W64LIT(0x58e48de0201b1720),
W64LIT(0x7216c8c5b9d555b9),
W64LIT(0x372d340195f58195),
W64LIT(0xa11799bbab7f7eab),
W64LIT(0x9f0fd595ee277cee),
W64LIT(0x676f102d0fb2740f),
W64LIT(0x9e9c047684d61d84),
W64LIT(0x49cefb6ecb5247cb),
W64LIT(0xd41279c8f162f9f1),
W64LIT(0x1f0c2617d82c01d8),
W64LIT(0x97a97c59547b9e54),
W64LIT(0xe76ce3af39b90939),
W64LIT(0xc3b8f61393121a93),
W64LIT(0x5ba40b309efdb49e),
W64LIT(0xea0a35e6b43afbb4),
W64LIT(0x5a37dad3f40cd5f4),
W64LIT(0x14ea090bdc9640dc),
W64LIT(0x5e6474b5a922a4a9),
W64LIT(0xfee03ced68acbb68),
W64LIT(0x071328b6e3c8d2e3),
W64LIT(0x5302a2fc24a15624),
W64LIT(0x85c38c0701d46d01),
W64LIT(0x3d58cafefbbea1fb),
W64LIT(0x84505de46b250c6b),
W64LIT(0x642f96fdb154d7b1),
W64LIT(0xbf886e4f19a21e19),
W64LIT(0x02d35733d417c2d4),
W64LIT(0x68da915756264456),
W64LIT(0x8710db34d5c3afd5),
W64LIT(0x0d66d6498d83f28d),
W64LIT(0x7b23b0ea6978d669),
W64LIT(0x1b5f887185027085),
W64LIT(0x3ccb1b1d914fc091),
W64LIT(0x0453ae665d2e715d),
W64LIT(0xcb1e5fdf294ef829),
W64LIT(0xf6469521d2f059d2),
W64LIT(0xb03def3540362e40),
W64LIT(0x633cbe4b529c0552),
W64LIT(0xf7d544c2b80138b8),
W64LIT(0x7ab061090389b703),
W64LIT(0x0000000000000000),
W64LIT(0xdba7f8b2a8f6c9a8),
W64LIT(0x35fe633241e24341),
W64LIT(0x21146a399d74039d),
W64LIT(0xd581a82b9b93989b),
W64LIT(0x0935782fd0ad83d0),
W64LIT(0x5ff7a556c3d3c5c3),
W64LIT(0xaf31c922981a2f98),
W64LIT(0x90ba54efb7b34cb7),
W64LIT(0x5291731f4e50374e),
W64LIT(0xc0f870c32df4b92d),
W64LIT(0x7ee3cf6f5ea7c65e),
W64LIT(0xe07fcb19da71dbda),
W64LIT(0x4eddd3d8289a9528),
W64LIT(0x13f921bd3f5e923f),
W64LIT(0xf50613f16c16fa6c),
W64LIT(0x981cfd230defae0d),
W64LIT(0x4c0e84ebfc8d57fc),
W64LIT(0x82d0a4b1e21cbfe2),
W64LIT(0x89368bade6a6fee6),
W64LIT(0xd292809d785b4a78),
W64LIT(0x47e8abf7f83716f8),
W64LIT(0x8e25a31b056e2c05),
W64LIT(0xd752ff184f845a4f),
W64LIT(0xcc0d7769ca862aca),
W64LIT(0x694940b43cd7253c),
W64LIT(0x2ea1eb43c4e033c4),
W64LIT(0xde6787379f29d99f),
W64LIT(0x181f0ea13be4d33b),
W64LIT(0x416852a2710ea571),
W64LIT(0x62af6fa8386d6438),
W64LIT(0xa0844858c18e1fc1),
W64LIT(0x337e9a67c8dbf0c8),
W64LIT(0x2c72bc7010f7f110),
W64LIT(0xbd5b397ccdb5dccd),
W64LIT(0xd8e77e6216106a16),
W64LIT(0x86830ad7bf32cebf),
W64LIT(0x4f4e023b426bf442),
W64LIT(0xe5bfb49cedaecbed),
W64LIT(0x8a760d7d58405d58),
W64LIT(0xe2ac9c2a0e66190e),
W64LIT(0xb5fd90b077e93e77),
W64LIT(0xdcb4d0044b3e1b4b),
W64LIT(0x453bfcc42c20d42c),
W64LIT(0xed191d5057f22957),
W64LIT(0xe1ec1afab080bab0),
W64LIT(0xee599b80e9148ae9),
W64LIT(0x2607428f7ebcd17e),
W64LIT(0x5d24f26517c40717),
W64LIT(0x6a09c66482318682),
W64LIT(0xa604b10d48b7ac48),
W64LIT(0xbe1bbfac73537f73),
W64LIT(0x282112164dd9804d),
W64LIT(0x7505e0735a1d875a),
W64LIT(0x73851926d32434d3),
W64LIT(0xd974af817ce10b7c),
W64LIT(0xeb99e405decb9ade),
W64LIT(0x9b5c7bf3b3090db3),
W64LIT(0xfab3928b3582ca35),
W64LIT(0x8003f382360b7d36),
W64LIT(0x94e9fa89ea9d3dea),
W64LIT(0xb1ae3ed62ac74f2a),
W64LIT(0x9acfaa10d9f86cd9),
W64LIT(0x390b6498a690d0a6),
W64LIT(0xf2153b478fde288f),
W64LIT(0x71564e150733f607),
W64LIT(0xa3c4ce887f68bc7f),
W64LIT(0xaaf1b6a7afc53faf),
W64LIT(0x1ddf71240c3bc30c),
W64LIT(0x77d6b7408e0a458e),
W64LIT(0x2b6194c6f33f23f3),
W64LIT(0xc9cd08ecfd593afd),
W64LIT(0xc85ed90f97a85b97),
W64LIT(0x8cf6f428d179eed1),
W64LIT(0x957a2b6a806c5c80),
W64LIT(0xbbdbc029448c6f44),
W64LIT(0x7863363ad79e75d7),
W64LIT(0x6e5a6802df1ff7df),
W64LIT(0xfb2043685f73ab5f),
};

static const byte SHARK_iG[8*8] = {
        0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41,
        0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68,
        0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52,
        0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2,
        0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71,
        0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e,
        0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5,
        0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71,
};
//-----------------
static const word32 SHA256_K[64] = {
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

static const word64 SHA512_K[80] = {
        W64LIT(0x428a2f98d728ae22), W64LIT(0x7137449123ef65cd),
        W64LIT(0xb5c0fbcfec4d3b2f), W64LIT(0xe9b5dba58189dbbc),
        W64LIT(0x3956c25bf348b538), W64LIT(0x59f111f1b605d019),
        W64LIT(0x923f82a4af194f9b), W64LIT(0xab1c5ed5da6d8118),
        W64LIT(0xd807aa98a3030242), W64LIT(0x12835b0145706fbe),
        W64LIT(0x243185be4ee4b28c), W64LIT(0x550c7dc3d5ffb4e2),
        W64LIT(0x72be5d74f27b896f), W64LIT(0x80deb1fe3b1696b1),
        W64LIT(0x9bdc06a725c71235), W64LIT(0xc19bf174cf692694),
        W64LIT(0xe49b69c19ef14ad2), W64LIT(0xefbe4786384f25e3),
        W64LIT(0x0fc19dc68b8cd5b5), W64LIT(0x240ca1cc77ac9c65),
        W64LIT(0x2de92c6f592b0275), W64LIT(0x4a7484aa6ea6e483),
        W64LIT(0x5cb0a9dcbd41fbd4), W64LIT(0x76f988da831153b5),
        W64LIT(0x983e5152ee66dfab), W64LIT(0xa831c66d2db43210),
        W64LIT(0xb00327c898fb213f), W64LIT(0xbf597fc7beef0ee4),
        W64LIT(0xc6e00bf33da88fc2), W64LIT(0xd5a79147930aa725),
        W64LIT(0x06ca6351e003826f), W64LIT(0x142929670a0e6e70),
        W64LIT(0x27b70a8546d22ffc), W64LIT(0x2e1b21385c26c926),
        W64LIT(0x4d2c6dfc5ac42aed), W64LIT(0x53380d139d95b3df),
        W64LIT(0x650a73548baf63de), W64LIT(0x766a0abb3c77b2a8),
        W64LIT(0x81c2c92e47edaee6), W64LIT(0x92722c851482353b),
        W64LIT(0xa2bfe8a14cf10364), W64LIT(0xa81a664bbc423001),
        W64LIT(0xc24b8b70d0f89791), W64LIT(0xc76c51a30654be30),
        W64LIT(0xd192e819d6ef5218), W64LIT(0xd69906245565a910),
        W64LIT(0xf40e35855771202a), W64LIT(0x106aa07032bbd1b8),
        W64LIT(0x19a4c116b8d2d0c8), W64LIT(0x1e376c085141ab53),
        W64LIT(0x2748774cdf8eeb99), W64LIT(0x34b0bcb5e19b48a8),
        W64LIT(0x391c0cb3c5c95a63), W64LIT(0x4ed8aa4ae3418acb),
        W64LIT(0x5b9cca4f7763e373), W64LIT(0x682e6ff3d6b2b8a3),
        W64LIT(0x748f82ee5defb2fc), W64LIT(0x78a5636f43172f60),
        W64LIT(0x84c87814a1f0ab72), W64LIT(0x8cc702081a6439ec),
        W64LIT(0x90befffa23631e28), W64LIT(0xa4506cebde82bde9),
        W64LIT(0xbef9a3f7b2c67915), W64LIT(0xc67178f2e372532b),
        W64LIT(0xca273eceea26619c), W64LIT(0xd186b8c721c0c207),
        W64LIT(0xeada7dd6cde0eb1e), W64LIT(0xf57d4f7fee6ed178),
        W64LIT(0x06f067aa72176fba), W64LIT(0x0a637dc5a2c898a6),
        W64LIT(0x113f9804bef90dae), W64LIT(0x1b710b35131c471b),
        W64LIT(0x28db77f523047d84), W64LIT(0x32caab7b40c72493),
        W64LIT(0x3c9ebe0a15c9bebc), W64LIT(0x431d67c49c100d4c),
        W64LIT(0x4cc5d4becb3e42b6), W64LIT(0x597f299cfc657e2a),
        W64LIT(0x5fcb6fab3ad6faec), W64LIT(0x6c44198c4a475817)
};

//-----------------
static const byte SAFER_exp_tab[256] =
        {1, 45, 226, 147, 190, 69, 21, 174, 120, 3, 135, 164, 184, 56, 207, 63,
        8, 103, 9, 148, 235, 38, 168, 107, 189, 24, 52, 27, 187, 191, 114, 247,
        64, 53, 72, 156, 81, 47, 59, 85, 227, 192, 159, 216, 211, 243, 141, 177,
        255, 167, 62, 220, 134, 119, 215, 166, 17, 251, 244, 186, 146, 145, 100, 131,
        241, 51, 239, 218, 44, 181, 178, 43, 136, 209, 153, 203, 140, 132, 29, 20,
        129, 151, 113, 202, 95, 163, 139, 87, 60, 130, 196, 82, 92, 28, 232, 160,
        4, 180, 133, 74, 246, 19, 84, 182, 223, 12, 26, 142, 222, 224, 57, 252,
        32, 155, 36, 78, 169, 152, 158, 171, 242, 96, 208, 108, 234, 250, 199, 217,
        0, 212, 31, 110, 67, 188, 236, 83, 137, 254, 122, 93, 73, 201, 50, 194,
        249, 154, 248, 109, 22, 219, 89, 150, 68, 233, 205, 230, 70, 66, 143, 10,
        193, 204, 185, 101, 176, 210, 198, 172, 30, 65, 98, 41, 46, 14, 116, 80,
        2, 90, 195, 37, 123, 138, 42, 91, 240, 6, 13, 71, 111, 112, 157, 126,
        16, 206, 18, 39, 213, 76, 79, 214, 121, 48, 104, 54, 117, 125, 228, 237,
        128, 106, 144, 55, 162, 94, 118, 170, 197, 127, 61, 175, 165, 229, 25, 97,
        253, 77, 124, 183, 11, 238, 173, 75, 34, 245, 231, 115, 35, 33, 200, 5,
        225, 102, 221, 179, 88, 105, 99, 86, 15, 161, 49, 149, 23, 7, 58, 40};

static const byte SAFER_log_tab[256] =
        {128, 0, 176, 9, 96, 239, 185, 253, 16, 18, 159, 228, 105, 186, 173, 248,
        192, 56, 194, 101, 79, 6, 148, 252, 25, 222, 106, 27, 93, 78, 168, 130,
        112, 237, 232, 236, 114, 179, 21, 195, 255, 171, 182, 71, 68, 1, 172, 37,
        201, 250, 142, 65, 26, 33, 203, 211, 13, 110, 254, 38, 88, 218, 50, 15,
        32, 169, 157, 132, 152, 5, 156, 187, 34, 140, 99, 231, 197, 225, 115, 198,
        175, 36, 91, 135, 102, 39, 247, 87, 244, 150, 177, 183, 92, 139, 213, 84,
        121, 223, 170, 246, 62, 163, 241, 17, 202, 245, 209, 23, 123, 147, 131, 188,
        189, 82, 30, 235, 174, 204, 214, 53, 8, 200, 138, 180, 226, 205, 191, 217,
        208, 80, 89, 63, 77, 98, 52, 10, 72, 136, 181, 86, 76, 46, 107, 158,
        210, 61, 60, 3, 19, 251, 151, 81, 117, 74, 145, 113, 35, 190, 118, 42,
        95, 249, 212, 85, 11, 220, 55, 49, 22, 116, 215, 119, 167, 230, 7, 219,
        164, 47, 70, 243, 97, 69, 103, 227, 12, 162, 59, 28, 133, 24, 4, 29,
        41, 160, 143, 178, 90, 216, 166, 126, 238, 141, 83, 75, 161, 154, 193, 14,
        122, 73, 165, 44, 129, 196, 199, 54, 43, 127, 67, 149, 51, 242, 108, 104,
        109, 240, 2, 40, 206, 221, 155, 234, 94, 153, 124, 20, 134, 207, 229, 66,
        184, 64, 120, 45, 58, 233, 100, 31, 146, 144, 125, 57, 111, 224, 137, 48};


//-----------------
static const word32 Rijndael_Te0[256] = {
    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,
    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,
    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,
    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,
    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,
    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,
    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,
    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,
    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,
    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,
    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,
    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,
    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,
    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,
    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,
    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,
    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,
    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,
    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,
    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,
    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,
    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,
    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,
    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,
    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,
    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,
    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,
    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,
    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,
    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,
    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,
    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,
    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,
    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,
    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,
    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,
    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,
    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,
    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,
    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,
    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,
    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,
    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,
    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,
    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,
    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,
    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,
    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,
    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,
    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,
    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,
    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,
    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,
    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,
    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,
    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,
    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,
    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,
    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,
    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,
    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,
    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,
    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
};
static const word32 Rijndael_Te1[256] = {
    0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,
    0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,
    0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,
    0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,
    0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,
    0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,
    0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,
    0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,
    0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,
    0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,
    0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,
    0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,
    0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,
    0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,
    0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,
    0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,
    0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,
    0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,
    0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,
    0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,
    0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,
    0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,
    0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,
    0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,
    0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,
    0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,
    0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,
    0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,
    0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,
    0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,
    0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,
    0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,
    0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,
    0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,
    0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,
    0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,
    0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,
    0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,
    0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,
    0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,
    0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,
    0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,
    0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,
    0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,
    0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,
    0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,
    0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,
    0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,
    0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,
    0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,
    0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,
    0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,
    0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,
    0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,
    0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,
    0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,
    0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,
    0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,
    0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,
    0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,
    0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,
    0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,
    0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,
    0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,
};
static const word32 Rijndael_Te2[256] = {
    0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,
    0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,
    0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,
    0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,
    0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,
    0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,
    0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,
    0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,
    0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,
    0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,
    0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,
    0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,
    0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,
    0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,
    0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,
    0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,
    0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,
    0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,
    0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,
    0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,
    0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,
    0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,
    0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,
    0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,
    0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,
    0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,
    0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,
    0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,
    0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,
    0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,
    0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,
    0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,
    0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,
    0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,
    0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,
    0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,
    0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,
    0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,
    0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,
    0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,
    0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,
    0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,
    0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,
    0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,
    0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,
    0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,
    0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,
    0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,
    0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,
    0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,
    0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,
    0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,
    0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,
    0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,
    0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,
    0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,
    0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,
    0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,
    0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,
    0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,
    0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,
    0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,
    0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,
    0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,
};

static const word32 Rijndael_Te3[256] = {
    0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,
    0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,
    0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,
    0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,
    0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,
    0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,
    0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,
    0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,
    0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,
    0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,
    0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,
    0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,
    0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,
    0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,
    0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,
    0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,
    0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,
    0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,
    0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,
    0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,
    0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,
    0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,
    0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,
    0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,
    0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,
    0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,
    0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,
    0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,
    0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,
    0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,
    0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,
    0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,
    0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,
    0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,
    0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,
    0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,
    0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,
    0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,
    0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,
    0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,
    0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,
    0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,
    0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,
    0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,
    0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,
    0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,
    0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,
    0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,
    0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,
    0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,
    0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,
    0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,
    0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,
    0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,
    0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,
    0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,
    0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,
    0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,
    0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,
    0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,
    0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,
    0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,
    0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,
    0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,
};

static const word32 Rijndael_Te4[256] = {
    0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,
    0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,
    0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,
    0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,
    0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,
    0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,
    0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,
    0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,
    0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,
    0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,
    0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,
    0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,
    0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,
    0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,
    0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,
    0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,
    0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,
    0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,
    0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,
    0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,
    0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,
    0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,
    0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,
    0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,
    0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,
    0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,
    0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,
    0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,
    0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,
    0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,
    0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,
    0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,
    0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,
    0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,
    0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,
    0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,
    0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,
    0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,
    0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,
    0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,
    0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,
    0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,
    0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,
    0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,
    0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,
    0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,
    0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,
    0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,
    0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,
    0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,
    0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,
    0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,
    0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,
    0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,
    0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,
    0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,
    0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,
    0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,
    0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,
    0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,
    0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,
    0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,
    0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,
    0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,
};

static const word32 Rijndael_Td0[256] = {
    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
};

static const word32 Rijndael_Td1[256] = {
    0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,
    0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,
    0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,
    0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,
    0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,
    0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,
    0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,
    0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,
    0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,
    0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,
    0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,
    0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,
    0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,
    0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,
    0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,
    0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,
    0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,
    0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,
    0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,
    0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,
    0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,
    0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,
    0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,
    0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,
    0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,
    0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,
    0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,
    0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,
    0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,
    0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,
    0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,
    0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,
    0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,
    0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,
    0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,
    0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,
    0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,
    0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,
    0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,
    0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,
    0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,
    0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,
    0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,
    0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,
    0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,
    0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,
    0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,
    0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,
    0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,
    0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,
    0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,
    0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,
    0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,
    0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,
    0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,
    0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,
    0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,
    0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,
    0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,
    0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,
    0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,
    0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,
    0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,
    0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,
};

static const word32 Rijndael_Td2[256] = {
    0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,
    0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,
    0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,
    0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,
    0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,
    0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,
    0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,
    0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,
    0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,
    0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,
    0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,
    0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,
    0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,
    0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,
    0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,
    0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,
    0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,
    0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,
    0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,
    0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,

    0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,
    0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,
    0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,
    0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,
    0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,
    0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,
    0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,
    0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,
    0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,
    0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,
    0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,
    0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,
    0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,
    0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,
    0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,
    0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,
    0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,
    0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,
    0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,
    0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,
    0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,
    0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,
    0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,
    0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,
    0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,
    0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,
    0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,
    0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,
    0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,
    0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,
    0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,
    0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,
    0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,
    0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,
    0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,
    0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,
    0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,
    0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,
    0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,
    0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,
    0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,
    0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,
    0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,
    0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,
};

static const word32 Rijndael_Td3[256] = {
    0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,
    0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,
    0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,
    0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,
    0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,
    0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,
    0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,
    0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,
    0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,
    0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,
    0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,
    0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,
    0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,
    0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,
    0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,
    0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,
    0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,
    0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,
    0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,
    0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,
    0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,
    0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,
    0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,
    0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,
    0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,
    0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,
    0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,
    0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,
    0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,
    0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,
    0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,
    0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,
    0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,
    0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,
    0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,
    0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,
    0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,
    0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,
    0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,
    0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,
    0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,
    0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,
    0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,
    0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,
    0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,
    0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,
    0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,
    0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,
    0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,
    0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,
    0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,
    0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,
    0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,
    0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,
    0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,
    0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,
    0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,
    0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,
    0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,
    0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,
    0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,
    0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,
    0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,
    0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,
};

static const word32 Rijndael_Td4[256] = {
    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,
    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,
    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,
    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,
    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,
    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,
    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,
    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,
    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,
    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,
    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,
    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,
    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,
    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,
    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,
    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,
    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,
    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,
    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,
    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,
    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,
    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,
    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,
    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,
    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,
    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,
    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,
    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,
    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,
    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,
    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,
    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,
    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,
    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,
    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,
    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,
    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,
    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,
    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,
    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,
    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,
    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,
    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,
    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,
    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,
    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,
    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,
    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,
    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,
    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,
    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,
    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,
    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,
    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,
    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,
    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,
    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,
    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,
    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,
    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,
    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,
    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,
    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,
    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,
};
//-----------------------
static const unsigned char rc2_PITABLE[256] = {
        217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,
        198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,
         23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,
        189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,
         84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,
         18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,
        111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,
        248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,
          8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,
        150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,
        194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,
        153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,
         45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,
        211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,
         13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,
        197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173};
//-----------------------

static const byte PKCS_DigestDecoration_MD2[] = {0x30,0x20,0x30,0x0c,0x06,0x08,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x02,0x02,0x05,0x00,0x04,0x10};
static const byte PKCS_DigestDecoration_MD5[] = {0x30,0x20,0x30,0x0c,0x06,0x08,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x02,0x05,0x05,0x00,0x04,0x10};
static const byte PKCS_DigestDecoration_RIPEMD160[] = {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x24,0x03,0x02,0x01,0x05,0x00,0x04,0x14};
static const byte PKCS_DigestDecoration_Tiger[] = {0x30,0x29,0x30,0x0D,0x06,0x09,0x2B,0x06,0x01,0x04,0x01,0xDA,0x47,0x0C,0x02,0x05,0x00,0x04,0x18};
static const byte PKCS_DigestDecoration_SHA256[] = {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20};
static const byte PKCS_DigestDecoration_SHA384[] = {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30};
static const byte PKCS_DigestDecoration_SHA512[] = {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40};
//--------------------
static const word32 MD5MAC_T[12] =
        { 0xac45ef97,0xcd430f29,0x551b7e45,0x3411801c,
          0x96ce77b1,0x7c8e722e,0x0aab5a5f,0x18be4336,
          0x21b4219d,0x4db987bc,0xbd279da2,0xc3d75bc7 };
//-----------------
static const byte MD2_S[256] = {
        41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6,
        19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188,
        76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24,
        138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251,
        245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63,
        148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50,
        39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165,
        181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210,
        150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157,
        112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27,
        96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15,
        85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197,
        234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65,
        129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123,
        8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233,
        203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228,
        166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237,
        31, 26, 219, 153, 141, 51, 159, 17, 131, 20
};

//-----------------
static const word32 MARS_Sbox[512] = {
  0x09d0c479, 0x28c8ffe0, 0x84aa6c39, 0x9dad7287,
  0x7dff9be3, 0xd4268361, 0xc96da1d4, 0x7974cc93,
  0x85d0582e, 0x2a4b5705, 0x1ca16a62, 0xc3bd279d,
  0x0f1f25e5, 0x5160372f, 0xc695c1fb, 0x4d7ff1e4,
  0xae5f6bf4, 0x0d72ee46, 0xff23de8a, 0xb1cf8e83,
  0xf14902e2, 0x3e981e42, 0x8bf53eb6, 0x7f4bf8ac,
  0x83631f83, 0x25970205, 0x76afe784, 0x3a7931d4,
  0x4f846450, 0x5c64c3f6, 0x210a5f18, 0xc6986a26,
  0x28f4e826, 0x3a60a81c, 0xd340a664, 0x7ea820c4,
  0x526687c5, 0x7eddd12b, 0x32a11d1d, 0x9c9ef086,
  0x80f6e831, 0xab6f04ad, 0x56fb9b53, 0x8b2e095c,
  0xb68556ae, 0xd2250b0d, 0x294a7721, 0xe21fb253,
  0xae136749, 0xe82aae86, 0x93365104, 0x99404a66,
  0x78a784dc, 0xb69ba84b, 0x04046793, 0x23db5c1e,
  0x46cae1d6, 0x2fe28134, 0x5a223942, 0x1863cd5b,
  0xc190c6e3, 0x07dfb846, 0x6eb88816, 0x2d0dcc4a,
  0xa4ccae59, 0x3798670d, 0xcbfa9493, 0x4f481d45,
  0xeafc8ca8, 0xdb1129d6, 0xb0449e20, 0x0f5407fb,
  0x6167d9a8, 0xd1f45763, 0x4daa96c3, 0x3bec5958,
  0xababa014, 0xb6ccd201, 0x38d6279f, 0x02682215,
  0x8f376cd5, 0x092c237e, 0xbfc56593, 0x32889d2c,
  0x854b3e95, 0x05bb9b43, 0x7dcd5dcd, 0xa02e926c,
  0xfae527e5, 0x36a1c330, 0x3412e1ae, 0xf257f462,
  0x3c4f1d71, 0x30a2e809, 0x68e5f551, 0x9c61ba44,
  0x5ded0ab8, 0x75ce09c8, 0x9654f93e, 0x698c0cca,
  0x243cb3e4, 0x2b062b97, 0x0f3b8d9e, 0x00e050df,
  0xfc5d6166, 0xe35f9288, 0xc079550d, 0x0591aee8,
  0x8e531e74, 0x75fe3578, 0x2f6d829a, 0xf60b21ae,
  0x95e8eb8d, 0x6699486b, 0x901d7d9b, 0xfd6d6e31,
  0x1090acef, 0xe0670dd8, 0xdab2e692, 0xcd6d4365,
  0xe5393514, 0x3af345f0, 0x6241fc4d, 0x460da3a3,
  0x7bcf3729, 0x8bf1d1e0, 0x14aac070, 0x1587ed55,
  0x3afd7d3e, 0xd2f29e01, 0x29a9d1f6, 0xefb10c53,
  0xcf3b870f, 0xb414935c, 0x664465ed, 0x024acac7,
  0x59a744c1, 0x1d2936a7, 0xdc580aa6, 0xcf574ca8,
  0x040a7a10, 0x6cd81807, 0x8a98be4c, 0xaccea063,
  0xc33e92b5, 0xd1e0e03d, 0xb322517e, 0x2092bd13,
  0x386b2c4a, 0x52e8dd58, 0x58656dfb, 0x50820371,
  0x41811896, 0xe337ef7e, 0xd39fb119, 0xc97f0df6,
  0x68fea01b, 0xa150a6e5, 0x55258962, 0xeb6ff41b,
  0xd7c9cd7a, 0xa619cd9e, 0xbcf09576, 0x2672c073,
  0xf003fb3c, 0x4ab7a50b, 0x1484126a, 0x487ba9b1,
  0xa64fc9c6, 0xf6957d49, 0x38b06a75, 0xdd805fcd,
  0x63d094cf, 0xf51c999e, 0x1aa4d343, 0xb8495294,
  0xce9f8e99, 0xbffcd770, 0xc7c275cc, 0x378453a7,
  0x7b21be33, 0x397f41bd, 0x4e94d131, 0x92cc1f98,
  0x5915ea51, 0x99f861b7, 0xc9980a88, 0x1d74fd5f,
  0xb0a495f8, 0x614deed0, 0xb5778eea, 0x5941792d,
  0xfa90c1f8, 0x33f824b4, 0xc4965372, 0x3ff6d550,
  0x4ca5fec0, 0x8630e964, 0x5b3fbbd6, 0x7da26a48,
  0xb203231a, 0x04297514, 0x2d639306, 0x2eb13149,
  0x16a45272, 0x532459a0, 0x8e5f4872, 0xf966c7d9,
  0x07128dc0, 0x0d44db62, 0xafc8d52d, 0x06316131,
  0xd838e7ce, 0x1bc41d00, 0x3a2e8c0f, 0xea83837e,
  0xb984737d, 0x13ba4891, 0xc4f8b949, 0xa6d6acb3,
  0xa215cdce, 0x8359838b, 0x6bd1aa31, 0xf579dd52,
  0x21b93f93, 0xf5176781, 0x187dfdde, 0xe94aeb76,
  0x2b38fd54, 0x431de1da, 0xab394825, 0x9ad3048f,
  0xdfea32aa, 0x659473e3, 0x623f7863, 0xf3346c59,
  0xab3ab685, 0x3346a90b, 0x6b56443e, 0xc6de01f8,
  0x8d421fc0, 0x9b0ed10c, 0x88f1a1e9, 0x54c1f029,
  0x7dead57b, 0x8d7ba426, 0x4cf5178a, 0x551a7cca,
  0x1a9a5f08, 0xfcd651b9, 0x25605182, 0xe11fc6c3,
  0xb6fd9676, 0x337b3027, 0xb7c8eb14, 0x9e5fd030,
  0x6b57e354, 0xad913cf7, 0x7e16688d, 0x58872a69,
  0x2c2fc7df, 0xe389ccc6, 0x30738df1, 0x0824a734,
  0xe1797a8b, 0xa4a8d57b, 0x5b5d193b, 0xc8a8309b,
  0x73f9a978, 0x73398d32, 0x0f59573e, 0xe9df2b03,
  0xe8a5b6c8, 0x848d0704, 0x98df93c2, 0x720a1dc3,
  0x684f259a, 0x943ba848, 0xa6370152, 0x863b5ea3,
  0xd17b978b, 0x6d9b58ef, 0x0a700dd4, 0xa73d36bf,
  0x8e6a0829, 0x8695bc14, 0xe35b3447, 0x933ac568,
  0x8894b022, 0x2f511c27, 0xddfbcc3c, 0x006662b6,
  0x117c83fe, 0x4e12b414, 0xc2bca766, 0x3a2fec10,
  0xf4562420, 0x55792e2a, 0x46f5d857, 0xceda25ce,
  0xc3601d3b, 0x6c00ab46, 0xefac9c28, 0xb3c35047,
  0x611dfee3, 0x257c3207, 0xfdd58482, 0x3b14d84f,
  0x23becb64, 0xa075f3a3, 0x088f8ead, 0x07adf158,
  0x7796943c, 0xfacabf3d, 0xc09730cd, 0xf7679969,
  0xda44e9ed, 0x2c854c12, 0x35935fa3, 0x2f057d9f,
  0x690624f8, 0x1cb0bafd, 0x7b0dbdc6, 0x810f23bb,
  0xfa929a1a, 0x6d969a17, 0x6742979b, 0x74ac7d05,
  0x010e65c4, 0x86a3d963, 0xf907b5a0, 0xd0042bd3,
  0x158d7d03, 0x287a8255, 0xbba8366f, 0x096edc33,
  0x21916a7b, 0x77b56b86, 0x951622f9, 0xa6c5e650,
  0x8cea17d1, 0xcd8c62bc, 0xa3d63433, 0x358a68fd,
  0x0f9b9d3c, 0xd6aa295b, 0xfe33384a, 0xc000738e,
  0xcd67eb2f, 0xe2eb6dc2, 0x97338b02, 0x06c9f246,
  0x419cf1ad, 0x2b83c045, 0x3723f18a, 0xcb5b3089,
  0x160bead7, 0x5d494656, 0x35f8a74b, 0x1e4e6c9e,
  0x000399bd, 0x67466880, 0xb4174831, 0xacf423b2,
  0xca815ab3, 0x5a6395e7, 0x302a67c5, 0x8bdb446b,
  0x108f8fa4, 0x10223eda, 0x92b8b48b, 0x7f38d0ee,
  0xab2701d4, 0x0262d415, 0xaf224a30, 0xb3d88aba,
  0xf8b2c3af, 0xdaf7ef70, 0xcc97d3b7, 0xe9614b6c,
  0x2baebff4, 0x70f687cf, 0x386c9156, 0xce092ee5,
  0x01e87da6, 0x6ce91e6a, 0xbb7bcc84, 0xc7922c20,
  0x9d3b71fd, 0x060e41c6, 0xd7590f15, 0x4e03bb47,
  0x183c198e, 0x63eeb240, 0x2ddbf49a, 0x6d5cba54,
  0x923750af, 0xf9e14236, 0x7838162b, 0x59726c72,
  0x81b66760, 0xbb2926c1, 0x48a0ce0d, 0xa6c0496d,
  0xad43507b, 0x718d496a, 0x9df057af, 0x44b1bde6,
  0x054356dc, 0xde7ced35, 0xd51a138b, 0x62088cc9,
  0x35830311, 0xc96efca2, 0x686f86ec, 0x8e77cb68,
  0x63e1d6b8, 0xc80f9778, 0x79c491fd, 0x1b4c67f2,
  0x72698d7d, 0x5e368c31, 0xf7d95e2e, 0xa1d3493f,
  0xdcd9433e, 0x896f1552, 0x4bc4ca7a, 0xa6d1baf4,
  0xa5a96dcc, 0x0bef8b46, 0xa169fda7, 0x74df40b7,
  0x4e208804, 0x9a756607, 0x038e87c8, 0x20211e44,
  0x8b7ad4bf, 0xc6403f35, 0x1848e36d, 0x80bdb038,
  0x1e62891c, 0x643d2107, 0xbf04d6f8, 0x21092c8c,
  0xf644f389, 0x0778404e, 0x7b78adb8, 0xa2c52d53,
  0x42157abe, 0xa2253e2e, 0x7bf3f4ae, 0x80f594f9,
  0x953194e7, 0x77eb92ed, 0xb3816930, 0xda8d9336,
  0xbf447469, 0xf26d9483, 0xee6faed5, 0x71371235,
  0xde425f73, 0xb4e59f43, 0x7dbe2d4e, 0x2d37b185,
  0x49dc9a63, 0x98c39d98, 0x1301c9a2, 0x389b1bbf,
  0x0c18588d, 0xa421c1ba, 0x7aa3865c, 0x71e08558,
  0x3c5cfcaa, 0x7d239ca4, 0x0297d9dd, 0xd7dc2830,
  0x4b37802b, 0x7428ab54, 0xaeee0347, 0x4b3fbb85,
  0x692f2f08, 0x134e578e, 0x36d9e0bf, 0xae8b5fcf,
  0xedb93ecf, 0x2b27248e, 0x170eb1ef, 0x7dc57fd6,
  0x1e760f16, 0xb1136601, 0x864e1b9b, 0xd7ea7319,
  0x3ab871bd, 0xcfa4d76f, 0xe31bd782, 0x0dbeb469,
  0xabb96061, 0x5370f85d, 0xffb07e37, 0xda30d0fb,
  0xebc977b6, 0x0b98b40f, 0x3a4d0fe6, 0xdf4fc26b,
  0x159cf22a, 0xc298d6e2, 0x2b78ef6a, 0x61a94ac0,
  0xab561187, 0x14eea0f0, 0xdf0d4164, 0x19af70ee
};
//--------------

static const unsigned int HAVAL_wi2[32] = { 5,14,26,18,11,28, 7,16, 0,23,20,22, 1,10, 4, 8,30, 3,21, 9,17,24,29, 6,19,12,15,13, 2,25,31,27};
static const unsigned int HAVAL_wi3[32] = {19, 9, 4,20,28,17, 8,22,29,14,25,12,24,30,16,26,31,15, 7, 3, 1, 0,18,27,13, 6,21,10,23,11, 5, 2};
static const unsigned int HAVAL_wi4[32] = {24, 4, 0,14, 2, 7,28,23,26, 6,30,20,18,25,19, 3,22,11,31,21, 8,27,12, 9, 1,29, 5,15,17,10,16,13};
static const unsigned int HAVAL_wi5[32] = {27, 3,21,26,17,11,20,29,19, 0,12, 7,13, 8,31,10, 5, 9,14,30,18, 6,28,24, 2,23,16,22, 4, 1,25,15};

static const word32 HAVAL_mc2[32] = {
  0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C, 0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917
, 0x9216D5D9, 0x8979FB1B, 0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7, 0xB8E1AFED, 0x6A267E96
, 0xBA7C9045, 0xF12C7F99, 0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16, 0x636920D8, 0x71574E69
, 0xA458FEA3, 0xF4933D7E, 0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE, 0x7B54A41D, 0xC25A59B5};

static const word32 HAVAL_mc3[32] = {
0x9C30D539,0x2AF26013,0xC5D1B023,0x286085F0,0xCA417918,0xB8DB38EF,0x8E79DCB0,0x603A180E,
0x6C9E0E8B,0xB01E8A3E,0xD71577C1,0xBD314B27,0x78AF2FDA,0x55605C60,0xE65525F3,0xAA55AB94,
0x57489862,0x63E81440,0x55CA396A,0x2AAB10B6,0xB4CC5C34,0x1141E8CE,0xA15486AF,0x7C72E993,
0xB3EE1411,0x636FBC2A,0x2BA9C55D,0x741831F6,0xCE5C3E16,0x9B87931E,0xAFD6BA33,0x6C24CF5C};

static const word32 HAVAL_mc4[32] = {
0x7A325381,0x28958677,0x3B8F4898,0x6B4BB9AF,0xC4BFE81B,0x66282193,0x61D809CC,0xFB21A991,
0x487CAC60,0x5DEC8032,0xEF845D5D,0xE98575B1,0xDC262302,0xEB651B88,0x23893E81,0xD396ACC5,
0x0F6D6FF3,0x83F44239,0x2E0B4482,0xA4842004,0x69C8F04A,0x9E1F9B5E,0x21C66842,0xF6E96C9A,
0x670C9C61,0xABD388F0,0x6A51A0D2,0xD8542F68,0x960FA728,0xAB5133A3,0x6EEF0B6C,0x137A3BE4};

static const word32 HAVAL_mc5[32] = {
0xBA3BF050,0x7EFB2A98,0xA1F1651D,0x39AF0176,0x66CA593E,0x82430E88,0x8CEE8619,0x456F9FB4,
0x7D84A5C3,0x3B8B5EBE,0xE06F75D8,0x85C12073,0x401A449F,0x56C16AA6,0x4ED3AA62,0x363F7706,
0x1BFEDF72,0x429B023D,0x37D0D724,0xD00A1248,0xDB0FEAD3,0x49F1C09B,0x075372C9,0x80991B7B,
0x25D479D8,0xF6E8DEF7,0xE3FE501A,0xB6794C3B,0x976CE0BD,0x04C006BA,0xC1A94FB6,0x409F60C4};

//----------------
static const byte GOST_sBox[8*16]={
        4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3,
        14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9,
        5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11,
        7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3,
        6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2,
        4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14,
        13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12,
        1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12};

//------------
static const word32 RawDES_Spbox[8*64] = {

0x01010400,0x00000000,0x00010000,0x01010404, 0x01010004,0x00010404,0x00000004,0x00010000,
0x00000400,0x01010400,0x01010404,0x00000400, 0x01000404,0x01010004,0x01000000,0x00000004,
0x00000404,0x01000400,0x01000400,0x00010400, 0x00010400,0x01010000,0x01010000,0x01000404,
0x00010004,0x01000004,0x01000004,0x00010004, 0x00000000,0x00000404,0x00010404,0x01000000,
0x00010000,0x01010404,0x00000004,0x01010000, 0x01010400,0x01000000,0x01000000,0x00000400,
0x01010004,0x00010000,0x00010400,0x01000004, 0x00000400,0x00000004,0x01000404,0x00010404,
0x01010404,0x00010004,0x01010000,0x01000404, 0x01000004,0x00000404,0x00010404,0x01010400,
0x00000404,0x01000400,0x01000400,0x00000000, 0x00010004,0x00010400,0x00000000,0x01010004,

0x80108020,0x80008000,0x00008000,0x00108020, 0x00100000,0x00000020,0x80100020,0x80008020,
0x80000020,0x80108020,0x80108000,0x80000000, 0x80008000,0x00100000,0x00000020,0x80100020,
0x00108000,0x00100020,0x80008020,0x00000000, 0x80000000,0x00008000,0x00108020,0x80100000,
0x00100020,0x80000020,0x00000000,0x00108000, 0x00008020,0x80108000,0x80100000,0x00008020,
0x00000000,0x00108020,0x80100020,0x00100000, 0x80008020,0x80100000,0x80108000,0x00008000,
0x80100000,0x80008000,0x00000020,0x80108020, 0x00108020,0x00000020,0x00008000,0x80000000,
0x00008020,0x80108000,0x00100000,0x80000020, 0x00100020,0x80008020,0x80000020,0x00100020,
0x00108000,0x00000000,0x80008000,0x00008020, 0x80000000,0x80100020,0x80108020,0x00108000,

0x00000208,0x08020200,0x00000000,0x08020008, 0x08000200,0x00000000,0x00020208,0x08000200,
0x00020008,0x08000008,0x08000008,0x00020000, 0x08020208,0x00020008,0x08020000,0x00000208,
0x08000000,0x00000008,0x08020200,0x00000200, 0x00020200,0x08020000,0x08020008,0x00020208,
0x08000208,0x00020200,0x00020000,0x08000208, 0x00000008,0x08020208,0x00000200,0x08000000,
0x08020200,0x08000000,0x00020008,0x00000208, 0x00020000,0x08020200,0x08000200,0x00000000,
0x00000200,0x00020008,0x08020208,0x08000200, 0x08000008,0x00000200,0x00000000,0x08020008,
0x08000208,0x00020000,0x08000000,0x08020208, 0x00000008,0x00020208,0x00020200,0x08000008,
0x08020000,0x08000208,0x00000208,0x08020000, 0x00020208,0x00000008,0x08020008,0x00020200,

0x00802001,0x00002081,0x00002081,0x00000080, 0x00802080,0x00800081,0x00800001,0x00002001,
0x00000000,0x00802000,0x00802000,0x00802081, 0x00000081,0x00000000,0x00800080,0x00800001,
0x00000001,0x00002000,0x00800000,0x00802001, 0x00000080,0x00800000,0x00002001,0x00002080,
0x00800081,0x00000001,0x00002080,0x00800080, 0x00002000,0x00802080,0x00802081,0x00000081,
0x00800080,0x00800001,0x00802000,0x00802081, 0x00000081,0x00000000,0x00000000,0x00802000,
0x00002080,0x00800080,0x00800081,0x00000001, 0x00802001,0x00002081,0x00002081,0x00000080,
0x00802081,0x00000081,0x00000001,0x00002000, 0x00800001,0x00002001,0x00802080,0x00800081,
0x00002001,0x00002080,0x00800000,0x00802001, 0x00000080,0x00800000,0x00002000,0x00802080,

0x00000100,0x02080100,0x02080000,0x42000100, 0x00080000,0x00000100,0x40000000,0x02080000,
0x40080100,0x00080000,0x02000100,0x40080100, 0x42000100,0x42080000,0x00080100,0x40000000,
0x02000000,0x40080000,0x40080000,0x00000000, 0x40000100,0x42080100,0x42080100,0x02000100,
0x42080000,0x40000100,0x00000000,0x42000000, 0x02080100,0x02000000,0x42000000,0x00080100,
0x00080000,0x42000100,0x00000100,0x02000000, 0x40000000,0x02080000,0x42000100,0x40080100,
0x02000100,0x40000000,0x42080000,0x02080100, 0x40080100,0x00000100,0x02000000,0x42080000,
0x42080100,0x00080100,0x42000000,0x42080100, 0x02080000,0x00000000,0x40080000,0x42000000,
0x00080100,0x02000100,0x40000100,0x00080000, 0x00000000,0x40080000,0x02080100,0x40000100,

0x20000010,0x20400000,0x00004000,0x20404010, 0x20400000,0x00000010,0x20404010,0x00400000,
0x20004000,0x00404010,0x00400000,0x20000010, 0x00400010,0x20004000,0x20000000,0x00004010,
0x00000000,0x00400010,0x20004010,0x00004000, 0x00404000,0x20004010,0x00000010,0x20400010,
0x20400010,0x00000000,0x00404010,0x20404000, 0x00004010,0x00404000,0x20404000,0x20000000,
0x20004000,0x00000010,0x20400010,0x00404000, 0x20404010,0x00400000,0x00004010,0x20000010,
0x00400000,0x20004000,0x20000000,0x00004010, 0x20000010,0x20404010,0x00404000,0x20400000,
0x00404010,0x20404000,0x00000000,0x20400010, 0x00000010,0x00004000,0x20400000,0x00404010,
0x00004000,0x00400010,0x20004010,0x00000000, 0x20404000,0x20000000,0x00400010,0x20004010,

0x00200000,0x04200002,0x04000802,0x00000000, 0x00000800,0x04000802,0x00200802,0x04200800,
0x04200802,0x00200000,0x00000000,0x04000002, 0x00000002,0x04000000,0x04200002,0x00000802,
0x04000800,0x00200802,0x00200002,0x04000800, 0x04000002,0x04200000,0x04200800,0x00200002,
0x04200000,0x00000800,0x00000802,0x04200802, 0x00200800,0x00000002,0x04000000,0x00200800,
0x04000000,0x00200800,0x00200000,0x04000802, 0x04000802,0x04200002,0x04200002,0x00000002,
0x00200002,0x04000000,0x04000800,0x00200000, 0x04200800,0x00000802,0x00200802,0x04200800,
0x00000802,0x04000002,0x04200802,0x04200000, 0x00200800,0x00000000,0x00000002,0x04200802,
0x00000000,0x00200802,0x04200000,0x00000800, 0x04000002,0x04000800,0x00000800,0x00200002,

0x10001040,0x00001000,0x00040000,0x10041040, 0x10000000,0x10001040,0x00000040,0x10000000,
0x00040040,0x10040000,0x10041040,0x00041000, 0x10041000,0x00041040,0x00001000,0x00000040,
0x10040000,0x10000040,0x10001000,0x00001040, 0x00041000,0x00040040,0x10040040,0x10041000,
0x00001040,0x00000000,0x00000000,0x10040040, 0x10000040,0x10001000,0x00041040,0x00040000,
0x00041040,0x00040000,0x10041000,0x00001000, 0x00000040,0x10040040,0x00001000,0x00041040,
0x10001000,0x00000040,0x10000040,0x10040000, 0x10040040,0x10000000,0x00040000,0x10001040,
0x00000000,0x10041040,0x00040040,0x10000040, 0x10040000,0x10001000,0x10001040,0x00000000,
0x10041040,0x00041000,0x00041000,0x00001040, 0x00001040,0x00040040,0x10000000,0x10041000
};
//------------------
static const byte DES_ip[] = {
           58, 50, 42, 34, 26, 18, 10,  2,
           60, 52, 44, 36, 28, 20, 12,  4,
           62, 54, 46, 38, 30, 22, 14,  6,
           64, 56, 48, 40, 32, 24, 16,  8,
           57, 49, 41, 33, 25, 17,  9,  1,
           59, 51, 43, 35, 27, 19, 11,  3,
           61, 53, 45, 37, 29, 21, 13,  5,
           63, 55, 47, 39, 31, 23, 15,  7
};

/* final permutation IP^-1 */
static const byte DES_fp[] = {
           40,  8, 48, 16, 56, 24, 64, 32,
           39,  7, 47, 15, 55, 23, 63, 31,
           38,  6, 46, 14, 54, 22, 62, 30,
           37,  5, 45, 13, 53, 21, 61, 29,
           36,  4, 44, 12, 52, 20, 60, 28,
           35,  3, 43, 11, 51, 19, 59, 27,
           34,  2, 42, 10, 50, 18, 58, 26,
           33,  1, 41,  9, 49, 17, 57, 25
};
/* expansion operation matrix */
static const byte DES_ei[] = {
           32,  1,  2,  3,  4,  5,
                4,  5,  6,  7,  8,  9,
                8,  9, 10, 11, 12, 13,
           12, 13, 14, 15, 16, 17,
           16, 17, 18, 19, 20, 21,
           20, 21, 22, 23, 24, 25,
           24, 25, 26, 27, 28, 29,
           28, 29, 30, 31, 32,  1
};
/* The (in)famous S-boxes */
static const byte DES_sbox[8*64] = {
           /* S1 */
           14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
                0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
                4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
           15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13,

           /* S2 */
           15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
                3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
                0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
           13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9,

           /* S3 */
           10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
           13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
           13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
                1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12,

           /* S4 */
                7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
           13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
           10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
                3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14,

           /* S5 */
                2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
           14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
                4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
           11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3,

           /* S6 */
           12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
           10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
                9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
                4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13,

           /* S7 */
                4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
           13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
                1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
                6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12,

           /* S8 */
           13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
                1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
                7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
                2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11
};

/* 32-bit permutation function P used on the output of the S-boxes */
static const byte DES_p32i[] = {
           16,  7, 20, 21,
           29, 12, 28, 17,
                1, 15, 23, 26,
                5, 18, 31, 10,
                2,  8, 24, 14,
           32, 27,  3,  9,
           19, 13, 30,  6,
           22, 11,  4, 25
};

/* permuted choice table (key) */
static const byte DES_pc1[] = {
           57, 49, 41, 33, 25, 17,  9,
                1, 58, 50, 42, 34, 26, 18,
           10,  2, 59, 51, 43, 35, 27,
           19, 11,  3, 60, 52, 44, 36,

           63, 55, 47, 39, 31, 23, 15,
                7, 62, 54, 46, 38, 30, 22,
           14,  6, 61, 53, 45, 37, 29,
           21, 13,  5, 28, 20, 12,  4
};

/* permuted choice key (table) */
static const byte DES_pc2[] = {
           14, 17, 11, 24,  1,  5,
                3, 28, 15,  6, 21, 10,
           23, 19, 12,  4, 26,  8,
           16,  7, 27, 20, 13,  2,
           41, 52, 31, 37, 47, 55,
           30, 40, 51, 45, 33, 48,
           44, 49, 39, 56, 34, 53,
           46, 42, 50, 36, 29, 32
};
//-----------------
static const word32 CRC32_m_tab[] = {
#ifdef IS_LITTLE_ENDIAN
        0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
        0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
        0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
        0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
        0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
        0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
        0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
        0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
        0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
        0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
        0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
        0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
        0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
        0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
        0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
        0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
        0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
        0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
        0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
        0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
        0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
        0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
        0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
        0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
        0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
        0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
        0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
        0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
        0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
        0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
        0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
        0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
        0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
        0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
        0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
        0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
        0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
        0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
        0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
        0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
        0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
        0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
        0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
        0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
        0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
        0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
        0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
        0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
        0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
        0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
        0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
        0x2d02ef8dL
#else
        0x00000000L, 0x96300777L, 0x2c610eeeL, 0xba510999L, 0x19c46d07L,
        0x8ff46a70L, 0x35a563e9L, 0xa395649eL, 0x3288db0eL, 0xa4b8dc79L,
        0x1ee9d5e0L, 0x88d9d297L, 0x2b4cb609L, 0xbd7cb17eL, 0x072db8e7L,
        0x911dbf90L, 0x6410b71dL, 0xf220b06aL, 0x4871b9f3L, 0xde41be84L,
        0x7dd4da1aL, 0xebe4dd6dL, 0x51b5d4f4L, 0xc785d383L, 0x56986c13L,
        0xc0a86b64L, 0x7af962fdL, 0xecc9658aL, 0x4f5c0114L, 0xd96c0663L,
        0x633d0ffaL, 0xf50d088dL, 0xc8206e3bL, 0x5e10694cL, 0xe44160d5L,
        0x727167a2L, 0xd1e4033cL, 0x47d4044bL, 0xfd850dd2L, 0x6bb50aa5L,
        0xfaa8b535L, 0x6c98b242L, 0xd6c9bbdbL, 0x40f9bcacL, 0xe36cd832L,
        0x755cdf45L, 0xcf0dd6dcL, 0x593dd1abL, 0xac30d926L, 0x3a00de51L,
        0x8051d7c8L, 0x1661d0bfL, 0xb5f4b421L, 0x23c4b356L, 0x9995bacfL,
        0x0fa5bdb8L, 0x9eb80228L, 0x0888055fL, 0xb2d90cc6L, 0x24e90bb1L,
        0x877c6f2fL, 0x114c6858L, 0xab1d61c1L, 0x3d2d66b6L, 0x9041dc76L,
        0x0671db01L, 0xbc20d298L, 0x2a10d5efL, 0x8985b171L, 0x1fb5b606L,
        0xa5e4bf9fL, 0x33d4b8e8L, 0xa2c90778L, 0x34f9000fL, 0x8ea80996L,
        0x18980ee1L, 0xbb0d6a7fL, 0x2d3d6d08L, 0x976c6491L, 0x015c63e6L,
        0xf4516b6bL, 0x62616c1cL, 0xd8306585L, 0x4e0062f2L, 0xed95066cL,
        0x7ba5011bL, 0xc1f40882L, 0x57c40ff5L, 0xc6d9b065L, 0x50e9b712L,
        0xeab8be8bL, 0x7c88b9fcL, 0xdf1ddd62L, 0x492dda15L, 0xf37cd38cL,
        0x654cd4fbL, 0x5861b24dL, 0xce51b53aL, 0x7400bca3L, 0xe230bbd4L,
        0x41a5df4aL, 0xd795d83dL, 0x6dc4d1a4L, 0xfbf4d6d3L, 0x6ae96943L,
        0xfcd96e34L, 0x468867adL, 0xd0b860daL, 0x732d0444L, 0xe51d0333L,
        0x5f4c0aaaL, 0xc97c0dddL, 0x3c710550L, 0xaa410227L, 0x10100bbeL,
        0x86200cc9L, 0x25b56857L, 0xb3856f20L, 0x09d466b9L, 0x9fe461ceL,
        0x0ef9de5eL, 0x98c9d929L, 0x2298d0b0L, 0xb4a8d7c7L, 0x173db359L,
        0x810db42eL, 0x3b5cbdb7L, 0xad6cbac0L, 0x2083b8edL, 0xb6b3bf9aL,
        0x0ce2b603L, 0x9ad2b174L, 0x3947d5eaL, 0xaf77d29dL, 0x1526db04L,
        0x8316dc73L, 0x120b63e3L, 0x843b6494L, 0x3e6a6d0dL, 0xa85a6a7aL,
        0x0bcf0ee4L, 0x9dff0993L, 0x27ae000aL, 0xb19e077dL, 0x44930ff0L,
        0xd2a30887L, 0x68f2011eL, 0xfec20669L, 0x5d5762f7L, 0xcb676580L,
        0x71366c19L, 0xe7066b6eL, 0x761bd4feL, 0xe02bd389L, 0x5a7ada10L,
        0xcc4add67L, 0x6fdfb9f9L, 0xf9efbe8eL, 0x43beb717L, 0xd58eb060L,
        0xe8a3d6d6L, 0x7e93d1a1L, 0xc4c2d838L, 0x52f2df4fL, 0xf167bbd1L,
        0x6757bca6L, 0xdd06b53fL, 0x4b36b248L, 0xda2b0dd8L, 0x4c1b0aafL,
        0xf64a0336L, 0x607a0441L, 0xc3ef60dfL, 0x55df67a8L, 0xef8e6e31L,
        0x79be6946L, 0x8cb361cbL, 0x1a8366bcL, 0xa0d26f25L, 0x36e26852L,
        0x95770cccL, 0x03470bbbL, 0xb9160222L, 0x2f260555L, 0xbe3bbac5L,
        0x280bbdb2L, 0x925ab42bL, 0x046ab35cL, 0xa7ffd7c2L, 0x31cfd0b5L,
        0x8b9ed92cL, 0x1daede5bL, 0xb0c2649bL, 0x26f263ecL, 0x9ca36a75L,
        0x0a936d02L, 0xa906099cL, 0x3f360eebL, 0x85670772L, 0x13570005L,
        0x824abf95L, 0x147ab8e2L, 0xae2bb17bL, 0x381bb60cL, 0x9b8ed292L,
        0x0dbed5e5L, 0xb7efdc7cL, 0x21dfdb0bL, 0xd4d2d386L, 0x42e2d4f1L,
        0xf8b3dd68L, 0x6e83da1fL, 0xcd16be81L, 0x5b26b9f6L, 0xe177b06fL,
        0x7747b718L, 0xe65a0888L, 0x706a0fffL, 0xca3b0666L, 0x5c0b0111L,
        0xff9e658fL, 0x69ae62f8L, 0xd3ff6b61L, 0x45cf6c16L, 0x78e20aa0L,
        0xeed20dd7L, 0x5483044eL, 0xc2b30339L, 0x612667a7L, 0xf71660d0L,
        0x4d476949L, 0xdb776e3eL, 0x4a6ad1aeL, 0xdc5ad6d9L, 0x660bdf40L,
        0xf03bd837L, 0x53aebca9L, 0xc59ebbdeL, 0x7fcfb247L, 0xe9ffb530L,
        0x1cf2bdbdL, 0x8ac2bacaL, 0x3093b353L, 0xa6a3b424L, 0x0536d0baL,
        0x9306d7cdL, 0x2957de54L, 0xbf67d923L, 0x2e7a66b3L, 0xb84a61c4L,
        0x021b685dL, 0x942b6f2aL, 0x37be0bb4L, 0xa18e0cc3L, 0x1bdf055aL,
        0x8def022dL
#endif
};

//-----------------

static const word32 CAST_S[8*256] = {

        0x30FB40D4UL, 0x9FA0FF0BUL, 0x6BECCD2FUL, 0x3F258C7AUL,
        0x1E213F2FUL, 0x9C004DD3UL, 0x6003E540UL, 0xCF9FC949UL,
        0xBFD4AF27UL, 0x88BBBDB5UL, 0xE2034090UL, 0x98D09675UL,
        0x6E63A0E0UL, 0x15C361D2UL, 0xC2E7661DUL, 0x22D4FF8EUL,
        0x28683B6FUL, 0xC07FD059UL, 0xFF2379C8UL, 0x775F50E2UL,
        0x43C340D3UL, 0xDF2F8656UL, 0x887CA41AUL, 0xA2D2BD2DUL,
        0xA1C9E0D6UL, 0x346C4819UL, 0x61B76D87UL, 0x22540F2FUL,
        0x2ABE32E1UL, 0xAA54166BUL, 0x22568E3AUL, 0xA2D341D0UL,
        0x66DB40C8UL, 0xA784392FUL, 0x004DFF2FUL, 0x2DB9D2DEUL,
        0x97943FACUL, 0x4A97C1D8UL, 0x527644B7UL, 0xB5F437A7UL,
        0xB82CBAEFUL, 0xD751D159UL, 0x6FF7F0EDUL, 0x5A097A1FUL,
        0x827B68D0UL, 0x90ECF52EUL, 0x22B0C054UL, 0xBC8E5935UL,
        0x4B6D2F7FUL, 0x50BB64A2UL, 0xD2664910UL, 0xBEE5812DUL,
        0xB7332290UL, 0xE93B159FUL, 0xB48EE411UL, 0x4BFF345DUL,
        0xFD45C240UL, 0xAD31973FUL, 0xC4F6D02EUL, 0x55FC8165UL,
        0xD5B1CAADUL, 0xA1AC2DAEUL, 0xA2D4B76DUL, 0xC19B0C50UL,
        0x882240F2UL, 0x0C6E4F38UL, 0xA4E4BFD7UL, 0x4F5BA272UL,
        0x564C1D2FUL, 0xC59C5319UL, 0xB949E354UL, 0xB04669FEUL,
        0xB1B6AB8AUL, 0xC71358DDUL, 0x6385C545UL, 0x110F935DUL,
        0x57538AD5UL, 0x6A390493UL, 0xE63D37E0UL, 0x2A54F6B3UL,
        0x3A787D5FUL, 0x6276A0B5UL, 0x19A6FCDFUL, 0x7A42206AUL,
        0x29F9D4D5UL, 0xF61B1891UL, 0xBB72275EUL, 0xAA508167UL,
        0x38901091UL, 0xC6B505EBUL, 0x84C7CB8CUL, 0x2AD75A0FUL,
        0x874A1427UL, 0xA2D1936BUL, 0x2AD286AFUL, 0xAA56D291UL,
        0xD7894360UL, 0x425C750DUL, 0x93B39E26UL, 0x187184C9UL,
        0x6C00B32DUL, 0x73E2BB14UL, 0xA0BEBC3CUL, 0x54623779UL,
        0x64459EABUL, 0x3F328B82UL, 0x7718CF82UL, 0x59A2CEA6UL,
        0x04EE002EUL, 0x89FE78E6UL, 0x3FAB0950UL, 0x325FF6C2UL,
        0x81383F05UL, 0x6963C5C8UL, 0x76CB5AD6UL, 0xD49974C9UL,
        0xCA180DCFUL, 0x380782D5UL, 0xC7FA5CF6UL, 0x8AC31511UL,
        0x35E79E13UL, 0x47DA91D0UL, 0xF40F9086UL, 0xA7E2419EUL,
        0x31366241UL, 0x051EF495UL, 0xAA573B04UL, 0x4A805D8DUL,
        0x548300D0UL, 0x00322A3CUL, 0xBF64CDDFUL, 0xBA57A68EUL,
        0x75C6372BUL, 0x50AFD341UL, 0xA7C13275UL, 0x915A0BF5UL,
        0x6B54BFABUL, 0x2B0B1426UL, 0xAB4CC9D7UL, 0x449CCD82UL,
        0xF7FBF265UL, 0xAB85C5F3UL, 0x1B55DB94UL, 0xAAD4E324UL,
        0xCFA4BD3FUL, 0x2DEAA3E2UL, 0x9E204D02UL, 0xC8BD25ACUL,
        0xEADF55B3UL, 0xD5BD9E98UL, 0xE31231B2UL, 0x2AD5AD6CUL,
        0x954329DEUL, 0xADBE4528UL, 0xD8710F69UL, 0xAA51C90FUL,
        0xAA786BF6UL, 0x22513F1EUL, 0xAA51A79BUL, 0x2AD344CCUL,
        0x7B5A41F0UL, 0xD37CFBADUL, 0x1B069505UL, 0x41ECE491UL,
        0xB4C332E6UL, 0x032268D4UL, 0xC9600ACCUL, 0xCE387E6DUL,
        0xBF6BB16CUL, 0x6A70FB78UL, 0x0D03D9C9UL, 0xD4DF39DEUL,
        0xE01063DAUL, 0x4736F464UL, 0x5AD328D8UL, 0xB347CC96UL,
        0x75BB0FC3UL, 0x98511BFBUL, 0x4FFBCC35UL, 0xB58BCF6AUL,
        0xE11F0ABCUL, 0xBFC5FE4AUL, 0xA70AEC10UL, 0xAC39570AUL,
        0x3F04442FUL, 0x6188B153UL, 0xE0397A2EUL, 0x5727CB79UL,
        0x9CEB418FUL, 0x1CACD68DUL, 0x2AD37C96UL, 0x0175CB9DUL,
        0xC69DFF09UL, 0xC75B65F0UL, 0xD9DB40D8UL, 0xEC0E7779UL,
        0x4744EAD4UL, 0xB11C3274UL, 0xDD24CB9EUL, 0x7E1C54BDUL,
        0xF01144F9UL, 0xD2240EB1UL, 0x9675B3FDUL, 0xA3AC3755UL,
        0xD47C27AFUL, 0x51C85F4DUL, 0x56907596UL, 0xA5BB15E6UL,
        0x580304F0UL, 0xCA042CF1UL, 0x011A37EAUL, 0x8DBFAADBUL,
        0x35BA3E4AUL, 0x3526FFA0UL, 0xC37B4D09UL, 0xBC306ED9UL,
        0x98A52666UL, 0x5648F725UL, 0xFF5E569DUL, 0x0CED63D0UL,
        0x7C63B2CFUL, 0x700B45E1UL, 0xD5EA50F1UL, 0x85A92872UL,
        0xAF1FBDA7UL, 0xD4234870UL, 0xA7870BF3UL, 0x2D3B4D79UL,
        0x42E04198UL, 0x0CD0EDE7UL, 0x26470DB8UL, 0xF881814CUL,
        0x474D6AD7UL, 0x7C0C5E5CUL, 0xD1231959UL, 0x381B7298UL,
        0xF5D2F4DBUL, 0xAB838653UL, 0x6E2F1E23UL, 0x83719C9EUL,
        0xBD91E046UL, 0x9A56456EUL, 0xDC39200CUL, 0x20C8C571UL,
        0x962BDA1CUL, 0xE1E696FFUL, 0xB141AB08UL, 0x7CCA89B9UL,
        0x1A69E783UL, 0x02CC4843UL, 0xA2F7C579UL, 0x429EF47DUL,
        0x427B169CUL, 0x5AC9F049UL, 0xDD8F0F00UL, 0x5C8165BFUL
,


        0x1F201094UL, 0xEF0BA75BUL, 0x69E3CF7EUL, 0x393F4380UL,
        0xFE61CF7AUL, 0xEEC5207AUL, 0x55889C94UL, 0x72FC0651UL,
        0xADA7EF79UL, 0x4E1D7235UL, 0xD55A63CEUL, 0xDE0436BAUL,
        0x99C430EFUL, 0x5F0C0794UL, 0x18DCDB7DUL, 0xA1D6EFF3UL,
        0xA0B52F7BUL, 0x59E83605UL, 0xEE15B094UL, 0xE9FFD909UL,
        0xDC440086UL, 0xEF944459UL, 0xBA83CCB3UL, 0xE0C3CDFBUL,
        0xD1DA4181UL, 0x3B092AB1UL, 0xF997F1C1UL, 0xA5E6CF7BUL,
        0x01420DDBUL, 0xE4E7EF5BUL, 0x25A1FF41UL, 0xE180F806UL,
        0x1FC41080UL, 0x179BEE7AUL, 0xD37AC6A9UL, 0xFE5830A4UL,
        0x98DE8B7FUL, 0x77E83F4EUL, 0x79929269UL, 0x24FA9F7BUL,
        0xE113C85BUL, 0xACC40083UL, 0xD7503525UL, 0xF7EA615FUL,
        0x62143154UL, 0x0D554B63UL, 0x5D681121UL, 0xC866C359UL,
        0x3D63CF73UL, 0xCEE234C0UL, 0xD4D87E87UL, 0x5C672B21UL,
        0x071F6181UL, 0x39F7627FUL, 0x361E3084UL, 0xE4EB573BUL,
        0x602F64A4UL, 0xD63ACD9CUL, 0x1BBC4635UL, 0x9E81032DUL,
        0x2701F50CUL, 0x99847AB4UL, 0xA0E3DF79UL, 0xBA6CF38CUL,
        0x10843094UL, 0x2537A95EUL, 0xF46F6FFEUL, 0xA1FF3B1FUL,
        0x208CFB6AUL, 0x8F458C74UL, 0xD9E0A227UL, 0x4EC73A34UL,
        0xFC884F69UL, 0x3E4DE8DFUL, 0xEF0E0088UL, 0x3559648DUL,
        0x8A45388CUL, 0x1D804366UL, 0x721D9BFDUL, 0xA58684BBUL,
        0xE8256333UL, 0x844E8212UL, 0x128D8098UL, 0xFED33FB4UL,
        0xCE280AE1UL, 0x27E19BA5UL, 0xD5A6C252UL, 0xE49754BDUL,
        0xC5D655DDUL, 0xEB667064UL, 0x77840B4DUL, 0xA1B6A801UL,
        0x84DB26A9UL, 0xE0B56714UL, 0x21F043B7UL, 0xE5D05860UL,
        0x54F03084UL, 0x066FF472UL, 0xA31AA153UL, 0xDADC4755UL,
        0xB5625DBFUL, 0x68561BE6UL, 0x83CA6B94UL, 0x2D6ED23BUL,
        0xECCF01DBUL, 0xA6D3D0BAUL, 0xB6803D5CUL, 0xAF77A709UL,
        0x33B4A34CUL, 0x397BC8D6UL, 0x5EE22B95UL, 0x5F0E5304UL,
        0x81ED6F61UL, 0x20E74364UL, 0xB45E1378UL, 0xDE18639BUL,
        0x881CA122UL, 0xB96726D1UL, 0x8049A7E8UL, 0x22B7DA7BUL,
        0x5E552D25UL, 0x5272D237UL, 0x79D2951CUL, 0xC60D894CUL,
        0x488CB402UL, 0x1BA4FE5BUL, 0xA4B09F6BUL, 0x1CA815CFUL,
        0xA20C3005UL, 0x8871DF63UL, 0xB9DE2FCBUL, 0x0CC6C9E9UL,
        0x0BEEFF53UL, 0xE3214517UL, 0xB4542835UL, 0x9F63293CUL,
        0xEE41E729UL, 0x6E1D2D7CUL, 0x50045286UL, 0x1E6685F3UL,
        0xF33401C6UL, 0x30A22C95UL, 0x31A70850UL, 0x60930F13UL,
        0x73F98417UL, 0xA1269859UL, 0xEC645C44UL, 0x52C877A9UL,
        0xCDFF33A6UL, 0xA02B1741UL, 0x7CBAD9A2UL, 0x2180036FUL,
        0x50D99C08UL, 0xCB3F4861UL, 0xC26BD765UL, 0x64A3F6ABUL,
        0x80342676UL, 0x25A75E7BUL, 0xE4E6D1FCUL, 0x20C710E6UL,
        0xCDF0B680UL, 0x17844D3BUL, 0x31EEF84DUL, 0x7E0824E4UL,
        0x2CCB49EBUL, 0x846A3BAEUL, 0x8FF77888UL, 0xEE5D60F6UL,
        0x7AF75673UL, 0x2FDD5CDBUL, 0xA11631C1UL, 0x30F66F43UL,
        0xB3FAEC54UL, 0x157FD7FAUL, 0xEF8579CCUL, 0xD152DE58UL,
        0xDB2FFD5EUL, 0x8F32CE19UL, 0x306AF97AUL, 0x02F03EF8UL,
        0x99319AD5UL, 0xC242FA0FUL, 0xA7E3EBB0UL, 0xC68E4906UL,
        0xB8DA230CUL, 0x80823028UL, 0xDCDEF3C8UL, 0xD35FB171UL,
        0x088A1BC8UL, 0xBEC0C560UL, 0x61A3C9E8UL, 0xBCA8F54DUL,
        0xC72FEFFAUL, 0x22822E99UL, 0x82C570B4UL, 0xD8D94E89UL,
        0x8B1C34BCUL, 0x301E16E6UL, 0x273BE979UL, 0xB0FFEAA6UL,
        0x61D9B8C6UL, 0x00B24869UL, 0xB7FFCE3FUL, 0x08DC283BUL,
        0x43DAF65AUL, 0xF7E19798UL, 0x7619B72FUL, 0x8F1C9BA4UL,
        0xDC8637A0UL, 0x16A7D3B1UL, 0x9FC393B7UL, 0xA7136EEBUL,
        0xC6BCC63EUL, 0x1A513742UL, 0xEF6828BCUL, 0x520365D6UL,
        0x2D6A77ABUL, 0x3527ED4BUL, 0x821FD216UL, 0x095C6E2EUL,
        0xDB92F2FBUL, 0x5EEA29CBUL, 0x145892F5UL, 0x91584F7FUL,
        0x5483697BUL, 0x2667A8CCUL, 0x85196048UL, 0x8C4BACEAUL,
        0x833860D4UL, 0x0D23E0F9UL, 0x6C387E8AUL, 0x0AE6D249UL,
        0xB284600CUL, 0xD835731DUL, 0xDCB1C647UL, 0xAC4C56EAUL,
        0x3EBD81B3UL, 0x230EABB0UL, 0x6438BC87UL, 0xF0B5B1FAUL,
        0x8F5EA2B3UL, 0xFC184642UL, 0x0A036B7AUL, 0x4FB089BDUL,
        0x649DA589UL, 0xA345415EUL, 0x5C038323UL, 0x3E5D3BB9UL,
        0x43D79572UL, 0x7E6DD07CUL, 0x06DFDF1EUL, 0x6C6CC4EFUL,
        0x7160A539UL, 0x73BFBE70UL, 0x83877605UL, 0x4523ECF1UL
,


        0x8DEFC240UL, 0x25FA5D9FUL, 0xEB903DBFUL, 0xE810C907UL,
        0x47607FFFUL, 0x369FE44BUL, 0x8C1FC644UL, 0xAECECA90UL,
        0xBEB1F9BFUL, 0xEEFBCAEAUL, 0xE8CF1950UL, 0x51DF07AEUL,
        0x920E8806UL, 0xF0AD0548UL, 0xE13C8D83UL, 0x927010D5UL,
        0x11107D9FUL, 0x07647DB9UL, 0xB2E3E4D4UL, 0x3D4F285EUL,
        0xB9AFA820UL, 0xFADE82E0UL, 0xA067268BUL, 0x8272792EUL,
        0x553FB2C0UL, 0x489AE22BUL, 0xD4EF9794UL, 0x125E3FBCUL,
        0x21FFFCEEUL, 0x825B1BFDUL, 0x9255C5EDUL, 0x1257A240UL,
        0x4E1A8302UL, 0xBAE07FFFUL, 0x528246E7UL, 0x8E57140EUL,
        0x3373F7BFUL, 0x8C9F8188UL, 0xA6FC4EE8UL, 0xC982B5A5UL,
        0xA8C01DB7UL, 0x579FC264UL, 0x67094F31UL, 0xF2BD3F5FUL,
        0x40FFF7C1UL, 0x1FB78DFCUL, 0x8E6BD2C1UL, 0x437BE59BUL,
        0x99B03DBFUL, 0xB5DBC64BUL, 0x638DC0E6UL, 0x55819D99UL,
        0xA197C81CUL, 0x4A012D6EUL, 0xC5884A28UL, 0xCCC36F71UL,
        0xB843C213UL, 0x6C0743F1UL, 0x8309893CUL, 0x0FEDDD5FUL,
        0x2F7FE850UL, 0xD7C07F7EUL, 0x02507FBFUL, 0x5AFB9A04UL,
        0xA747D2D0UL, 0x1651192EUL, 0xAF70BF3EUL, 0x58C31380UL,
        0x5F98302EUL, 0x727CC3C4UL, 0x0A0FB402UL, 0x0F7FEF82UL,
        0x8C96FDADUL, 0x5D2C2AAEUL, 0x8EE99A49UL, 0x50DA88B8UL,
        0x8427F4A0UL, 0x1EAC5790UL, 0x796FB449UL, 0x8252DC15UL,
        0xEFBD7D9BUL, 0xA672597DUL, 0xADA840D8UL, 0x45F54504UL,
        0xFA5D7403UL, 0xE83EC305UL, 0x4F91751AUL, 0x925669C2UL,
        0x23EFE941UL, 0xA903F12EUL, 0x60270DF2UL, 0x0276E4B6UL,
        0x94FD6574UL, 0x927985B2UL, 0x8276DBCBUL, 0x02778176UL,
        0xF8AF918DUL, 0x4E48F79EUL, 0x8F616DDFUL, 0xE29D840EUL,
        0x842F7D83UL, 0x340CE5C8UL, 0x96BBB682UL, 0x93B4B148UL,
        0xEF303CABUL, 0x984FAF28UL, 0x779FAF9BUL, 0x92DC560DUL,
        0x224D1E20UL, 0x8437AA88UL, 0x7D29DC96UL, 0x2756D3DCUL,
        0x8B907CEEUL, 0xB51FD240UL, 0xE7C07CE3UL, 0xE566B4A1UL,
        0xC3E9615EUL, 0x3CF8209DUL, 0x6094D1E3UL, 0xCD9CA341UL,
        0x5C76460EUL, 0x00EA983BUL, 0xD4D67881UL, 0xFD47572CUL,
        0xF76CEDD9UL, 0xBDA8229CUL, 0x127DADAAUL, 0x438A074EUL,
        0x1F97C090UL, 0x081BDB8AUL, 0x93A07EBEUL, 0xB938CA15UL,
        0x97B03CFFUL, 0x3DC2C0F8UL, 0x8D1AB2ECUL, 0x64380E51UL,
        0x68CC7BFBUL, 0xD90F2788UL, 0x12490181UL, 0x5DE5FFD4UL,
        0xDD7EF86AUL, 0x76A2E214UL, 0xB9A40368UL, 0x925D958FUL,
        0x4B39FFFAUL, 0xBA39AEE9UL, 0xA4FFD30BUL, 0xFAF7933BUL,
        0x6D498623UL, 0x193CBCFAUL, 0x27627545UL, 0x825CF47AUL,
        0x61BD8BA0UL, 0xD11E42D1UL, 0xCEAD04F4UL, 0x127EA392UL,
        0x10428DB7UL, 0x8272A972UL, 0x9270C4A8UL, 0x127DE50BUL,
        0x285BA1C8UL, 0x3C62F44FUL, 0x35C0EAA5UL, 0xE805D231UL,
        0x428929FBUL, 0xB4FCDF82UL, 0x4FB66A53UL, 0x0E7DC15BUL,
        0x1F081FABUL, 0x108618AEUL, 0xFCFD086DUL, 0xF9FF2889UL,
        0x694BCC11UL, 0x236A5CAEUL, 0x12DECA4DUL, 0x2C3F8CC5UL,
        0xD2D02DFEUL, 0xF8EF5896UL, 0xE4CF52DAUL, 0x95155B67UL,
        0x494A488CUL, 0xB9B6A80CUL, 0x5C8F82BCUL, 0x89D36B45UL,
        0x3A609437UL, 0xEC00C9A9UL, 0x44715253UL, 0x0A874B49UL,
        0xD773BC40UL, 0x7C34671CUL, 0x02717EF6UL, 0x4FEB5536UL,
        0xA2D02FFFUL, 0xD2BF60C4UL, 0xD43F03C0UL, 0x50B4EF6DUL,
        0x07478CD1UL, 0x006E1888UL, 0xA2E53F55UL, 0xB9E6D4BCUL,
        0xA2048016UL, 0x97573833UL, 0xD7207D67UL, 0xDE0F8F3DUL,
        0x72F87B33UL, 0xABCC4F33UL, 0x7688C55DUL, 0x7B00A6B0UL,
        0x947B0001UL, 0x570075D2UL, 0xF9BB88F8UL, 0x8942019EUL,
        0x4264A5FFUL, 0x856302E0UL, 0x72DBD92BUL, 0xEE971B69UL,
        0x6EA22FDEUL, 0x5F08AE2BUL, 0xAF7A616DUL, 0xE5C98767UL,
        0xCF1FEBD2UL, 0x61EFC8C2UL, 0xF1AC2571UL, 0xCC8239C2UL,
        0x67214CB8UL, 0xB1E583D1UL, 0xB7DC3E62UL, 0x7F10BDCEUL,
        0xF90A5C38UL, 0x0FF0443DUL, 0x606E6DC6UL, 0x60543A49UL,
        0x5727C148UL, 0x2BE98A1DUL, 0x8AB41738UL, 0x20E1BE24UL,
        0xAF96DA0FUL, 0x68458425UL, 0x99833BE5UL, 0x600D457DUL,
        0x282F9350UL, 0x8334B362UL, 0xD91D1120UL, 0x2B6D8DA0UL,
        0x642B1E31UL, 0x9C305A00UL, 0x52BCE688UL, 0x1B03588AUL,
        0xF7BAEFD5UL, 0x4142ED9CUL, 0xA4315C11UL, 0x83323EC5UL,
        0xDFEF4636UL, 0xA133C501UL, 0xE9D3531CUL, 0xEE353783UL
,


        0x9DB30420UL, 0x1FB6E9DEUL, 0xA7BE7BEFUL, 0xD273A298UL,
        0x4A4F7BDBUL, 0x64AD8C57UL, 0x85510443UL, 0xFA020ED1UL,
        0x7E287AFFUL, 0xE60FB663UL, 0x095F35A1UL, 0x79EBF120UL,
        0xFD059D43UL, 0x6497B7B1UL, 0xF3641F63UL, 0x241E4ADFUL,
        0x28147F5FUL, 0x4FA2B8CDUL, 0xC9430040UL, 0x0CC32220UL,
        0xFDD30B30UL, 0xC0A5374FUL, 0x1D2D00D9UL, 0x24147B15UL,
        0xEE4D111AUL, 0x0FCA5167UL, 0x71FF904CUL, 0x2D195FFEUL,
        0x1A05645FUL, 0x0C13FEFEUL, 0x081B08CAUL, 0x05170121UL,
        0x80530100UL, 0xE83E5EFEUL, 0xAC9AF4F8UL, 0x7FE72701UL,
        0xD2B8EE5FUL, 0x06DF4261UL, 0xBB9E9B8AUL, 0x7293EA25UL,
        0xCE84FFDFUL, 0xF5718801UL, 0x3DD64B04UL, 0xA26F263BUL,
        0x7ED48400UL, 0x547EEBE6UL, 0x446D4CA0UL, 0x6CF3D6F5UL,
        0x2649ABDFUL, 0xAEA0C7F5UL, 0x36338CC1UL, 0x503F7E93UL,
        0xD3772061UL, 0x11B638E1UL, 0x72500E03UL, 0xF80EB2BBUL,
        0xABE0502EUL, 0xEC8D77DEUL, 0x57971E81UL, 0xE14F6746UL,
        0xC9335400UL, 0x6920318FUL, 0x081DBB99UL, 0xFFC304A5UL,
        0x4D351805UL, 0x7F3D5CE3UL, 0xA6C866C6UL, 0x5D5BCCA9UL,
        0xDAEC6FEAUL, 0x9F926F91UL, 0x9F46222FUL, 0x3991467DUL,
        0xA5BF6D8EUL, 0x1143C44FUL, 0x43958302UL, 0xD0214EEBUL,
        0x022083B8UL, 0x3FB6180CUL, 0x18F8931EUL, 0x281658E6UL,
        0x26486E3EUL, 0x8BD78A70UL, 0x7477E4C1UL, 0xB506E07CUL,
        0xF32D0A25UL, 0x79098B02UL, 0xE4EABB81UL, 0x28123B23UL,
        0x69DEAD38UL, 0x1574CA16UL, 0xDF871B62UL, 0x211C40B7UL,
        0xA51A9EF9UL, 0x0014377BUL, 0x041E8AC8UL, 0x09114003UL,
        0xBD59E4D2UL, 0xE3D156D5UL, 0x4FE876D5UL, 0x2F91A340UL,
        0x557BE8DEUL, 0x00EAE4A7UL, 0x0CE5C2ECUL, 0x4DB4BBA6UL,
        0xE756BDFFUL, 0xDD3369ACUL, 0xEC17B035UL, 0x06572327UL,
        0x99AFC8B0UL, 0x56C8C391UL, 0x6B65811CUL, 0x5E146119UL,
        0x6E85CB75UL, 0xBE07C002UL, 0xC2325577UL, 0x893FF4ECUL,
        0x5BBFC92DUL, 0xD0EC3B25UL, 0xB7801AB7UL, 0x8D6D3B24UL,
        0x20C763EFUL, 0xC366A5FCUL, 0x9C382880UL, 0x0ACE3205UL,
        0xAAC9548AUL, 0xECA1D7C7UL, 0x041AFA32UL, 0x1D16625AUL,
        0x6701902CUL, 0x9B757A54UL, 0x31D477F7UL, 0x9126B031UL,
        0x36CC6FDBUL, 0xC70B8B46UL, 0xD9E66A48UL, 0x56E55A79UL,
        0x026A4CEBUL, 0x52437EFFUL, 0x2F8F76B4UL, 0x0DF980A5UL,
        0x8674CDE3UL, 0xEDDA04EBUL, 0x17A9BE04UL, 0x2C18F4DFUL,
        0xB7747F9DUL, 0xAB2AF7B4UL, 0xEFC34D20UL, 0x2E096B7CUL,
        0x1741A254UL, 0xE5B6A035UL, 0x213D42F6UL, 0x2C1C7C26UL,
        0x61C2F50FUL, 0x6552DAF9UL, 0xD2C231F8UL, 0x25130F69UL,
        0xD8167FA2UL, 0x0418F2C8UL, 0x001A96A6UL, 0x0D1526ABUL,
        0x63315C21UL, 0x5E0A72ECUL, 0x49BAFEFDUL, 0x187908D9UL,
        0x8D0DBD86UL, 0x311170A7UL, 0x3E9B640CUL, 0xCC3E10D7UL,
        0xD5CAD3B6UL, 0x0CAEC388UL, 0xF73001E1UL, 0x6C728AFFUL,
        0x71EAE2A1UL, 0x1F9AF36EUL, 0xCFCBD12FUL, 0xC1DE8417UL,
        0xAC07BE6BUL, 0xCB44A1D8UL, 0x8B9B0F56UL, 0x013988C3UL,
        0xB1C52FCAUL, 0xB4BE31CDUL, 0xD8782806UL, 0x12A3A4E2UL,
        0x6F7DE532UL, 0x58FD7EB6UL, 0xD01EE900UL, 0x24ADFFC2UL,
        0xF4990FC5UL, 0x9711AAC5UL, 0x001D7B95UL, 0x82E5E7D2UL,
        0x109873F6UL, 0x00613096UL, 0xC32D9521UL, 0xADA121FFUL,
        0x29908415UL, 0x7FBB977FUL, 0xAF9EB3DBUL, 0x29C9ED2AUL,
        0x5CE2A465UL, 0xA730F32CUL, 0xD0AA3FE8UL, 0x8A5CC091UL,
        0xD49E2CE7UL, 0x0CE454A9UL, 0xD60ACD86UL, 0x015F1919UL,
        0x77079103UL, 0xDEA03AF6UL, 0x78A8565EUL, 0xDEE356DFUL,
        0x21F05CBEUL, 0x8B75E387UL, 0xB3C50651UL, 0xB8A5C3EFUL,
        0xD8EEB6D2UL, 0xE523BE77UL, 0xC2154529UL, 0x2F69EFDFUL,
        0xAFE67AFBUL, 0xF470C4B2UL, 0xF3E0EB5BUL, 0xD6CC9876UL,
        0x39E4460CUL, 0x1FDA8538UL, 0x1987832FUL, 0xCA007367UL,
        0xA99144F8UL, 0x296B299EUL, 0x492FC295UL, 0x9266BEABUL,
        0xB5676E69UL, 0x9BD3DDDAUL, 0xDF7E052FUL, 0xDB25701CUL,
        0x1B5E51EEUL, 0xF65324E6UL, 0x6AFCE36CUL, 0x0316CC04UL,
        0x8644213EUL, 0xB7DC59D0UL, 0x7965291FUL, 0xCCD6FD43UL,
        0x41823979UL, 0x932BCDF6UL, 0xB657C34DUL, 0x4EDFD282UL,
        0x7AE5290CUL, 0x3CB9536BUL, 0x851E20FEUL, 0x9833557EUL,
        0x13ECF0B0UL, 0xD3FFB372UL, 0x3F85C5C1UL, 0x0AEF7ED2UL
,


        0x7EC90C04UL, 0x2C6E74B9UL, 0x9B0E66DFUL, 0xA6337911UL,
        0xB86A7FFFUL, 0x1DD358F5UL, 0x44DD9D44UL, 0x1731167FUL,
        0x08FBF1FAUL, 0xE7F511CCUL, 0xD2051B00UL, 0x735ABA00UL,
        0x2AB722D8UL, 0x386381CBUL, 0xACF6243AUL, 0x69BEFD7AUL,
        0xE6A2E77FUL, 0xF0C720CDUL, 0xC4494816UL, 0xCCF5C180UL,
        0x38851640UL, 0x15B0A848UL, 0xE68B18CBUL, 0x4CAADEFFUL,
        0x5F480A01UL, 0x0412B2AAUL, 0x259814FCUL, 0x41D0EFE2UL,
        0x4E40B48DUL, 0x248EB6FBUL, 0x8DBA1CFEUL, 0x41A99B02UL,
        0x1A550A04UL, 0xBA8F65CBUL, 0x7251F4E7UL, 0x95A51725UL,
        0xC106ECD7UL, 0x97A5980AUL, 0xC539B9AAUL, 0x4D79FE6AUL,
        0xF2F3F763UL, 0x68AF8040UL, 0xED0C9E56UL, 0x11B4958BUL,
        0xE1EB5A88UL, 0x8709E6B0UL, 0xD7E07156UL, 0x4E29FEA7UL,
        0x6366E52DUL, 0x02D1C000UL, 0xC4AC8E05UL, 0x9377F571UL,
        0x0C05372AUL, 0x578535F2UL, 0x2261BE02UL, 0xD642A0C9UL,
        0xDF13A280UL, 0x74B55BD2UL, 0x682199C0UL, 0xD421E5ECUL,
        0x53FB3CE8UL, 0xC8ADEDB3UL, 0x28A87FC9UL, 0x3D959981UL,
        0x5C1FF900UL, 0xFE38D399UL, 0x0C4EFF0BUL, 0x062407EAUL,
        0xAA2F4FB1UL, 0x4FB96976UL, 0x90C79505UL, 0xB0A8A774UL,
        0xEF55A1FFUL, 0xE59CA2C2UL, 0xA6B62D27UL, 0xE66A4263UL,
        0xDF65001FUL, 0x0EC50966UL, 0xDFDD55BCUL, 0x29DE0655UL,
        0x911E739AUL, 0x17AF8975UL, 0x32C7911CUL, 0x89F89468UL,
        0x0D01E980UL, 0x524755F4UL, 0x03B63CC9UL, 0x0CC844B2UL,
        0xBCF3F0AAUL, 0x87AC36E9UL, 0xE53A7426UL, 0x01B3D82BUL,
        0x1A9E7449UL, 0x64EE2D7EUL, 0xCDDBB1DAUL, 0x01C94910UL,
        0xB868BF80UL, 0x0D26F3FDUL, 0x9342EDE7UL, 0x04A5C284UL,
        0x636737B6UL, 0x50F5B616UL, 0xF24766E3UL, 0x8ECA36C1UL,
        0x136E05DBUL, 0xFEF18391UL, 0xFB887A37UL, 0xD6E7F7D4UL,
        0xC7FB7DC9UL, 0x3063FCDFUL, 0xB6F589DEUL, 0xEC2941DAUL,
        0x26E46695UL, 0xB7566419UL, 0xF654EFC5UL, 0xD08D58B7UL,
        0x48925401UL, 0xC1BACB7FUL, 0xE5FF550FUL, 0xB6083049UL,
        0x5BB5D0E8UL, 0x87D72E5AUL, 0xAB6A6EE1UL, 0x223A66CEUL,
        0xC62BF3CDUL, 0x9E0885F9UL, 0x68CB3E47UL, 0x086C010FUL,
        0xA21DE820UL, 0xD18B69DEUL, 0xF3F65777UL, 0xFA02C3F6UL,
        0x407EDAC3UL, 0xCBB3D550UL, 0x1793084DUL, 0xB0D70EBAUL,
        0x0AB378D5UL, 0xD951FB0CUL, 0xDED7DA56UL, 0x4124BBE4UL,
        0x94CA0B56UL, 0x0F5755D1UL, 0xE0E1E56EUL, 0x6184B5BEUL,
        0x580A249FUL, 0x94F74BC0UL, 0xE327888EUL, 0x9F7B5561UL,
        0xC3DC0280UL, 0x05687715UL, 0x646C6BD7UL, 0x44904DB3UL,
        0x66B4F0A3UL, 0xC0F1648AUL, 0x697ED5AFUL, 0x49E92FF6UL,
        0x309E374FUL, 0x2CB6356AUL, 0x85808573UL, 0x4991F840UL,
        0x76F0AE02UL, 0x083BE84DUL, 0x28421C9AUL, 0x44489406UL,
        0x736E4CB8UL, 0xC1092910UL, 0x8BC95FC6UL, 0x7D869CF4UL,
        0x134F616FUL, 0x2E77118DUL, 0xB31B2BE1UL, 0xAA90B472UL,
        0x3CA5D717UL, 0x7D161BBAUL, 0x9CAD9010UL, 0xAF462BA2UL,
        0x9FE459D2UL, 0x45D34559UL, 0xD9F2DA13UL, 0xDBC65487UL,
        0xF3E4F94EUL, 0x176D486FUL, 0x097C13EAUL, 0x631DA5C7UL,
        0x445F7382UL, 0x175683F4UL, 0xCDC66A97UL, 0x70BE0288UL,
        0xB3CDCF72UL, 0x6E5DD2F3UL, 0x20936079UL, 0x459B80A5UL,
        0xBE60E2DBUL, 0xA9C23101UL, 0xEBA5315CUL, 0x224E42F2UL,
        0x1C5C1572UL, 0xF6721B2CUL, 0x1AD2FFF3UL, 0x8C25404EUL,
        0x324ED72FUL, 0x4067B7FDUL, 0x0523138EUL, 0x5CA3BC78UL,
        0xDC0FD66EUL, 0x75922283UL, 0x784D6B17UL, 0x58EBB16EUL,
        0x44094F85UL, 0x3F481D87UL, 0xFCFEAE7BUL, 0x77B5FF76UL,
        0x8C2302BFUL, 0xAAF47556UL, 0x5F46B02AUL, 0x2B092801UL,
        0x3D38F5F7UL, 0x0CA81F36UL, 0x52AF4A8AUL, 0x66D5E7C0UL,
        0xDF3B0874UL, 0x95055110UL, 0x1B5AD7A8UL, 0xF61ED5ADUL,
        0x6CF6E479UL, 0x20758184UL, 0xD0CEFA65UL, 0x88F7BE58UL,
        0x4A046826UL, 0x0FF6F8F3UL, 0xA09C7F70UL, 0x5346ABA0UL,
        0x5CE96C28UL, 0xE176EDA3UL, 0x6BAC307FUL, 0x376829D2UL,
        0x85360FA9UL, 0x17E3FE2AUL, 0x24B79767UL, 0xF5A96B20UL,
        0xD6CD2595UL, 0x68FF1EBFUL, 0x7555442CUL, 0xF19F06BEUL,
        0xF9E0659AUL, 0xEEB9491DUL, 0x34010718UL, 0xBB30CAB8UL,
        0xE822FE15UL, 0x88570983UL, 0x750E6249UL, 0xDA627E55UL,
        0x5E76FFA8UL, 0xB1534546UL, 0x6D47DE08UL, 0xEFE9E7D4UL
,


        0xF6FA8F9DUL, 0x2CAC6CE1UL, 0x4CA34867UL, 0xE2337F7CUL,
        0x95DB08E7UL, 0x016843B4UL, 0xECED5CBCUL, 0x325553ACUL,
        0xBF9F0960UL, 0xDFA1E2EDUL, 0x83F0579DUL, 0x63ED86B9UL,
        0x1AB6A6B8UL, 0xDE5EBE39UL, 0xF38FF732UL, 0x8989B138UL,
        0x33F14961UL, 0xC01937BDUL, 0xF506C6DAUL, 0xE4625E7EUL,
        0xA308EA99UL, 0x4E23E33CUL, 0x79CBD7CCUL, 0x48A14367UL,
        0xA3149619UL, 0xFEC94BD5UL, 0xA114174AUL, 0xEAA01866UL,
        0xA084DB2DUL, 0x09A8486FUL, 0xA888614AUL, 0x2900AF98UL,
        0x01665991UL, 0xE1992863UL, 0xC8F30C60UL, 0x2E78EF3CUL,
        0xD0D51932UL, 0xCF0FEC14UL, 0xF7CA07D2UL, 0xD0A82072UL,
        0xFD41197EUL, 0x9305A6B0UL, 0xE86BE3DAUL, 0x74BED3CDUL,
        0x372DA53CUL, 0x4C7F4448UL, 0xDAB5D440UL, 0x6DBA0EC3UL,
        0x083919A7UL, 0x9FBAEED9UL, 0x49DBCFB0UL, 0x4E670C53UL,
        0x5C3D9C01UL, 0x64BDB941UL, 0x2C0E636AUL, 0xBA7DD9CDUL,
        0xEA6F7388UL, 0xE70BC762UL, 0x35F29ADBUL, 0x5C4CDD8DUL,
        0xF0D48D8CUL, 0xB88153E2UL, 0x08A19866UL, 0x1AE2EAC8UL,
        0x284CAF89UL, 0xAA928223UL, 0x9334BE53UL, 0x3B3A21BFUL,
        0x16434BE3UL, 0x9AEA3906UL, 0xEFE8C36EUL, 0xF890CDD9UL,
        0x80226DAEUL, 0xC340A4A3UL, 0xDF7E9C09UL, 0xA694A807UL,
        0x5B7C5ECCUL, 0x221DB3A6UL, 0x9A69A02FUL, 0x68818A54UL,
        0xCEB2296FUL, 0x53C0843AUL, 0xFE893655UL, 0x25BFE68AUL,
        0xB4628ABCUL, 0xCF222EBFUL, 0x25AC6F48UL, 0xA9A99387UL,
        0x53BDDB65UL, 0xE76FFBE7UL, 0xE967FD78UL, 0x0BA93563UL,
        0x8E342BC1UL, 0xE8A11BE9UL, 0x4980740DUL, 0xC8087DFCUL,
        0x8DE4BF99UL, 0xA11101A0UL, 0x7FD37975UL, 0xDA5A26C0UL,
        0xE81F994FUL, 0x9528CD89UL, 0xFD339FEDUL, 0xB87834BFUL,
        0x5F04456DUL, 0x22258698UL, 0xC9C4C83BUL, 0x2DC156BEUL,
        0x4F628DAAUL, 0x57F55EC5UL, 0xE2220ABEUL, 0xD2916EBFUL,
        0x4EC75B95UL, 0x24F2C3C0UL, 0x42D15D99UL, 0xCD0D7FA0UL,
        0x7B6E27FFUL, 0xA8DC8AF0UL, 0x7345C106UL, 0xF41E232FUL,
        0x35162386UL, 0xE6EA8926UL, 0x3333B094UL, 0x157EC6F2UL,
        0x372B74AFUL, 0x692573E4UL, 0xE9A9D848UL, 0xF3160289UL,
        0x3A62EF1DUL, 0xA787E238UL, 0xF3A5F676UL, 0x74364853UL,
        0x20951063UL, 0x4576698DUL, 0xB6FAD407UL, 0x592AF950UL,
        0x36F73523UL, 0x4CFB6E87UL, 0x7DA4CEC0UL, 0x6C152DAAUL,
        0xCB0396A8UL, 0xC50DFE5DUL, 0xFCD707ABUL, 0x0921C42FUL,
        0x89DFF0BBUL, 0x5FE2BE78UL, 0x448F4F33UL, 0x754613C9UL,
        0x2B05D08DUL, 0x48B9D585UL, 0xDC049441UL, 0xC8098F9BUL,
        0x7DEDE786UL, 0xC39A3373UL, 0x42410005UL, 0x6A091751UL,
        0x0EF3C8A6UL, 0x890072D6UL, 0x28207682UL, 0xA9A9F7BEUL,
        0xBF32679DUL, 0xD45B5B75UL, 0xB353FD00UL, 0xCBB0E358UL,
        0x830F220AUL, 0x1F8FB214UL, 0xD372CF08UL, 0xCC3C4A13UL,
        0x8CF63166UL, 0x061C87BEUL, 0x88C98F88UL, 0x6062E397UL,
        0x47CF8E7AUL, 0xB6C85283UL, 0x3CC2ACFBUL, 0x3FC06976UL,
        0x4E8F0252UL, 0x64D8314DUL, 0xDA3870E3UL, 0x1E665459UL,
        0xC10908F0UL, 0x513021A5UL, 0x6C5B68B7UL, 0x822F8AA0UL,
        0x3007CD3EUL, 0x74719EEFUL, 0xDC872681UL, 0x073340D4UL,
        0x7E432FD9UL, 0x0C5EC241UL, 0x8809286CUL, 0xF592D891UL,
        0x08A930F6UL, 0x957EF305UL, 0xB7FBFFBDUL, 0xC266E96FUL,
        0x6FE4AC98UL, 0xB173ECC0UL, 0xBC60B42AUL, 0x953498DAUL,
        0xFBA1AE12UL, 0x2D4BD736UL, 0x0F25FAABUL, 0xA4F3FCEBUL,
        0xE2969123UL, 0x257F0C3DUL, 0x9348AF49UL, 0x361400BCUL,
        0xE8816F4AUL, 0x3814F200UL, 0xA3F94043UL, 0x9C7A54C2UL,
        0xBC704F57UL, 0xDA41E7F9UL, 0xC25AD33AUL, 0x54F4A084UL,
        0xB17F5505UL, 0x59357CBEUL, 0xEDBD15C8UL, 0x7F97C5ABUL,
        0xBA5AC7B5UL, 0xB6F6DEAFUL, 0x3A479C3AUL, 0x5302DA25UL,
        0x653D7E6AUL, 0x54268D49UL, 0x51A477EAUL, 0x5017D55BUL,
        0xD7D25D88UL, 0x44136C76UL, 0x0404A8C8UL, 0xB8E5A121UL,
        0xB81A928AUL, 0x60ED5869UL, 0x97C55B96UL, 0xEAEC991BUL,
        0x29935913UL, 0x01FDB7F1UL, 0x088E8DFAUL, 0x9AB6F6F5UL,
        0x3B4CBF9FUL, 0x4A5DE3ABUL, 0xE6051D35UL, 0xA0E1D855UL,
        0xD36B4CF1UL, 0xF544EDEBUL, 0xB0E93524UL, 0xBEBB8FBDUL,
        0xA2D762CFUL, 0x49C92F54UL, 0x38B5F331UL, 0x7128A454UL,
        0x48392905UL, 0xA65B1DB8UL, 0x851C97BDUL, 0xD675CF2FUL
,


        0x85E04019UL, 0x332BF567UL, 0x662DBFFFUL, 0xCFC65693UL,
        0x2A8D7F6FUL, 0xAB9BC912UL, 0xDE6008A1UL, 0x2028DA1FUL,
        0x0227BCE7UL, 0x4D642916UL, 0x18FAC300UL, 0x50F18B82UL,
        0x2CB2CB11UL, 0xB232E75CUL, 0x4B3695F2UL, 0xB28707DEUL,
        0xA05FBCF6UL, 0xCD4181E9UL, 0xE150210CUL, 0xE24EF1BDUL,
        0xB168C381UL, 0xFDE4E789UL, 0x5C79B0D8UL, 0x1E8BFD43UL,
        0x4D495001UL, 0x38BE4341UL, 0x913CEE1DUL, 0x92A79C3FUL,
        0x089766BEUL, 0xBAEEADF4UL, 0x1286BECFUL, 0xB6EACB19UL,
        0x2660C200UL, 0x7565BDE4UL, 0x64241F7AUL, 0x8248DCA9UL,
        0xC3B3AD66UL, 0x28136086UL, 0x0BD8DFA8UL, 0x356D1CF2UL,
        0x107789BEUL, 0xB3B2E9CEUL, 0x0502AA8FUL, 0x0BC0351EUL,
        0x166BF52AUL, 0xEB12FF82UL, 0xE3486911UL, 0xD34D7516UL,
        0x4E7B3AFFUL, 0x5F43671BUL, 0x9CF6E037UL, 0x4981AC83UL,
        0x334266CEUL, 0x8C9341B7UL, 0xD0D854C0UL, 0xCB3A6C88UL,
        0x47BC2829UL, 0x4725BA37UL, 0xA66AD22BUL, 0x7AD61F1EUL,
        0x0C5CBAFAUL, 0x4437F107UL, 0xB6E79962UL, 0x42D2D816UL,
        0x0A961288UL, 0xE1A5C06EUL, 0x13749E67UL, 0x72FC081AUL,
        0xB1D139F7UL, 0xF9583745UL, 0xCF19DF58UL, 0xBEC3F756UL,
        0xC06EBA30UL, 0x07211B24UL, 0x45C28829UL, 0xC95E317FUL,
        0xBC8EC511UL, 0x38BC46E9UL, 0xC6E6FA14UL, 0xBAE8584AUL,
        0xAD4EBC46UL, 0x468F508BUL, 0x7829435FUL, 0xF124183BUL,
        0x821DBA9FUL, 0xAFF60FF4UL, 0xEA2C4E6DUL, 0x16E39264UL,
        0x92544A8BUL, 0x009B4FC3UL, 0xABA68CEDUL, 0x9AC96F78UL,
        0x06A5B79AUL, 0xB2856E6EUL, 0x1AEC3CA9UL, 0xBE838688UL,
        0x0E0804E9UL, 0x55F1BE56UL, 0xE7E5363BUL, 0xB3A1F25DUL,
        0xF7DEBB85UL, 0x61FE033CUL, 0x16746233UL, 0x3C034C28UL,
        0xDA6D0C74UL, 0x79AAC56CUL, 0x3CE4E1ADUL, 0x51F0C802UL,
        0x98F8F35AUL, 0x1626A49FUL, 0xEED82B29UL, 0x1D382FE3UL,
        0x0C4FB99AUL, 0xBB325778UL, 0x3EC6D97BUL, 0x6E77A6A9UL,
        0xCB658B5CUL, 0xD45230C7UL, 0x2BD1408BUL, 0x60C03EB7UL,
        0xB9068D78UL, 0xA33754F4UL, 0xF430C87DUL, 0xC8A71302UL,
        0xB96D8C32UL, 0xEBD4E7BEUL, 0xBE8B9D2DUL, 0x7979FB06UL,
        0xE7225308UL, 0x8B75CF77UL, 0x11EF8DA4UL, 0xE083C858UL,
        0x8D6B786FUL, 0x5A6317A6UL, 0xFA5CF7A0UL, 0x5DDA0033UL,
        0xF28EBFB0UL, 0xF5B9C310UL, 0xA0EAC280UL, 0x08B9767AUL,
        0xA3D9D2B0UL, 0x79D34217UL, 0x021A718DUL, 0x9AC6336AUL,
        0x2711FD60UL, 0x438050E3UL, 0x069908A8UL, 0x3D7FEDC4UL,
        0x826D2BEFUL, 0x4EEB8476UL, 0x488DCF25UL, 0x36C9D566UL,
        0x28E74E41UL, 0xC2610ACAUL, 0x3D49A9CFUL, 0xBAE3B9DFUL,
        0xB65F8DE6UL, 0x92AEAF64UL, 0x3AC7D5E6UL, 0x9EA80509UL,
        0xF22B017DUL, 0xA4173F70UL, 0xDD1E16C3UL, 0x15E0D7F9UL,
        0x50B1B887UL, 0x2B9F4FD5UL, 0x625ABA82UL, 0x6A017962UL,
        0x2EC01B9CUL, 0x15488AA9UL, 0xD716E740UL, 0x40055A2CUL,
        0x93D29A22UL, 0xE32DBF9AUL, 0x058745B9UL, 0x3453DC1EUL,
        0xD699296EUL, 0x496CFF6FUL, 0x1C9F4986UL, 0xDFE2ED07UL,
        0xB87242D1UL, 0x19DE7EAEUL, 0x053E561AUL, 0x15AD6F8CUL,
        0x66626C1CUL, 0x7154C24CUL, 0xEA082B2AUL, 0x93EB2939UL,
        0x17DCB0F0UL, 0x58D4F2AEUL, 0x9EA294FBUL, 0x52CF564CUL,
        0x9883FE66UL, 0x2EC40581UL, 0x763953C3UL, 0x01D6692EUL,
        0xD3A0C108UL, 0xA1E7160EUL, 0xE4F2DFA6UL, 0x693ED285UL,
        0x74904698UL, 0x4C2B0EDDUL, 0x4F757656UL, 0x5D393378UL,
        0xA132234FUL, 0x3D321C5DUL, 0xC3F5E194UL, 0x4B269301UL,
        0xC79F022FUL, 0x3C997E7EUL, 0x5E4F9504UL, 0x3FFAFBBDUL,
        0x76F7AD0EUL, 0x296693F4UL, 0x3D1FCE6FUL, 0xC61E45BEUL,
        0xD3B5AB34UL, 0xF72BF9B7UL, 0x1B0434C0UL, 0x4E72B567UL,
        0x5592A33DUL, 0xB5229301UL, 0xCFD2A87FUL, 0x60AEB767UL,
        0x1814386BUL, 0x30BCC33DUL, 0x38A0C07DUL, 0xFD1606F2UL,
        0xC363519BUL, 0x589DD390UL, 0x5479F8E6UL, 0x1CB8D647UL,
        0x97FD61A9UL, 0xEA7759F4UL, 0x2D57539DUL, 0x569A58CFUL,
        0xE84E63ADUL, 0x462E1B78UL, 0x6580F87EUL, 0xF3817914UL,
        0x91DA55F4UL, 0x40A230F3UL, 0xD1988F35UL, 0xB6E318D2UL,
        0x3FFA50BCUL, 0x3D40F021UL, 0xC3C0BDAEUL, 0x4958C24CUL,
        0x518F36B2UL, 0x84B1D370UL, 0x0FEDCE83UL, 0x878DDADAUL,
        0xF2A279C7UL, 0x94E01BE8UL, 0x90716F4BUL, 0x954B8AA3UL
,


        0xE216300DUL, 0xBBDDFFFCUL, 0xA7EBDABDUL, 0x35648095UL,
        0x7789F8B7UL, 0xE6C1121BUL, 0x0E241600UL, 0x052CE8B5UL,
        0x11A9CFB0UL, 0xE5952F11UL, 0xECE7990AUL, 0x9386D174UL,
        0x2A42931CUL, 0x76E38111UL, 0xB12DEF3AUL, 0x37DDDDFCUL,
        0xDE9ADEB1UL, 0x0A0CC32CUL, 0xBE197029UL, 0x84A00940UL,
        0xBB243A0FUL, 0xB4D137CFUL, 0xB44E79F0UL, 0x049EEDFDUL,
        0x0B15A15DUL, 0x480D3168UL, 0x8BBBDE5AUL, 0x669DED42UL,
        0xC7ECE831UL, 0x3F8F95E7UL, 0x72DF191BUL, 0x7580330DUL,
        0x94074251UL, 0x5C7DCDFAUL, 0xABBE6D63UL, 0xAA402164UL,
        0xB301D40AUL, 0x02E7D1CAUL, 0x53571DAEUL, 0x7A3182A2UL,
        0x12A8DDECUL, 0xFDAA335DUL, 0x176F43E8UL, 0x71FB46D4UL,
        0x38129022UL, 0xCE949AD4UL, 0xB84769ADUL, 0x965BD862UL,
        0x82F3D055UL, 0x66FB9767UL, 0x15B80B4EUL, 0x1D5B47A0UL,
        0x4CFDE06FUL, 0xC28EC4B8UL, 0x57E8726EUL, 0x647A78FCUL,
        0x99865D44UL, 0x608BD593UL, 0x6C200E03UL, 0x39DC5FF6UL,
        0x5D0B00A3UL, 0xAE63AFF2UL, 0x7E8BD632UL, 0x70108C0CUL,
        0xBBD35049UL, 0x2998DF04UL, 0x980CF42AUL, 0x9B6DF491UL,
        0x9E7EDD53UL, 0x06918548UL, 0x58CB7E07UL, 0x3B74EF2EUL,
        0x522FFFB1UL, 0xD24708CCUL, 0x1C7E27CDUL, 0xA4EB215BUL,
        0x3CF1D2E2UL, 0x19B47A38UL, 0x424F7618UL, 0x35856039UL,
        0x9D17DEE7UL, 0x27EB35E6UL, 0xC9AFF67BUL, 0x36BAF5B8UL,
        0x09C467CDUL, 0xC18910B1UL, 0xE11DBF7BUL, 0x06CD1AF8UL,
        0x7170C608UL, 0x2D5E3354UL, 0xD4DE495AUL, 0x64C6D006UL,
        0xBCC0C62CUL, 0x3DD00DB3UL, 0x708F8F34UL, 0x77D51B42UL,
        0x264F620FUL, 0x24B8D2BFUL, 0x15C1B79EUL, 0x46A52564UL,
        0xF8D7E54EUL, 0x3E378160UL, 0x7895CDA5UL, 0x859C15A5UL,
        0xE6459788UL, 0xC37BC75FUL, 0xDB07BA0CUL, 0x0676A3ABUL,
        0x7F229B1EUL, 0x31842E7BUL, 0x24259FD7UL, 0xF8BEF472UL,
        0x835FFCB8UL, 0x6DF4C1F2UL, 0x96F5B195UL, 0xFD0AF0FCUL,
        0xB0FE134CUL, 0xE2506D3DUL, 0x4F9B12EAUL, 0xF215F225UL,
        0xA223736FUL, 0x9FB4C428UL, 0x25D04979UL, 0x34C713F8UL,
        0xC4618187UL, 0xEA7A6E98UL, 0x7CD16EFCUL, 0x1436876CUL,
        0xF1544107UL, 0xBEDEEE14UL, 0x56E9AF27UL, 0xA04AA441UL,
        0x3CF7C899UL, 0x92ECBAE6UL, 0xDD67016DUL, 0x151682EBUL,
        0xA842EEDFUL, 0xFDBA60B4UL, 0xF1907B75UL, 0x20E3030FUL,
        0x24D8C29EUL, 0xE139673BUL, 0xEFA63FB8UL, 0x71873054UL,
        0xB6F2CF3BUL, 0x9F326442UL, 0xCB15A4CCUL, 0xB01A4504UL,
        0xF1E47D8DUL, 0x844A1BE5UL, 0xBAE7DFDCUL, 0x42CBDA70UL,
        0xCD7DAE0AUL, 0x57E85B7AUL, 0xD53F5AF6UL, 0x20CF4D8CUL,
        0xCEA4D428UL, 0x79D130A4UL, 0x3486EBFBUL, 0x33D3CDDCUL,
        0x77853B53UL, 0x37EFFCB5UL, 0xC5068778UL, 0xE580B3E6UL,
        0x4E68B8F4UL, 0xC5C8B37EUL, 0x0D809EA2UL, 0x398FEB7CUL,
        0x132A4F94UL, 0x43B7950EUL, 0x2FEE7D1CUL, 0x223613BDUL,
        0xDD06CAA2UL, 0x37DF932BUL, 0xC4248289UL, 0xACF3EBC3UL,
        0x5715F6B7UL, 0xEF3478DDUL, 0xF267616FUL, 0xC148CBE4UL,
        0x9052815EUL, 0x5E410FABUL, 0xB48A2465UL, 0x2EDA7FA4UL,
        0xE87B40E4UL, 0xE98EA084UL, 0x5889E9E1UL, 0xEFD390FCUL,
        0xDD07D35BUL, 0xDB485694UL, 0x38D7E5B2UL, 0x57720101UL,
        0x730EDEBCUL, 0x5B643113UL, 0x94917E4FUL, 0x503C2FBAUL,
        0x646F1282UL, 0x7523D24AUL, 0xE0779695UL, 0xF9C17A8FUL,
        0x7A5B2121UL, 0xD187B896UL, 0x29263A4DUL, 0xBA510CDFUL,
        0x81F47C9FUL, 0xAD1163EDUL, 0xEA7B5965UL, 0x1A00726EUL,
        0x11403092UL, 0x00DA6D77UL, 0x4A0CDD61UL, 0xAD1F4603UL,
        0x605BDFB0UL, 0x9EEDC364UL, 0x22EBE6A8UL, 0xCEE7D28AUL,
        0xA0E736A0UL, 0x5564A6B9UL, 0x10853209UL, 0xC7EB8F37UL,
        0x2DE705CAUL, 0x8951570FUL, 0xDF09822BUL, 0xBD691A6CUL,
        0xAA12E4F2UL, 0x87451C0FUL, 0xE0F6A27AUL, 0x3ADA4819UL,
        0x4CF1764FUL, 0x0D771C2BUL, 0x67CDB156UL, 0x350D8384UL,
        0x5938FA0FUL, 0x42399EF3UL, 0x36997B07UL, 0x0E84093DUL,
        0x4AA93E61UL, 0x8360D87BUL, 0x1FA98B0CUL, 0x1149382CUL,
        0xE97625A5UL, 0x0614D1B7UL, 0x0E25244BUL, 0x0C768347UL,
        0x589E8D82UL, 0x0D2059D1UL, 0xA466BB1EUL, 0xF8DA0A82UL,
        0x04F19130UL, 0xBA6E4EC0UL, 0x99265164UL, 0x1EE7230DUL,
        0x50B2AD80UL, 0xEAEE6801UL, 0x8DB2A283UL, 0xEA8BF59EUL
};

//-----------------
// The following CAST-256 implementation was contributed by Leonard Janke

static const word32 CAST256_t_m[8*24]={
        0x5a827999, 0xd151d6a1, 0x482133a9, 0xbef090b1, 0x35bfedb9, 0xac8f4ac1,
        0x235ea7c9, 0x9a2e04d1, 0x10fd61d9, 0x87ccbee1, 0xfe9c1be9, 0x756b78f1,
        0xec3ad5f9, 0x630a3301, 0xd9d99009, 0x50a8ed11, 0xc7784a19, 0x3e47a721,
        0xb5170429, 0x2be66131, 0xa2b5be39, 0x19851b41, 0x90547849, 0x0723d551,
        0xc95c653a, 0x402bc242, 0xb6fb1f4a, 0x2dca7c52, 0xa499d95a, 0x1b693662,
        0x9238936a, 0x0907f072, 0x7fd74d7a, 0xf6a6aa82, 0x6d76078a, 0xe4456492,
        0x5b14c19a, 0xd1e41ea2, 0x48b37baa, 0xbf82d8b2, 0x365235ba, 0xad2192c2,
        0x23f0efca, 0x9ac04cd2, 0x118fa9da, 0x885f06e2, 0xff2e63ea, 0x75fdc0f2,
        0x383650db, 0xaf05ade3, 0x25d50aeb, 0x9ca467f3, 0x1373c4fb, 0x8a432203,
        0x01127f0b, 0x77e1dc13, 0xeeb1391b, 0x65809623, 0xdc4ff32b, 0x531f5033,
        0xc9eead3b, 0x40be0a43, 0xb78d674b, 0x2e5cc453, 0xa52c215b, 0x1bfb7e63,
        0x92cadb6b, 0x099a3873, 0x8069957b, 0xf738f283, 0x6e084f8b, 0xe4d7ac93,
        0xa7103c7c, 0x1ddf9984, 0x94aef68c, 0x0b7e5394, 0x824db09c, 0xf91d0da4,
        0x6fec6aac, 0xe6bbc7b4, 0x5d8b24bc, 0xd45a81c4, 0x4b29decc, 0xc1f93bd4,
        0x38c898dc, 0xaf97f5e4, 0x266752ec, 0x9d36aff4, 0x14060cfc, 0x8ad56a04,
        0x01a4c70c, 0x78742414, 0xef43811c, 0x6612de24, 0xdce23b2c, 0x53b19834,
        0x15ea281d, 0x8cb98525, 0x0388e22d, 0x7a583f35, 0xf1279c3d, 0x67f6f945,
        0xdec6564d, 0x5595b355, 0xcc65105d, 0x43346d65, 0xba03ca6d, 0x30d32775,
        0xa7a2847d, 0x1e71e185, 0x95413e8d, 0x0c109b95, 0x82dff89d, 0xf9af55a5,
        0x707eb2ad, 0xe74e0fb5, 0x5e1d6cbd, 0xd4ecc9c5, 0x4bbc26cd, 0xc28b83d5,
        0x84c413be, 0xfb9370c6, 0x7262cdce, 0xe9322ad6, 0x600187de, 0xd6d0e4e6,
        0x4da041ee, 0xc46f9ef6, 0x3b3efbfe, 0xb20e5906, 0x28ddb60e, 0x9fad1316,
        0x167c701e, 0x8d4bcd26, 0x041b2a2e, 0x7aea8736, 0xf1b9e43e, 0x68894146,
        0xdf589e4e, 0x5627fb56, 0xccf7585e, 0x43c6b566, 0xba96126e, 0x31656f76,
        0xf39dff5f, 0x6a6d5c67, 0xe13cb96f, 0x580c1677, 0xcedb737f, 0x45aad087,
        0xbc7a2d8f, 0x33498a97, 0xaa18e79f, 0x20e844a7, 0x97b7a1af, 0x0e86feb7,
        0x85565bbf, 0xfc25b8c7, 0x72f515cf, 0xe9c472d7, 0x6093cfdf, 0xd7632ce7,
        0x4e3289ef, 0xc501e6f7, 0x3bd143ff, 0xb2a0a107, 0x296ffe0f, 0xa03f5b17,
        0x6277eb00, 0xd9474808, 0x5016a510, 0xc6e60218, 0x3db55f20, 0xb484bc28,
        0x2b541930, 0xa2237638, 0x18f2d340, 0x8fc23048, 0x06918d50, 0x7d60ea58,
        0xf4304760, 0x6affa468, 0xe1cf0170, 0x589e5e78, 0xcf6dbb80, 0x463d1888,
        0xbd0c7590, 0x33dbd298, 0xaaab2fa0, 0x217a8ca8, 0x9849e9b0, 0x0f1946b8
};

static const unsigned int CAST256_t_r[8*24]={
        19, 27, 3, 11, 19, 27, 3, 11, 19, 27, 3, 11, 19, 27, 3, 11, 19, 27, 3, 11, 19, 27, 3, 11,
        4, 12, 20, 28, 4, 12, 20, 28, 4, 12, 20, 28, 4, 12, 20, 28, 4, 12, 20, 28, 4, 12, 20, 28,
        21, 29, 5, 13, 21, 29, 5, 13, 21, 29, 5, 13, 21, 29, 5, 13, 21, 29, 5, 13, 21, 29, 5, 13,
        6, 14, 22, 30, 6, 14, 22, 30, 6, 14, 22, 30, 6, 14, 22, 30, 6, 14, 22, 30, 6, 14, 22, 30,
        23, 31, 7, 15, 23, 31, 7, 15, 23, 31, 7, 15, 23, 31, 7, 15, 23, 31, 7, 15, 23, 31, 7, 15,
        8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0, 8, 16, 24, 0,
        25, 1, 9, 17, 25, 1, 9, 17, 25, 1, 9, 17, 25, 1, 9, 17, 25, 1, 9, 17, 25, 1, 9, 17,
        10, 18, 26, 2, 10, 18, 26, 2, 10, 18, 26, 2, 10, 18, 26, 2, 10, 18, 26, 2, 10, 18, 26, 2
};
//-----------------
// The Camellia s-boxes

static const byte Camellia_s1[256] =
{
        112,130,44,236,179,39,192,229,228,133,87,53,234,12,174,65,
        35,239,107,147,69,25,165,33,237,14,79,78,29,101,146,189,
        134,184,175,143,124,235,31,206,62,48,220,95,94,197,11,26,
        166,225,57,202,213,71,93,61,217,1,90,214,81,86,108,77,
        139,13,154,102,251,204,176,45,116,18,43,32,240,177,132,153,
        223,76,203,194,52,126,118,5,109,183,169,49,209,23,4,215,
        20,88,58,97,222,27,17,28,50,15,156,22,83,24,242,34,
        254,68,207,178,195,181,122,145,36,8,232,168,96,252,105,80,
        170,208,160,125,161,137,98,151,84,91,30,149,224,255,100,210,
        16,196,0,72,163,247,117,219,138,3,230,218,9,63,221,148,
        135,92,131,2,205,74,144,51,115,103,246,243,157,127,191,226,
        82,155,216,38,200,55,198,59,129,150,111,75,19,190,99,46,
        233,121,167,140,159,110,188,142,41,245,249,182,47,253,180,89,
        120,152,6,106,231,70,113,186,212,37,171,66,136,162,141,250,
        114,7,185,85,248,238,172,10,54,73,42,104,60,56,241,164,
        64,40,211,123,187,201,67,193,21,227,173,244,119,199,128,158
};

static const byte Camellia_s2[256] =
{
        224,5,88,217,103,78,129,203,201,11,174,106,213,24,93,130,
        70,223,214,39,138,50,75,66,219,28,158,156,58,202,37,123,
        13,113,95,31,248,215,62,157,124,96,185,190,188,139,22,52,
        77,195,114,149,171,142,186,122,179,2,180,173,162,172,216,154,
        23,26,53,204,247,153,97,90,232,36,86,64,225,99,9,51,
        191,152,151,133,104,252,236,10,218,111,83,98,163,46,8,175,
        40,176,116,194,189,54,34,56,100,30,57,44,166,48,229,68,
        253,136,159,101,135,107,244,35,72,16,209,81,192,249,210,160,
        85,161,65,250,67,19,196,47,168,182,60,43,193,255,200,165,
        32,137,0,144,71,239,234,183,21,6,205,181,18,126,187,41,
        15,184,7,4,155,148,33,102,230,206,237,231,59,254,127,197,
        164,55,177,76,145,110,141,118,3,45,222,150,38,125,198,92,
        211,242,79,25,63,220,121,29,82,235,243,109,94,251,105,178,
        240,49,12,212,207,140,226,117,169,74,87,132,17,69,27,245,
        228,14,115,170,241,221,89,20,108,146,84,208,120,112,227,73,
        128,80,167,246,119,147,134,131,42,199,91,233,238,143,1,61
};

static const byte Camellia_s3[256] =
{
        56,65,22,118,217,147,96,242,114,194,171,154,117,6,87,160,
        145,247,181,201,162,140,210,144,246,7,167,39,142,178,73,222,
        67,92,215,199,62,245,143,103,31,24,110,175,47,226,133,13,
        83,240,156,101,234,163,174,158,236,128,45,107,168,43,54,166,
        197,134,77,51,253,102,88,150,58,9,149,16,120,216,66,204,
        239,38,229,97,26,63,59,130,182,219,212,152,232,139,2,235,
        10,44,29,176,111,141,136,14,25,135,78,11,169,12,121,17,
        127,34,231,89,225,218,61,200,18,4,116,84,48,126,180,40,
        85,104,80,190,208,196,49,203,42,173,15,202,112,255,50,105,
        8,98,0,36,209,251,186,237,69,129,115,109,132,159,238,74,
        195,46,193,1,230,37,72,153,185,179,123,249,206,191,223,113,
        41,205,108,19,100,155,99,157,192,75,183,165,137,95,177,23,
        244,188,211,70,207,55,94,71,148,250,252,91,151,254,90,172,
        60,76,3,53,243,35,184,93,106,146,213,33,68,81,198,125,
        57,131,220,170,124,119,86,5,27,164,21,52,30,28,248,82,
        32,20,233,189,221,228,161,224,138,241,214,122,187,227,64,79
};

static const byte Camellia_s4[256] =
{
        112,44,179,192,228,87,234,174,35,107,69,165,237,79,29,146,
        134,175,124,31,62,220,94,11,166,57,213,93,217,90,81,108,
        139,154,251,176,116,43,240,132,223,203,52,118,109,169,209,4,
        20,58,222,17,50,156,83,242,254,207,195,122,36,232,96,105,
        170,160,161,98,84,30,224,100,16,0,163,117,138,230,9,221,
        135,131,205,144,115,246,157,191,82,216,200,198,129,111,19,99,
        233,167,159,188,41,249,47,180,120,6,231,113,212,171,136,141,
        114,185,248,172,54,42,60,241,64,211,187,67,21,173,119,128,
        130,236,39,229,133,53,12,65,239,147,25,33,14,78,101,189,
        184,143,235,206,48,95,197,26,225,202,71,61,1,214,86,77,
        13,102,204,45,18,32,177,153,76,194,126,5,183,49,23,215,
        88,97,27,28,15,22,24,34,68,178,181,145,8,168,252,80,
        208,125,137,151,91,149,255,210,196,72,247,219,3,218,63,148,
        92,2,74,51,103,243,127,226,155,38,55,59,150,75,190,46,
        121,140,110,142,245,182,253,89,152,106,70,186,37,66,162,250,
        7,85,238,10,73,104,56,164,40,123,201,193,227,244,199,158
};
//-------------------

static const word32 Blowfish_p_init[] =
{
  608135816U, 2242054355U,  320440878U,   57701188U,
 2752067618U,  698298832U,  137296536U, 3964562569U,
 1160258022U,  953160567U, 3193202383U,  887688300U,
 3232508343U, 3380367581U, 1065670069U, 3041331479U,
 2450970073U, 2306472731U
} ;

static const word32 Blowfish_s_init[4*256] = {
 3509652390U, 2564797868U,  805139163U, 3491422135U,
 3101798381U, 1780907670U, 3128725573U, 4046225305U,
  614570311U, 3012652279U,  134345442U, 2240740374U,
 1667834072U, 1901547113U, 2757295779U, 4103290238U,
  227898511U, 1921955416U, 1904987480U, 2182433518U,
 2069144605U, 3260701109U, 2620446009U,  720527379U,
 3318853667U,  677414384U, 3393288472U, 3101374703U,
 2390351024U, 1614419982U, 1822297739U, 2954791486U,
 3608508353U, 3174124327U, 2024746970U, 1432378464U,
 3864339955U, 2857741204U, 1464375394U, 1676153920U,
 1439316330U,  715854006U, 3033291828U,  289532110U,
 2706671279U, 2087905683U, 3018724369U, 1668267050U,
  732546397U, 1947742710U, 3462151702U, 2609353502U,
 2950085171U, 1814351708U, 2050118529U,  680887927U,
  999245976U, 1800124847U, 3300911131U, 1713906067U,
 1641548236U, 4213287313U, 1216130144U, 1575780402U,
 4018429277U, 3917837745U, 3693486850U, 3949271944U,
  596196993U, 3549867205U,  258830323U, 2213823033U,
  772490370U, 2760122372U, 1774776394U, 2652871518U,
  566650946U, 4142492826U, 1728879713U, 2882767088U,
 1783734482U, 3629395816U, 2517608232U, 2874225571U,
 1861159788U,  326777828U, 3124490320U, 2130389656U,
 2716951837U,  967770486U, 1724537150U, 2185432712U,
 2364442137U, 1164943284U, 2105845187U,  998989502U,
 3765401048U, 2244026483U, 1075463327U, 1455516326U,
 1322494562U,  910128902U,  469688178U, 1117454909U,
  936433444U, 3490320968U, 3675253459U, 1240580251U,
  122909385U, 2157517691U,  634681816U, 4142456567U,
 3825094682U, 3061402683U, 2540495037U,   79693498U,
 3249098678U, 1084186820U, 1583128258U,  426386531U,
 1761308591U, 1047286709U,  322548459U,  995290223U,
 1845252383U, 2603652396U, 3431023940U, 2942221577U,
 3202600964U, 3727903485U, 1712269319U,  422464435U,
 3234572375U, 1170764815U, 3523960633U, 3117677531U,
 1434042557U,  442511882U, 3600875718U, 1076654713U,
 1738483198U, 4213154764U, 2393238008U, 3677496056U,
 1014306527U, 4251020053U,  793779912U, 2902807211U,
  842905082U, 4246964064U, 1395751752U, 1040244610U,
 2656851899U, 3396308128U,  445077038U, 3742853595U,
 3577915638U,  679411651U, 2892444358U, 2354009459U,
 1767581616U, 3150600392U, 3791627101U, 3102740896U,
  284835224U, 4246832056U, 1258075500U,  768725851U,
 2589189241U, 3069724005U, 3532540348U, 1274779536U,
 3789419226U, 2764799539U, 1660621633U, 3471099624U,
 4011903706U,  913787905U, 3497959166U,  737222580U,
 2514213453U, 2928710040U, 3937242737U, 1804850592U,
 3499020752U, 2949064160U, 2386320175U, 2390070455U,
 2415321851U, 4061277028U, 2290661394U, 2416832540U,
 1336762016U, 1754252060U, 3520065937U, 3014181293U,
  791618072U, 3188594551U, 3933548030U, 2332172193U,
 3852520463U, 3043980520U,  413987798U, 3465142937U,
 3030929376U, 4245938359U, 2093235073U, 3534596313U,
  375366246U, 2157278981U, 2479649556U,  555357303U,
 3870105701U, 2008414854U, 3344188149U, 4221384143U,
 3956125452U, 2067696032U, 3594591187U, 2921233993U,
    2428461U,  544322398U,  577241275U, 1471733935U,
  610547355U, 4027169054U, 1432588573U, 1507829418U,
 2025931657U, 3646575487U,  545086370U,   48609733U,
 2200306550U, 1653985193U,  298326376U, 1316178497U,
 3007786442U, 2064951626U,  458293330U, 2589141269U,
 3591329599U, 3164325604U,  727753846U, 2179363840U,
  146436021U, 1461446943U, 4069977195U,  705550613U,
 3059967265U, 3887724982U, 4281599278U, 3313849956U,
 1404054877U, 2845806497U,  146425753U, 1854211946U,

 1266315497U, 3048417604U, 3681880366U, 3289982499U,
 2909710000U, 1235738493U, 2632868024U, 2414719590U,
 3970600049U, 1771706367U, 1449415276U, 3266420449U,
  422970021U, 1963543593U, 2690192192U, 3826793022U,
 1062508698U, 1531092325U, 1804592342U, 2583117782U,
 2714934279U, 4024971509U, 1294809318U, 4028980673U,
 1289560198U, 2221992742U, 1669523910U,   35572830U,
  157838143U, 1052438473U, 1016535060U, 1802137761U,
 1753167236U, 1386275462U, 3080475397U, 2857371447U,
 1040679964U, 2145300060U, 2390574316U, 1461121720U,
 2956646967U, 4031777805U, 4028374788U,   33600511U,
 2920084762U, 1018524850U,  629373528U, 3691585981U,
 3515945977U, 2091462646U, 2486323059U,  586499841U,
  988145025U,  935516892U, 3367335476U, 2599673255U,
 2839830854U,  265290510U, 3972581182U, 2759138881U,
 3795373465U, 1005194799U,  847297441U,  406762289U,
 1314163512U, 1332590856U, 1866599683U, 4127851711U,
  750260880U,  613907577U, 1450815602U, 3165620655U,
 3734664991U, 3650291728U, 3012275730U, 3704569646U,
 1427272223U,  778793252U, 1343938022U, 2676280711U,
 2052605720U, 1946737175U, 3164576444U, 3914038668U,
 3967478842U, 3682934266U, 1661551462U, 3294938066U,
 4011595847U,  840292616U, 3712170807U,  616741398U,
  312560963U,  711312465U, 1351876610U,  322626781U,
 1910503582U,  271666773U, 2175563734U, 1594956187U,
   70604529U, 3617834859U, 1007753275U, 1495573769U,
 4069517037U, 2549218298U, 2663038764U,  504708206U,
 2263041392U, 3941167025U, 2249088522U, 1514023603U,
 1998579484U, 1312622330U,  694541497U, 2582060303U,
 2151582166U, 1382467621U,  776784248U, 2618340202U,
 3323268794U, 2497899128U, 2784771155U,  503983604U,
 4076293799U,  907881277U,  423175695U,  432175456U,
 1378068232U, 4145222326U, 3954048622U, 3938656102U,
 3820766613U, 2793130115U, 2977904593U,   26017576U,
 3274890735U, 3194772133U, 1700274565U, 1756076034U,
 4006520079U, 3677328699U,  720338349U, 1533947780U,
  354530856U,  688349552U, 3973924725U, 1637815568U,
  332179504U, 3949051286U,   53804574U, 2852348879U,
 3044236432U, 1282449977U, 3583942155U, 3416972820U,
 4006381244U, 1617046695U, 2628476075U, 3002303598U,
 1686838959U,  431878346U, 2686675385U, 1700445008U,
 1080580658U, 1009431731U,  832498133U, 3223435511U,
 2605976345U, 2271191193U, 2516031870U, 1648197032U,
 4164389018U, 2548247927U,  300782431U,  375919233U,
  238389289U, 3353747414U, 2531188641U, 2019080857U,
 1475708069U,  455242339U, 2609103871U,  448939670U,
 3451063019U, 1395535956U, 2413381860U, 1841049896U,
 1491858159U,  885456874U, 4264095073U, 4001119347U,
 1565136089U, 3898914787U, 1108368660U,  540939232U,
 1173283510U, 2745871338U, 3681308437U, 4207628240U,
 3343053890U, 4016749493U, 1699691293U, 1103962373U,
 3625875870U, 2256883143U, 3830138730U, 1031889488U,
 3479347698U, 1535977030U, 4236805024U, 3251091107U,
 2132092099U, 1774941330U, 1199868427U, 1452454533U,
  157007616U, 2904115357U,  342012276U,  595725824U,
 1480756522U,  206960106U,  497939518U,  591360097U,
  863170706U, 2375253569U, 3596610801U, 1814182875U,
 2094937945U, 3421402208U, 1082520231U, 3463918190U,
 2785509508U,  435703966U, 3908032597U, 1641649973U,
 2842273706U, 3305899714U, 1510255612U, 2148256476U,
 2655287854U, 3276092548U, 4258621189U,  236887753U,
 3681803219U,  274041037U, 1734335097U, 3815195456U,
 3317970021U, 1899903192U, 1026095262U, 4050517792U,
  356393447U, 2410691914U, 3873677099U, 3682840055U,

 3913112168U, 2491498743U, 4132185628U, 2489919796U,
 1091903735U, 1979897079U, 3170134830U, 3567386728U,
 3557303409U,  857797738U, 1136121015U, 1342202287U,
  507115054U, 2535736646U,  337727348U, 3213592640U,
 1301675037U, 2528481711U, 1895095763U, 1721773893U,
 3216771564U,   62756741U, 2142006736U,  835421444U,
 2531993523U, 1442658625U, 3659876326U, 2882144922U,
  676362277U, 1392781812U,  170690266U, 3921047035U,
 1759253602U, 3611846912U, 1745797284U,  664899054U,
 1329594018U, 3901205900U, 3045908486U, 2062866102U,
 2865634940U, 3543621612U, 3464012697U, 1080764994U,
  553557557U, 3656615353U, 3996768171U,  991055499U,
  499776247U, 1265440854U,  648242737U, 3940784050U,
  980351604U, 3713745714U, 1749149687U, 3396870395U,
 4211799374U, 3640570775U, 1161844396U, 3125318951U,
 1431517754U,  545492359U, 4268468663U, 3499529547U,
 1437099964U, 2702547544U, 3433638243U, 2581715763U,
 2787789398U, 1060185593U, 1593081372U, 2418618748U,
 4260947970U,   69676912U, 2159744348U,   86519011U,
 2512459080U, 3838209314U, 1220612927U, 3339683548U,
  133810670U, 1090789135U, 1078426020U, 1569222167U,
  845107691U, 3583754449U, 4072456591U, 1091646820U,
  628848692U, 1613405280U, 3757631651U,  526609435U,
  236106946U,   48312990U, 2942717905U, 3402727701U,
 1797494240U,  859738849U,  992217954U, 4005476642U,
 2243076622U, 3870952857U, 3732016268U,  765654824U,
 3490871365U, 2511836413U, 1685915746U, 3888969200U,
 1414112111U, 2273134842U, 3281911079U, 4080962846U,
  172450625U, 2569994100U,  980381355U, 4109958455U,
 2819808352U, 2716589560U, 2568741196U, 3681446669U,
 3329971472U, 1835478071U,  660984891U, 3704678404U,
 4045999559U, 3422617507U, 3040415634U, 1762651403U,
 1719377915U, 3470491036U, 2693910283U, 3642056355U,
 3138596744U, 1364962596U, 2073328063U, 1983633131U,
  926494387U, 3423689081U, 2150032023U, 4096667949U,
 1749200295U, 3328846651U,  309677260U, 2016342300U,
 1779581495U, 3079819751U,  111262694U, 1274766160U,
  443224088U,  298511866U, 1025883608U, 3806446537U,
 1145181785U,  168956806U, 3641502830U, 3584813610U,
 1689216846U, 3666258015U, 3200248200U, 1692713982U,
 2646376535U, 4042768518U, 1618508792U, 1610833997U,
 3523052358U, 4130873264U, 2001055236U, 3610705100U,
 2202168115U, 4028541809U, 2961195399U, 1006657119U,
 2006996926U, 3186142756U, 1430667929U, 3210227297U,
 1314452623U, 4074634658U, 4101304120U, 2273951170U,
 1399257539U, 3367210612U, 3027628629U, 1190975929U,
 2062231137U, 2333990788U, 2221543033U, 2438960610U,
 1181637006U,  548689776U, 2362791313U, 3372408396U,
 3104550113U, 3145860560U,  296247880U, 1970579870U,
 3078560182U, 3769228297U, 1714227617U, 3291629107U,
 3898220290U,  166772364U, 1251581989U,  493813264U,
  448347421U,  195405023U, 2709975567U,  677966185U,
 3703036547U, 1463355134U, 2715995803U, 1338867538U,
 1343315457U, 2802222074U, 2684532164U,  233230375U,
 2599980071U, 2000651841U, 3277868038U, 1638401717U,
 4028070440U, 3237316320U,    6314154U,  819756386U,
  300326615U,  590932579U, 1405279636U, 3267499572U,
 3150704214U, 2428286686U, 3959192993U, 3461946742U,
 1862657033U, 1266418056U,  963775037U, 2089974820U,
 2263052895U, 1917689273U,  448879540U, 3550394620U,
 3981727096U,  150775221U, 3627908307U, 1303187396U,
  508620638U, 2975983352U, 2726630617U, 1817252668U,
 1876281319U, 1457606340U,  908771278U, 3720792119U,
 3617206836U, 2455994898U, 1729034894U, 1080033504U,

  976866871U, 3556439503U, 2881648439U, 1522871579U,
 1555064734U, 1336096578U, 3548522304U, 2579274686U,
 3574697629U, 3205460757U, 3593280638U, 3338716283U,
 3079412587U,  564236357U, 2993598910U, 1781952180U,
 1464380207U, 3163844217U, 3332601554U, 1699332808U,
 1393555694U, 1183702653U, 3581086237U, 1288719814U,
  691649499U, 2847557200U, 2895455976U, 3193889540U,
 2717570544U, 1781354906U, 1676643554U, 2592534050U,
 3230253752U, 1126444790U, 2770207658U, 2633158820U,
 2210423226U, 2615765581U, 2414155088U, 3127139286U,
  673620729U, 2805611233U, 1269405062U, 4015350505U,
 3341807571U, 4149409754U, 1057255273U, 2012875353U,
 2162469141U, 2276492801U, 2601117357U,  993977747U,
 3918593370U, 2654263191U,  753973209U,   36408145U,
 2530585658U,   25011837U, 3520020182U, 2088578344U,
  530523599U, 2918365339U, 1524020338U, 1518925132U,
 3760827505U, 3759777254U, 1202760957U, 3985898139U,
 3906192525U,  674977740U, 4174734889U, 2031300136U,
 2019492241U, 3983892565U, 4153806404U, 3822280332U,
  352677332U, 2297720250U,   60907813U,   90501309U,
 3286998549U, 1016092578U, 2535922412U, 2839152426U,
  457141659U,  509813237U, 4120667899U,  652014361U,
 1966332200U, 2975202805U,   55981186U, 2327461051U,
  676427537U, 3255491064U, 2882294119U, 3433927263U,
 1307055953U,  942726286U,  933058658U, 2468411793U,
 3933900994U, 4215176142U, 1361170020U, 2001714738U,
 2830558078U, 3274259782U, 1222529897U, 1679025792U,
 2729314320U, 3714953764U, 1770335741U,  151462246U,
 3013232138U, 1682292957U, 1483529935U,  471910574U,
 1539241949U,  458788160U, 3436315007U, 1807016891U,
 3718408830U,  978976581U, 1043663428U, 3165965781U,
 1927990952U, 4200891579U, 2372276910U, 3208408903U,
 3533431907U, 1412390302U, 2931980059U, 4132332400U,
 1947078029U, 3881505623U, 4168226417U, 2941484381U,
 1077988104U, 1320477388U,  886195818U,   18198404U,
 3786409000U, 2509781533U,  112762804U, 3463356488U,
 1866414978U,  891333506U,   18488651U,  661792760U,
 1628790961U, 3885187036U, 3141171499U,  876946877U,
 2693282273U, 1372485963U,  791857591U, 2686433993U,
 3759982718U, 3167212022U, 3472953795U, 2716379847U,
  445679433U, 3561995674U, 3504004811U, 3574258232U,
   54117162U, 3331405415U, 2381918588U, 3769707343U,
 4154350007U, 1140177722U, 4074052095U,  668550556U,
 3214352940U,  367459370U,  261225585U, 2610173221U,
 4209349473U, 3468074219U, 3265815641U,  314222801U,
 3066103646U, 3808782860U,  282218597U, 3406013506U,
 3773591054U,  379116347U, 1285071038U,  846784868U,
 2669647154U, 3771962079U, 3550491691U, 2305946142U,
  453669953U, 1268987020U, 3317592352U, 3279303384U,
 3744833421U, 2610507566U, 3859509063U,  266596637U,
 3847019092U,  517658769U, 3462560207U, 3443424879U,
  370717030U, 4247526661U, 2224018117U, 4143653529U,
 4112773975U, 2788324899U, 2477274417U, 1456262402U,
 2901442914U, 1517677493U, 1846949527U, 2295493580U,
 3734397586U, 2176403920U, 1280348187U, 1908823572U,
 3871786941U,  846861322U, 1172426758U, 3287448474U,
 3383383037U, 1655181056U, 3139813346U,  901632758U,
 1897031941U, 2986607138U, 3066810236U, 3447102507U,
 1393639104U,  373351379U,  950779232U,  625454576U,
 3124240540U, 4148612726U, 2007998917U,  544563296U,
 2244738638U, 2330496472U, 2058025392U, 1291430526U,
  424198748U,   50039436U,   29584100U, 3605783033U,
 2429876329U, 2791104160U, 1057563949U, 3255363231U,
 3075367218U, 3463963227U, 1469046755U,  985887462U
};
//----------------

const array_info_t non_sparse_consts[] =
{
  { ARR(Blowfish_p_init),                 "Blowfish"       },
  { ARR(Blowfish_s_init),                 "Blowfish"       },
  { ARR(Camellia_s1),                     "Camellia"       },
  { ARR(Camellia_s2),                     "Camellia"       },
  { ARR(Camellia_s3),                     "Camellia"       },
  { ARR(Camellia_s4),                     "Camellia"       },
  { ARR(CAST_S),                          "CAST"           },
  { ARR(CAST256_t_m),                     "CAST256"        },
  { ARR(CAST256_t_r),                     "CAST256"        },
  { ARR(CRC32_m_tab),                     "CRC32"          },
  { ARR(DES_ei),                          "DES"            },
  { ARR(DES_fp),                          "DES"            },
  { ARR(DES_ip),                          "DES"            },
  { ARR(DES_p32i),                        "DES"            },
  { ARR(DES_pc1),                         "DES"            },
  { ARR(DES_pc2),                         "DES"            },
  { ARR(DES_sbox),                        "DES"            },
  { ARR(GOST_sBox),                       "GOST"           },
  { ARR(HAVAL_mc2),                       "HAVAL"          },
  { ARR(HAVAL_mc3),                       "HAVAL"          },
  { ARR(HAVAL_mc4),                       "HAVAL"          },
  { ARR(HAVAL_mc5),                       "HAVAL"          },
  { ARR(HAVAL_wi2),                       "HAVAL"          },
  { ARR(HAVAL_wi3),                       "HAVAL"          },
  { ARR(HAVAL_wi4),                       "HAVAL"          },
  { ARR(HAVAL_wi5),                       "HAVAL"          },
  { ARR(MARS_Sbox),                       "MARS"           },
  { ARR(MD2_S),                           "MD2"            },
  { ARR(MD5MAC_T),                        "MD5"            },
  { ARR(PKCS_DigestDecoration_MD2),       "PKCS_MD2"       },
  { ARR(PKCS_DigestDecoration_MD5),       "PKCS_MD5"       },
  { ARR(PKCS_DigestDecoration_RIPEMD160), "PKCS_RIPEMD160" },
  { ARR(PKCS_DigestDecoration_SHA256),    "PKCS_SHA256"    },
  { ARR(PKCS_DigestDecoration_SHA384),    "PKCS_SHA384"    },
  { ARR(PKCS_DigestDecoration_SHA512),    "PKCS_SHA512"    },
  { ARR(PKCS_DigestDecoration_Tiger),     "PKCS_Tiger"     },
  { ARR(RawDES_Spbox),                    "RawDES"         },
  { ARR(rc2_PITABLE),                     "RC2"            },
  { ARR(Rijndael_Td0),                    "Rijndael"       },
  { ARR(Rijndael_Td1),                    "Rijndael"       },
  { ARR(Rijndael_Td2),                    "Rijndael"       },
  { ARR(Rijndael_Td3),                    "Rijndael"       },
  { ARR(Rijndael_Td4),                    "Rijndael"       },
  { ARR(Rijndael_Te0),                    "Rijndael"       },
  { ARR(Rijndael_Te1),                    "Rijndael"       },
  { ARR(Rijndael_Te2),                    "Rijndael"       },
  { ARR(Rijndael_Te3),                    "Rijndael"       },
  { ARR(Rijndael_Te4),                    "Rijndael"       },
  { ARR(SAFER_exp_tab),                   "SAFER"          },
  { ARR(SAFER_log_tab),                   "SAFER"          },
  { ARR(SHA256_K),                        "SHA256"         },
  { ARR(SHA512_K),                        "SHA512"         },
  { ARR(SHARK_dec_cbox),                  "SHARK"          },
  { ARR(SHARK_enc_cbox),                  "SHARK"          },
  { ARR(SHARK_iG),                        "SHARK"          },
  { ARR(SKIPJACK_fTable),                 "SKIPJACK"       },
  { ARR(Square_Sd_or_SHARK_dec_sbox),     "Square/SHARK"   },
  { ARR(Square_Se_or_SHARK_enc_sbox),     "Square/SHARK"   },
  { ARR(Square_Td),                       "Square"         },
  { ARR(Square_Te),                       "Square"         },
  { ARR(Tiger_table),                     "Tiger"          },
  { ARR(Twofish_mds),                     "Twofish"        },
  { ARR(Twofish_q),                       "Twofish"        },
  { ARR(WAKE_tt),                         "WAKE"           },
  { ARR(Whirlpool_C0),                    "Whirlpool"      },
  { ARR(Whirlpool_C1),                    "Whirlpool"      },
  { ARR(Whirlpool_C2),                    "Whirlpool"      },
  { ARR(Whirlpool_C3),                    "Whirlpool"      },
  { ARR(Whirlpool_rc),                    "Whirlpool"      },
  { ARR(zdeflate_lengthCodes),            "zlib"           },
  { ARR(zinflate_distanceExtraBits),      "zlib"           },
  { ARR(zinflate_distanceStarts),         "zlib"           },
  { ARR(zinflate_lengthExtraBits),        "zlib"           },
  { ARR(zinflate_lengthStarts),           "zlib"           },
  { NULL, 0, NULL, NULL }
};



================================================
File: src/findcrypt/findcrypt.cpp
================================================
// FindCrypt - find constants used in crypto algorithms
// Copyright 2006 Ilfak Guilfanov <ig@hexblog.com>
// Copyright 2011 Vlad Tsyrklevich <vlad@tsyrklevich.net>
// This is a freeware program.
// This copytight message must be kept intact.

// This plugin looks for constant arrays used in popular crypto algorithms.
// If a crypto algorithm is found, it will rename the appropriate locations
// of the program and put bookmarks on them.

// Version 2-with-mmx
// Adapted to x64dbg
#include <set>
#include <thread>
#include "findcrypt.h"

Findcrypt::Findcrypt(duint VirtualStart, duint VirtualEnd)
{
	// Sanity check: make sure there are no duplicate entries anywhere
	static bool initOnce = false;

	if (!initOnce)
	{
		initOnce = true;
		VerifyConstants(non_sparse_consts);
		VerifyConstants(sparse_consts);
	}

	// Real class constructor code
	m_StartAddress	= VirtualStart;
	m_EndAddress	= VirtualEnd;
	m_DataSize		= VirtualEnd - VirtualStart;
	m_Data			= (PBYTE)malloc(m_DataSize);

	m_AESNICount	= 0;
	m_CryptoCount	= 0;

	// Read the remote memory into the local buffer
	if (!DbgMemRead(VirtualStart, m_Data, m_DataSize))
		memset(m_Data, 0, m_DataSize);
}

Findcrypt::~Findcrypt()
{
	if (m_Data)
		free(m_Data);
}

void Findcrypt::VerifyConstants(const array_info_t *consts)
{
	std::set<std::string> myset;

	// Verifies that all algorithm entries are different
	for (const array_info_t *ptr = consts; ptr->size != 0; ptr++)
	{
		std::string s((const char*)ptr->array, ptr->size);

		if (!myset.insert(s).second)
		{
			dprintf("duplicate array %s!", ptr->name);
			__debugbreak();
		}
	}
}

void Findcrypt::ScanConstants()
{
	for (duint ea = m_StartAddress; ea < m_EndAddress; ea = ea + 1)
	{
		// Update the status bar every 65k bytes
		if ((ea % 0x10000) == 0)
			ShowAddress(ea);

		// Check against normal constants
		BYTE b = GetByte(ea);

		for (const array_info_t *ptr = non_sparse_consts; ptr->size != 0; ptr++)
		{
			if (b != GetFirstByte(ptr))
				continue;

			if (MatchArrayPattern(ea, ptr))
			{
				dprintf("%p: Found const array %s (used in %s)\n", ea, ptr->name, ptr->algorithm);
				DbgSetAutoCommentAt(ea, ptr->algorithm);
				DbgSetAutoLabelAt(ea, ptr->name);
				m_CryptoCount++;
				break;
			}
		}

		// Check against sparse constants
		for (const array_info_t *ptr = sparse_consts; ptr->size != 0; ptr++)
		{
			if (b != GetFirstByte(ptr))
				continue;

			if (MatchSparsePattern(ea, ptr))
			{
				dprintf("%p: Found sparse constants for %s\n", ea, ptr->algorithm);
				DbgSetAutoCommentAt(ea, ptr->algorithm);
				m_CryptoCount++;
				break;
			}
		}
	}

	for (duint ea = m_StartAddress; ea < m_EndAddress; ea = ea + 1)
	{
		// Update the status bar every 65k bytes
		if ((ea % 0x10000) == 0)
			ShowAddress(ea);

		if (GetByte(ea) == 0x66 && GetByte(ea + 1) == 0x0f)
		{
			char *instruction = nullptr;

			if (GetByte(ea + 2) == 0x38)
			{
				switch (GetByte(ea + 3))
				{
				case 0xdb: instruction = "AESIMC";		break;
				case 0xdc: instruction = "AESENC";		break;
				case 0xdd: instruction = "AESENCLAST";	break;
				case 0xde: instruction = "AESDEC";		break;
				case 0xdf: instruction = "AESDECLAST";	break;
				}
			}
			else if (GetByte(ea + 2) == 0x3a && GetByte(ea + 3) == 0xdf)
				instruction = "AESKEYGENASSIST";

			if (instruction)
			{
				dprintf("%p: May be %s\n", ea, instruction);
				m_AESNICount++;
			}
		}
	}
}

BYTE Findcrypt::GetFirstByte(const array_info_t *ai)
{
	const BYTE *ptr = (const BYTE *)ai->array;

#ifndef IS_LITTLE_ENDIAN
	if (!inf.mf)
		return ptr[0];
#endif // IS_LITTLE_ENDIAN

	return ptr[ai->elsize - 1];
}

bool Findcrypt::MatchArrayPattern(duint Address, const array_info_t *ai)
{
	BYTE *ptr = (BYTE *)ai->array;

	for (size_t i = 0; i < ai->size; i++)
	{
		switch (ai->elsize)
		{
		case 1:
			if (GetByte(Address) != *(BYTE *)ptr)
				return false;
			break;
		case 2:
			if (GetWord(Address) != *(WORD *)ptr)
				return false;
			break;
		case 4:
			if (GetLong(Address) != *(ULONG *)ptr)
				return false;
			break;
		case 8:
			if (GetQword(Address) != *(UINT64 *)ptr)
				return false;
			break;
		default:
			dprintf("interr: unexpected array '%s' element size %d\n",
				ai->name, ai->elsize);
			__debugbreak();
		}

		ptr		+= ai->elsize;
		Address += ai->elsize;
	}

	return true;
}

bool Findcrypt::MatchSparsePattern(duint Address, const array_info_t *ai)
{
	const unsigned int *ptr = (const unsigned int *)ai->array;

	// Match first 4 bytes
	if (GetLong(Address) != *ptr++)
		return false;

	Address += 4;

	// Continue with looping the remaining pattern
	for (size_t i = 1; i < ai->size; i++)
	{
		unsigned int c = *ptr++;

#ifndef IS_LITTLE_ENDIAN
		if (inf.mf)
			c = swap32(c);
#endif // IS_LITTLE_ENDIAN

		// Look for the constant in the next N bytes
		const size_t N = 64;
		BYTE mem[N + 4];
		GetManyBytes(Address, mem, sizeof(mem));
		int j;
		for (j = 0; j < N; j++)
		{
			if (*(ULONG*)(mem + j) == c)
				break;
		}

		if (j == N)
			return false;

		Address += j + 4;
	}

	return true;
}

void Findcrypt::ShowAddress(duint Address)
{
	char buf[64];

	sprintf_s(buf, "\nAddress: %p\n", Address);
	GuiAddStatusBarMessage(buf);
}

void FindcryptScanRange(duint Start, duint End)
{
	dprintf("Starting a crypto scan of range %p to %p...\n", Start, End);

	// Run on this thread (which should be a command thread)
	Findcrypt scanner(Start, End);
	scanner.ScanConstants();

	dprintf("Found %d possible AES-NI instructions and %d constant arrays.\n", scanner.AESNICount(), scanner.CryptoCount());
}

void FindcryptScanModule()
{
	duint moduleStart = DbgGetCurrentModule();
	duint moduleEnd = moduleStart + DbgFunctions()->ModSizeFromAddr(moduleStart);

	FindcryptScanRange(moduleStart, moduleEnd);
}

void FindcryptScanAll()
{
	int totalAES	= 0;
	int totalCrypto	= 0;

	dprintf("Starting a crypto scan for all memory ranges...\n");

	DbgEnumMemoryRanges([&](duint Start, duint End)
	{
		Findcrypt scanner(Start, End);
		scanner.ScanConstants();

		// Increment counters
		totalAES	+= scanner.AESNICount();
		totalCrypto += scanner.CryptoCount();

		return true;
	});

	dprintf("Found %d possible AES-NI instructions and %d constant arrays.\n", totalAES, totalCrypto);
}

void Plugin_FindcryptLogo()
{
	dprintf("---- Findcrypt v2 with AES-NI extensions ----\n");
	dprintf("Executing self test...\n");

	Findcrypt test(0, 1);
	test.VerifyConstants(non_sparse_consts);
	test.VerifyConstants(sparse_consts);

	//
	// Displays the startup information for this build of findcrypt
	//
	int counter = 1;

	auto DisplayArray = [&](const array_info_t *ai)
	{
		for (const char *prev = nullptr; ai->size != 0; ai++)
		{
			if (!prev || (prev && _stricmp(prev, ai->algorithm) != 0))
			{
				dprintf("%s, ", ai->algorithm);

				if ((++counter) % 10 == 0)
					dprintf("\n\t");
			}

			prev = ai->algorithm;
		}
	};

	dprintf("Available constant checking:\n\t");
	DisplayArray(non_sparse_consts);
	DisplayArray(sparse_consts);
	dprintf("\n");
}


================================================
File: src/findcrypt/findcrypt.h
================================================
#pragma once

#include "../idaldr/stdafx.h"

#define IS_LITTLE_ENDIAN

#if defined(__GNUC__) || defined(__MWERKS__)
	#define WORD64_AVAILABLE
	typedef unsigned long long word64;
	typedef unsigned long word32;
	typedef unsigned char byte;
	#define W64LIT(x) x##LL
#elif defined(_MSC_VER) || defined(__BCPLUSPLUS__)
	#define WORD64_AVAILABLE
	typedef unsigned __int64 word64;
	typedef unsigned __int32 word32;
	typedef unsigned __int8 byte;
	#define W64LIT(x) x##ui64
#endif

struct array_info_t
{
	const void *array;
	size_t size;
	size_t elsize;
	const char *name;
	const char *algorithm;
};

extern const array_info_t non_sparse_consts[];
extern const array_info_t sparse_consts[];

#define ARR(x)  x, ARRAYSIZE(x), sizeof(x[0]), #x

class Findcrypt
{
public:
	Findcrypt(duint VirtualStart, duint VirtualEnd);
	~Findcrypt();

	void ScanConstants();
	void VerifyConstants(const array_info_t *consts);

	int AESNICount()
	{
		return m_AESNICount;
	}

	int CryptoCount()
	{
		return m_CryptoCount;
	}

protected:
	BYTE GetFirstByte(const array_info_t *ai);
	bool MatchArrayPattern(duint Address, const array_info_t *ai);
	bool MatchSparsePattern(duint Address, const array_info_t *ai);

	void ShowAddress(duint Address);

	template<typename T>
	T GetValueType(duint Address)
	{
		if (Address < m_StartAddress || (Address + sizeof(T)) > m_EndAddress)
			return (T)0;

		return *(T *)&m_Data[Address - m_StartAddress];
	}

	BYTE GetByte(duint Address)
	{
		return GetValueType<BYTE>(Address);
	}

	WORD GetWord(duint Address)
	{
		return GetValueType<WORD>(Address);
	}

	DWORD GetLong(duint Address)
	{
		return GetValueType<DWORD>(Address);
	}

	UINT64 GetQword(duint Address)
	{
		return GetValueType<UINT64>(Address);
	}

	bool GetManyBytes(duint Address, void *Buffer, size_t Size)
	{
		// Boundary check
		if (Address < m_StartAddress || (Address + Size) > m_EndAddress)
			return false;

		memcpy(Buffer, &m_Data[Address - m_StartAddress], Size);
		return true;
	}

private:
	duint m_StartAddress;
	duint m_EndAddress;
	duint m_DataSize;
	PBYTE m_Data;

	int m_AESNICount;
	int m_CryptoCount;
};

void FindcryptScanRange(duint Start, duint End);
void FindcryptScanModule();
void FindcryptScanAll();

void Plugin_FindcryptLogo();


================================================
File: src/findcrypt/sparse.cpp
================================================
#include "findcrypt.h"

// Various constants used in crypto algorithms
// They were copied from public domain codes

static const word32 SHA_1[] =
{
 0x67452301L,
 0xEFCDAB89L,
 0x98BADCFEL,
 0x10325476L,
 0xC3D2E1F0L,
};

static const word32 RC5_RC6[] =
{
  0xb7e15163L,    // magic constant P for wordsize
  0x9e3779b9L,    // magic constant Q for wordsize
};

static const word32 MD5[] =
{
  0xd76aa478,
  0xe8c7b756,
  0x242070db,
  0xc1bdceee,
  0xf57c0faf,
  0x4787c62a,
  0xa8304613,
  0xfd469501,
  0x698098d8,
  0x8b44f7af,
  0xffff5bb1,
  0x895cd7be,
  0x6b901122,
  0xfd987193,
  0xa679438e,
  0x49b40821,

  0xf61e2562,
  0xc040b340,
  0x265e5a51,
  0xe9b6c7aa,
  0xd62f105d,
  0x02441453,
  0xd8a1e681,
  0xe7d3fbc8,
  0x21e1cde6,
  0xc33707d6,
  0xf4d50d87,
  0x455a14ed,
  0xa9e3e905,
  0xfcefa3f8,
  0x676f02d9,
  0x8d2a4c8a,

  0xfffa3942,
  0x8771f681,
  0x6d9d6122,
  0xfde5380c,
  0xa4beea44,
  0x4bdecfa9,
  0xf6bb4b60,
  0xbebfbc70,
  0x289b7ec6,
  0xeaa127fa,
  0xd4ef3085,
  0x04881d05,
  0xd9d4d039,
  0xe6db99e5,
  0x1fa27cf8,
  0xc4ac5665,

  0xf4292244,
  0x432aff97,
  0xab9423a7,
  0xfc93a039,
  0x655b59c3,
  0x8f0ccc92,
  0xffeff47d,
  0x85845dd1,
  0x6fa87e4f,
  0xfe2ce6e0,
  0xa3014314,
  0x4e0811a1,
  0xf7537e82,
  0xbd3af235,
  0x2ad7d2bb,
  0xeb86d391,
};

static const word32 MD4[] =
{
  0x67452301L,
  0xefcdab89L,
  0x98badcfeL,
  0x10325476L,
};

static const word32 HAVAL[] =
{
  0x243F6A88,
  0x85A308D3,
  0x13198A2E,
  0x03707344,
  0xA4093822,
  0x299F31D0,
  0x082EFA98,
  0xEC4E6C89,
};

// NB: all sparse arrays must be word32!
const array_info_t sparse_consts[] =
{
  { ARR(SHA_1),      "SHA-1"     },
  { ARR(RC5_RC6),    "RC5_RC6"   },
  { ARR(MD5),        "MD5"       },
  { ARR(MD4),        "MD4"       },
  { ARR(HAVAL),      "HAVAL"     },
  { NULL, 0, NULL, NULL }
};


================================================
File: src/idaldr/Ldr.cpp
================================================
#include "stdafx.h"

int MatchNodeData(IDASigNode *Node, BYTE *Input, size_t Length)
{
	//
	// Matches a pattern of bytes with an input value
	//
	// Returns false when:
	//  Input buffer is too short
	//  Pattern does not match
	//
	// Returns true when:
	//  Pattern and buffer match
	//
	for (int i = 0; i < Node->m_DataIndex; i++)
	{
		// Check if the buffer was too short
		if (Length <= 0)
			return false;

		if (Node->Data[i].Type == 0xFF)
		{
			if (*Input != Node->Data[i].Value)
			{
				// Invalid
				return false;
			}

			Input++;
			Length--;
		}
		else if (Node->Data[i].Type == 0x00)
		{
			//
			// Relocation
			//
			// The bytes here don't matter
			//
			Input++;
			Length--;
		}
	}

	return true;
}

bool MatchSignatureLeaf(IDASigLeaf *Leaf, BYTE *Input, size_t Length)
{
	// Leaves depend on the CRC16
	if (Leaf->Crc16 == 0)
		return true;

	return true;
}

struct SignatureLookup
{
	// IN
	BYTE	*InputBuffer;
	size_t	InputSize;

	// OUT
	char	Name[256];
	int		Length;
};

bool MatchSignatureSymbol(IDASigNode *Base, SignatureLookup *Info)
{
	if (Base->Nodes.size() > 0)
	{
		// Check each node
		for (auto& node : Base->Nodes)
		{
			// Does this node match?
			if (MatchNodeData(&node, Info->InputBuffer, Info->InputSize))
			{
				// It does match, increment the input pointer and decrease length
				Info->InputBuffer	+= node.m_DataIndex;
				Info->InputSize		-= node.m_DataIndex;
				Info->Length		+= node.m_DataIndex;

				// Recurse
				return MatchSignatureSymbol(&node, Info);
			}
		}
	}
	else if (Base->Leaves.size() > 0)
	{
		// Check each leaf
		for (auto itr = Base->Leaves.begin(); itr != Base->Leaves.end(); itr++)
		{
			IDASigLeaf& leaf = *itr;

			// Does this leaf match?
			if (MatchSignatureLeaf(&leaf, Info->InputBuffer, Info->InputSize))
			{
				Info->Length += leaf.CrcOffset;

				// Check the CRC16 if there was one
				if (leaf.Crc16 != 0)
				{
					WORD calc = crc16(Info->InputBuffer, leaf.CrcOffset);

					if (calc != leaf.Crc16)
						return false;
				}

				// This entry has now been used, so remove it
				Base->Leaves.erase(itr);

				strcpy_s(Info->Name, leaf.Symbol);
				return true;
			}
		}
	}

	return false;
}

bool ApplySignatureSymbols(char *Path, duint ModuleBase)
{
	_plugin_logprintf("Opening sig file '%s'\n", Path);

	// Load the signature
	IDASig signature;

	if (!signature.Load(Path))
		return false;

	_plugin_logprintf("Loading signatures in '%s' (Version %d)\n", signature.SignatureName, (int)signature.SignatureVersion);

	// Architecture check
#ifdef _WIN64
	if (!signature.Support64Bit())
	{
		_plugin_logprintf("Signature type (64-bit) is not supported\n");
		return false;
	}
#else
	if (!signature.Support32Bit())
	{
		_plugin_logprintf("Signature type (32-bit) is not supported\n");
		return false;
	}
#endif // _WIN64

	// Get the module size
	duint moduleSize = DbgFunctions()->ModSizeFromAddr(ModuleBase);

	if (moduleSize <= 0)
	{
		_plugin_logprintf("Couldn't get module size from adress 0x%llX\n", ModuleBase);
		return false;
	}

	// Read the entire image to a local buffer for scanning
	PBYTE imageCopy = (PBYTE)VirtualAlloc(nullptr, moduleSize, MEM_COMMIT, PAGE_READWRITE);

	if (!imageCopy || !DbgMemRead(ModuleBase, imageCopy, moduleSize))
	{
		_plugin_logprintf("Failed to make a copy of the remote image\n", ModuleBase);

		if (imageCopy)
			VirtualFree(imageCopy, 0, MEM_RELEASE);

		return false;
	}

	// Scan memory
	UINT32 count = 0;

	for (PBYTE va = imageCopy; va < (imageCopy + moduleSize);)
	{
		SignatureLookup info;
		memset(&info, 0, sizeof(SignatureLookup));

		info.InputBuffer	= va;
		info.InputSize		= (va - imageCopy);

		if (MatchSignatureSymbol(&signature.BaseNode, &info))
		{
			duint remoteVA	= ModuleBase + (size_t)(va - imageCopy);
			va				+= info.Length;

			//_plugin_logprintf("VA: 0x%llx - %s\n", (ULONGLONG)remoteVA, info.Name);

			DbgSetAutoLabelAt(remoteVA, info.Name);
			count++;
		}
		else
		{
			va++;
		}
	}

	// Free memory
	VirtualFree(imageCopy, 0, MEM_RELEASE);

	_plugin_logprintf("Applied %d signatures(s)\n", count);
	return true;
}

bool ApplyDiffSymbols(char *Path, duint UNUSED_ModuleBase)
{
	_plugin_logprintf("Opening dif file '%s'\n", Path);

	// Parse the diff
	IDADiffReader diff;

	if (!diff.Load(Path))
		return false;

	// Convert the module name in the DIFF to an address
	duint moduleBase = DbgFunctions()->ModBaseFromName(diff.GetModule());

	if (!moduleBase)
	{
		_plugin_logprintf("Couldn't get base of module '%s'\n", diff.GetModule());
		return false;
	}

	// Load the image and query the size
	DWORD loadedSize	= 0;
	ULONG_PTR fileMapVa = 0;

	{
		char modPath[MAX_PATH];
		if (DbgFunctions()->ModPathFromAddr(moduleBase, modPath, ARRAYSIZE(modPath)) <= 0)
		{
			_plugin_logprintf("Failed to get module path for '%s'\n", diff.GetModule());
			return false;
		}

		// Load with TitanEngine
		HANDLE fileHandle;
		HANDLE fileMap;

		if (!StaticFileLoad(modPath, GENERIC_READ, true, &fileHandle, &loadedSize, &fileMap, &fileMapVa))
		{
			_plugin_logprintf("Couldn't load a static copy of '%s'\n", modPath);
			return false;
		}
	}

	// Patches use the FILE OFFSET (not virtual offset)
	UINT32 count = 0;

	for (auto& patch : diff.GetPatches())
	{
		// Convert the file offset to a virtual address
		ULONGLONG rva	= ConvertFileOffsetToVA(fileMapVa, (ULONG_PTR)(fileMapVa + patch.Offset), false);
		ULONGLONG va	= (rva == 0) ? 0 : (rva + moduleBase);

		// Get a copy of the original
		if (va)
		{
			BYTE val = 0;

			if (DbgMemRead(va, &val, sizeof(BYTE)) && val != patch.Old)
				_plugin_logprintf("WARNING: Old patch value does not match (Expected 0x%02X / 0x%02X) (File: 0x%llX) (VA: 0x%llX)\n", (ULONG)patch.Old, (ULONG)val, patch.Offset, va);
		}

		// Overwrite
		if (!va || !DbgFunctions()->MemPatch(va, &patch.New, sizeof(BYTE)))
		{
			_plugin_logprintf("Unable to apply a patch (File: 0x%llX) (VA: 0x%llX)\n", patch.Offset, va);
			continue;
		}

		count++;
	}

	// Unload the static copy
	StaticFileUnloadW(nullptr, false, nullptr, 0, nullptr, fileMapVa);

	_plugin_logprintf("Applied %d patch(es) to %s\n", count, diff.GetModule());
	return true;
}

bool ApplyMapSymbols(char *Path, duint ModuleBase)
{
	_plugin_logprintf("Opening map file '%s'\n", Path);

	// Parse the map
	MapFile map;

	if (!map.Load(Path))
		return false;

    auto& segments = map.GetSegments();

	if (!Settings::UseSegments)
		segments.clear();

	// Use the executable sections as segments when they are not supplied
	// in the file
    if (segments.empty())
    {
        char modulePath[MAX_MODULE_SIZE];

        if (DbgFunctions()->ModPathFromAddr(ModuleBase, modulePath, ARRAYSIZE(modulePath)))
        {
            size_t sectionCount = GetPE32Data(modulePath, 0, UE_SECTIONNUMBER);

            for (size_t i = 0; i < sectionCount; i++)
            {
                MapFileSegment segdef;
                memset(&segdef, 0, sizeof(segdef));
                strcpy_s(segdef.Name, (const char*)GetPE32Data(modulePath, i, UE_SECTIONNAME));
                segdef.Start = GetPE32Data(modulePath, i, UE_SECTIONVIRTUALOFFSET);
                segdef.Length = GetPE32Data(modulePath, i, UE_SECTIONVIRTUALSIZE);
                segdef.Id = i + 1;

                segments.push_back(segdef);
            }
        }
    }

    // Print segments to log
    _plugin_logprintf("%d segment(s)\n", segments.size());

    for (auto& seg : segments)
        _plugin_logprintf("  %d: Start=0x%08llX, Length=0x%08llX, %s\n", seg.Id, seg.Start, seg.Length, seg.Name);

	// Apply each symbol manually
    for (auto& sym : map.GetSymbols())
        DbgSetAutoLabelAt((duint)(ModuleBase + map.GetSegmentStart(sym.Id) + sym.Offset), sym.Name);

	_plugin_logprintf("Applied %d symbol(s)\n", map.GetSymbols().size());
	return true;
}

bool ExportDiffSymbols(char *Path, duint ModuleBase)
{
	IDADiffWriter diff;

	// Get the array size of patches needed
	size_t size = 0;
	DbgFunctions()->PatchEnum(nullptr, &size);

	if (size <= 0)
	{
		_plugin_logprintf("No patches found!\n");
		return true;
	}

	// Set basic information
	{
		char temp[MAX_PATH];
		if (!DbgFunctions()->ModNameFromAddr(ModuleBase, temp, true))
		{
			_plugin_logprintf("Couldn't get module name for diff header\n");
			return false;
		}

		diff.SetDescription("Generated by x64dbg (IDALdr - https://github.com/Nukem9/SwissArmyKnife)\n");
		diff.SetModule(temp);
	}

	// Load the image and query the size
	DWORD loadedSize	= 0;
	ULONG_PTR fileMapVa = 0;
	ULONG_PTR fileBase	= 0;

	{
		char modPath[MAX_PATH];
		if (DbgFunctions()->ModPathFromAddr(ModuleBase, modPath, ARRAYSIZE(modPath)) <= 0)
		{
			_plugin_logprintf("Failed to get module path for address '0x%llX'\n", (ULONGLONG)ModuleBase);
			return false;
		}

		// Load with TitanEngine
		HANDLE fileHandle;
		HANDLE fileMap;

		if (!StaticFileLoad(modPath, GENERIC_READ, true, &fileHandle, &loadedSize, &fileMap, &fileMapVa))
		{
			_plugin_logprintf("Couldn't load a static copy of '%s'\n", modPath);
			return false;
		}

		fileBase = GetPE32DataFromMappedFile(fileMapVa, NULL, UE_IMAGEBASE);
	}

	// Store each patch
	DBGPATCHINFO *patchInfo = (DBGPATCHINFO *)BridgeAlloc(size);
	DbgFunctions()->PatchEnum(patchInfo, &size);

	for (UINT32 i = 0; i < (size / sizeof(DBGPATCHINFO)); i++)
	{
		// Is this the module that we want?
		if (DbgFunctions()->ModBaseFromAddr(patchInfo[i].addr) != ModuleBase)
			continue;

		// Translate the virtual address to a file offset
		ULONG_PTR vaoffset		= (patchInfo[i].addr - ModuleBase) + fileBase;
		ULONGLONG fileoffset	= ConvertVAtoFileOffset(fileMapVa, vaoffset, false);

		if (!fileoffset)
		{
			_plugin_logprintf("Unable to convert virtual address 0x%llX to file offset\n", (ULONGLONG)patchInfo[i].addr);
			continue;
		}

		DiffFileEntry entry;
		entry.Offset	= fileoffset;
		entry.Old		= patchInfo[i].oldbyte;
		entry.New		= patchInfo[i].newbyte;

		diff.AddPatch(&entry);
	}

	BridgeFree(patchInfo);
	StaticFileUnloadW(nullptr, false, nullptr, 0, nullptr, fileMapVa);

	// Dump all patches to a file
	if (!diff.Generate(Path))
	{
		_plugin_logprintf("Failed to generate diff file\n");
		return false;
	}

	_plugin_logprintf("Successfully generated diff file at '%s'\n", Path);
	return true;
}

bool ExportMapSymbols(char *Path, duint ModuleBase)
{
	_plugin_logprintf("NOT IMPLEMENTED: Awaiting for x64dbg EnumLabels() API\n");
	return false;
}


================================================
File: src/idaldr/Ldr.h
================================================
#pragma once

bool ApplySignatureSymbols(char *Path, duint ModuleBase);
bool ApplyDiffSymbols(char *Path, duint UNUSED_ModuleBase);
bool ApplyMapSymbols(char *Path, duint ModuleBase);
bool ExportDiffSymbols(char *Path, duint ModuleBase);
bool ExportMapSymbols(char *Path, duint ModuleBase);


================================================
File: src/idaldr/sig.sig
================================================
[Non-text file]


================================================
File: src/idaldr/stdafx.cpp
================================================
// stdafx.cpp : source file that includes just the standard includes
// idaldr.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file



================================================
File: src/idaldr/stdafx.h
================================================
#pragma once

#include <windows.h>
#include <stdio.h>
#include <vector>
#include <map>
#include <stdint.h>

//
// SWISSARMYKNIFE
//
#include "../SwissArmyKnife/stdafx.h"

//
// PLUGIN
//
#include "IDA/Crc16.h"
#include "IDA/Sig.h"
#include "IDA/Diff.h"
#include "Map/Map.h"
#include "Ldr.h"


================================================
File: src/idaldr/IDA/Crc16.cpp
================================================
#include "../stdafx.h"

#define POLY 0x8408

/*
//                                     16   12   5
// this is the CCITT CRC 16 polynomial X  + X  + X  + 1.
// This works out to be 0x1021, but the way the algorithm works
// lets us use 0x8408 (the reverse of the bit pattern).  The high
// bit is always assumed to be set, thus we only use 16 bits to
// represent the 17 bit value.
*/

unsigned short crc16(unsigned char *data_p, size_t length)
{
	if (length <= 0)
		return 0;

	unsigned int data;
	unsigned int crc = 0xFFFF;

	do
	{
		data = *data_p++;
		for (unsigned char i = 0; i < 8; i++)
		{
			if ((crc ^ data) & 1)
				crc = (crc >> 1) ^ POLY;
			else
				crc >>= 1;
			data >>= 1;
		}
	} while (--length != 0);

	crc = ~crc;
	data = crc;
	crc = (crc << 8) | ((data >> 8) & 0xff);

	return (unsigned short)(crc);
}




================================================
File: src/idaldr/IDA/Crc16.h
================================================
#pragma once

unsigned short crc16(unsigned char *data_p, size_t length);


================================================
File: src/idaldr/IDA/Diff.h
================================================
#pragma once

struct DiffFileEntry
{
	ULONGLONG	Offset;
	BYTE		Old;
	BYTE		New;
};

class IDADiffReader
{
public:

private:
	FILE						*m_FileHandle;

	char						m_Module[MAX_PATH];
	std::vector<DiffFileEntry>	m_Patches;

public:
	IDADiffReader();
	~IDADiffReader();

	bool Load(const char *Path);

	const char					*GetModule();
	std::vector<DiffFileEntry>&	GetPatches();

private:
	bool EnumerateLines();
	bool LoadPatch(char *Value, int Line);
};

class IDADiffWriter
{
public:

private:
	char						m_Description[MAX_PATH];
	char						m_Module[MAX_PATH];
	std::vector<DiffFileEntry>	m_Patches;

public:
	IDADiffWriter();
	~IDADiffWriter();

	bool Generate(const char *Path);

	void SetDescription	(const char *Description);
	void SetModule		(const char *Module);
	void AddPatch		(DiffFileEntry *Entry);

private:
};


================================================
File: src/idaldr/IDA/DiffReader.cpp
================================================
#include "../stdafx.h"

// ********** //
//   READER   //
// ********** //

IDADiffReader::IDADiffReader()
{
	m_FileHandle = nullptr;

	memset(m_Module, 0, sizeof(m_Module));

	m_Patches.reserve(1000);
}

IDADiffReader::~IDADiffReader()
{
	if (m_FileHandle)
		fclose(m_FileHandle);

	m_Patches.clear();
}

bool IDADiffReader::Load(const char *Path)
{
	fopen_s(&m_FileHandle, Path, "rt");

	if (!m_FileHandle)
		return false;

	if (!EnumerateLines())
		return false;

	return true;
}

const char *IDADiffReader::GetModule()
{
	return m_Module;
}

std::vector<DiffFileEntry>&	IDADiffReader::GetPatches()
{
	return m_Patches;
}

bool IDADiffReader::EnumerateLines()
{
	int line = 0;
	char value[1024];

	while (fgets(value, ARRAYSIZE(value), m_FileHandle) != NULL)
	{
		if (strchr(value, '\r'))
			*strchr(value, '\r') = '\0';

		if (strchr(value, '\n'))
			*strchr(value, '\n') = '\0';

		if (!LoadPatch(value, line))
			return false;

		line++;
	}

	return true;
}

bool IDADiffReader::LoadPatch(char *Value, int Line)
{
	/*
	Description

	filename.exe
	00000001: 00 01
	00000003: 00 03
	*/

	// Description
	switch (Line)
	{
	case 0:
		// Description
		_plugin_logprintf("%s\n", Value);

	case 2:
		// File
		strcpy_s(m_Module, Value);

	case 1:
		// Blank line
		return true;
	}

	// Scan for the entry
	DiffFileEntry entry;

	if (sscanf_s(Value, "%llx: %hhX %hhX", &entry.Offset, &entry.Old, &entry.New) <= 0)
		return false;

	m_Patches.push_back(entry);

	return true;
}


================================================
File: src/idaldr/IDA/DiffWriter.cpp
================================================
#include "../stdafx.h"

// ********** //
//   WRITER   //
// ********** //

IDADiffWriter::IDADiffWriter()
{
	memset(m_Description, 0, sizeof(m_Description));
	memset(m_Module, 0, sizeof(m_Module));

	m_Patches.reserve(1000);
}

IDADiffWriter::~IDADiffWriter()
{
	m_Patches.clear();
}

bool IDADiffWriter::Generate(const char *Path)
{
	FILE *fileHandle = nullptr;
	fopen_s(&fileHandle, Path, "w");

	if (!fileHandle)
		return false;

	// Write the description
	fputs(m_Description, fileHandle);
	fputs("\n", fileHandle);

	// Module name
	fputs(m_Module, fileHandle);
	fputs("\n", fileHandle);

	// Loop through each patch
	for (auto& entry : m_Patches)
	{
		char buf[256];
		sprintf_s(buf, "%08llx: %02X %02X", entry.Offset, entry.Old, entry.New);

		fputs(buf, fileHandle);
		fputs("\n", fileHandle);
	}

	fclose(fileHandle);
	return true;
}

void IDADiffWriter::SetDescription(const char *Description)
{
	strcpy_s(m_Description, Description);
}

void IDADiffWriter::SetModule(const char *Module)
{
	strcpy_s(m_Module, Module);
}

void IDADiffWriter::AddPatch(DiffFileEntry *Entry)
{
	m_Patches.push_back(*Entry);
}


================================================
File: src/idaldr/IDA/Sig.cpp
================================================
#include "../stdafx.h"
#include "../../zlib/zlib.h"

IDASig::IDASig()
{
	memset(&Header, 0, sizeof(IDASigHeader));

	m_LegacyIDB		= false;
	m_FileHandle	= INVALID_HANDLE_VALUE;
	m_FileData		= nullptr;
}

IDASig::~IDASig()
{
	if (m_FileHandle != INVALID_HANDLE_VALUE)
		CloseHandle(m_FileHandle);

	if (m_FileData)
		VirtualFree(m_FileData, 0, MEM_RELEASE);
}

bool IDASig::Load(const char *Path)
{
	m_FileHandle = CreateFileA(Path, GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

	if (m_FileHandle == INVALID_HANDLE_VALUE)
	{
		_plugin_logprintf("Unable to open file\n");
		return false;
	}

	m_FileSize = GetFileSize(m_FileHandle, nullptr);

	if (m_FileSize <= 0)
	{
		_plugin_logprintf("No data in file\n");
		return false;
	}

	m_FileDataBase	= (char *)VirtualAlloc(nullptr, m_FileSize, MEM_COMMIT, PAGE_READWRITE);
	m_FileData		= m_FileDataBase;

	if (!m_FileDataBase)
	{
		_plugin_logprintf("Failed to allocate memory\n");
		return false;
	}

	// Read the file
	if (!ReadFile(m_FileHandle, m_FileDataBase, m_FileSize, &m_FileSize, nullptr))
		return false;

	// Copy the header into its own struct
	memcpy(&Header, m_FileData, sizeof(IDASigHeader));
	IncrementPos(sizeof(IDASigHeader));

	// Integrity check
	if (memcmp(Header.Magic, "IDASGN", 6) != 0)
	{
		_plugin_logprintf("Invalid signature header\n");
		return false;
	}

	// Log and fix up version if needed
	SignatureVersion = Header.Version;
	
	FixupVersion();

	if (Header.Version != IDASIG_VERSION_NEWEST)
	{
		_plugin_logprintf("Unsupported signature version %d\n", Header.Version);
		return false;
	}

	// Read the signature name (stored directly after the header)
	memcpy(SignatureName, m_FileData, Header.SigNameLength);
	SignatureName[Header.SigNameLength] = '\0';

	IncrementPos(Header.SigNameLength);

	// Now check if decompression is needed
	if (Header.SigFlags & IDASIG_FLAG_COMPRESSED)
	{
		if (!Decompress())
		{
			_plugin_logprintf("A fatal error occurred while decompressing\n");
			return false;
		}
	}

	BuildTree(&BaseNode);
	return true;
}

bool IDASig::Support32Bit()
{
	return (Header.AppTypes & IDASIG_APPTYPE_32BIT) != 0;
}

bool IDASig::Support64Bit()
{
	return (Header.AppTypes & IDASIG_APPTYPE_64BIT) != 0;
}

void IDASig::FixupVersion()
{
	//
	// Fix up the header to accommodate for older signature versions
	// NOTE: 'break' is intentionally left out
	//
	switch (Header.Version)
	{
	case IDASIG_VERSION_4:
		m_FileData				-= 2; // qfseek(File, -2, 1);
		Header.Version			= IDASIG_VERSION_4;

	case IDASIG_VERSION_5:
		m_FileData				-= 4; // qfseek(File, -4, 1);
		Header.ModuleCount		= Header.OldModuleCount;
		Header.Version			= IDASIG_VERSION_6;

	case IDASIG_VERSION_6:
		m_LegacyIDB				= true;
		Header.Version			= IDASIG_VERSION_7;
		break;

// 	case IDASIG_VERSION_7:
// 		m_FileData				-= 2; // qfseek(File, -2, 1);
// 		Header.NBytePatterns	= IDASIG_MAX_NODE_BYTES;
// 		Header.Version			= IDASIG_VERSION_8;
// 
// 	case IDASIG_VERSION_8:
// 		Header.Version			= IDASIG_VERSION_9;
// 
// 	case IDASIG_VERSION_9:
// 		break;
	}
}

bool IDASig::Decompress()
{
	//
	// ZLIB
	// 	
	DWORD inflatedOffset = m_FileData - m_FileDataBase;
	DWORD inflatedSize = m_FileSize - inflatedOffset;
	_plugin_logprintf("Compressed data at offset 0x%X with size 0x%X\n", inflatedOffset, inflatedSize);

	std::vector<unsigned char> inflatedData;
	inflatedData.resize(inflatedSize * 3);
	while (true)
	{
		uLongf destLen = inflatedData.size();
		int err = uncompress((Bytef*)inflatedData.data(), &destLen, (Bytef*)m_FileData, inflatedSize);
		if (err == Z_OK) //all good
			break;
		else if (err == Z_BUF_ERROR) //ouput buffer too small
			inflatedData.resize(inflatedData.size() * 2);
		else
		{
			_plugin_logprintf("Decompression error %d!\n", err);
			return false;
		}
	}

	VirtualFree(m_FileData, 0, MEM_RELEASE);
	m_FileData = (char *)VirtualAlloc(nullptr, inflatedData.size(), MEM_COMMIT, PAGE_READWRITE);
	if (!m_FileData)
	{
		_plugin_logprintf("Failed to allocate memory!\n");
		return false;
	}
	memcpy(m_FileData, inflatedData.data(), inflatedData.size());
	return true;
}

/*
Originally reversed and coded by:
	Rheax <rheaxmascot AT gmail DOT com>

More information from:
	https://github.com/JohnDMcMaster/uvudec/wiki/IDA-.sig-file-format
*/

void IDASig::BuildTree(IDASigNode *Node)
{
	uint32_t internalNodeCount = ReadBitshift();

	if (Header.Version <= IDASIG_VERSION_7)
	{
		if (internalNodeCount > 0)
			BuildTreeNode_V7(Node, internalNodeCount);
		else
			BuildLeafNode_V7(Node);
	}
	else
	{
		__debugbreak();
		// FIXME..........................
	}
}

void IDASig::BuildTreeNode_V7(IDASigNode *Node, int InternalNodeCount)
{
	uint32_t relocationBitmask;

	for (int i = 0; i < InternalNodeCount; ++i)
	{
		uint32_t nodeByteCount = ReadByte();
		IDASigNode childNode;

		// Only 32 bytes are allowed
		if (nodeByteCount > IDASIG_MAX_NODE_BYTES)
		{
			printf("Too many bytes\n");
			exit(1);
		}

		uint32_t curRelocationBitmask = 1 << (nodeByteCount - 1);

		if (nodeByteCount >= 16)
			relocationBitmask = ReadRelocationBit();
		else
			relocationBitmask = ReadBitshift();

		// Relocations don't appear until the end
		for (uint32_t j = 0; j < nodeByteCount; j++)
		{
			if (curRelocationBitmask & relocationBitmask)
			{
				childNode.WriteRelocation();
				//_plugin_logprintf("..");
			}
			else
			{
				uint8_t val = ReadByte();

				childNode.WriteByte(val);
				//_plugin_logprintf("%.2X", val);
			}

			curRelocationBitmask >>= 1;
		}

		//_plugin_logprintf(":\n");

		BuildTree(&childNode);
		Node->Nodes.push_back(childNode);
	}
}

void IDASig::BuildLeafNode_V7(IDASigNode *Node)
{
	// Leaf node
	uint32_t readFlags = 0;
	uint32_t funcIndex = 0;

	do
	{
		uint32_t treeBlockLen	= ReadByte();
		uint32_t crc16			= ReadWord();

		do
		{
			uint32_t totalLen		= ReadBitshift();
			uint32_t refCurOffset	= 0;

			//_plugin_logprintf("%d. tree_block_len:0x%.2X a_crc16:0x%.4X total_len:0x%.4X", funcIndex, treeBlockLen, crc16, totalLen);
			funcIndex++;

			do
			{
				std::string name;

				uint32_t delta = ReadBitshift();
				readFlags = ReadByte();

				bool has_negative = readFlags < 32;

				for (int i = 0;; ++i)
				{
					if (i >= 1024)
					{
						printf("reference length exceeded\n");
						exit(1);
					}

					if (readFlags < 32)
						readFlags = ReadByte();

					if (readFlags < 32)
						break;

					name += (char)readFlags;
					readFlags = 0;
				}

				refCurOffset += delta;

				if (refCurOffset == 0)
					printf(" ");

				IDASigLeaf leaf;
				strcpy_s(leaf.Symbol, name.c_str());
				leaf.CrcOffset = treeBlockLen;
				leaf.Crc16 = crc16;
				Node->Leaves.push_back(leaf);

				//_plugin_logprintf(" %.4X:%s", refCurOffset, name.c_str());
			} while (readFlags & 1);

			if (readFlags & 2)
			{
				uint32_t first = ReadBitshift();
				uint32_t second = ReadByte();
				//_plugin_logprintf(" (0x%.4X: 0x%.2X)", first, second);
			}

			// Symbol linked references
			if (readFlags & 4)
			{
				uint32_t a_offset = ReadBitshift();
				uint32_t ref_name_len = ReadByte();

				if (ref_name_len <= 0)
					ref_name_len = ReadBitshift();

				std::string ref_name = std::string(m_FileData, ref_name_len);

				// If last char is 0, we have a special flag set
				if (m_FileData[ref_name_len - 1] == 0)
					a_offset = -a_offset;

				IncrementPos(ref_name_len);
			}
			//_plugin_logprintf("\n");
		} while (readFlags & 0x08);
	} while (readFlags & 0x10);
}

void IDASig::IncrementPos(int Size)
{
	m_FileData += Size;
}

uint32_t IDASig::ReadByte()
{
	uint8_t val = *m_FileData;

	IncrementPos(sizeof(uint8_t));

	return val;
}

uint32_t IDASig::ReadWord()
{
	return (ReadByte() << 8) + ReadByte();
}

uint32_t IDASig::ReadBitshift()
{
	uint32_t val = ReadByte();

	if (val & 0x80)
		return ((val & 0x7F) << 8) + ReadByte();

	return val;
}

uint32_t IDASig::ReadRelocationBit()
{
	uint32_t val = ReadByte();

	if ((val & 0x80) != 0x80)
		return val;

	if ((val & 0xC0) != 0xC0)
		return ((val & 0x7F) << 8) + ReadByte();

	if ((val & 0xE0) != 0xE0)
	{
		uint32_t upper = ((val & 0xFF3F) << 8) + ReadByte();
		return ReadWord() + (upper << 16);
	}

	return ReadWord() + (ReadWord() << 16);
}


================================================
File: src/idaldr/IDA/Sig.h
================================================
#pragma once

#define IDASIG_VERSION_4 4	// ???
#define IDASIG_VERSION_5 5	// ???
#define IDASIG_VERSION_6 6	// ???
#define IDASIG_VERSION_7 7	// 6.1
#define IDASIG_VERSION_8 8	// 6.4
#define IDASIG_VERSION_9 9	// 6.5

#define IDASIG_VERSION_NEWEST IDASIG_VERSION_7 // Until fixed

#define IDASIG_FLAG_STARTUP			0x01
#define IDASIG_FLAG_USE_CTYPE		0x02
#define IDASIG_FLAG_USE_2BYTE_CTYPE 0x04
#define IDASIG_FLAG_USE_ALT_CTYPE	0x08
#define IDASIG_FLAG_COMPRESSED		0x10

#define IDASIG_APPTYPE_32BIT		0x100
#define IDASIG_APPTYPE_64BIT		0x200

#define IDASIG_MAX_NODE_BYTES		32

#pragma pack(push, 1)
// VERSION 6: 39 bytes total
// VERSION 7: 41 bytes total
// VERSION 8: 43 bytes total
// VERSION 9: 43 bytes total
struct IDASigHeader
{
	char	Magic[6];		//0x0000 Default: IDASGN
	BYTE	Version;		//0x0006 Default: VER_XX
	BYTE	ProcessorId;	//0x0007
	DWORD	FiletypeFlags;	//0x0008
	WORD	OSTypes;		//0x000C
	WORD	AppTypes;		//0x000E
	BYTE	SigFlags;		//0x0010

	char _0x0011[1];

	WORD	OldModuleCount;	//0x0012

	WORD	CTypeCRC;		//0x0014
	char	CTypeName[12];	//0x0016

	BYTE	SigNameLength;	//0x0022
	WORD	AltCTypeCrc;	//0x0023
	DWORD	ModuleCount;	//0x0025

	//WORD	NBytePatterns;	//0x0029 VER_8
};

static_assert(sizeof(IDASigHeader) == 0x29, "Invalid signature header size");
#pragma pack(pop)

class IDASigLeaf
{
public:
	char Symbol[1024];
	WORD CrcOffset;
	WORD Crc16;
	bool Used;
};

class IDASigNode
{
public:
	struct
	{
		BYTE Type;
		BYTE Value;
	} Data[IDASIG_MAX_NODE_BYTES];

	std::vector<IDASigNode> Nodes;
	std::vector<IDASigLeaf> Leaves;

	int m_DataIndex;

private:

public:
	IDASigNode()
	{
		memset(Data, 0, sizeof(Data));
		Nodes.clear();
		Leaves.clear();

		m_DataIndex = 0;
	}

	void WriteByte(BYTE Value)
	{
		Data[m_DataIndex].Type	= 0xFF;
		Data[m_DataIndex].Value	= Value;

		m_DataIndex++;
	}

	void WriteRelocation()
	{
		Data[m_DataIndex].Type	= 0x00;
		Data[m_DataIndex].Value = 0x00;

		m_DataIndex++;
	}
};

class IDASig
{
public:
	IDASigHeader	Header;
	BYTE			SignatureVersion;
	char			SignatureName[256];

	IDASigNode		BaseNode;

private:
	HANDLE	m_FileHandle;
	char	*m_FileDataBase; //only a reference buffer, don't touch this
	char	*m_FileData;
	DWORD	m_FileSize;

	// Kept for consistency
	bool m_LegacyIDB;

public:
	IDASig();
	~IDASig();

	bool Load(const char *Path);
	bool Support32Bit();
	bool Support64Bit();

private:
	void FixupVersion();
	bool Decompress();

	void BuildTree(IDASigNode *Node);
	void BuildTreeNode_V7(IDASigNode *Node, int InternalNodeCount);
	void BuildLeafNode_V7(IDASigNode *Node);

	void IncrementPos(int Size);
	uint32_t ReadByte();
	uint32_t ReadWord();
	uint32_t ReadBitshift();
	uint32_t ReadRelocationBit();
};


================================================
File: src/idaldr/Map/Map.h
================================================
#pragma once

struct MapFileSegment
{
	char		Name[64];
	char		Class[16];
	int			Id;
	ULONGLONG	Start;
	ULONGLONG	Length;
};

struct MapFileSymbol
{
	char		Name[256];
	int			Id;
	ULONGLONG	Offset;
};

class MapFile
{
public:

private:
	HANDLE	m_FileHandle;
	char	*m_FileDataBase;
	char	*m_FileData;

	ULONGLONG					m_SegmentTotalSize;
	std::vector<MapFileSegment>	m_Segments;
	std::vector<MapFileSymbol>	m_Symbols;

public:
	MapFile();
	~MapFile();

	bool Load(const char *Path);

	std::vector<MapFileSegment>&	GetSegments();
	std::vector<MapFileSymbol>&		GetSymbols();
	ULONGLONG						GetSegmentStart(int Id);

private:
	bool EnumerateLines(char *Start, int Type);

	bool LoadSegments();
	bool LoadSegment(char *Line);

	bool LoadSymbols();
	bool LoadSymbol(char *Line);
};


================================================
File: src/idaldr/Map/MapReader.cpp
================================================
#include "../stdafx.h"

MapFile::MapFile()
{
	m_FileHandle		= INVALID_HANDLE_VALUE;
	m_FileDataBase		= nullptr;
	m_FileData			= nullptr;
	m_SegmentTotalSize	= 0;
	m_Symbols.reserve(5000);
}

MapFile::~MapFile()
{
	if (m_FileHandle != INVALID_HANDLE_VALUE)
		CloseHandle(m_FileHandle);

	if (m_FileDataBase)
		VirtualFree(m_FileDataBase, 0, MEM_RELEASE);

	m_Segments.clear();
	m_Symbols.clear();
}

bool MapFile::Load(const char *Path)
{
	m_FileHandle = CreateFileA(Path, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

	if (m_FileHandle == INVALID_HANDLE_VALUE)
	{
		_plugin_logprintf("Unable to open file\n");
		return false;
	}

	DWORD fileSize = GetFileSize(m_FileHandle, nullptr);

	if (fileSize <= 0)
	{
		_plugin_logprintf("No data in file\n");
		return false;
	}

	m_FileDataBase	= (char *)VirtualAlloc(nullptr, fileSize, MEM_COMMIT, PAGE_READWRITE);
	m_FileData		= m_FileDataBase;

	if (!m_FileDataBase)
	{
		_plugin_logprintf("Failed to allocate memory\n");
		return false;
	}

	if (!ReadFile(m_FileHandle, m_FileData, fileSize, &fileSize, nullptr))
	{
		_plugin_logprintf("Failed to read file data\n");
		return false;
	}

	if (!LoadSegments())
		return false;

	if (!LoadSymbols())
		return false;

	return true;
}

std::vector<MapFileSegment>& MapFile::GetSegments()
{
	return m_Segments;
}

std::vector<MapFileSymbol>& MapFile::GetSymbols()
{
	return m_Symbols;
}

ULONGLONG MapFile::GetSegmentStart(int Id)
{
	for (auto& segment : m_Segments)
	{
		if (segment.Id == Id)
			return segment.Start;
	}

	return 0;
}

bool MapFile::EnumerateLines(char *Start, int Type)
{
	int line	= 0;
	char *ptr	= Start;
	char *eol	= nullptr;

	for (; *ptr; ptr++)
	{
		switch (*ptr)
		{
		case '\n':
			line++;

		case '\r':
		case ' ':
		case '\t':
			continue;
		}

		// Line #0 is the heading
		if (line < 1)
			continue;

		// Terminate the line
		eol = strchr(ptr, '\r');

		if (!eol)
			eol = strchr(ptr, '\n');

		if (eol)
			*eol = '\0';

		// If the delimiter is not present, the line is not valid
		if (!strchr(ptr, ':') && !strchr(ptr, ';'))
			break;

		if (Type == 'SEGM' && !LoadSegment(ptr))
			break;
		
		if (Type == 'SYMB' && !LoadSymbol(ptr))
			break;

		if (eol)
			ptr = eol + 1;
	}

	if (eol)
		*eol = '\r';

	m_FileData = ptr;
	return true;
}

bool MapFile::LoadSegments()
{
	/*
	 Start         Length     Name                   Class
	 0001:00000000 000000030H .init                  CODE
	*/
	char *startPos = strstr(m_FileData, "Start");
	char *addressPos = strstr(m_FileData, "Address");

	if (!startPos || startPos > addressPos)
	{
		_plugin_logprintf("Couldn't find starting position for segments, skipping\n");
		return true;
	}

	// Insert a fake segment for the PE header (Id #0)
	// Size: 4096 bytes
	MapFileSegment segdef;

	strcpy_s(segdef.Name, "PE_HEADER");
	strcpy_s(segdef.Class, "DATA");
	segdef.Id		= 0;
	segdef.Start	= 0;
	segdef.Length	= 4096;

	m_SegmentTotalSize += segdef.Length;
	m_Segments.push_back(segdef);

	// Enumerate segment definition lines
	return EnumerateLines(startPos, 'SEGM');
}

char *GrabToken(char *Dest, char *Src)
{
	// Skip spaces
	while (*Src == ' ' || *Src == '\t')
		Src++;

	char *bufEnd = strchr(Src, ' ');

	// Case with ':'
	{
		char *delim = strchr(Src, ':');

		if (delim && (delim < bufEnd))
			bufEnd = delim;
	}

	if (bufEnd)
		*bufEnd = '\0';

	strcpy(Dest, Src);

	return ((bufEnd) ? (bufEnd + 1) : nullptr);
}

char *GrabTokenSymbol(char *Dest, char *Src, int TokenIndex)
{
	// Skip spaces
	while (*Src == ' ' || *Src == '\t')
		Src++;

	char *bufEnd = nullptr;
	switch (TokenIndex)
	{
	case 0:
		// Case with ':'
		bufEnd = strchr(Src, ':');
		break;

	case 1:
		// Case with ' '
		bufEnd = strchr(Src, ' ');
		break;

	default:
		strcpy(Dest, Src);
		return nullptr;
	}

	if (bufEnd != nullptr)
		*bufEnd = '\0';

	strcpy(Dest, Src);

	return ((bufEnd) ? (bufEnd + 1) : nullptr);
}

bool MapFile::LoadSegment(char *Line)
{
	// ID:BASE LENGTH NAME CLASS
	char tokens[8][256];
	memset(tokens, 0, sizeof(tokens));

	// Skip spaces and make a copy
	while (*Line == ' ' || *Line == '\t')
		Line++;

	char buf[256];
	strncpy_s(buf, Line, 255);

	// Parse each token
	char *bufPtr	= buf;
	int tokenIndex	= 0;

	for (int i = 0; i < ARRAYSIZE(tokens); i++)
	{
		bufPtr = GrabToken(tokens[i], bufPtr);

		if (!bufPtr)
			break;
	}

	// Parse the file data directly
	// Format: "0002:00000150 00000004H .rdata$sxdata"
	MapFileSegment segdef;
	strcpy_s(segdef.Name, tokens[3]);
	strcpy_s(segdef.Class, tokens[4]);

	if (sscanf_s(tokens[0], "%x", &segdef.Id) <= 0)
		return false;

	if (sscanf_s(tokens[1], "%llx", &segdef.Start) <= 0)
		return false;

	if (sscanf_s(tokens[2], "%llxH", &segdef.Length) <= 0)
		return false;

	// Skip segments with a zero length
	if (segdef.Length <= 0)
		return true;

	segdef.Start		+= m_SegmentTotalSize;
	m_SegmentTotalSize	+= segdef.Length;

    m_Segments.push_back(segdef);

	return true;
}

bool MapFile::LoadSymbols()
{
	//
	// Address         Publics by Value
	// 0001:00000000       _init_proc
	//
	// Load regular symbols
	char *startPos = strstr(m_FileData, "Address");

	if (!startPos)
	{
		_plugin_logprintf("Couldn't find starting position for symbols\n");
		return false;
	}

	if (!EnumerateLines(startPos, 'SYMB'))
		return false;

	//
	// Static symbols
	// 0001:00000027       _pre_c_init                00401027 f   MSVCRT:wcrtexe.obj
	//
	// Now load static symbols (these are optional)
	startPos = strstr(m_FileData, "Static symbols");

	if (!startPos)
	{
		_plugin_logprintf("Couldn't find starting position for static symbols, skipping\n");
		return true;
	}

	return EnumerateLines(startPos, 'SYMB');
}

bool MapFile::LoadSymbol(char *Line)
{
	// ID:OFFSET NAME
	char tokens[5][256];
	memset(tokens, 0, sizeof(tokens));

	// Skip spaces and make a copy
	while (*Line == ' ' || *Line == '\t')
		Line++;

	char buf[256];
	strncpy_s(buf, Line, 255);

	// Parse each token
	char *bufPtr	= buf;
	int tokenIndex	= 0;

	for (int i = 0; i < ARRAYSIZE(tokens); i++)
	{
		bufPtr = GrabTokenSymbol(tokens[i], bufPtr, i);

		if (!bufPtr)
			break;
	}

	if (!strcmp(tokens[1], "function") || !strcmp(tokens[1], "procedure"))
		return true;

	MapFileSymbol symdef;
	strcpy_s(symdef.Name, tokens[2]);

	if (sscanf_s(tokens[0], "%x", &symdef.Id) <= 0)
		return false;

	if (sscanf_s(tokens[1], "%llx", &symdef.Offset) <= 0)
		return false;

	m_Symbols.push_back(symdef);

	return true;
}


================================================
File: src/idaldr/Map/MapWriter.cpp
================================================
#include "../stdafx.h"


================================================
File: src/peid/peid.cpp
================================================
#include "peid.h"
#include "../SwissArmyKnife/Util.h"
#include "../sigmake/Descriptor.h"

bool ApplyPEiDSymbols(char *Path, duint ModuleBase)
{
	FILE *dbFile = nullptr;

	fopen_s(&dbFile, Path, "r");

	if (!dbFile)
		return false;

	// Get a copy of the current module in disassembly
	duint moduleBase = ModuleBase;
	duint moduleSize = DbgFunctions()->ModSizeFromAddr(moduleBase);
	PBYTE processMemory = (PBYTE)BridgeAlloc(moduleSize);

	if (!DbgMemRead(moduleBase, processMemory, moduleSize))
		return false;

	// Buffers to store signature entries
	char buf[4096];
	char name[4096];
	char pattern[4096];

	memset(buf, 0, sizeof(buf));
	memset(name, 0, sizeof(name));
	memset(pattern, 0, sizeof(pattern));

	// Read the file line-by-line
	int totalCount = 0;

	while (fgets(buf, ARRAYSIZE(buf), dbFile) != nullptr)
	{
		if (buf[0] == ';')
		{
			// Comment line
			continue;
		}
		if (buf[0] == '[')
		{
			// '[' indicates the start of a signature
			strcpy_s(name, buf + 1);

			// Trim the ending bracket
			if (strrchr(name, ']'))
				*strrchr(name, ']') = '\0';
		}
		else if (_strnicmp(buf, "ep_only", 7) == 0)
		{
			// 'ep_only' indicates the end of a signature
			bool isEntry = strstr(buf, "true") ? true : false;

			// Replace bad characters
			std::string temp(pattern);

			StringReplace(temp, "\r", "");
			StringReplace(temp, "\n", "");
			StringReplace(temp, "signature = ", "");

			// Scan
			duint result = PEiDPatternScan(temp.c_str(), isEntry, processMemory, moduleBase, moduleSize);

			if (result)
			{
				DbgSetAutoCommentAt(result, name);
				_plugin_logprintf("Match 0x%p - %s\n", result, name);
			}

			// Reset everything
			memset(buf, 0, sizeof(buf));
			memset(name, 0, sizeof(name));
			memset(pattern, 0, sizeof(pattern));

			totalCount++;
		}
		else
		{
			// Anything non-whitespace is appended to the signature
			if (strlen(buf) > 0)
				strcat_s(pattern, buf);
		}
	}

	// Notify user
	_plugin_logprintf("%d signature(s) tested in scan\n", totalCount);

	BridgeFree(processMemory);
	fclose(dbFile);
	return true;
}

duint PEiDPatternScan(const char *Pattern, bool EntryPoint, PBYTE ModuleCopy, duint ModuleBase, duint ModuleSize)
{
	// Create the desciptor as a PEiD type
	SIG_DESCRIPTOR *desc = DescriptorFromPEiD(Pattern);

	if (!desc || desc->Count <= 0)
	{
		_plugin_logprintf("Trying to scan with an invalid signature\n");
		return 0;
	}

	// Check if only the entry point should be scanned
	if (EntryPoint)
	{
		//ModuleBase = ep_start;
		//ModuleSize = ep_size;
	}

	auto DataCompare = [](PBYTE Data, SIG_DESCRIPTOR_ENTRY *Entries, ULONG Count)
	{
		ULONG i = 0;

		for (; i < Count; ++Data, ++i)
		{
			if (Entries[i].Wildcard == 0 && *Data != Entries[i].Value)
				return false;
		}

		return i == Count;
	};

	// Scanner loop
	duint match = 0;

	for (duint i = 0; i < ModuleSize; i++)
	{
		PBYTE dataAddr = ModuleCopy + i;

		if (!DataCompare(dataAddr, desc->Entries, desc->Count))
			continue;

		match = ModuleBase + i;
		break;
	}

	BridgeFree(desc);
	return match;
}


================================================
File: src/peid/peid.h
================================================
#pragma once

#include "../idaldr/stdafx.h"

bool ApplyPEiDSymbols(char *Path, duint ModuleBase);
duint PEiDPatternScan(const char *Pattern, bool EntryPoint, PBYTE ModuleCopy, duint ModuleBase, duint ModuleSize);


================================================
File: src/pluginsdk/_dbgfunctions.h
================================================
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeMainWindowTitle[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef struct
{
    DWORD rva;
    BYTE type;
    WORD size;
} DBGRELOCATIONINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef struct
{
    duint handle;
    duint parent;
    DWORD threadId;
    DWORD style;
    DWORD styleEx;
    duint wndProc;
    bool enabled;
    RECT position;
    char windowTitle[MAX_COMMENT_SIZE];
    char windowClass[MAX_COMMENT_SIZE];
} WINDOW_INFO;

typedef struct
{
    duint addr;
    duint size;
    duint flags;
} HEAPINFO;

typedef struct
{
    const char* name;
    duint value;
} CONSTANTINFO;

typedef enum
{
    MODSYMUNLOADED = 0,
    MODSYMLOADING,
    MODSYMLOADED
} MODULESYMBOLSTATUS;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*GETSEHCHAIN)(DBGSEHCHAIN* sehchain);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line, duint* displacement);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool (*PATCHGETEX)(duint addr, DBGPATCHINFO* info);
typedef bool (*GETBRIDGEBP)(BPXTYPE type, duint addr, BRIDGEBP* bp);
typedef bool (*STRINGFORMATINLINE)(const char* format, size_t resultSize, char* result);
typedef void (*GETMNEMONICBRIEF)(const char* mnem, size_t resultSize, char* result);
typedef unsigned int (*GETTRACERECORDHITCOUNT)(duint address);
typedef TRACERECORDBYTETYPE(*GETTRACERECORDBYTETYPE)(duint address);
typedef bool (*SETTRACERECORDTYPE)(duint pageAddress, TRACERECORDTYPE type);
typedef TRACERECORDTYPE(*GETTRACERECORDTYPE)(duint pageAddress);
typedef bool (*ENUMHANDLES)(ListOf(HANDLEINFO) handles);
typedef bool (*GETHANDLENAME)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
typedef bool (*ENUMTCPCONNECTIONS)(ListOf(TCPCONNECTIONINFO) connections);
typedef duint(*GETDBGEVENTS)();
typedef MODULEPARTY(*MODGETPARTY)(duint base);
typedef void (*MODSETPARTY)(duint base, MODULEPARTY party);
typedef bool(*WATCHISWATCHDOGTRIGGERED)(unsigned int id);
typedef bool(*MEMISCODEPAGE)(duint addr, bool refresh);
typedef bool(*ANIMATECOMMAND)(const char* command);
typedef void(*DBGSETDEBUGGEEINITSCRIPT)(const char* fileName);
typedef const char* (*DBGGETDEBUGGEEINITSCRIPT)();
typedef bool(*HANDLESENUMWINDOWS)(ListOf(WINDOW_INFO) windows);
typedef bool(*HANDLESENUMHEAPS)(ListOf(HEAPINFO) heaps);
typedef bool(*THREADGETNAME)(DWORD tid, char* name);
typedef bool(*ISDEPENABLED)();
typedef void(*GETCALLSTACKEX)(DBGCALLSTACK* callstack, bool cache);
typedef bool(*GETUSERCOMMENT)(duint addr, char* comment);
typedef void(*ENUMCONSTANTS)(ListOf(CONSTANTINFO) constants);
typedef duint(*MEMBPSIZE)(duint addr);
typedef bool(*MODRELOCATIONSFROMADDR)(duint addr, ListOf(DBGRELOCATIONINFO) relocations);
typedef bool(*MODRELOCATIONATADDR)(duint addr, DBGRELOCATIONINFO* relocation);
typedef bool(*MODRELOCATIONSINRANGE)(duint addr, duint size, ListOf(DBGRELOCATIONINFO) relocations);
typedef duint(*DBGETHASH)();
typedef int(*SYMAUTOCOMPLETE)(const char* Search, char** Buffer, int MaxSymbols);
typedef void(*REFRESHMODULELIST)();
typedef duint(*GETADDRFROMLINEEX)(duint mod, const char* szSourceFile, int line);
typedef MODULESYMBOLSTATUS(*MODSYMBOLSTATUS)(duint mod);

//The list of all the DbgFunctions() return value.
//WARNING: This list is append only. Do not insert things in the middle or plugins would break.
typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    GETSEHCHAIN GetSEHChain;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
    GETBRIDGEBP GetBridgeBp;
    STRINGFORMATINLINE StringFormatInline;
    GETMNEMONICBRIEF GetMnemonicBrief;
    GETTRACERECORDHITCOUNT GetTraceRecordHitCount;
    GETTRACERECORDBYTETYPE GetTraceRecordByteType;
    SETTRACERECORDTYPE SetTraceRecordType;
    GETTRACERECORDTYPE GetTraceRecordType;
    ENUMHANDLES EnumHandles;
    GETHANDLENAME GetHandleName;
    ENUMTCPCONNECTIONS EnumTcpConnections;
    GETDBGEVENTS GetDbgEvents;
    MODGETPARTY ModGetParty;
    MODSETPARTY ModSetParty;
    WATCHISWATCHDOGTRIGGERED WatchIsWatchdogTriggered;
    MEMISCODEPAGE MemIsCodePage;
    ANIMATECOMMAND AnimateCommand;
    DBGSETDEBUGGEEINITSCRIPT DbgSetDebuggeeInitScript;
    DBGGETDEBUGGEEINITSCRIPT DbgGetDebuggeeInitScript;
    HANDLESENUMWINDOWS EnumWindows;
    HANDLESENUMHEAPS EnumHeaps;
    THREADGETNAME ThreadGetName;
    ISDEPENABLED IsDepEnabled;
    GETCALLSTACKEX GetCallStackEx;
    GETUSERCOMMENT GetUserComment;
    ENUMCONSTANTS EnumConstants;
    ENUMCONSTANTS EnumErrorCodes;
    ENUMCONSTANTS EnumExceptions;
    MEMBPSIZE MemBpSize;
    MODRELOCATIONSFROMADDR ModRelocationsFromAddr;
    MODRELOCATIONATADDR ModRelocationAtAddr;
    MODRELOCATIONSINRANGE ModRelocationsInRange;
    DBGETHASH DbGetHash;
    SYMAUTOCOMPLETE SymAutoComplete;
    REFRESHMODULELIST RefreshModuleList;
    GETADDRFROMLINEEX GetAddrFromLineEx;
    MODSYMBOLSTATUS ModSymbolStatus;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H



================================================
File: src/pluginsdk/_plugin_types.h
================================================
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"
#include "jansson/jansson.h"
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)

#else

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H



================================================
File: src/pluginsdk/_plugins.h
================================================
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
    int hMenuGraph; //plugin graph menu handle
    int hMenuMemmap; //plugin memory map menu handle
    int hMenuSymmod; //plugin symbol module menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

typedef struct
{
    const char* symbol;
    bool retval;
} PLUG_CB_FILTERSYMBOL;

typedef struct
{
    duint cip;
    bool stop;
} PLUG_CB_TRACEEXECUTE;

typedef struct
{
    int hWindow;
    duint VA;
} PLUG_CB_SELCHANGED;

typedef struct
{
    BridgeCFGraphList graph;
} PLUG_CB_ANALYZE;

typedef struct
{
    duint addr;
    BRIDGE_ADDRINFO* addrinfo;
    bool retval;
} PLUG_CB_ADDRINFO;

typedef struct
{
    const char* string;
    duint value;
    int* value_size;
    bool* isvar;
    bool* hexonly;
    bool retval;
} PLUG_CB_VALFROMSTRING;

typedef struct
{
    const char* string;
    duint value;
    bool retval;
} PLUG_CB_VALTOSTRING;

typedef struct
{
    GUIMENUTYPE hMenu;
} PLUG_CB_MENUPREPARE;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB, //PLUG_CB_LOADSAVEDB
    CB_FILTERSYMBOL, //PLUG_CB_FILTERSYMBOL
    CB_TRACEEXECUTE, //PLUG_CB_TRACEEXECUTE
    CB_SELCHANGED, //PLUG_CB_SELCHANGED
    CB_ANALYZE, //PLUG_CB_ANALYZE
    CB_ADDRINFO, //PLUG_CB_ADDRINFO
    CB_VALFROMSTRING, //PLUG_CB_VALFROMSTRING
    CB_VALTOSTRING, //PLUG_CB_VALTOSTRING
    CB_MENUPREPARE, //PLUG_CB_MENUPREPARE
    CB_LAST
} CBTYPE;

typedef enum
{
    FORMAT_ERROR, //generic failure (no message)
    FORMAT_SUCCESS, //success
    FORMAT_ERROR_MESSAGE, //formatting failed but an error was put in the buffer (there are always at least 511 characters available).
    FORMAT_BUFFER_TOO_SMALL //buffer too small (x64dbg will retry until the buffer is big enough)
} FORMATRESULT;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, duint* argv, void* userdata);
typedef FORMATRESULT(*CBPLUGINFORMATFUNCTION)(char* dest, size_t destCount, int argc, char* argv[], duint value, void* userdata);
typedef bool (*CBPLUGINPREDICATE)(void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_logprint(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentrysetchecked(int pluginHandle, int hEntry, bool checked);
PLUG_IMPEXP void _plugin_menusetvisible(int pluginHandle, int hMenu, bool visible);
PLUG_IMPEXP void _plugin_menuentrysetvisible(int pluginHandle, int hEntry, bool visible);
PLUG_IMPEXP void _plugin_menusetname(int pluginHandle, int hMenu, const char* name);
PLUG_IMPEXP void _plugin_menuentrysetname(int pluginHandle, int hEntry, const char* name);
PLUG_IMPEXP void _plugin_menuentrysethotkey(int pluginHandle, int hEntry, const char* hotkey);
PLUG_IMPEXP bool _plugin_menuremove(int hMenu);
PLUG_IMPEXP bool _plugin_menuentryremove(int pluginHandle, int hEntry);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);
PLUG_IMPEXP duint _plugin_hash(const void* data, duint size);
PLUG_IMPEXP bool _plugin_registerformatfunction(int pluginHandle, const char* type, CBPLUGINFORMATFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterformatfunction(int pluginHandle, const char* type);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H



================================================
File: src/pluginsdk/_scriptapi.h
================================================
#ifndef _SCRIPT_API_H
#define _SCRIPT_API_H

#include "_plugins.h"

#define SCRIPT_EXPORT PLUG_IMPEXP

#endif //_SCRIPT_API_H


================================================
File: src/pluginsdk/_scriptapi_argument.h
================================================
#ifndef _SCRIPTAPI_ARGUMENT_H
#define _SCRIPTAPI_ARGUMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Argument
    {
        struct ArgumentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const ArgumentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, ArgumentInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(ArgumentInfo) list); //caller has the responsibility to free the list
    }; //Argument
}; //Script

#endif //_SCRIPTAPI_ARGUMENT_H


================================================
File: src/pluginsdk/_scriptapi_assembler.h
================================================
#ifndef _SCRIPTAPI_ASSEMBLER_H
#define _SCRIPTAPI_ASSEMBLER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Assembler
    {
        SCRIPT_EXPORT bool Assemble(duint addr, unsigned char* dest, int* size, const char* instruction); //dest[16]
        SCRIPT_EXPORT bool AssembleEx(duint addr, unsigned char* dest, int* size, const char* instruction, char* error); //dest[16], error[MAX_ERROR_SIZE]
        SCRIPT_EXPORT bool AssembleMem(duint addr, const char* instruction);
        SCRIPT_EXPORT bool AssembleMemEx(duint addr, const char* instruction, int* size, char* error, bool fillnop); //error[MAX_ERROR_SIZE]
    }; //Assembler
}; //Script

#endif //_SCRIPTAPI_ASSEMBLER_H


================================================
File: src/pluginsdk/_scriptapi_bookmark.h
================================================
#ifndef _SCRIPTAPI_BOOKMARK_H
#define _SCRIPTAPI_BOOKMARK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Bookmark
    {
        struct BookmarkInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, bool manual = false);
        SCRIPT_EXPORT bool Set(const BookmarkInfo* info);
        SCRIPT_EXPORT bool Get(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, BookmarkInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(BookmarkInfo) list); //caller has the responsibility to free the list
    }; //Bookmark
}; //Script

#endif //_SCRIPTAPI_BOOKMARK_H


================================================
File: src/pluginsdk/_scriptapi_comment.h
================================================
#ifndef _SCRIPTAPI_COMMENT_H
#define _SCRIPTAPI_COMMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Comment
    {
        struct CommentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const CommentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_COMMENT_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, CommentInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(CommentInfo) list); //caller has the responsibility to free the list
    }; //Comment
}; //Script

#endif //_SCRIPTAPI_COMMENT_H


================================================
File: src/pluginsdk/_scriptapi_debug.h
================================================
#ifndef _SCRIPTAPI_DEBUG_H
#define _SCRIPTAPI_DEBUG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Debug
    {
        enum HardwareType
        {
            HardwareAccess,
            HardwareWrite,
            HardwareExecute
        };

        SCRIPT_EXPORT void Wait();
        SCRIPT_EXPORT void Run();
        SCRIPT_EXPORT void Pause();
        SCRIPT_EXPORT void Stop();
        SCRIPT_EXPORT void StepIn();
        SCRIPT_EXPORT void StepOver();
        SCRIPT_EXPORT void StepOut();
        SCRIPT_EXPORT bool SetBreakpoint(duint address);
        SCRIPT_EXPORT bool DeleteBreakpoint(duint address);
        SCRIPT_EXPORT bool DisableBreakpoint(duint address);
        SCRIPT_EXPORT bool SetHardwareBreakpoint(duint address, HardwareType type = HardwareExecute);
        SCRIPT_EXPORT bool DeleteHardwareBreakpoint(duint address);
    }; //Debug
}; //Script

#endif //_SCRIPTAPI_DEBUG_H


================================================
File: src/pluginsdk/_scriptapi_flag.h
================================================
#ifndef _SCRIPTAPI_FLAG_H
#define _SCRIPTAPI_FLAG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Flag
    {
        enum FlagEnum
        {
            ZF,
            OF,
            CF,
            PF,
            SF,
            TF,
            AF,
            DF,
            IF
        };

        SCRIPT_EXPORT bool Get(FlagEnum flag);
        SCRIPT_EXPORT bool Set(FlagEnum flag, bool value);

        SCRIPT_EXPORT bool GetZF();
        SCRIPT_EXPORT bool SetZF(bool value);
        SCRIPT_EXPORT bool GetOF();
        SCRIPT_EXPORT bool SetOF(bool value);
        SCRIPT_EXPORT bool GetCF();
        SCRIPT_EXPORT bool SetCF(bool value);
        SCRIPT_EXPORT bool GetPF();
        SCRIPT_EXPORT bool SetPF(bool value);
        SCRIPT_EXPORT bool GetSF();
        SCRIPT_EXPORT bool SetSF(bool value);
        SCRIPT_EXPORT bool GetTF();
        SCRIPT_EXPORT bool SetTF(bool value);
        SCRIPT_EXPORT bool GetAF();
        SCRIPT_EXPORT bool SetAF(bool value);
        SCRIPT_EXPORT bool GetDF();
        SCRIPT_EXPORT bool SetDF(bool value);
        SCRIPT_EXPORT bool GetIF();
        SCRIPT_EXPORT bool SetIF(bool value);
    };
};

#endif //_SCRIPTAPI_FLAG_H


================================================
File: src/pluginsdk/_scriptapi_function.h
================================================
#ifndef _SCRIPTAPI_FUNCTION_H
#define _SCRIPTAPI_FUNCTION_H

#include "_scriptapi.h"

namespace Script
{
    namespace Function
    {
        struct FunctionInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const FunctionInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, FunctionInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(FunctionInfo) list); //caller has the responsibility to free the list
    }; //Function
}; //Script

#endif //_SCRIPTAPI_FUNCTION_H



================================================
File: src/pluginsdk/_scriptapi_gui.h
================================================
#ifndef _SCRIPTAPI_GUI_H
#define _SCRIPTAPI_GUI_H

#include "_scriptapi.h"

namespace Script
{
    namespace Gui
    {
        namespace Disassembly
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Disassembly

        namespace Dump
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Dump

        namespace Stack
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Stack

        namespace Graph
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //Graph

        namespace MemMap
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //MemoryMap

        namespace SymMod
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //SymMod
    }; //Gui

    namespace Gui
    {
        enum Window
        {
            DisassemblyWindow,
            DumpWindow,
            StackWindow,
            GraphWindow,
            MemMapWindow,
            SymModWindow
        };

        SCRIPT_EXPORT bool SelectionGet(Window window, duint* start, duint* end);
        SCRIPT_EXPORT bool SelectionSet(Window window, duint start, duint end);
        SCRIPT_EXPORT duint SelectionGetStart(Window window);
        SCRIPT_EXPORT duint SelectionGetEnd(Window window);
        SCRIPT_EXPORT void Message(const char* message);
        SCRIPT_EXPORT bool MessageYesNo(const char* message);
        SCRIPT_EXPORT bool InputLine(const char* title, char* text); //text[GUI_MAX_LINE_SIZE]
        SCRIPT_EXPORT bool InputValue(const char* title, duint* value);
        SCRIPT_EXPORT void Refresh();
        SCRIPT_EXPORT void AddQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void ShowQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void CloseQWidgetTab(void* qWidget);

    }; //Gui
}; //Script

#endif //_SCRIPTAPI_GUI_H


================================================
File: src/pluginsdk/_scriptapi_label.h
================================================
#ifndef _SCRIPTAPI_LABEL_H
#define _SCRIPTAPI_LABEL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Label
    {
        struct LabelInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const LabelInfo* info);
        SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
    }; //Label
}; //Script

#endif //_SCRIPTAPI_LABEL_H


================================================
File: src/pluginsdk/_scriptapi_memory.h
================================================
#ifndef _SCRIPTAPI_MEMORY_H
#define _SCRIPTAPI_MEMORY_H

#include "_scriptapi.h"

namespace Script
{
    namespace Memory
    {
        SCRIPT_EXPORT bool Read(duint addr, void* data, duint size, duint* sizeRead);
        SCRIPT_EXPORT bool Write(duint addr, const void* data, duint size, duint* sizeWritten);
        SCRIPT_EXPORT bool IsValidPtr(duint addr);
        SCRIPT_EXPORT duint RemoteAlloc(duint addr, duint size);
        SCRIPT_EXPORT bool RemoteFree(duint addr);
        SCRIPT_EXPORT unsigned int GetProtect(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetBase(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetSize(duint addr, bool reserved = false, bool cache = true);

        SCRIPT_EXPORT unsigned char ReadByte(duint addr);
        SCRIPT_EXPORT bool WriteByte(duint addr, unsigned char data);
        SCRIPT_EXPORT unsigned short ReadWord(duint addr);
        SCRIPT_EXPORT bool WriteWord(duint addr, unsigned short data);
        SCRIPT_EXPORT unsigned int ReadDword(duint addr);
        SCRIPT_EXPORT bool WriteDword(duint addr, unsigned int data);
        SCRIPT_EXPORT unsigned long long ReadQword(duint addr);
        SCRIPT_EXPORT bool WriteQword(duint addr, unsigned long long data);
        SCRIPT_EXPORT duint ReadPtr(duint addr);
        SCRIPT_EXPORT bool WritePtr(duint addr, duint data);
    }; //Memory
}; //Script

#endif //_SCRIPTAPI_MEMORY_H


================================================
File: src/pluginsdk/_scriptapi_misc.h
================================================
#ifndef _SCRIPTAPI_MISC_H
#define _SCRIPTAPI_MISC_H

#include "_scriptapi.h"

namespace Script
{
    namespace Misc
    {
        /// <summary>
        /// Evaluates an expression and returns the result. Analagous to using the Command field in x64dbg.
        ///
        /// Expressions can consist of memory locations, registers, flags, API names, labels, symbols, variables etc.
        ///
        /// Example: bool success = ParseExpression("[esp+8]", &val)
        /// </summary>
        /// <param name="expression">The expression to evaluate.</param>
        /// <param name="value">The result of the expression.</param>
        /// <returns>True on success, False on failure.</returns>
        SCRIPT_EXPORT bool ParseExpression(const char* expression, duint* value);

        /// <summary>
        /// Returns the address of a function in the debuggee's memory space.
        ///
        /// Example: duint addr = RemoteGetProcAddress("kernel32.dll", "GetProcAddress")
        /// </summary>
        /// <param name="module">The name of the module.</param>
        /// <param name="api">The name of the function.</param>
        /// <returns>The address of the function in the debuggee.</returns>
        SCRIPT_EXPORT duint RemoteGetProcAddress(const char* module, const char* api);

        /// <summary>
        /// Returns the address for a label created in the disassembly window.
        ///
        /// Example: duint addr = ResolveLabel("sneaky_crypto")
        /// </summary>
        /// <param name="label">The name of the label to resolve.</param>
        /// <returns>The memory address for the label.</returns>
        SCRIPT_EXPORT duint ResolveLabel(const char* label);

        /// <summary>
        /// Allocates the requested number of bytes from x64dbg's default process heap.
        ///
        /// Note: this allocation is in the debugger, not the debuggee.
        ///
        /// Memory allocated using this function should be Free'd after use.
        ///
        /// Example: void* addr = Alloc(0x100000)
        /// </summary>
        /// <param name="size">Number of bytes to allocate.</param>
        /// <returns>A pointer to the newly allocated memory.</returns>
        SCRIPT_EXPORT void* Alloc(duint size);

        /// <summary>
        /// Frees memory previously allocated by Alloc.
        ///
        /// Example: Free(addr)
        /// </summary>
        /// <param name="ptr">Pointer returned by Alloc.</param>
        /// <returns>Nothing.</returns>
        SCRIPT_EXPORT void Free(void* ptr);
    }; //Misc
}; //Script

#endif //_SCRIPTAPI_MISC_H


================================================
File: src/pluginsdk/_scriptapi_module.h
================================================
#ifndef _SCRIPTAPI_MODULE_H
#define _SCRIPTAPI_MODULE_H

#include "_scriptapi.h"

namespace Script
{
    namespace Module
    {
        struct ModuleInfo
        {
            duint base;
            duint size;
            duint entry;
            int sectionCount;
            char name[MAX_MODULE_SIZE];
            char path[MAX_PATH];
        };

        struct ModuleSectionInfo
        {
            duint addr;
            duint size;
            char name[MAX_SECTION_SIZE * 5];
        };

        struct ModuleExport
        {
            duint ordinal;
            duint rva;
            duint va;
            bool forwarded;
            char forwardName[MAX_STRING_SIZE];
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        struct ModuleImport
        {
            duint iatRva;
            duint iatVa;
            duint ordinal; //equal to -1 if imported by name
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        SCRIPT_EXPORT bool InfoFromAddr(duint addr, ModuleInfo* info);
        SCRIPT_EXPORT bool InfoFromName(const char* name, ModuleInfo* info);
        SCRIPT_EXPORT duint BaseFromAddr(duint addr);
        SCRIPT_EXPORT duint BaseFromName(const char* name);
        SCRIPT_EXPORT duint SizeFromAddr(duint addr);
        SCRIPT_EXPORT duint SizeFromName(const char* name);
        SCRIPT_EXPORT bool NameFromAddr(duint addr, char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool PathFromAddr(duint addr, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool PathFromName(const char* name, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT duint EntryFromAddr(duint addr);
        SCRIPT_EXPORT duint EntryFromName(const char* name);
        SCRIPT_EXPORT int SectionCountFromAddr(duint addr);
        SCRIPT_EXPORT int SectionCountFromName(const char* name);
        SCRIPT_EXPORT bool SectionFromAddr(duint addr, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionFromName(const char* name, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionListFromAddr(duint addr, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool SectionListFromName(const char* name, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool GetMainModuleInfo(ModuleInfo* info);
        SCRIPT_EXPORT duint GetMainModuleBase();
        SCRIPT_EXPORT duint GetMainModuleSize();
        SCRIPT_EXPORT duint GetMainModuleEntry();
        SCRIPT_EXPORT int GetMainModuleSectionCount();
        SCRIPT_EXPORT bool GetMainModuleName(char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool GetMainModulePath(char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool GetMainModuleSectionList(ListOf(ModuleSectionInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetList(ListOf(ModuleInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetExports(const ModuleInfo* mod, ListOf(ModuleExport) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetImports(const ModuleInfo* mod, ListOf(ModuleImport) list); //caller has the responsibility to free the list
    }; //Module
}; //Script

#endif //_SCRIPTAPI_MODULE_H



================================================
File: src/pluginsdk/_scriptapi_pattern.h
================================================
#ifndef _SCRIPTAPI_PATTERN_H
#define _SCRIPTAPI_PATTERN_H

#include "_scriptapi.h"

namespace Script
{
    namespace Pattern
    {
        SCRIPT_EXPORT duint Find(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT void Write(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT void WriteMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT bool SearchAndReplace(unsigned char* data, duint datasize, const char* searchpattern, const char* replacepattern);
        SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern);
    };
};

#endif //_SCRIPTAPI_FIND_H


================================================
File: src/pluginsdk/_scriptapi_register.h
================================================
#ifndef _SCRIPTAPI_REGISTER_H
#define _SCRIPTAPI_REGISTER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Register
    {
        enum RegisterEnum
        {
            DR0,
            DR1,
            DR2,
            DR3,
            DR6,
            DR7,

            EAX,
            AX,
            AH,
            AL,
            EBX,
            BX,
            BH,
            BL,
            ECX,
            CX,
            CH,
            CL,
            EDX,
            DX,
            DH,
            DL,
            EDI,
            DI,
            ESI,
            SI,
            EBP,
            BP,
            ESP,
            SP,
            EIP,

#ifdef _WIN64
            RAX,
            RBX,
            RCX,
            RDX,
            RSI,
            SIL,
            RDI,
            DIL,
            RBP,
            BPL,
            RSP,
            SPL,
            RIP,
            R8,
            R8D,
            R8W,
            R8B,
            R9,
            R9D,
            R9W,
            R9B,
            R10,
            R10D,
            R10W,
            R10B,
            R11,
            R11D,
            R11W,
            R11B,
            R12,
            R12D,
            R12W,
            R12B,
            R13,
            R13D,
            R13W,
            R13B,
            R14,
            R14D,
            R14W,
            R14B,
            R15,
            R15D,
            R15W,
            R15B,
#endif //_WIN64

            CIP,
            CSP,
            CAX,
            CBX,
            CCX,
            CDX,
            CDI,
            CSI,
            CBP,
            CFLAGS
        }; //RegisterEnum

        SCRIPT_EXPORT duint Get(RegisterEnum reg);
        SCRIPT_EXPORT bool Set(RegisterEnum reg, duint value);
        SCRIPT_EXPORT int Size(); //gets architecture register size in bytes

        SCRIPT_EXPORT duint GetDR0();
        SCRIPT_EXPORT bool SetDR0(duint value);
        SCRIPT_EXPORT duint GetDR1();
        SCRIPT_EXPORT bool SetDR1(duint value);
        SCRIPT_EXPORT duint GetDR2();
        SCRIPT_EXPORT bool SetDR2(duint value);
        SCRIPT_EXPORT duint GetDR3();
        SCRIPT_EXPORT bool SetDR3(duint value);
        SCRIPT_EXPORT duint GetDR6();
        SCRIPT_EXPORT bool SetDR6(duint value);
        SCRIPT_EXPORT duint GetDR7();
        SCRIPT_EXPORT bool SetDR7(duint value);

        SCRIPT_EXPORT unsigned int GetEAX();
        SCRIPT_EXPORT bool SetEAX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetAX();
        SCRIPT_EXPORT bool SetAX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetAH();
        SCRIPT_EXPORT bool SetAH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetAL();
        SCRIPT_EXPORT bool SetAL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEBX();
        SCRIPT_EXPORT bool SetEBX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBX();
        SCRIPT_EXPORT bool SetBX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetBH();
        SCRIPT_EXPORT bool SetBH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetBL();
        SCRIPT_EXPORT bool SetBL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetECX();
        SCRIPT_EXPORT bool SetECX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetCX();
        SCRIPT_EXPORT bool SetCX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetCH();
        SCRIPT_EXPORT bool SetCH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetCL();
        SCRIPT_EXPORT bool SetCL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDX();
        SCRIPT_EXPORT bool SetEDX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDX();
        SCRIPT_EXPORT bool SetDX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetDH();
        SCRIPT_EXPORT bool SetDH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetDL();
        SCRIPT_EXPORT bool SetDL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDI();
        SCRIPT_EXPORT bool SetEDI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDI();
        SCRIPT_EXPORT bool SetDI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESI();
        SCRIPT_EXPORT bool SetESI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSI();
        SCRIPT_EXPORT bool SetSI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEBP();
        SCRIPT_EXPORT bool SetEBP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBP();
        SCRIPT_EXPORT bool SetBP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESP();
        SCRIPT_EXPORT bool SetESP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSP();
        SCRIPT_EXPORT bool SetSP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEIP();
        SCRIPT_EXPORT bool SetEIP(unsigned int value);

#ifdef _WIN64
        SCRIPT_EXPORT unsigned long long GetRAX();
        SCRIPT_EXPORT bool SetRAX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRBX();
        SCRIPT_EXPORT bool SetRBX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRCX();
        SCRIPT_EXPORT bool SetRCX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRDX();
        SCRIPT_EXPORT bool SetRDX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRSI();
        SCRIPT_EXPORT bool SetRSI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSIL();
        SCRIPT_EXPORT bool SetSIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRDI();
        SCRIPT_EXPORT bool SetRDI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetDIL();
        SCRIPT_EXPORT bool SetDIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRBP();
        SCRIPT_EXPORT bool SetRBP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetBPL();
        SCRIPT_EXPORT bool SetBPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRSP();
        SCRIPT_EXPORT bool SetRSP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSPL();
        SCRIPT_EXPORT bool SetSPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRIP();
        SCRIPT_EXPORT bool SetRIP(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetR8();
        SCRIPT_EXPORT bool SetR8(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR8D();
        SCRIPT_EXPORT bool SetR8D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR8W();
        SCRIPT_EXPORT bool SetR8W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR8B();
        SCRIPT_EXPORT bool SetR8B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR9();
        SCRIPT_EXPORT bool SetR9(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR9D();
        SCRIPT_EXPORT bool SetR9D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR9W();
        SCRIPT_EXPORT bool SetR9W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR9B();
        SCRIPT_EXPORT bool SetR9B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR10();
        SCRIPT_EXPORT bool SetR10(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR10D();
        SCRIPT_EXPORT bool SetR10D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR10W();
        SCRIPT_EXPORT bool SetR10W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR10B();
        SCRIPT_EXPORT bool SetR10B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR11();
        SCRIPT_EXPORT bool SetR11(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR11D();
        SCRIPT_EXPORT bool SetR11D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR11W();
        SCRIPT_EXPORT bool SetR11W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR11B();
        SCRIPT_EXPORT bool SetR11B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR12();
        SCRIPT_EXPORT bool SetR12(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR12D();
        SCRIPT_EXPORT bool SetR12D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR12W();
        SCRIPT_EXPORT bool SetR12W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR12B();
        SCRIPT_EXPORT bool SetR12B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR13();
        SCRIPT_EXPORT bool SetR13(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR13D();
        SCRIPT_EXPORT bool SetR13D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR13W();
        SCRIPT_EXPORT bool SetR13W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR13B();
        SCRIPT_EXPORT bool SetR13B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR14();
        SCRIPT_EXPORT bool SetR14(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR14D();
        SCRIPT_EXPORT bool SetR14D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR14W();
        SCRIPT_EXPORT bool SetR14W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR14B();
        SCRIPT_EXPORT bool SetR14B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR15();
        SCRIPT_EXPORT bool SetR15(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR15D();
        SCRIPT_EXPORT bool SetR15D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR15W();
        SCRIPT_EXPORT bool SetR15W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR15B();
        SCRIPT_EXPORT bool SetR15B(unsigned char value);
#endif //_WIN64

        SCRIPT_EXPORT duint GetCAX();
        SCRIPT_EXPORT bool SetCAX(duint value);
        SCRIPT_EXPORT duint GetCBX();
        SCRIPT_EXPORT bool SetCBX(duint value);
        SCRIPT_EXPORT duint GetCCX();
        SCRIPT_EXPORT bool SetCCX(duint value);
        SCRIPT_EXPORT duint GetCDX();
        SCRIPT_EXPORT bool SetCDX(duint value);
        SCRIPT_EXPORT duint GetCDI();
        SCRIPT_EXPORT bool SetCDI(duint value);
        SCRIPT_EXPORT duint GetCSI();
        SCRIPT_EXPORT bool SetCSI(duint value);
        SCRIPT_EXPORT duint GetCBP();
        SCRIPT_EXPORT bool SetCBP(duint value);
        SCRIPT_EXPORT duint GetCSP();
        SCRIPT_EXPORT bool SetCSP(duint value);
        SCRIPT_EXPORT duint GetCIP();
        SCRIPT_EXPORT bool SetCIP(duint value);
        SCRIPT_EXPORT duint GetCFLAGS();
        SCRIPT_EXPORT bool SetCFLAGS(duint value);
    }; //Register
}; //Script

#endif //_SCRIPTAPI_REGISTER_H


================================================
File: src/pluginsdk/_scriptapi_stack.h
================================================
#ifndef _SCRIPTAPI_STACK_H
#define _SCRIPTAPI_STACK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Stack
    {
        SCRIPT_EXPORT duint Pop();
        SCRIPT_EXPORT duint Push(duint value); //returns the previous top, equal to Peek(1)
        SCRIPT_EXPORT duint Peek(int offset = 0); //offset is in multiples of Register::Size(), for easy x32/x64 portability
    }; //Stack
}; //Script

#endif //_SCRIPTAPI_STACK_H


================================================
File: src/pluginsdk/_scriptapi_symbol.h
================================================
#ifndef _SCRIPTAPI_SYMBOL_H
#define _SCRIPTAPI_SYMBOL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Symbol
    {
        enum SymbolType
        {
            Function, //user-defined function
            Import, //IAT entry
            Export //export
        };

        struct SymbolInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char name[MAX_LABEL_SIZE];
            bool manual;
            SymbolType type;
        };

        SCRIPT_EXPORT bool GetList(ListOf(SymbolInfo) list); //caller has the responsibility to free the list
    }; //Symbol
}; //Script

#endif //_SCRIPTAPI_SYMBOL_H


================================================
File: src/pluginsdk/bridgegraph.h
================================================
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint addr; //virtual address of the instruction
    unsigned char data[15]; //instruction bytes
} BridgeCFInstruction;

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo instrs; //block instructions
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if _MSC_VER >= 1700 && !defined(NO_CPP11)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph = 0; //function of which this node is a part
    duint start = 0; //va of the first instruction in the block
    duint end = 0; //va of the last instruction in the block (inclusive)
    duint brtrue = 0; //destination if condition is true
    duint brfalse = 0; //destination if condition is false
    duint icount = 0; //number of instructions in node
    bool terminal = false; //node is a RET
    bool split = false; //node is a split (brtrue points to the next node)
    bool indirectcall = false; //node contains indirect calls (call reg, call [reg+X])
    void* userdata = nullptr; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<BridgeCFInstruction> instrs; //block instructions

    static void Free(const BridgeCFNodeList* nodeList)
    {
        if(!BridgeList<duint>::Free(&nodeList->exits))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::Free(&nodeList->instrs))
            __debugbreak();
    }

    BridgeCFNode() = default;

    BridgeCFNode(const BridgeCFNodeList* nodeList, bool freedata)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        indirectcall = nodeList->indirectcall;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::ToVector(&nodeList->instrs, instrs, freedata))
            __debugbreak();
    }

    BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.indirectcall = indirectcall;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<BridgeCFInstruction>::CopyData(&out.instrs, instrs);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    static void Free(const BridgeCFGraphList* graphList)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            BridgeCFNode::Free(&data[i]);
        BridgeFree(data);
    }

    explicit BridgeCFGraph(const BridgeCFGraphList* graphList, bool freedata)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
        {
            parents[child] = std::unordered_set<duint>();
            parents[child].insert(parent);
        }
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H


================================================
File: src/pluginsdk/bridgelist.h
================================================
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type)) //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count())) //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool Free(const ListInfo* listInfo)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        BridgeFree(listInfo->data);
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H


================================================
File: src/pluginsdk/bridgemain.h
================================================
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#define DEFAULT_PARAM(name, value) name
#else
#define DEFAULT_PARAM(name, value) name = value
#endif

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions

/// <summary>
/// Initialize the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeInit();

/// <summary>
/// Start the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeStart();

/// <summary>
/// Allocate buffer. Use BridgeFree to free the buffer.
/// </summary>
/// <param name="size">Size in bytes of the buffer to allocate.</param>
/// <returns>A pointer to the allocated buffer. This function will trigger a crash dump if unsuccessful.</returns>
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);

/// <summary>
/// Free buffer allocated by BridgeAlloc.
/// </summary>
/// <param name="ptr">Buffer to free.</param>
BRIDGE_IMPEXP void BridgeFree(void* ptr);

/// <summary>
/// Get a string setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output buffer for the value. Should be of MAX_SETTING_SIZE. Cannot be null.</param>
/// <returns>True if the setting was found and copied in the value parameter.</returns>
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);

/// <summary>
/// Get an integer setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output value.</param>
/// <returns>True if the setting was found and successfully converted to an integer.</returns>
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);

/// <summary>
/// Set a string setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value. Set to null to remove the key from the section.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);

/// <summary>
/// Set an integer setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);

/// <summary>
/// Flush the in-memory setting store to disk.
/// </summary>
/// <returns></returns>
BRIDGE_IMPEXP bool BridgeSettingFlush();

/// <summary>
/// Read the in-memory setting store from disk.
/// </summary>
/// <param name="errorLine">Line where the error occurred. Set to null to ignore this.</param>
/// <returns>True if the setting were read and parsed correctly.</returns>
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);

/// <summary>
/// Get the debugger version.
/// </summary>
/// <returns>25</returns>
BRIDGE_IMPEXP int BridgeGetDbgVersion();

/// <summary>
/// Checks if the current process is elevated.
/// </summary>
/// <returns>true if the process is elevated, false otherwise.</returns>
BRIDGE_IMPEXP bool BridgeIsProcessElevated();

#ifdef __cplusplus
}
#endif

//list structure (and C++ wrapper)
#include "bridgelist.h"

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 0x1,
    flaglabel = 0x2,
    flagcomment = 0x4,
    flagbookmark = 0x8,
    flagfunction = 0x10,
    flagloop = 0x20,
    flagargs = 0x40,
    flagNoFuncOffset = 0x80
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END,
    LOOP_SINGLE
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST,             // param1=ListOf(WATCHINFO),         param2=unused
    DBG_SELCHANGED,                 // param1=hWindow,                   param2=VA
    DBG_GET_PROCESS_HANDLE,         // param1=unused,                    param2=unused
    DBG_GET_THREAD_HANDLE,          // param1=unused,                    param2=unused
    DBG_GET_PROCESS_ID,             // param1=unused,                    param2=unused
    DBG_GET_THREAD_ID,              // param1=unused,                    param2=unused
    DBG_GET_PEB_ADDRESS,            // param1=DWORD ProcessId,           param2=unused
    DBG_GET_TEB_ADDRESS,            // param1=DWORD ThreadId,            param2=unused
    DBG_ANALYZE_FUNCTION,           // param1=BridgeCFGraphList* graph,  param2=duint entry
    DBG_MENU_PREPARE,               // param1=int hMenu,                 param2=unused
    DBG_GET_SYMBOL_INFO,            // param1=void* symbol,              param2=SYMBOLINFO* info
    DBG_GET_DEBUG_ENGINE,           // param1=unused,                    param2-unused
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8,
    size_xmmword = 16,
    size_ymmword = 32
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes avx512 not supported
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

typedef enum
{
    hw_access,
    hw_write,
    hw_execute
} BPHWTYPE;

typedef enum
{
    mem_access,
    mem_read,
    mem_write,
    mem_execute
} BPMEMTYPE;

typedef enum
{
    dll_load = 1,
    dll_unload,
    dll_all
} BPDLLTYPE;

typedef enum
{
    ex_firstchance = 1,
    ex_secondchance,
    ex_all
} BPEXTYPE;

typedef enum
{
    hw_byte,
    hw_word,
    hw_dword,
    hw_qword
} BPHWSIZE;

typedef enum
{
    sym_import,
    sym_export,
    sym_symbol
} SYMBOLTYPE;

typedef enum
{
    mod_user,
    mod_system
} MODULEPARTY;

typedef enum
{
    DebugEngineTitanEngine,
    DebugEngineGleeBug,
    DebugEngineStaticEngine,
} DEBUG_ENGINE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;

typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef bool (*CBSYMBOLENUM)(const struct SYMBOLPTR_* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned char typeEx; //BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE
    unsigned char hwSize; //BPHWSIZE
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} BRIDGE_ADDRINFO;

typedef struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    SYMBOLTYPE type;
    bool freeDecorated;
    bool freeUndecorated;
    DWORD ordinal;
} SYMBOLINFO;

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool ES;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    DWORD code;
    char name[128];
} LASTSTATUS;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
    LASTSTATUS lastStatus;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

typedef struct SYMBOLPTR_
{
    duint modbase;
    const void* symbol;
} SYMBOLPTR;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, void* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const void* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);

/// <summary>
/// Asynchronously execute a debugger command by adding it to the command queue.
/// Note: the command may not have completed before this call returns. Use this
/// function if you don't care when the command gets executed.
///
/// Example: DbgCmdExec("ClearLog")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command was successfully submitted to the command queue. False if the submission failed.</returns>
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);

/// <summary>
/// Performs synchronous execution of a debugger command. This function call only
/// returns after the command has completed.
///
/// Example: DbgCmdExecDirect("loadlib advapi32.dll")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command executed successfully, False if there was a problem.</returns>
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDumpEx(REGDUMP* regdump, size_t size);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr, duint* size);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);
BRIDGE_IMPEXP void DbgSelChanged(int hWindow, duint VA);
BRIDGE_IMPEXP HANDLE DbgGetProcessHandle();
BRIDGE_IMPEXP HANDLE DbgGetThreadHandle();
BRIDGE_IMPEXP DWORD DbgGetProcessId();
BRIDGE_IMPEXP DWORD DbgGetThreadId();
BRIDGE_IMPEXP duint DbgGetPebAddress(DWORD ProcessId);
BRIDGE_IMPEXP duint DbgGetTebAddress(DWORD ThreadId);
BRIDGE_IMPEXP bool DbgAnalyzeFunction(duint entry, BridgeCFGraphList* graph);
BRIDGE_IMPEXP duint DbgEval(const char* expression, bool* DEFAULT_PARAM(success, nullptr));
BRIDGE_IMPEXP void DbgGetSymbolInfo(const SYMBOLPTR* symbolptr, SYMBOLINFO* info);
BRIDGE_IMPEXP DEBUG_ENGINE DbgGetDebugEngine();

//Gui defines
typedef enum
{
    GUI_PLUGIN_MENU,
    GUI_DISASM_MENU,
    GUI_DUMP_MENU,
    GUI_STACK_MENU,
    GUI_GRAPH_MENU,
    GUI_MEMMAP_MENU,
    GUI_SYMMOD_MENU,
} GUIMENUTYPE;

BRIDGE_IMPEXP void DbgMenuPrepare(GUIMENUTYPE hMenu);

typedef enum
{
    GUI_DISASSEMBLY,
    GUI_DUMP,
    GUI_STACK,
    GUI_GRAPH,
    GUI_MEMMAP,
    GUI_SYMMOD,
} GUISELECTIONTYPE;

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=GUISELECTIONTYPE,     param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=GUISELECTIONTYPE,     param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_UPDATE_SEHCHAIN,            // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=duint addr
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACKEX cb,     param2=void* userdata
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG,     // param1=int id,               param2=unused
    GUI_UPDATE_ARGUMENT_VIEW,       // param1=unused,               param2=unused
    GUI_FOCUS_VIEW,                 // param1=int hWindow,          param2=unused
    GUI_UPDATE_WATCH_VIEW,          // param1=unused,               param2=unused
    GUI_LOAD_GRAPH,                 // param1=BridgeCFGraphList*    param2=unused
    GUI_GRAPH_AT,                   // param1=duint addr            param2=unused
    GUI_UPDATE_GRAPH_VIEW,          // param1=unused,               param2=unused
    GUI_SET_LOG_ENABLED,            // param1=bool isEnabled        param2=unused
    GUI_ADD_FAVOURITE_TOOL,         // param1=const char* name      param2=const char* description
    GUI_ADD_FAVOURITE_COMMAND,      // param1=const char* command   param2=const char* shortcut
    GUI_SET_FAVOURITE_TOOL_SHORTCUT,// param1=const char* name      param2=const char* shortcut
    GUI_FOLD_DISASSEMBLY,           // param1=duint startAddress    param2=duint length
    GUI_SELECT_IN_MEMORY_MAP,       // param1=duint addr,           param2=unused
    GUI_GET_ACTIVE_VIEW,            // param1=ACTIVEVIEW*,          param2=unused
    GUI_MENU_SET_ENTRY_CHECKED,     // param1=int hEntry,           param2=bool checked
    GUI_ADD_INFO_LINE,              // param1=const char* infoline, param2=unused
    GUI_PROCESS_EVENTS,             // param1=unused,               param2=unused
    GUI_TYPE_ADDNODE,               // param1=void* parent,         param2=TYPEDESCRIPTOR* type
    GUI_TYPE_CLEAR,                 // param1=unused,               param2=unused
    GUI_UPDATE_TYPE_WIDGET,         // param1=unused,               param2=unused
    GUI_CLOSE_APPLICATION,          // param1=unused,               param2=unused
    GUI_MENU_SET_VISIBLE,           // param1=int hMenu,            param2=bool visible
    GUI_MENU_SET_ENTRY_VISIBLE,     // param1=int hEntry,           param2=bool visible
    GUI_MENU_SET_NAME,              // param1=int hMenu,            param2=const char* name
    GUI_MENU_SET_ENTRY_NAME,        // param1=int hEntry,           param2=const char* name
    GUI_FLUSH_LOG,                  // param1=unused,               param2=unused
    GUI_MENU_SET_ENTRY_HOTKEY,      // param1=int hEntry,           param2=const char* hack
    GUI_REF_SEARCH_GETROWCOUNT,     // param1=unused,               param2=unused
    GUI_REF_SEARCH_GETCELLCONTENT,  // param1=int row,              param2=int col
    GUI_MENU_REMOVE,                // param1=int hEntryMenu,       param2=unused
    GUI_REF_ADDCOMMAND,             // param1=const char* title,    param2=const char* command
    GUI_OPEN_TRACE_FILE,            // param1=const char* file name,param2=unused
    GUI_UPDATE_TRACE_BROWSER,       // param1=unused,               param2=unused
    GUI_INVALIDATE_SYMBOL_SOURCE,   // param1=duint base,           param2=unused
    GUI_GET_CURRENT_GRAPH,          // param1=BridgeCFGraphList*,   param2=unused
    GUI_SHOW_REF,                   // param1=unused,               param2=unused
} GUIMSG;

//GUI Typedefs
struct _TYPEDESCRIPTOR;

typedef void (*GUICALLBACK)();
typedef void (*GUICALLBACKEX)(void*);
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);
typedef bool (*TYPETOSTRING)(const struct _TYPEDESCRIPTOR* type, char* dest, size_t* destCount); //don't change destCount for final failure

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

typedef struct
{
    void* titleHwnd;
    void* classHwnd;
    char title[MAX_STRING_SIZE];
    char className[MAX_STRING_SIZE];
} ACTIVEVIEW;

typedef struct _TYPEDESCRIPTOR
{
    bool expanded; //is the type node expanded?
    bool reverse; //big endian?
    const char* name; //type name (int b)
    duint addr; //virtual address
    duint offset; //offset to addr for the actual location
    int id; //type id
    int size; //sizeof(type)
    TYPETOSTRING callback; //convert to string
    void* userdata; //user data
} TYPEDESCRIPTOR;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiSetDebugStateFast(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP int GuiReferenceSearchGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP char* GuiReferenceSearchGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP void GuiMenuRemove(int hEntryMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(GUISELECTIONTYPE hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(GUISELECTIONTYPE hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFileEx(const char* path, duint addr);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryChecked(int hEntry, bool checked);
BRIDGE_IMPEXP void GuiMenuSetVisible(int hMenu, bool visible);
BRIDGE_IMPEXP void GuiMenuSetEntryVisible(int hEntry, bool visible);
BRIDGE_IMPEXP void GuiMenuSetName(int hMenu, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryName(int hEntry, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryHotkey(int hEntry, const char* hack);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP bool GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP duint GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);
BRIDGE_IMPEXP void GuiGetActiveView(ACTIVEVIEW* activeView);
BRIDGE_IMPEXP void GuiAddInfoLine(const char* infoLine);
BRIDGE_IMPEXP void GuiProcessEvents();
BRIDGE_IMPEXP void* GuiTypeAddNode(void* parent, const TYPEDESCRIPTOR* type);
BRIDGE_IMPEXP bool GuiTypeClear();
BRIDGE_IMPEXP void GuiUpdateTypeWidget();
BRIDGE_IMPEXP void GuiCloseApplication();
BRIDGE_IMPEXP void GuiFlushLog();
BRIDGE_IMPEXP void GuiReferenceAddCommand(const char* title, const char* command);
BRIDGE_IMPEXP void GuiUpdateTraceBrowser();
BRIDGE_IMPEXP void GuiOpenTraceFile(const char* fileName);
BRIDGE_IMPEXP void GuiInvalidateSymbolSource(duint base);
BRIDGE_IMPEXP void GuiExecuteOnGuiThreadEx(GUICALLBACKEX cbGuiThread, void* userdata);
BRIDGE_IMPEXP void GuiGetCurrentGraph(BridgeCFGraphList* graphList);
BRIDGE_IMPEXP void GuiShowReferences();

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_



================================================
File: src/pluginsdk/DeviceNameResolver/DeviceNameResolver.h
================================================
#ifndef _DEVICENAMERESOLVER_H
#define _DEVICENAMERESOLVER_H

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

__declspec(dllexport) bool DevicePathToPathW(const wchar_t* szDevicePath, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathToPathA(const char* szDevicePath, char* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleW(HANDLE hFile, wchar_t* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleA(HANDLE hFile, char* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleW(HANDLE hFile, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleA(HANDLE hFile, char* szPath, size_t nSizeInChars);

#ifdef __cplusplus
}
#endif

#endif // _DEVICENAMERESOLVER_H



================================================
File: src/pluginsdk/TitanEngine/TitanEngine.h
================================================
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <stdint.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9
#define UE_ENGINE_SAFE_ATTACH 10

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, const char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(const char* szFileName, const char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(const wchar_t* szFileName, const wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(const char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(const char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(const wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(const char* szFileName, const char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(const wchar_t* szFileName, const wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(const char* szFileName, const char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(const wchar_t* szFileName, const wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(const char* szInFileName, const char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(const wchar_t* szInFileName, const wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(const char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(const char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(const char* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(const char* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(const char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(const wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(const char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(const wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(const char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(const char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(const wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(const char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(const char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(const wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(const char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(const wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(const char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(const wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(const char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(const wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(const char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(const wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(const char* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(const wchar_t* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, const char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, const wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const char* szDumpFile1, const char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const wchar_t* szDumpFile1, const wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(const char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(const wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(const char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(const wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(const char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(const char* szFileName, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(const wchar_t* szFileName, char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(const char* szFileName, const char* szResourceType, DWORD ResourceType, const char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(const wchar_t* szFileName, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(const char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(const wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(const char* szFileName, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(const char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(const wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(const char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(const char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(const char* szDumpFileName, const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(const wchar_t* szDumpFileName, const wchar_t* szExportFileName, const wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(const char* szDLLName, const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, const char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, const wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(const char* szOriginalFile, const char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(const char* szOriginalFile, const char* szDumpFile, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile, const char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, const char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, const wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, const char* szDumpedFile, const char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, const wchar_t* szDumpedFile, const wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, const char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, const wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(const char* szModuleName, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(const char* szModuleName, const char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(const char* szModuleName, const char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(const char* szModuleName, const char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, const char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, const char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(const char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(const wchar_t* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(const wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(const char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(const char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(const char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(const wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(const char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(const wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(const char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(const char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(const wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(const char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(const wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(const char* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(const wchar_t* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(const char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(const wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, const char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, const wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(const char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(const wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(const char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(const wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(const char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(const wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(const char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(const wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(const wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(const char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(const char* szFileName, const char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(const wchar_t* szFileName, const wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(const char* szFileName, const char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(const wchar_t* szFileName, const wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(const char* WindowUnpackerTitle, const char* WindowUnpackerLongTitle, const char* WindowUnpackerName, const char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(const char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);
// Global.Engine.Extension.Functions:
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginLoaded(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginEnabled(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerDisableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerDisablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerEnableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerEnablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadPlugin(const char* szPluginName);
__declspec(dllexport) void* TITCALL ExtensionManagerGetPluginInfo(const char* szPluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/



================================================
File: src/pluginsdk/XEDParse/XEDParse.h
================================================
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H



================================================
File: src/pluginsdk/dbghelp/dbghelp.h
================================================
#ifndef _DBGHELP_
#define _DBGHELP_


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif

#pragma pack(push,8)

// For those without specstrings.h
// Since there are different versions of this header, I need to
// individually test each item and define it if it is not around.

#ifndef __in
#define __in
#endif
#ifndef __out
#define __out
#endif
#ifndef __inout
#define __inout
#endif
#ifndef __in_opt
#define __in_opt
#endif
#ifndef __out_opt
#define __out_opt
#endif
#ifndef __inout_opt
#define __inout_opt
#endif
#ifndef __in_ecount
#define __in_ecount(x)
#endif
#ifndef __out_ecount
#define __out_ecount(x)
#endif
#ifndef __inout_ecount
#define __inout_ecount(x)
#endif
#ifndef __in_bcount
#define __in_bcount(x)
#endif
#ifndef __out_bcount
#define __out_bcount(x)
#endif
#ifndef __inout_bcount
#define __inout_bcount(x)
#endif
#ifndef __out_xcount
#define __out_xcount(x)
#endif
#ifndef __deref_opt_out
#define __deref_opt_out
#endif
#ifndef __deref_out
#define __deref_out
#endif
#ifndef __out_ecount_opt
#define __out_ecount_opt(x)
#endif
#ifndef __in_bcount_opt
#define __in_bcount_opt(x)
#endif
#ifndef __out_bcount_opt
#define __out_bcount_opt(x)
#endif
#ifndef __deref_out_opt
#define __deref_out_opt
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DBHLP_DEPRECIATED   __declspec(deprecated)
#else
#define DBHLP_DEPRECIATED
#endif
#endif

#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

// Observant readers may notice that 2 new fields,
// 'fReadOnly' and 'Version' have been added to
// the LOADED_IMAGE structure after 'fDOSImage'.
// This does not change the size of the structure
// from previous headers.  That is because while
// 'fDOSImage' is a byte, it is padded by the
// compiler to 4 bytes.  So the 2 new fields are
// slipped into the extra space.

typedef struct _LOADED_IMAGE
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

#define MAX_SYM_NAME            2000


// Error codes set by dbghelp functions.  Call GetLastError
// to see them.
// Dbghelp also sets error codes found in winerror.h

#define ERROR_IMAGE_NOT_STRIPPED    0x8800  // the image is not stripped.  No dbg file available.
#define ERROR_NO_DBG_POINTER        0x8801  // image is stripped but there is no pointer to a dbg file
#define ERROR_NO_PDB_POINTER        0x8802  // image does not point to a pdb file

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFile(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in PVOID  CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFileW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFile(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath
);

HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR  DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFileExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACK)(
    __in PCSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPath(
    __in HANDLE hprocess,
    __in_opt PCSTR SearchPath,
    __in PCSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACK callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACKW)(
    __in PCWSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPathW(
    __in HANDLE hprocess,
    __in_opt PCWSTR SearchPath,
    __in PCWSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PWSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACKW callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImage(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACK Callback,
    __in PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImageW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImage(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath
);

HANDLE
IMAGEAPI
FindExecutableImageEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImageExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader(
    __in PVOID Base
);

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size,
    __out_opt PIMAGE_SECTION_HEADER* FoundHeader
);

PVOID
IMAGEAPI
ImageDirectoryEntryToData(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size
);

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva
);

PVOID
IMAGEAPI
ImageRvaToVa(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva,
    __in_opt OUT PIMAGE_SECTION_HEADER* LastRvaSection
);

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION
{
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    __in_opt HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PCSTR SymbolPath,
    __in ULONG ImageBase
);

BOOL
IMAGEAPI
UnmapDebugInformation(
    __out_xcount(unknown) PIMAGE_DEBUG_INFORMATION DebugInfo
);

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PSTR OutputPathBuffer
);

BOOL
IMAGEAPI
SearchTreeForFileW(
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PWSTR OutputPathBuffer
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACK)(
    __in PCSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTree(
    __in_opt HANDLE hProcess,
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACK cb,
    __in_opt PVOID data
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACKW)(
    __in PCWSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTreeW(
    __in_opt HANDLE hProcess,
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PWSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACKW cb,
    __in_opt PVOID data
);

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    __in PCSTR DirPath
);

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
//  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    __in PCSTR name,
    __out_ecount(maxStringLength) PSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolNameW(
    __in PCWSTR name,
    __out_ecount(maxStringLength) PWSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1
#define DBHHEADER_CVMISC        0x2
#define DBHHEADER_PDBGUID       0x3
typedef struct _MODLOAD_DATA
{
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

typedef struct _MODLOAD_CVMISC
{
    DWORD   oCV;                    // ofset to the codeview record
    size_t  cCV;                    // size of the codeview record
    DWORD   oMisc;                  // offset to the misc record
    size_t  cMisc;                  // size of the misc record
    DWORD   dtImage;                // datetime stamp of the image
    DWORD   cImage;                 // size of the image
} MODLOAD_CVMISC, *PMODLOAD_CVMISC;

typedef struct _MODLOAD_PDBGUID_PDBAGE
{
    GUID    PdbGuid;                // Pdb Guid
    DWORD   PdbAge;                 // Pdb Age
} MODLOAD_PDBGUID_PDBAGE, *PMODLOAD_PDBGUID_PDBAGE;

//
// StackWalking API
//

typedef enum
{
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64
{
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS
{
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    __in LPADDRESS a32,
    __out LPADDRESS64 a64
)
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    __in LPADDRESS64 a64,
    __out LPADDRESS a32
)
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD64   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD64   StackBase;
    DWORD64   StackLimit;

    DWORD64   Reserved[5];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD   StackBase;
    DWORD   StackLimit;

    DWORD   Reserved[5];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    __in PKDHELP p32,
    __out PKDHELP64 p64
)
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
    p64->KiUserExceptionDispatcher = p32->KiUserExceptionDispatcher;
    p64->StackBase = p32->StackBase;
    p64->StackLimit = p32->StackLimit;
}
#endif

typedef struct _tagSTACKFRAME64
{
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME
{
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 qwBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out LPDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    __in HANDLE ahProcess,
    __in DWORD64 AddrBase
);

typedef
DWORD64
(__stdcall* PGET_MODULE_BASE_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 Address
);

typedef
DWORD64
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE64)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __in LPADDRESS64 lpaddr
);

BOOL
IMAGEAPI
StackWalk64(
    __in DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME64 StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD lpBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out PDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);

typedef
DWORD
(__stdcall* PGET_MODULE_BASE_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD Address
);

typedef
DWORD
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __out LPADDRESS lpaddr
);

BOOL
IMAGEAPI
StackWalk(
    DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE TranslateAddress
);

#endif


#define API_VERSION_NUMBER 11

typedef struct API_VERSION
{
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
);

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    __in LPAPI_VERSION AppVersion
);

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    __in HMODULE Module
);

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64)(
    __in PCSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64W)(
    __in PCWSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt ULONG64 CallbackData,
    __in_opt ULONG64 UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK)(
    __in HANDLE hProcess,
    __in DWORD AddrBase,
    __in_opt PVOID UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG64 AddrBase,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK)(
    __in PCSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACKW)(
    __in PCWSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt PVOID CallbackData,
    __in_opt PVOID UserContext
);

#endif


// values found in SYMBOL_INFO.Tag
//
// This was taken from cvconst.h and should
// not override any values found there.
//
// #define _NO_CVCONST_H_ if you don't
// have access to that file...

#ifdef _NO_CVCONST_H

// DIA enums

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

#endif

//
// flags found in SYMBOL_INFO.Flags
//

#define SYMFLAG_VALUEPRESENT     0x00000001
#define SYMFLAG_REGISTER         0x00000008
#define SYMFLAG_REGREL           0x00000010
#define SYMFLAG_FRAMEREL         0x00000020
#define SYMFLAG_PARAMETER        0x00000040
#define SYMFLAG_LOCAL            0x00000080
#define SYMFLAG_CONSTANT         0x00000100
#define SYMFLAG_EXPORT           0x00000200
#define SYMFLAG_FORWARDER        0x00000400
#define SYMFLAG_FUNCTION         0x00000800
#define SYMFLAG_VIRTUAL          0x00001000
#define SYMFLAG_THUNK            0x00002000
#define SYMFLAG_TLSREL           0x00004000
#define SYMFLAG_SLOT             0x00008000
#define SYMFLAG_ILREL            0x00010000
#define SYMFLAG_METADATA         0x00020000
#define SYMFLAG_CLR_TOKEN        0x00040000

// this resets SymNext/Prev to the beginning
// of the module passed in the address field

#define SYMFLAG_RESET            0x80000000

//
// symbol type enumeration
//
typedef enum
{
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    SymVirtual,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR    Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

typedef struct _IMAGEHLP_SYMBOL64_PACKAGE
{
    IMAGEHLP_SYMBOL64 sym;
    CHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL64_PACKAGE, *PIMAGEHLP_SYMBOL64_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR   Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW64, *PIMAGEHLP_SYMBOLW64;

typedef struct _IMAGEHLP_SYMBOLW64_PACKAGE
{
    IMAGEHLP_SYMBOLW64 sym;
    WCHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW64_PACKAGE, *PIMAGEHLP_SYMBOLW64_PACKAGE;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#define IMAGEHLP_SYMBOL_PACKAGE IMAGEHLP_SYMBOL64_PACKAGE
#define PIMAGEHLP_SYMBOL_PACKAGE PIMAGEHLP_SYMBOL64_PACKAGE
#define IMAGEHLP_SYMBOLW IMAGEHLP_SYMBOLW64
#define PIMAGEHLP_SYMBOLW PIMAGEHLP_SYMBOLW64
#define IMAGEHLP_SYMBOLW_PACKAGE IMAGEHLP_SYMBOLW64_PACKAGE
#define PIMAGEHLP_SYMBOLW_PACKAGE PIMAGEHLP_SYMBOLW64_PACKAGE

#else

typedef struct _IMAGEHLP_SYMBOL
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef struct _IMAGEHLP_SYMBOL_PACKAGE
{
    IMAGEHLP_SYMBOL sym;
    CHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL_PACKAGE, *PIMAGEHLP_SYMBOL_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR                       Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW, *PIMAGEHLP_SYMBOLW;

typedef struct _IMAGEHLP_SYMBOLW_PACKAGE
{
    IMAGEHLP_SYMBOLW sym;
    WCHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW_PACKAGE, *PIMAGEHLP_SYMBOLW_PACKAGE;

#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
    // new elements: 07-Jun-2002
    CHAR     LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    // new elements: 07-Jun-2002
    WCHAR    LoadedImageName[256];   // symbol file name
    WCHAR    LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    WCHAR        CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    WCHAR    LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

typedef struct _IMAGEHLP_LINEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PWSTR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW64, *PIMAGEHLP_LINEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD    Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;

typedef struct _IMAGEHLP_LINEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW, *PIMAGEHLP_LINEW;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE
{
    DWORD64  ModBase;                // base address of loaded module
    PCHAR    FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

typedef struct _SOURCEFILEW
{
    DWORD64  ModBase;                // base address of loaded module
    PWSTR    FileName;               // full filename of source
} SOURCEFILEW, *PSOURCEFILEW;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000
#define CBA_SRCSRV_INFO                         0x20000000
#define CBA_SRCSRV_EVENT                        0x40000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY
{
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD*    bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum
{
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

#define EVENT_SRCSPEW_START 100
#define EVENT_SRCSPEW       100
#define EVENT_SRCSPEW_END   199

typedef struct _IMAGEHLP_CBA_EVENT
{
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_CBA_EVENTW
{
    DWORD  severity;                                     // values from sevInfo to sevFatal
    DWORD  code;                                         // numerical code IDs the error
    PCWSTR desc;                                         // may contain a text description of the error
    PVOID  object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENTW, *PIMAGEHLP_CBA_EVENTW;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;                     //
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOADW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOADW64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    WCHAR    FileName[MAX_PATH + 1]; // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;         //
} IMAGEHLP_DEFERRED_SYMBOL_LOADW64, *PIMAGEHLP_DEFERRED_SYMBOL_LOADW64;

#define DSLFLAG_MISMATCHED_PDB  0x1
#define DSLFLAG_MISMATCHED_DBG  0x2

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64
{
    DWORD              SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD              NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64 Symbol;                 // array of duplicate symbols
    DWORD              SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL
{
    DWORD            SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD            NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL Symbol;                 // array of duplicate symbols
    DWORD            SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
IMAGEAPI
SymSetParentWindow(
    __in HWND hwnd
);

PCHAR
IMAGEAPI
SymSetHomeDirectory(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR dir
);

PWSTR
IMAGEAPI
SymSetHomeDirectoryW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR dir
);

PCHAR
IMAGEAPI
SymGetHomeDirectory(
    __in DWORD type,
    __out_ecount(size) PSTR dir,
    __in size_t size
);

PWSTR
IMAGEAPI
SymGetHomeDirectoryW(
    __in DWORD type,
    __out_ecount(size) PWSTR dir,
    __in size_t size
);

enum
{
    hdBase = 0, // root directory for dbghelp
    hdSym,      // where symbols are stored
    hdSrc,      // where source is stored
    hdMax       // end marker
};

typedef struct _OMAP
{
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

BOOL
IMAGEAPI
SymGetOmaps(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll,
    __out POMAP* OmapTo,
    __out PDWORD64 cOmapTo,
    __out POMAP* OmapFrom,
    __out PDWORD64 cOmapFrom
);

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE          0x00000001
#define SYMOPT_UNDNAME                   0x00000002
#define SYMOPT_DEFERRED_LOADS            0x00000004
#define SYMOPT_NO_CPP                    0x00000008
#define SYMOPT_LOAD_LINES                0x00000010
#define SYMOPT_OMAP_FIND_NEAREST         0x00000020
#define SYMOPT_LOAD_ANYTHING             0x00000040
#define SYMOPT_IGNORE_CVREC              0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS      0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS      0x00000200
#define SYMOPT_EXACT_SYMBOLS             0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS    0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH         0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES     0x00002000
#define SYMOPT_PUBLICS_ONLY              0x00004000
#define SYMOPT_NO_PUBLICS                0x00008000
#define SYMOPT_AUTO_PUBLICS              0x00010000
#define SYMOPT_NO_IMAGE_SEARCH           0x00020000
#define SYMOPT_SECURE                    0x00040000
#define SYMOPT_NO_PROMPTS                0x00080000
#define SYMOPT_OVERWRITE                 0x00100000
#define SYMOPT_IGNORE_IMAGEDIR           0x00200000
#define SYMOPT_FLAT_DIRECTORY            0x00400000
#define SYMOPT_FAVOR_COMPRESSED          0x00800000
#define SYMOPT_ALLOW_ZERO_ADDRESS        0x01000000
#define SYMOPT_DISABLE_SYMSRV_AUTODETECT 0x02000000

#define SYMOPT_DEBUG                     0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    __in DWORD   SymOptions
);

DWORD
IMAGEAPI
SymGetOptions(
    VOID
);

BOOL
IMAGEAPI
SymCleanup(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymMatchString(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringA(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringW(
    __in PCWSTR string,
    __in PCWSTR expression,
    __in BOOL fCase
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACK)(
    __in PSOURCEFILE pSourceFile,
    __in_opt PVOID UserContext
);

// for backwards compatibility - don't use this
#define PSYM_ENUMSOURCFILES_CALLBACK PSYM_ENUMSOURCEFILES_CALLBACK

BOOL
IMAGEAPI
SymEnumSourceFiles(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACKW)(
    __in PSOURCEFILEW pSourceFile,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceFilesW(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModules64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModulesW64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    __in_opt PVOID UserContext
);
#endif

BOOL
IMAGEAPI
EnumerateLoadedModulesEx(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesExW(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesW64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    __in HANDLE hProcess,
    __in DWORD64 AddrBase
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);
#endif

BOOL
IMAGEAPI
SymGetUnwindInfo(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_bcount_opt(*Size) PVOID Buffer,
    __inout PULONG Size
);

BOOL
IMAGEAPI
SymGetModuleInfo64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULE64 ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULEW64 ModuleInfo
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULE ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULEW ModuleInfo
);
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    __in HANDLE hProcess,
    __in DWORD dwAddr
);
#endif

typedef struct _SRCCODEINFO
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    CHAR    Obj[MAX_PATH + 1];      // the object file within the module
    CHAR    FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFO, *PSRCCODEINFO;

typedef struct _SRCCODEINFOW
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    WCHAR   Obj[MAX_PATH + 1];      // the object file within the module
    WCHAR   FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFOW, *PSRCCODEINFOW;

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACK)(
    __in PSRCCODEINFO LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACKW)(
    __in PSRCCODEINFOW LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE64 Line64
);

BOOL
IMAGEAPI
SymGetLineFromAddrW64(
    __in HANDLE hProcess,
    __in DWORD64 dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW64 Line
);

BOOL
IMAGEAPI
SymEnumSourceLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

// flags for SymEnumSourceLines

#define ESLFLAG_FULLPATH        0x1
#define ESLFLAG_NEAREST         0x2
#define ESLFLAG_PREV            0x4
#define ESLFLAG_NEXT            0x8

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#define SymGetLineFromAddrW SymGetLineFromAddrW64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineFromAddrW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineFromNameW64(
    __in HANDLE hProcess,
    __in_opt PCWSTR ModuleName,
    __in_opt PCWSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE Line
);
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLinePrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLinePrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in PCSTR FileName,
    __out_ecount(BufferLines) PDWORD64 Buffer,
    __in ULONG BufferLines
);

BOOL
IMAGEAPI
SymMatchFileName(
    __in PCSTR FileName,
    __in PCSTR Match,
    __deref_opt_out PSTR* FileNameStop,
    __deref_opt_out PSTR* MatchStop
);

BOOL
IMAGEAPI
SymMatchFileNameW(
    __in PCWSTR FileName,
    __in PCWSTR Match,
    __deref_opt_out PWSTR* FileNameStop,
    __deref_opt_out PWSTR* MatchStop
);

BOOL
IMAGEAPI
SymGetSourceFile(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Params,
    __in PCSTR FileSpec,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Params,
    __in PCWSTR FileSpec,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileToken(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileTokenW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __in PCSTR VarName,
    __out_ecount(Size) PSTR Value,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __in PCWSTR VarName,
    __out_ecount(Size) PWSTR Value,
    __in DWORD Size
);

typedef BOOL (CALLBACK* PENUMSOURCEFILETOKENSCALLBACK)(__in PVOID token,  __in size_t size);

BOOL
IMAGEAPI
SymEnumSourceFileTokens(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PENUMSOURCEFILETOKENSCALLBACK Callback
);

BOOL
IMAGEAPI
SymInitialize(
    __in HANDLE hProcess,
    __in_opt PCSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymInitializeW(
    __in HANDLE hProcess,
    __in_opt PCWSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymGetSearchPath(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymGetSearchPathW(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PWSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymSetSearchPath(
    __in HANDLE hProcess,
    __in_opt PCSTR SearchPath
);

BOOL
IMAGEAPI
SymSetSearchPathW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SearchPath
);

#define SLMFLAG_VIRTUAL     0x1
#define SLMFLAG_ALT_INDEX   0x2
#define SLMFLAG_NO_SYMBOLS  0x4

DWORD64
IMAGEAPI
SymLoadModuleEx(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

DWORD64
IMAGEAPI
SymLoadModuleExW(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCWSTR ImageName,
    __in_opt PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

BOOL
IMAGEAPI
SymUnloadModule64(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    __in HANDLE hProcess,
    __in DWORD BaseOfDll
);
#endif

BOOL
IMAGEAPI
SymUnDName64(
    __in PIMAGEHLP_SYMBOL64 sym,            // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    __in PIMAGEHLP_SYMBOL sym,              // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterCallbackW64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC
{
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO   // AKA TYPTYP
{
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef struct _SYMBOL_INFO
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _SYMBOL_INFO_PACKAGE
{
    SYMBOL_INFO si;
    CHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGE, *PSYMBOL_INFO_PACKAGE;

typedef struct _SYMBOL_INFOW
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    WCHAR       Name[1];          // Name of symbol
} SYMBOL_INFOW, *PSYMBOL_INFOW;

typedef struct _SYMBOL_INFO_PACKAGEW
{
    SYMBOL_INFOW si;
    WCHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGEW, *PSYMBOL_INFO_PACKAGEW;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


BOOL
IMAGEAPI
SymSetContext(
    __in HANDLE hProcess,
    __in PIMAGEHLP_STACK_FRAME StackFrame,
    __in_opt PIMAGEHLP_CONTEXT Context
);

BOOL
IMAGEAPI
SymSetScopeFromAddr(
    __in HANDLE hProcess,
    __in ULONG64 Address
);

BOOL
IMAGEAPI
SymSetScopeFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index
);

typedef BOOL
(CALLBACK* PSYM_ENUMPROCESSES_CALLBACK)(
    __in HANDLE hProcess,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumProcesses(
    __in PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymFromAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromToken(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromTokenW(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymNext(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymNextW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

BOOL
IMAGEAPI
SymPrev(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymPrevW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromNameW(
    __in HANDLE hProcess,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACK)(
    __in PSYMBOL_INFO pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbols(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACKW)(
    __in PSYMBOL_INFOW pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

#define SYMSEARCH_MASKOBJS      0x01    // used internally to implement other APIs
#define SYMSEARCH_RECURSE       0X02    // recurse scopes
#define SYMSEARCH_GLOBALSONLY   0X04    // search only for global symbols
#define SYMSEARCH_ALLITEMS      0X08    // search for everything in the pdb, not just normal scoped symbols

BOOL
IMAGEAPI
SymSearch(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymSearchW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCWSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymGetScope(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetScopeW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromIndexW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO
{
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
    TI_GET_UDTKIND,
    TI_IS_EQUIV_TO,
    TI_GET_CALLING_CONVENTION,
    TI_IS_CLOSE_EQUIV_TO,
    TI_GTIEX_REQS_VALID,
    TI_GET_VIRTUALBASEOFFSET,
    TI_GET_VIRTUALBASEDISPINDEX,
    TI_GET_IS_REFERENCE,
    TI_GET_INDIRECTVIRTUALBASECLASS,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS
{
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __in ULONG TypeId,
    __in IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    __out PVOID pInfo
);

#define IMAGEHLP_GET_TYPE_INFO_UNCACHED 0x00000001
#define IMAGEHLP_GET_TYPE_INFO_CHILDREN 0x00000002

typedef struct _IMAGEHLP_GET_TYPE_INFO_PARAMS
{
    IN  ULONG    SizeOfStruct;
    IN  ULONG    Flags;
    IN  ULONG    NumIds;
    IN  PULONG   TypeIds;
    IN  ULONG64  TagFilter;
    IN  ULONG    NumReqs;
    IN  IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
    IN  PULONG_PTR ReqOffsets;
    IN  PULONG   ReqSizes;
    IN  ULONG_PTR ReqStride;
    IN  ULONG_PTR BufferSize;
    OUT PVOID    Buffer;
    OUT ULONG    EntriesMatched;
    OUT ULONG    EntriesFilled;
    OUT ULONG64  TagsFound;
    OUT ULONG64  AllReqsValid;
    IN  ULONG    NumReqsValid;
    OUT PULONG64 ReqsValid OPTIONAL;
} IMAGEHLP_GET_TYPE_INFO_PARAMS, *PIMAGEHLP_GET_TYPE_INFO_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfoEx(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __inout PIMAGEHLP_GET_TYPE_INFO_PARAMS Params
);

BOOL
IMAGEAPI
SymEnumTypes(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetTypeFromName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetTypeFromNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymAddSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymAddSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymRefreshModuleList(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymAddSourceStream(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAM)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamA(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAMA)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR FileSpec,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

BOOL
IMAGEAPI
SymSrvIsStoreW(
    __in_opt HANDLE hProcess,
    __in PCWSTR path
);

BOOL
IMAGEAPI
SymSrvIsStore(
    __in_opt HANDLE hProcess,
    __in PCSTR path
);

PCSTR
IMAGEAPI
SymSrvDeltaName(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Type,
    __in PCSTR File1,
    __in PCSTR File2
);

PCWSTR
IMAGEAPI
SymSrvDeltaNameW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Type,
    __in PCWSTR File1,
    __in PCWSTR File2
);

PCSTR
IMAGEAPI
SymSrvGetSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Node,
    __in PCSTR File
);

PCWSTR
IMAGEAPI
SymSrvGetSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File
);

BOOL
IMAGEAPI
SymSrvGetFileIndexes(
    __in PCSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexesW(
    __in PCWSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexStringW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __out_ecount(Size) PWSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexString(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __out_ecount(Size) PSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

typedef struct
{
    DWORD sizeofstruct;
    char file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    char dbgfile[MAX_PATH + 1];
    char pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFO, *PSYMSRV_INDEX_INFO;

typedef struct
{
    DWORD sizeofstruct;
    WCHAR file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    WCHAR dbgfile[MAX_PATH + 1];
    WCHAR pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFOW, *PSYMSRV_INDEX_INFOW;

BOOL
IMAGEAPI
SymSrvGetFileIndexInfo(
    __in PCSTR File,
    __out PSYMSRV_INDEX_INFO Info,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexInfoW(
    __in PCWSTR File,
    __out PSYMSRV_INDEX_INFOW Info,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR Node,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __in DWORD Flags
);

// used by SymGetSymbolFile's "Type" parameter

enum
{
    sfImage = 0,
    sfDbg,
    sfPdb,
    sfMpd,
    sfMax
};

BOOL
IMAGEAPI
SymGetSymbolFile(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
);

BOOL
IMAGEAPI
SymGetSymbolFileW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PWSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PWSTR DbgFile,
    __in size_t cDbgFile
);

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI* PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    __in DWORD DataType,
    __in PVOID* Data,
    __out LPDWORD DataLength,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDump(
    __in_opt LPCSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    __in_opt LPCWSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out_opt PDWORD64 pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL64  Symbol
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out_opt PDWORD pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif


// Symbol server exports

typedef BOOL (WINAPI* PSYMBOLSERVERPROC)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCA)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROC)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCA)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCW)(PCWSTR, PCWSTR, PCWSTR, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSWPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR(WINAPI* PSYMBOLSERVERGETOPTIONSPROC)();
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROC)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCA)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCW)(PCWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERGETVERSION)(LPAPI_VERSION);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAME)(PCSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAMEW)(PCWSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRING)(PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRINGW)(PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILE)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILEW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTORE)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTOREW)(PCWSTR);
typedef DWORD (WINAPI* PSYMBOLSERVERVERSION)();
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERMESSAGEPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);

#define SYMSRV_VERSION              2

#define SSRVOPT_CALLBACK            0x00000001
#define SSRVOPT_DWORD               0x00000002
#define SSRVOPT_DWORDPTR            0x00000004
#define SSRVOPT_GUIDPTR             0x00000008
#define SSRVOPT_OLDGUIDPTR          0x00000010
#define SSRVOPT_UNATTENDED          0x00000020
#define SSRVOPT_NOCOPY              0x00000040
#define SSRVOPT_GETPATH             0x00000040
#define SSRVOPT_PARENTWIN           0x00000080
#define SSRVOPT_PARAMTYPE           0x00000100
#define SSRVOPT_SECURE              0x00000200
#define SSRVOPT_TRACE               0x00000400
#define SSRVOPT_SETCONTEXT          0x00000800
#define SSRVOPT_PROXY               0x00001000
#define SSRVOPT_DOWNSTREAM_STORE    0x00002000
#define SSRVOPT_OVERWRITE           0x00004000
#define SSRVOPT_RESETTOU            0x00008000
#define SSRVOPT_CALLBACKW           0x00010000
#define SSRVOPT_FLAT_DEFAULT_STORE  0x00020000
#define SSRVOPT_PROXYW              0x00040000
#define SSRVOPT_MESSAGE             0x00080000
#define SSRVOPT_SERVICE             0x00100000   // deprecated
#define SSRVOPT_FAVOR_COMPRESSED    0x00200000
#define SSRVOPT_STRING              0x00400000
#define SSRVOPT_WINHTTP             0x00800000
#define SSRVOPT_WININET             0x01000000

#define SSRVOPT_MAX                 0x0100000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#define SSRVACTION_SIZE         5

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
#define SymInitialize                     SymInitializeW
#define SymAddSymbol                      SymAddSymbolW
#define SymDeleteSymbol                   SymDeleteSymbolW
#define SearchTreeForFile                 SearchTreeForFileW
#define UnDecorateSymbolName              UnDecorateSymbolNameW
#define SymGetLineFromName64              SymGetLineFromNameW64
#define SymGetLineFromAddr64              SymGetLineFromAddrW64
#define SymGetLineNext64                  SymGetLineNextW64
#define SymGetLinePrev64                  SymGetLinePrevW64
#define SymFromName                       SymFromNameW
#define SymFindExecutableImage            SymFindExecutableImageW
#define FindExecutableImageEx             FindExecutableImageExW
#define SymSearch                         SymSearchW
#define SymEnumLines                      SymEnumLinesW
#define SymEnumSourceLines                SymEnumSourceLinesW
#define SymGetTypeFromName                SymGetTypeFromNameW
#define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
#define SymFromAddr                       SymFromAddrW
#define SymMatchString                    SymMatchStringW
#define SymEnumSourceFiles                SymEnumSourceFilesW
#define SymEnumSymbols                    SymEnumSymbolsW
#define SymLoadModuleEx                   SymLoadModuleExW
#define SymSetSearchPath                  SymSetSearchPathW
#define SymGetSearchPath                  SymGetSearchPathW
#define EnumDirTree                       EnumDirTreeW
#define SymFromToken                      SymFromTokenW
#define SymFromIndex                      SymFromIndexW
#define SymGetScope                       SymGetScopeW
#define SymNext                           SymNextW
#define SymPrev                           SymPrevW
#define SymEnumTypes                      SymEnumTypesW
#define SymEnumTypesByName                SymEnumTypesByNameW
#define SymRegisterCallback64             SymRegisterCallbackW64
#define SymFindDebugInfoFile              SymFindDebugInfoFileW
#define FindDebugInfoFileEx               FindDebugInfoFileExW
#define SymFindFileInPath                 SymFindFileInPathW
#define SymEnumerateModules64             SymEnumerateModulesW64
#define SymSetHomeDirectory               SymSetHomeDirectoryW
#define SymGetHomeDirectory               SymGetHomeDirectoryW
#define SymGetSourceFile                  SymGetSourceFileW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
#define SymFindFileInPath                 SymFindFileInPathW
#define SymMatchFileName                  SymMatchFileNameW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetModuleInfo64                SymGetModuleInfoW64
#define SymSrvIsStore                     SymSrvIsStoreW
#define SymSrvDeltaName                   SymSrvDeltaNameW
#define SymSrvGetSupplement               SymSrvGetSupplementW
#define SymSrvStoreSupplement             SymSrvStoreSupplementW
#define SymSrvGetFileIndexes              SymSrvGetFileIndexes
#define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
#define SymSrvStoreFile                   SymSrvStoreFileW
#define SymGetSymbolFile                  SymGetSymbolFileW
#define EnumerateLoadedModules64          EnumerateLoadedModulesW64
#define EnumerateLoadedModulesEx          EnumerateLoadedModulesExW
#define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW

#define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
#define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
#define SYMBOL_INFO                       SYMBOL_INFOW
#define PSYMBOL_INFO                      PSYMBOL_INFOW
#define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
#define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
#define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
#define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
#define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
#define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
#define SRCCODEINFO                       SRCCODEINFOW
#define PSRCCODEINFO                      PSRCCODEINFOW
#define SOURCEFILE                        SOURCEFILEW
#define PSOURCEFILE                       PSOURCEFILEW
#define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
#define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
#define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
#define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
#define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
#define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
#define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
#define SYMSRV_INDEX_INFO                 SYMSRV_INDEX_INFOW
#define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

#define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
#define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
);
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000

#pragma pack(pop)


#pragma pack(push,4)

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR
{
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64
{
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR
{
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64
{
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER
{
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union
    {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY
{
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING
{
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE
{

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,
    TokenStream                 = 19,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005,
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,
    ceStreamProcessModuleMap    = 0x800B,
    ceStreamDiagnosisList       = 0x800C,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
//

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION
{

    //
    // X86 platforms use CPUID function to obtain processor information.
    //

    struct
    {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //

        ULONG32 VendorId [ 3 ];

        //
        // CPUID Subfunction 1, register EAX
        //

        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //

        ULONG32 FeatureInformation;


        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //

        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //

    struct
    {

        ULONG64 ProcessorFeatures [ 2 ];

    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;

typedef struct _MINIDUMP_SYSTEM_INFO
{

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //

    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union
    {
        USHORT Reserved0;
        struct
        {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //

    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //

    RVA CSDVersionRva;

    union
    {
        ULONG32 Reserved1;
        struct
        {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT(sizeof(((PPROCESS_INFORMATION)0)->dwThreadId) == 4);

typedef struct _MINIDUMP_THREAD
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION
{
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM
{
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST
{
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST
{
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST
{
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION
{
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64
{
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE
{
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION
{
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N* PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
{
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID            0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES         0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO  0x00000004
#define MINIDUMP_MISC3_PROCESS_INTEGRITY     0x00000010
#define MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS 0x00000020
#define MINIDUMP_MISC3_TIMEZONE              0x00000040
#define MINIDUMP_MISC3_PROTECTED_PROCESS     0x00000080

typedef struct _MINIDUMP_MISC_INFO
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

typedef struct _MINIDUMP_MISC_INFO_3
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
    ULONG32 ProcessIntegrityLevel;
    ULONG32 ProcessExecuteFlags;
    ULONG32 ProtectedProcess;
    ULONG32 TimeZoneId;
    TIME_ZONE_INFORMATION TimeZone;
} MINIDUMP_MISC_INFO_3, *PMINIDUMP_MISC_INFO_3;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_3 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO
{
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO
{
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;

//
// Support for token information.
//
typedef struct _MINIDUMP_TOKEN_INFO_HEADER
{
    ULONG   TokenSize;   // The size of the token structure.
    ULONG   TokenId;     // The PID in NtOpenProcessToken() call or TID in NtOpenThreadToken() call.
    ULONG64 TokenHandle; // The handle value returned.
} MINIDUMP_TOKEN_INFO_HEADER, *PMINIDUMP_TOKEN_INFO_HEADER;

typedef struct _MINIDUMP_TOKEN_INFO_LIST
{
    ULONG TokenListSize;
    ULONG TokenListEntries;
    ULONG ListHeaderSize;
    ULONG ElementHeaderSize;
} MINIDUMP_TOKEN_INFO_LIST, *PMINIDUMP_TOKEN_INFO_LIST;

//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD
{
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM
{
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION
{
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE
{
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK
{
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS
{
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK
{
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord;
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK
{
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS
{
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK
{
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
*PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT
{
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union
    {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT
{
    union
    {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct
        {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct
        {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct
        {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;


//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE
{
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    MiniDumpWithPrivateWriteCopyMemory     = 0x00010000,
    MiniDumpIgnoreInaccessibleMemory       = 0x00020000,
    MiniDumpWithTokenInformation           = 0x00040000,
    MiniDumpValidTypeFlags                 = 0x0007ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//

typedef enum _MINIDUMP_SECONDARY_FLAGS
{
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI* MINIDUMP_CALLBACK_ROUTINE)(
    __inout PVOID CallbackParam,
    __in    PMINIDUMP_CALLBACK_INPUT CallbackInput,
    __inout PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
);

typedef struct _MINIDUMP_CALLBACK_INFORMATION
{
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    __in HANDLE hProcess,
    __in DWORD ProcessId,
    __in HANDLE hFile,
    __in MINIDUMP_TYPE DumpType,
    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
);

BOOL
WINAPI
MiniDumpReadDumpStream(
    __in PVOID BaseOfDump,
    __in ULONG StreamNumber,
    __deref_out_opt PMINIDUMP_DIRECTORY* Dir,
    __deref_out_opt PVOID* StreamPointer,
    __out_opt ULONG* StreamSize
);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_




================================================
File: src/pluginsdk/jansson/jansson.h
================================================
/*
 * Copyright (c) 2009-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  9
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.9"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}

#if defined(__GNUC__) || defined(__clang__)
static JSON_INLINE
void json_decrefp(json_t** json)
{
    if(json)
    {
        json_decref(*json);
        *json = NULL;
    }
}

#define json_auto_t json_t __attribute__((cleanup(json_decrefp)))
#endif


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_object_foreach_safe(object, n, key, value)     \
    for(key = json_object_iter_key(json_object_iter(object)), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(n), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
__declspec(dllimport) void json_get_alloc_funcs(json_malloc_t* malloc_fn, json_free_t* free_fn);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: src/pluginsdk/jansson/jansson_config.h
================================================
/*
 * Copyright (c) 2010-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint strtoll
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1


/* Maximum recursion depth for parsing JSON input.
   This limits the depth of e.g. array-within-array constructions. */
#define JSON_PARSER_MAX_DEPTH 2048


#endif



================================================
File: src/pluginsdk/jansson/jansson_x64dbg.h
================================================
#pragma once

#include "jansson.h"

typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
    sprintf_s(hexvalue, "0x%llX", value);
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
    sscanf_s(hexvalue, "0x%llX", &ret);
    return ret;
}



================================================
File: src/pluginsdk/lz4/lz4.h
================================================
/*
   LZ4 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4_H
#define _LZ4_H

#if defined (__cplusplus)
extern "C"
{
#endif


/**************************************
   Version
**************************************/
#define LZ4_VERSION_MAJOR    1    /* for major interface/format changes  */
#define LZ4_VERSION_MINOR    1    /* for minor interface/format changes  */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */


/**************************************
   Compiler Options
**************************************/
#if (defined(__GNUC__) && defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__cplusplus))   /* Visual Studio */
#  define inline __inline           /* Visual C is not C99, but supports some kind of inline */
#endif


/**************************************
   Simple Functions
**************************************/

__declspec(dllimport) int LZ4_compress(const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_decompress_safe(const char* source, char* dest, int inputSize, int maxOutputSize);

/*
LZ4_compress() :
    Compresses 'inputSize' bytes from 'source' into 'dest'.
    Destination buffer must be already allocated,
    and must be sized to handle worst cases situations (input data not compressible)
    Worst case size evaluation is provided by function LZ4_compressBound()
    inputSize : Max supported value is LZ4_MAX_INPUT_VALUE
    return : the number of bytes written in buffer dest
             or 0 if the compression fails

LZ4_decompress_safe() :
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits (never writes outside of output buffer, and never reads outside of input buffer). Therefore, it is protected against malicious data packets
*/


/**************************************
   Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*
LZ4_compressBound() :
    Provides the maximum size that LZ4 may output in a "worst case" scenario (input data not compressible)
    primarily useful for memory allocation of output buffer.
    inline function is recommended for the general case,
    macro is also provided when result needs to be evaluated at compilation (such as stack memory allocation).

    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE
    return : maximum output size in a "worst case" scenario
             or 0, if input size is too large ( > LZ4_MAX_INPUT_SIZE)
*/
__declspec(dllimport) int LZ4_compressBound(int isize);


/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is LZ4_MAX_INPUT_VALUE
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes written in buffer 'dest'
             or 0 if the compression fails
*/
__declspec(dllimport) int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);


/*
LZ4_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is malformed, the function will stop decoding and return a negative result.
    note : This function is a bit faster than LZ4_decompress_safe()
           This function never writes outside of output buffers, but may read beyond input buffer in case of malicious data packet.
           Use this function preferably into a trusted environment (data to decode comes from a trusted source).
           Destination buffer must be already allocated. Its size must be a minimum of 'outputSize' bytes.
*/
__declspec(dllimport) int LZ4_decompress_fast(const char* source, char* dest, int originalSize);


/*
LZ4_decompress_safe_partial() :
    This function decompress a compressed block of size 'inputSize' at position 'source'
    into output buffer 'dest' of size 'maxOutputSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*/
__declspec(dllimport) int LZ4_decompress_safe_partial(const char* source, char* dest, int inputSize, int targetOutputSize, int maxOutputSize);


/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofState();

Note that tables must be aligned on 4-bytes boundaries, otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withState() and LZ4_compress_limitedOutput_withState() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/
__declspec(dllimport) int LZ4_sizeofState(void);
__declspec(dllimport) int LZ4_compress_withState(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compress_limitedOutput_withState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_create(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compress_continue(void* LZ4_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compress_limitedOutput_continue(void* LZ4_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBuffer(void* LZ4_Data);
__declspec(dllimport) int   LZ4_free(void* LZ4_Data);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4 Data Structure, thanks to the function :

void* LZ4_create (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4 Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compress_continue() or LZ4_compress_limitedOutput_continue().
Their behavior are identical to LZ4_compress() or LZ4_compress_limitedOutput(),
but require the LZ4 Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBuffer(void* LZ4_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compress_continue() or LZ4_compress_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_free() will release the memory used by the LZ4 Data Structure.
*/


__declspec(dllimport) int LZ4_sizeofStreamState(void);
__declspec(dllimport) int LZ4_resetStreamState(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_create (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamState();
Note also that space must be 4-bytes aligned.

Once space is allocated, you must initialize it using : LZ4_resetStreamState(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned on 4-bytes boundaries, and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamState() must be 0 is OK.
Any other value means there was an error (typically, pointer is not aligned on 4-bytes boundaries).
*/


__declspec(dllimport) int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int outputSize);

/*
*_withPrefix64k() :
    These decoding functions work the same as their "normal name" versions,
    but can use up to 64KB of data in front of 'char* dest'.
    These functions are necessary to decode inter-dependant blocks.
*/


/**************************************
   Obsolete Functions
**************************************/
/*
These functions are deprecated and should no longer be used.
They are provided here for compatibility with existing user programs.
*/
__declspec(dllimport) int LZ4_uncompress(const char* source, char* dest, int outputSize);
__declspec(dllimport) int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int isize, int maxOutputSize);


#if defined (__cplusplus)
}
#endif

#endif //_LZ4_H


================================================
File: src/pluginsdk/lz4/lz4file.h
================================================
#ifndef _LZ4FILE_H
#define _LZ4FILE_H

typedef enum _LZ4_STATUS
{
    LZ4_SUCCESS,
    LZ4_FAILED_OPEN_INPUT,
    LZ4_FAILED_OPEN_OUTPUT,
    LZ4_NOT_ENOUGH_MEMORY,
    LZ4_INVALID_ARCHIVE,
    LZ4_CORRUPTED_ARCHIVE
} LZ4_STATUS;

#if defined (__cplusplus)
extern "C"
{
#endif

__declspec(dllimport) LZ4_STATUS LZ4_compress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_compress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);

#if defined (__cplusplus)
}
#endif

#endif //_LZ4FILE_H


================================================
File: src/pluginsdk/lz4/lz4hc.h
================================================
/*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4HC_H
#define _LZ4HC_H

#if defined (__cplusplus)
extern "C"
{
#endif


__declspec(dllimport) int LZ4_compressHC(const char* source, char* dest, int inputSize);
/*
LZ4_compressHC :
    return : the number of bytes in compressed buffer dest
             or 0 if compression fails.
    note : destination buffer must be already allocated.
        To avoid any problem, size it to handle worst cases situations (input data not compressible)
        Worst case size evaluation is provided by function LZ4_compressBound() (see "lz4.h")
*/

__declspec(dllimport) int LZ4_compressHC_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);
/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is 1 GB
    maxOutputSize : is maximum allowed size into the destination buffer (which must be already allocated)
    return : the number of output bytes written in buffer 'dest'
             or 0 if compression fails.
*/


__declspec(dllimport) int LZ4_compressHC2(const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);
/*
    Same functions as above, but with programmable 'compressionLevel'.
    Recommended values are between 4 and 9, although any value between 0 and 16 will work.
    'compressionLevel'==0 means use default 'compressionLevel' value.
    Values above 16 behave the same as 16.
    Equivalent variants exist for all other compression functions below.
*/

/* Note :
Decompression functions are provided within LZ4 source code (see "lz4.h") (BSD license)
*/


/**************************************
   Using an external allocation
**************************************/
__declspec(dllimport) int LZ4_sizeofStateHC(void);
__declspec(dllimport) int LZ4_compressHC_withStateHC(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compressHC_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);

__declspec(dllimport) int LZ4_compressHC2_withStateHC(void* state, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofStateHC();

Note that tables must be aligned for pointer (32 or 64 bits), otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withStateHC() and LZ4_compress_limitedOutput_withStateHC() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_createHC(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compressHC_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compressHC_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
__declspec(dllimport) int   LZ4_freeHC(void* LZ4HC_Data);

__declspec(dllimport) int   LZ4_compressHC2_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int   LZ4_compressHC2_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4HC Data Structure, thanks to the function :

void* LZ4_createHC (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4HC Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue().
Their behavior are identical to LZ4_compressHC() or LZ4_compressHC_limitedOutput(),
but require the LZ4HC Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_freeHC() will release the memory used by the LZ4HC Data Structure.
*/

__declspec(dllimport) int LZ4_sizeofStreamStateHC(void);
__declspec(dllimport) int LZ4_resetStreamStateHC(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_createHC (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamStateHC();
Note also that space must be aligned for pointers (32 or 64 bits).

Once space is allocated, you must initialize it using : LZ4_resetStreamStateHC(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned for pointers (32 or 64 bits), and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamStateHC() must be 0 is OK.
Any other value means there was an error (typically, state is not aligned for pointers (32 or 64 bits)).
*/


#if defined (__cplusplus)
}
#endif

#endif //_LZ4HC_H



================================================
File: src/sigmake/Descriptor.cpp
================================================
#include "stdafx.h"

SIG_DESCRIPTOR *AllocDescriptor(ULONG Count)
{
	ULONG totalSize			= sizeof(SIG_DESCRIPTOR) + (sizeof(SIG_DESCRIPTOR_ENTRY) * Count);
	SIG_DESCRIPTOR *temp	= (SIG_DESCRIPTOR *)BridgeAlloc(totalSize);

	if (temp)
		temp->Count = Count;

	// Return value is gnored; BridgeAlloc will kill the program on failure
	return temp;
}

void TrimDescriptor(SIG_DESCRIPTOR *Descriptor)
{
	//
	// This removes any TRAILING wildcards, so
	// the loop starts from the end.
	//
	for (LONG i = Descriptor->Count - 1; i >= 0; i--)
	{
		if (Descriptor->Entries[i].Wildcard == 0)
			break;

		Descriptor->Count--;
	}
}

void ShortenDescriptor(SIG_DESCRIPTOR *Descriptor)
{
	//
	// This shortens patterns by detecting the number
	// of resulting matches. If there is more than one,
	// return. The signature is as short as possible, but
	// still accurate
	//
	std::vector<duint> results;

	for (ULONG init = Descriptor->Count; Descriptor->Count >= 1;)
	{
		// Zero previous values
		results.clear();

		// Scan
		PatternScan(Descriptor, results);

		// Was there more than 1 result?
		if (results.size() > 1)
		{
			if (init != Descriptor->Count)
				Descriptor->Count++;

			return;
		}

		// Otherwise decrease the sig and repeat
		Descriptor->Count--;
	}
}

void DescriptorToCode(SIG_DESCRIPTOR *Descriptor, char **Data, char **Mask)
{
	//
	// Allocate buffers for the resulting strings
	//
	size_t dataSize = Descriptor->Count * strlen("\\x00") + 1;
	size_t maskSize = Descriptor->Count * strlen("x") + 1;

	*Data = (char *)BridgeAlloc(dataSize);
	*Mask = (char *)BridgeAlloc(maskSize);

	for (ULONG i = 0; i < Descriptor->Count; i++)
	{
		if (Descriptor->Entries[i].Wildcard == 0)
		{
			char temp[16];
			sprintf_s(temp, "\\x%02X", (DWORD)Descriptor->Entries[i].Value);

			strcat_s(*Data, dataSize, temp);
			strcat_s(*Mask, maskSize, "x");
		}
		else
		{
			strcat_s(*Data, dataSize, "\\x00");
			strcat_s(*Mask, maskSize, "?");
		}
	}
}

void DescriptorToIDA(SIG_DESCRIPTOR *Descriptor, char **Data)
{
	//
	// Allocate buffers for the resulting strings.
	// Worst case scenario: all are 2 bytes (No wildcards)
	//
	size_t dataSize = Descriptor->Count * strlen("00 ") + 1;
	*Data			= (char *)BridgeAlloc(dataSize);

	for (ULONG i = 0; i < Descriptor->Count; i++)
	{
		if (Descriptor->Entries[i].Wildcard == 0)
		{
			char temp[16];
			sprintf_s(temp, "%02X ", (DWORD)Descriptor->Entries[i].Value);

			strcat_s(*Data, dataSize, temp);
		}
		else
		{
			strcat_s(*Data, dataSize, "? ");
		}
	}

	// Remove the final space
	if (strrchr(*Data, ' '))
		*strrchr(*Data, ' ') = '\0';
}

void DescriptorToPEiD(SIG_DESCRIPTOR *Descriptor, char **Data)
{
	// Similar to IDA, allows for one more ? -> '00 00 ?? 99 99'
	//
	// Allocate buffers for the resulting strings.
	// Worst case scenario: all are 2 bytes (No wildcards)
	//
	size_t dataSize = Descriptor->Count * strlen("00 ") + 1;
	*Data			= (char *)BridgeAlloc(dataSize);

	for (ULONG i = 0; i < Descriptor->Count; i++)
	{
		if (Descriptor->Entries[i].Wildcard == 0)
		{
			char temp[16];
			sprintf_s(temp, "%02X ", (DWORD)Descriptor->Entries[i].Value);

			strcat_s(*Data, dataSize, temp);
		}
		else
		{
			strcat_s(*Data, dataSize, "?? ");
		}
	}

	// Remove the final space
	if (strrchr(*Data, ' '))
		*strrchr(*Data, ' ') = '\0';
}

void DescriptorToCRC(SIG_DESCRIPTOR *Descriptor, char **Data, char **Mask)
{
	// TODO
	__debugbreak();
}

SIG_DESCRIPTOR *DescriptorFromCode(const char *Data, const char *Mask)
{
	ULONG count = (ULONG)strlen(Mask);
	SIG_DESCRIPTOR *desc = AllocDescriptor(count);

	//
	// \x00\x00\x00\x00
	// xx?x
	//
	Data += 2;

	for (ULONG i = 0; i < count; i++)
	{
		if (Mask[0] == 'x')
		{
			desc->Entries[i].Value		= (BYTE)strtol(Data, nullptr, 16);
			desc->Entries[i].Wildcard	= 0;
		}
		else
		{
			desc->Entries[i].Value		= 0;
			desc->Entries[i].Wildcard	= 1;
		}

		Data += 4;
		Mask += 1;
	}

	return desc;
}

SIG_DESCRIPTOR *DescriptorFromIDA(const char *Data)
{
	// Get the number of entries by counting spaces + 1
	size_t dataLen	= strlen(Data);
	ULONG count		= 1;

	for (size_t i = 0; i < dataLen; i++)
	{
		if (Data[i] == ' ')
			count++;
	}

	SIG_DESCRIPTOR *desc = AllocDescriptor(count);

	//
	// 00 44 ? ? 66 ? 88 99
	//
	const char *dataStart	= Data;
	const char *dataEnd		= Data + dataLen;

	for (ULONG i = 0; Data < dataEnd; i++)
	{
		if (Data[0] == '?')
		{
			desc->Entries[i].Value		= 0;
			desc->Entries[i].Wildcard	= 1;

			// Skip over the '?' and space
			Data += 2;
		}
		else
		{
			desc->Entries[i].Value		= (BYTE)strtol(Data, nullptr, 16);
			desc->Entries[i].Wildcard	= 0;

			// Skip over the BYTE and space
			Data += 3;
		}
	}

	return desc;
}

SIG_DESCRIPTOR *DescriptorFromPEiD(const char *Data)
{
	// This is identical to IDA, just replace '??' with '?'
	std::string newData(Data);
	StringReplace(newData, "??", "?");

	return DescriptorFromIDA(newData.c_str());
}

SIG_DESCRIPTOR *DescriptorFromCRC(const char *Data)
{
	// TODO
	__debugbreak();

	return nullptr;
}


================================================
File: src/sigmake/Descriptor.h
================================================
#pragma once

#pragma warning(push)
#pragma warning(disable: 4200)// nonstandard extension used : zero-sized array in struct/union
enum SIGNATURE_TYPE
{
	SIG_CODE,
	SIG_IDA,
	SIG_PEID,
	SIG_CRC,
};

struct SIG_DESCRIPTOR_ENTRY
{
	BYTE Value;
	BYTE Wildcard;
};

struct SIG_DESCRIPTOR
{
	ULONG Count;
	SIG_DESCRIPTOR_ENTRY Entries[0];
};
#pragma warning(pop)

SIG_DESCRIPTOR *AllocDescriptor(ULONG Count);
void TrimDescriptor(SIG_DESCRIPTOR *Descriptor);
void ShortenDescriptor(SIG_DESCRIPTOR *Descriptor);

void DescriptorToCode(SIG_DESCRIPTOR *Descriptor, char **Data, char **Mask);
void DescriptorToIDA(SIG_DESCRIPTOR *Descriptor, char **Data);
void DescriptorToPEiD(SIG_DESCRIPTOR *Descriptor, char **Data);
void DescriptorToCRC(SIG_DESCRIPTOR *Descriptor, char **Data, char **Mask);

SIG_DESCRIPTOR *DescriptorFromCode(const char *Data, const char *Mask);
SIG_DESCRIPTOR *DescriptorFromIDA(const char *Data);
SIG_DESCRIPTOR *DescriptorFromPEiD(const char *Data);
SIG_DESCRIPTOR *DescriptorFromCRC(const char *Data);


================================================
File: src/sigmake/SigMake.cpp
================================================
#include <algorithm>
#include "stdafx.h"

const static duint CodeSizeMinimum = 1;			// 01 bytes
const static duint CodeSizeMaximum = 64 * 1024;	// 64 kilobytes

SIG_DESCRIPTOR *GenerateSigFromCode(duint Start, duint End)
{
	// Avoid duplicating code everywhere
	bool returnStatus = false;

	PBYTE processMemory		= nullptr;
	SIG_DESCRIPTOR *desc	= nullptr;
	_DInst *instructions	= nullptr;

	//
	// Check if the copy size is within sane limits.
	// The last byte is inclusive.
	//
	ULONG codeSize = (ULONG)(End - Start + 1);

	if (codeSize < CodeSizeMinimum || codeSize > CodeSizeMaximum)
	{
		_plugin_logprintf("Code selection size 0x%X not within bounds (Min: 0x%X Max: 0x%X)\n", codeSize, CodeSizeMinimum, CodeSizeMaximum);
		goto __freememory;
	}

	// Allocate and read the memory buffer
	processMemory = (PBYTE)BridgeAlloc(codeSize);

	if (!DbgMemRead(Start, processMemory, codeSize))
	{
		_plugin_logprintf("Couldn't read process memory\n");
		goto __freememory;
	}

	// Allocate the descriptor buffer (Count = # of bytes)
	desc = AllocDescriptor(codeSize);

	// Allocate the disassembly buffer
	uint32_t instructionCount	= 0;
	instructions				= (_DInst *)BridgeAlloc(codeSize * sizeof(_DInst));

	_CodeInfo info;
	info.codeOffset = Start;
	info.code		= processMemory;
	info.codeLen	= codeSize;
	info.features	= DF_NONE;

#ifdef _WIN64
	info.dt = Decode64Bits;
#else
	info.dt = Decode32Bits;
#endif // _WIN64

	_DecodeResult res = distorm_decompose(&info, instructions, codeSize, &instructionCount);

	// Check if decoding failed
	if (res != DECRES_SUCCESS)
	{
		_plugin_logprintf("Instruction decoding failed\n");
		goto __freememory;
	}

	// Loop through each instruction
	uint32_t i = 0;// Instruction index counter
	uint32_t d = 0;// Data index counter

	for (; i < instructionCount; i++)
	{
		// Determine if the bytes should be used or not
		// All bytes are a wild card unless if proved otherwise
		{
			int matchSize = MatchInstruction(&instructions[i], &processMemory[d]);

			// Copy the actual instruction data into signature format
			for (int j = 0; j < instructions[i].size; j++)
			{
				// Is 'j' within the matched data block?
				if (j < matchSize)
				{
					desc->Entries[d + j].Value		= processMemory[d + j];
					desc->Entries[d + j].Wildcard	= 0;
				}
				else
				{
					desc->Entries[d + j].Value		= 0;
					desc->Entries[d + j].Wildcard	= 1;
				}
			}

			d += instructions[i].size;
		}
	}

	// Is the setting enabled to trim signatures?
	if (Settings::TrimSignatures)
		TrimDescriptor(desc);

	// Is the setting enabled to shorten signatures?
	if (Settings::ShortestSignatures)
		ShortenDescriptor(desc);

	returnStatus = true;

__freememory:
	if (processMemory)
		BridgeFree(processMemory);

	if (instructions)
		BridgeFree(instructions);

	// Was this function successful?
	if (!returnStatus)
	{
		if (desc)
			BridgeFree(desc);

		return nullptr;
	}

	return desc;
}

void PatternScan(SIG_DESCRIPTOR *Descriptor, std::vector<duint>& Results, duint BaseAddress, duint Size, PBYTE Memory)
{
	if (Descriptor->Count <= 0)
	{
		_plugin_logprintf("Trying to scan with an invalid signature\n");
		return;
	}

	std::vector<uintptr_t> results;
	std::vector<std::pair<uint8_t, bool>> pattern;

	for (size_t i = 0; i < Descriptor->Count; i++)
		pattern.emplace_back(Descriptor->Entries[i].Value, Descriptor->Entries[i].Wildcard);

	const uint8_t *dataStart = (uint8_t *)Memory;
	const uint8_t *dataEnd = (uint8_t *)Memory + Size + 1;

	for (const uint8_t *i = dataStart;;)
	{
		auto ret = std::search(i, dataEnd, pattern.begin(), pattern.end(),
			[](uint8_t CurrentByte, std::pair<uint8_t, bool>& Pattern)
		{
			return Pattern.second || (CurrentByte == Pattern.first);
		});

		// No byte pattern matched, exit loop
		if (ret == dataEnd)
			break;

		// Cap at 10K for bogus results
		if (Results.size() >= 10000)
			break;

		uintptr_t addr = std::distance(dataStart, ret) + BaseAddress;
		Results.push_back(addr);

		i = std::next(ret);
	}
}

void PatternScan(SIG_DESCRIPTOR *Descriptor, std::vector<duint>& Results)
{
	// Get a copy of the current module in disassembly
	duint moduleBase	= DbgGetCurrentModule();
	duint moduleSize	= DbgFunctions()->ModSizeFromAddr(moduleBase);
	PBYTE processMemory = (PBYTE)BridgeAlloc(moduleSize);

	if (!DbgMemRead(moduleBase, processMemory, moduleSize))
	{
		_plugin_logprintf("Couldn't read process memory for scan\n");
		return;
	}

	PatternScan(Descriptor, Results, moduleBase, moduleSize, processMemory);
	BridgeFree(processMemory);
}

bool MatchOperands(_DInst *Instruction, _Operand *Operands, int PrefixSize)
{
	//
	// This function determines if an instruction is static and will be
	// included in the signature. Each operand is checked (4) to verify this.
	// Settings are also taken into account.
	//

	// Determine if short branches are allowed
	if (META_GET_FC(Instruction->meta) == FC_UNC_BRANCH ||
		META_GET_FC(Instruction->meta) == FC_CND_BRANCH)
	{
		// Unused prefixes might cause a larger instruction size
		if (Settings::IncludeShortJumps && ((Instruction->size - PrefixSize) < 5))
			return true;
	}

	// Loop through the operands
	for (int i = 0; i < ARRAYSIZE(Instruction->ops); i++)
	{
		switch (Operands[i].type)
		{
		case O_NONE:	// Invalid operand
		case O_REG:		// Register
			continue;

		case O_IMM:		// Only accept IMM if it's less than 32 bits or not a real pointer
			if (Settings::IncludeMemRefences)
				continue;

			if (Operands[i].size < 32)
				continue;

			if (!DbgMemIsValidReadPtr(Instruction->imm.qword))
				continue;

			return false;

		case O_IMM1:	// Special operands for ENTER (These are INCLUDED)
		case O_IMM2:	// Same as above
			continue;

		case O_DISP:	// Only accept DISP if it is RIP-relative, less than 32 bits,
		case O_SMEM:	// or not a real pointer
		case O_MEM:		//
#ifdef _WIN64
			if (!Settings::IncludeRelAddresses && Operands[i].index == R_RIP)
				return false;
#endif // _WIN64

			if (Settings::IncludeMemRefences)
				continue;

			if (Instruction->dispSize < 32)
				continue;

			if (!DbgMemIsValidReadPtr(Instruction->disp))
				continue;

			return false;

		case O_PC:		// Relative branches
		case O_PTR:		// FAR branches
			return false;
		}
	}

	return true;
}

int MatchInstruction(_DInst *Instruction, PBYTE Data)
{
	// Are wild cards forced to be off?
	if (Settings::DisableWildcards)
		return Instruction->size;

	// Create a temporary struct in order to decode data
	_CodeInfo info;
	_PrefixState ps;

	memset(&info, 0, sizeof(_CodeInfo));
	memset(&ps, 0, sizeof(_PrefixState));
	memset(ps.pfxIndexer, PFXIDX_NONE, sizeof(int) * PFXIDX_MAX);

	info.codeOffset = (_OffsetType)Data;
	info.code		= Data;
	info.codeLen	= Instruction->size;
	info.features	= DF_NONE;

	ps.start		= Data;
	ps.last			= Data;

#ifdef _WIN64
	info.dt = Decode64Bits;
#else
	info.dt = Decode32Bits;
#endif // _WIN64

	//
	// Calculate the prefixes (already validated)
	// along with the sizes.
	//
	prefixes_decode(Data, info.codeLen, &ps, info.dt);

	int prefixSize = (int)(ps.last - ps.start);

	//
	// The return value is ignored here. _CodeInfo::codeLen is modified
	// and varies depending on the instruction length.
	//
	info.codeOffset = (_OffsetType)ps.last;
	info.code		= ps.last;
	info.codeLen	-= prefixSize;

	inst_lookup(&info, &ps);

	//
	// The instruction opcode itself is ALWAYS returned. The
	// operands are variable.
	// 'partialInstructionSize' holds sizeof(PREFIX) + sizeof(OPCODE).
	// 'totalInstructionSize'   holds sizeof(PREFIX) + sizeof(OPCODE) + sizeof(OPERANDS).
	//
	int partialInstructionSize	= Instruction->size - info.codeLen;
	int totalInstructionSize	= Instruction->size;

	//
	// Determine if the operands should be included - increasing
	// the total copy size.
	//
	if (MatchOperands(Instruction, Instruction->ops, prefixSize))
		return totalInstructionSize;

	return partialInstructionSize;
}


================================================
File: src/sigmake/SigMake.h
================================================
#pragma once

SIG_DESCRIPTOR *GenerateSigFromCode(duint Start, duint End);
void PatternScan(SIG_DESCRIPTOR *Descriptor, std::vector<duint>& Results, duint BaseAddress, duint Size, PBYTE Memory);
void PatternScan(SIG_DESCRIPTOR *Descriptor, std::vector<duint>& Results);

bool MatchOperands(_DInst *Instruction, _Operand *Operands, int PrefixSize);
int MatchInstruction(_DInst *Instruction, PBYTE Data);


================================================
File: src/sigmake/resource.h
================================================
[Non-text file]


================================================
File: src/sigmake/sigmake.rc
================================================
[Non-text file]


================================================
File: src/sigmake/stdafx.cpp
================================================
// stdafx.cpp : source file that includes just the standard includes
// idaldr.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file



================================================
File: src/sigmake/stdafx.h
================================================
#pragma once

#include <windows.h>
#include <stdio.h>
#include <vector>
#include <stdint.h>

//
// DISTORM
//
extern "C"
{
#include "distorm/distorm.h"
#include "distorm/mnemonics.h"
#include "distorm/instructions.h"
#include "distorm/prefix.h"
}

//
// SWISSARMYKNIFE
//
#include "../SwissArmyKnife/stdafx.h"

//
// PLUGIN
//
#define CLOSE_WINDOW(handle, global) { (global) = nullptr; DestroyWindow((handle)); }

extern HMODULE g_LocalDllHandle;

#include "resource.h"
#include "Descriptor.h"
#include "SigMake.h"
#include "Dialog/SigMakeDialog.h"
#include "Dialog/Settings.h"
#include "Dialog/SettingsDialog.h"


================================================
File: src/sigmake/Dialog/BatchSigDialog.cpp
================================================
#include <algorithm>
#include <execution>
#include <ctype.h>
#include "../stdafx.h"

HWND g_BatchSigDialog;

void BatchSigDialogInit(HWND hwndDlg)
{
	const char *message =
		"//\r\n"
		"// Enter a separate address on each line. Addresses must be within a module. Commented lines will be ignored. Example format:\r\n"
		"// 0x12345678\r\n"
		"// 0x0987654312345678\r\n"
		"//\r\n"
		"// NOTE: This threaded scan may consume a large amount of memory depending on module size.\r\n"
		"//\r\n";

	SetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1), message);
}

void BatchSigDialogExecute(HWND hwndDlg)
{
	int dataLen = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1)) + 1;
	char *data = (char *)BridgeAlloc(dataLen);
	GetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1), data, dataLen);

	// Each line will have a single hexadecimal address with a 0x prefix
	std::vector<duint> addresses;

	auto skipLine = [](const char *&Ptr)
	{
		while (Ptr[0] != '\0' && Ptr[0] != '\n')
			Ptr++;

		if (Ptr[0] == '\n')
			Ptr++;
	};

	for (const char *ptr = data; ptr[0] != '\0';)
	{
		if (ptr[0] == '/' && ptr[1] == '/')
		{
			skipLine(ptr);
			continue;
		}

		if (isspace(ptr[0]))
		{
			ptr++;
			continue;
		}

		if (ptr[0] == '0' && ptr[1] == 'x')
		{
			addresses.push_back(strtoull(&ptr[2], nullptr, 16));
			skipLine(ptr);

			continue;
		}

		_plugin_logprintf("Trying to parse malformed data in address list\n");
		break;
	}

	BridgeFree(data);

	if (addresses.empty())
	{
		_plugin_logprintf("Found no addresses to scan for\n");
		return;
	}

	_plugin_logprintf("Parsed %d addresses in list, scanning...\n", addresses.size());

	// Guess the amount of bytes needed for a unique signature starting from 10 and maxing out at ~50. This
	// doesn't take function boundaries into account.
	std::mutex descriptorLock;
	std::map<duint, SIG_DESCRIPTOR *> descriptors;

	// Avoid a lock just to assign null descriptors
	for (duint address : addresses)
		descriptors.emplace(address, nullptr);

	std::for_each(std::execution::par_unseq, addresses.begin(), addresses.end(),
	[&descriptorLock, &descriptors](duint Address)
	{
		const uint32_t minSigLength = 10;
		const uint32_t maxSigLength = 50;

		// Keep a copy of the module in memory
		duint moduleBase = DbgFunctions()->ModBaseFromAddr(Address);
		duint moduleSize = DbgFunctions()->ModSizeFromAddr(moduleBase);
		PBYTE processMemory = (PBYTE)BridgeAlloc(moduleSize);

		if (!DbgMemRead(moduleBase, processMemory, moduleSize))
		{
			_plugin_logprintf("Couldn't read process memory for address 0x%llX\n", Address);
			return;
		}

		for (uint32_t length = 0; length < maxSigLength;)
		{
			// Gather some instructions to meet the minimum length
			while (length < minSigLength)
			{
				DISASM_INSTR inst;
				DbgDisasmAt(Address + length, &inst);

				// Default to 1 byte on failure
				length += max(inst.instr_size, 1);
			}

			SIG_DESCRIPTOR *desc = GenerateSigFromCode(Address, Address + length);

			std::vector<duint> results;
			PatternScan(desc, results, moduleBase, moduleSize, processMemory);

			if (results.empty())
			{
				BridgeFree(desc);

				_plugin_logprintf("Unable to match any signatures for address 0x%llX. How did this happen?\n", Address);
				break;
			}

			if (results.size() > 1)
			{
				BridgeFree(desc);

				// Multiple results. Disassemble yet another instruction.
				DISASM_INSTR inst;
				DbgDisasmAt(Address + length, &inst);

				length += max(inst.instr_size, 1);
			}
			else
			{
				// Done.
				descriptorLock.lock();
				descriptors.insert_or_assign(Address, desc);
				descriptorLock.unlock();

				break;
			}
		}

		BridgeFree(processMemory);
	});

	// Print out all of the results
	for (auto& [address, desc] : descriptors)
	{
		char *data = nullptr;
		char *mask = nullptr;

		if (desc)
		{
			switch (Settings::LastType)
			{
			case SIG_CODE:
				DescriptorToCode(desc, &data, &mask);
				_plugin_logprintf("0x%llX: %s, %s\n", address, data, mask);
				break;

			case SIG_IDA:
				DescriptorToIDA(desc, &data);
				_plugin_logprintf("0x%llX: %s\n", address, data);
				break;

			case SIG_PEID:
				DescriptorToPEiD(desc, &data);
				_plugin_logprintf("0x%llX: %s\n", address, data);
				break;

			case SIG_CRC:
				break;
			}
		}
		else
		{
			_plugin_logprintf("0x%llX: Unable to find a valid signature for given length\n", address);
		}

		if (data)
			BridgeFree(data);

		if (mask)
			BridgeFree(mask);

		if (desc)
			BridgeFree(desc);
	}
}

INT_PTR CALLBACK BatchSigDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		// Check if the user has any code selected
		BatchSigDialogInit(hwndDlg);

		// TODO: CRC disabled until I can find a good piece of code for it
		EnableWindow(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), FALSE);

		// Update the initial signature type selection button
		switch (Settings::LastType)
		{
		case SIG_CODE:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_CHECKED, 0);
			break;

		case SIG_IDA:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_CHECKED, 0);
			break;

		case SIG_PEID:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_CHECKED, 0);
			break;

		case SIG_CRC:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_CHECKED, 0);
			break;
		}
	}
	break;

	case WM_CLOSE:
	{
		CLOSE_WINDOW(hwndDlg, g_BatchSigDialog);
		return TRUE;
	}
	break;

	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case IDC_SIGMAKE_SCAN:
			// Scan for the signatures
			BatchSigDialogExecute(hwndDlg);

			CLOSE_WINDOW(hwndDlg, g_BatchSigDialog);
			break;

		case IDC_SIGMAKE_CANCEL:
			// Cancel button; close dialog
			CLOSE_WINDOW(hwndDlg, g_BatchSigDialog);
			break;

		case IDC_SIGMAKE_CODE:
			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_CODE;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_UNCHECKED, 0);
			break;

		case IDC_SIGMAKE_IDA:
			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_IDA;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_UNCHECKED, 0);
			break;

		case IDC_SIGMAKE_PEID:
			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_PEID;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_UNCHECKED, 0);
			break;

		case IDC_SIGMAKE_CRC:
			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_CRC;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_UNCHECKED, 0);
			break;
		}
	}
	break;
	}

	return FALSE;
}

void OpenBatchSigDialog()
{
	if (!DbgIsDebugging())
	{
		_plugin_logprintf("No process is being debugged!\n");
		return;
	}

	g_BatchSigDialog = CreateDialog(g_LocalDllHandle, MAKEINTRESOURCE(IDD_BATCHSIG), GuiGetWindowHandle(), BatchSigDialogProc);

	if (!g_BatchSigDialog)
	{
		_plugin_logprintf("Failed to create signature view window\n");
		return;
	}

	ShowWindow(g_BatchSigDialog, SW_SHOW);
}

void DestroyBatchSigDialog()
{
	if (g_BatchSigDialog)
		SendMessage(g_BatchSigDialog, WM_CLOSE, 0, 0);
}


================================================
File: src/sigmake/Dialog/Settings.cpp
================================================
#include "../stdafx.h"

namespace Settings
{
	char IniPath[MAX_PATH];

	bool TrimSignatures;
	bool DisableWildcards;
	bool ShortestSignatures;
	bool IncludeShortJumps;
	bool IncludeMemRefences;
	bool IncludeRelAddresses;
	bool UseSegments;
	SIGNATURE_TYPE LastType;

	void InitIni()
	{
		// Get the current directory
		GetCurrentDirectory(ARRAYSIZE(IniPath), IniPath);

		// Append the file name
		strcat_s(IniPath, "\\swa_settings.ini");

		// Create the file if it doesn't exist
		HANDLE file = CreateFile(IniPath, GENERIC_READ | GENERIC_WRITE, 0, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);

		if (file != INVALID_HANDLE_VALUE)
		{
			// The file was created
			CloseHandle(file);

			// Set the default values
			TrimSignatures		= true;
			IncludeShortJumps	= true;
			IncludeRelAddresses = false;
			UseSegments         = false;

			Save();
		}
	}

	void Load()
	{
		auto GetProfileBool = [](const char *Setting) -> bool
		{
			return GetPrivateProfileInt("Options", Setting, 0, IniPath) > 0;
		};

		TrimSignatures		= GetProfileBool("TrimSignatures");
		DisableWildcards	= GetProfileBool("DisableWildcards");
		ShortestSignatures	= GetProfileBool("ShortestSignatures");
		IncludeShortJumps	= GetProfileBool("IncludeShortJumps");
		IncludeMemRefences	= GetProfileBool("IncludeMemRefences");
		IncludeRelAddresses	= GetProfileBool("IncludeRelAddresses");
		UseSegments         = GetProfileBool("UseSegments");
		LastType			= (SIGNATURE_TYPE)GetPrivateProfileInt("Options", "LastType", 0, IniPath);
	}

	void Save()
	{
		auto SetProfileInt = [](const char *Setting, int Value) -> void
		{
			char temp[32];
			sprintf_s(temp, "%i", Value);

			WritePrivateProfileString("Options", Setting, temp, IniPath);
		};

		SetProfileInt("TrimSignatures",			TrimSignatures);
		SetProfileInt("DisableWildcards",		DisableWildcards);
		SetProfileInt("ShortestSignatures",		ShortestSignatures);
		SetProfileInt("IncludeShortJumps",		IncludeShortJumps);
		SetProfileInt("IncludeMemRefences",		IncludeMemRefences);
		SetProfileInt("IncludeRelAddresses",	IncludeRelAddresses);
		SetProfileInt("LastType",				LastType);
		SetProfileInt("UseSegments",            UseSegments);
	}
}


================================================
File: src/sigmake/Dialog/Settings.h
================================================
#pragma once

namespace Settings
{
	extern bool TrimSignatures;
	extern bool DisableWildcards;
	extern bool ShortestSignatures;
	extern bool IncludeShortJumps;
	extern bool IncludeMemRefences;
	extern bool IncludeRelAddresses;
	extern bool UseSegments;
	extern SIGNATURE_TYPE LastType;

	void InitIni();
	void Load();
	void Save();
}



================================================
File: src/sigmake/Dialog/SettingsDialog.cpp
================================================
#include "../stdafx.h"

HWND g_SettingsDialog;

INT_PTR CALLBACK SettingsDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		// If this isn't a 64-bit build, disable the RIP-relative option
#ifndef _WIN64
		EnableWindow(GetDlgItem(hwndDlg, IDC_SETTINGS_RELADDR), FALSE);
#endif // ndef _WIN64

		// Update all check box settings
		#define CHECK(x) ((x) ? BST_CHECKED : BST_UNCHECKED)
		SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_TRIM), BM_SETCHECK, CHECK(Settings::TrimSignatures), 0);
		SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_NOWILDCARD), BM_SETCHECK, CHECK(Settings::DisableWildcards), 0);
		SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_SHORTEST), BM_SETCHECK, CHECK(Settings::ShortestSignatures), 0);
		SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_SHORTJMP), BM_SETCHECK, CHECK(Settings::IncludeShortJumps), 0);
		SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_MEMREFS), BM_SETCHECK, CHECK(Settings::IncludeMemRefences), 0);
		SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_RELADDR), BM_SETCHECK, CHECK(Settings::IncludeRelAddresses), 0);
		SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_USESEGMENTS), BM_SETCHECK, CHECK(Settings::UseSegments), 0);
	}
	break;

	case WM_CLOSE:
	{
		CLOSE_WINDOW(hwndDlg, g_SettingsDialog);
		return TRUE;
	}
	break;

	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case IDC_SETTINGS_OK:
			// Update each checkbox setting at once
			Settings::TrimSignatures		= SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_TRIM), BM_GETCHECK, 0, 0) == BST_CHECKED;
			Settings::DisableWildcards		= SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_NOWILDCARD), BM_GETCHECK, 0, 0) == BST_CHECKED;
			Settings::ShortestSignatures	= SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_SHORTEST), BM_GETCHECK, 0, 0) == BST_CHECKED;
			Settings::IncludeShortJumps		= SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_SHORTJMP), BM_GETCHECK, 0, 0) == BST_CHECKED;
			Settings::IncludeMemRefences	= SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_MEMREFS), BM_GETCHECK, 0, 0) == BST_CHECKED;
			Settings::IncludeRelAddresses	= SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_RELADDR), BM_GETCHECK, 0, 0) == BST_CHECKED;
			Settings::UseSegments           = SendMessage(GetDlgItem(hwndDlg, IDC_SETTINGS_USESEGMENTS), BM_GETCHECK, 0, 0) == BST_CHECKED;

			// Save options
			Settings::Save();

			// Close dialog
			CLOSE_WINDOW(hwndDlg, g_SettingsDialog);
			break;

		case IDC_SETTINGS_CANCEL:
			CLOSE_WINDOW(hwndDlg, g_SettingsDialog);
			break;
		}
	}
	break;
	}

	return FALSE;
}

void OpenSettingsDialog()
{
	g_SettingsDialog = CreateDialog(g_LocalDllHandle, MAKEINTRESOURCE(IDD_SETTINGS), GuiGetWindowHandle(), SettingsDialogProc);

	if (!g_SettingsDialog)
	{
		_plugin_logprintf("Failed to create settings window\n");
		return;
	}

	ShowWindow(g_SettingsDialog, SW_SHOW);
}

void DestroySettingsDialog()
{
	if (g_SettingsDialog)
		SendMessage(g_SettingsDialog, WM_CLOSE, 0, 0);
}


================================================
File: src/sigmake/Dialog/SettingsDialog.h
================================================
#pragma once

void OpenSettingsDialog();
void DestroySettingsDialog();


================================================
File: src/sigmake/Dialog/SigMakeDialog.cpp
================================================
#include "../stdafx.h"

HWND g_SigMakeDialog;

void MakeSigDialogInit(HWND hwndDlg)
{
	// Get the debugger window's selection and generate the signature
	SELECTIONDATA selection;

	if (!GuiSelectionGet(GUI_DISASSEMBLY, &selection))
		return;

	SIG_DESCRIPTOR *desc = GenerateSigFromCode(selection.start, selection.end);

	if (!desc)
		return;

	// SIG_DESCRIPTOR -> String
	char *data = nullptr;
	char *mask = nullptr;

	switch (Settings::LastType)
	{
	case SIG_CODE:	DescriptorToCode(desc, &data, &mask);	break;
	case SIG_IDA:	DescriptorToIDA(desc, &data);			break;
	case SIG_PEID:	DescriptorToPEiD(desc, &data);			break;
	case SIG_CRC:	DescriptorToCRC(desc, &data, &mask);	break;
	}

	BridgeFree(desc);

	// Set the edit box text and clean up
	if (data)
	{
		SetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1), data);
		BridgeFree(data);
	}

	if (mask)
	{
		SetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT2), mask);
		BridgeFree(mask);
	}
}

void MakeSigDialogConvert(HWND hwndDlg, SIGNATURE_TYPE To, SIGNATURE_TYPE From)
{
	// Don't convert if destination and source types are the same
	if (To == From)
		return;

	int dataLen = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1)) + 1;
	int maskLen = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT2)) + 1;

	char *data = (char *)BridgeAlloc(dataLen);
	char *mask = (char *)BridgeAlloc(maskLen);

	GetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1), data, dataLen);
	GetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT2), mask, maskLen);

	// Convert string(s) to the incoming raw code descriptor
	SIG_DESCRIPTOR *inDesc = nullptr;

	switch (From)
	{
	case SIG_CODE:	inDesc = DescriptorFromCode(data, mask);	break;
	case SIG_IDA:	inDesc = DescriptorFromIDA(data);			break;
	case SIG_PEID:	inDesc = DescriptorFromPEiD(data);			break;
	case SIG_CRC:	inDesc = DescriptorFromCRC(data);			break;
	}

	BridgeFree(data);
	BridgeFree(mask);

	data = nullptr;
	mask = nullptr;

	// Convert raw code to destination strings
	switch (To)
	{
	case SIG_CODE:	DescriptorToCode(inDesc, &data, &mask);	break;
	case SIG_IDA:	DescriptorToIDA(inDesc, &data);			break;
	case SIG_PEID:	DescriptorToPEiD(inDesc, &data);		break;
	case SIG_CRC:	DescriptorToCRC(inDesc, &data, &mask);	break;
	}

	// Update dialog
	SetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1), data ? data : "");
	SetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT2), mask ? mask : "");

	if (data)
		BridgeFree(data);

	if (mask)
		BridgeFree(mask);

	BridgeFree(inDesc);
}

void MakeSigDialogExecute(HWND hwndDlg)
{
	int dataLen = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1)) + 1;
	int maskLen = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT2)) + 1;

	char *data = (char *)BridgeAlloc(dataLen);
	char *mask = (char *)BridgeAlloc(maskLen);

	GetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT1), data, dataLen);
	GetWindowText(GetDlgItem(hwndDlg, IDC_SIGMAKE_EDIT2), mask, maskLen);

	// Convert the string to a code descriptor
	SIG_DESCRIPTOR *desc = nullptr;

	switch (Settings::LastType)
	{
	case SIG_CODE:	desc = DescriptorFromCode(data, mask);	break;
	case SIG_IDA:	desc = DescriptorFromIDA(data);			break;
	case SIG_PEID:	desc = DescriptorFromPEiD(data);		break;
	case SIG_CRC:	desc = DescriptorFromCRC(data);			break;
	}

	// Scan & log it to the GUI
	std::vector<duint> results;
	PatternScan(desc, results);

	GuiReferenceDeleteAllColumns();
	GuiReferenceAddColumn(20, "Address");
	GuiReferenceAddColumn(100, "Disassembly");
	GuiReferenceSetRowCount((int)results.size());
	GuiReferenceSetProgress(0);
	GuiShowReferences();

	int i = 0;
	for (auto& match : results)
	{
		DISASM_INSTR inst;
		DbgDisasmAt(match, &inst);

		char temp[32];
		sprintf_s(temp, "%p", (PVOID)match);

		GuiReferenceSetCellContent(i, 0, temp);
		GuiReferenceSetCellContent(i++, 1, inst.instruction);
	}

	_plugin_logprintf("Found %d references(s)\n", results.size());
	GuiReferenceSetProgress(100);
	GuiUpdateAllViews();

	BridgeFree(data);
	BridgeFree(mask);
	BridgeFree(desc);
}

INT_PTR CALLBACK MakeSigDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		// Check if the user has any code selected
		MakeSigDialogInit(hwndDlg);

		// TODO: CRC disabled until I can find a good piece of code for it
		EnableWindow(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), FALSE);

		// Update the initial signature type selection button
		switch (Settings::LastType)
		{
		case SIG_CODE:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_CHECKED, 0);
			break;

		case SIG_IDA:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_CHECKED, 0);
			break;

		case SIG_PEID:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_CHECKED, 0);
			break;

		case SIG_CRC:
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_CHECKED, 0);
			break;
		}
	}
	break;

	case WM_CLOSE:
	{
		CLOSE_WINDOW(hwndDlg, g_SigMakeDialog);
		return TRUE;
	}
	break;

	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case IDC_SIGMAKE_SCAN:
			// Scan for the signature
			MakeSigDialogExecute(hwndDlg);

			CLOSE_WINDOW(hwndDlg, g_SigMakeDialog);
			break;

		case IDC_SIGMAKE_CANCEL:
			// Cancel button; close dialog
			CLOSE_WINDOW(hwndDlg, g_SigMakeDialog);
			break;

		case IDC_SIGMAKE_CODE:
			// Convert sig
			MakeSigDialogConvert(hwndDlg, SIG_CODE, Settings::LastType);

			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_CODE;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_UNCHECKED, 0);
			break;

		case IDC_SIGMAKE_IDA:
			// Convert sig
			MakeSigDialogConvert(hwndDlg, SIG_IDA, Settings::LastType);

			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_IDA;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_UNCHECKED, 0);
			break;

		case IDC_SIGMAKE_PEID:
			// Convert sig
			MakeSigDialogConvert(hwndDlg, SIG_PEID, Settings::LastType);

			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_PEID;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CRC), BM_SETCHECK, BST_UNCHECKED, 0);
			break;

		case IDC_SIGMAKE_CRC:
			// Convert sig
			MakeSigDialogConvert(hwndDlg, SIG_CRC, Settings::LastType);

			// Uncheck the other radio button and update last set variable
			Settings::LastType = SIG_CRC;

			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_CODE), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_PEID), BM_SETCHECK, BST_UNCHECKED, 0);
			SendMessage(GetDlgItem(hwndDlg, IDC_SIGMAKE_IDA), BM_SETCHECK, BST_UNCHECKED, 0);
			break;
		}
	}
	break;
	}

	return FALSE;
}

void OpenSigMakeDialog()
{
	if (!DbgIsDebugging())
	{
		_plugin_logprintf("No process is being debugged!\n");
		return;
	}

	g_SigMakeDialog = CreateDialog(g_LocalDllHandle, MAKEINTRESOURCE(IDD_MAKESIG), GuiGetWindowHandle(), MakeSigDialogProc);

	if (!g_SigMakeDialog)
	{
		_plugin_logprintf("Failed to create signature view window\n");
		return;
	}

	ShowWindow(g_SigMakeDialog, SW_SHOW);
}

void DestroySigMakeDialog()
{
	if (g_SigMakeDialog)
		SendMessage(g_SigMakeDialog, WM_CLOSE, 0, 0);
}


================================================
File: src/sigmake/Dialog/SigMakeDialog.h
================================================
#pragma once

void OpenSigMakeDialog();
void DestroySigMakeDialog();
void OpenBatchSigDialog();
void DestroyBatchSigDialog();


================================================
File: src/sigmake/distorm/config.h
================================================
/*
config.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef CONFIG_H
#define CONFIG_H

/* diStorm version number. */
#define __DISTORMV__ 0x030300

#include <string.h> /* memset, memcpy - can be easily self implemented for libc independency. */

#include "distorm.h"


/*
 * 64 bit offsets support:
 * This macro should be defined from compiler command line flags, e.g: -DSUPPORT_64BIT_OFFSET
 * Note: make sure that the caller (library user) defines it too!
 */
/* #define SUPPORT_64BIT_OFFSET */

/*
 * If you compile diStorm as a dynamic library (.dll or .so) file, make sure you uncomment the next line.
 * So the interface functions will be exported, otherwise they are useable only for static library.
 * For example, this macro is being set for compiling diStorm as a .dll for Python with CTypes.
 */
/* #define DISTORM_DYNAMIC */

/*
 * If DISTORM_LIGHT is defined, everything involved in formatting the instructions
 * as text will be excluded from compilation.
 * distorm_decode(..) and distorm_format(..) will not be available.
 * This will decrease the size of the executable and leave you with decomposition functionality only.
 *
 * Note: it should be either set in the preprocessor definitions manually or in command line -D switch.
 * #define DISTORM_LIGHT
 */

/*
 * diStorm now supports little/big endian CPU's.
 * It should detect the endianness according to predefined macro's of the compiler.
 * If you don't use GCC/MSVC you will have to define it on your own.
 */

/* These macros are used in order to make the code portable. */
#ifdef __GNUC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ static
/* GCC ignores this directive... */
/*#define _FASTCALL_ __attribute__((__fastcall__))*/

/* Set endianity (supposed to be LE though): */
#ifdef __BIG_ENDIAN__
	#define BE_SYSTEM
#endif

/* End of __GCC__ */

#elif __WATCOMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __WATCOMC__ */

#elif __DMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __DMC__ */

#elif __TINYC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_

/* End of __TINYC__ */

#elif _MSC_VER

/* stdint alternative is defined in distorm.h */

#define _DLLEXPORT_ __declspec(dllexport)
#define _FASTCALL_ __fastcall
#define _INLINE_ __inline

/* Set endianity (supposed to be LE though): */
#if !defined(_M_IX86) && !defined(_M_X64)
	#define BE_SYSTEM
#endif

#endif /* #elif _MSC_VER */

/* If the library isn't compiled as a dynamic library don't export any functions. */
#ifndef DISTORM_DYNAMIC
#undef _DLLEXPORT_
#define _DLLEXPORT_
#endif

#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif

/* Define stream read functions for big endian systems. */
#ifdef BE_SYSTEM
/*
 * These functions can read from the stream safely!
 * Swap endianity of input to little endian.
 */
static _INLINE_ int16_t RSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
static _INLINE_ uint16_t RUSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
static _INLINE_ int32_t RLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
static _INLINE_ uint32_t RULONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
static _INLINE_ int64_t RLLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}
static _INLINE_ uint64_t RULLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}
#else
/* Little endian macro's will just make the cast. */
#define RSHORT(x) *(int16_t *)x
#define RUSHORT(x) *(uint16_t *)x
#define RLONG(x) *(int32_t *)x
#define RULONG(x) *(uint32_t *)x
#define RLLONG(x) *(int64_t *)x
#define RULLONG(x) *(uint64_t *)x
#endif

#endif /* CONFIG_H */



================================================
File: src/sigmake/distorm/decoder.c
================================================
/*
decoder.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "decoder.h"
#include "instructions.h"
#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "operands.h"
#include "insts.h"
#include "mnemonics.h"


/* Instruction Prefixes - Opcode - ModR/M - SIB - Displacement - Immediate */

static _DecodeType decode_get_effective_addr_size(_DecodeType dt, _iflags decodedPrefixes)
{
	/*
	 * This table is to map from the current decoding mode to an effective address size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode32
	 */
	static _DecodeType AddrSizeTable[] = {Decode32Bits, Decode16Bits, Decode32Bits};

	/* Switch to non default mode if prefix exists, only for ADDRESS SIZE. */
	if (decodedPrefixes & INST_PRE_ADDR_SIZE) dt = AddrSizeTable[dt];
	return dt;
}

static _DecodeType decode_get_effective_op_size(_DecodeType dt, _iflags decodedPrefixes, unsigned int rex, _iflags instFlags)
{
	/*
	 * This table is to map from the current decoding mode to an effective operand size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode16
	 * Not that in 64bits it's a bit more complicated, because of REX and promoted instructions.
	 */
	static _DecodeType OpSizeTable[] = {Decode32Bits, Decode16Bits, Decode16Bits};

	if (decodedPrefixes & INST_PRE_OP_SIZE) return OpSizeTable[dt];

	if (dt == Decode64Bits) {
		/*
		 * REX Prefix toggles data size to 64 bits.
		 * Operand size prefix toggles data size to 16.
		 * Default data size is 32 bits.
		 * Promoted instructions are 64 bits if they don't require a REX perfix.
		 * Non promoted instructions are 64 bits if the REX prefix exists.
		 */
		/* Automatically promoted instructions have only INST_64BITS SET! */
		if (((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS) ||
		/* Other instructions in 64 bits can be promoted only with a REX prefix. */
			((decodedPrefixes & INST_PRE_REX) && (rex & PREFIX_EX_W))) dt = Decode64Bits;
		else dt = Decode32Bits; /* Default. */
	}
	return dt;
}

static _DecodeResult decode_inst(_CodeInfo* ci, _PrefixState* ps, _DInst* di)
{
	/* The ModR/M byte of the current instruction. */
	unsigned int modrm = 0;

	/* The REX/VEX prefix byte value. */
	unsigned int vrex = ps->vrex;

	/*
	 * Backup original input, so we can use it later if a problem occurs
	 * (like not enough data for decoding, invalid opcode, etc).
	 */
	const uint8_t* startCode = ci->code;

	/* Holds the info about the current found instruction. */
	_InstInfo* ii = NULL;
	_InstSharedInfo* isi = NULL;

	/* Used only for special CMP instructions which have pseudo opcodes suffix. */
	unsigned char cmpType = 0;

	/*
	 * Indicates whether it is right to LOCK the instruction by decoding its first operand.
	 * Only then you know if it's ok to output the LOCK prefix's text...
	 * Used for first operand only.
	 */
	int lockable = FALSE;

	/* Calcualte (and cache) effective-operand-size and effective-address-size only once. */
	_DecodeType effOpSz, effAdrSz;
	_iflags instFlags;

	ii = inst_lookup(ci, ps);
	if (ii == NULL) goto _Undecodable;
	isi = &InstSharedInfoTable[ii->sharedIndex];
	instFlags = FlagsTable[isi->flagsIndex];

	/*
	 * If both REX and OpSize are available we will have to disable the OpSize, because REX has precedence.
	 * However, only if REX.W is set !
	 * We had to wait with this test, since the operand size may be a mandatory prefix,
	 * and we know it only after prefetching.
	 */
	if ((ps->prefixExtType == PET_REX) &&
		(ps->decodedPrefixes & INST_PRE_OP_SIZE) &&
		(!ps->isOpSizeMandatory) &&
		(vrex & PREFIX_EX_W)) {
		ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
		prefixes_ignore(ps, PFXIDX_OP_SIZE);
	}

	/*
	 * In this point we know the instruction we are about to decode and its operands (unless, it's an invalid one!),
	 * so it makes it the right time for decoding-type suitability testing.
	 * Which practically means, don't allow 32 bits instructions in 16 bits decoding mode, but do allow
	 * 16 bits instructions in 32 bits decoding mode, of course...

	 * NOTE: Make sure the instruction set for 32 bits has explicitly this specfic flag set.
	 * NOTE2: Make sure the instruction set for 64 bits has explicitly this specfic flag set.

	 * If this is the case, drop what we've got and restart all over after DB'ing that byte.

	 * Though, don't drop an instruction which is also supported in 16 and 32 bits.
	 */

	/* ! ! ! DISABLED UNTIL FURTHER NOTICE ! ! ! Decode16Bits CAN NOW DECODE 32 BITS INSTRUCTIONS ! ! !*/
	/* if (ii && (dt == Decode16Bits) && (instFlags & INST_32BITS) && (~instFlags & INST_16BITS)) ii = NULL; */

	/* Drop instructions which are invalid in 64 bits. */
	if ((ci->dt == Decode64Bits) && (instFlags & INST_INVALID_64BITS)) goto _Undecodable;

	/* If it's only a 64 bits instruction drop it in other decoding modes. */
	if ((ci->dt != Decode64Bits) && (instFlags & INST_64BITS_FETCH)) goto _Undecodable;

	if (instFlags & INST_MODRM_REQUIRED) {
		/* If the ModRM byte is not part of the opcode, skip the last byte code, so code points now to ModRM. */
		if (~instFlags & INST_MODRM_INCLUDED) {
			ci->code++;
			if (--ci->codeLen < 0) goto _Undecodable;
		}
		modrm = *ci->code;

		/* Some instructions enforce that reg=000, so validate that. (Specifically EXTRQ). */
		if ((instFlags & INST_FORCE_REG0) && (((modrm >> 3) & 7) != 0)) goto _Undecodable;
		/* Some instructions enforce that mod=11, so validate that. */
		if ((instFlags & INST_MODRR_REQUIRED) && (modrm < INST_DIVIDED_MODRM)) goto _Undecodable;
	}

	ci->code++; /* Skip the last byte we just read (either last opcode's byte code or a ModRM). */

	/* Cache the effective operand-size and address-size. */
	effOpSz = decode_get_effective_op_size(ci->dt, ps->decodedPrefixes, vrex, instFlags);
	effAdrSz = decode_get_effective_addr_size(ci->dt, ps->decodedPrefixes);

	memset(di, 0, sizeof(_DInst));
	di->base = R_NONE;

	/*
	 * Try to extract the next operand only if the latter exists.
	 * For example, if there is not first operand, no reason to try to extract second operand...
	 * I decided that a for-break is better for readability in this specific case than goto.
	 * Note: do-while with a constant 0 makes the compiler warning about it.
	 */
	for (;;) {
		if (isi->d != OT_NONE) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->d, ONT_1, modrm, ps, effOpSz, effAdrSz, &lockable)) goto _Undecodable;
		} else break;

		if (isi->s != OT_NONE) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->s, ONT_2, modrm, ps, effOpSz, effAdrSz, NULL)) goto _Undecodable;
		} else break;

		/* Use third operand, only if the flags says this InstInfo requires it. */
		if (instFlags & INST_USE_OP3) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op3, ONT_3, modrm, ps, effOpSz, effAdrSz, NULL)) goto _Undecodable;
		} else break;
		
		/* Support for a fourth operand is added for (i.e:) INSERTQ instruction. */
		if (instFlags & INST_USE_OP4) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op4, ONT_4, modrm, ps, effOpSz, effAdrSz, NULL)) goto _Undecodable;
		}
		break;
	} /* Continue here after all operands were extracted. */

	/* If it were a 3DNow! instruction, we will have to find the instruction itself now that we got its operands extracted. */
	if (instFlags & INST_3DNOW_FETCH) {
		ii = inst_lookup_3dnow(ci);
		if (ii == NULL) goto _Undecodable;
		isi = &InstSharedInfoTable[ii->sharedIndex];
		instFlags = FlagsTable[isi->flagsIndex];
	}

	/* Check whether pseudo opcode is needed, only for CMP instructions: */
	if (instFlags & INST_PSEUDO_OPCODE) {
		if (--ci->codeLen < 0) goto _Undecodable;
		cmpType = *ci->code;
		ci->code++;
		if (instFlags & INST_PRE_VEX) {
			/* AVX Comparison type must be between 0 to 32, otherwise Reserved. */
			if (cmpType >= INST_VCMP_MAX_RANGE) goto _Undecodable;
		} else {
			/* SSE Comparison type must be between 0 to 8, otherwise Reserved. */
			if (cmpType >= INST_CMP_MAX_RANGE) goto _Undecodable;
		}
	}

	/*
	 * There's a limit of 15 bytes on instruction length. The only way to violate
	 * this limit is by putting redundant prefixes before an instruction.
	 * start points to first prefix if any, otherwise it points to instruction first byte.
	 */
	if ((ci->code - ps->start) > INST_MAXIMUM_SIZE) goto _Undecodable; /* Drop instruction. */

	/*
	 * If we reached here the instruction was fully decoded, we located the instruction in the DB and extracted operands.
	 * Use the correct mnemonic according to the DT.
	 * If we are in 32 bits decoding mode it doesn't necessarily mean we will choose mnemonic2, alas,
	 * it means that if there is a mnemonic2, it will be used.
	 */

	/* Start with prefix LOCK. */
	if ((lockable == TRUE) && (instFlags & INST_PRE_LOCK)) {
		ps->usedPrefixes |= INST_PRE_LOCK;
		di->flags |= FLAG_LOCK;
	} else if ((instFlags & INST_PRE_REPNZ) && (ps->decodedPrefixes & INST_PRE_REPNZ)) {
		ps->usedPrefixes |= INST_PRE_REPNZ;
		di->flags |= FLAG_REPNZ;
	} else if ((instFlags & INST_PRE_REP) && (ps->decodedPrefixes & INST_PRE_REP)) {
		ps->usedPrefixes |= INST_PRE_REP;
		di->flags |= FLAG_REP;
	}

	/* If it's JeCXZ the ADDR_SIZE prefix affects them. */
	if ((instFlags & (INST_PRE_ADDR_SIZE | INST_USE_EXMNEMONIC)) == (INST_PRE_ADDR_SIZE | INST_USE_EXMNEMONIC)) {
		ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
		if (effAdrSz == Decode16Bits) di->opcode = ii->opcodeId;
		else if (effAdrSz == Decode32Bits) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
		/* Ignore REX.W in 64bits, JECXZ is promoted. */
		else /* Decode64Bits */ di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
	}

	/* LOOPxx instructions are also native instruction, but they are special case ones, ADDR_SIZE prefix affects them. */
	else if ((instFlags & (INST_PRE_ADDR_SIZE | INST_NATIVE)) == (INST_PRE_ADDR_SIZE | INST_NATIVE)) {
		di->opcode = ii->opcodeId;

		/* If LOOPxx gets here from 64bits, it must be Decode32Bits because Address Size perfix is set. */
		ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
	}
	/*
	 * Note:
	 * If the instruction is prefixed by operand size we will format it in the non-default decoding mode!
	 * So there might be a situation that an instruction of 32 bit gets formatted in 16 bits decoding mode.
	 * Both ways should end up with a correct and expected formatting of the text.
	*/
	else if (effOpSz == Decode16Bits) { /* Decode16Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode16Bits);

		/*
		 * If it's a special instruction which has two mnemonics, then use the 16 bits one + update usedPrefixes.
		 * Note: use 16 bits mnemonic if that instruction supports 32 bit or 64 bit explicitly.
		 */
		if ((instFlags & INST_USE_EXMNEMONIC) && ((instFlags & (INST_32BITS | INST_64BITS)) == 0)) ps->usedPrefixes |= INST_PRE_OP_SIZE;
		di->opcode = ii->opcodeId;
	} else if (effOpSz == Decode32Bits) { /* Decode32Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode32Bits);

		/* Give a chance for special mnemonic instruction in 32 bits decoding. */
		if (instFlags & INST_USE_EXMNEMONIC) {
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* Is it a special instruction which has another mnemonic for mod=11 ? */
			if (instFlags & INST_MNEMONIC_MODRM_BASED) {
				if (modrm >= INST_DIVIDED_MODRM) di->opcode = ii->opcodeId;
				else di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
			} else di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
		} else di->opcode = ii->opcodeId;
	} else { /* Decode64Bits, note that some instructions might be decoded in Decode32Bits above. */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode64Bits);

		if (instFlags & (INST_USE_EXMNEMONIC | INST_USE_EXMNEMONIC2)) {
			/*
			 * We shouldn't be here for MODRM based mnemonics with a MOD=11,
			 * because they must not use REX (otherwise it will get to the wrong instruction which share same opcode).
			 * See XRSTOR and XSAVEOPT.
			 */
			if ((instFlags & INST_MNEMONIC_MODRM_BASED) && (modrm >= INST_DIVIDED_MODRM)) goto _Undecodable;

			/* Use third mnemonic, for 64 bits. */
			if ((instFlags & INST_USE_EXMNEMONIC2) && (vrex & PREFIX_EX_W)) {
				ps->usedPrefixes |= INST_PRE_REX;
				di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
			} else di->opcode = ((_InstInfoEx*)ii)->opcodeId2; /* Use second mnemonic. */
		} else di->opcode = ii->opcodeId;
	}

	/* If it's a native instruction use OpSize Prefix. */
	if ((instFlags & INST_NATIVE) && (ps->decodedPrefixes & INST_PRE_OP_SIZE)) ps->usedPrefixes |= INST_PRE_OP_SIZE;

	/* Check VEX mnemonics: */
	if ((instFlags & INST_PRE_VEX) &&
		(((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXW_BASED) && (vrex & PREFIX_EX_W)) ||
		 ((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXL_BASED) && (vrex & PREFIX_EX_L)))) {
		di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
	}

	/* Or is it a special CMP instruction which needs a pseudo opcode suffix ? */
	if (instFlags & INST_PSEUDO_OPCODE) {
		/*
		 * The opcodeId is the offset to the FIRST pseudo compare mnemonic,
		 * we will have to fix it so it offsets into the corrected mnemonic.
		 * Therefore, we use another table to fix the offset.
		 */
		if (instFlags & INST_PRE_VEX) {
			/* Use the AVX pesudo compare mnemonics table. */
			di->opcode = ii->opcodeId + VCmpMnemonicOffsets[cmpType];
		} else {
			/* Use the SSE psuedo compare mnemonics table. */
			di->opcode = ii->opcodeId + CmpMnemonicOffsets[cmpType];
		}
	}

	/*
	 * Store the address size inside the flags.
	 * This is necessary for the caller to know the size of rSP when using PUSHA for example.
	 */
	FLAG_SET_ADDRSIZE(di, effAdrSz);

	/* Copy DST_WR flag. */
	if (instFlags & INST_DST_WR) di->flags |= FLAG_DST_WR;

	/* Set the unused prefixes mask. */
	di->unusedPrefixesMask = prefixes_set_unused_mask(ps);

	/* Copy instruction meta. */
	di->meta = isi->meta;
	if (di->segment == 0) di->segment = R_NONE;

	/* Take into account the O_MEM base register for the mask. */
	if (di->base != R_NONE) di->usedRegistersMask |= _REGISTERTORCLASS[di->base];

	/* Copy CPU affected flags. */
	di->modifiedFlagsMask = isi->modifiedFlags;
	di->testedFlagsMask = isi->testedFlags;
	di->undefinedFlagsMask = isi->undefinedFlags;

	/* Calculate the size of the instruction we've just decoded. */
	di->size = (uint8_t)((ci->code - startCode) & 0xff);
	return DECRES_SUCCESS;

_Undecodable: /* If the instruction couldn't be decoded for some reason, drop the first byte. */
	memset(di, 0, sizeof(_DInst));
	di->base = R_NONE;

	di->size = 1;
	/* Clean prefixes just in case... */
	ps->usedPrefixes = 0;

	/* Special case for WAIT instruction: If it's dropped, you have to return a valid instruction! */
	if (*startCode == INST_WAIT_INDEX) {
		di->opcode = I_WAIT;
		META_SET_ISC(di, ISC_INTEGER);
		return DECRES_SUCCESS;
	}

	/* Mark that we didn't manage to decode the instruction well, caller will drop it. */
	return DECRES_INPUTERR;
}

/*
 * decode_internal
 *
 * supportOldIntr - Since now we work with new structure instead of the old _DecodedInst, we are still interested in backward compatibility.
 *                  So although, the array is now of type _DInst, we want to read it in jumps of the old array element's size.
 *                  This is in order to save memory allocation for conversion between the new and the old structures.
 *                  It really means we can do the conversion in-place now.
 */
_DecodeResult decode_internal(_CodeInfo* _ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount)
{
	_PrefixState ps;
	unsigned int prefixSize;
	_CodeInfo ci;

	_OffsetType codeOffset = _ci->codeOffset;
	const uint8_t* code = _ci->code;
	int codeLen = _ci->codeLen;

	/*
	 * This is used for printing only, it is the real offset of where the whole instruction begins.
	 * We need this variable in addition to codeOffset, because prefixes might change the real offset an instruction begins at.
	 * So we keep track of both.
	 */
	_OffsetType startInstOffset = 0;

	const uint8_t* p;

	/* Current working decoded instruction in results. */
	unsigned int nextPos = 0;
	_DInst *pdi = NULL;

	_OffsetType addrMask = (_OffsetType)-1;

	_DecodeResult decodeResult;

#ifdef DISTORM_LIGHT
	supportOldIntr; /* Unreferenced. */
#endif

	if (_ci->features & DF_MAXIMUM_ADDR32) addrMask = 0xffffffff;
	else if (_ci->features & DF_MAXIMUM_ADDR16) addrMask = 0xffff;

	/* No entries are used yet. */
	*usedInstructionsCount = 0;
	ci.dt = _ci->dt;
	_ci->nextOffset = codeOffset;

	/* Decode instructions as long as we have what to decode/enough room in entries. */
	while (codeLen > 0) {

		/* startInstOffset holds the displayed offset of current instruction. */
		startInstOffset = codeOffset;

		memset(&ps, 0, (size_t)((char*)&ps.pfxIndexer[0] - (char*)&ps));
		memset(ps.pfxIndexer, PFXIDX_NONE, sizeof(int) * PFXIDX_MAX);
		ps.start = code;
		ps.last = code;
		prefixSize = 0;

		if (prefixes_is_valid(*code, ci.dt)) {
			prefixes_decode(code, codeLen, &ps, ci.dt);
			/* Count prefixes, start points to first prefix. */
			prefixSize = (unsigned int)(ps.last - ps.start);
			/*
			 * It might be that we will just notice that we ran out of bytes, or only prefixes
			 * so we will have to drop everything and halt.
			 * Also take into consideration of flow control instruction filter.
			 */
			codeLen -= prefixSize;
			if ((codeLen == 0) || (prefixSize == INST_MAXIMUM_SIZE)) {
				if (~_ci->features & DF_RETURN_FC_ONLY) {
					/* Make sure there is enough room. */
					if (nextPos + (ps.last - code) > maxResultCount) return DECRES_MEMORYERR;

					for (p = code; p < ps.last; p++, startInstOffset++) {
						/* Use next entry. */
#ifndef DISTORM_LIGHT
						if (supportOldIntr) {
							pdi = (_DInst*)((char*)result + nextPos * sizeof(_DecodedInst));
						}
						else
#endif /* DISTORM_LIGHT */
						{
							pdi = &result[nextPos];
						}
						nextPos++;
						memset(pdi, 0, sizeof(_DInst));

						pdi->flags = FLAG_NOT_DECODABLE;
						pdi->imm.byte = *p;
						pdi->size = 1;
						pdi->addr = startInstOffset & addrMask;
					}
					*usedInstructionsCount = nextPos; /* Include them all. */
				}
				if (codeLen == 0) break; /* Bye bye, out of bytes. */
			}
			code += prefixSize;
			codeOffset += prefixSize;

			/* If we got only prefixes continue to next instruction. */
			if (prefixSize == INST_MAXIMUM_SIZE) continue;
		}

		/*
		 * Now we decode the instruction and only then we do further prefixes handling.
		 * This is because the instruction could not be decoded at all, or an instruction requires
		 * a mandatory prefix, or some of the prefixes were useless, etc...

		 * Even if there were a mandatory prefix, we already took into account its size as a normal prefix.
		 * so prefixSize includes that, and the returned size in pdi is simply the size of the real(=without prefixes) instruction.
		 */
		if (ci.dt == Decode64Bits) {
			if (ps.decodedPrefixes & INST_PRE_REX) {
				/* REX prefix must precede first byte of instruction. */
				if (ps.rexPos != (code - 1)) {
					ps.decodedPrefixes &= ~INST_PRE_REX;
					ps.prefixExtType = PET_NONE;
					prefixes_ignore(&ps, PFXIDX_REX);
				}
				/*
				 * We will disable operand size prefix,
				 * if it exists only after decoding the instruction, since it might be a mandatory prefix.
				 * This will be done after calling inst_lookup in decode_inst.
				 */
			}
			/* In 64 bits, segment overrides of CS, DS, ES and SS are ignored. So don't take'em into account. */
			if (ps.decodedPrefixes & INST_PRE_SEGOVRD_MASK32) {
				ps.decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK32;
				prefixes_ignore(&ps, PFXIDX_SEG);
			}
		}

		/* Make sure there is at least one more entry to use, for the upcoming instruction. */
		if (nextPos + 1 > maxResultCount) return DECRES_MEMORYERR;
#ifndef DISTORM_LIGHT
		if (supportOldIntr) {
			pdi = (_DInst*)((char*)result + nextPos * sizeof(_DecodedInst));
		}
		else
#endif /* DISTORM_LIGHT */
		{
			pdi = &result[nextPos];
		}
		nextPos++;

		/*
		 * The reason we copy these two again is because we have to keep track on the input ourselves.
		 * There might be a case when an instruction is invalid, and then it will be counted as one byte only.
		 * But that instruction already read a byte or two from the stream and only then returned the error.
		 * Thus, we end up unsynchronized on the stream.
		 * This way, we are totally safe, because we keep track after the call to decode_inst, using the returned size.
		 */
		ci.code = code;
		ci.codeLen = codeLen;
		/* Nobody uses codeOffset in the decoder itself, so spare it. */

		decodeResult = decode_inst(&ci, &ps, pdi);

		/* See if we need to filter this instruction. */
		if ((_ci->features & DF_RETURN_FC_ONLY) && (META_GET_FC(pdi->meta) == FC_NONE)) decodeResult = DECRES_FILTERED;

		/* Set address to the beginning of the instruction. */
		pdi->addr = startInstOffset & addrMask;
		/* pdi->disp &= addrMask; */

		/* Advance to next instruction. */
		codeLen -= pdi->size;
		codeOffset += pdi->size;
		code += pdi->size;

		/* Instruction's size should include prefixes. */
		pdi->size += (uint8_t)prefixSize;

		/* Drop all prefixes and the instruction itself, because the instruction wasn't successfully decoded. */
		if ((decodeResult == DECRES_INPUTERR) && (~_ci->features & DF_RETURN_FC_ONLY)) {
			nextPos--; /* Undo last result. */
			if ((prefixSize + 1) > 0) { /* 1 for the first instruction's byte. */
				if ((nextPos + prefixSize + 1) > maxResultCount) return DECRES_MEMORYERR;

				for (p = ps.start; p < ps.last + 1; p++, startInstOffset++) {
					/* Use next entry. */
#ifndef DISTORM_LIGHT
					if (supportOldIntr) {
						pdi = (_DInst*)((char*)result + nextPos * sizeof(_DecodedInst));
					}
					else
#endif /* DISTORM_LIGHT */
					{
						pdi = &result[nextPos];
					}
					nextPos++;

					memset(pdi, 0, sizeof(_DInst));
					pdi->flags = FLAG_NOT_DECODABLE;
					pdi->imm.byte = *p;
					pdi->size = 1;
					pdi->addr = startInstOffset & addrMask;
				}
			}
		} else if (decodeResult == DECRES_FILTERED) nextPos--; /* Return it to pool, since it was filtered. */

		/* Alright, the caller can read, at least, up to this one. */
		*usedInstructionsCount = nextPos;
		/* Fix next offset. */
		_ci->nextOffset = codeOffset;

		/* Check whether we need to stop on any flow control instruction. */
		if ((decodeResult == DECRES_SUCCESS) && (_ci->features & DF_STOP_ON_FLOW_CONTROL)) {
			if (((_ci->features & DF_STOP_ON_CALL) && (META_GET_FC(pdi->meta) == FC_CALL)) ||
				((_ci->features & DF_STOP_ON_RET) && (META_GET_FC(pdi->meta) == FC_RET)) ||
				((_ci->features & DF_STOP_ON_SYS) && (META_GET_FC(pdi->meta) == FC_SYS)) ||
				((_ci->features & DF_STOP_ON_UNC_BRANCH) && (META_GET_FC(pdi->meta) == FC_UNC_BRANCH)) ||
				((_ci->features & DF_STOP_ON_CND_BRANCH) && (META_GET_FC(pdi->meta) == FC_CND_BRANCH)) ||
				((_ci->features & DF_STOP_ON_INT) && (META_GET_FC(pdi->meta) == FC_INT)) ||
				((_ci->features & DF_STOP_ON_CMOV) && (META_GET_FC(pdi->meta) == FC_CMOV)))
				return DECRES_SUCCESS;
		}
	}

	return DECRES_SUCCESS;
}



================================================
File: src/sigmake/distorm/decoder.h
================================================
/*
decoder.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2011  Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef DECODER_H
#define DECODER_H

#include "config.h"

typedef unsigned int _iflags;

_DecodeResult decode_internal(_CodeInfo* ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount);

#endif /* DECODER_H */



================================================
File: src/sigmake/distorm/distorm.c
================================================
/*
distorm.c

diStorm3 C Library Interface
diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "distorm.h"
#include "config.h"
#include "decoder.h"
#include "x86defs.h"
#include "textdefs.h"
#include "wstring.h"
#include "mnemonics.h"

/* C DLL EXPORTS */
#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	if (usedInstructionsCount == NULL) {
		return DECRES_SUCCESS;
	}

	/* DECRES_SUCCESS still may indicate we may have something in the result, so zero it first thing. */
	*usedInstructionsCount = 0;

	if ((ci == NULL) ||
		(ci->codeLen < 0) ||
		((ci->dt != Decode16Bits) && (ci->dt != Decode32Bits) && (ci->dt != Decode64Bits)) ||
		(ci->code == NULL) ||
		(result == NULL) ||
		((ci->features & (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)) == (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)))
	{
		return DECRES_INPUTERR;
	}

	/* Assume length=0 is success. */
	if (ci->codeLen == 0) {
		return DECRES_SUCCESS;
	}

	return decode_internal(ci, FALSE, result, maxInstructions, usedInstructionsCount);
}

#ifndef DISTORM_LIGHT

/* Helper function to concat an explicit size when it's unknown from the operands. */
static void distorm_format_size(_WString* str, const _DInst* di, int opNum)
{
	/*
	 * We only have to output the size explicitly if it's not clear from the operands.
	 * For example:
	 * mov al, [0x1234] -> The size is 8, we know it from the AL register operand.
	 * mov [0x1234], 0x11 -> Now we don't know the size. Pam pam pam
	 *
	 * If given operand number is higher than 2, then output the size anyways.
	 */
	if (((opNum >= 2) || ((di->ops[0].type != O_REG) && (di->ops[1].type != O_REG))) ||
		/*
		 * INS/OUTS are exception, because DX is a port specifier and not a real src/dst register.
		 * MOVZX is also an exception, because the source operand can be a memory indirection:
		 * MOVZX EBX, [ECX], but which size from ECX was read?
		 */
		((di->opcode == I_INS) || (di->opcode == I_OUTS) || (di->opcode == I_MOVZX))) {
		switch (di->ops[opNum].size)
		{
			case 0: break; /* OT_MEM's unknown size. */
			case 8: strcat_WSN(str, "BYTE "); break;
			case 16: strcat_WSN(str, "WORD "); break;
			case 32: strcat_WSN(str, "DWORD "); break;
			case 64: strcat_WSN(str, "QWORD "); break;
			case 80: strcat_WSN(str, "TBYTE "); break;
			case 128: strcat_WSN(str, "DQWORD "); break;
			case 256: strcat_WSN(str, "YWORD "); break;
			default: /* Big oh uh if it gets here. */ break;
		}
	}
}

static void distorm_format_signed_disp(_WString* str, const _DInst* di, uint64_t addrMask)
{
	int64_t tmpDisp64;

	if (di->dispSize) {
		chrcat_WS(str, ((int64_t)di->disp < 0) ? MINUS_DISP_CHR : PLUS_DISP_CHR);
		if ((int64_t)di->disp < 0) tmpDisp64 = -(int64_t)di->disp;
		else tmpDisp64 = di->disp;
		tmpDisp64 &= addrMask;
		str_code_hqw(str, (uint8_t*)&tmpDisp64);
	}
}

#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#else
	_DLLEXPORT_ void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#endif
{
	_WString* str;
	unsigned int i, isDefault;
	int64_t tmpDisp64;
	uint64_t addrMask = (uint64_t)-1;
	uint8_t segment;
	const _WMnemonic* mnemonic;

	/* Set address mask, when default is for 64bits addresses. */
	if (ci->features & DF_MAXIMUM_ADDR32) addrMask = 0xffffffff;
	else if (ci->features & DF_MAXIMUM_ADDR16) addrMask = 0xffff;

	/* Copy other fields. */
	result->size = di->size;
	result->offset = di->addr & addrMask;

	if (di->flags == FLAG_NOT_DECODABLE) {
		str = &result->mnemonic;
		strclear_WS(&result->operands);
		strcpy_WSN(str, "DB ");
		str_code_hb(str, di->imm.byte);
		strclear_WS(&result->instructionHex);
		str_hex_b(&result->instructionHex, di->imm.byte);
		return; /* Skip to next instruction. */
	}

	str = &result->instructionHex;
	strclear_WS(str);
	for (i = 0; i < di->size; i++)
		str_hex_b(str, ci->code[(unsigned int)(di->addr - ci->codeOffset + i)]);

	str = &result->mnemonic;
	switch (FLAG_GET_PREFIX(di->flags))
	{
		case FLAG_LOCK:
			strcpy_WSN(str, "LOCK ");
		break;
		case FLAG_REP:
			strcpy_WSN(str, "REP ");
		break;
		case FLAG_REPNZ:
			strcpy_WSN(str, "REPNZ ");
		break;
		default:
			/* Init mnemonic string, cause next touch is concatenation. */
			strclear_WS(str);
		break;
	}

	mnemonic = (const _WMnemonic*)&_MNEMONICS[di->opcode];
	memcpy((int8_t*)&str->p[str->length], mnemonic->p, mnemonic->length + 1);
	str->length += mnemonic->length;

	/* Format operands: */
	str = &result->operands;
	strclear_WS(str);

	/* Special treatment for String instructions. */
	if ((META_GET_ISC(di->meta) == ISC_INTEGER) &&
		((di->opcode == I_MOVS) ||
		 (di->opcode == I_CMPS) ||
		 (di->opcode == I_STOS) ||
		 (di->opcode == I_LODS) ||
		 (di->opcode == I_SCAS)))
	{
		/*
		 * No operands are needed if the address size is the default one,
		 * and no segment is overridden, so add the suffix letter,
		 * to indicate size of operation and continue to next instruction.
		 */
		if ((FLAG_GET_ADDRSIZE(di->flags) == ci->dt) && (SEGMENT_IS_DEFAULT(di->segment))) {
			str = &result->mnemonic;
			switch (di->ops[0].size)
			{
				case 8: chrcat_WS(str, 'B'); break;
				case 16: chrcat_WS(str, 'W'); break;
				case 32: chrcat_WS(str, 'D'); break;
				case 64: chrcat_WS(str, 'Q'); break;
			}
			return;
		}
	}

	for (i = 0; ((i < OPERANDS_NO) && (di->ops[i].type != O_NONE)); i++) {
		if (i > 0) strcat_WSN(str, ", ");
		switch (di->ops[i].type)
		{
			case O_REG:
				strcat_WS(str, (const _WString*)&_REGISTERS[di->ops[i].index]);
			break;
			case O_IMM:
				/* If the instruction is 'push', show explicit size (except byte imm). */
				if (di->opcode == I_PUSH && di->ops[i].size != 8) distorm_format_size(str, di, i);
				/* Special fix for negative sign extended immediates. */
				if ((di->flags & FLAG_IMM_SIGNED) && (di->ops[i].size == 8)) {
					if (di->imm.sbyte < 0) {
						chrcat_WS(str, MINUS_DISP_CHR);
						str_code_hb(str, -di->imm.sbyte);
						break;
					}
				}
				if (di->ops[i].size == 64) str_code_hqw(str, (uint8_t*)&di->imm.qword);
				else str_code_hdw(str, di->imm.dword);
			break;
			case O_IMM1:
				str_code_hdw(str, di->imm.ex.i1);
			break;
			case O_IMM2:
				str_code_hdw(str, di->imm.ex.i2);
			break;
			case O_DISP:
				distorm_format_size(str, di, i);
				chrcat_WS(str, OPEN_CHR);
				if ((SEGMENT_GET(di->segment) != R_NONE) && !SEGMENT_IS_DEFAULT(di->segment)) {
					strcat_WS(str, (const _WString*)&_REGISTERS[SEGMENT_GET(di->segment)]);
					chrcat_WS(str, SEG_OFF_CHR);
				}
				tmpDisp64 = di->disp & addrMask;
				str_code_hqw(str, (uint8_t*)&tmpDisp64);
				chrcat_WS(str, CLOSE_CHR);
			break;
			case O_SMEM:
				distorm_format_size(str, di, i);
				chrcat_WS(str, OPEN_CHR);

				/*
				 * This is where we need to take special care for String instructions.
				 * If we got here, it means we need to explicitly show their operands.
				 * The problem with CMPS and MOVS is that they have two(!) memory operands.
				 * So we have to complete it ourselves, since the structure supplies only the segment that can be overridden.
				 * And make the rest of the String operations explicit.
				 */
				segment = SEGMENT_GET(di->segment);
				isDefault = SEGMENT_IS_DEFAULT(di->segment);
				switch (di->opcode)
				{
					case I_MOVS:
						isDefault = FALSE;
						if (i == 0) segment = R_ES;
					break;
					case I_CMPS:
						isDefault = FALSE;
						if (i == 1) segment = R_ES;
					break;
					case I_INS:
					case I_LODS:
					case I_STOS:
					case I_SCAS: isDefault = FALSE; break;
				}
				if (!isDefault && (segment != R_NONE)) {
					strcat_WS(str, (const _WString*)&_REGISTERS[segment]);
					chrcat_WS(str, SEG_OFF_CHR);
				}

				strcat_WS(str, (const _WString*)&_REGISTERS[di->ops[i].index]);

				distorm_format_signed_disp(str, di, addrMask);
				chrcat_WS(str, CLOSE_CHR);
			break;
			case O_MEM:
				distorm_format_size(str, di, i);
				chrcat_WS(str, OPEN_CHR);
				if ((SEGMENT_GET(di->segment) != R_NONE) && !SEGMENT_IS_DEFAULT(di->segment)) {
					strcat_WS(str, (const _WString*)&_REGISTERS[SEGMENT_GET(di->segment)]);
					chrcat_WS(str, SEG_OFF_CHR);
				}
				if (di->base != R_NONE) {
					strcat_WS(str, (const _WString*)&_REGISTERS[di->base]);
					chrcat_WS(str, PLUS_DISP_CHR);
				}
				strcat_WS(str, (const _WString*)&_REGISTERS[di->ops[i].index]);
				if (di->scale != 0) {
					chrcat_WS(str, '*');
					if (di->scale == 2) chrcat_WS(str, '2');
					else if (di->scale == 4) chrcat_WS(str, '4');
					else /* if (di->scale == 8) */ chrcat_WS(str, '8');
				}

				distorm_format_signed_disp(str, di, addrMask);
				chrcat_WS(str, CLOSE_CHR);
			break;
			case O_PC:
#ifdef SUPPORT_64BIT_OFFSET
				str_off64(str, (di->imm.sqword + di->addr + di->size) & addrMask);
#else
				str_code_hdw(str, ((_OffsetType)di->imm.sdword + di->addr + di->size) & (uint32_t)addrMask);
#endif
			break;
			case O_PTR:
				str_code_hdw(str, di->imm.ptr.seg);
				chrcat_WS(str, SEG_OFF_CHR);
				str_code_hdw(str, di->imm.ptr.off);
			break;
		}
	}

	if (di->flags & FLAG_HINT_TAKEN) strcat_WSN(str, " ;TAKEN");
	else if (di->flags & FLAG_HINT_NOT_TAKEN) strcat_WSN(str, " ;NOT TAKEN");
}

#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	_DecodeResult res;
	_DInst di;
	_CodeInfo ci;
	unsigned int instsCount = 0, i;

	*usedInstructionsCount = 0;

	/* I use codeLen as a signed variable in order to ease detection of underflow... and besides - */
	if (codeLen < 0) {
		return DECRES_INPUTERR;
	}

	if ((dt != Decode16Bits) && (dt != Decode32Bits) && (dt != Decode64Bits)) {
		return DECRES_INPUTERR;
	}

	if (code == NULL || result == NULL) {
		return DECRES_INPUTERR;
	}

	/* Assume length=0 is success. */
	if (codeLen == 0) {
		return DECRES_SUCCESS;
	}

	/*
	 * We have to format the result into text. But the interal decoder works with the new structure of _DInst.
	 * Therefore, we will pass the result array(!) from the caller and the interal decoder will fill it in with _DInst's.
	 * Then we will copy each result to a temporary structure, and use it to reformat that specific result.
	 *
	 * This is all done to save memory allocation and to work on the same result array in-place!!!
	 * It's a bit ugly, I have to admit, but worth it.
	 */

	ci.codeOffset = codeOffset;
	ci.code = code;
	ci.codeLen = codeLen;
	ci.dt = dt;
	ci.features = DF_NONE;
	if (dt == Decode16Bits) ci.features = DF_MAXIMUM_ADDR16;
	else if (dt == Decode32Bits) ci.features = DF_MAXIMUM_ADDR32;

	res = decode_internal(&ci, TRUE, (_DInst*)result, maxInstructions, &instsCount);
	for (i = 0; i < instsCount; i++) {
		if ((*usedInstructionsCount + i) >= maxInstructions) return DECRES_MEMORYERR;

		/* Copy the current decomposed result to a temp structure, so we can override the result with text. */
		memcpy(&di, (char*)result + (i * sizeof(_DecodedInst)), sizeof(_DInst));
#ifdef SUPPORT_64BIT_OFFSET
		distorm_format64(&ci, &di, &result[i]);
#else
		distorm_format32(&ci, &di, &result[i]);
#endif
	}

	*usedInstructionsCount = instsCount;
	return res;
}

#endif /* DISTORM_LIGHT */

_DLLEXPORT_ unsigned int distorm_version()
{
	return __DISTORMV__;
}



================================================
File: src/sigmake/distorm/distorm.h
================================================
/* diStorm3 3.3 */

/*
distorm.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef DISTORM_H
#define DISTORM_H

/*
 * 64 bit offsets support:
 * If the diStorm library you use was compiled with 64 bits offsets,
 * make sure you compile your own code with the following macro set:
 * SUPPORT_64BIT_OFFSET
 * Otherwise comment it out, or you will get a linker error of an unresolved symbol...
 * Turned on by default!
 */

#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))
	/* Define this macro for outer projects by default. */
	#define SUPPORT_64BIT_OFFSET
#endif

/* TINYC has a problem with some 64bits library functions, so ignore 64 bit offsets. */
#ifdef __TINYC__
	#undef SUPPORT_64BIT_OFFSET
#endif

/* If your compiler doesn't support stdint.h, define your own 64 bits type. */
#ifdef SUPPORT_64BIT_OFFSET
	#ifdef _MSC_VER
		#define OFFSET_INTEGER unsigned __int64
	#else
		#include <stdint.h>
		#define OFFSET_INTEGER uint64_t
	#endif
#else
	/* 32 bit offsets are used. */
	#define OFFSET_INTEGER unsigned long
#endif

#ifdef _MSC_VER
/* Since MSVC isn't shipped with stdint.h, we will have our own: */
typedef signed __int64		int64_t;
typedef unsigned __int64	uint64_t;
typedef signed __int32		int32_t;
typedef unsigned __int32	uint32_t;
typedef signed __int16		int16_t;
typedef unsigned __int16	uint16_t;
typedef signed __int8		int8_t;
typedef unsigned __int8		uint8_t;
#endif

/* Support C++ compilers */
#ifdef __cplusplus
 extern "C" {
#endif


/* ***  Helper Macros  *** */

/* Get the ISC of the instruction, used with the definitions below. */
#define META_GET_ISC(meta) (((meta) >> 3) & 0x1f)
#define META_SET_ISC(di, isc) (((di)->meta) |= ((isc) << 3))
/* Get the flow control flags of the instruction, see 'features for decompose' below. */
#define META_GET_FC(meta) ((meta) & 0x7)

/* Get the target address of a branching instruction. O_PC operand type. */
#define INSTRUCTION_GET_TARGET(di) ((_OffsetType)(((di)->addr + (di)->imm.addr + (di)->size)))
/* Get the target address of a RIP-relative memory indirection. */
#define INSTRUCTION_GET_RIP_TARGET(di) ((_OffsetType)(((di)->addr + (di)->disp + (di)->size)))

/*
 * Operand Size or Adderss size are stored inside the flags:
 * 0 - 16 bits
 * 1 - 32 bits
 * 2 - 64 bits
 * 3 - reserved
 *
 * If you call these set-macros more than once, you will have to clean the bits before doing so.
 */
#define FLAG_SET_OPSIZE(di, size) ((di->flags) |= (((size) & 3) << 8))
#define FLAG_SET_ADDRSIZE(di, size) ((di->flags) |= (((size) & 3) << 10))
#define FLAG_GET_OPSIZE(flags) (((flags) >> 8) & 3)
#define FLAG_GET_ADDRSIZE(flags) (((flags) >> 10) & 3)
/* To get the LOCK/REPNZ/REP prefixes. */
#define FLAG_GET_PREFIX(flags) ((flags) & 7)

/*
 * Macros to extract segment registers from 'segment':
 */
#define SEGMENT_DEFAULT 0x80
#define SEGMENT_SET(di, seg) ((di->segment) |= seg)
#define SEGMENT_GET(segment) (((segment) == R_NONE) ? R_NONE : ((segment) & 0x7f))
#define SEGMENT_IS_DEFAULT(segment) (((segment) & SEGMENT_DEFAULT) == SEGMENT_DEFAULT)


/* Decodes modes of the disassembler, 16 bits or 32 bits or 64 bits for AMD64, x86-64. */
typedef enum { Decode16Bits = 0, Decode32Bits = 1, Decode64Bits = 2 } _DecodeType;

typedef OFFSET_INTEGER _OffsetType;

typedef struct {
	_OffsetType codeOffset, nextOffset; /* nextOffset is OUT only. */
	const uint8_t* code;
	int codeLen; /* Using signed integer makes it easier to detect an underflow. */
	_DecodeType dt;
	unsigned int features;
} _CodeInfo;

typedef enum { O_NONE, O_REG, O_IMM, O_IMM1, O_IMM2, O_DISP, O_SMEM, O_MEM, O_PC, O_PTR } _OperandType;

typedef union {
	/* Used by O_IMM: */
	int8_t sbyte;
	uint8_t byte;
	int16_t sword;
	uint16_t word;
	int32_t sdword;
	uint32_t dword;
	int64_t sqword; /* All immediates are SIGN-EXTENDED to 64 bits! */
	uint64_t qword;

	/* Used by O_PC: (Use GET_TARGET_ADDR).*/
	_OffsetType addr; /* It's a relative offset as for now. */

	/* Used by O_PTR: */
	struct {
		uint16_t seg;
		/* Can be 16 or 32 bits, size is in ops[n].size. */
		uint32_t off;
	} ptr;

	/* Used by O_IMM1 (i1) and O_IMM2 (i2). ENTER instruction only. */
	struct {
		uint32_t i1;
		uint32_t i2;
	} ex;
} _Value;

typedef struct {
	/* Type of operand:
		O_NONE: operand is to be ignored.
		O_REG: index holds global register index.
		O_IMM: instruction.imm.
		O_IMM1: instruction.imm.ex.i1.
		O_IMM2: instruction.imm.ex.i2.
		O_DISP: memory dereference with displacement only, instruction.disp.
		O_SMEM: simple memory dereference with optional displacement (a single register memory dereference).
		O_MEM: complex memory dereference (optional fields: s/i/b/disp).
		O_PC: the relative address of a branch instruction (instruction.imm.addr).
		O_PTR: the absolute target address of a far branch instruction (instruction.imm.ptr.seg/off).
	*/
	uint8_t type; /* _OperandType */

	/* Index of:
		O_REG: holds global register index
		O_SMEM: holds the 'base' register. E.G: [ECX], [EBX+0x1234] are both in operand.index.
		O_MEM: holds the 'index' register. E.G: [EAX*4] is in operand.index.
	*/
	uint8_t index;

	/* Size of:
		O_REG: register
		O_IMM: instruction.imm
		O_IMM1: instruction.imm.ex.i1
		O_IMM2: instruction.imm.ex.i2
		O_DISP: instruction.disp
		O_SMEM: size of indirection.
		O_MEM: size of indirection.
		O_PC: size of the relative offset
		O_PTR: size of instruction.imm.ptr.off (16 or 32)
	*/
	uint16_t size;
} _Operand;

#define OPCODE_ID_NONE 0
/* Instruction could not be disassembled. */
#define FLAG_NOT_DECODABLE ((uint16_t)-1)
/* The instruction locks memory access. */
#define FLAG_LOCK (1 << 0)
/* The instruction is prefixed with a REPNZ. */
#define FLAG_REPNZ (1 << 1)
/* The instruction is prefixed with a REP, this can be a REPZ, it depends on the specific instruction. */
#define FLAG_REP (1 << 2)
/* Indicates there is a hint taken for Jcc instructions only. */
#define FLAG_HINT_TAKEN (1 << 3)
/* Indicates there is a hint non-taken for Jcc instructions only. */
#define FLAG_HINT_NOT_TAKEN (1 << 4)
/* The Imm value is signed extended. */
#define FLAG_IMM_SIGNED (1 << 5)
/* The destination operand is writable. */
#define FLAG_DST_WR (1 << 6)
/* The instruction uses RIP-relative indirection. */
#define FLAG_RIP_RELATIVE (1 << 7)

/* No register was defined. */
#define R_NONE ((uint8_t)-1)

#define REGS64_BASE 0
#define REGS32_BASE 16
#define REGS16_BASE 32
#define REGS8_BASE 48
#define REGS8_REX_BASE 64
#define SREGS_BASE 68
#define FPUREGS_BASE 75
#define MMXREGS_BASE 83
#define SSEREGS_BASE 91
#define AVXREGS_BASE 107
#define CREGS_BASE 123
#define DREGS_BASE 132

#define OPERANDS_NO (4)

typedef struct {
	/* Used by ops[n].type == O_IMM/O_IMM1&O_IMM2/O_PTR/O_PC. Its size is ops[n].size. */
	_Value imm;
	/* Used by ops[n].type == O_SMEM/O_MEM/O_DISP. Its size is dispSize. */
	uint64_t disp;
	/* Virtual address of first byte of instruction. */
	_OffsetType addr;
	/* General flags of instruction, holds prefixes and more, if FLAG_NOT_DECODABLE, instruction is invalid. */
	uint16_t flags;
	/* Unused prefixes mask, for each bit that is set that prefix is not used (LSB is byte [addr + 0]). */
	uint16_t unusedPrefixesMask;
	/* Mask of registers that were used in the operands, only used for quick look up, in order to know *some* operand uses that register class. */
	uint16_t usedRegistersMask;
	/* ID of opcode in the global opcode table. Use for mnemonic look up. */
	uint16_t opcode;
	/* Up to four operands per instruction, ignored if ops[n].type == O_NONE. */
	_Operand ops[OPERANDS_NO];
	/* Size of the whole instruction. */
	uint8_t size;
	/* Segment information of memory indirection, default segment, or overriden one, can be -1. Use SEGMENT macros. */
	uint8_t segment;
	/* Used by ops[n].type == O_MEM. Base global register index (might be R_NONE), scale size (2/4/8), ignored for 0 or 1. */
	uint8_t base, scale;
	uint8_t dispSize;
	/* Meta defines the instruction set class, and the flow control flags. Use META macros. */
	uint8_t meta;
	/* The CPU flags that the instruction operates upon. */
	uint8_t modifiedFlagsMask, testedFlagsMask, undefinedFlagsMask;
} _DInst;

#ifndef DISTORM_LIGHT

/* Static size of strings. Do not change this value. Keep Python wrapper in sync. */
#define MAX_TEXT_SIZE (48)
typedef struct {
	unsigned int length;
	unsigned char p[MAX_TEXT_SIZE]; /* p is a null terminated string. */
} _WString;

/*
 * Old decoded instruction structure in text format.
 * Used only for backward compatibility with diStorm64.
 * This structure holds all information the disassembler generates per instruction.
 */
typedef struct {
	_WString mnemonic; /* Mnemonic of decoded instruction, prefixed if required by REP, LOCK etc. */
	_WString operands; /* Operands of the decoded instruction, up to 3 operands, comma-seperated. */
	_WString instructionHex; /* Hex dump - little endian, including prefixes. */
	unsigned int size; /* Size of decoded instruction. */
	_OffsetType offset; /* Start offset of the decoded instruction. */
} _DecodedInst;

#endif /* DISTORM_LIGHT */

/* Register masks for quick look up, each mask indicates one of a register-class that is being used in some operand. */
#define RM_AX 1     /* AL, AH, AX, EAX, RAX */
#define RM_CX 2     /* CL, CH, CX, ECX, RCX */
#define RM_DX 4     /* DL, DH, DX, EDX, RDX */
#define RM_BX 8     /* BL, BH, BX, EBX, RBX */
#define RM_SP 0x10  /* SPL, SP, ESP, RSP */ 
#define RM_BP 0x20  /* BPL, BP, EBP, RBP */
#define RM_SI 0x40  /* SIL, SI, ESI, RSI */
#define RM_DI 0x80  /* DIL, DI, EDI, RDI */
#define RM_FPU 0x100 /* ST(0) - ST(7) */
#define RM_MMX 0x200 /* MM0 - MM7 */
#define RM_SSE 0x400 /* XMM0 - XMM15 */
#define RM_AVX 0x800 /* YMM0 - YMM15 */
#define RM_CR 0x1000 /* CR0, CR2, CR3, CR4, CR8 */
#define RM_DR 0x2000 /* DR0, DR1, DR2, DR3, DR6, DR7 */
/* RIP should be checked using the 'flags' field and FLAG_RIP_RELATIVE.
 * Segments should be checked using the segment macros.
 * For now R8 - R15 are not supported and non general purpose registers map into same RM.
 */

/* CPU Flags that instructions modify, test or undefine. */
#define D_ZF 1 /* Zero */
#define D_SF 2 /* Sign */
#define D_CF 4 /* Carry */
#define D_OF 8 /* Overflow */
#define D_PF 0x10 /* Parity */
#define D_AF 0x20 /* Auxilary */
#define D_DF 0x40 /* Direction */
#define D_IF 0x80 /* Interrupt */

/*
 * Instructions Set classes:
 * if you want a better understanding of the available classes, look at disOps project, file: x86sets.py.
 */
/* Indicates the instruction belongs to the General Integer set. */
#define ISC_INTEGER 1
/* Indicates the instruction belongs to the 387 FPU set. */
#define ISC_FPU 2
/* Indicates the instruction belongs to the P6 set. */
#define ISC_P6 3
/* Indicates the instruction belongs to the MMX set. */
#define ISC_MMX 4
/* Indicates the instruction belongs to the SSE set. */
#define ISC_SSE 5
/* Indicates the instruction belongs to the SSE2 set. */
#define ISC_SSE2 6
/* Indicates the instruction belongs to the SSE3 set. */
#define ISC_SSE3 7
/* Indicates the instruction belongs to the SSSE3 set. */
#define ISC_SSSE3 8
/* Indicates the instruction belongs to the SSE4.1 set. */
#define ISC_SSE4_1 9
/* Indicates the instruction belongs to the SSE4.2 set. */
#define ISC_SSE4_2 10
/* Indicates the instruction belongs to the AMD's SSE4.A set. */
#define ISC_SSE4_A 11
/* Indicates the instruction belongs to the 3DNow! set. */
#define ISC_3DNOW 12
/* Indicates the instruction belongs to the 3DNow! Extensions set. */
#define ISC_3DNOWEXT 13
/* Indicates the instruction belongs to the VMX (Intel) set. */
#define ISC_VMX 14
/* Indicates the instruction belongs to the SVM (AMD) set. */
#define ISC_SVM 15
/* Indicates the instruction belongs to the AVX (Intel) set. */
#define ISC_AVX 16
/* Indicates the instruction belongs to the FMA (Intel) set. */
#define ISC_FMA 17
/* Indicates the instruction belongs to the AES/AVX (Intel) set. */
#define ISC_AES 18
/* Indicates the instruction belongs to the CLMUL (Intel) set. */
#define ISC_CLMUL 19

/* Features for decompose: */
#define DF_NONE 0
/* The decoder will limit addresses to a maximum of 16 bits. */
#define DF_MAXIMUM_ADDR16 1
/* The decoder will limit addresses to a maximum of 32 bits. */
#define DF_MAXIMUM_ADDR32 2
/* The decoder will return only flow control instructions (and filter the others internally). */
#define DF_RETURN_FC_ONLY 4
/* The decoder will stop and return to the caller when the instruction 'CALL' (near and far) was decoded. */
#define DF_STOP_ON_CALL 8
/* The decoder will stop and return to the caller when the instruction 'RET' (near and far) was decoded. */
#define DF_STOP_ON_RET 0x10
/* The decoder will stop and return to the caller when the instruction system-call/ret was decoded. */
#define DF_STOP_ON_SYS 0x20
/* The decoder will stop and return to the caller when any of the branch 'JMP', (near and far) instructions were decoded. */
#define DF_STOP_ON_UNC_BRANCH 0x40
/* The decoder will stop and return to the caller when any of the conditional branch instruction were decoded. */
#define DF_STOP_ON_CND_BRANCH 0x80
/* The decoder will stop and return to the caller when the instruction 'INT' (INT, INT1, INTO, INT 3) was decoded. */
#define DF_STOP_ON_INT 0x100
/* The decoder will stop and return to the caller when any of the 'CMOVxx' instruction was decoded. */
#define DF_STOP_ON_CMOV 0x200
/* The decoder will stop and return to the caller when any flow control instruction was decoded. */
#define DF_STOP_ON_FLOW_CONTROL (DF_STOP_ON_CALL | DF_STOP_ON_RET | DF_STOP_ON_SYS | DF_STOP_ON_UNC_BRANCH | DF_STOP_ON_CND_BRANCH | DF_STOP_ON_INT | DF_STOP_ON_CMOV)

/* Indicates the instruction is not a flow-control instruction. */
#define FC_NONE 0
/* Indicates the instruction is one of: CALL, CALL FAR. */
#define FC_CALL 1
/* Indicates the instruction is one of: RET, IRET, RETF. */
#define FC_RET 2
/* Indicates the instruction is one of: SYSCALL, SYSRET, SYSENTER, SYSEXIT. */
#define FC_SYS 3
/* Indicates the instruction is one of: JMP, JMP FAR. */
#define FC_UNC_BRANCH 4
/*
 * Indicates the instruction is one of:
 * JCXZ, JO, JNO, JB, JAE, JZ, JNZ, JBE, JA, JS, JNS, JP, JNP, JL, JGE, JLE, JG, LOOP, LOOPZ, LOOPNZ.
 */
#define FC_CND_BRANCH 5
/* Indiciates the instruction is one of: INT, INT1, INT 3, INTO, UD2. */
#define FC_INT 6
/* Indicates the instruction is one of: CMOVxx. */
#define FC_CMOV 7

/* Return code of the decoding function. */
typedef enum { DECRES_NONE, DECRES_SUCCESS, DECRES_MEMORYERR, DECRES_INPUTERR, DECRES_FILTERED } _DecodeResult;

/* Define the following interface functions only for outer projects. */
#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))

/* distorm_decode
 * Input:
 *         offset - Origin of the given code (virtual address that is), NOT an offset in code.
 *         code - Pointer to the code buffer to be disassembled.
 *         length - Amount of bytes that should be decoded from the code buffer.
 *         dt - Decoding mode, 16 bits (Decode16Bits), 32 bits (Decode32Bits) or AMD64 (Decode64Bits).
 *         result - Array of type _DecodeInst which will be used by this function in order to return the disassembled instructions.
 *         maxInstructions - The maximum number of entries in the result array that you pass to this function, so it won't exceed its bound.
 *         usedInstructionsCount - Number of the instruction that successfully were disassembled and written to the result array.
 * Output: usedInstructionsCount will hold the number of entries used in the result array
 *         and the result array itself will be filled with the disassembled instructions.
 * Return: DECRES_SUCCESS on success (no more to disassemble), DECRES_INPUTERR on input error (null code buffer, invalid decoding mode, etc...),
 *         DECRES_MEMORYERR when there are not enough entries to use in the result array, BUT YOU STILL have to check for usedInstructionsCount!
 * Side-Effects: Even if the return code is DECRES_MEMORYERR, there might STILL be data in the
 *               array you passed, this function will try to use as much entries as possible!
 * Notes:  1)The minimal size of maxInstructions is 15.
 *         2)You will have to synchronize the offset,code and length by yourself if you pass code fragments and not a complete code block!
 */
#ifdef SUPPORT_64BIT_OFFSET

	_DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose64

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode64
	#define distorm_format distorm_format64
#endif /*DISTORM_LIGHT*/

#else /*SUPPORT_64BIT_OFFSET*/

	_DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose32

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode32
	#define distorm_format distorm_format32
#endif /*DISTORM_LIGHT*/

#endif

/*
 * distorm_version
 * Input:
 *        none
 *
 * Output: unsigned int - version of compiled library.
 */
unsigned int distorm_version();

#endif /* DISTORM_STATIC */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#endif /* DISTORM_H */



================================================
File: src/sigmake/distorm/instructions.c
================================================
/*
instructions.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "instructions.h"

#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "mnemonics.h"


/* Helper macros to extract the type or index from an inst-node value. */
#define INST_NODE_INDEX(n) ((n) & 0x1fff)
#define INST_NODE_TYPE(n) ((n) >> 13)

/* Helper macro to read the actual flags that are associated with an inst-info. */
#define INST_INFO_FLAGS(ii) (FlagsTable[InstSharedInfoTable[(ii)->sharedIndex].flagsIndex])

/*
I use the trie data structure as I found it most fitting to a disassembler mechanism.
When you read a byte and have to decide if it's enough or you should read more bytes, 'till you get to the instruction information.
It's really fast because you POP the instruction info in top 3 iterates on the DB, because an instruction can be formed from two bytes + 3 bits reg from the ModR/M byte.
For a simple explanation, check this out:
http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Trie/
Futher reading: http://en.wikipedia.org/wiki/Trie

The first GATE (array you read off a trie data structure), as I call them, is statically allocated by the compiler.
The second and third gates if used are being allocated dynamically by the instructions-insertion functionality.

How would such a thing look in memory, say we support 4 instructions with 3 bytes top (means 2 dynamically allocated gates).

->
|-------|                                0,
|0|     -------------------------------> |-------|
|1|RET  |      1,                        |0|AND  |
|2|     -----> |-------|                 |1|XOR  |
|3|INT3 |      |0|PUSH |                 |2|OR   |         0,3,
|-------|      |1|POP  |                 |3|     --------->|-------|
               |2|PUSHF|                 |-------|         |0|ROR  |
               |3|POPF |                                   |1|ROL  |
               |-------|                                   |2|SHR  |
                                                           |3|SHL  |
                                                           |-------|

Of course, this is NOT how Intel instructions set looks!!!
but I just wanted to give a small demonstration.
Now the instructions you get from such a trie DB goes like this:

0, 0 - AND
0, 1 - XOR
0, 2 - OR
0, 3, 0, ROR
0, 3, 1, ROL
0, 3, 2, SHR
0, 3, 3, SHL
1 - RET
2, 0 - PUSH
2, 1 - POP
2, 2 - PUSHF
2, 3 - POPF
3 - INT3

I guess it's clear by now.
So now, if you read 0, you know that you have to enter the second gate(list) with the second byte specifying the index.
But if you read 1, you know that you go to an instruction (in this case, a RET).
That's why there's an Instruction-Node structure, it tells you whether you got to an instruction or another list
so you should keep on reading byte).

In Intel, you could go through 4 gates at top, because there're instructions which are built from 2 bytes and another smaller list
for the REG part, or newest SSE4 instructions which use 4 bytes for opcode.
Therefore, Intel's first gate is 256 long, and other gates are 256 (/72) or 8 long, yes, it costs pretty much alot of memory
for non-used defined instructions, but I think that it still rocks.
*/

/*
 * A helper function to look up the correct inst-info structure.
 * It does one fetch from the index-table, and then another to get the inst-info.
 * Note that it takes care about basic inst-info or inst-info-ex.
 * The caller should worry about boundary checks and whether it accesses a last-level table.
 */
static _InstInfo* inst_get_info(_InstNode in, int index)
{
	int instIndex = 0;

	in = InstructionsTree[INST_NODE_INDEX(in) + index];
	if (in == INT_NOTEXISTS) return NULL;

	instIndex = INST_NODE_INDEX(in);
	return INST_NODE_TYPE(in) == INT_INFO ? &InstInfos[instIndex] : (_InstInfo*)&InstInfosEx[instIndex];
}

/*
 * This function is responsible to return the instruction information of the first found in code.
 * It returns the _InstInfo of the found instruction, otherwise NULL.
 * code should point to the ModR/M byte upon exit (if used), or after the instruction binary code itself.
 * This function is NOT decoding-type dependant, it is up to the caller to see whether the instruction is valid.
 * Get the instruction info, using a Trie data structure.
 *
 * Sometimes normal prefixes become mandatory prefixes, which means they are now part of the instruction opcode bytes.

 * This is a bit tricky now,
 * if the first byte is a REP (F3) prefix, we will have to give a chance to an SSE instruction.
 * If an instruction doesn't exist, we will make it as a prefix and re-locateinst.
 * A case such that a REP prefix is being changed into an instruction byte and also an SSE instruction will not be found can't happen,
 * simply because there are no collisions between string instruction and SSE instructions (they are escaped).

 * As for S/SSE2/3, check for F2 and 66 as well.

 * In 64 bits, we have to make sure that we will skip the REX prefix, if it exists.
 * There's a specific case, where a 66 is mandatory but it was dropped because REG.W was used,
 * but it doesn't behave as an operand size prefix but as a mandatory, so we will have to take it into account.

 * For example (64 bits decoding mode):
 * 66 98 CBW
 * 48 98 CDQE
 * 66 48 98: db 0x66; CDQE
 * Shows that operand size is dropped.

 * Now, it's a mandatory prefix and NOT an operand size one.
 * 66480f2dc0 db 0x48; CVTPD2PI XMM0, XMM0
 * Although this instruction doesn't require a REX.W, it just shows, that even if it did - it doesn't matter.
 * REX.W is dropped because it's not requried, but the decode function disabled the operand size even so.
 */
static _InstInfo* inst_lookup_prefixed(_InstNode in, _PrefixState* ps)
{
	int checkOpSize = FALSE;
	int index = 0;
	_InstInfo* ii = NULL;

	/* Check prefixes of current decoded instruction (None, 0x66, 0xf3, 0xf2). */
	switch (ps->decodedPrefixes & (INST_PRE_OP_SIZE | INST_PRE_REPS))
	{
		case 0:
			/* Non-prefixed, index = 0. */
			index = 0;
		break;
		case INST_PRE_OP_SIZE:
			/* 0x66, index = 1. */
			index = 1;
			/* Mark that we used it as a mandatory prefix. */
			ps->isOpSizeMandatory = TRUE;
			ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
		break;
		case INST_PRE_REP:
			/* 0xf3, index = 2. */
			index = 2;
			ps->decodedPrefixes &= ~INST_PRE_REP;
		break;
		case INST_PRE_REPNZ:
			/* 0xf2, index = 3. */
			index = 3;
			ps->decodedPrefixes &= ~INST_PRE_REPNZ;
		break;
		default:
			/*
			 * Now we got a problem, since there are a few mandatory prefixes at once.
			 * There is only one case when it's ok, when the operand size prefix is for real (not mandatory).
			 * Otherwise we will have to return NULL, since the instruction is illegal.
			 * Therefore we will start with REPNZ and REP prefixes,
			 * try to get the instruction and only then check for the operand size prefix.
			 */

			/* If both REPNZ and REP are together, it's illegal for sure. */
			if ((ps->decodedPrefixes & INST_PRE_REPS) == INST_PRE_REPS) return NULL;

			/* Now we know it's either REPNZ+OPSIZE or REP+OPSIZE, so examine the instruction. */
			if (ps->decodedPrefixes & INST_PRE_REPNZ) {
				index = 3;
				ps->decodedPrefixes &= ~INST_PRE_REPNZ;
			} else if (ps->decodedPrefixes & INST_PRE_REP) {
				index = 2;
				ps->decodedPrefixes &= ~INST_PRE_REP;
			}
			/* Mark to verify the operand-size prefix of the fetched instruction below. */
			checkOpSize = TRUE;
		break;
	}

	/* Fetch the inst-info from the index. */
	ii = inst_get_info(in, index);

	if (checkOpSize) {
		/* If the instruction doesn't support operand size prefix, then it's illegal. */
		if ((ii == NULL) || (~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE)) return NULL;
	}

	/* If there was a prefix, but the instruction wasn't found. Try to fall back to use the normal instruction. */
	if (ii == NULL) ii = inst_get_info(in, 0);
	return ii;
}

/* A helper function to look up special VEX instructions.
 * See if it's a MOD based instruction and fix index if required.
 * Only after a first lookup (that was done by caller), we can tell if we need to fix the index.
 * Because these are coupled instructions
 * (which means that the base instruction hints about the other instruction).
 * Note that caller should check if it's a MOD dependent instruction before getting in here.
 */
static _InstInfo* inst_vex_mod_lookup(_CodeInfo* ci, _InstNode in, _InstInfo* ii, unsigned int index)
{
	/* Advance to read the MOD from ModRM byte. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	if (*ci->code < INST_DIVIDED_MODRM) {
		/* MOD is not 11, therefore change the index to 8 - 12 range in the prefixed table. */
		index += 4;
		/* Make a second lookup for this special instruction. */
		return inst_get_info(in, index);
	}
	/* Return the original one, in case we didn't find a stuited instruction. */
	return ii;
}

static _InstInfo* inst_vex_lookup(_CodeInfo* ci, _PrefixState* ps)
{
	_InstNode in = 0;
	unsigned int pp = 0, start = 0;
	unsigned int index = 4; /* VEX instructions start at index 4 in the Prefixed table. */
	uint8_t vex = *ps->vexPos, vex2 = 0, v = 0;
	int instType = 0, instIndex = 0;

	/* The VEX instruction will #ud if any of 66, f0, f2, f3, REX prefixes precede. */
	_iflags illegal = (INST_PRE_OP_SIZE | INST_PRE_LOCK | INST_PRE_REP | INST_PRE_REPNZ | INST_PRE_REX);
	if ((ps->decodedPrefixes & illegal) != 0) return NULL;

	/* Read the some fields from the VEX prefix we need to extract the instruction. */
	if (ps->prefixExtType == PET_VEX2BYTES) {
		ps->vexV = v = (~vex >> 3) & 0xf;
		pp = vex & 3;
		/* Implied leading 0x0f byte by default for 2 bytes VEX prefix. */
		start = 1;
	} else { /* PET_VEX3BYTES */
		start = vex & 0x1f;
		vex2 = *(ps->vexPos + 1);
		ps->vexV = v = (~vex2 >> 3) & 0xf;
		pp = vex2 & 3;
	}

	/* start can be either 1 (0x0f), 2 (0x0f, 0x038) or 3 (0x0f, 0x3a), otherwise it's illegal. */
	switch (start)
	{
		case 1: in = Table_0F; break;
		case 2: in = Table_0F_38; break;
		case 3: in = Table_0F_3A; break;
		default: return NULL;
	}

	/* pp is actually the implied mandatory prefix, apply it to the index. */
	index += pp; /* (None, 0x66, 0xf3, 0xf2) */

	/* Read a byte from the stream. */
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	in = InstructionsTree[INST_NODE_INDEX(in) + *ci->code];
	if (in == INT_NOTEXISTS) return NULL;

	instType = INST_NODE_TYPE(in);
	instIndex = INST_NODE_INDEX(in);

	/*
	 * If we started with 0f38 or 0f3a so it's a prefixed table,
	 * therefore it's surely a VEXed instruction (because of a high index).
	 * However, starting with 0f, could also lead immediately to a prefixed table for some bytes.
	 * it might return NULL, if the index is invalid.
	 */
	if (instType == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/*
	 * If we reached here, obviously we started with 0f. VEXed instructions must be nodes of a prefixed table.
	 * But since we found an instruction (or divided one), just return NULL.
	 * They cannot lead to a VEXed instruction.
	 */
	if ((instType == INT_INFO) || (instType == INT_INFOEX) || (instType == INT_LIST_DIVIDED)) return NULL;

	/* Now we are left with handling either GROUP or FULL tables, therefore we will read another byte from the stream. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[instIndex + ((*ci->code >> 3) & 7)];
		/* Continue below to check prefixed table. */
	} else if (instType == INT_LIST_FULL) {
		in = InstructionsTree[instIndex + *ci->code];
		/* Continue below to check prefixed table. */
	}

	/* Now that we got to the last table in the trie, check for a prefixed table. */
	if (INST_NODE_TYPE(in) == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/* No VEXed instruction was found. */
	return NULL;
}

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps)
{
	unsigned int tmpIndex0 = 0, tmpIndex1 = 0, tmpIndex2 = 0, rex = ps->vrex;
	int instType = 0;
	_InstNode in = 0;
	_InstInfo* ii = NULL;
	int isWaitIncluded = FALSE;

	/* See whether we have to handle a VEX prefixed instruction. */
	if (ps->decodedPrefixes & INST_PRE_VEX) {
		ii = inst_vex_lookup(ci, ps);
		if (ii != NULL) {
			/* Make sure that VEX.L exists when forced. */
			if ((((_InstInfoEx*)ii)->flagsEx & INST_FORCE_VEXL) && (~ps->vrex & PREFIX_EX_L)) return NULL;
			/* If the instruction doesn't use VEX.vvvv it must be zero. */
			if ((((_InstInfoEx*)ii)->flagsEx & INST_VEX_V_UNUSED) && ps->vexV) return NULL;
		}
		return ii;
	}

	/* Read first byte. */
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex0 = *ci->code;

	/* Check for special 0x9b, WAIT instruction, which can be part of some instructions(x87). */
	if (tmpIndex0 == INST_WAIT_INDEX) {
		/* Only OCST_1dBYTES get a chance to include this byte as part of the opcode. */
		isWaitIncluded = TRUE;

		/* Ignore all prefixes, since they are useless and operate on the WAIT instruction itself. */
		prefixes_ignore_all(ps);

		/* Move to next code byte as a new whole instruction. */
		ci->code += 1;
		ci->codeLen -= 1;
		if (ci->codeLen < 0) return NULL; /* Faster to return NULL, it will be detected as WAIT later anyway. */
		/* Since we got a WAIT prefix, we re-read the first byte. */
		tmpIndex0 = *ci->code;
	}

	/* Walk first byte in InstructionsTree root. */
	in = InstructionsTree[tmpIndex0];
	if (in == INT_NOTEXISTS) return NULL;
	instType = INST_NODE_TYPE(in);

	/* Single byte instruction (OCST_1BYTE). */
	if ((instType < INT_INFOS) && (!isWaitIncluded)) {
		/* Some single byte instructions need extra treatment. */
		switch (tmpIndex0)
		{
			case INST_ARPL_INDEX:
				/*
				 * ARPL/MOVSXD share the same opcode, and both have different operands and mnemonics, of course.
				 * Practically, I couldn't come up with a comfortable way to merge the operands' types of ARPL/MOVSXD.
				 * And since the DB can't be patched dynamically, because the DB has to be multi-threaded compliant,
				 * I have no choice but to check for ARPL/MOVSXD right here - "right about now, the funk soul brother, check it out now, the funk soul brother...", fatboy slim
				 */
				if (ci->dt == Decode64Bits) {
					return &II_MOVSXD;
				} /* else ARPL will be returned because its defined in the DB already. */
			break;

			case INST_NOP_INDEX: /* Nopnopnop */
				/* Check for Pause, since it's prefixed with 0xf3, which is not a real mandatory prefix. */
				if (ps->decodedPrefixes & INST_PRE_REP) {
					/* Flag this prefix as used. */
					ps->usedPrefixes |= INST_PRE_REP;
					return &II_PAUSE;
				}

				/*
				 * Treat NOP/XCHG specially.
				 * If we're not in 64bits restore XCHG to NOP, since in the DB it's XCHG.
				 * Else if we're in 64bits examine REX, if exists, and decide which instruction should go to output.
				 * 48 90 XCHG RAX, RAX is a true NOP (eat REX in this case because it's valid).
				 * 90 XCHG EAX, EAX is a true NOP (and not high dword of RAX = 0 although it should be a 32 bits operation).
				 * Note that if the REX.B is used, then the register is not RAX anymore but R8, which means it's not a NOP.
				 */
				if (rex & PREFIX_EX_W) ps->usedPrefixes |= INST_PRE_REX;
				if ((ci->dt != Decode64Bits) || (~rex & PREFIX_EX_B)) return &II_NOP;
			break;
			
			case INST_LEA_INDEX:
				/* Ignore segment override prefixes for LEA instruction. */
				ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
				/* Update unused mask for ignoring segment prefix. */
				prefixes_ignore(ps, PFXIDX_SEG);
			break;
		}

		/* Return the 1 byte instruction we found. */
		return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];
	}

	/* Read second byte, still doens't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex1 = *ci->code;
	
	/* Try single byte instruction + reg bits (OCST_13BYTES). */
	if ((instType == INT_LIST_GROUP) && (!isWaitIncluded)) return inst_get_info(in, (tmpIndex1 >> 3) & 7);

	/* Try single byte instruction + reg byte OR one whole byte (OCST_1dBYTES). */
	if (instType == INT_LIST_DIVIDED) {
		/* OCST_1dBYTES is relatively simple to OCST_2dBYTES, since it's really divided at 0xc0. */
		if (tmpIndex1 < INST_DIVIDED_MODRM) {
			/* An instruction which requires a ModR/M byte. Thus it's 1.3 bytes long instruction. */
			tmpIndex1 = (tmpIndex1 >> 3) & 7; /* Isolate the 3 REG/OPCODE bits. */
		} else { /* Normal 2 bytes instruction. */
			/*
			 * Divided instructions can't be in the range of 0x8-0xc0.
			 * That's because 0-8 are used for 3 bits group.
			 * And 0xc0-0xff are used for not-divided instruction.
			 * So the inbetween range is omitted, thus saving some more place in the tables.
			 */
			tmpIndex1 -= INST_DIVIDED_MODRM - 8;
		}

		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS) {
			/* If the instruction doesn't support the wait (marked as opsize) as part of the opcode, it's illegal. */
			ii = instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];
			if ((~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE) && (isWaitIncluded)) return NULL;
			return ii;
		}
		/*
		 * If we got here the instruction can support the wait prefix, so see if it was part of the stream.
		 * Examine prefixed table, specially used for 0x9b, since it's optional.
		 * No Wait: index = 0.
		 * Wait Exists, index = 1.
		 */
		return inst_get_info(in, isWaitIncluded);
	}

	/* Don't allow to continue if WAIT is part of the opcode, because there are no instructions that include it. */
	if (isWaitIncluded) return NULL;

	/* Try 2 bytes long instruction (doesn't include ModRM byte). */
	if (instType == INT_LIST_FULL) {
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		/* This is where we check if we just read two escape bytes in a row, which means it is a 3DNow! instruction. */
		if ((tmpIndex0 == _3DNOW_ESCAPE_BYTE) && (tmpIndex1 == _3DNOW_ESCAPE_BYTE)) return &II_3DNOW;

		/* 2 bytes instruction (OCST_2BYTES). */
		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/*
		 * 2 bytes + mandatory perfix.
		 * Mandatory prefixes can be anywhere in the prefixes.
		 * There cannot be more than one mandatory prefix, unless it's a normal operand size prefix.
		 */
		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Read third byte, still doens't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex2 = *ci->code;

	/* Try 2 bytes + reg instruction (OCST_23BYTES). */
	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/* It has to be a prefixed table then. */
		return inst_lookup_prefixed(in, ps);
	}

	/* Try 2 bytes + divided range (OCST_2dBYTES). */
	if (instType == INT_LIST_DIVIDED) {
		_InstNode in2 = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		/*
		 * Do NOT check for NULL here, since we do a bit of a guess work,
		 * hence we don't override 'in', cause we might still need it.
		 */
		instType = INST_NODE_TYPE(in2);
		
		if (instType == INT_INFO) ii = &InstInfos[INST_NODE_INDEX(in2)];
		else if (instType == INT_INFOEX) ii = (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in2)];

		/*
		 * OCST_2dBYTES is complex, because there are a few instructions which are not divided in some special cases.
		 * If the instruction wasn't divided (but still it must be a 2.3 because we are in divided category)
		 * or it was an official 2.3 (because its index was less than 0xc0) -
		 * Then it means the instruction should be using the REG bits, otherwise give a chance to range 0xc0-0xff.
		 */
		/* If we found an instruction only by its REG bits, AND it is not divided, then return it. */
		if ((ii != NULL) && (INST_INFO_FLAGS(ii) & INST_NOT_DIVIDED)) return ii;
		/* Otherwise, if the range is above 0xc0, try the special divided range (range 0x8-0xc0 is omitted). */
		if (tmpIndex2 >= INST_DIVIDED_MODRM) return inst_get_info(in, tmpIndex2 - INST_DIVIDED_MODRM + 8);

		/* It might be that we got here without touching ii in the above if statements, then it becomes an invalid instruction prolly. */
		return ii;
	}

	/* Try 3 full bytes (OCST_3BYTES - no ModRM byte). */
	if (instType == INT_LIST_FULL) {
		/* OCST_3BYTES. */
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex2];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Kahtchinggg, damn. */
	return NULL;
}

/*
* 3DNow! instruction handling:

* This is used when we encounter a 3DNow! instruction.
* We can't really locate a 3DNow! instruction before we see two escaped bytes,
* 0x0f, 0x0f. Then we have to extract operands which are, dest=mmx register, src=mmx register or quadword indirection.
* When we are finished with the extraction of operands we can resume to locate the instruction by reading another byte
* which tells us which 3DNow instruction we really tracked down...
* So in order to tell the extract operands function which operands the 3DNow! instruction require, we need to set up some
* generic instruction info for 3DNow! instructions.

* In the inst_lookup itself, when we read an OCST_3BYTES which the two first bytes are 0x0f and 0x0f.
* we will return this special generic II for the specific operands we are interested in (MM, MM64).
* Then after extracting the operand, we'll call a completion routine for locating the instruction
* which will be called only for 3DNow! instructions, distinguished by a flag, and it will read the last byte of the 3 bytes.
*
* The id of this opcode should not be used, the following function should change it anyway.
*/
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci)
{
	/* Start off from the two escape bytes gates... which is 3DNow! table.*/
	_InstNode in = Table_0F_0F;

	int index;

	/* Make sure we can read a byte off the stream. */
	if (ci->codeLen < 1) return NULL;

	index = *ci->code;

	ci->codeLen -= 1;
	ci->code += 1;
	return inst_get_info(in, index);
}



================================================
File: src/sigmake/distorm/instructions.h
================================================
/*
instructions.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef INSTRUCTIONS_H
#define INSTRUCTIONS_H

#include "config.h"
#include "prefix.h"


/*
 * Operand type possibilities:
 * Note "_FULL" suffix indicates to decode the operand as 16 bits or 32 bits depends on DecodeType -
 * actually, it depends on the decoding mode, unless there's an operand/address size prefix.
 * For example, the code: 33 c0 could be decoded/executed as XOR AX, AX or XOR EAX, EAX.
 */
typedef enum OpType {
	/* No operand is set */
	OT_NONE = 0,

	/* Read a byte(8 bits) immediate */
	OT_IMM8,
	/* Force a read of a word(16 bits) immediate, used by ret only */
	OT_IMM16,
	/* Read a word/dword immediate */
	OT_IMM_FULL,
	/* Read a double-word(32 bits) immediate */
	OT_IMM32,

	/* Read a signed extended byte(8 bits) immediate */
	OT_SEIMM8,

	/*
	 * Special immediates for instructions which have more than one immediate,
	 * which is an exception from standard instruction format.
	 * As to version v1.0: ENTER, INSERTQ, EXTRQ are the only problematic ones.
	 */
	/* 16 bits immediate using the first imm-slot */
	OT_IMM16_1,
	/* 8 bits immediate using the first imm-slot */
	OT_IMM8_1,
	/* 8 bits immediate using the second imm-slot */
	OT_IMM8_2,

	/* Use a 8bit register */
	OT_REG8,
	/* Use a 16bit register */
	OT_REG16,
	/* Use a 16/32/64bit register */
	OT_REG_FULL,
	/* Use a 32bit register */
	OT_REG32,
	/*
	 * If used with REX the reg operand size becomes 64 bits, otherwise 32 bits.
	 * VMX instructions are promoted automatically without a REX prefix.
	 */
	OT_REG32_64,
	/* Used only by MOV CR/DR(n). Promoted with REX onlly. */
	OT_FREG32_64_RM,

	/* Use or read (indirection) a 8bit register or immediate byte */
	OT_RM8,
	/* Some instructions force 16 bits (mov sreg, rm16) */
	OT_RM16,
	/* Use or read a 16/32/64bit register or immediate word/dword/qword */
	OT_RM_FULL,
	/*
	 * 32 or 64 bits (with REX) operand size indirection memory operand.
	 * Some instructions are promoted automatically without a REX prefix.
	 */
	OT_RM32_64,
	/* 16 or 32 bits RM. This is used only with MOVZXD instruction in 64bits. */
	OT_RM16_32,
	/* Same as OT_RMXX but POINTS to 16 bits [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM16,
	/* Same as OT_RMXX but POINTS to 32 bits (single precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM32,
	/* Same as OT_RMXX but POINTS to 64 bits (double precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM64,
	/* Same as OT_RMXX but POINTS to 80 bits (extended precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM80,

	/*
	 * Special operand type for SSE4 where the ModR/M might
	 * be a 32 bits register or 8 bits memory indirection operand.
	 */
	OT_R32_M8,
	/*
	 * Special ModR/M for PINSRW, which need a 16 bits memory operand or 32 bits register.
	 * In 16 bits decoding mode R32 becomes R16, operand size cannot affect this.
	 */
	OT_R32_M16,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 8 bits memory indirection operand.
	 */
	OT_R32_64_M8,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 16 bits memory indirection operand.
	 */
	OT_R32_64_M16,
	/*
	 * Special operand type for MOV reg16/32/64/mem16, segReg 8C /r. and SMSW.
	 * It supports all decoding modes, but if used as a memory indirection it's a 16 bit ModR/M indirection.
	 */
	OT_RFULL_M16,

	/* Use a control register */
	OT_CREG,
	/* Use a debug register */
	OT_DREG,
	/* Use a segment register */
	OT_SREG,
	/*
	 * SEG is encoded in the flags of the opcode itself!
	 * This is used for specific "push SS" where SS is a segment where
	 * each "push SS" has an absolutely different opcode byte.
	 * We need this to detect whether an operand size prefix is used.
	 */
	OT_SEG,
	
	/* Use AL */
	OT_ACC8,
	/* Use AX (FSTSW) */
	OT_ACC16,
	/* Use AX/EAX/RAX */
	OT_ACC_FULL,
	/* Use AX/EAX, no REX is possible for RAX, used only with IN/OUT which don't support 64 bit registers */
	OT_ACC_FULL_NOT64,

	/*
	 * Read one word (seg), and a word/dword/qword (depends on operand size) from memory.
	 * JMP FAR [EBX] means EBX point to 16:32 ptr.
	 */
	OT_MEM16_FULL,
	/* Read one word (seg) and a word/dword/qword (depends on operand size), usually SEG:OFF, JMP 1234:1234 */
	OT_PTR16_FULL,
	/* Read one word (limit) and a dword/qword (limit) (depends on operand size), used by SGDT, SIDT, LGDT, LIDT. */
	OT_MEM16_3264,

	/* Read a byte(8 bits) immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELCB,
	/* Read a word/dword immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELC_FULL,

	/* Use general memory indirection, with varying sizes: */
	OT_MEM,
	/* Used when a memory indirection is required, but if the mod field is 11, this operand will be ignored. */
	OT_MEM_OPT,
	OT_MEM32,
	/* Memory dereference for MOVNTI, either 32 or 64 bits (with REX). */
	OT_MEM32_64,
	OT_MEM64,
	OT_MEM128,
	/* Used for cmpxchg8b/16b. */
	OT_MEM64_128,

	/* Read an immediate as an absolute address, size is known by instruction, used by MOV (memory offset) only */
	OT_MOFFS8,
	OT_MOFFS_FULL,
	/* Use an immediate of 1, as for SHR R/M, 1 */
	OT_CONST1,
	/* Use CL, as for SHR R/M, CL */
	OT_REGCL,

	/*
	 * Instruction-Block for one byte long instructions, used by INC/DEC/PUSH/POP/XCHG,
	 * REG is extracted from the value of opcode
	 * Use a 8bit register
	 */
	OT_IB_RB,
	/* Use a 16/32/64bit register */
	OT_IB_R_FULL,

	/* Use [(r)SI] as INDIRECTION, for repeatable instructions */
	OT_REGI_ESI,
	/* Use [(r)DI] as INDIRECTION, for repeatable instructions */
	OT_REGI_EDI,
	/* Use [(r)BX + AL] as INDIRECTIOM, used by XLAT only */
	OT_REGI_EBXAL,
	/* Use [(r)AX] as INDIRECTION, used by AMD's SVM instructions */
	OT_REGI_EAX,
	/* Use DX, as for OUTS DX, BYTE [SI] */
	OT_REGDX,
	/* Use ECX in INVLPGA instruction */
	OT_REGECX,

	/* FPU registers: */
	OT_FPU_SI, /* ST(i) */
	OT_FPU_SSI, /* ST(0), ST(i) */
	OT_FPU_SIS, /* ST(i), ST(0) */

	/* MMX registers: */
	OT_MM,
	/* Extract the MMX register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_MM_RM,
	/* ModR/M points to 32 bits MMX variable */
	OT_MM32,
	/* ModR/M points to 32 bits MMX variable */
	OT_MM64,

	/* SSE registers: */
	OT_XMM,
	/* Extract the SSE register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_XMM_RM,
	/* ModR/M points to 16 bits SSE variable */
	OT_XMM16,
	/* ModR/M points to 32 bits SSE variable */
	OT_XMM32,
	/* ModR/M points to 64 bits SSE variable */
	OT_XMM64,
	/* ModR/M points to 128 bits SSE variable */
	OT_XMM128,
	/* Implied XMM0 register as operand, used in SSE4. */
	OT_REGXMM0,

	/* AVX operands: */

	/* ModR/M for 32 bits. */
	OT_RM32,
	/* Reg32/Reg64 (prefix width) or Mem8. */
	OT_REG32_64_M8,
	/* Reg32/Reg64 (prefix width) or Mem16. */
	OT_REG32_64_M16,
	/* Reg32/Reg 64 depends on prefix width only. */
	OT_WREG32_64,
	/* RM32/RM64 depends on prefix width only. */
	OT_WRM32_64,
	/* XMM or Mem32/Mem64 depends on perfix width only. */
	OT_WXMM32_64,
	/* XMM is encoded in VEX.VVVV. */
	OT_VXMM,
	/* XMM is encoded in the high nibble of an immediate byte. */
	OT_XMM_IMM,
	/* YMM/XMM is dependent on VEX.L. */
	OT_YXMM,
	/* YMM/XMM (depends on prefix length) is encoded in the high nibble of an immediate byte. */
	OT_YXMM_IMM,
	/* YMM is encoded in reg. */
	OT_YMM,
	/* YMM or Mem256. */
	OT_YMM256,
	/* YMM is encoded in VEX.VVVV. */
	OT_VYMM,
	/* YMM/XMM is dependent on VEX.L, and encoded in VEX.VVVV. */
	OT_VYXMM,
	/* YMM/XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_YXMM64_256,
	/* YMM/XMM or Mem128/Mem256 is dependent on VEX.L. */
	OT_YXMM128_256,
	/* XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_LXMM64_128,
	/* Mem128/Mem256 is dependent on VEX.L. */
	OT_LMEM128_256
} _OpType;

/* Flags for instruction: */

/* Empty flags indicator: */
#define INST_FLAGS_NONE (0)
/* The instruction we are going to decode requires ModR/M encoding. */
#define INST_MODRM_REQUIRED (1)
/* Special treatment for instructions which are in the divided-category but still needs the whole byte for ModR/M... */
#define INST_NOT_DIVIDED (1 << 1)
/*
 * Used explicitly in repeatable instructions,
 * which needs a suffix letter in their mnemonic to specify operation-size (depend on operands).
 */
#define INST_16BITS (1 << 2)
/* If the opcode is supported by 80286 and upper models (16/32 bits). */
#define INST_32BITS (1 << 3)
/*
 * Prefix flags (6 types: lock/rep, seg override, addr-size, oper-size, REX, VEX)
 * There are several specific instructions that can follow LOCK prefix,
 * note that they must be using a memory operand form, otherwise they generate an exception.
 */
#define INST_PRE_LOCK (1 << 4)
/* REPNZ prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REPNZ (1 << 5)
/* REP prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REP (1 << 6)
/* CS override prefix. */
#define INST_PRE_CS (1 << 7)
/* SS override prefix. */
#define INST_PRE_SS (1 << 8)
/* DS override prefix. */
#define INST_PRE_DS (1 << 9)
/* ES override prefix. */
#define INST_PRE_ES (1 << 10)
/* FS override prefix. Funky Segment :) */
#define INST_PRE_FS (1 << 11)
/* GS override prefix. Groovy Segment, of course not, duh ! */
#define INST_PRE_GS (1 << 12)
/* Switch operand size from 32 to 16 and vice versa. */
#define INST_PRE_OP_SIZE (1 << 13)
/* Switch address size from 32 to 16 and vice versa. */
#define INST_PRE_ADDR_SIZE (1 << 14)
/* Native instructions which needs suffix letter to indicate their operation-size (and don't depend on operands). */
#define INST_NATIVE (1 << 15)
/* Use extended mnemonic, means it's an _InstInfoEx structure, which contains another mnemonic for 32 bits specifically. */
#define INST_USE_EXMNEMONIC (1 << 16)
/* Use third operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP3 (1 << 17)
/* Use fourth operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP4 (1 << 18)
/* The instruction's mnemonic depends on the mod value of the ModR/M byte (mod=11, mod!=11). */
#define INST_MNEMONIC_MODRM_BASED (1 << 19)
/* The instruction uses a ModR/M byte which the MOD must be 11 (for registers operands only). */
#define INST_MODRR_REQUIRED (1 << 20)
/* The way of 3DNow! instructions are built, we have to handle their locating specially. Suffix imm8 tells which instruction it is. */
#define INST_3DNOW_FETCH (1 << 21)
/* The instruction needs two suffixes, one for the comparison type (imm8) and the second for its operation size indication (second mnemonic). */
#define INST_PSEUDO_OPCODE (1 << 22)
/* Invalid instruction at 64 bits decoding mode. */
#define INST_INVALID_64BITS (1 << 23)
/* Specific instruction can be promoted to 64 bits (without REX, it is promoted automatically). */
#define INST_64BITS (1 << 24)
/* Indicates the instruction must be REX prefixed in order to use 64 bits operands. */
#define INST_PRE_REX (1 << 25)
/* Third mnemonic is set. */
#define INST_USE_EXMNEMONIC2 (1 << 26)
/* Instruction is only valid in 64 bits decoding mode. */
#define INST_64BITS_FETCH (1 << 27)
/* Forces that the ModRM-REG/Opcode field will be 0. (For EXTRQ). */
#define INST_FORCE_REG0 (1 << 28)
/* Indicates that instruction is encoded with a VEX prefix. */
#define INST_PRE_VEX (1 << 29)
/* Indicates that the instruction is encoded with a ModRM byte (REG field specifically). */
#define INST_MODRM_INCLUDED (1 << 30)
/* Indicates that the first (/destination) operand of the instruction is writable. */
#define INST_DST_WR (1 << 31)

#define INST_PRE_REPS (INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_LOKREP_MASK (INST_PRE_LOCK | INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_SEGOVRD_MASK32 (INST_PRE_CS | INST_PRE_SS | INST_PRE_DS | INST_PRE_ES)
#define INST_PRE_SEGOVRD_MASK64 (INST_PRE_FS | INST_PRE_GS)
#define INST_PRE_SEGOVRD_MASK (INST_PRE_SEGOVRD_MASK32 | INST_PRE_SEGOVRD_MASK64)

/* Extended flags for VEX: */
/* Indicates that the instruction might have VEX.L encoded. */
#define INST_VEX_L (1)
/* Indicates that the instruction might have VEX.W encoded. */
#define INST_VEX_W (1 << 1)
/* Indicates that the mnemonic of the instruction is based on the VEX.W bit. */
#define INST_MNEMONIC_VEXW_BASED (1 << 2)
/* Indicates that the mnemonic of the instruction is based on the VEX.L bit. */
#define INST_MNEMONIC_VEXL_BASED (1 << 3)
/* Forces the instruction to be encoded with VEX.L, otherwise it's undefined. */
#define INST_FORCE_VEXL (1 << 4)
/*
 * Indicates that the instruction is based on the MOD field of the ModRM byte.
 * (MOD==11: got the right instruction, else skip +4 in prefixed table for the correct instruction).
 */
#define INST_MODRR_BASED (1 << 5)
/* Indicates that the instruction doesn't use the VVVV field of the VEX prefix, if it does then it's undecodable. */
#define INST_VEX_V_UNUSED (1 << 6)

/*
 * Indicates which operand is being decoded.
 * Destination (1st), Source (2nd), op3 (3rd), op4 (4th).
 * Used to set the operands' fields in the _DInst structure!
 */
typedef enum {ONT_NONE = -1, ONT_1 = 0, ONT_2 = 1, ONT_3 = 2, ONT_4 = 3} _OperandNumberType;

/*
 * In order to save more space for storing the DB statically,
 * I came up with another level of shared info.
 * Because I saw that most of the information that instructions use repeats itself.
 *
 * Info about the instruction, source/dest types, meta and flags.
 * _InstInfo points to a table of _InstSharedInfo.
 */
typedef struct {
	uint8_t flagsIndex; /* An index into FlagsTables */
	uint8_t s, d; /* OpType. */
	uint8_t meta; /* Hi 5 bits = Instruction set class | Lo 3 bits = flow control flags. */
	/* The following are CPU flag masks that the instruction changes. */
	uint8_t modifiedFlags;
	uint8_t testedFlags;
	uint8_t undefinedFlags;
} _InstSharedInfo;

/*
 * This structure is used for the instructions DB and NOT for the disassembled result code!
 * This is the BASE structure, there are extentions to this structure below.
 */
typedef struct {
	uint16_t sharedIndex; /* An index into the SharedInfoTable. */
	uint16_t opcodeId; /* The opcodeId is really a byte-offset into the mnemonics table. */
} _InstInfo;

/*
 * There are merely few instructions which need a second mnemonic for 32 bits.
 * Or a third for 64 bits. Therefore sometimes the second mnemonic is empty but not the third.
 * In all decoding modes the first mnemonic is the default.
 * A flag will indicate it uses another mnemonic.
 *
 * There are a couple of (SSE4) instructions in the whole DB which need both op3 and 3rd mnemonic for 64bits,
 * therefore, I decided to make the extended structure contain all extra info in the same structure.
 * There are a few instructions (SHLD/SHRD/IMUL and SSE too) which use third operand (or a fourth).
 * A flag will indicate it uses a third/fourth operand.
 */
typedef struct {
	/* Base structure (doesn't get accessed directly from code). */
	_InstInfo BASE;

	/* Extended starts here. */
	uint8_t flagsEx; /* 8 bits are enough, in the future we might make it a bigger integer. */
	uint8_t op3, op4; /* OpType. */
	uint16_t opcodeId2, opcodeId3;
} _InstInfoEx;

/* Trie data structure node type: */
typedef enum {
	INT_NOTEXISTS = 0, /* Not exists. */
	INT_INFO = 1, /* It's an instruction info. */
	INT_INFOEX,
	INT_LIST_GROUP,
	INT_LIST_FULL,
	INT_LIST_DIVIDED,
	INT_LIST_PREFIXED
} _InstNodeType;

/* Used to check instType < INT_INFOS, means we got an inst-info. Cause it has to be only one of them. */
#define INT_INFOS (INT_LIST_GROUP)

/* Instruction node is treated as { int index:13;  int type:3; } */
typedef uint16_t _InstNode;

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps);
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci);

#endif /* INSTRUCTIONS_H */



================================================
File: src/sigmake/distorm/insts.c
================================================
/*
insts.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "config.h"
#include "insts.h"
#include "instructions.h"


/*
 * GENERATED BY disOps at Fri Sep 21 15:33:01 2012
 */

_InstInfo II_MOVSXD =	/*II*/ {0x1cf, 10013};
_InstInfo II_NOP =	/*II*/ {0x53, 581};
_InstInfo II_PAUSE =	/*II*/ {0x88, 10021};
_InstInfo II_WAIT =	/*II*/ {0x53, 10028};
_InstInfo II_3DNOW =	/*II*/ {0x1d0, 10034};

_iflags FlagsTable[98] = {
0x80000011,
0x80000000,
0x800400,
0x80800400,
0x800080,
0x800100,
0x80800100,
0x800200,
0x80800200,
0x800000,
0x1,
0x0,
0x80800000,
0x1000000,
0x81000000,
0x808000,
0x800001,
0x80020001,
0x1002000,
0x60,
0x64,
0x80000001,
0x4010000,
0x1008000,
0x80000060,
0x83000064,
0x3000064,
0x83000000,
0x3008000,
0x200,
0xc000,
0x4014000,
0x8,
0x81000009,
0x9,
0x80000009,
0x1000808,
0x81000808,
0x80020009,
0x1001008,
0x81001008,
0x80000019,
0x3000009,
0x83000009,
0x83000008,
0xc0000011,
0x40000001,
0xc0800011,
0x40800001,
0xc0000019,
0xc1000001,
0xc0000001,
0x40000000,
0x40000008,
0x40000009,
0x41000001,
0x43000001,
0xc0000003,
0x40000003,
0x48000000,
0x200009,
0x20000009,
0x60020009,
0x60000009,
0x80090009,
0x200b0009,
0x20020009,
0x80100009,
0x21100009,
0x87000009,
0x20009,
0x20000008,
0x1000009,
0x10020009,
0x160009,
0x100009,
0x47000009,
0x47090009,
0x40090009,
0x80002009,
0xc0000009,
0x2001,
0x80002001,
0x410009,
0x20420009,
0x20060009,
0x120009,
0x21020009,
0xc7000019,
0x20100009,
0x40002009,
0x40002008,
0x4020009,
0x40100009,
0x60120009,
0x41000009,
0x83000001,
0x200001
};

_InstNode Table_0F = 256;
_InstNode Table_0F_0F = 1312;
_InstNode Table_0F_38 = 1768;
_InstNode Table_0F_3A = 2024;

_InstInfo InstInfos[1242] = {
	/*II_00*/ {0x0, 11},
	/*II_01*/ {0x1, 11},
	/*II_02*/ {0x2, 11},
	/*II_03*/ {0x3, 11},
	/*II_04*/ {0x4, 11},
	/*II_05*/ {0x5, 11},
	/*II_06*/ {0x6, 16},
	/*II_07*/ {0x7, 22},
	/*II_08*/ {0x8, 27},
	/*II_09*/ {0x9, 27},
	/*II_0A*/ {0xa, 27},
	/*II_0B*/ {0xb, 27},
	/*II_0C*/ {0xc, 27},
	/*II_0D*/ {0xd, 27},
	/*II_0E*/ {0xe, 16},
	/*II_10*/ {0xf, 31},
	/*II_11*/ {0x10, 31},
	/*II_12*/ {0x11, 31},
	/*II_13*/ {0x12, 31},
	/*II_14*/ {0x13, 31},
	/*II_15*/ {0x14, 31},
	/*II_16*/ {0x15, 16},
	/*II_17*/ {0x16, 22},
	/*II_18*/ {0xf, 36},
	/*II_19*/ {0x10, 36},
	/*II_1A*/ {0x11, 36},
	/*II_1B*/ {0x12, 36},
	/*II_1C*/ {0x13, 36},
	/*II_1D*/ {0x14, 36},
	/*II_1E*/ {0x17, 16},
	/*II_1F*/ {0x18, 22},
	/*II_20*/ {0x19, 41},
	/*II_21*/ {0x1a, 41},
	/*II_22*/ {0x1b, 41},
	/*II_23*/ {0x1c, 41},
	/*II_24*/ {0x1d, 41},
	/*II_25*/ {0x1e, 41},
	/*II_27*/ {0x1f, 46},
	/*II_28*/ {0x0, 51},
	/*II_29*/ {0x1, 51},
	/*II_2A*/ {0x2, 51},
	/*II_2B*/ {0x3, 51},
	/*II_2C*/ {0x4, 51},
	/*II_2D*/ {0x5, 51},
	/*II_2F*/ {0x1f, 56},
	/*II_30*/ {0x20, 61},
	/*II_31*/ {0x21, 61},
	/*II_32*/ {0x22, 61},
	/*II_33*/ {0x23, 61},
	/*II_34*/ {0x24, 61},
	/*II_35*/ {0x25, 61},
	/*II_37*/ {0x26, 66},
	/*II_38*/ {0x27, 71},
	/*II_39*/ {0x28, 71},
	/*II_3A*/ {0x29, 71},
	/*II_3B*/ {0x2a, 71},
	/*II_3C*/ {0x2b, 71},
	/*II_3D*/ {0x2c, 71},
	/*II_3F*/ {0x26, 76},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_40*/ {0x2d, 81},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_48*/ {0x2d, 86},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_50*/ {0x2e, 16},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_58*/ {0x2f, 22},
	/*II_60*/ {0x30, 91},
	/*II_61*/ {0x30, 98},
	/*II_62*/ {0x31, 104},
	/*II_63*/ {0x32, 111},
	/*II_68*/ {0x33, 16},
	/*II_6A*/ {0x35, 16},
	/*II_6C*/ {0x36, 123},
	/*II_6D*/ {0x37, 123},
	/*II_6E*/ {0x38, 128},
	/*II_6F*/ {0x39, 128},
	/*II_70*/ {0x3a, 134},
	/*II_71*/ {0x3a, 138},
	/*II_72*/ {0x3b, 143},
	/*II_73*/ {0x3b, 147},
	/*II_74*/ {0x3c, 152},
	/*II_75*/ {0x3c, 156},
	/*II_76*/ {0x3d, 161},
	/*II_77*/ {0x3d, 166},
	/*II_78*/ {0x3e, 170},
	/*II_79*/ {0x3e, 174},
	/*II_7A*/ {0x3f, 179},
	/*II_7B*/ {0x3f, 183},
	/*II_7C*/ {0x40, 188},
	/*II_7D*/ {0x40, 192},
	/*II_7E*/ {0x41, 197},
	/*II_7F*/ {0x41, 202},
	/*II_84*/ {0x42, 206},
	/*II_85*/ {0x43, 206},
	/*II_86*/ {0x44, 212},
	/*II_87*/ {0x45, 212},
	/*II_88*/ {0x46, 218},
	/*II_89*/ {0x47, 218},
	/*II_8A*/ {0x48, 218},
	/*II_8B*/ {0x49, 218},
	/*II_8C*/ {0x4a, 218},
	/*II_8D*/ {0x4b, 223},
	/*II_8E*/ {0x4c, 218},
	/*II_90*/ {0x4d, 212},
	/*II_91*/ {0x4d, 212},
	/*II_92*/ {0x4d, 212},
	/*II_93*/ {0x4d, 212},
	/*II_94*/ {0x4d, 212},
	/*II_95*/ {0x4d, 212},
	/*II_96*/ {0x4d, 212},
	/*II_97*/ {0x4d, 212},
	/*II_9A*/ {0x4f, 260},
	/*II_9C*/ {0x50, 270},
	/*II_9D*/ {0x51, 277},
	/*II_9E*/ {0x52, 283},
	/*II_9F*/ {0x53, 289},
	/*II_A0*/ {0x54, 218},
	/*II_A1*/ {0x55, 218},
	/*II_A2*/ {0x56, 218},
	/*II_A3*/ {0x57, 218},
	/*II_A4*/ {0x58, 295},
	/*II_A5*/ {0x59, 295},
	/*II_A6*/ {0x5a, 301},
	/*II_A7*/ {0x5b, 301},
	/*II_A8*/ {0x5c, 206},
	/*II_A9*/ {0x5d, 206},
	/*II_AA*/ {0x5e, 307},
	/*II_AB*/ {0x5f, 307},
	/*II_AC*/ {0x60, 313},
	/*II_AD*/ {0x61, 313},
	/*II_AE*/ {0x62, 319},
	/*II_AF*/ {0x63, 319},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B0*/ {0x64, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_B8*/ {0x65, 218},
	/*II_C2*/ {0x66, 325},
	/*II_C3*/ {0x67, 325},
	/*II_C4*/ {0x68, 330},
	/*II_C5*/ {0x68, 335},
	/*II_C8*/ {0x69, 340},
	/*II_C9*/ {0x6a, 347},
	/*II_CA*/ {0x6b, 354},
	/*II_CB*/ {0x6c, 354},
	/*II_CC*/ {0x6d, 360},
	/*II_CD*/ {0x6e, 367},
	/*II_CE*/ {0x6f, 372},
	/*II_CF*/ {0x70, 378},
	/*II_D4*/ {0x71, 384},
	/*II_D5*/ {0x71, 389},
	/*II_D6*/ {0x72, 394},
	/*II_D7*/ {0x73, 400},
	/*II_E0*/ {0x74, 406},
	/*II_E1*/ {0x74, 414},
	/*II_E2*/ {0x75, 421},
	/*II_E4*/ {0x77, 447},
	/*II_E5*/ {0x78, 447},
	/*II_E6*/ {0x79, 451},
	/*II_E7*/ {0x7a, 451},
	/*II_E8*/ {0x7b, 456},
	/*II_E9*/ {0x7c, 462},
	/*II_EA*/ {0x7d, 467},
	/*II_EB*/ {0x7e, 462},
	/*II_EC*/ {0x7f, 447},
	/*II_ED*/ {0x80, 447},
	/*II_EE*/ {0x81, 451},
	/*II_EF*/ {0x82, 451},
	/*II_F1*/ {0x6d, 476},
	/*II_F4*/ {0x53, 482},
	/*II_F5*/ {0x83, 487},
	/*II_F8*/ {0x83, 492},
	/*II_F9*/ {0x83, 497},
	/*II_FA*/ {0x84, 502},
	/*II_FB*/ {0x84, 507},
	/*II_FC*/ {0x85, 512},
	/*II_FD*/ {0x85, 517},
	/*II_0F_02*/ {0x86, 522},
	/*II_0F_03*/ {0x86, 527},
	/*II_0F_05*/ {0x87, 532},
	/*II_0F_06*/ {0x88, 541},
	/*II_0F_07*/ {0x87, 547},
	/*II_0F_08*/ {0x88, 555},
	/*II_0F_09*/ {0x88, 561},
	/*II_0F_0B*/ {0x89, 569},
	/*II_0F_0E*/ {0x8a, 574},
	/*II_0F_1F*/ {0x8b, 581},
	/*II_0F_20*/ {0x8c, 218},
	/*II_0F_21*/ {0x8d, 218},
	/*II_0F_22*/ {0x8e, 218},
	/*II_0F_23*/ {0x8f, 218},
	/*II_0F_30*/ {0x88, 586},
	/*II_0F_31*/ {0x88, 593},
	/*II_0F_32*/ {0x88, 600},
	/*II_0F_33*/ {0x88, 607},
	/*II_0F_34*/ {0x87, 614},
	/*II_0F_35*/ {0x87, 624},
	/*II_0F_37*/ {0x90, 633},
	/*II_0F_40*/ {0x91, 641},
	/*II_0F_41*/ {0x91, 648},
	/*II_0F_42*/ {0x92, 656},
	/*II_0F_43*/ {0x92, 663},
	/*II_0F_44*/ {0x93, 671},
	/*II_0F_45*/ {0x93, 678},
	/*II_0F_46*/ {0x94, 686},
	/*II_0F_47*/ {0x94, 694},
	/*II_0F_48*/ {0x95, 701},
	/*II_0F_49*/ {0x95, 708},
	/*II_0F_4A*/ {0x96, 716},
	/*II_0F_4B*/ {0x96, 723},
	/*II_0F_4C*/ {0x97, 731},
	/*II_0F_4D*/ {0x97, 738},
	/*II_0F_4E*/ {0x98, 746},
	/*II_0F_4F*/ {0x98, 754},
	/*II_0F_80*/ {0x99, 134},
	/*II_0F_81*/ {0x99, 138},
	/*II_0F_82*/ {0x9a, 143},
	/*II_0F_83*/ {0x9a, 147},
	/*II_0F_84*/ {0x9b, 152},
	/*II_0F_85*/ {0x9b, 156},
	/*II_0F_86*/ {0x9c, 161},
	/*II_0F_87*/ {0x9c, 166},
	/*II_0F_88*/ {0x9d, 170},
	/*II_0F_89*/ {0x9d, 174},
	/*II_0F_8A*/ {0x9e, 179},
	/*II_0F_8B*/ {0x9e, 183},
	/*II_0F_8C*/ {0x9f, 188},
	/*II_0F_8D*/ {0x9f, 192},
	/*II_0F_8E*/ {0xa0, 197},
	/*II_0F_8F*/ {0xa0, 202},
	/*II_0F_90*/ {0xa1, 761},
	/*II_0F_91*/ {0xa1, 767},
	/*II_0F_92*/ {0xa2, 774},
	/*II_0F_93*/ {0xa2, 780},
	/*II_0F_94*/ {0xa3, 787},
	/*II_0F_95*/ {0xa3, 793},
	/*II_0F_96*/ {0xa4, 800},
	/*II_0F_97*/ {0xa4, 807},
	/*II_0F_98*/ {0xa5, 813},
	/*II_0F_99*/ {0xa5, 819},
	/*II_0F_9A*/ {0xa6, 826},
	/*II_0F_9B*/ {0xa6, 832},
	/*II_0F_9C*/ {0xa7, 839},
	/*II_0F_9D*/ {0xa7, 845},
	/*II_0F_9E*/ {0xa8, 852},
	/*II_0F_9F*/ {0xa8, 859},
	/*II_0F_A0*/ {0xa9, 16},
	/*II_0F_A1*/ {0xaa, 22},
	/*II_0F_A2*/ {0x88, 865},
	/*II_0F_A3*/ {0xab, 872},
	/*II_0F_A8*/ {0xad, 16},
	/*II_0F_A9*/ {0xae, 22},
	/*II_0F_AA*/ {0xaf, 882},
	/*II_0F_AB*/ {0xb0, 887},
	/*II_0F_AF*/ {0xb1, 117},
	/*II_0F_B0*/ {0xb2, 898},
	/*II_0F_B1*/ {0xb3, 898},
	/*II_0F_B2*/ {0xb4, 907},
	/*II_0F_B3*/ {0xb0, 912},
	/*II_0F_B4*/ {0xb4, 917},
	/*II_0F_B5*/ {0xb4, 922},
	/*II_0F_B6*/ {0xb5, 927},
	/*II_0F_B7*/ {0xb6, 927},
	/*II_0F_B9*/ {0x89, 569},
	/*II_0F_BB*/ {0xb0, 934},
	/*II_0F_BE*/ {0xb5, 939},
	/*II_0F_BF*/ {0xb6, 939},
	/*II_0F_C0*/ {0xb2, 946},
	/*II_0F_C1*/ {0xb3, 946},
	/*II_0F_C3*/ {0xb7, 952},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_0F_C8*/ {0xb8, 960},
	/*II_80_00*/ {0xb9, 11},
	/*II_80_01*/ {0xba, 27},
	/*II_80_02*/ {0xbb, 31},
	/*II_80_03*/ {0xbb, 36},
	/*II_80_04*/ {0xbc, 41},
	/*II_80_05*/ {0xb9, 51},
	/*II_80_06*/ {0xbd, 61},
	/*II_80_07*/ {0xbe, 71},
	/*II_81_00*/ {0xbf, 11},
	/*II_81_01*/ {0xc0, 27},
	/*II_81_02*/ {0xc1, 31},
	/*II_81_03*/ {0xc1, 36},
	/*II_81_04*/ {0xc2, 41},
	/*II_81_05*/ {0xbf, 51},
	/*II_81_06*/ {0xc3, 61},
	/*II_81_07*/ {0xc4, 71},
	/*II_82_00*/ {0xc5, 11},
	/*II_82_01*/ {0xc6, 27},
	/*II_82_02*/ {0xc7, 31},
	/*II_82_03*/ {0xc7, 36},
	/*II_82_04*/ {0xc8, 41},
	/*II_82_05*/ {0xc5, 51},
	/*II_82_06*/ {0xc9, 61},
	/*II_82_07*/ {0xca, 71},
	/*II_83_00*/ {0xcb, 11},
	/*II_83_01*/ {0xcc, 27},
	/*II_83_02*/ {0xcd, 31},
	/*II_83_03*/ {0xcd, 36},
	/*II_83_04*/ {0xce, 41},
	/*II_83_05*/ {0xcb, 51},
	/*II_83_06*/ {0xcf, 61},
	/*II_83_07*/ {0xd0, 71},
	/*II_8F_00*/ {0xd1, 22},
	/*II_C0_00*/ {0xd2, 967},
	/*II_C0_01*/ {0xd2, 972},
	/*II_C0_02*/ {0xd3, 977},
	/*II_C0_03*/ {0xd3, 982},
	/*II_C0_04*/ {0xd4, 987},
	/*II_C0_05*/ {0xd4, 992},
	/*II_C0_06*/ {0xd5, 997},
	/*II_C0_07*/ {0xd5, 1002},
	/*II_C1_00*/ {0xd6, 967},
	/*II_C1_01*/ {0xd6, 972},
	/*II_C1_02*/ {0xd7, 977},
	/*II_C1_03*/ {0xd7, 982},
	/*II_C1_04*/ {0xd8, 987},
	/*II_C1_05*/ {0xd8, 992},
	/*II_C1_06*/ {0xd9, 997},
	/*II_C1_07*/ {0xd9, 1002},
	/*II_C6_00*/ {0xd5, 218},
	/*II_C7_00*/ {0xda, 218},
	/*II_D0_00*/ {0xdb, 967},
	/*II_D0_01*/ {0xdb, 972},
	/*II_D0_02*/ {0xdc, 977},
	/*II_D0_03*/ {0xdc, 982},
	/*II_D0_04*/ {0xdd, 987},
	/*II_D0_05*/ {0xdd, 992},
	/*II_D0_06*/ {0xde, 997},
	/*II_D0_07*/ {0xde, 1002},
	/*II_D1_00*/ {0xdf, 967},
	/*II_D1_01*/ {0xdf, 972},
	/*II_D1_02*/ {0xe0, 977},
	/*II_D1_03*/ {0xe0, 982},
	/*II_D1_04*/ {0xe1, 987},
	/*II_D1_05*/ {0xe1, 992},
	/*II_D1_06*/ {0xe2, 997},
	/*II_D1_07*/ {0xe2, 1002},
	/*II_D2_00*/ {0xe3, 967},
	/*II_D2_01*/ {0xe3, 972},
	/*II_D2_02*/ {0xe4, 977},
	/*II_D2_03*/ {0xe4, 982},
	/*II_D2_04*/ {0xe5, 987},
	/*II_D2_05*/ {0xe5, 992},
	/*II_D2_06*/ {0xe6, 997},
	/*II_D2_07*/ {0xe6, 1002},
	/*II_D3_00*/ {0xe7, 967},
	/*II_D3_01*/ {0xe7, 972},
	/*II_D3_02*/ {0xe8, 977},
	/*II_D3_03*/ {0xe8, 982},
	/*II_D3_04*/ {0xe9, 987},
	/*II_D3_05*/ {0xe9, 992},
	/*II_D3_06*/ {0xea, 997},
	/*II_D3_07*/ {0xea, 1002},
	/*II_D8_00*/ {0xeb, 1007},
	/*II_D8_01*/ {0xeb, 1013},
	/*II_D8_02*/ {0xeb, 1019},
	/*II_D8_03*/ {0xeb, 1025},
	/*II_D8_04*/ {0xeb, 1032},
	/*II_D8_05*/ {0xeb, 1038},
	/*II_D8_06*/ {0xeb, 1045},
	/*II_D8_07*/ {0xeb, 1051},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C0*/ {0xec, 1007},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_C8*/ {0xec, 1013},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D0*/ {0xed, 1019},
	/*II_D8_D8*/ {0xed, 1025},
	/*II_D8_D9*/ {0xee, 1025},
	/*II_D8_D8*/ {0xed, 1025},
	/*II_D8_D8*/ {0xed, 1025},
	/*II_D8_D8*/ {0xed, 1025},
	/*II_D8_D8*/ {0xed, 1025},
	/*II_D8_D8*/ {0xed, 1025},
	/*II_D8_D8*/ {0xed, 1025},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E0*/ {0xec, 1032},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_E8*/ {0xec, 1038},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F0*/ {0xec, 1045},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D8_F8*/ {0xec, 1051},
	/*II_D9_00*/ {0xeb, 1058},
	/*II_D9_02*/ {0xeb, 1063},
	/*II_D9_03*/ {0xeb, 1068},
	/*II_D9_04*/ {0xef, 1074},
	/*II_D9_05*/ {0xef, 1082},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C0*/ {0xed, 1058},
	/*II_D9_C8*/ {0xed, 1089},
	/*II_D9_C9*/ {0xee, 1089},
	/*II_D9_C8*/ {0xed, 1089},
	/*II_D9_C8*/ {0xed, 1089},
	/*II_D9_C8*/ {0xed, 1089},
	/*II_D9_C8*/ {0xed, 1089},
	/*II_D9_C8*/ {0xed, 1089},
	/*II_D9_C8*/ {0xed, 1089},
	/*II_D9_D0*/ {0xee, 1095},
	/*II_D9_E0*/ {0xee, 1101},
	/*II_D9_E1*/ {0xee, 1107},
	/*II_D9_E4*/ {0xee, 1113},
	/*II_D9_E5*/ {0xee, 1119},
	/*II_D9_E8*/ {0xee, 1125},
	/*II_D9_E9*/ {0xee, 1131},
	/*II_D9_EA*/ {0xee, 1139},
	/*II_D9_EB*/ {0xee, 1147},
	/*II_D9_EC*/ {0xee, 1154},
	/*II_D9_ED*/ {0xee, 1162},
	/*II_D9_EE*/ {0xee, 1170},
	/*II_D9_F0*/ {0xee, 1176},
	/*II_D9_F1*/ {0xee, 1183},
	/*II_D9_F2*/ {0xee, 1190},
	/*II_D9_F3*/ {0xee, 1197},
	/*II_D9_F4*/ {0xee, 1205},
	/*II_D9_F5*/ {0xee, 1214},
	/*II_D9_F6*/ {0xee, 1222},
	/*II_D9_F7*/ {0xee, 1231},
	/*II_D9_F8*/ {0xee, 1240},
	/*II_D9_F9*/ {0xee, 1247},
	/*II_D9_FA*/ {0xee, 1256},
	/*II_D9_FB*/ {0xee, 1263},
	/*II_D9_FC*/ {0xee, 1272},
	/*II_D9_FD*/ {0xee, 1281},
	/*II_D9_FE*/ {0xee, 1289},
	/*II_D9_FF*/ {0xee, 1295},
	/*II_DA_00*/ {0xeb, 1301},
	/*II_DA_01*/ {0xeb, 1308},
	/*II_DA_02*/ {0xeb, 1315},
	/*II_DA_03*/ {0xeb, 1322},
	/*II_DA_04*/ {0xeb, 1330},
	/*II_DA_05*/ {0xeb, 1337},
	/*II_DA_06*/ {0xeb, 1345},
	/*II_DA_07*/ {0xeb, 1352},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C0*/ {0xf0, 1360},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_C8*/ {0xf1, 1368},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D0*/ {0xf2, 1376},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_D8*/ {0xf3, 1385},
	/*II_DA_E9*/ {0xee, 1393},
	/*II_DB_00*/ {0xeb, 1402},
	/*II_DB_01*/ {0xf4, 1408},
	/*II_DB_02*/ {0xeb, 1416},
	/*II_DB_03*/ {0xeb, 1422},
	/*II_DB_05*/ {0xf5, 1058},
	/*II_DB_07*/ {0xf5, 1068},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C0*/ {0xf0, 1429},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_C8*/ {0xf1, 1438},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D0*/ {0xf2, 1447},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_D8*/ {0xf3, 1457},
	/*II_DB_E0*/ {0xee, 1466},
	/*II_DB_E1*/ {0xee, 1472},
	/*II_DB_E4*/ {0xee, 1480},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_E8*/ {0xf6, 1488},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DB_F0*/ {0xf7, 1496},
	/*II_DC_00*/ {0xf8, 1007},
	/*II_DC_01*/ {0xf8, 1013},
	/*II_DC_02*/ {0xf8, 1019},
	/*II_DC_03*/ {0xf8, 1025},
	/*II_DC_04*/ {0xf8, 1032},
	/*II_DC_05*/ {0xf8, 1038},
	/*II_DC_06*/ {0xf8, 1045},
	/*II_DC_07*/ {0xf8, 1051},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C0*/ {0xf9, 1007},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_C8*/ {0xf9, 1013},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E0*/ {0xf9, 1038},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_E8*/ {0xf9, 1032},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F0*/ {0xf9, 1051},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DC_F8*/ {0xf9, 1045},
	/*II_DD_00*/ {0xf8, 1058},
	/*II_DD_01*/ {0xfa, 1408},
	/*II_DD_02*/ {0xf8, 1063},
	/*II_DD_03*/ {0xf8, 1068},
	/*II_DD_04*/ {0xef, 1503},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_C0*/ {0xed, 1511},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D0*/ {0xed, 1063},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_D8*/ {0xed, 1068},
	/*II_DD_E0*/ {0xf9, 1518},
	/*II_DD_E1*/ {0xee, 1518},
	/*II_DD_E0*/ {0xf9, 1518},
	/*II_DD_E0*/ {0xf9, 1518},
	/*II_DD_E0*/ {0xf9, 1518},
	/*II_DD_E0*/ {0xf9, 1518},
	/*II_DD_E0*/ {0xf9, 1518},
	/*II_DD_E0*/ {0xf9, 1518},
	/*II_DD_E8*/ {0xed, 1525},
	/*II_DD_E9*/ {0xee, 1525},
	/*II_DD_E8*/ {0xed, 1525},
	/*II_DD_E8*/ {0xed, 1525},
	/*II_DD_E8*/ {0xed, 1525},
	/*II_DD_E8*/ {0xed, 1525},
	/*II_DD_E8*/ {0xed, 1525},
	/*II_DD_E8*/ {0xed, 1525},
	/*II_DE_00*/ {0xfb, 1301},
	/*II_DE_01*/ {0xfb, 1308},
	/*II_DE_02*/ {0xfb, 1315},
	/*II_DE_03*/ {0xfb, 1322},
	/*II_DE_04*/ {0xfb, 1330},
	/*II_DE_05*/ {0xfb, 1337},
	/*II_DE_06*/ {0xfb, 1345},
	/*II_DE_07*/ {0xfb, 1352},
	/*II_DE_C0*/ {0xf9, 1533},
	/*II_DE_C1*/ {0xee, 1533},
	/*II_DE_C0*/ {0xf9, 1533},
	/*II_DE_C0*/ {0xf9, 1533},
	/*II_DE_C0*/ {0xf9, 1533},
	/*II_DE_C0*/ {0xf9, 1533},
	/*II_DE_C0*/ {0xf9, 1533},
	/*II_DE_C0*/ {0xf9, 1533},
	/*II_DE_C8*/ {0xf9, 1540},
	/*II_DE_C9*/ {0xee, 1540},
	/*II_DE_C8*/ {0xf9, 1540},
	/*II_DE_C8*/ {0xf9, 1540},
	/*II_DE_C8*/ {0xf9, 1540},
	/*II_DE_C8*/ {0xf9, 1540},
	/*II_DE_C8*/ {0xf9, 1540},
	/*II_DE_C8*/ {0xf9, 1540},
	/*II_DE_D9*/ {0xee, 1547},
	/*II_DE_E0*/ {0xf9, 1555},
	/*II_DE_E1*/ {0xee, 1555},
	/*II_DE_E0*/ {0xf9, 1555},
	/*II_DE_E0*/ {0xf9, 1555},
	/*II_DE_E0*/ {0xf9, 1555},
	/*II_DE_E0*/ {0xf9, 1555},
	/*II_DE_E0*/ {0xf9, 1555},
	/*II_DE_E0*/ {0xf9, 1555},
	/*II_DE_E8*/ {0xf9, 1563},
	/*II_DE_E9*/ {0xee, 1563},
	/*II_DE_E8*/ {0xf9, 1563},
	/*II_DE_E8*/ {0xf9, 1563},
	/*II_DE_E8*/ {0xf9, 1563},
	/*II_DE_E8*/ {0xf9, 1563},
	/*II_DE_E8*/ {0xf9, 1563},
	/*II_DE_E8*/ {0xf9, 1563},
	/*II_DE_F0*/ {0xf9, 1570},
	/*II_DE_F1*/ {0xee, 1570},
	/*II_DE_F0*/ {0xf9, 1570},
	/*II_DE_F0*/ {0xf9, 1570},
	/*II_DE_F0*/ {0xf9, 1570},
	/*II_DE_F0*/ {0xf9, 1570},
	/*II_DE_F0*/ {0xf9, 1570},
	/*II_DE_F0*/ {0xf9, 1570},
	/*II_DE_F8*/ {0xf9, 1578},
	/*II_DE_F9*/ {0xee, 1578},
	/*II_DE_F8*/ {0xf9, 1578},
	/*II_DE_F8*/ {0xf9, 1578},
	/*II_DE_F8*/ {0xf9, 1578},
	/*II_DE_F8*/ {0xf9, 1578},
	/*II_DE_F8*/ {0xf9, 1578},
	/*II_DE_F8*/ {0xf9, 1578},
	/*II_DF_00*/ {0xfb, 1402},
	/*II_DF_01*/ {0xfc, 1408},
	/*II_DF_02*/ {0xfb, 1416},
	/*II_DF_03*/ {0xfb, 1422},
	/*II_DF_04*/ {0xf5, 1585},
	/*II_DF_05*/ {0xf8, 1402},
	/*II_DF_06*/ {0xf5, 1591},
	/*II_DF_07*/ {0xf8, 1422},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_E8*/ {0xf6, 1598},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_DF_F0*/ {0xf6, 1607},
	/*II_F6_00*/ {0xfd, 206},
	/*II_F6_02*/ {0xfe, 1615},
	/*II_F6_03*/ {0xff, 1620},
	/*II_F6_04*/ {0x100, 1625},
	/*II_F6_05*/ {0x100, 117},
	/*II_F6_06*/ {0x101, 1630},
	/*II_F6_07*/ {0x101, 1635},
	/*II_F7_00*/ {0x102, 206},
	/*II_F7_02*/ {0x103, 1615},
	/*II_F7_03*/ {0x104, 1620},
	/*II_F7_04*/ {0x105, 1625},
	/*II_F7_05*/ {0x105, 117},
	/*II_F7_06*/ {0x106, 1630},
	/*II_F7_07*/ {0x106, 1635},
	/*II_FE_00*/ {0x107, 81},
	/*II_FE_01*/ {0x107, 86},
	/*II_FF_00*/ {0x108, 81},
	/*II_FF_01*/ {0x108, 86},
	/*II_FF_02*/ {0x109, 456},
	/*II_FF_03*/ {0x10a, 260},
	/*II_FF_04*/ {0x10b, 462},
	/*II_FF_05*/ {0x10c, 467},
	/*II_FF_06*/ {0x10d, 16},
	/*II_0F_00_00*/ {0x10e, 1641},
	/*II_0F_00_01*/ {0x10f, 1647},
	/*II_0F_00_02*/ {0x10f, 1652},
	/*II_0F_00_03*/ {0x110, 1658},
	/*II_0F_00_04*/ {0x111, 1663},
	/*II_0F_00_05*/ {0x111, 1669},
	/*II_0F_01_00*/ {0x112, 1675},
	/*II_0F_01_01*/ {0x112, 1681},
	/*II_0F_01_02*/ {0x112, 1687},
	/*II_0F_01_03*/ {0x112, 1693},
	/*II_0F_01_04*/ {0x113, 1699},
	/*II_0F_01_06*/ {0x114, 1705},
	/*II_0F_01_07*/ {0x115, 1711},
	/*II_0F_01_C1*/ {0x116, 1719},
	/*II_0F_01_C2*/ {0x116, 1727},
	/*II_0F_01_C3*/ {0x116, 1737},
	/*II_0F_01_C4*/ {0x116, 1747},
	/*II_0F_01_C8*/ {0x117, 1755},
	/*II_0F_01_C9*/ {0x117, 1764},
	/*II_0F_01_D0*/ {0x88, 1771},
	/*II_0F_01_D1*/ {0x88, 1779},
	/*II_0F_01_D4*/ {0x116, 1787},
	/*II_0F_01_D8*/ {0x118, 1795},
	/*II_0F_01_D9*/ {0x119, 1802},
	/*II_0F_01_DA*/ {0x11a, 1811},
	/*II_0F_01_DB*/ {0x11a, 1819},
	/*II_0F_01_DC*/ {0x119, 1827},
	/*II_0F_01_DD*/ {0x119, 1833},
	/*II_0F_01_DE*/ {0x11a, 1839},
	/*II_0F_01_DF*/ {0x11b, 1847},
	/*II_0F_01_F8*/ {0x11c, 1856},
	/*II_0F_01_F9*/ {0x11c, 1864},
	/*II_0F_0D_00*/ {0x11d, 1872},
	/*II_0F_0D_01*/ {0x11d, 1882},
	/*II_0F_0F_0C*/ {0x11e, 1893},
	/*II_0F_0F_0D*/ {0x11f, 1900},
	/*II_0F_0F_1C*/ {0x11e, 1907},
	/*II_0F_0F_1D*/ {0x11f, 1914},
	/*II_0F_0F_8A*/ {0x11e, 1921},
	/*II_0F_0F_8E*/ {0x11e, 1929},
	/*II_0F_0F_90*/ {0x11f, 1938},
	/*II_0F_0F_94*/ {0x11f, 1947},
	/*II_0F_0F_96*/ {0x11f, 1954},
	/*II_0F_0F_97*/ {0x11f, 1961},
	/*II_0F_0F_9A*/ {0x11f, 1970},
	/*II_0F_0F_9E*/ {0x11f, 1977},
	/*II_0F_0F_A0*/ {0x11f, 1984},
	/*II_0F_0F_A4*/ {0x11f, 1993},
	/*II_0F_0F_A6*/ {0x11f, 2000},
	/*II_0F_0F_A7*/ {0x11f, 2010},
	/*II_0F_0F_AA*/ {0x11f, 2020},
	/*II_0F_0F_AE*/ {0x11f, 2028},
	/*II_0F_0F_B0*/ {0x11f, 2035},
	/*II_0F_0F_B4*/ {0x11f, 2044},
	/*II_0F_0F_B6*/ {0x11f, 2051},
	/*II_0F_0F_B7*/ {0x11f, 2061},
	/*II_0F_0F_BB*/ {0x11e, 2070},
	/*II_0F_0F_BF*/ {0x11f, 2078},
	/*II_0F_10*/ {0x120, 2087},
	/*II_66_0F_10*/ {0x121, 2095},
	/*II_F3_0F_10*/ {0x122, 2103},
	/*II_F2_0F_10*/ {0x123, 2110},
	/*II_0F_11*/ {0x128, 2087},
	/*II_66_0F_11*/ {0x129, 2095},
	/*II_F3_0F_11*/ {0x12a, 2103},
	/*II_F2_0F_11*/ {0x12b, 2110},
	/*II_66_0F_12*/ {0x130, 2168},
	/*II_F3_0F_12*/ {0x131, 2176},
	/*II_F2_0F_12*/ {0x131, 2186},
	/*II_0F_13*/ {0x135, 2160},
	/*II_66_0F_13*/ {0x136, 2168},
	/*II_0F_14*/ {0x138, 2244},
	/*II_66_0F_14*/ {0x139, 2254},
	/*II_0F_15*/ {0x138, 2286},
	/*II_66_0F_15*/ {0x139, 2296},
	/*II_66_0F_16*/ {0x130, 2345},
	/*II_F3_0F_16*/ {0x13b, 2353},
	/*II_0F_17*/ {0x135, 2337},
	/*II_66_0F_17*/ {0x136, 2345},
	/*II_0F_18_00*/ {0x13c, 2402},
	/*II_0F_18_01*/ {0x13c, 2415},
	/*II_0F_18_02*/ {0x13c, 2427},
	/*II_0F_18_03*/ {0x13c, 2439},
	/*II_0F_28*/ {0x120, 2451},
	/*II_66_0F_28*/ {0x121, 2459},
	/*II_0F_29*/ {0x128, 2451},
	/*II_66_0F_29*/ {0x129, 2459},
	/*II_0F_2A*/ {0x13d, 2485},
	/*II_66_0F_2A*/ {0x13e, 2495},
	/*II_F3_0F_2A*/ {0x13f, 2505},
	/*II_F2_0F_2A*/ {0x140, 2515},
	/*II_0F_2B*/ {0x141, 2547},
	/*II_66_0F_2B*/ {0x142, 2556},
	/*II_F3_0F_2B*/ {0x143, 2565},
	/*II_F2_0F_2B*/ {0x144, 2574},
	/*II_0F_2C*/ {0x146, 2603},
	/*II_66_0F_2C*/ {0x147, 2614},
	/*II_F3_0F_2C*/ {0x148, 2625},
	/*II_F2_0F_2C*/ {0x149, 2636},
	/*II_0F_2D*/ {0x146, 2671},
	/*II_66_0F_2D*/ {0x139, 2681},
	/*II_F3_0F_2D*/ {0x148, 2691},
	/*II_F2_0F_2D*/ {0x149, 2701},
	/*II_0F_2E*/ {0x14b, 2733},
	/*II_66_0F_2E*/ {0x14c, 2742},
	/*II_0F_2F*/ {0x14b, 2771},
	/*II_66_0F_2F*/ {0x14c, 2779},
	/*II_0F_50*/ {0x14f, 2805},
	/*II_66_0F_50*/ {0x150, 2815},
	/*II_0F_51*/ {0x138, 2847},
	/*II_66_0F_51*/ {0x139, 2855},
	/*II_F3_0F_51*/ {0x152, 2863},
	/*II_F2_0F_51*/ {0x14c, 2871},
	/*II_0F_52*/ {0x138, 2915},
	/*II_F3_0F_52*/ {0x152, 2924},
	/*II_0F_53*/ {0x138, 2953},
	/*II_F3_0F_53*/ {0x152, 2960},
	/*II_0F_54*/ {0x138, 2983},
	/*II_66_0F_54*/ {0x139, 2990},
	/*II_0F_55*/ {0x138, 3013},
	/*II_66_0F_55*/ {0x139, 3021},
	/*II_0F_56*/ {0x138, 3047},
	/*II_66_0F_56*/ {0x139, 3053},
	/*II_0F_57*/ {0x138, 3073},
	/*II_66_0F_57*/ {0x139, 3080},
	/*II_0F_58*/ {0x138, 3103},
	/*II_66_0F_58*/ {0x139, 3110},
	/*II_F3_0F_58*/ {0x152, 3117},
	/*II_F2_0F_58*/ {0x14c, 3124},
	/*II_0F_59*/ {0x138, 3163},
	/*II_66_0F_59*/ {0x139, 3170},
	/*II_F3_0F_59*/ {0x152, 3177},
	/*II_F2_0F_59*/ {0x14c, 3184},
	/*II_0F_5A*/ {0x14c, 3223},
	/*II_66_0F_5A*/ {0x139, 3233},
	/*II_F3_0F_5A*/ {0x153, 3243},
	/*II_F2_0F_5A*/ {0x14c, 3253},
	/*II_0F_5B*/ {0x139, 3307},
	/*II_66_0F_5B*/ {0x139, 3317},
	/*II_F3_0F_5B*/ {0x139, 3327},
	/*II_0F_5C*/ {0x138, 3372},
	/*II_66_0F_5C*/ {0x139, 3379},
	/*II_F3_0F_5C*/ {0x152, 3386},
	/*II_F2_0F_5C*/ {0x14c, 3393},
	/*II_0F_5D*/ {0x138, 3432},
	/*II_66_0F_5D*/ {0x139, 3439},
	/*II_F3_0F_5D*/ {0x152, 3446},
	/*II_F2_0F_5D*/ {0x14c, 3453},
	/*II_0F_5E*/ {0x138, 3492},
	/*II_66_0F_5E*/ {0x139, 3499},
	/*II_F3_0F_5E*/ {0x152, 3506},
	/*II_F2_0F_5E*/ {0x14c, 3513},
	/*II_0F_5F*/ {0x138, 3552},
	/*II_66_0F_5F*/ {0x139, 3559},
	/*II_F3_0F_5F*/ {0x152, 3566},
	/*II_F2_0F_5F*/ {0x14c, 3573},
	/*II_0F_60*/ {0x156, 3612},
	/*II_66_0F_60*/ {0x139, 3612},
	/*II_0F_61*/ {0x156, 3635},
	/*II_66_0F_61*/ {0x139, 3635},
	/*II_0F_62*/ {0x156, 3658},
	/*II_66_0F_62*/ {0x139, 3658},
	/*II_0F_63*/ {0x157, 3681},
	/*II_66_0F_63*/ {0x139, 3681},
	/*II_0F_64*/ {0x157, 3702},
	/*II_66_0F_64*/ {0x139, 3702},
	/*II_0F_65*/ {0x157, 3721},
	/*II_66_0F_65*/ {0x139, 3721},
	/*II_0F_66*/ {0x157, 3740},
	/*II_66_0F_66*/ {0x139, 3740},
	/*II_0F_67*/ {0x157, 3759},
	/*II_66_0F_67*/ {0x139, 3759},
	/*II_0F_68*/ {0x157, 3780},
	/*II_66_0F_68*/ {0x139, 3780},
	/*II_0F_69*/ {0x157, 3803},
	/*II_66_0F_69*/ {0x139, 3803},
	/*II_0F_6A*/ {0x157, 3826},
	/*II_66_0F_6A*/ {0x139, 3826},
	/*II_0F_6B*/ {0x157, 3849},
	/*II_66_0F_6B*/ {0x139, 3849},
	/*II_66_0F_6C*/ {0x139, 3870},
	/*II_66_0F_6D*/ {0x139, 3895},
	/*II_0F_6F*/ {0x15b, 3926},
	/*II_66_0F_6F*/ {0x121, 3946},
	/*II_F3_0F_6F*/ {0x121, 3954},
	/*II_0F_74*/ {0x157, 4043},
	/*II_66_0F_74*/ {0x139, 4043},
	/*II_0F_75*/ {0x157, 4062},
	/*II_66_0F_75*/ {0x139, 4062},
	/*II_0F_76*/ {0x157, 4081},
	/*II_66_0F_76*/ {0x139, 4081},
	/*II_0F_77*/ {0x15f, 4100},
	/*II_0F_78*/ {0x161, 4128},
	/*II_0F_79*/ {0x164, 4152},
	/*II_66_0F_79*/ {0x165, 4136},
	/*II_F2_0F_79*/ {0x166, 4143},
	/*II_0F_7A_30*/ {0x167, 4161},
	/*II_0F_7A_31*/ {0x168, 4171},
	/*II_66_0F_7C*/ {0x169, 4181},
	/*II_F2_0F_7C*/ {0x169, 4189},
	/*II_66_0F_7D*/ {0x169, 4215},
	/*II_F2_0F_7D*/ {0x169, 4223},
	/*II_F3_0F_7E*/ {0x123, 3926},
	/*II_0F_7F*/ {0x16d, 3926},
	/*II_66_0F_7F*/ {0x129, 3946},
	/*II_F3_0F_7F*/ {0x129, 3954},
	/*II_F3_0F_B8*/ {0x171, 4338},
	/*II_0F_BA_04*/ {0x172, 872},
	/*II_0F_BA_05*/ {0x173, 887},
	/*II_0F_BA_06*/ {0x173, 912},
	/*II_0F_BA_07*/ {0x173, 934},
	/*II_0F_BC*/ {0x174, 4346},
	/*II_F3_0F_BC*/ {0x175, 4351},
	/*II_0F_BD*/ {0x174, 4358},
	/*II_F3_0F_BD*/ {0x176, 4363},
	/*II_0F_C7_07*/ {0x186, 6385},
	/*II_66_0F_D0*/ {0x169, 6394},
	/*II_F2_0F_D0*/ {0x169, 6404},
	/*II_0F_D1*/ {0x157, 6436},
	/*II_66_0F_D1*/ {0x139, 6436},
	/*II_0F_D2*/ {0x157, 6451},
	/*II_66_0F_D2*/ {0x139, 6451},
	/*II_0F_D3*/ {0x157, 6466},
	/*II_66_0F_D3*/ {0x139, 6466},
	/*II_0F_D4*/ {0x14c, 6481},
	/*II_66_0F_D4*/ {0x139, 6481},
	/*II_0F_D5*/ {0x157, 6496},
	/*II_66_0F_D5*/ {0x139, 6496},
	/*II_66_0F_D6*/ {0x12b, 3926},
	/*II_F3_0F_D6*/ {0x187, 6513},
	/*II_F2_0F_D6*/ {0x188, 6522},
	/*II_0F_D7*/ {0x18a, 6531},
	/*II_66_0F_D7*/ {0x18b, 6531},
	/*II_0F_D8*/ {0x157, 6552},
	/*II_66_0F_D8*/ {0x139, 6552},
	/*II_0F_D9*/ {0x157, 6571},
	/*II_66_0F_D9*/ {0x139, 6571},
	/*II_0F_DA*/ {0x18d, 6590},
	/*II_66_0F_DA*/ {0x139, 6590},
	/*II_0F_DB*/ {0x157, 6607},
	/*II_66_0F_DB*/ {0x139, 6607},
	/*II_0F_DC*/ {0x157, 6620},
	/*II_66_0F_DC*/ {0x139, 6620},
	/*II_0F_DD*/ {0x157, 6639},
	/*II_66_0F_DD*/ {0x139, 6639},
	/*II_0F_DE*/ {0x18d, 6648},
	/*II_66_0F_DE*/ {0x139, 6648},
	/*II_0F_DF*/ {0x157, 6665},
	/*II_66_0F_DF*/ {0x139, 6665},
	/*II_0F_E0*/ {0x18d, 6680},
	/*II_66_0F_E0*/ {0x139, 6680},
	/*II_0F_E1*/ {0x157, 6695},
	/*II_66_0F_E1*/ {0x139, 6695},
	/*II_0F_E2*/ {0x157, 6710},
	/*II_66_0F_E2*/ {0x139, 6710},
	/*II_0F_E3*/ {0x18d, 6725},
	/*II_66_0F_E3*/ {0x139, 6725},
	/*II_0F_E4*/ {0x18d, 6740},
	/*II_66_0F_E4*/ {0x139, 6740},
	/*II_0F_E5*/ {0x157, 6759},
	/*II_66_0F_E5*/ {0x139, 6759},
	/*II_66_0F_E6*/ {0x139, 6776},
	/*II_F3_0F_E6*/ {0x14c, 6787},
	/*II_F2_0F_E6*/ {0x139, 6797},
	/*II_0F_E7*/ {0x18e, 6841},
	/*II_66_0F_E7*/ {0x142, 6849},
	/*II_0F_E8*/ {0x157, 6868},
	/*II_66_0F_E8*/ {0x139, 6868},
	/*II_0F_E9*/ {0x157, 6885},
	/*II_66_0F_E9*/ {0x139, 6885},
	/*II_0F_EA*/ {0x18d, 6902},
	/*II_66_0F_EA*/ {0x139, 6902},
	/*II_0F_EB*/ {0x157, 6919},
	/*II_66_0F_EB*/ {0x139, 6919},
	/*II_0F_EC*/ {0x157, 6930},
	/*II_66_0F_EC*/ {0x139, 6930},
	/*II_0F_ED*/ {0x157, 6947},
	/*II_66_0F_ED*/ {0x139, 6947},
	/*II_0F_EE*/ {0x18d, 6964},
	/*II_66_0F_EE*/ {0x139, 6964},
	/*II_0F_EF*/ {0x157, 6981},
	/*II_66_0F_EF*/ {0x139, 6981},
	/*II_F2_0F_F0*/ {0x18f, 6994},
	/*II_0F_F1*/ {0x157, 7009},
	/*II_66_0F_F1*/ {0x139, 7009},
	/*II_0F_F2*/ {0x157, 7024},
	/*II_66_0F_F2*/ {0x139, 7024},
	/*II_0F_F3*/ {0x157, 7039},
	/*II_66_0F_F3*/ {0x139, 7039},
	/*II_0F_F4*/ {0x191, 7054},
	/*II_66_0F_F4*/ {0x139, 7054},
	/*II_0F_F5*/ {0x157, 7073},
	/*II_66_0F_F5*/ {0x139, 7073},
	/*II_0F_F6*/ {0x18d, 7092},
	/*II_66_0F_F6*/ {0x139, 7092},
	/*II_0F_F7*/ {0x192, 7109},
	/*II_66_0F_F7*/ {0x193, 7119},
	/*II_0F_F8*/ {0x157, 7144},
	/*II_66_0F_F8*/ {0x139, 7144},
	/*II_0F_F9*/ {0x157, 7159},
	/*II_66_0F_F9*/ {0x139, 7159},
	/*II_0F_FA*/ {0x157, 7174},
	/*II_66_0F_FA*/ {0x139, 7174},
	/*II_0F_FB*/ {0x191, 7189},
	/*II_66_0F_FB*/ {0x139, 7189},
	/*II_0F_FC*/ {0x157, 7204},
	/*II_66_0F_FC*/ {0x139, 7204},
	/*II_0F_FD*/ {0x157, 7219},
	/*II_66_0F_FD*/ {0x139, 7219},
	/*II_0F_FE*/ {0x157, 7234},
	/*II_66_0F_FE*/ {0x139, 7234},
	/*II_D9_06*/ {0xef, 7249},
	/*II_9B_D9_06*/ {0x195, 7258},
	/*II_D9_07*/ {0xef, 7266},
	/*II_9B_D9_07*/ {0x195, 7274},
	/*II_DB_E2*/ {0xee, 7281},
	/*II_9B_DB_E2*/ {0x196, 7289},
	/*II_DB_E3*/ {0xee, 7296},
	/*II_9B_DB_E3*/ {0x196, 7304},
	/*II_DD_06*/ {0xef, 7311},
	/*II_9B_DD_06*/ {0x195, 7319},
	/*II_DD_07*/ {0xef, 7326},
	/*II_9B_DD_07*/ {0x195, 7334},
	/*II_DF_E0*/ {0x197, 7326},
	/*II_9B_DF_E0*/ {0x198, 7334},
	/*II_0F_38_00*/ {0x199, 7341},
	/*II_66_0F_38_00*/ {0x19a, 7341},
	/*II_0F_38_01*/ {0x199, 7358},
	/*II_66_0F_38_01*/ {0x19a, 7358},
	/*II_0F_38_02*/ {0x199, 7375},
	/*II_66_0F_38_02*/ {0x19a, 7375},
	/*II_0F_38_03*/ {0x199, 7392},
	/*II_66_0F_38_03*/ {0x19a, 7392},
	/*II_0F_38_04*/ {0x199, 7411},
	/*II_66_0F_38_04*/ {0x19a, 7411},
	/*II_0F_38_05*/ {0x199, 7434},
	/*II_66_0F_38_05*/ {0x19a, 7434},
	/*II_0F_38_06*/ {0x199, 7451},
	/*II_66_0F_38_06*/ {0x19a, 7451},
	/*II_0F_38_07*/ {0x199, 7468},
	/*II_66_0F_38_07*/ {0x19a, 7468},
	/*II_0F_38_08*/ {0x199, 7487},
	/*II_66_0F_38_08*/ {0x19a, 7487},
	/*II_0F_38_09*/ {0x199, 7504},
	/*II_66_0F_38_09*/ {0x19a, 7504},
	/*II_0F_38_0A*/ {0x199, 7521},
	/*II_66_0F_38_0A*/ {0x19a, 7521},
	/*II_0F_38_0B*/ {0x199, 7538},
	/*II_66_0F_38_0B*/ {0x19a, 7538},
	/*II_66_0F_38_17*/ {0x19c, 7629},
	/*II_0F_38_1C*/ {0x199, 7688},
	/*II_66_0F_38_1C*/ {0x19a, 7688},
	/*II_0F_38_1D*/ {0x199, 7703},
	/*II_66_0F_38_1D*/ {0x19a, 7703},
	/*II_0F_38_1E*/ {0x199, 7718},
	/*II_66_0F_38_1E*/ {0x19a, 7718},
	/*II_66_0F_38_20*/ {0x1a1, 7733},
	/*II_66_0F_38_21*/ {0x1a2, 7754},
	/*II_66_0F_38_22*/ {0x1a3, 7775},
	/*II_66_0F_38_23*/ {0x1a1, 7796},
	/*II_66_0F_38_24*/ {0x1a2, 7817},
	/*II_66_0F_38_25*/ {0x1a1, 7838},
	/*II_66_0F_38_28*/ {0x1a5, 7859},
	/*II_66_0F_38_29*/ {0x1a5, 7876},
	/*II_66_0F_38_2A*/ {0x1a6, 7895},
	/*II_66_0F_38_2B*/ {0x1a5, 7916},
	/*II_66_0F_38_30*/ {0x1a1, 7961},
	/*II_66_0F_38_31*/ {0x1a2, 7982},
	/*II_66_0F_38_32*/ {0x1a3, 8003},
	/*II_66_0F_38_33*/ {0x1a1, 8024},
	/*II_66_0F_38_34*/ {0x1a2, 8045},
	/*II_66_0F_38_35*/ {0x1a1, 8066},
	/*II_66_0F_38_37*/ {0x19c, 8087},
	/*II_66_0F_38_38*/ {0x1a5, 8106},
	/*II_66_0F_38_39*/ {0x1a5, 8123},
	/*II_66_0F_38_3A*/ {0x1a5, 8140},
	/*II_66_0F_38_3B*/ {0x1a5, 8157},
	/*II_66_0F_38_3C*/ {0x1a5, 8174},
	/*II_66_0F_38_3D*/ {0x1a5, 8191},
	/*II_66_0F_38_3E*/ {0x1a5, 8208},
	/*II_66_0F_38_3F*/ {0x1a5, 8225},
	/*II_66_0F_38_40*/ {0x1a5, 8242},
	/*II_66_0F_38_41*/ {0x1a5, 8259},
	/*II_66_0F_38_80*/ {0x1a9, 8284},
	/*II_66_0F_38_81*/ {0x1a9, 8292},
	/*II_66_0F_38_82*/ {0x1a9, 8301},
	/*II_66_0F_38_DB*/ {0x1ac, 9150},
	/*II_66_0F_38_DC*/ {0x1ac, 9167},
	/*II_66_0F_38_DD*/ {0x1ac, 9184},
	/*II_66_0F_38_DE*/ {0x1ac, 9209},
	/*II_66_0F_38_DF*/ {0x1ac, 9226},
	/*II_0F_38_F0*/ {0x1af, 9251},
	/*II_F2_0F_38_F0*/ {0x1b0, 9258},
	/*II_0F_38_F1*/ {0x1b1, 9251},
	/*II_F2_0F_38_F1*/ {0x1b2, 9258},
	/*II_0F_71_02*/ {0x1c9, 6436},
	/*II_66_0F_71_02*/ {0x1ca, 6436},
	/*II_0F_71_04*/ {0x1c9, 6695},
	/*II_66_0F_71_04*/ {0x1ca, 6695},
	/*II_0F_71_06*/ {0x1c9, 7009},
	/*II_66_0F_71_06*/ {0x1ca, 7009},
	/*II_0F_72_02*/ {0x1c9, 6451},
	/*II_66_0F_72_02*/ {0x1ca, 6451},
	/*II_0F_72_04*/ {0x1c9, 6710},
	/*II_66_0F_72_04*/ {0x1ca, 6710},
	/*II_0F_72_06*/ {0x1c9, 7024},
	/*II_66_0F_72_06*/ {0x1ca, 7024},
	/*II_0F_73_02*/ {0x1c9, 6466},
	/*II_66_0F_73_02*/ {0x1ca, 6466},
	/*II_66_0F_73_03*/ {0x1ca, 9830},
	/*II_0F_73_06*/ {0x1c9, 7039},
	/*II_66_0F_73_06*/ {0x1ca, 7039},
	/*II_66_0F_73_07*/ {0x1ca, 9847},
	/*II_F3_0F_AE_00*/ {0x1cc, 9882},
	/*II_F3_0F_AE_01*/ {0x1cc, 9912},
	/*II_0F_AE_02*/ {0x115, 9922},
	/*II_F3_0F_AE_02*/ {0x1cc, 9931},
	/*II_0F_AE_03*/ {0x115, 9951},
	/*II_F3_0F_AE_03*/ {0x1cc, 9960},
	/*II_66_0F_C7_06*/ {0x186, 9997},
	/*II_F3_0F_C7_06*/ {0x186, 10006}
};

_InstInfoEx InstInfosEx[382] = {
	/*II_69*/ {0x34, 117, 0x0, 3, 0, 0, 0},
	/*II_6B*/ {0x34, 117, 0x0, 5, 0, 0, 0},
	/*II_98*/ {0x4e, 228, 0x0, 0, 0, 233, 239},
	/*II_99*/ {0x4e, 245, 0x0, 0, 0, 250, 255},
	/*II_E3*/ {0x76, 427, 0x0, 0, 0, 433, 440},
	/*II_0F_A4*/ {0xac, 876, 0x0, 1, 0, 0, 0},
	/*II_0F_A5*/ {0xac, 876, 0x0, 52, 0, 0, 0},
	/*II_0F_AC*/ {0xac, 892, 0x0, 1, 0, 0, 0},
	/*II_0F_AD*/ {0xac, 892, 0x0, 52, 0, 0, 0},
	/*II_V_0F_10*/ {0x124, 2117, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_10*/ {0x124, 2126, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_10*/ {0x125, 2135, 0x20, 69, 0, 0, 0},
	/*II_V_F2_0F_10*/ {0x125, 2143, 0x20, 69, 0, 0, 0},
	/*II_VRR_F3_0F_10*/ {0x126, 2135, 0x60, 0, 0, 0, 0},
	/*II_VRR_F2_0F_10*/ {0x127, 2143, 0x60, 0, 0, 0, 0},
	/*II_V_0F_11*/ {0x12c, 2117, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_11*/ {0x12c, 2126, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_11*/ {0x125, 2135, 0x20, 69, 0, 0, 0},
	/*II_V_F2_0F_11*/ {0x125, 2143, 0x20, 69, 0, 0, 0},
	/*II_VRR_F3_0F_11*/ {0x12d, 2135, 0x60, 0, 0, 0, 0},
	/*II_VRR_F2_0F_11*/ {0x12e, 2143, 0x60, 0, 0, 0, 0},
	/*II_0F_12*/ {0x12f, 2151, 0x0, 0, 0, 2160, 0},
	/*II_V_0F_12*/ {0x132, 2195, 0x0, 72, 0, 2205, 0},
	/*II_V_66_0F_12*/ {0x133, 2214, 0x0, 46, 0, 0, 0},
	/*II_V_F3_0F_12*/ {0x124, 2223, 0x41, 0, 0, 0, 0},
	/*II_V_F2_0F_12*/ {0x134, 2234, 0x41, 0, 0, 0, 0},
	/*II_V_0F_13*/ {0x137, 2205, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_13*/ {0x137, 2214, 0x40, 0, 0, 0, 0},
	/*II_V_0F_14*/ {0x13a, 2264, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_14*/ {0x13a, 2275, 0x1, 90, 0, 0, 0},
	/*II_V_0F_15*/ {0x13a, 2306, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_15*/ {0x13a, 2317, 0x1, 90, 0, 0, 0},
	/*II_0F_16*/ {0x12f, 2328, 0x0, 0, 0, 2337, 0},
	/*II_V_0F_16*/ {0x132, 2363, 0x0, 72, 0, 2373, 0},
	/*II_V_66_0F_16*/ {0x133, 2382, 0x0, 46, 0, 0, 0},
	/*II_V_F3_0F_16*/ {0x124, 2391, 0x41, 0, 0, 0, 0},
	/*II_V_0F_17*/ {0x137, 2373, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_17*/ {0x137, 2382, 0x40, 0, 0, 0, 0},
	/*II_V_0F_28*/ {0x124, 2467, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_28*/ {0x124, 2476, 0x41, 0, 0, 0, 0},
	/*II_V_0F_29*/ {0x12c, 2467, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_29*/ {0x12c, 2476, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_2A*/ {0x133, 2525, 0x2, 79, 0, 0, 0},
	/*II_V_F2_0F_2A*/ {0x133, 2536, 0x2, 79, 0, 0, 0},
	/*II_V_0F_2B*/ {0x145, 2583, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_2B*/ {0x145, 2593, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_2C*/ {0x14a, 2647, 0x42, 0, 0, 0, 0},
	/*II_V_F2_0F_2C*/ {0x14a, 2659, 0x42, 0, 0, 0, 0},
	/*II_V_F3_0F_2D*/ {0x14a, 2711, 0x42, 0, 0, 0, 0},
	/*II_V_F2_0F_2D*/ {0x14a, 2722, 0x42, 0, 0, 0, 0},
	/*II_V_0F_2E*/ {0x14d, 2751, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_2E*/ {0x14e, 2761, 0x40, 0, 0, 0, 0},
	/*II_V_0F_2F*/ {0x14d, 2787, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_2F*/ {0x14e, 2796, 0x40, 0, 0, 0, 0},
	/*II_V_0F_50*/ {0x151, 2825, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_50*/ {0x151, 2836, 0x41, 0, 0, 0, 0},
	/*II_V_0F_51*/ {0x124, 2879, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_51*/ {0x124, 2888, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_51*/ {0x133, 2897, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_51*/ {0x133, 2906, 0x0, 72, 0, 0, 0},
	/*II_V_0F_52*/ {0x124, 2933, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_52*/ {0x133, 2943, 0x0, 71, 0, 0, 0},
	/*II_V_0F_53*/ {0x124, 2967, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_53*/ {0x133, 2975, 0x0, 71, 0, 0, 0},
	/*II_V_0F_54*/ {0x13a, 2997, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_54*/ {0x13a, 3005, 0x1, 90, 0, 0, 0},
	/*II_V_0F_55*/ {0x13a, 3029, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_55*/ {0x13a, 3038, 0x1, 90, 0, 0, 0},
	/*II_V_0F_56*/ {0x13a, 3059, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_56*/ {0x13a, 3066, 0x1, 90, 0, 0, 0},
	/*II_V_0F_57*/ {0x13a, 3087, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_57*/ {0x13a, 3095, 0x1, 90, 0, 0, 0},
	/*II_V_0F_58*/ {0x13a, 3131, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_58*/ {0x13a, 3139, 0x1, 90, 0, 0, 0},
	/*II_V_F3_0F_58*/ {0x133, 3147, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_58*/ {0x133, 3155, 0x0, 72, 0, 0, 0},
	/*II_V_0F_59*/ {0x13a, 3191, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_59*/ {0x13a, 3199, 0x1, 90, 0, 0, 0},
	/*II_V_F3_0F_59*/ {0x133, 3207, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_59*/ {0x133, 3215, 0x0, 72, 0, 0, 0},
	/*II_V_0F_5A*/ {0x154, 3263, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_5A*/ {0x155, 3274, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_5A*/ {0x133, 3285, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_5A*/ {0x133, 3296, 0x0, 72, 0, 0, 0},
	/*II_V_0F_5B*/ {0x124, 3338, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_5B*/ {0x124, 3349, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_5B*/ {0x124, 3360, 0x41, 0, 0, 0, 0},
	/*II_V_0F_5C*/ {0x13a, 3400, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_5C*/ {0x13a, 3408, 0x1, 90, 0, 0, 0},
	/*II_V_F3_0F_5C*/ {0x133, 3416, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_5C*/ {0x133, 3424, 0x0, 72, 0, 0, 0},
	/*II_V_0F_5D*/ {0x13a, 3460, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_5D*/ {0x13a, 3468, 0x1, 90, 0, 0, 0},
	/*II_V_F3_0F_5D*/ {0x133, 3476, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_5D*/ {0x133, 3484, 0x0, 72, 0, 0, 0},
	/*II_V_0F_5E*/ {0x13a, 3520, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_5E*/ {0x13a, 3528, 0x1, 90, 0, 0, 0},
	/*II_V_F3_0F_5E*/ {0x133, 3536, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_5E*/ {0x133, 3544, 0x0, 72, 0, 0, 0},
	/*II_V_0F_5F*/ {0x13a, 3580, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_5F*/ {0x13a, 3588, 0x1, 90, 0, 0, 0},
	/*II_V_F3_0F_5F*/ {0x133, 3596, 0x0, 71, 0, 0, 0},
	/*II_V_F2_0F_5F*/ {0x133, 3604, 0x0, 72, 0, 0, 0},
	/*II_V_66_0F_60*/ {0x133, 3623, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_61*/ {0x133, 3646, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_62*/ {0x133, 3669, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_63*/ {0x133, 3691, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_64*/ {0x133, 3711, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_65*/ {0x133, 3730, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_66*/ {0x133, 3749, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_67*/ {0x133, 3769, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_68*/ {0x133, 3791, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_69*/ {0x133, 3814, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_6A*/ {0x133, 3837, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_6B*/ {0x133, 3859, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_6C*/ {0x133, 3882, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_6D*/ {0x133, 3907, 0x0, 73, 0, 0, 0},
	/*II_0F_6E*/ {0x158, 3920, 0x0, 0, 0, 0, 3926},
	/*II_66_0F_6E*/ {0x159, 3920, 0x0, 0, 0, 0, 3926},
	/*II_V_66_0F_6E*/ {0x15a, 3932, 0x46, 0, 0, 3939, 0},
	/*II_V_66_0F_6F*/ {0x124, 3962, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_6F*/ {0x124, 3971, 0x41, 0, 0, 0, 0},
	/*II_0F_70*/ {0x15c, 3980, 0x0, 1, 0, 0, 0},
	/*II_66_0F_70*/ {0x15d, 3988, 0x0, 1, 0, 0, 0},
	/*II_F3_0F_70*/ {0x15d, 3996, 0x0, 1, 0, 0, 0},
	/*II_F2_0F_70*/ {0x15d, 4005, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_70*/ {0x15e, 4014, 0x40, 1, 0, 0, 0},
	/*II_V_F3_0F_70*/ {0x15e, 4023, 0x40, 1, 0, 0, 0},
	/*II_V_F2_0F_70*/ {0x15e, 4033, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_74*/ {0x133, 4052, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_75*/ {0x133, 4071, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_76*/ {0x133, 4090, 0x0, 73, 0, 0, 0},
	/*II_V_0F_77*/ {0x160, 4106, 0x49, 0, 0, 4118, 0},
	/*II_66_0F_78*/ {0x162, 4136, 0x0, 8, 0, 0, 0},
	/*II_F2_0F_78*/ {0x163, 4143, 0x0, 7, 8, 0, 0},
	/*II_V_66_0F_7C*/ {0x13a, 4197, 0x1, 90, 0, 0, 0},
	/*II_V_F2_0F_7C*/ {0x13a, 4206, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_7D*/ {0x13a, 4231, 0x1, 90, 0, 0, 0},
	/*II_V_F2_0F_7D*/ {0x13a, 4240, 0x1, 90, 0, 0, 0},
	/*II_0F_7E*/ {0x16a, 3920, 0x0, 0, 0, 0, 3926},
	/*II_66_0F_7E*/ {0x16b, 3920, 0x0, 0, 0, 0, 3926},
	/*II_V_66_0F_7E*/ {0x16c, 3932, 0x46, 0, 0, 3939, 0},
	/*II_V_F3_0F_7E*/ {0x14e, 3939, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_7F*/ {0x12c, 3962, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_7F*/ {0x12c, 3971, 0x41, 0, 0, 0, 0},
	/*II_0F_AE_04*/ {0x16e, 4249, 0x0, 0, 0, 0, 4256},
	/*II_0F_AE_05*/ {0x16f, 4265, 0x0, 0, 0, 4273, 4281},
	/*II_0F_AE_06*/ {0x16f, 4291, 0x0, 0, 0, 4299, 4309},
	/*II_0F_AE_07*/ {0x170, 4321, 0x0, 0, 0, 4329, 0},
	/*II_0F_C2*/ {0x177, 4370, 0x0, 0, 0, 4379, 4388},
	/*II_66_0F_C2*/ {0x178, 4449, 0x0, 0, 0, 4458, 4467},
	/*II_F3_0F_C2*/ {0x179, 4528, 0x0, 0, 0, 4537, 4546},
	/*II_F2_0F_C2*/ {0x17a, 4607, 0x0, 0, 0, 4616, 4625},
	/*II_V_0F_C2*/ {0x17b, 4686, 0x1, 90, 0, 4696, 4706},
	/*II_V_66_0F_C2*/ {0x17b, 5088, 0x1, 90, 0, 5098, 5108},
	/*II_V_F3_0F_C2*/ {0x17c, 5490, 0x0, 71, 0, 5500, 5510},
	/*II_V_F2_0F_C2*/ {0x17c, 5892, 0x0, 72, 0, 5902, 5912},
	/*II_0F_C4*/ {0x17d, 6294, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C4*/ {0x17e, 6294, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_C4*/ {0x17f, 6302, 0x0, 25, 1, 0, 0},
	/*II_0F_C5*/ {0x180, 6311, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C5*/ {0x181, 6311, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_C5*/ {0x182, 6319, 0x40, 1, 0, 0, 0},
	/*II_0F_C6*/ {0x183, 6328, 0x0, 1, 0, 0, 0},
	/*II_66_0F_C6*/ {0x15d, 6336, 0x0, 1, 0, 0, 0},
	/*II_V_0F_C6*/ {0x184, 6344, 0x1, 90, 1, 0, 0},
	/*II_V_66_0F_C6*/ {0x184, 6353, 0x1, 90, 1, 0, 0},
	/*II_0F_C7_01*/ {0x185, 6362, 0x0, 0, 0, 0, 6373},
	/*II_V_66_0F_D0*/ {0x13a, 6414, 0x1, 90, 0, 0, 0},
	/*II_V_F2_0F_D0*/ {0x13a, 6425, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_D1*/ {0x133, 6443, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_D2*/ {0x133, 6458, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_D3*/ {0x133, 6473, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_D4*/ {0x133, 6488, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_D5*/ {0x133, 6504, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_D6*/ {0x189, 3939, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_D7*/ {0x18c, 6541, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_D8*/ {0x133, 6561, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_D9*/ {0x133, 6580, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_DA*/ {0x133, 6598, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_DB*/ {0x133, 6613, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_DC*/ {0x133, 6629, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_DD*/ {0x133, 6629, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_DE*/ {0x133, 6656, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_DF*/ {0x133, 6672, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E0*/ {0x133, 6687, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E1*/ {0x133, 6702, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E2*/ {0x133, 6717, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E3*/ {0x133, 6732, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E4*/ {0x133, 6749, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E5*/ {0x133, 6767, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E6*/ {0x155, 6807, 0x41, 0, 0, 0, 0},
	/*II_V_F3_0F_E6*/ {0x154, 6819, 0x41, 0, 0, 0, 0},
	/*II_V_F2_0F_E6*/ {0x155, 6830, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_E7*/ {0x145, 6858, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_E8*/ {0x133, 6876, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_E9*/ {0x133, 6893, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_EA*/ {0x133, 6910, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_EB*/ {0x133, 6924, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_EC*/ {0x133, 6938, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_ED*/ {0x133, 6955, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_EE*/ {0x133, 6972, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_EF*/ {0x133, 6987, 0x0, 73, 0, 0, 0},
	/*II_V_F2_0F_F0*/ {0x190, 7001, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_F1*/ {0x133, 7016, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_F2*/ {0x133, 7031, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_F3*/ {0x133, 7046, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_F4*/ {0x133, 7063, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_F5*/ {0x133, 7082, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_F6*/ {0x133, 7100, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_F7*/ {0x194, 7131, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_F8*/ {0x133, 7151, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_F9*/ {0x133, 7166, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_FA*/ {0x133, 7181, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_FB*/ {0x133, 7196, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_FC*/ {0x133, 7211, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_FD*/ {0x133, 7226, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_FE*/ {0x133, 7241, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_00*/ {0x133, 7349, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_01*/ {0x133, 7366, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_02*/ {0x133, 7383, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_03*/ {0x133, 7401, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_04*/ {0x133, 7422, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_05*/ {0x133, 7442, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_06*/ {0x133, 7459, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_07*/ {0x133, 7477, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_08*/ {0x133, 7495, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_09*/ {0x133, 7512, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_0A*/ {0x133, 7529, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_0B*/ {0x133, 7548, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_0C*/ {0x13a, 7559, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_38_0D*/ {0x13a, 7570, 0x1, 90, 0, 0, 0},
	/*II_V_66_0F_38_0E*/ {0x124, 7581, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_0F*/ {0x124, 7590, 0x41, 0, 0, 0, 0},
	/*II_66_0F_38_10*/ {0x19b, 7599, 0x0, 74, 0, 0, 0},
	/*II_66_0F_38_14*/ {0x19b, 7609, 0x0, 74, 0, 0, 0},
	/*II_66_0F_38_15*/ {0x19b, 7619, 0x0, 74, 0, 0, 0},
	/*II_V_66_0F_38_17*/ {0x124, 7636, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_18*/ {0x19d, 7644, 0x41, 0, 0, 0, 0},
	/*II_V_66_0F_38_19*/ {0x19e, 7658, 0x50, 0, 0, 0, 0},
	/*II_V_66_0F_38_1A*/ {0x19f, 7672, 0x50, 0, 0, 0, 0},
	/*II_V_66_0F_38_1C*/ {0x1a0, 7695, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_1D*/ {0x1a0, 7710, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_1E*/ {0x1a0, 7725, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_20*/ {0x14e, 7743, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_21*/ {0x14d, 7764, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_22*/ {0x1a4, 7785, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_23*/ {0x14e, 7806, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_24*/ {0x14d, 7827, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_25*/ {0x14e, 7848, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_28*/ {0x133, 7867, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_29*/ {0x133, 7885, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_2A*/ {0x1a7, 7905, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_2B*/ {0x133, 7926, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_2C*/ {0x13a, 7937, 0x1, 92, 0, 0, 0},
	/*II_V_66_0F_38_2D*/ {0x13a, 7949, 0x1, 92, 0, 0, 0},
	/*II_V_66_0F_38_2E*/ {0x1a8, 7937, 0x1, 83, 0, 0, 0},
	/*II_V_66_0F_38_2F*/ {0x1a8, 7949, 0x1, 83, 0, 0, 0},
	/*II_V_66_0F_38_30*/ {0x14e, 7971, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_31*/ {0x14d, 7992, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_32*/ {0x1a4, 8013, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_33*/ {0x14e, 8034, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_34*/ {0x14d, 8055, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_35*/ {0x14e, 8076, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_37*/ {0x133, 8096, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_38*/ {0x133, 8114, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_39*/ {0x133, 8131, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_3A*/ {0x133, 8148, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_3B*/ {0x133, 8165, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_3C*/ {0x133, 8182, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_3D*/ {0x133, 8199, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_3E*/ {0x133, 8216, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_3F*/ {0x133, 8233, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_40*/ {0x133, 8250, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_41*/ {0x1a0, 8271, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_96*/ {0x1aa, 8310, 0x7, 90, 0, 8326, 0},
	/*II_V_66_0F_38_97*/ {0x1aa, 8342, 0x7, 90, 0, 8358, 0},
	/*II_V_66_0F_38_98*/ {0x1aa, 8374, 0x7, 90, 0, 8387, 0},
	/*II_V_66_0F_38_99*/ {0x1ab, 8400, 0x6, 80, 0, 8413, 0},
	/*II_V_66_0F_38_9A*/ {0x1aa, 8426, 0x7, 90, 0, 8439, 0},
	/*II_V_66_0F_38_9B*/ {0x1ab, 8452, 0x6, 80, 0, 8465, 0},
	/*II_V_66_0F_38_9C*/ {0x1aa, 8478, 0x7, 90, 0, 8492, 0},
	/*II_V_66_0F_38_9D*/ {0x1ab, 8506, 0x6, 80, 0, 8520, 0},
	/*II_V_66_0F_38_9E*/ {0x1aa, 8534, 0x7, 90, 0, 8548, 0},
	/*II_V_66_0F_38_9F*/ {0x1ab, 8562, 0x6, 80, 0, 8576, 0},
	/*II_V_66_0F_38_A6*/ {0x1aa, 8590, 0x7, 90, 0, 8606, 0},
	/*II_V_66_0F_38_A7*/ {0x1aa, 8622, 0x7, 90, 0, 8638, 0},
	/*II_V_66_0F_38_A8*/ {0x1aa, 8654, 0x7, 90, 0, 8667, 0},
	/*II_V_66_0F_38_A9*/ {0x1ab, 8680, 0x6, 80, 0, 8693, 0},
	/*II_V_66_0F_38_AA*/ {0x1aa, 8706, 0x7, 90, 0, 8719, 0},
	/*II_V_66_0F_38_AB*/ {0x1ab, 8732, 0x6, 80, 0, 8745, 0},
	/*II_V_66_0F_38_AC*/ {0x1aa, 8758, 0x7, 90, 0, 8772, 0},
	/*II_V_66_0F_38_AD*/ {0x1ab, 8786, 0x6, 80, 0, 8800, 0},
	/*II_V_66_0F_38_AE*/ {0x1aa, 8814, 0x7, 90, 0, 8828, 0},
	/*II_V_66_0F_38_AF*/ {0x1ab, 8842, 0x6, 80, 0, 8856, 0},
	/*II_V_66_0F_38_B6*/ {0x1aa, 8870, 0x7, 90, 0, 8886, 0},
	/*II_V_66_0F_38_B7*/ {0x1aa, 8902, 0x7, 90, 0, 8918, 0},
	/*II_V_66_0F_38_B8*/ {0x1aa, 8934, 0x7, 90, 0, 8947, 0},
	/*II_V_66_0F_38_B9*/ {0x1ab, 8960, 0x6, 80, 0, 8973, 0},
	/*II_V_66_0F_38_BA*/ {0x1aa, 8986, 0x7, 90, 0, 8999, 0},
	/*II_V_66_0F_38_BB*/ {0x1ab, 9012, 0x6, 80, 0, 9025, 0},
	/*II_V_66_0F_38_BC*/ {0x1aa, 9038, 0x7, 90, 0, 9052, 0},
	/*II_V_66_0F_38_BD*/ {0x1ab, 9066, 0x6, 80, 0, 9080, 0},
	/*II_V_66_0F_38_BE*/ {0x1aa, 9094, 0x7, 90, 0, 9108, 0},
	/*II_V_66_0F_38_BF*/ {0x1ab, 9122, 0x6, 80, 0, 9136, 0},
	/*II_V_66_0F_38_DB*/ {0x1ad, 9158, 0x40, 0, 0, 0, 0},
	/*II_V_66_0F_38_DC*/ {0x1ae, 9175, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_DD*/ {0x1ae, 9196, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_DE*/ {0x1ae, 9217, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_38_DF*/ {0x1ae, 9238, 0x0, 73, 0, 0, 0},
	/*II_V_66_0F_3A_04*/ {0x1b3, 7559, 0x41, 1, 0, 0, 0},
	/*II_V_66_0F_3A_05*/ {0x1b3, 7570, 0x41, 1, 0, 0, 0},
	/*II_V_66_0F_3A_06*/ {0x1b4, 9265, 0x10, 86, 1, 0, 0},
	/*II_66_0F_3A_08*/ {0x19b, 9277, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_08*/ {0x1b3, 9286, 0x41, 1, 0, 0, 0},
	/*II_66_0F_3A_09*/ {0x19b, 9296, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_09*/ {0x1b3, 9305, 0x41, 1, 0, 0, 0},
	/*II_66_0F_3A_0A*/ {0x1b5, 9315, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0A*/ {0x17f, 9324, 0x0, 71, 1, 0, 0},
	/*II_66_0F_3A_0B*/ {0x1b6, 9334, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0B*/ {0x17f, 9343, 0x0, 72, 1, 0, 0},
	/*II_66_0F_3A_0C*/ {0x19b, 9353, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0C*/ {0x184, 9362, 0x1, 90, 1, 0, 0},
	/*II_66_0F_3A_0D*/ {0x19b, 9372, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0D*/ {0x184, 9381, 0x1, 90, 1, 0, 0},
	/*II_66_0F_3A_0E*/ {0x19b, 9391, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0E*/ {0x17f, 9400, 0x0, 73, 1, 0, 0},
	/*II_0F_3A_0F*/ {0x1b7, 9410, 0x0, 1, 0, 0, 0},
	/*II_66_0F_3A_0F*/ {0x1b8, 9410, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_0F*/ {0x17f, 9419, 0x0, 73, 1, 0, 0},
	/*II_66_0F_3A_14*/ {0x1b9, 9429, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_14*/ {0x1ba, 9437, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_15*/ {0x1bb, 6311, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_15*/ {0x1bc, 6319, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_16*/ {0x1bd, 9446, 0x0, 1, 0, 0, 9454},
	/*II_V_66_0F_3A_16*/ {0x1be, 9462, 0x46, 1, 0, 9471, 0},
	/*II_66_0F_3A_17*/ {0x1bf, 9480, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_17*/ {0x1c0, 9491, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_3A_18*/ {0x1b4, 9503, 0x10, 73, 1, 0, 0},
	/*II_V_66_0F_3A_19*/ {0x1c1, 9516, 0x50, 1, 0, 0, 0},
	/*II_66_0F_3A_20*/ {0x1c2, 9530, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_20*/ {0x17f, 9538, 0x0, 76, 1, 0, 0},
	/*II_66_0F_3A_21*/ {0x1b5, 9547, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_21*/ {0x17f, 9557, 0x0, 71, 1, 0, 0},
	/*II_66_0F_3A_22*/ {0x1c3, 9568, 0x0, 1, 0, 0, 9576},
	/*II_V_66_0F_3A_22*/ {0x17f, 9584, 0x6, 79, 1, 9593, 0},
	/*II_66_0F_3A_40*/ {0x19b, 9602, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_40*/ {0x184, 9608, 0x1, 90, 1, 0, 0},
	/*II_66_0F_3A_41*/ {0x19b, 9615, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_41*/ {0x17f, 9621, 0x0, 73, 1, 0, 0},
	/*II_66_0F_3A_42*/ {0x19b, 9628, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_42*/ {0x17f, 9637, 0x0, 73, 1, 0, 0},
	/*II_66_0F_3A_44*/ {0x1c4, 9647, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_44*/ {0x1c5, 9658, 0x0, 73, 1, 0, 0},
	/*II_V_66_0F_3A_4A*/ {0x184, 9670, 0x1, 90, 84, 0, 0},
	/*II_V_66_0F_3A_4B*/ {0x184, 9681, 0x1, 90, 84, 0, 0},
	/*II_V_66_0F_3A_4C*/ {0x17f, 9692, 0x0, 73, 82, 0, 0},
	/*II_66_0F_3A_60*/ {0x1c6, 9703, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_60*/ {0x15e, 9714, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_61*/ {0x1c6, 9726, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_61*/ {0x15e, 9737, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_62*/ {0x1c6, 9749, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_62*/ {0x15e, 9760, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_63*/ {0x1c6, 9772, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_63*/ {0x15e, 9783, 0x40, 1, 0, 0, 0},
	/*II_66_0F_3A_DF*/ {0x1c7, 9795, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_3A_DF*/ {0x1c8, 9812, 0x40, 1, 0, 0, 0},
	/*II_V_66_0F_71_02*/ {0x1cb, 6443, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_71_04*/ {0x1cb, 6702, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_71_06*/ {0x1cb, 7016, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_02*/ {0x1cb, 6458, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_04*/ {0x1cb, 6717, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_72_06*/ {0x1cb, 7031, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_02*/ {0x1cb, 6473, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_03*/ {0x1cb, 9838, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_06*/ {0x1cb, 7046, 0x0, 1, 0, 0, 0},
	/*II_V_66_0F_73_07*/ {0x1cb, 9855, 0x0, 1, 0, 0, 0},
	/*II_0F_AE_00*/ {0x16e, 9864, 0x0, 0, 0, 0, 9872},
	/*II_0F_AE_01*/ {0x16e, 9892, 0x0, 0, 0, 0, 9901},
	/*II_V_0F_AE_02*/ {0x1cd, 9941, 0x40, 0, 0, 0, 0},
	/*II_V_0F_AE_03*/ {0x1cd, 9970, 0x40, 0, 0, 0, 0},
	/*II_0F_C7_06*/ {0x1ce, 9980, 0x0, 0, 0, 9988, 0}
};

_InstNode InstructionsTree[5560] = {
/* 0 - _00 */  0x2000,
/* 1 - _01 */  0x2001,
/* 2 - _02 */  0x2002,
/* 3 - _03 */  0x2003,
/* 4 - _04 */  0x2004,
/* 5 - _05 */  0x2005,
/* 6 - _06 */  0x2006,
/* 7 - _07 */  0x2007,
/* 8 - _08 */  0x2008,
/* 9 - _09 */  0x2009,
/* a - _0A */  0x200a,
/* b - _0B */  0x200b,
/* c - _0C */  0x200c,
/* d - _0D */  0x200d,
/* e - _0E */  0x200e,
/* f - _0F */  0x8100,
/* 10 - _10 */  0x200f,
/* 11 - _11 */  0x2010,
/* 12 - _12 */  0x2011,
/* 13 - _13 */  0x2012,
/* 14 - _14 */  0x2013,
/* 15 - _15 */  0x2014,
/* 16 - _16 */  0x2015,
/* 17 - _17 */  0x2016,
/* 18 - _18 */  0x2017,
/* 19 - _19 */  0x2018,
/* 1a - _1A */  0x2019,
/* 1b - _1B */  0x201a,
/* 1c - _1C */  0x201b,
/* 1d - _1D */  0x201c,
/* 1e - _1E */  0x201d,
/* 1f - _1F */  0x201e,
/* 20 - _20 */  0x201f,
/* 21 - _21 */  0x2020,
/* 22 - _22 */  0x2021,
/* 23 - _23 */  0x2022,
/* 24 - _24 */  0x2023,
/* 25 - _25 */  0x2024,
/* 26 -  */  0,
/* 27 - _27 */  0x2025,
/* 28 - _28 */  0x2026,
/* 29 - _29 */  0x2027,
/* 2a - _2A */  0x2028,
/* 2b - _2B */  0x2029,
/* 2c - _2C */  0x202a,
/* 2d - _2D */  0x202b,
/* 2e -  */  0,
/* 2f - _2F */  0x202c,
/* 30 - _30 */  0x202d,
/* 31 - _31 */  0x202e,
/* 32 - _32 */  0x202f,
/* 33 - _33 */  0x2030,
/* 34 - _34 */  0x2031,
/* 35 - _35 */  0x2032,
/* 36 -  */  0,
/* 37 - _37 */  0x2033,
/* 38 - _38 */  0x2034,
/* 39 - _39 */  0x2035,
/* 3a - _3A */  0x2036,
/* 3b - _3B */  0x2037,
/* 3c - _3C */  0x2038,
/* 3d - _3D */  0x2039,
/* 3e -  */  0,
/* 3f - _3F */  0x203a,
/* 40 - _40 */  0x203b,
/* 41 - _40 */  0x203c,
/* 42 - _40 */  0x203d,
/* 43 - _40 */  0x203e,
/* 44 - _40 */  0x203f,
/* 45 - _40 */  0x2040,
/* 46 - _40 */  0x2041,
/* 47 - _40 */  0x2042,
/* 48 - _48 */  0x2043,
/* 49 - _48 */  0x2044,
/* 4a - _48 */  0x2045,
/* 4b - _48 */  0x2046,
/* 4c - _48 */  0x2047,
/* 4d - _48 */  0x2048,
/* 4e - _48 */  0x2049,
/* 4f - _48 */  0x204a,
/* 50 - _50 */  0x204b,
/* 51 - _50 */  0x204c,
/* 52 - _50 */  0x204d,
/* 53 - _50 */  0x204e,
/* 54 - _50 */  0x204f,
/* 55 - _50 */  0x2050,
/* 56 - _50 */  0x2051,
/* 57 - _50 */  0x2052,
/* 58 - _58 */  0x2053,
/* 59 - _58 */  0x2054,
/* 5a - _58 */  0x2055,
/* 5b - _58 */  0x2056,
/* 5c - _58 */  0x2057,
/* 5d - _58 */  0x2058,
/* 5e - _58 */  0x2059,
/* 5f - _58 */  0x205a,
/* 60 - _60 */  0x205b,
/* 61 - _61 */  0x205c,
/* 62 - _62 */  0x205d,
/* 63 - _63 */  0x205e,
/* 64 -  */  0,
/* 65 -  */  0,
/* 66 -  */  0,
/* 67 -  */  0,
/* 68 - _68 */  0x205f,
/* 69 - _69 */  0x4000,
/* 6a - _6A */  0x2060,
/* 6b - _6B */  0x4001,
/* 6c - _6C */  0x2061,
/* 6d - _6D */  0x2062,
/* 6e - _6E */  0x2063,
/* 6f - _6F */  0x2064,
/* 70 - _70 */  0x2065,
/* 71 - _71 */  0x2066,
/* 72 - _72 */  0x2067,
/* 73 - _73 */  0x2068,
/* 74 - _74 */  0x2069,
/* 75 - _75 */  0x206a,
/* 76 - _76 */  0x206b,
/* 77 - _77 */  0x206c,
/* 78 - _78 */  0x206d,
/* 79 - _79 */  0x206e,
/* 7a - _7A */  0x206f,
/* 7b - _7B */  0x2070,
/* 7c - _7C */  0x2071,
/* 7d - _7D */  0x2072,
/* 7e - _7E */  0x2073,
/* 7f - _7F */  0x2074,
/* 80 - _80 */  0x6200,
/* 81 - _81 */  0x6208,
/* 82 - _82 */  0x6210,
/* 83 - _83 */  0x6218,
/* 84 - _84 */  0x2075,
/* 85 - _85 */  0x2076,
/* 86 - _86 */  0x2077,
/* 87 - _87 */  0x2078,
/* 88 - _88 */  0x2079,
/* 89 - _89 */  0x207a,
/* 8a - _8A */  0x207b,
/* 8b - _8B */  0x207c,
/* 8c - _8C */  0x207d,
/* 8d - _8D */  0x207e,
/* 8e - _8E */  0x207f,
/* 8f - _8F */  0x6220,
/* 90 - _90 */  0x2080,
/* 91 - _91 */  0x2081,
/* 92 - _92 */  0x2082,
/* 93 - _93 */  0x2083,
/* 94 - _94 */  0x2084,
/* 95 - _95 */  0x2085,
/* 96 - _96 */  0x2086,
/* 97 - _97 */  0x2087,
/* 98 - _98 */  0x4002,
/* 99 - _99 */  0x4003,
/* 9a - _9A */  0x2088,
/* 9b -  */  0,
/* 9c - _9C */  0x2089,
/* 9d - _9D */  0x208a,
/* 9e - _9E */  0x208b,
/* 9f - _9F */  0x208c,
/* a0 - _A0 */  0x208d,
/* a1 - _A1 */  0x208e,
/* a2 - _A2 */  0x208f,
/* a3 - _A3 */  0x2090,
/* a4 - _A4 */  0x2091,
/* a5 - _A5 */  0x2092,
/* a6 - _A6 */  0x2093,
/* a7 - _A7 */  0x2094,
/* a8 - _A8 */  0x2095,
/* a9 - _A9 */  0x2096,
/* aa - _AA */  0x2097,
/* ab - _AB */  0x2098,
/* ac - _AC */  0x2099,
/* ad - _AD */  0x209a,
/* ae - _AE */  0x209b,
/* af - _AF */  0x209c,
/* b0 - _B0 */  0x209d,
/* b1 - _B0 */  0x209e,
/* b2 - _B0 */  0x209f,
/* b3 - _B0 */  0x20a0,
/* b4 - _B0 */  0x20a1,
/* b5 - _B0 */  0x20a2,
/* b6 - _B0 */  0x20a3,
/* b7 - _B0 */  0x20a4,
/* b8 - _B8 */  0x20a5,
/* b9 - _B8 */  0x20a6,
/* ba - _B8 */  0x20a7,
/* bb - _B8 */  0x20a8,
/* bc - _B8 */  0x20a9,
/* bd - _B8 */  0x20aa,
/* be - _B8 */  0x20ab,
/* bf - _B8 */  0x20ac,
/* c0 - _C0 */  0x6228,
/* c1 - _C1 */  0x6230,
/* c2 - _C2 */  0x20ad,
/* c3 - _C3 */  0x20ae,
/* c4 - _C4 */  0x20af,
/* c5 - _C5 */  0x20b0,
/* c6 - _C6 */  0x6238,
/* c7 - _C7 */  0x6240,
/* c8 - _C8 */  0x20b1,
/* c9 - _C9 */  0x20b2,
/* ca - _CA */  0x20b3,
/* cb - _CB */  0x20b4,
/* cc - _CC */  0x20b5,
/* cd - _CD */  0x20b6,
/* ce - _CE */  0x20b7,
/* cf - _CF */  0x20b8,
/* d0 - _D0 */  0x6248,
/* d1 - _D1 */  0x6250,
/* d2 - _D2 */  0x6258,
/* d3 - _D3 */  0x6260,
/* d4 - _D4 */  0x20b9,
/* d5 - _D5 */  0x20ba,
/* d6 - _D6 */  0x20bb,
/* d7 - _D7 */  0x20bc,
/* d8 - _D8 */  0xa268,
/* d9 - _D9 */  0xa2b0,
/* da - _DA */  0xa2f8,
/* db - _DB */  0xa340,
/* dc - _DC */  0xa388,
/* dd - _DD */  0xa3d0,
/* de - _DE */  0xa418,
/* df - _DF */  0xa460,
/* e0 - _E0 */  0x20bd,
/* e1 - _E1 */  0x20be,
/* e2 - _E2 */  0x20bf,
/* e3 - _E3 */  0x4004,
/* e4 - _E4 */  0x20c0,
/* e5 - _E5 */  0x20c1,
/* e6 - _E6 */  0x20c2,
/* e7 - _E7 */  0x20c3,
/* e8 - _E8 */  0x20c4,
/* e9 - _E9 */  0x20c5,
/* ea - _EA */  0x20c6,
/* eb - _EB */  0x20c7,
/* ec - _EC */  0x20c8,
/* ed - _ED */  0x20c9,
/* ee - _EE */  0x20ca,
/* ef - _EF */  0x20cb,
/* f0 -  */  0,
/* f1 - _F1 */  0x20cc,
/* f2 -  */  0,
/* f3 -  */  0,
/* f4 - _F4 */  0x20cd,
/* f5 - _F5 */  0x20ce,
/* f6 - _F6 */  0x64a8,
/* f7 - _F7 */  0x64b0,
/* f8 - _F8 */  0x20cf,
/* f9 - _F9 */  0x20d0,
/* fa - _FA */  0x20d1,
/* fb - _FB */  0x20d2,
/* fc - _FC */  0x20d3,
/* fd - _FD */  0x20d4,
/* fe - _FE */  0x64b8,
/* ff - _FF */  0x64c0,
/* 100 - _0F_00 */  0x64c8,
/* 101 - _0F_01 */  0xa4d0,
/* 102 - _0F_02 */  0x20d5,
/* 103 - _0F_03 */  0x20d6,
/* 104 -  */  0,
/* 105 - _0F_05 */  0x20d7,
/* 106 - _0F_06 */  0x20d8,
/* 107 - _0F_07 */  0x20d9,
/* 108 - _0F_08 */  0x20da,
/* 109 - _0F_09 */  0x20db,
/* 10a -  */  0,
/* 10b - _0F_0B */  0x20dc,
/* 10c -  */  0,
/* 10d - _0F_0D */  0x6518,
/* 10e - _0F_0E */  0x20dd,
/* 10f - _0F_0F */  0x8520,
/* 110 - _0F_10 */  0xc620,
/* 111 - _0F_11 */  0xc62c,
/* 112 - _0F_12 */  0xc638,
/* 113 - _0F_13 */  0xc644,
/* 114 - _0F_14 */  0xc650,
/* 115 - _0F_15 */  0xc65c,
/* 116 - _0F_16 */  0xc668,
/* 117 - _0F_17 */  0xc674,
/* 118 - _0F_18 */  0x6680,
/* 119 -  */  0,
/* 11a -  */  0,
/* 11b -  */  0,
/* 11c -  */  0,
/* 11d -  */  0,
/* 11e -  */  0,
/* 11f - _0F_1F */  0x20de,
/* 120 - _0F_20 */  0x20df,
/* 121 - _0F_21 */  0x20e0,
/* 122 - _0F_22 */  0x20e1,
/* 123 - _0F_23 */  0x20e2,
/* 124 -  */  0,
/* 125 -  */  0,
/* 126 -  */  0,
/* 127 -  */  0,
/* 128 - _0F_28 */  0xc688,
/* 129 - _0F_29 */  0xc694,
/* 12a - _0F_2A */  0xc6a0,
/* 12b - _0F_2B */  0xc6ac,
/* 12c - _0F_2C */  0xc6b8,
/* 12d - _0F_2D */  0xc6c4,
/* 12e - _0F_2E */  0xc6d0,
/* 12f - _0F_2F */  0xc6dc,
/* 130 - _0F_30 */  0x20e3,
/* 131 - _0F_31 */  0x20e4,
/* 132 - _0F_32 */  0x20e5,
/* 133 - _0F_33 */  0x20e6,
/* 134 - _0F_34 */  0x20e7,
/* 135 - _0F_35 */  0x20e8,
/* 136 -  */  0,
/* 137 - _0F_37 */  0x20e9,
/* 138 - _0F_38 */  0x86e8,
/* 139 -  */  0,
/* 13a - _0F_3A */  0x87e8,
/* 13b -  */  0,
/* 13c -  */  0,
/* 13d -  */  0,
/* 13e -  */  0,
/* 13f -  */  0,
/* 140 - _0F_40 */  0x20ea,
/* 141 - _0F_41 */  0x20eb,
/* 142 - _0F_42 */  0x20ec,
/* 143 - _0F_43 */  0x20ed,
/* 144 - _0F_44 */  0x20ee,
/* 145 - _0F_45 */  0x20ef,
/* 146 - _0F_46 */  0x20f0,
/* 147 - _0F_47 */  0x20f1,
/* 148 - _0F_48 */  0x20f2,
/* 149 - _0F_49 */  0x20f3,
/* 14a - _0F_4A */  0x20f4,
/* 14b - _0F_4B */  0x20f5,
/* 14c - _0F_4C */  0x20f6,
/* 14d - _0F_4D */  0x20f7,
/* 14e - _0F_4E */  0x20f8,
/* 14f - _0F_4F */  0x20f9,
/* 150 - _0F_50 */  0xc8e8,
/* 151 - _0F_51 */  0xc8f4,
/* 152 - _0F_52 */  0xc900,
/* 153 - _0F_53 */  0xc90c,
/* 154 - _0F_54 */  0xc918,
/* 155 - _0F_55 */  0xc924,
/* 156 - _0F_56 */  0xc930,
/* 157 - _0F_57 */  0xc93c,
/* 158 - _0F_58 */  0xc948,
/* 159 - _0F_59 */  0xc954,
/* 15a - _0F_5A */  0xc960,
/* 15b - _0F_5B */  0xc96c,
/* 15c - _0F_5C */  0xc978,
/* 15d - _0F_5D */  0xc984,
/* 15e - _0F_5E */  0xc990,
/* 15f - _0F_5F */  0xc99c,
/* 160 - _0F_60 */  0xc9a8,
/* 161 - _0F_61 */  0xc9b4,
/* 162 - _0F_62 */  0xc9c0,
/* 163 - _0F_63 */  0xc9cc,
/* 164 - _0F_64 */  0xc9d8,
/* 165 - _0F_65 */  0xc9e4,
/* 166 - _0F_66 */  0xc9f0,
/* 167 - _0F_67 */  0xc9fc,
/* 168 - _0F_68 */  0xca08,
/* 169 - _0F_69 */  0xca14,
/* 16a - _0F_6A */  0xca20,
/* 16b - _0F_6B */  0xca2c,
/* 16c - _0F_6C */  0xca38,
/* 16d - _0F_6D */  0xca44,
/* 16e - _0F_6E */  0xca50,
/* 16f - _0F_6F */  0xca5c,
/* 170 - _0F_70 */  0xca68,
/* 171 - _0F_71 */  0x6a74,
/* 172 - _0F_72 */  0x6a7c,
/* 173 - _0F_73 */  0x6a84,
/* 174 - _0F_74 */  0xca8c,
/* 175 - _0F_75 */  0xca98,
/* 176 - _0F_76 */  0xcaa4,
/* 177 - _0F_77 */  0xcab0,
/* 178 - _0F_78 */  0xcabc,
/* 179 - _0F_79 */  0xcac8,
/* 17a - _0F_7A */  0x8ad4,
/* 17b -  */  0,
/* 17c - _0F_7C */  0xcbd4,
/* 17d - _0F_7D */  0xcbe0,
/* 17e - _0F_7E */  0xcbec,
/* 17f - _0F_7F */  0xcbf8,
/* 180 - _0F_80 */  0x20fa,
/* 181 - _0F_81 */  0x20fb,
/* 182 - _0F_82 */  0x20fc,
/* 183 - _0F_83 */  0x20fd,
/* 184 - _0F_84 */  0x20fe,
/* 185 - _0F_85 */  0x20ff,
/* 186 - _0F_86 */  0x2100,
/* 187 - _0F_87 */  0x2101,
/* 188 - _0F_88 */  0x2102,
/* 189 - _0F_89 */  0x2103,
/* 18a - _0F_8A */  0x2104,
/* 18b - _0F_8B */  0x2105,
/* 18c - _0F_8C */  0x2106,
/* 18d - _0F_8D */  0x2107,
/* 18e - _0F_8E */  0x2108,
/* 18f - _0F_8F */  0x2109,
/* 190 - _0F_90 */  0x210a,
/* 191 - _0F_91 */  0x210b,
/* 192 - _0F_92 */  0x210c,
/* 193 - _0F_93 */  0x210d,
/* 194 - _0F_94 */  0x210e,
/* 195 - _0F_95 */  0x210f,
/* 196 - _0F_96 */  0x2110,
/* 197 - _0F_97 */  0x2111,
/* 198 - _0F_98 */  0x2112,
/* 199 - _0F_99 */  0x2113,
/* 19a - _0F_9A */  0x2114,
/* 19b - _0F_9B */  0x2115,
/* 19c - _0F_9C */  0x2116,
/* 19d - _0F_9D */  0x2117,
/* 19e - _0F_9E */  0x2118,
/* 19f - _0F_9F */  0x2119,
/* 1a0 - _0F_A0 */  0x211a,
/* 1a1 - _0F_A1 */  0x211b,
/* 1a2 - _0F_A2 */  0x211c,
/* 1a3 - _0F_A3 */  0x211d,
/* 1a4 - _0F_A4 */  0x4005,
/* 1a5 - _0F_A5 */  0x4006,
/* 1a6 -  */  0,
/* 1a7 -  */  0,
/* 1a8 - _0F_A8 */  0x211e,
/* 1a9 - _0F_A9 */  0x211f,
/* 1aa - _0F_AA */  0x2120,
/* 1ab - _0F_AB */  0x2121,
/* 1ac - _0F_AC */  0x4007,
/* 1ad - _0F_AD */  0x4008,
/* 1ae - _0F_AE */  0x6c04,
/* 1af - _0F_AF */  0x2122,
/* 1b0 - _0F_B0 */  0x2123,
/* 1b1 - _0F_B1 */  0x2124,
/* 1b2 - _0F_B2 */  0x2125,
/* 1b3 - _0F_B3 */  0x2126,
/* 1b4 - _0F_B4 */  0x2127,
/* 1b5 - _0F_B5 */  0x2128,
/* 1b6 - _0F_B6 */  0x2129,
/* 1b7 - _0F_B7 */  0x212a,
/* 1b8 - _0F_B8 */  0xcc0c,
/* 1b9 - _0F_B9 */  0x212b,
/* 1ba - _0F_BA */  0x6c18,
/* 1bb - _0F_BB */  0x212c,
/* 1bc - _0F_BC */  0xcc20,
/* 1bd - _0F_BD */  0xcc2c,
/* 1be - _0F_BE */  0x212d,
/* 1bf - _0F_BF */  0x212e,
/* 1c0 - _0F_C0 */  0x212f,
/* 1c1 - _0F_C1 */  0x2130,
/* 1c2 - _0F_C2 */  0xcc38,
/* 1c3 - _0F_C3 */  0x2131,
/* 1c4 - _0F_C4 */  0xcc44,
/* 1c5 - _0F_C5 */  0xcc50,
/* 1c6 - _0F_C6 */  0xcc5c,
/* 1c7 - _0F_C7 */  0x6c68,
/* 1c8 - _0F_C8 */  0x2132,
/* 1c9 - _0F_C8 */  0x2133,
/* 1ca - _0F_C8 */  0x2134,
/* 1cb - _0F_C8 */  0x2135,
/* 1cc - _0F_C8 */  0x2136,
/* 1cd - _0F_C8 */  0x2137,
/* 1ce - _0F_C8 */  0x2138,
/* 1cf - _0F_C8 */  0x2139,
/* 1d0 - _0F_D0 */  0xcc70,
/* 1d1 - _0F_D1 */  0xcc7c,
/* 1d2 - _0F_D2 */  0xcc88,
/* 1d3 - _0F_D3 */  0xcc94,
/* 1d4 - _0F_D4 */  0xcca0,
/* 1d5 - _0F_D5 */  0xccac,
/* 1d6 - _0F_D6 */  0xccb8,
/* 1d7 - _0F_D7 */  0xccc4,
/* 1d8 - _0F_D8 */  0xccd0,
/* 1d9 - _0F_D9 */  0xccdc,
/* 1da - _0F_DA */  0xcce8,
/* 1db - _0F_DB */  0xccf4,
/* 1dc - _0F_DC */  0xcd00,
/* 1dd - _0F_DD */  0xcd0c,
/* 1de - _0F_DE */  0xcd18,
/* 1df - _0F_DF */  0xcd24,
/* 1e0 - _0F_E0 */  0xcd30,
/* 1e1 - _0F_E1 */  0xcd3c,
/* 1e2 - _0F_E2 */  0xcd48,
/* 1e3 - _0F_E3 */  0xcd54,
/* 1e4 - _0F_E4 */  0xcd60,
/* 1e5 - _0F_E5 */  0xcd6c,
/* 1e6 - _0F_E6 */  0xcd78,
/* 1e7 - _0F_E7 */  0xcd84,
/* 1e8 - _0F_E8 */  0xcd90,
/* 1e9 - _0F_E9 */  0xcd9c,
/* 1ea - _0F_EA */  0xcda8,
/* 1eb - _0F_EB */  0xcdb4,
/* 1ec - _0F_EC */  0xcdc0,
/* 1ed - _0F_ED */  0xcdcc,
/* 1ee - _0F_EE */  0xcdd8,
/* 1ef - _0F_EF */  0xcde4,
/* 1f0 - _0F_F0 */  0xcdf0,
/* 1f1 - _0F_F1 */  0xcdfc,
/* 1f2 - _0F_F2 */  0xce08,
/* 1f3 - _0F_F3 */  0xce14,
/* 1f4 - _0F_F4 */  0xce20,
/* 1f5 - _0F_F5 */  0xce2c,
/* 1f6 - _0F_F6 */  0xce38,
/* 1f7 - _0F_F7 */  0xce44,
/* 1f8 - _0F_F8 */  0xce50,
/* 1f9 - _0F_F9 */  0xce5c,
/* 1fa - _0F_FA */  0xce68,
/* 1fb - _0F_FB */  0xce74,
/* 1fc - _0F_FC */  0xce80,
/* 1fd - _0F_FD */  0xce8c,
/* 1fe - _0F_FE */  0xce98,
/* 1ff -  */  0,
/* 200 - _80_00 */  0x213a,
/* 201 - _80_01 */  0x213b,
/* 202 - _80_02 */  0x213c,
/* 203 - _80_03 */  0x213d,
/* 204 - _80_04 */  0x213e,
/* 205 - _80_05 */  0x213f,
/* 206 - _80_06 */  0x2140,
/* 207 - _80_07 */  0x2141,
/* 208 - _81_00 */  0x2142,
/* 209 - _81_01 */  0x2143,
/* 20a - _81_02 */  0x2144,
/* 20b - _81_03 */  0x2145,
/* 20c - _81_04 */  0x2146,
/* 20d - _81_05 */  0x2147,
/* 20e - _81_06 */  0x2148,
/* 20f - _81_07 */  0x2149,
/* 210 - _82_00 */  0x214a,
/* 211 - _82_01 */  0x214b,
/* 212 - _82_02 */  0x214c,
/* 213 - _82_03 */  0x214d,
/* 214 - _82_04 */  0x214e,
/* 215 - _82_05 */  0x214f,
/* 216 - _82_06 */  0x2150,
/* 217 - _82_07 */  0x2151,
/* 218 - _83_00 */  0x2152,
/* 219 - _83_01 */  0x2153,
/* 21a - _83_02 */  0x2154,
/* 21b - _83_03 */  0x2155,
/* 21c - _83_04 */  0x2156,
/* 21d - _83_05 */  0x2157,
/* 21e - _83_06 */  0x2158,
/* 21f - _83_07 */  0x2159,
/* 220 - _8F_00 */  0x215a,
/* 221 -  */  0,
/* 222 -  */  0,
/* 223 -  */  0,
/* 224 -  */  0,
/* 225 -  */  0,
/* 226 -  */  0,
/* 227 -  */  0,
/* 228 - _C0_00 */  0x215b,
/* 229 - _C0_01 */  0x215c,
/* 22a - _C0_02 */  0x215d,
/* 22b - _C0_03 */  0x215e,
/* 22c - _C0_04 */  0x215f,
/* 22d - _C0_05 */  0x2160,
/* 22e - _C0_06 */  0x2161,
/* 22f - _C0_07 */  0x2162,
/* 230 - _C1_00 */  0x2163,
/* 231 - _C1_01 */  0x2164,
/* 232 - _C1_02 */  0x2165,
/* 233 - _C1_03 */  0x2166,
/* 234 - _C1_04 */  0x2167,
/* 235 - _C1_05 */  0x2168,
/* 236 - _C1_06 */  0x2169,
/* 237 - _C1_07 */  0x216a,
/* 238 - _C6_00 */  0x216b,
/* 239 -  */  0,
/* 23a -  */  0,
/* 23b -  */  0,
/* 23c -  */  0,
/* 23d -  */  0,
/* 23e -  */  0,
/* 23f -  */  0,
/* 240 - _C7_00 */  0x216c,
/* 241 -  */  0,
/* 242 -  */  0,
/* 243 -  */  0,
/* 244 -  */  0,
/* 245 -  */  0,
/* 246 -  */  0,
/* 247 -  */  0,
/* 248 - _D0_00 */  0x216d,
/* 249 - _D0_01 */  0x216e,
/* 24a - _D0_02 */  0x216f,
/* 24b - _D0_03 */  0x2170,
/* 24c - _D0_04 */  0x2171,
/* 24d - _D0_05 */  0x2172,
/* 24e - _D0_06 */  0x2173,
/* 24f - _D0_07 */  0x2174,
/* 250 - _D1_00 */  0x2175,
/* 251 - _D1_01 */  0x2176,
/* 252 - _D1_02 */  0x2177,
/* 253 - _D1_03 */  0x2178,
/* 254 - _D1_04 */  0x2179,
/* 255 - _D1_05 */  0x217a,
/* 256 - _D1_06 */  0x217b,
/* 257 - _D1_07 */  0x217c,
/* 258 - _D2_00 */  0x217d,
/* 259 - _D2_01 */  0x217e,
/* 25a - _D2_02 */  0x217f,
/* 25b - _D2_03 */  0x2180,
/* 25c - _D2_04 */  0x2181,
/* 25d - _D2_05 */  0x2182,
/* 25e - _D2_06 */  0x2183,
/* 25f - _D2_07 */  0x2184,
/* 260 - _D3_00 */  0x2185,
/* 261 - _D3_01 */  0x2186,
/* 262 - _D3_02 */  0x2187,
/* 263 - _D3_03 */  0x2188,
/* 264 - _D3_04 */  0x2189,
/* 265 - _D3_05 */  0x218a,
/* 266 - _D3_06 */  0x218b,
/* 267 - _D3_07 */  0x218c,
/* 268 - _D8_00 */  0x218d,
/* 269 - _D8_01 */  0x218e,
/* 26a - _D8_02 */  0x218f,
/* 26b - _D8_03 */  0x2190,
/* 26c - _D8_04 */  0x2191,
/* 26d - _D8_05 */  0x2192,
/* 26e - _D8_06 */  0x2193,
/* 26f - _D8_07 */  0x2194,
/* 270 - _D8_C0 */  0x2195,
/* 271 - _D8_C0 */  0x2196,
/* 272 - _D8_C0 */  0x2197,
/* 273 - _D8_C0 */  0x2198,
/* 274 - _D8_C0 */  0x2199,
/* 275 - _D8_C0 */  0x219a,
/* 276 - _D8_C0 */  0x219b,
/* 277 - _D8_C0 */  0x219c,
/* 278 - _D8_C8 */  0x219d,
/* 279 - _D8_C8 */  0x219e,
/* 27a - _D8_C8 */  0x219f,
/* 27b - _D8_C8 */  0x21a0,
/* 27c - _D8_C8 */  0x21a1,
/* 27d - _D8_C8 */  0x21a2,
/* 27e - _D8_C8 */  0x21a3,
/* 27f - _D8_C8 */  0x21a4,
/* 280 - _D8_D0 */  0x21a5,
/* 281 - _D8_D0 */  0x21a6,
/* 282 - _D8_D0 */  0x21a7,
/* 283 - _D8_D0 */  0x21a8,
/* 284 - _D8_D0 */  0x21a9,
/* 285 - _D8_D0 */  0x21aa,
/* 286 - _D8_D0 */  0x21ab,
/* 287 - _D8_D0 */  0x21ac,
/* 288 - _D8_D8 */  0x21ad,
/* 289 - _D8_D9 */  0x21ae,
/* 28a - _D8_D8 */  0x21af,
/* 28b - _D8_D8 */  0x21b0,
/* 28c - _D8_D8 */  0x21b1,
/* 28d - _D8_D8 */  0x21b2,
/* 28e - _D8_D8 */  0x21b3,
/* 28f - _D8_D8 */  0x21b4,
/* 290 - _D8_E0 */  0x21b5,
/* 291 - _D8_E0 */  0x21b6,
/* 292 - _D8_E0 */  0x21b7,
/* 293 - _D8_E0 */  0x21b8,
/* 294 - _D8_E0 */  0x21b9,
/* 295 - _D8_E0 */  0x21ba,
/* 296 - _D8_E0 */  0x21bb,
/* 297 - _D8_E0 */  0x21bc,
/* 298 - _D8_E8 */  0x21bd,
/* 299 - _D8_E8 */  0x21be,
/* 29a - _D8_E8 */  0x21bf,
/* 29b - _D8_E8 */  0x21c0,
/* 29c - _D8_E8 */  0x21c1,
/* 29d - _D8_E8 */  0x21c2,
/* 29e - _D8_E8 */  0x21c3,
/* 29f - _D8_E8 */  0x21c4,
/* 2a0 - _D8_F0 */  0x21c5,
/* 2a1 - _D8_F0 */  0x21c6,
/* 2a2 - _D8_F0 */  0x21c7,
/* 2a3 - _D8_F0 */  0x21c8,
/* 2a4 - _D8_F0 */  0x21c9,
/* 2a5 - _D8_F0 */  0x21ca,
/* 2a6 - _D8_F0 */  0x21cb,
/* 2a7 - _D8_F0 */  0x21cc,
/* 2a8 - _D8_F8 */  0x21cd,
/* 2a9 - _D8_F8 */  0x21ce,
/* 2aa - _D8_F8 */  0x21cf,
/* 2ab - _D8_F8 */  0x21d0,
/* 2ac - _D8_F8 */  0x21d1,
/* 2ad - _D8_F8 */  0x21d2,
/* 2ae - _D8_F8 */  0x21d3,
/* 2af - _D8_F8 */  0x21d4,
/* 2b0 - _D9_00 */  0x21d5,
/* 2b1 -  */  0,
/* 2b2 - _D9_02 */  0x21d6,
/* 2b3 - _D9_03 */  0x21d7,
/* 2b4 - _D9_04 */  0x21d8,
/* 2b5 - _D9_05 */  0x21d9,
/* 2b6 - _D9_06 */  0xcea4,
/* 2b7 - _D9_07 */  0xceb0,
/* 2b8 - _D9_C0 */  0x21da,
/* 2b9 - _D9_C0 */  0x21db,
/* 2ba - _D9_C0 */  0x21dc,
/* 2bb - _D9_C0 */  0x21dd,
/* 2bc - _D9_C0 */  0x21de,
/* 2bd - _D9_C0 */  0x21df,
/* 2be - _D9_C0 */  0x21e0,
/* 2bf - _D9_C0 */  0x21e1,
/* 2c0 - _D9_C8 */  0x21e2,
/* 2c1 - _D9_C9 */  0x21e3,
/* 2c2 - _D9_C8 */  0x21e4,
/* 2c3 - _D9_C8 */  0x21e5,
/* 2c4 - _D9_C8 */  0x21e6,
/* 2c5 - _D9_C8 */  0x21e7,
/* 2c6 - _D9_C8 */  0x21e8,
/* 2c7 - _D9_C8 */  0x21e9,
/* 2c8 - _D9_D0 */  0x21ea,
/* 2c9 -  */  0,
/* 2ca -  */  0,
/* 2cb -  */  0,
/* 2cc -  */  0,
/* 2cd -  */  0,
/* 2ce -  */  0,
/* 2cf -  */  0,
/* 2d0 -  */  0,
/* 2d1 -  */  0,
/* 2d2 -  */  0,
/* 2d3 -  */  0,
/* 2d4 -  */  0,
/* 2d5 -  */  0,
/* 2d6 -  */  0,
/* 2d7 -  */  0,
/* 2d8 - _D9_E0 */  0x21eb,
/* 2d9 - _D9_E1 */  0x21ec,
/* 2da -  */  0,
/* 2db -  */  0,
/* 2dc - _D9_E4 */  0x21ed,
/* 2dd - _D9_E5 */  0x21ee,
/* 2de -  */  0,
/* 2df -  */  0,
/* 2e0 - _D9_E8 */  0x21ef,
/* 2e1 - _D9_E9 */  0x21f0,
/* 2e2 - _D9_EA */  0x21f1,
/* 2e3 - _D9_EB */  0x21f2,
/* 2e4 - _D9_EC */  0x21f3,
/* 2e5 - _D9_ED */  0x21f4,
/* 2e6 - _D9_EE */  0x21f5,
/* 2e7 -  */  0,
/* 2e8 - _D9_F0 */  0x21f6,
/* 2e9 - _D9_F1 */  0x21f7,
/* 2ea - _D9_F2 */  0x21f8,
/* 2eb - _D9_F3 */  0x21f9,
/* 2ec - _D9_F4 */  0x21fa,
/* 2ed - _D9_F5 */  0x21fb,
/* 2ee - _D9_F6 */  0x21fc,
/* 2ef - _D9_F7 */  0x21fd,
/* 2f0 - _D9_F8 */  0x21fe,
/* 2f1 - _D9_F9 */  0x21ff,
/* 2f2 - _D9_FA */  0x2200,
/* 2f3 - _D9_FB */  0x2201,
/* 2f4 - _D9_FC */  0x2202,
/* 2f5 - _D9_FD */  0x2203,
/* 2f6 - _D9_FE */  0x2204,
/* 2f7 - _D9_FF */  0x2205,
/* 2f8 - _DA_00 */  0x2206,
/* 2f9 - _DA_01 */  0x2207,
/* 2fa - _DA_02 */  0x2208,
/* 2fb - _DA_03 */  0x2209,
/* 2fc - _DA_04 */  0x220a,
/* 2fd - _DA_05 */  0x220b,
/* 2fe - _DA_06 */  0x220c,
/* 2ff - _DA_07 */  0x220d,
/* 300 - _DA_C0 */  0x220e,
/* 301 - _DA_C0 */  0x220f,
/* 302 - _DA_C0 */  0x2210,
/* 303 - _DA_C0 */  0x2211,
/* 304 - _DA_C0 */  0x2212,
/* 305 - _DA_C0 */  0x2213,
/* 306 - _DA_C0 */  0x2214,
/* 307 - _DA_C0 */  0x2215,
/* 308 - _DA_C8 */  0x2216,
/* 309 - _DA_C8 */  0x2217,
/* 30a - _DA_C8 */  0x2218,
/* 30b - _DA_C8 */  0x2219,
/* 30c - _DA_C8 */  0x221a,
/* 30d - _DA_C8 */  0x221b,
/* 30e - _DA_C8 */  0x221c,
/* 30f - _DA_C8 */  0x221d,
/* 310 - _DA_D0 */  0x221e,
/* 311 - _DA_D0 */  0x221f,
/* 312 - _DA_D0 */  0x2220,
/* 313 - _DA_D0 */  0x2221,
/* 314 - _DA_D0 */  0x2222,
/* 315 - _DA_D0 */  0x2223,
/* 316 - _DA_D0 */  0x2224,
/* 317 - _DA_D0 */  0x2225,
/* 318 - _DA_D8 */  0x2226,
/* 319 - _DA_D8 */  0x2227,
/* 31a - _DA_D8 */  0x2228,
/* 31b - _DA_D8 */  0x2229,
/* 31c - _DA_D8 */  0x222a,
/* 31d - _DA_D8 */  0x222b,
/* 31e - _DA_D8 */  0x222c,
/* 31f - _DA_D8 */  0x222d,
/* 320 -  */  0,
/* 321 -  */  0,
/* 322 -  */  0,
/* 323 -  */  0,
/* 324 -  */  0,
/* 325 -  */  0,
/* 326 -  */  0,
/* 327 -  */  0,
/* 328 -  */  0,
/* 329 - _DA_E9 */  0x222e,
/* 32a -  */  0,
/* 32b -  */  0,
/* 32c -  */  0,
/* 32d -  */  0,
/* 32e -  */  0,
/* 32f -  */  0,
/* 330 -  */  0,
/* 331 -  */  0,
/* 332 -  */  0,
/* 333 -  */  0,
/* 334 -  */  0,
/* 335 -  */  0,
/* 336 -  */  0,
/* 337 -  */  0,
/* 338 -  */  0,
/* 339 -  */  0,
/* 33a -  */  0,
/* 33b -  */  0,
/* 33c -  */  0,
/* 33d -  */  0,
/* 33e -  */  0,
/* 33f -  */  0,
/* 340 - _DB_00 */  0x222f,
/* 341 - _DB_01 */  0x2230,
/* 342 - _DB_02 */  0x2231,
/* 343 - _DB_03 */  0x2232,
/* 344 -  */  0,
/* 345 - _DB_05 */  0x2233,
/* 346 -  */  0,
/* 347 - _DB_07 */  0x2234,
/* 348 - _DB_C0 */  0x2235,
/* 349 - _DB_C0 */  0x2236,
/* 34a - _DB_C0 */  0x2237,
/* 34b - _DB_C0 */  0x2238,
/* 34c - _DB_C0 */  0x2239,
/* 34d - _DB_C0 */  0x223a,
/* 34e - _DB_C0 */  0x223b,
/* 34f - _DB_C0 */  0x223c,
/* 350 - _DB_C8 */  0x223d,
/* 351 - _DB_C8 */  0x223e,
/* 352 - _DB_C8 */  0x223f,
/* 353 - _DB_C8 */  0x2240,
/* 354 - _DB_C8 */  0x2241,
/* 355 - _DB_C8 */  0x2242,
/* 356 - _DB_C8 */  0x2243,
/* 357 - _DB_C8 */  0x2244,
/* 358 - _DB_D0 */  0x2245,
/* 359 - _DB_D0 */  0x2246,
/* 35a - _DB_D0 */  0x2247,
/* 35b - _DB_D0 */  0x2248,
/* 35c - _DB_D0 */  0x2249,
/* 35d - _DB_D0 */  0x224a,
/* 35e - _DB_D0 */  0x224b,
/* 35f - _DB_D0 */  0x224c,
/* 360 - _DB_D8 */  0x224d,
/* 361 - _DB_D8 */  0x224e,
/* 362 - _DB_D8 */  0x224f,
/* 363 - _DB_D8 */  0x2250,
/* 364 - _DB_D8 */  0x2251,
/* 365 - _DB_D8 */  0x2252,
/* 366 - _DB_D8 */  0x2253,
/* 367 - _DB_D8 */  0x2254,
/* 368 - _DB_E0 */  0x2255,
/* 369 - _DB_E1 */  0x2256,
/* 36a - _DB_E2 */  0xcebc,
/* 36b - _DB_E3 */  0xcec8,
/* 36c - _DB_E4 */  0x2257,
/* 36d -  */  0,
/* 36e -  */  0,
/* 36f -  */  0,
/* 370 - _DB_E8 */  0x2258,
/* 371 - _DB_E8 */  0x2259,
/* 372 - _DB_E8 */  0x225a,
/* 373 - _DB_E8 */  0x225b,
/* 374 - _DB_E8 */  0x225c,
/* 375 - _DB_E8 */  0x225d,
/* 376 - _DB_E8 */  0x225e,
/* 377 - _DB_E8 */  0x225f,
/* 378 - _DB_F0 */  0x2260,
/* 379 - _DB_F0 */  0x2261,
/* 37a - _DB_F0 */  0x2262,
/* 37b - _DB_F0 */  0x2263,
/* 37c - _DB_F0 */  0x2264,
/* 37d - _DB_F0 */  0x2265,
/* 37e - _DB_F0 */  0x2266,
/* 37f - _DB_F0 */  0x2267,
/* 380 -  */  0,
/* 381 -  */  0,
/* 382 -  */  0,
/* 383 -  */  0,
/* 384 -  */  0,
/* 385 -  */  0,
/* 386 -  */  0,
/* 387 -  */  0,
/* 388 - _DC_00 */  0x2268,
/* 389 - _DC_01 */  0x2269,
/* 38a - _DC_02 */  0x226a,
/* 38b - _DC_03 */  0x226b,
/* 38c - _DC_04 */  0x226c,
/* 38d - _DC_05 */  0x226d,
/* 38e - _DC_06 */  0x226e,
/* 38f - _DC_07 */  0x226f,
/* 390 - _DC_C0 */  0x2270,
/* 391 - _DC_C0 */  0x2271,
/* 392 - _DC_C0 */  0x2272,
/* 393 - _DC_C0 */  0x2273,
/* 394 - _DC_C0 */  0x2274,
/* 395 - _DC_C0 */  0x2275,
/* 396 - _DC_C0 */  0x2276,
/* 397 - _DC_C0 */  0x2277,
/* 398 - _DC_C8 */  0x2278,
/* 399 - _DC_C8 */  0x2279,
/* 39a - _DC_C8 */  0x227a,
/* 39b - _DC_C8 */  0x227b,
/* 39c - _DC_C8 */  0x227c,
/* 39d - _DC_C8 */  0x227d,
/* 39e - _DC_C8 */  0x227e,
/* 39f - _DC_C8 */  0x227f,
/* 3a0 -  */  0,
/* 3a1 -  */  0,
/* 3a2 -  */  0,
/* 3a3 -  */  0,
/* 3a4 -  */  0,
/* 3a5 -  */  0,
/* 3a6 -  */  0,
/* 3a7 -  */  0,
/* 3a8 -  */  0,
/* 3a9 -  */  0,
/* 3aa -  */  0,
/* 3ab -  */  0,
/* 3ac -  */  0,
/* 3ad -  */  0,
/* 3ae -  */  0,
/* 3af -  */  0,
/* 3b0 - _DC_E0 */  0x2280,
/* 3b1 - _DC_E0 */  0x2281,
/* 3b2 - _DC_E0 */  0x2282,
/* 3b3 - _DC_E0 */  0x2283,
/* 3b4 - _DC_E0 */  0x2284,
/* 3b5 - _DC_E0 */  0x2285,
/* 3b6 - _DC_E0 */  0x2286,
/* 3b7 - _DC_E0 */  0x2287,
/* 3b8 - _DC_E8 */  0x2288,
/* 3b9 - _DC_E8 */  0x2289,
/* 3ba - _DC_E8 */  0x228a,
/* 3bb - _DC_E8 */  0x228b,
/* 3bc - _DC_E8 */  0x228c,
/* 3bd - _DC_E8 */  0x228d,
/* 3be - _DC_E8 */  0x228e,
/* 3bf - _DC_E8 */  0x228f,
/* 3c0 - _DC_F0 */  0x2290,
/* 3c1 - _DC_F0 */  0x2291,
/* 3c2 - _DC_F0 */  0x2292,
/* 3c3 - _DC_F0 */  0x2293,
/* 3c4 - _DC_F0 */  0x2294,
/* 3c5 - _DC_F0 */  0x2295,
/* 3c6 - _DC_F0 */  0x2296,
/* 3c7 - _DC_F0 */  0x2297,
/* 3c8 - _DC_F8 */  0x2298,
/* 3c9 - _DC_F8 */  0x2299,
/* 3ca - _DC_F8 */  0x229a,
/* 3cb - _DC_F8 */  0x229b,
/* 3cc - _DC_F8 */  0x229c,
/* 3cd - _DC_F8 */  0x229d,
/* 3ce - _DC_F8 */  0x229e,
/* 3cf - _DC_F8 */  0x229f,
/* 3d0 - _DD_00 */  0x22a0,
/* 3d1 - _DD_01 */  0x22a1,
/* 3d2 - _DD_02 */  0x22a2,
/* 3d3 - _DD_03 */  0x22a3,
/* 3d4 - _DD_04 */  0x22a4,
/* 3d5 -  */  0,
/* 3d6 - _DD_06 */  0xced4,
/* 3d7 - _DD_07 */  0xcee0,
/* 3d8 - _DD_C0 */  0x22a5,
/* 3d9 - _DD_C0 */  0x22a6,
/* 3da - _DD_C0 */  0x22a7,
/* 3db - _DD_C0 */  0x22a8,
/* 3dc - _DD_C0 */  0x22a9,
/* 3dd - _DD_C0 */  0x22aa,
/* 3de - _DD_C0 */  0x22ab,
/* 3df - _DD_C0 */  0x22ac,
/* 3e0 -  */  0,
/* 3e1 -  */  0,
/* 3e2 -  */  0,
/* 3e3 -  */  0,
/* 3e4 -  */  0,
/* 3e5 -  */  0,
/* 3e6 -  */  0,
/* 3e7 -  */  0,
/* 3e8 - _DD_D0 */  0x22ad,
/* 3e9 - _DD_D0 */  0x22ae,
/* 3ea - _DD_D0 */  0x22af,
/* 3eb - _DD_D0 */  0x22b0,
/* 3ec - _DD_D0 */  0x22b1,
/* 3ed - _DD_D0 */  0x22b2,
/* 3ee - _DD_D0 */  0x22b3,
/* 3ef - _DD_D0 */  0x22b4,
/* 3f0 - _DD_D8 */  0x22b5,
/* 3f1 - _DD_D8 */  0x22b6,
/* 3f2 - _DD_D8 */  0x22b7,
/* 3f3 - _DD_D8 */  0x22b8,
/* 3f4 - _DD_D8 */  0x22b9,
/* 3f5 - _DD_D8 */  0x22ba,
/* 3f6 - _DD_D8 */  0x22bb,
/* 3f7 - _DD_D8 */  0x22bc,
/* 3f8 - _DD_E0 */  0x22bd,
/* 3f9 - _DD_E1 */  0x22be,
/* 3fa - _DD_E0 */  0x22bf,
/* 3fb - _DD_E0 */  0x22c0,
/* 3fc - _DD_E0 */  0x22c1,
/* 3fd - _DD_E0 */  0x22c2,
/* 3fe - _DD_E0 */  0x22c3,
/* 3ff - _DD_E0 */  0x22c4,
/* 400 - _DD_E8 */  0x22c5,
/* 401 - _DD_E9 */  0x22c6,
/* 402 - _DD_E8 */  0x22c7,
/* 403 - _DD_E8 */  0x22c8,
/* 404 - _DD_E8 */  0x22c9,
/* 405 - _DD_E8 */  0x22ca,
/* 406 - _DD_E8 */  0x22cb,
/* 407 - _DD_E8 */  0x22cc,
/* 408 -  */  0,
/* 409 -  */  0,
/* 40a -  */  0,
/* 40b -  */  0,
/* 40c -  */  0,
/* 40d -  */  0,
/* 40e -  */  0,
/* 40f -  */  0,
/* 410 -  */  0,
/* 411 -  */  0,
/* 412 -  */  0,
/* 413 -  */  0,
/* 414 -  */  0,
/* 415 -  */  0,
/* 416 -  */  0,
/* 417 -  */  0,
/* 418 - _DE_00 */  0x22cd,
/* 419 - _DE_01 */  0x22ce,
/* 41a - _DE_02 */  0x22cf,
/* 41b - _DE_03 */  0x22d0,
/* 41c - _DE_04 */  0x22d1,
/* 41d - _DE_05 */  0x22d2,
/* 41e - _DE_06 */  0x22d3,
/* 41f - _DE_07 */  0x22d4,
/* 420 - _DE_C0 */  0x22d5,
/* 421 - _DE_C1 */  0x22d6,
/* 422 - _DE_C0 */  0x22d7,
/* 423 - _DE_C0 */  0x22d8,
/* 424 - _DE_C0 */  0x22d9,
/* 425 - _DE_C0 */  0x22da,
/* 426 - _DE_C0 */  0x22db,
/* 427 - _DE_C0 */  0x22dc,
/* 428 - _DE_C8 */  0x22dd,
/* 429 - _DE_C9 */  0x22de,
/* 42a - _DE_C8 */  0x22df,
/* 42b - _DE_C8 */  0x22e0,
/* 42c - _DE_C8 */  0x22e1,
/* 42d - _DE_C8 */  0x22e2,
/* 42e - _DE_C8 */  0x22e3,
/* 42f - _DE_C8 */  0x22e4,
/* 430 -  */  0,
/* 431 -  */  0,
/* 432 -  */  0,
/* 433 -  */  0,
/* 434 -  */  0,
/* 435 -  */  0,
/* 436 -  */  0,
/* 437 -  */  0,
/* 438 -  */  0,
/* 439 - _DE_D9 */  0x22e5,
/* 43a -  */  0,
/* 43b -  */  0,
/* 43c -  */  0,
/* 43d -  */  0,
/* 43e -  */  0,
/* 43f -  */  0,
/* 440 - _DE_E0 */  0x22e6,
/* 441 - _DE_E1 */  0x22e7,
/* 442 - _DE_E0 */  0x22e8,
/* 443 - _DE_E0 */  0x22e9,
/* 444 - _DE_E0 */  0x22ea,
/* 445 - _DE_E0 */  0x22eb,
/* 446 - _DE_E0 */  0x22ec,
/* 447 - _DE_E0 */  0x22ed,
/* 448 - _DE_E8 */  0x22ee,
/* 449 - _DE_E9 */  0x22ef,
/* 44a - _DE_E8 */  0x22f0,
/* 44b - _DE_E8 */  0x22f1,
/* 44c - _DE_E8 */  0x22f2,
/* 44d - _DE_E8 */  0x22f3,
/* 44e - _DE_E8 */  0x22f4,
/* 44f - _DE_E8 */  0x22f5,
/* 450 - _DE_F0 */  0x22f6,
/* 451 - _DE_F1 */  0x22f7,
/* 452 - _DE_F0 */  0x22f8,
/* 453 - _DE_F0 */  0x22f9,
/* 454 - _DE_F0 */  0x22fa,
/* 455 - _DE_F0 */  0x22fb,
/* 456 - _DE_F0 */  0x22fc,
/* 457 - _DE_F0 */  0x22fd,
/* 458 - _DE_F8 */  0x22fe,
/* 459 - _DE_F9 */  0x22ff,
/* 45a - _DE_F8 */  0x2300,
/* 45b - _DE_F8 */  0x2301,
/* 45c - _DE_F8 */  0x2302,
/* 45d - _DE_F8 */  0x2303,
/* 45e - _DE_F8 */  0x2304,
/* 45f - _DE_F8 */  0x2305,
/* 460 - _DF_00 */  0x2306,
/* 461 - _DF_01 */  0x2307,
/* 462 - _DF_02 */  0x2308,
/* 463 - _DF_03 */  0x2309,
/* 464 - _DF_04 */  0x230a,
/* 465 - _DF_05 */  0x230b,
/* 466 - _DF_06 */  0x230c,
/* 467 - _DF_07 */  0x230d,
/* 468 -  */  0,
/* 469 -  */  0,
/* 46a -  */  0,
/* 46b -  */  0,
/* 46c -  */  0,
/* 46d -  */  0,
/* 46e -  */  0,
/* 46f -  */  0,
/* 470 -  */  0,
/* 471 -  */  0,
/* 472 -  */  0,
/* 473 -  */  0,
/* 474 -  */  0,
/* 475 -  */  0,
/* 476 -  */  0,
/* 477 -  */  0,
/* 478 -  */  0,
/* 479 -  */  0,
/* 47a -  */  0,
/* 47b -  */  0,
/* 47c -  */  0,
/* 47d -  */  0,
/* 47e -  */  0,
/* 47f -  */  0,
/* 480 -  */  0,
/* 481 -  */  0,
/* 482 -  */  0,
/* 483 -  */  0,
/* 484 -  */  0,
/* 485 -  */  0,
/* 486 -  */  0,
/* 487 -  */  0,
/* 488 - _DF_E0 */  0xceec,
/* 489 -  */  0,
/* 48a -  */  0,
/* 48b -  */  0,
/* 48c -  */  0,
/* 48d -  */  0,
/* 48e -  */  0,
/* 48f -  */  0,
/* 490 - _DF_E8 */  0x230e,
/* 491 - _DF_E8 */  0x230f,
/* 492 - _DF_E8 */  0x2310,
/* 493 - _DF_E8 */  0x2311,
/* 494 - _DF_E8 */  0x2312,
/* 495 - _DF_E8 */  0x2313,
/* 496 - _DF_E8 */  0x2314,
/* 497 - _DF_E8 */  0x2315,
/* 498 - _DF_F0 */  0x2316,
/* 499 - _DF_F0 */  0x2317,
/* 49a - _DF_F0 */  0x2318,
/* 49b - _DF_F0 */  0x2319,
/* 49c - _DF_F0 */  0x231a,
/* 49d - _DF_F0 */  0x231b,
/* 49e - _DF_F0 */  0x231c,
/* 49f - _DF_F0 */  0x231d,
/* 4a0 -  */  0,
/* 4a1 -  */  0,
/* 4a2 -  */  0,
/* 4a3 -  */  0,
/* 4a4 -  */  0,
/* 4a5 -  */  0,
/* 4a6 -  */  0,
/* 4a7 -  */  0,
/* 4a8 - _F6_00 */  0x231e,
/* 4a9 -  */  0,
/* 4aa - _F6_02 */  0x231f,
/* 4ab - _F6_03 */  0x2320,
/* 4ac - _F6_04 */  0x2321,
/* 4ad - _F6_05 */  0x2322,
/* 4ae - _F6_06 */  0x2323,
/* 4af - _F6_07 */  0x2324,
/* 4b0 - _F7_00 */  0x2325,
/* 4b1 -  */  0,
/* 4b2 - _F7_02 */  0x2326,
/* 4b3 - _F7_03 */  0x2327,
/* 4b4 - _F7_04 */  0x2328,
/* 4b5 - _F7_05 */  0x2329,
/* 4b6 - _F7_06 */  0x232a,
/* 4b7 - _F7_07 */  0x232b,
/* 4b8 - _FE_00 */  0x232c,
/* 4b9 - _FE_01 */  0x232d,
/* 4ba -  */  0,
/* 4bb -  */  0,
/* 4bc -  */  0,
/* 4bd -  */  0,
/* 4be -  */  0,
/* 4bf -  */  0,
/* 4c0 - _FF_00 */  0x232e,
/* 4c1 - _FF_01 */  0x232f,
/* 4c2 - _FF_02 */  0x2330,
/* 4c3 - _FF_03 */  0x2331,
/* 4c4 - _FF_04 */  0x2332,
/* 4c5 - _FF_05 */  0x2333,
/* 4c6 - _FF_06 */  0x2334,
/* 4c7 -  */  0,
/* 4c8 - _0F_00_00 */  0x2335,
/* 4c9 - _0F_00_01 */  0x2336,
/* 4ca - _0F_00_02 */  0x2337,
/* 4cb - _0F_00_03 */  0x2338,
/* 4cc - _0F_00_04 */  0x2339,
/* 4cd - _0F_00_05 */  0x233a,
/* 4ce -  */  0,
/* 4cf -  */  0,
/* 4d0 - _0F_01_00 */  0x233b,
/* 4d1 - _0F_01_01 */  0x233c,
/* 4d2 - _0F_01_02 */  0x233d,
/* 4d3 - _0F_01_03 */  0x233e,
/* 4d4 - _0F_01_04 */  0x233f,
/* 4d5 -  */  0,
/* 4d6 - _0F_01_06 */  0x2340,
/* 4d7 - _0F_01_07 */  0x2341,
/* 4d8 -  */  0,
/* 4d9 - _0F_01_C1 */  0x2342,
/* 4da - _0F_01_C2 */  0x2343,
/* 4db - _0F_01_C3 */  0x2344,
/* 4dc - _0F_01_C4 */  0x2345,
/* 4dd -  */  0,
/* 4de -  */  0,
/* 4df -  */  0,
/* 4e0 - _0F_01_C8 */  0x2346,
/* 4e1 - _0F_01_C9 */  0x2347,
/* 4e2 -  */  0,
/* 4e3 -  */  0,
/* 4e4 -  */  0,
/* 4e5 -  */  0,
/* 4e6 -  */  0,
/* 4e7 -  */  0,
/* 4e8 - _0F_01_D0 */  0x2348,
/* 4e9 - _0F_01_D1 */  0x2349,
/* 4ea -  */  0,
/* 4eb -  */  0,
/* 4ec - _0F_01_D4 */  0x234a,
/* 4ed -  */  0,
/* 4ee -  */  0,
/* 4ef -  */  0,
/* 4f0 - _0F_01_D8 */  0x234b,
/* 4f1 - _0F_01_D9 */  0x234c,
/* 4f2 - _0F_01_DA */  0x234d,
/* 4f3 - _0F_01_DB */  0x234e,
/* 4f4 - _0F_01_DC */  0x234f,
/* 4f5 - _0F_01_DD */  0x2350,
/* 4f6 - _0F_01_DE */  0x2351,
/* 4f7 - _0F_01_DF */  0x2352,
/* 4f8 -  */  0,
/* 4f9 -  */  0,
/* 4fa -  */  0,
/* 4fb -  */  0,
/* 4fc -  */  0,
/* 4fd -  */  0,
/* 4fe -  */  0,
/* 4ff -  */  0,
/* 500 -  */  0,
/* 501 -  */  0,
/* 502 -  */  0,
/* 503 -  */  0,
/* 504 -  */  0,
/* 505 -  */  0,
/* 506 -  */  0,
/* 507 -  */  0,
/* 508 -  */  0,
/* 509 -  */  0,
/* 50a -  */  0,
/* 50b -  */  0,
/* 50c -  */  0,
/* 50d -  */  0,
/* 50e -  */  0,
/* 50f -  */  0,
/* 510 - _0F_01_F8 */  0x2353,
/* 511 - _0F_01_F9 */  0x2354,
/* 512 -  */  0,
/* 513 -  */  0,
/* 514 -  */  0,
/* 515 -  */  0,
/* 516 -  */  0,
/* 517 -  */  0,
/* 518 - _0F_0D_00 */  0x2355,
/* 519 - _0F_0D_01 */  0x2356,
/* 51a -  */  0,
/* 51b -  */  0,
/* 51c -  */  0,
/* 51d -  */  0,
/* 51e -  */  0,
/* 51f -  */  0,
/* 520 -  */  0,
/* 521 -  */  0,
/* 522 -  */  0,
/* 523 -  */  0,
/* 524 -  */  0,
/* 525 -  */  0,
/* 526 -  */  0,
/* 527 -  */  0,
/* 528 -  */  0,
/* 529 -  */  0,
/* 52a -  */  0,
/* 52b -  */  0,
/* 52c - _0F_0F_0C */  0x2357,
/* 52d - _0F_0F_0D */  0x2358,
/* 52e -  */  0,
/* 52f -  */  0,
/* 530 -  */  0,
/* 531 -  */  0,
/* 532 -  */  0,
/* 533 -  */  0,
/* 534 -  */  0,
/* 535 -  */  0,
/* 536 -  */  0,
/* 537 -  */  0,
/* 538 -  */  0,
/* 539 -  */  0,
/* 53a -  */  0,
/* 53b -  */  0,
/* 53c - _0F_0F_1C */  0x2359,
/* 53d - _0F_0F_1D */  0x235a,
/* 53e -  */  0,
/* 53f -  */  0,
/* 540 -  */  0,
/* 541 -  */  0,
/* 542 -  */  0,
/* 543 -  */  0,
/* 544 -  */  0,
/* 545 -  */  0,
/* 546 -  */  0,
/* 547 -  */  0,
/* 548 -  */  0,
/* 549 -  */  0,
/* 54a -  */  0,
/* 54b -  */  0,
/* 54c -  */  0,
/* 54d -  */  0,
/* 54e -  */  0,
/* 54f -  */  0,
/* 550 -  */  0,
/* 551 -  */  0,
/* 552 -  */  0,
/* 553 -  */  0,
/* 554 -  */  0,
/* 555 -  */  0,
/* 556 -  */  0,
/* 557 -  */  0,
/* 558 -  */  0,
/* 559 -  */  0,
/* 55a -  */  0,
/* 55b -  */  0,
/* 55c -  */  0,
/* 55d -  */  0,
/* 55e -  */  0,
/* 55f -  */  0,
/* 560 -  */  0,
/* 561 -  */  0,
/* 562 -  */  0,
/* 563 -  */  0,
/* 564 -  */  0,
/* 565 -  */  0,
/* 566 -  */  0,
/* 567 -  */  0,
/* 568 -  */  0,
/* 569 -  */  0,
/* 56a -  */  0,
/* 56b -  */  0,
/* 56c -  */  0,
/* 56d -  */  0,
/* 56e -  */  0,
/* 56f -  */  0,
/* 570 -  */  0,
/* 571 -  */  0,
/* 572 -  */  0,
/* 573 -  */  0,
/* 574 -  */  0,
/* 575 -  */  0,
/* 576 -  */  0,
/* 577 -  */  0,
/* 578 -  */  0,
/* 579 -  */  0,
/* 57a -  */  0,
/* 57b -  */  0,
/* 57c -  */  0,
/* 57d -  */  0,
/* 57e -  */  0,
/* 57f -  */  0,
/* 580 -  */  0,
/* 581 -  */  0,
/* 582 -  */  0,
/* 583 -  */  0,
/* 584 -  */  0,
/* 585 -  */  0,
/* 586 -  */  0,
/* 587 -  */  0,
/* 588 -  */  0,
/* 589 -  */  0,
/* 58a -  */  0,
/* 58b -  */  0,
/* 58c -  */  0,
/* 58d -  */  0,
/* 58e -  */  0,
/* 58f -  */  0,
/* 590 -  */  0,
/* 591 -  */  0,
/* 592 -  */  0,
/* 593 -  */  0,
/* 594 -  */  0,
/* 595 -  */  0,
/* 596 -  */  0,
/* 597 -  */  0,
/* 598 -  */  0,
/* 599 -  */  0,
/* 59a -  */  0,
/* 59b -  */  0,
/* 59c -  */  0,
/* 59d -  */  0,
/* 59e -  */  0,
/* 59f -  */  0,
/* 5a0 -  */  0,
/* 5a1 -  */  0,
/* 5a2 -  */  0,
/* 5a3 -  */  0,
/* 5a4 -  */  0,
/* 5a5 -  */  0,
/* 5a6 -  */  0,
/* 5a7 -  */  0,
/* 5a8 -  */  0,
/* 5a9 -  */  0,
/* 5aa - _0F_0F_8A */  0x235b,
/* 5ab -  */  0,
/* 5ac -  */  0,
/* 5ad -  */  0,
/* 5ae - _0F_0F_8E */  0x235c,
/* 5af -  */  0,
/* 5b0 - _0F_0F_90 */  0x235d,
/* 5b1 -  */  0,
/* 5b2 -  */  0,
/* 5b3 -  */  0,
/* 5b4 - _0F_0F_94 */  0x235e,
/* 5b5 -  */  0,
/* 5b6 - _0F_0F_96 */  0x235f,
/* 5b7 - _0F_0F_97 */  0x2360,
/* 5b8 -  */  0,
/* 5b9 -  */  0,
/* 5ba - _0F_0F_9A */  0x2361,
/* 5bb -  */  0,
/* 5bc -  */  0,
/* 5bd -  */  0,
/* 5be - _0F_0F_9E */  0x2362,
/* 5bf -  */  0,
/* 5c0 - _0F_0F_A0 */  0x2363,
/* 5c1 -  */  0,
/* 5c2 -  */  0,
/* 5c3 -  */  0,
/* 5c4 - _0F_0F_A4 */  0x2364,
/* 5c5 -  */  0,
/* 5c6 - _0F_0F_A6 */  0x2365,
/* 5c7 - _0F_0F_A7 */  0x2366,
/* 5c8 -  */  0,
/* 5c9 -  */  0,
/* 5ca - _0F_0F_AA */  0x2367,
/* 5cb -  */  0,
/* 5cc -  */  0,
/* 5cd -  */  0,
/* 5ce - _0F_0F_AE */  0x2368,
/* 5cf -  */  0,
/* 5d0 - _0F_0F_B0 */  0x2369,
/* 5d1 -  */  0,
/* 5d2 -  */  0,
/* 5d3 -  */  0,
/* 5d4 - _0F_0F_B4 */  0x236a,
/* 5d5 -  */  0,
/* 5d6 - _0F_0F_B6 */  0x236b,
/* 5d7 - _0F_0F_B7 */  0x236c,
/* 5d8 -  */  0,
/* 5d9 -  */  0,
/* 5da -  */  0,
/* 5db - _0F_0F_BB */  0x236d,
/* 5dc -  */  0,
/* 5dd -  */  0,
/* 5de -  */  0,
/* 5df - _0F_0F_BF */  0x236e,
/* 5e0 -  */  0,
/* 5e1 -  */  0,
/* 5e2 -  */  0,
/* 5e3 -  */  0,
/* 5e4 -  */  0,
/* 5e5 -  */  0,
/* 5e6 -  */  0,
/* 5e7 -  */  0,
/* 5e8 -  */  0,
/* 5e9 -  */  0,
/* 5ea -  */  0,
/* 5eb -  */  0,
/* 5ec -  */  0,
/* 5ed -  */  0,
/* 5ee -  */  0,
/* 5ef -  */  0,
/* 5f0 -  */  0,
/* 5f1 -  */  0,
/* 5f2 -  */  0,
/* 5f3 -  */  0,
/* 5f4 -  */  0,
/* 5f5 -  */  0,
/* 5f6 -  */  0,
/* 5f7 -  */  0,
/* 5f8 -  */  0,
/* 5f9 -  */  0,
/* 5fa -  */  0,
/* 5fb -  */  0,
/* 5fc -  */  0,
/* 5fd -  */  0,
/* 5fe -  */  0,
/* 5ff -  */  0,
/* 600 -  */  0,
/* 601 -  */  0,
/* 602 -  */  0,
/* 603 -  */  0,
/* 604 -  */  0,
/* 605 -  */  0,
/* 606 -  */  0,
/* 607 -  */  0,
/* 608 -  */  0,
/* 609 -  */  0,
/* 60a -  */  0,
/* 60b -  */  0,
/* 60c -  */  0,
/* 60d -  */  0,
/* 60e -  */  0,
/* 60f -  */  0,
/* 610 -  */  0,
/* 611 -  */  0,
/* 612 -  */  0,
/* 613 -  */  0,
/* 614 -  */  0,
/* 615 -  */  0,
/* 616 -  */  0,
/* 617 -  */  0,
/* 618 -  */  0,
/* 619 -  */  0,
/* 61a -  */  0,
/* 61b -  */  0,
/* 61c -  */  0,
/* 61d -  */  0,
/* 61e -  */  0,
/* 61f -  */  0,
/* 620 - _0F_10 */  0x236f,
/* 621 - _66_0F_10 */  0x2370,
/* 622 - _F3_0F_10 */  0x2371,
/* 623 - _F2_0F_10 */  0x2372,
/* 624 - _V_0F_10 */  0x4009,
/* 625 - _V_66_0F_10 */  0x400a,
/* 626 - _V_F3_0F_10 */  0x400b,
/* 627 - _V_F2_0F_10 */  0x400c,
/* 628 -  */  0,
/* 629 -  */  0,
/* 62a - _VRR_F3_0F_10 */  0x400d,
/* 62b - _VRR_F2_0F_10 */  0x400e,
/* 62c - _0F_11 */  0x2373,
/* 62d - _66_0F_11 */  0x2374,
/* 62e - _F3_0F_11 */  0x2375,
/* 62f - _F2_0F_11 */  0x2376,
/* 630 - _V_0F_11 */  0x400f,
/* 631 - _V_66_0F_11 */  0x4010,
/* 632 - _V_F3_0F_11 */  0x4011,
/* 633 - _V_F2_0F_11 */  0x4012,
/* 634 -  */  0,
/* 635 -  */  0,
/* 636 - _VRR_F3_0F_11 */  0x4013,
/* 637 - _VRR_F2_0F_11 */  0x4014,
/* 638 - _0F_12 */  0x4015,
/* 639 - _66_0F_12 */  0x2377,
/* 63a - _F3_0F_12 */  0x2378,
/* 63b - _F2_0F_12 */  0x2379,
/* 63c - _V_0F_12 */  0x4016,
/* 63d - _V_66_0F_12 */  0x4017,
/* 63e - _V_F3_0F_12 */  0x4018,
/* 63f - _V_F2_0F_12 */  0x4019,
/* 640 -  */  0,
/* 641 -  */  0,
/* 642 -  */  0,
/* 643 -  */  0,
/* 644 - _0F_13 */  0x237a,
/* 645 - _66_0F_13 */  0x237b,
/* 646 -  */  0,
/* 647 -  */  0,
/* 648 - _V_0F_13 */  0x401a,
/* 649 - _V_66_0F_13 */  0x401b,
/* 64a -  */  0,
/* 64b -  */  0,
/* 64c -  */  0,
/* 64d -  */  0,
/* 64e -  */  0,
/* 64f -  */  0,
/* 650 - _0F_14 */  0x237c,
/* 651 - _66_0F_14 */  0x237d,
/* 652 -  */  0,
/* 653 -  */  0,
/* 654 - _V_0F_14 */  0x401c,
/* 655 - _V_66_0F_14 */  0x401d,
/* 656 -  */  0,
/* 657 -  */  0,
/* 658 -  */  0,
/* 659 -  */  0,
/* 65a -  */  0,
/* 65b -  */  0,
/* 65c - _0F_15 */  0x237e,
/* 65d - _66_0F_15 */  0x237f,
/* 65e -  */  0,
/* 65f -  */  0,
/* 660 - _V_0F_15 */  0x401e,
/* 661 - _V_66_0F_15 */  0x401f,
/* 662 -  */  0,
/* 663 -  */  0,
/* 664 -  */  0,
/* 665 -  */  0,
/* 666 -  */  0,
/* 667 -  */  0,
/* 668 - _0F_16 */  0x4020,
/* 669 - _66_0F_16 */  0x2380,
/* 66a - _F3_0F_16 */  0x2381,
/* 66b -  */  0,
/* 66c - _V_0F_16 */  0x4021,
/* 66d - _V_66_0F_16 */  0x4022,
/* 66e - _V_F3_0F_16 */  0x4023,
/* 66f -  */  0,
/* 670 -  */  0,
/* 671 -  */  0,
/* 672 -  */  0,
/* 673 -  */  0,
/* 674 - _0F_17 */  0x2382,
/* 675 - _66_0F_17 */  0x2383,
/* 676 -  */  0,
/* 677 -  */  0,
/* 678 - _V_0F_17 */  0x4024,
/* 679 - _V_66_0F_17 */  0x4025,
/* 67a -  */  0,
/* 67b -  */  0,
/* 67c -  */  0,
/* 67d -  */  0,
/* 67e -  */  0,
/* 67f -  */  0,
/* 680 - _0F_18_00 */  0x2384,
/* 681 - _0F_18_01 */  0x2385,
/* 682 - _0F_18_02 */  0x2386,
/* 683 - _0F_18_03 */  0x2387,
/* 684 -  */  0,
/* 685 -  */  0,
/* 686 -  */  0,
/* 687 -  */  0,
/* 688 - _0F_28 */  0x2388,
/* 689 - _66_0F_28 */  0x2389,
/* 68a -  */  0,
/* 68b -  */  0,
/* 68c - _V_0F_28 */  0x4026,
/* 68d - _V_66_0F_28 */  0x4027,
/* 68e -  */  0,
/* 68f -  */  0,
/* 690 -  */  0,
/* 691 -  */  0,
/* 692 -  */  0,
/* 693 -  */  0,
/* 694 - _0F_29 */  0x238a,
/* 695 - _66_0F_29 */  0x238b,
/* 696 -  */  0,
/* 697 -  */  0,
/* 698 - _V_0F_29 */  0x4028,
/* 699 - _V_66_0F_29 */  0x4029,
/* 69a -  */  0,
/* 69b -  */  0,
/* 69c -  */  0,
/* 69d -  */  0,
/* 69e -  */  0,
/* 69f -  */  0,
/* 6a0 - _0F_2A */  0x238c,
/* 6a1 - _66_0F_2A */  0x238d,
/* 6a2 - _F3_0F_2A */  0x238e,
/* 6a3 - _F2_0F_2A */  0x238f,
/* 6a4 -  */  0,
/* 6a5 -  */  0,
/* 6a6 - _V_F3_0F_2A */  0x402a,
/* 6a7 - _V_F2_0F_2A */  0x402b,
/* 6a8 -  */  0,
/* 6a9 -  */  0,
/* 6aa -  */  0,
/* 6ab -  */  0,
/* 6ac - _0F_2B */  0x2390,
/* 6ad - _66_0F_2B */  0x2391,
/* 6ae - _F3_0F_2B */  0x2392,
/* 6af - _F2_0F_2B */  0x2393,
/* 6b0 - _V_0F_2B */  0x402c,
/* 6b1 - _V_66_0F_2B */  0x402d,
/* 6b2 -  */  0,
/* 6b3 -  */  0,
/* 6b4 -  */  0,
/* 6b5 -  */  0,
/* 6b6 -  */  0,
/* 6b7 -  */  0,
/* 6b8 - _0F_2C */  0x2394,
/* 6b9 - _66_0F_2C */  0x2395,
/* 6ba - _F3_0F_2C */  0x2396,
/* 6bb - _F2_0F_2C */  0x2397,
/* 6bc -  */  0,
/* 6bd -  */  0,
/* 6be - _V_F3_0F_2C */  0x402e,
/* 6bf - _V_F2_0F_2C */  0x402f,
/* 6c0 -  */  0,
/* 6c1 -  */  0,
/* 6c2 -  */  0,
/* 6c3 -  */  0,
/* 6c4 - _0F_2D */  0x2398,
/* 6c5 - _66_0F_2D */  0x2399,
/* 6c6 - _F3_0F_2D */  0x239a,
/* 6c7 - _F2_0F_2D */  0x239b,
/* 6c8 -  */  0,
/* 6c9 -  */  0,
/* 6ca - _V_F3_0F_2D */  0x4030,
/* 6cb - _V_F2_0F_2D */  0x4031,
/* 6cc -  */  0,
/* 6cd -  */  0,
/* 6ce -  */  0,
/* 6cf -  */  0,
/* 6d0 - _0F_2E */  0x239c,
/* 6d1 - _66_0F_2E */  0x239d,
/* 6d2 -  */  0,
/* 6d3 -  */  0,
/* 6d4 - _V_0F_2E */  0x4032,
/* 6d5 - _V_66_0F_2E */  0x4033,
/* 6d6 -  */  0,
/* 6d7 -  */  0,
/* 6d8 -  */  0,
/* 6d9 -  */  0,
/* 6da -  */  0,
/* 6db -  */  0,
/* 6dc - _0F_2F */  0x239e,
/* 6dd - _66_0F_2F */  0x239f,
/* 6de -  */  0,
/* 6df -  */  0,
/* 6e0 - _V_0F_2F */  0x4034,
/* 6e1 - _V_66_0F_2F */  0x4035,
/* 6e2 -  */  0,
/* 6e3 -  */  0,
/* 6e4 -  */  0,
/* 6e5 -  */  0,
/* 6e6 -  */  0,
/* 6e7 -  */  0,
/* 6e8 - _0F_38_00 */  0xcef8,
/* 6e9 - _0F_38_01 */  0xcf04,
/* 6ea - _0F_38_02 */  0xcf10,
/* 6eb - _0F_38_03 */  0xcf1c,
/* 6ec - _0F_38_04 */  0xcf28,
/* 6ed - _0F_38_05 */  0xcf34,
/* 6ee - _0F_38_06 */  0xcf40,
/* 6ef - _0F_38_07 */  0xcf4c,
/* 6f0 - _0F_38_08 */  0xcf58,
/* 6f1 - _0F_38_09 */  0xcf64,
/* 6f2 - _0F_38_0A */  0xcf70,
/* 6f3 - _0F_38_0B */  0xcf7c,
/* 6f4 - _0F_38_0C */  0xcf88,
/* 6f5 - _0F_38_0D */  0xcf94,
/* 6f6 - _0F_38_0E */  0xcfa0,
/* 6f7 - _0F_38_0F */  0xcfac,
/* 6f8 - _0F_38_10 */  0xcfb8,
/* 6f9 -  */  0,
/* 6fa -  */  0,
/* 6fb -  */  0,
/* 6fc - _0F_38_14 */  0xcfc4,
/* 6fd - _0F_38_15 */  0xcfd0,
/* 6fe -  */  0,
/* 6ff - _0F_38_17 */  0xcfdc,
/* 700 - _0F_38_18 */  0xcfe8,
/* 701 - _0F_38_19 */  0xcff4,
/* 702 - _0F_38_1A */  0xd000,
/* 703 -  */  0,
/* 704 - _0F_38_1C */  0xd00c,
/* 705 - _0F_38_1D */  0xd018,
/* 706 - _0F_38_1E */  0xd024,
/* 707 -  */  0,
/* 708 - _0F_38_20 */  0xd030,
/* 709 - _0F_38_21 */  0xd03c,
/* 70a - _0F_38_22 */  0xd048,
/* 70b - _0F_38_23 */  0xd054,
/* 70c - _0F_38_24 */  0xd060,
/* 70d - _0F_38_25 */  0xd06c,
/* 70e -  */  0,
/* 70f -  */  0,
/* 710 - _0F_38_28 */  0xd078,
/* 711 - _0F_38_29 */  0xd084,
/* 712 - _0F_38_2A */  0xd090,
/* 713 - _0F_38_2B */  0xd09c,
/* 714 - _0F_38_2C */  0xd0a8,
/* 715 - _0F_38_2D */  0xd0b4,
/* 716 - _0F_38_2E */  0xd0c0,
/* 717 - _0F_38_2F */  0xd0cc,
/* 718 - _0F_38_30 */  0xd0d8,
/* 719 - _0F_38_31 */  0xd0e4,
/* 71a - _0F_38_32 */  0xd0f0,
/* 71b - _0F_38_33 */  0xd0fc,
/* 71c - _0F_38_34 */  0xd108,
/* 71d - _0F_38_35 */  0xd114,
/* 71e -  */  0,
/* 71f - _0F_38_37 */  0xd120,
/* 720 - _0F_38_38 */  0xd12c,
/* 721 - _0F_38_39 */  0xd138,
/* 722 - _0F_38_3A */  0xd144,
/* 723 - _0F_38_3B */  0xd150,
/* 724 - _0F_38_3C */  0xd15c,
/* 725 - _0F_38_3D */  0xd168,
/* 726 - _0F_38_3E */  0xd174,
/* 727 - _0F_38_3F */  0xd180,
/* 728 - _0F_38_40 */  0xd18c,
/* 729 - _0F_38_41 */  0xd198,
/* 72a -  */  0,
/* 72b -  */  0,
/* 72c -  */  0,
/* 72d -  */  0,
/* 72e -  */  0,
/* 72f -  */  0,
/* 730 -  */  0,
/* 731 -  */  0,
/* 732 -  */  0,
/* 733 -  */  0,
/* 734 -  */  0,
/* 735 -  */  0,
/* 736 -  */  0,
/* 737 -  */  0,
/* 738 -  */  0,
/* 739 -  */  0,
/* 73a -  */  0,
/* 73b -  */  0,
/* 73c -  */  0,
/* 73d -  */  0,
/* 73e -  */  0,
/* 73f -  */  0,
/* 740 -  */  0,
/* 741 -  */  0,
/* 742 -  */  0,
/* 743 -  */  0,
/* 744 -  */  0,
/* 745 -  */  0,
/* 746 -  */  0,
/* 747 -  */  0,
/* 748 -  */  0,
/* 749 -  */  0,
/* 74a -  */  0,
/* 74b -  */  0,
/* 74c -  */  0,
/* 74d -  */  0,
/* 74e -  */  0,
/* 74f -  */  0,
/* 750 -  */  0,
/* 751 -  */  0,
/* 752 -  */  0,
/* 753 -  */  0,
/* 754 -  */  0,
/* 755 -  */  0,
/* 756 -  */  0,
/* 757 -  */  0,
/* 758 -  */  0,
/* 759 -  */  0,
/* 75a -  */  0,
/* 75b -  */  0,
/* 75c -  */  0,
/* 75d -  */  0,
/* 75e -  */  0,
/* 75f -  */  0,
/* 760 -  */  0,
/* 761 -  */  0,
/* 762 -  */  0,
/* 763 -  */  0,
/* 764 -  */  0,
/* 765 -  */  0,
/* 766 -  */  0,
/* 767 -  */  0,
/* 768 - _0F_38_80 */  0xd1a4,
/* 769 - _0F_38_81 */  0xd1b0,
/* 76a - _0F_38_82 */  0xd1bc,
/* 76b -  */  0,
/* 76c -  */  0,
/* 76d -  */  0,
/* 76e -  */  0,
/* 76f -  */  0,
/* 770 -  */  0,
/* 771 -  */  0,
/* 772 -  */  0,
/* 773 -  */  0,
/* 774 -  */  0,
/* 775 -  */  0,
/* 776 -  */  0,
/* 777 -  */  0,
/* 778 -  */  0,
/* 779 -  */  0,
/* 77a -  */  0,
/* 77b -  */  0,
/* 77c -  */  0,
/* 77d -  */  0,
/* 77e - _0F_38_96 */  0xd1c8,
/* 77f - _0F_38_97 */  0xd1d4,
/* 780 - _0F_38_98 */  0xd1e0,
/* 781 - _0F_38_99 */  0xd1ec,
/* 782 - _0F_38_9A */  0xd1f8,
/* 783 - _0F_38_9B */  0xd204,
/* 784 - _0F_38_9C */  0xd210,
/* 785 - _0F_38_9D */  0xd21c,
/* 786 - _0F_38_9E */  0xd228,
/* 787 - _0F_38_9F */  0xd234,
/* 788 -  */  0,
/* 789 -  */  0,
/* 78a -  */  0,
/* 78b -  */  0,
/* 78c -  */  0,
/* 78d -  */  0,
/* 78e - _0F_38_A6 */  0xd240,
/* 78f - _0F_38_A7 */  0xd24c,
/* 790 - _0F_38_A8 */  0xd258,
/* 791 - _0F_38_A9 */  0xd264,
/* 792 - _0F_38_AA */  0xd270,
/* 793 - _0F_38_AB */  0xd27c,
/* 794 - _0F_38_AC */  0xd288,
/* 795 - _0F_38_AD */  0xd294,
/* 796 - _0F_38_AE */  0xd2a0,
/* 797 - _0F_38_AF */  0xd2ac,
/* 798 -  */  0,
/* 799 -  */  0,
/* 79a -  */  0,
/* 79b -  */  0,
/* 79c -  */  0,
/* 79d -  */  0,
/* 79e - _0F_38_B6 */  0xd2b8,
/* 79f - _0F_38_B7 */  0xd2c4,
/* 7a0 - _0F_38_B8 */  0xd2d0,
/* 7a1 - _0F_38_B9 */  0xd2dc,
/* 7a2 - _0F_38_BA */  0xd2e8,
/* 7a3 - _0F_38_BB */  0xd2f4,
/* 7a4 - _0F_38_BC */  0xd300,
/* 7a5 - _0F_38_BD */  0xd30c,
/* 7a6 - _0F_38_BE */  0xd318,
/* 7a7 - _0F_38_BF */  0xd324,
/* 7a8 -  */  0,
/* 7a9 -  */  0,
/* 7aa -  */  0,
/* 7ab -  */  0,
/* 7ac -  */  0,
/* 7ad -  */  0,
/* 7ae -  */  0,
/* 7af -  */  0,
/* 7b0 -  */  0,
/* 7b1 -  */  0,
/* 7b2 -  */  0,
/* 7b3 -  */  0,
/* 7b4 -  */  0,
/* 7b5 -  */  0,
/* 7b6 -  */  0,
/* 7b7 -  */  0,
/* 7b8 -  */  0,
/* 7b9 -  */  0,
/* 7ba -  */  0,
/* 7bb -  */  0,
/* 7bc -  */  0,
/* 7bd -  */  0,
/* 7be -  */  0,
/* 7bf -  */  0,
/* 7c0 -  */  0,
/* 7c1 -  */  0,
/* 7c2 -  */  0,
/* 7c3 - _0F_38_DB */  0xd330,
/* 7c4 - _0F_38_DC */  0xd33c,
/* 7c5 - _0F_38_DD */  0xd348,
/* 7c6 - _0F_38_DE */  0xd354,
/* 7c7 - _0F_38_DF */  0xd360,
/* 7c8 -  */  0,
/* 7c9 -  */  0,
/* 7ca -  */  0,
/* 7cb -  */  0,
/* 7cc -  */  0,
/* 7cd -  */  0,
/* 7ce -  */  0,
/* 7cf -  */  0,
/* 7d0 -  */  0,
/* 7d1 -  */  0,
/* 7d2 -  */  0,
/* 7d3 -  */  0,
/* 7d4 -  */  0,
/* 7d5 -  */  0,
/* 7d6 -  */  0,
/* 7d7 -  */  0,
/* 7d8 - _0F_38_F0 */  0xd36c,
/* 7d9 - _0F_38_F1 */  0xd378,
/* 7da -  */  0,
/* 7db -  */  0,
/* 7dc -  */  0,
/* 7dd -  */  0,
/* 7de -  */  0,
/* 7df -  */  0,
/* 7e0 -  */  0,
/* 7e1 -  */  0,
/* 7e2 -  */  0,
/* 7e3 -  */  0,
/* 7e4 -  */  0,
/* 7e5 -  */  0,
/* 7e6 -  */  0,
/* 7e7 -  */  0,
/* 7e8 -  */  0,
/* 7e9 -  */  0,
/* 7ea -  */  0,
/* 7eb -  */  0,
/* 7ec - _0F_3A_04 */  0xd384,
/* 7ed - _0F_3A_05 */  0xd390,
/* 7ee - _0F_3A_06 */  0xd39c,
/* 7ef -  */  0,
/* 7f0 - _0F_3A_08 */  0xd3a8,
/* 7f1 - _0F_3A_09 */  0xd3b4,
/* 7f2 - _0F_3A_0A */  0xd3c0,
/* 7f3 - _0F_3A_0B */  0xd3cc,
/* 7f4 - _0F_3A_0C */  0xd3d8,
/* 7f5 - _0F_3A_0D */  0xd3e4,
/* 7f6 - _0F_3A_0E */  0xd3f0,
/* 7f7 - _0F_3A_0F */  0xd3fc,
/* 7f8 -  */  0,
/* 7f9 -  */  0,
/* 7fa -  */  0,
/* 7fb -  */  0,
/* 7fc - _0F_3A_14 */  0xd408,
/* 7fd - _0F_3A_15 */  0xd414,
/* 7fe - _0F_3A_16 */  0xd420,
/* 7ff - _0F_3A_17 */  0xd42c,
/* 800 - _0F_3A_18 */  0xd438,
/* 801 - _0F_3A_19 */  0xd444,
/* 802 -  */  0,
/* 803 -  */  0,
/* 804 -  */  0,
/* 805 -  */  0,
/* 806 -  */  0,
/* 807 -  */  0,
/* 808 - _0F_3A_20 */  0xd450,
/* 809 - _0F_3A_21 */  0xd45c,
/* 80a - _0F_3A_22 */  0xd468,
/* 80b -  */  0,
/* 80c -  */  0,
/* 80d -  */  0,
/* 80e -  */  0,
/* 80f -  */  0,
/* 810 -  */  0,
/* 811 -  */  0,
/* 812 -  */  0,
/* 813 -  */  0,
/* 814 -  */  0,
/* 815 -  */  0,
/* 816 -  */  0,
/* 817 -  */  0,
/* 818 -  */  0,
/* 819 -  */  0,
/* 81a -  */  0,
/* 81b -  */  0,
/* 81c -  */  0,
/* 81d -  */  0,
/* 81e -  */  0,
/* 81f -  */  0,
/* 820 -  */  0,
/* 821 -  */  0,
/* 822 -  */  0,
/* 823 -  */  0,
/* 824 -  */  0,
/* 825 -  */  0,
/* 826 -  */  0,
/* 827 -  */  0,
/* 828 - _0F_3A_40 */  0xd474,
/* 829 - _0F_3A_41 */  0xd480,
/* 82a - _0F_3A_42 */  0xd48c,
/* 82b -  */  0,
/* 82c - _0F_3A_44 */  0xd498,
/* 82d -  */  0,
/* 82e -  */  0,
/* 82f -  */  0,
/* 830 -  */  0,
/* 831 -  */  0,
/* 832 - _0F_3A_4A */  0xd4a4,
/* 833 - _0F_3A_4B */  0xd4b0,
/* 834 - _0F_3A_4C */  0xd4bc,
/* 835 -  */  0,
/* 836 -  */  0,
/* 837 -  */  0,
/* 838 -  */  0,
/* 839 -  */  0,
/* 83a -  */  0,
/* 83b -  */  0,
/* 83c -  */  0,
/* 83d -  */  0,
/* 83e -  */  0,
/* 83f -  */  0,
/* 840 -  */  0,
/* 841 -  */  0,
/* 842 -  */  0,
/* 843 -  */  0,
/* 844 -  */  0,
/* 845 -  */  0,
/* 846 -  */  0,
/* 847 -  */  0,
/* 848 - _0F_3A_60 */  0xd4c8,
/* 849 - _0F_3A_61 */  0xd4d4,
/* 84a - _0F_3A_62 */  0xd4e0,
/* 84b - _0F_3A_63 */  0xd4ec,
/* 84c -  */  0,
/* 84d -  */  0,
/* 84e -  */  0,
/* 84f -  */  0,
/* 850 -  */  0,
/* 851 -  */  0,
/* 852 -  */  0,
/* 853 -  */  0,
/* 854 -  */  0,
/* 855 -  */  0,
/* 856 -  */  0,
/* 857 -  */  0,
/* 858 -  */  0,
/* 859 -  */  0,
/* 85a -  */  0,
/* 85b -  */  0,
/* 85c -  */  0,
/* 85d -  */  0,
/* 85e -  */  0,
/* 85f -  */  0,
/* 860 -  */  0,
/* 861 -  */  0,
/* 862 -  */  0,
/* 863 -  */  0,
/* 864 -  */  0,
/* 865 -  */  0,
/* 866 -  */  0,
/* 867 -  */  0,
/* 868 -  */  0,
/* 869 -  */  0,
/* 86a -  */  0,
/* 86b -  */  0,
/* 86c -  */  0,
/* 86d -  */  0,
/* 86e -  */  0,
/* 86f -  */  0,
/* 870 -  */  0,
/* 871 -  */  0,
/* 872 -  */  0,
/* 873 -  */  0,
/* 874 -  */  0,
/* 875 -  */  0,
/* 876 -  */  0,
/* 877 -  */  0,
/* 878 -  */  0,
/* 879 -  */  0,
/* 87a -  */  0,
/* 87b -  */  0,
/* 87c -  */  0,
/* 87d -  */  0,
/* 87e -  */  0,
/* 87f -  */  0,
/* 880 -  */  0,
/* 881 -  */  0,
/* 882 -  */  0,
/* 883 -  */  0,
/* 884 -  */  0,
/* 885 -  */  0,
/* 886 -  */  0,
/* 887 -  */  0,
/* 888 -  */  0,
/* 889 -  */  0,
/* 88a -  */  0,
/* 88b -  */  0,
/* 88c -  */  0,
/* 88d -  */  0,
/* 88e -  */  0,
/* 88f -  */  0,
/* 890 -  */  0,
/* 891 -  */  0,
/* 892 -  */  0,
/* 893 -  */  0,
/* 894 -  */  0,
/* 895 -  */  0,
/* 896 -  */  0,
/* 897 -  */  0,
/* 898 -  */  0,
/* 899 -  */  0,
/* 89a -  */  0,
/* 89b -  */  0,
/* 89c -  */  0,
/* 89d -  */  0,
/* 89e -  */  0,
/* 89f -  */  0,
/* 8a0 -  */  0,
/* 8a1 -  */  0,
/* 8a2 -  */  0,
/* 8a3 -  */  0,
/* 8a4 -  */  0,
/* 8a5 -  */  0,
/* 8a6 -  */  0,
/* 8a7 -  */  0,
/* 8a8 -  */  0,
/* 8a9 -  */  0,
/* 8aa -  */  0,
/* 8ab -  */  0,
/* 8ac -  */  0,
/* 8ad -  */  0,
/* 8ae -  */  0,
/* 8af -  */  0,
/* 8b0 -  */  0,
/* 8b1 -  */  0,
/* 8b2 -  */  0,
/* 8b3 -  */  0,
/* 8b4 -  */  0,
/* 8b5 -  */  0,
/* 8b6 -  */  0,
/* 8b7 -  */  0,
/* 8b8 -  */  0,
/* 8b9 -  */  0,
/* 8ba -  */  0,
/* 8bb -  */  0,
/* 8bc -  */  0,
/* 8bd -  */  0,
/* 8be -  */  0,
/* 8bf -  */  0,
/* 8c0 -  */  0,
/* 8c1 -  */  0,
/* 8c2 -  */  0,
/* 8c3 -  */  0,
/* 8c4 -  */  0,
/* 8c5 -  */  0,
/* 8c6 -  */  0,
/* 8c7 - _0F_3A_DF */  0xd4f8,
/* 8c8 -  */  0,
/* 8c9 -  */  0,
/* 8ca -  */  0,
/* 8cb -  */  0,
/* 8cc -  */  0,
/* 8cd -  */  0,
/* 8ce -  */  0,
/* 8cf -  */  0,
/* 8d0 -  */  0,
/* 8d1 -  */  0,
/* 8d2 -  */  0,
/* 8d3 -  */  0,
/* 8d4 -  */  0,
/* 8d5 -  */  0,
/* 8d6 -  */  0,
/* 8d7 -  */  0,
/* 8d8 -  */  0,
/* 8d9 -  */  0,
/* 8da -  */  0,
/* 8db -  */  0,
/* 8dc -  */  0,
/* 8dd -  */  0,
/* 8de -  */  0,
/* 8df -  */  0,
/* 8e0 -  */  0,
/* 8e1 -  */  0,
/* 8e2 -  */  0,
/* 8e3 -  */  0,
/* 8e4 -  */  0,
/* 8e5 -  */  0,
/* 8e6 -  */  0,
/* 8e7 -  */  0,
/* 8e8 - _0F_50 */  0x23a0,
/* 8e9 - _66_0F_50 */  0x23a1,
/* 8ea -  */  0,
/* 8eb -  */  0,
/* 8ec - _V_0F_50 */  0x4036,
/* 8ed - _V_66_0F_50 */  0x4037,
/* 8ee -  */  0,
/* 8ef -  */  0,
/* 8f0 -  */  0,
/* 8f1 -  */  0,
/* 8f2 -  */  0,
/* 8f3 -  */  0,
/* 8f4 - _0F_51 */  0x23a2,
/* 8f5 - _66_0F_51 */  0x23a3,
/* 8f6 - _F3_0F_51 */  0x23a4,
/* 8f7 - _F2_0F_51 */  0x23a5,
/* 8f8 - _V_0F_51 */  0x4038,
/* 8f9 - _V_66_0F_51 */  0x4039,
/* 8fa - _V_F3_0F_51 */  0x403a,
/* 8fb - _V_F2_0F_51 */  0x403b,
/* 8fc -  */  0,
/* 8fd -  */  0,
/* 8fe -  */  0,
/* 8ff -  */  0,
/* 900 - _0F_52 */  0x23a6,
/* 901 -  */  0,
/* 902 - _F3_0F_52 */  0x23a7,
/* 903 -  */  0,
/* 904 - _V_0F_52 */  0x403c,
/* 905 -  */  0,
/* 906 - _V_F3_0F_52 */  0x403d,
/* 907 -  */  0,
/* 908 -  */  0,
/* 909 -  */  0,
/* 90a -  */  0,
/* 90b -  */  0,
/* 90c - _0F_53 */  0x23a8,
/* 90d -  */  0,
/* 90e - _F3_0F_53 */  0x23a9,
/* 90f -  */  0,
/* 910 - _V_0F_53 */  0x403e,
/* 911 -  */  0,
/* 912 - _V_F3_0F_53 */  0x403f,
/* 913 -  */  0,
/* 914 -  */  0,
/* 915 -  */  0,
/* 916 -  */  0,
/* 917 -  */  0,
/* 918 - _0F_54 */  0x23aa,
/* 919 - _66_0F_54 */  0x23ab,
/* 91a -  */  0,
/* 91b -  */  0,
/* 91c - _V_0F_54 */  0x4040,
/* 91d - _V_66_0F_54 */  0x4041,
/* 91e -  */  0,
/* 91f -  */  0,
/* 920 -  */  0,
/* 921 -  */  0,
/* 922 -  */  0,
/* 923 -  */  0,
/* 924 - _0F_55 */  0x23ac,
/* 925 - _66_0F_55 */  0x23ad,
/* 926 -  */  0,
/* 927 -  */  0,
/* 928 - _V_0F_55 */  0x4042,
/* 929 - _V_66_0F_55 */  0x4043,
/* 92a -  */  0,
/* 92b -  */  0,
/* 92c -  */  0,
/* 92d -  */  0,
/* 92e -  */  0,
/* 92f -  */  0,
/* 930 - _0F_56 */  0x23ae,
/* 931 - _66_0F_56 */  0x23af,
/* 932 -  */  0,
/* 933 -  */  0,
/* 934 - _V_0F_56 */  0x4044,
/* 935 - _V_66_0F_56 */  0x4045,
/* 936 -  */  0,
/* 937 -  */  0,
/* 938 -  */  0,
/* 939 -  */  0,
/* 93a -  */  0,
/* 93b -  */  0,
/* 93c - _0F_57 */  0x23b0,
/* 93d - _66_0F_57 */  0x23b1,
/* 93e -  */  0,
/* 93f -  */  0,
/* 940 - _V_0F_57 */  0x4046,
/* 941 - _V_66_0F_57 */  0x4047,
/* 942 -  */  0,
/* 943 -  */  0,
/* 944 -  */  0,
/* 945 -  */  0,
/* 946 -  */  0,
/* 947 -  */  0,
/* 948 - _0F_58 */  0x23b2,
/* 949 - _66_0F_58 */  0x23b3,
/* 94a - _F3_0F_58 */  0x23b4,
/* 94b - _F2_0F_58 */  0x23b5,
/* 94c - _V_0F_58 */  0x4048,
/* 94d - _V_66_0F_58 */  0x4049,
/* 94e - _V_F3_0F_58 */  0x404a,
/* 94f - _V_F2_0F_58 */  0x404b,
/* 950 -  */  0,
/* 951 -  */  0,
/* 952 -  */  0,
/* 953 -  */  0,
/* 954 - _0F_59 */  0x23b6,
/* 955 - _66_0F_59 */  0x23b7,
/* 956 - _F3_0F_59 */  0x23b8,
/* 957 - _F2_0F_59 */  0x23b9,
/* 958 - _V_0F_59 */  0x404c,
/* 959 - _V_66_0F_59 */  0x404d,
/* 95a - _V_F3_0F_59 */  0x404e,
/* 95b - _V_F2_0F_59 */  0x404f,
/* 95c -  */  0,
/* 95d -  */  0,
/* 95e -  */  0,
/* 95f -  */  0,
/* 960 - _0F_5A */  0x23ba,
/* 961 - _66_0F_5A */  0x23bb,
/* 962 - _F3_0F_5A */  0x23bc,
/* 963 - _F2_0F_5A */  0x23bd,
/* 964 - _V_0F_5A */  0x4050,
/* 965 - _V_66_0F_5A */  0x4051,
/* 966 - _V_F3_0F_5A */  0x4052,
/* 967 - _V_F2_0F_5A */  0x4053,
/* 968 -  */  0,
/* 969 -  */  0,
/* 96a -  */  0,
/* 96b -  */  0,
/* 96c - _0F_5B */  0x23be,
/* 96d - _66_0F_5B */  0x23bf,
/* 96e - _F3_0F_5B */  0x23c0,
/* 96f -  */  0,
/* 970 - _V_0F_5B */  0x4054,
/* 971 - _V_66_0F_5B */  0x4055,
/* 972 - _V_F3_0F_5B */  0x4056,
/* 973 -  */  0,
/* 974 -  */  0,
/* 975 -  */  0,
/* 976 -  */  0,
/* 977 -  */  0,
/* 978 - _0F_5C */  0x23c1,
/* 979 - _66_0F_5C */  0x23c2,
/* 97a - _F3_0F_5C */  0x23c3,
/* 97b - _F2_0F_5C */  0x23c4,
/* 97c - _V_0F_5C */  0x4057,
/* 97d - _V_66_0F_5C */  0x4058,
/* 97e - _V_F3_0F_5C */  0x4059,
/* 97f - _V_F2_0F_5C */  0x405a,
/* 980 -  */  0,
/* 981 -  */  0,
/* 982 -  */  0,
/* 983 -  */  0,
/* 984 - _0F_5D */  0x23c5,
/* 985 - _66_0F_5D */  0x23c6,
/* 986 - _F3_0F_5D */  0x23c7,
/* 987 - _F2_0F_5D */  0x23c8,
/* 988 - _V_0F_5D */  0x405b,
/* 989 - _V_66_0F_5D */  0x405c,
/* 98a - _V_F3_0F_5D */  0x405d,
/* 98b - _V_F2_0F_5D */  0x405e,
/* 98c -  */  0,
/* 98d -  */  0,
/* 98e -  */  0,
/* 98f -  */  0,
/* 990 - _0F_5E */  0x23c9,
/* 991 - _66_0F_5E */  0x23ca,
/* 992 - _F3_0F_5E */  0x23cb,
/* 993 - _F2_0F_5E */  0x23cc,
/* 994 - _V_0F_5E */  0x405f,
/* 995 - _V_66_0F_5E */  0x4060,
/* 996 - _V_F3_0F_5E */  0x4061,
/* 997 - _V_F2_0F_5E */  0x4062,
/* 998 -  */  0,
/* 999 -  */  0,
/* 99a -  */  0,
/* 99b -  */  0,
/* 99c - _0F_5F */  0x23cd,
/* 99d - _66_0F_5F */  0x23ce,
/* 99e - _F3_0F_5F */  0x23cf,
/* 99f - _F2_0F_5F */  0x23d0,
/* 9a0 - _V_0F_5F */  0x4063,
/* 9a1 - _V_66_0F_5F */  0x4064,
/* 9a2 - _V_F3_0F_5F */  0x4065,
/* 9a3 - _V_F2_0F_5F */  0x4066,
/* 9a4 -  */  0,
/* 9a5 -  */  0,
/* 9a6 -  */  0,
/* 9a7 -  */  0,
/* 9a8 - _0F_60 */  0x23d1,
/* 9a9 - _66_0F_60 */  0x23d2,
/* 9aa -  */  0,
/* 9ab -  */  0,
/* 9ac -  */  0,
/* 9ad - _V_66_0F_60 */  0x4067,
/* 9ae -  */  0,
/* 9af -  */  0,
/* 9b0 -  */  0,
/* 9b1 -  */  0,
/* 9b2 -  */  0,
/* 9b3 -  */  0,
/* 9b4 - _0F_61 */  0x23d3,
/* 9b5 - _66_0F_61 */  0x23d4,
/* 9b6 -  */  0,
/* 9b7 -  */  0,
/* 9b8 -  */  0,
/* 9b9 - _V_66_0F_61 */  0x4068,
/* 9ba -  */  0,
/* 9bb -  */  0,
/* 9bc -  */  0,
/* 9bd -  */  0,
/* 9be -  */  0,
/* 9bf -  */  0,
/* 9c0 - _0F_62 */  0x23d5,
/* 9c1 - _66_0F_62 */  0x23d6,
/* 9c2 -  */  0,
/* 9c3 -  */  0,
/* 9c4 -  */  0,
/* 9c5 - _V_66_0F_62 */  0x4069,
/* 9c6 -  */  0,
/* 9c7 -  */  0,
/* 9c8 -  */  0,
/* 9c9 -  */  0,
/* 9ca -  */  0,
/* 9cb -  */  0,
/* 9cc - _0F_63 */  0x23d7,
/* 9cd - _66_0F_63 */  0x23d8,
/* 9ce -  */  0,
/* 9cf -  */  0,
/* 9d0 -  */  0,
/* 9d1 - _V_66_0F_63 */  0x406a,
/* 9d2 -  */  0,
/* 9d3 -  */  0,
/* 9d4 -  */  0,
/* 9d5 -  */  0,
/* 9d6 -  */  0,
/* 9d7 -  */  0,
/* 9d8 - _0F_64 */  0x23d9,
/* 9d9 - _66_0F_64 */  0x23da,
/* 9da -  */  0,
/* 9db -  */  0,
/* 9dc -  */  0,
/* 9dd - _V_66_0F_64 */  0x406b,
/* 9de -  */  0,
/* 9df -  */  0,
/* 9e0 -  */  0,
/* 9e1 -  */  0,
/* 9e2 -  */  0,
/* 9e3 -  */  0,
/* 9e4 - _0F_65 */  0x23db,
/* 9e5 - _66_0F_65 */  0x23dc,
/* 9e6 -  */  0,
/* 9e7 -  */  0,
/* 9e8 -  */  0,
/* 9e9 - _V_66_0F_65 */  0x406c,
/* 9ea -  */  0,
/* 9eb -  */  0,
/* 9ec -  */  0,
/* 9ed -  */  0,
/* 9ee -  */  0,
/* 9ef -  */  0,
/* 9f0 - _0F_66 */  0x23dd,
/* 9f1 - _66_0F_66 */  0x23de,
/* 9f2 -  */  0,
/* 9f3 -  */  0,
/* 9f4 -  */  0,
/* 9f5 - _V_66_0F_66 */  0x406d,
/* 9f6 -  */  0,
/* 9f7 -  */  0,
/* 9f8 -  */  0,
/* 9f9 -  */  0,
/* 9fa -  */  0,
/* 9fb -  */  0,
/* 9fc - _0F_67 */  0x23df,
/* 9fd - _66_0F_67 */  0x23e0,
/* 9fe -  */  0,
/* 9ff -  */  0,
/* a00 -  */  0,
/* a01 - _V_66_0F_67 */  0x406e,
/* a02 -  */  0,
/* a03 -  */  0,
/* a04 -  */  0,
/* a05 -  */  0,
/* a06 -  */  0,
/* a07 -  */  0,
/* a08 - _0F_68 */  0x23e1,
/* a09 - _66_0F_68 */  0x23e2,
/* a0a -  */  0,
/* a0b -  */  0,
/* a0c -  */  0,
/* a0d - _V_66_0F_68 */  0x406f,
/* a0e -  */  0,
/* a0f -  */  0,
/* a10 -  */  0,
/* a11 -  */  0,
/* a12 -  */  0,
/* a13 -  */  0,
/* a14 - _0F_69 */  0x23e3,
/* a15 - _66_0F_69 */  0x23e4,
/* a16 -  */  0,
/* a17 -  */  0,
/* a18 -  */  0,
/* a19 - _V_66_0F_69 */  0x4070,
/* a1a -  */  0,
/* a1b -  */  0,
/* a1c -  */  0,
/* a1d -  */  0,
/* a1e -  */  0,
/* a1f -  */  0,
/* a20 - _0F_6A */  0x23e5,
/* a21 - _66_0F_6A */  0x23e6,
/* a22 -  */  0,
/* a23 -  */  0,
/* a24 -  */  0,
/* a25 - _V_66_0F_6A */  0x4071,
/* a26 -  */  0,
/* a27 -  */  0,
/* a28 -  */  0,
/* a29 -  */  0,
/* a2a -  */  0,
/* a2b -  */  0,
/* a2c - _0F_6B */  0x23e7,
/* a2d - _66_0F_6B */  0x23e8,
/* a2e -  */  0,
/* a2f -  */  0,
/* a30 -  */  0,
/* a31 - _V_66_0F_6B */  0x4072,
/* a32 -  */  0,
/* a33 -  */  0,
/* a34 -  */  0,
/* a35 -  */  0,
/* a36 -  */  0,
/* a37 -  */  0,
/* a38 -  */  0,
/* a39 - _66_0F_6C */  0x23e9,
/* a3a -  */  0,
/* a3b -  */  0,
/* a3c -  */  0,
/* a3d - _V_66_0F_6C */  0x4073,
/* a3e -  */  0,
/* a3f -  */  0,
/* a40 -  */  0,
/* a41 -  */  0,
/* a42 -  */  0,
/* a43 -  */  0,
/* a44 -  */  0,
/* a45 - _66_0F_6D */  0x23ea,
/* a46 -  */  0,
/* a47 -  */  0,
/* a48 -  */  0,
/* a49 - _V_66_0F_6D */  0x4074,
/* a4a -  */  0,
/* a4b -  */  0,
/* a4c -  */  0,
/* a4d -  */  0,
/* a4e -  */  0,
/* a4f -  */  0,
/* a50 - _0F_6E */  0x4075,
/* a51 - _66_0F_6E */  0x4076,
/* a52 -  */  0,
/* a53 -  */  0,
/* a54 -  */  0,
/* a55 - _V_66_0F_6E */  0x4077,
/* a56 -  */  0,
/* a57 -  */  0,
/* a58 -  */  0,
/* a59 -  */  0,
/* a5a -  */  0,
/* a5b -  */  0,
/* a5c - _0F_6F */  0x23eb,
/* a5d - _66_0F_6F */  0x23ec,
/* a5e - _F3_0F_6F */  0x23ed,
/* a5f -  */  0,
/* a60 -  */  0,
/* a61 - _V_66_0F_6F */  0x4078,
/* a62 - _V_F3_0F_6F */  0x4079,
/* a63 -  */  0,
/* a64 -  */  0,
/* a65 -  */  0,
/* a66 -  */  0,
/* a67 -  */  0,
/* a68 - _0F_70 */  0x407a,
/* a69 - _66_0F_70 */  0x407b,
/* a6a - _F3_0F_70 */  0x407c,
/* a6b - _F2_0F_70 */  0x407d,
/* a6c -  */  0,
/* a6d - _V_66_0F_70 */  0x407e,
/* a6e - _V_F3_0F_70 */  0x407f,
/* a6f - _V_F2_0F_70 */  0x4080,
/* a70 -  */  0,
/* a71 -  */  0,
/* a72 -  */  0,
/* a73 -  */  0,
/* a74 -  */  0,
/* a75 -  */  0,
/* a76 - _0F_71_02 */  0xd504,
/* a77 -  */  0,
/* a78 - _0F_71_04 */  0xd510,
/* a79 -  */  0,
/* a7a - _0F_71_06 */  0xd51c,
/* a7b -  */  0,
/* a7c -  */  0,
/* a7d -  */  0,
/* a7e - _0F_72_02 */  0xd528,
/* a7f -  */  0,
/* a80 - _0F_72_04 */  0xd534,
/* a81 -  */  0,
/* a82 - _0F_72_06 */  0xd540,
/* a83 -  */  0,
/* a84 -  */  0,
/* a85 -  */  0,
/* a86 - _0F_73_02 */  0xd54c,
/* a87 - _0F_73_03 */  0xd558,
/* a88 -  */  0,
/* a89 -  */  0,
/* a8a - _0F_73_06 */  0xd564,
/* a8b - _0F_73_07 */  0xd570,
/* a8c - _0F_74 */  0x23ee,
/* a8d - _66_0F_74 */  0x23ef,
/* a8e -  */  0,
/* a8f -  */  0,
/* a90 -  */  0,
/* a91 - _V_66_0F_74 */  0x4081,
/* a92 -  */  0,
/* a93 -  */  0,
/* a94 -  */  0,
/* a95 -  */  0,
/* a96 -  */  0,
/* a97 -  */  0,
/* a98 - _0F_75 */  0x23f0,
/* a99 - _66_0F_75 */  0x23f1,
/* a9a -  */  0,
/* a9b -  */  0,
/* a9c -  */  0,
/* a9d - _V_66_0F_75 */  0x4082,
/* a9e -  */  0,
/* a9f -  */  0,
/* aa0 -  */  0,
/* aa1 -  */  0,
/* aa2 -  */  0,
/* aa3 -  */  0,
/* aa4 - _0F_76 */  0x23f2,
/* aa5 - _66_0F_76 */  0x23f3,
/* aa6 -  */  0,
/* aa7 -  */  0,
/* aa8 -  */  0,
/* aa9 - _V_66_0F_76 */  0x4083,
/* aaa -  */  0,
/* aab -  */  0,
/* aac -  */  0,
/* aad -  */  0,
/* aae -  */  0,
/* aaf -  */  0,
/* ab0 - _0F_77 */  0x23f4,
/* ab1 -  */  0,
/* ab2 -  */  0,
/* ab3 -  */  0,
/* ab4 - _V_0F_77 */  0x4084,
/* ab5 -  */  0,
/* ab6 -  */  0,
/* ab7 -  */  0,
/* ab8 -  */  0,
/* ab9 -  */  0,
/* aba -  */  0,
/* abb -  */  0,
/* abc - _0F_78 */  0x23f5,
/* abd - _66_0F_78 */  0x4085,
/* abe -  */  0,
/* abf - _F2_0F_78 */  0x4086,
/* ac0 -  */  0,
/* ac1 -  */  0,
/* ac2 -  */  0,
/* ac3 -  */  0,
/* ac4 -  */  0,
/* ac5 -  */  0,
/* ac6 -  */  0,
/* ac7 -  */  0,
/* ac8 - _0F_79 */  0x23f6,
/* ac9 - _66_0F_79 */  0x23f7,
/* aca -  */  0,
/* acb - _F2_0F_79 */  0x23f8,
/* acc -  */  0,
/* acd -  */  0,
/* ace -  */  0,
/* acf -  */  0,
/* ad0 -  */  0,
/* ad1 -  */  0,
/* ad2 -  */  0,
/* ad3 -  */  0,
/* ad4 -  */  0,
/* ad5 -  */  0,
/* ad6 -  */  0,
/* ad7 -  */  0,
/* ad8 -  */  0,
/* ad9 -  */  0,
/* ada -  */  0,
/* adb -  */  0,
/* adc -  */  0,
/* add -  */  0,
/* ade -  */  0,
/* adf -  */  0,
/* ae0 -  */  0,
/* ae1 -  */  0,
/* ae2 -  */  0,
/* ae3 -  */  0,
/* ae4 -  */  0,
/* ae5 -  */  0,
/* ae6 -  */  0,
/* ae7 -  */  0,
/* ae8 -  */  0,
/* ae9 -  */  0,
/* aea -  */  0,
/* aeb -  */  0,
/* aec -  */  0,
/* aed -  */  0,
/* aee -  */  0,
/* aef -  */  0,
/* af0 -  */  0,
/* af1 -  */  0,
/* af2 -  */  0,
/* af3 -  */  0,
/* af4 -  */  0,
/* af5 -  */  0,
/* af6 -  */  0,
/* af7 -  */  0,
/* af8 -  */  0,
/* af9 -  */  0,
/* afa -  */  0,
/* afb -  */  0,
/* afc -  */  0,
/* afd -  */  0,
/* afe -  */  0,
/* aff -  */  0,
/* b00 -  */  0,
/* b01 -  */  0,
/* b02 -  */  0,
/* b03 -  */  0,
/* b04 - _0F_7A_30 */  0x23f9,
/* b05 - _0F_7A_31 */  0x23fa,
/* b06 -  */  0,
/* b07 -  */  0,
/* b08 -  */  0,
/* b09 -  */  0,
/* b0a -  */  0,
/* b0b -  */  0,
/* b0c -  */  0,
/* b0d -  */  0,
/* b0e -  */  0,
/* b0f -  */  0,
/* b10 -  */  0,
/* b11 -  */  0,
/* b12 -  */  0,
/* b13 -  */  0,
/* b14 -  */  0,
/* b15 -  */  0,
/* b16 -  */  0,
/* b17 -  */  0,
/* b18 -  */  0,
/* b19 -  */  0,
/* b1a -  */  0,
/* b1b -  */  0,
/* b1c -  */  0,
/* b1d -  */  0,
/* b1e -  */  0,
/* b1f -  */  0,
/* b20 -  */  0,
/* b21 -  */  0,
/* b22 -  */  0,
/* b23 -  */  0,
/* b24 -  */  0,
/* b25 -  */  0,
/* b26 -  */  0,
/* b27 -  */  0,
/* b28 -  */  0,
/* b29 -  */  0,
/* b2a -  */  0,
/* b2b -  */  0,
/* b2c -  */  0,
/* b2d -  */  0,
/* b2e -  */  0,
/* b2f -  */  0,
/* b30 -  */  0,
/* b31 -  */  0,
/* b32 -  */  0,
/* b33 -  */  0,
/* b34 -  */  0,
/* b35 -  */  0,
/* b36 -  */  0,
/* b37 -  */  0,
/* b38 -  */  0,
/* b39 -  */  0,
/* b3a -  */  0,
/* b3b -  */  0,
/* b3c -  */  0,
/* b3d -  */  0,
/* b3e -  */  0,
/* b3f -  */  0,
/* b40 -  */  0,
/* b41 -  */  0,
/* b42 -  */  0,
/* b43 -  */  0,
/* b44 -  */  0,
/* b45 -  */  0,
/* b46 -  */  0,
/* b47 -  */  0,
/* b48 -  */  0,
/* b49 -  */  0,
/* b4a -  */  0,
/* b4b -  */  0,
/* b4c -  */  0,
/* b4d -  */  0,
/* b4e -  */  0,
/* b4f -  */  0,
/* b50 -  */  0,
/* b51 -  */  0,
/* b52 -  */  0,
/* b53 -  */  0,
/* b54 -  */  0,
/* b55 -  */  0,
/* b56 -  */  0,
/* b57 -  */  0,
/* b58 -  */  0,
/* b59 -  */  0,
/* b5a -  */  0,
/* b5b -  */  0,
/* b5c -  */  0,
/* b5d -  */  0,
/* b5e -  */  0,
/* b5f -  */  0,
/* b60 -  */  0,
/* b61 -  */  0,
/* b62 -  */  0,
/* b63 -  */  0,
/* b64 -  */  0,
/* b65 -  */  0,
/* b66 -  */  0,
/* b67 -  */  0,
/* b68 -  */  0,
/* b69 -  */  0,
/* b6a -  */  0,
/* b6b -  */  0,
/* b6c -  */  0,
/* b6d -  */  0,
/* b6e -  */  0,
/* b6f -  */  0,
/* b70 -  */  0,
/* b71 -  */  0,
/* b72 -  */  0,
/* b73 -  */  0,
/* b74 -  */  0,
/* b75 -  */  0,
/* b76 -  */  0,
/* b77 -  */  0,
/* b78 -  */  0,
/* b79 -  */  0,
/* b7a -  */  0,
/* b7b -  */  0,
/* b7c -  */  0,
/* b7d -  */  0,
/* b7e -  */  0,
/* b7f -  */  0,
/* b80 -  */  0,
/* b81 -  */  0,
/* b82 -  */  0,
/* b83 -  */  0,
/* b84 -  */  0,
/* b85 -  */  0,
/* b86 -  */  0,
/* b87 -  */  0,
/* b88 -  */  0,
/* b89 -  */  0,
/* b8a -  */  0,
/* b8b -  */  0,
/* b8c -  */  0,
/* b8d -  */  0,
/* b8e -  */  0,
/* b8f -  */  0,
/* b90 -  */  0,
/* b91 -  */  0,
/* b92 -  */  0,
/* b93 -  */  0,
/* b94 -  */  0,
/* b95 -  */  0,
/* b96 -  */  0,
/* b97 -  */  0,
/* b98 -  */  0,
/* b99 -  */  0,
/* b9a -  */  0,
/* b9b -  */  0,
/* b9c -  */  0,
/* b9d -  */  0,
/* b9e -  */  0,
/* b9f -  */  0,
/* ba0 -  */  0,
/* ba1 -  */  0,
/* ba2 -  */  0,
/* ba3 -  */  0,
/* ba4 -  */  0,
/* ba5 -  */  0,
/* ba6 -  */  0,
/* ba7 -  */  0,
/* ba8 -  */  0,
/* ba9 -  */  0,
/* baa -  */  0,
/* bab -  */  0,
/* bac -  */  0,
/* bad -  */  0,
/* bae -  */  0,
/* baf -  */  0,
/* bb0 -  */  0,
/* bb1 -  */  0,
/* bb2 -  */  0,
/* bb3 -  */  0,
/* bb4 -  */  0,
/* bb5 -  */  0,
/* bb6 -  */  0,
/* bb7 -  */  0,
/* bb8 -  */  0,
/* bb9 -  */  0,
/* bba -  */  0,
/* bbb -  */  0,
/* bbc -  */  0,
/* bbd -  */  0,
/* bbe -  */  0,
/* bbf -  */  0,
/* bc0 -  */  0,
/* bc1 -  */  0,
/* bc2 -  */  0,
/* bc3 -  */  0,
/* bc4 -  */  0,
/* bc5 -  */  0,
/* bc6 -  */  0,
/* bc7 -  */  0,
/* bc8 -  */  0,
/* bc9 -  */  0,
/* bca -  */  0,
/* bcb -  */  0,
/* bcc -  */  0,
/* bcd -  */  0,
/* bce -  */  0,
/* bcf -  */  0,
/* bd0 -  */  0,
/* bd1 -  */  0,
/* bd2 -  */  0,
/* bd3 -  */  0,
/* bd4 -  */  0,
/* bd5 - _66_0F_7C */  0x23fb,
/* bd6 -  */  0,
/* bd7 - _F2_0F_7C */  0x23fc,
/* bd8 -  */  0,
/* bd9 - _V_66_0F_7C */  0x4087,
/* bda -  */  0,
/* bdb - _V_F2_0F_7C */  0x4088,
/* bdc -  */  0,
/* bdd -  */  0,
/* bde -  */  0,
/* bdf -  */  0,
/* be0 -  */  0,
/* be1 - _66_0F_7D */  0x23fd,
/* be2 -  */  0,
/* be3 - _F2_0F_7D */  0x23fe,
/* be4 -  */  0,
/* be5 - _V_66_0F_7D */  0x4089,
/* be6 -  */  0,
/* be7 - _V_F2_0F_7D */  0x408a,
/* be8 -  */  0,
/* be9 -  */  0,
/* bea -  */  0,
/* beb -  */  0,
/* bec - _0F_7E */  0x408b,
/* bed - _66_0F_7E */  0x408c,
/* bee - _F3_0F_7E */  0x23ff,
/* bef -  */  0,
/* bf0 -  */  0,
/* bf1 - _V_66_0F_7E */  0x408d,
/* bf2 - _V_F3_0F_7E */  0x408e,
/* bf3 -  */  0,
/* bf4 -  */  0,
/* bf5 -  */  0,
/* bf6 -  */  0,
/* bf7 -  */  0,
/* bf8 - _0F_7F */  0x2400,
/* bf9 - _66_0F_7F */  0x2401,
/* bfa - _F3_0F_7F */  0x2402,
/* bfb -  */  0,
/* bfc -  */  0,
/* bfd - _V_66_0F_7F */  0x408f,
/* bfe - _V_F3_0F_7F */  0x4090,
/* bff -  */  0,
/* c00 -  */  0,
/* c01 -  */  0,
/* c02 -  */  0,
/* c03 -  */  0,
/* c04 - _0F_AE_00 */  0xd57c,
/* c05 - _0F_AE_01 */  0xd588,
/* c06 - _0F_AE_02 */  0xd594,
/* c07 - _0F_AE_03 */  0xd5a0,
/* c08 - _0F_AE_04 */  0x4091,
/* c09 - _0F_AE_05 */  0x4092,
/* c0a - _0F_AE_06 */  0x4093,
/* c0b - _0F_AE_07 */  0x4094,
/* c0c -  */  0,
/* c0d -  */  0,
/* c0e - _F3_0F_B8 */  0x2403,
/* c0f -  */  0,
/* c10 -  */  0,
/* c11 -  */  0,
/* c12 -  */  0,
/* c13 -  */  0,
/* c14 -  */  0,
/* c15 -  */  0,
/* c16 -  */  0,
/* c17 -  */  0,
/* c18 -  */  0,
/* c19 -  */  0,
/* c1a -  */  0,
/* c1b -  */  0,
/* c1c - _0F_BA_04 */  0x2404,
/* c1d - _0F_BA_05 */  0x2405,
/* c1e - _0F_BA_06 */  0x2406,
/* c1f - _0F_BA_07 */  0x2407,
/* c20 - _0F_BC */  0x2408,
/* c21 -  */  0,
/* c22 - _F3_0F_BC */  0x2409,
/* c23 -  */  0,
/* c24 -  */  0,
/* c25 -  */  0,
/* c26 -  */  0,
/* c27 -  */  0,
/* c28 -  */  0,
/* c29 -  */  0,
/* c2a -  */  0,
/* c2b -  */  0,
/* c2c - _0F_BD */  0x240a,
/* c2d -  */  0,
/* c2e - _F3_0F_BD */  0x240b,
/* c2f -  */  0,
/* c30 -  */  0,
/* c31 -  */  0,
/* c32 -  */  0,
/* c33 -  */  0,
/* c34 -  */  0,
/* c35 -  */  0,
/* c36 -  */  0,
/* c37 -  */  0,
/* c38 - _0F_C2 */  0x4095,
/* c39 - _66_0F_C2 */  0x4096,
/* c3a - _F3_0F_C2 */  0x4097,
/* c3b - _F2_0F_C2 */  0x4098,
/* c3c - _V_0F_C2 */  0x4099,
/* c3d - _V_66_0F_C2 */  0x409a,
/* c3e - _V_F3_0F_C2 */  0x409b,
/* c3f - _V_F2_0F_C2 */  0x409c,
/* c40 -  */  0,
/* c41 -  */  0,
/* c42 -  */  0,
/* c43 -  */  0,
/* c44 - _0F_C4 */  0x409d,
/* c45 - _66_0F_C4 */  0x409e,
/* c46 -  */  0,
/* c47 -  */  0,
/* c48 -  */  0,
/* c49 - _V_66_0F_C4 */  0x409f,
/* c4a -  */  0,
/* c4b -  */  0,
/* c4c -  */  0,
/* c4d -  */  0,
/* c4e -  */  0,
/* c4f -  */  0,
/* c50 - _0F_C5 */  0x40a0,
/* c51 - _66_0F_C5 */  0x40a1,
/* c52 -  */  0,
/* c53 -  */  0,
/* c54 -  */  0,
/* c55 - _V_66_0F_C5 */  0x40a2,
/* c56 -  */  0,
/* c57 -  */  0,
/* c58 -  */  0,
/* c59 -  */  0,
/* c5a -  */  0,
/* c5b -  */  0,
/* c5c - _0F_C6 */  0x40a3,
/* c5d - _66_0F_C6 */  0x40a4,
/* c5e -  */  0,
/* c5f -  */  0,
/* c60 - _V_0F_C6 */  0x40a5,
/* c61 - _V_66_0F_C6 */  0x40a6,
/* c62 -  */  0,
/* c63 -  */  0,
/* c64 -  */  0,
/* c65 -  */  0,
/* c66 -  */  0,
/* c67 -  */  0,
/* c68 -  */  0,
/* c69 - _0F_C7_01 */  0x40a7,
/* c6a -  */  0,
/* c6b -  */  0,
/* c6c -  */  0,
/* c6d -  */  0,
/* c6e - _0F_C7_06 */  0xd5ac,
/* c6f - _0F_C7_07 */  0x240c,
/* c70 -  */  0,
/* c71 - _66_0F_D0 */  0x240d,
/* c72 -  */  0,
/* c73 - _F2_0F_D0 */  0x240e,
/* c74 -  */  0,
/* c75 - _V_66_0F_D0 */  0x40a8,
/* c76 -  */  0,
/* c77 - _V_F2_0F_D0 */  0x40a9,
/* c78 -  */  0,
/* c79 -  */  0,
/* c7a -  */  0,
/* c7b -  */  0,
/* c7c - _0F_D1 */  0x240f,
/* c7d - _66_0F_D1 */  0x2410,
/* c7e -  */  0,
/* c7f -  */  0,
/* c80 -  */  0,
/* c81 - _V_66_0F_D1 */  0x40aa,
/* c82 -  */  0,
/* c83 -  */  0,
/* c84 -  */  0,
/* c85 -  */  0,
/* c86 -  */  0,
/* c87 -  */  0,
/* c88 - _0F_D2 */  0x2411,
/* c89 - _66_0F_D2 */  0x2412,
/* c8a -  */  0,
/* c8b -  */  0,
/* c8c -  */  0,
/* c8d - _V_66_0F_D2 */  0x40ab,
/* c8e -  */  0,
/* c8f -  */  0,
/* c90 -  */  0,
/* c91 -  */  0,
/* c92 -  */  0,
/* c93 -  */  0,
/* c94 - _0F_D3 */  0x2413,
/* c95 - _66_0F_D3 */  0x2414,
/* c96 -  */  0,
/* c97 -  */  0,
/* c98 -  */  0,
/* c99 - _V_66_0F_D3 */  0x40ac,
/* c9a -  */  0,
/* c9b -  */  0,
/* c9c -  */  0,
/* c9d -  */  0,
/* c9e -  */  0,
/* c9f -  */  0,
/* ca0 - _0F_D4 */  0x2415,
/* ca1 - _66_0F_D4 */  0x2416,
/* ca2 -  */  0,
/* ca3 -  */  0,
/* ca4 -  */  0,
/* ca5 - _V_66_0F_D4 */  0x40ad,
/* ca6 -  */  0,
/* ca7 -  */  0,
/* ca8 -  */  0,
/* ca9 -  */  0,
/* caa -  */  0,
/* cab -  */  0,
/* cac - _0F_D5 */  0x2417,
/* cad - _66_0F_D5 */  0x2418,
/* cae -  */  0,
/* caf -  */  0,
/* cb0 -  */  0,
/* cb1 - _V_66_0F_D5 */  0x40ae,
/* cb2 -  */  0,
/* cb3 -  */  0,
/* cb4 -  */  0,
/* cb5 -  */  0,
/* cb6 -  */  0,
/* cb7 -  */  0,
/* cb8 -  */  0,
/* cb9 - _66_0F_D6 */  0x2419,
/* cba - _F3_0F_D6 */  0x241a,
/* cbb - _F2_0F_D6 */  0x241b,
/* cbc -  */  0,
/* cbd - _V_66_0F_D6 */  0x40af,
/* cbe -  */  0,
/* cbf -  */  0,
/* cc0 -  */  0,
/* cc1 -  */  0,
/* cc2 -  */  0,
/* cc3 -  */  0,
/* cc4 - _0F_D7 */  0x241c,
/* cc5 - _66_0F_D7 */  0x241d,
/* cc6 -  */  0,
/* cc7 -  */  0,
/* cc8 -  */  0,
/* cc9 - _V_66_0F_D7 */  0x40b0,
/* cca -  */  0,
/* ccb -  */  0,
/* ccc -  */  0,
/* ccd -  */  0,
/* cce -  */  0,
/* ccf -  */  0,
/* cd0 - _0F_D8 */  0x241e,
/* cd1 - _66_0F_D8 */  0x241f,
/* cd2 -  */  0,
/* cd3 -  */  0,
/* cd4 -  */  0,
/* cd5 - _V_66_0F_D8 */  0x40b1,
/* cd6 -  */  0,
/* cd7 -  */  0,
/* cd8 -  */  0,
/* cd9 -  */  0,
/* cda -  */  0,
/* cdb -  */  0,
/* cdc - _0F_D9 */  0x2420,
/* cdd - _66_0F_D9 */  0x2421,
/* cde -  */  0,
/* cdf -  */  0,
/* ce0 -  */  0,
/* ce1 - _V_66_0F_D9 */  0x40b2,
/* ce2 -  */  0,
/* ce3 -  */  0,
/* ce4 -  */  0,
/* ce5 -  */  0,
/* ce6 -  */  0,
/* ce7 -  */  0,
/* ce8 - _0F_DA */  0x2422,
/* ce9 - _66_0F_DA */  0x2423,
/* cea -  */  0,
/* ceb -  */  0,
/* cec -  */  0,
/* ced - _V_66_0F_DA */  0x40b3,
/* cee -  */  0,
/* cef -  */  0,
/* cf0 -  */  0,
/* cf1 -  */  0,
/* cf2 -  */  0,
/* cf3 -  */  0,
/* cf4 - _0F_DB */  0x2424,
/* cf5 - _66_0F_DB */  0x2425,
/* cf6 -  */  0,
/* cf7 -  */  0,
/* cf8 -  */  0,
/* cf9 - _V_66_0F_DB */  0x40b4,
/* cfa -  */  0,
/* cfb -  */  0,
/* cfc -  */  0,
/* cfd -  */  0,
/* cfe -  */  0,
/* cff -  */  0,
/* d00 - _0F_DC */  0x2426,
/* d01 - _66_0F_DC */  0x2427,
/* d02 -  */  0,
/* d03 -  */  0,
/* d04 -  */  0,
/* d05 - _V_66_0F_DC */  0x40b5,
/* d06 -  */  0,
/* d07 -  */  0,
/* d08 -  */  0,
/* d09 -  */  0,
/* d0a -  */  0,
/* d0b -  */  0,
/* d0c - _0F_DD */  0x2428,
/* d0d - _66_0F_DD */  0x2429,
/* d0e -  */  0,
/* d0f -  */  0,
/* d10 -  */  0,
/* d11 - _V_66_0F_DD */  0x40b6,
/* d12 -  */  0,
/* d13 -  */  0,
/* d14 -  */  0,
/* d15 -  */  0,
/* d16 -  */  0,
/* d17 -  */  0,
/* d18 - _0F_DE */  0x242a,
/* d19 - _66_0F_DE */  0x242b,
/* d1a -  */  0,
/* d1b -  */  0,
/* d1c -  */  0,
/* d1d - _V_66_0F_DE */  0x40b7,
/* d1e -  */  0,
/* d1f -  */  0,
/* d20 -  */  0,
/* d21 -  */  0,
/* d22 -  */  0,
/* d23 -  */  0,
/* d24 - _0F_DF */  0x242c,
/* d25 - _66_0F_DF */  0x242d,
/* d26 -  */  0,
/* d27 -  */  0,
/* d28 -  */  0,
/* d29 - _V_66_0F_DF */  0x40b8,
/* d2a -  */  0,
/* d2b -  */  0,
/* d2c -  */  0,
/* d2d -  */  0,
/* d2e -  */  0,
/* d2f -  */  0,
/* d30 - _0F_E0 */  0x242e,
/* d31 - _66_0F_E0 */  0x242f,
/* d32 -  */  0,
/* d33 -  */  0,
/* d34 -  */  0,
/* d35 - _V_66_0F_E0 */  0x40b9,
/* d36 -  */  0,
/* d37 -  */  0,
/* d38 -  */  0,
/* d39 -  */  0,
/* d3a -  */  0,
/* d3b -  */  0,
/* d3c - _0F_E1 */  0x2430,
/* d3d - _66_0F_E1 */  0x2431,
/* d3e -  */  0,
/* d3f -  */  0,
/* d40 -  */  0,
/* d41 - _V_66_0F_E1 */  0x40ba,
/* d42 -  */  0,
/* d43 -  */  0,
/* d44 -  */  0,
/* d45 -  */  0,
/* d46 -  */  0,
/* d47 -  */  0,
/* d48 - _0F_E2 */  0x2432,
/* d49 - _66_0F_E2 */  0x2433,
/* d4a -  */  0,
/* d4b -  */  0,
/* d4c -  */  0,
/* d4d - _V_66_0F_E2 */  0x40bb,
/* d4e -  */  0,
/* d4f -  */  0,
/* d50 -  */  0,
/* d51 -  */  0,
/* d52 -  */  0,
/* d53 -  */  0,
/* d54 - _0F_E3 */  0x2434,
/* d55 - _66_0F_E3 */  0x2435,
/* d56 -  */  0,
/* d57 -  */  0,
/* d58 -  */  0,
/* d59 - _V_66_0F_E3 */  0x40bc,
/* d5a -  */  0,
/* d5b -  */  0,
/* d5c -  */  0,
/* d5d -  */  0,
/* d5e -  */  0,
/* d5f -  */  0,
/* d60 - _0F_E4 */  0x2436,
/* d61 - _66_0F_E4 */  0x2437,
/* d62 -  */  0,
/* d63 -  */  0,
/* d64 -  */  0,
/* d65 - _V_66_0F_E4 */  0x40bd,
/* d66 -  */  0,
/* d67 -  */  0,
/* d68 -  */  0,
/* d69 -  */  0,
/* d6a -  */  0,
/* d6b -  */  0,
/* d6c - _0F_E5 */  0x2438,
/* d6d - _66_0F_E5 */  0x2439,
/* d6e -  */  0,
/* d6f -  */  0,
/* d70 -  */  0,
/* d71 - _V_66_0F_E5 */  0x40be,
/* d72 -  */  0,
/* d73 -  */  0,
/* d74 -  */  0,
/* d75 -  */  0,
/* d76 -  */  0,
/* d77 -  */  0,
/* d78 -  */  0,
/* d79 - _66_0F_E6 */  0x243a,
/* d7a - _F3_0F_E6 */  0x243b,
/* d7b - _F2_0F_E6 */  0x243c,
/* d7c -  */  0,
/* d7d - _V_66_0F_E6 */  0x40bf,
/* d7e - _V_F3_0F_E6 */  0x40c0,
/* d7f - _V_F2_0F_E6 */  0x40c1,
/* d80 -  */  0,
/* d81 -  */  0,
/* d82 -  */  0,
/* d83 -  */  0,
/* d84 - _0F_E7 */  0x243d,
/* d85 - _66_0F_E7 */  0x243e,
/* d86 -  */  0,
/* d87 -  */  0,
/* d88 -  */  0,
/* d89 - _V_66_0F_E7 */  0x40c2,
/* d8a -  */  0,
/* d8b -  */  0,
/* d8c -  */  0,
/* d8d -  */  0,
/* d8e -  */  0,
/* d8f -  */  0,
/* d90 - _0F_E8 */  0x243f,
/* d91 - _66_0F_E8 */  0x2440,
/* d92 -  */  0,
/* d93 -  */  0,
/* d94 -  */  0,
/* d95 - _V_66_0F_E8 */  0x40c3,
/* d96 -  */  0,
/* d97 -  */  0,
/* d98 -  */  0,
/* d99 -  */  0,
/* d9a -  */  0,
/* d9b -  */  0,
/* d9c - _0F_E9 */  0x2441,
/* d9d - _66_0F_E9 */  0x2442,
/* d9e -  */  0,
/* d9f -  */  0,
/* da0 -  */  0,
/* da1 - _V_66_0F_E9 */  0x40c4,
/* da2 -  */  0,
/* da3 -  */  0,
/* da4 -  */  0,
/* da5 -  */  0,
/* da6 -  */  0,
/* da7 -  */  0,
/* da8 - _0F_EA */  0x2443,
/* da9 - _66_0F_EA */  0x2444,
/* daa -  */  0,
/* dab -  */  0,
/* dac -  */  0,
/* dad - _V_66_0F_EA */  0x40c5,
/* dae -  */  0,
/* daf -  */  0,
/* db0 -  */  0,
/* db1 -  */  0,
/* db2 -  */  0,
/* db3 -  */  0,
/* db4 - _0F_EB */  0x2445,
/* db5 - _66_0F_EB */  0x2446,
/* db6 -  */  0,
/* db7 -  */  0,
/* db8 -  */  0,
/* db9 - _V_66_0F_EB */  0x40c6,
/* dba -  */  0,
/* dbb -  */  0,
/* dbc -  */  0,
/* dbd -  */  0,
/* dbe -  */  0,
/* dbf -  */  0,
/* dc0 - _0F_EC */  0x2447,
/* dc1 - _66_0F_EC */  0x2448,
/* dc2 -  */  0,
/* dc3 -  */  0,
/* dc4 -  */  0,
/* dc5 - _V_66_0F_EC */  0x40c7,
/* dc6 -  */  0,
/* dc7 -  */  0,
/* dc8 -  */  0,
/* dc9 -  */  0,
/* dca -  */  0,
/* dcb -  */  0,
/* dcc - _0F_ED */  0x2449,
/* dcd - _66_0F_ED */  0x244a,
/* dce -  */  0,
/* dcf -  */  0,
/* dd0 -  */  0,
/* dd1 - _V_66_0F_ED */  0x40c8,
/* dd2 -  */  0,
/* dd3 -  */  0,
/* dd4 -  */  0,
/* dd5 -  */  0,
/* dd6 -  */  0,
/* dd7 -  */  0,
/* dd8 - _0F_EE */  0x244b,
/* dd9 - _66_0F_EE */  0x244c,
/* dda -  */  0,
/* ddb -  */  0,
/* ddc -  */  0,
/* ddd - _V_66_0F_EE */  0x40c9,
/* dde -  */  0,
/* ddf -  */  0,
/* de0 -  */  0,
/* de1 -  */  0,
/* de2 -  */  0,
/* de3 -  */  0,
/* de4 - _0F_EF */  0x244d,
/* de5 - _66_0F_EF */  0x244e,
/* de6 -  */  0,
/* de7 -  */  0,
/* de8 -  */  0,
/* de9 - _V_66_0F_EF */  0x40ca,
/* dea -  */  0,
/* deb -  */  0,
/* dec -  */  0,
/* ded -  */  0,
/* dee -  */  0,
/* def -  */  0,
/* df0 -  */  0,
/* df1 -  */  0,
/* df2 -  */  0,
/* df3 - _F2_0F_F0 */  0x244f,
/* df4 -  */  0,
/* df5 -  */  0,
/* df6 -  */  0,
/* df7 - _V_F2_0F_F0 */  0x40cb,
/* df8 -  */  0,
/* df9 -  */  0,
/* dfa -  */  0,
/* dfb -  */  0,
/* dfc - _0F_F1 */  0x2450,
/* dfd - _66_0F_F1 */  0x2451,
/* dfe -  */  0,
/* dff -  */  0,
/* e00 -  */  0,
/* e01 - _V_66_0F_F1 */  0x40cc,
/* e02 -  */  0,
/* e03 -  */  0,
/* e04 -  */  0,
/* e05 -  */  0,
/* e06 -  */  0,
/* e07 -  */  0,
/* e08 - _0F_F2 */  0x2452,
/* e09 - _66_0F_F2 */  0x2453,
/* e0a -  */  0,
/* e0b -  */  0,
/* e0c -  */  0,
/* e0d - _V_66_0F_F2 */  0x40cd,
/* e0e -  */  0,
/* e0f -  */  0,
/* e10 -  */  0,
/* e11 -  */  0,
/* e12 -  */  0,
/* e13 -  */  0,
/* e14 - _0F_F3 */  0x2454,
/* e15 - _66_0F_F3 */  0x2455,
/* e16 -  */  0,
/* e17 -  */  0,
/* e18 -  */  0,
/* e19 - _V_66_0F_F3 */  0x40ce,
/* e1a -  */  0,
/* e1b -  */  0,
/* e1c -  */  0,
/* e1d -  */  0,
/* e1e -  */  0,
/* e1f -  */  0,
/* e20 - _0F_F4 */  0x2456,
/* e21 - _66_0F_F4 */  0x2457,
/* e22 -  */  0,
/* e23 -  */  0,
/* e24 -  */  0,
/* e25 - _V_66_0F_F4 */  0x40cf,
/* e26 -  */  0,
/* e27 -  */  0,
/* e28 -  */  0,
/* e29 -  */  0,
/* e2a -  */  0,
/* e2b -  */  0,
/* e2c - _0F_F5 */  0x2458,
/* e2d - _66_0F_F5 */  0x2459,
/* e2e -  */  0,
/* e2f -  */  0,
/* e30 -  */  0,
/* e31 - _V_66_0F_F5 */  0x40d0,
/* e32 -  */  0,
/* e33 -  */  0,
/* e34 -  */  0,
/* e35 -  */  0,
/* e36 -  */  0,
/* e37 -  */  0,
/* e38 - _0F_F6 */  0x245a,
/* e39 - _66_0F_F6 */  0x245b,
/* e3a -  */  0,
/* e3b -  */  0,
/* e3c -  */  0,
/* e3d - _V_66_0F_F6 */  0x40d1,
/* e3e -  */  0,
/* e3f -  */  0,
/* e40 -  */  0,
/* e41 -  */  0,
/* e42 -  */  0,
/* e43 -  */  0,
/* e44 - _0F_F7 */  0x245c,
/* e45 - _66_0F_F7 */  0x245d,
/* e46 -  */  0,
/* e47 -  */  0,
/* e48 -  */  0,
/* e49 - _V_66_0F_F7 */  0x40d2,
/* e4a -  */  0,
/* e4b -  */  0,
/* e4c -  */  0,
/* e4d -  */  0,
/* e4e -  */  0,
/* e4f -  */  0,
/* e50 - _0F_F8 */  0x245e,
/* e51 - _66_0F_F8 */  0x245f,
/* e52 -  */  0,
/* e53 -  */  0,
/* e54 -  */  0,
/* e55 - _V_66_0F_F8 */  0x40d3,
/* e56 -  */  0,
/* e57 -  */  0,
/* e58 -  */  0,
/* e59 -  */  0,
/* e5a -  */  0,
/* e5b -  */  0,
/* e5c - _0F_F9 */  0x2460,
/* e5d - _66_0F_F9 */  0x2461,
/* e5e -  */  0,
/* e5f -  */  0,
/* e60 -  */  0,
/* e61 - _V_66_0F_F9 */  0x40d4,
/* e62 -  */  0,
/* e63 -  */  0,
/* e64 -  */  0,
/* e65 -  */  0,
/* e66 -  */  0,
/* e67 -  */  0,
/* e68 - _0F_FA */  0x2462,
/* e69 - _66_0F_FA */  0x2463,
/* e6a -  */  0,
/* e6b -  */  0,
/* e6c -  */  0,
/* e6d - _V_66_0F_FA */  0x40d5,
/* e6e -  */  0,
/* e6f -  */  0,
/* e70 -  */  0,
/* e71 -  */  0,
/* e72 -  */  0,
/* e73 -  */  0,
/* e74 - _0F_FB */  0x2464,
/* e75 - _66_0F_FB */  0x2465,
/* e76 -  */  0,
/* e77 -  */  0,
/* e78 -  */  0,
/* e79 - _V_66_0F_FB */  0x40d6,
/* e7a -  */  0,
/* e7b -  */  0,
/* e7c -  */  0,
/* e7d -  */  0,
/* e7e -  */  0,
/* e7f -  */  0,
/* e80 - _0F_FC */  0x2466,
/* e81 - _66_0F_FC */  0x2467,
/* e82 -  */  0,
/* e83 -  */  0,
/* e84 -  */  0,
/* e85 - _V_66_0F_FC */  0x40d7,
/* e86 -  */  0,
/* e87 -  */  0,
/* e88 -  */  0,
/* e89 -  */  0,
/* e8a -  */  0,
/* e8b -  */  0,
/* e8c - _0F_FD */  0x2468,
/* e8d - _66_0F_FD */  0x2469,
/* e8e -  */  0,
/* e8f -  */  0,
/* e90 -  */  0,
/* e91 - _V_66_0F_FD */  0x40d8,
/* e92 -  */  0,
/* e93 -  */  0,
/* e94 -  */  0,
/* e95 -  */  0,
/* e96 -  */  0,
/* e97 -  */  0,
/* e98 - _0F_FE */  0x246a,
/* e99 - _66_0F_FE */  0x246b,
/* e9a -  */  0,
/* e9b -  */  0,
/* e9c -  */  0,
/* e9d - _V_66_0F_FE */  0x40d9,
/* e9e -  */  0,
/* e9f -  */  0,
/* ea0 -  */  0,
/* ea1 -  */  0,
/* ea2 -  */  0,
/* ea3 -  */  0,
/* ea4 - _D9_06 */  0x246c,
/* ea5 - _9B_D9_06 */  0x246d,
/* ea6 -  */  0,
/* ea7 -  */  0,
/* ea8 -  */  0,
/* ea9 -  */  0,
/* eaa -  */  0,
/* eab -  */  0,
/* eac -  */  0,
/* ead -  */  0,
/* eae -  */  0,
/* eaf -  */  0,
/* eb0 - _D9_07 */  0x246e,
/* eb1 - _9B_D9_07 */  0x246f,
/* eb2 -  */  0,
/* eb3 -  */  0,
/* eb4 -  */  0,
/* eb5 -  */  0,
/* eb6 -  */  0,
/* eb7 -  */  0,
/* eb8 -  */  0,
/* eb9 -  */  0,
/* eba -  */  0,
/* ebb -  */  0,
/* ebc - _DB_E2 */  0x2470,
/* ebd - _9B_DB_E2 */  0x2471,
/* ebe -  */  0,
/* ebf -  */  0,
/* ec0 -  */  0,
/* ec1 -  */  0,
/* ec2 -  */  0,
/* ec3 -  */  0,
/* ec4 -  */  0,
/* ec5 -  */  0,
/* ec6 -  */  0,
/* ec7 -  */  0,
/* ec8 - _DB_E3 */  0x2472,
/* ec9 - _9B_DB_E3 */  0x2473,
/* eca -  */  0,
/* ecb -  */  0,
/* ecc -  */  0,
/* ecd -  */  0,
/* ece -  */  0,
/* ecf -  */  0,
/* ed0 -  */  0,
/* ed1 -  */  0,
/* ed2 -  */  0,
/* ed3 -  */  0,
/* ed4 - _DD_06 */  0x2474,
/* ed5 - _9B_DD_06 */  0x2475,
/* ed6 -  */  0,
/* ed7 -  */  0,
/* ed8 -  */  0,
/* ed9 -  */  0,
/* eda -  */  0,
/* edb -  */  0,
/* edc -  */  0,
/* edd -  */  0,
/* ede -  */  0,
/* edf -  */  0,
/* ee0 - _DD_07 */  0x2476,
/* ee1 - _9B_DD_07 */  0x2477,
/* ee2 -  */  0,
/* ee3 -  */  0,
/* ee4 -  */  0,
/* ee5 -  */  0,
/* ee6 -  */  0,
/* ee7 -  */  0,
/* ee8 -  */  0,
/* ee9 -  */  0,
/* eea -  */  0,
/* eeb -  */  0,
/* eec - _DF_E0 */  0x2478,
/* eed - _9B_DF_E0 */  0x2479,
/* eee -  */  0,
/* eef -  */  0,
/* ef0 -  */  0,
/* ef1 -  */  0,
/* ef2 -  */  0,
/* ef3 -  */  0,
/* ef4 -  */  0,
/* ef5 -  */  0,
/* ef6 -  */  0,
/* ef7 -  */  0,
/* ef8 - _0F_38_00 */  0x247a,
/* ef9 - _66_0F_38_00 */  0x247b,
/* efa -  */  0,
/* efb -  */  0,
/* efc -  */  0,
/* efd - _V_66_0F_38_00 */  0x40da,
/* efe -  */  0,
/* eff -  */  0,
/* f00 -  */  0,
/* f01 -  */  0,
/* f02 -  */  0,
/* f03 -  */  0,
/* f04 - _0F_38_01 */  0x247c,
/* f05 - _66_0F_38_01 */  0x247d,
/* f06 -  */  0,
/* f07 -  */  0,
/* f08 -  */  0,
/* f09 - _V_66_0F_38_01 */  0x40db,
/* f0a -  */  0,
/* f0b -  */  0,
/* f0c -  */  0,
/* f0d -  */  0,
/* f0e -  */  0,
/* f0f -  */  0,
/* f10 - _0F_38_02 */  0x247e,
/* f11 - _66_0F_38_02 */  0x247f,
/* f12 -  */  0,
/* f13 -  */  0,
/* f14 -  */  0,
/* f15 - _V_66_0F_38_02 */  0x40dc,
/* f16 -  */  0,
/* f17 -  */  0,
/* f18 -  */  0,
/* f19 -  */  0,
/* f1a -  */  0,
/* f1b -  */  0,
/* f1c - _0F_38_03 */  0x2480,
/* f1d - _66_0F_38_03 */  0x2481,
/* f1e -  */  0,
/* f1f -  */  0,
/* f20 -  */  0,
/* f21 - _V_66_0F_38_03 */  0x40dd,
/* f22 -  */  0,
/* f23 -  */  0,
/* f24 -  */  0,
/* f25 -  */  0,
/* f26 -  */  0,
/* f27 -  */  0,
/* f28 - _0F_38_04 */  0x2482,
/* f29 - _66_0F_38_04 */  0x2483,
/* f2a -  */  0,
/* f2b -  */  0,
/* f2c -  */  0,
/* f2d - _V_66_0F_38_04 */  0x40de,
/* f2e -  */  0,
/* f2f -  */  0,
/* f30 -  */  0,
/* f31 -  */  0,
/* f32 -  */  0,
/* f33 -  */  0,
/* f34 - _0F_38_05 */  0x2484,
/* f35 - _66_0F_38_05 */  0x2485,
/* f36 -  */  0,
/* f37 -  */  0,
/* f38 -  */  0,
/* f39 - _V_66_0F_38_05 */  0x40df,
/* f3a -  */  0,
/* f3b -  */  0,
/* f3c -  */  0,
/* f3d -  */  0,
/* f3e -  */  0,
/* f3f -  */  0,
/* f40 - _0F_38_06 */  0x2486,
/* f41 - _66_0F_38_06 */  0x2487,
/* f42 -  */  0,
/* f43 -  */  0,
/* f44 -  */  0,
/* f45 - _V_66_0F_38_06 */  0x40e0,
/* f46 -  */  0,
/* f47 -  */  0,
/* f48 -  */  0,
/* f49 -  */  0,
/* f4a -  */  0,
/* f4b -  */  0,
/* f4c - _0F_38_07 */  0x2488,
/* f4d - _66_0F_38_07 */  0x2489,
/* f4e -  */  0,
/* f4f -  */  0,
/* f50 -  */  0,
/* f51 - _V_66_0F_38_07 */  0x40e1,
/* f52 -  */  0,
/* f53 -  */  0,
/* f54 -  */  0,
/* f55 -  */  0,
/* f56 -  */  0,
/* f57 -  */  0,
/* f58 - _0F_38_08 */  0x248a,
/* f59 - _66_0F_38_08 */  0x248b,
/* f5a -  */  0,
/* f5b -  */  0,
/* f5c -  */  0,
/* f5d - _V_66_0F_38_08 */  0x40e2,
/* f5e -  */  0,
/* f5f -  */  0,
/* f60 -  */  0,
/* f61 -  */  0,
/* f62 -  */  0,
/* f63 -  */  0,
/* f64 - _0F_38_09 */  0x248c,
/* f65 - _66_0F_38_09 */  0x248d,
/* f66 -  */  0,
/* f67 -  */  0,
/* f68 -  */  0,
/* f69 - _V_66_0F_38_09 */  0x40e3,
/* f6a -  */  0,
/* f6b -  */  0,
/* f6c -  */  0,
/* f6d -  */  0,
/* f6e -  */  0,
/* f6f -  */  0,
/* f70 - _0F_38_0A */  0x248e,
/* f71 - _66_0F_38_0A */  0x248f,
/* f72 -  */  0,
/* f73 -  */  0,
/* f74 -  */  0,
/* f75 - _V_66_0F_38_0A */  0x40e4,
/* f76 -  */  0,
/* f77 -  */  0,
/* f78 -  */  0,
/* f79 -  */  0,
/* f7a -  */  0,
/* f7b -  */  0,
/* f7c - _0F_38_0B */  0x2490,
/* f7d - _66_0F_38_0B */  0x2491,
/* f7e -  */  0,
/* f7f -  */  0,
/* f80 -  */  0,
/* f81 - _V_66_0F_38_0B */  0x40e5,
/* f82 -  */  0,
/* f83 -  */  0,
/* f84 -  */  0,
/* f85 -  */  0,
/* f86 -  */  0,
/* f87 -  */  0,
/* f88 -  */  0,
/* f89 -  */  0,
/* f8a -  */  0,
/* f8b -  */  0,
/* f8c -  */  0,
/* f8d - _V_66_0F_38_0C */  0x40e6,
/* f8e -  */  0,
/* f8f -  */  0,
/* f90 -  */  0,
/* f91 -  */  0,
/* f92 -  */  0,
/* f93 -  */  0,
/* f94 -  */  0,
/* f95 -  */  0,
/* f96 -  */  0,
/* f97 -  */  0,
/* f98 -  */  0,
/* f99 - _V_66_0F_38_0D */  0x40e7,
/* f9a -  */  0,
/* f9b -  */  0,
/* f9c -  */  0,
/* f9d -  */  0,
/* f9e -  */  0,
/* f9f -  */  0,
/* fa0 -  */  0,
/* fa1 -  */  0,
/* fa2 -  */  0,
/* fa3 -  */  0,
/* fa4 -  */  0,
/* fa5 - _V_66_0F_38_0E */  0x40e8,
/* fa6 -  */  0,
/* fa7 -  */  0,
/* fa8 -  */  0,
/* fa9 -  */  0,
/* faa -  */  0,
/* fab -  */  0,
/* fac -  */  0,
/* fad -  */  0,
/* fae -  */  0,
/* faf -  */  0,
/* fb0 -  */  0,
/* fb1 - _V_66_0F_38_0F */  0x40e9,
/* fb2 -  */  0,
/* fb3 -  */  0,
/* fb4 -  */  0,
/* fb5 -  */  0,
/* fb6 -  */  0,
/* fb7 -  */  0,
/* fb8 -  */  0,
/* fb9 - _66_0F_38_10 */  0x40ea,
/* fba -  */  0,
/* fbb -  */  0,
/* fbc -  */  0,
/* fbd -  */  0,
/* fbe -  */  0,
/* fbf -  */  0,
/* fc0 -  */  0,
/* fc1 -  */  0,
/* fc2 -  */  0,
/* fc3 -  */  0,
/* fc4 -  */  0,
/* fc5 - _66_0F_38_14 */  0x40eb,
/* fc6 -  */  0,
/* fc7 -  */  0,
/* fc8 -  */  0,
/* fc9 -  */  0,
/* fca -  */  0,
/* fcb -  */  0,
/* fcc -  */  0,
/* fcd -  */  0,
/* fce -  */  0,
/* fcf -  */  0,
/* fd0 -  */  0,
/* fd1 - _66_0F_38_15 */  0x40ec,
/* fd2 -  */  0,
/* fd3 -  */  0,
/* fd4 -  */  0,
/* fd5 -  */  0,
/* fd6 -  */  0,
/* fd7 -  */  0,
/* fd8 -  */  0,
/* fd9 -  */  0,
/* fda -  */  0,
/* fdb -  */  0,
/* fdc -  */  0,
/* fdd - _66_0F_38_17 */  0x2492,
/* fde -  */  0,
/* fdf -  */  0,
/* fe0 -  */  0,
/* fe1 - _V_66_0F_38_17 */  0x40ed,
/* fe2 -  */  0,
/* fe3 -  */  0,
/* fe4 -  */  0,
/* fe5 -  */  0,
/* fe6 -  */  0,
/* fe7 -  */  0,
/* fe8 -  */  0,
/* fe9 -  */  0,
/* fea -  */  0,
/* feb -  */  0,
/* fec -  */  0,
/* fed - _V_66_0F_38_18 */  0x40ee,
/* fee -  */  0,
/* fef -  */  0,
/* ff0 -  */  0,
/* ff1 -  */  0,
/* ff2 -  */  0,
/* ff3 -  */  0,
/* ff4 -  */  0,
/* ff5 -  */  0,
/* ff6 -  */  0,
/* ff7 -  */  0,
/* ff8 -  */  0,
/* ff9 - _V_66_0F_38_19 */  0x40ef,
/* ffa -  */  0,
/* ffb -  */  0,
/* ffc -  */  0,
/* ffd -  */  0,
/* ffe -  */  0,
/* fff -  */  0,
/* 1000 -  */  0,
/* 1001 -  */  0,
/* 1002 -  */  0,
/* 1003 -  */  0,
/* 1004 -  */  0,
/* 1005 - _V_66_0F_38_1A */  0x40f0,
/* 1006 -  */  0,
/* 1007 -  */  0,
/* 1008 -  */  0,
/* 1009 -  */  0,
/* 100a -  */  0,
/* 100b -  */  0,
/* 100c - _0F_38_1C */  0x2493,
/* 100d - _66_0F_38_1C */  0x2494,
/* 100e -  */  0,
/* 100f -  */  0,
/* 1010 -  */  0,
/* 1011 - _V_66_0F_38_1C */  0x40f1,
/* 1012 -  */  0,
/* 1013 -  */  0,
/* 1014 -  */  0,
/* 1015 -  */  0,
/* 1016 -  */  0,
/* 1017 -  */  0,
/* 1018 - _0F_38_1D */  0x2495,
/* 1019 - _66_0F_38_1D */  0x2496,
/* 101a -  */  0,
/* 101b -  */  0,
/* 101c -  */  0,
/* 101d - _V_66_0F_38_1D */  0x40f2,
/* 101e -  */  0,
/* 101f -  */  0,
/* 1020 -  */  0,
/* 1021 -  */  0,
/* 1022 -  */  0,
/* 1023 -  */  0,
/* 1024 - _0F_38_1E */  0x2497,
/* 1025 - _66_0F_38_1E */  0x2498,
/* 1026 -  */  0,
/* 1027 -  */  0,
/* 1028 -  */  0,
/* 1029 - _V_66_0F_38_1E */  0x40f3,
/* 102a -  */  0,
/* 102b -  */  0,
/* 102c -  */  0,
/* 102d -  */  0,
/* 102e -  */  0,
/* 102f -  */  0,
/* 1030 -  */  0,
/* 1031 - _66_0F_38_20 */  0x2499,
/* 1032 -  */  0,
/* 1033 -  */  0,
/* 1034 -  */  0,
/* 1035 - _V_66_0F_38_20 */  0x40f4,
/* 1036 -  */  0,
/* 1037 -  */  0,
/* 1038 -  */  0,
/* 1039 -  */  0,
/* 103a -  */  0,
/* 103b -  */  0,
/* 103c -  */  0,
/* 103d - _66_0F_38_21 */  0x249a,
/* 103e -  */  0,
/* 103f -  */  0,
/* 1040 -  */  0,
/* 1041 - _V_66_0F_38_21 */  0x40f5,
/* 1042 -  */  0,
/* 1043 -  */  0,
/* 1044 -  */  0,
/* 1045 -  */  0,
/* 1046 -  */  0,
/* 1047 -  */  0,
/* 1048 -  */  0,
/* 1049 - _66_0F_38_22 */  0x249b,
/* 104a -  */  0,
/* 104b -  */  0,
/* 104c -  */  0,
/* 104d - _V_66_0F_38_22 */  0x40f6,
/* 104e -  */  0,
/* 104f -  */  0,
/* 1050 -  */  0,
/* 1051 -  */  0,
/* 1052 -  */  0,
/* 1053 -  */  0,
/* 1054 -  */  0,
/* 1055 - _66_0F_38_23 */  0x249c,
/* 1056 -  */  0,
/* 1057 -  */  0,
/* 1058 -  */  0,
/* 1059 - _V_66_0F_38_23 */  0x40f7,
/* 105a -  */  0,
/* 105b -  */  0,
/* 105c -  */  0,
/* 105d -  */  0,
/* 105e -  */  0,
/* 105f -  */  0,
/* 1060 -  */  0,
/* 1061 - _66_0F_38_24 */  0x249d,
/* 1062 -  */  0,
/* 1063 -  */  0,
/* 1064 -  */  0,
/* 1065 - _V_66_0F_38_24 */  0x40f8,
/* 1066 -  */  0,
/* 1067 -  */  0,
/* 1068 -  */  0,
/* 1069 -  */  0,
/* 106a -  */  0,
/* 106b -  */  0,
/* 106c -  */  0,
/* 106d - _66_0F_38_25 */  0x249e,
/* 106e -  */  0,
/* 106f -  */  0,
/* 1070 -  */  0,
/* 1071 - _V_66_0F_38_25 */  0x40f9,
/* 1072 -  */  0,
/* 1073 -  */  0,
/* 1074 -  */  0,
/* 1075 -  */  0,
/* 1076 -  */  0,
/* 1077 -  */  0,
/* 1078 -  */  0,
/* 1079 - _66_0F_38_28 */  0x249f,
/* 107a -  */  0,
/* 107b -  */  0,
/* 107c -  */  0,
/* 107d - _V_66_0F_38_28 */  0x40fa,
/* 107e -  */  0,
/* 107f -  */  0,
/* 1080 -  */  0,
/* 1081 -  */  0,
/* 1082 -  */  0,
/* 1083 -  */  0,
/* 1084 -  */  0,
/* 1085 - _66_0F_38_29 */  0x24a0,
/* 1086 -  */  0,
/* 1087 -  */  0,
/* 1088 -  */  0,
/* 1089 - _V_66_0F_38_29 */  0x40fb,
/* 108a -  */  0,
/* 108b -  */  0,
/* 108c -  */  0,
/* 108d -  */  0,
/* 108e -  */  0,
/* 108f -  */  0,
/* 1090 -  */  0,
/* 1091 - _66_0F_38_2A */  0x24a1,
/* 1092 -  */  0,
/* 1093 -  */  0,
/* 1094 -  */  0,
/* 1095 - _V_66_0F_38_2A */  0x40fc,
/* 1096 -  */  0,
/* 1097 -  */  0,
/* 1098 -  */  0,
/* 1099 -  */  0,
/* 109a -  */  0,
/* 109b -  */  0,
/* 109c -  */  0,
/* 109d - _66_0F_38_2B */  0x24a2,
/* 109e -  */  0,
/* 109f -  */  0,
/* 10a0 -  */  0,
/* 10a1 - _V_66_0F_38_2B */  0x40fd,
/* 10a2 -  */  0,
/* 10a3 -  */  0,
/* 10a4 -  */  0,
/* 10a5 -  */  0,
/* 10a6 -  */  0,
/* 10a7 -  */  0,
/* 10a8 -  */  0,
/* 10a9 -  */  0,
/* 10aa -  */  0,
/* 10ab -  */  0,
/* 10ac -  */  0,
/* 10ad - _V_66_0F_38_2C */  0x40fe,
/* 10ae -  */  0,
/* 10af -  */  0,
/* 10b0 -  */  0,
/* 10b1 -  */  0,
/* 10b2 -  */  0,
/* 10b3 -  */  0,
/* 10b4 -  */  0,
/* 10b5 -  */  0,
/* 10b6 -  */  0,
/* 10b7 -  */  0,
/* 10b8 -  */  0,
/* 10b9 - _V_66_0F_38_2D */  0x40ff,
/* 10ba -  */  0,
/* 10bb -  */  0,
/* 10bc -  */  0,
/* 10bd -  */  0,
/* 10be -  */  0,
/* 10bf -  */  0,
/* 10c0 -  */  0,
/* 10c1 -  */  0,
/* 10c2 -  */  0,
/* 10c3 -  */  0,
/* 10c4 -  */  0,
/* 10c5 - _V_66_0F_38_2E */  0x4100,
/* 10c6 -  */  0,
/* 10c7 -  */  0,
/* 10c8 -  */  0,
/* 10c9 -  */  0,
/* 10ca -  */  0,
/* 10cb -  */  0,
/* 10cc -  */  0,
/* 10cd -  */  0,
/* 10ce -  */  0,
/* 10cf -  */  0,
/* 10d0 -  */  0,
/* 10d1 - _V_66_0F_38_2F */  0x4101,
/* 10d2 -  */  0,
/* 10d3 -  */  0,
/* 10d4 -  */  0,
/* 10d5 -  */  0,
/* 10d6 -  */  0,
/* 10d7 -  */  0,
/* 10d8 -  */  0,
/* 10d9 - _66_0F_38_30 */  0x24a3,
/* 10da -  */  0,
/* 10db -  */  0,
/* 10dc -  */  0,
/* 10dd - _V_66_0F_38_30 */  0x4102,
/* 10de -  */  0,
/* 10df -  */  0,
/* 10e0 -  */  0,
/* 10e1 -  */  0,
/* 10e2 -  */  0,
/* 10e3 -  */  0,
/* 10e4 -  */  0,
/* 10e5 - _66_0F_38_31 */  0x24a4,
/* 10e6 -  */  0,
/* 10e7 -  */  0,
/* 10e8 -  */  0,
/* 10e9 - _V_66_0F_38_31 */  0x4103,
/* 10ea -  */  0,
/* 10eb -  */  0,
/* 10ec -  */  0,
/* 10ed -  */  0,
/* 10ee -  */  0,
/* 10ef -  */  0,
/* 10f0 -  */  0,
/* 10f1 - _66_0F_38_32 */  0x24a5,
/* 10f2 -  */  0,
/* 10f3 -  */  0,
/* 10f4 -  */  0,
/* 10f5 - _V_66_0F_38_32 */  0x4104,
/* 10f6 -  */  0,
/* 10f7 -  */  0,
/* 10f8 -  */  0,
/* 10f9 -  */  0,
/* 10fa -  */  0,
/* 10fb -  */  0,
/* 10fc -  */  0,
/* 10fd - _66_0F_38_33 */  0x24a6,
/* 10fe -  */  0,
/* 10ff -  */  0,
/* 1100 -  */  0,
/* 1101 - _V_66_0F_38_33 */  0x4105,
/* 1102 -  */  0,
/* 1103 -  */  0,
/* 1104 -  */  0,
/* 1105 -  */  0,
/* 1106 -  */  0,
/* 1107 -  */  0,
/* 1108 -  */  0,
/* 1109 - _66_0F_38_34 */  0x24a7,
/* 110a -  */  0,
/* 110b -  */  0,
/* 110c -  */  0,
/* 110d - _V_66_0F_38_34 */  0x4106,
/* 110e -  */  0,
/* 110f -  */  0,
/* 1110 -  */  0,
/* 1111 -  */  0,
/* 1112 -  */  0,
/* 1113 -  */  0,
/* 1114 -  */  0,
/* 1115 - _66_0F_38_35 */  0x24a8,
/* 1116 -  */  0,
/* 1117 -  */  0,
/* 1118 -  */  0,
/* 1119 - _V_66_0F_38_35 */  0x4107,
/* 111a -  */  0,
/* 111b -  */  0,
/* 111c -  */  0,
/* 111d -  */  0,
/* 111e -  */  0,
/* 111f -  */  0,
/* 1120 -  */  0,
/* 1121 - _66_0F_38_37 */  0x24a9,
/* 1122 -  */  0,
/* 1123 -  */  0,
/* 1124 -  */  0,
/* 1125 - _V_66_0F_38_37 */  0x4108,
/* 1126 -  */  0,
/* 1127 -  */  0,
/* 1128 -  */  0,
/* 1129 -  */  0,
/* 112a -  */  0,
/* 112b -  */  0,
/* 112c -  */  0,
/* 112d - _66_0F_38_38 */  0x24aa,
/* 112e -  */  0,
/* 112f -  */  0,
/* 1130 -  */  0,
/* 1131 - _V_66_0F_38_38 */  0x4109,
/* 1132 -  */  0,
/* 1133 -  */  0,
/* 1134 -  */  0,
/* 1135 -  */  0,
/* 1136 -  */  0,
/* 1137 -  */  0,
/* 1138 -  */  0,
/* 1139 - _66_0F_38_39 */  0x24ab,
/* 113a -  */  0,
/* 113b -  */  0,
/* 113c -  */  0,
/* 113d - _V_66_0F_38_39 */  0x410a,
/* 113e -  */  0,
/* 113f -  */  0,
/* 1140 -  */  0,
/* 1141 -  */  0,
/* 1142 -  */  0,
/* 1143 -  */  0,
/* 1144 -  */  0,
/* 1145 - _66_0F_38_3A */  0x24ac,
/* 1146 -  */  0,
/* 1147 -  */  0,
/* 1148 -  */  0,
/* 1149 - _V_66_0F_38_3A */  0x410b,
/* 114a -  */  0,
/* 114b -  */  0,
/* 114c -  */  0,
/* 114d -  */  0,
/* 114e -  */  0,
/* 114f -  */  0,
/* 1150 -  */  0,
/* 1151 - _66_0F_38_3B */  0x24ad,
/* 1152 -  */  0,
/* 1153 -  */  0,
/* 1154 -  */  0,
/* 1155 - _V_66_0F_38_3B */  0x410c,
/* 1156 -  */  0,
/* 1157 -  */  0,
/* 1158 -  */  0,
/* 1159 -  */  0,
/* 115a -  */  0,
/* 115b -  */  0,
/* 115c -  */  0,
/* 115d - _66_0F_38_3C */  0x24ae,
/* 115e -  */  0,
/* 115f -  */  0,
/* 1160 -  */  0,
/* 1161 - _V_66_0F_38_3C */  0x410d,
/* 1162 -  */  0,
/* 1163 -  */  0,
/* 1164 -  */  0,
/* 1165 -  */  0,
/* 1166 -  */  0,
/* 1167 -  */  0,
/* 1168 -  */  0,
/* 1169 - _66_0F_38_3D */  0x24af,
/* 116a -  */  0,
/* 116b -  */  0,
/* 116c -  */  0,
/* 116d - _V_66_0F_38_3D */  0x410e,
/* 116e -  */  0,
/* 116f -  */  0,
/* 1170 -  */  0,
/* 1171 -  */  0,
/* 1172 -  */  0,
/* 1173 -  */  0,
/* 1174 -  */  0,
/* 1175 - _66_0F_38_3E */  0x24b0,
/* 1176 -  */  0,
/* 1177 -  */  0,
/* 1178 -  */  0,
/* 1179 - _V_66_0F_38_3E */  0x410f,
/* 117a -  */  0,
/* 117b -  */  0,
/* 117c -  */  0,
/* 117d -  */  0,
/* 117e -  */  0,
/* 117f -  */  0,
/* 1180 -  */  0,
/* 1181 - _66_0F_38_3F */  0x24b1,
/* 1182 -  */  0,
/* 1183 -  */  0,
/* 1184 -  */  0,
/* 1185 - _V_66_0F_38_3F */  0x4110,
/* 1186 -  */  0,
/* 1187 -  */  0,
/* 1188 -  */  0,
/* 1189 -  */  0,
/* 118a -  */  0,
/* 118b -  */  0,
/* 118c -  */  0,
/* 118d - _66_0F_38_40 */  0x24b2,
/* 118e -  */  0,
/* 118f -  */  0,
/* 1190 -  */  0,
/* 1191 - _V_66_0F_38_40 */  0x4111,
/* 1192 -  */  0,
/* 1193 -  */  0,
/* 1194 -  */  0,
/* 1195 -  */  0,
/* 1196 -  */  0,
/* 1197 -  */  0,
/* 1198 -  */  0,
/* 1199 - _66_0F_38_41 */  0x24b3,
/* 119a -  */  0,
/* 119b -  */  0,
/* 119c -  */  0,
/* 119d - _V_66_0F_38_41 */  0x4112,
/* 119e -  */  0,
/* 119f -  */  0,
/* 11a0 -  */  0,
/* 11a1 -  */  0,
/* 11a2 -  */  0,
/* 11a3 -  */  0,
/* 11a4 -  */  0,
/* 11a5 - _66_0F_38_80 */  0x24b4,
/* 11a6 -  */  0,
/* 11a7 -  */  0,
/* 11a8 -  */  0,
/* 11a9 -  */  0,
/* 11aa -  */  0,
/* 11ab -  */  0,
/* 11ac -  */  0,
/* 11ad -  */  0,
/* 11ae -  */  0,
/* 11af -  */  0,
/* 11b0 -  */  0,
/* 11b1 - _66_0F_38_81 */  0x24b5,
/* 11b2 -  */  0,
/* 11b3 -  */  0,
/* 11b4 -  */  0,
/* 11b5 -  */  0,
/* 11b6 -  */  0,
/* 11b7 -  */  0,
/* 11b8 -  */  0,
/* 11b9 -  */  0,
/* 11ba -  */  0,
/* 11bb -  */  0,
/* 11bc -  */  0,
/* 11bd - _66_0F_38_82 */  0x24b6,
/* 11be -  */  0,
/* 11bf -  */  0,
/* 11c0 -  */  0,
/* 11c1 -  */  0,
/* 11c2 -  */  0,
/* 11c3 -  */  0,
/* 11c4 -  */  0,
/* 11c5 -  */  0,
/* 11c6 -  */  0,
/* 11c7 -  */  0,
/* 11c8 -  */  0,
/* 11c9 -  */  0,
/* 11ca -  */  0,
/* 11cb -  */  0,
/* 11cc -  */  0,
/* 11cd - _V_66_0F_38_96 */  0x4113,
/* 11ce -  */  0,
/* 11cf -  */  0,
/* 11d0 -  */  0,
/* 11d1 -  */  0,
/* 11d2 -  */  0,
/* 11d3 -  */  0,
/* 11d4 -  */  0,
/* 11d5 -  */  0,
/* 11d6 -  */  0,
/* 11d7 -  */  0,
/* 11d8 -  */  0,
/* 11d9 - _V_66_0F_38_97 */  0x4114,
/* 11da -  */  0,
/* 11db -  */  0,
/* 11dc -  */  0,
/* 11dd -  */  0,
/* 11de -  */  0,
/* 11df -  */  0,
/* 11e0 -  */  0,
/* 11e1 -  */  0,
/* 11e2 -  */  0,
/* 11e3 -  */  0,
/* 11e4 -  */  0,
/* 11e5 - _V_66_0F_38_98 */  0x4115,
/* 11e6 -  */  0,
/* 11e7 -  */  0,
/* 11e8 -  */  0,
/* 11e9 -  */  0,
/* 11ea -  */  0,
/* 11eb -  */  0,
/* 11ec -  */  0,
/* 11ed -  */  0,
/* 11ee -  */  0,
/* 11ef -  */  0,
/* 11f0 -  */  0,
/* 11f1 - _V_66_0F_38_99 */  0x4116,
/* 11f2 -  */  0,
/* 11f3 -  */  0,
/* 11f4 -  */  0,
/* 11f5 -  */  0,
/* 11f6 -  */  0,
/* 11f7 -  */  0,
/* 11f8 -  */  0,
/* 11f9 -  */  0,
/* 11fa -  */  0,
/* 11fb -  */  0,
/* 11fc -  */  0,
/* 11fd - _V_66_0F_38_9A */  0x4117,
/* 11fe -  */  0,
/* 11ff -  */  0,
/* 1200 -  */  0,
/* 1201 -  */  0,
/* 1202 -  */  0,
/* 1203 -  */  0,
/* 1204 -  */  0,
/* 1205 -  */  0,
/* 1206 -  */  0,
/* 1207 -  */  0,
/* 1208 -  */  0,
/* 1209 - _V_66_0F_38_9B */  0x4118,
/* 120a -  */  0,
/* 120b -  */  0,
/* 120c -  */  0,
/* 120d -  */  0,
/* 120e -  */  0,
/* 120f -  */  0,
/* 1210 -  */  0,
/* 1211 -  */  0,
/* 1212 -  */  0,
/* 1213 -  */  0,
/* 1214 -  */  0,
/* 1215 - _V_66_0F_38_9C */  0x4119,
/* 1216 -  */  0,
/* 1217 -  */  0,
/* 1218 -  */  0,
/* 1219 -  */  0,
/* 121a -  */  0,
/* 121b -  */  0,
/* 121c -  */  0,
/* 121d -  */  0,
/* 121e -  */  0,
/* 121f -  */  0,
/* 1220 -  */  0,
/* 1221 - _V_66_0F_38_9D */  0x411a,
/* 1222 -  */  0,
/* 1223 -  */  0,
/* 1224 -  */  0,
/* 1225 -  */  0,
/* 1226 -  */  0,
/* 1227 -  */  0,
/* 1228 -  */  0,
/* 1229 -  */  0,
/* 122a -  */  0,
/* 122b -  */  0,
/* 122c -  */  0,
/* 122d - _V_66_0F_38_9E */  0x411b,
/* 122e -  */  0,
/* 122f -  */  0,
/* 1230 -  */  0,
/* 1231 -  */  0,
/* 1232 -  */  0,
/* 1233 -  */  0,
/* 1234 -  */  0,
/* 1235 -  */  0,
/* 1236 -  */  0,
/* 1237 -  */  0,
/* 1238 -  */  0,
/* 1239 - _V_66_0F_38_9F */  0x411c,
/* 123a -  */  0,
/* 123b -  */  0,
/* 123c -  */  0,
/* 123d -  */  0,
/* 123e -  */  0,
/* 123f -  */  0,
/* 1240 -  */  0,
/* 1241 -  */  0,
/* 1242 -  */  0,
/* 1243 -  */  0,
/* 1244 -  */  0,
/* 1245 - _V_66_0F_38_A6 */  0x411d,
/* 1246 -  */  0,
/* 1247 -  */  0,
/* 1248 -  */  0,
/* 1249 -  */  0,
/* 124a -  */  0,
/* 124b -  */  0,
/* 124c -  */  0,
/* 124d -  */  0,
/* 124e -  */  0,
/* 124f -  */  0,
/* 1250 -  */  0,
/* 1251 - _V_66_0F_38_A7 */  0x411e,
/* 1252 -  */  0,
/* 1253 -  */  0,
/* 1254 -  */  0,
/* 1255 -  */  0,
/* 1256 -  */  0,
/* 1257 -  */  0,
/* 1258 -  */  0,
/* 1259 -  */  0,
/* 125a -  */  0,
/* 125b -  */  0,
/* 125c -  */  0,
/* 125d - _V_66_0F_38_A8 */  0x411f,
/* 125e -  */  0,
/* 125f -  */  0,
/* 1260 -  */  0,
/* 1261 -  */  0,
/* 1262 -  */  0,
/* 1263 -  */  0,
/* 1264 -  */  0,
/* 1265 -  */  0,
/* 1266 -  */  0,
/* 1267 -  */  0,
/* 1268 -  */  0,
/* 1269 - _V_66_0F_38_A9 */  0x4120,
/* 126a -  */  0,
/* 126b -  */  0,
/* 126c -  */  0,
/* 126d -  */  0,
/* 126e -  */  0,
/* 126f -  */  0,
/* 1270 -  */  0,
/* 1271 -  */  0,
/* 1272 -  */  0,
/* 1273 -  */  0,
/* 1274 -  */  0,
/* 1275 - _V_66_0F_38_AA */  0x4121,
/* 1276 -  */  0,
/* 1277 -  */  0,
/* 1278 -  */  0,
/* 1279 -  */  0,
/* 127a -  */  0,
/* 127b -  */  0,
/* 127c -  */  0,
/* 127d -  */  0,
/* 127e -  */  0,
/* 127f -  */  0,
/* 1280 -  */  0,
/* 1281 - _V_66_0F_38_AB */  0x4122,
/* 1282 -  */  0,
/* 1283 -  */  0,
/* 1284 -  */  0,
/* 1285 -  */  0,
/* 1286 -  */  0,
/* 1287 -  */  0,
/* 1288 -  */  0,
/* 1289 -  */  0,
/* 128a -  */  0,
/* 128b -  */  0,
/* 128c -  */  0,
/* 128d - _V_66_0F_38_AC */  0x4123,
/* 128e -  */  0,
/* 128f -  */  0,
/* 1290 -  */  0,
/* 1291 -  */  0,
/* 1292 -  */  0,
/* 1293 -  */  0,
/* 1294 -  */  0,
/* 1295 -  */  0,
/* 1296 -  */  0,
/* 1297 -  */  0,
/* 1298 -  */  0,
/* 1299 - _V_66_0F_38_AD */  0x4124,
/* 129a -  */  0,
/* 129b -  */  0,
/* 129c -  */  0,
/* 129d -  */  0,
/* 129e -  */  0,
/* 129f -  */  0,
/* 12a0 -  */  0,
/* 12a1 -  */  0,
/* 12a2 -  */  0,
/* 12a3 -  */  0,
/* 12a4 -  */  0,
/* 12a5 - _V_66_0F_38_AE */  0x4125,
/* 12a6 -  */  0,
/* 12a7 -  */  0,
/* 12a8 -  */  0,
/* 12a9 -  */  0,
/* 12aa -  */  0,
/* 12ab -  */  0,
/* 12ac -  */  0,
/* 12ad -  */  0,
/* 12ae -  */  0,
/* 12af -  */  0,
/* 12b0 -  */  0,
/* 12b1 - _V_66_0F_38_AF */  0x4126,
/* 12b2 -  */  0,
/* 12b3 -  */  0,
/* 12b4 -  */  0,
/* 12b5 -  */  0,
/* 12b6 -  */  0,
/* 12b7 -  */  0,
/* 12b8 -  */  0,
/* 12b9 -  */  0,
/* 12ba -  */  0,
/* 12bb -  */  0,
/* 12bc -  */  0,
/* 12bd - _V_66_0F_38_B6 */  0x4127,
/* 12be -  */  0,
/* 12bf -  */  0,
/* 12c0 -  */  0,
/* 12c1 -  */  0,
/* 12c2 -  */  0,
/* 12c3 -  */  0,
/* 12c4 -  */  0,
/* 12c5 -  */  0,
/* 12c6 -  */  0,
/* 12c7 -  */  0,
/* 12c8 -  */  0,
/* 12c9 - _V_66_0F_38_B7 */  0x4128,
/* 12ca -  */  0,
/* 12cb -  */  0,
/* 12cc -  */  0,
/* 12cd -  */  0,
/* 12ce -  */  0,
/* 12cf -  */  0,
/* 12d0 -  */  0,
/* 12d1 -  */  0,
/* 12d2 -  */  0,
/* 12d3 -  */  0,
/* 12d4 -  */  0,
/* 12d5 - _V_66_0F_38_B8 */  0x4129,
/* 12d6 -  */  0,
/* 12d7 -  */  0,
/* 12d8 -  */  0,
/* 12d9 -  */  0,
/* 12da -  */  0,
/* 12db -  */  0,
/* 12dc -  */  0,
/* 12dd -  */  0,
/* 12de -  */  0,
/* 12df -  */  0,
/* 12e0 -  */  0,
/* 12e1 - _V_66_0F_38_B9 */  0x412a,
/* 12e2 -  */  0,
/* 12e3 -  */  0,
/* 12e4 -  */  0,
/* 12e5 -  */  0,
/* 12e6 -  */  0,
/* 12e7 -  */  0,
/* 12e8 -  */  0,
/* 12e9 -  */  0,
/* 12ea -  */  0,
/* 12eb -  */  0,
/* 12ec -  */  0,
/* 12ed - _V_66_0F_38_BA */  0x412b,
/* 12ee -  */  0,
/* 12ef -  */  0,
/* 12f0 -  */  0,
/* 12f1 -  */  0,
/* 12f2 -  */  0,
/* 12f3 -  */  0,
/* 12f4 -  */  0,
/* 12f5 -  */  0,
/* 12f6 -  */  0,
/* 12f7 -  */  0,
/* 12f8 -  */  0,
/* 12f9 - _V_66_0F_38_BB */  0x412c,
/* 12fa -  */  0,
/* 12fb -  */  0,
/* 12fc -  */  0,
/* 12fd -  */  0,
/* 12fe -  */  0,
/* 12ff -  */  0,
/* 1300 -  */  0,
/* 1301 -  */  0,
/* 1302 -  */  0,
/* 1303 -  */  0,
/* 1304 -  */  0,
/* 1305 - _V_66_0F_38_BC */  0x412d,
/* 1306 -  */  0,
/* 1307 -  */  0,
/* 1308 -  */  0,
/* 1309 -  */  0,
/* 130a -  */  0,
/* 130b -  */  0,
/* 130c -  */  0,
/* 130d -  */  0,
/* 130e -  */  0,
/* 130f -  */  0,
/* 1310 -  */  0,
/* 1311 - _V_66_0F_38_BD */  0x412e,
/* 1312 -  */  0,
/* 1313 -  */  0,
/* 1314 -  */  0,
/* 1315 -  */  0,
/* 1316 -  */  0,
/* 1317 -  */  0,
/* 1318 -  */  0,
/* 1319 -  */  0,
/* 131a -  */  0,
/* 131b -  */  0,
/* 131c -  */  0,
/* 131d - _V_66_0F_38_BE */  0x412f,
/* 131e -  */  0,
/* 131f -  */  0,
/* 1320 -  */  0,
/* 1321 -  */  0,
/* 1322 -  */  0,
/* 1323 -  */  0,
/* 1324 -  */  0,
/* 1325 -  */  0,
/* 1326 -  */  0,
/* 1327 -  */  0,
/* 1328 -  */  0,
/* 1329 - _V_66_0F_38_BF */  0x4130,
/* 132a -  */  0,
/* 132b -  */  0,
/* 132c -  */  0,
/* 132d -  */  0,
/* 132e -  */  0,
/* 132f -  */  0,
/* 1330 -  */  0,
/* 1331 - _66_0F_38_DB */  0x24b7,
/* 1332 -  */  0,
/* 1333 -  */  0,
/* 1334 -  */  0,
/* 1335 - _V_66_0F_38_DB */  0x4131,
/* 1336 -  */  0,
/* 1337 -  */  0,
/* 1338 -  */  0,
/* 1339 -  */  0,
/* 133a -  */  0,
/* 133b -  */  0,
/* 133c -  */  0,
/* 133d - _66_0F_38_DC */  0x24b8,
/* 133e -  */  0,
/* 133f -  */  0,
/* 1340 -  */  0,
/* 1341 - _V_66_0F_38_DC */  0x4132,
/* 1342 -  */  0,
/* 1343 -  */  0,
/* 1344 -  */  0,
/* 1345 -  */  0,
/* 1346 -  */  0,
/* 1347 -  */  0,
/* 1348 -  */  0,
/* 1349 - _66_0F_38_DD */  0x24b9,
/* 134a -  */  0,
/* 134b -  */  0,
/* 134c -  */  0,
/* 134d - _V_66_0F_38_DD */  0x4133,
/* 134e -  */  0,
/* 134f -  */  0,
/* 1350 -  */  0,
/* 1351 -  */  0,
/* 1352 -  */  0,
/* 1353 -  */  0,
/* 1354 -  */  0,
/* 1355 - _66_0F_38_DE */  0x24ba,
/* 1356 -  */  0,
/* 1357 -  */  0,
/* 1358 -  */  0,
/* 1359 - _V_66_0F_38_DE */  0x4134,
/* 135a -  */  0,
/* 135b -  */  0,
/* 135c -  */  0,
/* 135d -  */  0,
/* 135e -  */  0,
/* 135f -  */  0,
/* 1360 -  */  0,
/* 1361 - _66_0F_38_DF */  0x24bb,
/* 1362 -  */  0,
/* 1363 -  */  0,
/* 1364 -  */  0,
/* 1365 - _V_66_0F_38_DF */  0x4135,
/* 1366 -  */  0,
/* 1367 -  */  0,
/* 1368 -  */  0,
/* 1369 -  */  0,
/* 136a -  */  0,
/* 136b -  */  0,
/* 136c - _0F_38_F0 */  0x24bc,
/* 136d -  */  0,
/* 136e -  */  0,
/* 136f - _F2_0F_38_F0 */  0x24bd,
/* 1370 -  */  0,
/* 1371 -  */  0,
/* 1372 -  */  0,
/* 1373 -  */  0,
/* 1374 -  */  0,
/* 1375 -  */  0,
/* 1376 -  */  0,
/* 1377 -  */  0,
/* 1378 - _0F_38_F1 */  0x24be,
/* 1379 -  */  0,
/* 137a -  */  0,
/* 137b - _F2_0F_38_F1 */  0x24bf,
/* 137c -  */  0,
/* 137d -  */  0,
/* 137e -  */  0,
/* 137f -  */  0,
/* 1380 -  */  0,
/* 1381 -  */  0,
/* 1382 -  */  0,
/* 1383 -  */  0,
/* 1384 -  */  0,
/* 1385 -  */  0,
/* 1386 -  */  0,
/* 1387 -  */  0,
/* 1388 -  */  0,
/* 1389 - _V_66_0F_3A_04 */  0x4136,
/* 138a -  */  0,
/* 138b -  */  0,
/* 138c -  */  0,
/* 138d -  */  0,
/* 138e -  */  0,
/* 138f -  */  0,
/* 1390 -  */  0,
/* 1391 -  */  0,
/* 1392 -  */  0,
/* 1393 -  */  0,
/* 1394 -  */  0,
/* 1395 - _V_66_0F_3A_05 */  0x4137,
/* 1396 -  */  0,
/* 1397 -  */  0,
/* 1398 -  */  0,
/* 1399 -  */  0,
/* 139a -  */  0,
/* 139b -  */  0,
/* 139c -  */  0,
/* 139d -  */  0,
/* 139e -  */  0,
/* 139f -  */  0,
/* 13a0 -  */  0,
/* 13a1 - _V_66_0F_3A_06 */  0x4138,
/* 13a2 -  */  0,
/* 13a3 -  */  0,
/* 13a4 -  */  0,
/* 13a5 -  */  0,
/* 13a6 -  */  0,
/* 13a7 -  */  0,
/* 13a8 -  */  0,
/* 13a9 - _66_0F_3A_08 */  0x4139,
/* 13aa -  */  0,
/* 13ab -  */  0,
/* 13ac -  */  0,
/* 13ad - _V_66_0F_3A_08 */  0x413a,
/* 13ae -  */  0,
/* 13af -  */  0,
/* 13b0 -  */  0,
/* 13b1 -  */  0,
/* 13b2 -  */  0,
/* 13b3 -  */  0,
/* 13b4 -  */  0,
/* 13b5 - _66_0F_3A_09 */  0x413b,
/* 13b6 -  */  0,
/* 13b7 -  */  0,
/* 13b8 -  */  0,
/* 13b9 - _V_66_0F_3A_09 */  0x413c,
/* 13ba -  */  0,
/* 13bb -  */  0,
/* 13bc -  */  0,
/* 13bd -  */  0,
/* 13be -  */  0,
/* 13bf -  */  0,
/* 13c0 -  */  0,
/* 13c1 - _66_0F_3A_0A */  0x413d,
/* 13c2 -  */  0,
/* 13c3 -  */  0,
/* 13c4 -  */  0,
/* 13c5 - _V_66_0F_3A_0A */  0x413e,
/* 13c6 -  */  0,
/* 13c7 -  */  0,
/* 13c8 -  */  0,
/* 13c9 -  */  0,
/* 13ca -  */  0,
/* 13cb -  */  0,
/* 13cc -  */  0,
/* 13cd - _66_0F_3A_0B */  0x413f,
/* 13ce -  */  0,
/* 13cf -  */  0,
/* 13d0 -  */  0,
/* 13d1 - _V_66_0F_3A_0B */  0x4140,
/* 13d2 -  */  0,
/* 13d3 -  */  0,
/* 13d4 -  */  0,
/* 13d5 -  */  0,
/* 13d6 -  */  0,
/* 13d7 -  */  0,
/* 13d8 -  */  0,
/* 13d9 - _66_0F_3A_0C */  0x4141,
/* 13da -  */  0,
/* 13db -  */  0,
/* 13dc -  */  0,
/* 13dd - _V_66_0F_3A_0C */  0x4142,
/* 13de -  */  0,
/* 13df -  */  0,
/* 13e0 -  */  0,
/* 13e1 -  */  0,
/* 13e2 -  */  0,
/* 13e3 -  */  0,
/* 13e4 -  */  0,
/* 13e5 - _66_0F_3A_0D */  0x4143,
/* 13e6 -  */  0,
/* 13e7 -  */  0,
/* 13e8 -  */  0,
/* 13e9 - _V_66_0F_3A_0D */  0x4144,
/* 13ea -  */  0,
/* 13eb -  */  0,
/* 13ec -  */  0,
/* 13ed -  */  0,
/* 13ee -  */  0,
/* 13ef -  */  0,
/* 13f0 -  */  0,
/* 13f1 - _66_0F_3A_0E */  0x4145,
/* 13f2 -  */  0,
/* 13f3 -  */  0,
/* 13f4 -  */  0,
/* 13f5 - _V_66_0F_3A_0E */  0x4146,
/* 13f6 -  */  0,
/* 13f7 -  */  0,
/* 13f8 -  */  0,
/* 13f9 -  */  0,
/* 13fa -  */  0,
/* 13fb -  */  0,
/* 13fc - _0F_3A_0F */  0x4147,
/* 13fd - _66_0F_3A_0F */  0x4148,
/* 13fe -  */  0,
/* 13ff -  */  0,
/* 1400 -  */  0,
/* 1401 - _V_66_0F_3A_0F */  0x4149,
/* 1402 -  */  0,
/* 1403 -  */  0,
/* 1404 -  */  0,
/* 1405 -  */  0,
/* 1406 -  */  0,
/* 1407 -  */  0,
/* 1408 -  */  0,
/* 1409 - _66_0F_3A_14 */  0x414a,
/* 140a -  */  0,
/* 140b -  */  0,
/* 140c -  */  0,
/* 140d - _V_66_0F_3A_14 */  0x414b,
/* 140e -  */  0,
/* 140f -  */  0,
/* 1410 -  */  0,
/* 1411 -  */  0,
/* 1412 -  */  0,
/* 1413 -  */  0,
/* 1414 -  */  0,
/* 1415 - _66_0F_3A_15 */  0x414c,
/* 1416 -  */  0,
/* 1417 -  */  0,
/* 1418 -  */  0,
/* 1419 - _V_66_0F_3A_15 */  0x414d,
/* 141a -  */  0,
/* 141b -  */  0,
/* 141c -  */  0,
/* 141d -  */  0,
/* 141e -  */  0,
/* 141f -  */  0,
/* 1420 -  */  0,
/* 1421 - _66_0F_3A_16 */  0x414e,
/* 1422 -  */  0,
/* 1423 -  */  0,
/* 1424 -  */  0,
/* 1425 - _V_66_0F_3A_16 */  0x414f,
/* 1426 -  */  0,
/* 1427 -  */  0,
/* 1428 -  */  0,
/* 1429 -  */  0,
/* 142a -  */  0,
/* 142b -  */  0,
/* 142c -  */  0,
/* 142d - _66_0F_3A_17 */  0x4150,
/* 142e -  */  0,
/* 142f -  */  0,
/* 1430 -  */  0,
/* 1431 - _V_66_0F_3A_17 */  0x4151,
/* 1432 -  */  0,
/* 1433 -  */  0,
/* 1434 -  */  0,
/* 1435 -  */  0,
/* 1436 -  */  0,
/* 1437 -  */  0,
/* 1438 -  */  0,
/* 1439 -  */  0,
/* 143a -  */  0,
/* 143b -  */  0,
/* 143c -  */  0,
/* 143d - _V_66_0F_3A_18 */  0x4152,
/* 143e -  */  0,
/* 143f -  */  0,
/* 1440 -  */  0,
/* 1441 -  */  0,
/* 1442 -  */  0,
/* 1443 -  */  0,
/* 1444 -  */  0,
/* 1445 -  */  0,
/* 1446 -  */  0,
/* 1447 -  */  0,
/* 1448 -  */  0,
/* 1449 - _V_66_0F_3A_19 */  0x4153,
/* 144a -  */  0,
/* 144b -  */  0,
/* 144c -  */  0,
/* 144d -  */  0,
/* 144e -  */  0,
/* 144f -  */  0,
/* 1450 -  */  0,
/* 1451 - _66_0F_3A_20 */  0x4154,
/* 1452 -  */  0,
/* 1453 -  */  0,
/* 1454 -  */  0,
/* 1455 - _V_66_0F_3A_20 */  0x4155,
/* 1456 -  */  0,
/* 1457 -  */  0,
/* 1458 -  */  0,
/* 1459 -  */  0,
/* 145a -  */  0,
/* 145b -  */  0,
/* 145c -  */  0,
/* 145d - _66_0F_3A_21 */  0x4156,
/* 145e -  */  0,
/* 145f -  */  0,
/* 1460 -  */  0,
/* 1461 - _V_66_0F_3A_21 */  0x4157,
/* 1462 -  */  0,
/* 1463 -  */  0,
/* 1464 -  */  0,
/* 1465 -  */  0,
/* 1466 -  */  0,
/* 1467 -  */  0,
/* 1468 -  */  0,
/* 1469 - _66_0F_3A_22 */  0x4158,
/* 146a -  */  0,
/* 146b -  */  0,
/* 146c -  */  0,
/* 146d - _V_66_0F_3A_22 */  0x4159,
/* 146e -  */  0,
/* 146f -  */  0,
/* 1470 -  */  0,
/* 1471 -  */  0,
/* 1472 -  */  0,
/* 1473 -  */  0,
/* 1474 -  */  0,
/* 1475 - _66_0F_3A_40 */  0x415a,
/* 1476 -  */  0,
/* 1477 -  */  0,
/* 1478 -  */  0,
/* 1479 - _V_66_0F_3A_40 */  0x415b,
/* 147a -  */  0,
/* 147b -  */  0,
/* 147c -  */  0,
/* 147d -  */  0,
/* 147e -  */  0,
/* 147f -  */  0,
/* 1480 -  */  0,
/* 1481 - _66_0F_3A_41 */  0x415c,
/* 1482 -  */  0,
/* 1483 -  */  0,
/* 1484 -  */  0,
/* 1485 - _V_66_0F_3A_41 */  0x415d,
/* 1486 -  */  0,
/* 1487 -  */  0,
/* 1488 -  */  0,
/* 1489 -  */  0,
/* 148a -  */  0,
/* 148b -  */  0,
/* 148c -  */  0,
/* 148d - _66_0F_3A_42 */  0x415e,
/* 148e -  */  0,
/* 148f -  */  0,
/* 1490 -  */  0,
/* 1491 - _V_66_0F_3A_42 */  0x415f,
/* 1492 -  */  0,
/* 1493 -  */  0,
/* 1494 -  */  0,
/* 1495 -  */  0,
/* 1496 -  */  0,
/* 1497 -  */  0,
/* 1498 -  */  0,
/* 1499 - _66_0F_3A_44 */  0x4160,
/* 149a -  */  0,
/* 149b -  */  0,
/* 149c -  */  0,
/* 149d - _V_66_0F_3A_44 */  0x4161,
/* 149e -  */  0,
/* 149f -  */  0,
/* 14a0 -  */  0,
/* 14a1 -  */  0,
/* 14a2 -  */  0,
/* 14a3 -  */  0,
/* 14a4 -  */  0,
/* 14a5 -  */  0,
/* 14a6 -  */  0,
/* 14a7 -  */  0,
/* 14a8 -  */  0,
/* 14a9 - _V_66_0F_3A_4A */  0x4162,
/* 14aa -  */  0,
/* 14ab -  */  0,
/* 14ac -  */  0,
/* 14ad -  */  0,
/* 14ae -  */  0,
/* 14af -  */  0,
/* 14b0 -  */  0,
/* 14b1 -  */  0,
/* 14b2 -  */  0,
/* 14b3 -  */  0,
/* 14b4 -  */  0,
/* 14b5 - _V_66_0F_3A_4B */  0x4163,
/* 14b6 -  */  0,
/* 14b7 -  */  0,
/* 14b8 -  */  0,
/* 14b9 -  */  0,
/* 14ba -  */  0,
/* 14bb -  */  0,
/* 14bc -  */  0,
/* 14bd -  */  0,
/* 14be -  */  0,
/* 14bf -  */  0,
/* 14c0 -  */  0,
/* 14c1 - _V_66_0F_3A_4C */  0x4164,
/* 14c2 -  */  0,
/* 14c3 -  */  0,
/* 14c4 -  */  0,
/* 14c5 -  */  0,
/* 14c6 -  */  0,
/* 14c7 -  */  0,
/* 14c8 -  */  0,
/* 14c9 - _66_0F_3A_60 */  0x4165,
/* 14ca -  */  0,
/* 14cb -  */  0,
/* 14cc -  */  0,
/* 14cd - _V_66_0F_3A_60 */  0x4166,
/* 14ce -  */  0,
/* 14cf -  */  0,
/* 14d0 -  */  0,
/* 14d1 -  */  0,
/* 14d2 -  */  0,
/* 14d3 -  */  0,
/* 14d4 -  */  0,
/* 14d5 - _66_0F_3A_61 */  0x4167,
/* 14d6 -  */  0,
/* 14d7 -  */  0,
/* 14d8 -  */  0,
/* 14d9 - _V_66_0F_3A_61 */  0x4168,
/* 14da -  */  0,
/* 14db -  */  0,
/* 14dc -  */  0,
/* 14dd -  */  0,
/* 14de -  */  0,
/* 14df -  */  0,
/* 14e0 -  */  0,
/* 14e1 - _66_0F_3A_62 */  0x4169,
/* 14e2 -  */  0,
/* 14e3 -  */  0,
/* 14e4 -  */  0,
/* 14e5 - _V_66_0F_3A_62 */  0x416a,
/* 14e6 -  */  0,
/* 14e7 -  */  0,
/* 14e8 -  */  0,
/* 14e9 -  */  0,
/* 14ea -  */  0,
/* 14eb -  */  0,
/* 14ec -  */  0,
/* 14ed - _66_0F_3A_63 */  0x416b,
/* 14ee -  */  0,
/* 14ef -  */  0,
/* 14f0 -  */  0,
/* 14f1 - _V_66_0F_3A_63 */  0x416c,
/* 14f2 -  */  0,
/* 14f3 -  */  0,
/* 14f4 -  */  0,
/* 14f5 -  */  0,
/* 14f6 -  */  0,
/* 14f7 -  */  0,
/* 14f8 -  */  0,
/* 14f9 - _66_0F_3A_DF */  0x416d,
/* 14fa -  */  0,
/* 14fb -  */  0,
/* 14fc -  */  0,
/* 14fd - _V_66_0F_3A_DF */  0x416e,
/* 14fe -  */  0,
/* 14ff -  */  0,
/* 1500 -  */  0,
/* 1501 -  */  0,
/* 1502 -  */  0,
/* 1503 -  */  0,
/* 1504 - _0F_71_02 */  0x24c0,
/* 1505 - _66_0F_71_02 */  0x24c1,
/* 1506 -  */  0,
/* 1507 -  */  0,
/* 1508 -  */  0,
/* 1509 - _V_66_0F_71_02 */  0x416f,
/* 150a -  */  0,
/* 150b -  */  0,
/* 150c -  */  0,
/* 150d -  */  0,
/* 150e -  */  0,
/* 150f -  */  0,
/* 1510 - _0F_71_04 */  0x24c2,
/* 1511 - _66_0F_71_04 */  0x24c3,
/* 1512 -  */  0,
/* 1513 -  */  0,
/* 1514 -  */  0,
/* 1515 - _V_66_0F_71_04 */  0x4170,
/* 1516 -  */  0,
/* 1517 -  */  0,
/* 1518 -  */  0,
/* 1519 -  */  0,
/* 151a -  */  0,
/* 151b -  */  0,
/* 151c - _0F_71_06 */  0x24c4,
/* 151d - _66_0F_71_06 */  0x24c5,
/* 151e -  */  0,
/* 151f -  */  0,
/* 1520 -  */  0,
/* 1521 - _V_66_0F_71_06 */  0x4171,
/* 1522 -  */  0,
/* 1523 -  */  0,
/* 1524 -  */  0,
/* 1525 -  */  0,
/* 1526 -  */  0,
/* 1527 -  */  0,
/* 1528 - _0F_72_02 */  0x24c6,
/* 1529 - _66_0F_72_02 */  0x24c7,
/* 152a -  */  0,
/* 152b -  */  0,
/* 152c -  */  0,
/* 152d - _V_66_0F_72_02 */  0x4172,
/* 152e -  */  0,
/* 152f -  */  0,
/* 1530 -  */  0,
/* 1531 -  */  0,
/* 1532 -  */  0,
/* 1533 -  */  0,
/* 1534 - _0F_72_04 */  0x24c8,
/* 1535 - _66_0F_72_04 */  0x24c9,
/* 1536 -  */  0,
/* 1537 -  */  0,
/* 1538 -  */  0,
/* 1539 - _V_66_0F_72_04 */  0x4173,
/* 153a -  */  0,
/* 153b -  */  0,
/* 153c -  */  0,
/* 153d -  */  0,
/* 153e -  */  0,
/* 153f -  */  0,
/* 1540 - _0F_72_06 */  0x24ca,
/* 1541 - _66_0F_72_06 */  0x24cb,
/* 1542 -  */  0,
/* 1543 -  */  0,
/* 1544 -  */  0,
/* 1545 - _V_66_0F_72_06 */  0x4174,
/* 1546 -  */  0,
/* 1547 -  */  0,
/* 1548 -  */  0,
/* 1549 -  */  0,
/* 154a -  */  0,
/* 154b -  */  0,
/* 154c - _0F_73_02 */  0x24cc,
/* 154d - _66_0F_73_02 */  0x24cd,
/* 154e -  */  0,
/* 154f -  */  0,
/* 1550 -  */  0,
/* 1551 - _V_66_0F_73_02 */  0x4175,
/* 1552 -  */  0,
/* 1553 -  */  0,
/* 1554 -  */  0,
/* 1555 -  */  0,
/* 1556 -  */  0,
/* 1557 -  */  0,
/* 1558 -  */  0,
/* 1559 - _66_0F_73_03 */  0x24ce,
/* 155a -  */  0,
/* 155b -  */  0,
/* 155c -  */  0,
/* 155d - _V_66_0F_73_03 */  0x4176,
/* 155e -  */  0,
/* 155f -  */  0,
/* 1560 -  */  0,
/* 1561 -  */  0,
/* 1562 -  */  0,
/* 1563 -  */  0,
/* 1564 - _0F_73_06 */  0x24cf,
/* 1565 - _66_0F_73_06 */  0x24d0,
/* 1566 -  */  0,
/* 1567 -  */  0,
/* 1568 -  */  0,
/* 1569 - _V_66_0F_73_06 */  0x4177,
/* 156a -  */  0,
/* 156b -  */  0,
/* 156c -  */  0,
/* 156d -  */  0,
/* 156e -  */  0,
/* 156f -  */  0,
/* 1570 -  */  0,
/* 1571 - _66_0F_73_07 */  0x24d1,
/* 1572 -  */  0,
/* 1573 -  */  0,
/* 1574 -  */  0,
/* 1575 - _V_66_0F_73_07 */  0x4178,
/* 1576 -  */  0,
/* 1577 -  */  0,
/* 1578 -  */  0,
/* 1579 -  */  0,
/* 157a -  */  0,
/* 157b -  */  0,
/* 157c - _0F_AE_00 */  0x4179,
/* 157d -  */  0,
/* 157e - _F3_0F_AE_00 */  0x24d2,
/* 157f -  */  0,
/* 1580 -  */  0,
/* 1581 -  */  0,
/* 1582 -  */  0,
/* 1583 -  */  0,
/* 1584 -  */  0,
/* 1585 -  */  0,
/* 1586 -  */  0,
/* 1587 -  */  0,
/* 1588 - _0F_AE_01 */  0x417a,
/* 1589 -  */  0,
/* 158a - _F3_0F_AE_01 */  0x24d3,
/* 158b -  */  0,
/* 158c -  */  0,
/* 158d -  */  0,
/* 158e -  */  0,
/* 158f -  */  0,
/* 1590 -  */  0,
/* 1591 -  */  0,
/* 1592 -  */  0,
/* 1593 -  */  0,
/* 1594 - _0F_AE_02 */  0x24d4,
/* 1595 -  */  0,
/* 1596 - _F3_0F_AE_02 */  0x24d5,
/* 1597 -  */  0,
/* 1598 - _V_0F_AE_02 */  0x417b,
/* 1599 -  */  0,
/* 159a -  */  0,
/* 159b -  */  0,
/* 159c -  */  0,
/* 159d -  */  0,
/* 159e -  */  0,
/* 159f -  */  0,
/* 15a0 - _0F_AE_03 */  0x24d6,
/* 15a1 -  */  0,
/* 15a2 - _F3_0F_AE_03 */  0x24d7,
/* 15a3 -  */  0,
/* 15a4 - _V_0F_AE_03 */  0x417c,
/* 15a5 -  */  0,
/* 15a6 -  */  0,
/* 15a7 -  */  0,
/* 15a8 -  */  0,
/* 15a9 -  */  0,
/* 15aa -  */  0,
/* 15ab -  */  0,
/* 15ac - _0F_C7_06 */  0x417d,
/* 15ad - _66_0F_C7_06 */  0x24d8,
/* 15ae - _F3_0F_C7_06 */  0x24d9,
/* 15af -  */  0,
/* 15b0 -  */  0,
/* 15b1 -  */  0,
/* 15b2 -  */  0,
/* 15b3 -  */  0,
/* 15b4 -  */  0,
/* 15b5 -  */  0,
/* 15b6 -  */  0,
/* 15b7 -  */  0
};

_InstSharedInfo InstSharedInfoTable[465] = {
{0, 9, 15, 8, 63, 0, 0},
{0, 11, 17, 8, 63, 0, 0},
{0, 15, 9, 8, 63, 0, 0},
{0, 17, 11, 8, 63, 0, 0},
{1, 1, 33, 8, 63, 0, 0},
{1, 3, 35, 8, 63, 0, 0},
{2, 0, 32, 8, 0, 0, 0},
{3, 0, 32, 8, 0, 0, 0},
{0, 9, 15, 8, 19, 32, 0},
{0, 11, 17, 8, 19, 32, 0},
{0, 15, 9, 8, 19, 32, 0},
{0, 17, 11, 8, 19, 32, 0},
{1, 1, 33, 8, 19, 32, 0},
{1, 3, 35, 8, 19, 32, 0},
{4, 0, 32, 8, 0, 0, 0},
{0, 9, 15, 8, 63, 4, 0},
{0, 11, 17, 8, 63, 4, 0},
{0, 15, 9, 8, 63, 4, 0},
{0, 17, 11, 8, 63, 4, 0},
{1, 1, 33, 8, 63, 4, 0},
{1, 3, 35, 8, 63, 4, 0},
{5, 0, 32, 8, 0, 0, 0},
{6, 0, 32, 8, 0, 0, 0},
{7, 0, 32, 8, 0, 0, 0},
{8, 0, 32, 8, 0, 0, 0},
{0, 9, 15, 8, 31, 0, 32},
{0, 11, 17, 8, 31, 0, 32},
{0, 15, 9, 8, 31, 0, 32},
{0, 17, 11, 8, 31, 0, 32},
{1, 1, 33, 8, 31, 0, 32},
{1, 3, 35, 8, 31, 0, 32},
{9, 0, 0, 8, 55, 36, 8},
{0, 9, 15, 8, 19, 0, 32},
{0, 11, 17, 8, 19, 0, 32},
{0, 15, 9, 8, 19, 0, 32},
{0, 17, 11, 8, 19, 0, 32},
{1, 1, 33, 8, 19, 0, 32},
{1, 3, 35, 8, 19, 0, 32},
{9, 0, 0, 8, 36, 32, 27},
{10, 9, 15, 8, 63, 0, 0},
{10, 11, 17, 8, 63, 0, 0},
{10, 15, 9, 8, 63, 0, 0},
{10, 17, 11, 8, 63, 0, 0},
{11, 1, 33, 8, 63, 0, 0},
{11, 3, 35, 8, 63, 0, 0},
{12, 0, 54, 8, 59, 0, 0},
{13, 0, 54, 8, 0, 0, 0},
{14, 0, 54, 8, 0, 0, 0},
{15, 0, 0, 8, 0, 0, 0},
{16, 42, 11, 8, 0, 0, 0},
{10, 10, 16, 8, 1, 0, 0},
{13, 0, 3, 8, 0, 0, 0},
{17, 17, 11, 8, 12, 0, 51},
{18, 0, 5, 8, 0, 0, 0},
{19, 59, 56, 8, 0, 64, 0},
{20, 59, 56, 8, 0, 64, 0},
{19, 55, 59, 8, 0, 64, 0},
{20, 55, 59, 8, 0, 64, 0},
{13, 0, 40, 13, 0, 8, 0},
{13, 0, 40, 13, 0, 4, 0},
{13, 0, 40, 13, 0, 1, 0},
{13, 0, 40, 13, 0, 5, 0},
{13, 0, 40, 13, 0, 2, 0},
{13, 0, 40, 13, 0, 16, 0},
{13, 0, 40, 13, 0, 10, 0},
{13, 0, 40, 13, 0, 11, 0},
{10, 9, 15, 8, 19, 0, 32},
{10, 11, 17, 8, 19, 0, 32},
{0, 9, 15, 8, 0, 0, 0},
{0, 11, 17, 8, 0, 0, 0},
{21, 9, 15, 8, 0, 0, 0},
{21, 11, 17, 8, 0, 0, 0},
{21, 15, 9, 8, 0, 0, 0},
{21, 17, 11, 8, 0, 0, 0},
{21, 31, 28, 8, 0, 0, 0},
{21, 42, 11, 8, 0, 0, 0},
{21, 28, 31, 8, 0, 0, 0},
{1, 35, 54, 8, 0, 0, 0},
{22, 0, 0, 8, 0, 0, 0},
{9, 0, 38, 9, 0, 0, 0},
{23, 0, 0, 8, 0, 0, 0},
{23, 0, 0, 8, 255, 0, 0},
{11, 0, 0, 8, 55, 0, 0},
{11, 0, 0, 8, 0, 0, 0},
{1, 49, 33, 8, 0, 0, 0},
{1, 50, 35, 8, 0, 0, 0},
{1, 33, 49, 8, 0, 0, 0},
{1, 35, 50, 8, 0, 0, 0},
{24, 55, 56, 8, 0, 64, 0},
{25, 55, 56, 8, 0, 64, 0},
{19, 56, 55, 8, 63, 64, 0},
{26, 56, 55, 8, 63, 64, 0},
{11, 1, 33, 8, 19, 0, 32},
{11, 3, 35, 8, 19, 0, 32},
{19, 33, 56, 8, 0, 64, 0},
{26, 35, 56, 8, 0, 64, 0},
{19, 55, 33, 8, 0, 64, 0},
{26, 55, 35, 8, 0, 64, 0},
{19, 33, 56, 8, 63, 64, 0},
{26, 35, 56, 8, 63, 64, 0},
{1, 1, 53, 8, 0, 0, 0},
{27, 3, 54, 8, 0, 0, 0},
{13, 0, 2, 10, 0, 0, 0},
{13, 0, 0, 10, 0, 0, 0},
{16, 37, 11, 8, 0, 0, 0},
{13, 8, 6, 8, 0, 0, 0},
{13, 0, 0, 8, 0, 0, 0},
{28, 0, 2, 10, 0, 0, 0},
{28, 0, 0, 10, 0, 0, 0},
{11, 0, 0, 14, 0, 0, 0},
{11, 0, 1, 14, 0, 0, 0},
{9, 0, 0, 14, 0, 0, 0},
{28, 0, 0, 10, 255, 0, 0},
{9, 0, 1, 8, 19, 0, 44},
{9, 0, 0, 8, 0, 0, 0},
{29, 0, 57, 8, 0, 0, 0},
{30, 0, 40, 13, 0, 1, 0},
{30, 0, 40, 13, 0, 0, 0},
{31, 0, 40, 13, 0, 0, 0},
{1, 1, 33, 8, 0, 0, 0},
{1, 1, 36, 8, 0, 0, 0},
{11, 33, 1, 8, 0, 0, 0},
{11, 36, 1, 8, 0, 0, 0},
{13, 0, 41, 9, 0, 0, 0},
{13, 0, 41, 12, 0, 0, 0},
{9, 0, 38, 12, 0, 0, 0},
{13, 0, 40, 12, 0, 0, 0},
{1, 59, 33, 8, 0, 0, 0},
{1, 59, 36, 8, 0, 0, 0},
{11, 33, 59, 8, 0, 0, 0},
{11, 36, 59, 8, 0, 0, 0},
{11, 0, 0, 8, 4, 0, 0},
{11, 0, 0, 8, 128, 0, 0},
{11, 0, 0, 8, 64, 0, 0},
{10, 16, 11, 8, 1, 0, 0},
{32, 0, 0, 27, 0, 0, 0},
{32, 0, 0, 8, 0, 0, 0},
{32, 0, 0, 14, 0, 0, 0},
{11, 0, 0, 96, 0, 0, 0},
{10, 0, 17, 8, 0, 0, 0},
{33, 29, 14, 8, 0, 0, 0},
{33, 30, 14, 8, 0, 0, 0},
{33, 14, 29, 8, 0, 0, 0},
{33, 14, 30, 8, 0, 0, 0},
{34, 0, 0, 8, 0, 0, 0},
{35, 17, 11, 31, 0, 8, 0},
{35, 17, 11, 31, 0, 4, 0},
{35, 17, 11, 31, 0, 1, 0},
{35, 17, 11, 31, 0, 5, 0},
{35, 17, 11, 31, 0, 2, 0},
{35, 17, 11, 31, 0, 16, 0},
{35, 17, 11, 31, 0, 10, 0},
{35, 17, 11, 31, 0, 11, 0},
{32, 0, 41, 13, 0, 8, 0},
{32, 0, 41, 13, 0, 4, 0},
{32, 0, 41, 13, 0, 1, 0},
{32, 0, 41, 13, 0, 5, 0},
{32, 0, 41, 13, 0, 2, 0},
{32, 0, 41, 13, 0, 16, 0},
{32, 0, 41, 13, 0, 10, 0},
{32, 0, 41, 13, 0, 11, 0},
{35, 0, 15, 8, 0, 8, 0},
{35, 0, 15, 8, 0, 4, 0},
{35, 0, 15, 8, 0, 1, 0},
{35, 0, 15, 8, 0, 5, 0},
{35, 0, 15, 8, 0, 2, 0},
{35, 0, 15, 8, 0, 16, 0},
{35, 0, 15, 8, 0, 10, 0},
{35, 0, 15, 8, 0, 11, 0},
{36, 0, 32, 8, 0, 0, 0},
{37, 0, 32, 8, 0, 0, 0},
{35, 11, 17, 8, 4, 0, 59},
{38, 11, 17, 8, 23, 0, 40},
{39, 0, 32, 8, 0, 0, 0},
{40, 0, 32, 8, 0, 0, 0},
{32, 0, 0, 8, 255, 0, 0},
{41, 11, 17, 8, 4, 0, 59},
{35, 17, 11, 8, 12, 0, 51},
{41, 9, 15, 8, 63, 0, 0},
{41, 11, 17, 8, 63, 0, 0},
{42, 37, 11, 8, 0, 0, 0},
{35, 15, 11, 8, 0, 0, 0},
{43, 16, 11, 8, 0, 0, 0},
{43, 13, 45, 48, 0, 0, 0},
{44, 0, 54, 8, 0, 0, 0},
{45, 1, 15, 8, 63, 0, 0},
{45, 1, 15, 8, 19, 32, 0},
{45, 1, 15, 8, 63, 4, 0},
{45, 1, 15, 8, 31, 0, 32},
{45, 1, 15, 8, 19, 0, 32},
{46, 1, 15, 8, 63, 0, 0},
{45, 3, 17, 8, 63, 0, 0},
{45, 3, 17, 8, 19, 32, 0},
{45, 3, 17, 8, 63, 4, 0},
{45, 3, 17, 8, 31, 0, 32},
{45, 3, 17, 8, 19, 0, 32},
{46, 3, 17, 8, 63, 0, 0},
{47, 1, 15, 8, 63, 0, 0},
{47, 1, 15, 8, 19, 32, 0},
{47, 1, 15, 8, 63, 4, 0},
{47, 1, 15, 8, 31, 0, 32},
{47, 1, 15, 8, 19, 0, 32},
{48, 1, 15, 8, 63, 0, 0},
{45, 5, 17, 8, 63, 0, 0},
{49, 5, 17, 8, 19, 32, 0},
{45, 5, 17, 8, 63, 4, 0},
{49, 5, 17, 8, 31, 0, 32},
{49, 5, 17, 8, 19, 0, 32},
{46, 5, 17, 8, 63, 0, 0},
{50, 0, 17, 8, 0, 0, 0},
{51, 1, 15, 8, 4, 0, 8},
{51, 1, 15, 8, 4, 4, 8},
{51, 1, 15, 8, 23, 0, 40},
{51, 1, 15, 8, 0, 0, 0},
{51, 1, 17, 8, 4, 0, 8},
{51, 1, 17, 8, 4, 4, 8},
{51, 1, 17, 8, 23, 0, 40},
{51, 1, 17, 8, 0, 0, 0},
{51, 3, 17, 8, 0, 0, 0},
{51, 51, 15, 8, 12, 0, 0},
{51, 51, 15, 8, 12, 4, 0},
{51, 51, 15, 8, 31, 0, 32},
{51, 51, 15, 8, 0, 0, 0},
{51, 51, 17, 8, 12, 0, 0},
{51, 51, 17, 8, 12, 4, 0},
{51, 51, 17, 8, 31, 0, 32},
{51, 51, 17, 8, 0, 0, 0},
{51, 52, 15, 8, 4, 0, 8},
{51, 52, 15, 8, 4, 4, 8},
{51, 52, 15, 8, 23, 0, 40},
{51, 52, 15, 8, 0, 0, 0},
{51, 52, 17, 8, 4, 0, 8},
{51, 52, 17, 8, 4, 4, 8},
{51, 52, 17, 8, 23, 0, 40},
{51, 52, 17, 8, 0, 0, 0},
{46, 0, 21, 16, 0, 0, 0},
{52, 0, 62, 16, 0, 0, 0},
{52, 0, 61, 16, 0, 0, 0},
{52, 0, 0, 16, 0, 0, 0},
{46, 0, 42, 16, 0, 0, 0},
{53, 0, 62, 24, 0, 4, 0},
{53, 0, 62, 24, 0, 1, 0},
{53, 0, 62, 24, 0, 5, 0},
{53, 0, 62, 24, 0, 16, 0},
{54, 0, 21, 56, 0, 0, 0},
{46, 0, 23, 16, 0, 0, 0},
{53, 0, 62, 16, 21, 0, 0},
{53, 0, 62, 24, 21, 0, 0},
{46, 0, 22, 16, 0, 0, 0},
{52, 0, 63, 16, 0, 0, 0},
{54, 0, 22, 56, 0, 0, 0},
{46, 0, 20, 16, 0, 0, 0},
{54, 0, 20, 56, 0, 0, 0},
{46, 1, 15, 8, 19, 0, 32},
{45, 0, 15, 8, 0, 0, 0},
{45, 0, 15, 8, 63, 0, 0},
{51, 0, 15, 8, 12, 0, 51},
{51, 0, 15, 8, 0, 0, 63},
{46, 3, 17, 8, 19, 0, 32},
{45, 0, 17, 8, 0, 0, 0},
{45, 0, 17, 8, 63, 0, 0},
{51, 0, 17, 8, 12, 0, 51},
{51, 0, 17, 8, 0, 0, 63},
{45, 0, 15, 8, 59, 0, 0},
{45, 0, 17, 8, 59, 0, 0},
{55, 0, 17, 9, 0, 0, 0},
{56, 0, 37, 9, 0, 0, 0},
{55, 0, 17, 12, 0, 0, 0},
{56, 0, 37, 12, 0, 0, 0},
{55, 0, 17, 8, 0, 0, 0},
{46, 0, 17, 8, 0, 0, 0},
{46, 0, 16, 8, 0, 0, 0},
{54, 0, 16, 8, 0, 0, 0},
{46, 0, 16, 8, 1, 0, 0},
{55, 0, 39, 8, 0, 0, 0},
{57, 0, 28, 8, 0, 0, 0},
{58, 0, 16, 8, 0, 0, 0},
{54, 0, 42, 8, 0, 0, 0},
{53, 0, 0, 112, 0, 0, 0},
{53, 0, 0, 8, 0, 0, 0},
{54, 0, 58, 120, 0, 0, 0},
{53, 0, 0, 120, 0, 0, 0},
{53, 0, 58, 120, 0, 0, 0},
{53, 60, 58, 120, 0, 0, 0},
{59, 0, 0, 8, 0, 0, 0},
{54, 0, 42, 96, 0, 0, 0},
{60, 67, 64, 104, 0, 0, 0},
{60, 67, 64, 96, 0, 0, 0},
{35, 73, 68, 40, 0, 0, 0},
{35, 73, 68, 48, 0, 0, 0},
{35, 71, 68, 40, 0, 0, 0},
{35, 72, 68, 48, 0, 0, 0},
{61, 90, 83, 128, 0, 0, 0},
{62, 81, 68, 128, 0, 0, 0},
{63, 44, 68, 128, 0, 0, 0},
{63, 46, 68, 128, 0, 0, 0},
{35, 68, 73, 40, 0, 0, 0},
{35, 68, 73, 48, 0, 0, 0},
{35, 68, 71, 40, 0, 0, 0},
{35, 68, 72, 48, 0, 0, 0},
{61, 83, 90, 128, 0, 0, 0},
{63, 68, 44, 128, 0, 0, 0},
{63, 68, 46, 128, 0, 0, 0},
{64, 72, 68, 40, 0, 0, 0},
{35, 46, 68, 48, 0, 0, 0},
{35, 72, 68, 56, 0, 0, 0},
{65, 81, 68, 128, 0, 0, 0},
{66, 81, 68, 128, 0, 0, 0},
{61, 89, 83, 128, 0, 0, 0},
{35, 68, 46, 40, 0, 0, 0},
{35, 68, 46, 48, 0, 0, 0},
{61, 68, 46, 128, 0, 0, 0},
{34, 73, 68, 40, 0, 0, 0},
{34, 73, 68, 48, 0, 0, 0},
{66, 88, 83, 128, 0, 0, 0},
{35, 73, 68, 56, 0, 0, 0},
{54, 0, 42, 40, 0, 0, 0},
{34, 67, 68, 40, 0, 0, 0},
{34, 67, 68, 48, 0, 0, 0},
{42, 18, 68, 40, 0, 0, 0},
{42, 18, 68, 48, 0, 0, 0},
{35, 68, 47, 40, 0, 0, 0},
{35, 68, 47, 48, 0, 0, 0},
{35, 68, 44, 88, 0, 0, 0},
{35, 68, 46, 88, 0, 0, 0},
{61, 83, 92, 128, 0, 0, 0},
{34, 72, 64, 40, 0, 0, 0},
{34, 73, 64, 48, 0, 0, 0},
{42, 71, 13, 40, 0, 0, 0},
{42, 72, 13, 48, 0, 0, 0},
{61, 80, 78, 128, 0, 0, 0},
{34, 71, 68, 40, 21, 0, 0},
{34, 72, 68, 48, 0, 0, 0},
{61, 71, 68, 128, 0, 0, 0},
{61, 72, 68, 128, 0, 0, 0},
{67, 69, 12, 40, 0, 0, 0},
{67, 69, 12, 48, 0, 0, 0},
{68, 83, 13, 128, 0, 0, 0},
{34, 71, 68, 40, 0, 0, 0},
{34, 71, 68, 48, 0, 0, 0},
{61, 91, 83, 128, 0, 0, 0},
{61, 90, 68, 128, 0, 0, 0},
{34, 66, 64, 32, 0, 0, 0},
{34, 67, 64, 32, 0, 0, 0},
{69, 18, 64, 32, 0, 0, 0},
{69, 18, 68, 48, 0, 0, 0},
{61, 79, 68, 128, 0, 0, 0},
{35, 67, 64, 32, 0, 0, 0},
{70, 67, 64, 40, 0, 0, 0},
{70, 73, 68, 48, 0, 0, 0},
{66, 73, 68, 128, 0, 0, 0},
{32, 0, 0, 32, 0, 0, 0},
{71, 0, 0, 128, 0, 0, 0},
{72, 13, 18, 112, 0, 0, 0},
{73, 7, 69, 88, 0, 0, 0},
{74, 69, 68, 88, 0, 0, 0},
{72, 18, 13, 112, 0, 0, 0},
{34, 69, 68, 88, 0, 0, 0},
{75, 69, 68, 88, 0, 0, 0},
{32, 72, 68, 112, 0, 0, 0},
{32, 68, 72, 112, 0, 0, 0},
{34, 73, 68, 56, 0, 0, 0},
{69, 64, 18, 32, 0, 0, 0},
{69, 68, 18, 48, 0, 0, 0},
{61, 68, 79, 128, 0, 0, 0},
{35, 64, 67, 32, 0, 0, 0},
{76, 0, 42, 8, 0, 0, 0},
{77, 0, 43, 8, 0, 0, 0},
{78, 0, 43, 8, 0, 0, 0},
{79, 17, 11, 80, 1, 0, 0},
{80, 1, 17, 8, 4, 0, 59},
{49, 1, 17, 8, 4, 0, 59},
{34, 17, 11, 8, 1, 0, 63},
{81, 17, 11, 112, 0, 0, 0},
{82, 17, 11, 8, 5, 0, 58},
{83, 73, 68, 40, 0, 0, 0},
{83, 73, 68, 48, 0, 0, 0},
{83, 71, 68, 40, 0, 0, 0},
{83, 72, 68, 48, 0, 0, 0},
{84, 88, 83, 128, 0, 0, 0},
{84, 81, 68, 128, 0, 0, 0},
{70, 25, 64, 40, 0, 0, 0},
{70, 25, 68, 48, 0, 0, 0},
{85, 81, 68, 128, 0, 0, 0},
{86, 65, 12, 40, 0, 0, 0},
{70, 69, 12, 48, 0, 0, 0},
{87, 68, 13, 128, 0, 0, 0},
{70, 73, 68, 40, 0, 0, 0},
{85, 88, 83, 128, 0, 0, 0},
{88, 0, 48, 8, 1, 0, 0},
{54, 0, 46, 112, 0, 0, 0},
{67, 65, 68, 48, 0, 0, 0},
{67, 69, 64, 48, 0, 0, 0},
{61, 68, 72, 128, 0, 0, 0},
{75, 65, 12, 40, 0, 0, 0},
{75, 69, 12, 48, 0, 0, 0},
{68, 68, 13, 128, 0, 0, 0},
{34, 67, 64, 40, 0, 0, 0},
{35, 64, 46, 40, 0, 0, 0},
{34, 42, 68, 56, 0, 0, 0},
{61, 92, 83, 128, 0, 0, 0},
{34, 67, 64, 48, 0, 0, 0},
{75, 65, 64, 40, 0, 0, 0},
{75, 69, 68, 48, 0, 0, 0},
{89, 69, 68, 128, 0, 0, 0},
{90, 0, 42, 16, 0, 0, 0},
{91, 0, 0, 16, 0, 0, 0},
{52, 0, 34, 16, 0, 0, 0},
{91, 0, 34, 16, 0, 0, 0},
{34, 67, 64, 64, 0, 0, 0},
{34, 73, 68, 64, 0, 0, 0},
{70, 73, 68, 72, 0, 0, 0},
{34, 73, 68, 80, 0, 0, 0},
{61, 44, 83, 128, 0, 0, 0},
{61, 46, 85, 128, 0, 0, 0},
{61, 47, 85, 128, 0, 0, 0},
{61, 73, 68, 128, 0, 0, 0},
{34, 72, 68, 72, 0, 0, 0},
{34, 71, 68, 72, 0, 0, 0},
{34, 70, 68, 72, 0, 0, 0},
{61, 70, 68, 128, 0, 0, 0},
{34, 73, 68, 72, 0, 0, 0},
{35, 47, 68, 72, 0, 0, 0},
{61, 47, 68, 128, 0, 0, 0},
{66, 88, 92, 128, 0, 0, 0},
{72, 47, 13, 112, 0, 0, 0},
{66, 88, 83, 136, 0, 0, 0},
{66, 81, 68, 136, 0, 0, 0},
{34, 73, 68, 152, 0, 0, 0},
{61, 73, 68, 152, 0, 0, 0},
{66, 81, 68, 152, 0, 0, 0},
{35, 17, 11, 8, 0, 0, 0},
{35, 15, 13, 80, 0, 0, 0},
{35, 11, 17, 8, 0, 0, 0},
{35, 17, 13, 80, 0, 0, 0},
{66, 90, 83, 128, 0, 0, 0},
{85, 87, 85, 128, 0, 0, 0},
{70, 71, 68, 72, 0, 0, 0},
{70, 72, 68, 72, 0, 0, 0},
{70, 67, 64, 64, 0, 0, 0},
{70, 73, 68, 64, 0, 0, 0},
{70, 68, 26, 72, 0, 0, 0},
{87, 68, 76, 128, 0, 0, 0},
{70, 68, 27, 72, 0, 0, 0},
{87, 68, 77, 128, 0, 0, 0},
{92, 68, 18, 72, 0, 0, 0},
{66, 68, 79, 128, 0, 0, 0},
{70, 68, 18, 72, 0, 0, 0},
{66, 68, 75, 128, 0, 0, 0},
{66, 85, 73, 128, 0, 0, 0},
{70, 24, 68, 72, 0, 0, 0},
{92, 18, 68, 72, 0, 0, 0},
{70, 73, 68, 144, 0, 0, 0},
{85, 81, 68, 144, 0, 0, 0},
{70, 73, 68, 80, 0, 0, 0},
{70, 73, 68, 152, 0, 0, 0},
{66, 73, 68, 152, 0, 0, 0},
{93, 1, 65, 32, 0, 0, 0},
{54, 1, 69, 48, 0, 0, 0},
{94, 69, 81, 128, 0, 0, 0},
{95, 0, 13, 112, 0, 0, 0},
{63, 0, 44, 128, 0, 0, 0},
{78, 0, 43, 112, 0, 0, 0},
{96, 75, 13, 8, 0, 0, 0},
{97, 67, 64, 96, 0, 0, 0}
};

uint16_t CmpMnemonicOffsets[8] = {
0, 9, 18, 27, 39, 49, 59, 69
};
uint16_t VCmpMnemonicOffsets[32] = {
0, 10, 20, 30, 43, 54, 65, 76, 87, 100, 111, 122, 135, 149, 159, 169, 181, 194, 207, 220, 235, 249, 263, 277, 290, 303, 317, 331, 347, 361, 374, 387
};


================================================
File: src/sigmake/distorm/insts.h
================================================
/*
insts.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef INSTS_H
#define INSTS_H

#include "instructions.h"


/* Flags Table */
extern _iflags FlagsTable[];

/* Root Trie DB */
extern _InstSharedInfo InstSharedInfoTable[];
extern _InstInfo InstInfos[];
extern _InstInfoEx InstInfosEx[];
extern _InstNode InstructionsTree[];

/* 3DNow! Trie DB */
extern _InstNode Table_0F_0F;
/* AVX related: */
extern _InstNode Table_0F, Table_0F_38, Table_0F_3A;

/*
 * The inst_lookup will return on of these two instructions according to the specified decoding mode.
 * ARPL or MOVSXD on 64 bits is one byte instruction at index 0x63.
 */
extern _InstInfo II_ARPL;
extern _InstInfo II_MOVSXD;

/*
 * The NOP instruction can be prefixed by REX in 64bits, therefore we have to decide in runtime whether it's an XCHG or NOP instruction.
 * If 0x90 is prefixed by a useable REX it will become XCHG, otherwise it will become a NOP.
 * Also note that if it's prefixed by 0xf3, it becomes a Pause.
 */
extern _InstInfo II_NOP;
extern _InstInfo II_PAUSE;

/*
 * Used for letting the extract operand know the type of operands without knowing the
 * instruction itself yet, because of the way those instructions work.
 * See function instructions.c!inst_lookup_3dnow.
 */
extern _InstInfo II_3DNOW;

/* Helper tables for pesudo compare mnemonics. */
extern uint16_t CmpMnemonicOffsets[8]; /* SSE */
extern uint16_t VCmpMnemonicOffsets[32]; /* AVX */

#endif /* INSTS_H */



================================================
File: src/sigmake/distorm/mnemonics.c
================================================
/*
mnemonics.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "mnemonics.h"

#ifndef DISTORM_LIGHT


const unsigned char _MNEMONICS[] =
"\x09" "UNDEFINED\0" "\x03" "ADD\0" "\x04" "PUSH\0" "\x03" "POP\0" "\x02" "OR\0" \
"\x03" "ADC\0" "\x03" "SBB\0" "\x03" "AND\0" "\x03" "DAA\0" "\x03" "SUB\0" \
"\x03" "DAS\0" "\x03" "XOR\0" "\x03" "AAA\0" "\x03" "CMP\0" "\x03" "AAS\0" \
"\x03" "INC\0" "\x03" "DEC\0" "\x05" "PUSHA\0" "\x04" "POPA\0" "\x05" "BOUND\0" \
"\x04" "ARPL\0" "\x04" "IMUL\0" "\x03" "INS\0" "\x04" "OUTS\0" "\x02" "JO\0" \
"\x03" "JNO\0" "\x02" "JB\0" "\x03" "JAE\0" "\x02" "JZ\0" "\x03" "JNZ\0" "\x03" "JBE\0" \
"\x02" "JA\0" "\x02" "JS\0" "\x03" "JNS\0" "\x02" "JP\0" "\x03" "JNP\0" "\x02" "JL\0" \
"\x03" "JGE\0" "\x03" "JLE\0" "\x02" "JG\0" "\x04" "TEST\0" "\x04" "XCHG\0" \
"\x03" "MOV\0" "\x03" "LEA\0" "\x03" "CBW\0" "\x04" "CWDE\0" "\x04" "CDQE\0" \
"\x03" "CWD\0" "\x03" "CDQ\0" "\x03" "CQO\0" "\x08" "CALL FAR\0" "\x05" "PUSHF\0" \
"\x04" "POPF\0" "\x04" "SAHF\0" "\x04" "LAHF\0" "\x04" "MOVS\0" "\x04" "CMPS\0" \
"\x04" "STOS\0" "\x04" "LODS\0" "\x04" "SCAS\0" "\x03" "RET\0" "\x03" "LES\0" \
"\x03" "LDS\0" "\x05" "ENTER\0" "\x05" "LEAVE\0" "\x04" "RETF\0" "\x05" "INT 3\0" \
"\x03" "INT\0" "\x04" "INTO\0" "\x04" "IRET\0" "\x03" "AAM\0" "\x03" "AAD\0" \
"\x04" "SALC\0" "\x04" "XLAT\0" "\x06" "LOOPNZ\0" "\x05" "LOOPZ\0" "\x04" "LOOP\0" \
"\x04" "JCXZ\0" "\x05" "JECXZ\0" "\x05" "JRCXZ\0" "\x02" "IN\0" "\x03" "OUT\0" \
"\x04" "CALL\0" "\x03" "JMP\0" "\x07" "JMP FAR\0" "\x04" "INT1\0" "\x03" "HLT\0" \
"\x03" "CMC\0" "\x03" "CLC\0" "\x03" "STC\0" "\x03" "CLI\0" "\x03" "STI\0" \
"\x03" "CLD\0" "\x03" "STD\0" "\x03" "LAR\0" "\x03" "LSL\0" "\x07" "SYSCALL\0" \
"\x04" "CLTS\0" "\x06" "SYSRET\0" "\x04" "INVD\0" "\x06" "WBINVD\0" "\x03" "UD2\0" \
"\x05" "FEMMS\0" "\x03" "NOP\0" "\x05" "WRMSR\0" "\x05" "RDTSC\0" "\x05" "RDMSR\0" \
"\x05" "RDPMC\0" "\x08" "SYSENTER\0" "\x07" "SYSEXIT\0" "\x06" "GETSEC\0" "\x05" "CMOVO\0" \
"\x06" "CMOVNO\0" "\x05" "CMOVB\0" "\x06" "CMOVAE\0" "\x05" "CMOVZ\0" "\x06" "CMOVNZ\0" \
"\x06" "CMOVBE\0" "\x05" "CMOVA\0" "\x05" "CMOVS\0" "\x06" "CMOVNS\0" "\x05" "CMOVP\0" \
"\x06" "CMOVNP\0" "\x05" "CMOVL\0" "\x06" "CMOVGE\0" "\x06" "CMOVLE\0" "\x05" "CMOVG\0" \
"\x04" "SETO\0" "\x05" "SETNO\0" "\x04" "SETB\0" "\x05" "SETAE\0" "\x04" "SETZ\0" \
"\x05" "SETNZ\0" "\x05" "SETBE\0" "\x04" "SETA\0" "\x04" "SETS\0" "\x05" "SETNS\0" \
"\x04" "SETP\0" "\x05" "SETNP\0" "\x04" "SETL\0" "\x05" "SETGE\0" "\x05" "SETLE\0" \
"\x04" "SETG\0" "\x05" "CPUID\0" "\x02" "BT\0" "\x04" "SHLD\0" "\x03" "RSM\0" \
"\x03" "BTS\0" "\x04" "SHRD\0" "\x07" "CMPXCHG\0" "\x03" "LSS\0" "\x03" "BTR\0" \
"\x03" "LFS\0" "\x03" "LGS\0" "\x05" "MOVZX\0" "\x03" "BTC\0" "\x05" "MOVSX\0" \
"\x04" "XADD\0" "\x06" "MOVNTI\0" "\x05" "BSWAP\0" "\x03" "ROL\0" "\x03" "ROR\0" \
"\x03" "RCL\0" "\x03" "RCR\0" "\x03" "SHL\0" "\x03" "SHR\0" "\x03" "SAL\0" \
"\x03" "SAR\0" "\x04" "FADD\0" "\x04" "FMUL\0" "\x04" "FCOM\0" "\x05" "FCOMP\0" \
"\x04" "FSUB\0" "\x05" "FSUBR\0" "\x04" "FDIV\0" "\x05" "FDIVR\0" "\x03" "FLD\0" \
"\x03" "FST\0" "\x04" "FSTP\0" "\x06" "FLDENV\0" "\x05" "FLDCW\0" "\x04" "FXCH\0" \
"\x04" "FNOP\0" "\x04" "FCHS\0" "\x04" "FABS\0" "\x04" "FTST\0" "\x04" "FXAM\0" \
"\x04" "FLD1\0" "\x06" "FLDL2T\0" "\x06" "FLDL2E\0" "\x05" "FLDPI\0" "\x06" "FLDLG2\0" \
"\x06" "FLDLN2\0" "\x04" "FLDZ\0" "\x05" "F2XM1\0" "\x05" "FYL2X\0" "\x05" "FPTAN\0" \
"\x06" "FPATAN\0" "\x07" "FXTRACT\0" "\x06" "FPREM1\0" "\x07" "FDECSTP\0" "\x07" "FINCSTP\0" \
"\x05" "FPREM\0" "\x07" "FYL2XP1\0" "\x05" "FSQRT\0" "\x07" "FSINCOS\0" "\x07" "FRNDINT\0" \
"\x06" "FSCALE\0" "\x04" "FSIN\0" "\x04" "FCOS\0" "\x05" "FIADD\0" "\x05" "FIMUL\0" \
"\x05" "FICOM\0" "\x06" "FICOMP\0" "\x05" "FISUB\0" "\x06" "FISUBR\0" "\x05" "FIDIV\0" \
"\x06" "FIDIVR\0" "\x06" "FCMOVB\0" "\x06" "FCMOVE\0" "\x07" "FCMOVBE\0" "\x06" "FCMOVU\0" \
"\x07" "FUCOMPP\0" "\x04" "FILD\0" "\x06" "FISTTP\0" "\x04" "FIST\0" "\x05" "FISTP\0" \
"\x07" "FCMOVNB\0" "\x07" "FCMOVNE\0" "\x08" "FCMOVNBE\0" "\x07" "FCMOVNU\0" \
"\x04" "FENI\0" "\x06" "FEDISI\0" "\x06" "FSETPM\0" "\x06" "FUCOMI\0" "\x05" "FCOMI\0" \
"\x06" "FRSTOR\0" "\x05" "FFREE\0" "\x05" "FUCOM\0" "\x06" "FUCOMP\0" "\x05" "FADDP\0" \
"\x05" "FMULP\0" "\x06" "FCOMPP\0" "\x06" "FSUBRP\0" "\x05" "FSUBP\0" "\x06" "FDIVRP\0" \
"\x05" "FDIVP\0" "\x04" "FBLD\0" "\x05" "FBSTP\0" "\x07" "FUCOMIP\0" "\x06" "FCOMIP\0" \
"\x03" "NOT\0" "\x03" "NEG\0" "\x03" "MUL\0" "\x03" "DIV\0" "\x04" "IDIV\0" \
"\x04" "SLDT\0" "\x03" "STR\0" "\x04" "LLDT\0" "\x03" "LTR\0" "\x04" "VERR\0" \
"\x04" "VERW\0" "\x04" "SGDT\0" "\x04" "SIDT\0" "\x04" "LGDT\0" "\x04" "LIDT\0" \
"\x04" "SMSW\0" "\x04" "LMSW\0" "\x06" "INVLPG\0" "\x06" "VMCALL\0" "\x08" "VMLAUNCH\0" \
"\x08" "VMRESUME\0" "\x06" "VMXOFF\0" "\x07" "MONITOR\0" "\x05" "MWAIT\0" "\x06" "XGETBV\0" \
"\x06" "XSETBV\0" "\x06" "VMFUNC\0" "\x05" "VMRUN\0" "\x07" "VMMCALL\0" "\x06" "VMLOAD\0" \
"\x06" "VMSAVE\0" "\x04" "STGI\0" "\x04" "CLGI\0" "\x06" "SKINIT\0" "\x07" "INVLPGA\0" \
"\x06" "SWAPGS\0" "\x06" "RDTSCP\0" "\x08" "PREFETCH\0" "\x09" "PREFETCHW\0" \
"\x05" "PI2FW\0" "\x05" "PI2FD\0" "\x05" "PF2IW\0" "\x05" "PF2ID\0" "\x06" "PFNACC\0" \
"\x07" "PFPNACC\0" "\x07" "PFCMPGE\0" "\x05" "PFMIN\0" "\x05" "PFRCP\0" "\x07" "PFRSQRT\0" \
"\x05" "PFSUB\0" "\x05" "PFADD\0" "\x07" "PFCMPGT\0" "\x05" "PFMAX\0" "\x08" "PFRCPIT1\0" \
"\x08" "PFRSQIT1\0" "\x06" "PFSUBR\0" "\x05" "PFACC\0" "\x07" "PFCMPEQ\0" "\x05" "PFMUL\0" \
"\x08" "PFRCPIT2\0" "\x07" "PMULHRW\0" "\x06" "PSWAPD\0" "\x07" "PAVGUSB\0" \
"\x06" "MOVUPS\0" "\x06" "MOVUPD\0" "\x05" "MOVSS\0" "\x05" "MOVSD\0" "\x07" "VMOVUPS\0" \
"\x07" "VMOVUPD\0" "\x06" "VMOVSS\0" "\x06" "VMOVSD\0" "\x07" "MOVHLPS\0" "\x06" "MOVLPS\0" \
"\x06" "MOVLPD\0" "\x08" "MOVSLDUP\0" "\x07" "MOVDDUP\0" "\x08" "VMOVHLPS\0" \
"\x07" "VMOVLPS\0" "\x07" "VMOVLPD\0" "\x09" "VMOVSLDUP\0" "\x08" "VMOVDDUP\0" \
"\x08" "UNPCKLPS\0" "\x08" "UNPCKLPD\0" "\x09" "VUNPCKLPS\0" "\x09" "VUNPCKLPD\0" \
"\x08" "UNPCKHPS\0" "\x08" "UNPCKHPD\0" "\x09" "VUNPCKHPS\0" "\x09" "VUNPCKHPD\0" \
"\x07" "MOVLHPS\0" "\x06" "MOVHPS\0" "\x06" "MOVHPD\0" "\x08" "MOVSHDUP\0" \
"\x08" "VMOVLHPS\0" "\x07" "VMOVHPS\0" "\x07" "VMOVHPD\0" "\x09" "VMOVSHDUP\0" \
"\x0b" "PREFETCHNTA\0" "\x0a" "PREFETCHT0\0" "\x0a" "PREFETCHT1\0" "\x0a" "PREFETCHT2\0" \
"\x06" "MOVAPS\0" "\x06" "MOVAPD\0" "\x07" "VMOVAPS\0" "\x07" "VMOVAPD\0" "\x08" "CVTPI2PS\0" \
"\x08" "CVTPI2PD\0" "\x08" "CVTSI2SS\0" "\x08" "CVTSI2SD\0" "\x09" "VCVTSI2SS\0" \
"\x09" "VCVTSI2SD\0" "\x07" "MOVNTPS\0" "\x07" "MOVNTPD\0" "\x07" "MOVNTSS\0" \
"\x07" "MOVNTSD\0" "\x08" "VMOVNTPS\0" "\x08" "VMOVNTPD\0" "\x09" "CVTTPS2PI\0" \
"\x09" "CVTTPD2PI\0" "\x09" "CVTTSS2SI\0" "\x09" "CVTTSD2SI\0" "\x0a" "VCVTTSS2SI\0" \
"\x0a" "VCVTTSD2SI\0" "\x08" "CVTPS2PI\0" "\x08" "CVTPD2PI\0" "\x08" "CVTSS2SI\0" \
"\x08" "CVTSD2SI\0" "\x09" "VCVTSS2SI\0" "\x09" "VCVTSD2SI\0" "\x07" "UCOMISS\0" \
"\x07" "UCOMISD\0" "\x08" "VUCOMISS\0" "\x08" "VUCOMISD\0" "\x06" "COMISS\0" \
"\x06" "COMISD\0" "\x07" "VCOMISS\0" "\x07" "VCOMISD\0" "\x08" "MOVMSKPS\0" \
"\x08" "MOVMSKPD\0" "\x09" "VMOVMSKPS\0" "\x09" "VMOVMSKPD\0" "\x06" "SQRTPS\0" \
"\x06" "SQRTPD\0" "\x06" "SQRTSS\0" "\x06" "SQRTSD\0" "\x07" "VSQRTPS\0" "\x07" "VSQRTPD\0" \
"\x07" "VSQRTSS\0" "\x07" "VSQRTSD\0" "\x07" "RSQRTPS\0" "\x07" "RSQRTSS\0" \
"\x08" "VRSQRTPS\0" "\x08" "VRSQRTSS\0" "\x05" "RCPPS\0" "\x05" "RCPSS\0" "\x06" "VRCPPS\0" \
"\x06" "VRCPSS\0" "\x05" "ANDPS\0" "\x05" "ANDPD\0" "\x06" "VANDPS\0" "\x06" "VANDPD\0" \
"\x06" "ANDNPS\0" "\x06" "ANDNPD\0" "\x07" "VANDNPS\0" "\x07" "VANDNPD\0" "\x04" "ORPS\0" \
"\x04" "ORPD\0" "\x05" "VORPS\0" "\x05" "VORPD\0" "\x05" "XORPS\0" "\x05" "XORPD\0" \
"\x06" "VXORPS\0" "\x06" "VXORPD\0" "\x05" "ADDPS\0" "\x05" "ADDPD\0" "\x05" "ADDSS\0" \
"\x05" "ADDSD\0" "\x06" "VADDPS\0" "\x06" "VADDPD\0" "\x06" "VADDSS\0" "\x06" "VADDSD\0" \
"\x05" "MULPS\0" "\x05" "MULPD\0" "\x05" "MULSS\0" "\x05" "MULSD\0" "\x06" "VMULPS\0" \
"\x06" "VMULPD\0" "\x06" "VMULSS\0" "\x06" "VMULSD\0" "\x08" "CVTPS2PD\0" "\x08" "CVTPD2PS\0" \
"\x08" "CVTSS2SD\0" "\x08" "CVTSD2SS\0" "\x09" "VCVTPS2PD\0" "\x09" "VCVTPD2PS\0" \
"\x09" "VCVTSS2SD\0" "\x09" "VCVTSD2SS\0" "\x08" "CVTDQ2PS\0" "\x08" "CVTPS2DQ\0" \
"\x09" "CVTTPS2DQ\0" "\x09" "VCVTDQ2PS\0" "\x09" "VCVTPS2DQ\0" "\x0a" "VCVTTPS2DQ\0" \
"\x05" "SUBPS\0" "\x05" "SUBPD\0" "\x05" "SUBSS\0" "\x05" "SUBSD\0" "\x06" "VSUBPS\0" \
"\x06" "VSUBPD\0" "\x06" "VSUBSS\0" "\x06" "VSUBSD\0" "\x05" "MINPS\0" "\x05" "MINPD\0" \
"\x05" "MINSS\0" "\x05" "MINSD\0" "\x06" "VMINPS\0" "\x06" "VMINPD\0" "\x06" "VMINSS\0" \
"\x06" "VMINSD\0" "\x05" "DIVPS\0" "\x05" "DIVPD\0" "\x05" "DIVSS\0" "\x05" "DIVSD\0" \
"\x06" "VDIVPS\0" "\x06" "VDIVPD\0" "\x06" "VDIVSS\0" "\x06" "VDIVSD\0" "\x05" "MAXPS\0" \
"\x05" "MAXPD\0" "\x05" "MAXSS\0" "\x05" "MAXSD\0" "\x06" "VMAXPS\0" "\x06" "VMAXPD\0" \
"\x06" "VMAXSS\0" "\x06" "VMAXSD\0" "\x09" "PUNPCKLBW\0" "\x0a" "VPUNPCKLBW\0" \
"\x09" "PUNPCKLWD\0" "\x0a" "VPUNPCKLWD\0" "\x09" "PUNPCKLDQ\0" "\x0a" "VPUNPCKLDQ\0" \
"\x08" "PACKSSWB\0" "\x09" "VPACKSSWB\0" "\x07" "PCMPGTB\0" "\x08" "VPCMPGTB\0" \
"\x07" "PCMPGTW\0" "\x08" "VPCMPGTW\0" "\x07" "PCMPGTD\0" "\x08" "VPCMPGTD\0" \
"\x08" "PACKUSWB\0" "\x09" "VPACKUSWB\0" "\x09" "PUNPCKHBW\0" "\x0a" "VPUNPCKHBW\0" \
"\x09" "PUNPCKHWD\0" "\x0a" "VPUNPCKHWD\0" "\x09" "PUNPCKHDQ\0" "\x0a" "VPUNPCKHDQ\0" \
"\x08" "PACKSSDW\0" "\x09" "VPACKSSDW\0" "\x0a" "PUNPCKLQDQ\0" "\x0b" "VPUNPCKLQDQ\0" \
"\x0a" "PUNPCKHQDQ\0" "\x0b" "VPUNPCKHQDQ\0" "\x04" "MOVD\0" "\x04" "MOVQ\0" \
"\x05" "VMOVD\0" "\x05" "VMOVQ\0" "\x06" "MOVDQA\0" "\x06" "MOVDQU\0" "\x07" "VMOVDQA\0" \
"\x07" "VMOVDQU\0" "\x06" "PSHUFW\0" "\x06" "PSHUFD\0" "\x07" "PSHUFHW\0" "\x07" "PSHUFLW\0" \
"\x07" "VPSHUFD\0" "\x08" "VPSHUFHW\0" "\x08" "VPSHUFLW\0" "\x07" "PCMPEQB\0" \
"\x08" "VPCMPEQB\0" "\x07" "PCMPEQW\0" "\x08" "VPCMPEQW\0" "\x07" "PCMPEQD\0" \
"\x08" "VPCMPEQD\0" "\x04" "EMMS\0" "\x0a" "VZEROUPPER\0" "\x08" "VZEROALL\0" \
"\x06" "VMREAD\0" "\x05" "EXTRQ\0" "\x07" "INSERTQ\0" "\x07" "VMWRITE\0" "\x08" "CVTPH2PS\0" \
"\x08" "CVTPS2PH\0" "\x06" "HADDPD\0" "\x06" "HADDPS\0" "\x07" "VHADDPD\0" \
"\x07" "VHADDPS\0" "\x06" "HSUBPD\0" "\x06" "HSUBPS\0" "\x07" "VHSUBPD\0" "\x07" "VHSUBPS\0" \
"\x05" "XSAVE\0" "\x07" "XSAVE64\0" "\x06" "LFENCE\0" "\x06" "XRSTOR\0" "\x08" "XRSTOR64\0" \
"\x06" "MFENCE\0" "\x08" "XSAVEOPT\0" "\x0a" "XSAVEOPT64\0" "\x06" "SFENCE\0" \
"\x07" "CLFLUSH\0" "\x06" "POPCNT\0" "\x03" "BSF\0" "\x05" "TZCNT\0" "\x03" "BSR\0" \
"\x05" "LZCNT\0" "\x07" "CMPEQPS\0" "\x07" "CMPLTPS\0" "\x07" "CMPLEPS\0" "\x0a" "CMPUNORDPS\0" \
"\x08" "CMPNEQPS\0" "\x08" "CMPNLTPS\0" "\x08" "CMPNLEPS\0" "\x08" "CMPORDPS\0" \
"\x07" "CMPEQPD\0" "\x07" "CMPLTPD\0" "\x07" "CMPLEPD\0" "\x0a" "CMPUNORDPD\0" \
"\x08" "CMPNEQPD\0" "\x08" "CMPNLTPD\0" "\x08" "CMPNLEPD\0" "\x08" "CMPORDPD\0" \
"\x07" "CMPEQSS\0" "\x07" "CMPLTSS\0" "\x07" "CMPLESS\0" "\x0a" "CMPUNORDSS\0" \
"\x08" "CMPNEQSS\0" "\x08" "CMPNLTSS\0" "\x08" "CMPNLESS\0" "\x08" "CMPORDSS\0" \
"\x07" "CMPEQSD\0" "\x07" "CMPLTSD\0" "\x07" "CMPLESD\0" "\x0a" "CMPUNORDSD\0" \
"\x08" "CMPNEQSD\0" "\x08" "CMPNLTSD\0" "\x08" "CMPNLESD\0" "\x08" "CMPORDSD\0" \
"\x08" "VCMPEQPS\0" "\x08" "VCMPLTPS\0" "\x08" "VCMPLEPS\0" "\x0b" "VCMPUNORDPS\0" \
"\x09" "VCMPNEQPS\0" "\x09" "VCMPNLTPS\0" "\x09" "VCMPNLEPS\0" "\x09" "VCMPORDPS\0" \
"\x0b" "VCMPEQ_UQPS\0" "\x09" "VCMPNGEPS\0" "\x09" "VCMPNGTPS\0" "\x0b" "VCMPFALSEPS\0" \
"\x0c" "VCMPNEQ_OQPS\0" "\x08" "VCMPGEPS\0" "\x08" "VCMPGTPS\0" "\x0a" "VCMPTRUEPS\0" \
"\x0b" "VCMPEQ_OSPS\0" "\x0b" "VCMPLT_OQPS\0" "\x0b" "VCMPLE_OQPS\0" "\x0d" "VCMPUNORD_SPS\0" \
"\x0c" "VCMPNEQ_USPS\0" "\x0c" "VCMPNLT_UQPS\0" "\x0c" "VCMPNLE_UQPS\0" "\x0b" "VCMPORD_SPS\0" \
"\x0b" "VCMPEQ_USPS\0" "\x0c" "VCMPNGE_UQPS\0" "\x0c" "VCMPNGT_UQPS\0" "\x0e" "VCMPFALSE_OSPS\0" \
"\x0c" "VCMPNEQ_OSPS\0" "\x0b" "VCMPGE_OQPS\0" "\x0b" "VCMPGT_OQPS\0" "\x0d" "VCMPTRUE_USPS\0" \
"\x08" "VCMPEQPD\0" "\x08" "VCMPLTPD\0" "\x08" "VCMPLEPD\0" "\x0b" "VCMPUNORDPD\0" \
"\x09" "VCMPNEQPD\0" "\x09" "VCMPNLTPD\0" "\x09" "VCMPNLEPD\0" "\x09" "VCMPORDPD\0" \
"\x0b" "VCMPEQ_UQPD\0" "\x09" "VCMPNGEPD\0" "\x09" "VCMPNGTPD\0" "\x0b" "VCMPFALSEPD\0" \
"\x0c" "VCMPNEQ_OQPD\0" "\x08" "VCMPGEPD\0" "\x08" "VCMPGTPD\0" "\x0a" "VCMPTRUEPD\0" \
"\x0b" "VCMPEQ_OSPD\0" "\x0b" "VCMPLT_OQPD\0" "\x0b" "VCMPLE_OQPD\0" "\x0d" "VCMPUNORD_SPD\0" \
"\x0c" "VCMPNEQ_USPD\0" "\x0c" "VCMPNLT_UQPD\0" "\x0c" "VCMPNLE_UQPD\0" "\x0b" "VCMPORD_SPD\0" \
"\x0b" "VCMPEQ_USPD\0" "\x0c" "VCMPNGE_UQPD\0" "\x0c" "VCMPNGT_UQPD\0" "\x0e" "VCMPFALSE_OSPD\0" \
"\x0c" "VCMPNEQ_OSPD\0" "\x0b" "VCMPGE_OQPD\0" "\x0b" "VCMPGT_OQPD\0" "\x0d" "VCMPTRUE_USPD\0" \
"\x08" "VCMPEQSS\0" "\x08" "VCMPLTSS\0" "\x08" "VCMPLESS\0" "\x0b" "VCMPUNORDSS\0" \
"\x09" "VCMPNEQSS\0" "\x09" "VCMPNLTSS\0" "\x09" "VCMPNLESS\0" "\x09" "VCMPORDSS\0" \
"\x0b" "VCMPEQ_UQSS\0" "\x09" "VCMPNGESS\0" "\x09" "VCMPNGTSS\0" "\x0b" "VCMPFALSESS\0" \
"\x0c" "VCMPNEQ_OQSS\0" "\x08" "VCMPGESS\0" "\x08" "VCMPGTSS\0" "\x0a" "VCMPTRUESS\0" \
"\x0b" "VCMPEQ_OSSS\0" "\x0b" "VCMPLT_OQSS\0" "\x0b" "VCMPLE_OQSS\0" "\x0d" "VCMPUNORD_SSS\0" \
"\x0c" "VCMPNEQ_USSS\0" "\x0c" "VCMPNLT_UQSS\0" "\x0c" "VCMPNLE_UQSS\0" "\x0b" "VCMPORD_SSS\0" \
"\x0b" "VCMPEQ_USSS\0" "\x0c" "VCMPNGE_UQSS\0" "\x0c" "VCMPNGT_UQSS\0" "\x0e" "VCMPFALSE_OSSS\0" \
"\x0c" "VCMPNEQ_OSSS\0" "\x0b" "VCMPGE_OQSS\0" "\x0b" "VCMPGT_OQSS\0" "\x0d" "VCMPTRUE_USSS\0" \
"\x08" "VCMPEQSD\0" "\x08" "VCMPLTSD\0" "\x08" "VCMPLESD\0" "\x0b" "VCMPUNORDSD\0" \
"\x09" "VCMPNEQSD\0" "\x09" "VCMPNLTSD\0" "\x09" "VCMPNLESD\0" "\x09" "VCMPORDSD\0" \
"\x0b" "VCMPEQ_UQSD\0" "\x09" "VCMPNGESD\0" "\x09" "VCMPNGTSD\0" "\x0b" "VCMPFALSESD\0" \
"\x0c" "VCMPNEQ_OQSD\0" "\x08" "VCMPGESD\0" "\x08" "VCMPGTSD\0" "\x0a" "VCMPTRUESD\0" \
"\x0b" "VCMPEQ_OSSD\0" "\x0b" "VCMPLT_OQSD\0" "\x0b" "VCMPLE_OQSD\0" "\x0d" "VCMPUNORD_SSD\0" \
"\x0c" "VCMPNEQ_USSD\0" "\x0c" "VCMPNLT_UQSD\0" "\x0c" "VCMPNLE_UQSD\0" "\x0b" "VCMPORD_SSD\0" \
"\x0b" "VCMPEQ_USSD\0" "\x0c" "VCMPNGE_UQSD\0" "\x0c" "VCMPNGT_UQSD\0" "\x0e" "VCMPFALSE_OSSD\0" \
"\x0c" "VCMPNEQ_OSSD\0" "\x0b" "VCMPGE_OQSD\0" "\x0b" "VCMPGT_OQSD\0" "\x0d" "VCMPTRUE_USSD\0" \
"\x06" "PINSRW\0" "\x07" "VPINSRW\0" "\x06" "PEXTRW\0" "\x07" "VPEXTRW\0" "\x06" "SHUFPS\0" \
"\x06" "SHUFPD\0" "\x07" "VSHUFPS\0" "\x07" "VSHUFPD\0" "\x09" "CMPXCHG8B\0" \
"\x0a" "CMPXCHG16B\0" "\x07" "VMPTRST\0" "\x08" "ADDSUBPD\0" "\x08" "ADDSUBPS\0" \
"\x09" "VADDSUBPD\0" "\x09" "VADDSUBPS\0" "\x05" "PSRLW\0" "\x06" "VPSRLW\0" \
"\x05" "PSRLD\0" "\x06" "VPSRLD\0" "\x05" "PSRLQ\0" "\x06" "VPSRLQ\0" "\x05" "PADDQ\0" \
"\x06" "VPADDQ\0" "\x06" "PMULLW\0" "\x07" "VPMULLW\0" "\x07" "MOVQ2DQ\0" "\x07" "MOVDQ2Q\0" \
"\x08" "PMOVMSKB\0" "\x09" "VPMOVMSKB\0" "\x07" "PSUBUSB\0" "\x08" "VPSUBUSB\0" \
"\x07" "PSUBUSW\0" "\x08" "VPSUBUSW\0" "\x06" "PMINUB\0" "\x07" "VPMINUB\0" \
"\x04" "PAND\0" "\x05" "VPAND\0" "\x07" "PADDUSB\0" "\x08" "VPADDUSW\0" "\x07" "PADDUSW\0" \
"\x06" "PMAXUB\0" "\x07" "VPMAXUB\0" "\x05" "PANDN\0" "\x06" "VPANDN\0" "\x05" "PAVGB\0" \
"\x06" "VPAVGB\0" "\x05" "PSRAW\0" "\x06" "VPSRAW\0" "\x05" "PSRAD\0" "\x06" "VPSRAD\0" \
"\x05" "PAVGW\0" "\x06" "VPAVGW\0" "\x07" "PMULHUW\0" "\x08" "VPMULHUW\0" "\x06" "PMULHW\0" \
"\x07" "VPMULHW\0" "\x09" "CVTTPD2DQ\0" "\x08" "CVTDQ2PD\0" "\x08" "CVTPD2DQ\0" \
"\x0a" "VCVTTPD2DQ\0" "\x09" "VCVTDQ2PD\0" "\x09" "VCVTPD2DQ\0" "\x06" "MOVNTQ\0" \
"\x07" "MOVNTDQ\0" "\x08" "VMOVNTDQ\0" "\x06" "PSUBSB\0" "\x07" "VPSUBSB\0" \
"\x06" "PSUBSW\0" "\x07" "VPSUBSW\0" "\x06" "PMINSW\0" "\x07" "VPMINSW\0" "\x03" "POR\0" \
"\x04" "VPOR\0" "\x06" "PADDSB\0" "\x07" "VPADDSB\0" "\x06" "PADDSW\0" "\x07" "VPADDSW\0" \
"\x06" "PMAXSW\0" "\x07" "VPMAXSW\0" "\x04" "PXOR\0" "\x05" "VPXOR\0" "\x05" "LDDQU\0" \
"\x06" "VLDDQU\0" "\x05" "PSLLW\0" "\x06" "VPSLLW\0" "\x05" "PSLLD\0" "\x06" "VPSLLD\0" \
"\x05" "PSLLQ\0" "\x06" "VPSLLQ\0" "\x07" "PMULUDQ\0" "\x08" "VPMULUDQ\0" "\x07" "PMADDWD\0" \
"\x08" "VPMADDWD\0" "\x06" "PSADBW\0" "\x07" "VPSADBW\0" "\x08" "MASKMOVQ\0" \
"\x0a" "MASKMOVDQU\0" "\x0b" "VMASKMOVDQU\0" "\x05" "PSUBB\0" "\x06" "VPSUBB\0" \
"\x05" "PSUBW\0" "\x06" "VPSUBW\0" "\x05" "PSUBD\0" "\x06" "VPSUBD\0" "\x05" "PSUBQ\0" \
"\x06" "VPSUBQ\0" "\x05" "PADDB\0" "\x06" "VPADDB\0" "\x05" "PADDW\0" "\x06" "VPADDW\0" \
"\x05" "PADDD\0" "\x06" "VPADDD\0" "\x07" "FNSTENV\0" "\x06" "FSTENV\0" "\x06" "FNSTCW\0" \
"\x05" "FSTCW\0" "\x06" "FNCLEX\0" "\x05" "FCLEX\0" "\x06" "FNINIT\0" "\x05" "FINIT\0" \
"\x06" "FNSAVE\0" "\x05" "FSAVE\0" "\x06" "FNSTSW\0" "\x05" "FSTSW\0" "\x06" "PSHUFB\0" \
"\x07" "VPSHUFB\0" "\x06" "PHADDW\0" "\x07" "VPHADDW\0" "\x06" "PHADDD\0" "\x07" "VPHADDD\0" \
"\x07" "PHADDSW\0" "\x08" "VPHADDSW\0" "\x09" "PMADDUBSW\0" "\x0a" "VPMADDUBSW\0" \
"\x06" "PHSUBW\0" "\x07" "VPHSUBW\0" "\x06" "PHSUBD\0" "\x07" "VPHSUBD\0" "\x07" "PHSUBSW\0" \
"\x08" "VPHSUBSW\0" "\x06" "PSIGNB\0" "\x07" "VPSIGNB\0" "\x06" "PSIGNW\0" \
"\x07" "VPSIGNW\0" "\x06" "PSIGND\0" "\x07" "VPSIGND\0" "\x08" "PMULHRSW\0" \
"\x09" "VPMULHRSW\0" "\x09" "VPERMILPS\0" "\x09" "VPERMILPD\0" "\x07" "VTESTPS\0" \
"\x07" "VTESTPD\0" "\x08" "PBLENDVB\0" "\x08" "BLENDVPS\0" "\x08" "BLENDVPD\0" \
"\x05" "PTEST\0" "\x06" "VPTEST\0" "\x0c" "VBROADCASTSS\0" "\x0c" "VBROADCASTSD\0" \
"\x0e" "VBROADCASTF128\0" "\x05" "PABSB\0" "\x06" "VPABSB\0" "\x05" "PABSW\0" \
"\x06" "VPABSW\0" "\x05" "PABSD\0" "\x06" "VPABSD\0" "\x08" "PMOVSXBW\0" "\x09" "VPMOVSXBW\0" \
"\x08" "PMOVSXBD\0" "\x09" "VPMOVSXBD\0" "\x08" "PMOVSXBQ\0" "\x09" "VPMOVSXBQ\0" \
"\x08" "PMOVSXWD\0" "\x09" "VPMOVSXWD\0" "\x08" "PMOVSXWQ\0" "\x09" "VPMOVSXWQ\0" \
"\x08" "PMOVSXDQ\0" "\x09" "VPMOVSXDQ\0" "\x06" "PMULDQ\0" "\x07" "VPMULDQ\0" \
"\x07" "PCMPEQQ\0" "\x08" "VPCMPEQQ\0" "\x08" "MOVNTDQA\0" "\x09" "VMOVNTDQA\0" \
"\x08" "PACKUSDW\0" "\x09" "VPACKUSDW\0" "\x0a" "VMASKMOVPS\0" "\x0a" "VMASKMOVPD\0" \
"\x08" "PMOVZXBW\0" "\x09" "VPMOVZXBW\0" "\x08" "PMOVZXBD\0" "\x09" "VPMOVZXBD\0" \
"\x08" "PMOVZXBQ\0" "\x09" "VPMOVZXBQ\0" "\x08" "PMOVZXWD\0" "\x09" "VPMOVZXWD\0" \
"\x08" "PMOVZXWQ\0" "\x09" "VPMOVZXWQ\0" "\x08" "PMOVZXDQ\0" "\x09" "VPMOVZXDQ\0" \
"\x07" "PCMPGTQ\0" "\x08" "VPCMPGTQ\0" "\x06" "PMINSB\0" "\x07" "VPMINSB\0" \
"\x06" "PMINSD\0" "\x07" "VPMINSD\0" "\x06" "PMINUW\0" "\x07" "VPMINUW\0" "\x06" "PMINUD\0" \
"\x07" "VPMINUD\0" "\x06" "PMAXSB\0" "\x07" "VPMAXSB\0" "\x06" "PMAXSD\0" "\x07" "VPMAXSD\0" \
"\x06" "PMAXUW\0" "\x07" "VPMAXUW\0" "\x06" "PMAXUD\0" "\x07" "VPMAXUD\0" "\x06" "PMULLD\0" \
"\x07" "VPMULLD\0" "\x0a" "PHMINPOSUW\0" "\x0b" "VPHMINPOSUW\0" "\x06" "INVEPT\0" \
"\x07" "INVVPID\0" "\x07" "INVPCID\0" "\x0e" "VFMADDSUB132PS\0" "\x0e" "VFMADDSUB132PD\0" \
"\x0e" "VFMSUBADD132PS\0" "\x0e" "VFMSUBADD132PD\0" "\x0b" "VFMADD132PS\0" \
"\x0b" "VFMADD132PD\0" "\x0b" "VFMADD132SS\0" "\x0b" "VFMADD132SD\0" "\x0b" "VFMSUB132PS\0" \
"\x0b" "VFMSUB132PD\0" "\x0b" "VFMSUB132SS\0" "\x0b" "VFMSUB132SD\0" "\x0c" "VFNMADD132PS\0" \
"\x0c" "VFNMADD132PD\0" "\x0c" "VFNMADD132SS\0" "\x0c" "VFNMADD132SD\0" "\x0c" "VFNMSUB132PS\0" \
"\x0c" "VFNMSUB132PD\0" "\x0c" "VFNMSUB132SS\0" "\x0c" "VFNMSUB132SD\0" "\x0e" "VFMADDSUB213PS\0" \
"\x0e" "VFMADDSUB213PD\0" "\x0e" "VFMSUBADD213PS\0" "\x0e" "VFMSUBADD213PD\0" \
"\x0b" "VFMADD213PS\0" "\x0b" "VFMADD213PD\0" "\x0b" "VFMADD213SS\0" "\x0b" "VFMADD213SD\0" \
"\x0b" "VFMSUB213PS\0" "\x0b" "VFMSUB213PD\0" "\x0b" "VFMSUB213SS\0" "\x0b" "VFMSUB213SD\0" \
"\x0c" "VFNMADD213PS\0" "\x0c" "VFNMADD213PD\0" "\x0c" "VFNMADD213SS\0" "\x0c" "VFNMADD213SD\0" \
"\x0c" "VFNMSUB213PS\0" "\x0c" "VFNMSUB213PD\0" "\x0c" "VFNMSUB213SS\0" "\x0c" "VFNMSUB213SD\0" \
"\x0e" "VFMADDSUB231PS\0" "\x0e" "VFMADDSUB231PD\0" "\x0e" "VFMSUBADD231PS\0" \
"\x0e" "VFMSUBADD231PD\0" "\x0b" "VFMADD231PS\0" "\x0b" "VFMADD231PD\0" "\x0b" "VFMADD231SS\0" \
"\x0b" "VFMADD231SD\0" "\x0b" "VFMSUB231PS\0" "\x0b" "VFMSUB231PD\0" "\x0b" "VFMSUB231SS\0" \
"\x0b" "VFMSUB231SD\0" "\x0c" "VFNMADD231PS\0" "\x0c" "VFNMADD231PD\0" "\x0c" "VFNMADD231SS\0" \
"\x0c" "VFNMADD231SD\0" "\x0c" "VFNMSUB231PS\0" "\x0c" "VFNMSUB231PD\0" "\x0c" "VFNMSUB231SS\0" \
"\x0c" "VFNMSUB231SD\0" "\x06" "AESIMC\0" "\x07" "VAESIMC\0" "\x06" "AESENC\0" \
"\x07" "VAESENC\0" "\x0a" "AESENCLAST\0" "\x0b" "VAESENCLAST\0" "\x06" "AESDEC\0" \
"\x07" "VAESDEC\0" "\x0a" "AESDECLAST\0" "\x0b" "VAESDECLAST\0" "\x05" "MOVBE\0" \
"\x05" "CRC32\0" "\x0a" "VPERM2F128\0" "\x07" "ROUNDPS\0" "\x08" "VROUNDPS\0" \
"\x07" "ROUNDPD\0" "\x08" "VROUNDPD\0" "\x07" "ROUNDSS\0" "\x08" "VROUNDSS\0" \
"\x07" "ROUNDSD\0" "\x08" "VROUNDSD\0" "\x07" "BLENDPS\0" "\x08" "VBLENDPS\0" \
"\x07" "BLENDPD\0" "\x08" "VBLENDPD\0" "\x07" "PBLENDW\0" "\x08" "VPBLENDW\0" \
"\x07" "PALIGNR\0" "\x08" "VPALIGNR\0" "\x06" "PEXTRB\0" "\x07" "VPEXTRB\0" \
"\x06" "PEXTRD\0" "\x06" "PEXTRQ\0" "\x07" "VPEXTRD\0" "\x07" "VPEXTRQ\0" "\x09" "EXTRACTPS\0" \
"\x0a" "VEXTRACTPS\0" "\x0b" "VINSERTF128\0" "\x0c" "VEXTRACTF128\0" "\x06" "PINSRB\0" \
"\x07" "VPINSRB\0" "\x08" "INSERTPS\0" "\x09" "VINSERTPS\0" "\x06" "PINSRD\0" \
"\x06" "PINSRQ\0" "\x07" "VPINSRD\0" "\x07" "VPINSRQ\0" "\x04" "DPPS\0" "\x05" "VDPPS\0" \
"\x04" "DPPD\0" "\x05" "VDPPD\0" "\x07" "MPSADBW\0" "\x08" "VMPSADBW\0" "\x09" "PCLMULQDQ\0" \
"\x0a" "VPCLMULQDQ\0" "\x09" "VBLENDVPS\0" "\x09" "VBLENDVPD\0" "\x09" "VPBLENDVB\0" \
"\x09" "PCMPESTRM\0" "\x0a" "VPCMPESTRM\0" "\x09" "PCMPESTRI\0" "\x0a" "VPCMPESTRI\0" \
"\x09" "PCMPISTRM\0" "\x0a" "VPCMPISTRM\0" "\x09" "PCMPISTRI\0" "\x0a" "VPCMPISTRI\0" \
"\x0f" "AESKEYGENASSIST\0" "\x10" "VAESKEYGENASSIST\0" "\x06" "PSRLDQ\0" "\x07" "VPSRLDQ\0" \
"\x06" "PSLLDQ\0" "\x07" "VPSLLDQ\0" "\x06" "FXSAVE\0" "\x08" "FXSAVE64\0" \
"\x08" "RDFSBASE\0" "\x07" "FXRSTOR\0" "\x09" "FXRSTOR64\0" "\x08" "RDGSBASE\0" \
"\x07" "LDMXCSR\0" "\x08" "WRFSBASE\0" "\x08" "VLDMXCSR\0" "\x07" "STMXCSR\0" \
"\x08" "WRGSBASE\0" "\x08" "VSTMXCSR\0" "\x06" "RDRAND\0" "\x07" "VMPTRLD\0" \
"\x07" "VMCLEAR\0" "\x05" "VMXON\0" "\x06" "MOVSXD\0" "\x05" "PAUSE\0" "\x04" "WAIT\0" \
"\x06" "_3DNOW\0";

const _WRegister _REGISTERS[] = {
	{3, "RAX"}, {3, "RCX"}, {3, "RDX"}, {3, "RBX"}, {3, "RSP"}, {3, "RBP"}, {3, "RSI"}, {3, "RDI"}, {2, "R8"}, {2, "R9"}, {3, "R10"}, {3, "R11"}, {3, "R12"}, {3, "R13"}, {3, "R14"}, {3, "R15"},
	{3, "EAX"}, {3, "ECX"}, {3, "EDX"}, {3, "EBX"}, {3, "ESP"}, {3, "EBP"}, {3, "ESI"}, {3, "EDI"}, {3, "R8D"}, {3, "R9D"}, {4, "R10D"}, {4, "R11D"}, {4, "R12D"}, {4, "R13D"}, {4, "R14D"}, {4, "R15D"},
	{2, "AX"}, {2, "CX"}, {2, "DX"}, {2, "BX"}, {2, "SP"}, {2, "BP"}, {2, "SI"}, {2, "DI"}, {3, "R8W"}, {3, "R9W"}, {4, "R10W"}, {4, "R11W"}, {4, "R12W"}, {4, "R13W"}, {4, "R14W"}, {4, "R15W"},
	{2, "AL"}, {2, "CL"}, {2, "DL"}, {2, "BL"}, {2, "AH"}, {2, "CH"}, {2, "DH"}, {2, "BH"}, {3, "R8B"}, {3, "R9B"}, {4, "R10B"}, {4, "R11B"}, {4, "R12B"}, {4, "R13B"}, {4, "R14B"}, {4, "R15B"},
	{3, "SPL"}, {3, "BPL"}, {3, "SIL"}, {3, "DIL"},
	{2, "ES"}, {2, "CS"}, {2, "SS"}, {2, "DS"}, {2, "FS"}, {2, "GS"},
	{3, "RIP"},
	{3, "ST0"}, {3, "ST1"}, {3, "ST2"}, {3, "ST3"}, {3, "ST4"}, {3, "ST5"}, {3, "ST6"}, {3, "ST7"},
	{3, "MM0"}, {3, "MM1"}, {3, "MM2"}, {3, "MM3"}, {3, "MM4"}, {3, "MM5"}, {3, "MM6"}, {3, "MM7"},
	{4, "XMM0"}, {4, "XMM1"}, {4, "XMM2"}, {4, "XMM3"}, {4, "XMM4"}, {4, "XMM5"}, {4, "XMM6"}, {4, "XMM7"}, {4, "XMM8"}, {4, "XMM9"}, {5, "XMM10"}, {5, "XMM11"}, {5, "XMM12"}, {5, "XMM13"}, {5, "XMM14"}, {5, "XMM15"},
	{4, "YMM0"}, {4, "YMM1"}, {4, "YMM2"}, {4, "YMM3"}, {4, "YMM4"}, {4, "YMM5"}, {4, "YMM6"}, {4, "YMM7"}, {4, "YMM8"}, {4, "YMM9"}, {5, "YMM10"}, {5, "YMM11"}, {5, "YMM12"}, {5, "YMM13"}, {5, "YMM14"}, {5, "YMM15"},
	{3, "CR0"}, {0, ""}, {3, "CR2"}, {3, "CR3"}, {3, "CR4"}, {0, ""}, {0, ""}, {0, ""}, {3, "CR8"},
	{3, "DR0"}, {3, "DR1"}, {3, "DR2"}, {3, "DR3"}, {0, ""}, {0, ""}, {3, "DR6"}, {3, "DR7"}
};

#endif /* DISTORM_LIGHT */



================================================
File: src/sigmake/distorm/mnemonics.h
================================================
/*
mnemonics.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef MNEMONICS_H
#define MNEMONICS_H

#ifdef __cplusplus
 extern "C" {
#endif

#ifndef DISTORM_LIGHT

typedef struct WMnemonic {
	unsigned char length;
	unsigned char p[1]; /* p is a null terminated string, which contains 'length' characters. */
} _WMnemonic;

typedef struct WRegister {
	unsigned int length;
	unsigned char p[6]; /* p is a null terminated string. */
} _WRegister;

extern const unsigned char _MNEMONICS[];
extern const _WRegister _REGISTERS[];

#endif /* DISTORM_LIGHT */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#define GET_REGISTER_NAME(r) (unsigned char*)_REGISTERS[(r)].p
#define GET_MNEMONIC_NAME(m) ((_WMnemonic*)&_MNEMONICS[(m)])->p

typedef enum {
	I_UNDEFINED = 0, I_AAA = 66, I_AAD = 389, I_AAM = 384, I_AAS = 76, I_ADC = 31, I_ADD = 11, I_ADDPD = 3110,
	I_ADDPS = 3103, I_ADDSD = 3124, I_ADDSS = 3117, I_ADDSUBPD = 6394, I_ADDSUBPS = 6404,
	I_AESDEC = 9209, I_AESDECLAST = 9226, I_AESENC = 9167, I_AESENCLAST = 9184,
	I_AESIMC = 9150, I_AESKEYGENASSIST = 9795, I_AND = 41, I_ANDNPD = 3021, I_ANDNPS = 3013,
	I_ANDPD = 2990, I_ANDPS = 2983, I_ARPL = 111, I_BLENDPD = 9372, I_BLENDPS = 9353,
	I_BLENDVPD = 7619, I_BLENDVPS = 7609, I_BOUND = 104, I_BSF = 4346, I_BSR = 4358,
	I_BSWAP = 960, I_BT = 872, I_BTC = 934, I_BTR = 912, I_BTS = 887, I_CALL = 456,
	I_CALL_FAR = 260, I_CBW = 228, I_CDQ = 250, I_CDQE = 239, I_CLC = 492, I_CLD = 512,
	I_CLFLUSH = 4329, I_CLGI = 1833, I_CLI = 502, I_CLTS = 541, I_CMC = 487, I_CMOVA = 694,
	I_CMOVAE = 663, I_CMOVB = 656, I_CMOVBE = 686, I_CMOVG = 754, I_CMOVGE = 738,
	I_CMOVL = 731, I_CMOVLE = 746, I_CMOVNO = 648, I_CMOVNP = 723, I_CMOVNS = 708,
	I_CMOVNZ = 678, I_CMOVO = 641, I_CMOVP = 716, I_CMOVS = 701, I_CMOVZ = 671,
	I_CMP = 71, I_CMPEQPD = 4449, I_CMPEQPS = 4370, I_CMPEQSD = 4607, I_CMPEQSS = 4528,
	I_CMPLEPD = 4467, I_CMPLEPS = 4388, I_CMPLESD = 4625, I_CMPLESS = 4546, I_CMPLTPD = 4458,
	I_CMPLTPS = 4379, I_CMPLTSD = 4616, I_CMPLTSS = 4537, I_CMPNEQPD = 4488, I_CMPNEQPS = 4409,
	I_CMPNEQSD = 4646, I_CMPNEQSS = 4567, I_CMPNLEPD = 4508, I_CMPNLEPS = 4429,
	I_CMPNLESD = 4666, I_CMPNLESS = 4587, I_CMPNLTPD = 4498, I_CMPNLTPS = 4419,
	I_CMPNLTSD = 4656, I_CMPNLTSS = 4577, I_CMPORDPD = 4518, I_CMPORDPS = 4439,
	I_CMPORDSD = 4676, I_CMPORDSS = 4597, I_CMPS = 301, I_CMPUNORDPD = 4476, I_CMPUNORDPS = 4397,
	I_CMPUNORDSD = 4634, I_CMPUNORDSS = 4555, I_CMPXCHG = 898, I_CMPXCHG16B = 6373,
	I_CMPXCHG8B = 6362, I_COMISD = 2779, I_COMISS = 2771, I_CPUID = 865, I_CQO = 255,
	I_CRC32 = 9258, I_CVTDQ2PD = 6787, I_CVTDQ2PS = 3307, I_CVTPD2DQ = 6797, I_CVTPD2PI = 2681,
	I_CVTPD2PS = 3233, I_CVTPH2PS = 4161, I_CVTPI2PD = 2495, I_CVTPI2PS = 2485,
	I_CVTPS2DQ = 3317, I_CVTPS2PD = 3223, I_CVTPS2PH = 4171, I_CVTPS2PI = 2671,
	I_CVTSD2SI = 2701, I_CVTSD2SS = 3253, I_CVTSI2SD = 2515, I_CVTSI2SS = 2505,
	I_CVTSS2SD = 3243, I_CVTSS2SI = 2691, I_CVTTPD2DQ = 6776, I_CVTTPD2PI = 2614,
	I_CVTTPS2DQ = 3327, I_CVTTPS2PI = 2603, I_CVTTSD2SI = 2636, I_CVTTSS2SI = 2625,
	I_CWD = 245, I_CWDE = 233, I_DAA = 46, I_DAS = 56, I_DEC = 86, I_DIV = 1630,
	I_DIVPD = 3499, I_DIVPS = 3492, I_DIVSD = 3513, I_DIVSS = 3506, I_DPPD = 9615,
	I_DPPS = 9602, I_EMMS = 4100, I_ENTER = 340, I_EXTRACTPS = 9480, I_EXTRQ = 4136,
	I_F2XM1 = 1176, I_FABS = 1107, I_FADD = 1007, I_FADDP = 1533, I_FBLD = 1585,
	I_FBSTP = 1591, I_FCHS = 1101, I_FCLEX = 7289, I_FCMOVB = 1360, I_FCMOVBE = 1376,
	I_FCMOVE = 1368, I_FCMOVNB = 1429, I_FCMOVNBE = 1447, I_FCMOVNE = 1438, I_FCMOVNU = 1457,
	I_FCMOVU = 1385, I_FCOM = 1019, I_FCOMI = 1496, I_FCOMIP = 1607, I_FCOMP = 1025,
	I_FCOMPP = 1547, I_FCOS = 1295, I_FDECSTP = 1222, I_FDIV = 1045, I_FDIVP = 1578,
	I_FDIVR = 1051, I_FDIVRP = 1570, I_FEDISI = 1472, I_FEMMS = 574, I_FENI = 1466,
	I_FFREE = 1511, I_FIADD = 1301, I_FICOM = 1315, I_FICOMP = 1322, I_FIDIV = 1345,
	I_FIDIVR = 1352, I_FILD = 1402, I_FIMUL = 1308, I_FINCSTP = 1231, I_FINIT = 7304,
	I_FIST = 1416, I_FISTP = 1422, I_FISTTP = 1408, I_FISUB = 1330, I_FISUBR = 1337,
	I_FLD = 1058, I_FLD1 = 1125, I_FLDCW = 1082, I_FLDENV = 1074, I_FLDL2E = 1139,
	I_FLDL2T = 1131, I_FLDLG2 = 1154, I_FLDLN2 = 1162, I_FLDPI = 1147, I_FLDZ = 1170,
	I_FMUL = 1013, I_FMULP = 1540, I_FNCLEX = 7281, I_FNINIT = 7296, I_FNOP = 1095,
	I_FNSAVE = 7311, I_FNSTCW = 7266, I_FNSTENV = 7249, I_FNSTSW = 7326, I_FPATAN = 1197,
	I_FPREM = 1240, I_FPREM1 = 1214, I_FPTAN = 1190, I_FRNDINT = 1272, I_FRSTOR = 1503,
	I_FSAVE = 7319, I_FSCALE = 1281, I_FSETPM = 1480, I_FSIN = 1289, I_FSINCOS = 1263,
	I_FSQRT = 1256, I_FST = 1063, I_FSTCW = 7274, I_FSTENV = 7258, I_FSTP = 1068,
	I_FSTSW = 7334, I_FSUB = 1032, I_FSUBP = 1563, I_FSUBR = 1038, I_FSUBRP = 1555,
	I_FTST = 1113, I_FUCOM = 1518, I_FUCOMI = 1488, I_FUCOMIP = 1598, I_FUCOMP = 1525,
	I_FUCOMPP = 1393, I_FXAM = 1119, I_FXCH = 1089, I_FXRSTOR = 9892, I_FXRSTOR64 = 9901,
	I_FXSAVE = 9864, I_FXSAVE64 = 9872, I_FXTRACT = 1205, I_FYL2X = 1183, I_FYL2XP1 = 1247,
	I_GETSEC = 633, I_HADDPD = 4181, I_HADDPS = 4189, I_HLT = 482, I_HSUBPD = 4215,
	I_HSUBPS = 4223, I_IDIV = 1635, I_IMUL = 117, I_IN = 447, I_INC = 81, I_INS = 123,
	I_INSERTPS = 9547, I_INSERTQ = 4143, I_INT = 367, I_INT_3 = 360, I_INT1 = 476,
	I_INTO = 372, I_INVD = 555, I_INVEPT = 8284, I_INVLPG = 1711, I_INVLPGA = 1847,
	I_INVPCID = 8301, I_INVVPID = 8292, I_IRET = 378, I_JA = 166, I_JAE = 147,
	I_JB = 143, I_JBE = 161, I_JCXZ = 427, I_JECXZ = 433, I_JG = 202, I_JGE = 192,
	I_JL = 188, I_JLE = 197, I_JMP = 462, I_JMP_FAR = 467, I_JNO = 138, I_JNP = 183,
	I_JNS = 174, I_JNZ = 156, I_JO = 134, I_JP = 179, I_JRCXZ = 440, I_JS = 170,
	I_JZ = 152, I_LAHF = 289, I_LAR = 522, I_LDDQU = 6994, I_LDMXCSR = 9922, I_LDS = 335,
	I_LEA = 223, I_LEAVE = 347, I_LES = 330, I_LFENCE = 4265, I_LFS = 917, I_LGDT = 1687,
	I_LGS = 922, I_LIDT = 1693, I_LLDT = 1652, I_LMSW = 1705, I_LODS = 313, I_LOOP = 421,
	I_LOOPNZ = 406, I_LOOPZ = 414, I_LSL = 527, I_LSS = 907, I_LTR = 1658, I_LZCNT = 4363,
	I_MASKMOVDQU = 7119, I_MASKMOVQ = 7109, I_MAXPD = 3559, I_MAXPS = 3552, I_MAXSD = 3573,
	I_MAXSS = 3566, I_MFENCE = 4291, I_MINPD = 3439, I_MINPS = 3432, I_MINSD = 3453,
	I_MINSS = 3446, I_MONITOR = 1755, I_MOV = 218, I_MOVAPD = 2459, I_MOVAPS = 2451,
	I_MOVBE = 9251, I_MOVD = 3920, I_MOVDDUP = 2186, I_MOVDQ2Q = 6522, I_MOVDQA = 3946,
	I_MOVDQU = 3954, I_MOVHLPS = 2151, I_MOVHPD = 2345, I_MOVHPS = 2337, I_MOVLHPS = 2328,
	I_MOVLPD = 2168, I_MOVLPS = 2160, I_MOVMSKPD = 2815, I_MOVMSKPS = 2805, I_MOVNTDQ = 6849,
	I_MOVNTDQA = 7895, I_MOVNTI = 952, I_MOVNTPD = 2556, I_MOVNTPS = 2547, I_MOVNTQ = 6841,
	I_MOVNTSD = 2574, I_MOVNTSS = 2565, I_MOVQ = 3926, I_MOVQ2DQ = 6513, I_MOVS = 295,
	I_MOVSD = 2110, I_MOVSHDUP = 2353, I_MOVSLDUP = 2176, I_MOVSS = 2103, I_MOVSX = 939,
	I_MOVSXD = 10013, I_MOVUPD = 2095, I_MOVUPS = 2087, I_MOVZX = 927, I_MPSADBW = 9628,
	I_MUL = 1625, I_MULPD = 3170, I_MULPS = 3163, I_MULSD = 3184, I_MULSS = 3177,
	I_MWAIT = 1764, I_NEG = 1620, I_NOP = 581, I_NOT = 1615, I_OR = 27, I_ORPD = 3053,
	I_ORPS = 3047, I_OUT = 451, I_OUTS = 128, I_PABSB = 7688, I_PABSD = 7718, I_PABSW = 7703,
	I_PACKSSDW = 3849, I_PACKSSWB = 3681, I_PACKUSDW = 7916, I_PACKUSWB = 3759,
	I_PADDB = 7204, I_PADDD = 7234, I_PADDQ = 6481, I_PADDSB = 6930, I_PADDSW = 6947,
	I_PADDUSB = 6620, I_PADDUSW = 6639, I_PADDW = 7219, I_PALIGNR = 9410, I_PAND = 6607,
	I_PANDN = 6665, I_PAUSE = 10021, I_PAVGB = 6680, I_PAVGUSB = 2078, I_PAVGW = 6725,
	I_PBLENDVB = 7599, I_PBLENDW = 9391, I_PCLMULQDQ = 9647, I_PCMPEQB = 4043,
	I_PCMPEQD = 4081, I_PCMPEQQ = 7876, I_PCMPEQW = 4062, I_PCMPESTRI = 9726,
	I_PCMPESTRM = 9703, I_PCMPGTB = 3702, I_PCMPGTD = 3740, I_PCMPGTQ = 8087,
	I_PCMPGTW = 3721, I_PCMPISTRI = 9772, I_PCMPISTRM = 9749, I_PEXTRB = 9429,
	I_PEXTRD = 9446, I_PEXTRQ = 9454, I_PEXTRW = 6311, I_PF2ID = 1914, I_PF2IW = 1907,
	I_PFACC = 2028, I_PFADD = 1977, I_PFCMPEQ = 2035, I_PFCMPGE = 1938, I_PFCMPGT = 1984,
	I_PFMAX = 1993, I_PFMIN = 1947, I_PFMUL = 2044, I_PFNACC = 1921, I_PFPNACC = 1929,
	I_PFRCP = 1954, I_PFRCPIT1 = 2000, I_PFRCPIT2 = 2051, I_PFRSQIT1 = 2010, I_PFRSQRT = 1961,
	I_PFSUB = 1970, I_PFSUBR = 2020, I_PHADDD = 7375, I_PHADDSW = 7392, I_PHADDW = 7358,
	I_PHMINPOSUW = 8259, I_PHSUBD = 7451, I_PHSUBSW = 7468, I_PHSUBW = 7434, I_PI2FD = 1900,
	I_PI2FW = 1893, I_PINSRB = 9530, I_PINSRD = 9568, I_PINSRQ = 9576, I_PINSRW = 6294,
	I_PMADDUBSW = 7411, I_PMADDWD = 7073, I_PMAXSB = 8174, I_PMAXSD = 8191, I_PMAXSW = 6964,
	I_PMAXUB = 6648, I_PMAXUD = 8225, I_PMAXUW = 8208, I_PMINSB = 8106, I_PMINSD = 8123,
	I_PMINSW = 6902, I_PMINUB = 6590, I_PMINUD = 8157, I_PMINUW = 8140, I_PMOVMSKB = 6531,
	I_PMOVSXBD = 7754, I_PMOVSXBQ = 7775, I_PMOVSXBW = 7733, I_PMOVSXDQ = 7838,
	I_PMOVSXWD = 7796, I_PMOVSXWQ = 7817, I_PMOVZXBD = 7982, I_PMOVZXBQ = 8003,
	I_PMOVZXBW = 7961, I_PMOVZXDQ = 8066, I_PMOVZXWD = 8024, I_PMOVZXWQ = 8045,
	I_PMULDQ = 7859, I_PMULHRSW = 7538, I_PMULHRW = 2061, I_PMULHUW = 6740, I_PMULHW = 6759,
	I_PMULLD = 8242, I_PMULLW = 6496, I_PMULUDQ = 7054, I_POP = 22, I_POPA = 98,
	I_POPCNT = 4338, I_POPF = 277, I_POR = 6919, I_PREFETCH = 1872, I_PREFETCHNTA = 2402,
	I_PREFETCHT0 = 2415, I_PREFETCHT1 = 2427, I_PREFETCHT2 = 2439, I_PREFETCHW = 1882,
	I_PSADBW = 7092, I_PSHUFB = 7341, I_PSHUFD = 3988, I_PSHUFHW = 3996, I_PSHUFLW = 4005,
	I_PSHUFW = 3980, I_PSIGNB = 7487, I_PSIGND = 7521, I_PSIGNW = 7504, I_PSLLD = 7024,
	I_PSLLDQ = 9847, I_PSLLQ = 7039, I_PSLLW = 7009, I_PSRAD = 6710, I_PSRAW = 6695,
	I_PSRLD = 6451, I_PSRLDQ = 9830, I_PSRLQ = 6466, I_PSRLW = 6436, I_PSUBB = 7144,
	I_PSUBD = 7174, I_PSUBQ = 7189, I_PSUBSB = 6868, I_PSUBSW = 6885, I_PSUBUSB = 6552,
	I_PSUBUSW = 6571, I_PSUBW = 7159, I_PSWAPD = 2070, I_PTEST = 7629, I_PUNPCKHBW = 3780,
	I_PUNPCKHDQ = 3826, I_PUNPCKHQDQ = 3895, I_PUNPCKHWD = 3803, I_PUNPCKLBW = 3612,
	I_PUNPCKLDQ = 3658, I_PUNPCKLQDQ = 3870, I_PUNPCKLWD = 3635, I_PUSH = 16,
	I_PUSHA = 91, I_PUSHF = 270, I_PXOR = 6981, I_RCL = 977, I_RCPPS = 2953, I_RCPSS = 2960,
	I_RCR = 982, I_RDFSBASE = 9882, I_RDGSBASE = 9912, I_RDMSR = 600, I_RDPMC = 607,
	I_RDRAND = 9980, I_RDTSC = 593, I_RDTSCP = 1864, I_RET = 325, I_RETF = 354,
	I_ROL = 967, I_ROR = 972, I_ROUNDPD = 9296, I_ROUNDPS = 9277, I_ROUNDSD = 9334,
	I_ROUNDSS = 9315, I_RSM = 882, I_RSQRTPS = 2915, I_RSQRTSS = 2924, I_SAHF = 283,
	I_SAL = 997, I_SALC = 394, I_SAR = 1002, I_SBB = 36, I_SCAS = 319, I_SETA = 807,
	I_SETAE = 780, I_SETB = 774, I_SETBE = 800, I_SETG = 859, I_SETGE = 845, I_SETL = 839,
	I_SETLE = 852, I_SETNO = 767, I_SETNP = 832, I_SETNS = 819, I_SETNZ = 793,
	I_SETO = 761, I_SETP = 826, I_SETS = 813, I_SETZ = 787, I_SFENCE = 4321, I_SGDT = 1675,
	I_SHL = 987, I_SHLD = 876, I_SHR = 992, I_SHRD = 892, I_SHUFPD = 6336, I_SHUFPS = 6328,
	I_SIDT = 1681, I_SKINIT = 1839, I_SLDT = 1641, I_SMSW = 1699, I_SQRTPD = 2855,
	I_SQRTPS = 2847, I_SQRTSD = 2871, I_SQRTSS = 2863, I_STC = 497, I_STD = 517,
	I_STGI = 1827, I_STI = 507, I_STMXCSR = 9951, I_STOS = 307, I_STR = 1647, I_SUB = 51,
	I_SUBPD = 3379, I_SUBPS = 3372, I_SUBSD = 3393, I_SUBSS = 3386, I_SWAPGS = 1856,
	I_SYSCALL = 532, I_SYSENTER = 614, I_SYSEXIT = 624, I_SYSRET = 547, I_TEST = 206,
	I_TZCNT = 4351, I_UCOMISD = 2742, I_UCOMISS = 2733, I_UD2 = 569, I_UNPCKHPD = 2296,
	I_UNPCKHPS = 2286, I_UNPCKLPD = 2254, I_UNPCKLPS = 2244, I_VADDPD = 3139,
	I_VADDPS = 3131, I_VADDSD = 3155, I_VADDSS = 3147, I_VADDSUBPD = 6414, I_VADDSUBPS = 6425,
	I_VAESDEC = 9217, I_VAESDECLAST = 9238, I_VAESENC = 9175, I_VAESENCLAST = 9196,
	I_VAESIMC = 9158, I_VAESKEYGENASSIST = 9812, I_VANDNPD = 3038, I_VANDNPS = 3029,
	I_VANDPD = 3005, I_VANDPS = 2997, I_VBLENDPD = 9381, I_VBLENDPS = 9362, I_VBLENDVPD = 9681,
	I_VBLENDVPS = 9670, I_VBROADCASTF128 = 7672, I_VBROADCASTSD = 7658, I_VBROADCASTSS = 7644,
	I_VCMPEQPD = 5088, I_VCMPEQPS = 4686, I_VCMPEQSD = 5892, I_VCMPEQSS = 5490,
	I_VCMPEQ_OSPD = 5269, I_VCMPEQ_OSPS = 4867, I_VCMPEQ_OSSD = 6073, I_VCMPEQ_OSSS = 5671,
	I_VCMPEQ_UQPD = 5175, I_VCMPEQ_UQPS = 4773, I_VCMPEQ_UQSD = 5979, I_VCMPEQ_UQSS = 5577,
	I_VCMPEQ_USPD = 5378, I_VCMPEQ_USPS = 4976, I_VCMPEQ_USSD = 6182, I_VCMPEQ_USSS = 5780,
	I_VCMPFALSEPD = 5210, I_VCMPFALSEPS = 4808, I_VCMPFALSESD = 6014, I_VCMPFALSESS = 5612,
	I_VCMPFALSE_OSPD = 5419, I_VCMPFALSE_OSPS = 5017, I_VCMPFALSE_OSSD = 6223,
	I_VCMPFALSE_OSSS = 5821, I_VCMPGEPD = 5237, I_VCMPGEPS = 4835, I_VCMPGESD = 6041,
	I_VCMPGESS = 5639, I_VCMPGE_OQPD = 5449, I_VCMPGE_OQPS = 5047, I_VCMPGE_OQSD = 6253,
	I_VCMPGE_OQSS = 5851, I_VCMPGTPD = 5247, I_VCMPGTPS = 4845, I_VCMPGTSD = 6051,
	I_VCMPGTSS = 5649, I_VCMPGT_OQPD = 5462, I_VCMPGT_OQPS = 5060, I_VCMPGT_OQSD = 6266,
	I_VCMPGT_OQSS = 5864, I_VCMPLEPD = 5108, I_VCMPLEPS = 4706, I_VCMPLESD = 5912,
	I_VCMPLESS = 5510, I_VCMPLE_OQPD = 5295, I_VCMPLE_OQPS = 4893, I_VCMPLE_OQSD = 6099,
	I_VCMPLE_OQSS = 5697, I_VCMPLTPD = 5098, I_VCMPLTPS = 4696, I_VCMPLTSD = 5902,
	I_VCMPLTSS = 5500, I_VCMPLT_OQPD = 5282, I_VCMPLT_OQPS = 4880, I_VCMPLT_OQSD = 6086,
	I_VCMPLT_OQSS = 5684, I_VCMPNEQPD = 5131, I_VCMPNEQPS = 4729, I_VCMPNEQSD = 5935,
	I_VCMPNEQSS = 5533, I_VCMPNEQ_OQPD = 5223, I_VCMPNEQ_OQPS = 4821, I_VCMPNEQ_OQSD = 6027,
	I_VCMPNEQ_OQSS = 5625, I_VCMPNEQ_OSPD = 5435, I_VCMPNEQ_OSPS = 5033, I_VCMPNEQ_OSSD = 6239,
	I_VCMPNEQ_OSSS = 5837, I_VCMPNEQ_USPD = 5323, I_VCMPNEQ_USPS = 4921, I_VCMPNEQ_USSD = 6127,
	I_VCMPNEQ_USSS = 5725, I_VCMPNGEPD = 5188, I_VCMPNGEPS = 4786, I_VCMPNGESD = 5992,
	I_VCMPNGESS = 5590, I_VCMPNGE_UQPD = 5391, I_VCMPNGE_UQPS = 4989, I_VCMPNGE_UQSD = 6195,
	I_VCMPNGE_UQSS = 5793, I_VCMPNGTPD = 5199, I_VCMPNGTPS = 4797, I_VCMPNGTSD = 6003,
	I_VCMPNGTSS = 5601, I_VCMPNGT_UQPD = 5405, I_VCMPNGT_UQPS = 5003, I_VCMPNGT_UQSD = 6209,
	I_VCMPNGT_UQSS = 5807, I_VCMPNLEPD = 5153, I_VCMPNLEPS = 4751, I_VCMPNLESD = 5957,
	I_VCMPNLESS = 5555, I_VCMPNLE_UQPD = 5351, I_VCMPNLE_UQPS = 4949, I_VCMPNLE_UQSD = 6155,
	I_VCMPNLE_UQSS = 5753, I_VCMPNLTPD = 5142, I_VCMPNLTPS = 4740, I_VCMPNLTSD = 5946,
	I_VCMPNLTSS = 5544, I_VCMPNLT_UQPD = 5337, I_VCMPNLT_UQPS = 4935, I_VCMPNLT_UQSD = 6141,
	I_VCMPNLT_UQSS = 5739, I_VCMPORDPD = 5164, I_VCMPORDPS = 4762, I_VCMPORDSD = 5968,
	I_VCMPORDSS = 5566, I_VCMPORD_SPD = 5365, I_VCMPORD_SPS = 4963, I_VCMPORD_SSD = 6169,
	I_VCMPORD_SSS = 5767, I_VCMPTRUEPD = 5257, I_VCMPTRUEPS = 4855, I_VCMPTRUESD = 6061,
	I_VCMPTRUESS = 5659, I_VCMPTRUE_USPD = 5475, I_VCMPTRUE_USPS = 5073, I_VCMPTRUE_USSD = 6279,
	I_VCMPTRUE_USSS = 5877, I_VCMPUNORDPD = 5118, I_VCMPUNORDPS = 4716, I_VCMPUNORDSD = 5922,
	I_VCMPUNORDSS = 5520, I_VCMPUNORD_SPD = 5308, I_VCMPUNORD_SPS = 4906, I_VCMPUNORD_SSD = 6112,
	I_VCMPUNORD_SSS = 5710, I_VCOMISD = 2796, I_VCOMISS = 2787, I_VCVTDQ2PD = 6819,
	I_VCVTDQ2PS = 3338, I_VCVTPD2DQ = 6830, I_VCVTPD2PS = 3274, I_VCVTPS2DQ = 3349,
	I_VCVTPS2PD = 3263, I_VCVTSD2SI = 2722, I_VCVTSD2SS = 3296, I_VCVTSI2SD = 2536,
	I_VCVTSI2SS = 2525, I_VCVTSS2SD = 3285, I_VCVTSS2SI = 2711, I_VCVTTPD2DQ = 6807,
	I_VCVTTPS2DQ = 3360, I_VCVTTSD2SI = 2659, I_VCVTTSS2SI = 2647, I_VDIVPD = 3528,
	I_VDIVPS = 3520, I_VDIVSD = 3544, I_VDIVSS = 3536, I_VDPPD = 9621, I_VDPPS = 9608,
	I_VERR = 1663, I_VERW = 1669, I_VEXTRACTF128 = 9516, I_VEXTRACTPS = 9491,
	I_VFMADD132PD = 8387, I_VFMADD132PS = 8374, I_VFMADD132SD = 8413, I_VFMADD132SS = 8400,
	I_VFMADD213PD = 8667, I_VFMADD213PS = 8654, I_VFMADD213SD = 8693, I_VFMADD213SS = 8680,
	I_VFMADD231PD = 8947, I_VFMADD231PS = 8934, I_VFMADD231SD = 8973, I_VFMADD231SS = 8960,
	I_VFMADDSUB132PD = 8326, I_VFMADDSUB132PS = 8310, I_VFMADDSUB213PD = 8606,
	I_VFMADDSUB213PS = 8590, I_VFMADDSUB231PD = 8886, I_VFMADDSUB231PS = 8870,
	I_VFMSUB132PD = 8439, I_VFMSUB132PS = 8426, I_VFMSUB132SD = 8465, I_VFMSUB132SS = 8452,
	I_VFMSUB213PD = 8719, I_VFMSUB213PS = 8706, I_VFMSUB213SD = 8745, I_VFMSUB213SS = 8732,
	I_VFMSUB231PD = 8999, I_VFMSUB231PS = 8986, I_VFMSUB231SD = 9025, I_VFMSUB231SS = 9012,
	I_VFMSUBADD132PD = 8358, I_VFMSUBADD132PS = 8342, I_VFMSUBADD213PD = 8638,
	I_VFMSUBADD213PS = 8622, I_VFMSUBADD231PD = 8918, I_VFMSUBADD231PS = 8902,
	I_VFNMADD132PD = 8492, I_VFNMADD132PS = 8478, I_VFNMADD132SD = 8520, I_VFNMADD132SS = 8506,
	I_VFNMADD213PD = 8772, I_VFNMADD213PS = 8758, I_VFNMADD213SD = 8800, I_VFNMADD213SS = 8786,
	I_VFNMADD231PD = 9052, I_VFNMADD231PS = 9038, I_VFNMADD231SD = 9080, I_VFNMADD231SS = 9066,
	I_VFNMSUB132PD = 8548, I_VFNMSUB132PS = 8534, I_VFNMSUB132SD = 8576, I_VFNMSUB132SS = 8562,
	I_VFNMSUB213PD = 8828, I_VFNMSUB213PS = 8814, I_VFNMSUB213SD = 8856, I_VFNMSUB213SS = 8842,
	I_VFNMSUB231PD = 9108, I_VFNMSUB231PS = 9094, I_VFNMSUB231SD = 9136, I_VFNMSUB231SS = 9122,
	I_VHADDPD = 4197, I_VHADDPS = 4206, I_VHSUBPD = 4231, I_VHSUBPS = 4240, I_VINSERTF128 = 9503,
	I_VINSERTPS = 9557, I_VLDDQU = 7001, I_VLDMXCSR = 9941, I_VMASKMOVDQU = 7131,
	I_VMASKMOVPD = 7949, I_VMASKMOVPS = 7937, I_VMAXPD = 3588, I_VMAXPS = 3580,
	I_VMAXSD = 3604, I_VMAXSS = 3596, I_VMCALL = 1719, I_VMCLEAR = 9997, I_VMFUNC = 1787,
	I_VMINPD = 3468, I_VMINPS = 3460, I_VMINSD = 3484, I_VMINSS = 3476, I_VMLAUNCH = 1727,
	I_VMLOAD = 1811, I_VMMCALL = 1802, I_VMOVAPD = 2476, I_VMOVAPS = 2467, I_VMOVD = 3932,
	I_VMOVDDUP = 2234, I_VMOVDQA = 3962, I_VMOVDQU = 3971, I_VMOVHLPS = 2195,
	I_VMOVHPD = 2382, I_VMOVHPS = 2373, I_VMOVLHPS = 2363, I_VMOVLPD = 2214, I_VMOVLPS = 2205,
	I_VMOVMSKPD = 2836, I_VMOVMSKPS = 2825, I_VMOVNTDQ = 6858, I_VMOVNTDQA = 7905,
	I_VMOVNTPD = 2593, I_VMOVNTPS = 2583, I_VMOVQ = 3939, I_VMOVSD = 2143, I_VMOVSHDUP = 2391,
	I_VMOVSLDUP = 2223, I_VMOVSS = 2135, I_VMOVUPD = 2126, I_VMOVUPS = 2117, I_VMPSADBW = 9637,
	I_VMPTRLD = 9988, I_VMPTRST = 6385, I_VMREAD = 4128, I_VMRESUME = 1737, I_VMRUN = 1795,
	I_VMSAVE = 1819, I_VMULPD = 3199, I_VMULPS = 3191, I_VMULSD = 3215, I_VMULSS = 3207,
	I_VMWRITE = 4152, I_VMXOFF = 1747, I_VMXON = 10006, I_VORPD = 3066, I_VORPS = 3059,
	I_VPABSB = 7695, I_VPABSD = 7725, I_VPABSW = 7710, I_VPACKSSDW = 3859, I_VPACKSSWB = 3691,
	I_VPACKUSDW = 7926, I_VPACKUSWB = 3769, I_VPADDB = 7211, I_VPADDD = 7241,
	I_VPADDQ = 6488, I_VPADDSB = 6938, I_VPADDSW = 6955, I_VPADDUSW = 6629, I_VPADDW = 7226,
	I_VPALIGNR = 9419, I_VPAND = 6613, I_VPANDN = 6672, I_VPAVGB = 6687, I_VPAVGW = 6732,
	I_VPBLENDVB = 9692, I_VPBLENDW = 9400, I_VPCLMULQDQ = 9658, I_VPCMPEQB = 4052,
	I_VPCMPEQD = 4090, I_VPCMPEQQ = 7885, I_VPCMPEQW = 4071, I_VPCMPESTRI = 9737,
	I_VPCMPESTRM = 9714, I_VPCMPGTB = 3711, I_VPCMPGTD = 3749, I_VPCMPGTQ = 8096,
	I_VPCMPGTW = 3730, I_VPCMPISTRI = 9783, I_VPCMPISTRM = 9760, I_VPERM2F128 = 9265,
	I_VPERMILPD = 7570, I_VPERMILPS = 7559, I_VPEXTRB = 9437, I_VPEXTRD = 9462,
	I_VPEXTRQ = 9471, I_VPEXTRW = 6319, I_VPHADDD = 7383, I_VPHADDSW = 7401, I_VPHADDW = 7366,
	I_VPHMINPOSUW = 8271, I_VPHSUBD = 7459, I_VPHSUBSW = 7477, I_VPHSUBW = 7442,
	I_VPINSRB = 9538, I_VPINSRD = 9584, I_VPINSRQ = 9593, I_VPINSRW = 6302, I_VPMADDUBSW = 7422,
	I_VPMADDWD = 7082, I_VPMAXSB = 8182, I_VPMAXSD = 8199, I_VPMAXSW = 6972, I_VPMAXUB = 6656,
	I_VPMAXUD = 8233, I_VPMAXUW = 8216, I_VPMINSB = 8114, I_VPMINSD = 8131, I_VPMINSW = 6910,
	I_VPMINUB = 6598, I_VPMINUD = 8165, I_VPMINUW = 8148, I_VPMOVMSKB = 6541,
	I_VPMOVSXBD = 7764, I_VPMOVSXBQ = 7785, I_VPMOVSXBW = 7743, I_VPMOVSXDQ = 7848,
	I_VPMOVSXWD = 7806, I_VPMOVSXWQ = 7827, I_VPMOVZXBD = 7992, I_VPMOVZXBQ = 8013,
	I_VPMOVZXBW = 7971, I_VPMOVZXDQ = 8076, I_VPMOVZXWD = 8034, I_VPMOVZXWQ = 8055,
	I_VPMULDQ = 7867, I_VPMULHRSW = 7548, I_VPMULHUW = 6749, I_VPMULHW = 6767,
	I_VPMULLD = 8250, I_VPMULLW = 6504, I_VPMULUDQ = 7063, I_VPOR = 6924, I_VPSADBW = 7100,
	I_VPSHUFB = 7349, I_VPSHUFD = 4014, I_VPSHUFHW = 4023, I_VPSHUFLW = 4033,
	I_VPSIGNB = 7495, I_VPSIGND = 7529, I_VPSIGNW = 7512, I_VPSLLD = 7031, I_VPSLLDQ = 9855,
	I_VPSLLQ = 7046, I_VPSLLW = 7016, I_VPSRAD = 6717, I_VPSRAW = 6702, I_VPSRLD = 6458,
	I_VPSRLDQ = 9838, I_VPSRLQ = 6473, I_VPSRLW = 6443, I_VPSUBB = 7151, I_VPSUBD = 7181,
	I_VPSUBQ = 7196, I_VPSUBSB = 6876, I_VPSUBSW = 6893, I_VPSUBUSB = 6561, I_VPSUBUSW = 6580,
	I_VPSUBW = 7166, I_VPTEST = 7636, I_VPUNPCKHBW = 3791, I_VPUNPCKHDQ = 3837,
	I_VPUNPCKHQDQ = 3907, I_VPUNPCKHWD = 3814, I_VPUNPCKLBW = 3623, I_VPUNPCKLDQ = 3669,
	I_VPUNPCKLQDQ = 3882, I_VPUNPCKLWD = 3646, I_VPXOR = 6987, I_VRCPPS = 2967,
	I_VRCPSS = 2975, I_VROUNDPD = 9305, I_VROUNDPS = 9286, I_VROUNDSD = 9343,
	I_VROUNDSS = 9324, I_VRSQRTPS = 2933, I_VRSQRTSS = 2943, I_VSHUFPD = 6353,
	I_VSHUFPS = 6344, I_VSQRTPD = 2888, I_VSQRTPS = 2879, I_VSQRTSD = 2906, I_VSQRTSS = 2897,
	I_VSTMXCSR = 9970, I_VSUBPD = 3408, I_VSUBPS = 3400, I_VSUBSD = 3424, I_VSUBSS = 3416,
	I_VTESTPD = 7590, I_VTESTPS = 7581, I_VUCOMISD = 2761, I_VUCOMISS = 2751,
	I_VUNPCKHPD = 2317, I_VUNPCKHPS = 2306, I_VUNPCKLPD = 2275, I_VUNPCKLPS = 2264,
	I_VXORPD = 3095, I_VXORPS = 3087, I_VZEROALL = 4118, I_VZEROUPPER = 4106,
	I_WAIT = 10028, I_WBINVD = 561, I_WRFSBASE = 9931, I_WRGSBASE = 9960, I_WRMSR = 586,
	I_XADD = 946, I_XCHG = 212, I_XGETBV = 1771, I_XLAT = 400, I_XOR = 61, I_XORPD = 3080,
	I_XORPS = 3073, I_XRSTOR = 4273, I_XRSTOR64 = 4281, I_XSAVE = 4249, I_XSAVE64 = 4256,
	I_XSAVEOPT = 4299, I_XSAVEOPT64 = 4309, I_XSETBV = 1779, I__3DNOW = 10034
} _InstructionType;

typedef enum {
	R_RAX, R_RCX, R_RDX, R_RBX, R_RSP, R_RBP, R_RSI, R_RDI, R_R8, R_R9, R_R10, R_R11, R_R12, R_R13, R_R14, R_R15,
	R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI, R_R8D, R_R9D, R_R10D, R_R11D, R_R12D, R_R13D, R_R14D, R_R15D,
	R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI, R_R8W, R_R9W, R_R10W, R_R11W, R_R12W, R_R13W, R_R14W, R_R15W,
	R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH, R_R8B, R_R9B, R_R10B, R_R11B, R_R12B, R_R13B, R_R14B, R_R15B,
	R_SPL, R_BPL, R_SIL, R_DIL,
	R_ES, R_CS, R_SS, R_DS, R_FS, R_GS,
	R_RIP,
	R_ST0, R_ST1, R_ST2, R_ST3, R_ST4, R_ST5, R_ST6, R_ST7,
	R_MM0, R_MM1, R_MM2, R_MM3, R_MM4, R_MM5, R_MM6, R_MM7,
	R_XMM0, R_XMM1, R_XMM2, R_XMM3, R_XMM4, R_XMM5, R_XMM6, R_XMM7, R_XMM8, R_XMM9, R_XMM10, R_XMM11, R_XMM12, R_XMM13, R_XMM14, R_XMM15,
	R_YMM0, R_YMM1, R_YMM2, R_YMM3, R_YMM4, R_YMM5, R_YMM6, R_YMM7, R_YMM8, R_YMM9, R_YMM10, R_YMM11, R_YMM12, R_YMM13, R_YMM14, R_YMM15,
	R_CR0, R_UNUSED0, R_CR2, R_CR3, R_CR4, R_UNUSED1, R_UNUSED2, R_UNUSED3, R_CR8,
	R_DR0, R_DR1, R_DR2, R_DR3, R_UNUSED4, R_UNUSED5, R_DR6, R_DR7
} _RegisterType;

#endif /* MNEMONICS_H */



================================================
File: src/sigmake/distorm/operands.c
================================================
/*
operands.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "config.h"
#include "operands.h"
#include "x86defs.h"
#include "insts.h"
#include "mnemonics.h"


/* Maps a register to its register-class mask. */
uint16_t _REGISTERTORCLASS[] = /* Based on _RegisterType enumeration! */
{RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, 0, 0, 0, 0, 0, 0, 0, 0,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, 0, 0, 0, 0, 0, 0, 0, 0,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, 0, 0, 0, 0, 0, 0, 0, 0,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_AX, RM_CX, RM_DX, RM_BX, 0, 0, 0, 0, 0, 0, 0, 0,
 RM_SP, RM_BP, RM_SI, RM_DI,
 0, 0, 0, 0, 0, 0,
 0,
 RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU,
 RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX,
 RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE,
 RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX,
 RM_CR, 0, RM_CR, RM_CR, RM_CR, 0, 0, 0, RM_CR,
 RM_DR, RM_DR, RM_DR, RM_DR, 0, 0, RM_DR, RM_DR
};

typedef enum {OPERAND_SIZE_NONE = 0, OPERAND_SIZE8, OPERAND_SIZE16, OPERAND_SIZE32, OPERAND_SIZE64, OPERAND_SIZE80, OPERAND_SIZE128, OPERAND_SIZE256} _OperandSizeType;
static uint16_t _OPSIZETOINT[] = {0, 8, 16, 32, 64, 80, 128, 256};

/* A helper function to fix the 8 bits register if REX is used (to support SIL, DIL, etc). */
static unsigned int _FASTCALL_ operands_fix_8bit_rex_base(unsigned int reg)
{
	if ((reg >= 4) && (reg < 8)) return reg + REGS8_REX_BASE - 4;
	return reg + REGS8_BASE;
}

/* A helper function to set operand's type and size. */
static void _FASTCALL_ operands_set_ts(_Operand* op, _OperandType type, uint16_t size)
{
	op->type = type;
	op->size = size;
}

/* A helper function to set operand's type, size and index. */
static void _FASTCALL_ operands_set_tsi(_Operand* op, _OperandType type, uint16_t size, unsigned int index)
{
	op->type = type;
	op->index = (uint8_t)index;
	op->size = size;
}

/* A helper function to read an unsigned integer from the stream safely. */
static int _FASTCALL_ read_stream_safe_uint(_CodeInfo* ci, void* result, unsigned int size)
{
	ci->codeLen -= size;
	if (ci->codeLen < 0) return FALSE;
	switch (size)
	{
		case 1: *(uint8_t*)result = *(uint8_t*)ci->code; break;
		case 2: *(uint16_t*)result = RUSHORT(ci->code); break;
		case 4: *(uint32_t*)result = RULONG(ci->code); break;
		case 8: *(uint64_t*)result = RULLONG(ci->code); break;
	}
	ci->code += size;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
static int _FASTCALL_ read_stream_safe_sint(_CodeInfo* ci, int64_t* result, unsigned int size)
{
	ci->codeLen -= size;
	if (ci->codeLen < 0) return FALSE;
	switch (size)
	{
		case 1: *result = *(int8_t*)ci->code; break;
		case 2: *result = RSHORT(ci->code); break;
		case 4: *result = RLONG(ci->code); break;
		case 8: *result = RLLONG(ci->code); break;
	}
	ci->code += size;
	return TRUE;
}

/*
 * SIB decoding is the most confusing part when decoding IA-32 instructions.
 * This explanation should clear up some stuff.
 *
 * ! When base == 5, use EBP as the base register !
 * if (rm == 4) {
 *	if mod == 01, decode SIB byte and ALSO read a 8 bits displacement.
 *	if mod == 10, decode SIB byte and ALSO read a 32 bits displacement.
 *	if mod == 11 <-- EXCEPTION, this is a general-purpose register and mustn't lead to SIB decoding!
 *	; So far so good, now the confusing part comes in with mod == 0 and base=5, but no worry.
 *	if (mod == 00) {
 *	 decode SIB byte WITHOUT any displacement.
 *	 EXCEPTION!!! when base == 5, read a 32 bits displacement, but this time DO NOT use (EBP) BASE at all!
 *	}
 *
 *	NOTE: base could specify None (no base register) if base==5 and mod==0, but then you also need DISP32.
 * }
 */
static void operands_extract_sib(_DInst* di, _OperandNumberType opNum,
                                 _PrefixState* ps, _DecodeType effAdrSz,
                                 unsigned int sib, unsigned int mod)
{
	unsigned int scale = 0, index = 0, base = 0;
	unsigned int vrex = ps->vrex;
	uint8_t* pIndex = NULL;

	_Operand* op = &di->ops[opNum];

	/*
	 * SIB bits:
	 * |7---6-5----3-2---0|
	 * |SCALE| INDEX| BASE|
	 * |------------------|
	 */
	scale = (sib >> 6) & 3;
	index = (sib >> 3) & 7;
	base = sib & 7;

	/*
	 * The following fields: base/index/scale/disp8/32 are ALL optional by specific rules!
	 * The idea here is to keep the indirection as a simple-memory type.
	 * Because the base is optional, and we might be left with only one index.
	 * So even if there's a base but no index, or vice versa, we end up with one index register.
	 */

	/* In 64 bits the REX prefix might affect the index of the SIB byte. */
	if (vrex & PREFIX_EX_X) {
		ps->usedPrefixes |= INST_PRE_REX;
		index += EX_GPR_BASE;
	}

	if (index == 4) { /* No index is used. Use SMEM. */
		op->type = O_SMEM;
		pIndex = &op->index;
	} else {
		op->type = O_MEM;
		pIndex = &di->base;
		/* No base, unless it is updated below. E.G: [EAX*4] has no base reg. */
	}

	if (base != 5) {
		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		*pIndex = effAdrSz == Decode64Bits ? REGS64_BASE : REGS32_BASE;
		*pIndex += (uint8_t)(base + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));
	} else if (mod != 0) {
		/*
		 * if base == 5 then you have to decode according to MOD.
		 * mod(00) - disp32.
		 * mod(01) - disp8 + rBP
		 * mod(10) - disp32 + rBP
		 * mod(11) - not possible, it's a general-purpose register.
		 */

		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		if (effAdrSz == Decode64Bits) *pIndex = REGS64_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);
		else *pIndex = REGS32_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);
	} else if (index == 4) {
		 /* 32bits displacement only. */
		op->type = O_DISP;
		return;
	}

	if (index != 4) { /* In 64 bits decoding mode, if index == R12, it's valid! */
		if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + index);
		else op->index = (uint8_t)(REGS32_BASE + index);
		di->scale = scale != 0 ? (1 << scale) : 0;
	}
}

/*
 * This seems to be the hardest part in decoding the operands.
 * If you take a look carefully at Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte,
 * you will understand it's easy to decode the operands.

 * First we check the DT, so we can decide according to which Table in the documentation we are supposed to decode.
 * Then we follow the specific table whether it's 16 bits or 32/64 bits.

 * Don't forget that Operand Size AND Address Size prefixes may change the decoding!

 * Some instructions force the use of RM16 or other specific types, so take it into account.
 */
static int operands_extract_modrm(_CodeInfo* ci,
                                  _DInst* di, _OpType type,
                                  _OperandNumberType opNum, _PrefixState* ps,
                                  _DecodeType effOpSz, _DecodeType effAdrSz,
                                  int* lockableInstruction, unsigned int mod, unsigned int rm,
                                  _iflags instFlags)
{
	unsigned int vrex = ps->vrex, sib = 0, base = 0;
	_Operand* op = &di->ops[opNum];
	uint16_t size = 0;

	if (mod == 3) {
		/*
		 * General-purpose register is handled the same way in 16/32/64 bits decoding modes.
		 * NOTE!! that we have to override the size of the register, since it was set earlier as Memory and not Register!
		 */
		op->type = O_REG;
		/* Start with original size which was set earlier, some registers have same size of memory and depend on it. */
		size = op->size;
		switch(type)
		{
			case OT_RFULL_M16:
			case OT_RM_FULL:
				switch (effOpSz)
				{
					case Decode16Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							rm += EX_GPR_BASE;
						}
						size = 16;
						rm += REGS16_BASE;
					break;
					case Decode32Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							rm += EX_GPR_BASE;
						}
						size = 32;
						rm += REGS32_BASE;
					break;
					case Decode64Bits:
						/* A fix for SMSW RAX which use the REX prefix. */
						if (type == OT_RFULL_M16) ps->usedPrefixes |= INST_PRE_REX;
						/* CALL NEAR/PUSH/POP defaults to 64 bits. --> INST_64BITS, REX isn't required, thus ignored anyways. */
						if (instFlags & INST_PRE_REX) ps->usedPrefixes |= INST_PRE_REX;
						/* Include REX if used for REX.B. */
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							rm += EX_GPR_BASE;
						}
						size = 64;
						rm += REGS64_BASE;
					break;
				}
			break;
			case OT_R32_64_M8:
			/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_R32_64_M16:
			/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_RM32_64: /* Take care specifically in MOVNTI/MOVD/CVT's instructions, making it _REG64 with REX or if they are promoted. */
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
				if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
					size = 64;
					rm += REGS64_BASE;
					break;
				}
				/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
				if (vrex & PREFIX_EX_W) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 64;
					rm += REGS64_BASE;
				} else {
					size = 32;
					rm += REGS32_BASE;
				}
			break;
			case OT_RM16_32: /* Used only with MOVZXD instruction to support 16 bits operand. */
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it 16 bits operand size? */
				if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
					rm += REGS16_BASE;
				} else {
					size = 32;
					rm += REGS32_BASE;
				}
			break;
			case OT_RM16:
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				rm += REGS16_BASE;
			break;
			case OT_RM8:
				if (ps->prefixExtType == PET_REX) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm = operands_fix_8bit_rex_base(rm + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));
				} else rm += REGS8_BASE;
			break;
			case OT_MM32:
			case OT_MM64:
				/* MMX doesn't support extended registers. */
				size = 64;
				rm += MMXREGS_BASE;
			break;

			case OT_XMM16:
			case OT_XMM32:
			case OT_XMM64:
			case OT_XMM128:
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 128;
				rm += SSEREGS_BASE;
			break;

			case OT_RM32:
			case OT_R32_M8:
			case OT_R32_M16:
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 32;
				rm += REGS32_BASE;
			break;

			case OT_YMM256:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				rm += AVXREGS_BASE;
			break;
			case OT_YXMM64_256:
			case OT_YXMM128_256:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (vrex & PREFIX_EX_L) {
					size = 256;
					rm += AVXREGS_BASE;
				} else {
					size = 128;
					rm += SSEREGS_BASE;
				}
			break;
			case OT_WXMM32_64:
			case OT_LXMM64_128:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				size = 128;
				rm += SSEREGS_BASE;
			break;

			case OT_WRM32_64:
			case OT_REG32_64_M8:
			case OT_REG32_64_M16:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (vrex & PREFIX_EX_W) {
					size = 64;
					rm += REGS64_BASE;
				} else {
					size = 32;
					rm += REGS32_BASE;
				}
			break;

			default: return FALSE;
		}
		op->size = size;
		op->index = (uint8_t)rm;
		return TRUE;
	}

	/* Memory indirection decoding ahead:) */

	ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
	if (lockableInstruction && (ps->decodedPrefixes & INST_PRE_LOCK)) *lockableInstruction = TRUE;

	if (effAdrSz == Decode16Bits) {
		/* Decoding according to Table 2-1. (16 bits) */
		if ((mod == 0) && (rm == 6)) {
			/* 6 is a special case - only 16 bits displacement. */
			op->type = O_DISP;
			di->dispSize = 16;
			if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int16_t))) return FALSE;
		} else {
			/*
			 * Create the O_MEM for 16 bits indirection that requires 2 registers, E.G: [BS+SI].
			 * or create O_SMEM for a single register indirection, E.G: [BP].
			 */
			static uint8_t MODS[] = {R_BX, R_BX, R_BP, R_BP, R_SI, R_DI, R_BP, R_BX};
			static uint8_t MODS2[] = {R_SI, R_DI, R_SI, R_DI};
			if (rm < 4) {
				op->type = O_MEM;
				di->base = MODS[rm];
				op->index = MODS2[rm];
			} else {
				op->type = O_SMEM;
				op->index = MODS[rm];
			}

			if (mod == 1) { /* 8 bits displacement + indirection */
				di->dispSize = 8;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int8_t))) return FALSE;
			} else if (mod == 2) { /* 16 bits displacement + indirection */
				di->dispSize = 16;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int16_t))) return FALSE;
			}
		}

		if ((rm == 2) || (rm == 3) || ((rm == 6) && (mod != 0))) {
			/* BP's default segment is SS, so ignore it. */
			prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
		} else {
			/* Ignore default DS segment. */
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
	} else { /* Decode32Bits or Decode64Bits! */
		/* Remember that from a 32/64 bits ModR/M byte a SIB byte could follow! */
		if ((mod == 0) && (rm == 5)) {

			/* 5 is a special case - only 32 bits displacement, or RIP relative. */
			di->dispSize = 32;
			if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int32_t))) return FALSE;

			if (ci->dt == Decode64Bits) {
				/* In 64 bits decoding mode depsite of the address size, a RIP-relative address it is. */
				op->type = O_SMEM;
				op->index = R_RIP;
				di->flags |= FLAG_RIP_RELATIVE;
			} else {
				/* Absolute address: */
				op->type = O_DISP;
			}
		} else {
			if (rm == 4) {
				/* 4 is a special case - SIB byte + disp8/32 follows! */
				/* Read SIB byte. */
				if (!read_stream_safe_uint(ci, &sib, sizeof(int8_t))) return FALSE;
				operands_extract_sib(di, opNum, ps, effAdrSz, sib, mod);
			} else {
				op->type = O_SMEM;
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}

				if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + rm);
				else op->index = (uint8_t)(REGS32_BASE + rm);
			}

			if (mod == 1) {
				di->dispSize = 8;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int8_t))) return FALSE;
			} else if ((mod == 2) || ((sib & 7) == 5)) { /* If there is no BASE, read DISP32! */
				di->dispSize = 32;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int32_t))) return FALSE;
			}
		}

		/* Get the base register. */
		base = op->index;
		if (di->base != R_NONE) base = di->base;
		else if (di->scale >= 2) base = 0; /* If it's only an index but got scale, it's still DS. */
		/* Default for EBP/ESP is SS segment. 64 bits mode ignores DS anyway. */
		if ((base == R_EBP) || (base == R_ESP)) prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
		else prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
	}

	return TRUE;
}


/*
 * This function is reponsible to textually format a required operand according to its type.
 * It is vital to understand that there are other operands than what the ModR/M byte specifies.

 * Only by decoding the operands of an instruction which got a LOCK prefix, we could tell whether it may use the LOCK prefix.
 * According to Intel, LOCK prefix must precede some specific instructions AND in their memory destination operand form (which means first operand).
 * LOCK INC EAX, would generate an exception, but LOCK INC [EAX] is alright.
 * Also LOCK ADD BX, [BP] would generate an exception.

 * Return code:
 * TRUE - continue parsing the instruction and its operands, everything went right 'till now.
 * FALSE - not enough bytes, or invalid operands.
 */

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type, _OperandNumberType opNum,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, int* lockableInstruction)
{
	int ret = 0;
	unsigned int mod = 0, reg = 0, rm = 0, vexV = ps->vexV;
	unsigned int vrex = ps->vrex, typeHandled = TRUE;
	_Operand* op = &di->ops[opNum];

	/* Used to indicate the size of the MEMORY INDIRECTION only. */
	_OperandSizeType opSize = OPERAND_SIZE_NONE;

	/*
	 * ModRM bits:
	 * |7-6-5--------3-2-0|
	 * |MOD|REG/OPCODE|RM |
	 * |------------------|
	 */
	mod = (modrm >> 6) & 3; /* Mode(register-indirection, disp8+reg+indirection, disp16+reg+indirection, general-purpose register) */
	reg = (modrm >> 3) & 7; /* Register(could be part of the opcode itself or general-purpose register) */
	rm = modrm & 7; /* Specifies which general-purpose register or disp+reg to use. */

	/* -- Memory Indirection Operands (that cannot be a general purpose register) -- */
	switch (type)
	{
		case OT_MEM64_128: /* Used only by CMPXCHG8/16B. */
			/* Make a specific check when the type is OT_MEM64_128 since the lockable CMPXCHG8B uses this one... */
			if (lockableInstruction && (ps->decodedPrefixes & INST_PRE_LOCK)) *lockableInstruction = TRUE;
			if (effOpSz == Decode64Bits) {
				ps->usedPrefixes |= INST_PRE_REX;
				opSize = OPERAND_SIZE128;
			} else opSize = OPERAND_SIZE64;
		break;
		case OT_MEM32: opSize = OPERAND_SIZE32; break;
		case OT_MEM32_64:
			/* Used by MOVNTI. Default size is 32bits, 64bits with REX. */
			if (effOpSz == Decode64Bits) {
				ps->usedPrefixes |= INST_PRE_REX;
				opSize = OPERAND_SIZE64;
			} else opSize = OPERAND_SIZE32;
		break;
		case OT_MEM64: opSize = OPERAND_SIZE64; break;
		case OT_MEM128: opSize = OPERAND_SIZE128; break;
		case OT_MEM16_FULL: /* The size indicates about the second item of the pair. */
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					opSize = OPERAND_SIZE16;
				break;
				case Decode32Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					opSize = OPERAND_SIZE32;
				break;
				case Decode64Bits:
					/* Mark usage of REX only if it was required. */
					if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) ps->usedPrefixes |= INST_PRE_REX;
					opSize = OPERAND_SIZE64;
				break;
			}
		break;
		case OT_MEM16_3264: /* The size indicates about the second item of the pair. */
			if (ci->dt == Decode64Bits) opSize = OPERAND_SIZE64;
			else opSize = OPERAND_SIZE32;
		break;
		case OT_MEM_OPT:
			/* Since the MEM is optional, only when mod != 3, then return true as if the operand was alright. */
			if (mod == 0x3) return TRUE;
		break;
		case OT_FPUM16: opSize = OPERAND_SIZE16; break;
		case OT_FPUM32: opSize = OPERAND_SIZE32; break;
		case OT_FPUM64: opSize = OPERAND_SIZE64; break;
		case OT_FPUM80: opSize = OPERAND_SIZE80; break;
		case OT_LMEM128_256:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE256;
			else opSize = OPERAND_SIZE128;
		break;
		case OT_MEM: /* Size is unknown, but still handled. */ break;
		default: typeHandled = FALSE; break;
	}
	if (typeHandled) {
		/* All of the above types can't use a general-purpose register (a MOD of 3)!. */
		if (mod == 0x3) {
			if (lockableInstruction) *lockableInstruction = FALSE;
			return FALSE;
		}
		op->size = _OPSIZETOINT[opSize];
		ret = operands_extract_modrm(ci, di, type, opNum, ps, effOpSz, effAdrSz, lockableInstruction, mod, rm, instFlags);
		if ((op->type == O_REG) || (op->type == O_SMEM) || (op->type == O_MEM)) {
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		}
		return ret;
	}

	/* -- Memory Indirection Operands (that can be a register) -- */
	typeHandled = TRUE;
	switch (type)
	{
		case OT_RM_FULL:
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* PUSH/JMP/CALL are automatically promoted to 64 bits! */
			if (effOpSz == Decode32Bits) {
				opSize = OPERAND_SIZE32;
				break;
			} else if (effOpSz == Decode64Bits) {
				/* Mark usage of REX only if it was required. */
				if ((instFlags & INST_64BITS) == 0) ps->usedPrefixes |= INST_PRE_REX;
				opSize = OPERAND_SIZE64;
				break;
			}
			/* FALL THROUGH BECAUSE dt==Decoded16Bits @-<----*/
		case OT_RM16:
			/* If we got here not from OT_RM16, then the prefix was used. */
			if (type != OT_RM16) ps->usedPrefixes |= INST_PRE_OP_SIZE;
			opSize = OPERAND_SIZE16;
		break;
		case OT_RM32_64:
			/* The default size is 32, which can be 64 with a REX only. */
			if (effOpSz == Decode64Bits) {
				opSize = OPERAND_SIZE64;
				/* Mark REX prefix as used if non-promoted instruction. */
				if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) {
					ps->usedPrefixes |= INST_PRE_REX;
				}
			} else opSize = OPERAND_SIZE32;
		break;
		case OT_RM16_32:
			/* Ignore REX, it's either 32 or 16 bits RM. */
			if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				/* Assume: We are in 64bits when we have this operand used. */
				opSize = OPERAND_SIZE16;
			} else opSize = OPERAND_SIZE32;
		break;
		case OT_WXMM32_64:
		case OT_WRM32_64:
			if (vrex & PREFIX_EX_W) opSize = OPERAND_SIZE64;
			else opSize = OPERAND_SIZE32;
		break;
		case OT_YXMM64_256:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE256;
			else opSize = OPERAND_SIZE64;
		break;
		case OT_YXMM128_256:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE256;
			else opSize = OPERAND_SIZE128;
		break;
		case OT_LXMM64_128:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE128;
			else opSize = OPERAND_SIZE64;
		break;
		case OT_RFULL_M16:
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			opSize = OPERAND_SIZE16;
		break;

		case OT_RM8:
		case OT_R32_M8:
		case OT_R32_64_M8:
		case OT_REG32_64_M8:
			opSize = OPERAND_SIZE8;
		break;

		case OT_XMM16:
		case OT_R32_M16:
		case OT_R32_64_M16:
		case OT_REG32_64_M16:
			opSize = OPERAND_SIZE16;
		break;

		case OT_RM32:
		case OT_MM32:
		case OT_XMM32:
			opSize = OPERAND_SIZE32;
		break;

		case OT_MM64:
		case OT_XMM64:
			opSize = OPERAND_SIZE64;
		break;

		case OT_XMM128: opSize = OPERAND_SIZE128; break;
		case OT_YMM256: opSize = OPERAND_SIZE256; break;
		default: typeHandled = FALSE; break;
	}
	if (typeHandled) {
		/* Fill size of memory dereference for operand. */
		op->size = _OPSIZETOINT[opSize];
		ret = operands_extract_modrm(ci, di, type, opNum, ps, effOpSz, effAdrSz, lockableInstruction, mod, rm, instFlags);
		if ((op->type == O_REG) || (op->type == O_SMEM) || (op->type == O_MEM)) {
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		}
		return ret;
	}

	/* Simple operand type (no ModRM byte). */
	switch (type)
	{
		case OT_IMM8:
			operands_set_ts(op, O_IMM, 8);
			if (!read_stream_safe_uint(ci, &di->imm.byte, sizeof(int8_t))) return FALSE;
		break;
		case OT_IMM_FULL: /* 16, 32 or 64, depends on prefixes. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				/* FALL THROUGH */
		case OT_IMM16: /* Force 16 bits imm. */
			operands_set_ts(op, O_IMM, 16);
			if (!read_stream_safe_uint(ci, &di->imm.word, sizeof(int16_t))) return FALSE;
		break;
			/*
			 * Extension: MOV imm64, requires REX.
			 * Make sure it needs the REX.
			 * REX must be present because op size function takes it into consideration.
			 */
			} else if ((effOpSz == Decode64Bits) &&
				        ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX))) {
				ps->usedPrefixes |= INST_PRE_REX;

				operands_set_ts(op, O_IMM, 64);
				if (!read_stream_safe_uint(ci, &di->imm.qword, sizeof(int64_t))) return FALSE;
				break;
			} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* FALL THROUGH BECAUSE dt==Decoded32Bits @-<----*/
		case OT_IMM32:
			op->type = O_IMM;
			if (ci->dt == Decode64Bits) {
				/* Imm32 is sign extended to 64 bits! */
				op->size = 64;
				di->flags |= FLAG_IMM_SIGNED;
				if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int32_t))) return FALSE;
			} else {
				op->size = 32;
				if (!read_stream_safe_uint(ci, &di->imm.dword, sizeof(int32_t))) return FALSE;
			}
		break;
		case OT_SEIMM8: /* Sign extended immediate. */
			/*
			 * PUSH SEIMM8 can be prefixed by operand size:
			 * Input stream: 66, 6a, 55
			 * 64bits DT: push small 55
			 * 32bits DT: push small 55
			 * 16bits DT: push large 55
			 * small/large indicates the size of the eSP pointer advancement.
			 * Check the instFlags (ii->flags) if it can be operand-size-prefixed and if the prefix exists.
			 */
			op->type = O_IMM;
			if ((instFlags & INST_PRE_OP_SIZE) && (ps->decodedPrefixes & INST_PRE_OP_SIZE)) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				switch (ci->dt)
				{
					case Decode16Bits: op->size = 32; break;
					case Decode32Bits:
					case Decode64Bits:
						op->size = 16;
					break;
				}
			} else op->size = 8;
			di->flags |= FLAG_IMM_SIGNED;
			if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int8_t))) return FALSE;
		break;
		case OT_IMM16_1:
			operands_set_ts(op, O_IMM1, 16);
			if (!read_stream_safe_uint(ci, &di->imm.ex.i1, sizeof(int16_t))) return FALSE;
		break;
		case OT_IMM8_1:
			operands_set_ts(op, O_IMM1, 8);
			if (!read_stream_safe_uint(ci, &di->imm.ex.i1, sizeof(int8_t))) return FALSE;
		break;
		case OT_IMM8_2:
			operands_set_ts(op, O_IMM2, 8);
			if (!read_stream_safe_uint(ci, &di->imm.ex.i2, sizeof(int8_t))) return FALSE;
		break;
		case OT_REG8:
			operands_set_ts(op, O_REG, 8);
			if (ps->prefixExtType) {
				/*
				 * If REX prefix is valid then we will have to use low bytes.
				 * This is a PASSIVE behaviour changer of REX prefix, it affects operands even if its value is 0x40 !
				 */
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + ((vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
			} else op->index = (uint8_t)(REGS8_BASE + reg);
		break;
		case OT_REG16:
			operands_set_tsi(op, O_REG, 16, REGS16_BASE + reg);
		break;
		case OT_REG_FULL:
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits: /* rex must be presented. */
					ps->usedPrefixes |= INST_PRE_REX;
					operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg + ((vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
				break;
			}
		break;
		case OT_REG32:
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_REG32_64: /* Handle CVT's, MOVxX and MOVNTI instructions which could be extended to 64 bits registers with REX. */
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}

			/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
			if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
				operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
			/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
			if (vrex & PREFIX_EX_W) {
				ps->usedPrefixes |= INST_PRE_REX;
				operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
			} else operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_FREG32_64_RM: /* Force decoding mode. Used for MOV CR(n)/DR(n) which defaults to 64 bits operand size in 64 bits. */
			if (vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}

			if (ci->dt == Decode64Bits) operands_set_tsi(op, O_REG, 64, REGS64_BASE + rm);
			else operands_set_tsi(op, O_REG, 32, REGS32_BASE + rm);
		break;
		case OT_MM: /* MMX register */
			operands_set_tsi(op, O_REG, 64, MMXREGS_BASE + reg);
		break;
		case OT_MM_RM: /* MMX register, this time from the RM field */
			operands_set_tsi(op, O_REG, 64, MMXREGS_BASE + rm);
		break;
		case OT_REGXMM0: /* Implicit XMM0 operand. */
			reg = 0;
			vrex = 0;
		/* FALL THROUGH */
		case OT_XMM: /* SSE register */
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_XMM_RM: /* SSE register, this time from the RM field */
			if (vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + rm);
		break;
		case OT_CREG:
			/*
			 * Don't parse if the reg exceeds the bounds of the array.
			 * Most of the CR's are not implemented, so if there's no matching string, the operand is invalid.
			 */
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			} else if ((ci->dt == Decode32Bits) && (ps->decodedPrefixes & INST_PRE_LOCK)) {
				/*
				 * NOTE: In 32 bits decoding mode,
				 * if the lock prefix is set before MOV CR(n) it will become the 4th bit of the REG field like REX.R in 64 bits.
				 */
				reg += EX_GPR_BASE;
				ps->usedPrefixes |= INST_PRE_LOCK;
			}
			/* Ignore some registers which do not exist. */
			if ((reg >= CREGS_MAX) || (reg == 1) || ((reg >= 5) && (reg <= 7))) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(CREGS_BASE + reg);
		break;
		case OT_DREG:
			/*
			 * In 64 bits there are 16 debug registers.
			 * but accessing any of dr8-15 which aren't implemented will cause an #ud.
			 */
			if ((reg == 4) || (reg == 5) || (vrex & PREFIX_EX_R)) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(DREGS_BASE + reg);
		break;
		case OT_SREG: /* Works with REG16 only! */
			/* If lockableInstruction pointer is non-null we know it's the first operand. */
			if (lockableInstruction && (reg == 1)) return FALSE; /* Can't MOV CS, <REG>. */
			/*Don't parse if the reg exceeds the bounds of the array. */
			if (reg <= SEG_REGS_MAX - 1) operands_set_tsi(op, O_REG, 16, SREGS_BASE + reg);
			else return FALSE;
		break;
		case OT_SEG:
			op->type = O_REG;
			/* Size of reg is always 16, it's up to caller to zero extend it to operand size. */
			op->size = 16;
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/*
			 * Extract the SEG from ii->flags this time!!!
			 * Check whether an operand size prefix is used.
			 */
			switch (instFlags & INST_PRE_SEGOVRD_MASK)
			{
				case INST_PRE_ES: op->index = R_ES; break;
				case INST_PRE_CS: op->index = R_CS; break;
				case INST_PRE_SS: op->index = R_SS; break;
				case INST_PRE_DS: op->index = R_DS; break;
				case INST_PRE_FS: op->index = R_FS; break;
				case INST_PRE_GS: op->index = R_GS; break;
			}
		break;
		case OT_ACC8:
			operands_set_tsi(op, O_REG, 8, R_AL);
		break;
		case OT_ACC16:
			operands_set_tsi(op, O_REG, 16, R_AX);
		break;
		case OT_ACC_FULL_NOT64: /* No REX.W support for IN/OUT. */
			vrex &= ~PREFIX_EX_W;
		case OT_ACC_FULL:
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(op, O_REG, 16, R_AX);
			} else if (effOpSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(op, O_REG, 32, R_EAX);
			} else { /* Decode64Bits */
				/* Only non-promoted instructions need REX in order to decode in 64 bits. */
				/* MEM-OFFSET MOV's are NOT automatically promoted to 64 bits. */
				if (~instFlags & INST_64BITS) {
					ps->usedPrefixes |= INST_PRE_REX;
				}
				operands_set_tsi(op, O_REG, 64, R_RAX);
			}
		break;
		case OT_PTR16_FULL:
			/* ptr16:full - full is size of operand size to read, therefore Operand Size Prefix affects this. So we need to handle it. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int16_t)*2;
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 16);
				di->imm.ptr.off = RUSHORT(ci->code); /* Read offset first. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int16_t))); /* And read segment. */

				ci->code += sizeof(int16_t)*2;
			} else { /* Decode32Bits, for Decode64Bits this instruction is invalid. */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int32_t) + sizeof(int16_t);
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 32);
				di->imm.ptr.off = RULONG(ci->code); /* Read 32bits offset this time. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int32_t))); /* And read segment, 16 bits. */
				
				ci->code += sizeof(int32_t) + sizeof(int16_t);
			}
		break;
		case OT_RELCB:
		case OT_RELC_FULL:

			if (type == OT_RELCB) {
				operands_set_ts(op, O_PC, 8);
				if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int8_t))) return FALSE;
			} else { /* OT_RELC_FULL */

				/* Yep, operand size prefix affects relc also.  */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				if (effOpSz == Decode16Bits) {
					operands_set_ts(op, O_PC, 16);
					if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int16_t))) return FALSE;
				} else { /* Decode32Bits or Decode64Bits = for now they are the same */
					operands_set_ts(op, O_PC, 32);
					if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int32_t))) return FALSE;
				}
			}

			/* Support for hint, see if there's a segment override. */
			if ((ii->opcodeId >= I_JO) && (ii->opcodeId <= I_JG)) {
				if (ps->decodedPrefixes & INST_PRE_CS) {
					ps->usedPrefixes |= INST_PRE_CS;
					di->flags |= FLAG_HINT_NOT_TAKEN;
				} else if (ps->decodedPrefixes & INST_PRE_DS) {
					ps->usedPrefixes |= INST_PRE_DS;
					di->flags |= FLAG_HINT_TAKEN;
				}
			}
		break;
		case OT_MOFFS8:
			op->size = 8;
			/* FALL THROUGH, size won't be changed. */
		case OT_MOFFS_FULL:
			op->type = O_DISP;
			if (op->size == 0) {
				/* Calculate size of operand (same as ACC size). */
				switch (effOpSz)
				{
					case Decode16Bits: op->size = 16; break;
					case Decode32Bits: op->size = 32; break;
					case Decode64Bits: op->size = 64; break;
				}
			}

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/*
			 * Just a pointer to a BYTE, WORD, DWORD, QWORD. Works only with ACC8/16/32/64 respectively. 
			 * MOV [0x1234], AL ; MOV AX, [0x1234] ; MOV EAX, [0x1234], note that R/E/AX will be chosen by OT_ACC_FULL.
			 */
			if (effAdrSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 16;
				if (!read_stream_safe_uint(ci, &di->disp, sizeof(int16_t))) return FALSE;
			} else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 32;
				if (!read_stream_safe_uint(ci, &di->disp, sizeof(int32_t))) return FALSE;
			} else { /* Decode64Bits */
				di->dispSize = 64;
				if (!read_stream_safe_uint(ci, &di->disp, sizeof(int64_t))) return FALSE;
			}
		break;
		case OT_CONST1:
			operands_set_ts(op, O_IMM, 8);
			di->imm.byte = 1;
		break;
		case OT_REGCL:
			operands_set_tsi(op, O_REG, 8, R_CL);
		break;

		case OT_FPU_SI:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_tsi(op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
		break;
		case OT_FPU_SSI:
			operands_set_tsi(op, O_REG, 32, R_ST0);
			operands_set_tsi(op + 1, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
		break;
		case OT_FPU_SIS:
			operands_set_tsi(op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
			operands_set_tsi(op + 1, O_REG, 32, R_ST0);
		break;

		/*
		 * Special treatment for Instructions-Block:
		 * INC/DEC (only 16/32 bits) /PUSH/POP/XCHG instructions, which get their REG from their own binary code.

		 * Notice these instructions are 1 or 2 byte long,
		 * code points after the byte which represents the instruction itself,
		 * thus, even if the instructions are 2 bytes long it will read its last byte which contains the REG info.
		 */
		case OT_IB_RB:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_ts(op, O_REG, 8);
			reg = *(ci->code-1) & 7;
			if (vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + EX_GPR_BASE);
			} else if (ps->prefixExtType == PET_REX) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg);
			} else op->index = (uint8_t)(REGS8_BASE + reg);
		break;
		case OT_IB_R_FULL:
			reg = *(ci->code-1) & 7;
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits:
					/*
					 * Automatically promoted instruction can drop REX prefix if not required.
					 * PUSH/POP defaults to 64 bits. --> INST_64BITS
					 * MOV imm64 / BSWAP requires REX.W to be 64 bits --> INST_64BITS | INST_PRE_REX
					 */
					if ((instFlags & INST_64BITS) && ((instFlags & INST_PRE_REX) == 0)) {
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							reg += EX_GPR_BASE;
						}
					} else {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += (vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0;
					}
					operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
		break;

		/*
		 * Special treatment for repeatable instructions.

		 * We want the following output:
		 * If there's only the REP/NZ prefix, we won't output anything (All operands are implicit).
		 * If there's an operand size prefix, we will change the suffix letter of the mnemonic, which specifies the size of operand to the required one.
		 * If there's a segment override prefix, we will output the segment and the used index register (EDI/ESI).
		 * If there's an address size prefix, we will output the (segment if needed and) the used and inverted index register (DI/SI).

		 * Example:
		 * :: Decoding in 16 bits mode! ::
		 * AD ~ LODSW
		 * 66 AD ~ LODSD
		 * F3 AC ~ REP LODSB
		 * F3 66 AD ~ REP LODSD
		 * F3 3E AC ~ REP LODS BYTE DS:[SI]
		 * F3 67 AD ~ REP LODS WORD [ESI]

		 * The basic form of a repeatable instruction has its operands hidden and has a suffix letter
		 * which implies on the size of operation being done.
		 * Therefore, we cannot change the mnemonic here when we encounter another prefix and its not the decoder's responsibility to do so.
		 * That's why the caller is responsible to add the suffix letter if no other prefixes are used.
		 * And all we are doing here is formatting the operand correctly.
		 */
		case OT_REGI_ESI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16, 32 or 64 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/*
			 * Clear segment in case OT_REGI_EDI was parsed earlier,
			 * DS can be overridden and therefore has precedence.
			 */
			di->segment = 0;
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			if (effAdrSz == Decode16Bits) op->index = R_SI;
			else if (effAdrSz == Decode32Bits) op->index = R_ESI;
			else op->index = R_RSI;
		break;
		case OT_REGI_EDI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16 or 32 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/* Note: The [rDI] operand can't be prefixed by a segment override, therefore we don't set usedPrefixes. */
			if ((opNum == ONT_1) && (ci->dt != Decode64Bits)) di->segment = R_ES | SEGMENT_DEFAULT; /* No ES in 64 bits mode. */

			if (effAdrSz == Decode16Bits) op->index = R_DI;
			else if (effAdrSz == Decode32Bits) op->index = R_EDI;
			else op->index = R_RDI;
		break;

		/* Used for In/Out instructions varying forms. */
		case OT_REGDX:
			/* Simple single IN/OUT instruction. */
			operands_set_tsi(op, O_REG, 16, R_DX);
		break;

		/* Used for INVLPGA instruction. */
		case OT_REGECX:
			operands_set_tsi(op, O_REG, 32, R_ECX);
		break;
		case OT_REGI_EBXAL:
			/* XLAT BYTE [rBX + AL] */
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/* Size of deref is always 8 for xlat. */
			operands_set_tsi(op, O_MEM, 8, R_AL);

			if (effAdrSz == Decode16Bits) di->base = R_BX;
			else if (effAdrSz == Decode32Bits) di->base = R_EBX;
			else {
				ps->usedPrefixes |= INST_PRE_REX;
				di->base = R_RBX;
			}
		break;
		case OT_REGI_EAX:
			/*
			 * Implicit rAX as memory indirection operand. Used by AMD's SVM instructions.
			 * Since this is a memory indirection, the default address size in 64bits decoding mode is 64.
			 */

			if (effAdrSz == Decode64Bits) operands_set_tsi(op, O_SMEM, 64, R_RAX);
			else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(op, O_SMEM, 32, R_EAX);
			} else {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(op, O_SMEM, 16, R_AX);
			}
		break;
		case OT_VXMM:
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + vexV);
		break;
		case OT_XMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YXMM:
			if (vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_YXMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;

			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YMM:
			if (vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + reg);
		break;
		case OT_VYMM:
			operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + vexV);
		break;
		case OT_VYXMM:
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + vexV);
			else operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + vexV); 
		break;
		case OT_WREG32_64:
			if (vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_W) operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
			else operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
		break;
		default: return FALSE;
	}

	if ((op->type == O_REG) || (op->type == O_SMEM) || (op->type == O_MEM)) {
		di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
	}

	return TRUE;
}



================================================
File: src/sigmake/distorm/operands.h
================================================
/*
operands.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef OPERANDS_H
#define OPERANDS_H

#include "config.h"
#include "decoder.h"
#include "prefix.h"
#include "instructions.h"


extern uint16_t _REGISTERTORCLASS[];

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type, _OperandNumberType opNum,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, int* lockableInstruction);

#endif /* OPERANDS_H */



================================================
File: src/sigmake/distorm/prefix.c
================================================
/*
prefix.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "prefix.h"

#include "x86defs.h"
#include "instructions.h"
#include "mnemonics.h"


/*
 * The main purpose of this module is to keep track of all kind of prefixes a single instruction may have.
 * The problem is that a single instruction may have up to six different prefix-types.
 * That's why I have to detect such cases and drop those excess prefixes.
 */

int prefixes_is_valid(unsigned int ch, _DecodeType dt)
{
	switch (ch) {
		/* for i in xrange(0x40, 0x50): print "case 0x%2x:" % i */
		case 0x40: /* REX: */
		case 0x41:
		case 0x42:
		case 0x43:
		case 0x44:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4a:
		case 0x4b:
		case 0x4c:
		case 0x4d:
		case 0x4e:
		case 0x4f: return (dt == Decode64Bits);
		case PREFIX_LOCK: return TRUE;
		case PREFIX_REPNZ: return TRUE;
		case PREFIX_REP: return TRUE;
		case PREFIX_CS: return TRUE;
		case PREFIX_SS: return TRUE;
		case PREFIX_DS: return TRUE;
		case PREFIX_ES: return TRUE;
		case PREFIX_FS: return TRUE;
		case PREFIX_GS: return TRUE;
		case PREFIX_OP_SIZE: return TRUE;
		case PREFIX_ADDR_SIZE: return TRUE;
		/* The VEXs might be false positives, the decode_perfixes will determine for sure. */
		case PREFIX_VEX2b: /* VEX is supported for all modes, because 16 bits Pmode is included. */
		case PREFIX_VEX3b: return TRUE;
	}
	return FALSE;
}

/* Ignore a specific prefix type. */
void prefixes_ignore(_PrefixState* ps, _PrefixIndexer pi)
{
	/*
	 * If that type of prefix appeared already, set the bit of that *former* prefix.
	 * Anyway, set the new index of that prefix type to the current index, so next time we know its position.
	 */
	if (ps->pfxIndexer[pi] != PFXIDX_NONE) ps->unusedPrefixesMask |= (1 << ps->pfxIndexer[pi]);
}

/* Ignore all prefix. */
void prefixes_ignore_all(_PrefixState* ps)
{
	int i;
	for (i = 0; i < PFXIDX_MAX; i++)
		prefixes_ignore(ps, i);
}

/* Calculates which prefixes weren't used and accordingly sets the bits in the unusedPrefixesMask. */
uint16_t prefixes_set_unused_mask(_PrefixState* ps)
{
	/*
	 * The decodedPrefixes represents the prefixes that were *read* from the binary stream for the instruction.
	 * The usedPrefixes represents the prefixes that were actually used by the instruction in the *decode* phase.
	 * Xoring between the two will result in a 'diff' which returns the prefixes that were read
	 * from the stream *and* that were never used in the actual decoding.
	 *
	 * Only one prefix per type can be set in decodedPrefixes from the stream.
	 * Therefore it's enough to check each type once and set the flag accordingly.
	 * That's why we had to book-keep each prefix type and its position.
	 * So now we know which bits we need to set exactly in the mask.
	 */
	_iflags unusedPrefixesDiff = ps->decodedPrefixes ^ ps->usedPrefixes;

	/* Examine unused prefixes by type: */
	/*
	 * About REX: it might be set in the diff although it was never in the stream itself.
	 * This is because the vrex is shared between VEX and REX and some places flag it as REX usage, while
	 * we were really decoding an AVX instruction.
	 * It's not a big problem, because the prefixes_ignore func will ignore it anyway,
	 * since it wasn't seen earlier. But it's important to know this.
	 */
	if (unusedPrefixesDiff & INST_PRE_REX) prefixes_ignore(ps, PFXIDX_REX);
	if (unusedPrefixesDiff & INST_PRE_SEGOVRD_MASK) prefixes_ignore(ps, PFXIDX_SEG);
	if (unusedPrefixesDiff & INST_PRE_LOKREP_MASK) prefixes_ignore(ps, PFXIDX_LOREP);
	if (unusedPrefixesDiff & INST_PRE_OP_SIZE) prefixes_ignore(ps, PFXIDX_OP_SIZE);
	if (unusedPrefixesDiff & INST_PRE_ADDR_SIZE) prefixes_ignore(ps, PFXIDX_ADRS);
	/* If a VEX instruction was found, its prefix is considered as used, therefore no point for checking for it. */

	return ps->unusedPrefixesMask;
}

/*
 * Mark a prefix as unused, and bookkeep where we last saw this same type,
 * because in the future we might want to disable it too.
 */
_INLINE_ void prefixes_track_unused(_PrefixState* ps, int index, _PrefixIndexer pi)
{
	prefixes_ignore(ps, pi);
	/* Book-keep the current index for this type. */
	ps->pfxIndexer[pi] = index;
}

/*
 * Read as many prefixes as possible, up to 15 bytes, and halt when we encounter non-prefix byte.
 * This algorithm tries to imitate a real processor, where the same prefix can appear a few times, etc.
 * The tiny complexity is that we want to know when a prefix was superfluous and mark any copy of it as unused.
 * Note that the last prefix of its type will be considered as used, and all the others (of same type) before it as unused.
 */
void prefixes_decode(const uint8_t* code, int codeLen, _PrefixState* ps, _DecodeType dt)
{
	int index, done;
	uint8_t vex;

	/*
	 * First thing to do, scan for prefixes, there are six types of prefixes.
	 * There may be up to six prefixes before a single instruction, not the same type, no special order,
	 * except REX/VEX must precede immediately the first opcode byte.
	 * BTW - This is the reason why I didn't make the REP prefixes part of the instructions (STOS/SCAS/etc).
	 *
	 * Another thing, the instruction maximum size is 15 bytes, thus if we read more than 15 bytes, we will halt.
	 *
	 * We attach all prefixes to the next instruction, there might be two or more occurrences from the same prefix.
	 * Also, since VEX can be allowed only once we will test it separately.
	 */
	for (index = 0, done = FALSE;
		 (codeLen > 0) && (code - ps->start < INST_MAXIMUM_SIZE);
		 code++, codeLen--, index++) {
		/*
		NOTE: AMD treat lock/rep as two different groups... But I am based on Intel.

			- Lock and Repeat:
				- 0xF0 — LOCK
				- 0xF2 — REPNE/REPNZ
				- 0xF3 - REP/REPE/REPZ
			- Segment Override:
				- 0x2E - CS
				- 0x36 - SS
				- 0x3E - DS
				- 0x26 - ES
				- 0x64 - FS
				- 0x65 - GS
			- Operand-Size Override: 0x66, switching default size.
			- Address-Size Override: 0x67, switching default size.

		64 Bits:
			- REX: 0x40 - 0x4f, extends register access.
			- 2 Bytes VEX: 0xc4
			- 3 Bytes VEX: 0xc5
		32 Bits:
			- 2 Bytes VEX: 0xc4 11xx-xxxx
			- 3 Bytes VEX: 0xc5 11xx-xxxx
		*/

		/* Examine what type of prefix we got. */
		switch (*code)
		{
			/* REX type, 64 bits decoding mode only: */
			case 0x40:
			case 0x41:
			case 0x42:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x47:
			case 0x48:
			case 0x49:
			case 0x4a:
			case 0x4b:
			case 0x4c:
			case 0x4d:
			case 0x4e:
			case 0x4f:
				if (dt == Decode64Bits) {
					ps->decodedPrefixes |= INST_PRE_REX;
					ps->vrex = *code & 0xf; /* Keep only BXRW. */
					ps->rexPos = code;
					ps->prefixExtType = PET_REX;
					prefixes_track_unused(ps, index, PFXIDX_REX);
				} else done = TRUE; /* If we are not in 64 bits mode, it's an instruction, then halt. */
			break;

			/* LOCK and REPx type: */
			case PREFIX_LOCK:
				ps->decodedPrefixes |= INST_PRE_LOCK;
				prefixes_track_unused(ps, index, PFXIDX_LOREP);
			break;
			case PREFIX_REPNZ:
				ps->decodedPrefixes |= INST_PRE_REPNZ;
				prefixes_track_unused(ps, index, PFXIDX_LOREP);
			break;
			case PREFIX_REP:
				ps->decodedPrefixes |= INST_PRE_REP;
				prefixes_track_unused(ps, index, PFXIDX_LOREP);
			break;

			/* Seg Overide type: */
			case PREFIX_CS:
				ps->decodedPrefixes |= INST_PRE_CS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_SS:
				ps->decodedPrefixes |= INST_PRE_SS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_DS:
				ps->decodedPrefixes |= INST_PRE_DS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_ES:
				ps->decodedPrefixes |= INST_PRE_ES;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_FS:
				ps->decodedPrefixes |= INST_PRE_FS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_GS:
				ps->decodedPrefixes |= INST_PRE_GS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;

			/* Op Size type: */
			case PREFIX_OP_SIZE:
				ps->decodedPrefixes |= INST_PRE_OP_SIZE;
				prefixes_track_unused(ps, index, PFXIDX_OP_SIZE);
			break;

			/* Addr Size type: */
			case PREFIX_ADDR_SIZE:
				ps->decodedPrefixes |= INST_PRE_ADDR_SIZE;
				prefixes_track_unused(ps, index, PFXIDX_ADRS);
			break;

			/* Non-prefix byte now, so break 2. */
			default: done = TRUE; break;
		}
		if (done) break;
	}

	/* 2 Bytes VEX: */
	if ((codeLen >= 2) &&
		(*code == PREFIX_VEX2b) &&
		((code - ps->start) <= INST_MAXIMUM_SIZE - 2)) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LDS instruction.
		 */
		if ((dt == Decode64Bits) || (*(code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX2BYTES;

			/*
			 * VEX 1 byte bits:
			 * |7-6--3-2-10|
			 * |R|vvvv|L|pp|
			 * |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			if (~vex & 0x80 && dt == Decode64Bits) ps->vrex |= PREFIX_EX_R; /* Convert VEX.R. */
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */

			code += 2;
		}
	}

	/* 3 Bytes VEX: */
	if ((codeLen >= 3) &&
		(*code == PREFIX_VEX3b) &&
		((code - ps->start) <= INST_MAXIMUM_SIZE - 3) &&
		(~ps->decodedPrefixes & INST_PRE_VEX)) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LES instruction.
		 * And we don't care now about the 3rd byte.
		 */
		if ((dt == Decode64Bits) || (*(code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX3BYTES;

			/*
			 * VEX first and second bytes:
			 * |7-6-5-4----0|  |7-6--3-2-10|
			 * |R|X|B|m-mmmm|  |W|vvvv|L|pp|
			 * |------------|  |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			ps->vrex |= ((~vex >> 5) & 0x7); /* Shift and invert VEX.R/X/B to their place */
			vex = *(ps->vexPos + 1);
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */
			if (vex & 0x80) ps->vrex |= PREFIX_EX_W; /* Convert VEX.W. */

			/* Clear some flags if the mode isn't 64 bits. */
			if (dt != Decode64Bits) ps->vrex &= ~(PREFIX_EX_B | PREFIX_EX_X | PREFIX_EX_R | PREFIX_EX_W);

			code += 3;
		}
	}

	/*
	 * Save last byte scanned address, so the decoder could keep on scanning from this point and on and on and on.
	 * In addition the decoder is able to know that the last byte could lead to MMX/SSE instructions (preceding REX if exists).
	 */
	ps->last = code; /* ps->last points to an opcode byte. */
}

/*
 * For every memory-indirection operand we want to set its corresponding default segment.
 * If the segment is being overrided, we need to see whether we use it or not.
 * We will use it only if it's not the default one already.
 */
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di)
{
	_iflags flags = 0;
	if (dt == Decode64Bits) flags = ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK64;
	else flags = ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK;

	if ((flags == 0) || (flags == defaultSeg)) {
		flags = defaultSeg;
		di->segment |= SEGMENT_DEFAULT;
	} else if (flags != defaultSeg) {
		/* Use it only if it's non-default segment. */
		ps->usedPrefixes |= flags;
	}

	/* ASSERT: R_XX must be below 128. */
	switch (flags)
	{
		case INST_PRE_ES: di->segment |= R_ES; break;
		case INST_PRE_CS: di->segment |= R_CS; break;
		case INST_PRE_SS: di->segment |= R_SS; break;
		case INST_PRE_DS: di->segment |= R_DS; break;
		case INST_PRE_FS: di->segment |= R_FS; break;
		case INST_PRE_GS: di->segment |= R_GS; break;
	}

	/* If it's one of the CS,SS,DS,ES and the mode is 64 bits, set segment it to none, since it's ignored. */
	if ((dt == Decode64Bits) && (flags & INST_PRE_SEGOVRD_MASK32)) di->segment = R_NONE;
}



================================================
File: src/sigmake/distorm/prefix.h
================================================
/*
prefix.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef PREFIX_H
#define PREFIX_H

#include "config.h"
#include "decoder.h"


/* Specifies the type of the extension prefix, such as: REX, 2 bytes VEX, 3 bytes VEX. */
typedef enum {PET_NONE = 0, PET_REX, PET_VEX2BYTES, PET_VEX3BYTES} _PrefixExtType;

/* Specifies an index into a table of prefixes by their type. */
typedef enum {PFXIDX_NONE = -1, PFXIDX_REX, PFXIDX_LOREP, PFXIDX_SEG, PFXIDX_OP_SIZE, PFXIDX_ADRS, PFXIDX_MAX} _PrefixIndexer;

/*
* This holds the prefixes state for the current instruction we decode.
* decodedPrefixes includes all specific prefixes that the instruction got.
* start is a pointer to the first prefix to take into account.
* last is a pointer to the last byte we scanned.
* Other pointers are used to keep track of prefixes positions and help us know if they appeared already and where.
*/
typedef struct {
	_iflags decodedPrefixes, usedPrefixes;
	const uint8_t *start, *last, *vexPos, *rexPos;
	_PrefixExtType prefixExtType;
	uint16_t unusedPrefixesMask;
	/* Indicates whether the operand size prefix (0x66) was used as a mandatory prefix. */
	int isOpSizeMandatory;
	/* If VEX prefix is used, store the VEX.vvvv field. */
	unsigned int vexV;
	/* The fields B/X/R/W/L of REX and VEX are stored together in this byte. */
	unsigned int vrex;

	/* !! Make sure pfxIndexer is LAST! Otherwise memset won't work well with it. !! */

	/* Holds the offset to the prefix byte by its type. */
	int pfxIndexer[PFXIDX_MAX];
} _PrefixState;

/*
* Intel supports 6 types of prefixes, whereas AMD supports 5 types (lock is seperated from rep/nz).
* REX is the fifth prefix type, this time I'm based on AMD64.
* VEX is the 6th, though it can't be repeated.
*/
#define MAX_PREFIXES (5)

int prefixes_is_valid(unsigned int ch, _DecodeType dt);
void prefixes_ignore(_PrefixState* ps, _PrefixIndexer pi);
void prefixes_ignore_all(_PrefixState* ps);
uint16_t prefixes_set_unused_mask(_PrefixState* ps);
void prefixes_decode(const uint8_t* code, int codeLen, _PrefixState* ps, _DecodeType dt);
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di);

#endif /* PREFIX_H */



================================================
File: src/sigmake/distorm/textdefs.c
================================================
/*
textdefs.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "textdefs.h"

#ifndef DISTORM_LIGHT

static uint8_t Nibble2ChrTable[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
#define NIBBLE_TO_CHR Nibble2ChrTable[t]

void _FASTCALL_ str_hex_b(_WString* s, unsigned int x)
{
	/*
	 * def prebuilt():
	 * 	s = ""
	 * 	for i in xrange(256):
	 * 		if ((i % 0x10) == 0):
	 * 			s += "\r\n"
	 * 		s += "\"%02x\", " % (i)
	 * 	return s
	 */
	static int8_t TextBTable[256][3] = {
		"00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f",
		"10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f",
		"20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f",
		"30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f",
		"40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f",
		"50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f",
		"60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f",
		"70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f",
		"80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f",
		"90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f",
		"a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af",
		"b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf",
		"c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf",
		"d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df",
		"e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef",
		"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"
	};

	/*
	 * Fixed length of 3 including null terminate character.
	 */
	memcpy(&s->p[s->length], TextBTable[x & 255], 3);
	s->length += 2;
}

void _FASTCALL_ str_code_hb(_WString* s, unsigned int x)
{
	static int8_t TextHBTable[256][5] = {
	/*
	 * def prebuilt():
	 * 	s = ""
	 * 	for i in xrange(256):
	 * 		if ((i % 0x10) == 0):
	 * 			s += "\r\n"
	 * 		s += "\"0x%x\", " % (i)
	 * 	return s
	 */
		"0x0", "0x1", "0x2", "0x3", "0x4", "0x5", "0x6", "0x7", "0x8", "0x9", "0xa", "0xb", "0xc", "0xd", "0xe", "0xf",
		"0x10", "0x11", "0x12", "0x13", "0x14", "0x15", "0x16", "0x17", "0x18", "0x19", "0x1a", "0x1b", "0x1c", "0x1d", "0x1e", "0x1f",
		"0x20", "0x21", "0x22", "0x23", "0x24", "0x25", "0x26", "0x27", "0x28", "0x29", "0x2a", "0x2b", "0x2c", "0x2d", "0x2e", "0x2f",
		"0x30", "0x31", "0x32", "0x33", "0x34", "0x35", "0x36", "0x37", "0x38", "0x39", "0x3a", "0x3b", "0x3c", "0x3d", "0x3e", "0x3f",
		"0x40", "0x41", "0x42", "0x43", "0x44", "0x45", "0x46", "0x47", "0x48", "0x49", "0x4a", "0x4b", "0x4c", "0x4d", "0x4e", "0x4f",
		"0x50", "0x51", "0x52", "0x53", "0x54", "0x55", "0x56", "0x57", "0x58", "0x59", "0x5a", "0x5b", "0x5c", "0x5d", "0x5e", "0x5f",
		"0x60", "0x61", "0x62", "0x63", "0x64", "0x65", "0x66", "0x67", "0x68", "0x69", "0x6a", "0x6b", "0x6c", "0x6d", "0x6e", "0x6f",
		"0x70", "0x71", "0x72", "0x73", "0x74", "0x75", "0x76", "0x77", "0x78", "0x79", "0x7a", "0x7b", "0x7c", "0x7d", "0x7e", "0x7f",
		"0x80", "0x81", "0x82", "0x83", "0x84", "0x85", "0x86", "0x87", "0x88", "0x89", "0x8a", "0x8b", "0x8c", "0x8d", "0x8e", "0x8f",
		"0x90", "0x91", "0x92", "0x93", "0x94", "0x95", "0x96", "0x97", "0x98", "0x99", "0x9a", "0x9b", "0x9c", "0x9d", "0x9e", "0x9f",
		"0xa0", "0xa1", "0xa2", "0xa3", "0xa4", "0xa5", "0xa6", "0xa7", "0xa8", "0xa9", "0xaa", "0xab", "0xac", "0xad", "0xae", "0xaf",
		"0xb0", "0xb1", "0xb2", "0xb3", "0xb4", "0xb5", "0xb6", "0xb7", "0xb8", "0xb9", "0xba", "0xbb", "0xbc", "0xbd", "0xbe", "0xbf",
		"0xc0", "0xc1", "0xc2", "0xc3", "0xc4", "0xc5", "0xc6", "0xc7", "0xc8", "0xc9", "0xca", "0xcb", "0xcc", "0xcd", "0xce", "0xcf",
		"0xd0", "0xd1", "0xd2", "0xd3", "0xd4", "0xd5", "0xd6", "0xd7", "0xd8", "0xd9", "0xda", "0xdb", "0xdc", "0xdd", "0xde", "0xdf",
		"0xe0", "0xe1", "0xe2", "0xe3", "0xe4", "0xe5", "0xe6", "0xe7", "0xe8", "0xe9", "0xea", "0xeb", "0xec", "0xed", "0xee", "0xef",
		"0xf0", "0xf1", "0xf2", "0xf3", "0xf4", "0xf5", "0xf6", "0xf7", "0xf8", "0xf9", "0xfa", "0xfb", "0xfc", "0xfd", "0xfe", "0xff"
	};

	if (x < 0x10) {	/* < 0x10 has a fixed length of 4 including null terminate. */
		memcpy(&s->p[s->length], TextHBTable[x & 255], 4);
		s->length += 3;
	} else { /* >= 0x10 has a fixed length of 5 including null terminate. */
		memcpy(&s->p[s->length], TextHBTable[x & 255], 5);
		s->length += 4;
	}
}

void _FASTCALL_ str_code_hdw(_WString* s, uint32_t x)
{
	int8_t* buf;
	int i = 0, shift = 0;
	unsigned int t = 0;

	buf = (int8_t*)&s->p[s->length];

	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 28; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	s->length += i + 2;
	buf[i] = '\0';
}

void _FASTCALL_ str_code_hqw(_WString* s, uint8_t src[8])
{
	int8_t* buf;
	int i = 0, shift = 0;
	uint32_t x = RULONG(&src[sizeof(int32_t)]);
	int t;

	buf = (int8_t*)&s->p[s->length];
	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 28; shift != -4; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}

	x = RULONG(src);
	for (shift = 28; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	s->length += i + 2;
	buf[i] = '\0';
}

#ifdef SUPPORT_64BIT_OFFSET
void _FASTCALL_ str_off64(_WString* s, OFFSET_INTEGER x)
{
	int8_t* buf;
	int i = 0, shift = 0;
	OFFSET_INTEGER t = 0;

	buf = (int8_t*)&s->p[s->length];

	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 60; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	s->length += i + 2;
	buf[i] = '\0';
}
#endif /* SUPPORT_64BIT_OFFSET */

#endif /* DISTORM_LIGHT */



================================================
File: src/sigmake/distorm/textdefs.h
================================================
/*
textdefs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef TEXTDEFS_H
#define TEXTDEFS_H

#include "config.h"
#include "wstring.h"

#ifndef DISTORM_LIGHT

#define PLUS_DISP_CHR '+'
#define MINUS_DISP_CHR '-'
#define OPEN_CHR '['
#define CLOSE_CHR ']'
#define SP_CHR ' '
#define SEG_OFF_CHR ':'

/*
Naming Convention:

* get - returns a pointer to a string.
* str - concatenates to string.

* hex - means the function is used for hex dump (number is padded to required size) - Little Endian output.
* code - means the function is used for disassembled instruction - Big Endian output.
* off - means the function is used for 64bit offset - Big Endian output.

* h - '0x' in front of the string.

* b - byte
* dw - double word (can be used for word also)
* qw - quad word

* all numbers are in HEX.
*/

extern int8_t TextBTable[256][4];

void _FASTCALL_ str_hex_b(_WString* s, unsigned int x);
void _FASTCALL_ str_code_hb(_WString* s, unsigned int x);
void _FASTCALL_ str_code_hdw(_WString* s, uint32_t x);
void _FASTCALL_ str_code_hqw(_WString* s, uint8_t src[8]);

#ifdef SUPPORT_64BIT_OFFSET
void _FASTCALL_ str_off64(_WString* s, OFFSET_INTEGER x);
#endif

#endif /* DISTORM_LIGHT */

#endif /* TEXTDEFS_H */



================================================
File: src/sigmake/distorm/wstring.c
================================================
/*
wstring.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#include "wstring.h"

#ifndef DISTORM_LIGHT

void strclear_WS(_WString* s)
{
	s->p[0] = '\0';
	s->length = 0;
}

void chrcat_WS(_WString* s, uint8_t ch)
{
	s->p[s->length] = ch;
	s->p[s->length + 1] = '\0';
	s->length += 1;
}

void strcpylen_WS(_WString* s, const int8_t* buf, unsigned int len)
{
	s->length = len;
	memcpy((int8_t*)s->p, buf, len + 1);
}

void strcatlen_WS(_WString* s, const int8_t* buf, unsigned int len)
{
	memcpy((int8_t*)&s->p[s->length], buf, len + 1);
	s->length += len;
}

void strcat_WS(_WString* s, const _WString* s2)
{
	memcpy((int8_t*)&s->p[s->length], s2->p, s2->length + 1);
	s->length += s2->length;
}

#endif /* DISTORM_LIGHT */



================================================
File: src/sigmake/distorm/wstring.h
================================================
/*
wstring.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef WSTRING_H
#define WSTRING_H

#include "config.h"

#ifndef DISTORM_LIGHT

void strclear_WS(_WString* s);
void chrcat_WS(_WString* s, uint8_t ch);
void strcpylen_WS(_WString* s, const int8_t* buf, unsigned int len);
void strcatlen_WS(_WString* s, const int8_t* buf, unsigned int len);
void strcat_WS(_WString* s, const _WString* s2);

/*
* Warning, this macro should be used only when the compiler knows the size of string in advance!
* This macro is used in order to spare the call to strlen when the strings are known already.
* Note: sizeof includes NULL terminated character.
*/
#define strcat_WSN(s, t) strcatlen_WS((s), ((const int8_t*)t), sizeof((t))-1)
#define strcpy_WSN(s, t) strcpylen_WS((s), ((const int8_t*)t), sizeof((t))-1)

#endif /* DISTORM_LIGHT */

#endif /* WSTRING_H */



================================================
File: src/sigmake/distorm/x86defs.h
================================================
/*
x86defs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef X86DEFS_H
#define X86DEFS_H


#define SEG_REGS_MAX (6)
#define CREGS_MAX (9)
#define DREGS_MAX (8)

/* Maximum instruction size, including prefixes */
#define INST_MAXIMUM_SIZE (15)

/* Maximum range of imm8 (comparison type) of special SSE CMP instructions. */
#define INST_CMP_MAX_RANGE (8)

/* Maximum range of imm8 (comparison type) of special AVX VCMP instructions. */
#define INST_VCMP_MAX_RANGE (32)

/* Wait instruction byte code. */
#define INST_WAIT_INDEX (0x9b)

/* Lea instruction byte code. */
#define INST_LEA_INDEX (0x8d)

/* NOP/XCHG instruction byte code. */
#define INST_NOP_INDEX (0x90)

/* ARPL/MOVSXD instruction byte code. */
#define INST_ARPL_INDEX (0x63)

/*
 * Minimal MODR/M value of divided instructions.
 * It's 0xc0, two MSBs set, which indicates a general purpose register is used too.
 */
#define INST_DIVIDED_MODRM (0xc0)

/* This is the escape byte value used for 3DNow! instructions. */
#define _3DNOW_ESCAPE_BYTE (0x0f)

#define PREFIX_LOCK (0xf0)
#define PREFIX_REPNZ (0xf2)
#define PREFIX_REP (0xf3)
#define PREFIX_CS (0x2e)
#define PREFIX_SS (0x36)
#define PREFIX_DS (0x3e)
#define PREFIX_ES (0x26)
#define PREFIX_FS (0x64)
#define PREFIX_GS (0x65)
#define PREFIX_OP_SIZE (0x66)
#define PREFIX_ADDR_SIZE (0x67)
#define PREFIX_VEX2b (0xc5)
#define PREFIX_VEX3b (0xc4)

/* REX prefix value range, 64 bits mode decoding only. */
#define PREFIX_REX_LOW (0x40)
#define PREFIX_REX_HI (0x4f)
/* In order to use the extended GPR's we have to add 8 to the Modr/M info values. */
#define EX_GPR_BASE (8)

/* Mask for REX and VEX features: */
/* Base */
#define PREFIX_EX_B (1)
/* Index */
#define PREFIX_EX_X (2)
/* Register */
#define PREFIX_EX_R (4)
/* Operand Width */
#define PREFIX_EX_W (8)
/* Vector Lengh */
#define PREFIX_EX_L (0x10)

#endif /* X86DEFS_H */



================================================
File: src/zlib/LICENSE
================================================
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.8, April 28th, 2013

  Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu

*/


================================================
File: src/zlib/adler32.c
================================================
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2011 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#include "zutil.h"

#define local static

local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));

#define BASE 65521      /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* use NO_DIVIDE if your processor does not do division in hardware --
   try it both ways to see which is faster */
#ifdef NO_DIVIDE
/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
   (thank you to John Reiser for pointing this out) */
#  define CHOP(a) \
    do { \
        unsigned long tmp = a >> 16; \
        a &= 0xffffUL; \
        a += (tmp << 4) - tmp; \
    } while (0)
#  define MOD28(a) \
    do { \
        CHOP(a); \
        if (a >= BASE) a -= BASE; \
    } while (0)
#  define MOD(a) \
    do { \
        CHOP(a); \
        MOD28(a); \
    } while (0)
#  define MOD63(a) \
    do { /* this assumes a is not negative */ \
        z_off64_t tmp = a >> 32; \
        a &= 0xffffffffL; \
        a += (tmp << 8) - (tmp << 5) + tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        if (a >= BASE) a -= BASE; \
    } while (0)
#else
#  define MOD(a) a %= BASE
#  define MOD28(a) a %= BASE
#  define MOD63(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
        adler += buf[0];
        if (adler >= BASE)
            adler -= BASE;
        sum2 += adler;
        if (sum2 >= BASE)
            sum2 -= BASE;
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
        MOD28(sum2);            /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}

/* ========================================================================= */
local uLong adler32_combine_(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off64_t len2;
{
    unsigned long sum1;
    unsigned long sum2;
    unsigned rem;

    /* for negative len, return invalid adler32 as a clue for debugging */
    if (len2 < 0)
        return 0xffffffffUL;

    /* the derivation of this formula is left as an exercise for the reader */
    MOD63(len2);                /* assumes len2 >= 0 */
    rem = (unsigned)len2;
    sum1 = adler1 & 0xffff;
    sum2 = rem * sum1;
    MOD(sum2);
    sum1 += (adler2 & 0xffff) + BASE - 1;
    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);
    if (sum2 >= BASE) sum2 -= BASE;
    return sum1 | (sum2 << 16);
}

/* ========================================================================= */
uLong ZEXPORT adler32_combine(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off_t len2;
{
    return adler32_combine_(adler1, adler2, len2);
}

uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off64_t len2;
{
    return adler32_combine_(adler1, adler2, len2);
}



================================================
File: src/zlib/compress.c
================================================
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#define ZLIB_INTERNAL
#include "zlib.h"

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
    int level;
{
    z_stream stream;
    int err;

    stream.next_in = (z_const Bytef *)source;
    stream.avail_in = (uInt)sourceLen;
#ifdef MAXSEG_64K
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
#endif
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    err = deflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        deflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = deflateEnd(&stream);
    return err;
}

/* ===========================================================================
 */
int ZEXPORT compress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}

/* ===========================================================================
     If the default memLevel or windowBits for deflateInit() is changed, then
   this function needs to be updated.
 */
uLong ZEXPORT compressBound (sourceLen)
    uLong sourceLen;
{
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13;
}



================================================
File: src/zlib/crc32.c
================================================
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2006, 2010, 2011, 2012 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
 * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
 * tables for updating the shift register in one step with three exclusive-ors
 * instead of four steps with four exclusive-ors.  This results in about a
 * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
 */

/* @(#) $Id$ */

/*
  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
  protection on the static variables used to control the first-use generation
  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
  first call get_crc_table() to initialize the tables before allowing more than
  one thread to use crc32().

  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
 */

#ifdef MAKECRCH
#  include <stdio.h>
#  ifndef DYNAMIC_CRC_TABLE
#    define DYNAMIC_CRC_TABLE
#  endif /* !DYNAMIC_CRC_TABLE */
#endif /* MAKECRCH */

#include "zutil.h"      /* for STDC and FAR definitions */

#define local static

/* Definitions for doing the crc four data bytes at a time. */
#if !defined(NOBYFOUR) && defined(Z_U4)
#  define BYFOUR
#endif
#ifdef BYFOUR
   local unsigned long crc32_little OF((unsigned long,
                        const unsigned char FAR *, unsigned));
   local unsigned long crc32_big OF((unsigned long,
                        const unsigned char FAR *, unsigned));
#  define TBLS 8
#else
#  define TBLS 1
#endif /* BYFOUR */

/* Local functions for crc concatenation */
local unsigned long gf2_matrix_times OF((unsigned long *mat,
                                         unsigned long vec));
local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));


#ifdef DYNAMIC_CRC_TABLE

local volatile int crc_table_empty = 1;
local z_crc_t FAR crc_table[TBLS][256];
local void make_crc_table OF((void));
#ifdef MAKECRCH
   local void write_table OF((FILE *, const z_crc_t FAR *));
#endif /* MAKECRCH */
/*
  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The first table is simply the CRC of all possible eight bit values.  This is
  all the information needed to generate CRCs on data a byte at a time for all
  combinations of CRC register values and incoming bytes.  The remaining tables
  allow for word-at-a-time CRC calculation for both big-endian and little-
  endian machines, where a word is four bytes.
*/
local void make_crc_table()
{
    z_crc_t c;
    int n, k;
    z_crc_t poly;                       /* polynomial exclusive-or pattern */
    /* terms of polynomial defining this crc (except x^32): */
    static volatile int first = 1;      /* flag to limit concurrent making */
    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

    /* See if another task is already doing this (not thread-safe, but better
       than nothing -- significantly reduces duration of vulnerability in
       case the advice about DYNAMIC_CRC_TABLE is ignored) */
    if (first) {
        first = 0;

        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
        poly = 0;
        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
            poly |= (z_crc_t)1 << (31 - p[n]);

        /* generate a crc for every 8-bit value */
        for (n = 0; n < 256; n++) {
            c = (z_crc_t)n;
            for (k = 0; k < 8; k++)
                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
            crc_table[0][n] = c;
        }

#ifdef BYFOUR
        /* generate crc for each value followed by one, two, and three zeros,
           and then the byte reversal of those as well as the first table */
        for (n = 0; n < 256; n++) {
            c = crc_table[0][n];
            crc_table[4][n] = ZSWAP32(c);
            for (k = 1; k < 4; k++) {
                c = crc_table[0][c & 0xff] ^ (c >> 8);
                crc_table[k][n] = c;
                crc_table[k + 4][n] = ZSWAP32(c);
            }
        }
#endif /* BYFOUR */

        crc_table_empty = 0;
    }
    else {      /* not first */
        /* wait for the other guy to finish (not efficient, but rare) */
        while (crc_table_empty)
            ;
    }

#ifdef MAKECRCH
    /* write out CRC tables to crc32.h */
    {
        FILE *out;

        out = fopen("crc32.h", "w");
        if (out == NULL) return;
        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
        fprintf(out, "local const z_crc_t FAR ");
        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
        write_table(out, crc_table[0]);
#  ifdef BYFOUR
        fprintf(out, "#ifdef BYFOUR\n");
        for (k = 1; k < 8; k++) {
            fprintf(out, "  },\n  {\n");
            write_table(out, crc_table[k]);
        }
        fprintf(out, "#endif\n");
#  endif /* BYFOUR */
        fprintf(out, "  }\n};\n");
        fclose(out);
    }
#endif /* MAKECRCH */
}

#ifdef MAKECRCH
local void write_table(out, table)
    FILE *out;
    const z_crc_t FAR *table;
{
    int n;

    for (n = 0; n < 256; n++)
        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
                (unsigned long)(table[n]),
                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
}
#endif /* MAKECRCH */

#else /* !DYNAMIC_CRC_TABLE */
/* ========================================================================
 * Tables of CRC-32s of all single-byte values, made by make_crc_table().
 */
#include "crc32.h"
#endif /* DYNAMIC_CRC_TABLE */

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const z_crc_t FAR * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */
    return (const z_crc_t FAR *)crc_table;
}

/* ========================================================================= */
#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1

/* ========================================================================= */
local unsigned long crc32_generic(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0UL;

#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */

#ifdef BYFOUR
    if (sizeof(void *) == sizeof(ptrdiff_t)) {
        z_crc_t endian;

        endian = 1;
        if (*((unsigned char *)(&endian)))
            return crc32_little(crc, buf, len);
        else
            return crc32_big(crc, buf, len);
    }
#endif /* BYFOUR */
    crc = crc ^ 0xffffffffUL;
    while (len >= 8) {
        DO8;
        len -= 8;
    }
    if (len) do {
        DO1;
    } while (--len);
    return crc ^ 0xffffffffUL;
}

#ifdef HAS_PCLMUL

#define PCLMUL_MIN_LEN 64
#define PCLMUL_ALIGN 16
#define PCLMUL_ALIGN_MASK 15

/* Function stolen from linux kernel 3.14. It computes the CRC over the given
 * buffer with initial CRC value <crc32>. The buffer is <len> byte in length,
 * and must be 16-byte aligned.
 */
extern uint crc32_pclmul_le_16(unsigned char const *buffer,
                               size_t len, uInt crc32);

uLong crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (len < PCLMUL_MIN_LEN + PCLMUL_ALIGN  - 1)
      return crc32_generic(crc, buf, len);

    /* Handle the leading patial chunk */
    uInt misalign = PCLMUL_ALIGN_MASK & ((unsigned long)buf);
    uInt sz = (PCLMUL_ALIGN - misalign) % PCLMUL_ALIGN;
    if (sz) {
      crc = crc32_generic(crc, buf, sz);
      buf += sz;
      len -= sz;
    }

    /* Go over 16-byte chunks */
    crc = crc32_pclmul_le_16(buf, (len & ~PCLMUL_ALIGN_MASK),
                             crc ^ 0xffffffffUL);
    crc = crc ^ 0xffffffffUL;

    /* Handle the trailing partial chunk */
    sz = len & PCLMUL_ALIGN_MASK;
    if (sz) {
      crc = crc32_generic(crc, buf + len - sz, sz);
    }

    return crc;
}
#undef PCLMUL_MIN_LEN
#undef PCLMUL_ALIGN
#undef PCLMUL_ALIGN_MASK

#else
uLong crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    return crc32_generic(crc, buf, len);
}
#endif

#ifdef BYFOUR

/* ========================================================================= */
#define DOLIT4 c ^= *buf4++; \
        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4

/* ========================================================================= */
local unsigned long crc32_little(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    unsigned len;
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = (z_crc_t)crc;
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    while (len >= 32) {
        DOLIT32;
        len -= 32;
    }
    while (len >= 4) {
        DOLIT4;
        len -= 4;
    }
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    } while (--len);
    c = ~c;
    return (unsigned long)c;
}

/* ========================================================================= */
#define DOBIG4 c ^= *++buf4; \
        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4

/* ========================================================================= */
local unsigned long crc32_big(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    unsigned len;
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = ZSWAP32((z_crc_t)crc);
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    buf4--;
    while (len >= 32) {
        DOBIG32;
        len -= 32;
    }
    while (len >= 4) {
        DOBIG4;
        len -= 4;
    }
    buf4++;
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    } while (--len);
    c = ~c;
    return (unsigned long)(ZSWAP32(c));
}

#endif /* BYFOUR */

#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */

/* ========================================================================= */
local unsigned long gf2_matrix_times(mat, vec)
    unsigned long *mat;
    unsigned long vec;
{
    unsigned long sum;

    sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}

/* ========================================================================= */
local void gf2_matrix_square(square, mat)
    unsigned long *square;
    unsigned long *mat;
{
    int n;

    for (n = 0; n < GF2_DIM; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}

/* ========================================================================= */
local uLong crc32_combine_(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off64_t len2;
{
    int n;
    unsigned long row;
    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */

    /* degenerate case (also disallow negative lengths) */
    if (len2 <= 0)
        return crc1;

    /* put operator for one zero bit in odd */
    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
    row = 1;
    for (n = 1; n < GF2_DIM; n++) {
        odd[n] = row;
        row <<= 1;
    }

    /* put operator for two zero bits in even */
    gf2_matrix_square(even, odd);

    /* put operator for four zero bits in odd */
    gf2_matrix_square(odd, even);

    /* apply len2 zeros to crc1 (first square will put the operator for one
       zero byte, eight zero bits, in even) */
    do {
        /* apply zeros operator for this bit of len2 */
        gf2_matrix_square(even, odd);
        if (len2 & 1)
            crc1 = gf2_matrix_times(even, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
        if (len2 == 0)
            break;

        /* another iteration of the loop with odd and even swapped */
        gf2_matrix_square(odd, even);
        if (len2 & 1)
            crc1 = gf2_matrix_times(odd, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
    } while (len2 != 0);

    /* return combined crc */
    crc1 ^= crc2;
    return crc1;
}

/* ========================================================================= */
uLong ZEXPORT crc32_combine(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off_t len2;
{
    return crc32_combine_(crc1, crc2, len2);
}

uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off64_t len2;
{
    return crc32_combine_(crc1, crc2, len2);
}



================================================
File: src/zlib/crc32.h
================================================
/* crc32.h -- tables for rapid CRC calculation
 * Generated automatically by crc32.c
 */

local const z_crc_t FAR crc_table[TBLS][256] =
{
  {
    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
    0x2d02ef8dUL
#ifdef BYFOUR
  },
  {
    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
    0x9324fd72UL
  },
  {
    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
    0xbe9834edUL
  },
  {
    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
    0xde0506f1UL
  },
  {
    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
    0x8def022dUL
  },
  {
    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
    0x72fd2493UL
  },
  {
    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
    0xed3498beUL
  },
  {
    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
    0xf10605deUL
#endif
  }
};



================================================
File: src/zlib/deflate.c
================================================
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in http://tools.ietf.org/html/rfc1951
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#include "deflate.h"
#include <immintrin.h>

const char deflate_copyright[] =
   " deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func)(deflate_state *s, int flush);
/* Compression function. Returns the block state after the call. */

static void fill_window(deflate_state *s);
static block_state deflate_stored(deflate_state *s, int flush);
static block_state deflate_fast(deflate_state *s, int flush);
static block_state deflate_slow(deflate_state *s, int flush);
static block_state deflate_rle(deflate_state *s, int flush);
static block_state deflate_huff(deflate_state *s, int flush);
static void lm_init(deflate_state *s);
static void putShortMSB(deflate_state *s, uint32_t b);
static void flush_pending(z_streamp strm);
static int read_buf(z_streamp strm, uint8_t  *buf, uint32_t  size);

#ifdef DEBUG
static  void check_match(deflate_state *s, IPos start, IPos match,
                            int length);
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */
#define ACTUAL_MIN_MATCH 4
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   uint16_t good_length; /* reduce lazy search above this match length */
   uint16_t max_lazy;    /* do not perform lazy search above this match length */
   uint16_t nice_length; /* quit search above this match length */
   uint16_t max_chain;
   compress_func func;
} config;

static const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
#define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))

static uint32_t hash_func(deflate_state *s, void* str) {
    return _mm_crc32_u32(0, *(uint32_t*)str) & s->hash_mask;
}
/* ===========================================================================
 * Insert string str in the dictionary and return the previous head
 * of the hash chain (the most recent string with same hash key).
 * IN  assertion: ACTUAL_MIN_MATCH bytes of str are valid
 *    (except for the last ACTUAL_MIN_MATCH-1 bytes of the input file).
 */
static Pos insert_string(deflate_state *s, Pos str) {
    Pos match_head;
    s->ins_h = hash_func(s, &s->window[str]);
    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h];
    s->head[s->ins_h] = (Pos)str;
    return match_head;
}

static void bulk_insert_str(deflate_state *s, Pos startpos, uint32_t count) {
    uint32_t idx;
    for (idx = 0; idx < count; idx++) {
        s->ins_h = hash_func(s, &s->window[startpos + idx]);
        s->prev[(startpos + idx) & s->w_mask] = s->head[s->ins_h];
        s->head[s->ins_h] = (Pos)(startpos + idx);
    }
}

static int _tr_tally_lit(deflate_state *s, uint8_t cc) {
    s->d_buf[s->last_lit] = 0;
    s->l_buf[s->last_lit++] = cc;
    s->dyn_ltree[cc].Freq++;
    return (s->last_lit == s->lit_bufsize-1);
}

static int _tr_tally_dist(deflate_state *s, uint16_t dist, uint8_t len) {
    s->d_buf[s->last_lit] = dist;
    s->l_buf[s->last_lit++] = len;
    dist--;
    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++;
    s->dyn_dtree[d_code(dist)].Freq++;
    return (s->last_lit == s->lit_bufsize-1);
}
/* ===========================================================================
 * Initialize the hash table prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    zmemzero((uint8_t *)s->head, (unsigned)(s->hash_size)*sizeof(*s->head));

/* ========================================================================= */
int ZEXPORT deflateInit_(strm, level, version, stream_size)
    z_streamp strm;
    int level;
    const char *version;
    int stream_size;
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
                  version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
    deflate_state *s;
    int wrap = 1;
    static const char my_version[] = ZLIB_VERSION;

    uint16_t *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
        return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif

    if (level == Z_DEFAULT_COMPRESSION) level = 6;

    if (windowBits < 0) { /* suppress zlib wrapper */
        wrap = 0;
        windowBits = -windowBits;
    }
    else if (windowBits > 15) {
        wrap = 2;       /* write gzip wrapper instead */
        windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state *)s;
    s->strm = strm;

    s->wrap = wrap;
    s->gzhead = Z_NULL;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;

    s->window = (uint8_t *) ZALLOC(strm, s->w_size, 2*sizeof(uint8_t));
    s->prev   = (Pos *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Pos *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->high_water = 0;      /* nothing written to s->window yet */

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (uint16_t *) ZALLOC(strm, s->lit_bufsize, sizeof(uint16_t)+2);
    s->pending_buf = (uint8_t *) overlay;
    s->pending_buf_size = (uint64_t)s->lit_bufsize * (sizeof(uint16_t)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        s->status = FINISH_STATE;
        strm->msg = ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(uint16_t);
    s->l_buf = s->pending_buf + (1+sizeof(uint16_t))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (uint8_t)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    const uint8_t  *dictionary;
    uint32_t  dictLength;
{
    deflate_state *s;
    uint32_t str, n;
    int wrap;
    uint32_t  avail;
    z_const uint8_t *next;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
        return Z_STREAM_ERROR;
    s = strm->state;
    wrap = s->wrap;
    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
        return Z_STREAM_ERROR;

    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
    if (wrap == 1)
        strm->adler = adler32(strm->adler, dictionary, dictLength);
    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

    /* if dictionary would fill window, just replace the history */
    if (dictLength >= s->w_size) {
        if (wrap == 0) {            /* already empty otherwise */
            CLEAR_HASH(s);
            s->strstart = 0;
            s->block_start = 0L;
            s->insert = 0;
        }
        dictionary += dictLength - s->w_size;  /* use the tail */
        dictLength = s->w_size;
    }

    /* insert dictionary into window and hash */
    avail = strm->avail_in;
    next = strm->next_in;
    strm->avail_in = dictLength;
    strm->next_in = (z_const uint8_t*)dictionary;
    fill_window(s);
    while (s->lookahead >= ACTUAL_MIN_MATCH) {
        str = s->strstart;
       	n = s->lookahead - (ACTUAL_MIN_MATCH-1);
        bulk_insert_str(s, str, n);
        s->strstart = str + n;
        s->lookahead = ACTUAL_MIN_MATCH-1;
        fill_window(s);
    }
    s->strstart += s->lookahead;
    s->block_start = (long)s->strstart;
    s->insert = s->lookahead;
    s->lookahead = 0;
    s->match_length = s->prev_length = ACTUAL_MIN_MATCH-1;
    s->match_available = 0;
    strm->next_in = next;
    strm->avail_in = avail;
    s->wrap = wrap;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateResetKeep (strm)
    z_streamp strm;
{
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
        return Z_STREAM_ERROR;
    }

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->wrap < 0) {
        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
    }
    s->status = s->wrap ? INIT_STATE : BUSY_STATE;
    strm->adler =
        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
        adler32(0L, Z_NULL, 0);
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset (strm)
    z_streamp strm;
{
    int ret;

    ret = deflateResetKeep(strm);
    if (ret == Z_OK)
        lm_init(strm->state);
    return ret;
}

/* ========================================================================= */
int ZEXPORT deflateSetHeader (strm, head)
    z_streamp strm;
    gz_headerp head;
{
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
    strm->state->gzhead = head;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePending (strm, pending, bits)
    uint32_t  *pending;
    int *bits;
    z_streamp strm;
{
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    if (pending != Z_NULL)
        *pending = strm->state->pending;
    if (bits != Z_NULL)
        *bits = strm->state->bi_valid;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePrime (strm, bits, value)
    z_streamp strm;
    int bits;
    int value;
{
    deflate_state *s;
    int put;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
    if ((uint8_t *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
        return Z_BUF_ERROR;
    do {
        put = Buf_size - s->bi_valid;
        if (put > bits)
            put = bits;
        s->bi_buf |= (uint16_t)((value & ((1 << put) - 1)) << s->bi_valid);
        s->bi_valid += put;
        _tr_flush_bits(s);
        value >>= put;
        bits -= put;
    } while (bits);
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

    if (level == Z_DEFAULT_COMPRESSION) level = 6;
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        strm->total_in != 0) {
        /* Flush the last buffer: */
        err = deflate(strm, Z_BLOCK);
        if (err == Z_BUF_ERROR && s->pending == 0)
            err = Z_OK;
    }
    if (s->level != level) {
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* ========================================================================= */
int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
    z_streamp strm;
    int good_length;
    int max_lazy;
    int nice_length;
    int max_chain;
{
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
    s->good_match = good_length;
    s->max_lazy_match = max_lazy;
    s->nice_match = nice_length;
    s->max_chain_length = max_chain;
    return Z_OK;
}

/* =========================================================================
 * For the default windowBits of 15 and memLevel of 8, this function returns
 * a close to exact, as well as small, upper bound on the compressed size.
 * They are coded as constants here for a reason--if the #define's are
 * changed, then this function needs to be changed as well.  The return
 * value for 15 and 8 only works for those exact settings.
 *
 * For any setting other than those defaults for windowBits and memLevel,
 * the value returned is a conservative worst case for the maximum expansion
 * resulting from using fixed blocks instead of stored blocks, which deflate
 * can emit on compressed data for some combinations of the parameters.
 *
 * This function could be more sophisticated to provide closer upper bounds for
 * every combination of windowBits and memLevel.  But even the conservative
 * upper bound of about 14% expansion does not seem onerous for output buffer
 * allocation.
 */
uint64_t ZEXPORT deflateBound(strm, sourceLen)
    z_streamp strm;
    uint64_t sourceLen;
{
    deflate_state *s;
    uint64_t complen, wraplen;
    uint8_t  *str;

    /* conservative upper bound for compressed data */
    complen = sourceLen +
              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

    /* if can't get parameters, return conservative bound plus zlib wrapper */
    if (strm == Z_NULL || strm->state == Z_NULL)
        return complen + 6;

    /* compute wrapper length */
    s = strm->state;
    switch (s->wrap) {
    case 0:                                 /* raw deflate */
        wraplen = 0;
        break;
    case 1:                                 /* zlib wrapper */
        wraplen = 6 + (s->strstart ? 4 : 0);
        break;
    case 2:                                 /* gzip wrapper */
        wraplen = 18;
        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
            if (s->gzhead->extra != Z_NULL)
                wraplen += 2 + s->gzhead->extra_len;
            str = s->gzhead->name;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            str = s->gzhead->comment;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            if (s->gzhead->hcrc)
                wraplen += 2;
        }
        break;
    default:                                /* for compiler happiness */
        wraplen = 6;
    }

    /* if not default parameters, return conservative bound */
    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
        return complen + wraplen;

    /* default settings: return tight bound for that case */
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13 - 6 + wraplen;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
static void putShortMSB (s, b)
    deflate_state *s;
    uint32_t b;
{
    put_byte(s, (uint8_t)(b >> 8));
    put_byte(s, (uint8_t)(b & 0xff));
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
static void flush_pending(strm)
    z_streamp strm;
{
    uint32_t  len;
    deflate_state *s = strm->state;

    _tr_flush_bits(s);
    len = s->pending;
    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, s->pending_out, len);
    strm->next_out  += len;
    s->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    s->pending -= len;
    if (s->pending == 0) {
        s->pending_out = s->pending_buf;
    }
}

/* ========================================================================= */
int ZEXPORT deflate (strm, flush)
    z_streamp strm;
    int flush;
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
        flush > Z_BLOCK || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
        (s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the header */
    if (s->status == INIT_STATE) {
        if (s->wrap == 2) {
            strm->adler = crc32(0L, Z_NULL, 0);
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (s->gzhead == Z_NULL) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s->level == 9 ? 2 :
                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                             4 : 0));
                put_byte(s, OS_CODE);
                s->status = BUSY_STATE;
            }
            else {
                put_byte(s, (s->gzhead->text ? 1 : 0) +
                            (s->gzhead->hcrc ? 2 : 0) +
                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
                            (s->gzhead->name == Z_NULL ? 0 : 8) +
                            (s->gzhead->comment == Z_NULL ? 0 : 16)
                        );
                put_byte(s, (uint8_t)(s->gzhead->time & 0xff));
                put_byte(s, (uint8_t)((s->gzhead->time >> 8) & 0xff));
                put_byte(s, (uint8_t)((s->gzhead->time >> 16) & 0xff));
                put_byte(s, (uint8_t)((s->gzhead->time >> 24) & 0xff));
                put_byte(s, s->level == 9 ? 2 :
                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                             4 : 0));
                put_byte(s, s->gzhead->os & 0xff);
                if (s->gzhead->extra != Z_NULL) {
                    put_byte(s, s->gzhead->extra_len & 0xff);
                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
                }
                if (s->gzhead->hcrc)
                    strm->adler = crc32(strm->adler, s->pending_buf,
                                        s->pending);
                s->gzindex = 0;
                s->status = EXTRA_STATE;
            }
        }
        else
        {
            uint32_t header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
            uint32_t level_flags;

            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
                level_flags = 0;
            else if (s->level < 6)
                level_flags = 1;
            else if (s->level == 6)
                level_flags = 2;
            else
                level_flags = 3;
            header |= (level_flags << 6);
            if (s->strstart != 0) header |= PRESET_DICT;
            header += 31 - (header % 31);

            s->status = BUSY_STATE;
            putShortMSB(s, header);

            /* Save the adler32 of the preset dictionary: */
            if (s->strstart != 0) {
                putShortMSB(s, (uint32_t)(strm->adler >> 16));
                putShortMSB(s, (uint32_t)(strm->adler & 0xffff));
            }
            strm->adler = adler32(0L, Z_NULL, 0);
        }
    }
    if (s->status == EXTRA_STATE) {
        if (s->gzhead->extra != Z_NULL) {
            uint32_t beg = s->pending;  /* start of bytes to update crc */

            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size)
                        break;
                }
                put_byte(s, s->gzhead->extra[s->gzindex]);
                s->gzindex++;
            }
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (s->gzindex == s->gzhead->extra_len) {
                s->gzindex = 0;
                s->status = NAME_STATE;
            }
        }
        else
            s->status = NAME_STATE;
    }
    if (s->status == NAME_STATE) {
        if (s->gzhead->name != Z_NULL) {
            uint32_t beg = s->pending;  /* start of bytes to update crc */
            int val;

            do {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                val = s->gzhead->name[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (val == 0) {
                s->gzindex = 0;
                s->status = COMMENT_STATE;
            }
        }
        else
            s->status = COMMENT_STATE;
    }
    if (s->status == COMMENT_STATE) {
        if (s->gzhead->comment != Z_NULL) {
            uint32_t beg = s->pending;  /* start of bytes to update crc */
            int val;

            do {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                val = s->gzhead->comment[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (val == 0)
                s->status = HCRC_STATE;
        }
        else
            s->status = HCRC_STATE;
    }
    if (s->status == HCRC_STATE) {
        if (s->gzhead->hcrc) {
            if (s->pending + 2 > s->pending_buf_size)
                flush_pending(strm);
            if (s->pending + 2 <= s->pending_buf_size) {
                put_byte(s, (uint8_t)(strm->adler & 0xff));
                put_byte(s, (uint8_t)((strm->adler >> 8) & 0xff));
                strm->adler = crc32(0L, Z_NULL, 0);
                s->status = BUSY_STATE;
            }
        }
        else
            s->status = BUSY_STATE;
    }

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
            /* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */
            s->last_flush = -1;
            return Z_OK;
        }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
               flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

        bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
                        (*(configuration_table[s->level].func))(s, flush));

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
            if (strm->avail_out == 0) {
                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
            }
            return Z_OK;
            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */
        }
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (uint8_t*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                    if (s->lookahead == 0) {
                        s->strstart = 0;
                        s->block_start = 0L;
                        s->insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm->avail_out == 0) {
              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
              return Z_OK;
            }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->wrap <= 0) return Z_STREAM_END;

    /* Write the trailer */
    if (s->wrap == 2) {
        put_byte(s, (uint8_t)(strm->adler & 0xff));
        put_byte(s, (uint8_t)((strm->adler >> 8) & 0xff));
        put_byte(s, (uint8_t)((strm->adler >> 16) & 0xff));
        put_byte(s, (uint8_t)((strm->adler >> 24) & 0xff));
        put_byte(s, (uint8_t)(strm->total_in & 0xff));
        put_byte(s, (uint8_t)((strm->total_in >> 8) & 0xff));
        put_byte(s, (uint8_t)((strm->total_in >> 16) & 0xff));
        put_byte(s, (uint8_t)((strm->total_in >> 24) & 0xff));
    }
    else
    {
        putShortMSB(s, (uint32_t)(strm->adler >> 16));
        putShortMSB(s, (uint32_t)(strm->adler & 0xffff));
    }
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd (strm)
    z_streamp strm;
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    status = strm->state->status;
    if (status != INIT_STATE &&
        status != EXTRA_STATE &&
        status != NAME_STATE &&
        status != COMMENT_STATE &&
        status != HCRC_STATE &&
        status != BUSY_STATE &&
        status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy (dest, source)
    z_streamp dest;
    z_streamp source;
{
    deflate_state *ds;
    deflate_state *ss;
    uint16_t *overlay;


    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state *) ds;
    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
    ds->strm = dest;

    ds->window = (uint8_t *) ZALLOC(dest, ds->w_size, 2*sizeof(uint8_t));
    ds->prev   = (Pos *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Pos *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (uint16_t *) ZALLOC(dest, ds->lit_bufsize, sizeof(uint16_t)+2);
    ds->pending_buf = (uint8_t *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(uint8_t));
    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uint32_t)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(uint16_t);
    ds->l_buf = ds->pending_buf + (1+sizeof(uint16_t))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
static int read_buf(strm, buf, size)
    z_streamp strm;
    uint8_t  *buf;
    uint32_t  size;
{
    uint32_t  len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    zmemcpy(buf, strm->next_in, len);
    if (strm->state->wrap == 1) {
        strm->adler = adler32(strm->adler, buf, len);
    }
    else if (strm->state->wrap == 2) {
        strm->adler = crc32(strm->adler, buf, len);
    }
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
static void lm_init (s)
    deflate_state *s;
{
    s->window_size = (uint64_t)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->insert = 0;
    s->match_length = s->prev_length = ACTUAL_MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
}

/* longest_match() with minor change to improve performance (in terms of
 * execution time).
 *
 * The pristine longest_match() function is sketched bellow (strip the
 * then-clause of the "#ifdef UNALIGNED_OK"-directive)
 *
 * ------------------------------------------------------------
 * uInt longest_match(...) {
 *    ...   
 *    do {
 *        match = s->window + cur_match;                //s0
 *        if (*(ushf*)(match+best_len-1) != scan_end || //s1
 *            *(ushf*)match != scan_start) continue;    //s2
 *        ...
 *
 *        do {
 *        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
 *                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
 *                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
 *                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
 *                 scan < strend); //s3
 *
 *        ...
 *    } while(cond); //s4
 *
 * -------------------------------------------------------------
 *
 * The change include:
 *
 *  1) The hottest statements of the function is: s0, s1 and s4. Pull them
 *     together to form a new loop. The benefit is two-fold:
 *
 *    o. Ease the compiler to yield good code layout: the conditional-branch
 *       corresponding to s1 and its biased target s4 become very close (likely,
 *       fit in the same cache-line), hence improving instruction-fetching
 *       efficiency.
 *
 *    o. Ease the compiler to promote "s->window" into register. "s->window"
 *       is loop-invariant; it is supposed to be promoted into register and keep
 *       the value throughout the entire loop. However, there are many such
 *       loop-invariant, and x86-family has small register file; "s->window" is
 *       likely to be chosen as register-allocation victim such that its value
 *       is reloaded from memory in every single iteration. By forming a new loop,
 *       "s->window" is loop-invariant of that newly created tight loop. It is
 *       lot easier for compiler to promote this quantity to register and keep
 *       its value throughout the entire small loop.
 * 
 * 2) Transfrom s3 such that it examines sizeof(long)-byte-match at a time.
 *    This is done by:
 *        ------------------------------------------------
 *        v1 = load from "scan" by sizeof(long) bytes
 *        v2 = load from "match" by sizeof(lnog) bytes
 *        v3 = v1 xor v2
 *        match-bit = little-endian-machine(yes-for-x86) ?
 *                     count-trailing-zero(v3) :
 *                     count-leading-zero(v3);
 *
 *        match-byte = match-bit/8
 *
 *        "scan" and "match" advance if necessary
 *       -------------------------------------------------
 */

#ifndef _WIN64
unsigned char _BitScanForward64(unsigned long *r, unsigned __int64 x)
{
	unsigned char c = _BitScanForward(r, x);
	if (!c)
	{
		c = _BitScanForward(r, x >> 32);
		if (c)
			*r += 32;
	}
	return c;
}
#endif

static uint32_t longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    uint32_t chain_length = s->max_chain_length;      /* max hash chain length */
    register uint8_t *scan = s->window + s->strstart; /* current string */
    register uint8_t *match;                          /* matched string */
    register int len;                                 /* length of current match */
    int best_len = s->prev_length;                    /* best match length so far */
    int nice_match = s->nice_match;                   /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Pos *prev = s->prev;
    uint32_t wmask = s->w_mask;

    register uint8_t *strend = s->window + s->strstart + MAX_MATCH;
    /* We optimize for a minimal match of four bytes */
    register uint32_t scan_start = *(uint32_t*)scan;
    register uint32_t scan_end   = *(uint32_t*)(scan+best_len-3);

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uint32_t)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((uint64_t)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */
        auto win = s->window;
        int cont = 1;
        do {
            match = win + cur_match;
            if (likely(*(uint32_t*)(match+best_len-3) != scan_end) || (*(uint32_t*)match != scan_start)) {
                if ((cur_match = prev[cur_match & wmask]) > limit
                    && --chain_length != 0) {
                    continue;
                } else
                    cont = 0;
            }
            break;
        } while (1);

        if (!cont)
            break;

        scan += 4, match+=4;
        do {
            uint64_t sv = *(uint64_t*)(void*)scan;
            uint64_t mv = *(uint64_t*)(void*)match;
            uint64_t xor = sv ^ mv;
            if (xor) {
				unsigned __int32 i;
				_BitScanForward64(&i, xor);
                int match_byte = i / 8;
                scan += match_byte;
                match += match_byte;
                break;
            } else {
                scan += 8;
                match += 8;
            }
        } while (scan < strend);

        if (scan > strend)
            scan = strend;

        Assert(scan <= s->window+(uint32_t)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
            scan_end = *(uint32_t*)(scan+best_len-3);
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uint32_t)best_len <= s->lookahead) return (uint32_t)best_len;
    return s->lookahead;
}

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
static void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
                start, match, length);
        do {
            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
        } while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif /* DEBUG */

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
static void fill_window(s)
    deflate_state *s;
{
    register uint32_t  n, m;
    register Pos *p;
    uint32_t more;    /* Amount of free space at the end of the window. */
    uint32_t wsize = s->w_size;

    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

    do {
        more = (unsigned)(s->window_size -(uint64_t)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (sizeof(int) <= 2) {
            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                more = wsize;

            } else if (more == (unsigned)(-1)) {
                /* Very unlikely, but possible on 16 bit machine if
                 * strstart == 0 && lookahead == 1 (input done a byte at time)
                 */
                more--;
            }
        }

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (int64_t) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level > 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */
            
            /* Use intrinsics, because compiler generates suboptimal code */
            n = s->hash_size;
            __m128i W = _mm_set1_epi16(wsize);
            __m128i *q = (__m128i*)s->head;
            int i;
            /* hash size would always be a pot */
            for(i=0; i<n/8; i++) {
                _mm_storeu_si128(q, _mm_subs_epu16(_mm_loadu_si128(q), W));
                q++;
            }

            n = wsize;
            q = (__m128i*)s->prev;
            /* assuming wsize would always be a pot */
            for(i=0; i<n/8; i++) {
                _mm_storeu_si128(q, _mm_subs_epu16(_mm_loadu_si128(q), W));
                q++;
            }

            more += wsize;
        }
        if (s->strm->avail_in == 0) break;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead + s->insert >= ACTUAL_MIN_MATCH) {
            uint32_t str = s->strstart - s->insert;
            uint32_t ins_h = s->window[str];
            while (s->insert) {
                ins_h = hash_func(s, &s->window[str]);
                s->prev[str & s->w_mask] = s->head[ins_h];
                s->head[ins_h] = (Pos)str;
                str++;
                s->insert--;
                if (s->lookahead + s->insert < ACTUAL_MIN_MATCH)
                    break;
            }
            s->ins_h = ins_h;
        }
        /* If the whole input has less than ACTUAL_MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

    /* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */
    if (s->high_water < s->window_size) {
        uint64_t curr = s->strstart + (ulg)(s->lookahead);
        uint64_t init;

        if (s->high_water < curr) {
            /* Previous high water mark below current data -- zero WIN_INIT
             * bytes or up to end of window, whichever is less.
             */
            init = s->window_size - curr;
            if (init > WIN_INIT)
                init = WIN_INIT;
            zmemzero(s->window + curr, (unsigned)init);
            s->high_water = curr + init;
        }
        else if (s->high_water < (uint64_t)curr + WIN_INIT) {
            /* High water mark at or above current data, but below current data
             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
             * to end of window, whichever is less.
             */
            init = (uint64_t)curr + WIN_INIT - s->high_water;
            if (init > s->window_size - s->high_water)
                init = s->window_size - s->high_water;
            zmemzero(s->window + s->high_water, (unsigned)init);
            s->high_water += init;
        }
    }

    Assert((uint64_t)s->strstart <= s->window_size - MIN_LOOKAHEAD,
           "not enough room for search");
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, last) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (uint8_t *)&s->window[(uint64_t)s->block_start] : \
                   (uint8_t *)Z_NULL), \
                (uint64_t)((int64_t)s->strstart - s->block_start), \
                (last)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, last) { \
   FLUSH_BLOCK_ONLY(s, last); \
   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
static block_state deflate_stored(s, flush)
    deflate_state *s;
    int flush;
{
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    uint64_t max_block_size = 0xffff;
    uint64_t max_start;

    if (max_block_size > s->pending_buf_size - 5) {
        max_block_size = s->pending_buf_size - 5;
    }

    /* Copy as much as possible from input to output: */
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                   s->block_start >= (int64_t)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
        Assert(s->block_start >= 0L, "block gone");

        s->strstart += s->lookahead;
        s->lookahead = 0;

        /* Emit a stored block if pending_buf will be full: */
        max_start = s->block_start + max_block_size;
        if (s->strstart == 0 || (uint64_t)s->strstart >= max_start) {
            /* strstart == 0 is possible when wraparound on 16-bit machine */
            s->lookahead = (uint32_t)(s->strstart - max_start);
            s->strstart = (uint32_t)max_start;
            FLUSH_BLOCK(s, 0);
        }
        /* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s->strstart - (uint32_t)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
        }
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if ((int64_t)s->strstart > s->block_start)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
static block_state deflate_fast(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head;       /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus ACTUAL_MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= ACTUAL_MIN_MATCH) {
            hash_head = insert_string(s, s->strstart);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < ACTUAL_MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */
        }
        if (s->match_length >= ACTUAL_MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            bflush = _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= ACTUAL_MIN_MATCH) {
                s->match_length--; /* string at strstart already in table */
                do {
                    s->strstart++;
                    hash_head = insert_string(s, s->strstart);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always ACTUAL_MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++;
            } else {
                s->strstart += s->match_length;
                s->match_length = 0;
                /* If lookahead < ACTUAL_MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            bflush = _tr_tally_lit (s, s->window[s->strstart]);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = s->strstart < ACTUAL_MIN_MATCH-1 ? s->strstart : ACTUAL_MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
static block_state deflate_slow(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head;          /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus ACTUAL_MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+3] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= ACTUAL_MIN_MATCH) {
            hash_head = insert_string(s, s->strstart);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = ACTUAL_MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED )) {

                /* If prev_match is also ACTUAL_MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = ACTUAL_MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= ACTUAL_MIN_MATCH && s->match_length <= s->prev_length) {
            uint32_t max_insert = s->strstart + s->lookahead - ACTUAL_MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            bflush = _tr_tally_dist(s, s->strstart -1 - s->prev_match,
                           s->prev_length - MIN_MATCH);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;

            uint32_t mov_fwd = s->prev_length - 2;
            uint32_t insert_cnt = mov_fwd;
            if (unlikely(insert_cnt > max_insert - s->strstart))
                insert_cnt = max_insert - s->strstart;

            bulk_insert_str(s, s->strstart + 1, insert_cnt);
            s->prev_length = 0;
            s->match_available = 0;
            s->match_length = ACTUAL_MIN_MATCH-1;
            s->strstart += mov_fwd + 1;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
            bflush = _tr_tally_lit(s, s->window[s->strstart-1]);
            if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        bflush = _tr_tally_lit(s, s->window[s->strstart-1]);
        s->match_available = 0;
    }
    s->insert = s->strstart < ACTUAL_MIN_MATCH-1 ? s->strstart : ACTUAL_MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
static block_state deflate_rle(s, flush)
    deflate_state *s;
    int flush;
{
    int bflush;                 /* set if current block must be flushed */
    uint32_t prev;              /* byte at distance one to match */
    uint8_t  *scan, *strend;    /* scan goes up to strend for length of run */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */
        if (s->lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* See how many times the previous byte repeats */
        s->match_length = 0;
        if (s->lookahead >= ACTUAL_MIN_MATCH && s->strstart > 0) {
            scan = s->window + s->strstart - 1;
            prev = *scan;
            if (prev == *++scan && prev == *++scan && prev == *++scan) {
                strend = s->window + s->strstart + MAX_MATCH;
                do {
                } while (prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         scan < strend);
                s->match_length = MAX_MATCH - (int)(strend - scan);
                if (s->match_length > s->lookahead)
                    s->match_length = s->lookahead;
            }
            Assert(scan <= s->window+(uint32_t)(s->window_size-1), "wild scan");
        }

        /* Emit match if have run of ACTUAL_MIN_MATCH or longer, else emit literal */
        if (s->match_length >= ACTUAL_MIN_MATCH) {
            check_match(s, s->strstart, s->strstart - 1, s->match_length);

            bflush = _tr_tally_dist(s, 1, s->match_length - MIN_MATCH);

            s->lookahead -= s->match_length;
            s->strstart += s->match_length;
            s->match_length = 0;
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            bflush = _tr_tally_lit (s, s->window[s->strstart]);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
static block_state deflate_huff(s, flush)
    deflate_state *s;
    int flush;
{
    int bflush;             /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we have a literal to write. */
        if (s->lookahead == 0) {
            fill_window(s);
            if (s->lookahead == 0) {
                if (flush == Z_NO_FLUSH)
                    return need_more;
                break;      /* flush the current block */
            }
        }

        /* Output a literal byte */
        s->match_length = 0;
        Tracevv((stderr,"%c", s->window[s->strstart]));
        bflush = _tr_tally_lit (s, s->window[s->strstart]);
        s->lookahead--;
        s->strstart++;
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}



================================================
File: src/zlib/deflate.h
================================================
/* deflate.h -- internal compression state
 * Copyright (C) 1995-2012 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef DEFLATE_H
#define DEFLATE_H

#include "zutil.h"

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define Buf_size 64
/* size of bit buffer in bi_buf */

#define INIT_STATE    42
#define EXTRA_STATE   69
#define NAME_STATE    73
#define COMMENT_STATE 91
#define HCRC_STATE   103
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        uint16_t  freq;       /* frequency count */
        uint16_t  code;       /* bit string */
    } fc;
    union {
        uint16_t  dad;        /* father node in Huffman tree */
        uint16_t  len;        /* length of bit string */
    } dl;
} ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    static_tree_desc *stat_desc; /* the corresponding static tree */
} tree_desc;

typedef uint16_t Pos;
typedef uint32_t IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp  strm;              /* pointer back to this zlib stream */
    int        status;            /* as the name implies */
    uint8_t    *pending_buf;      /* output still pending */
    uint64_t   pending_buf_size;  /* size of pending_buf */
    uint8_t    *pending_out;      /* next pending byte to output to the stream */
    uint32_t   pending;           /* nb of bytes in the pending buffer */
    int        wrap;              /* bit 0 true for zlib, bit 1 true for gzip */
    gz_headerp gzhead;            /* gzip header information to write */
    uint32_t   gzindex;           /* where in extra, name, or comment */
    uint8_t    method;            /* can only be DEFLATED */
    int        last_flush;        /* value of flush param for previous deflate call */

    /* used by deflate.c: */
    uint32_t  w_size;        /* LZ77 window size (32K by default) */
    uint32_t  w_bits;        /* log2(w_size)  (8..16) */
    uint32_t  w_mask;        /* w_size - 1 */

    uint8_t *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    uint32_t window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Pos *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Pos *head; /* Heads of the hash chains or NIL. */

    uint32_t  ins_h;          /* hash index of string to be inserted */
    uint32_t  hash_size;      /* number of elements in hash table */
    uint32_t  hash_bits;      /* log2(hash_size) */
    uint32_t  hash_mask;      /* hash_size-1 */

    uint32_t  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uint32_t match_length;           /* length of best match */
    IPos prev_match;                 /* previous match */
    int match_available;             /* set if previous match exists */
    uint32_t strstart;               /* start of string to insert */
    uint32_t match_start;            /* start of matching string */
    uint32_t lookahead;              /* number of valid bytes ahead in window */

    uint32_t prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uint32_t max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uint32_t max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uint32_t good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

    /* used by trees.c: */
    /* Didn't use ct_data typedef below to suppress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    uint16_t bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uint8_t depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uint8_t *l_buf;          /* buffer for literals or lengths */

    uint32_t  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uint32_t last_lit;      /* running index in l_buf */

    uint16_t *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    uint64_t opt_len;        /* bit length of current block with optimal trees */
    uint64_t static_len;     /* bit length of current block with static trees */
    uint32_t matches;       /* number of string matches in current block */
    uint32_t insert;        /* bytes at end of window left to insert */

#ifdef DEBUG
    uint64_t compressed_len; /* total bit length of compressed file mod 2^32 */
    uint64_t bits_sent;      /* bit length of compressed data sent mod 2^32 */
#endif

    uint64_t bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

    uint64_t high_water;
    /* High water mark offset in window for initialized bytes -- bytes above
     * this are set to zero in order to avoid memory check warnings when
     * longest match routines access bytes past the input.  This is then
     * updated to the new high water mark.
     */

} deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */

#define put_short(s, w) { \
    s->pending += 2; \
    *(ush*)(&s->pending_buf[s->pending - 2]) = (w) ; \
}

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

#define WIN_INIT MAX_MATCH
/* Number of bytes after end of data in window to initialize in order to avoid
   memory checker errors from longest match routines */

        /* in trees.c */
void ZLIB_INTERNAL _tr_init(deflate_state *s);
int  ZLIB_INTERNAL _tr_tally(deflate_state *s, uint32_t dist, unsigned lc);
void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, uint8_t *buf,
                        uint64_t stored_len, int last);
void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s);
void ZLIB_INTERNAL _tr_align(deflate_state *s);
void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, uint8_t *buf,
                        uint64_t stored_len, int last);

#define d_code(dist) \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */

extern const uint8_t ZLIB_INTERNAL _length_code[];
extern const uint8_t ZLIB_INTERNAL _dist_code[];

#define likely(x) x
#define unlikely(x) x

#endif /* DEFLATE_H */



================================================
File: src/zlib/gzclose.c
================================================
/* gzclose.c -- zlib gzclose() function
 * Copyright (C) 2004, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* gzclose() is in a separate file so that it is linked in only if it is used.
   That way the other gzclose functions can be used instead to avoid linking in
   unneeded compression or decompression routines. */
int ZEXPORT gzclose(file)
    gzFile file;
{
#ifndef NO_GZCOMPRESS
    gz_statep state;

    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
#else
    return gzclose_r(file);
#endif
}



================================================
File: src/zlib/gzguts.h
================================================
/* gzguts.h -- zlib internal header definitions for gz* operations
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#ifdef _LARGEFILE64_SOURCE
#  ifndef _LARGEFILE_SOURCE
#    define _LARGEFILE_SOURCE 1
#  endif
#  ifdef _FILE_OFFSET_BITS
#    undef _FILE_OFFSET_BITS
#  endif
#endif

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include <stdio.h>
#include "zlib.h"
#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#  include <limits.h>
#endif
#include <fcntl.h>

#ifdef _WIN32
#  include <stddef.h>
#endif

#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
#  include <io.h>
#endif

#ifdef WINAPI_FAMILY
#  define open _open
#  define read _read
#  define write _write
#  define close _close
#endif

#ifdef NO_DEFLATE       /* for compatibility with old definition */
#  define NO_GZCOMPRESS
#endif

#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(__CYGWIN__)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)
#  ifndef HAVE_VSNPRINTF
#    define HAVE_VSNPRINTF
#  endif
#endif

#ifndef HAVE_VSNPRINTF
#  ifdef MSDOS
/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
   but for now we just assume it doesn't. */
#    define NO_vsnprintf
#  endif
#  ifdef __TURBOC__
#    define NO_vsnprintf
#  endif
#  ifdef WIN32
/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
#         define vsnprintf _vsnprintf
#      endif
#    endif
#  endif
#  ifdef __SASC
#    define NO_vsnprintf
#  endif
#  ifdef VMS
#    define NO_vsnprintf
#  endif
#  ifdef __OS400__
#    define NO_vsnprintf
#  endif
#  ifdef __MVS__
#    define NO_vsnprintf
#  endif
#endif

/* unlike snprintf (which is required in C99, yet still not supported by
   Microsoft more than a decade later!), _snprintf does not guarantee null
   termination of the result -- however this is only used in gzlib.c where
   the result is assured to fit in the space provided */
#ifdef _MSC_VER
#  define snprintf _snprintf
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

/* gz* functions always use library allocation functions */
#ifndef STDC
  extern voidp  malloc OF((uInt size));
  extern void   free   OF((voidpf ptr));
#endif

/* get errno and strerror definition */
#if defined UNDER_CE
#  include <windows.h>
#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
#else
#  ifndef NO_STRERROR
#    include <errno.h>
#    define zstrerror() strerror(errno)
#  else
#    define zstrerror() "stdio error (consult errno)"
#  endif
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
#endif

/* default memLevel */
#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif

/* default i/o buffer size -- double this for output when reading (this and
   twice this must be able to fit in an unsigned type) */
#define GZBUFSIZE 8192

/* gzip modes, also provide a little integrity check on the passed structure */
#define GZ_NONE 0
#define GZ_READ 7247
#define GZ_WRITE 31153
#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */

/* values for gz_state how */
#define LOOK 0      /* look for a gzip header */
#define COPY 1      /* copy input directly */
#define GZIP 2      /* decompress a gzip stream */

/* internal gzip file state data structure */
typedef struct {
        /* exposed contents for gzgetc() macro */
    struct gzFile_s x;      /* "x" for exposed */
                            /* x.have: number of bytes available at x.next */
                            /* x.next: next output data to deliver or write */
                            /* x.pos: current position in uncompressed data */
        /* used for both reading and writing */
    int mode;               /* see gzip modes above */
    int fd;                 /* file descriptor */
    char *path;             /* path or fd for error messages */
    unsigned size;          /* buffer size, zero if not allocated yet */
    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
    unsigned char *in;      /* input buffer */
    unsigned char *out;     /* output buffer (double-sized when reading) */
    int direct;             /* 0 if processing gzip, 1 if transparent */
        /* just for reading */
    int how;                /* 0: get header, 1: copy, 2: decompress */
    z_off64_t start;        /* where the gzip data started, for rewinding */
    int eof;                /* true if end of input file reached */
    int past;               /* true if read requested past end */
        /* just for writing */
    int level;              /* compression level */
    int strategy;           /* compression strategy */
        /* seek request */
    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
    int seek;               /* true if seek request pending */
        /* error information */
    int err;                /* error code */
    char *msg;              /* error message */
        /* zlib inflate or deflate stream */
    z_stream strm;          /* stream structure in-place (not a pointer) */
} gz_state;
typedef gz_state FAR *gz_statep;

/* shared functions */
void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));
#if defined UNDER_CE
char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));
#endif

/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
   value -- needed when comparing unsigned to z_off64_t, which is signed
   (possible z_off64_t types off_t, off64_t, and long are all signed) */
#ifdef INT_MAX
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
#else
unsigned ZLIB_INTERNAL gz_intmax OF((void));
#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
#endif



================================================
File: src/zlib/gzlib.c
================================================
/* gzlib.c -- zlib functions common to reading and writing gzip files
 * Copyright (C) 2004, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

#if defined(_WIN32) && !defined(__BORLANDC__)
#  define LSEEK _lseeki64
#else
#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
#  define LSEEK lseek64
#else
#  define LSEEK lseek
#endif
#endif

/* Local functions */
local void gz_reset OF((gz_statep));
local gzFile gz_open OF((const void *, int, const char *));

#if defined UNDER_CE

/* Map the Windows error number in ERROR to a locale-dependent error message
   string and return a pointer to it.  Typically, the values for ERROR come
   from GetLastError.

   The string pointed to shall not be modified by the application, but may be
   overwritten by a subsequent call to gz_strwinerror

   The gz_strwinerror function does not change the current setting of
   GetLastError. */
char ZLIB_INTERNAL *gz_strwinerror (error)
     DWORD error;
{
    static char buf[1024];

    wchar_t *msgbuf;
    DWORD lasterr = GetLastError();
    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL,
        error,
        0, /* Default language */
        (LPVOID)&msgbuf,
        0,
        NULL);
    if (chars != 0) {
        /* If there is an \r\n appended, zap it.  */
        if (chars >= 2
            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
            chars -= 2;
            msgbuf[chars] = 0;
        }

        if (chars > sizeof (buf) - 1) {
            chars = sizeof (buf) - 1;
            msgbuf[chars] = 0;
        }

        wcstombs(buf, msgbuf, chars + 1);
        LocalFree(msgbuf);
    }
    else {
        sprintf(buf, "unknown win32 error (%ld)", error);
    }

    SetLastError(lasterr);
    return buf;
}

#endif /* UNDER_CE */

/* Reset gzip file state */
local void gz_reset(state)
    gz_statep state;
{
    state->x.have = 0;              /* no output data available */
    if (state->mode == GZ_READ) {   /* for reading ... */
        state->eof = 0;             /* not at end of file */
        state->past = 0;            /* have not read past end yet */
        state->how = LOOK;          /* look for gzip header */
    }
    state->seek = 0;                /* no seek request pending */
    gz_error(state, Z_OK, NULL);    /* clear error */
    state->x.pos = 0;               /* no uncompressed data yet */
    state->strm.avail_in = 0;       /* no input data yet */
}

/* Open a gzip file either by name or file descriptor. */
local gzFile gz_open(path, fd, mode)
    const void *path;
    int fd;
    const char *mode;
{
    gz_statep state;
    size_t len;
    int oflag;
#ifdef O_CLOEXEC
    int cloexec = 0;
#endif
#ifdef O_EXCL
    int exclusive = 0;
#endif

    /* check input */
    if (path == NULL)
        return NULL;

    /* allocate gzFile structure to return */
    state = (gz_statep)malloc(sizeof(gz_state));
    if (state == NULL)
        return NULL;
    state->size = 0;            /* no buffers allocated yet */
    state->want = GZBUFSIZE;    /* requested buffer size */
    state->msg = NULL;          /* no error message yet */

    /* interpret mode */
    state->mode = GZ_NONE;
    state->level = Z_DEFAULT_COMPRESSION;
    state->strategy = Z_DEFAULT_STRATEGY;
    state->direct = 0;
    while (*mode) {
        if (*mode >= '0' && *mode <= '9')
            state->level = *mode - '0';
        else
            switch (*mode) {
            case 'r':
                state->mode = GZ_READ;
                break;
#ifndef NO_GZCOMPRESS
            case 'w':
                state->mode = GZ_WRITE;
                break;
            case 'a':
                state->mode = GZ_APPEND;
                break;
#endif
            case '+':       /* can't read and write at the same time */
                free(state);
                return NULL;
            case 'b':       /* ignore -- will request binary anyway */
                break;
#ifdef O_CLOEXEC
            case 'e':
                cloexec = 1;
                break;
#endif
#ifdef O_EXCL
            case 'x':
                exclusive = 1;
                break;
#endif
            case 'f':
                state->strategy = Z_FILTERED;
                break;
            case 'h':
                state->strategy = Z_HUFFMAN_ONLY;
                break;
            case 'R':
                state->strategy = Z_RLE;
                break;
            case 'F':
                state->strategy = Z_FIXED;
                break;
            case 'T':
                state->direct = 1;
                break;
            default:        /* could consider as an error, but just ignore */
                ;
            }
        mode++;
    }

    /* must provide an "r", "w", or "a" */
    if (state->mode == GZ_NONE) {
        free(state);
        return NULL;
    }

    /* can't force transparent read */
    if (state->mode == GZ_READ) {
        if (state->direct) {
            free(state);
            return NULL;
        }
        state->direct = 1;      /* for empty file */
    }

    /* save the path name for error messages */
#ifdef _WIN32
    if (fd == -2) {
        len = wcstombs(NULL, path, 0);
        if (len == (size_t)-1)
            len = 0;
    }
    else
#endif
        len = strlen((const char *)path);
    state->path = (char *)malloc(len + 1);
    if (state->path == NULL) {
        free(state);
        return NULL;
    }
#ifdef _WIN32
    if (fd == -2)
        if (len)
            wcstombs(state->path, path, len + 1);
        else
            *(state->path) = 0;
    else
#endif
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
        snprintf(state->path, len + 1, "%s", (const char *)path);
#else
        strcpy(state->path, path);
#endif

    /* compute the flags for open() */
    oflag =
#ifdef O_LARGEFILE
        O_LARGEFILE |
#endif
#ifdef O_BINARY
        O_BINARY |
#endif
#ifdef O_CLOEXEC
        (cloexec ? O_CLOEXEC : 0) |
#endif
        (state->mode == GZ_READ ?
         O_RDONLY :
         (O_WRONLY | O_CREAT |
#ifdef O_EXCL
          (exclusive ? O_EXCL : 0) |
#endif
          (state->mode == GZ_WRITE ?
           O_TRUNC :
           O_APPEND)));

    /* open the file with the appropriate flags (or just use fd) */
    state->fd = fd > -1 ? fd : (
#ifdef _WIN32
        fd == -2 ? _wopen(path, oflag, 0666) :
#endif
        open((const char *)path, oflag, 0666));
    if (state->fd == -1) {
        free(state->path);
        free(state);
        return NULL;
    }
    if (state->mode == GZ_APPEND)
        state->mode = GZ_WRITE;         /* simplify later checks */

    /* save the current position for rewinding (only if reading) */
    if (state->mode == GZ_READ) {
        state->start = LSEEK(state->fd, 0, SEEK_CUR);
        if (state->start == -1) state->start = 0;
    }

    /* initialize stream */
    gz_reset(state);

    /* return stream */
    return (gzFile)state;
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen(path, mode)
    const char *path;
    const char *mode;
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen64(path, mode)
    const char *path;
    const char *mode;
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzdopen(fd, mode)
    int fd;
    const char *mode;
{
    char *path;         /* identifier for error messages */
    gzFile gz;

    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
        return NULL;
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd); /* for debugging */
#else
    sprintf(path, "<fd:%d>", fd);   /* for debugging */
#endif
    gz = gz_open(path, fd, mode);
    free(path);
    return gz;
}

/* -- see zlib.h -- */
#ifdef _WIN32
gzFile ZEXPORT gzopen_w(path, mode)
    const wchar_t *path;
    const char *mode;
{
    return gz_open(path, -2, mode);
}
#endif

/* -- see zlib.h -- */
int ZEXPORT gzbuffer(file, size)
    gzFile file;
    unsigned size;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* make sure we haven't already allocated memory */
    if (state->size != 0)
        return -1;

    /* check and set requested size */
    if (size < 2)
        size = 2;               /* need two bytes to check magic header */
    state->want = size;
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzrewind(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* back up and start over */
    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
        return -1;
    gz_reset(state);
    return 0;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzseek64(file, offset, whence)
    gzFile file;
    z_off64_t offset;
    int whence;
{
    unsigned n;
    z_off64_t ret;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* check that there's no error */
    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;

    /* can only seek from start or relative to current position */
    if (whence != SEEK_SET && whence != SEEK_CUR)
        return -1;

    /* normalize offset to a SEEK_CUR specification */
    if (whence == SEEK_SET)
        offset -= state->x.pos;
    else if (state->seek)
        offset += state->skip;
    state->seek = 0;

    /* if within raw area while reading, just go there */
    if (state->mode == GZ_READ && state->how == COPY &&
            state->x.pos + offset >= 0) {
        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
        if (ret == -1)
            return -1;
        state->x.have = 0;
        state->eof = 0;
        state->past = 0;
        state->seek = 0;
        gz_error(state, Z_OK, NULL);
        state->strm.avail_in = 0;
        state->x.pos += offset;
        return state->x.pos;
    }

    /* calculate skip amount, rewinding if needed for back seek when reading */
    if (offset < 0) {
        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
            return -1;
        offset += state->x.pos;
        if (offset < 0)                     /* before start of file! */
            return -1;
        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
            return -1;
    }

    /* if reading, skip what's in output buffer (one less gzgetc() check) */
    if (state->mode == GZ_READ) {
        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
            (unsigned)offset : state->x.have;
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        offset -= n;
    }

    /* request skip (if not zero) */
    if (offset) {
        state->seek = 1;
        state->skip = offset;
    }
    return state->x.pos + offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzseek(file, offset, whence)
    gzFile file;
    z_off_t offset;
    int whence;
{
    z_off64_t ret;

    ret = gzseek64(file, (z_off64_t)offset, whence);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gztell64(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* return position */
    return state->x.pos + (state->seek ? state->skip : 0);
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gztell(file)
    gzFile file;
{
    z_off64_t ret;

    ret = gztell64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzoffset64(file)
    gzFile file;
{
    z_off64_t offset;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* compute and return effective offset in file */
    offset = LSEEK(state->fd, 0, SEEK_CUR);
    if (offset == -1)
        return -1;
    if (state->mode == GZ_READ)             /* reading */
        offset -= state->strm.avail_in;     /* don't count buffered input */
    return offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzoffset(file)
    gzFile file;
{
    z_off64_t ret;

    ret = gzoffset64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
int ZEXPORT gzeof(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return 0;

    /* return end-of-file state */
    return state->mode == GZ_READ ? state->past : 0;
}

/* -- see zlib.h -- */
const char * ZEXPORT gzerror(file, errnum)
    gzFile file;
    int *errnum;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return NULL;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return NULL;

    /* return error information */
    if (errnum != NULL)
        *errnum = state->err;
    return state->err == Z_MEM_ERROR ? "out of memory" :
                                       (state->msg == NULL ? "" : state->msg);
}

/* -- see zlib.h -- */
void ZEXPORT gzclearerr(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return;

    /* clear error and end-of-file */
    if (state->mode == GZ_READ) {
        state->eof = 0;
        state->past = 0;
    }
    gz_error(state, Z_OK, NULL);
}

/* Create an error message in allocated memory and set state->err and
   state->msg accordingly.  Free any previous error message already there.  Do
   not try to free or allocate space if the error is Z_MEM_ERROR (out of
   memory).  Simply save the error message as a static string.  If there is an
   allocation failure constructing the error message, then convert the error to
   out of memory. */
void ZLIB_INTERNAL gz_error(state, err, msg)
    gz_statep state;
    int err;
    const char *msg;
{
    /* free previously allocated message and clear */
    if (state->msg != NULL) {
        if (state->err != Z_MEM_ERROR)
            free(state->msg);
        state->msg = NULL;
    }

    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
    if (err != Z_OK && err != Z_BUF_ERROR)
        state->x.have = 0;

    /* set error code, and if no message, then done */
    state->err = err;
    if (msg == NULL)
        return;

    /* for an out of memory error, return literal string when requested */
    if (err == Z_MEM_ERROR)
        return;

    /* construct error message with path */
    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
            NULL) {
        state->err = Z_MEM_ERROR;
        return;
    }
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
             "%s%s%s", state->path, ": ", msg);
#else
    strcpy(state->msg, state->path);
    strcat(state->msg, ": ");
    strcat(state->msg, msg);
#endif
    return;
}

#ifndef INT_MAX
/* portably return maximum value for an int (when limits.h presumed not
   available) -- we need to do this to cover cases where 2's complement not
   used, since C standard permits 1's complement and sign-bit representations,
   otherwise we could just use ((unsigned)-1) >> 1 */
unsigned ZLIB_INTERNAL gz_intmax()
{
    unsigned p, q;

    p = 1;
    do {
        q = p;
        p <<= 1;
        p++;
    } while (p > q);
    return q >> 1;
}
#endif



================================================
File: src/zlib/gzread.c
================================================
/* gzread.c -- zlib functions for reading gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* Local functions */
local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
local int gz_avail OF((gz_statep));
local int gz_look OF((gz_statep));
local int gz_decomp OF((gz_statep));
local int gz_fetch OF((gz_statep));
local int gz_skip OF((gz_statep, z_off64_t));

/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
   state->fd, and update state->eof, state->err, and state->msg as appropriate.
   This function needs to loop on read(), since read() is not guaranteed to
   read the number of bytes requested, depending on the type of descriptor. */
local int gz_load(state, buf, len, have)
    gz_statep state;
    unsigned char *buf;
    unsigned len;
    unsigned *have;
{
    int ret;

    *have = 0;
    do {
        ret = read(state->fd, buf + *have, len - *have);
        if (ret <= 0)
            break;
        *have += ret;
    } while (*have < len);
    if (ret < 0) {
        gz_error(state, Z_ERRNO, zstrerror());
        return -1;
    }
    if (ret == 0)
        state->eof = 1;
    return 0;
}

/* Load up input buffer and set eof flag if last data loaded -- return -1 on
   error, 0 otherwise.  Note that the eof flag is set when the end of the input
   file is reached, even though there may be unused data in the buffer.  Once
   that data has been used, no more attempts will be made to read the file.
   If strm->avail_in != 0, then the current data is moved to the beginning of
   the input buffer, and then the remainder of the buffer is loaded with the
   available data from the input file. */
local int gz_avail(state)
    gz_statep state;
{
    unsigned got;
    z_streamp strm = &(state->strm);

    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;
    if (state->eof == 0) {
        if (strm->avail_in) {       /* copy what's there to the start */
            unsigned char *p = state->in;
            unsigned const char *q = strm->next_in;
            unsigned n = strm->avail_in;
            do {
                *p++ = *q++;
            } while (--n);
        }
        if (gz_load(state, state->in + strm->avail_in,
                    state->size - strm->avail_in, &got) == -1)
            return -1;
        strm->avail_in += got;
        strm->next_in = state->in;
    }
    return 0;
}

/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
   If this is the first time in, allocate required memory.  state->how will be
   left unchanged if there is no more input data available, will be set to COPY
   if there is no gzip header and direct copying will be performed, or it will
   be set to GZIP for decompression.  If direct copying, then leftover input
   data from the input buffer will be copied to the output buffer.  In that
   case, all further file reads will be directly to either the output buffer or
   a user buffer.  If decompressing, the inflate state will be initialized.
   gz_look() will return 0 on success or -1 on failure. */
local int gz_look(state)
    gz_statep state;
{
    z_streamp strm = &(state->strm);

    /* allocate read buffers and inflate memory */
    if (state->size == 0) {
        /* allocate buffers */
        state->in = (unsigned char *)malloc(state->want);
        state->out = (unsigned char *)malloc(state->want << 1);
        if (state->in == NULL || state->out == NULL) {
            if (state->out != NULL)
                free(state->out);
            if (state->in != NULL)
                free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        state->size = state->want;

        /* allocate inflate memory */
        state->strm.zalloc = Z_NULL;
        state->strm.zfree = Z_NULL;
        state->strm.opaque = Z_NULL;
        state->strm.avail_in = 0;
        state->strm.next_in = Z_NULL;
        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
            free(state->out);
            free(state->in);
            state->size = 0;
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
    }

    /* get at least the magic bytes in the input buffer */
    if (strm->avail_in < 2) {
        if (gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0)
            return 0;
    }

    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
       a logical dilemma here when considering the case of a partially written
       gzip file, to wit, if a single 31 byte is written, then we cannot tell
       whether this is a single-byte file, or just a partially written gzip
       file -- for here we assume that if a gzip file is being written, then
       the header will be written in a single operation, so that reading a
       single byte is sufficient indication that it is not a gzip file) */
    if (strm->avail_in > 1 &&
            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
        inflateReset(strm);
        state->how = GZIP;
        state->direct = 0;
        return 0;
    }

    /* no gzip header -- if we were decoding gzip before, then this is trailing
       garbage.  Ignore the trailing garbage and finish. */
    if (state->direct == 0) {
        strm->avail_in = 0;
        state->eof = 1;
        state->x.have = 0;
        return 0;
    }

    /* doing raw i/o, copy any leftover input to output -- this assumes that
       the output buffer is larger than the input buffer, which also assures
       space for gzungetc() */
    state->x.next = state->out;
    if (strm->avail_in) {
        memcpy(state->x.next, strm->next_in, strm->avail_in);
        state->x.have = strm->avail_in;
        strm->avail_in = 0;
    }
    state->how = COPY;
    state->direct = 1;
    return 0;
}

/* Decompress from input to the provided next_out and avail_out in the state.
   On return, state->x.have and state->x.next point to the just decompressed
   data.  If the gzip stream completes, state->how is reset to LOOK to look for
   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
   on success, -1 on failure. */
local int gz_decomp(state)
    gz_statep state;
{
    int ret = Z_OK;
    unsigned had;
    z_streamp strm = &(state->strm);

    /* fill output buffer up to end of deflate stream */
    had = strm->avail_out;
    do {
        /* get more input for inflate() */
        if (strm->avail_in == 0 && gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0) {
            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
            break;
        }

        /* decompress and handle errors */
        ret = inflate(strm, Z_NO_FLUSH);
        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
            gz_error(state, Z_STREAM_ERROR,
                     "internal error: inflate stream corrupt");
            return -1;
        }
        if (ret == Z_MEM_ERROR) {
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
            gz_error(state, Z_DATA_ERROR,
                     strm->msg == NULL ? "compressed data error" : strm->msg);
            return -1;
        }
    } while (strm->avail_out && ret != Z_STREAM_END);

    /* update available output */
    state->x.have = had - strm->avail_out;
    state->x.next = strm->next_out - state->x.have;

    /* if the gzip stream completed successfully, look for another */
    if (ret == Z_STREAM_END)
        state->how = LOOK;

    /* good decompression */
    return 0;
}

/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
   Data is either copied from the input file or decompressed from the input
   file depending on state->how.  If state->how is LOOK, then a gzip header is
   looked for to determine whether to copy or decompress.  Returns -1 on error,
   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
   end of the input file has been reached and all data has been processed.  */
local int gz_fetch(state)
    gz_statep state;
{
    z_streamp strm = &(state->strm);

    do {
        switch(state->how) {
        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
            if (gz_look(state) == -1)
                return -1;
            if (state->how == LOOK)
                return 0;
            break;
        case COPY:      /* -> COPY */
            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
                    == -1)
                return -1;
            state->x.next = state->out;
            return 0;
        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
            strm->avail_out = state->size << 1;
            strm->next_out = state->out;
            if (gz_decomp(state) == -1)
                return -1;
        }
    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
    return 0;
}

/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
local int gz_skip(state, len)
    gz_statep state;
    z_off64_t len;
{
    unsigned n;

    /* skip over len bytes or reach end-of-file, whichever comes first */
    while (len)
        /* skip over whatever is in output buffer */
        if (state->x.have) {
            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
                (unsigned)len : state->x.have;
            state->x.have -= n;
            state->x.next += n;
            state->x.pos += n;
            len -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && state->strm.avail_in == 0)
            break;

        /* need more data to skip -- load up output buffer */
        else {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return -1;
        }
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzread(file, buf, len)
    gzFile file;
    voidp buf;
    unsigned len;
{
    unsigned got, n;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids the flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
        return -1;
    }

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return -1;
    }

    /* get len bytes to buf, or less than len if at the end */
    got = 0;
    do {
        /* first just try copying data from the output buffer */
        if (state->x.have) {
            n = state->x.have > len ? len : state->x.have;
            memcpy(buf, state->x.next, n);
            state->x.next += n;
            state->x.have -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && strm->avail_in == 0) {
            state->past = 1;        /* tried to read past end */
            break;
        }

        /* need output data -- for small len or new stream load up our output
           buffer */
        else if (state->how == LOOK || len < (state->size << 1)) {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return -1;
            continue;       /* no progress yet -- go back to copy above */
            /* the copy above assures that we will leave with space in the
               output buffer, allowing at least one gzungetc() to succeed */
        }

        /* large len -- read directly into user buffer */
        else if (state->how == COPY) {      /* read directly */
            if (gz_load(state, (unsigned char *)buf, len, &n) == -1)
                return -1;
        }

        /* large len -- decompress directly into user buffer */
        else {  /* state->how == GZIP */
            strm->avail_out = len;
            strm->next_out = (unsigned char *)buf;
            if (gz_decomp(state) == -1)
                return -1;
            n = state->x.have;
            state->x.have = 0;
        }

        /* update progress */
        len -= n;
        buf = (char *)buf + n;
        got += n;
        state->x.pos += n;
    } while (len);

    /* return number of bytes read into user buffer (will fit in int) */
    return (int)got;
}

/* -- see zlib.h -- */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#else
#  undef gzgetc
#endif
int ZEXPORT gzgetc(file)
    gzFile file;
{
    int ret;
    unsigned char buf[1];
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* try output buffer (no need to check for skip request) */
    if (state->x.have) {
        state->x.have--;
        state->x.pos++;
        return *(state->x.next)++;
    }

    /* nothing there -- try gzread() */
    ret = gzread(file, buf, 1);
    return ret < 1 ? -1 : buf[0];
}

int ZEXPORT gzgetc_(file)
gzFile file;
{
    return gzgetc(file);
}

/* -- see zlib.h -- */
int ZEXPORT gzungetc(c, file)
    int c;
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return -1;
    }

    /* can't push EOF */
    if (c < 0)
        return -1;

    /* if output buffer empty, put byte at end (allows more pushing) */
    if (state->x.have == 0) {
        state->x.have = 1;
        state->x.next = state->out + (state->size << 1) - 1;
        state->x.next[0] = c;
        state->x.pos--;
        state->past = 0;
        return c;
    }

    /* if no room, give up (must have already done a gzungetc()) */
    if (state->x.have == (state->size << 1)) {
        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
        return -1;
    }

    /* slide output data if needed and insert byte before existing data */
    if (state->x.next == state->out) {
        unsigned char *src = state->out + state->x.have;
        unsigned char *dest = state->out + (state->size << 1);
        while (src > state->out)
            *--dest = *--src;
        state->x.next = dest;
    }
    state->x.have++;
    state->x.next--;
    state->x.next[0] = c;
    state->x.pos--;
    state->past = 0;
    return c;
}

/* -- see zlib.h -- */
char * ZEXPORT gzgets(file, buf, len)
    gzFile file;
    char *buf;
    int len;
{
    unsigned left, n;
    char *str;
    unsigned char *eol;
    gz_statep state;

    /* check parameters and get internal structure */
    if (file == NULL || buf == NULL || len < 1)
        return NULL;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return NULL;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return NULL;
    }

    /* copy output bytes up to new line or len - 1, whichever comes first --
       append a terminating zero to the string (we don't check for a zero in
       the contents, let the user worry about that) */
    str = buf;
    left = (unsigned)len - 1;
    if (left) do {
        /* assure that something is in the output buffer */
        if (state->x.have == 0 && gz_fetch(state) == -1)
            return NULL;                /* error */
        if (state->x.have == 0) {       /* end of file */
            state->past = 1;            /* read past end */
            break;                      /* return what we have */
        }

        /* look for end-of-line in current output buffer */
        n = state->x.have > left ? left : state->x.have;
        eol = (unsigned char *)memchr(state->x.next, '\n', n);
        if (eol != NULL)
            n = (unsigned)(eol - state->x.next) + 1;

        /* copy through end-of-line, or remainder if not found */
        memcpy(buf, state->x.next, n);
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        left -= n;
        buf += n;
    } while (left && eol == NULL);

    /* return terminated string, or if nothing, end of file */
    if (buf == str)
        return NULL;
    buf[0] = 0;
    return str;
}

/* -- see zlib.h -- */
int ZEXPORT gzdirect(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;

    /* if the state is not known, but we can find out, then do so (this is
       mainly for right after a gzopen() or gzdopen()) */
    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
        (void)gz_look(state);

    /* return 1 if transparent, 0 if processing a gzip stream */
    return state->direct;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_r(file)
    gzFile file;
{
    int ret, err;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're reading */
    if (state->mode != GZ_READ)
        return Z_STREAM_ERROR;

    /* free memory and close file */
    if (state->size) {
        inflateEnd(&(state->strm));
        free(state->out);
        free(state->in);
    }
    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
    gz_error(state, Z_OK, NULL);
    free(state->path);
    ret = close(state->fd);
    free(state);
    return ret ? Z_ERRNO : err;
}



================================================
File: src/zlib/gzwrite.c
================================================
/* gzwrite.c -- zlib functions for writing gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "gzguts.h"

/* Local functions */
local int gz_init OF((gz_statep));
local int gz_comp OF((gz_statep, int));
local int gz_zero OF((gz_statep, z_off64_t));

/* Initialize state for writing a gzip file.  Mark initialization by setting
   state->size to non-zero.  Return -1 on failure or 0 on success. */
local int gz_init(state)
    gz_statep state;
{
    int ret;
    z_streamp strm = &(state->strm);

    /* allocate input buffer */
    state->in = (unsigned char *)malloc(state->want);
    if (state->in == NULL) {
        gz_error(state, Z_MEM_ERROR, "out of memory");
        return -1;
    }

    /* only need output buffer and deflate state if compressing */
    if (!state->direct) {
        /* allocate output buffer */
        state->out = (unsigned char *)malloc(state->want);
        if (state->out == NULL) {
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }

        /* allocate deflate memory, set up for gzip compression */
        strm->zalloc = Z_NULL;
        strm->zfree = Z_NULL;
        strm->opaque = Z_NULL;
        ret = deflateInit2(strm, state->level, Z_DEFLATED,
                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
        if (ret != Z_OK) {
            free(state->out);
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
    }

    /* mark state as initialized */
    state->size = state->want;

    /* initialize write buffer if compressing */
    if (!state->direct) {
        strm->avail_out = state->size;
        strm->next_out = state->out;
        state->x.next = strm->next_out;
    }
    return 0;
}

/* Compress whatever is at avail_in and next_in and write to the output file.
   Return -1 if there is an error writing to the output file, otherwise 0.
   flush is assumed to be a valid deflate() flush value.  If flush is Z_FINISH,
   then the deflate() state is reset to start a new gzip stream.  If gz->direct
   is true, then simply write to the output file without compressing, and
   ignore flush. */
local int gz_comp(state, flush)
    gz_statep state;
    int flush;
{
    int ret, got;
    unsigned have;
    z_streamp strm = &(state->strm);

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return -1;

    /* write directly if requested */
    if (state->direct) {
        got = write(state->fd, strm->next_in, strm->avail_in);
        if (got < 0 || (unsigned)got != strm->avail_in) {
            gz_error(state, Z_ERRNO, zstrerror());
            return -1;
        }
        strm->avail_in = 0;
        return 0;
    }

    /* run deflate() on provided input until it produces no more output */
    ret = Z_OK;
    do {
        /* write out current buffer contents if full, or if flushing, but if
           doing Z_FINISH then don't write until we get to Z_STREAM_END */
        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
            (flush != Z_FINISH || ret == Z_STREAM_END))) {
            have = (unsigned)(strm->next_out - state->x.next);
            if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
                         (unsigned)got != have)) {
                gz_error(state, Z_ERRNO, zstrerror());
                return -1;
            }
            if (strm->avail_out == 0) {
                strm->avail_out = state->size;
                strm->next_out = state->out;
            }
            state->x.next = strm->next_out;
        }

        /* compress */
        have = strm->avail_out;
        ret = deflate(strm, flush);
        if (ret == Z_STREAM_ERROR) {
            gz_error(state, Z_STREAM_ERROR,
                      "internal error: deflate stream corrupt");
            return -1;
        }
        have -= strm->avail_out;
    } while (have);

    /* if that completed a deflate stream, allow another to start */
    if (flush == Z_FINISH)
        deflateReset(strm);

    /* all done, no errors */
    return 0;
}

/* Compress len zeros to output.  Return -1 on error, 0 on success. */
local int gz_zero(state, len)
    gz_statep state;
    z_off64_t len;
{
    int first;
    unsigned n;
    z_streamp strm = &(state->strm);

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return -1;

    /* compress len zeros (len guaranteed > 0) */
    first = 1;
    while (len) {
        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
            (unsigned)len : state->size;
        if (first) {
            memset(state->in, 0, n);
            first = 0;
        }
        strm->avail_in = n;
        strm->next_in = state->in;
        state->x.pos += n;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return -1;
        len -= n;
    }
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzwrite(file, buf, len)
    gzFile file;
    voidpc buf;
    unsigned len;
{
    unsigned put = len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids the flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
        return 0;
    }

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* for small len, copy to input buffer, otherwise compress directly */
    if (len < state->size) {
        /* copy to input buffer, compress when full */
        do {
            unsigned have, copy;

            if (strm->avail_in == 0)
                strm->next_in = state->in;
            have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
            copy = state->size - have;
            if (copy > len)
                copy = len;
            memcpy(state->in + have, buf, copy);
            strm->avail_in += copy;
            state->x.pos += copy;
            buf = (const char *)buf + copy;
            len -= copy;
            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
                return 0;
        } while (len);
    }
    else {
        /* consume whatever's left in the input buffer */
        if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
            return 0;

        /* directly compress user buffer to file */
        strm->avail_in = len;
        strm->next_in = (z_const Bytef *)buf;
        state->x.pos += len;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return 0;
    }

    /* input was all buffered or compressed (put will fit in int) */
    return (int)put;
}

/* -- see zlib.h -- */
int ZEXPORT gzputc(file, c)
    gzFile file;
    int c;
{
    unsigned have;
    unsigned char buf[1];
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return -1;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* try writing to input buffer for speed (state->size == 0 if buffer not
       initialized) */
    if (state->size) {
        if (strm->avail_in == 0)
            strm->next_in = state->in;
        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
        if (have < state->size) {
            state->in[have] = c;
            strm->avail_in++;
            state->x.pos++;
            return c & 0xff;
        }
    }

    /* no room in buffer or not initialized, use gz_write() */
    buf[0] = c;
    if (gzwrite(file, buf, 1) != 1)
        return -1;
    return c & 0xff;
}

/* -- see zlib.h -- */
int ZEXPORT gzputs(file, str)
    gzFile file;
    const char *str;
{
    int ret;
    unsigned len;

    /* write string */
    len = (unsigned)strlen(str);
    ret = gzwrite(file, str, len);
    return ret == 0 && len != 0 ? -1 : ret;
}

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#include <stdarg.h>

/* -- see zlib.h -- */
int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
{
    int size, len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return 0;

    /* do the printf() into the input buffer, put length in len */
    size = (int)(state->size);
    state->in[size - 1] = 0;
#ifdef NO_vsnprintf
#  ifdef HAS_vsprintf_void
    (void)vsprintf((char *)(state->in), format, va);
    for (len = 0; len < size; len++)
        if (state->in[len] == 0) break;
#  else
    len = vsprintf((char *)(state->in), format, va);
#  endif
#else
#  ifdef HAS_vsnprintf_void
    (void)vsnprintf((char *)(state->in), size, format, va);
    len = strlen((char *)(state->in));
#  else
    len = vsnprintf((char *)(state->in), size, format, va);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
        return 0;

    /* update buffer and position, defer compression until needed */
    strm->avail_in = (unsigned)len;
    strm->next_in = state->in;
    state->x.pos += len;
    return len;
}

int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
{
    va_list va;
    int ret;

    va_start(va, format);
    ret = gzvprintf(file, format, va);
    va_end(va);
    return ret;
}

#else /* !STDC && !Z_HAVE_STDARG_H */

/* -- see zlib.h -- */
int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    int size, len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that can really pass pointer in ints */
    if (sizeof(int) != sizeof(void *))
        return 0;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return 0;

    /* do the printf() into the input buffer, put length in len */
    size = (int)(state->size);
    state->in[size - 1] = 0;
#ifdef NO_snprintf
#  ifdef HAS_sprintf_void
    sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    for (len = 0; len < size; len++)
        if (state->in[len] == 0) break;
#  else
    len = sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
                  a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#  endif
#else
#  ifdef HAS_snprintf_void
    snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6, a7, a8,
             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    len = strlen((char *)(state->in));
#  else
    len = snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6,
                   a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18,
                   a19, a20);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
        return 0;

    /* update buffer and position, defer compression until needed */
    strm->avail_in = (unsigned)len;
    strm->next_in = state->in;
    state->x.pos += len;
    return len;
}

#endif

/* -- see zlib.h -- */
int ZEXPORT gzflush(file, flush)
    gzFile file;
    int flush;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* check flush parameter */
    if (flush < 0 || flush > Z_FINISH)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* compress remaining data with requested flush */
    gz_comp(state, flush);
    return state->err;
}

/* -- see zlib.h -- */
int ZEXPORT gzsetparams(file, level, strategy)
    gzFile file;
    int level;
    int strategy;
{
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* if no change is requested, then do nothing */
    if (level == state->level && strategy == state->strategy)
        return Z_OK;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* change compression parameters for subsequent input */
    if (state->size) {
        /* flush previous input with previous parameters before changing */
        if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)
            return state->err;
        deflateParams(strm, level, strategy);
    }
    state->level = level;
    state->strategy = strategy;
    return Z_OK;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_w(file)
    gzFile file;
{
    int ret = Z_OK;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're writing */
    if (state->mode != GZ_WRITE)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            ret = state->err;
    }

    /* flush, free memory, and close file */
    if (gz_comp(state, Z_FINISH) == -1)
        ret = state->err;
    if (state->size) {
        if (!state->direct) {
            (void)deflateEnd(&(state->strm));
            free(state->out);
        }
        free(state->in);
    }
    gz_error(state, Z_OK, NULL);
    free(state->path);
    if (close(state->fd) == -1)
        ret = Z_ERRNO;
    free(state);
    return ret;
}



================================================
File: src/zlib/infback.c
================================================
/* infback.c -- inflate using a call-back interface
 * Copyright (C) 1995-2011 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
   This code is largely copied from inflate.c.  Normally either infback.o or
   inflate.o would be linked into an application--not both.  The interface
   with inffast.c is retained so that optimized assembler-coded versions of
   inflate_fast() can be used with either inflate.c or infback.c.
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

/* function prototypes */
local void fixedtables OF((struct inflate_state FAR *state));

/*
   strm provides memory allocation functions in zalloc and zfree, or
   Z_NULL to use the library memory allocation functions.

   windowBits is in the range 8..15, and window is a user-supplied
   window and output buffer that is 2**windowBits bytes.
 */
int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
z_streamp strm;
int windowBits;
unsigned char FAR *window;
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL || window == Z_NULL ||
        windowBits < 8 || windowBits > 15)
        return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
    strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
                                               sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->dmax = 32768U;
    state->wbits = windowBits;
    state->wsize = 1U << windowBits;
    state->window = window;
    state->wnext = 0;
    state->whave = 0;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables(state)
struct inflate_state FAR *state;
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

/* Macros for inflateBack(): */

/* Load returned state from inflate_fast() */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Set state from registers for inflate_fast() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Assure that some input is available.  If input is requested, but denied,
   then return a Z_BUF_ERROR from inflateBack(). */
#define PULL() \
    do { \
        if (have == 0) { \
            have = in(in_desc, &next); \
            if (have == 0) { \
                next = Z_NULL; \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflateBack()
   with an error if there is no input available. */
#define PULLBYTE() \
    do { \
        PULL(); \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflateBack() with
   an error. */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/* Assure that some output space is available, by writing out the window
   if it's full.  If the write fails, return from inflateBack() with a
   Z_BUF_ERROR. */
#define ROOM() \
    do { \
        if (left == 0) { \
            put = state->window; \
            left = state->wsize; \
            state->whave = left; \
            if (out(out_desc, put, left)) { \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/*
   strm provides the memory allocation functions and window buffer on input,
   and provides information on the unused input on return.  For Z_DATA_ERROR
   returns, strm will also provide an error message.

   in() and out() are the call-back input and output functions.  When
   inflateBack() needs more input, it calls in().  When inflateBack() has
   filled the window with output, or when it completes with data in the
   window, it calls out() to write out the data.  The application must not
   change the provided input until in() is called again or inflateBack()
   returns.  The application must not change the window/output buffer until
   inflateBack() returns.

   in() and out() are called with a descriptor parameter provided in the
   inflateBack() call.  This parameter can be a structure that provides the
   information required to do the read or write, as well as accumulated
   information on the input and output such as totals and check values.

   in() should return zero on failure.  out() should return non-zero on
   failure.  If either in() or out() fails, than inflateBack() returns a
   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
   was in() or out() that caused in the error.  Otherwise,  inflateBack()
   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
   error, or Z_MEM_ERROR if it could not allocate memory for the state.
   inflateBack() can also return Z_STREAM_ERROR if the input parameters
   are not correct, i.e. strm is Z_NULL or the state was not initialized.
 */
int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
z_streamp strm;
in_func in;
void FAR *in_desc;
out_func out;
void FAR *out_desc;
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    /* Check that the strm exists and that the state was initialized */
    if (strm == Z_NULL || strm->state == Z_NULL)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* Reset the state */
    strm->msg = Z_NULL;
    state->mode = TYPE;
    state->last = 0;
    state->whave = 0;
    next = strm->next_in;
    have = next != Z_NULL ? strm->avail_in : 0;
    hold = 0;
    bits = 0;
    put = state->window;
    left = state->wsize;

    /* Inflate until end of block marked as last */
    for (;;)
        switch (state->mode) {
        case TYPE:
            /* determine and dispatch block type */
            if (state->last) {
                BYTEBITS();
                state->mode = DONE;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;

        case STORED:
            /* get and verify stored block length */
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();

            /* copy stored block from input to output */
            while (state->length != 0) {
                copy = state->length;
                PULL();
                ROOM();
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;

        case TABLE:
            /* get dynamic table entries descriptor */
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));

            /* get code length code lengths (not a typo) */
            state->have = 0;
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));

            /* get length and distance code code lengths */
            state->have = 0;
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = (unsigned)(state->lens[state->have - 1]);
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;

        case LEN:
            /* use inflate_fast() if we have enough input and output */
            if (have >= 6 && left >= 258) {
                RESTORE();
                if (state->whave < state->wsize)
                    state->whave = state->wsize - left;
                inflate_fast(strm, state->wsize);
                LOAD();
                break;
            }

            /* get a literal, length, or end-of-block code */
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            state->length = (unsigned)here.val;

            /* process literal */
            if (here.op == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                ROOM();
                *put++ = (unsigned char)(state->length);
                left--;
                state->mode = LEN;
                break;
            }

            /* process end of block */
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }

            /* invalid code */
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }

            /* length code -- get extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));

            /* get distance code */
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;

            /* get distance extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
            }
            if (state->offset > state->wsize - (state->whave < state->wsize ?
                                                left : 0)) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));

            /* copy match from window to output */
            do {
                ROOM();
                copy = state->wsize - state->offset;
                if (copy < left) {
                    from = put + copy;
                    copy = left - copy;
                }
                else {
                    from = put - state->offset;
                    copy = left;
                }
                if (copy > state->length) copy = state->length;
                state->length -= copy;
                left -= copy;
                do {
                    *put++ = *from++;
                } while (--copy);
            } while (state->length != 0);
            break;

        case DONE:
            /* inflate stream terminated properly -- write leftover output */
            ret = Z_STREAM_END;
            if (left < state->wsize) {
                if (out(out_desc, state->window, state->wsize - left))
                    ret = Z_BUF_ERROR;
            }
            goto inf_leave;

        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;

        default:                /* can't happen, but makes compilers happy */
            ret = Z_STREAM_ERROR;
            goto inf_leave;
        }

    /* Return unused input */
  inf_leave:
    strm->next_in = next;
    strm->avail_in = have;
    return ret;
}

int ZEXPORT inflateBackEnd(strm)
z_streamp strm;
{
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}



================================================
File: src/zlib/inffast.c
================================================
/* inffast.c -- fast decoding
 * Copyright (C) 1995-2008, 2010, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

#ifndef ASMINF

/* Allow machine dependent optimization for post-increment or pre-increment.
   Based on testing to date,
   Pre-increment preferred for:
   - PowerPC G3 (Adler)
   - MIPS R5000 (Randers-Pehrson)
   Post-increment preferred for:
   - none
   No measurable difference:
   - Pentium III (Anderson)
   - M68060 (Nikl)
 */
#ifdef POSTINC
#  define OFF 0
#  define PUP(a) *(a)++
#else
#  define OFF 1
#  define PUP(a) *++(a)
#endif

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state->mode == LEN
        strm->avail_in >= 6
        strm->avail_out >= 258
        start >= strm->avail_out
        state->bits < 8

   On return, state->mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm->avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void ZLIB_INTERNAL inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *in;      /* local strm->next_in */
    z_const unsigned char FAR *last;    /* have enough input while in < last */
    unsigned char FAR *out;     /* local strm->next_out */
    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
    unsigned char FAR *end;     /* while out < end, enough space available */
#ifdef INFLATE_STRICT
    unsigned dmax;              /* maximum distance from zlib header */
#endif
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
    unsigned long hold;         /* local strm->hold */
    unsigned bits;              /* local strm->bits */
    code const FAR *lcode;      /* local strm->lencode */
    code const FAR *dcode;      /* local strm->distcode */
    unsigned lmask;             /* mask for first level of length codes */
    unsigned dmask;             /* mask for first level of distance codes */
    code here;                  /* retrieved table entry */
    unsigned op;                /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    wnext = state->wnext;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
      dolen:
        op = (unsigned)(here.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(here.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", here.val));
            PUP(out) = (unsigned char)(here.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(here.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
                hold >>= op;
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
            }
            here = dcode[hold & dmask];
          dodist:
            op = (unsigned)(here.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(here.op);
            if (op & 16) {                      /* distance base */
                dist = (unsigned)(here.val);
                op &= 15;                       /* number of extra bits */
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
#ifdef INFLATE_STRICT
                if (dist > dmax) {
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
                        if (state->sane) {
                            strm->msg =
                                (char *)"invalid distance too far back";
                            state->mode = BAD;
                            break;
                        }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                        if (len <= op - whave) {
                            do {
                                PUP(out) = 0;
                            } while (--len);
                            continue;
                        }
                        len -= op - whave;
                        do {
                            PUP(out) = 0;
                        } while (--op > whave);
                        if (op == 0) {
                            from = out - dist;
                            do {
                                PUP(out) = PUP(from);
                            } while (--len);
                            continue;
                        }
#endif
                    }
                    from = window - OFF;
                    if (wnext == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (wnext < op) {      /* wrap around window */
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = window - OFF;
                            if (wnext < len) {  /* some from start of window */
                                op = wnext;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
                                } while (--op);
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += wnext - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
                            PUP(out) = PUP(from);
                    }
                }
                else {
                    from = out - dist;          /* copy direct from output */
                    do {                        /* minimum length is three */
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    } while (len > 2);
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
                            PUP(out) = PUP(from);
                    }
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
                here = dcode[here.val + (hold & ((1U << op) - 1))];
                goto dodist;
            }
            else {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            here = lcode[here.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    in -= len;
    bits -= len << 3;
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
    state->bits = bits;
    return;
}

/*
   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
   - Using bit fields for code structure
   - Different op definition to avoid & for extra bits (do & for table bits)
   - Three separate decoding do-loops for direct, window, and wnext == 0
   - Special case for distance > 1 copies to do overlapped load and store copy
   - Explicit branch predictions (based on measured branch probabilities)
   - Deferring match copy and interspersed it with decoding subsequent codes
   - Swapping literal/length else
   - Swapping window/direct else
   - Larger unrolled copy loops (three is about right)
   - Moving len -= 3 statement into middle of loop
 */

#endif /* !ASMINF */



================================================
File: src/zlib/inffast.h
================================================
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-2003, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));



================================================
File: src/zlib/inffixed.h
================================================
    /* inffixed.h -- table for decoding fixed codes
     * Generated automatically by makefixed().
     */

    /* WARNING: this file should *not* be used by applications.
       It is part of the implementation of this library and is
       subject to change. Applications should only use zlib.h.
     */

    static const code lenfix[512] = {
        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
        {0,9,255}
    };

    static const code distfix[32] = {
        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
        {22,5,193},{64,5,0}
    };



================================================
File: src/zlib/inflate.c
================================================
/* inflate.c -- zlib decompression
 * Copyright (C) 1995-2012 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 * Change history:
 *
 * 1.2.beta0    24 Nov 2002
 * - First version -- complete rewrite of inflate to simplify code, avoid
 *   creation of window when not needed, minimize use of window when it is
 *   needed, make inffast.c even faster, implement gzip decoding, and to
 *   improve code readability and style over the previous zlib inflate code
 *
 * 1.2.beta1    25 Nov 2002
 * - Use pointers for available input and output checking in inffast.c
 * - Remove input and output counters in inffast.c
 * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
 * - Remove unnecessary second byte pull from length extra in inffast.c
 * - Unroll direct copy to three copies per loop in inffast.c
 *
 * 1.2.beta2    4 Dec 2002
 * - Change external routine names to reduce potential conflicts
 * - Correct filename to inffixed.h for fixed tables in inflate.c
 * - Make hbuf[] unsigned char to match parameter type in inflate.c
 * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
 *   to avoid negation problem on Alphas (64 bit) in inflate.c
 *
 * 1.2.beta3    22 Dec 2002
 * - Add comments on state->bits assertion in inffast.c
 * - Add comments on op field in inftrees.h
 * - Fix bug in reuse of allocated window after inflateReset()
 * - Remove bit fields--back to byte structure for speed
 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
 * - Use local copies of stream next and avail values, as well as local bit
 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
 *
 * 1.2.beta4    1 Jan 2003
 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
 * - Move a comment on output buffer sizes from inffast.c to inflate.c
 * - Add comments in inffast.c to introduce the inflate_fast() routine
 * - Rearrange window copies in inflate_fast() for speed and simplification
 * - Unroll last copy for window match in inflate_fast()
 * - Use local copies of window variables in inflate_fast() for speed
 * - Pull out common wnext == 0 case for speed in inflate_fast()
 * - Make op and len in inflate_fast() unsigned for consistency
 * - Add FAR to lcode and dcode declarations in inflate_fast()
 * - Simplified bad distance check in inflate_fast()
 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
 *   source file infback.c to provide a call-back interface to inflate for
 *   programs like gzip and unzip -- uses window as output buffer to avoid
 *   window copying
 *
 * 1.2.beta5    1 Jan 2003
 * - Improved inflateBack() interface to allow the caller to provide initial
 *   input in strm.
 * - Fixed stored blocks bug in inflateBack()
 *
 * 1.2.beta6    4 Jan 2003
 * - Added comments in inffast.c on effectiveness of POSTINC
 * - Typecasting all around to reduce compiler warnings
 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
 *   make compilers happy
 * - Changed type of window in inflateBackInit() to unsigned char *
 *
 * 1.2.beta7    27 Jan 2003
 * - Changed many types to unsigned or unsigned short to avoid warnings
 * - Added inflateCopy() function
 *
 * 1.2.0        9 Mar 2003
 * - Changed inflateBack() interface to provide separate opaque descriptors
 *   for the in() and out() functions
 * - Changed inflateBack() argument and in_func typedef to swap the length
 *   and buffer address return values for the input function
 * - Check next_in and next_out for Z_NULL on entry to inflate()
 *
 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
 */

#include "zutil.h"
#include "inftrees.h"
#include "inflate.h"
#include "inffast.h"

#ifdef MAKEFIXED
#  ifndef BUILDFIXED
#    define BUILDFIXED
#  endif
#endif

/* function prototypes */
local void fixedtables OF((struct inflate_state FAR *state));
local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
                           unsigned copy));
#ifdef BUILDFIXED
   void makefixed OF((void));
#endif
local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                              unsigned len));

int ZEXPORT inflateResetKeep(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    if (state->wrap)        /* to support ill-conceived Java test suite */
        strm->adler = state->wrap & 1;
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
    state->head = Z_NULL;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    state->sane = 1;
    state->back = -1;
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}

int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    state->wsize = 0;
    state->whave = 0;
    state->wnext = 0;
    return inflateResetKeep(strm);
}

int ZEXPORT inflateReset2(strm, windowBits)
z_streamp strm;
int windowBits;
{
    int wrap;
    struct inflate_state FAR *state;

    /* get the state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* extract wrap request from windowBits parameter */
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    }
    else {
        wrap = (windowBits >> 4) + 1;
#ifdef GUNZIP
        if (windowBits < 48)
            windowBits &= 15;
#endif
    }

    /* set number of window bits, free window if different */
    if (windowBits && (windowBits < 8 || windowBits > 15))
        return Z_STREAM_ERROR;
    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
        ZFREE(strm, state->window);
        state->window = Z_NULL;
    }

    /* update state and reset the rest of it */
    state->wrap = wrap;
    state->wbits = (unsigned)windowBits;
    return inflateReset(strm);
}

int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
    int ret;
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->window = Z_NULL;
    ret = inflateReset2(strm, windowBits);
    if (ret != Z_OK) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
    }
    return ret;
}

int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
}

int ZEXPORT inflatePrime(strm, bits, value)
z_streamp strm;
int bits;
int value;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (bits < 0) {
        state->hold = 0;
        state->bits = 0;
        return Z_OK;
    }
    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
    value &= (1L << bits) - 1;
    state->hold += value << state->bits;
    state->bits += bits;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables(state)
struct inflate_state FAR *state;
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

#ifdef MAKEFIXED
#include <stdio.h>

/*
   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   those tables to stdout, which would be piped to inffixed.h.  A small program
   can simply call makefixed to do this:

    void makefixed(void);

    int main(void)
    {
        makefixed();
        return 0;
    }

   Then that can be linked with zlib built with MAKEFIXED defined and run:

    a.out > inffixed.h
 */
void makefixed()
{
    unsigned low, size;
    struct inflate_state state;

    fixedtables(&state);
    puts("    /* inffixed.h -- table for decoding fixed codes");
    puts("     * Generated automatically by makefixed().");
    puts("     */");
    puts("");
    puts("    /* WARNING: this file should *not* be used by applications.");
    puts("       It is part of the implementation of this library and is");
    puts("       subject to change. Applications should only use zlib.h.");
    puts("     */");
    puts("");
    size = 1U << 9;
    printf("    static const code lenfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 7) == 0) printf("\n        ");
        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
               state.lencode[low].bits, state.lencode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
    size = 1U << 5;
    printf("\n    static const code distfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 6) == 0) printf("\n        ");
        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
               state.distcode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
}
#endif /* MAKEFIXED */

/*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
 */
local int updatewindow(strm, end, copy)
z_streamp strm;
const Bytef *end;
unsigned copy;
{
    struct inflate_state FAR *state;
    unsigned dist;

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
        state->wnext = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state->wsize) {
        zmemcpy(state->window, end - state->wsize, state->wsize);
        state->wnext = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->wnext;
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->wnext, end - copy, dist);
        copy -= dist;
        if (copy) {
            zmemcpy(state->window, end - copy, copy);
            state->wnext = copy;
            state->whave = state->wsize;
        }
        else {
            state->wnext += dist;
            if (state->wnext == state->wsize) state->wnext = 0;
            if (state->whave < state->wsize) state->whave += dist;
        }
    }
    return 0;
}

/* Macros for inflate(): */

/* check function to use adler32() for zlib or crc32() for gzip */
#ifdef GUNZIP
#  define UPDATE(check, buf, len) \
    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
#else
#  define UPDATE(check, buf, len) adler32(check, buf, len)
#endif

/* check macros for header crc */
#ifdef GUNZIP
#  define CRC2(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        check = crc32(check, hbuf, 2); \
    } while (0)

#  define CRC4(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        hbuf[2] = (unsigned char)((word) >> 16); \
        hbuf[3] = (unsigned char)((word) >> 24); \
        check = crc32(check, hbuf, 4); \
    } while (0)
#endif

/* Load registers with state in inflate() for speed */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Restore state from registers in inflate() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */
#define PULLBYTE() \
    do { \
        if (have == 0) goto inf_leave; \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/*
   inflate() uses a state machine to process as much input data and generate as
   much output data as possible before returning.  The state machine is
   structured roughly as follows:

    for (;;) switch (state) {
    ...
    case STATEn:
        if (not enough input data or output space to make progress)
            return;
        ... make progress ...
        state = STATEm;
        break;
    ...
    }

   so when inflate() is called again, the same case is attempted again, and
   if the appropriate resources are provided, the machine proceeds to the
   next state.  The NEEDBITS() macro is usually the way the state evaluates
   whether it can proceed or should return.  NEEDBITS() does the return if
   the requested bits are not available.  The typical use of the BITS macros
   is:

        NEEDBITS(n);
        ... do something with BITS(n) ...
        DROPBITS(n);

   where NEEDBITS(n) either returns from inflate() if there isn't enough
   input left to load n bits into the accumulator, or it continues.  BITS(n)
   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   the low n bits off the accumulator.  INITBITS() clears the accumulator
   and sets the number of available bits to zero.  BYTEBITS() discards just
   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.

   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   if there is no input available.  The decoding of variable length codes uses
   PULLBYTE() directly in order to pull just enough bytes to decode the next
   code, and no more.

   Some states loop until they get enough input, making sure that enough
   state information is maintained to continue the loop where it left off
   if NEEDBITS() returns in the loop.  For example, want, need, and keep
   would all have to actually be part of the saved state in case NEEDBITS()
   returns:

    case STATEw:
        while (want < need) {
            NEEDBITS(n);
            keep[want++] = BITS(n);
            DROPBITS(n);
        }
        state = STATEx;
    case STATEx:

   As shown above, if the next state is also the next case, then the break
   is omitted.

   A state may also return if there is not enough output space available to
   complete that state.  Those states are copying stored data, writing a
   literal byte, and copying a matching string.

   When returning, a "goto inf_leave" is used to update the total counters,
   update the check value, and determine whether any progress has been made
   during that inflate() call in order to return the proper return code.
   Progress is defined as a change in either strm->avail_in or strm->avail_out.
   When there is a window, goto inf_leave will update the window with the last
   output written.  If a goto inf_leave occurs in the middle of decompression
   and there is no window currently, goto inf_leave will create one and copy
   output to the window for the next call of inflate().

   In this implementation, the flush parameter of inflate() only affects the
   return code (per zlib.h).  inflate() always writes as much as possible to
   strm->next_out, given the space available and the provided input--the effect
   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   the allocation of and copying into a sliding window until necessary, which
   provides the effect documented in zlib.h for Z_FINISH when the entire input
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */

int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned in, out;           /* save starting available input and output */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
#ifdef GUNZIP
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
            if (state->wbits == 0)
                state->wbits = len;
            else if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
            state->mode = TIME;
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
            state->mode = OS;
        case OS:
            NEEDBITS(16);
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
                    next += copy;
                    state->length -= copy;
                }
                if (state->length) goto inf_leave;
            }
            state->length = 0;
            state->mode = NAME;
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
            state->mode = COMMENT;
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = ZSWAP32(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = TYPE;
        case TYPE:
            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
        case TYPEDO:
            if (state->last) {
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN_;             /* decode codes */
                if (flush == Z_TREES) {
                    DROPBITS(2);
                    goto inf_leave;
                }
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
            state->mode = COPY_;
            if (flush == Z_TREES) goto inf_leave;
        case COPY_:
            state->mode = COPY;
        case COPY:
            copy = state->length;
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
                break;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (const code FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN_;
            if (flush == Z_TREES) goto inf_leave;
        case LEN_:
            state->mode = LEN;
        case LEN:
            if (have >= 6 && left >= 258) {
                RESTORE();
                inflate_fast(strm, out);
                LOAD();
                if (state->mode == TYPE)
                    state->back = -1;
                break;
            }
            state->back = 0;
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            state->length = (unsigned)here.val;
            if ((int)(here.op) == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                state->mode = LIT;
                break;
            }
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->back = -1;
                state->mode = TYPE;
                break;
            }
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(here.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->was = state->length;
            state->mode = DIST;
        case DIST:
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;
            state->extra = (unsigned)(here.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
#ifdef INFLATE_STRICT
            if (state->offset > state->dmax) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->whave) {
                    if (state->sane) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                    Trace((stderr, "inflate.c too far\n"));
                    copy -= state->whave;
                    if (copy > state->length) copy = state->length;
                    if (copy > left) copy = left;
                    left -= copy;
                    state->length -= copy;
                    do {
                        *put++ = 0;
                    } while (--copy);
                    if (state->length == 0) state->mode = LEN;
                    break;
#endif
                }
                if (copy > state->wnext) {
                    copy -= state->wnext;
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->wnext - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
            left--;
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     ZSWAP32(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
        case LENGTH:
            if (state->wrap && state->flags) {
                NEEDBITS(32);
                if (hold != (state->total & 0xffffffffUL)) {
                    strm->msg = (char *)"incorrect length check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
        }

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
            (state->mode < CHECK || flush != Z_FINISH)))
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0) +
                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) ZFREE(strm, state->window);
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}

int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
z_streamp strm;
Bytef *dictionary;
uInt *dictLength;
{
    struct inflate_state FAR *state;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* copy dictionary */
    if (state->whave && dictionary != Z_NULL) {
        zmemcpy(dictionary, state->window + state->wnext,
                state->whave - state->wnext);
        zmemcpy(dictionary + state->whave - state->wnext,
                state->window, state->wnext);
    }
    if (dictLength != Z_NULL)
        *dictLength = state->whave;
    return Z_OK;
}

int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
z_streamp strm;
const Bytef *dictionary;
uInt dictLength;
{
    struct inflate_state FAR *state;
    unsigned long dictid;
    int ret;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->wrap != 0 && state->mode != DICT)
        return Z_STREAM_ERROR;

    /* check for correct dictionary identifier */
    if (state->mode == DICT) {
        dictid = adler32(0L, Z_NULL, 0);
        dictid = adler32(dictid, dictionary, dictLength);
        if (dictid != state->check)
            return Z_DATA_ERROR;
    }

    /* copy dictionary to window using updatewindow(), which will amend the
       existing dictionary if appropriate */
    ret = updatewindow(strm, dictionary + dictLength, dictLength);
    if (ret) {
        state->mode = MEM;
        return Z_MEM_ERROR;
    }
    state->havedict = 1;
    Tracev((stderr, "inflate:   dictionary set\n"));
    return Z_OK;
}

int ZEXPORT inflateGetHeader(strm, head)
z_streamp strm;
gz_headerp head;
{
    struct inflate_state FAR *state;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

    /* save header structure */
    state->head = head;
    head->done = 0;
    return Z_OK;
}

/*
   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
   or when out of input.  When called, *have is the number of pattern bytes
   found in order so far, in 0..3.  On return *have is updated to the new
   state.  If on return *have equals four, then the pattern was found and the
   return value is how many bytes were read including the last byte of the
   pattern.  If *have is less than four, then the pattern has not been found
   yet and the return value is len.  In the latter case, syncsearch() can be
   called again with more data and the *have state.  *have is initialized to
   zero for the first call.
 */
local unsigned syncsearch(have, buf, len)
unsigned FAR *have;
const unsigned char FAR *buf;
unsigned len;
{
    unsigned got;
    unsigned next;

    got = *have;
    next = 0;
    while (next < len && got < 4) {
        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
            got++;
        else if (buf[next])
            got = 0;
        else
            got = 4 - got;
        next++;
    }
    *have = got;
    return next;
}

int ZEXPORT inflateSync(strm)
z_streamp strm;
{
    unsigned len;               /* number of bytes to look at or looked at */
    unsigned long in, out;      /* temporary to save total_in and total_out */
    unsigned char buf[4];       /* to restore bit buffer to byte string */
    struct inflate_state FAR *state;

    /* check parameters */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

    /* if first time, start search in bit buffer */
    if (state->mode != SYNC) {
        state->mode = SYNC;
        state->hold <<= state->bits & 7;
        state->bits -= state->bits & 7;
        len = 0;
        while (state->bits >= 8) {
            buf[len++] = (unsigned char)(state->hold);
            state->hold >>= 8;
            state->bits -= 8;
        }
        state->have = 0;
        syncsearch(&(state->have), buf, len);
    }

    /* search available input */
    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
    strm->avail_in -= len;
    strm->next_in += len;
    strm->total_in += len;

    /* return no joy or set up to restart inflate() on a new block */
    if (state->have != 4) return Z_DATA_ERROR;
    in = strm->total_in;  out = strm->total_out;
    inflateReset(strm);
    strm->total_in = in;  strm->total_out = out;
    state->mode = TYPE;
    return Z_OK;
}

/*
   Returns true if inflate is currently at the end of a block generated by
   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   implementation to provide an additional safety check. PPP uses
   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   block. When decompressing, PPP checks that at the end of input packet,
   inflate is waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    return state->mode == STORED && state->bits == 0;
}

int ZEXPORT inflateCopy(dest, source)
z_streamp dest;
z_streamp source;
{
    struct inflate_state FAR *state;
    struct inflate_state FAR *copy;
    unsigned char FAR *window;
    unsigned wsize;

    /* check input */
    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)source->state;

    /* allocate space */
    copy = (struct inflate_state FAR *)
           ZALLOC(source, 1, sizeof(struct inflate_state));
    if (copy == Z_NULL) return Z_MEM_ERROR;
    window = Z_NULL;
    if (state->window != Z_NULL) {
        window = (unsigned char FAR *)
                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
        if (window == Z_NULL) {
            ZFREE(source, copy);
            return Z_MEM_ERROR;
        }
    }

    /* copy state */
    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
    if (state->lencode >= state->codes &&
        state->lencode <= state->codes + ENOUGH - 1) {
        copy->lencode = copy->codes + (state->lencode - state->codes);
        copy->distcode = copy->codes + (state->distcode - state->codes);
    }
    copy->next = copy->codes + (state->next - state->codes);
    if (window != Z_NULL) {
        wsize = 1U << state->wbits;
        zmemcpy(window, state->window, wsize);
    }
    copy->window = window;
    dest->state = (struct internal_state FAR *)copy;
    return Z_OK;
}

int ZEXPORT inflateUndermine(strm, subvert)
z_streamp strm;
int subvert;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    state->sane = !subvert;
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
    return Z_OK;
#else
    state->sane = 1;
    return Z_DATA_ERROR;
#endif
}

long ZEXPORT inflateMark(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
    state = (struct inflate_state FAR *)strm->state;
    return ((long)(state->back) << 16) +
        (state->mode == COPY ? state->length :
            (state->mode == MATCH ? state->was - state->length : 0));
}



================================================
File: src/zlib/inflate.h
================================================
/* inflate.h -- internal inflate state definition
 * Copyright (C) 1995-2009 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* define NO_GZIP when compiling if you want to disable gzip header and
   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
   the crc code when it is not needed.  For shared libraries, gzip decoding
   should be left enabled. */
#ifndef NO_GZIP
#  define GUNZIP
#endif

/* Possible inflate modes between inflate() calls */
typedef enum {
    HEAD,       /* i: waiting for magic header */
    FLAGS,      /* i: waiting for method and flags (gzip) */
    TIME,       /* i: waiting for modification time (gzip) */
    OS,         /* i: waiting for extra flags and operating system (gzip) */
    EXLEN,      /* i: waiting for extra length (gzip) */
    EXTRA,      /* i: waiting for extra bytes (gzip) */
    NAME,       /* i: waiting for end of file name (gzip) */
    COMMENT,    /* i: waiting for end of comment (gzip) */
    HCRC,       /* i: waiting for header crc (gzip) */
    DICTID,     /* i: waiting for dictionary check value */
    DICT,       /* waiting for inflateSetDictionary() call */
        TYPE,       /* i: waiting for type bits, including last-flag bit */
        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
        STORED,     /* i: waiting for stored size (length and complement) */
        COPY_,      /* i/o: same as COPY below, but only first time in */
        COPY,       /* i/o: waiting for input or output to copy stored block */
        TABLE,      /* i: waiting for dynamic block table lengths */
        LENLENS,    /* i: waiting for code length code lengths */
        CODELENS,   /* i: waiting for length/lit and distance code lengths */
            LEN_,       /* i: same as LEN below, but only first time in */
            LEN,        /* i: waiting for length/lit/eob code */
            LENEXT,     /* i: waiting for length extra bits */
            DIST,       /* i: waiting for distance code */
            DISTEXT,    /* i: waiting for distance extra bits */
            MATCH,      /* o: waiting for output space to copy string */
            LIT,        /* o: waiting for output space to write literal */
    CHECK,      /* i: waiting for 32-bit check value */
    LENGTH,     /* i: waiting for 32-bit length (gzip) */
    DONE,       /* finished check, done -- remain here until reset */
    BAD,        /* got a data error -- remain here until reset */
    MEM,        /* got an inflate() memory error -- remain here until reset */
    SYNC        /* looking for synchronization bytes to restart inflate() */
} inflate_mode;

/*
    State transitions between above modes -

    (most modes can go to BAD or MEM on error -- not shown for clarity)

    Process header:
        HEAD -> (gzip) or (zlib) or (raw)
        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
                  HCRC -> TYPE
        (zlib) -> DICTID or TYPE
        DICTID -> DICT -> TYPE
        (raw) -> TYPEDO
    Read deflate blocks:
            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
            STORED -> COPY_ -> COPY -> TYPE
            TABLE -> LENLENS -> CODELENS -> LEN_
            LEN_ -> LEN
    Read deflate codes in fixed or dynamic block:
                LEN -> LENEXT or LIT or TYPE
                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
                LIT -> LEN
    Process trailer:
        CHECK -> LENGTH -> DONE
 */

/* state maintained between inflate() calls.  Approximately 10K bytes. */
struct inflate_state {
    inflate_mode mode;          /* current inflate mode */
    int last;                   /* true if processing last block */
    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
    int havedict;               /* true if dictionary provided */
    int flags;                  /* gzip header method and flags (0 if zlib) */
    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
    unsigned long check;        /* protected copy of check value */
    unsigned long total;        /* protected copy of output count */
    gz_headerp head;            /* where to save gzip header information */
        /* sliding window */
    unsigned wbits;             /* log base 2 of requested window size */
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if needed */
        /* bit accumulator */
    unsigned long hold;         /* input bit accumulator */
    unsigned bits;              /* number of bits in "in" */
        /* for string and stored block copying */
    unsigned length;            /* literal or length of data to copy */
    unsigned offset;            /* distance back to copy string from */
        /* for table and code decoding */
    unsigned extra;             /* extra bits needed */
        /* fixed and dynamic code tables */
    code const FAR *lencode;    /* starting table for length/literal codes */
    code const FAR *distcode;   /* starting table for distance codes */
    unsigned lenbits;           /* index bits for lencode */
    unsigned distbits;          /* index bits for distcode */
        /* dynamic table building */
    unsigned ncode;             /* number of code length code lengths */
    unsigned nlen;              /* number of length code lengths */
    unsigned ndist;             /* number of distance code lengths */
    unsigned have;              /* number of code lengths in lens[] */
    code FAR *next;             /* next available space in codes[] */
    unsigned short lens[320];   /* temporary storage for code lengths */
    unsigned short work[288];   /* work area for code table building */
    code codes[ENOUGH];         /* space for code tables */
    int sane;                   /* if false, allow invalid distance too far */
    int back;                   /* bits back of last unprocessed length/lit */
    unsigned was;               /* initial length of match */
};



================================================
File: src/zlib/inftrees.c
================================================
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "zutil.h"
#include "inftrees.h"

#define MAXBITS 15

const char inflate_copyright[] =
   " inflate 1.2.8 Copyright 1995-2013 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/*
   Build a set of tables to decode the provided canonical Huffman code.
   The code lengths are lens[0..codes-1].  The result starts at *table,
   whose indices are 0..2^bits-1.  work is a writable array of at least
   lens shorts, which is used as a work area.  type is the type of code
   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
codetype type;
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
    unsigned len;               /* a code's length in bits */
    unsigned sym;               /* index of code symbols */
    unsigned min, max;          /* minimum and maximum code lengths */
    unsigned root;              /* number of index bits for root table */
    unsigned curr;              /* number of index bits for current table */
    unsigned drop;              /* code bits to drop for sub-table */
    int left;                   /* number of prefix codes available */
    unsigned used;              /* code entries in table used */
    unsigned huff;              /* Huffman code */
    unsigned incr;              /* for incrementing code, index */
    unsigned fill;              /* index for replicating entries */
    unsigned low;               /* low bits for current root entry */
    unsigned mask;              /* mask for low root bits */
    code here;                  /* table entry for duplication */
    code FAR *next;             /* next available space in table */
    const unsigned short FAR *base;     /* base value table to use */
    const unsigned short FAR *extra;    /* extra bits table to use */
    int end;                    /* use base and extra for symbol > end */
    unsigned short count[MAXBITS+1];    /* number of codes of each length */
    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0};
    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64};

    /*
       Process a set of code lengths to create a canonical Huffman code.  The
       code lengths are lens[0..codes-1].  Each length corresponds to the
       symbols 0..codes-1.  The Huffman code is generated by first sorting the
       symbols by length from short to long, and retaining the symbol order
       for codes with equal lengths.  Then the code starts with all zero bits
       for the first code of the shortest length, and the codes are integer
       increments for the same length, and zeros are appended as the length
       increases.  For the deflate format, these bits are stored backwards
       from their more natural integer increment ordering, and so when the
       decoding tables are built in the large loop below, the integer codes
       are incremented backwards.

       This routine assumes, but does not check, that all of the entries in
       lens[] are in the range 0..MAXBITS.  The caller must assure this.
       1..MAXBITS is interpreted as that code length.  zero means that that
       symbol does not occur in this code.

       The codes are sorted by computing a count of codes for each length,
       creating from that a table of starting indices for each length in the
       sorted table, and then entering the symbols in order in the sorted
       table.  The sorted table is work[], with that space being provided by
       the caller.

       The length counts are used for other purposes as well, i.e. finding
       the minimum and maximum length codes, determining if there are any
       codes at all, checking for a valid set of lengths, and looking ahead
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
        if (count[max] != 0) break;
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        here.op = (unsigned char)64;    /* invalid code marker */
        here.bits = (unsigned char)1;
        here.val = (unsigned short)0;
        *(*table)++ = here;             /* make a table to force an error */
        *(*table)++ = here;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min < max; min++)
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

    /*
       Create and fill in decoding tables.  In this loop, the table being
       filled is at next and has curr index bits.  The code being used is huff
       with length len.  That code is converted to an index by dropping drop
       bits off of the bottom.  For codes where len is less than drop + curr,
       those top drop + curr - len bits are incremented through all values to
       fill the table with replicated entries.

       root is the number of index bits for the root table.  When len exceeds
       root, sub-tables are created pointed to by the root entry with an index
       of the low root bits of huff.  This is saved in low to check for when a
       new sub-table should be started.  drop is zero when the root table is
       being filled, and drop is root when sub-tables are being filled.

       When a new sub-table is needed, it is necessary to look ahead in the
       code lengths to determine what size sub-table is needed.  The length
       counts are used for this, and so count[] is decremented as codes are
       entered in the tables.

       used keeps track of how many table entries have been allocated from the
       provided *table space.  It is checked for LENS and DIST tables against
       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
       the initial root table size constants.  See the comments in inftrees.h
       for more information.

       sym increments through all symbols, and the loop terminates when
       all codes of length max, i.e. all codes, have been processed.  This
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
        end = -1;
    }

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if ((type == LENS && used > ENOUGH_LENS) ||
        (type == DISTS && used > ENOUGH_DISTS))
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        here.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
            here.op = (unsigned char)0;
            here.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            here.op = (unsigned char)(extra[work[sym]]);
            here.val = base[work[sym]];
        }
        else {
            here.op = (unsigned char)(32 + 64);         /* end of block */
            here.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = here;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
        }
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
            if (len == max) break;
            len = lens[work[sym]];
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
            if ((type == LENS && used > ENOUGH_LENS) ||
                (type == DISTS && used > ENOUGH_DISTS))
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
            (*table)[low].bits = (unsigned char)root;
            (*table)[low].val = (unsigned short)(next - *table);
        }
    }

    /* fill in remaining table entry if code is incomplete (guaranteed to have
       at most one remaining entry, since if the code is incomplete, the
       maximum code length that was allowed to get this far is one bit) */
    if (huff != 0) {
        here.op = (unsigned char)64;            /* invalid code marker */
        here.bits = (unsigned char)(len - drop);
        here.val = (unsigned short)0;
        next[huff] = here;
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}



================================================
File: src/zlib/inftrees.h
================================================
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-2005, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Structure for decoding tables.  Each entry provides either the
   information needed to do the operation requested by the code that
   indexed that table entry, or it provides a pointer to another
   table that indexes more bits of the code.  op indicates whether
   the entry is a pointer to another table, a literal, a length or
   distance, an end-of-block, or an invalid code.  For a table
   pointer, the low four bits of op is the number of index bits of
   that table.  For a length or distance, the low four bits of op
   is the number of extra bits to get after the code.  bits is
   the number of bits in this code or part of the code to drop off
   of the bit buffer.  val is the actual byte to output in the case
   of a literal, the base length or distance, or the offset from
   the current table to the next table.  Each entry is four bytes. */
typedef struct {
    unsigned char op;           /* operation, extra bits, table bits */
    unsigned char bits;         /* bits in this part of the code */
    unsigned short val;         /* offset in table or code value */
} code;

/* op values as set by inflate_table():
    00000000 - literal
    0000tttt - table link, tttt != 0 is the number of table index bits
    0001eeee - length or distance, eeee is the number of extra bits
    01100000 - end of block
    01000000 - invalid code
 */

/* Maximum size of the dynamic table.  The maximum number of code structures is
   1444, which is the sum of 852 for literal/length codes and 592 for distance
   codes.  These values were found by exhaustive searches using the program
   examples/enough.c found in the zlib distribtution.  The arguments to that
   program are the number of symbols, the initial root table size, and the
   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
   The initial root table size (9 or 6) is found in the fifth argument of the
   inflate_table() calls in inflate.c and infback.c.  If the root table size is
   changed, then these maximum sizes would be need to be recalculated and
   updated. */
#define ENOUGH_LENS 852
#define ENOUGH_DISTS 592
#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)

/* Type of code to build for inflate_table() */
typedef enum {
    CODES,
    LENS,
    DISTS
} codetype;

int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
                             unsigned codes, code FAR * FAR *table,
                             unsigned FAR *bits, unsigned short FAR *work));



================================================
File: src/zlib/trees.c
================================================
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2012 Jean-loup Gailly
 * detect_data_type() function provided freely by Cosmin Truta, 2006
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

static const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

static const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

static const uint8_t bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

static ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

static ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uint8_t _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uint8_t _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

static int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

static int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const int *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

static static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

static static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

static static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

static void tr_static_init (void);
static void init_block     (deflate_state *s);
static void pqdownheap     (deflate_state *s, ct_data *tree, int k);
static void gen_bitlen     (deflate_state *s, tree_desc *desc);
static void gen_codes      (ct_data *tree, int max_code, uint16_t *bl_count);
static void build_tree     (deflate_state *s, tree_desc *desc);
static void scan_tree      (deflate_state *s, ct_data *tree, int max_code);
static void send_tree      (deflate_state *s, ct_data *tree, int max_code);
static int  build_bl_tree  (deflate_state *s);
static void send_all_trees (deflate_state *s, int lcodes, int dcodes,
                              int blcodes);
static void compress_block (deflate_state *s, const ct_data *ltree,
                              const ct_data *dtree);
static int  detect_data_type (deflate_state *s);
static unsigned bi_reverse (unsigned value, int length);
static void bi_windup      (deflate_state *s);
static void bi_flush       (deflate_state *s);
static void copy_block     (deflate_state *s, uint8_t *buf, unsigned len,
                              int header);

#ifdef GEN_TREES_H
static void gen_trees_header OF(void);
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 64 and value fits in length bits.
 */


static void send_bits(deflate_state* s, uint64_t val, int len) {

#ifdef DEBUG
    Tracevv((stderr," l %2d v %4llx ", len, val));
    Assert(len > 0 && len <= 64, "invalid length");
    s->bits_sent += len;
#endif

    s->bi_buf ^= (val<<s->bi_valid);
    s->bi_valid += len;
    if (s->bi_valid >= 64) {
        *(uint64_t*)(&s->pending_buf[s->pending]) = s->bi_buf;
        s->pending += 8;
        s->bi_valid -= 64;
        s->bi_buf = val >> (len - s->bi_valid);
    }
}

/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
static void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    uint16_t bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
#endif

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uint8_t)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uint8_t)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uint8_t)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uint8_t)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
            "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "static const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "static const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uint8_t ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
        fprintf(header, "%2u%s", _dist_code[i],
                SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header,
        "const uint8_t ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
        fprintf(header, "%2u%s", _length_code[i],
                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "static const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
        fprintf(header, "%1u%s", base_length[i],
                SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "static const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "%5u%s", base_dist[i],
                SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void ZLIB_INTERNAL _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
static void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
static void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
static void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    uint16_t f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (uint16_t)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if ((unsigned) tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (uint16_t)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
static void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    uint16_t *bl_count;            /* number of codes at each bit length */
{
    uint16_t next_code[MAX_BITS+1]; /* next code value for each bit length */
    uint16_t code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
static void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uint8_t)((s->depth[n] >= s->depth[m] ?
                                s->depth[n] : s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (uint16_t)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
static void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (uint16_t)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
static void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
static int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %lld, stat %lld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
static void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %lld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %lld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %lld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
    deflate_state *s;
    uint8_t *buf;       /* input block */
    uint64_t stored_len;   /* length of input block */
    int last;         /* one if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (uint64_t)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
 */
void ZLIB_INTERNAL _tr_flush_bits(s)
    deflate_state *s;
{
    bi_flush(s);
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
    deflate_state *s;
    uint8_t *buf;       /* input block, or NULL if too old */
    uint64_t stored_len;   /* length of input block */
    int last;         /* one if this is the last block for a file */
{
    uint64_t opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

        /* Check if the file is binary or text */
        if (s->strm->data_type == Z_UNKNOWN)
            s->strm->data_type = detect_data_type(s);

        /* Construct the literal and distance trees */
        build_tree(s, (tree_desc *)(&(s->l_desc)));
        Tracev((stderr, "\nlit data: dyn %lld, stat %lld", s->opt_len,
                s->static_len));

        build_tree(s, (tree_desc *)(&(s->d_desc)));
        Tracev((stderr, "\ndist data: dyn %lld, stat %lld", s->opt_len,
                s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */

        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);

        /* Determine the best encoding. Compute the block lengths in bytes. */
        opt_lenb = (s->opt_len+3+7)>>3;
        static_lenb = (s->static_len+3+7)>>3;

        Tracev((stderr, "\nopt %llu(%llu) stat %llu(%llu) stored %llu lit %u ",
                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                s->last_lit));

        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (uint8_t*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != NULL) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != NULL) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, last);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+last, 3);
        compress_block(s, (const ct_data *)static_ltree,
                       (const ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+last, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (const ct_data *)s->dyn_ltree,
                       (const ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    init_block(s);

    if (last) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %llu(%llu) ", s->compressed_len>>3,
           s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int ZLIB_INTERNAL _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (uint16_t)dist;
    s->l_buf[s->last_lit++] = (uint8_t)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((uint16_t)dist < (ush)MAX_DIST(s) &&
               (uint16_t)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (uint16_t)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        uint64_t out_length = (ulg)s->last_lit*8L;
        uint64_t in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
static void compress_block(s, ltree, dtree)
    deflate_state *s;
    const ct_data *ltree; /* literal tree */
    const ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    uint64_t bit_buf = s->bi_buf;
    int filled = s->bi_valid;

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            uint64_t val = ltree[lc].Code;
            int len = ltree[lc].Len;
#ifdef DEBUG
            Tracevv((stderr," l %2d v %4llx ", len, val));
            Assert(len > 0 && len <= 64, "invalid length");
            s->bits_sent += len;
#endif
            bit_buf ^= (val << filled);
            filled += len;

            if(filled >= 64) {
                *(uint64_t*)(&s->pending_buf[s->pending]) = bit_buf;
                s->pending += 8;
                filled -= 64;
                bit_buf = val >> (len - filled);
            }

            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];

            uint64_t val = ltree[code+LITERALS+1].Code;
            int len = ltree[code+LITERALS+1].Len;
#ifdef DEBUG
            Tracevv((stderr," l %2d v %4llx ", len, val));
            Assert(len > 0 && len <= 64, "invalid length");
            s->bits_sent += len;
#endif
            bit_buf ^= (val << filled);
            filled += len;
            if(filled >= 64) {
                *(uint64_t*)(&s->pending_buf[s->pending]) = bit_buf;
                s->pending += 8;
                filled -= 64;
                bit_buf = val >> (len - filled);
            }
            
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                val = lc;
                len = extra;
#ifdef DEBUG
                Tracevv((stderr," l %2d v %4llx ", len, val));
                Assert(len > 0 && len <= 64, "invalid length");
                s->bits_sent += len;
#endif
                bit_buf ^= (val << filled);
                filled += len;

                if(filled >= 64) {
                    *(uint64_t*)(&s->pending_buf[s->pending]) = bit_buf;
                    s->pending += 8;
                    filled -= 64;
                    bit_buf = val >> (len - filled);
                }
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");
            val = dtree[code].Code;
            len = dtree[code].Len;
#ifdef DEBUG
            Tracevv((stderr," l %2d v %4llx ", len, val));
            Assert(len > 0 && len <= 64, "invalid length");
            s->bits_sent += len;
#endif
            bit_buf ^= (val << filled);
            filled += len;
            if(filled >= 64) {
                *(uint64_t*)(&s->pending_buf[s->pending]) = bit_buf;
                s->pending += 8;
                filled -= 64;
                bit_buf = val >> (len - filled);
            }

            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];

                val = dist;
                len = extra;
                bit_buf ^= (val << filled);
                filled += len;
#ifdef DEBUG
                Tracevv((stderr," l %2d v %4llx ", len, val));
                Assert(len > 0 && len <= 64, "invalid length");
                s->bits_sent += len;
#endif
                if(filled >= 64) {
                    *(uint64_t*)(&s->pending_buf[s->pending]) = bit_buf;
                    s->pending += 8;
                    filled -= 64;
                    bit_buf = val >> (len - filled);
                }
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
               "pendingBuf overflow");

    } while (lx < s->last_lit);
    uint64_t val = ltree[END_BLOCK].Code;
    int len = ltree[END_BLOCK].Len;
#ifdef DEBUG
    Tracevv((stderr," l %2d v %4llx ", len, val));
    Assert(len > 0 && len <= 64, "invalid length");
    s->bits_sent += len;
#endif
    bit_buf ^= (val << filled);
    filled += len;

    if(filled >= 64) {
        *(uint64_t*)(&s->pending_buf[s->pending]) = bit_buf;
        s->pending += 8;
        filled -= 64;
        bit_buf = val >> (len - filled);
    }

    s->bi_buf = bit_buf;
    s->bi_valid = filled;
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
static int detect_data_type(s)
    deflate_state *s;
{
    /* black_mask is the bit mask of black-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */
    unsigned long black_mask = 0xf3ffc07fUL;
    int n;

    /* Check for non-textual ("black-listed") bytes. */
    for (n = 0; n <= 31; n++, black_mask >>= 1)
        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
            return Z_BINARY;

    /* Check for textual ("white-listed") bytes. */
    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
            || s->dyn_ltree[13].Freq != 0)
        return Z_TEXT;
    for (n = 32; n < LITERALS; n++)
        if (s->dyn_ltree[n].Freq != 0)
            return Z_TEXT;

    /* There are no "black-listed" or "white-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */
    return Z_BINARY;
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
static unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
static void bi_flush(s)
    deflate_state *s;
{
    while (s->bi_valid >= 16) {
        put_short(s, s->bi_buf);
        s->bi_buf >>= 16;
        s->bi_valid -= 16;
    }
    if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
static void bi_windup(s)
    deflate_state *s;
{
    while (s->bi_valid >= 16) {
        put_short(s, s->bi_buf);
        s->bi_buf >>= 16;
        s->bi_valid -= 16;
    }
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
static void copy_block(s, buf, len, header)
    deflate_state *s;
    uint8_t    *buf;    /* the input data */
    unsigned len;     /* its length */
    int      header;  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */

    if (header) {
        put_short(s, (uint16_t)len);
        put_short(s, (uint16_t)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}



================================================
File: src/zlib/trees.h
================================================
/* header created automatically with -DGEN_TREES_H */

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};




================================================
File: src/zlib/uncompr.c
================================================
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-2003, 2010 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#define ZLIB_INTERNAL
#include "zlib.h"

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/
int ZEXPORT uncompress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    z_stream stream;
    int err;

    stream.next_in = (z_const Bytef *)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))
            return Z_DATA_ERROR;
        return err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}



================================================
File: src/zlib/zconf.h
================================================
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2013 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#ifndef ZCONF_H
#define ZCONF_H
#include <stdint.h>
/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 * Even better than compiling with -DZ_PREFIX would be to use configure to set
 * this permanently in zconf.h using "./configure --zprefix".
 */
#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
#  define Z_PREFIX_SET

/* all linked symbols */
#  define _dist_code            z__dist_code
#  define _length_code          z__length_code
#  define _tr_align             z__tr_align
#  define _tr_flush_bits        z__tr_flush_bits
#  define _tr_flush_block       z__tr_flush_block
#  define _tr_init              z__tr_init
#  define _tr_stored_block      z__tr_stored_block
#  define _tr_tally             z__tr_tally
#  define adler32               z_adler32
#  define adler32_combine       z_adler32_combine
#  define adler32_combine64     z_adler32_combine64
#  ifndef Z_SOLO
#    define compress              z_compress
#    define compress2             z_compress2
#    define compressBound         z_compressBound
#  endif
#  define crc32                 z_crc32
#  define crc32_combine         z_crc32_combine
#  define crc32_combine64       z_crc32_combine64
#  define deflate               z_deflate
#  define deflateBound          z_deflateBound
#  define deflateCopy           z_deflateCopy
#  define deflateEnd            z_deflateEnd
#  define deflateInit2_         z_deflateInit2_
#  define deflateInit_          z_deflateInit_
#  define deflateParams         z_deflateParams
#  define deflatePending        z_deflatePending
#  define deflatePrime          z_deflatePrime
#  define deflateReset          z_deflateReset
#  define deflateResetKeep      z_deflateResetKeep
#  define deflateSetDictionary  z_deflateSetDictionary
#  define deflateSetHeader      z_deflateSetHeader
#  define deflateTune           z_deflateTune
#  define deflate_copyright     z_deflate_copyright
#  define get_crc_table         z_get_crc_table
#  ifndef Z_SOLO
#    define gz_error              z_gz_error
#    define gz_intmax             z_gz_intmax
#    define gz_strwinerror        z_gz_strwinerror
#    define gzbuffer              z_gzbuffer
#    define gzclearerr            z_gzclearerr
#    define gzclose               z_gzclose
#    define gzclose_r             z_gzclose_r
#    define gzclose_w             z_gzclose_w
#    define gzdirect              z_gzdirect
#    define gzdopen               z_gzdopen
#    define gzeof                 z_gzeof
#    define gzerror               z_gzerror
#    define gzflush               z_gzflush
#    define gzgetc                z_gzgetc
#    define gzgetc_               z_gzgetc_
#    define gzgets                z_gzgets
#    define gzoffset              z_gzoffset
#    define gzoffset64            z_gzoffset64
#    define gzopen                z_gzopen
#    define gzopen64              z_gzopen64
#    ifdef _WIN32
#      define gzopen_w              z_gzopen_w
#    endif
#    define gzprintf              z_gzprintf
#    define gzvprintf             z_gzvprintf
#    define gzputc                z_gzputc
#    define gzputs                z_gzputs
#    define gzread                z_gzread
#    define gzrewind              z_gzrewind
#    define gzseek                z_gzseek
#    define gzseek64              z_gzseek64
#    define gzsetparams           z_gzsetparams
#    define gztell                z_gztell
#    define gztell64              z_gztell64
#    define gzungetc              z_gzungetc
#    define gzwrite               z_gzwrite
#  endif
#  define inflate               z_inflate
#  define inflateBack           z_inflateBack
#  define inflateBackEnd        z_inflateBackEnd
#  define inflateBackInit_      z_inflateBackInit_
#  define inflateCopy           z_inflateCopy
#  define inflateEnd            z_inflateEnd
#  define inflateGetHeader      z_inflateGetHeader
#  define inflateInit2_         z_inflateInit2_
#  define inflateInit_          z_inflateInit_
#  define inflateMark           z_inflateMark
#  define inflatePrime          z_inflatePrime
#  define inflateReset          z_inflateReset
#  define inflateReset2         z_inflateReset2
#  define inflateSetDictionary  z_inflateSetDictionary
#  define inflateGetDictionary  z_inflateGetDictionary
#  define inflateSync           z_inflateSync
#  define inflateSyncPoint      z_inflateSyncPoint
#  define inflateUndermine      z_inflateUndermine
#  define inflateResetKeep      z_inflateResetKeep
#  define inflate_copyright     z_inflate_copyright
#  define inflate_fast          z_inflate_fast
#  define inflate_table         z_inflate_table
#  ifndef Z_SOLO
#    define uncompress            z_uncompress
#  endif
#  define zError                z_zError
#  ifndef Z_SOLO
#    define zcalloc               z_zcalloc
#    define zcfree                z_zcfree
#  endif
#  define zlibCompileFlags      z_zlibCompileFlags
#  define zlibVersion           z_zlibVersion

/* all zlib typedefs in zlib.h and zconf.h */
#  define Byte                  z_Byte
#  define Bytef                 z_Bytef
#  define alloc_func            z_alloc_func
#  define charf                 z_charf
#  define free_func             z_free_func
#  ifndef Z_SOLO
#    define gzFile                z_gzFile
#  endif
#  define gz_header             z_gz_header
#  define gz_headerp            z_gz_headerp
#  define in_func               z_in_func
#  define intf                  z_intf
#  define out_func              z_out_func
#  define uInt                  z_uInt
#  define uIntf                 z_uIntf
#  define uLong                 z_uLong
#  define uLongf                z_uLongf
#  define voidp                 z_voidp
#  define voidpc                z_voidpc
#  define voidpf                z_voidpf

/* all zlib structs in zlib.h and zconf.h */
#  define gz_header_s           z_gz_header_s
#  define internal_state        z_internal_state

#endif

#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif
#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
#  define OS2
#endif
#if defined(_WINDOWS) && !defined(WINDOWS)
#  define WINDOWS
#endif
#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
#    ifndef SYS16BIT
#      define SYS16BIT
#    endif
#  endif
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#ifdef SYS16BIT
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#ifdef __STDC_VERSION__
#  ifndef STDC
#    define STDC
#  endif
#  if __STDC_VERSION__ >= 199901L
#    ifndef STDC99
#      define STDC99
#    endif
#  endif
#endif
#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
#  define STDC
#endif
#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
#  define STDC
#endif
#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
#  define STDC
#endif
#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
#  define STDC
#endif

#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
#  define STDC
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const       /* note: need a more gentle solution here */
#  endif
#endif

#if defined(ZLIB_CONST) && !defined(z_const)
#  define z_const const
#else
#  define z_const
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

#ifndef Z_ARG /* function prototypes for stdarg */
#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
#    define Z_ARG(args)  args
#  else
#    define Z_ARG(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#ifdef SYS16BIT
#  if defined(M_I86SM) || defined(M_I86MM)
     /* MSC small or medium model */
#    define SMALL_MEDIUM
#    ifdef _MSC_VER
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#  if (defined(__SMALL__) || defined(__MEDIUM__))
     /* Turbo C small or medium model */
#    define SMALL_MEDIUM
#    ifdef __BORLANDC__
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#endif

#if defined(WINDOWS) || defined(WIN32)
   /* If building or using zlib as a DLL, define ZLIB_DLL.
    * This is not mandatory, but it offers a little performance increase.
    */
#  ifdef ZLIB_DLL
#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
#      ifdef ZLIB_INTERNAL
#        define ZEXTERN extern __declspec(dllexport)
#      else
#        define ZEXTERN extern __declspec(dllimport)
#      endif
#    endif
#  endif  /* ZLIB_DLL */
   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
    * define ZLIB_WINAPI.
    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
    */
#  ifdef ZLIB_WINAPI
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
     /* No need for _export, use ZLIB.DEF instead. */
     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
#    define ZEXPORT WINAPI
#    ifdef WIN32
#      define ZEXPORTVA WINAPIV
#    else
#      define ZEXPORTVA FAR CDECL
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  ifdef ZLIB_DLL
#    ifdef ZLIB_INTERNAL
#      define ZEXPORT   __declspec(dllexport)
#      define ZEXPORTVA __declspec(dllexport)
#    else
#      define ZEXPORT   __declspec(dllimport)
#      define ZEXPORTVA __declspec(dllimport)
#    endif
#  endif
#endif

#ifndef ZEXTERN
#  define ZEXTERN extern
#endif
#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif

#ifndef FAR
#  define FAR
#endif

#if !defined(__MACTYPES__)
typedef uint8_t    Byte;  /* 8 bits */
#endif
typedef uint32_t   uInt;  /* 32 bits */
typedef uint64_t   uLong; /* 64 bits */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void const *voidpc;
   typedef void FAR   *voidpf;
   typedef void       *voidp;
#else
   typedef Byte const *voidpc;
   typedef Byte FAR   *voidpf;
   typedef Byte       *voidp;
#endif

#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
#  include <limits.h>
#  if (UINT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned
#  elif (ULONG_MAX == 0xffffffffUL)
#    define Z_U4 unsigned long
#  elif (USHRT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned short
#  endif
#endif

#ifdef Z_U4
   typedef Z_U4 z_crc_t;
#else
   typedef unsigned long z_crc_t;
#endif

#if 0    /* was set to #if 1 by ./configure */
#  define Z_HAVE_UNISTD_H
#endif

#if 1    /* was set to #if 1 by ./configure */
#  define Z_HAVE_STDARG_H
#endif

#ifdef STDC
#  ifndef Z_SOLO
#    include <sys/types.h>      /* for off_t */
#  endif
#endif

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
#    include <stdarg.h>         /* for va_list */
#  endif
#endif

#ifdef _WIN32
#  ifndef Z_SOLO
#    include <stddef.h>         /* for wchar_t */
#  endif
#endif

/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
 * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
 * though the former does not conform to the LFS document), but considering
 * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
 * equivalently requesting no 64-bit operations
 */
#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
#  undef _LARGEFILE64_SOURCE
#endif

#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
#  define Z_HAVE_UNISTD_H
#endif
#ifndef Z_SOLO
#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
#    ifdef VMS
#      include <unixio.h>       /* for off_t */
#    endif
#    ifndef z_off_t
#      define z_off_t off_t
#    endif
#  endif
#endif

#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
#  define Z_LFS64
#endif

#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
#  define Z_LARGE64
#endif

#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
#  define Z_WANT64
#endif

#if !defined(SEEK_SET) && !defined(Z_SOLO)
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif

#ifndef z_off_t
#  define z_off_t long
#endif

#if !defined(_WIN32) && defined(Z_LARGE64)
#  define z_off64_t off64_t
#else
#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
#    define z_off64_t __int64
#  else
#    define z_off64_t z_off_t
#  endif
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
  #pragma map(deflateInit_,"DEIN")
  #pragma map(deflateInit2_,"DEIN2")
  #pragma map(deflateEnd,"DEEND")
  #pragma map(deflateBound,"DEBND")
  #pragma map(inflateInit_,"ININ")
  #pragma map(inflateInit2_,"ININ2")
  #pragma map(inflateEnd,"INEND")
  #pragma map(inflateSync,"INSY")
  #pragma map(inflateSetDictionary,"INSEDI")
  #pragma map(compressBound,"CMBND")
  #pragma map(inflate_table,"INTABL")
  #pragma map(inflate_fast,"INFA")
  #pragma map(inflate_copyright,"INCOPY")
#endif

#endif /* ZCONF_H */



================================================
File: src/zlib/zlib.h
================================================
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.8, April 28th, 2013

  Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
*/

#ifndef ZLIB_H
#define ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.2.8"
#define ZLIB_VERNUM 0x1280
#define ZLIB_VER_MAJOR 1
#define ZLIB_VER_MINOR 2
#define ZLIB_VER_REVISION 8
#define ZLIB_VER_SUBREVISION 0

/*
    The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed data.
  This version of the library supports only one compression method (deflation)
  but other algorithms will be added later and will have the same stream
  interface.

    Compression can be done in a single step if the buffers are large enough,
  or can be done by repeated calls of the compression function.  In the latter
  case, the application must provide more input and/or consume the output
  (providing more output space) before each call.

    The compressed data format used by default by the in-memory functions is
  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
  around a deflate stream, which is itself documented in RFC 1951.

    The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio using the functions that start
  with "gz".  The gzip format is different from the zlib format.  gzip is a
  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.

    This library can optionally read and write gzip streams in memory as well.

    The zlib format was designed to be compact and fast for use in memory
  and on communications channels.  The gzip format was designed for single-
  file compression on file systems, has a larger header than zlib to maintain
  directory information, and uses a different, slower check method than zlib.

    The library does not install any signal handler.  The decoder checks
  the consistency of the compressed data, so the library should never crash
  even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    z_const Bytef *next_in;     /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total number of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total number of bytes output so far */

    z_const char *msg;  /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: binary or text */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
     gzip header information passed to and from zlib routines.  See RFC 1952
  for more details on the meanings of these fields.
*/
typedef struct gz_header_s {
    int     text;       /* true if compressed data believed to be text */
    uLong   time;       /* modification time */
    int     xflags;     /* extra flags (not used when writing a gzip file) */
    int     os;         /* operating system */
    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
    uInt    extra_max;  /* space at extra (only when reading header) */
    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
    uInt    name_max;   /* space at name (only when reading header) */
    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
    uInt    comm_max;   /* space at comment (only when reading header) */
    int     hcrc;       /* true if there was or will be a header crc */
    int     done;       /* true when done reading gzip header (not used
                           when writing a gzip file) */
} gz_header;

typedef gz_header FAR *gz_headerp;

/*
     The application must update next_in and avail_in when avail_in has dropped
   to zero.  It must update next_out and avail_out when avail_out has dropped
   to zero.  The application must initialize zalloc, zfree and opaque before
   calling the init function.  All other fields are set by the compression
   library and must not be updated by the application.

     The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree.  This can be useful for custom
   memory management.  The compression library attaches no meaning to the
   opaque value.

     zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

     On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this if
   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
   returned by zalloc for objects of exactly 65536 bytes *must* have their
   offset normalized to zero.  The default allocation function provided by this
   library ensures this (see zutil.c).  To reduce memory requirements and avoid
   any allocation of 64K objects, at the expense of compression ratio, compile
   the library with -DMAX_WBITS=14 (see zconf.h).

     The fields total_in and total_out can be used for statistics or progress
   reports.  After compression, total_in holds the total size of the
   uncompressed data and may be saved for use in the decompressor (particularly
   if the decompressor wants to decompress everything in a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
#define Z_BLOCK         5
#define Z_TREES         6
/* Allowed flush values; see deflate() and inflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_RLE                 3
#define Z_FIXED               4
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_TEXT     1
#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
#define Z_UNKNOWN  2
/* Possible values of the data_type field (though see inflate()) */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */


                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is not
   compatible with the zlib.h header file used by the application.  This check
   is automatically made by deflateInit and inflateInit.
 */

/*
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression.  The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
   allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at all
   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
   requests a default compromise between speed and compression (currently
   equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if level is not a valid compression level, or
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
   if there is no error message.  deflateInit does not perform any compression:
   this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows.  deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).  Some
    output may be provided even if flush is not set.

    Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating avail_in or avail_out accordingly; avail_out should
  never be zero before the call.  The application can consume the compressed
  output when it wants, for example when the output buffer is full (avail_out
  == 0), or after each call of deflate().  If deflate returns Z_OK and with
  zero avail_out, it must be called again after making room in the output
  buffer because there might be more output pending.

    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
  decide how much data to accumulate before producing output, in order to
  maximize compression.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far.  (In
  particular avail_in is zero after the call if enough output space has been
  provided before the call.) Flushing may degrade compression for some
  compression algorithms and so it should be used only when necessary.  This
  completes the current deflate block and follows it with an empty stored block
  that is three bits plus filler bits to the next byte, followed by four bytes
  (00 00 ff ff).

    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
  output buffer, but the output is not aligned to a byte boundary.  All of the
  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
  This completes the current deflate block and follows it with an empty fixed
  codes block that is 10 bits long.  This assures that enough bytes are output
  in order for the decompressor to finish the block before the empty fixed code
  block.

    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
  seven bits of the current block are held to be written as the next byte after
  the next deflate block is completed.  In this case, the decompressor may not
  be provided enough bits at this point in order to complete decompression of
  the data provided so far to the compressor.  It may need to wait for the next
  block to be emitted.  This is for advanced applications that need to control
  the emission of deflate blocks.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
  compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
  avail_out is greater than six to avoid repeated flush markers due to
  avail_out == 0 on return.

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there was
  enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error.  After
  deflate has returned Z_STREAM_END, the only possible operations on the stream
  are deflateReset or deflateEnd.

    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step.  In this case, avail_out must be at least the
  value returned by deflateBound (see below).  Then deflate is guaranteed to
  return Z_STREAM_END.  If not enough output space is provided, deflate will
  not return Z_STREAM_END, and it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update strm->data_type if it can make a good guess about
  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
  binary.  This field is only for information purposes and does not affect the
  compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
  fatal, and deflate() can be called again with more input and more output
  space to continue compressing.
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded).  In the error case, msg
   may be set but then points to a static string (which must not be
   deallocated).
*/


/*
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression.  The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
   exact value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit does not perform any decompression
   apart from possibly reading the zlib header if present: actual decompression
   will be done by inflate().  (So next_in and avail_in may be modified, but
   next_out and avail_out are unused and unchanged.) The current implementation
   of inflateInit() does not process any header information -- that is deferred
   until inflate() is called.
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

  The detailed semantics are as follows.  inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing will
    resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there is
    no more input data or no more space in the output buffer (see below about
    the flush parameter).

    Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating the next_* and avail_* values accordingly.  The
  application can consume the uncompressed output when it wants, for example
  when the output buffer is full (avail_out == 0), or after each call of
  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
  called again after making room in the output buffer because there might be
  more output pending.

    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
  output as possible to the output buffer.  Z_BLOCK requests that inflate()
  stop if and when it gets to the next deflate block boundary.  When decoding
  the zlib or gzip format, this will cause inflate() to return immediately
  after the header and before the first block.  When doing a raw inflate,
  inflate() will go ahead and process the first block, and will return when it
  gets to the end of that block, or when it runs out of data.

    The Z_BLOCK option assists in appending to or combining deflate streams.
  Also to assist in this, on return inflate() will set strm->data_type to the
  number of unused bits in the last byte taken from strm->next_in, plus 64 if
  inflate() is currently decoding the last block in the deflate stream, plus
  128 if inflate() returned immediately after decoding an end-of-block code or
  decoding the complete header up to just before the first byte of the deflate
  stream.  The end-of-block will not be indicated until all of the uncompressed
  data from that block has been written to strm->next_out.  The number of
  unused bits may in general be greater than seven, except when bit 7 of
  data_type is set, in which case the number of unused bits will be less than
  eight.  data_type is set as noted here every time inflate() returns for all
  flush options, and so can be used to determine the amount of currently
  consumed input in bits.

    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
  end of each deflate block header is reached, before any actual data in that
  block is decoded.  This allows the caller to determine the length of the
  deflate block header for later use in random access within a deflate block.
  256 is added to the value of strm->data_type when inflate() returns
  immediately after reaching the end of the deflate block header.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error.  However if all decompression is to be performed in a single step (a
  single call of inflate), the parameter flush should be set to Z_FINISH.  In
  this case all pending input is processed and all pending output is flushed;
  avail_out must be large enough to hold all of the uncompressed data for the
  operation to complete.  (The size of the uncompressed data may have been
  saved by the compressor for this purpose.) The use of Z_FINISH is not
  required to perform an inflation in one step.  However it may be used to
  inform inflate that a faster approach can be used for the single inflate()
  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
  stream completes, which reduces inflate's memory footprint.  If the stream
  does not complete, either because not all of the stream is provided or not
  enough output space is provided, then a sliding window will be allocated and
  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
  been used.

     In this implementation, inflate() always flushes as much output as
  possible to the output buffer, and always uses the faster approach on the
  first call.  So the effects of the flush parameter in this implementation are
  on the return value of inflate() as noted below, when inflate() returns early
  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
  memory for a sliding window when Z_FINISH is used.

     If a preset dictionary is needed after this call (see inflateSetDictionary
  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
  strm->adler to the Adler-32 checksum of all output produced so far (that is,
  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
  below.  At the end of the stream, inflate() checks that its computed adler32
  checksum is equal to that saved by the compressor and returns Z_STREAM_END
  only if the checksum is correct.

    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
  deflate data.  The header type is detected automatically, if requested when
  initializing with inflateInit2().  Any information contained in the gzip
  header is not retained, so applications that need that information should
  instead use raw inflate, see inflateInit2() below, or inflateBack() and
  perform their own processing of the gzip header and trailer.  When processing
  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
  producted so far.  The CRC-32 is checked against the gzip trailer.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect check
  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
  inflate() can be called again with more input and more output space to
  continue decompressing.  If Z_DATA_ERROR is returned, the application may
  then call inflateSync() to look for a good compression block if a partial
  recovery of the data is desired.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent.  In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/


                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options.  The
   fields next_in, zalloc, zfree and opaque must be initialized before by the
   caller.

     The method parameter is the compression method.  It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library.  Larger values of this parameter result in better
   compression at the expense of memory usage.  The default value is 15 if
   deflateInit is used instead.

     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
   determines the window size.  deflate() will then generate raw deflate data
   with no zlib header or trailer, and will not compute an adler32 check value.

     windowBits can also be greater than 15 for optional gzip encoding.  Add
   16 to windowBits to write a simple gzip header and trailer around the
   compressed data instead of a zlib wrapper.  The gzip header will have no
   file name, no extra data, no comment, no modification time (set to zero), no
   header crc, and the operating system will be set to 255 (unknown).  If a
   gzip stream is being written, strm->adler is a crc32 instead of an adler32.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state.  memLevel=1 uses minimum memory but is
   slow and reduces compression ratio; memLevel=9 uses maximum memory for
   optimal speed.  The default value is 8.  See zconf.h for total memory usage
   as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm.  Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match), or Z_RLE to limit match distances to one (run-length
   encoding).  Filtered data consists mostly of small values with a somewhat
   random distribution.  In this case, the compression algorithm is tuned to
   compress them better.  The effect of Z_FILTERED is to force more Huffman
   coding and less string matching; it is somewhat intermediate between
   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
   strategy parameter only affects the compression ratio but not the
   correctness of the compressed output even if it is not set appropriately.
   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
   decoder for special applications.

     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
   set to null if there is no error message.  deflateInit2 does not perform any
   compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output.  When using the zlib format, this
   function must be called immediately after deflateInit, deflateInit2 or
   deflateReset, and before any call of deflate.  When doing raw deflate, this
   function must be called either before any call of deflate, or immediately
   after the completion of a deflate block, i.e. after all input has been
   consumed and all output has been delivered when using any of the flush
   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
   compressor and decompressor must use exactly the same dictionary (see
   inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary.  Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size
   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
   useful should be put at the end of the dictionary, not at the front.  In
   addition, the current implementation of deflate will use at most the window
   size minus 262 bytes of the provided dictionary.

     Upon return of this function, strm->adler is set to the adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor.  (The adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.) If a raw deflate was requested, then the
   adler32 value is not computed and strm->adler is not set.

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if not at a block boundary for raw deflate).  deflateSetDictionary does
   not perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter.  The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and can
   consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.  The
   stream will keep the same compression level and any other attributes that
   may have been set by deflateInit2.

     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
                                      int level,
                                      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different strategy.
   If the compression level is changed, the input available so far is
   compressed with the old level (and may be flushed); the new level will take
   effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to be
   compressed and flushed.  In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
   strm->avail_out was zero.
*/

ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
                                    int good_length,
                                    int max_lazy,
                                    int nice_length,
                                    int max_chain));
/*
     Fine tune deflate's internal compression parameters.  This should only be
   used by someone who understands the algorithm used by zlib's deflate for
   searching for the best matching string, and even then only by the most
   fanatic optimizer trying to squeeze out the last compressed bit for their
   specific input data.  Read the deflate.c source code for the meaning of the
   max_lazy, good_length, nice_length, and max_chain parameters.

     deflateTune() can be called after deflateInit() or deflateInit2(), and
   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
 */

ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
                                       uLong sourceLen));
/*
     deflateBound() returns an upper bound on the compressed size after
   deflation of sourceLen bytes.  It must be called after deflateInit() or
   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
   to allocate an output buffer for deflation in a single pass, and so would be
   called before deflate().  If that first deflate() call is provided the
   sourceLen input bytes, an output buffer allocated to the size returned by
   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
   to return Z_STREAM_END.  Note that it is possible for the compressed size to
   be larger than the value returned by deflateBound() if flush options other
   than Z_FINISH or Z_NO_FLUSH are used.
*/

ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
                                       unsigned *pending,
                                       int *bits));
/*
     deflatePending() returns the number of bytes and bits of output that have
   been generated, but not yet provided in the available output.  The bytes not
   provided would be due to the available output space having being consumed.
   The number of bits of output not provided are between 0 and 7, where they
   await more bits to join them in order to fill out a full byte.  If pending
   or bits are Z_NULL, then those values are not set.

     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
 */

ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     deflatePrime() inserts bits in the deflate output stream.  The intent
   is that this function is used to start off the deflate output with the bits
   leftover from a previous deflate stream when appending to it.  As such, this
   function can only be used for raw deflate, and must be used before the first
   deflate() call after a deflateInit2() or deflateReset().  bits must be less
   than or equal to 16, and that many of the least significant bits of value
   will be inserted in the output.

     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     deflateSetHeader() provides gzip header information for when a gzip
   stream is requested by deflateInit2().  deflateSetHeader() may be called
   after deflateInit2() or deflateReset() and before the first call of
   deflate().  The text, time, os, extra field, name, and comment information
   in the provided gz_header structure are written to the gzip header (xflag is
   ignored -- the extra flags are set according to the compression level).  The
   caller must assure that, if not Z_NULL, name and comment are terminated with
   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
   available there.  If hcrc is true, a gzip header crc is included.  Note that
   the current versions of the command-line version of gzip (up through version
   1.3.x) do not support header crc's, and will report that it is a "multi-part
   gzip file" and give up.

     If deflateSetHeader is not used, the default gzip header has text false,
   the time set to zero, and os set to 255, with no extra, name, or comment
   fields.  The gzip header is returned to the default state by deflateReset().

     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter.  The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library.  The default value is 15 if inflateInit is used
   instead.  windowBits must be greater than or equal to the windowBits value
   provided to deflateInit2() while compressing, or it must be equal to 15 if
   deflateInit2() was not used.  If a compressed stream with a larger window
   size is given as input, inflate() will return with the error code
   Z_DATA_ERROR instead of trying to allocate a larger window.

     windowBits can also be zero to request that inflate use the window size in
   the zlib header of the compressed stream.

     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
   determines the window size.  inflate() will then process raw deflate data,
   not looking for a zlib or gzip header, not generating a check value, and not
   looking for any check values for comparison at the end of the stream.  This
   is for use with other formats that use the deflate compressed data format
   such as zip.  Those formats provide their own check values.  If a custom
   format is developed using the raw deflate format for compressed data, it is
   recommended that a check value such as an adler32 or a crc32 be applied to
   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   most applications, the zlib format should be used as is.  Note that comments
   above on the use in deflateInit2() applies to the magnitude of windowBits.

     windowBits can also be greater than 15 for optional gzip decoding.  Add
   32 to windowBits to enable zlib and gzip decoding with automatic header
   detection, or add 16 to decode only the gzip format (the zlib format will
   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
   crc32 instead of an adler32.

     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit2 does not perform any decompression
   apart from possibly reading the zlib header if present: actual decompression
   will be done by inflate().  (So next_in and avail_in may be modified, but
   next_out and avail_out are unused and unchanged.) The current implementation
   of inflateInit2() does not process any header information -- that is
   deferred until inflate() is called.
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence.  This function must be called immediately after a call of inflate,
   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
   can be determined from the adler32 value returned by that call of inflate.
   The compressor and decompressor must use exactly the same dictionary (see
   deflateSetDictionary).  For raw inflate, this function can be called at any
   time to set the dictionary.  If the provided dictionary is smaller than the
   window and there is already data in the window, then the provided dictionary
   will amend what's there.  The application must insure that the dictionary
   that was used for compression is provided.

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect adler32 value).  inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
                                             Bytef *dictionary,
                                             uInt  *dictLength));
/*
     Returns the sliding dictionary being maintained by inflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If inflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similary, if dictLength is Z_NULL, then it is not set.

     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/*
     Skips invalid compressed data until a possible full flush point (see above
   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
   available input is skipped.  No output is provided.

     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
   All full flush points have this pattern, but not all occurrences of this
   pattern are full flush points.

     inflateSync returns Z_OK if a possible full flush point has been found,
   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
   In the success case, the application may save the current current value of
   total_in which indicates where valid compressed data was found.  In the
   error case, the application may repeatedly call inflateSync, providing more
   input each time, until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when randomly accessing a large stream.  The
   first pass through the stream can periodically record the inflate state,
   allowing restarting inflate at those points when randomly accessing the
   stream.

     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.  The
   stream will keep attributes that may have been set by inflateInit2.

     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
                                      int windowBits));
/*
     This function is the same as inflateReset, but it also permits changing
   the wrap and window size requests.  The windowBits parameter is interpreted
   the same as it is for inflateInit2.

     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
   the windowBits parameter is invalid.
*/

ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     This function inserts bits in the inflate input stream.  The intent is
   that this function is used to start inflating at a bit position in the
   middle of a byte.  The provided bits will be used before any bytes are used
   from next_in.  This function should only be used with raw inflate, and
   should be used before the first inflate() call after inflateInit2() or
   inflateReset().  bits must be less than or equal to 16, and that many of the
   least significant bits of value will be inserted in the input.

     If bits is negative, then the input stream bit buffer is emptied.  Then
   inflatePrime() can be called again to put bits in the buffer.  This is used
   to clear out bits leftover after feeding inflate a block description prior
   to feeding inflate codes.

     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
/*
     This function returns two values, one in the lower 16 bits of the return
   value, and the other in the remaining upper bits, obtained by shifting the
   return value down 16 bits.  If the upper value is -1 and the lower value is
   zero, then inflate() is currently decoding information outside of a block.
   If the upper value is -1 and the lower value is non-zero, then inflate is in
   the middle of a stored block, with the lower value equaling the number of
   bytes from the input remaining to copy.  If the upper value is not -1, then
   it is the number of bits back from the current bit position in the input of
   the code (literal or length/distance pair) currently being processed.  In
   that case the lower value is the number of bytes already emitted for that
   code.

     A code is being processed if inflate is waiting for more input to complete
   decoding of the code, or if it has completed decoding but is waiting for
   more output space to write the literal or match data.

     inflateMark() is used to mark locations in the input data for random
   access, which may be at bit positions, and to note those cases where the
   output of a code may span boundaries of random access blocks.  The current
   location in the input stream can be determined from avail_in and data_type
   as noted in the description for the Z_BLOCK flush parameter for inflate.

     inflateMark returns the value noted above or -1 << 16 if the provided
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     inflateGetHeader() requests that gzip header information be stored in the
   provided gz_header structure.  inflateGetHeader() may be called after
   inflateInit2() or inflateReset(), and before the first call of inflate().
   As inflate() processes the gzip stream, head->done is zero until the header
   is completed, at which time head->done is set to one.  If a zlib stream is
   being decoded, then head->done is set to -1 to indicate that there will be
   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
   used to force inflate() to return immediately after header processing is
   complete and before any actual data is decompressed.

     The text, time, xflags, and os fields are filled in with the gzip header
   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
   contains the maximum number of bytes to write to extra.  Once done is true,
   extra_len contains the actual extra field length, and extra contains the
   extra field, or that field truncated if extra_max is less than extra_len.
   If name is not Z_NULL, then up to name_max characters are written there,
   terminated with a zero unless the length is greater than name_max.  If
   comment is not Z_NULL, then up to comm_max characters are written there,
   terminated with a zero unless the length is greater than comm_max.  When any
   of extra, name, or comment are not Z_NULL and the respective field is not
   present in the header, then that field is set to Z_NULL to signal its
   absence.  This allows the use of deflateSetHeader() with the returned
   structure to duplicate the header.  However if those fields are set to
   allocated memory, then the application will need to save those pointers
   elsewhere so that they can be eventually freed.

     If inflateGetHeader is not used, then the header information is simply
   discarded.  The header is always checked for validity, including the header
   CRC if present.  inflateReset() will reset the process to discard the header
   information.  The application would need to call inflateGetHeader() again to
   retrieve the header from the next gzip stream.

     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
                                        unsigned char FAR *window));

     Initialize the internal stream state for decompression using inflateBack()
   calls.  The fields zalloc, zfree and opaque in strm must be initialized
   before the call.  If zalloc and zfree are Z_NULL, then the default library-
   derived memory allocation routines are used.  windowBits is the base two
   logarithm of the window size, in the range 8..15.  window is a caller
   supplied buffer of that size.  Except for special applications where it is
   assured that deflate was used with small window sizes, windowBits must be 15
   and a 32K byte window must be supplied to be able to decompress general
   deflate streams.

     See inflateBack() for the usage of these routines.

     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
   allocated, or Z_VERSION_ERROR if the version of the library does not match
   the version of the header file.
*/

typedef unsigned (*in_func) OF((void FAR *,
                                z_const unsigned char FAR * FAR *));
typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));

ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
                                    in_func in, void FAR *in_desc,
                                    out_func out, void FAR *out_desc));
/*
     inflateBack() does a raw inflate with a single call using a call-back
   interface for input and output.  This is potentially more efficient than
   inflate() for file i/o applications, in that it avoids copying between the
   output and the sliding window by simply making the window itself the output
   buffer.  inflate() can be faster on modern CPUs when used with large
   buffers.  inflateBack() trusts the application to not change the output
   buffer passed by the output function, at least until inflateBack() returns.

     inflateBackInit() must be called first to allocate the internal state
   and to initialize the state with the user-provided window buffer.
   inflateBack() may then be used multiple times to inflate a complete, raw
   deflate stream with each call.  inflateBackEnd() is then called to free the
   allocated state.

     A raw deflate stream is one with no zlib or gzip header or trailer.
   This routine would normally be used in a utility that reads zip or gzip
   files and writes out uncompressed files.  The utility would decode the
   header and process the trailer on its own, hence this routine expects only
   the raw deflate stream to decompress.  This is different from the normal
   behavior of inflate(), which expects either a zlib or gzip header and
   trailer around the deflate stream.

     inflateBack() uses two subroutines supplied by the caller that are then
   called by inflateBack() for input and output.  inflateBack() calls those
   routines until it reads a complete deflate stream and writes out all of the
   uncompressed data, or until it encounters an error.  The function's
   parameters and return types are defined above in the in_func and out_func
   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   number of bytes of provided input, and a pointer to that input in buf.  If
   there is no input available, in() must return zero--buf is ignored in that
   case--and inflateBack() will return a buffer error.  inflateBack() will call
   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
   should return zero on success, or non-zero on failure.  If out() returns
   non-zero, inflateBack() will return with an error.  Neither in() nor out()
   are permitted to change the contents of the window provided to
   inflateBackInit(), which is also the buffer that out() uses to write from.
   The length written by out() will be at most the window size.  Any non-zero
   amount of input may be provided by in().

     For convenience, inflateBack() can be provided input on the first call by
   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   in() will be called.  Therefore strm->next_in must be initialized before
   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   must also be initialized, and then if strm->avail_in is not zero, input will
   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].

     The in_desc and out_desc parameters of inflateBack() is passed as the
   first parameter of in() and out() respectively when they are called.  These
   descriptors can be optionally used to pass any information that the caller-
   supplied in() and out() functions need to do their job.

     On return, inflateBack() will set strm->next_in and strm->avail_in to
   pass back any unused input that was provided by the last in() call.  The
   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
   in the deflate stream (in which case strm->msg is set to indicate the nature
   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
   In the case of Z_BUF_ERROR, an input or output error can be distinguished
   using strm->next_in which will be Z_NULL only if in() returned an error.  If
   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
   non-zero.  (in() will always be called before out(), so strm->next_in is
   assured to be defined if out() returns non-zero.) Note that inflateBack()
   cannot return Z_OK.
*/

ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
/*
     All memory allocated by inflateBackInit() is freed.

     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   state was inconsistent.
*/

ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
/* Return flags indicating compile-time options.

    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
     1.0: size of uInt
     3.2: size of uLong
     5.4: size of voidpf (pointer)
     7.6: size of z_off_t

    Compiler, assembler, and debug options:
     8: DEBUG
     9: ASMV or ASMINF -- use ASM code
     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
     11: 0 (reserved)

    One-time table building (smaller code, but not thread-safe if true):
     12: BUILDFIXED -- build static block decoding tables when needed
     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
     14,15: 0 (reserved)

    Library content (indicates missing functionality):
     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
                          deflate code when not needed)
     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
                    and decode gzip streams (to avoid linking crc code)
     18-19: 0 (reserved)

    Operation variations (changes in library functionality):
     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
     21: FASTEST -- deflate algorithm with only one, lowest compression level
     22,23: 0 (reserved)

    The sprintf variant used by gzprintf (zero is best):
     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
     26: 0 = returns value, 1 = void -- 1 means inferred string length returned

    Remainder:
     27-31: 0 (reserved)
 */

#ifndef Z_SOLO

                        /* utility functions */

/*
     The following utility functions are implemented on top of the basic
   stream-oriented functions.  To simplify the interface, some default options
   are assumed (compression level and memory usage, standard memory allocation
   functions).  The source code of these utility functions can be modified if
   you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed buffer.

     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer.  The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer.  Upon entry, destLen is the total size of the
   destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
/*
     compressBound() returns an upper bound on the compressed size after
   compress() or compress2() on sourceLen bytes.  It would be used before a
   compress() or compress2() call to allocate the destination buffer.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be large enough to hold the entire
   uncompressed data.  (The size of the uncompressed data must have been saved
   previously by the compressor and transmitted to the decompressor by some
   mechanism outside the scope of this compression library.) Upon exit, destLen
   is the actual size of the uncompressed buffer.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
   the case where there is not enough room, uncompress() will fill the output
   buffer with the uncompressed data up to that point.
*/

                        /* gzip file access functions */

/*
     This library supports reading and writing files in gzip (.gz) format with
   an interface similar to that of stdio, using the functions that start with
   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
   wrapper, documented in RFC 1952, wrapped around a deflate stream.
*/

typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */

/*
ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));

     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
   for fixed code compression as in "wb9F".  (See the description of
   deflateInit2 for more information about the strategy parameter.)  'T' will
   request transparent writing or appending with no compression and not using
   the gzip format.

     "a" can be used instead of "w" to request that the gzip stream that will
   be written be appended to the file.  "+" will result in an error, since
   reading and writing to the same gzip file is not supported.  The addition of
   "x" when writing will create the file exclusively, which fails if the file
   already exists.  On systems that support it, the addition of "e" when
   reading or writing will set the flag to close the file on an execve() call.

     These functions, as well as gzip, will read and decode a sequence of gzip
   streams in a file.  The append function of gzopen() can be used to create
   such a file.  (Also see gzflush() for another way to do this.)  When
   appending, gzopen does not test whether the file begins with a gzip stream,
   nor does it look for the end of the gzip streams to begin appending.  gzopen
   will simply append a gzip stream to the existing file.

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.  When
   reading, this will be detected automatically by looking for the magic two-
   byte gzip header.

     gzopen returns NULL if the file could not be opened, if there was
   insufficient memory to allocate the gzFile state, or if an invalid mode was
   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
   errno can be checked to determine if the reason gzopen failed was that the
   file could not be opened.
*/

ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
/*
     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
   are obtained from calls like open, dup, creat, pipe or fileno (if the file
   has been previously opened with fopen).  The mode parameter is as in gzopen.

     The next call of gzclose on the returned gzFile will also close the file
   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
   mode);.  The duplicated descriptor should be saved to avoid a leak, since
   gzdopen does not close fd if it fails.  If you are using fileno() to get the
   file descriptor from a FILE *, then you will have to use dup() to avoid
   double-close()ing the file descriptor.  Both gzclose() and fclose() will
   close the associated file descriptor, so they need to have different file
   descriptors.

     gzdopen returns NULL if there was insufficient memory to allocate the
   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
   used until the next gz* read, write, seek, or close operation, so gzdopen
   will not detect if fd is invalid (unless fd is -1).
*/

ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
/*
     Set the internal buffer size used by this library's functions.  The
   default buffer size is 8192 bytes.  This function must be called after
   gzopen() or gzdopen(), and before any other calls that read or write the
   file.  The buffer memory allocation is always deferred to the first read or
   write.  Two buffers are allocated, either both of the specified size when
   writing, or one of the specified size and the other twice that size when
   reading.  A larger buffer size of, for example, 64K or 128K bytes will
   noticeably increase the speed of decompression (reading).

     The new buffer size also affects the maximum length for gzprintf().

     gzbuffer() returns 0 on success, or -1 on failure, such as being called
   too late.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy.  See the description
   of deflateInit2 for the meaning of these parameters.

     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.  If
   the input file is not in gzip format, gzread copies the given number of
   bytes into the buffer directly from the file.

     After reaching the end of a gzip stream in the input, gzread will continue
   to read, looking for another gzip stream.  Any number of gzip streams may be
   concatenated in the input file, and will all be decompressed by gzread().
   If something other than a gzip stream is encountered after a gzip stream,
   that remaining trailing garbage is ignored (and no error is returned).

     gzread can be used to read a gzip file that is being concurrently written.
   Upon reaching the end of the input, gzread will return with the available
   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
   gzclearerr can be used to clear the end of file indicator in order to permit
   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
   middle of a gzip stream.  Note that gzread does not return -1 in the event
   of an incomplete gzip stream.  This error is deferred until gzclose(), which
   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
   stream.  Alternatively, gzerror can be used before gzclose to detect this
   case.

     gzread returns the number of uncompressed bytes actually read, less than
   len for end of file, or -1 for error.
*/

ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
                                voidpc buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes written or 0 in case of
   error.
*/

ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the arguments to the compressed file under
   control of the format string, as in fprintf.  gzprintf returns the number of
   uncompressed bytes actually written, or 0 in case of error.  The number of
   uncompressed bytes written is limited to 8191, or one less than the buffer
   size given to gzbuffer().  The caller should assure that this limit is not
   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
   nothing written.  In this case, there may also be a buffer overflow with
   unpredictable consequences, which is possible only if zlib was compiled with
   the insecure functions sprintf() or vsprintf() because the secure snprintf()
   or vsnprintf() functions were not available.  This can be determined using
   zlibCompileFlags().
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
     Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.

     gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
     Reads bytes from the compressed file until len-1 characters are read, or a
   newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  If any characters are read or if len == 1, the
   string is terminated with a null character.  If no characters are read due
   to an end-of-file or len < 1, then the buffer is left untouched.

     gzgets returns buf which is a null-terminated string, or it returns NULL
   for end-of-file or in case of error.  If there was an error, the contents at
   buf are indeterminate.
*/

ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
/*
     Writes c, converted to an unsigned char, into the compressed file.  gzputc
   returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
/*
     Reads one byte from the compressed file.  gzgetc returns this byte or -1
   in case of end of file or error.  This is implemented as a macro for speed.
   As such, it does not do all of the checking the other functions do.  I.e.
   it does not check to see if file is NULL, nor whether the structure file
   points to has been clobbered or not.
*/

ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
/*
     Push one character back onto the stream to be read as the first character
   on the next read.  At least one character of push-back is allowed.
   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
   fail if c is -1, and may fail if a character has been pushed but not read
   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
   The pushed character will be discarded if the stream is repositioned with
   gzseek() or gzrewind().
*/

ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file.  The parameter flush
   is as in the deflate() function.  The return value is the zlib error number
   (see function gzerror below).  gzflush is only permitted when writing.

     If the flush parameter is Z_FINISH, the remaining data is written and the
   gzip stream is completed in the output.  If gzwrite() is called again, a new
   gzip stream will be started in the output.  gzread() is able to read such
   concatented gzip streams.

     gzflush should be called only when strictly necessary because it will
   degrade compression if called too often.
*/

/*
ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
                                   z_off_t offset, int whence));

     Sets the starting position for the next gzread or gzwrite on the given
   compressed file.  The offset represents a number of bytes in the
   uncompressed data stream.  The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.

     If the file is opened for reading, this function is emulated but can be
   extremely slow.  If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

     gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

/*
ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));

     Returns the starting position for the next gzread or gzwrite on the given
   compressed file.  This position represents a number of bytes in the
   uncompressed data stream, and is zero when starting, even if appending or
   reading a gzip stream from the middle of a file using gzdopen().

     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

/*
ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));

     Returns the current offset in the file being read or written.  This offset
   includes the count of bytes that precede the gzip stream, for example when
   appending or when using gzdopen() for reading.  When reading, the offset
   does not include as yet unused buffered input.  This information can be used
   for a progress indicator.  On error, gzoffset() returns -1.
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns true (1) if the end-of-file indicator has been set while reading,
   false (0) otherwise.  Note that the end-of-file indicator is set only if the
   read tried to go past the end of the input, but came up short.  Therefore,
   just like feof(), gzeof() may return false even if there is no more data to
   read, in the event that the last read request was for the exact number of
   bytes remaining in the input file.  This will happen if the input file size
   is an exact multiple of the buffer size.

     If gzeof() returns true, then the read functions will return no more data,
   unless the end-of-file indicator is reset by gzclearerr() and the input file
   has grown since the previous end of file was detected.
*/

ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
/*
     Returns true (1) if file is being copied directly while reading, or false
   (0) if file is a gzip stream being decompressed.

     If the input file is empty, gzdirect() will return true, since the input
   does not contain a gzip stream.

     If gzdirect() is used immediately after gzopen() or gzdopen() it will
   cause buffers to be allocated to allow reading the file to determine if it
   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
   gzdirect().

     When writing, gzdirect() returns true (1) if transparent writing was
   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
   gzdirect() is not needed when writing.  Transparent writing must be
   explicitly requested, so the application already knows the answer.  When
   linking statically, using gzdirect() will include all of the zlib code for
   gzip file reading and decompression, which may not be desired.)
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file and
   deallocates the (de)compression state.  Note that once file is closed, you
   cannot call gzerror with file, since its structures have been deallocated.
   gzclose must not be called more than once on the same file, just as free
   must not be called more than once on the same allocation.

     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
   last read ended in the middle of a gzip stream, or Z_OK on success.
*/

ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
/*
     Same as gzclose(), but gzclose_r() is only for use when reading, and
   gzclose_w() is only for use when writing or appending.  The advantage to
   using these instead of gzclose() is that they avoid linking in zlib
   compression or decompression code that is not used when only reading or only
   writing respectively.  If gzclose() is used, then both compression and
   decompression code will be included the application when linking to a static
   zlib library.
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the given
   compressed file.  errnum is set to zlib error number.  If an error occurred
   in the file system and not in the compression library, errnum is set to
   Z_ERRNO and the application may consult errno to get the exact error code.

     The application must not modify the returned string.  Future calls to
   this function may invalidate the previously returned string.  If file is
   closed, then the string previously returned by gzerror will no longer be
   available.

     gzerror() should be used to distinguish errors from end-of-file for those
   functions above that do not distinguish those cases in their return values.
*/

ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
/*
     Clears the error and end-of-file flags for file.  This is analogous to the
   clearerr() function in stdio.  This is useful for continuing to read a gzip
   file that is being written concurrently.
*/

#endif /* !Z_SOLO */

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the compression
   library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum.  If buf is Z_NULL, this function returns the
   required initial value for the checksum.

     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster.

   Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

/*
ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
                                          z_off_t len2));

     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
   that the z_off_t type (like off_t) is a signed integer.  If len2 is
   negative, the result has no meaning or utility.
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running CRC-32 with the bytes buf[0..len-1] and return the
   updated CRC-32.  If buf is Z_NULL, this function returns the required
   initial value for the crc.  Pre- and post-conditioning (one's complement) is
   performed within this function so it shouldn't be done by the application.

   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/

/*
ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));

     Combine two CRC-32 check values into one.  For two sequences of bytes,
   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
   len2.
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
                                         unsigned char FAR *window,
                                         const char *version,
                                         int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
                      (int)sizeof(z_stream))
#define inflateBackInit(strm, windowBits, window) \
        inflateBackInit_((strm), (windowBits), (window), \
                      ZLIB_VERSION, (int)sizeof(z_stream))

#ifndef Z_SOLO

/* gzgetc() macro and its supporting function and exposed data structure.  Note
 * that the real internal state is much larger than the exposed structure.
 * This abbreviated structure exposes just enough for the gzgetc() macro.  The
 * user should not mess with these exposed elements, since their names or
 * behavior could change in the future, perhaps even capriciously.  They can
 * only be used by the gzgetc() macro.  You have been warned.
 */
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    z_off64_t pos;
};
ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#  define z_gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
#else
#  define gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
#endif

/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
 * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
 * both are true, the application gets the *64 functions, and the regular
 * functions are changed to 64 bits) -- in case these are set on systems
 * without large file support, _LFS64_LARGEFILE must also be true
 */
#ifdef Z_LARGE64
   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
#endif

#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
#  ifdef Z_PREFIX_SET
#    define z_gzopen z_gzopen64
#    define z_gzseek z_gzseek64
#    define z_gztell z_gztell64
#    define z_gzoffset z_gzoffset64
#    define z_adler32_combine z_adler32_combine64
#    define z_crc32_combine z_crc32_combine64
#  else
#    define gzopen gzopen64
#    define gzseek gzseek64
#    define gztell gztell64
#    define gzoffset gzoffset64
#    define adler32_combine adler32_combine64
#    define crc32_combine crc32_combine64
#  endif
#  ifndef Z_LARGE64
     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#  endif
#else
   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
#endif

#else /* Z_SOLO */

   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));

#endif /* !Z_SOLO */

/* hack for buggy compilers */
#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;};
#endif

/* undocumented functions */
ZEXTERN const char   * ZEXPORT zError           OF((int));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
#if defined(_WIN32) && !defined(Z_SOLO)
ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
                                            const char *mode));
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
                                                  const char *format,
                                                  va_list va));
#  endif
#endif

#ifdef __cplusplus
}
#endif

#endif /* ZLIB_H */



================================================
File: src/zlib/zutil.c
================================================
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2005, 2010, 2011, 2012 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#include "zutil.h"
#ifndef Z_SOLO
#  include "gzguts.h"
#endif

#ifndef NO_DUMMY_DECL
struct internal_state      {int dummy;}; /* for buggy compilers */
#endif

z_const char * const z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

uLong ZEXPORT zlibCompileFlags()
{
    uLong flags;

    flags = 0;
    switch ((int)(sizeof(uInt))) {
    case 2:     break;
    case 4:     flags += 1;     break;
    case 8:     flags += 2;     break;
    default:    flags += 3;
    }
    switch ((int)(sizeof(uLong))) {
    case 2:     break;
    case 4:     flags += 1 << 2;        break;
    case 8:     flags += 2 << 2;        break;
    default:    flags += 3 << 2;
    }
    switch ((int)(sizeof(voidpf))) {
    case 2:     break;
    case 4:     flags += 1 << 4;        break;
    case 8:     flags += 2 << 4;        break;
    default:    flags += 3 << 4;
    }
    switch ((int)(sizeof(z_off_t))) {
    case 2:     break;
    case 4:     flags += 1 << 6;        break;
    case 8:     flags += 2 << 6;        break;
    default:    flags += 3 << 6;
    }
#ifdef DEBUG
    flags += 1 << 8;
#endif
#if defined(ASMV) || defined(ASMINF)
    flags += 1 << 9;
#endif
#ifdef ZLIB_WINAPI
    flags += 1 << 10;
#endif
#ifdef BUILDFIXED
    flags += 1 << 12;
#endif
#ifdef DYNAMIC_CRC_TABLE
    flags += 1 << 13;
#endif
#ifdef NO_GZCOMPRESS
    flags += 1L << 16;
#endif
#ifdef NO_GZIP
    flags += 1L << 17;
#endif
#ifdef PKZIP_BUG_WORKAROUND
    flags += 1L << 20;
#endif
#ifdef FASTEST
    flags += 1L << 21;
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifdef NO_vsnprintf
    flags += 1L << 25;
#    ifdef HAS_vsprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_vsnprintf_void
    flags += 1L << 26;
#    endif
#  endif
#else
    flags += 1L << 24;
#  ifdef NO_snprintf
    flags += 1L << 25;
#    ifdef HAS_sprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_snprintf_void
    flags += 1L << 26;
#    endif
#  endif
#endif
    return flags;
}

#ifdef DEBUG

#  ifndef verbose
#    define verbose 0
#  endif
int ZLIB_INTERNAL z_verbose = verbose;

void ZLIB_INTERNAL z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError(err)
    int err;
{
    return ERR_MSG(err);
}

#if defined(_WIN32_WCE)
    /* The Microsoft C Run-Time Library for Windows CE doesn't have
     * errno.  We define it as a global variable to simplify porting.
     * Its value is always 0 and should not be used.
     */
    int errno = 0;
#endif

#ifndef HAVE_MEMCPY

void ZLIB_INTERNAL zmemcpy(dest, source, len)
    Bytef* dest;
    const Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int ZLIB_INTERNAL zmemcmp(s1, s2, len)
    const Bytef* s1;
    const Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void ZLIB_INTERNAL zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifndef Z_SOLO

#ifdef SYS16BIT

#ifdef __TURBOC__
/* Turbo C in 16-bit mode */

#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}

#endif /* __TURBOC__ */


#ifdef M_I86
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* M_I86 */

#endif /* SYS16BIT */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  malloc OF((uInt size));
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    if (opaque) items += size - size; /* make compiler happy */
    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
                              (voidpf)calloc(items, size);
}

void ZLIB_INTERNAL zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */

#endif /* !Z_SOLO */



================================================
File: src/zlib/zutil.h
================================================
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2013 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef ZUTIL_H
#define ZUTIL_H

#ifdef HAVE_HIDDEN
#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
#else
#  define ZLIB_INTERNAL
#endif

#include "zlib.h"
#include <stdint.h>

#if defined(STDC) && !defined(Z_SOLO)
#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
#    include <stddef.h>
#  endif
#  include <string.h>
#  include <stdlib.h>
#endif

#ifdef Z_SOLO
   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
#  define OS_CODE  0x00
#  ifndef Z_SOLO
#    if defined(__TURBOC__) || defined(__BORLANDC__)
#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
         /* Allow compilation with ANSI keywords only enabled */
         void _Cdecl farfree( void *block );
         void *_Cdecl farmalloc( unsigned long nbytes );
#      else
#        include <alloc.h>
#      endif
#    else /* MSC or DJGPP */
#      include <malloc.h>
#    endif
#  endif
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#ifdef OS2
#  define OS_CODE  0x06
#  if defined(M_I86) && !defined(Z_SOLO)
#    include <malloc.h>
#  endif
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  ifndef Z_SOLO
#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#      include <unix.h> /* for fdopen */
#    else
#      ifndef fdopen
#        define fdopen(fd,mode) NULL /* No fdopen() */
#      endif
#    endif
#  endif
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#ifdef WIN32
#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
#    define OS_CODE  0x0b
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0f
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
#  if defined(_WIN32_WCE)
#    define fdopen(fd,mode) NULL /* No fdopen() */
#    ifndef _PTRDIFF_T_DEFINED
       typedef int ptrdiff_t;
#      define _PTRDIFF_T_DEFINED
#    endif
#  else
#    define fdopen(fd,type)  _fdopen(fd,type)
#  endif
#endif

#if defined(__BORLANDC__) && !defined(MSDOS)
  #pragma warn -8004
  #pragma warn -8008
  #pragma warn -8066
#endif

/* provide prototypes for these when building zlib without LFS */
#if !defined(_WIN32) && \
    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#endif

        /* common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#if defined(pyr) || defined(Z_SOLO)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int ZLIB_INTERNAL z_verbose;
   extern void ZLIB_INTERNAL z_error OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif

#ifndef Z_SOLO
   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
                                    unsigned size));
   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
#endif

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

/* Reverse the bytes in a 32-bit value */
#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))

#endif /* ZUTIL_H */



Directory structure:
└── mooncat-greenpy-x64dbg_golanganalyzerplugin/
    ├── README.md
    ├── LICENSE
    ├── x64dbg_GolangAnalyzerPlugin.sln
    └── x64dbg_GolangAnalyzerPlugin/
        ├── golang_analyzer.cpp
        ├── golang_analyzer.h
        ├── golang_function.cpp
        ├── golang_function.h
        ├── gopclntab.cpp
        ├── gopclntab.h
        ├── menu.cpp
        ├── menu.h
        ├── util.cpp
        ├── util.h
        ├── x64dbg_GolangAnalyzerPlugin.cpp
        ├── x64dbg_GolangAnalyzerPlugin.h
        ├── x64dbg_GolangAnalyzerPlugin.vcxproj
        └── x64dbg_GolangAnalyzerPlugin.vcxproj.filters

================================================
File: README.md
================================================
# GolangAnalyzerPlugin
GolangAnalyzer helps you analyze Golang binaries.

## Features
- Add functions
- Add source file and line number information to comments

## Usage
1. Download the release
2. Copy x64dbg_GolangAnalyzerPlugin.dp32/x64dbg_GolangAnalyzerPlugin.dp64 files to plugins directories of x64dbg
3. Start debugging
4. `GoAnalyzer.line.enable`
5. `GoAnalyzer.analyze`

### Commands
- `GoAnalyzer.analyze`: Run analysis
- `GoAnalyzer.line.enable`: Enable the ability to comment source file and line number information
- `GoAnalyzer.line.enable`: Disable the ability to comment source file and line number information



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2021 mooncat-greenpy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: x64dbg_GolangAnalyzerPlugin.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30711.63
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "x64dbg_GolangAnalyzerPlugin", "x64dbg_GolangAnalyzerPlugin\x64dbg_GolangAnalyzerPlugin.vcxproj", "{34D49BFD-EB2D-429D-A0CD-55451DC6474E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Debug|x64.ActiveCfg = Debug|x64
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Debug|x64.Build.0 = Debug|x64
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Debug|x86.ActiveCfg = Debug|Win32
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Debug|x86.Build.0 = Debug|Win32
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Release|x64.ActiveCfg = Release|x64
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Release|x64.Build.0 = Release|x64
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Release|x86.ActiveCfg = Release|Win32
		{34D49BFD-EB2D-429D-A0CD-55451DC6474E}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7368E1F0-8D08-42B2-B024-2563B185697A}
	EndGlobalSection
EndGlobal



================================================
File: x64dbg_GolangAnalyzerPlugin/golang_analyzer.cpp
================================================
#include "golang_analyzer.h"
#include "golang_function.h"


duint get_go_routine_id(const GOPCLNTAB& gopclntab, bool* result)
{
    if (gopclntab.pointer_size == 4)
    {
        return DbgEval("[[fs:[0x14]]+0x50]", result);
    }
    else if(gopclntab.pointer_size == 8)
    {
        duint sp = DbgEval("rsp", result);
        if (!result)
        {
            return false;
        }
        bool lo_result = false;
        bool hi_result = false;
        if (gopclntab.version < GO_VERSION::GO_118)// < GO_117
        {
            duint lo = DbgEval("[[gs:[0x28]]+0x0]", &lo_result);
            duint hi = DbgEval("[[gs:[0x28]]+0x8]", &hi_result);
            if (lo <= sp && sp < hi)
            {
                return DbgEval("[[gs:[0x28]]+0x98]", result);
            }
        }
        if (gopclntab.version > GO_VERSION::GO_116)//  >= GO_117
        {
            duint lo = DbgEval("[r14+0x0]", &lo_result);
            duint hi = DbgEval("[r14+0x8]", &hi_result);
            if (lo <= sp && sp < hi)
            {
                return DbgEval("[r14+0x98]", result);
            }
        }
        *result = false;
        return 0;
    }
    else
    {
        *result = false;
        return 0;
    }
}


void print_call_stack(const std::vector<GoFunc>& go_func_list, duint pc, duint sp)
{
    bool result = false;
    for (int i = 0; i < 0x20; i++)
    {
        GoFunc go_func = {};
        if (!get_target_function(go_func_list, pc, &go_func))
        {
            return;
        }
        duint stack_size = 0;
        if (!get_target_stack_size(go_func, pc, &stack_size))
        {
            return;
        }
        sp += stack_size;
        char query[MAX_PATH] = {};
        _snprintf_s(query, sizeof(query), MAX_PATH, "[%p]", (void*)sp);
        duint ret_addr = DbgEval(query, &result);
        if (!result)
        {
            return;
        }
        goanalyzer_logprintf("Golang Analyzer: name=%s ip=%p sp=%s ret=%p\n", go_func.name.c_str(), pc, query, ret_addr);

        pc = ret_addr;
        sp += sizeof(duint);
    }
}


bool analyze_command()
{
    GOPCLNTAB gopclntab = {};
    if (!get_gopclntab(&gopclntab))
    {
        goanalyzer_logputs("Golang Analyzer: Failed to get gopclntab");
        return false;
    }
    std::vector<GoFunc> go_func_list;
    if (!analyze_functions(gopclntab, &go_func_list, get_line_enabled()))
    {
        goanalyzer_logputs("Golang Analyzer: Failed to analyze functions");
        return false;
    }
    set_functions_info(go_func_list);
    if (!analyze_datatypes(&gopclntab))
    {
        goanalyzer_logputs("Golang Analyzer: Failed to analyze datatypes");
        return false;
    }
    goanalyzer_logputs("Golang Analyzer: Analyze");
    return true;
}

bool gid_command()
{
    GOPCLNTAB gopclntab = {};
    if (!get_gopclntab(&gopclntab))
    {
        goanalyzer_logputs("Golang Analyzer: Failed to get gopclntab");
        return false;
    }

    bool result = false;
    duint gid = get_go_routine_id(gopclntab, &result);
    if (result)
    {
        goanalyzer_logprintf("Golang Analyzer: gid = %p\n", gid);
    }
    else
    {
        goanalyzer_logprintf("Golang Analyzer: Failed to get gid\n");
    }
    return result;
}

bool callstack_command(duint ip, duint sp)
{
    GOPCLNTAB gopclntab_base = {};
    if (!get_gopclntab(&gopclntab_base))
    {
        goanalyzer_logputs("Golang Analyzer: Failed to get gopclntab");
        return false;
    }
    std::vector<GoFunc> go_func_list;
    if (!analyze_functions(gopclntab_base, &go_func_list, false))
    {
        goanalyzer_logputs("Golang Analyzer: Failed to analyze functions");
        return false;
    }

    print_call_stack(go_func_list, ip, sp);
    return true;
}

bool command_callback(int argc, char* argv[])
{
    if (argc < 1)
    {
        return false;
    }

    if (strstr(argv[0], "help"))
    {
        goanalyzer_logputs("Golang Analyzer: Help\n"
            "Command:\n"
            "    GoAnalyzer.help\n"
            "    GoAnalyzer.analyze\n"
            "    GoAnalyzer.line.enable\n"
            "    GoAnalyzer.line.disable\n"
            "    GoAnalyzer.gid\n"
            "    GoAnalyzer.callstack [ip, sp]");
    }
    else if (strstr(argv[0], "analyze"))
    {
        return analyze_command();
    }
    else if (strstr(argv[0], "line.enable"))
    {
        set_line_enabled(true);
        goanalyzer_logputs("Golang Analyzer: Enabled");
    }
    else if (strstr(argv[0], "line.disable"))
    {
        set_line_enabled(false);
        goanalyzer_logputs("Golang Analyzer: Disabled");
    }
    else if (strstr(argv[0], "gid"))
    {
        return gid_command();
    }
    else if (strstr(argv[0], "callstack"))
    {
        bool result = false;
        duint ip = 0;
        duint sp = 0;
        if (argc > 2)
        {
            ip = DbgEval(argv[1], &result);
        }
        else
        {
            ip = DbgEval("cip", &result);
        }
        if (!result)
        {
            goanalyzer_logputs("Golang Analyzer: Failed to get ip");
            return false;
        }
        if (argc > 2)
        {
            sp = DbgEval(argv[2], &result);
        }
        else
        {
            sp = DbgEval("csp", &result);
        }
        if (!result)
        {
            goanalyzer_logputs("Golang Analyzer: Failed to get sp");
            return false;
        }
        goanalyzer_logprintf("Golang Analyzer: ip = %p, sp = %p\n", ip, sp);

        return callstack_command(ip, sp);
    }

    return true;
}


bool init_analyzer_plugin()
{
    _plugin_registercommand(pluginHandle, "GoAnalyzer.help", command_callback, false);
    _plugin_registercommand(pluginHandle, "GoAnalyzer.analyze", command_callback, false);
    _plugin_registercommand(pluginHandle, "GoAnalyzer.line.enable", command_callback, false);
    _plugin_registercommand(pluginHandle, "GoAnalyzer.line.disable", command_callback, false);
    _plugin_registercommand(pluginHandle, "GoAnalyzer.gid", command_callback, false);
    _plugin_registercommand(pluginHandle, "GoAnalyzer.callstack", command_callback, false);

    return true;
}


bool stop_analyzer_plugin()
{
    _plugin_unregistercommand(pluginHandle, "GoAnalyzer.help");
    _plugin_unregistercommand(pluginHandle, "GoAnalyzer.analyze");
    _plugin_unregistercommand(pluginHandle, "GoAnalyzer.line.enable");
    _plugin_unregistercommand(pluginHandle, "GoAnalyzer.line.disable");
    _plugin_unregistercommand(pluginHandle, "GoAnalyzer.gid");
    _plugin_unregistercommand(pluginHandle, "GoAnalyzer.callstack");

    return true;
}


void setup_analyzer_plugin()
{
}



================================================
File: x64dbg_GolangAnalyzerPlugin/golang_analyzer.h
================================================
#pragma once

#include "x64dbg_GolangAnalyzerPlugin.h"


bool init_analyzer_plugin();
bool stop_analyzer_plugin();
void setup_analyzer_plugin();



================================================
File: x64dbg_GolangAnalyzerPlugin/golang_function.cpp
================================================
#include "golang_function.h"


uint32_t read_pc_data(duint addr, uint32_t* i)
{
    if (!DbgMemIsValidReadPtr(addr)) {
        return 0;
    }
    uint32_t value = 0;
    for (uint32_t shift = 0;; shift += 7) {
        uint32_t tmp = 0;
        if (!read_dbg_memory(addr + (*i)++, &tmp, 1))
        {
            tmp = 0;
        }
        value |= (tmp & 0x7f) << shift;
        if ((tmp & 0x80) == 0) {
            break;
        }
    }
    return value;
}

int32_t zig_zag_decode(uint32_t value)
{
    if ((value & 1) != 0) {
        value = (value >> 1) + 1;
        return value * -1;
    }
    else {
        return value >> 1;
    }
}

bool pc_to_file_name(const GOPCLNTAB& gopclntab, duint func_info_addr, uint64_t target_pc_offset, char* file_name, size_t file_name_size)
{
    duint functab_field_size = gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120 ? 4 : gopclntab.pointer_size;

    uint32_t pcfile_offset = 0;
    read_dbg_memory(func_info_addr + functab_field_size + 4 * 4, &pcfile_offset, 4);
    duint pcfile_base = gopclntab.addr + pcfile_offset;
    if (gopclntab.version == GO_VERSION::GO_116 || gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120)
    {
        uint64_t tmp_value = 0;
        if (!read_dbg_memory(gopclntab.addr + 8 + gopclntab.pointer_size * (gopclntab.version == GO_VERSION::GO_116 ? 5 : 6), &tmp_value, gopclntab.pointer_size))
        {
            return false;
        }
        pcfile_base = gopclntab.addr + (duint)tmp_value + pcfile_offset;
    }

    int64_t file_no = -1;
    uint32_t i = 0;
    boolean first = true;
    uint64_t pc_offset = 0;
    while (true)
    {
        uint32_t decoded_file_no_add = read_pc_data(pcfile_base, &i);
        uint32_t byte_size = read_pc_data(pcfile_base, &i);
        if (decoded_file_no_add == 0 && !first) {
            break;
        }
        first = false;
        int32_t file_no_add = zig_zag_decode(decoded_file_no_add);
        file_no += file_no_add;
        pc_offset += (uint64_t)byte_size * gopclntab.quantum;

        if (target_pc_offset <= pc_offset)
        {
            if (gopclntab.version == GO_VERSION::GO_116 || gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120)
            {
                uint32_t cu_offset = 0;
                if (!read_dbg_memory(func_info_addr + functab_field_size + 4 * 7, &cu_offset, 4))
                {
                    return false;
                }
                uint64_t tmp_value = 0;
                if (!read_dbg_memory(gopclntab.addr + 8 + gopclntab.pointer_size * (gopclntab.version == GO_VERSION::GO_116 ? 3 : 4), &tmp_value, gopclntab.pointer_size))
                {
                    return false;
                }
                duint cutab_base = gopclntab.addr + (duint)tmp_value;
                uint32_t file_no_offset = 0;
                if (!read_dbg_memory(cutab_base + (cu_offset + (duint)file_no) * 4, &file_no_offset, 4))
                {
                    return false;
                }
                if (!read_dbg_memory(gopclntab.addr + 8 + gopclntab.pointer_size * (gopclntab.version == GO_VERSION::GO_116 ? 4 : 5), &tmp_value, gopclntab.pointer_size))
                {
                    return false;
                }
                duint file_name_addr = gopclntab.addr + (duint)tmp_value + file_no_offset;
                char tmp_file_name[MAX_PATH] = {};
                if (!read_dbg_memory(file_name_addr, tmp_file_name, sizeof(tmp_file_name)))
                {
                    return false;
                }
                strncpy_s(file_name, file_name_size, tmp_file_name, _TRUNCATE);
                return true;
            }
            if (file_no - 1 < 0 || gopclntab.file_name_list.size() <= (size_t)file_no - 1)
            {
                goanalyzer_logprintf("Error file name list index out of range: %d\n", file_no - 1);
                return false;
            }
            strncpy_s(file_name, file_name_size, gopclntab.file_name_list.at((size_t)file_no - 1).c_str(), _TRUNCATE);
            return true;
        }
    }
    return false;
}

std::map<uint64_t, std::string> init_file_line_map(const GOPCLNTAB& gopclntab, duint func_info_addr, uint64_t* func_size)
{
    std::map<uint64_t, std::string> file_line_comment_map;
    file_line_comment_map.clear();

    duint functab_field_size = gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120 ? 4 : gopclntab.pointer_size;
    uint32_t pcln_offset = 0;
    read_dbg_memory(func_info_addr + functab_field_size + 5 * 4, &pcln_offset, 4);
    duint pcln_base;
    if (gopclntab.version == GO_VERSION::GO_116 || gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120)
    {
        uint64_t tmp_value = 0;
        if (!read_dbg_memory(gopclntab.addr + 8 + (uint32_t)gopclntab.pointer_size * (gopclntab.version == GO_VERSION::GO_116 ? 5 : 6), &tmp_value, gopclntab.pointer_size))
        {
            return file_line_comment_map;
        }
        pcln_base = gopclntab.addr + (duint)tmp_value + pcln_offset;
    }
    else
    {
        pcln_base = gopclntab.addr + pcln_offset;
    }

    int64_t line_num = -1;
    uint32_t i = 0;
    bool first = true;
    uint64_t pc_offset = 0;
    while (true) {
        uint32_t decoded_line_num_add = read_pc_data(pcln_base, &i);
        uint32_t byte_size = read_pc_data(pcln_base, &i);
        if (decoded_line_num_add == 0 && !first)
        {
            break;
        }

        first = false;
        uint64_t key = pc_offset;
        int32_t line_num_add = zig_zag_decode(decoded_line_num_add);
        line_num += line_num_add;
        pc_offset += (uint64_t)byte_size * gopclntab.quantum;

        if (get_line_enabled())
        {
            char file_name[MAX_PATH] = "not found";
            if (!pc_to_file_name(gopclntab, func_info_addr, pc_offset, file_name, sizeof(file_name))) {
                strncpy_s(file_name, sizeof(file_name), "not found", _TRUNCATE);
            }

            char line_string[MAX_PATH] = { 0 };
            _snprintf_s(line_string, sizeof(line_string), MAX_PATH, "%s:%lld", file_name, line_num);
            file_line_comment_map[key] = line_string;
        }
    }
    *func_size = pc_offset;
    return file_line_comment_map;
}

std::map<uint64_t, uint64_t> init_sp_map(const GOPCLNTAB& gopclntab, duint func_info_addr, uint64_t* func_size)
{
    std::map<uint64_t, uint64_t> sp_comment_map;

    duint functab_field_size = gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120 ? 4 : gopclntab.pointer_size;
    uint32_t pcsp_offset = 0;
    read_dbg_memory(func_info_addr + functab_field_size + 3 * 4, &pcsp_offset, 4);
    duint pcsp_base = gopclntab.addr + pcsp_offset;
    if (gopclntab.version == GO_VERSION::GO_116 || gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120)
    {
        uint64_t tmp_value = 0;
        if (!read_dbg_memory(gopclntab.addr + 8 + gopclntab.pointer_size * (gopclntab.version == GO_VERSION::GO_116 ? 5 : 6), &tmp_value, gopclntab.pointer_size))
        {
            return sp_comment_map;
        }
        pcsp_base = gopclntab.addr + (duint)tmp_value + pcsp_offset;
    }

    int64_t sp_size = -1;
    uint32_t i = 0;
    bool first = true;
    uint64_t pc_offset = 0;
    while (true) {
        uint32_t decoded_sp_size_add = read_pc_data(pcsp_base, &i);
        uint32_t byte_size = read_pc_data(pcsp_base, &i);
        if (decoded_sp_size_add == 0 && !first)
        {
            break;
        }

        first = false;
        uint64_t key = pc_offset;
        int32_t sp_size_add = zig_zag_decode(decoded_sp_size_add);
        sp_size += sp_size_add;
        pc_offset += (uint64_t)byte_size * gopclntab.quantum;

        sp_comment_map[key] = sp_size;
    }
    *func_size = pc_offset;
    return sp_comment_map;
}

bool analyze_functions(const GOPCLNTAB& gopclntab, std::vector<GoFunc>* go_func_list, bool is_file_line_enabled)
{
    for (uint32_t i = 0; i < gopclntab.func_num; i++)
    {
        duint functab_field_size = gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120 ? 4 : gopclntab.pointer_size;

        uint64_t func_addr_value = 0;
        if (!read_dbg_memory(gopclntab.func_list_base + (duint)i * functab_field_size * 2, &func_addr_value, functab_field_size))
        {
            return false;
        }
        if (gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120)
        {
            uint64_t text_addr = 0;
            if (!read_dbg_memory(gopclntab.addr + 8 + (uint32_t)gopclntab.pointer_size * 2, &text_addr, gopclntab.pointer_size))
            {
                return false;
            }
            func_addr_value += text_addr;
        }
        uint64_t func_info_offset = 0;
        if (!read_dbg_memory(gopclntab.func_list_base + (duint)i * functab_field_size * 2 + functab_field_size, &func_info_offset, functab_field_size))
        {
            return false;
        }
        duint func_info_addr = gopclntab.addr + (duint)func_info_offset;
        if (gopclntab.version == GO_VERSION::GO_116 || gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120)
        {
            func_info_addr = gopclntab.func_list_base + (duint)func_info_offset;
        }
        uint64_t func_name_offset = 0;
        if (!read_dbg_memory(func_info_addr + functab_field_size, &func_name_offset, 4))
        {
            return false;
        }

        char func_name[MAX_PATH] = { 0 };
        duint func_name_base = gopclntab.addr;
        if (gopclntab.version == GO_VERSION::GO_116 || gopclntab.version == GO_VERSION::GO_118 || gopclntab.version == GO_VERSION::GO_120)
        {
            uint64_t tmp_value = 0;
            if (!read_dbg_memory(gopclntab.addr + 8 + (uint32_t)gopclntab.pointer_size * (gopclntab.version == GO_VERSION::GO_116 ? 2 : 3), &tmp_value, gopclntab.pointer_size))
            {
                return false;
            }
            func_name_base = gopclntab.addr + (duint)tmp_value;
        }
        if (!read_dbg_memory(func_name_base + (duint)func_name_offset, func_name, sizeof(func_name)))
        {
            return false;
        }
        func_name[sizeof(func_name) - 1] = '\0';

        uint32_t args_size = 0;
        if (!read_dbg_memory(func_info_addr + functab_field_size + 4, &args_size, 4))
        {
            return false;
        }
        if (args_size >= 0x80000000)
        {
            args_size = 0;
        }

        uint64_t func_size = 0;
        std::map<uint64_t, std::string> file_line_map;
        if (is_file_line_enabled)
        {
            file_line_map = init_file_line_map(gopclntab, func_info_addr, &func_size);
        }
        std::map<uint64_t, uint64_t> sp_map = init_sp_map(gopclntab, func_info_addr, &func_size);

        GoFunc go_func = { func_addr_value, func_size, func_name, args_size, file_line_map, sp_map };
        go_func_list->push_back(go_func);
    }
    return true;
}


void make_comment_map(const std::map<uint64_t, std::string>& file_line_map, const std::map<uint64_t, uint64_t>& sp_map, std::map<uint64_t, std::string>* comment_map)
{
    for (auto& i : file_line_map)
    {
        if (comment_map->count(i.first))
        {
            (*comment_map)[i.first] += " " + i.second;
        }
        else
        {
            (*comment_map)[i.first] = i.second;
        }
    }

    for (auto& i : sp_map)
    {
        char sp_string[MAX_PATH] = { 0 };
        _snprintf_s(sp_string, sizeof(sp_string), MAX_PATH, "sp:%#llx", i.second);
        if (comment_map->count(i.first))
        {
            (*comment_map)[i.first] += " " + std::string(sp_string);
        }
        else
        {
            (*comment_map)[i.first] = std::string(sp_string);
        }
    }
}

void set_functions_info(const std::vector<GoFunc>& go_func_list)
{
    for (auto go_func : go_func_list)
    {
        DbgSetLabelAt((duint)go_func.addr, go_func.name.c_str());
        DbgFunctionAdd((duint)go_func.addr, (duint)go_func.addr + (duint)go_func.size - 1);

        if (!get_line_enabled())
        {
            continue;
        }
        std::map<uint64_t, std::string> comment_map;
        make_comment_map(go_func.file_line_map, go_func.sp_map, &comment_map);
        if (comment_map.size() == 0)
        {
            continue;
        }
        for (auto& j : comment_map)
        {
            DbgSetCommentAt((duint)go_func.addr + (duint)j.first, j.second.c_str());
        }
        char func_comment[MAX_COMMENT_SIZE] = { 0 };
        _snprintf_s(func_comment, sizeof(func_comment), _TRUNCATE, "%s args:%d %s", go_func.name.c_str(), go_func.args_size, comment_map.at(0).c_str());
        DbgSetCommentAt((duint)go_func.addr, func_comment);
    }
}


bool get_target_function(const std::vector<GoFunc>& go_func_list, duint target_pc, GoFunc* target_func)
{
    for (auto& go_func : go_func_list)
    {
        if (go_func.addr <= target_pc && target_pc < go_func.addr + go_func.size)
        {
            *target_func = go_func;
            return true;
        }
    }
    return false;
}

bool get_target_stack_size(const GoFunc& go_func, duint target_pc, duint* target_size)
{
    if (target_pc < go_func.addr && go_func.addr + go_func.size <= target_pc)
    {
        return false;
    }
    duint stack_size = 0;
    for (auto& i : go_func.sp_map)
    {
        if (i.first > target_pc - go_func.addr)
        {
            break;
        }
        stack_size = i.second;
    }
    *target_size = stack_size;
    return true;
}



================================================
File: x64dbg_GolangAnalyzerPlugin/golang_function.h
================================================
#pragma once

#include "gopclntab.h"
#include "x64dbg_GolangAnalyzerPlugin.h"

struct GoFunc
{
    uint64_t addr;
    uint64_t size;
    std::string name;
    uint32_t args_size;
    std::map<uint64_t, std::string> file_line_map;
    std::map<uint64_t, uint64_t> sp_map;
};


bool analyze_functions(const GOPCLNTAB& gopclntab, std::vector<GoFunc>* go_func_list, bool is_file_line_enabled);
void set_functions_info(const std::vector<GoFunc>& go_func_list);
bool get_target_function(const std::vector<GoFunc>& go_func_list, duint target_pc, GoFunc* target_func);
bool get_target_stack_size(const GoFunc& go_func, duint target_pc, duint* target_size);



================================================
File: x64dbg_GolangAnalyzerPlugin/gopclntab.cpp
================================================
#include "gopclntab.h"


bool make_gopclntab(duint target_addr, GO_VERSION version, GOPCLNTAB* gopclntab)
{
    gopclntab->version = version;

    uint8_t* tmp_gopclntab_base = (uint8_t*)target_addr;
    if (!read_dbg_memory((duint)tmp_gopclntab_base, gopclntab, 8))
    {
        return false;
    }

    if ((gopclntab->quantum != 1 && gopclntab->quantum != 2 && gopclntab->quantum != 4) ||
        (gopclntab->pointer_size != sizeof(duint))) {
        return false;
    }
    if (!read_dbg_memory((duint)tmp_gopclntab_base + 8, &gopclntab->func_num, 4))
    {
        return false;
    }

    uint8_t* func_list_base;
    if (gopclntab->version == GO_VERSION::GO_118 || gopclntab->version == GO_VERSION::GO_120)
    {
        uint8_t* tmp_addr = tmp_gopclntab_base + 8 + (uint32_t)gopclntab->pointer_size * 7;
        uint64_t tmp_value = 0;
        if (!read_dbg_memory((duint)tmp_addr, &tmp_value, gopclntab->pointer_size))
        {
            return false;
        }
        func_list_base = tmp_gopclntab_base + tmp_value;
    }
    else if (gopclntab->version == GO_VERSION::GO_116)
    {
        uint8_t* tmp_addr = tmp_gopclntab_base + 8 + (uint32_t)gopclntab->pointer_size * 6;
        uint64_t tmp_value = 0;
        if (!read_dbg_memory((duint)tmp_addr, &tmp_value, gopclntab->pointer_size))
        {
            return false;
        }
        func_list_base = tmp_gopclntab_base + tmp_value;
    }
    else
    {
        func_list_base = tmp_gopclntab_base + 8 + gopclntab->pointer_size;
    }

    duint functab_field_size = gopclntab->version == GO_VERSION::GO_118 || gopclntab->version == GO_VERSION::GO_120 ? 4 : gopclntab->pointer_size;
    uint64_t func_info_offset = 0;
    if (!read_dbg_memory((duint)func_list_base + functab_field_size, &func_info_offset, functab_field_size))
    {
        return false;
    }

    uint64_t func_addr_value = 0;
    if (!read_dbg_memory((duint)func_list_base, &func_addr_value, functab_field_size))
    {
        return false;
    }

    uint64_t func_entry_value = 0;
    uint8_t* func_entry_value_base;
    if (gopclntab->version == GO_VERSION::GO_116 || gopclntab->version == GO_VERSION::GO_118 || gopclntab->version == GO_VERSION::GO_120)
    {
        func_entry_value_base = func_list_base;
    }
    else
    {
        func_entry_value_base = tmp_gopclntab_base;
    }
    if (!read_dbg_memory((duint)func_entry_value_base + func_info_offset, &func_entry_value, functab_field_size))
    {
        return false;
    }
    if (func_addr_value == func_entry_value && (gopclntab->version == GO_VERSION::GO_118 || gopclntab->version == GO_VERSION::GO_120 || func_addr_value != 0)) {
        gopclntab->addr = (duint)tmp_gopclntab_base;
        gopclntab->func_list_base = (duint)func_list_base;
        gopclntab->func_info_offset = func_info_offset;
        uint32_t file_name_table_offset = 0;
        duint file_name_table_offset_addr = gopclntab->func_list_base + (duint)gopclntab->func_num * gopclntab->pointer_size * 2 + gopclntab->pointer_size;
        if (!read_dbg_memory(file_name_table_offset_addr, &file_name_table_offset, 4))
        {
            return false;
        }
        gopclntab->file_name_table = gopclntab->addr + file_name_table_offset;

        if (get_line_enabled())
        {
            return analyze_file_name(gopclntab);
        }
        return true;
    }
    return false;
}

bool analyze_file_name(GOPCLNTAB* gopclntab)
{
    if (gopclntab->version == GO_VERSION::GO_116 || gopclntab->version == GO_VERSION::GO_118 || gopclntab->version == GO_VERSION::GO_120)
    {
        return true;
    }

    uint32_t size = 0;
    if (!read_dbg_memory(gopclntab->file_name_table, &size, 4))
    {
        goanalyzer_logputs("Failed to get size");
        return false;
    }

    gopclntab->file_name_list.clear();
    for (uint32_t i = 1; i < size; i++)
    {
        duint offset_addr = gopclntab->file_name_table + (duint)i * 4;
        uint32_t offset = 0;
        if (!read_dbg_memory(offset_addr, &offset, 4))
        {
            goanalyzer_logprintf("Failed to get offset %p\n", offset_addr);
            return false;
        }

        duint file_name_addr = gopclntab->addr + offset;
        size_t file_name_size = MAX_PATH;
        char file_name[MAX_PATH] = { 0 };
        if (!DbgMemIsValidReadPtr(file_name_addr))
        {
            goanalyzer_logprintf("Failed to get file_name %p\n", file_name_addr);
            return false;
        }

        while (file_name_size > 1)
        {
            if (DbgMemIsValidReadPtr(file_name_addr + file_name_size))
            {
                break;
            }
            file_name_size--;
        }

        if (!read_dbg_memory(file_name_addr, file_name, file_name_size))
        {
            return false;
        }
        file_name[sizeof(file_name) - 1] = '\0';
        gopclntab->file_name_list.push_back(file_name);
    }
    return true;
}

bool get_gopclntab(GOPCLNTAB* gopclntab)
{
#define GOPCLNTAB_MAGIC_COUNT 4
    uint8_t gopclntab_magic[GOPCLNTAB_MAGIC_COUNT][4] = {
        { 0xfb, 0xff, 0xff, 0xff },
        { 0xfa, 0xff, 0xff, 0xff },
        { 0xf0, 0xff, 0xff, 0xff },
        { 0xf1, 0xff, 0xff, 0xff },
    };
    GO_VERSION go_version[GOPCLNTAB_MAGIC_COUNT] = {
        GO_VERSION::GO_12,
        GO_VERSION::GO_116,
        GO_VERSION::GO_118,
        GO_VERSION::GO_120,
    };

    for (int i = 0; i < GOPCLNTAB_MAGIC_COUNT; i++)
    {
        std::vector<duint> gopclntab_addr_list;
        search_dbg_memory(&gopclntab_addr_list, gopclntab_magic[i], sizeof(gopclntab_magic[i]));

        for (auto addr : gopclntab_addr_list)
        {
            if (make_gopclntab(addr, go_version[i], gopclntab))
            {
                return true;
            }
        }
    }
    return false;
}



================================================
File: x64dbg_GolangAnalyzerPlugin/gopclntab.h
================================================
#pragma once

#include "x64dbg_GolangAnalyzerPlugin.h"

enum class GO_VERSION
{
    UNKNOWN,
    GO_12,
    GO_116,
    GO_118,
    GO_120,
};

struct GOPCLNTAB
{
    uint8_t magic[4] = { 0 };
    uint8_t unknown[2] = { 0 };
    uint8_t quantum = 0;
    uint8_t pointer_size = 0;

    GO_VERSION version = GO_VERSION::UNKNOWN;
    duint addr = 0;
    uint32_t func_num = 0;
    duint func_list_base = 0;
    uint64_t func_info_offset = 0;
    duint file_name_table = 0;

    std::vector<std::string> file_name_list;
};


bool get_gopclntab(GOPCLNTAB* gopclntab);
bool analyze_file_name(GOPCLNTAB* gopclntab);



================================================
File: x64dbg_GolangAnalyzerPlugin/menu.cpp
================================================
#include "menu.h"

static bool line_enabled = false;


bool get_line_enabled()
{
    return line_enabled;
}
void set_line_enabled(bool value)
{
    line_enabled = value;
}


================================================
File: x64dbg_GolangAnalyzerPlugin/menu.h
================================================
#pragma once

#include "x64dbg_GolangAnalyzerPlugin.h"

bool get_line_enabled();
void set_line_enabled(bool value);



================================================
File: x64dbg_GolangAnalyzerPlugin/util.cpp
================================================
#include "util.h"


bool read_dbg_memory(duint va, void* dest, duint size)
{
    if (!DbgMemIsValidReadPtr(va) || !DbgMemRead(va, dest, size))
    {
        return false;
    }
    return true;
}

void search_dbg_memory(std::vector<duint>* result, const uint8_t* target, int target_size)
{
    MEMMAP memory_map = {};
    if (!DbgMemMap(&memory_map) || memory_map.page == NULL)
    {
        return;
    }

    for (int i = 0; i < memory_map.count; i++)
    {
        uint8_t* mem_addr = (uint8_t*)memory_map.page[i].mbi.BaseAddress;
        size_t resion_size = memory_map.page[i].mbi.RegionSize;
        if (resion_size <= 0 || resion_size > 0x10000000)
        {
            continue;
        }

        std::vector<uint8_t> mem_data(resion_size, 0);
        if (!read_dbg_memory((duint)mem_addr, mem_data.data(), mem_data.size()))
        {
            continue;
        }

        for (size_t j = 0; j < mem_data.size() - target_size; j++)
        {
            if (!memcmp(mem_data.data() + j, target, target_size))
            {
                result->push_back((duint)(mem_addr + j));
            }
        }
    }
}



================================================
File: x64dbg_GolangAnalyzerPlugin/util.h
================================================
#pragma once

#include "x64dbg_GolangAnalyzerPlugin.h"

#define PLUGIN_NAME_LOG_HEADER "[" PLUGIN_NAME "] "
#define goanalyzer_logprintf(format, ...) _plugin_logprintf(PLUGIN_NAME_LOG_HEADER format, __VA_ARGS__)
#define goanalyzer_logputs(text) _plugin_logputs(PLUGIN_NAME_LOG_HEADER text)
#define logprintf(format, ...) _plugin_logprintf(format, __VA_ARGS__)
#define logputs(text) _plugin_logputs(text)


bool read_dbg_memory(duint va, void* dest, duint size);
void search_dbg_memory(std::vector<duint>* result, const uint8_t* target, int target_size);



================================================
File: x64dbg_GolangAnalyzerPlugin/x64dbg_GolangAnalyzerPlugin.cpp
================================================
#include "x64dbg_GolangAnalyzerPlugin.h"
#include "golang_analyzer.h"


#define szx64dbg_GolangAnalyzerPluginInfo "GolangAnalyzerPlugin Usage:\n" 


int pluginHandle;
HWND hwndDlg;
int hMenu;
int hMenuDisasm;
int hMenuDump;
int hMenuStack;


extern "C" DLL_EXPORT BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    return TRUE;
}


DLL_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    initStruct->pluginVersion = PLUGIN_VERSION;
    initStruct->sdkVersion = PLUG_SDKVERSION;
    strcpy(initStruct->pluginName, PLUGIN_NAME);
    pluginHandle = initStruct->pluginHandle;

    init_analyzer_plugin();
    return true;
}


DLL_EXPORT bool plugstop()
{
    _plugin_menuclear(hMenu);

    stop_analyzer_plugin();
    return true;
}


DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    hwndDlg = setupStruct->hwndDlg;
    hMenu = setupStruct->hMenu;
    hMenuDisasm = setupStruct->hMenuDisasm;
    hMenuDump = setupStruct->hMenuDump;
    hMenuStack = setupStruct->hMenuStack;

    GuiAddLogMessage, szx64dbg_GolangAnalyzerPluginInfo;

    setup_analyzer_plugin();
}


extern "C" __declspec(dllexport) void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY * info)
{

}


extern "C" __declspec(dllexport) void CBINITDEBUG(CBTYPE cbType, PLUG_CB_INITDEBUG * info)
{
    set_line_enabled(false);
}


extern "C" __declspec(dllexport) void CBSYSTEMBREAKPOINT(CBTYPE cbType, PLUG_CB_SYSTEMBREAKPOINT * info)
{

}



================================================
File: x64dbg_GolangAnalyzerPlugin/x64dbg_GolangAnalyzerPlugin.h
================================================
#ifndef _PLUGINMAIN_H
#define _PLUGINMAIN_H

#include "pluginsdk\TitanEngine\TitanEngine.h"
#include <windows.h>
#include <stdio.h>
#include <psapi.h>
#include <string>
#include <map>
#include "pluginsdk\_plugins.h"
#include "util.h"
#include "menu.h"
#include "gopclntab.h"


#define PLUGIN_NAME "x64dbg_GolangAnalyzerPlugin"
#define PLUGIN_VERSION 0


#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif //DLL_EXPORT


extern int pluginHandle;
extern HWND hwndDlg;
extern int hMenu;
extern int hMenuDisasm;
extern int hMenuDump;
extern int hMenuStack;


#ifdef __cplusplus
extern "C"
{
#endif

// Default plugin exports - required
DLL_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct);
DLL_EXPORT bool plugstop();
DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct);

#ifdef __cplusplus
}
#endif

#endif //_PLUGINMAIN_H



================================================
File: x64dbg_GolangAnalyzerPlugin/x64dbg_GolangAnalyzerPlugin.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{34D49BFD-EB2D-429D-A0CD-55451DC6474E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>x64dbg_GolangAnalyzerPlugin</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>NotSet</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
    <OutDir>$(SolutionDir)bin\x32\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
    <OutDir>$(SolutionDir)bin\x32\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
    <OutDir>$(SolutionDir)bin\x64\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_WINDOWS;_USRDLL;X64DBG_PLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>winmm.lib;psapi.lib;pluginsdk\x32dbg.lib;pluginsdk\x32bridge.lib;pluginsdk\TitanEngine\TitanEngine_x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_WINDOWS;_USRDLL;X64DBG_PLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <ErrorReporting>None</ErrorReporting>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <OmitFramePointers>false</OmitFramePointers>
      <IntrinsicFunctions>false</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <TargetMachine>MachineX64</TargetMachine>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <AdditionalDependencies>winmm.lib;psapi.lib;pluginsdk\x64dbg.lib;pluginsdk\x64bridge.lib;pluginsdk\TitanEngine\TitanEngine_x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;X64DBG_PLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ErrorReporting>None</ErrorReporting>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>winmm.lib;psapi.lib;pluginsdk\x32dbg.lib;pluginsdk\x32bridge.lib;pluginsdk\TitanEngine\TitanEngine_x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <TargetMachine>MachineX86</TargetMachine>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;X64DBG_PLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <OmitFramePointers>false</OmitFramePointers>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ErrorReporting>None</ErrorReporting>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <TargetMachine>MachineX64</TargetMachine>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <AdditionalDependencies>winmm.lib;psapi.lib;pluginsdk\x64dbg.lib;pluginsdk\x64bridge.lib;pluginsdk\TitanEngine\TitanEngine_x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="golang_analyzer.cpp" />
    <ClCompile Include="golang_function.cpp" />
    <ClCompile Include="gopclntab.cpp" />
    <ClCompile Include="menu.cpp" />
    <ClCompile Include="util.cpp" />
    <ClCompile Include="x64dbg_GolangAnalyzerPlugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="golang_analyzer.h" />
    <ClInclude Include="golang_function.h" />
    <ClInclude Include="gopclntab.h" />
    <ClInclude Include="menu.h" />
    <ClInclude Include="pluginsdk\bridgelist.h" />
    <ClInclude Include="pluginsdk\bridgemain.h" />
    <ClInclude Include="pluginsdk\capstone\arm.h" />
    <ClInclude Include="pluginsdk\capstone\arm64.h" />
    <ClInclude Include="pluginsdk\capstone\capstone.h" />
    <ClInclude Include="pluginsdk\capstone\mips.h" />
    <ClInclude Include="pluginsdk\capstone\platform.h" />
    <ClInclude Include="pluginsdk\capstone\ppc.h" />
    <ClInclude Include="pluginsdk\capstone\sparc.h" />
    <ClInclude Include="pluginsdk\capstone\systemz.h" />
    <ClInclude Include="pluginsdk\capstone\x86.h" />
    <ClInclude Include="pluginsdk\capstone\xcore.h" />
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h" />
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h" />
    <ClInclude Include="pluginsdk\jansson\jansson.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_config.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h" />
    <ClInclude Include="pluginsdk\lz4\lz4.h" />
    <ClInclude Include="pluginsdk\lz4\lz4file.h" />
    <ClInclude Include="pluginsdk\lz4\lz4hc.h" />
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h" />
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h" />
    <ClInclude Include="pluginsdk\yara\yara.h" />
    <ClInclude Include="pluginsdk\yara\yara\ahocorasick.h" />
    <ClInclude Include="pluginsdk\yara\yara\arena.h" />
    <ClInclude Include="pluginsdk\yara\yara\atoms.h" />
    <ClInclude Include="pluginsdk\yara\yara\compiler.h" />
    <ClInclude Include="pluginsdk\yara\yara\elf.h" />
    <ClInclude Include="pluginsdk\yara\yara\error.h" />
    <ClInclude Include="pluginsdk\yara\yara\exec.h" />
    <ClInclude Include="pluginsdk\yara\yara\exefiles.h" />
    <ClInclude Include="pluginsdk\yara\yara\filemap.h" />
    <ClInclude Include="pluginsdk\yara\yara\globals.h" />
    <ClInclude Include="pluginsdk\yara\yara\hash.h" />
    <ClInclude Include="pluginsdk\yara\yara\hex_lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\libyara.h" />
    <ClInclude Include="pluginsdk\yara\yara\limits.h" />
    <ClInclude Include="pluginsdk\yara\yara\mem.h" />
    <ClInclude Include="pluginsdk\yara\yara\modules.h" />
    <ClInclude Include="pluginsdk\yara\yara\object.h" />
    <ClInclude Include="pluginsdk\yara\yara\parser.h" />
    <ClInclude Include="pluginsdk\yara\yara\pe.h" />
    <ClInclude Include="pluginsdk\yara\yara\proc.h" />
    <ClInclude Include="pluginsdk\yara\yara\re.h" />
    <ClInclude Include="pluginsdk\yara\yara\re_lexer.h" />
    <ClInclude Include="pluginsdk\yara\yara\rules.h" />
    <ClInclude Include="pluginsdk\yara\yara\scan.h" />
    <ClInclude Include="pluginsdk\yara\yara\sizedstr.h" />
    <ClInclude Include="pluginsdk\yara\yara\strutils.h" />
    <ClInclude Include="pluginsdk\yara\yara\types.h" />
    <ClInclude Include="pluginsdk\yara\yara\utils.h" />
    <ClInclude Include="pluginsdk\_dbgfunctions.h" />
    <ClInclude Include="pluginsdk\_plugins.h" />
    <ClInclude Include="pluginsdk\_plugin_types.h" />
    <ClInclude Include="pluginsdk\_scriptapi.h" />
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h" />
    <ClInclude Include="pluginsdk\_scriptapi_debug.h" />
    <ClInclude Include="pluginsdk\_scriptapi_gui.h" />
    <ClInclude Include="pluginsdk\_scriptapi_memory.h" />
    <ClInclude Include="pluginsdk\_scriptapi_misc.h" />
    <ClInclude Include="pluginsdk\_scriptapi_module.h" />
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h" />
    <ClInclude Include="pluginsdk\_scriptapi_register.h" />
    <ClInclude Include="pluginsdk\_scriptapi_stack.h" />
    <ClInclude Include="util.h" />
    <ClInclude Include="x64dbg_GolangAnalyzerPlugin.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: x64dbg_GolangAnalyzerPlugin/x64dbg_GolangAnalyzerPlugin.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\pluginsdk">
      <UniqueIdentifier>{446998e0-6d5e-4d23-9249-3d1a0bc7fe31}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\capstone">
      <UniqueIdentifier>{30becf17-3b08-443d-85ad-05fb45775cb8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\dbghelp">
      <UniqueIdentifier>{88215581-88d7-47cf-972e-9eaf11d8f670}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\DeviceNameResolver">
      <UniqueIdentifier>{605c6980-440a-42a2-96d1-731aaec67b20}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\jansson">
      <UniqueIdentifier>{c6c74972-8272-46f2-ac18-d31b1725b6ca}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\lz4">
      <UniqueIdentifier>{d0fea627-ee2e-4417-91f8-12aba4fa882f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\TitanEngine">
      <UniqueIdentifier>{6632d6c2-8818-4b44-aac6-cf8db6572505}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\XEDParse">
      <UniqueIdentifier>{bf231cfd-f78f-4c31-a4e2-261c8fd88e0f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\yara">
      <UniqueIdentifier>{4889a9b3-e798-492d-ac42-03445d21e379}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\pluginsdk\yara\yara">
      <UniqueIdentifier>{7459ed30-6c92-481c-8add-0be8d296f015}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="x64dbg_GolangAnalyzerPlugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="golang_analyzer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="gopclntab.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="menu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="golang_function.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pluginsdk\_dbgfunctions.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugin_types.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugins.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_debug.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_gui.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_memory.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_misc.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_module.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_register.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_stack.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgelist.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgemain.h">
      <Filter>Header Files\pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\arm.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\arm64.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\capstone.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\mips.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\platform.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\ppc.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\sparc.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\systemz.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\x86.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\capstone\xcore.h">
      <Filter>Header Files\pluginsdk\capstone</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h">
      <Filter>Header Files\pluginsdk\dbghelp</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h">
      <Filter>Header Files\pluginsdk\DeviceNameResolver</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_config.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4file.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4hc.h">
      <Filter>Header Files\pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara.h">
      <Filter>Header Files\pluginsdk\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\ahocorasick.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\arena.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\atoms.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\compiler.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\elf.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\error.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\exec.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\exefiles.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\filemap.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\globals.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\hash.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\hex_lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\libyara.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\limits.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\mem.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\modules.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\object.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\parser.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\pe.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\proc.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\re.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\re_lexer.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\rules.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\scan.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\sizedstr.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\strutils.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\types.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\yara\yara\utils.h">
      <Filter>Header Files\pluginsdk\yara\yara</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h">
      <Filter>Header Files\pluginsdk\XEDParse</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h">
      <Filter>Header Files\pluginsdk\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h">
      <Filter>Header Files\pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_GolangAnalyzerPlugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="golang_analyzer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="gopclntab.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="menu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="golang_function.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


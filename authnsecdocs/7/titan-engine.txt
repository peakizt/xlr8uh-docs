Directory structure:
└── x64dbg-titanengine/
    ├── LICENSE
    ├── TitanEngine.sln
    ├── format.bat
    ├── install.bat
    ├── readme.txt
    ├── SDK/
    │   └── C/
    │       └── TitanEngine.h
    ├── TitanEngine/
    │   ├── Global.Breakpoints.cpp
    │   ├── Global.Breakpoints.h
    │   ├── Global.Debugger.cpp
    │   ├── Global.Debugger.h
    │   ├── Global.Engine.Context.cpp
    │   ├── Global.Engine.Context.h
    │   ├── Global.Engine.GUI.cpp
    │   ├── Global.Engine.GUI.h
    │   ├── Global.Engine.Hash.cpp
    │   ├── Global.Engine.Hash.h
    │   ├── Global.Engine.Hider.cpp
    │   ├── Global.Engine.Hider.h
    │   ├── Global.Engine.Hook.cpp
    │   ├── Global.Engine.Hook.h
    │   ├── Global.Engine.Importer.cpp
    │   ├── Global.Engine.Importer.h
    │   ├── Global.Engine.Simplification.cpp
    │   ├── Global.Engine.Simplification.h
    │   ├── Global.Engine.Threading.cpp
    │   ├── Global.Engine.Threading.h
    │   ├── Global.Engine.cpp
    │   ├── Global.Engine.h
    │   ├── Global.Garbage.cpp
    │   ├── Global.Garbage.h
    │   ├── Global.Handle.cpp
    │   ├── Global.Handle.h
    │   ├── Global.Helper.cpp
    │   ├── Global.Helper.h
    │   ├── Global.Injector.cpp
    │   ├── Global.Injector.h
    │   ├── Global.Librarian.cpp
    │   ├── Global.Librarian.h
    │   ├── Global.Mapping.cpp
    │   ├── Global.Mapping.h
    │   ├── Global.OEPFinder.cpp
    │   ├── Global.OEPFinder.h
    │   ├── Global.Realigner.cpp
    │   ├── Global.Realigner.h
    │   ├── Global.TLS.cpp
    │   ├── Global.TLS.h
    │   ├── Global.Threader.cpp
    │   ├── Global.Threader.h
    │   ├── LOGO.bmp
    │   ├── LzmaDec.cpp
    │   ├── LzmaDec.h
    │   ├── LzmaTypes.h
    │   ├── TitanEngine.Breakpoints.cpp
    │   ├── TitanEngine.Debugger.Context.cpp
    │   ├── TitanEngine.Debugger.Control.cpp
    │   ├── TitanEngine.Debugger.Data.cpp
    │   ├── TitanEngine.Debugger.DebugLoop.cpp
    │   ├── TitanEngine.Debugger.Helper.cpp
    │   ├── TitanEngine.Debugger.Memory.cpp
    │   ├── TitanEngine.Debugger.cpp
    │   ├── TitanEngine.Disassembler.cpp
    │   ├── TitanEngine.Dumper.cpp
    │   ├── TitanEngine.Engine.Simplification.cpp
    │   ├── TitanEngine.Engine.cpp
    │   ├── TitanEngine.Exporter.cpp
    │   ├── TitanEngine.Handler.cpp
    │   ├── TitanEngine.Hider.cpp
    │   ├── TitanEngine.Hooks.cpp
    │   ├── TitanEngine.Importer.cpp
    │   ├── TitanEngine.Injector.cpp
    │   ├── TitanEngine.Librarian.cpp
    │   ├── TitanEngine.OEPFinder.cpp
    │   ├── TitanEngine.PE.Convert.cpp
    │   ├── TitanEngine.PE.Data.cpp
    │   ├── TitanEngine.PE.Fixer.cpp
    │   ├── TitanEngine.PE.Overlay.cpp
    │   ├── TitanEngine.PE.Section.cpp
    │   ├── TitanEngine.PE.cpp
    │   ├── TitanEngine.Process.cpp
    │   ├── TitanEngine.Realigner.cpp
    │   ├── TitanEngine.Relocator.cpp
    │   ├── TitanEngine.Resourcer.cpp
    │   ├── TitanEngine.Static.cpp
    │   ├── TitanEngine.TLS.cpp
    │   ├── TitanEngine.Threader.cpp
    │   ├── TitanEngine.Tracer.cpp
    │   ├── TitanEngine.TranslateName.cpp
    │   ├── TitanEngine.cbp
    │   ├── TitanEngine.cpp
    │   ├── TitanEngine.def
    │   ├── TitanEngine.rc
    │   ├── TitanEngine.vcproj
    │   ├── TitanEngine.vcxproj
    │   ├── TitanEngine.vcxproj.filters
    │   ├── TitanEngine.workspace
    │   ├── aplib.h
    │   ├── definitions.h
    │   ├── distorm.h
    │   ├── manifest.xml
    │   ├── ntdll.h
    │   ├── resource.h
    │   ├── scylla_wrapper.h
    │   ├── stdafx.cpp
    │   ├── stdafx.h
    │   └── targetver.h
    ├── TitanEngineLoaders/
    │   └── LibraryLoader/
    │       ├── LibraryLoader.cpp
    │       ├── LibraryLoader.sln
    │       ├── LibraryLoader.vcxproj
    │       ├── LibraryLoader.vcxproj.filters
    │       ├── x32/
    │       └── x64/
    ├── hooks/
    │   ├── README.md
    │   ├── AStyleHelper.exe.config
    │   └── pre-commit
    ├── scylla_wrapper_dll/
    └── .github/
        └── workflows/
            └── build.yml

================================================
File: LICENSE
================================================
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.



================================================
File: TitanEngine.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TitanEngine", "TitanEngine\TitanEngine.vcxproj", "{9C7B8246-FDDA-48C7-9634-044969701E40}"
	ProjectSection(ProjectDependencies) = postProject
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C} = {F874B1B3-8EF7-4DF1-9889-57098E08A51C}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "scylla_wrapper", "scylla_wrapper_dll\scylla_wrapper\scylla_wrapper.vcxproj", "{F874B1B3-8EF7-4DF1-9889-57098E08A51C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Debug|Win32.ActiveCfg = Debug|Win32
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Debug|Win32.Build.0 = Debug|Win32
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Debug|x64.ActiveCfg = Debug|x64
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Debug|x64.Build.0 = Debug|x64
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Release|Win32.ActiveCfg = Release|Win32
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Release|Win32.Build.0 = Release|Win32
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Release|x64.ActiveCfg = Release|x64
		{9C7B8246-FDDA-48C7-9634-044969701E40}.Release|x64.Build.0 = Release|x64
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Debug|Win32.ActiveCfg = Release-Lib|Win32
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Debug|Win32.Build.0 = Release-Lib|Win32
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Debug|x64.ActiveCfg = Release-Lib|x64
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Debug|x64.Build.0 = Release-Lib|x64
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Release|Win32.ActiveCfg = Release-Lib|Win32
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Release|Win32.Build.0 = Release-Lib|Win32
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Release|x64.ActiveCfg = Release-Lib|x64
		{F874B1B3-8EF7-4DF1-9889-57098E08A51C}.Release|x64.Build.0 = Release-Lib|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6AD826EE-00F0-410E-9586-2B4EC239DC9E}
	EndGlobalSection
EndGlobal



================================================
File: format.bat
================================================
@echo off
hooks\AStyleHelper.exe Silent


================================================
File: install.bat
================================================
@echo off
echo Run this to install the auto-format hook.
copy hooks\pre-commit .git\hooks\pre-commit


================================================
File: readme.txt
================================================
This is a bugfixed & enhanced version of TitanEngine v2.0.3

The following things have been fixed/added (list might be incomplete):
- fixed memory breakpoints in general
- fixed harware breakpoints in general
- only report exceptions that are unhandled by the debugger
- working on x64 (previously there was a structure alignment problem)
- some code commenting
- fixed DumpProcessExW (found/fix provided by Aguila)
- added a callback on the system breakpoint
- added memory breakpoints on execute
- added QWORD hardware breakpoints
- smaller and faster DLL loaders
- supports multiple calling conventions (including the callbacks)
- MinGW import libraries
- fixed exception handling
- Importer functions use Scyllas business logic now, much more accurate
- updated distorm lib to v3, was v1
- countless code improvements

NOTE: LUA, Python, MASM and Delphi might not work correctly
      Mainly because their headers havent been adjusted 
      to these changes. However this is easy. Compare with 
      C/C++ headers, fix it up and send us.
      
      
If you are good with these kinda codes, please help review, do pull-requests, 
and criticize what you think can be be improved !

You can discuss with us here 
http://forum.tuts4you.com/forum/138-titanengine-community-edition/


================================================
File: SDK/C/TitanEngine.h
================================================
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <stdint.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9
#define UE_ENGINE_SAFE_ATTACH 10
#define UE_ENGINE_MEMBP_ALT 11
#define UE_ENGINE_DISABLE_ASLR 12
#define UE_ENGINE_SAFE_STEP 13

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
	YmmRegister_t Low; //AVX part
	YmmRegister_t High; //AVX-512 part
} ZmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

typedef struct
{
#ifdef _WIN64
	ZmmRegister_t ZmmRegisters[32];
#else // x86
	ZmmRegister_t ZmmRegisters[8];
#endif
	ULONGLONG Opmask[8];
} TITAN_ENGINE_CONTEXT_AVX512_t;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, const char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(const char* szFileName, const char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(const wchar_t* szFileName, const wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(const char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(const char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(const wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(const char* szFileName, const char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(const wchar_t* szFileName, const wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(const char* szFileName, const char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(const wchar_t* szFileName, const wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(const char* szInFileName, const char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(const wchar_t* szInFileName, const wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(const char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(const char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(const char* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(const char* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(const char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(const wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(const char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(const wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(const char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(const char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(const wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(const char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(const char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(const wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(const char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(const wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(const char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(const wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(const char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(const wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(const char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(const wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(const char* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(const wchar_t* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, const char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, const wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const char* szDumpFile1, const char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const wchar_t* szDumpFile1, const wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(const char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(const wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(const char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(const wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(const char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(const char* szFileName, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(const wchar_t* szFileName, char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(const char* szFileName, const char* szResourceType, DWORD ResourceType, const char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(const wchar_t* szFileName, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(const char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(const wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(const char* szFileName, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetAVX512Context(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVX512Context(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(const char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(const wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(const char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(const char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(const char* szDumpFileName, const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(const wchar_t* szDumpFileName, const wchar_t* szExportFileName, const wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(const char* szDLLName, const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, const char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, const wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(const char* szOriginalFile, const char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(const char* szOriginalFile, const char* szDumpFile, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile, const char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, const char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, const wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, const char* szDumpedFile, const char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, const wchar_t* szDumpedFile, const wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, const char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, const wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(const char* szModuleName, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(const char* szModuleName, const char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(const char* szModuleName, const char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(const char* szModuleName, const char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, const char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, const char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(const char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(const wchar_t* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(const wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(const char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(const char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(const char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(const wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(const char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(const wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(const char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(const char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(const wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(const char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(const wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(const char* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(const wchar_t* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(const char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(const wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, const char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, const wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(const char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(const wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(const char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(const wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(const char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(const wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(const char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(const wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(const wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(const char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(const char* szFileName, const char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(const wchar_t* szFileName, const wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(const char* szFileName, const char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(const wchar_t* szFileName, const wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(const char* WindowUnpackerTitle, const char* WindowUnpackerLongTitle, const char* WindowUnpackerName, const char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(const char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/



================================================
File: TitanEngine/Global.Breakpoints.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Breakpoints.h"

std::vector<BreakPointDetail> BreakPointBuffer;
std::unordered_map<ULONG_PTR, MemoryBreakpointPageDetail> MemoryBreakpointPages;

ULONG_PTR dr7uint(DR7* dr7)
{
    ULONG_PTR ret = 0;
    if(BITGET(dr7->HWBP_MODE[0], 0))
        BITSET(ret, 0);
    if(BITGET(dr7->HWBP_MODE[0], 1))
        BITSET(ret, 1);
    if(BITGET(dr7->HWBP_MODE[1], 0))
        BITSET(ret, 2);
    if(BITGET(dr7->HWBP_MODE[1], 1))
        BITSET(ret, 3);
    if(BITGET(dr7->HWBP_MODE[2], 0))
        BITSET(ret, 4);
    if(BITGET(dr7->HWBP_MODE[2], 1))
        BITSET(ret, 5);
    if(BITGET(dr7->HWBP_MODE[3], 0))
        BITSET(ret, 6);
    if(BITGET(dr7->HWBP_MODE[3], 1))
        BITSET(ret, 7);
    if(BITGET(dr7->HWBP_TYPE[0], 0))
        BITSET(ret, 16);
    if(BITGET(dr7->HWBP_TYPE[0], 1))
        BITSET(ret, 17);
    if(BITGET(dr7->HWBP_SIZE[0], 0))
        BITSET(ret, 18);
    if(BITGET(dr7->HWBP_SIZE[0], 1))
        BITSET(ret, 19);
    if(BITGET(dr7->HWBP_TYPE[1], 0))
        BITSET(ret, 20);
    if(BITGET(dr7->HWBP_TYPE[1], 1))
        BITSET(ret, 21);
    if(BITGET(dr7->HWBP_SIZE[1], 0))
        BITSET(ret, 22);
    if(BITGET(dr7->HWBP_SIZE[1], 1))
        BITSET(ret, 23);
    if(BITGET(dr7->HWBP_TYPE[2], 0))
        BITSET(ret, 24);
    if(BITGET(dr7->HWBP_TYPE[2], 1))
        BITSET(ret, 25);
    if(BITGET(dr7->HWBP_SIZE[2], 0))
        BITSET(ret, 26);
    if(BITGET(dr7->HWBP_SIZE[2], 1))
        BITSET(ret, 27);
    if(BITGET(dr7->HWBP_TYPE[3], 0))
        BITSET(ret, 28);
    if(BITGET(dr7->HWBP_TYPE[3], 1))
        BITSET(ret, 29);
    if(BITGET(dr7->HWBP_SIZE[3], 0))
        BITSET(ret, 30);
    if(BITGET(dr7->HWBP_SIZE[3], 1))
        BITSET(ret, 31);
    return ret;
}

void uintdr7(ULONG_PTR dr7, DR7* ret)
{
    memset(ret, 0, sizeof(DR7));
    if(BITGET(dr7, 0))
        BITSET(ret->HWBP_MODE[0], 0);
    if(BITGET(dr7, 1))
        BITSET(ret->HWBP_MODE[0], 1);
    if(BITGET(dr7, 2))
        BITSET(ret->HWBP_MODE[1], 0);
    if(BITGET(dr7, 3))
        BITSET(ret->HWBP_MODE[1], 1);
    if(BITGET(dr7, 4))
        BITSET(ret->HWBP_MODE[2], 0);
    if(BITGET(dr7, 5))
        BITSET(ret->HWBP_MODE[2], 1);
    if(BITGET(dr7, 6))
        BITSET(ret->HWBP_MODE[3], 0);
    if(BITGET(dr7, 7))
        BITSET(ret->HWBP_MODE[3], 1);
    if(BITGET(dr7, 16))
        BITSET(ret->HWBP_TYPE[0], 0);
    if(BITGET(dr7, 17))
        BITSET(ret->HWBP_TYPE[0], 1);
    if(BITGET(dr7, 18))
        BITSET(ret->HWBP_SIZE[0], 0);
    if(BITGET(dr7, 19))
        BITSET(ret->HWBP_SIZE[0], 1);
    if(BITGET(dr7, 20))
        BITSET(ret->HWBP_TYPE[1], 0);
    if(BITGET(dr7, 21))
        BITSET(ret->HWBP_TYPE[1], 1);
    if(BITGET(dr7, 22))
        BITSET(ret->HWBP_SIZE[1], 0);
    if(BITGET(dr7, 23))
        BITSET(ret->HWBP_SIZE[1], 1);
    if(BITGET(dr7, 24))
        BITSET(ret->HWBP_TYPE[2], 0);
    if(BITGET(dr7, 25))
        BITSET(ret->HWBP_TYPE[2], 1);
    if(BITGET(dr7, 26))
        BITSET(ret->HWBP_SIZE[2], 0);
    if(BITGET(dr7, 27))
        BITSET(ret->HWBP_SIZE[2], 1);
    if(BITGET(dr7, 28))
        BITSET(ret->HWBP_TYPE[3], 0);
    if(BITGET(dr7, 29))
        BITSET(ret->HWBP_TYPE[3], 1);
    if(BITGET(dr7, 30))
        BITSET(ret->HWBP_SIZE[3], 0);
    if(BITGET(dr7, 31))
        BITSET(ret->HWBP_SIZE[3], 1);
}

void BreakPointPostReadFilter(ULONG_PTR lpBaseAddress, unsigned char* lpBuffer, SIZE_T nSize)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    ULONG_PTR start = lpBaseAddress;
    ULONG_PTR end = start + nSize;
    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        BreakPointDetail* curBp = &BreakPointBuffer.at(i);
        //check if the breakpoint is one we should be concerned about
        if(curBp->BreakPointActive != UE_BPXACTIVE || (curBp->BreakPointType != UE_BREAKPOINT && curBp->BreakPointType != UE_SINGLESHOOT))
            continue;
        ULONG_PTR cur_addr = curBp->BreakPointAddress;
        for(SIZE_T j = 0; j < curBp->BreakPointSize; j++)
        {
            if(cur_addr + j >= start && cur_addr + j < end) //breakpoint is in range
            {
                ULONG_PTR index = cur_addr + j - start; //calculate where to write in the buffer
                memcpy(lpBuffer + index, &curBp->OriginalByte[j], sizeof(char));
            }
        }
    }
}

void BreakPointPreWriteFilter(ULONG_PTR lpBaseAddress, SIZE_T nSize)
{
    ULONG_PTR start = lpBaseAddress;
    ULONG_PTR end = start + nSize;
    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        BreakPointDetail* curBp = &BreakPointBuffer.at(i);
        //check if the breakpoint is one we should be concerned about
        if(curBp->BreakPointActive != UE_BPXACTIVE || (curBp->BreakPointType != UE_BREAKPOINT && curBp->BreakPointType != UE_SINGLESHOOT))
            continue;
        ULONG_PTR cur_addr = curBp->BreakPointAddress;
        for(SIZE_T j = 0; j < curBp->BreakPointSize; j++)
        {
            if(cur_addr + j >= start && cur_addr + j < end) //breakpoint byte is in range
            {
                DisableBPX(cur_addr);
                curBp->BreakPointActive = UE_BPXACTIVE; //little hack
                break;
            }
        }
    }
}

void BreakPointPostWriteFilter(ULONG_PTR lpBaseAddress, SIZE_T nSize)
{
    ULONG_PTR start = lpBaseAddress;
    ULONG_PTR end = start + nSize;
    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        BreakPointDetail* curBp = &BreakPointBuffer.at(i);
        //check if the breakpoint is one we should be concerned about
        if(curBp->BreakPointActive != UE_BPXACTIVE || (curBp->BreakPointType != UE_BREAKPOINT && curBp->BreakPointType != UE_SINGLESHOOT))
            continue;
        ULONG_PTR cur_addr = curBp->BreakPointAddress;
        for(SIZE_T j = 0; j < curBp->BreakPointSize; j++)
        {
            if(cur_addr + j >= start && cur_addr + j < end) //breakpoint byte is in range
            {
                curBp->BreakPointActive = UE_BPXINACTIVE; //little hack
                EnableBPX(cur_addr); //needs a cleaner solution
                break;
            }
        }
    }
}

bool IsDepEnabled(bool* outPermanent)
{
    bool isEnabled = false;
    bool isPermanent = false;

#ifndef _WIN64
    ULONG depFlags = 0;
    NTSTATUS status = NtQueryInformationProcess(dbgProcessInformation.hProcess, ProcessExecuteFlags, &depFlags, sizeof(depFlags), nullptr);
    if(status == STATUS_SUCCESS)
    {
        isEnabled = (depFlags & 0x1) != 0; // 0x1 is MEM_EXECUTE_OPTION_DISABLE
        isPermanent = (depFlags & 0x8) != 0; // 0x8 is MEM_EXECUTE_OPTION_PERMANENT
    }
#else
    isEnabled = true;
    isPermanent = true;
#endif //_WIN64

    if(outPermanent != nullptr)
        *outPermanent = isPermanent;

    return isEnabled;
}

DWORD GetPageProtectionForMemoryBreakpoint(const MemoryBreakpointPageDetail & page)
{
    // Memory Protection Constants: https://msdn.microsoft.com/en-us/library/windows/desktop/aa366786(v=vs.85).aspx

    // If DEP is disabled or enabled but not permanent (i.e. may be disabled unpredictably in the future),
    //  we cannot rely on "PAGE_EXECUTE_*" protection options for BPs on execution
    //  and should use PAGE_GUARD (or PAGE_NOACCESS) instead, a much slower approach:
    bool isDepPermanent = false;
    bool isDepPermanentlyEnabled = IsDepEnabled(&isDepPermanent) && isDepPermanent;

    // for ACCESS and READ breakpoints, apply the "lowest" protection: GUARD_PAGE or PAGE_NOACCESS
    if(page.accessBps > 0 || page.readBps > 0 || (page.executeBps > 0 && !isDepPermanentlyEnabled))
    {
        // GUARD_PAGE is incompatible with PAGE_NOACCESS
        if((page.origProtect & 0xFF) == PAGE_NOACCESS || engineMembpAlt)
            return (page.origProtect & ~0x7FF) | PAGE_NOACCESS;
        else
            // erase PAGE_NOCACHE and PAGE_WRITECOMBINE (cannot be used with the PAGE_GUARD)
            return (page.origProtect & ~0x700) | PAGE_GUARD;
    }

    int newProtect = page.origProtect & ~PAGE_GUARD; // erase guard page, just in case
    if(page.executeBps > 0 && isDepPermanentlyEnabled)
    {
        // Remove execute access e.g. PAGE_EXECUTE_READWRITE => PAGE_READWRITE
        DWORD dwBase = newProtect & 0xFF;
        DWORD dwHigh = newProtect & 0xFFFFFF00;
        switch(dwBase)
        {
        case PAGE_EXECUTE:
            newProtect = dwHigh | PAGE_READONLY;
            break;
        case PAGE_EXECUTE_READ:
        case PAGE_EXECUTE_READWRITE:
        case PAGE_EXECUTE_WRITECOPY:
            newProtect = dwHigh | (dwBase >> 4);
            break;
        }
    }

    if(page.writeBps > 0)
    {
        // Remove write access e.g. PAGE_EXECUTE_READWRITE => PAGE_EXECUTE
        DWORD dwBase = newProtect & 0xFF;
        switch(dwBase)
        {
        case PAGE_READWRITE:
        case PAGE_EXECUTE_READWRITE:
            newProtect = (newProtect & 0xFFFFFF00) | (dwBase >> 1);
            break;
        }
    }

    return newProtect;
}

bool IsMemoryAccessAllowed(DWORD memProtect, ULONG_PTR accessType /*0 (READ), 1 (WRITE), or 8 (EXECUTE)*/)
{
    const bool isRead = accessType == 0;
    const bool isWrite = accessType == 1;
    const bool isExecute = accessType == 8;

    switch(memProtect & 0xFF)
    {
    case PAGE_EXECUTE:
    case PAGE_EXECUTE_READ:
        return isRead || isExecute;
    case PAGE_EXECUTE_READWRITE:
    case PAGE_EXECUTE_WRITECOPY:
        return true;
    case PAGE_READONLY:
        return isRead || (isExecute && !IsDepEnabled());
    case PAGE_READWRITE:
    case PAGE_WRITECOPY:
        return isRead || isWrite || (isExecute && !IsDepEnabled());
    default:
    case PAGE_NOACCESS:
        return false;
    }
}



================================================
File: TitanEngine/Global.Breakpoints.h
================================================
#ifndef _GLOBAL_BREAKPOINTS_H
#define _GLOBAL_BREAKPOINTS_H

#include <vector>
#include <unordered_map>

#include "Global.Engine.Threading.h"
#include "Global.Engine.h"
#include "Global.Debugger.h"


extern std::vector<BreakPointDetail> BreakPointBuffer;
extern std::unordered_map<ULONG_PTR, MemoryBreakpointPageDetail> MemoryBreakpointPages;

void uintdr7(ULONG_PTR dr7, DR7* ret);
ULONG_PTR dr7uint(DR7* dr7);
void BreakPointPostReadFilter(ULONG_PTR lpBaseAddress, unsigned char* lpBuffer, SIZE_T nSize);
void BreakPointPreWriteFilter(ULONG_PTR lpBaseAddress, SIZE_T nSize);
void BreakPointPostWriteFilter(ULONG_PTR lpBaseAddress, SIZE_T nSize);

bool IsDepEnabled(bool* outPermanent = nullptr);
DWORD GetPageProtectionForMemoryBreakpoint(const MemoryBreakpointPageDetail & page);
bool IsMemoryAccessAllowed(DWORD memProtect, ULONG_PTR accessType);

#endif //_GLOBAL_BREAKPOINTS_H



================================================
File: TitanEngine/Global.Debugger.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "Global.Engine.h"
#include "Global.Breakpoints.h"

HARDWARE_DATA DebugRegister[4] = {};
PROCESS_INFORMATION dbgProcessInformation = {};
CustomHandler myDBGCustomHandler = {};
PCustomHandler DBGCustomHandler = &myDBGCustomHandler;
ExpertDebug expertDebug = {};
STARTUPINFOW dbgStartupInfo = {};
LPVOID DebugModuleEntryPointCallBack;
LPVOID DebugExeFileEntryPointCallBack;
ULONG_PTR DebugModuleEntryPoint;
ULONG_PTR DebugModuleImageBase;
ULONG_PTR DebugAttachedProcessCallBack = NULL;
ULONG_PTR DebugReserveModuleBase = NULL;
ULONG_PTR DebugDebuggingMainModuleBase = NULL;
ULONG_PTR DebugDebuggingDLLBase = NULL;
HANDLE DebugDLLFileMapping;
bool DebugAttachedToProcess = false;
bool DebugDebuggingDLL = false;
wchar_t* DebugDebuggingDLLFullFileName;
wchar_t* DebugDebuggingDLLFileName;
DEBUG_EVENT DBGEvent = {};
DEBUG_EVENT TerminateDBGEvent = {};
DWORD ProcessExitCode = 0;
HANDLE DBGFileHandle;
std::vector<ULONG_PTR> tlsCallBackList;
std::vector<PROCESS_ITEM_DATA> hListProcess;
DWORD engineStepCount = 0;
LPVOID engineStepCallBack = NULL;
bool engineStepActive = false;
bool engineProcessIsNowDetached = false;
DWORD DBGCode = DBG_CONTINUE;
bool engineFileIsBeingDebugged = false;
ULONG_PTR engineFakeDLLHandle = NULL;
LPVOID engineAttachedProcessDebugInfo = NULL;
wchar_t szDebuggerName[512];
bool DebugStepFinal = false;
LPVOID StepOutCallBack = NULL;
CRITICAL_SECTION engineStepActiveCr;

// Workaround for a bug in the kernel with x64 emulation on ARM
DWORD ContextControlFlags = []
{
    DWORD flags = CONTEXT_CONTROL;
    typedef BOOL(WINAPI *type_IsWow64Process2)(HANDLE, USHORT*, USHORT*);
    auto p_IsWow64Process2 = (type_IsWow64Process2)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "IsWow64Process2");
    if (p_IsWow64Process2)
    {
        USHORT processMachine = 0;
        USHORT nativeMachine = 0;
        if (p_IsWow64Process2(GetCurrentProcess(), &processMachine, &nativeMachine))
        {
#ifndef IMAGE_FILE_MACHINE_ARM64
#define IMAGE_FILE_MACHINE_ARM64 0xAA64
#endif // IMAGE_FILE_MACHINE_ARM64
            if (nativeMachine == IMAGE_FILE_MACHINE_ARM || nativeMachine == IMAGE_FILE_MACHINE_ARM64)
            {
                flags = CONTEXT_ALL;
            }
        }
    }
    return flags;
}();

// Global.Debugger.functions:
long DebugLoopInSecondThread(LPVOID InputParameter)
{
    if(InputParameter == NULL) //IsFileDll
    {
        InitDebugExW(expertDebug.szFileName, expertDebug.szCommandLine, expertDebug.szCurrentFolder, expertDebug.EntryCallBack);
    }
    else
    {
        InitDLLDebugW(expertDebug.szFileName, expertDebug.ReserveModuleBase, expertDebug.szCommandLine, expertDebug.szCurrentFolder, expertDebug.EntryCallBack);
    }
    DebugLoop();
    return NULL;
}

void DebuggerReset()
{
    if(engineResetCustomHandler)
    {
        RtlZeroMemory(&myDBGCustomHandler, sizeof CustomHandler);
    }
    std::vector<BreakPointDetail>().swap(BreakPointBuffer);
    std::unordered_map<ULONG_PTR, MemoryBreakpointPageDetail>().swap(MemoryBreakpointPages);
}

void ClearProcessList()
{
    std::vector<PROCESS_ITEM_DATA>().swap(hListProcess);
}

void ClearTlsCallBackList()
{
    std::vector<ULONG_PTR>().swap(tlsCallBackList);
}

void StepOutStepCallBack()
{
    BYTE cipch = 0x90;
    MemoryReadSafe(dbgProcessInformation.hProcess, (void*)GetContextData(UE_CIP), &cipch, sizeof(cipch), 0);
    if(cipch == 0xC3 || cipch == 0xC2) //ret
    {
        if(DebugStepFinal)
            StepOver(StepOutCallBack);
        else
        {
            typedef void(TITCALL * fCustomBreakPoint)();
            ((fCustomBreakPoint)StepOutCallBack)();
        }
    }
    else
        StepOver(StepOutStepCallBack);
}

static DWORD BaseSetLastNTError(IN NTSTATUS Status)
{
    DWORD dwErrCode;
    dwErrCode = RtlNtStatusToDosError(Status);
    SetLastError(dwErrCode);
    return dwErrCode;
}

static HANDLE WINAPI ProcessIdToHandle(IN DWORD dwProcessId)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;
    CLIENT_ID ClientId;

    /* If we don't have a PID, look it up */
    //if (dwProcessId == MAXDWORD) dwProcessId = (DWORD_PTR)CsrGetProcessId();

    /* Open a handle to the process */
    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = UlongToHandle(dwProcessId);
    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
    Status = NtOpenProcess(&Handle,
                           PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION |
                           PROCESS_VM_WRITE | PROCESS_VM_READ |
                           PROCESS_SUSPEND_RESUME | PROCESS_QUERY_INFORMATION,
                           &ObjectAttributes,
                           &ClientId);
    if(!NT_SUCCESS(Status))
    {
        /* Fail */
        BaseSetLastNTError(Status);
        return 0;
    }

    /* Return the handle */
    return Handle;
}

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET 0x00000020
#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080

static NTSTATUS CreateThreadSkipAttach(IN HANDLE ProcessHandle, IN PUSER_THREAD_START_ROUTINE StartRoutine, IN PVOID Argument)
{
    NTSTATUS Status;
    HANDLE hThread;

    typedef NTSTATUS(NTAPI * t_NtCreateThreadEx)(
        PHANDLE /* ThreadHandle */,
        ACCESS_MASK /* DesiredAccess */,
        POBJECT_ATTRIBUTES /* ObjectAttributes */,
        HANDLE /* ProcessHandle */,
        PUSER_THREAD_START_ROUTINE /* StartRoutine */,
        PVOID /* Argument */,
        ULONG /* CreateFlags */,
        ULONG_PTR /* ZeroBits */,
        SIZE_T /* StackSize */,
        SIZE_T /* MaximumStackSize */,
        PPS_ATTRIBUTE_LIST /* AttributeList */
    );

    auto p_NtCreateThreadEx = (t_NtCreateThreadEx)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateThreadEx");
    if(p_NtCreateThreadEx)
    {
        // Based on: https://chromium-review.googlesource.com/c/crashpad/crashpad/+/339263/16/client/crashpad_client_win.cc#697
        Status = p_NtCreateThreadEx(&hThread,
                                    STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                                    nullptr,
                                    ProcessHandle,
                                    StartRoutine,
                                    Argument,
                                    THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH,
                                    0,
                                    0x4000 /* PAGE_SIZE * 4 */,
                                    0x4000,
                                    nullptr);
    }
    else
    {
        CLIENT_ID ClientId;
        Status = RtlCreateUserThread(ProcessHandle,
                                     NULL,
                                     FALSE,
                                     0,
                                     0x4000,
                                     0x4000 /* PAGE_SIZE * 4 */,
                                     StartRoutine,
                                     Argument,
                                     &hThread,
                                     &ClientId);
    }

    if(NT_SUCCESS(Status))
    {
        NtClose(hThread);
    }

    return Status;
}

static NTSTATUS NTAPI DbgUiIssueRemoteBreakin_(IN HANDLE Process)
{
    PUSER_THREAD_START_ROUTINE RemoteBreakFunction = (PUSER_THREAD_START_ROUTINE)DbgUiRemoteBreakin;
    LPVOID RemoteMemory = VirtualAllocEx(Process, 0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READ);
    if(RemoteMemory)
    {
        SIZE_T written = 0;
        unsigned char payload[] = { 0xCC, 0xC3 };
        if(WriteProcessMemory(Process, RemoteMemory, payload, sizeof(payload), &written))
        {
            RemoteBreakFunction = (PUSER_THREAD_START_ROUTINE)RemoteMemory;
        }
        else
        {
            VirtualFreeEx(Process, RemoteMemory, 0, MEM_RELEASE);
        }
    }

    /* Create the thread that will perform the breakin (on Vista+ it will skip DllMain and TLS callbacks) */
    return CreateThreadSkipAttach(Process, RemoteBreakFunction, NULL);
}

static NTSTATUS NTAPI DbgUiDebugActiveProcess_(IN HANDLE Process)
{
    /* Tell the kernel to start debugging */
    NTSTATUS Status = NtDebugActiveProcess(Process, NtCurrentTeb()->DbgSsReserved[1]);
    return Status;

#if 0
    if(NT_SUCCESS(Status))
    {
        /* Now break-in the process */
        Status = DbgUiIssueRemoteBreakin_(Process);
        if(!NT_SUCCESS(Status))
        {
            /* We couldn't break-in, cancel debugging */
            DbgUiStopDebugging(Process);
        }
    }

    /* Return status */
    return Status;
#endif
}

static NTSTATUS NTAPI DbgUiConnectToDbg_()
{
    if(NtCurrentTeb()->DbgSsReserved[1] != NULL)
        return STATUS_SUCCESS;

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
    return NtCreateDebugObject(&NtCurrentTeb()->DbgSsReserved[1], DEBUG_ALL_ACCESS, &ObjectAttributes, 0);
}

// Source: https://github.com/mirror/reactos/blob/c6d2b35ffc91e09f50dfb214ea58237509329d6b/reactos/dll/win32/kernel32/client/debugger.c#L480
BOOL WINAPI DebugActiveProcess_(IN DWORD dwProcessId)
{
    /* Connect to the debugger */
    NTSTATUS Status = DbgUiConnectToDbg_();
    if(!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    /* Get the process handle */
    HANDLE Handle = ProcessIdToHandle(dwProcessId);
    if(!Handle)
    {
        return FALSE;
    }

    /* Now debug the process */
    Status = DbgUiDebugActiveProcess_(Handle);

    /* Close the handle since we're done */
    NtClose(Handle);

    /* Check if debugging worked */
    if(!NT_SUCCESS(Status))
    {
        /* Fail */
        BaseSetLastNTError(Status);
        return FALSE;
    }

    /* Success */
    return TRUE;
}


================================================
File: TitanEngine/Global.Debugger.h
================================================
#ifndef _GLOBAL_DEBUGGER_H
#define _GLOBAL_DEBUGGER_H

#include <vector>
#include <Windows.h>

extern HARDWARE_DATA DebugRegister[4];
extern PROCESS_INFORMATION dbgProcessInformation;
extern CustomHandler myDBGCustomHandler;
extern PCustomHandler DBGCustomHandler;
extern ExpertDebug expertDebug;
extern STARTUPINFOW dbgStartupInfo;
extern LPVOID DebugModuleEntryPointCallBack;
extern LPVOID DebugExeFileEntryPointCallBack;
extern ULONG_PTR DebugModuleEntryPoint;
extern ULONG_PTR DebugModuleImageBase;
extern ULONG_PTR DebugAttachedProcessCallBack;
extern bool DebugAttachedToProcess;
extern ULONG_PTR DebugReserveModuleBase;
extern ULONG_PTR DebugDebuggingMainModuleBase;
extern ULONG_PTR DebugDebuggingDLLBase;
extern HANDLE DebugDLLFileMapping;
extern bool DebugDebuggingDLL;
extern wchar_t* DebugDebuggingDLLFullFileName;
extern wchar_t* DebugDebuggingDLLFileName;
extern DEBUG_EVENT DBGEvent;
extern DEBUG_EVENT TerminateDBGEvent;
extern DWORD ProcessExitCode;
extern HANDLE DBGFileHandle;
extern std::vector<ULONG_PTR> tlsCallBackList;
extern std::vector<PROCESS_ITEM_DATA> hListProcess;
extern DWORD engineStepCount;
extern LPVOID engineStepCallBack;
extern bool engineStepActive;
extern bool engineProcessIsNowDetached;
extern DWORD DBGCode;
extern bool engineFileIsBeingDebugged;
extern ULONG_PTR engineFakeDLLHandle;
extern LPVOID engineAttachedProcessDebugInfo;
extern wchar_t szDebuggerName[512];
extern bool DebugStepFinal;
extern LPVOID StepOutCallBack;
extern CRITICAL_SECTION engineStepActiveCr;
extern DWORD ContextControlFlags;

long DebugLoopInSecondThread(LPVOID InputParameter);
void DebuggerReset();
void ClearProcessList();
void ClearTlsCallBackList();
void StepOutStepCallBack();
BOOL WINAPI DebugActiveProcess_(IN DWORD dwProcessId);

#endif //_GLOBAL_DEBUGGER_H



================================================
File: TitanEngine/Global.Engine.Context.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Context.h"

#ifdef _WIN64
//https://stackoverflow.com/a/869597/1806760
template<typename T> struct identity
{
    typedef T type;
};

template<typename Dst> Dst implicit_cast(typename identity<Dst>::type t)
{
    return t;
}

//https://github.com/electron/crashpad/blob/4054e6cba3ba023d9c00260518ec2912607ae17c/snapshot/cpu_context.cc
enum
{
    kX87TagValid = 0,
    kX87TagZero,
    kX87TagSpecial,
    kX87TagEmpty,
};

typedef uint8_t X87Register[10];

union X87OrMMXRegister
{
    struct
    {
        X87Register st;
        uint8_t st_reserved[6];
    };
    struct
    {
        uint8_t mm_value[8];
        uint8_t mm_reserved[8];
    };
};

static_assert(sizeof(X87OrMMXRegister) == sizeof(M128A), "sizeof(X87OrMMXRegister) != sizeof(M128A)");

static uint16_t FxsaveToFsaveTagWord(
    uint16_t fsw,
    uint8_t fxsave_tag,
    const X87OrMMXRegister* st_mm)
{
    // The x87 tag word (in both abridged and full form) identifies physical
    // registers, but |st_mm| is arranged in logical stack order. In order to map
    // physical tag word bits to the logical stack registers they correspond to,
    // the "stack top" value from the x87 status word is necessary.
    int stack_top = (fsw >> 11) & 0x7;

    uint16_t fsave_tag = 0;
    for(int physical_index = 0; physical_index < 8; ++physical_index)
    {
        bool fxsave_bit = (fxsave_tag & (1 << physical_index)) != 0;
        uint8_t fsave_bits;

        if(fxsave_bit)
        {
            int st_index = (physical_index + 8 - stack_top) % 8;
            const X87Register & st = st_mm[st_index].st;

            uint32_t exponent = ((st[9] & 0x7f) << 8) | st[8];
            if(exponent == 0x7fff)
            {
                // Infinity, NaN, pseudo-infinity, or pseudo-NaN. If it was important to
                // distinguish between these, the J bit and the M bit (the most
                // significant bit of |fraction|) could be consulted.
                fsave_bits = kX87TagSpecial;
            }
            else
            {
                // The integer bit the "J bit".
                bool integer_bit = (st[7] & 0x80) != 0;
                if(exponent == 0)
                {
                    uint64_t fraction = ((implicit_cast<uint64_t>(st[7]) & 0x7f) << 56) |
                                        (implicit_cast<uint64_t>(st[6]) << 48) |
                                        (implicit_cast<uint64_t>(st[5]) << 40) |
                                        (implicit_cast<uint64_t>(st[4]) << 32) |
                                        (implicit_cast<uint32_t>(st[3]) << 24) |
                                        (st[2] << 16) | (st[1] << 8) | st[0];
                    if(!integer_bit && fraction == 0)
                    {
                        fsave_bits = kX87TagZero;
                    }
                    else
                    {
                        // Denormal (if the J bit is clear) or pseudo-denormal.
                        fsave_bits = kX87TagSpecial;
                    }
                }
                else if(integer_bit)
                {
                    fsave_bits = kX87TagValid;
                }
                else
                {
                    // Unnormal.
                    fsave_bits = kX87TagSpecial;
                }
            }
        }
        else
        {
            fsave_bits = kX87TagEmpty;
        }

        fsave_tag |= (fsave_bits << (physical_index * 2));
    }

    return fsave_tag;
}

static uint8_t FsaveToFxsaveTagWord(uint16_t fsave_tag)
{
    uint8_t fxsave_tag = 0;
    for(int physical_index = 0; physical_index < 8; ++physical_index)
    {
        const uint8_t fsave_bits = (fsave_tag >> (physical_index * 2)) & 0x3;
        const bool fxsave_bit = fsave_bits != kX87TagEmpty;
        fxsave_tag |= fxsave_bit << physical_index;
    }
    return fxsave_tag;
}
#endif //_WIN64

PGETENABLEDXSTATEFEATURES _GetEnabledXStateFeatures = NULL;
PINITIALIZECONTEXT _InitializeContext = NULL;
PGETXSTATEFEATURESMASK _GetXStateFeaturesMask = NULL;
LOCATEXSTATEFEATURE _LocateXStateFeature = NULL;
SETXSTATEFEATURESMASK _SetXStateFeaturesMask = NULL;

bool _SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext, bool AVX_PRIORITY)
{
    CONTEXT DBGContext;
    memset(&DBGContext, 0, sizeof(DBGContext));

    DBGContext.ContextFlags = CONTEXT_ALL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;

    if(!GetThreadContext(hActiveThread, &DBGContext))
    {
        ResumeThread(hActiveThread);
        return false;
    }

    DBGContext.EFlags = (DWORD)titcontext->eflags;
    DBGContext.Dr0 = titcontext->dr0;
    DBGContext.Dr1 = titcontext->dr1;
    DBGContext.Dr2 = titcontext->dr2;
    DBGContext.Dr3 = titcontext->dr3;
    DBGContext.Dr6 = titcontext->dr6;
    DBGContext.Dr7 = titcontext->dr7;
    DBGContext.SegGs = titcontext->gs;
    DBGContext.SegFs = titcontext->fs;
    DBGContext.SegEs = titcontext->es;
    DBGContext.SegDs = titcontext->ds;
    DBGContext.SegCs = titcontext->cs;
    DBGContext.SegSs = titcontext->ss;

#ifdef _WIN64 //x64
    DBGContext.Rax = titcontext->cax;
    DBGContext.Rbx = titcontext->cbx;
    DBGContext.Rcx = titcontext->ccx;
    DBGContext.Rdx = titcontext->cdx;
    DBGContext.Rdi = titcontext->cdi;
    DBGContext.Rsi = titcontext->csi;
    DBGContext.Rbp = titcontext->cbp;
    DBGContext.Rsp = titcontext->csp;
    DBGContext.Rip = titcontext->cip;
    DBGContext.R8 = titcontext->r8;
    DBGContext.R9 = titcontext->r9;
    DBGContext.R10 = titcontext->r10;
    DBGContext.R11 = titcontext->r11;
    DBGContext.R12 = titcontext->r12;
    DBGContext.R13 = titcontext->r13;
    DBGContext.R14 = titcontext->r14;
    DBGContext.R15 = titcontext->r15;

    DBGContext.FltSave.ControlWord = titcontext->x87fpu.ControlWord;
    DBGContext.FltSave.StatusWord = titcontext->x87fpu.StatusWord;
    DBGContext.FltSave.TagWord = FsaveToFxsaveTagWord(titcontext->x87fpu.TagWord);
    DBGContext.FltSave.ErrorSelector = (WORD)titcontext->x87fpu.ErrorSelector;
    DBGContext.FltSave.ErrorOffset = titcontext->x87fpu.ErrorOffset;
    DBGContext.FltSave.DataSelector = (WORD)titcontext->x87fpu.DataSelector;
    DBGContext.FltSave.DataOffset = titcontext->x87fpu.DataOffset;
    // Skip titcontext->x87fpu.Cr0NpxState
    DBGContext.MxCsr = titcontext->MxCsr;

    for(int i = 0; i < 8; i++)
        memcpy(& DBGContext.FltSave.FloatRegisters[i], &(titcontext->RegisterArea[i * 10]), 10);

    for(int i = 0; i < 16; i++)
        memcpy(& (DBGContext.FltSave.XmmRegisters[i]), & (titcontext->XmmRegisters[i]), 16);

#else //x86
    DBGContext.Eax = titcontext->cax;
    DBGContext.Ebx = titcontext->cbx;
    DBGContext.Ecx = titcontext->ccx;
    DBGContext.Edx = titcontext->cdx;
    DBGContext.Edi = titcontext->cdi;
    DBGContext.Esi = titcontext->csi;
    DBGContext.Ebp = titcontext->cbp;
    DBGContext.Esp = titcontext->csp;
    DBGContext.Eip = titcontext->cip;

    DBGContext.FloatSave.ControlWord = titcontext->x87fpu.ControlWord;
    DBGContext.FloatSave.StatusWord = titcontext->x87fpu.StatusWord;
    DBGContext.FloatSave.TagWord = titcontext->x87fpu.TagWord;
    DBGContext.FloatSave.ErrorSelector = titcontext->x87fpu.ErrorSelector;
    DBGContext.FloatSave.ErrorOffset = titcontext->x87fpu.ErrorOffset;
    DBGContext.FloatSave.DataSelector = titcontext->x87fpu.DataSelector;
    DBGContext.FloatSave.DataOffset = titcontext->x87fpu.DataOffset;
#ifdef NTDDI_WIN8
    DBGContext.FloatSave.Spare0 = titcontext->x87fpu.Cr0NpxState;
#else
    DBGContext.FloatSave.Cr0NpxState = titcontext->x87fpu.Cr0NpxState;
#endif

    memcpy(DBGContext.FloatSave.RegisterArea, titcontext->RegisterArea, 80);

    // MXCSR ExtendedRegisters[24]
    memcpy(& (DBGContext.ExtendedRegisters[24]), & titcontext->MxCsr, sizeof(titcontext->MxCsr));

    // for x86 copy the 8 Xmm Registers from ExtendedRegisters[(10+n)*16]; (n is the index of the xmm register) to the XMM register
    for(int i = 0; i < 8; i++)
        memcpy(& DBGContext.ExtendedRegisters[(10 + i) * 16], &(titcontext->XmmRegisters[i]), 16);
#endif

    bool returnf = SetThreadContext(hActiveThread, & DBGContext) ? true : false;

    if(AVX_PRIORITY)
        SetAVXContext(hActiveThread, titcontext);

    return returnf;
}

bool _GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext, bool avx)
{
    CONTEXT DBGContext;
    memset(&DBGContext, 0, sizeof(CONTEXT));
    memset(titcontext, 0, sizeof(TITAN_ENGINE_CONTEXT_t));

    DBGContext.ContextFlags = CONTEXT_ALL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;

    if(!GetThreadContext(hActiveThread, &DBGContext))
        return false;

    titcontext->eflags = DBGContext.EFlags;
    titcontext->dr0 = DBGContext.Dr0;
    titcontext->dr1 = DBGContext.Dr1;
    titcontext->dr2 = DBGContext.Dr2;
    titcontext->dr3 = DBGContext.Dr3;
    titcontext->dr6 = DBGContext.Dr6;
    titcontext->dr7 = DBGContext.Dr7;
    titcontext->gs = (unsigned short) DBGContext.SegGs;
    titcontext->fs = (unsigned short) DBGContext.SegFs;
    titcontext->es = (unsigned short) DBGContext.SegEs;
    titcontext->ds = (unsigned short) DBGContext.SegDs;
    titcontext->cs = (unsigned short) DBGContext.SegCs;
    titcontext->ss = (unsigned short) DBGContext.SegSs;

#ifdef _WIN64 //x64
    titcontext->cax = DBGContext.Rax;
    titcontext->cbx = DBGContext.Rbx;
    titcontext->ccx = DBGContext.Rcx;
    titcontext->cdx = DBGContext.Rdx;
    titcontext->cdi = DBGContext.Rdi;
    titcontext->csi = DBGContext.Rsi;
    titcontext->cbp = DBGContext.Rbp;
    titcontext->csp = DBGContext.Rsp;
    titcontext->cip = DBGContext.Rip;
    titcontext->r8 = DBGContext.R8;
    titcontext->r9 = DBGContext.R9;
    titcontext->r10 = DBGContext.R10;
    titcontext->r11 = DBGContext.R11;
    titcontext->r12 = DBGContext.R12;
    titcontext->r13 = DBGContext.R13;
    titcontext->r14 = DBGContext.R14;
    titcontext->r15 = DBGContext.R15;

    titcontext->x87fpu.ControlWord = DBGContext.FltSave.ControlWord;
    titcontext->x87fpu.StatusWord = DBGContext.FltSave.StatusWord;
    titcontext->x87fpu.TagWord = FxsaveToFsaveTagWord(DBGContext.FltSave.StatusWord, DBGContext.FltSave.TagWord, (const X87OrMMXRegister*)DBGContext.FltSave.FloatRegisters);
    titcontext->x87fpu.ErrorSelector = DBGContext.FltSave.ErrorSelector;
    titcontext->x87fpu.ErrorOffset = DBGContext.FltSave.ErrorOffset;
    titcontext->x87fpu.DataSelector = DBGContext.FltSave.DataSelector;
    titcontext->x87fpu.DataOffset = DBGContext.FltSave.DataOffset;
    // Skip titcontext->x87fpu.Cr0NpxState (https://github.com/x64dbg/x64dbg/issues/255)
    titcontext->MxCsr = DBGContext.MxCsr;

    for(int i = 0; i < 8; i++)
        memcpy(&titcontext->RegisterArea[i * 10], &DBGContext.FltSave.FloatRegisters[i], 10);

    for(int i = 0; i < 16; i++)
        memcpy(&titcontext->XmmRegisters[i], &DBGContext.FltSave.XmmRegisters[i], 16);

#else //x86
    titcontext->cax = DBGContext.Eax;
    titcontext->cbx = DBGContext.Ebx;
    titcontext->ccx = DBGContext.Ecx;
    titcontext->cdx = DBGContext.Edx;
    titcontext->cdi = DBGContext.Edi;
    titcontext->csi = DBGContext.Esi;
    titcontext->cbp = DBGContext.Ebp;
    titcontext->csp = DBGContext.Esp;
    titcontext->cip = DBGContext.Eip;

    titcontext->x87fpu.ControlWord = (WORD) DBGContext.FloatSave.ControlWord;
    titcontext->x87fpu.StatusWord = (WORD) DBGContext.FloatSave.StatusWord;
    titcontext->x87fpu.TagWord = (WORD) DBGContext.FloatSave.TagWord;
    titcontext->x87fpu.ErrorSelector = DBGContext.FloatSave.ErrorSelector;
    titcontext->x87fpu.ErrorOffset = DBGContext.FloatSave.ErrorOffset;
    titcontext->x87fpu.DataSelector = DBGContext.FloatSave.DataSelector;
    titcontext->x87fpu.DataOffset = DBGContext.FloatSave.DataOffset;
#ifdef NTDDI_WIN8
    titcontext->x87fpu.Cr0NpxState = DBGContext.FloatSave.Spare0;
#else
    titcontext->x87fpu.Cr0NpxState = DBGContext.FloatSave.Cr0NpxState;
#endif

    memcpy(titcontext->RegisterArea, DBGContext.FloatSave.RegisterArea, 80);

    // MXCSR ExtendedRegisters[24]
    memcpy(& (titcontext->MxCsr), & (DBGContext.ExtendedRegisters[24]), sizeof(titcontext->MxCsr));

    // for x86 copy the 8 Xmm Registers from ExtendedRegisters[(10+n)*16]; (n is the index of the xmm register) to the XMM register
    for(int i = 0; i < 8; i++)
        memcpy(&(titcontext->XmmRegisters[i]),  & DBGContext.ExtendedRegisters[(10 + i) * 16], 16);
#endif

    if(avx)
        GetAVXContext(hActiveThread, titcontext);

    return true;
}

bool InitXState()
{
    static bool init = false;
    if(!init)
    {
        init = true;
        HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
        if(kernel32 != NULL)
        {
            _GetEnabledXStateFeatures = (PGETENABLEDXSTATEFEATURES)GetProcAddress(kernel32, "GetEnabledXStateFeatures");
            _InitializeContext = (PINITIALIZECONTEXT)GetProcAddress(kernel32, "InitializeContext");
            _GetXStateFeaturesMask = (PGETXSTATEFEATURESMASK)GetProcAddress(kernel32, "GetXStateFeaturesMask");
            _LocateXStateFeature = (LOCATEXSTATEFEATURE)GetProcAddress(kernel32, "LocateXStateFeature");
            _SetXStateFeaturesMask = (SETXSTATEFEATURESMASK)GetProcAddress(kernel32, "SetXStateFeaturesMask");
        }
    }
    return (_GetEnabledXStateFeatures != NULL &&
            _InitializeContext != NULL &&
            _GetXStateFeaturesMask != NULL &&
            _LocateXStateFeature != NULL &&
            _SetXStateFeaturesMask != NULL);
}


================================================
File: TitanEngine/Global.Engine.Context.h
================================================
#ifndef _GLOBAL_ENGINE_CONTEXT_H
#define _GLOBAL_ENGINE_CONTEXT_H

#undef CONTEXT_XSTATE

#if defined(_M_X64)
#define CONTEXT_XSTATE                      (0x00100040)
#else
#define CONTEXT_XSTATE                      (0x00010040)
#endif

#define XSTATE_AVX                          (XSTATE_GSSE)
#define XSTATE_MASK_AVX                     (XSTATE_MASK_GSSE)

typedef DWORD64(WINAPI* PGETENABLEDXSTATEFEATURES)();
typedef BOOL (WINAPI* PINITIALIZECONTEXT)(PVOID Buffer, DWORD ContextFlags, PCONTEXT* Context, PDWORD ContextLength);
typedef BOOL (WINAPI* PGETXSTATEFEATURESMASK)(PCONTEXT Context, PDWORD64 FeatureMask);
typedef PVOID(WINAPI* LOCATEXSTATEFEATURE)(PCONTEXT Context, DWORD FeatureId, PDWORD Length);
typedef BOOL (WINAPI* SETXSTATEFEATURESMASK)(PCONTEXT Context, DWORD64 FeatureMask);

extern PGETENABLEDXSTATEFEATURES _GetEnabledXStateFeatures;
extern PINITIALIZECONTEXT _InitializeContext;
extern PGETXSTATEFEATURESMASK _GetXStateFeaturesMask;
extern LOCATEXSTATEFEATURE _LocateXStateFeature;
extern SETXSTATEFEATURESMASK _SetXStateFeaturesMask;

bool _SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext, bool AVX_PRIORITY);
bool _GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext, bool avx);
bool InitXState(void);

#endif //_GLOBAL_ENGINE_CONTEXT_H


================================================
File: TitanEngine/Global.Engine.GUI.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.GUI.h"
#include "Global.Engine.h"

#define TE_VER_MAJOR 2
#define TE_VER_MIDDLE 1
#define TE_VER_MINOR 0

char szWindowUnpackerName[128];
char szWindowUnpackerTitle[128];
char szWindowUnpackerLongTitle[128];
char szWindowUnpackerAuthor[128];

HWND EngineBoxHandle;

static HWND EngineWindowHandle;

// Global.TitanEngine.Engine.functions:
bool EngineGetFileDialog(char* GlobalBuffer)
{
    OPENFILENAMEA sOpenFileName;
    char szFilterString[] = "All Files \0*.*\0\0";
    char szDialogTitle[] = "TitanEngine2 from Reversing Labs";

    RtlZeroMemory(&sOpenFileName, sizeof(OPENFILENAMEA));
    sOpenFileName.lStructSize = sizeof(OPENFILENAMEA);
    sOpenFileName.lpstrFilter = szFilterString;
    sOpenFileName.lpstrFile = GlobalBuffer;
    sOpenFileName.nMaxFile = 1024;
    sOpenFileName.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_LONGNAMES | OFN_EXPLORER | OFN_HIDEREADONLY;
    sOpenFileName.lpstrTitle = szDialogTitle;
    if(!GetOpenFileNameA(&sOpenFileName))
    {
        RtlZeroMemory(GlobalBuffer, 1024);
        return false;
    }
    else
    {
        return true;
    }
}

long EngineWndProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    char szAboutTitle[] = "[ About ]";
    char szAboutText[] = "%s \r\n\r\n ReversingLabs - http://www.reversinglabs.com \r\n\r\n  Minimum engine version needed:\r\n- TitanEngine %i.%i.%i by RevLabs\r\n\r\nUnpacker coded by %s";
    typedef void(TITCALL * fStartUnpacking)(char* szInputFile, bool RealignFile, bool CopyOverlay);
    fStartUnpacking myStartUnpacking = (fStartUnpacking)EngineStartUnpackingCallBack;
    char GlobalBuffer[1024] = {};
    char AboutBuffer[1024] = {};
    bool bRealignFile = false;
    bool bCopyOverlay = false;

    if(uMsg == WM_INITDIALOG)
    {
        SendMessageA(hwndDlg, WM_SETTEXT, NULL, (LPARAM)&szWindowUnpackerTitle);
        HICON hIconLarge = (HICON)LoadImage(engineHandle, MAKEINTRESOURCE(IDI_ICON1), IMAGE_ICON, 32, 32, LR_DEFAULTSIZE);
        SendMessage(hwndDlg, WM_SETICON, ICON_BIG, (LPARAM)hIconLarge);
        HICON hIconSmall = (HICON)LoadImage(engineHandle, MAKEINTRESOURCE(IDI_ICON1), IMAGE_ICON, 16, 16, LR_DEFAULTSIZE);
        SendMessage(hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIconSmall);
        SetDlgItemTextA(hwndDlg, IDD_UNPACKERTITLE, szWindowUnpackerLongTitle);
        SetDlgItemTextA(hwndDlg, IDC_FILENAME, "filename.exe");
        CheckDlgButton(hwndDlg, IDC_REALING, 1);
        EngineWindowHandle = hwndDlg;
    }
    else if(uMsg == WM_DROPFILES)
    {
        DragQueryFileA((HDROP)wParam, NULL, GlobalBuffer, sizeof(GlobalBuffer));
        SetDlgItemTextA(hwndDlg, IDC_FILENAME, GlobalBuffer);
    }
    else if(uMsg == WM_CLOSE)
    {
        EndDialog(hwndDlg, NULL);
    }
    else if(uMsg == WM_COMMAND)
    {
        if(wParam == IDC_UNPACK)
        {
            GetDlgItemTextA(hwndDlg, IDC_FILENAME, GlobalBuffer, sizeof(GlobalBuffer));
            if(!IsFileBeingDebugged() && EngineFileExists(GlobalBuffer))
            {
                EngineBoxHandle = GetDlgItem(hwndDlg, IDC_LISTBOX);
                SendMessageA(EngineBoxHandle, LB_RESETCONTENT, NULL, NULL);
                if(IsDlgButtonChecked(EngineWindowHandle, IDC_REALING))
                {
                    bRealignFile = true;
                }
                if(IsDlgButtonChecked(EngineWindowHandle, IDC_COPYOVERLAY))
                {
                    bCopyOverlay = true;
                }
                myStartUnpacking(GlobalBuffer, bRealignFile, bCopyOverlay);
            }
        }
        else if(wParam == IDC_BROWSE)
        {
            if(EngineGetFileDialog(GlobalBuffer))
            {
                SetDlgItemTextA(hwndDlg, IDC_FILENAME, GlobalBuffer);
            }
        }
        else if(wParam == IDC_ABOUT)
        {
            wsprintfA(AboutBuffer, szAboutText, szWindowUnpackerName, TE_VER_MAJOR, TE_VER_MIDDLE, TE_VER_MINOR, szWindowUnpackerAuthor);
            MessageBoxA(hwndDlg, AboutBuffer, szAboutTitle, MB_ICONASTERISK);
        }
        else if(wParam == IDC_EXIT)
        {
            EndDialog(hwndDlg, NULL);
        }
    }
    return 0;
}



================================================
File: TitanEngine/Global.Engine.GUI.h
================================================
#ifndef _GLOBAL_ENGINE_GUI_H
#define _GLOBAL_ENGINE_GUI_H

#include "resource.h"

extern char szWindowUnpackerName[128];
extern char szWindowUnpackerTitle[128];
extern char szWindowUnpackerLongTitle[128];
extern char szWindowUnpackerAuthor[128];

extern HWND EngineBoxHandle;

bool EngineGetFileDialog(char* GlobalBuffer);
long EngineWndProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif //_GLOBAL_ENGINE_GUI_H


================================================
File: TitanEngine/Global.Engine.Hash.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Hash.h"

static unsigned long Crc32Table[256];

// Global.Engine.Hash.functions:
void HashInit()
{
    unsigned long ulPolynomial = 0x04C11DB7; //0x04C11DB7 is the official polynomial used by PKZip, WinZip and Ethernet.
    // CRC32 table initialization
    for(int iCodes = 0; iCodes <= 0xFF; iCodes++)
    {
        Crc32Table[iCodes] = EngineCrc32Reflect(iCodes, 8) << 24;
        for(int iPos = 0; iPos < 8; iPos++)
        {
            Crc32Table[iCodes] = (Crc32Table[iCodes] << 1) ^ ((Crc32Table[iCodes] & (1 << 31)) ? ulPolynomial : 0);
        }
        Crc32Table[iCodes] = EngineCrc32Reflect(Crc32Table[iCodes], 32);
    }
}

unsigned long EngineCrc32Reflect(unsigned long ulReflect, const char cChar)
{

    unsigned long ulValue = 0;

    // Swap bit 0 for bit 7, bit 1 For bit 6, etc....
    for(int iPos = 1; iPos < (cChar + 1); iPos++)
    {
        if(ulReflect & 1)
        {
            ulValue |= (1 << (cChar - iPos));
        }
        ulReflect >>= 1;
    }
    return ulValue;
}

void EngineCrc32PartialCRC(unsigned long* ulCRC, const unsigned char* sData, unsigned long ulDataLength)
{

    while(ulDataLength--)
    {
        //If your compiler complains about the following line, try changing each
        //  occurrence of *ulCRC with "((unsigned long)*ulCRC)" or "*(unsigned long *)ulCRC".
        *(unsigned long*)ulCRC = ((*(unsigned long*)ulCRC) >> 8) ^ Crc32Table[((*(unsigned long*)ulCRC) & 0xFF) ^ *sData++];
    }
}


================================================
File: TitanEngine/Global.Engine.Hash.h
================================================
#ifndef _GLOBAL_ENGINE_HASH_H
#define _GLOBAL_ENGINE_HASH_H

void HashInit();
unsigned long EngineCrc32Reflect(unsigned long ulReflect, const char cChar);
void EngineCrc32PartialCRC(unsigned long* ulCRC, const unsigned char* sData, unsigned long ulDataLength);

#endif //_GLOBAL_ENGINE_HASH_H


================================================
File: TitanEngine/Global.Engine.Hider.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Hider.h"
#include "Global.Engine.h"
#include "Global.Engine.Importer.h"
#include "Global.Debugger.h"

// Global.Engine.Hider.functions:
static bool isAtleastVista()
{
    static bool isAtleastVista = false;
    static bool isSet = false;
    if(isSet)
        return isAtleastVista;
    OSVERSIONINFO versionInfo = {0};
    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&versionInfo);
    isAtleastVista = versionInfo.dwMajorVersion >= 6;
    isSet = true;
    return isAtleastVista;
}

//TODO: unclear behaviour, will return true when on wow64, but should not return true, because the system structures are x32 in that case
static bool isWindows64()
{
    SYSTEM_INFO si = {0};
    typedef void (WINAPI * tGetNativeSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
    tGetNativeSystemInfo _GetNativeSystemInfo = (tGetNativeSystemInfo)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetNativeSystemInfo");

    if(_GetNativeSystemInfo)
    {
        _GetNativeSystemInfo(&si);
    }
    else
    {
        GetSystemInfo(&si);
    }

    return (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64);
}

static void FixAntidebugApiInProcess(HANDLE hProcess, bool Hide, bool x64)
{
    const BYTE patchCheckRemoteDebuggerPresent32[5] =
    {
        0x33, 0xC0,      //XOR EAX,EAX
        0xC2, 0x08, 0x00 //RETN 0x8
    };
    const BYTE patchGetTickCount32[3] =
    {
        0x33, 0xC0, //XOR EAX,EAX
        0xC3        //RETN
    };
    const BYTE patchCheckRemoteDebuggerPresent64[4] =
    {
        0x48, 0x31, 0xC0, //XOR RAX,RAX
        0xC3  //RETN
    };
    const BYTE patchGetTickCount64[4] =
    {
        0x48, 0x31, 0xC0, //XOR RAX,RAX
        0xC3 //RETN
    };

    const BYTE* patchCheckRemoteDebuggerPresent;
    int patchCheckRemoteDebuggerPresentSize;
    const BYTE* patchGetTickCount;
    int patchGetTickCountSize;

    if(x64) //x64 patches
    {
        patchCheckRemoteDebuggerPresent = patchCheckRemoteDebuggerPresent64;
        patchCheckRemoteDebuggerPresentSize = sizeof(patchCheckRemoteDebuggerPresent64);
        patchGetTickCount = patchGetTickCount64;
        patchGetTickCountSize = sizeof(patchGetTickCount64);
    }
    else //x86 patches
    {
        patchCheckRemoteDebuggerPresent = patchCheckRemoteDebuggerPresent32;
        patchCheckRemoteDebuggerPresentSize = sizeof(patchCheckRemoteDebuggerPresent32);
        patchGetTickCount = patchGetTickCount32;
        patchGetTickCountSize = sizeof(patchGetTickCount32);
    }

    ULONG_PTR APIPatchAddress = 0;
    DWORD OldProtect = 0;
    SIZE_T ueNumberOfBytesRead = 0;

    if(Hide)
    {
        APIPatchAddress = EngineGetProcAddressRemote(hProcess, L"kernel32.dll", "CheckRemoteDebuggerPresent");
        if(VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchCheckRemoteDebuggerPresentSize, PAGE_EXECUTE_READWRITE, &OldProtect))
        {
            WriteProcessMemory(hProcess, (LPVOID)(APIPatchAddress), &patchCheckRemoteDebuggerPresent, patchCheckRemoteDebuggerPresentSize, &ueNumberOfBytesRead);
            VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchCheckRemoteDebuggerPresentSize, OldProtect, &OldProtect);
        }

        APIPatchAddress = EngineGetProcAddressRemote(hProcess, L"kernel32.dll", "GetTickCount");
        if(VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchGetTickCountSize, PAGE_EXECUTE_READWRITE, &OldProtect))
        {
            WriteProcessMemory(hProcess, (LPVOID)(APIPatchAddress), &patchGetTickCount, patchGetTickCountSize, &ueNumberOfBytesRead);
            VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchGetTickCountSize, OldProtect, &OldProtect);
        }
    }
    else
    {
        APIPatchAddress = EngineGetProcAddressRemote(hProcess, L"kernel32.dll", "CheckRemoteDebuggerPresent");
        if(VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchCheckRemoteDebuggerPresentSize, PAGE_EXECUTE_READWRITE, &OldProtect))
        {
            WriteProcessMemory(hProcess, (LPVOID)(APIPatchAddress), (void*)GetProcAddress(GetModuleHandleA("kernel32.dll"), "CheckRemoteDebuggerPresent"), patchCheckRemoteDebuggerPresentSize, &ueNumberOfBytesRead);
            VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchCheckRemoteDebuggerPresentSize, OldProtect, &OldProtect);
        }

        APIPatchAddress = EngineGetProcAddressRemote(hProcess, L"kernel32.dll", "GetTickCount");
        if(VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchGetTickCountSize, PAGE_EXECUTE_READWRITE, &OldProtect))
        {
            WriteProcessMemory(hProcess, (LPVOID)(APIPatchAddress), (void*)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetTickCount"), patchGetTickCountSize, &ueNumberOfBytesRead);
            VirtualProtectEx(hProcess, (LPVOID)APIPatchAddress, patchGetTickCountSize, OldProtect, &OldProtect);
        }
    }

    FlushInstructionCache(hProcess, NULL, 0);
}

//Quote from The Ultimate Anti-Debugging Reference by Peter Ferrie
//Flags field exists at offset 0x0C in the heap on the 32-bit versions of Windows NT, Windows 2000, and Windows XP; and at offset 0x40 on the 32-bit versions of Windows Vista and later.
//Flags field exists at offset 0x14 in the heap on the 64-bit versions of Windows XP, and at offset 0x70 in the heap on the 64-bit versions of Windows Vista and later.
//ForceFlags field exists at offset 0x10 in the heap on the 32-bit versions of Windows NT, Windows 2000, and Windows XP; and at offset 0x44 on the 32-bit versions of Windows Vista and later.
//ForceFlags field exists at offset 0x18 in the heap on the 64-bit versions of Windows XP, and at offset 0x74 in the heap on the 64-bit versions of Windows Vista and later.

static int getHeapFlagsOffset(bool x64)
{
    if(x64)  //x64 offsets
    {
        if(isAtleastVista())
        {
            return 0x70;
        }
        else
        {
            return 0x14;
        }
    }
    else //x86 offsets
    {
        if(isAtleastVista())
        {
            return 0x40;
        }
        else
        {
            return 0x0C;
        }
    }
}

static int getHeapForceFlagsOffset(bool x64)
{
    if(x64)  //x64 offsets
    {
        if(isAtleastVista())
        {
            return 0x74;
        }
        else
        {
            return 0x18;
        }
    }
    else //x86 offsets
    {
        if(isAtleastVista())
        {
            return 0x44;
        }
        else
        {
            return 0x10;
        }
    }
}

static bool FixPebInProcess(HANDLE hProcess, bool Hide)
{
    PEB_CURRENT myPEB = {0};
    SIZE_T ueNumberOfBytesRead = 0;
    void* heapFlagsAddress = 0;
    DWORD heapFlags = 0;
    void* heapForceFlagsAddress = 0;
    DWORD heapForceFlags = 0;

#ifndef _WIN64
    PEB64 myPEB64 = {0};
    void* AddressOfPEB64 = GetPEBLocation64(hProcess);
#endif

    void* AddressOfPEB = GetPEBLocation(hProcess);

    if(!AddressOfPEB)
        return false;

    if(ReadProcessMemory(hProcess, AddressOfPEB, (void*)&myPEB, sizeof(PEB_CURRENT), &ueNumberOfBytesRead))
    {
#ifndef _WIN64
        if(AddressOfPEB64)
        {
            ReadProcessMemory(hProcess, AddressOfPEB64, (void*)&myPEB64, sizeof(PEB64), &ueNumberOfBytesRead);
        }
#endif

        if(Hide)
        {
            //TODO: backup GlobalFlag
            myPEB.BeingDebugged = FALSE;
            myPEB.NtGlobalFlag &= ~0x70;

#ifndef _WIN64
            myPEB64.BeingDebugged = FALSE;
            myPEB64.NtGlobalFlag &= ~0x70;
#endif

            //TODO: backup heap flags
#ifdef _WIN64
            heapFlagsAddress = (void*)((LONG_PTR)myPEB.ProcessHeap + getHeapFlagsOffset(true));
            heapForceFlagsAddress = (void*)((LONG_PTR)myPEB.ProcessHeap + getHeapForceFlagsOffset(true));
#else
            heapFlagsAddress = (void*)((LONG_PTR)myPEB.ProcessHeap + getHeapFlagsOffset(false));
            heapForceFlagsAddress = (void*)((LONG_PTR)myPEB.ProcessHeap + getHeapForceFlagsOffset(false));
#endif //_WIN64
            ReadProcessMemory(hProcess, heapFlagsAddress, &heapFlags, sizeof(DWORD), 0);
            ReadProcessMemory(hProcess, heapForceFlagsAddress, &heapForceFlags, sizeof(DWORD), 0);

            heapFlags &= HEAP_GROWABLE;
            heapForceFlags = 0;

            WriteProcessMemory(hProcess, heapFlagsAddress, &heapFlags, sizeof(DWORD), 0);
            WriteProcessMemory(hProcess, heapForceFlagsAddress, &heapForceFlags, sizeof(DWORD), 0);
        }
        else
        {
            myPEB.BeingDebugged = TRUE;
#ifndef _WIN64
            myPEB64.BeingDebugged = TRUE;
#endif
        }

        if(WriteProcessMemory(hProcess, AddressOfPEB, (void*)&myPEB, sizeof(PEB_CURRENT), &ueNumberOfBytesRead))
        {
#ifndef _WIN64
            if(AddressOfPEB64)
            {
                WriteProcessMemory(hProcess, AddressOfPEB64, (void*)&myPEB64, sizeof(PEB64), &ueNumberOfBytesRead);
            }
#endif
            return true;
        }
    }
    return false;
}

bool ChangeHideDebuggerState(HANDLE hProcess, DWORD PatchAPILevel, bool Hide)
{
    if(hProcess)
    {
        if(FixPebInProcess(hProcess, Hide))
        {
            if(PatchAPILevel == UE_HIDE_BASIC)
            {
#ifdef _WIN64
                FixAntidebugApiInProcess(hProcess, Hide, true);
#else
                FixAntidebugApiInProcess(hProcess, Hide, false);
#endif
            }
            return true;
        }
    }

    return false;
}

#ifndef _WIN64
bool IsThisProcessWow64()
{
    typedef BOOL (WINAPI * tIsWow64Process)(HANDLE hProcess, PBOOL Wow64Process);
    BOOL bIsWow64 = FALSE;
    tIsWow64Process fnIsWow64Process = (tIsWow64Process)GetProcAddress(GetModuleHandleA("kernel32.dll"), "IsWow64Process");

    if(fnIsWow64Process)
    {
        fnIsWow64Process(GetCurrentProcess(), &bIsWow64);
    }

    return (bIsWow64 != FALSE);
}
#endif


================================================
File: TitanEngine/Global.Engine.Hider.h
================================================
#ifndef _GLOBAL_ENGINE_HIDER_H
#define _GLOBAL_ENGINE_HIDER_H

bool ChangeHideDebuggerState(HANDLE hProcess, DWORD PatchAPILevel, bool Hide);
#ifndef _WIN64
bool IsThisProcessWow64();
#endif

#endif //_GLOBAL_ENGINE_HIDER_H


================================================
File: TitanEngine/Global.Engine.Hook.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Hook.h"
#include "Global.Debugger.h"

// Global.Engine.Hook.functions:
void EngineFakeLoadLibraryReturn()
{

    ULONG_PTR ParameterData;
    LPDEBUG_EVENT currentDBGEvent;
    HANDLE currentProcess;

    currentDBGEvent = (LPDEBUG_EVENT)GetDebugData();
    currentProcess = dbgProcessInformation.hProcess;
    if(currentProcess != NULL)
    {
#if !defined(_WIN64)
        ParameterData = (ULONG_PTR)GetFunctionParameter(currentProcess, UE_FUNCTION_STDCALL_RET, 1, UE_PARAMETER_DWORD);
        if(ParameterData != NULL)
        {
            if(engineFakeDLLHandle != NULL)
            {
                SetContextData(UE_EAX, engineFakeDLLHandle);
            }
            else
            {
                SetContextData(UE_EAX, 0x10000000);
            }
        }
#else
        ParameterData = (ULONG_PTR)GetFunctionParameter(currentProcess, UE_FUNCTION_FASTCALL, 1, UE_PARAMETER_QWORD);
        if(ParameterData != NULL)
        {
            if(engineFakeDLLHandle != NULL)
            {
                SetContextData(UE_RAX, engineFakeDLLHandle);
            }
            else
            {
                SetContextData(UE_RAX, 0x10000000);
            }
        }
#endif
    }
}

void EngineFakeGetProcAddressReturn()
{

    ULONG_PTR ParameterData;
    LPDEBUG_EVENT currentDBGEvent;
    HANDLE currentProcess;

    currentDBGEvent = (LPDEBUG_EVENT)GetDebugData();
    currentProcess = dbgProcessInformation.hProcess;
    if(currentProcess != NULL)
    {
#if !defined(_WIN64)
        ParameterData = (ULONG_PTR)GetFunctionParameter(currentProcess, UE_FUNCTION_STDCALL_RET, 1, UE_PARAMETER_DWORD);
        if(ParameterData != NULL)
        {
            SetContextData(UE_EAX, (ULONG_PTR)ImporterGetRemoteAPIAddress(currentProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitProcess")));
        }
#else
        ParameterData = (ULONG_PTR)GetFunctionParameter(currentProcess, UE_FUNCTION_FASTCALL, 1, UE_PARAMETER_QWORD);
        if(ParameterData != NULL)
        {
            SetContextData(UE_RAX, (ULONG_PTR)ImporterGetRemoteAPIAddress(currentProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitProcess")));
        }
#endif
    }
}


================================================
File: TitanEngine/Global.Engine.Hook.h
================================================
#ifndef _GLOBAL_ENGINE_HOOK_H
#define _GLOBAL_ENGINE_HOOK_H

void EngineFakeLoadLibraryReturn();
void EngineFakeGetProcAddressReturn();

#endif //_GLOBAL_ENGINE_HOOK_H


================================================
File: TitanEngine/Global.Engine.Importer.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Engine.Importer.h"
#include "Global.Debugger.h"
#include "Global.Mapping.h"

ULONG_PTR EngineGetProcAddressRemote(HANDLE hProcess, const wchar_t* szDLLName, const char* szAPIName)
{
    if(!hProcess) //no process specified
    {
        if(!dbgProcessInformation.hProcess)
            hProcess = GetCurrentProcess();
        else
            hProcess = dbgProcessInformation.hProcess;
    }
    DWORD cbNeeded = 0;
    if(EnumProcessModules(hProcess, 0, 0, &cbNeeded))
    {
        HMODULE* hMods = (HMODULE*)malloc(cbNeeded * sizeof(HMODULE));
        if(EnumProcessModules(hProcess, hMods, cbNeeded, &cbNeeded))
        {
            for(unsigned int i = 0; i < cbNeeded / sizeof(HMODULE); i++)
            {
                wchar_t szModuleName[MAX_PATH] = L"";
                if(GetModuleFileNameExW(hProcess, hMods[i], szModuleName, _countof(szModuleName)))
                {
                    wchar_t* dllName = wcsrchr(szModuleName, L'\\');
                    if(dllName)
                    {
                        dllName++;
                        if(!_wcsicmp(dllName, szDLLName))
                        {
                            HMODULE hModule = LoadLibraryExW(szModuleName, 0, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE);
                            if(hModule)
                            {
                                ULONG_PTR funcAddress = (ULONG_PTR)GetProcAddress(hModule, szAPIName);
                                if(funcAddress)
                                {
                                    funcAddress -= (ULONG_PTR)hModule; //rva
                                    FreeLibrary(hModule);
                                    return funcAddress + (ULONG_PTR)hMods[i]; //va
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        free(hMods);
    }
    return 0;
}

ULONG_PTR EngineGetProcAddressRemote(HANDLE hProcess, const char* szDLLName, const char* szAPIName)
{
    WCHAR uniDLLName[MAX_PATH] = {0};
    if(MultiByteToWideChar(CP_ACP, NULL, szDLLName, -1, uniDLLName, _countof(uniDLLName)))
    {
        return EngineGetProcAddressRemote(hProcess, uniDLLName, szAPIName);
    }
    else
    {
        return 0;
    }
}

ULONG_PTR EngineGetModuleBaseRemote(HANDLE hProcess, ULONG_PTR APIAddress)
{
    if(!hProcess) //no process specified
    {
        if(!dbgProcessInformation.hProcess)
            hProcess = GetCurrentProcess();
        else
            hProcess = dbgProcessInformation.hProcess;
    }
    DWORD cbNeeded = 0;
    if(EnumProcessModules(hProcess, 0, 0, &cbNeeded))
    {
        HMODULE* hMods = (HMODULE*)malloc(cbNeeded * sizeof(HMODULE));
        if(EnumProcessModules(hProcess, hMods, cbNeeded, &cbNeeded))
        {
            for(unsigned int i = 0; i < cbNeeded / sizeof(HMODULE); i++)
            {
                MODULEINFO modinfo;
                memset(&modinfo, 0, sizeof(MODULEINFO));
                if(GetModuleInformation(hProcess, hMods[i], &modinfo, sizeof(MODULEINFO)))
                {
                    ULONG_PTR start = (ULONG_PTR)hMods[i];
                    ULONG_PTR end = start + modinfo.SizeOfImage;
                    if(APIAddress >= start && APIAddress < end)
                        return start;
                }
            }
        }
        free(hMods);
    }
    return 0;
}

ULONG_PTR EngineGetModuleBaseRemote(HANDLE hProcess, const wchar_t* szDLLName)
{
    if(!hProcess) //no process specified
    {
        if(!dbgProcessInformation.hProcess)
            hProcess = GetCurrentProcess();
        else
            hProcess = dbgProcessInformation.hProcess;
    }
    DWORD cbNeeded = 0;
    if(EnumProcessModules(hProcess, 0, 0, &cbNeeded))
    {
        HMODULE* hMods = (HMODULE*)malloc(cbNeeded * sizeof(HMODULE));
        if(EnumProcessModules(hProcess, hMods, cbNeeded, &cbNeeded))
        {
            for(unsigned int i = 0; i < cbNeeded / sizeof(HMODULE); i++)
            {
                wchar_t szModuleName[MAX_PATH] = L"";
                if(GetModuleFileNameExW(hProcess, hMods[i], szModuleName, _countof(szModuleName)))
                {
                    wchar_t* dllName = wcsrchr(szModuleName, L'\\');
                    if(dllName)
                    {
                        dllName++;
                        if(!_wcsicmp(dllName, szDLLName))
                        {
                            return (ULONG_PTR)hMods[i];
                        }
                    }
                }
            }
        }
        free(hMods);
    }
    return 0;
}

ULONG_PTR EngineGetModuleBaseRemote(HANDLE hProcess, const char* szDLLName)
{
    WCHAR uniDLLName[MAX_PATH] = {0};
    if(MultiByteToWideChar(CP_ACP, NULL, szDLLName, -1, uniDLLName, _countof(uniDLLName)))
    {
        return EngineGetModuleBaseRemote(hProcess, szDLLName);
    }
    else
    {
        return 0;
    }
}

ULONG_PTR EngineGetAddressRemote(HANDLE hProcess, ULONG_PTR Address)
{
    HMODULE localModuleBase = (HMODULE)EngineGetModuleBaseRemote(GetCurrentProcess(), Address);
    if(localModuleBase)
    {
        wchar_t szModuleName[MAX_PATH] = L"";
        if(GetModuleFileNameExW(hProcess, localModuleBase, szModuleName, _countof(szModuleName)))
        {
            wchar_t* dllName = wcsrchr(szModuleName, L'\\');
            if(dllName)
            {
                dllName++;
                ULONG_PTR remoteModuleBase = EngineGetModuleBaseRemote(hProcess, dllName);
                if(remoteModuleBase)
                {
                    Address -= (ULONG_PTR)localModuleBase; //rva
                    return Address + remoteModuleBase;
                }
            }
        }
    }
    return 0;
}

ULONG_PTR EngineGetAddressLocal(HANDLE hProcess, ULONG_PTR Address)
{
    HMODULE remoteModuleBase = (HMODULE)EngineGetModuleBaseRemote(hProcess, Address);
    if(remoteModuleBase)
    {
        wchar_t szModuleName[MAX_PATH] = L"";
        if(GetModuleFileNameExW(hProcess, remoteModuleBase, szModuleName, _countof(szModuleName)))
        {
            wchar_t* dllName = wcsrchr(szModuleName, L'\\');
            if(dllName)
            {
                dllName++;
                ULONG_PTR localModuleBase = EngineGetModuleBaseRemote(GetCurrentProcess(), dllName);
                if(localModuleBase)
                {
                    Address -= (ULONG_PTR)remoteModuleBase; //rva
                    return Address + localModuleBase;
                }
            }
        }
    }
    return 0;
}

bool EngineGetAPINameRemote(HANDLE hProcess, ULONG_PTR APIAddress, char* APIName, DWORD APINameSize, DWORD* APINameSizeNeeded)
{
    if(!hProcess) //no process specified
    {
        if(!dbgProcessInformation.hProcess)
            hProcess = GetCurrentProcess();
        else
            hProcess = dbgProcessInformation.hProcess;
    }
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ModuleBase = EngineGetModuleBaseRemote(hProcess, APIAddress);
    if(!ModuleBase)
        return false;
    wchar_t szModulePath[MAX_PATH] = L"";
    if(!GetModuleFileNameExW(hProcess, (HMODULE)ModuleBase, szModulePath, _countof(szModulePath)))
        return false;
    if(MapFileExW(szModulePath, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, 0))
    {
        PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            ULONG_PTR ExportDirectoryVA;
            DWORD ExportDirectorySize;
            ULONG_PTR ImageBase;
            if(PEHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            {
                ImageBase = PEHeader32->OptionalHeader.ImageBase;
                ExportDirectoryVA = (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                ExportDirectorySize = (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
            }
            else //x64
            {
                ImageBase = (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase;
                ExportDirectoryVA = (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                ExportDirectorySize = (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
            }
            PIMAGE_EXPORT_DIRECTORY ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)ConvertVAtoFileOffset(FileMapVA, ExportDirectoryVA + ImageBase, true);
            if(ExportDirectory)
            {
                DWORD* AddrOfFunctions = (DWORD*)ConvertVAtoFileOffset(FileMapVA, ExportDirectory->AddressOfFunctions + ImageBase, true);
                DWORD* AddrOfNames = (DWORD*)ConvertVAtoFileOffset(FileMapVA, ExportDirectory->AddressOfNames + ImageBase, true);
                SHORT* AddrOfNameOrdinals = (SHORT*)ConvertVAtoFileOffset(FileMapVA, ExportDirectory->AddressOfNameOrdinals + ImageBase, true);
                if(AddrOfFunctions && AddrOfNames && AddrOfNameOrdinals)
                {
                    unsigned int NumberOfNames = ExportDirectory->NumberOfNames;
                    for(unsigned int i = 0; i < NumberOfNames; i++)
                    {
                        const char* curName = (const char*)ConvertVAtoFileOffset(FileMapVA, AddrOfNames[i] + ImageBase, true);
                        if(!curName)
                            continue;
                        unsigned int curRva = AddrOfFunctions[AddrOfNameOrdinals[i]];
                        if(curRva < ExportDirectoryVA || curRva >= ExportDirectoryVA + ExportDirectorySize) //non-forwarded exports
                        {
                            if(curRva + ModuleBase == APIAddress)
                            {
                                if(APIName && APINameSize > strlen(curName))
                                {
                                    strcpy(APIName, curName);
                                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                    return true;
                                }
                                if(APINameSizeNeeded)
                                {
                                    *APINameSizeNeeded = (DWORD)strlen(curName);
                                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    }
    return false;
}

DWORD EngineGetAPIOrdinalRemote(HANDLE hProcess, ULONG_PTR APIAddress)
{
    if(!hProcess) //no process specified
    {
        if(!dbgProcessInformation.hProcess)
            hProcess = GetCurrentProcess();
        else
            hProcess = dbgProcessInformation.hProcess;
    }
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ModuleBase = EngineGetModuleBaseRemote(hProcess, APIAddress);
    if(!ModuleBase)
        return 0;
    wchar_t szModulePath[MAX_PATH] = L"";
    if(!GetModuleFileNameExW(hProcess, (HMODULE)ModuleBase, szModulePath, _countof(szModulePath)))
        return 0;
    if(MapFileExW(szModulePath, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, 0))
    {
        PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            ULONG_PTR ExportDirectoryVA;
            DWORD ExportDirectorySize;
            ULONG_PTR ImageBase;
            if(PEHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            {
                ImageBase = PEHeader32->OptionalHeader.ImageBase;
                ExportDirectoryVA = (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                ExportDirectorySize = (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
            }
            else //x64
            {
                ImageBase = (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase;
                ExportDirectoryVA = (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                ExportDirectorySize = (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
            }
            PIMAGE_EXPORT_DIRECTORY ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)ConvertVAtoFileOffset(FileMapVA, ExportDirectoryVA + ImageBase, true);
            if(ExportDirectory)
            {
                DWORD* AddrOfFunctions = (DWORD*)ConvertVAtoFileOffset(FileMapVA, ExportDirectory->AddressOfFunctions + ImageBase, true);
                if(AddrOfFunctions)
                {
                    unsigned int NumberOfFunctions = ExportDirectory->NumberOfFunctions;
                    for(unsigned int i = 0, j = 0; i < NumberOfFunctions; i++)
                    {
                        unsigned int curRva = AddrOfFunctions[i];
                        if(!curRva)
                            continue;
                        j++; //ordinal
                        if(curRva < ExportDirectoryVA || curRva >= ExportDirectoryVA + ExportDirectorySize) //non-forwarded exports
                        {
                            if(curRva + ModuleBase == APIAddress)
                            {
                                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                return j;
                            }
                        }
                    }
                }
            }
        }
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    }
    return 0;
}



================================================
File: TitanEngine/Global.Engine.Importer.h
================================================
#ifndef _GLOBAL_ENGINE_IMPORTER_H
#define _GLOBAL_ENGINE_IMPORTER_H

//EngineGetProcAddressRemote
ULONG_PTR EngineGetProcAddressRemote(HANDLE hProcess, const wchar_t* szDLLName, const char* szAPIName);
ULONG_PTR EngineGetProcAddressRemote(HANDLE hProcess, const char* szDLLName, const char* szAPIName);
ULONG_PTR EngineGetModuleBaseRemote(HANDLE hProcess, ULONG_PTR APIAddress);
ULONG_PTR EngineGetModuleBaseRemote(HANDLE hProcess, const wchar_t* szDLLName);
ULONG_PTR EngineGetModuleBaseRemote(HANDLE hProcess, const char* szDLLName);
ULONG_PTR EngineGetAddressRemote(HANDLE hProcess, ULONG_PTR APIAddress);
ULONG_PTR EngineGetAddressLocal(HANDLE hProcess, ULONG_PTR APIAddress);
bool EngineGetAPINameRemote(HANDLE hProcess, ULONG_PTR APIAddress, char* APIName, DWORD APINameSize, DWORD* APINameSizeNeeded);
DWORD EngineGetAPIOrdinalRemote(HANDLE hProcess, ULONG_PTR APIAddress);

#endif //_GLOBAL_ENGINE_IMPORTER_H


================================================
File: TitanEngine/Global.Engine.Simplification.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Simplification.h"
#include "Global.Debugger.h"

// Global.Engine.Simplify
bool EngineUnpackerOptionLogData;
bool EngineUnpackerFileImporterInit;
bool EngineUnpackerOptionRealingFile;
bool EngineUnpackerOptionMoveOverlay;
bool EngineUnpackerOptionRelocationFix;
ULONG_PTR EngineUnpackerOptionUnpackedOEP;
wchar_t szEngineUnpackerInputFile[MAX_PATH];
wchar_t szEngineUnpackerOutputFile[MAX_PATH];
wchar_t szEngineUnpackerSnapShot1[MAX_PATH];
wchar_t szEngineUnpackerSnapShot2[MAX_PATH];
FILE_STATUS_INFO EngineUnpackerFileStatus = {};
LPPROCESS_INFORMATION pEngineUnpackerProcessHandle;
std::vector<UnpackerInformation> EngineUnpackerBreakInfo;

// Global.Engine.Simplification.functions:
void EngineSimplifyLoadLibraryCallBack()
{

    ULONG_PTR iParameter1;
    char szLogBufferData[MAX_PATH] = {};
    char szReadStringData[MAX_PATH] = {};
    ULONG_PTR CurrentBreakAddress = (ULONG_PTR)GetContextData(UE_CIP);

    if(!EngineUnpackerFileImporterInit)
    {
        EngineUnpackerFileImporterInit = true;
        /* broken since scylla integration but we dont care
        if(EngineUnpackerFileStatus.FileIsDLL)
        {
            ImporterInit(50 * 1024, (ULONG_PTR)GetDebuggedDLLBaseAddress());
        }
        else
        {
            ImporterInit(50 * 1024, (ULONG_PTR)GetDebuggedFileBaseAddress());
        }*/
    }
    for(int i = 0; i < (int)EngineUnpackerBreakInfo.size(); i++)
    {
        if(EngineUnpackerBreakInfo[i].BreakPointAddress == CurrentBreakAddress)
        {
            iParameter1 = (ULONG_PTR)GetContextData((DWORD)EngineUnpackerBreakInfo[i].Parameter1);
            if(EngineUnpackerBreakInfo[i].SingleBreak)
            {
                EngineUnpackerBreakInfo.erase(EngineUnpackerBreakInfo.begin() + i);
            }
            if(GetRemoteString(pEngineUnpackerProcessHandle->hProcess, (void*)iParameter1, &szReadStringData[0], MAX_PATH))
            {
                ImporterAddNewDll(szReadStringData, (ULONG_PTR)GetContextData((DWORD)EngineUnpackerBreakInfo[i].Parameter2));
                if(EngineUnpackerOptionLogData)
                {
                    wsprintfA(szLogBufferData, "[x] LoadLibrary BPX -> %s", szReadStringData);
                    EngineAddUnpackerWindowLogMessage(szLogBufferData);
                }
            }
            break;
        }
    }
}

void EngineSimplifyGetProcAddressCallBack()
{

    ULONG_PTR iParameter1;
    char szLogBufferData[MAX_PATH] = {};
    char szReadStringData[MAX_PATH] = {};
    ULONG_PTR CurrentBreakAddress = (ULONG_PTR)GetContextData(UE_CIP);

    for(int i = 0; i < (int)EngineUnpackerBreakInfo.size(); i++)
    {
        if(EngineUnpackerBreakInfo[i].BreakPointAddress == CurrentBreakAddress)
        {
            iParameter1 = (ULONG_PTR)GetContextData((DWORD)EngineUnpackerBreakInfo[i].Parameter1);
            if(EngineUnpackerBreakInfo[i].SingleBreak)
            {
                EngineUnpackerBreakInfo.erase(EngineUnpackerBreakInfo.begin() + i);
            }
            if(EngineUnpackerFileStatus.FileIsDLL)
            {
                if(iParameter1 > (ULONG_PTR)GetDebuggedDLLBaseAddress())
                {
                    if(GetRemoteString(pEngineUnpackerProcessHandle->hProcess, (void*)iParameter1, &szReadStringData[0], MAX_PATH))
                    {
                        ImporterAddNewAPI(szReadStringData, (ULONG_PTR)GetContextData((DWORD)EngineUnpackerBreakInfo[i].Parameter2));
                        if(EngineUnpackerOptionLogData)
                        {
                            wsprintfA(szLogBufferData, "[x] GetProcAddress BPX -> %s", szReadStringData);
                            EngineAddUnpackerWindowLogMessage(szLogBufferData);
                        }
                    }
                }
                else
                {
                    ImporterAddNewOrdinalAPI(iParameter1, (ULONG_PTR)GetContextData((DWORD)EngineUnpackerBreakInfo[i].Parameter2));
                    if(EngineUnpackerOptionLogData)
                    {
                        wsprintfA(szLogBufferData, "[x] GetProcAddress BPX -> %08X", iParameter1);
                        EngineAddUnpackerWindowLogMessage(szLogBufferData);
                    }
                }
            }
            else
            {
                if(iParameter1 > (ULONG_PTR)GetDebuggedFileBaseAddress())
                {
                    if(GetRemoteString(pEngineUnpackerProcessHandle->hProcess, (void*)iParameter1, &szReadStringData[0], MAX_PATH))
                    {
                        ImporterAddNewAPI(szReadStringData, (ULONG_PTR)GetContextData((DWORD)EngineUnpackerBreakInfo[i].Parameter2));
                        if(EngineUnpackerOptionLogData)
                        {
                            wsprintfA(szLogBufferData, "[x] GetProcAddress BPX -> %s", szReadStringData);
                            EngineAddUnpackerWindowLogMessage(szLogBufferData);
                        }
                    }
                }
                else
                {
                    ImporterAddNewOrdinalAPI(iParameter1, (ULONG_PTR)GetContextData((DWORD)EngineUnpackerBreakInfo[i].Parameter2));
                    if(EngineUnpackerOptionLogData)
                    {
                        wsprintfA(szLogBufferData, "[x] GetProcAddress BPX -> %08X", iParameter1);
                        EngineAddUnpackerWindowLogMessage(szLogBufferData);
                    }
                }
            }
            break;
        }
    }
}

void EngineSimplifyMakeSnapshotCallBack()
{

    ULONG_PTR fdLoadedBase;
    wchar_t szTempName[MAX_PATH] = {};
    wchar_t szTempFolder[MAX_PATH] = {};
    ULONG_PTR CurrentBreakAddress = (ULONG_PTR)GetContextData(UE_CIP);

    if(EngineUnpackerFileStatus.FileIsDLL)
    {
        fdLoadedBase = (ULONG_PTR)GetDebuggedDLLBaseAddress();
    }
    else
    {
        fdLoadedBase = (ULONG_PTR)GetDebuggedFileBaseAddress();
    }
    for(int i = 0; i < (int)EngineUnpackerBreakInfo.size(); i++)
    {
        if(EngineUnpackerBreakInfo[i].BreakPointAddress == CurrentBreakAddress)
        {
            if(EngineUnpackerBreakInfo[i].SnapShotNumber == 1)
            {
                if(GetTempPathW(MAX_PATH, szTempFolder) < MAX_PATH)
                {
                    if(GetTempFileNameW(szTempFolder, L"OverlayTemp", GetTickCount() + 101, szTempName))
                    {
                        lstrcpyW(szEngineUnpackerSnapShot1, szTempName);
                        RelocaterMakeSnapshotW(pEngineUnpackerProcessHandle->hProcess, szEngineUnpackerSnapShot1, (void*)(EngineUnpackerBreakInfo[i].Parameter1 + fdLoadedBase), EngineUnpackerBreakInfo[i].Parameter2);
                    }
                }
            }
            else
            {
                if(GetTempPathW(MAX_PATH, szTempFolder) < MAX_PATH)
                {
                    if(GetTempFileNameW(szTempFolder, L"OverlayTemp", GetTickCount() + 201, szTempName))
                    {
                        lstrcpyW(szEngineUnpackerSnapShot2, szTempName);
                        RelocaterMakeSnapshotW(pEngineUnpackerProcessHandle->hProcess, szEngineUnpackerSnapShot2, (void*)(EngineUnpackerBreakInfo[i].Parameter1 + fdLoadedBase), EngineUnpackerBreakInfo[i].Parameter2);
                    }
                }
            }
            return;
        }
    }
}

void EngineSimplifyEntryPointCallBack()
{

    int i = 0;
    int j = 0;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    HANDLE FileHandle;
    long mImportTableOffset;
    long mRelocTableOffset;
    DWORD pOverlayStart;
    DWORD pOverlaySize;
    ULONG_PTR fdLoadedBase;
    char szLogBufferData[MAX_PATH] = {};
    wchar_t szTempFolder[MAX_PATH] = {};
    wchar_t szTempName[MAX_PATH] = {};

    __try
    {
        if(EngineUnpackerOptionUnpackedOEP == NULL)
        {
            EngineUnpackerOptionUnpackedOEP = (ULONG_PTR)GetContextData(UE_CIP);
        }
        if(EngineUnpackerOptionLogData)
        {
            wsprintfA(szLogBufferData, "[x] Entry Point at: %08X", EngineUnpackerOptionUnpackedOEP);
            EngineAddUnpackerWindowLogMessage(szLogBufferData);
        }
        if(EngineUnpackerFileStatus.FileIsDLL)
        {
            fdLoadedBase = (ULONG_PTR)GetDebuggedDLLBaseAddress();
            RelocaterInit(100 * 1024, (ULONG_PTR)GetPE32DataW(szEngineUnpackerInputFile, NULL, UE_IMAGEBASE), fdLoadedBase);
            for(i = 0; i < (int)EngineUnpackerBreakInfo.size(); i++)
            {
                if(EngineUnpackerBreakInfo[i].SnapShotNumber == 1)
                {
                    j = i;
                }
            }
            if(szEngineUnpackerSnapShot2[0] == 0x00)
            {
                if(GetTempPathW(MAX_PATH, szTempFolder) < MAX_PATH)
                {
                    if(GetTempFileNameW(szTempFolder, L"OverlayTemp", GetTickCount() + 301, szTempName))
                    {
                        lstrcpyW(szEngineUnpackerSnapShot2, szTempName);
                        RelocaterMakeSnapshotW(pEngineUnpackerProcessHandle->hProcess, szEngineUnpackerSnapShot2, (void*)(EngineUnpackerBreakInfo[j].Parameter1 + fdLoadedBase), EngineUnpackerBreakInfo[j].Parameter2);
                    }
                }
            }
            RelocaterCompareTwoSnapshotsW(pEngineUnpackerProcessHandle->hProcess, fdLoadedBase, (ULONG_PTR)GetPE32DataW(szEngineUnpackerInputFile, NULL, UE_SIZEOFIMAGE), szEngineUnpackerSnapShot1, szEngineUnpackerSnapShot2, EngineUnpackerBreakInfo[j].Parameter1 + fdLoadedBase);
            EngineUnpackerOptionRelocationFix = true;
        }
        else
        {
            fdLoadedBase = (ULONG_PTR)GetDebuggedFileBaseAddress();
        }
        if(PastePEHeaderW(pEngineUnpackerProcessHandle->hProcess, (void*)fdLoadedBase, szEngineUnpackerInputFile))
        {
            if(EngineUnpackerOptionLogData)
            {
                EngineAddUnpackerWindowLogMessage("[x] Paste PE header");
            }
        }
        DumpProcessW(pEngineUnpackerProcessHandle->hProcess, (void*)fdLoadedBase, szEngineUnpackerOutputFile, EngineUnpackerOptionUnpackedOEP);
        if(EngineUnpackerOptionLogData)
        {
            EngineAddUnpackerWindowLogMessage("[x] Process dumped!");
        }
        mImportTableOffset = AddNewSectionW(szEngineUnpackerOutputFile, ".TEv2", ImporterEstimatedSize() + 200) + (DWORD)fdLoadedBase;
        if(EngineUnpackerOptionRelocationFix)
        {
            if(EngineUnpackerFileStatus.FileIsDLL)
            {
                mRelocTableOffset = AddNewSectionW(szEngineUnpackerOutputFile, ".TEv2", RelocaterEstimatedSize() + 200);
            }
        }
        if(StaticFileLoadW(szEngineUnpackerOutputFile, UE_ACCESS_ALL, false, &FileHandle, &FileSize, &FileMap, &FileMapVA))
        {
            if(ImporterExportIAT((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, mImportTableOffset, true), FileMapVA, FileHandle))
            {
                if(EngineUnpackerOptionLogData)
                {
                    EngineAddUnpackerWindowLogMessage("[x] IAT has been fixed!");
                }
            }
            if(EngineUnpackerOptionRelocationFix)
            {
                if(EngineUnpackerFileStatus.FileIsDLL)
                {
                    RelocaterExportRelocation((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, mRelocTableOffset + fdLoadedBase, true), mRelocTableOffset, FileMapVA);
                    if(EngineUnpackerOptionLogData)
                    {
                        EngineAddUnpackerWindowLogMessage("[x] Exporting relocations!");
                    }
                }
            }
            if(EngineUnpackerOptionRealingFile)
            {
                FileSize = RealignPE(FileMapVA, FileSize, 2);
                if(EngineUnpackerOptionLogData)
                {
                    EngineAddUnpackerWindowLogMessage("[x] Realigning file!");
                }
            }
            StaticFileUnloadW(szEngineUnpackerOutputFile, false, FileHandle, FileSize, FileMap, FileMapVA);
            MakeAllSectionsRWEW(szEngineUnpackerOutputFile);
            if(EngineUnpackerFileStatus.FileIsDLL)
            {
                if(RelocaterChangeFileBaseW(szEngineUnpackerOutputFile, (ULONG_PTR)GetPE32DataW(szEngineUnpackerInputFile, NULL, UE_IMAGEBASE)))
                {
                    if(EngineUnpackerOptionLogData)
                    {
                        EngineAddUnpackerWindowLogMessage("[x] Rebase file image!");
                    }
                }
            }
            if(EngineUnpackerOptionMoveOverlay && FindOverlayW(szEngineUnpackerInputFile, &pOverlayStart, &pOverlaySize))
            {
                CopyOverlayW(szEngineUnpackerInputFile, szEngineUnpackerOutputFile);
                if(EngineUnpackerOptionLogData)
                {
                    EngineAddUnpackerWindowLogMessage("[x] Moving overlay to unpacked file!");
                }
            }
            StopDebug();
            if(EngineUnpackerOptionLogData)
            {
                EngineAddUnpackerWindowLogMessage("[Success] File has been unpacked!");
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ForceClose();
        //broken since scylla integration but we dont care
        //ImporterCleanup();
        if(FileMapVA > NULL)
        {
            StaticFileUnloadW(szEngineUnpackerOutputFile, false, FileHandle, FileSize, FileMap, FileMapVA);
        }
        DeleteFileW(szEngineUnpackerOutputFile);
        if(EngineUnpackerOptionLogData)
        {
            EngineAddUnpackerWindowLogMessage("[Fatal Unpacking Error] Please mail file you tried to unpack to ReversingLabs Corporation!");
        }
    }
    if(EngineUnpackerOptionLogData)
    {
        EngineAddUnpackerWindowLogMessage("-> Unpack ended...");
    }
}


================================================
File: TitanEngine/Global.Engine.Simplification.h
================================================
#ifndef _GLOBAL_ENGINE_SIMPLIFICATION_H
#define _GLOBAL_ENGINE_SIMPLIFICATION_H

#include <vector>

extern bool EngineUnpackerOptionLogData;
extern bool EngineUnpackerFileImporterInit;
extern bool EngineUnpackerOptionRealingFile;
extern bool EngineUnpackerOptionMoveOverlay;
extern bool EngineUnpackerOptionRelocationFix;
extern ULONG_PTR EngineUnpackerOptionUnpackedOEP;
extern wchar_t szEngineUnpackerInputFile[MAX_PATH];
extern wchar_t szEngineUnpackerOutputFile[MAX_PATH];
extern wchar_t szEngineUnpackerSnapShot1[MAX_PATH];
extern wchar_t szEngineUnpackerSnapShot2[MAX_PATH];
extern FILE_STATUS_INFO EngineUnpackerFileStatus;
extern LPPROCESS_INFORMATION pEngineUnpackerProcessHandle;
extern std::vector<UnpackerInformation> EngineUnpackerBreakInfo;

void EngineSimplifyLoadLibraryCallBack();
void EngineSimplifyGetProcAddressCallBack();
void EngineSimplifyMakeSnapshotCallBack();
void EngineSimplifyEntryPointCallBack();

#endif //_GLOBAL_ENGINE_SIMPLIFICATION_H


================================================
File: TitanEngine/Global.Engine.Threading.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Threading.h"

CRITICAL_SECTION CriticalSectionLocker::locks[LockLast] = {};
bool CriticalSectionLocker::bInitDone = false;

void CriticalSectionLocker::Initialize()
{
    if(bInitDone)
        return;
    for(int i = 0; i < LockLast; i++)
        InitializeCriticalSection(&locks[i]);
    bInitDone = true;
}

void CriticalSectionLocker::Deinitialize()
{
    if(!bInitDone)
        return;
    for(int i = 0; i < LockLast; i++)
    {
        EnterCriticalSection(&locks[i]); //obtain ownership
        DeleteCriticalSection(&locks[i]);
    }
    bInitDone = false;
}

CriticalSectionLocker::CriticalSectionLocker(CriticalSectionLock lock)
{
    Initialize(); //initialize critical sections
    gLock = lock;

    EnterCriticalSection(&locks[gLock]);
    Locked = true;
}

CriticalSectionLocker::~CriticalSectionLocker()
{
    if(Locked)
        LeaveCriticalSection(&locks[gLock]);
}

void CriticalSectionLocker::unlock()
{
    Locked = false;
    LeaveCriticalSection(&locks[gLock]);
}

void CriticalSectionLocker::relock()
{
    EnterCriticalSection(&locks[gLock]);
    Locked = true;
}


================================================
File: TitanEngine/Global.Engine.Threading.h
================================================
#ifndef _GLOBAL_ENGINE_THREADING_H
#define _GLOBAL_ENGINE_THREADING_H

#define GetSTInTOPStackFromStatusWord(StatusWord) ((StatusWord & 0x3800) >> 11)
#define Getx87r0PositionInRegisterArea(STInTopStack) ((8 - STInTopStack) % 8)
#define Calculatex87registerPositionInRegisterArea(x87r0_position, index) (((x87r0_position + index) % 8))
#define GetRegisterAreaOf87register(register_area, x87r0_position, index) (((char *) register_area) + 10 * Calculatex87registerPositionInRegisterArea(x87r0_position, index) )
#define GetSTValueFromIndex(x87r0_position, index) ((x87r0_position + index) % 8)

enum CriticalSectionLock
{
    LockBreakPointBuffer,
    LockMemoryProtection,
    LockLast
};

class CriticalSectionLocker
{
public:
    static void Deinitialize();
    CriticalSectionLocker(CriticalSectionLock lock);
    ~CriticalSectionLocker();
    void unlock();
    void relock();

private:
    static void Initialize();
    static bool bInitDone;
    static CRITICAL_SECTION locks[LockLast];

    CriticalSectionLock gLock;
    bool Locked;
};

#endif //_GLOBAL_ENGINE_THREADING_H


================================================
File: TitanEngine/Global.Engine.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Handle.h"
#include "Global.Mapping.h"
#include "Global.Engine.Hash.h"
#include "Global.Debugger.h"

bool engineCheckForwarders = true;
bool engineAlowModuleLoading = false;
bool engineCreatePathForFiles = true; // hardcoded
bool engineBackupForCriticalFunctions = true;
bool engineResumeProcessIfNoThreadIsActive = false;
bool engineResetCustomHandler = true;
bool engineRemoveConsoleForDebugee = false;
bool enginePassAllExceptions = true;
bool engineAutoHideFromDebugger = false; // hardcoded
bool engineEnableDebugPrivilege = false;
bool engineSafeAttach = false;
bool engineMembpAlt = false;
bool engineDisableAslr = false;
bool engineSafeStep = true;

char engineFoundDLLName[512] = {0};
char engineFoundAPIName[512] = {0};
wchar_t engineExtractedFileNameW[512] = {0};
HMODULE engineHandle;
LPVOID engineExitThreadOneShootCallBack = NULL;
LPVOID engineDependencyFiles;
LPVOID engineDependencyFilesCWP;
void* EngineStartUnpackingCallBack;

// Global.Engine.functions:
void EngineInit()
{
    HashInit();
}

bool EngineIsThereFreeHardwareBreakSlot(LPDWORD FreeRegister)
{
    if(DebugRegister[0].DrxEnabled == false)
    {
        if(FreeRegister != NULL)
        {
            *FreeRegister = UE_DR0;
        }
        return true;
    }
    else if(DebugRegister[1].DrxEnabled == false)
    {
        if(FreeRegister != NULL)
        {
            *FreeRegister = UE_DR1;
        }
        return true;
    }
    else if(DebugRegister[2].DrxEnabled == false)
    {
        if(FreeRegister != NULL)
        {
            *FreeRegister = UE_DR2;
        }
        return true;
    }
    else if(DebugRegister[3].DrxEnabled == false)
    {
        if(FreeRegister != NULL)
        {
            *FreeRegister = UE_DR3;
        }
        return true;
    }
    return false;
}

bool EngineFileExists(char* szFileName)
{

    HANDLE hFile = CreateFileA(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        EngineCloseHandle(hFile);
        return true;
    }
    else
    {
        return false;
    }
}

void EngineCreatePathForFile(char* szFileName)
{
    int len = lstrlenA(szFileName);
    while(szFileName[len] != '\\' && len)
        len--;
    char szFolderName[MAX_PATH] = "";
    lstrcpyA(szFolderName, szFileName);
    if(len)
        szFolderName[len + 1] = '\0';
    else //just a filename
        return;
    lstrcatA(szFolderName, "\\");
    len = lstrlenA(szFolderName);
    char szCreateFolder[MAX_PATH] = "";
    for(int i = 3; i < len; i++)
    {
        if(szFolderName[i] == '\\')
        {
            lstrcpyA(szCreateFolder, szFolderName);
            szCreateFolder[i] = '\0';
            CreateDirectoryA(szCreateFolder, 0);
        }
    }
}

void EngineCreatePathForFileW(wchar_t* szFileName)
{
    int len = lstrlenW(szFileName);
    while(szFileName[len] != L'\\' && len)
        len--;
    wchar_t szFolderName[MAX_PATH] = L"";
    lstrcpyW(szFolderName, szFileName);
    if(len)
        szFolderName[len + 1] = L'\0';
    else //just a filename
        return;
    len = lstrlenW(szFolderName);
    wchar_t szCreateFolder[MAX_PATH] = L"";
    for(int i = 3; i < len; i++)
    {
        if(szFolderName[i] == '\\')
        {
            lstrcpyW(szCreateFolder, szFolderName);
            szCreateFolder[i] = '\0';
            CreateDirectoryW(szCreateFolder, 0);
        }
    }
}

wchar_t* EngineExtractFileNameW(wchar_t* szFileName)
{

    int i;
    int j;
    int x = 0;

    i = lstrlenW(szFileName);
    RtlZeroMemory(&engineExtractedFileNameW, sizeof engineExtractedFileNameW);
    while(i > 0 && szFileName[i] != 0x5C)
    {
        i--;
    }
    if(szFileName[i] == 0x5C)
    {
        int len = lstrlenW(szFileName);
        for(j = i + 1; j <= len; j++)
        {
            engineExtractedFileNameW[x] = szFileName[j];
            x++;
        }
    }
    else
    {
        return(szFileName);
    }
    return(engineExtractedFileNameW);
}

bool EngineIsPointedMemoryString(ULONG_PTR PossibleStringPtr)
{

    bool StringIsValid = true;
    unsigned int i = 512;
    MEMORY_BASIC_INFORMATION MemInfo = {0};
    DWORD MaxDisassmSize = 512;
    BYTE TestChar;

    VirtualQueryEx(GetCurrentProcess(), (LPVOID)PossibleStringPtr, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
    if(MemInfo.State == MEM_COMMIT)
    {
        if((ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize - PossibleStringPtr <= 512)
        {
            MaxDisassmSize = (DWORD)((ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize - PossibleStringPtr - 1);
            VirtualQueryEx(GetCurrentProcess(), (LPVOID)(PossibleStringPtr + (ULONG_PTR)MemInfo.RegionSize), &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
            if(MemInfo.State != MEM_COMMIT)
            {
                i = MaxDisassmSize;
            }
            else
            {
                MaxDisassmSize = 512;
            }
        }
        else
        {
            MaxDisassmSize = 512;
        }

        TestChar = *((BYTE*)PossibleStringPtr);
        while(i > NULL && StringIsValid == true && TestChar != 0x00)
        {
            TestChar = *((BYTE*)PossibleStringPtr);

            if(TestChar < ' ' || TestChar > '~') //is inside the lower-ascii range
            {
                if(TestChar != 0x00)
                {
                    StringIsValid = false;
                }
            }
            PossibleStringPtr++;
            i--;
        }
        if(StringIsValid == true && MaxDisassmSize - i > 4)
        {
            return true;
        }
    }
    return false;
}

int EnginePointedMemoryStringLength(ULONG_PTR PossibleStringPtr)
{

    bool StringIsValid = true;
    unsigned int i = 512;
    MEMORY_BASIC_INFORMATION MemInfo;
    DWORD MaxDisassmSize = 512;
    BYTE TestChar;

    VirtualQueryEx(GetCurrentProcess(), (LPVOID)PossibleStringPtr, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
    if(MemInfo.State == MEM_COMMIT)
    {
        if((ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize - PossibleStringPtr <= 512)
        {
            MaxDisassmSize = (DWORD)((ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize - PossibleStringPtr - 1);
            VirtualQueryEx(GetCurrentProcess(), (LPVOID)(PossibleStringPtr + (ULONG_PTR)MemInfo.RegionSize), &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
            if(MemInfo.State != MEM_COMMIT)
            {
                i = MaxDisassmSize;
            }
        }

        TestChar = *((BYTE*)PossibleStringPtr);
        while(i > NULL && StringIsValid == true && TestChar != 0x00)
        {
            TestChar = *((BYTE*)PossibleStringPtr);

            if(TestChar < 32 || TestChar > 126)
            {
                if(TestChar != 0x00)
                {
                    StringIsValid = false;
                }
            }
            PossibleStringPtr++;
            i--;
        }
        if(StringIsValid == true && 512 - i > 4)
        {
            i = 512 - i;
            return(i);
        }
    }
    return(NULL);
}

bool EngineCompareResourceString(wchar_t* String1, wchar_t* String2)
{

    PMEMORY_COMPARE_HANDLER memData = (PMEMORY_COMPARE_HANDLER)String1;
    wchar_t StringCmp[MAX_PATH] = {};

    String1 = (wchar_t*)((ULONG_PTR)String1 + 2);
    RtlMoveMemory(&StringCmp[0], &String1[0], memData->Array.wArrayEntry[0] * 2);
    if(lstrcmpiW(StringCmp, String2) == NULL)
    {
        return true;
    }
    return false;
}

ULONG_PTR EngineEstimateNewSectionRVA(ULONG_PTR FileMapVA)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD NewSectionVirtualOffset = 0;
    DWORD SectionNumber = 0;
    BOOL FileIs64;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        if(PEHeader32->OptionalHeader.Magic == 0x10B)
        {
            FileIs64 = false;
        }
        else if(PEHeader32->OptionalHeader.Magic == 0x20B)
        {
            FileIs64 = true;
        }
        else
        {
            return(0);
        }

        if(!FileIs64)
        {
            PESections = IMAGE_FIRST_SECTION(PEHeader32);
            SectionNumber = PEHeader32->FileHeader.NumberOfSections;
            __try
            {
                PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                NewSectionVirtualOffset = PESections->VirtualAddress + (PESections->Misc.VirtualSize / PEHeader32->OptionalHeader.SectionAlignment) * PEHeader32->OptionalHeader.SectionAlignment;
                if(NewSectionVirtualOffset < PESections->VirtualAddress + PESections->Misc.VirtualSize)
                {
                    NewSectionVirtualOffset = NewSectionVirtualOffset + PEHeader32->OptionalHeader.SectionAlignment;
                }
                return((ULONG_PTR)(NewSectionVirtualOffset + PEHeader32->OptionalHeader.ImageBase));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return(0);
            }
        }
        else
        {
            PESections = IMAGE_FIRST_SECTION(PEHeader64);
            SectionNumber = PEHeader64->FileHeader.NumberOfSections;
            __try
            {
                PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                NewSectionVirtualOffset = PESections->VirtualAddress + (PESections->Misc.VirtualSize / PEHeader64->OptionalHeader.SectionAlignment) * PEHeader64->OptionalHeader.SectionAlignment;
                if(NewSectionVirtualOffset < PESections->VirtualAddress + PESections->Misc.VirtualSize)
                {
                    NewSectionVirtualOffset = NewSectionVirtualOffset + PEHeader32->OptionalHeader.SectionAlignment;
                }
                return((ULONG_PTR)(NewSectionVirtualOffset + PEHeader64->OptionalHeader.ImageBase));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return(0);
            }
        }
    }
    return(0);
}

bool EngineExtractForwarderData(ULONG_PTR PossibleStringPtr, LPVOID szFwdDLLName, LPVOID szFwdAPIName)
{

    __try
    {
        LPVOID lpPossibleStringPtr = (LPVOID)PossibleStringPtr;
        BYTE TestChar;

        TestChar = *((BYTE*)PossibleStringPtr);

        while(TestChar != 0x2E && TestChar != 0x00)
        {
            TestChar = *((BYTE*)PossibleStringPtr);
            PossibleStringPtr++;
        }
        if(TestChar == 0x00)
        {
            return false;
        }
        PossibleStringPtr--;
        RtlCopyMemory(szFwdDLLName, lpPossibleStringPtr, PossibleStringPtr - (ULONG_PTR)lpPossibleStringPtr);
        lstrcatA((LPSTR)szFwdDLLName, ".dll");
        lpPossibleStringPtr = (LPVOID)(PossibleStringPtr + 1);
        TestChar = *((BYTE*)PossibleStringPtr);

        if(TestChar == 0x23)
        {
            lpPossibleStringPtr = (LPVOID)(PossibleStringPtr + 1);
        }
        while(TestChar != 0x00)
        {
            TestChar = *((BYTE*)PossibleStringPtr);
            PossibleStringPtr++;
        }
        RtlCopyMemory(szFwdAPIName, lpPossibleStringPtr, PossibleStringPtr - (ULONG_PTR)lpPossibleStringPtr);
        return true;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return false;
    }
}

bool EngineGrabDataFromMappedFile(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR FileOffset, DWORD CopySize, LPVOID CopyToMemory)
{
    DWORD rfNumberOfBytesRead = NULL;

    RtlZeroMemory(CopyToMemory, CopySize);
    SetFilePointer(hFile, (DWORD)(FileOffset - FileMapVA), NULL, FILE_BEGIN);
    return !!ReadFile(hFile, CopyToMemory, CopySize, &rfNumberOfBytesRead, NULL);
}

bool EngineExtractResource(char* szResourceName, wchar_t* szExtractedFileName)
{

    HRSRC hResource;
    HGLOBAL hResourceGlobal;
    DWORD ResourceSize;
    LPVOID ResourceData;
    DWORD NumberOfBytesWritten;
    HANDLE hFile;

    hResource = FindResourceA(engineHandle, (LPCSTR)szResourceName, "BINARY");
    if(hResource != NULL)
    {
        hResourceGlobal = LoadResource(engineHandle, hResource);
        if(hResourceGlobal != NULL)
        {
            ResourceSize = SizeofResource(engineHandle, hResource);
            ResourceData = LockResource(hResourceGlobal);
            EngineCreatePathForFileW(szExtractedFileName);
            hFile = CreateFileW(szExtractedFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                if(WriteFile(hFile, ResourceData, ResourceSize, &NumberOfBytesWritten, NULL))
                {
                    EngineCloseHandle(hFile);
                    return true;
                }
                EngineCloseHandle(hFile);
            }
        }
    }
    return false;
}

bool EngineIsDependencyPresent(char* szFileName, char* szDependencyForFile, char* szPresentInFolder)
{
    int i, j;
    HANDLE hFile;
    char szTryFileName[512] = {0};

    if(szPresentInFolder != NULL && szFileName != NULL)
    {
        lstrcpyA(szTryFileName, szPresentInFolder);
        if(szTryFileName[lstrlenA(szTryFileName) - 1] != 0x5C)
        {
            szTryFileName[lstrlenA(szTryFileName)] = 0x5C;
        }
        lstrcatA(szTryFileName, szFileName);
        hFile = CreateFileA(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            EngineCloseHandle(hFile);
            return true;
        }
    }

    if(szFileName != NULL)
    {
        hFile = CreateFileA(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            EngineCloseHandle(hFile);
            return true;
        }
        if(GetSystemDirectoryA(szTryFileName, 512) > NULL)
        {
            lstrcatA(szTryFileName, "\\");
            lstrcatA(szTryFileName, szFileName);
            hFile = CreateFileA(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                EngineCloseHandle(hFile);
                return true;
            }
        }
        if(GetWindowsDirectoryA(szTryFileName, 512) > NULL)
        {
            lstrcatA(szTryFileName, "\\");
            lstrcatA(szTryFileName, szFileName);
            hFile = CreateFileA(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                EngineCloseHandle(hFile);
                return true;
            }
        }
        if(szDependencyForFile != NULL)
        {
            RtlZeroMemory(&szTryFileName, 512);
            i = lstrlenA(szDependencyForFile);
            while(i > 0 && szDependencyForFile[i] != 0x5C)
            {
                i--;
            }
            for(j = 0; j <= i; j++)
            {
                szTryFileName[j] = szDependencyForFile[j];
            }
            lstrcatA(szTryFileName, szFileName);
            hFile = CreateFileA(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                EngineCloseHandle(hFile);
                return true;
            }
        }
    }
    return false;
}

bool EngineIsDependencyPresentW(wchar_t* szFileName, wchar_t* szDependencyForFile, wchar_t* szPresentInFolder)
{

    int i, j;
    HANDLE hFile;
    wchar_t szTryFileName[512] = {0};

    if(szPresentInFolder != NULL)
    {
        lstrcpyW(szTryFileName, szPresentInFolder);
        if(szTryFileName[lstrlenW(szTryFileName) - 1] != 0x5C)
        {
            szTryFileName[lstrlenW(szTryFileName)] = 0x5C;
        }
        lstrcatW(szTryFileName, szFileName);
        hFile = CreateFileW(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            EngineCloseHandle(hFile);
            return true;
        }
    }
    if(szFileName != NULL)
    {
        hFile = CreateFileW(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            EngineCloseHandle(hFile);
            return true;
        }
        if(GetSystemDirectoryW(szTryFileName, 512) > NULL)
        {
            lstrcatW(szTryFileName, L"\\");
            lstrcatW(szTryFileName, szFileName);
            hFile = CreateFileW(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                EngineCloseHandle(hFile);
                return true;
            }
        }

        if(GetWindowsDirectoryW(szTryFileName, 512) > NULL)
        {
            lstrcatW(szTryFileName, L"\\");
            lstrcatW(szTryFileName, szFileName);
            hFile = CreateFileW(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                EngineCloseHandle(hFile);
                return true;
            }
        }

        if(szDependencyForFile != NULL)
        {
            i = lstrlenW(szDependencyForFile);
            while(i > 0 && szDependencyForFile[i] != 0x5C)
            {
                i--;
            }
            for(j = 0; j <= i; j++)
            {
                szTryFileName[j] = szDependencyForFile[j];
            }
            lstrcatW(szTryFileName, szFileName);
            hFile = CreateFileW(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                EngineCloseHandle(hFile);
                return true;
            }
        }
    }
    return false;
}

bool EngineGetDependencyLocation(char* szFileName, char* szDependencyForFile, void* szLocationOfTheFile, int MaxStringSize)
{
    wchar_t uniFileName[MAX_PATH] = {0};
    wchar_t uniDependencyForFile[MAX_PATH] = {0};
    wchar_t* uniLocationOfTheFile = (WCHAR*)malloc(sizeof(WCHAR) * MaxStringSize);

    MultiByteToWideChar(CP_ACP, NULL, szFileName, -1, uniFileName, _countof(uniFileName));
    MultiByteToWideChar(CP_ACP, NULL, szDependencyForFile, -1, uniDependencyForFile, _countof(uniDependencyForFile));
    if(EngineGetDependencyLocationW(uniFileName, uniDependencyForFile, uniLocationOfTheFile, MaxStringSize))
    {
        bool retVal = (WideCharToMultiByte(CP_ACP, NULL, uniLocationOfTheFile, -1, (char*)szLocationOfTheFile, MaxStringSize, NULL, NULL) != 0);
        free(uniLocationOfTheFile);
        return retVal;
    }

    return false;
}

bool EngineGetDependencyLocationW(wchar_t* szFileName, wchar_t* szDependencyForFile, void* szLocationOfTheFile, int MaxStringSize)
{

    int i, j;
    HANDLE hFile;
    wchar_t szTryFileName[512] = {0};

    if(szFileName != NULL)
    {
        RtlZeroMemory(szLocationOfTheFile, MaxStringSize * sizeof(WCHAR));

        hFile = CreateFileW(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            if((int)wcslen(szFileName) <= MaxStringSize)
            {
                RtlCopyMemory(szLocationOfTheFile, szFileName, wcslen(szFileName) * sizeof(WCHAR));
            }
            EngineCloseHandle(hFile);
            return true;
        }
        if(GetSystemDirectoryW(szTryFileName, _countof(szTryFileName)) > NULL)
        {
            wcscat(szTryFileName, L"\\");
            wcscat(szTryFileName, szFileName);
            hFile = CreateFileW(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                if((int)wcslen(szTryFileName) <= MaxStringSize)
                {
                    RtlCopyMemory(szLocationOfTheFile, &szTryFileName, wcslen(szTryFileName) * sizeof(WCHAR));
                }
                EngineCloseHandle(hFile);
                return true;
            }
        }
        if(GetWindowsDirectoryW(szTryFileName, _countof(szTryFileName)) > NULL)
        {
            wcscat(szTryFileName, L"\\");
            wcscat(szTryFileName, szFileName);
            hFile = CreateFileW(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                if((int)wcslen(szTryFileName) <= MaxStringSize)
                {
                    RtlCopyMemory(szLocationOfTheFile, &szTryFileName, wcslen(szTryFileName) * sizeof(WCHAR));
                }
                EngineCloseHandle(hFile);
                return true;
            }
        }
        if(szDependencyForFile != NULL)
        {
            RtlZeroMemory(szTryFileName, sizeof(szTryFileName));
            i = (int)wcslen(szDependencyForFile);
            while(i > 0 && szDependencyForFile[i] != L'\\')
            {
                i--;
            }
            for(j = 0; j <= i; j++)
            {
                szTryFileName[j] = szDependencyForFile[j];
            }
            wcscat(szTryFileName, szFileName);
            hFile = CreateFileW(szTryFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                if((int)wcslen(szTryFileName) <= MaxStringSize)
                {
                    RtlCopyMemory(szLocationOfTheFile, &szTryFileName, wcslen(szTryFileName) * sizeof(WCHAR));
                }
                EngineCloseHandle(hFile);
                return true;
            }
        }
    }
    return false;
}

long EngineHashString(char* szStringToHash)
{

    int i = NULL;
    DWORD HashValue = NULL;

    if(szStringToHash != NULL)
    {
        const int strl = lstrlenA(szStringToHash);
        for(i = 0; i < strl; i++)
        {
            HashValue = (((HashValue << 7) | (HashValue >> (32 - 7))) ^ szStringToHash[i]);
        }
    }
    return(HashValue);
}

long EngineHashMemory(char* MemoryAddress, int MemorySize, DWORD InitialHashValue)
{

    int i = NULL;
    DWORD HashValue = InitialHashValue;

    for(i = 0; i < MemorySize; i++)
    {
        if(MemoryAddress[i] != NULL)
        {
            HashValue = (((HashValue << 7) | (HashValue >> (32 - 7))) ^ MemoryAddress[i]);
        }
    }
    return(HashValue);
}

bool EngineIsValidReadPtrEx(LPVOID DataPointer, DWORD DataSize)
{

    MEMORY_BASIC_INFORMATION MemInfo = {0};

    while(DataSize > NULL)
    {
        VirtualQuery(DataPointer, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        if(MemInfo.AllocationProtect == MEM_FREE || MemInfo.AllocationProtect == MEM_PRIVATE)
        {
            return false;
        }
        DataPointer = (LPVOID)((ULONG_PTR)DataPointer + MemInfo.RegionSize);
        if(MemInfo.RegionSize > DataSize)
        {
            DataSize = NULL;
        }
        else
        {
            DataSize = DataSize - (DWORD)MemInfo.RegionSize;
        }
    }
    return true;
}

bool EngineValidateResource(HMODULE hModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR lParam)
{
    HRSRC hResource;
    HGLOBAL hResourceGlobal;
    DWORD ResourceSize;
    LPVOID ResourceData;
    BYTE ReturnData = UE_FIELD_FIXABLE_CRITICAL;

    hResource = FindResourceA(hModule, (LPCSTR)lpszName, (LPCSTR)lpszType);
    if(hResource != NULL) //FindResourceA didn't fail
    {
        hResourceGlobal = LoadResource(hModule, hResource);
        if(hResourceGlobal != NULL) //LoadResource didn't fail
        {
            ResourceSize = SizeofResource(hModule, hResource);
            ResourceData = LockResource(hResourceGlobal);
            if(ResourceData != NULL) //LockResource didn't fail
            {
                if(EngineIsValidReadPtrEx(ResourceData, ResourceSize)) //ResourceData is a valid read pointer
                {
                    return true;
                }
            }
        }
    }
    *((LONG*)lParam) = ReturnData;
    return false;
}

bool EngineValidateHeader(ULONG_PTR FileMapVA, HANDLE hFileProc, LPVOID ImageBase, PIMAGE_DOS_HEADER DOSHeader, bool IsFile)
{
    MODULEINFO ModuleInfo;
    DWORD PESize, MaxPESize;
    PIMAGE_NT_HEADERS PEHeader;
    IMAGE_NT_HEADERS RemotePEHeader;
    ULONG_PTR NumberOfBytesRW = NULL;

    if(IsFile)
    {
        if(hFileProc == NULL)
        {
            PESize = 0;
            MaxPESize = ULONG_MAX;
        }
        else
        {
            PESize = GetFileSize(hFileProc, NULL);
            MaxPESize = PESize;
        }
        __try
        {
            if(DOSHeader->e_magic == IMAGE_DOS_SIGNATURE)
            {
                DWORD LfaNew = DOSHeader->e_lfanew;
                if((PESize == 0 || (LfaNew < PESize && LfaNew + sizeof(IMAGE_NT_SIGNATURE) + sizeof(IMAGE_FILE_HEADER) < PESize)) &&
                        MaxPESize != 0 &&
                        LfaNew < (MaxPESize - sizeof(IMAGE_NT_SIGNATURE) - sizeof(IMAGE_FILE_HEADER)))
                {
                    PEHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DOSHeader + LfaNew);
                    return PEHeader->Signature == IMAGE_NT_SIGNATURE;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
    else
    {
        RtlZeroMemory(&ModuleInfo, sizeof MODULEINFO);
        GetModuleInformation(hFileProc, (HMODULE)ImageBase, &ModuleInfo, sizeof(MODULEINFO));
        PESize = ModuleInfo.SizeOfImage;
        __try
        {
            if(DOSHeader->e_magic == IMAGE_DOS_SIGNATURE)
            {
                DWORD LfaNew = DOSHeader->e_lfanew;
                if((LfaNew < PESize && LfaNew + sizeof(IMAGE_NT_SIGNATURE) + sizeof(IMAGE_FILE_HEADER) < PESize) &&
                        LfaNew < (PESize - sizeof(IMAGE_NT_SIGNATURE) - sizeof(IMAGE_FILE_HEADER)))
                {
                    if(ReadProcessMemory(hFileProc, (LPVOID)((ULONG_PTR)ImageBase + LfaNew), &RemotePEHeader, sizeof(IMAGE_NT_HEADERS), &NumberOfBytesRW))
                    {
                        PEHeader = (PIMAGE_NT_HEADERS)&RemotePEHeader;
                        return PEHeader->Signature == IMAGE_NT_SIGNATURE;
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
    return false;
}

ULONG_PTR EngineSimulateNtLoaderW(wchar_t* szFileName)
{

    DWORD PeHeaderSize;
    LPVOID AllocatedFile;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    DWORD SectionRawOffset = 0;
    DWORD SectionRawSize = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return(NULL);
            }
            if(!FileIs64)
            {
                AllocatedFile = VirtualAlloc(NULL, PEHeader32->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_READWRITE);
                __try
                {
                    PeHeaderSize = DOSHeader->e_lfanew + PEHeader32->FileHeader.SizeOfOptionalHeader + (sizeof(IMAGE_SECTION_HEADER) * PEHeader32->FileHeader.NumberOfSections) + sizeof(IMAGE_FILE_HEADER) + 4;
                    PESections = IMAGE_FIRST_SECTION(PEHeader32);
                    SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                    RtlCopyMemory(AllocatedFile, (LPVOID)FileMapVA, PeHeaderSize);
                    while(SectionNumber > 0)
                    {
                        RtlCopyMemory((LPVOID)((ULONG_PTR)AllocatedFile + PESections->VirtualAddress), (LPVOID)(FileMapVA + PESections->PointerToRawData), PESections->SizeOfRawData);
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    VirtualFree(AllocatedFile, NULL, MEM_RELEASE);
                    AllocatedFile = NULL;
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return((ULONG_PTR)AllocatedFile);
            }
            else
            {
                AllocatedFile = VirtualAlloc(NULL, PEHeader64->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_READWRITE);
                __try
                {
                    PeHeaderSize = DOSHeader->e_lfanew + PEHeader64->FileHeader.SizeOfOptionalHeader + (sizeof(IMAGE_SECTION_HEADER) * PEHeader64->FileHeader.NumberOfSections) + sizeof(IMAGE_FILE_HEADER) + 4;
                    PESections = IMAGE_FIRST_SECTION(PEHeader64);
                    SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                    RtlCopyMemory(AllocatedFile, (LPVOID)FileMapVA, PeHeaderSize);
                    while(SectionNumber > 0)
                    {
                        RtlCopyMemory((LPVOID)((ULONG_PTR)AllocatedFile + PESections->VirtualAddress), (LPVOID)(FileMapVA + PESections->PointerToRawData), PESections->SizeOfRawData);
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    VirtualFree(AllocatedFile, NULL, MEM_RELEASE);
                    AllocatedFile = NULL;
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return((ULONG_PTR)AllocatedFile);
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return(NULL);
        }
    }
    return(NULL);
}

ULONG_PTR EngineSimulateNtLoader(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {0};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, -1, uniFileName, _countof(uniFileName));
        return(EngineSimulateNtLoaderW(uniFileName));
    }
    else
    {
        return(NULL);
    }
}

ULONG_PTR EngineSimulateDllLoader(HANDLE hProcess, char* szFileName)
{
    WCHAR uniFileName[MAX_PATH] = {0};

    if(hProcess && szFileName)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, -1, uniFileName, _countof(uniFileName));
        return EngineSimulateDllLoaderW(hProcess, uniFileName);
    }

    return 0;
}

ULONG_PTR EngineSimulateDllLoaderW(HANDLE hProcess, wchar_t* szFileName)
{
    int n;
    BOOL FileIs64;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    HANDLE FileHandle;
    LPVOID DLLMemory = NULL;
    DWORD ExportDelta = NULL;
    DWORD PEHeaderSize = NULL;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    PEXPORTED_DATA ExportedFunctionNames;
    ULONG_PTR ConvertedExport = NULL;
    WCHAR szFileRemoteProc[1024] = {0};
    WCHAR szDLLFileLocation[512] = {0};
    WCHAR* szTranslatedProcName = 0;

    GetProcessImageFileNameW(hProcess, szFileRemoteProc, _countof(szFileRemoteProc));

    szTranslatedProcName = (WCHAR*)TranslateNativeNameW(szFileRemoteProc);
    if(EngineIsDependencyPresentW(szFileName, NULL, NULL))
    {
        if(EngineGetDependencyLocationW(szFileName, szTranslatedProcName, &szDLLFileLocation, _countof(szDLLFileLocation)))
        {
            VirtualFree((void*)szTranslatedProcName, NULL, MEM_RELEASE);
            if(MapFileExW(szDLLFileLocation, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
            {
                DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
                if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
                {
                    PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                    PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                    if(PEHeader32->OptionalHeader.Magic == 0x10B)
                    {
                        PEHeaderSize = PEHeader32->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER + PEHeader32->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER) + 4;
                        FileIs64 = false;
                    }
                    else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                    {
                        PEHeaderSize = PEHeader64->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER + PEHeader64->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER) + 4;
                        FileIs64 = true;
                    }
                    else
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return(NULL);
                    }
                    if(!FileIs64)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                        {
                            DLLMemory = VirtualAlloc(NULL, DOSHeader->e_lfanew + PEHeaderSize + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size + 0x1000, MEM_COMMIT, PAGE_READWRITE);
                            if(DLLMemory != NULL)
                            {
                                __try
                                {
                                    if((DOSHeader->e_lfanew + PEHeaderSize) % 0x1000 != 0) //SectionAlignment, the default value is the page size for the system.
                                    {
                                        ExportDelta = (((DOSHeader->e_lfanew + PEHeaderSize) / 0x1000) + 1) * 0x1000;
                                    }
                                    else
                                    {
                                        ExportDelta = (DOSHeader->e_lfanew + PEHeaderSize); //multiple of 0x1000
                                    }
                                    ConvertedExport = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, PEHeader32->OptionalHeader.ImageBase, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, true, true);
                                    if(ConvertedExport != NULL)
                                    {
                                        PEExports = (PIMAGE_EXPORT_DIRECTORY)((ULONG_PTR)DLLMemory + ExportDelta);
                                        RtlCopyMemory(DLLMemory, (LPVOID)FileMapVA, PEHeaderSize + DOSHeader->e_lfanew);
                                        RtlCopyMemory((LPVOID)((ULONG_PTR)DLLMemory + ExportDelta), (LPVOID)ConvertedExport, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);
                                        PEExports->AddressOfFunctions = PEExports->AddressOfFunctions - PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        PEExports->AddressOfNameOrdinals = PEExports->AddressOfNameOrdinals - PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        PEExports->AddressOfNames = PEExports->AddressOfNames - PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        PEExports->Name = PEExports->Name - PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        ExportedFunctionNames = (PEXPORTED_DATA)(PEExports->AddressOfNames + (ULONG_PTR)DLLMemory);
                                        for(n = 0; n < (int)PEExports->NumberOfNames; n++)
                                        {
                                            ExportedFunctionNames->ExportedItem = ExportedFunctionNames->ExportedItem - PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                            ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + 4);
                                        }
                                        DOSHeader = (PIMAGE_DOS_HEADER)DLLMemory;
                                        PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = ExportDelta;
                                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                        return((ULONG_PTR)DLLMemory);
                                    }
                                    else
                                    {
                                        VirtualFree(DLLMemory, NULL, MEM_RELEASE);
                                    }
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    VirtualFree(DLLMemory, NULL, MEM_RELEASE);
                                }
                            }
                        }
                    }
                    else
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                        {
                            DLLMemory = VirtualAlloc(NULL, DOSHeader->e_lfanew + PEHeaderSize + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size + 0x1000, MEM_COMMIT, PAGE_READWRITE);
                            if(DLLMemory != NULL)
                            {
                                __try
                                {
                                    if((DOSHeader->e_lfanew + PEHeaderSize) % 0x1000 != 0) //SectionAlignment, the default value is the page size for the system.
                                    {
                                        ExportDelta = (((DOSHeader->e_lfanew + PEHeaderSize) / 0x1000) + 1) * 0x1000;
                                    }
                                    else
                                    {
                                        ExportDelta = (DOSHeader->e_lfanew + PEHeaderSize); //multiple of 0x1000
                                    }
                                    ConvertedExport = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, true, true);
                                    if(ConvertedExport != NULL)
                                    {
                                        PEExports = (PIMAGE_EXPORT_DIRECTORY)((ULONG_PTR)DLLMemory + ExportDelta);
                                        RtlCopyMemory(DLLMemory, (LPVOID)FileMapVA, PEHeaderSize + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);
                                        RtlCopyMemory((LPVOID)((ULONG_PTR)DLLMemory + ExportDelta), (LPVOID)ConvertedExport, PEHeaderSize + DOSHeader->e_lfanew);
                                        PEExports->AddressOfFunctions = PEExports->AddressOfFunctions - PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        PEExports->AddressOfNameOrdinals = PEExports->AddressOfNameOrdinals - PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        PEExports->AddressOfNames = PEExports->AddressOfNames - PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        PEExports->Name = PEExports->Name - PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                        ExportedFunctionNames = (PEXPORTED_DATA)(PEExports->AddressOfNames + (ULONG_PTR)DLLMemory);
                                        for(n = 0; n < (int)PEExports->NumberOfNames; n++)
                                        {
                                            ExportedFunctionNames->ExportedItem = ExportedFunctionNames->ExportedItem - PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + ExportDelta;
                                            ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + 4);
                                        }
                                        DOSHeader = (PIMAGE_DOS_HEADER)DLLMemory;
                                        PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = ExportDelta;
                                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                        return((ULONG_PTR)DLLMemory);
                                    }
                                    else
                                    {
                                        VirtualFree(DLLMemory, NULL, MEM_RELEASE);
                                    }
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    VirtualFree(DLLMemory, NULL, MEM_RELEASE);
                                }
                            }
                        }
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                }
            }
        }
    }
    VirtualFree((void*)szTranslatedProcName, NULL, MEM_RELEASE);
    return(NULL);
}

ULONG_PTR EngineGetProcAddress(ULONG_PTR ModuleBase, char* szAPIName)
{

    int i = 0;
    int j = 0;
    ULONG_PTR APIFoundAddress = 0;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    PEXPORTED_DATA ExportedFunctions;
    PEXPORTED_DATA ExportedFunctionNames;
    PEXPORTED_DATA_WORD ExportedFunctionOrdinals;
    bool FileIs64 = false;

    APIFoundAddress = (ULONG_PTR)GetProcAddress((HMODULE)ModuleBase, szAPIName);

    if(APIFoundAddress == 0)
    {
        __try
        {
            DOSHeader = (PIMAGE_DOS_HEADER)ModuleBase;
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return(NULL);
            }
            if(!FileIs64)
            {
                PEExports = (PIMAGE_EXPORT_DIRECTORY)(ModuleBase + (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
                ExportedFunctions = (PEXPORTED_DATA)(ModuleBase + (ULONG_PTR)PEExports->AddressOfFunctions);
                ExportedFunctionNames = (PEXPORTED_DATA)(ModuleBase + (ULONG_PTR)PEExports->AddressOfNames);
                ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(ModuleBase + (ULONG_PTR)PEExports->AddressOfNameOrdinals);
            }
            else
            {
                PEExports = (PIMAGE_EXPORT_DIRECTORY)(ModuleBase + (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
                ExportedFunctions = (PEXPORTED_DATA)(ModuleBase + (ULONG_PTR)PEExports->AddressOfFunctions);
                ExportedFunctionNames = (PEXPORTED_DATA)(ModuleBase + (ULONG_PTR)PEExports->AddressOfNames);
                ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(ModuleBase + (ULONG_PTR)PEExports->AddressOfNameOrdinals);
            }
            for(j = 0; j < (int)PEExports->NumberOfNames; j++)
            {
                if(lstrcmpiA((LPCSTR)szAPIName, (LPCSTR)(ModuleBase + (ULONG_PTR)ExportedFunctionNames->ExportedItem)) == NULL)
                {
                    ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)((ULONG_PTR)ExportedFunctionOrdinals + j * 2);
                    ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + (ExportedFunctionOrdinals->OrdinalNumber) * 4);
                    APIFoundAddress = ExportedFunctions->ExportedItem + (ULONG_PTR)ModuleBase;
                    return((ULONG_PTR)APIFoundAddress);
                }
                ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + 4);
            }
            return(NULL);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else
    {
        return APIFoundAddress;
    }
}

bool EngineGetLibraryOrdinalData(ULONG_PTR ModuleBase, LPDWORD ptrOrdinalBase, LPDWORD ptrOrdinalCount)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    bool FileIs64 = false;

    __try
    {
        DOSHeader = (PIMAGE_DOS_HEADER)ModuleBase;
        PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        if(PEHeader32->OptionalHeader.Magic == 0x10B)
        {
            FileIs64 = false;
        }
        else if(PEHeader32->OptionalHeader.Magic == 0x20B)
        {
            FileIs64 = true;
        }
        else
        {
            return false;
        }
        if(!FileIs64)
        {
            PEExports = (PIMAGE_EXPORT_DIRECTORY)(ModuleBase + (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
            *ptrOrdinalBase = PEExports->Base;
            *ptrOrdinalCount = PEExports->NumberOfNames;
        }
        else
        {
            PEExports = (PIMAGE_EXPORT_DIRECTORY)(ModuleBase + (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
            *ptrOrdinalBase = PEExports->Base;
            *ptrOrdinalCount = PEExports->NumberOfNames;
        }
        return true;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return false;
    }
    return false;
}

ULONG_PTR EngineGlobalAPIHandler(HANDLE handleProcess, ULONG_PTR EnumedModulesBases, ULONG_PTR APIAddress, const char* szAPIName, DWORD ReturnType)
{

    unsigned int i = 0;
    unsigned int j = 0;
    unsigned int n = 0;
    unsigned int x = 0;
    unsigned int y = 0;
    unsigned int z = 0;
    DWORD Dummy = NULL;
    HANDLE hProcess = NULL;
    ULONG_PTR EnumeratedModules[0x1000] = {0};
    ULONG_PTR LoadedModules[1000][4] = {0};
    char RemoteDLLName[MAX_PATH] = {0};
    char FullRemoteDLLName[MAX_PATH] = {0};
    char szWindowsSideBySide[MAX_PATH] = {0};
    char szWindowsSideBySideCmp[MAX_PATH] = {0};
    char szWindowsKernelBase[MAX_PATH] = {0};
    HANDLE hLoadedModule = NULL;
    HANDLE ModuleHandle = NULL;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    PEXPORTED_DATA ExportedFunctions;
    PEXPORTED_DATA ExportedFunctionNames;
    PEXPORTED_DATA_WORD ExportedFunctionOrdinals;
    ULONG_PTR APIFoundAddress = NULL;
    MODULEINFO RemoteModuleInfo;
    bool ValidateHeader = false;
    bool FileIs64 = false;
    bool APINameFound = false;
    bool SkipModule = false;
    unsigned int FoundIndex = 0;
    unsigned int FoundOrdinalNumber = 0;
    ULONG_PTR FileMapVA;
    char szFwdDLLName[512] = {0};
    char szFwdAPIName[512] = {0};
    ULONG_PTR RealignedAPIAddress;
    ULONG_PTR ForwarderData = NULL;
    unsigned int ClosestAPI = 0x1000;
    int Vista64UserForwarderFix = 0;
    unsigned int Windows7KernelBase = 0xFFFFFFFF;

    GetWindowsDirectoryA(szWindowsSideBySide, MAX_PATH);
    lstrcpyA(szWindowsKernelBase, szWindowsSideBySide);
    lstrcatA(szWindowsSideBySide, "\\WinSxS");
    if(EnumedModulesBases != NULL)
    {
        RtlMoveMemory(EnumeratedModules, (LPVOID)EnumedModulesBases, 0x1000);
        i--;
    }
    if(handleProcess == NULL)
    {
        if(dbgProcessInformation.hProcess == NULL)
        {
            hProcess = GetCurrentProcess();
        }
        else
        {
            hProcess = dbgProcessInformation.hProcess;
        }
    }
    else
    {
        hProcess = handleProcess;
    }
    if(EnumedModulesBases != NULL || EnumProcessModules(hProcess, (HMODULE*)EnumeratedModules, sizeof(EnumeratedModules), &Dummy))
    {
        i++;
        z = i;
        y = i;
        while(EnumeratedModules[y] != NULL)
        {
            // Vista x64 fix
            if(Vista64UserForwarderFix == NULL)
            {
                GetModuleBaseNameA(hProcess, (HMODULE)EnumeratedModules[y], (LPSTR)RemoteDLLName, MAX_PATH);
                if(!lstrcmpiA(RemoteDLLName, "user32.dll"))
                    Vista64UserForwarderFix = y;
                //NOTE: this code is used to ignore all APIs inside kernelbase.dll
                else if(!lstrcmpiA(RemoteDLLName, "kernelbase.dll"))
                {
                    GetModuleFileNameExA(hProcess, (HMODULE)EnumeratedModules[y], (LPSTR)RemoteDLLName, MAX_PATH);
                    RemoteDLLName[lstrlenA(szWindowsKernelBase)] = 0x00;
                    if(lstrcmpiA(RemoteDLLName, szWindowsKernelBase) == NULL)
                    {
                        Windows7KernelBase = y;
                    }
                }
            }
            y++;
        }
        while(APINameFound == false && EnumeratedModules[i] != NULL)
        {
            //NOTE: un-comment when kernelbase should be ignored
            /*if(i == Windows7KernelBase)
            {
                i++;
                if(EnumeratedModules[i] == NULL)
                {
                    break;
                }
            }*/
            ValidateHeader = false;
            RtlZeroMemory(&RemoteDLLName, MAX_PATH);
            GetModuleFileNameExA(hProcess, (HMODULE)EnumeratedModules[i], (LPSTR)RemoteDLLName, MAX_PATH);
            lstrcpyA(FullRemoteDLLName, RemoteDLLName);
            RtlZeroMemory(&szWindowsSideBySideCmp, MAX_PATH);
            RtlCopyMemory(&szWindowsSideBySideCmp, FullRemoteDLLName, lstrlenA(szWindowsSideBySide));
            if(GetModuleHandleA(RemoteDLLName) == NULL)
            {
                RtlZeroMemory(&RemoteDLLName, MAX_PATH);
                GetModuleBaseNameA(hProcess, (HMODULE)EnumeratedModules[i], (LPSTR)RemoteDLLName, MAX_PATH);
                if(GetModuleHandleA(RemoteDLLName) == NULL || lstrcmpiA(szWindowsSideBySideCmp, szWindowsSideBySide) == NULL)
                {
                    if(engineAlowModuleLoading)
                    {
                        hLoadedModule = LoadLibraryA(FullRemoteDLLName);
                        if(hLoadedModule != NULL)
                        {
                            LoadedModules[i][0] = EnumeratedModules[i];
                            LoadedModules[i][1] = (ULONG_PTR)hLoadedModule;
                            LoadedModules[i][2] = 1;
                        }
                    }
                    else
                    {
                        hLoadedModule = (HANDLE)EngineSimulateDllLoader(hProcess, FullRemoteDLLName);
                        if(hLoadedModule != NULL)
                        {
                            LoadedModules[i][0] = EnumeratedModules[i];
                            LoadedModules[i][1] = (ULONG_PTR)hLoadedModule;
                            LoadedModules[i][2] = 1;
                            ValidateHeader = true;
                        }
                    }
                }
                else
                {
                    LoadedModules[i][0] = EnumeratedModules[i];
                    LoadedModules[i][1] = (ULONG_PTR)GetModuleHandleA(RemoteDLLName);
                    LoadedModules[i][2] = 0;
                }
            }
            else
            {
                LoadedModules[i][0] = EnumeratedModules[i];
                LoadedModules[i][1] = (ULONG_PTR)GetModuleHandleA(RemoteDLLName);
                LoadedModules[i][2] = 0;
            }


            if(ReturnType != UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLNAME && ReturnType != UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLINDEX && ReturnType != UE_OPTION_IMPORTER_RETURN_FORWARDER_APINAME)
            {
                if(szAPIName == NULL && ReturnType == UE_OPTION_IMPORTER_REALIGN_APIADDRESS)
                {
                    RtlZeroMemory(&RemoteModuleInfo, sizeof MODULEINFO);
                    //GetModuleInformation(GetCurrentProcess(), (HMODULE)LoadedModules[i][1], &RemoteModuleInfo, sizeof MODULEINFO);
                    GetModuleInformation(hProcess, (HMODULE)LoadedModules[i][0], &RemoteModuleInfo, sizeof MODULEINFO);
                    if(APIAddress >= LoadedModules[i][1] && APIAddress <= LoadedModules[i][1] + RemoteModuleInfo.SizeOfImage)
                    {
                        GetModuleBaseNameA(hProcess, (HMODULE)LoadedModules[i][0], (LPSTR)engineFoundDLLName, 512);
                        APIFoundAddress = (ULONG_PTR)(APIAddress - LoadedModules[i][1] + LoadedModules[i][0]);
                        APINameFound = true;
                        FoundIndex = i;
                        break;
                    }
                }
                else if(szAPIName == NULL && ReturnType == UE_OPTION_IMPORTER_REALIGN_LOCAL_APIADDRESS)
                {
                    RtlZeroMemory(&RemoteModuleInfo, sizeof MODULEINFO);
                    GetModuleInformation(hProcess, (HMODULE)LoadedModules[i][0], &RemoteModuleInfo, sizeof MODULEINFO);
                    if(APIAddress >= LoadedModules[i][0] && APIAddress <= LoadedModules[i][0] + RemoteModuleInfo.SizeOfImage)
                    {
                        GetModuleBaseNameA(hProcess, (HMODULE)LoadedModules[i][0], (LPSTR)engineFoundDLLName, 512);
                        APIFoundAddress = (ULONG_PTR)(APIAddress - LoadedModules[i][0] + LoadedModules[i][1]);
                        APINameFound = true;
                        FoundIndex = i;
                        break;
                    }
                }
                else if(szAPIName == NULL && ReturnType == UE_OPTION_IMPORTER_RETURN_DLLBASE)
                {
                    if(APIAddress == LoadedModules[i][1])
                    {
                        APIFoundAddress = LoadedModules[i][0];
                        APINameFound = true;
                        FoundIndex = i;
                        break;
                    }
                }
                else if(ReturnType == UE_OPTION_IMPORTER_RETURN_NEAREST_APIADDRESS || ReturnType == UE_OPTION_IMPORTER_RETURN_NEAREST_APINAME)
                {
                    RtlZeroMemory(&RemoteModuleInfo, sizeof MODULEINFO);
                    GetModuleInformation(hProcess, (HMODULE)LoadedModules[i][0], &RemoteModuleInfo, sizeof MODULEINFO);
                    if(APIAddress >= LoadedModules[i][0] && APIAddress <= LoadedModules[i][0] + RemoteModuleInfo.SizeOfImage)
                    {
                        DOSHeader = (PIMAGE_DOS_HEADER)LoadedModules[i][1];
                        if(ValidateHeader || EngineValidateHeader((ULONG_PTR)LoadedModules[i][1], GetCurrentProcess(), RemoteModuleInfo.lpBaseOfDll, DOSHeader, false))
                        {
                            __try
                            {
                                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                                if(PEHeader32->OptionalHeader.Magic == 0x10B)
                                {
                                    FileIs64 = false;
                                }
                                else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                                {
                                    FileIs64 = true;
                                }
                                else
                                {
                                    return(NULL);
                                }
                                if(!FileIs64)
                                {
                                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                                    ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                                }
                                else
                                {
                                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                                    ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                                }
                                for(n = 0; n < PEExports->NumberOfFunctions; n++)  //NumberOfNames
                                {
                                    if(APIAddress - (ExportedFunctions->ExportedItem + LoadedModules[i][0]) < ClosestAPI)
                                    {
                                        ClosestAPI = (unsigned int)(APIAddress - (ExportedFunctions->ExportedItem + LoadedModules[i][0]));
                                        ExportedFunctionNames = (PEXPORTED_DATA)(PEExports->AddressOfNames + LoadedModules[i][1]);
                                        ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(PEExports->AddressOfNameOrdinals + LoadedModules[i][1]);
                                        GetModuleBaseNameA(hProcess, (HMODULE)LoadedModules[i][0], (LPSTR)engineFoundDLLName, 512);
                                        RtlZeroMemory(&engineFoundAPIName, sizeof(engineFoundAPIName));
                                        x = n;
                                        FoundOrdinalNumber = (unsigned int)PEExports->Base;
                                        for(j = 0; j < PEExports->NumberOfNames; j++)
                                        {
                                            if(ExportedFunctionOrdinals->OrdinalNumber != x)
                                            {
                                                ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)((ULONG_PTR)ExportedFunctionOrdinals + 2);
                                            }
                                            else
                                            {
                                                FoundOrdinalNumber = FoundOrdinalNumber + (unsigned int)ExportedFunctionOrdinals->OrdinalNumber;
                                                break;
                                            }
                                        }
                                        ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + j * 4);
                                        if(EngineIsPointedMemoryString((ULONG_PTR)(ExportedFunctionNames->ExportedItem + LoadedModules[i][1])))
                                        {
                                            lstrcpyA((LPSTR)engineFoundAPIName, (LPCSTR)(ExportedFunctionNames->ExportedItem + LoadedModules[i][1]));
                                        }
                                        APIFoundAddress = ExportedFunctions->ExportedItem + LoadedModules[i][0];
                                        APINameFound = true;
                                        FoundIndex = i;
                                    }
                                    ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + 4);
                                }
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                ClosestAPI = 0x1000;
                                APINameFound = false;
                            }
                        }
                    }
                }

                if((ReturnType == UE_OPTION_IMPORTER_RETURN_API_ORDINAL_NUMBER || (ReturnType > UE_OPTION_IMPORTER_REALIGN_APIADDRESS && ReturnType < UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLNAME)) && ReturnType != UE_OPTION_IMPORTER_RETURN_DLLBASE && LoadedModules[i][1] != NULL)
                {
                    RtlZeroMemory(&RemoteModuleInfo, sizeof MODULEINFO);
                    DOSHeader = (PIMAGE_DOS_HEADER)LoadedModules[i][1];
                    //GetModuleInformation(GetCurrentProcess(), (HMODULE)LoadedModules[i][1], &RemoteModuleInfo, sizeof MODULEINFO);
                    GetModuleInformation(hProcess, (HMODULE)LoadedModules[i][0], &RemoteModuleInfo, sizeof MODULEINFO);
                    if(APIAddress >= LoadedModules[i][0] && APIAddress <= LoadedModules[i][0] + RemoteModuleInfo.SizeOfImage)
                    {
                        if(ValidateHeader || EngineValidateHeader((ULONG_PTR)LoadedModules[i][1], GetCurrentProcess(), RemoteModuleInfo.lpBaseOfDll, DOSHeader, false))
                        {
                            __try
                            {
                                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                                if(PEHeader32->OptionalHeader.Magic == 0x10B)
                                {
                                    FileIs64 = false;
                                }
                                else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                                {
                                    FileIs64 = true;
                                }
                                else
                                {
                                    return(NULL);
                                }
                                if(!FileIs64)
                                {
                                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                                    ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                                    ExportedFunctionNames = (PEXPORTED_DATA)(PEExports->AddressOfNames + LoadedModules[i][1]);
                                    ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(PEExports->AddressOfNameOrdinals + LoadedModules[i][1]);
                                }
                                else
                                {
                                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                                    ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                                    ExportedFunctionNames = (PEXPORTED_DATA)(PEExports->AddressOfNames + LoadedModules[i][1]);
                                    ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(PEExports->AddressOfNameOrdinals + LoadedModules[i][1]);
                                }
                                if(ReturnType == UE_OPTION_IMPORTER_RETURN_APINAME || ReturnType == UE_OPTION_IMPORTER_RETURN_DLLNAME || ReturnType == UE_OPTION_IMPORTER_RETURN_DLLINDEX || ReturnType == UE_OPTION_IMPORTER_RETURN_API_ORDINAL_NUMBER)
                                {
                                    for(j = 0; j < PEExports->NumberOfFunctions; j++)  //NumberOfNames
                                    {
                                        if(ExportedFunctions->ExportedItem + LoadedModules[i][0] == APIAddress)
                                        {
                                            GetModuleBaseNameA(hProcess, (HMODULE)LoadedModules[i][0], (LPSTR)engineFoundDLLName, 512);
                                            RtlZeroMemory(&engineFoundAPIName, sizeof(engineFoundAPIName));
                                            x = j;
                                            FoundOrdinalNumber = (unsigned int)PEExports->Base;
                                            for(j = 0; j < PEExports->NumberOfNames; j++)
                                            {
                                                if(ExportedFunctionOrdinals->OrdinalNumber != x)
                                                {
                                                    ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)((ULONG_PTR)ExportedFunctionOrdinals + 2);
                                                }
                                                else
                                                {
                                                    FoundOrdinalNumber = FoundOrdinalNumber + (unsigned int)ExportedFunctionOrdinals->OrdinalNumber;
                                                    break;
                                                }
                                            }
                                            ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + j * 4);
                                            if(EngineIsPointedMemoryString((ULONG_PTR)(ExportedFunctionNames->ExportedItem + LoadedModules[i][1])))
                                            {
                                                lstrcpyA((LPSTR)engineFoundAPIName, (LPCSTR)(ExportedFunctionNames->ExportedItem + LoadedModules[i][1]));
                                            }
                                            APINameFound = true;
                                            FoundIndex = i;
                                            break;
                                        }
                                        ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + 4);
                                    }
                                }
                                else if(ReturnType == UE_OPTION_IMPORTER_RETURN_APIADDRESS)
                                {
                                    for(j = 0; j < PEExports->NumberOfFunctions; j++)  //NumberOfNames
                                    {
                                        if(lstrcmpiA((LPCSTR)szAPIName, (LPCSTR)(ExportedFunctionNames->ExportedItem + LoadedModules[i][1])) == NULL)
                                        {
                                            ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)((ULONG_PTR)ExportedFunctionOrdinals + j * 2);
                                            ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + (ExportedFunctionOrdinals->OrdinalNumber) * 4);
                                            GetModuleBaseNameA(hProcess, (HMODULE)LoadedModules[i][0], (LPSTR)engineFoundDLLName, 512);
                                            RtlZeroMemory(&engineFoundAPIName, sizeof(engineFoundAPIName));
                                            ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + (j + PEExports->Base) * 4);
                                            APIFoundAddress = ExportedFunctions->ExportedItem + LoadedModules[i][0];
                                            APINameFound = true;
                                            FoundIndex = i;
                                            break;
                                        }
                                        ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + 4);
                                    }
                                }
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                RtlZeroMemory(&engineFoundAPIName, sizeof(engineFoundAPIName));
                                APINameFound = false;
                            }
                        }
                    }
                }
            }
            i++;
        }

        if(ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLNAME || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_APINAME || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLINDEX || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_API_ORDINAL_NUMBER)
        {
            RealignedAPIAddress = (ULONG_PTR)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_REALIGN_APIADDRESS);
            if(z <= 1)
            {
                z = 2;
            }
            for(i = y; i >= z; i--)
            {
                FileMapVA = LoadedModules[i][1];
                if(FileMapVA != NULL)
                {
                    DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
                    RtlZeroMemory(&RemoteModuleInfo, sizeof MODULEINFO);
                    //GetModuleInformation(GetCurrentProcess(), (HMODULE)LoadedModules[i][1], &RemoteModuleInfo, sizeof MODULEINFO);
                    GetModuleInformation(hProcess, (HMODULE)LoadedModules[i][0], &RemoteModuleInfo, sizeof MODULEINFO);
                    if(ValidateHeader || EngineValidateHeader((ULONG_PTR)LoadedModules[i][1], GetCurrentProcess(), RemoteModuleInfo.lpBaseOfDll, DOSHeader, false))
                    {
                        __try
                        {
                            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                            if(PEHeader32->OptionalHeader.Magic == 0x10B)
                            {
                                FileIs64 = false;
                            }
                            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                            {
                                FileIs64 = true;
                            }
                            else
                            {
                                SkipModule = true;
                            }
                            if(!SkipModule)
                            {
                                if(!FileIs64)
                                {
                                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                                    ExportedFunctionNames = (PEXPORTED_DATA)(PEExports->AddressOfNames + LoadedModules[i][1]);
                                    ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                                    ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(PEExports->AddressOfNameOrdinals + LoadedModules[i][1]);
                                }
                                else
                                {
                                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                                    ExportedFunctionNames = (PEXPORTED_DATA)(PEExports->AddressOfNames + LoadedModules[i][1]);
                                    ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                                    ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(PEExports->AddressOfNameOrdinals + LoadedModules[i][1]);
                                }
                                for(j = 0; j < PEExports->NumberOfFunctions; j++)
                                {
                                    if(EngineIsPointedMemoryString((ULONG_PTR)ExportedFunctions->ExportedItem + LoadedModules[i][1]))
                                    {
                                        RtlZeroMemory(&szFwdAPIName, 512);
                                        RtlZeroMemory(&szFwdDLLName, 512);
                                        if(EngineExtractForwarderData((ULONG_PTR)ExportedFunctions->ExportedItem + LoadedModules[i][1], &szFwdDLLName, &szFwdAPIName))
                                        {
                                            if((ULONG_PTR)GetProcAddress(GetModuleHandleA(szFwdDLLName), szFwdAPIName) == RealignedAPIAddress)
                                            {
                                                GetModuleBaseNameA(hProcess, (HMODULE)LoadedModules[i][0], (LPSTR)engineFoundDLLName, 512);
                                                RtlZeroMemory(&engineFoundAPIName, 512);
                                                x = j;
                                                FoundOrdinalNumber = (unsigned int)PEExports->Base;
                                                for(j = 0; j < PEExports->NumberOfNames; j++)
                                                {
                                                    if(ExportedFunctionOrdinals->OrdinalNumber != x)
                                                    {
                                                        ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)((ULONG_PTR)ExportedFunctionOrdinals + 2);
                                                    }
                                                    else
                                                    {
                                                        FoundOrdinalNumber = FoundOrdinalNumber + (unsigned int)ExportedFunctionOrdinals->OrdinalNumber;
                                                        break;
                                                    }
                                                }
                                                ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + j * 4);
                                                if(EngineIsPointedMemoryString((ULONG_PTR)(ExportedFunctionNames->ExportedItem + LoadedModules[i][1])))
                                                {
                                                    lstrcpyA((LPSTR)engineFoundAPIName, (LPCSTR)(ExportedFunctionNames->ExportedItem + LoadedModules[i][1]));
                                                }
                                                APINameFound = true;
                                                FoundIndex = i;
                                                break;
                                            }
                                        }
                                    }
                                    ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + 4);
                                }
                            }
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            RtlZeroMemory(&szFwdAPIName, 512);
                            RtlZeroMemory(&szFwdDLLName, 512);
                            APINameFound = false;
                        }
                    }
                }
                if(APINameFound)
                {
                    break;
                }
            }
        }
        i = 1;
        while(EnumeratedModules[i] != NULL)
        {
            if(engineAlowModuleLoading)
            {
                if(LoadedModules[i][2] == 1)
                {
                    FreeLibrary((HMODULE)LoadedModules[i][1]);
                }
            }
            else
            {
                if(LoadedModules[i][2] == 1)
                {
                    VirtualFree((void*)LoadedModules[i][1], NULL, MEM_RELEASE);
                }
            }
            i++;
        }
        if(APINameFound)
        {
            //
            // Vista/w7 x64 fix
            //
            if(lstrcmpiA(engineFoundAPIName, "NtdllDefWindowProc_A") == NULL)
            {
                lstrcpyA(engineFoundAPIName, "DefWindowProcA");
                lstrcpyA(engineFoundDLLName, "user32.dll");
                FoundIndex = Vista64UserForwarderFix;
            }
            else if(lstrcmpiA(engineFoundAPIName, "NtdllDefWindowProc_W") == NULL)
            {
                lstrcpyA(engineFoundAPIName, "DefWindowProcW");
                lstrcpyA(engineFoundDLLName, "user32.dll");
                FoundIndex = Vista64UserForwarderFix;
            }
            else if(lstrcmpiA(engineFoundAPIName, "NtdllDialogWndProc_A") == NULL)
            {
                lstrcpyA(engineFoundAPIName, "DefDlgProcA");
                lstrcpyA(engineFoundDLLName, "user32.dll");
                FoundIndex = Vista64UserForwarderFix;
            }
            else if(lstrcmpiA(engineFoundAPIName, "NtdllDialogWndProc_W") == NULL)
            {
                lstrcpyA(engineFoundAPIName, "DefDlgProcW");
                lstrcpyA(engineFoundDLLName, "user32.dll");
                FoundIndex = Vista64UserForwarderFix;
            }
            if(ReturnType == UE_OPTION_IMPORTER_RETURN_APINAME || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_APINAME)
            {
                if(ReturnType == UE_OPTION_IMPORTER_RETURN_APINAME && engineCheckForwarders == true)
                {
                    if(engineAlowModuleLoading == true || (engineAlowModuleLoading == false && LoadedModules[FoundIndex][2] != 1))
                    {
                        if(lstrcmpiA(engineFoundDLLName, "ntdll.dll") == NULL)
                        {
                            ForwarderData = (ULONG_PTR)EngineGlobalAPIHandler(handleProcess, EnumedModulesBases, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_APINAME);
                        }
                        else
                        {
                            ForwarderData = NULL;
                        }
                        if(ForwarderData != NULL)
                        {
                            return(ForwarderData);
                        }
                        else
                        {
                            if(engineFoundAPIName[0] != 0x00)
                            {
                                return((ULONG_PTR)engineFoundAPIName);
                            }
                            else
                            {
                                return(NULL);
                            }
                        }
                    }
                    else
                    {
                        if(engineFoundAPIName[0] != 0x00)
                        {
                            return((ULONG_PTR)engineFoundAPIName);
                        }
                        else
                        {
                            return(NULL);
                        }
                    }
                }
                else
                {
                    if(engineFoundAPIName[0] != 0x00)
                    {
                        return((ULONG_PTR)engineFoundAPIName);
                    }
                    else
                    {
                        return(NULL);
                    }
                }
            }
            else if(ReturnType == UE_OPTION_IMPORTER_RETURN_APIADDRESS)
            {
                return(APIFoundAddress);
            }
            else if(ReturnType == UE_OPTION_IMPORTER_RETURN_API_ORDINAL_NUMBER || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_API_ORDINAL_NUMBER)
            {
                return((ULONG_PTR)FoundOrdinalNumber);
            }
            else if(ReturnType == UE_OPTION_IMPORTER_RETURN_DLLNAME || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLNAME)
            {
                if(ReturnType == UE_OPTION_IMPORTER_RETURN_DLLNAME && engineCheckForwarders == true)
                {
                    if(engineAlowModuleLoading == true || (engineAlowModuleLoading == false && LoadedModules[FoundIndex][2] != 1))
                    {
                        if(lstrcmpiA(engineFoundDLLName, "ntdll.dll") == NULL)
                        {
                            ForwarderData = (ULONG_PTR)EngineGlobalAPIHandler(handleProcess, EnumedModulesBases, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLNAME);
                        }
                        else
                        {
                            ForwarderData = NULL;
                        }
                        if(ForwarderData != NULL)
                        {
                            return(ForwarderData);
                        }
                        else
                        {
                            if(engineFoundDLLName[0] != 0x00)
                            {
                                return((ULONG_PTR)engineFoundDLLName);
                            }
                            else
                            {
                                return(NULL);
                            }
                        }
                    }
                    else
                    {
                        if(engineFoundDLLName[0] != 0x00)
                        {
                            return((ULONG_PTR)engineFoundDLLName);
                        }
                        else
                        {
                            return(NULL);
                        }
                    }
                }
                else
                {
                    if(engineFoundDLLName[0] != 0x00)
                    {
                        return((ULONG_PTR)engineFoundDLLName);
                    }
                    else
                    {
                        return(NULL);
                    }
                }
            }
            else if(ReturnType == UE_OPTION_IMPORTER_RETURN_DLLINDEX || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLINDEX)
            {
                if(ReturnType == UE_OPTION_IMPORTER_RETURN_DLLINDEX && engineCheckForwarders == true)
                {
                    if(engineAlowModuleLoading == true || (engineAlowModuleLoading == false && LoadedModules[FoundIndex][2] != 1))
                    {
                        if(lstrcmpiA(engineFoundDLLName, "ntdll.dll") == NULL)
                        {
                            ForwarderData = (ULONG_PTR)EngineGlobalAPIHandler(handleProcess, EnumedModulesBases, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLINDEX);
                        }
                        else
                        {
                            ForwarderData = NULL;
                        }
                        if(ForwarderData != NULL)
                        {
                            return(ForwarderData);
                        }
                        else
                        {
                            return(FoundIndex);
                        }
                    }
                    else
                    {
                        return(FoundIndex);
                    }
                }
                else
                {
                    return(FoundIndex);
                }
            }
            else if(ReturnType == UE_OPTION_IMPORTER_RETURN_DLLBASE)
            {
                return(APIFoundAddress);
            }
            else if(ReturnType == UE_OPTION_IMPORTER_RETURN_NEAREST_APIADDRESS)
            {
                return(APIFoundAddress);
            }
            else if(ReturnType == UE_OPTION_IMPORTER_RETURN_NEAREST_APINAME)
            {
                if(engineCheckForwarders)
                {
                    if(engineAlowModuleLoading == true || (engineAlowModuleLoading == false && LoadedModules[FoundIndex][2] != 1))
                    {
                        if(lstrcmpiA(engineFoundDLLName, "ntdll.dll") == NULL)
                        {
                            ForwarderData = (ULONG_PTR)EngineGlobalAPIHandler(handleProcess, EnumedModulesBases, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_APINAME);
                        }
                        else
                        {
                            ForwarderData = NULL;
                        }
                        if(ForwarderData != NULL)
                        {
                            return(ForwarderData);
                        }
                        else
                        {
                            if(engineFoundAPIName[0] != 0x00)
                            {
                                return((ULONG_PTR)engineFoundAPIName);
                            }
                            else
                            {
                                return(NULL);
                            }
                        }
                    }
                    else
                    {
                        if(engineFoundAPIName[0] != 0x00)
                        {
                            return((ULONG_PTR)engineFoundAPIName);
                        }
                        else
                        {
                            return(NULL);
                        }
                    }
                }
                else
                {
                    if(engineFoundAPIName[0] != 0x00)
                    {
                        return((ULONG_PTR)engineFoundAPIName);
                    }
                    else
                    {
                        return(NULL);
                    }
                }
            }
            else
            {
                return(APIFoundAddress);
            }
        }
        else
        {
            if(ReturnType == UE_OPTION_IMPORTER_RETURN_API_ORDINAL_NUMBER || ReturnType == UE_OPTION_IMPORTER_RETURN_FORWARDER_API_ORDINAL_NUMBER)
            {
                return((ULONG_PTR) - 1);
            }
            else
            {
                return(NULL);
            }
        }
    }
    else
    {
        return(NULL);
    }
    return(NULL);
}

DWORD EngineSetDebugPrivilege(HANDLE hProcess, bool bEnablePrivilege)
{
    HANDLE TokenHandle;
    NTSTATUS Status = NtOpenProcessToken(hProcess,
                                         TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                                         &TokenHandle);
    if(!NT_SUCCESS(Status))
        return RtlNtStatusToDosError(Status);

    LUID LuidPrivilege;
    LuidPrivilege.LowPart = SE_DEBUG_PRIVILEGE;
    LuidPrivilege.HighPart = 0;

    TOKEN_PRIVILEGES Privileges;
    Privileges.PrivilegeCount = 1;
    Privileges.Privileges[0].Luid = LuidPrivilege;
    Privileges.Privileges[0].Attributes = bEnablePrivilege ? SE_PRIVILEGE_ENABLED : 0;

    ULONG ReturnLength;
    Status = NtAdjustPrivilegesToken(TokenHandle,
                                     FALSE,
                                     &Privileges,
                                     sizeof(Privileges),
                                     nullptr,
                                     &ReturnLength);
    NtClose(TokenHandle);

    // Map the success code NOT_ALL_ASSIGNED to an appropriate error
    // since we're only trying to adjust one privilege.
    if(Status == STATUS_NOT_ALL_ASSIGNED)
        Status = STATUS_PRIVILEGE_NOT_HELD;

    return NT_SUCCESS(Status) ? ERROR_SUCCESS : RtlNtStatusToDosError(Status);
}

HANDLE EngineOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId)
{
    return OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
}

HANDLE EngineOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId)
{
    return OpenThread(dwDesiredAccess, bInheritHandle, dwThreadId);
}



================================================
File: TitanEngine/Global.Engine.h
================================================
#ifndef _GLOBAL_ENGINE_H
#define _GLOBAL_ENGINE_H

#include <vector>

//Global.Engine.Variables
extern HMODULE engineHandle;
extern LPVOID engineExitThreadOneShootCallBack;
extern LPVOID engineDependencyFiles;
extern LPVOID engineDependencyFilesCWP;
extern void* EngineStartUnpackingCallBack;

extern bool engineAlowModuleLoading;
extern bool engineCheckForwarders;
extern bool engineBackupForCriticalFunctions;
extern bool engineResumeProcessIfNoThreadIsActive;
extern bool engineResetCustomHandler;
extern bool engineRemoveConsoleForDebugee;
extern bool enginePassAllExceptions;
extern bool engineAutoHideFromDebugger;
extern bool engineEnableDebugPrivilege;
extern bool engineSafeAttach;
extern bool engineMembpAlt;
extern bool engineDisableAslr;
extern bool engineSafeStep;

//Global.Engine.Functions
void EngineInit();
bool EngineIsThereFreeHardwareBreakSlot(LPDWORD FreeRegister);
bool EngineFileExists(char* szFileName);
void EngineCreatePathForFile(char* szFileName);
void EngineCreatePathForFileW(wchar_t* szFileName);
wchar_t* EngineExtractFileNameW(wchar_t* szFileName);
bool EngineIsPointedMemoryString(ULONG_PTR PossibleStringPtr);
int EnginePointedMemoryStringLength(ULONG_PTR PossibleStringPtr);
bool EngineCompareResourceString(wchar_t* String1, wchar_t* String2);
ULONG_PTR EngineEstimateNewSectionRVA(ULONG_PTR FileMapVA);
bool EngineExtractForwarderData(ULONG_PTR PossibleStringPtr, LPVOID szFwdDLLName, LPVOID szFwdAPIName);
bool EngineGrabDataFromMappedFile(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR FileOffset, DWORD CopySize, LPVOID CopyToMemory);
bool EngineExtractResource(char* szResourceName, wchar_t* szExtractedFileName);
bool EngineIsDependencyPresent(char* szFileName, char* szDependencyForFile, char* szPresentInFolder);
bool EngineIsDependencyPresentW(wchar_t* szFileName, wchar_t* szDependencyForFile, wchar_t* szPresentInFolder);
bool EngineGetDependencyLocation(char* szFileName, char* szDependencyForFile, void* szLocationOfTheFile, int MaxStringSize);
bool EngineGetDependencyLocationW(wchar_t* szFileName, wchar_t* szDependencyForFile, void* szLocationOfTheFile, int MaxStringSize);
long EngineHashString(char* szStringToHash);
long EngineHashMemory(char* MemoryAddress, int MemorySize, DWORD InitialHashValue);
bool EngineIsValidReadPtrEx(LPVOID DataPointer, DWORD DataSize);
bool EngineValidateResource(HMODULE hModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR lParam);
bool EngineValidateHeader(ULONG_PTR FileMapVA, HANDLE hFileProc, LPVOID ImageBase, PIMAGE_DOS_HEADER DOSHeader, bool IsFile);
ULONG_PTR EngineSimulateNtLoaderW(wchar_t* szFileName);
ULONG_PTR EngineSimulateNtLoader(char* szFileName);
ULONG_PTR EngineSimulateDllLoader(HANDLE hProcess, char* szFileName);
ULONG_PTR EngineSimulateDllLoaderW(HANDLE hProcess, wchar_t* szFileName);
ULONG_PTR EngineGetProcAddress(ULONG_PTR ModuleBase, char* szAPIName);
bool EngineGetLibraryOrdinalData(ULONG_PTR ModuleBase, LPDWORD ptrOrdinalBase, LPDWORD ptrOrdinalCount);
ULONG_PTR EngineGlobalAPIHandler(HANDLE handleProcess, ULONG_PTR EnumedModulesBases, ULONG_PTR APIAddress, const char* szAPIName, DWORD ReturnType);
DWORD EngineSetDebugPrivilege(HANDLE hProcess, bool bEnablePrivilege);
HANDLE EngineOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
HANDLE EngineOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);

#endif //_GLOBAL_ENGINE_H


================================================
File: TitanEngine/Global.Garbage.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Garbage.h"
#include "Global.Handle.h"
#include "Global.Engine.h"

// Global.Garbage.functions:
bool CreateGarbageItem(void* outGargabeItem, int MaxGargabeStringSize)
{
    return false;
}

bool RemoveGarbageItem(wchar_t* szGarbageItem, bool RemoveFolder)
{
    return false;
}

bool FillGarbageItem(wchar_t* szGarbageItem, wchar_t* szFileName, void* outGargabeItem, int MaxGargabeStringSize)
{
    return false;
}

void EmptyGarbage()
{
}



================================================
File: TitanEngine/Global.Garbage.h
================================================
#ifndef _GLOBAL_GARBAGE_H
#define _GLOBAL_GARBAGE_H

// Global.Garbage.functions:
bool CreateGarbageItem(void* outGargabeItem, int MaxGargabeStringSize);
bool RemoveGarbageItem(wchar_t* szGarbageItem, bool RemoveFolder);
bool FillGarbageItem(wchar_t* szGarbageItem, wchar_t* szFileName, void* outGargabeItem, int MaxGargabeStringSize);
void EmptyGarbage();

#endif //_GLOBAL_GARBAGE_H


================================================
File: TitanEngine/Global.Handle.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Handle.h"

// Global.Handle.functions:
bool EngineCloseHandle(HANDLE myHandle)
{
    DWORD HandleFlags;
    if(GetHandleInformation(myHandle, &HandleFlags) && (HandleFlags & HANDLE_FLAG_PROTECT_FROM_CLOSE) != HANDLE_FLAG_PROTECT_FROM_CLOSE)
        return !!CloseHandle(myHandle);
    return false;
}


================================================
File: TitanEngine/Global.Handle.h
================================================
#ifndef _GLOBAL_HANDLE_H
#define _GLOBAL_HANDLE_H

bool EngineCloseHandle(HANDLE myHandle);

#endif //_GLOBAL_HANDLE_H


================================================
File: TitanEngine/Global.Helper.cpp
================================================
#include "stdafx.h"
#include "Global.Helper.h"



bool IsStrEqual(const char* const a, const char* const b, bool considercase/*=true*/)
{
    const int stringlen = (int)std::strlen(a);
    if(stringlen != std::strlen(b))
        return false; //cheap

    if(considercase)
    {
        //plain old strcmp
        return std::strcmp(a, b) == 0;
    }
    else
    {
        for(int i = 0; i < stringlen; i++)
        {
            if(tolower(a[i]) != tolower(b[i]))
                return false;
        }

        return true;
    }
}

void* MemAlloc(size_t sz)
{
    void* r = malloc(sz);
    if(r)
        memset(r, 0, sz);
    return r;
}

void MemFree(void* mem)
{
    free(mem);
}



================================================
File: TitanEngine/Global.Helper.h
================================================
#ifndef Helper_h__
#define Helper_h__

#include <string>
#include <vector>

/*
Compares two strings
a : string 1
b : string 2
considercase : casesensitivity
*/
bool IsStrEqual(const char* const a, const char* const b, bool considercase = true);

/*
A basic dynamic buffer, exception free.
*/
class DynBuf
{
public:
    DynBuf(size_t sz = 0)
    {
        Allocate(sz);
    }
    typedef std::vector<char> DynBufVec;

    void* Allocate(size_t sz)
    {
        void* r = NULL;
        try
        {
            if(Size() < sz)
                mem.resize(sz);
            if(Size())
                r = GetPtr();
            if(r && sz)
                memset(r, 0, sz);
        }
        catch(...)
        {
        }

        return r;
    }
    void* GetPtr()
    {
        if(Size())
            return &mem.front(); //in c++11: .data()
        return NULL;
    }
    void Free()
    {
        mem.clear();
    }
    DynBufVec & GetVector()
    {
        return mem;
    }
    const DynBufVec & GetVector() const
    {
        return mem;
    }
    size_t Size() const
    {
        return mem.size();
    }


protected:
    char & operator[](std::size_t idx)
    {
        return mem[idx];
    };
    const char & operator[](std::size_t idx) const
    {
        return mem[idx];
    };

    DynBufVec mem;
};


//Unused malloc/free wrappers

/*
malloc wrapper
*/
void* MemAlloc(size_t sz);

/*
free wrapper
*/
void MemFree(void* mem);



#endif // Helper_h__




================================================
File: TitanEngine/Global.Injector.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Injector.h"

HANDLE engineReservedMemoryProcess = NULL;
ULONG_PTR engineReservedMemoryLeft[UE_MAX_RESERVED_MEMORY_LEFT];

long injectedRemoteLoadLibrary(LPVOID Parameter)
{
    PInjectCodeData APIData = (PInjectCodeData)Parameter;
    Parameter = (LPVOID)((ULONG_PTR)Parameter + sizeof InjectCodeData);
#if !defined(_WIN64)
    typedef ULONG_PTR(WINAPI * fLoadLibraryW)(LPCWSTR fLibraryName);
    typedef ULONG_PTR(WINAPI * fVirtualFree)(LPVOID fMemBase, SIZE_T fMemSize, DWORD fFreeType);
#else
    typedef ULONG_PTR(__fastcall * fLoadLibraryW)(LPCWSTR fLibraryName);
    typedef ULONG_PTR(__fastcall * fVirtualFree)(LPVOID fMemBase, SIZE_T fMemSize, DWORD fFreeType);
#endif
    fLoadLibraryW cLoadLibraryW = (fLoadLibraryW)(APIData->fLoadLibrary);
    fVirtualFree cVirtualFree = (fVirtualFree)(APIData->fVirtualFree);
    long retValue = NULL;

    if(cLoadLibraryW((LPCWSTR)Parameter) != NULL)
    {
        retValue++;
    }
    cVirtualFree(Parameter, NULL, MEM_RELEASE);
    return(retValue);
}

long injectedRemoteFreeLibrary(LPVOID Parameter)
{

    PInjectCodeData APIData = (PInjectCodeData)Parameter;
#if !defined(_WIN64)
    typedef ULONG_PTR(WINAPI * fFreeLibrary)(HMODULE fLibBase);
    typedef ULONG_PTR(WINAPI * fVirtualFree)(LPVOID fMemBase, SIZE_T fMemSize, DWORD fFreeType);
#else
    typedef ULONG_PTR(__fastcall * fFreeLibrary)(HMODULE fLibBase);
    typedef ULONG_PTR(__fastcall * fVirtualFree)(LPVOID fMemBase, SIZE_T fMemSize, DWORD fFreeType);
#endif
    fFreeLibrary cFreeLibrary = (fFreeLibrary)(APIData->fFreeLibrary);
    fVirtualFree cVirtualFree = (fVirtualFree)(APIData->fVirtualFree);
    long retValue = NULL;

    if(cFreeLibrary(APIData->fFreeLibraryHandle))
    {
        retValue++;
    }
    cVirtualFree(Parameter, NULL, MEM_RELEASE);
    return(retValue);
}

long injectedRemoteFreeLibrarySimple(LPVOID Parameter)
{

    PInjectCodeData APIData = (PInjectCodeData)Parameter;
    LPVOID orgParameter = Parameter;
    Parameter = (LPVOID)((ULONG_PTR)Parameter + sizeof InjectCodeData);
#if !defined(_WIN64)
    typedef ULONG_PTR(WINAPI * fFreeLibrary)(HMODULE fLibBase);
    typedef HMODULE(WINAPI * fGetModuleHandleW)(LPCWSTR fLibraryName);
    typedef ULONG_PTR(WINAPI * fVirtualFree)(LPVOID fMemBase, SIZE_T fMemSize, DWORD fFreeType);
#else
    typedef ULONG_PTR(__fastcall * fFreeLibrary)(HMODULE fLibBase);
    typedef HMODULE(__fastcall * fGetModuleHandleW)(LPCWSTR fLibraryName);
    typedef ULONG_PTR(__fastcall * fVirtualFree)(LPVOID fMemBase, SIZE_T fMemSize, DWORD fFreeType);
#endif
    fGetModuleHandleW cGetModuleHandleW = (fGetModuleHandleW)(APIData->fGetModuleHandle);
    fFreeLibrary cFreeLibrary = (fFreeLibrary)(APIData->fFreeLibrary);
    fVirtualFree cVirtualFree = (fVirtualFree)(APIData->fVirtualFree);
    long retValue = NULL;
    HMODULE hModule;

    hModule = cGetModuleHandleW((LPCWSTR)Parameter);
    if(hModule != NULL)
    {
        if(cFreeLibrary(hModule))
        {
            retValue++;
        }
    }
    else
    {
        retValue++;
    }
    cVirtualFree(orgParameter, NULL, MEM_RELEASE);
    return(retValue);
}

long injectedExitProcess(LPVOID Parameter)
{

    PInjectCodeData APIData = (PInjectCodeData)Parameter;
#if !defined(_WIN64)
    typedef ULONG_PTR(WINAPI * fExitProcess)(DWORD fExitCode);
#else
    typedef ULONG_PTR(__fastcall * fExitProcess)(DWORD fExitCode);
#endif
    fExitProcess cExitProcess = (fExitProcess)(APIData->fExitProcess);
    long retValue = NULL;

    cExitProcess(APIData->fExitProcessCode);
    return(NULL);
}

void injectedTerminator()
{

    int i;

    for(i = 0; i < UE_MAX_RESERVED_MEMORY_LEFT; i++)
    {
        if(engineReservedMemoryLeft[i] != NULL)
        {
            VirtualFreeEx(engineReservedMemoryProcess, (LPVOID)engineReservedMemoryLeft[i], NULL, MEM_RELEASE);
            engineReservedMemoryLeft[i] = NULL;
        }
    }
}

// Global.Injector.functions: {DO NOT REORDER! USE ONLY IN RELEASE MODE!}
long injectedImpRec(LPVOID Parameter)
{
    HANDLE hFile;
    HANDLE hFileMap;
    PInjectImpRecCodeData APIData = (PInjectImpRecCodeData)Parameter;
    LPVOID szFileName = (LPVOID)((ULONG_PTR)Parameter + sizeof InjectImpRecCodeData);
    typedef ULONG_PTR(__cdecl * fTrace)(DWORD hFileMap, DWORD dwSizeMap, DWORD dwTimeOut, DWORD dwToTrace, DWORD dwExactCall);
    typedef HANDLE(WINAPI * fCreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
    typedef HANDLE(WINAPI * fCreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
    typedef BOOL(__cdecl * fCloseHandle)(HANDLE hHandle);
    fTrace cTrace = (fTrace)(APIData->fTrace);
    fCreateFileW cCreateFileW = (fCreateFileW)(APIData->fCreateFileA);
    fCloseHandle cCloseHandle = (fCloseHandle)(APIData->fCloseHandle);
    fCreateFileMappingA cCreateFileMappingA = (fCreateFileMappingA)(APIData->fCreateFileMappingA);

    hFile = cCreateFileW((LPCWSTR)szFileName, GENERIC_READ + GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        hFileMap = cCreateFileMappingA(hFile, NULL, 4, NULL, 0x100, NULL);
        cTrace((DWORD)hFileMap, 0x100, -1, (DWORD)APIData->AddressToTrace, NULL);
        cCloseHandle(hFile);
        return(1);
    }
    else
    {
        return(0);
    }
}


================================================
File: TitanEngine/Global.Injector.h
================================================
#ifndef _GLOBAL_INJECTOR_H
#define _GLOBAL_INJECTOR_H

extern HANDLE engineReservedMemoryProcess;
extern ULONG_PTR engineReservedMemoryLeft[UE_MAX_RESERVED_MEMORY_LEFT];

long injectedRemoteLoadLibrary(LPVOID Parameter);
long injectedRemoteFreeLibrary(LPVOID Parameter);
long injectedRemoteFreeLibrarySimple(LPVOID Parameter);
long injectedExitProcess(LPVOID Parameter);
void injectedTerminator();
long injectedImpRec(LPVOID Parameter);

#endif //_GLOBAL_INJECTOR_H


================================================
File: TitanEngine/Global.Librarian.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Librarian.h"

// Global.Engine.Librarian:
std::vector<LIBRARY_ITEM_DATAW> hListLibrary;
std::vector<LIBRARY_BREAK_DATA> LibrarianData;

void ClearLibraryList()
{
    std::vector<LIBRARY_ITEM_DATAW>().swap(hListLibrary);
}



================================================
File: TitanEngine/Global.Librarian.h
================================================
#ifndef _GLOBAL_LIBRARIAN_H
#define _GLOBAL_LIBRARIAN_H

#include <vector>

extern std::vector<LIBRARY_ITEM_DATAW> hListLibrary;
extern std::vector<LIBRARY_BREAK_DATA> LibrarianData;

void ClearLibraryList();

#endif //_GLOBAL_LIBRARIAN_H



================================================
File: TitanEngine/Global.Mapping.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Mapping.h"
#include "Global.Handle.h"

// Global.Mapping.functions:
bool MapFileEx(const char* szFileName, DWORD ReadOrWrite, LPHANDLE FileHandle, LPDWORD FileSize, LPHANDLE FileMap, LPVOID FileMapVA, DWORD SizeModifier)
{
    DWORD FileAccess = 0;
    DWORD FileMapType = 0;
    DWORD FileMapViewType = 0;

    if(ReadOrWrite == UE_ACCESS_READ)
    {
        FileAccess = GENERIC_READ;
        FileMapType = PAGE_READONLY;
        FileMapViewType = FILE_MAP_READ;
    }
    else if(ReadOrWrite == UE_ACCESS_WRITE)
    {
        FileAccess = GENERIC_WRITE;
        FileMapType = PAGE_READWRITE;
        FileMapViewType = FILE_MAP_WRITE;
    }
    else if(ReadOrWrite == UE_ACCESS_ALL)
    {
        FileAccess = GENERIC_READ + GENERIC_WRITE + GENERIC_EXECUTE;
        FileMapType = PAGE_EXECUTE_READWRITE;
        FileMapViewType = FILE_MAP_WRITE;
    }
    else
    {
        FileAccess = GENERIC_READ + GENERIC_WRITE + GENERIC_EXECUTE;
        FileMapType = PAGE_EXECUTE_READWRITE;
        FileMapViewType = FILE_MAP_ALL_ACCESS;
    }

    HANDLE hFile = CreateFileA(szFileName, FileAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        *FileHandle = hFile;
        DWORD mfFileSize = GetFileSize(hFile, NULL);
        mfFileSize = mfFileSize + SizeModifier;
        *FileSize = mfFileSize;
        HANDLE mfFileMap = CreateFileMappingA(hFile, NULL, FileMapType, NULL, mfFileSize, NULL);
        if(mfFileMap != NULL)
        {
            *FileMap = mfFileMap;
            LPVOID mfFileMapVA = MapViewOfFile(mfFileMap, FileMapViewType, NULL, NULL, NULL);
            if(mfFileMapVA != NULL)
            {
                RtlMoveMemory(FileMapVA, &mfFileMapVA, sizeof ULONG_PTR);
                return true;
            }
        }
        RtlZeroMemory(FileMapVA, sizeof ULONG_PTR);
        *FileHandle = NULL;
        *FileSize = NULL;
        EngineCloseHandle(hFile);
    }
    else
    {
        RtlZeroMemory(FileMapVA, sizeof ULONG_PTR);
    }
    return false;
}

bool MapFileExW(const wchar_t* szFileName, DWORD ReadOrWrite, LPHANDLE FileHandle, LPDWORD FileSize, LPHANDLE FileMap, LPVOID FileMapVA, DWORD SizeModifier)
{
    DWORD FileAccess = 0;
    DWORD FileMapType = 0;
    DWORD FileMapViewType = 0;

    if(ReadOrWrite == UE_ACCESS_READ)
    {
        FileAccess = GENERIC_READ;
        FileMapType = PAGE_READONLY;
        FileMapViewType = FILE_MAP_READ;
    }
    else if(ReadOrWrite == UE_ACCESS_WRITE)
    {
        FileAccess = GENERIC_WRITE;
        FileMapType = PAGE_READWRITE;
        FileMapViewType = FILE_MAP_WRITE;
    }
    else if(ReadOrWrite == UE_ACCESS_ALL)
    {
        FileAccess = GENERIC_READ + GENERIC_WRITE + GENERIC_EXECUTE;
        FileMapType = PAGE_EXECUTE_READWRITE;
        FileMapViewType = FILE_MAP_WRITE;
    }
    else
    {
        FileAccess = GENERIC_READ + GENERIC_WRITE + GENERIC_EXECUTE;
        FileMapType = PAGE_EXECUTE_READWRITE;
        FileMapViewType = FILE_MAP_ALL_ACCESS;
    }

    HANDLE hFile = CreateFileW(szFileName, FileAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        *FileHandle = hFile;
        DWORD mfFileSize = GetFileSize(hFile, NULL);
        mfFileSize = mfFileSize + SizeModifier;
        *FileSize = mfFileSize;
        HANDLE mfFileMap = CreateFileMappingA(hFile, NULL, FileMapType, NULL, mfFileSize, NULL);
        if(mfFileMap != NULL)
        {
            *FileMap = mfFileMap;
            LPVOID mfFileMapVA = MapViewOfFile(mfFileMap, FileMapViewType, NULL, NULL, NULL);
            if(mfFileMapVA != NULL)
            {
                RtlMoveMemory(FileMapVA, &mfFileMapVA, sizeof ULONG_PTR);
                return true;
            }
        }
        RtlZeroMemory(FileMapVA, sizeof ULONG_PTR);
        *FileHandle = NULL;
        *FileSize = NULL;
        EngineCloseHandle(hFile);
    }
    else
    {
        RtlZeroMemory(FileMapVA, sizeof ULONG_PTR);
    }
    return false;
}

void UnMapFileEx(HANDLE FileHandle, DWORD FileSize, HANDLE FileMap, ULONG_PTR FileMapVA)
{
    if(UnmapViewOfFile((void*)FileMapVA))
    {
        EngineCloseHandle(FileMap);
        SetFilePointer(FileHandle, FileSize, NULL, FILE_BEGIN);
        SetEndOfFile(FileHandle);
        EngineCloseHandle(FileHandle);
    }
}



================================================
File: TitanEngine/Global.Mapping.h
================================================
#ifndef _GLOBAL_MAPPING_H
#define _GLOBAL_MAPPING_H

bool MapFileEx(const char* szFileName, DWORD ReadOrWrite, LPHANDLE FileHandle, LPDWORD FileSize, LPHANDLE FileMap, LPVOID FileMapVA, DWORD SizeModifier);
bool MapFileExW(const wchar_t* szFileName, DWORD ReadOrWrite, LPHANDLE FileHandle, LPDWORD FileSize, LPHANDLE FileMap, LPVOID FileMapVA, DWORD SizeModifier);
void UnMapFileEx(HANDLE FileHandle, DWORD FileSize, HANDLE FileMap, ULONG_PTR FileMapVA);

#endif //_GLOBAL_MAPPING_H


================================================
File: TitanEngine/Global.OEPFinder.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.OEPFinder.h"
#include "Global.Engine.h"
#include "Global.Breakpoints.h"
#include "Global.Debugger.h"
#include "Global.Mapping.h"
#include "Global.Handle.h"

GenericOEPTracerData glbEntryTracerData = {};

// Global.FindOEP.functions:
void GenericOEPVirtualProtectHit()
{
    MEMORY_BASIC_INFORMATION MemInfo;
    DWORD MaximumBreakPoints = 0;
    DWORD NewProtect = 0;
    DWORD OldProtect = 0;

    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        BreakPointDetail curDetail = BreakPointBuffer.at(i);
        if(curDetail.BreakPointType == UE_MEMORY && curDetail.BreakPointActive == UE_BPXACTIVE)
        {
            VirtualQueryEx(dbgProcessInformation.hProcess, (LPVOID)curDetail.BreakPointAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
            OldProtect = MemInfo.Protect;
            if(!(OldProtect & PAGE_GUARD))
            {
                NewProtect = OldProtect ^ PAGE_GUARD;
                VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)curDetail.BreakPointAddress, curDetail.BreakPointSize, NewProtect, &OldProtect);
            }
        }
        MaximumBreakPoints++;
    }
}

void GenericOEPTraceHit()
{

    char* szInstructionType;
    typedef void(TITCALL * fEPCallBack)();
    fEPCallBack myEPCallBack = (fEPCallBack)glbEntryTracerData.EPCallBack;
    LPDEBUG_EVENT myDbgEvent = (LPDEBUG_EVENT)GetDebugData();

    glbEntryTracerData.MemoryAccessedFrom = (ULONG_PTR)GetContextData(UE_CIP);
    glbEntryTracerData.MemoryAccessed = myDbgEvent->u.Exception.ExceptionRecord.ExceptionInformation[1];
    glbEntryTracerData.AccessType = myDbgEvent->u.Exception.ExceptionRecord.ExceptionInformation[0];
    szInstructionType = (char*)DisassembleEx(dbgProcessInformation.hProcess, (void*)glbEntryTracerData.MemoryAccessedFrom, true);
    StepInto(&GenericOEPTraceHited);
}

void GenericOEPTraceHited()
{

    int i;
    //void* lpHashBuffer;
    char lpHashBuffer[0x1000] = {0};
    bool FakeEPDetected = false;
    ULONG_PTR NumberOfBytesRW;
    LPDEBUG_EVENT myDbgEvent = (LPDEBUG_EVENT)GetDebugData();
    typedef void(TITCALL * fEPCallBack)();
    fEPCallBack myEPCallBack = (fEPCallBack)glbEntryTracerData.EPCallBack;
    PMEMORY_COMPARE_HANDLER myCmpHandler;
    ULONG_PTR memBpxAddress;
    ULONG_PTR memBpxSize;
    DWORD originalHash;
    DWORD currentHash;

    if(myDbgEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_SINGLE_STEP)
    {
        if(glbEntryTracerData.MemoryAccessed >= glbEntryTracerData.LoadedImageBase && glbEntryTracerData.MemoryAccessed <= glbEntryTracerData.LoadedImageBase + glbEntryTracerData.SizeOfImage)
        {
            for(i = 0; i < glbEntryTracerData.SectionNumber; i++)
            {
                if(glbEntryTracerData.MemoryAccessed >= glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.LoadedImageBase && glbEntryTracerData.MemoryAccessed < glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.SectionData[i].SectionVirtualSize + glbEntryTracerData.LoadedImageBase)
                {
                    if(glbEntryTracerData.AccessType == 1)
                    {
                        glbEntryTracerData.SectionData[i].AccessedAlready = true;
                    }
                    if(glbEntryTracerData.MemoryAccessedFrom >= glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.LoadedImageBase && glbEntryTracerData.MemoryAccessedFrom <= glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.SectionData[i].SectionVirtualSize + glbEntryTracerData.LoadedImageBase)
                    {
                        if(i != glbEntryTracerData.OriginalEntryPointNum)
                        {
                            glbEntryTracerData.SectionData[i].AccessedAlready = true;
                        }
                        memBpxAddress = (glbEntryTracerData.MemoryAccessed / sizeof(lpHashBuffer)) * sizeof(lpHashBuffer);
                        memBpxSize = glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.SectionData[i].SectionVirtualSize + glbEntryTracerData.LoadedImageBase - memBpxAddress;
                        if(memBpxSize > sizeof(lpHashBuffer))
                        {
                            memBpxSize = sizeof(lpHashBuffer);
                        }
                        if(ReadProcessMemory(dbgProcessInformation.hProcess, (void*)(memBpxAddress), lpHashBuffer, memBpxSize, &NumberOfBytesRW))
                        {
                            currentHash = EngineHashMemory((char*)lpHashBuffer, (DWORD)memBpxSize, NULL);
                            originalHash = EngineHashMemory((char*)((ULONG_PTR)glbEntryTracerData.SectionData[i].AllocatedSection + memBpxAddress - glbEntryTracerData.LoadedImageBase - glbEntryTracerData.SectionData[i].SectionVirtualOffset), (DWORD)memBpxSize, NULL);
                            if(ReadProcessMemory(dbgProcessInformation.hProcess, (void*)(glbEntryTracerData.CurrentIntructionPointer), lpHashBuffer, MAXIMUM_INSTRUCTION_SIZE, &NumberOfBytesRW))
                            {
                                myCmpHandler = (PMEMORY_COMPARE_HANDLER)(lpHashBuffer);
                                if(myCmpHandler->Array.bArrayEntry[0] == 0xC3)      // RET
                                {
                                    FakeEPDetected = true;
                                }
                                else if(myCmpHandler->Array.bArrayEntry[0] == 0x33 && myCmpHandler->Array.bArrayEntry[1] == 0xC0 && myCmpHandler->Array.bArrayEntry[2] == 0xC3)     // XOR EAX,EAX; RET
                                {
                                    FakeEPDetected = true;
                                }
                            }
                            if(currentHash != originalHash && glbEntryTracerData.SectionData[i].AccessedAlready == true && i != glbEntryTracerData.OriginalEntryPointNum && FakeEPDetected == false)
                            {
                                __try
                                {
                                    if(glbEntryTracerData.EPCallBack != NULL)
                                    {
                                        glbEntryTracerData.CurrentIntructionPointer = (ULONG_PTR)GetContextData(UE_CIP);
                                        SetContextData(UE_CIP, glbEntryTracerData.MemoryAccessedFrom);
                                        DeleteAPIBreakPoint("kernel32.dll", "VirtualProtect", UE_APIEND);
                                        RemoveAllBreakPoints(UE_OPTION_REMOVEALL);
                                        myEPCallBack();
                                        SetContextData(UE_CIP, glbEntryTracerData.CurrentIntructionPointer);
                                    }
                                    else
                                    {
                                        StopDebug();
                                    }
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    StopDebug();
                                }
                            }
                        }
                    }
                    else
                    {
                        SetMemoryBPXEx((ULONG_PTR)(glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.LoadedImageBase), glbEntryTracerData.SectionData[i].SectionVirtualSize, UE_MEMORY, false, &GenericOEPTraceHit);
                    }
                }
                else
                {
                    SetMemoryBPXEx((ULONG_PTR)(glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.LoadedImageBase), glbEntryTracerData.SectionData[i].SectionVirtualSize, UE_MEMORY, false, &GenericOEPTraceHit);
                }
            }
        }
    }
    else
    {
        StopDebug();
    }
}

void GenericOEPLibraryDetailsHit()
{

    int i;
    bool memBreakPointSet = false;
    char szModuleName[2 * MAX_PATH] = {};
#if !defined(_WIN64)
    int inReg = UE_EAX;
#else
    int inReg = UE_RAX;
#endif

    if(GetModuleBaseNameA(dbgProcessInformation.hProcess, (HMODULE)GetContextData(inReg), szModuleName, sizeof szModuleName) > NULL)
    {
        if(lstrcmpiA(szModuleName, "kernel32.dll") != NULL)
        {
            if(glbEntryTracerData.FileIsDLL)
            {
                glbEntryTracerData.LoadedImageBase = (ULONG_PTR)GetDebuggedDLLBaseAddress();
            }
            else
            {
                glbEntryTracerData.LoadedImageBase = (ULONG_PTR)GetDebuggedFileBaseAddress();
            }
            for(i = 0; i < glbEntryTracerData.SectionNumber; i++)
            {
                if(glbEntryTracerData.SectionData[i].SectionAttributes & IMAGE_SCN_MEM_EXECUTE || glbEntryTracerData.SectionData[i].SectionAttributes & IMAGE_SCN_CNT_CODE)
                {
                    SetMemoryBPXEx((ULONG_PTR)(glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.LoadedImageBase), glbEntryTracerData.SectionData[i].SectionVirtualSize, UE_MEMORY, false, &GenericOEPTraceHit);
                    memBreakPointSet = true;
                }
            }
            if(!memBreakPointSet)
            {
                StopDebug();
            }
            else
            {
                DeleteAPIBreakPoint("kernel32.dll", "GetModuleHandleW", UE_APIEND);
                DeleteAPIBreakPoint("kernel32.dll", "LoadLibraryExW", UE_APIEND);
            }
        }
    }
}

void GenericOEPTraceInit()
{

    int i;
    void* lpHashBuffer;
    ULONG_PTR NumberOfBytesRW;
    typedef void(TITCALL * fInitCallBack)();
    fInitCallBack myInitCallBack = (fInitCallBack)glbEntryTracerData.InitCallBack;

    if(glbEntryTracerData.FileIsDLL)
    {
        glbEntryTracerData.LoadedImageBase = (ULONG_PTR)GetDebuggedDLLBaseAddress();
    }
    else
    {
        glbEntryTracerData.LoadedImageBase = (ULONG_PTR)GetDebuggedFileBaseAddress();
    }
    for(i = 0; i < glbEntryTracerData.SectionNumber; i++)
    {
        lpHashBuffer = VirtualAlloc(NULL, glbEntryTracerData.SectionData[i].SectionVirtualSize, MEM_COMMIT, PAGE_READWRITE);
        if(lpHashBuffer != NULL)
        {
            if(ReadProcessMemory(dbgProcessInformation.hProcess, (void*)(glbEntryTracerData.SectionData[i].SectionVirtualOffset + glbEntryTracerData.LoadedImageBase), lpHashBuffer, glbEntryTracerData.SectionData[i].SectionVirtualSize, &NumberOfBytesRW))
            {
                glbEntryTracerData.SectionData[i].AllocatedSection = lpHashBuffer;
            }
        }
    }
    SetAPIBreakPoint("kernel32.dll", "VirtualProtect", UE_BREAKPOINT, UE_APIEND, &GenericOEPVirtualProtectHit);
    SetAPIBreakPoint("kernel32.dll", "GetModuleHandleW", UE_BREAKPOINT, UE_APIEND, &GenericOEPLibraryDetailsHit);
    SetAPIBreakPoint("kernel32.dll", "LoadLibraryExW", UE_BREAKPOINT, UE_APIEND, &GenericOEPLibraryDetailsHit);
    if(glbEntryTracerData.InitCallBack != NULL)
    {
        __try
        {
            myInitCallBack();
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            StopDebug();
        }
    }
}

bool GenericOEPFileInitW(wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack)
{

    int i;
#if defined(_WIN64)
    PE64Struct PEStruct = {};
#else
    PE32Struct PEStruct = {};
#endif
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        if(GetPE32DataFromMappedFileEx(FileMapVA, &PEStruct))
        {
            RtlZeroMemory(&glbEntryTracerData, sizeof GenericOEPTracerData);
            glbEntryTracerData.OriginalImageBase = PEStruct.ImageBase;
            glbEntryTracerData.OriginalEntryPoint = PEStruct.OriginalEntryPoint;
            glbEntryTracerData.SizeOfImage = PEStruct.NtSizeOfImage;
            glbEntryTracerData.SectionNumber = PEStruct.SectionNumber;
            glbEntryTracerData.FileIsDLL = IsFileDLL(NULL, FileMapVA);
            glbEntryTracerData.OriginalEntryPointNum = GetPE32SectionNumberFromVA(FileMapVA, glbEntryTracerData.OriginalImageBase + glbEntryTracerData.OriginalEntryPoint);
            for(i = 0; i < glbEntryTracerData.SectionNumber; i++)
            {
                glbEntryTracerData.SectionData[i].SectionVirtualOffset = (DWORD)GetPE32DataFromMappedFile(FileMapVA, i, UE_SECTIONVIRTUALOFFSET);
                glbEntryTracerData.SectionData[i].SectionVirtualSize = (DWORD)GetPE32DataFromMappedFile(FileMapVA, i, UE_SECTIONVIRTUALSIZE);
                if(glbEntryTracerData.SectionData[i].SectionVirtualSize % 0x1000 != 0) //SectionAlignment, the default value is the page size for the system.
                {
                    glbEntryTracerData.SectionData[i].SectionVirtualSize = ((glbEntryTracerData.SectionData[i].SectionVirtualSize / 0x1000) + 1) * 0x1000;
                }
                glbEntryTracerData.SectionData[i].SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, i, UE_SECTIONFLAGS);
            }
            glbEntryTracerData.EPCallBack = CallBack;
            glbEntryTracerData.InitCallBack = TraceInitCallBack;
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            if(glbEntryTracerData.FileIsDLL)
            {
                return false;
            }
            else
            {
                return true;
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        }
    }
    return false;
}



================================================
File: TitanEngine/Global.OEPFinder.h
================================================
#ifndef _GLOBAL_OEPFINDER_H
#define _GLOBAL_OEPFINDER_H

extern GenericOEPTracerData glbEntryTracerData;

void GenericOEPVirtualProtectHit();
void GenericOEPTraceHit();
void GenericOEPTraceHited();
void GenericOEPLibraryDetailsHit();
void GenericOEPTraceInit();
bool GenericOEPFileInitW(wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);

#endif //_GLOBAL_OEPFINDER_H


================================================
File: TitanEngine/Global.Realigner.cpp
================================================
#include "stdafx.h"
#include "Global.Realigner.h"

// Global.Realigner.functions:
void SetOverallFileStatus(PFILE_STATUS_INFO myFileInfo, BYTE FiledStatus, bool FiledCritical)
{

    if(myFileInfo->OveralEvaluation == UE_RESULT_FILE_OK || myFileInfo->OveralEvaluation == UE_RESULT_FILE_INVALID_BUT_FIXABLE)
    {
        if(FiledStatus == UE_FIELD_FIXABLE_CRITICAL || FiledStatus == UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE || FiledStatus == UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED)
        {
            myFileInfo->OveralEvaluation = UE_RESULT_FILE_INVALID_BUT_FIXABLE;
        }
        else if(FiledStatus == UE_FIELD_BROKEN_NON_FIXABLE && FiledCritical == true)
        {
            myFileInfo->OveralEvaluation = UE_RESULT_FILE_INVALID_AND_NON_FIXABLE;
        }
        else if(FiledStatus == UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE)
        {
            myFileInfo->OveralEvaluation = UE_RESULT_FILE_INVALID_BUT_FIXABLE;
        }
    }
}


================================================
File: TitanEngine/Global.Realigner.h
================================================
#ifndef _GLOBAL_REALIGNER_H
#define _GLOBAL_REALIGNER_H

void SetOverallFileStatus(PFILE_STATUS_INFO myFileInfo, BYTE FiledStatus, bool FiledCritical);

#endif //_GLOBAL_REALIGNER_H


================================================
File: TitanEngine/Global.TLS.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.TLS.h"

ULONG_PTR engineTLSBreakOnCallBackAddress;
bool engineTLSBreakOnCallBack = false;

void ClearTlsVector(std::vector<ULONG_PTR>* vec)
{
    std::vector<ULONG_PTR>().swap(*vec);
}


================================================
File: TitanEngine/Global.TLS.h
================================================
#ifndef _GLOBAL_TLS_H
#define _GLOBAL_TLS_H

#include <vector>

extern ULONG_PTR engineTLSBreakOnCallBackAddress;
extern bool engineTLSBreakOnCallBack;

void ClearTlsVector(std::vector<ULONG_PTR>* vec);

#endif //_GLOBAL_TLS_H


================================================
File: TitanEngine/Global.Threader.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Threader.h"

std::vector<THREAD_ITEM_DATA> hListThread;

void ClearThreadList()
{
    std::vector<THREAD_ITEM_DATA>().swap(hListThread);
}



================================================
File: TitanEngine/Global.Threader.h
================================================
#ifndef _GLOBAL_THREADER_H
#define _GLOBAL_THREADER_H

#include <vector>

extern std::vector<THREAD_ITEM_DATA> hListThread;

void ClearThreadList();

#endif //_GLOBAL_THREADER_H



================================================
File: TitanEngine/LOGO.bmp
================================================
[Non-text file]


================================================
File: TitanEngine/LzmaDec.cpp
================================================
/* LzmaDec.c -- LZMA Decoder
2008-11-06 : Igor Pavlov : Public domain */

#include "stdafx.h"
#include "LzmaDec.h"

#include <string.h>

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5

#define RC_INIT_SIZE 5

#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
  { UPDATE_0(p); i = (i + i); A0; } else \
  { UPDATE_1(p); i = (i + i) + 1; A1; }
#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)

#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
#define TREE_DECODE(probs, limit, i) \
  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }

/* #define _LZMA_SIZE_OPT */

#ifdef _LZMA_SIZE_OPT
#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
#else
#define TREE_6_DECODE(probs, i) \
  { i = 1; \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  i -= 0x40; }
#endif

#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0_CHECK range = bound;
#define UPDATE_1_CHECK range -= bound; code -= bound;
#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
  { UPDATE_0_CHECK; i = (i + i); A0; } else \
  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
#define TREE_DECODE_CHECK(probs, limit, i) \
  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }


#define kNumPosBitsMax 4
#define kNumPosStatesMax (1 << kNumPosBitsMax)

#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define LenChoice 0
#define LenChoice2 (LenChoice + 1)
#define LenLow (LenChoice2 + 1)
#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
#define kNumLenProbs (LenHigh + kLenNumHighSymbols)


#define kNumStates 12
#define kNumLitStates 7

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))

#define kNumPosSlotBits 6
#define kNumLenToPosStates 4

#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)

#define kMatchMinLen 2
#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)

#define IsMatch 0
#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
#define IsRepG0 (IsRep + kNumStates)
#define IsRepG1 (IsRepG0 + kNumStates)
#define IsRepG2 (IsRepG1 + kNumStates)
#define IsRep0Long (IsRepG2 + kNumStates)
#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
#define LenCoder (Align + kAlignTableSize)
#define RepLenCoder (LenCoder + kNumLenProbs)
#define Literal (RepLenCoder + kNumLenProbs)

#define LZMA_BASE_SIZE 1846
#define LZMA_LIT_SIZE 768

#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))

#if Literal != LZMA_BASE_SIZE
StopCompilingDueBUG
#endif

static const Byte kLiteralNextStates[kNumStates * 2] =
{
    0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
    7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
};

#define LZMA_DIC_MIN (1 << 12)

/* First LZMA-symbol is always decoded.
And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
Out:
  Result:
    SZ_OK - OK
    SZ_ERROR_DATA - Error
  p->remainLen:
    < kMatchSpecLenStart : normal remain
    = kMatchSpecLenStart : finished
    = kMatchSpecLenStart + 1 : Flush marker
    = kMatchSpecLenStart + 2 : State Init Marker
*/

static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec* p, SizeT limit, const Byte* bufLimit)
{
    CLzmaProb* probs = p->probs;

    unsigned state = p->state;
    UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
    unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
    unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
    unsigned lc = p->prop.lc;

    Byte* dic = p->dic;
    SizeT dicBufSize = p->dicBufSize;
    SizeT dicPos = p->dicPos;

    UInt32 processedPos = p->processedPos;
    UInt32 checkDicSize = p->checkDicSize;
    unsigned len = 0;

    const Byte* buf = p->buf;
    UInt32 range = p->range;
    UInt32 code = p->code;

    do
    {
        CLzmaProb* prob;
        UInt32 bound;
        unsigned ttt;
        unsigned posState = processedPos & pbMask;

        prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
        IF_BIT_0(prob)
        {
            unsigned symbol;
            UPDATE_0(prob);
            prob = probs + Literal;
            if(checkDicSize != 0 || processedPos != 0)
                prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
                                          (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));

            if(state < kNumLitStates)
            {
                symbol = 1;
                do
                {
                    GET_BIT(prob + symbol, symbol)
                }
                while(symbol < 0x100);
            }
            else
            {
                unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
                unsigned offs = 0x100;
                symbol = 1;
                do
                {
                    unsigned bit;
                    CLzmaProb* probLit;
                    matchByte <<= 1;
                    bit = (matchByte & offs);
                    probLit = prob + offs + bit + symbol;
                    GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
                }
                while(symbol < 0x100);
            }
            dic[dicPos++] = (Byte)symbol;
            processedPos++;

            state = kLiteralNextStates[state];
            /* if (state < 4) state = 0; else if (state < 10) state -= 3; else state -= 6; */
            continue;
        }
        else
        {
            UPDATE_1(prob);
            prob = probs + IsRep + state;
            IF_BIT_0(prob)
            {
                UPDATE_0(prob);
                state += kNumStates;
                prob = probs + LenCoder;
            }
            else
            {
                UPDATE_1(prob);
                if(checkDicSize == 0 && processedPos == 0)
                    return SZ_ERROR_DATA;
                prob = probs + IsRepG0 + state;
                IF_BIT_0(prob)
                {
                    UPDATE_0(prob);
                    prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
                    IF_BIT_0(prob)
                    {
                        UPDATE_0(prob);
                        dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
                        dicPos++;
                        processedPos++;
                        state = state < kNumLitStates ? 9 : 11;
                        continue;
                    }
                    UPDATE_1(prob);
                }
                else
                {
                    UInt32 distance;
                    UPDATE_1(prob);
                    prob = probs + IsRepG1 + state;
                    IF_BIT_0(prob)
                    {
                        UPDATE_0(prob);
                        distance = rep1;
                    }
                    else
                    {
                        UPDATE_1(prob);
                        prob = probs + IsRepG2 + state;
                        IF_BIT_0(prob)
                        {
                            UPDATE_0(prob);
                            distance = rep2;
                        }
                        else
                        {
                            UPDATE_1(prob);
                            distance = rep3;
                            rep3 = rep2;
                        }
                        rep2 = rep1;
                    }
                    rep1 = rep0;
                    rep0 = distance;
                }
                state = state < kNumLitStates ? 8 : 11;
                prob = probs + RepLenCoder;
            }
            {
                unsigned limit, offset;
                CLzmaProb* probLen = prob + LenChoice;
                IF_BIT_0(probLen)
                {
                    UPDATE_0(probLen);
                    probLen = prob + LenLow + (posState << kLenNumLowBits);
                    offset = 0;
                    limit = (1 << kLenNumLowBits);
                }
                else
                {
                    UPDATE_1(probLen);
                    probLen = prob + LenChoice2;
                    IF_BIT_0(probLen)
                    {
                        UPDATE_0(probLen);
                        probLen = prob + LenMid + (posState << kLenNumMidBits);
                        offset = kLenNumLowSymbols;
                        limit = (1 << kLenNumMidBits);
                    }
                    else
                    {
                        UPDATE_1(probLen);
                        probLen = prob + LenHigh;
                        offset = kLenNumLowSymbols + kLenNumMidSymbols;
                        limit = (1 << kLenNumHighBits);
                    }
                }
                TREE_DECODE(probLen, limit, len);
                len += offset;
            }

            if(state >= kNumStates)
            {
                UInt32 distance;
                prob = probs + PosSlot +
                       ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
                TREE_6_DECODE(prob, distance);
                if(distance >= kStartPosModelIndex)
                {
                    unsigned posSlot = (unsigned)distance;
                    int numDirectBits = (int)(((distance >> 1) - 1));
                    distance = (2 | (distance & 1));
                    if(posSlot < kEndPosModelIndex)
                    {
                        distance <<= numDirectBits;
                        prob = probs + SpecPos + distance - posSlot - 1;
                        {
                            UInt32 mask = 1;
                            unsigned i = 1;
                            do
                            {
                                GET_BIT2(prob + i, i, ;, distance |= mask);
                                mask <<= 1;
                            }
                            while(--numDirectBits != 0);
                        }
                    }
                    else
                    {
                        numDirectBits -= kNumAlignBits;
                        do
                        {
                            NORMALIZE
                            range >>= 1;

                            {
                                UInt32 t;
                                code -= range;
                                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
                                distance = (distance << 1) + (t + 1);
                                code += range & t;
                            }
                            /*
                            distance <<= 1;
                            if (code >= range)
                            {
                              code -= range;
                              distance |= 1;
                            }
                            */
                        }
                        while(--numDirectBits != 0);
                        prob = probs + Align;
                        distance <<= kNumAlignBits;
                        {
                            unsigned i = 1;
                            GET_BIT2(prob + i, i, ;, distance |= 1);
                            GET_BIT2(prob + i, i, ;, distance |= 2);
                            GET_BIT2(prob + i, i, ;, distance |= 4);
                            GET_BIT2(prob + i, i, ;, distance |= 8);
                        }
                        if(distance == (UInt32)0xFFFFFFFF)
                        {
                            len += kMatchSpecLenStart;
                            state -= kNumStates;
                            break;
                        }
                    }
                }
                rep3 = rep2;
                rep2 = rep1;
                rep1 = rep0;
                rep0 = distance + 1;
                if(checkDicSize == 0)
                {
                    if(distance >= processedPos)
                        return SZ_ERROR_DATA;
                }
                else if(distance >= checkDicSize)
                    return SZ_ERROR_DATA;
                state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
                /* state = kLiteralNextStates[state]; */
            }

            len += kMatchMinLen;

            if(limit == dicPos)
                return SZ_ERROR_DATA;
            {
                SizeT rem = limit - dicPos;
                unsigned curLen = ((rem < len) ? (unsigned)rem : len);
                SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);

                processedPos += curLen;

                len -= curLen;
                if(pos + curLen <= dicBufSize)
                {
                    Byte* dest = dic + dicPos;
                    ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
                    const Byte* lim = dest + curLen;
                    dicPos += curLen;
                    do
                        *(dest) = (Byte) * (dest + src);
                    while(++dest != lim);
                }
                else
                {
                    do
                    {
                        dic[dicPos++] = dic[pos];
                        if(++pos == dicBufSize)
                            pos = 0;
                    }
                    while(--curLen != 0);
                }
            }
        }
    }
    while(dicPos < limit && buf < bufLimit);
    NORMALIZE;
    p->buf = buf;
    p->range = range;
    p->code = code;
    p->remainLen = len;
    p->dicPos = dicPos;
    p->processedPos = processedPos;
    p->reps[0] = rep0;
    p->reps[1] = rep1;
    p->reps[2] = rep2;
    p->reps[3] = rep3;
    p->state = state;

    return SZ_OK;
}

static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec* p, SizeT limit)
{
    if(p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
    {
        Byte* dic = p->dic;
        SizeT dicPos = p->dicPos;
        SizeT dicBufSize = p->dicBufSize;
        unsigned len = p->remainLen;
        UInt32 rep0 = p->reps[0];
        if(limit - dicPos < len)
            len = (unsigned)(limit - dicPos);

        if(p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
            p->checkDicSize = p->prop.dicSize;

        p->processedPos += len;
        p->remainLen -= len;
        while(len-- != 0)
        {
            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
            dicPos++;
        }
        p->dicPos = dicPos;
    }
}

static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec* p, SizeT limit, const Byte* bufLimit)
{
    do
    {
        SizeT limit2 = limit;
        if(p->checkDicSize == 0)
        {
            UInt32 rem = p->prop.dicSize - p->processedPos;
            if(limit - p->dicPos > rem)
                limit2 = p->dicPos + rem;
        }
        RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
        if(p->processedPos >= p->prop.dicSize)
            p->checkDicSize = p->prop.dicSize;
        LzmaDec_WriteRem(p, limit);
    }
    while(p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);

    if(p->remainLen > kMatchSpecLenStart)
    {
        p->remainLen = kMatchSpecLenStart;
    }
    return 0;
}

typedef enum
{
    DUMMY_ERROR, /* unexpected end of input stream */
    DUMMY_LIT,
    DUMMY_MATCH,
    DUMMY_REP
} ELzmaDummy;

static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec* p, const Byte* buf, SizeT inSize)
{
    UInt32 range = p->range;
    UInt32 code = p->code;
    const Byte* bufLimit = buf + inSize;
    CLzmaProb* probs = p->probs;
    unsigned state = p->state;
    ELzmaDummy res;

    {
        CLzmaProb* prob;
        UInt32 bound;
        unsigned ttt;
        unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);

        prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
        IF_BIT_0_CHECK(prob)
        {
            UPDATE_0_CHECK

            /* if (bufLimit - buf >= 7) return DUMMY_LIT; */

            prob = probs + Literal;
            if(p->checkDicSize != 0 || p->processedPos != 0)
                prob += (LZMA_LIT_SIZE *
                         ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
                          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));

            if(state < kNumLitStates)
            {
                unsigned symbol = 1;
                do
                {
                    GET_BIT_CHECK(prob + symbol, symbol)
                }
                while(symbol < 0x100);
            }
            else
            {
                unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
                                                      ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
                unsigned offs = 0x100;
                unsigned symbol = 1;
                do
                {
                    unsigned bit;
                    CLzmaProb* probLit;
                    matchByte <<= 1;
                    bit = (matchByte & offs);
                    probLit = prob + offs + bit + symbol;
                    GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
                }
                while(symbol < 0x100);
            }
            res = DUMMY_LIT;
        }
        else
        {
            unsigned len;
            UPDATE_1_CHECK;

            prob = probs + IsRep + state;
            IF_BIT_0_CHECK(prob)
            {
                UPDATE_0_CHECK;
                state = 0;
                prob = probs + LenCoder;
                res = DUMMY_MATCH;
            }
            else
            {
                UPDATE_1_CHECK;
                res = DUMMY_REP;
                prob = probs + IsRepG0 + state;
                IF_BIT_0_CHECK(prob)
                {
                    UPDATE_0_CHECK;
                    prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
                    IF_BIT_0_CHECK(prob)
                    {
                        UPDATE_0_CHECK;
                        NORMALIZE_CHECK;
                        return DUMMY_REP;
                    }
                    else
                    {
                        UPDATE_1_CHECK;
                    }
                }
                else
                {
                    UPDATE_1_CHECK;
                    prob = probs + IsRepG1 + state;
                    IF_BIT_0_CHECK(prob)
                    {
                        UPDATE_0_CHECK;
                    }
                    else
                    {
                        UPDATE_1_CHECK;
                        prob = probs + IsRepG2 + state;
                        IF_BIT_0_CHECK(prob)
                        {
                            UPDATE_0_CHECK;
                        }
                        else
                        {
                            UPDATE_1_CHECK;
                        }
                    }
                }
                state = kNumStates;
                prob = probs + RepLenCoder;
            }
            {
                unsigned limit, offset;
                CLzmaProb* probLen = prob + LenChoice;
                IF_BIT_0_CHECK(probLen)
                {
                    UPDATE_0_CHECK;
                    probLen = prob + LenLow + (posState << kLenNumLowBits);
                    offset = 0;
                    limit = 1 << kLenNumLowBits;
                }
                else
                {
                    UPDATE_1_CHECK;
                    probLen = prob + LenChoice2;
                    IF_BIT_0_CHECK(probLen)
                    {
                        UPDATE_0_CHECK;
                        probLen = prob + LenMid + (posState << kLenNumMidBits);
                        offset = kLenNumLowSymbols;
                        limit = 1 << kLenNumMidBits;
                    }
                    else
                    {
                        UPDATE_1_CHECK;
                        probLen = prob + LenHigh;
                        offset = kLenNumLowSymbols + kLenNumMidSymbols;
                        limit = 1 << kLenNumHighBits;
                    }
                }
                TREE_DECODE_CHECK(probLen, limit, len);
                len += offset;
            }

            if(state < 4)
            {
                unsigned posSlot;
                prob = probs + PosSlot +
                       ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
                        kNumPosSlotBits);
                TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
                if(posSlot >= kStartPosModelIndex)
                {
                    int numDirectBits = ((posSlot >> 1) - 1);

                    /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */

                    if(posSlot < kEndPosModelIndex)
                    {
                        prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
                    }
                    else
                    {
                        numDirectBits -= kNumAlignBits;
                        do
                        {
                            NORMALIZE_CHECK
                            range >>= 1;
                            code -= range & (((code - range) >> 31) - 1);
                            /* if (code >= range) code -= range; */
                        }
                        while(--numDirectBits != 0);
                        prob = probs + Align;
                        numDirectBits = kNumAlignBits;
                    }
                    {
                        unsigned i = 1;
                        do
                        {
                            GET_BIT_CHECK(prob + i, i);
                        }
                        while(--numDirectBits != 0);
                    }
                }
            }
        }
    }
    NORMALIZE_CHECK;
    return res;
}


static void LzmaDec_InitRc(CLzmaDec* p, const Byte* data)
{
    p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
    p->range = 0xFFFFFFFF;
    p->needFlush = 0;
}

void LzmaDec_InitDicAndState(CLzmaDec* p, Bool initDic, Bool initState)
{
    p->needFlush = 1;
    p->remainLen = 0;
    p->tempBufSize = 0;

    if(initDic)
    {
        p->processedPos = 0;
        p->checkDicSize = 0;
        p->needInitState = 1;
    }
    if(initState)
        p->needInitState = 1;
}

void LzmaDec_Init(CLzmaDec* p)
{
    p->dicPos = 0;
    LzmaDec_InitDicAndState(p, True, True);
}

static void LzmaDec_InitStateReal(CLzmaDec* p)
{
    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
    UInt32 i;
    CLzmaProb* probs = p->probs;
    for(i = 0; i < numProbs; i++)
        probs[i] = kBitModelTotal >> 1;
    p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
    p->state = 0;
    p->needInitState = 0;
}

SRes LzmaDec_DecodeToDic(CLzmaDec* p, SizeT dicLimit, const Byte* src, SizeT* srcLen,
                         ELzmaFinishMode finishMode, ELzmaStatus* status)
{
    SizeT inSize = *srcLen;
    (*srcLen) = 0;
    LzmaDec_WriteRem(p, dicLimit);

    *status = LZMA_STATUS_NOT_SPECIFIED;

    while(p->remainLen != kMatchSpecLenStart)
    {
        int checkEndMarkNow;

        if(p->needFlush != 0)
        {
            for(; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
                p->tempBuf[p->tempBufSize++] = *src++;
            if(p->tempBufSize < RC_INIT_SIZE)
            {
                *status = LZMA_STATUS_NEEDS_MORE_INPUT;
                return SZ_OK;
            }
            if(p->tempBuf[0] != 0)
                return SZ_ERROR_DATA;

            LzmaDec_InitRc(p, p->tempBuf);
            p->tempBufSize = 0;
        }

        checkEndMarkNow = 0;
        if(p->dicPos >= dicLimit)
        {
            if(p->remainLen == 0 && p->code == 0)
            {
                *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
                return SZ_OK;
            }
            if(finishMode == LZMA_FINISH_ANY)
            {
                *status = LZMA_STATUS_NOT_FINISHED;
                return SZ_OK;
            }
            if(p->remainLen != 0)
            {
                *status = LZMA_STATUS_NOT_FINISHED;
                return SZ_ERROR_DATA;
            }
            checkEndMarkNow = 1;
        }

        if(p->needInitState)
            LzmaDec_InitStateReal(p);

        if(p->tempBufSize == 0)
        {
            SizeT processed;
            const Byte* bufLimit;
            if(inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
            {
                int dummyRes = LzmaDec_TryDummy(p, src, inSize);
                if(dummyRes == DUMMY_ERROR)
                {
                    memcpy(p->tempBuf, src, inSize);
                    p->tempBufSize = (unsigned)inSize;
                    (*srcLen) += inSize;
                    *status = LZMA_STATUS_NEEDS_MORE_INPUT;
                    return SZ_OK;
                }
                if(checkEndMarkNow && dummyRes != DUMMY_MATCH)
                {
                    *status = LZMA_STATUS_NOT_FINISHED;
                    return SZ_ERROR_DATA;
                }
                bufLimit = src;
            }
            else
                bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
            p->buf = src;
            if(LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
                return SZ_ERROR_DATA;
            processed = (SizeT)(p->buf - src);
            (*srcLen) += processed;
            src += processed;
            inSize -= processed;
        }
        else
        {
            unsigned rem = p->tempBufSize, lookAhead = 0;
            while(rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
                p->tempBuf[rem++] = src[lookAhead++];
            p->tempBufSize = rem;
            if(rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
            {
                int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
                if(dummyRes == DUMMY_ERROR)
                {
                    (*srcLen) += lookAhead;
                    *status = LZMA_STATUS_NEEDS_MORE_INPUT;
                    return SZ_OK;
                }
                if(checkEndMarkNow && dummyRes != DUMMY_MATCH)
                {
                    *status = LZMA_STATUS_NOT_FINISHED;
                    return SZ_ERROR_DATA;
                }
            }
            p->buf = p->tempBuf;
            if(LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
                return SZ_ERROR_DATA;
            lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
            (*srcLen) += lookAhead;
            src += lookAhead;
            inSize -= lookAhead;
            p->tempBufSize = 0;
        }
    }
    if(p->code == 0)
        *status = LZMA_STATUS_FINISHED_WITH_MARK;
    return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
}

SRes LzmaDec_DecodeToBuf(CLzmaDec* p, Byte* dest, SizeT* destLen, const Byte* src, SizeT* srcLen, ELzmaFinishMode finishMode, ELzmaStatus* status)
{
    SizeT outSize = *destLen;
    SizeT inSize = *srcLen;
    *srcLen = *destLen = 0;
    for(;;)
    {
        SizeT inSizeCur = inSize, outSizeCur, dicPos;
        ELzmaFinishMode curFinishMode;
        SRes res;
        if(p->dicPos == p->dicBufSize)
            p->dicPos = 0;
        dicPos = p->dicPos;
        if(outSize > p->dicBufSize - dicPos)
        {
            outSizeCur = p->dicBufSize;
            curFinishMode = LZMA_FINISH_ANY;
        }
        else
        {
            outSizeCur = dicPos + outSize;
            curFinishMode = finishMode;
        }

        res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
        src += inSizeCur;
        inSize -= inSizeCur;
        *srcLen += inSizeCur;
        outSizeCur = p->dicPos - dicPos;
        memcpy(dest, p->dic + dicPos, outSizeCur);
        dest += outSizeCur;
        outSize -= outSizeCur;
        *destLen += outSizeCur;
        if(res != 0)
            return res;
        if(outSizeCur == 0 || outSize == 0)
            return SZ_OK;
    }
}

void LzmaDec_FreeProbs(CLzmaDec* p, ISzAlloc* alloc)
{
    alloc->Free(alloc, p->probs);
    p->probs = 0;
}

static void LzmaDec_FreeDict(CLzmaDec* p, ISzAlloc* alloc)
{
    alloc->Free(alloc, p->dic);
    p->dic = 0;
}

void LzmaDec_Free(CLzmaDec* p, ISzAlloc* alloc)
{
    LzmaDec_FreeProbs(p, alloc);
    LzmaDec_FreeDict(p, alloc);
}

SRes LzmaProps_Decode(CLzmaProps* p, const Byte* data, unsigned size)
{
    UInt32 dicSize;
    Byte d;

    if(size < LZMA_PROPS_SIZE)
        return SZ_ERROR_UNSUPPORTED;
    else
        dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);

    if(dicSize < LZMA_DIC_MIN)
        dicSize = LZMA_DIC_MIN;
    p->dicSize = dicSize;

    d = data[0];
    if(d >= (9 * 5 * 5))
        return SZ_ERROR_UNSUPPORTED;

    p->lc = d % 9;
    d /= 9;
    p->pb = d / 5;
    p->lp = d % 5;

    return SZ_OK;
}

static SRes LzmaDec_AllocateProbs2(CLzmaDec* p, const CLzmaProps* propNew, ISzAlloc* alloc)
{
    UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
    if(p->probs == 0 || numProbs != p->numProbs)
    {
        LzmaDec_FreeProbs(p, alloc);
        p->probs = (CLzmaProb*)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
        p->numProbs = numProbs;
        if(p->probs == 0)
            return SZ_ERROR_MEM;
    }
    return SZ_OK;
}

SRes LzmaDec_AllocateProbs(CLzmaDec* p, const Byte* props, unsigned propsSize, ISzAlloc* alloc)
{
    CLzmaProps propNew;
    RINOK(LzmaProps_Decode(&propNew, props, propsSize));
    RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
    p->prop = propNew;
    return SZ_OK;
}

SRes LzmaDec_Allocate(CLzmaDec* p, const Byte* props, unsigned propsSize, ISzAlloc* alloc)
{
    CLzmaProps propNew;
    SizeT dicBufSize;
    RINOK(LzmaProps_Decode(&propNew, props, propsSize));
    RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
    dicBufSize = propNew.dicSize;
    if(p->dic == 0 || dicBufSize != p->dicBufSize)
    {
        LzmaDec_FreeDict(p, alloc);
        p->dic = (Byte*)alloc->Alloc(alloc, dicBufSize);
        if(p->dic == 0)
        {
            LzmaDec_FreeProbs(p, alloc);
            return SZ_ERROR_MEM;
        }
    }
    p->dicBufSize = dicBufSize;
    p->prop = propNew;
    return SZ_OK;
}

SRes LzmaDecode(Byte* dest, SizeT* destLen, const Byte* src, SizeT* srcLen,
                const Byte* propData, unsigned propSize, ELzmaFinishMode finishMode,
                ELzmaStatus* status, ISzAlloc* alloc)
{
    CLzmaDec p;
    SRes res;
    SizeT inSize = *srcLen;
    SizeT outSize = *destLen;
    *srcLen = *destLen = 0;
    if(inSize < RC_INIT_SIZE)
        return SZ_ERROR_INPUT_EOF;

    LzmaDec_Construct(&p);
    res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
    if(res != 0)
        return res;
    p.dic = dest;
    p.dicBufSize = outSize;

    LzmaDec_Init(&p);

    *srcLen = inSize;
    res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);

    if(res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
        res = SZ_ERROR_INPUT_EOF;

    (*destLen) = p.dicPos;
    LzmaDec_FreeProbs(&p, alloc);
    return res;
}

void* LzmaAllocMem(void* p, size_t size)
{
    return(VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE));
}

void LzmaFreeMem(void* p, void* address)
{
    VirtualFree(address, NULL, MEM_RELEASE);
}



================================================
File: TitanEngine/LzmaDec.h
================================================
/* LzmaDec.h -- LZMA Decoder
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZMADEC_H
#define __LZMADEC_H

#include "LzmaTypes.h"

/* #define _LZMA_PROB32 */
/* _LZMA_PROB32 can increase the speed on some CPUs,
   but memory usage for CLzmaDec::probs will be doubled in that case */

#ifdef _LZMA_PROB32
#define CLzmaProb UInt32
#else
#define CLzmaProb UInt16
#endif


/* ---------- LZMA Properties ---------- */

#define LZMA_PROPS_SIZE 5

typedef struct _CLzmaProps
{
    unsigned lc, lp, pb;
    UInt32 dicSize;
} CLzmaProps;

/* LzmaProps_Decode - decodes properties
Returns:
  SZ_OK
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/

SRes LzmaProps_Decode(CLzmaProps* p, const Byte* data, unsigned size);


/* ---------- LZMA Decoder state ---------- */

/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */

#define LZMA_REQUIRED_INPUT_MAX 20

typedef struct
{
    CLzmaProps prop;
    CLzmaProb* probs;
    Byte* dic;
    const Byte* buf;
    UInt32 range, code;
    SizeT dicPos;
    SizeT dicBufSize;
    UInt32 processedPos;
    UInt32 checkDicSize;
    unsigned state;
    UInt32 reps[4];
    unsigned remainLen;
    int needFlush;
    int needInitState;
    UInt32 numProbs;
    unsigned tempBufSize;
    Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
} CLzmaDec;

#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }

void LzmaDec_Init(CLzmaDec* p);

/* There are two types of LZMA streams:
     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */

typedef enum
{
    LZMA_FINISH_ANY,   /* finish at any point */
    LZMA_FINISH_END    /* block must be finished at the end */
} ELzmaFinishMode;

/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!

   You must use LZMA_FINISH_END, when you know that current output buffer
   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.

   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
   and output value of destLen will be less than output buffer size limit.
   You can check status result also.

   You can use multiple checks to test data integrity after full decompression:
     1) Check Result and "status" variable.
     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
        You must use correct finish mode in that case. */

typedef enum
{
    LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
    LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
    LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
    LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
    LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
} ELzmaStatus;

/* ELzmaStatus is used only as output value for function call */


/* ---------- Interfaces ---------- */

/* There are 3 levels of interfaces:
     1) Dictionary Interface
     2) Buffer Interface
     3) One Call Interface
   You can select any of these interfaces, but don't mix functions from different
   groups for same object. */


/* There are two variants to allocate state for Dictionary Interface:
     1) LzmaDec_Allocate / LzmaDec_Free
     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
   You can use variant 2, if you set dictionary buffer manually.
   For Buffer Interface you must always use variant 1.

LzmaDec_Allocate* can return:
  SZ_OK
  SZ_ERROR_MEM         - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/

SRes LzmaDec_AllocateProbs(CLzmaDec* p, const Byte* props, unsigned propsSize, ISzAlloc* alloc);
void LzmaDec_FreeProbs(CLzmaDec* p, ISzAlloc* alloc);

SRes LzmaDec_Allocate(CLzmaDec* state, const Byte* prop, unsigned propsSize, ISzAlloc* alloc);
void LzmaDec_Free(CLzmaDec* state, ISzAlloc* alloc);

/* ---------- Dictionary Interface ---------- */

/* You can use it, if you want to eliminate the overhead for data copying from
   dictionary to some other external buffer.
   You must work with CLzmaDec variables directly in this interface.

   STEPS:
     LzmaDec_Constr()
     LzmaDec_Allocate()
     for (each new stream)
     {
       LzmaDec_Init()
       while (it needs more decompression)
       {
         LzmaDec_DecodeToDic()
         use data from CLzmaDec::dic and update CLzmaDec::dicPos
       }
     }
     LzmaDec_Free()
*/

/* LzmaDec_DecodeToDic

   The decoding to internal dictionary buffer (CLzmaDec::dic).
   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!

finishMode:
  It has meaning only if the decoding reaches output limit (dicLimit).
  LZMA_FINISH_ANY - Decode just dicLimit bytes.
  LZMA_FINISH_END - Stream must be finished after dicLimit.

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_NEEDS_MORE_INPUT
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
*/

SRes LzmaDec_DecodeToDic(CLzmaDec* p, SizeT dicLimit,
                         const Byte* src, SizeT* srcLen, ELzmaFinishMode finishMode, ELzmaStatus* status);


/* ---------- Buffer Interface ---------- */

/* It's zlib-like interface.
   See LzmaDec_DecodeToDic description for information about STEPS and return results,
   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
   to work with CLzmaDec variables manually.

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).
*/

SRes LzmaDec_DecodeToBuf(CLzmaDec* p, Byte* dest, SizeT* destLen,
                         const Byte* src, SizeT* srcLen, ELzmaFinishMode finishMode, ELzmaStatus* status);


/* ---------- One Call Interface ---------- */

/* LzmaDecode

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
*/

SRes LzmaDecode(Byte* dest, SizeT* destLen, const Byte* src, SizeT* srcLen,
                const Byte* propData, unsigned propSize, ELzmaFinishMode finishMode,
                ELzmaStatus* status, ISzAlloc* alloc);

#endif



================================================
File: TitanEngine/LzmaTypes.h
================================================
/* Types.h -- Basic types
2008-11-23 : Igor Pavlov : Public domain */

#ifndef __7Z_TYPES_H
#define __7Z_TYPES_H

#include <stddef.h>

#ifdef _WIN32
#include <windows.h>
#endif

#define SZ_OK 0

#define SZ_ERROR_DATA 1
#define SZ_ERROR_MEM 2
#define SZ_ERROR_CRC 3
#define SZ_ERROR_UNSUPPORTED 4
#define SZ_ERROR_PARAM 5
#define SZ_ERROR_INPUT_EOF 6
#define SZ_ERROR_OUTPUT_EOF 7
#define SZ_ERROR_READ 8
#define SZ_ERROR_WRITE 9
#define SZ_ERROR_PROGRESS 10
#define SZ_ERROR_FAIL 11
#define SZ_ERROR_THREAD 12

#define SZ_ERROR_ARCHIVE 16
#define SZ_ERROR_NO_ARCHIVE 17

typedef int SRes;

#ifdef _WIN32
typedef DWORD WRes;
#else
typedef int WRes;
#endif

#ifndef RINOK
#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
#endif

typedef unsigned char Byte;
typedef short Int16;
typedef unsigned short UInt16;

#ifdef _LZMA_UINT32_IS_ULONG
typedef long Int32;
typedef unsigned long UInt32;
#else
typedef int Int32;
typedef unsigned int UInt32;
#endif

#ifdef _SZ_NO_INT_64

/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
   NOTES: Some code will work incorrectly in that case! */

typedef long Int64;
typedef unsigned long UInt64;

#else

#if defined(_MSC_VER) || defined(__BORLANDC__)
typedef __int64 Int64;
typedef unsigned __int64 UInt64;
#else
typedef long long int Int64;
typedef unsigned long long int UInt64;
#endif

#endif

#ifdef _LZMA_NO_SYSTEM_SIZE_T
typedef UInt32 SizeT;
#else
typedef size_t SizeT;
#endif

typedef int Bool;
#define True 1
#define False 0


#ifdef _MSC_VER

#if _MSC_VER >= 1300
#define MY_NO_INLINE __declspec(noinline)
#else
#define MY_NO_INLINE
#endif

#define MY_CDECL __cdecl
#define MY_STD_CALL __stdcall
#define MY_FAST_CALL MY_NO_INLINE __fastcall

#else

#define MY_CDECL
#define MY_STD_CALL
#define MY_FAST_CALL

#endif


/* The following interfaces use first parameter as pointer to structure */

typedef struct
{
    SRes(*Read)(void* p, void* buf, size_t* size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) < input(*size)) is allowed */
} ISeqInStream;

/* it can return SZ_ERROR_INPUT_EOF */
SRes SeqInStream_Read(ISeqInStream* stream, void* buf, size_t size);
SRes SeqInStream_Read2(ISeqInStream* stream, void* buf, size_t size, SRes errorType);
SRes SeqInStream_ReadByte(ISeqInStream* stream, Byte* buf);

typedef struct
{
    size_t (*Write)(void* p, const void* buf, size_t size);
    /* Returns: result - the number of actually written bytes.
       (result < size) means error */
} ISeqOutStream;

typedef enum
{
    SZ_SEEK_SET = 0,
    SZ_SEEK_CUR = 1,
    SZ_SEEK_END = 2
} ESzSeek;

typedef struct
{
    SRes(*Read)(void* p, void* buf, size_t* size);   /* same as ISeqInStream::Read */
    SRes(*Seek)(void* p, Int64* pos, ESzSeek origin);
} ISeekInStream;

typedef struct
{
    SRes(*Look)(void* p, void** buf, size_t* size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) > input(*size)) is not allowed
       (output(*size) < input(*size)) is allowed */
    SRes(*Skip)(void* p, size_t offset);
    /* offset must be <= output(*size) of Look */

    SRes(*Read)(void* p, void* buf, size_t* size);
    /* reads directly (without buffer). It's same as ISeqInStream::Read */
    SRes(*Seek)(void* p, Int64* pos, ESzSeek origin);
} ILookInStream;

SRes LookInStream_LookRead(ILookInStream* stream, void* buf, size_t* size);
SRes LookInStream_SeekTo(ILookInStream* stream, UInt64 offset);

/* reads via ILookInStream::Read */
SRes LookInStream_Read2(ILookInStream* stream, void* buf, size_t size, SRes errorType);
SRes LookInStream_Read(ILookInStream* stream, void* buf, size_t size);

#define LookToRead_BUF_SIZE (1 << 14)

typedef struct
{
    ILookInStream s;
    ISeekInStream* realStream;
    size_t pos;
    size_t size;
    Byte buf[LookToRead_BUF_SIZE];
} CLookToRead;

void LookToRead_CreateVTable(CLookToRead* p, int lookahead);
void LookToRead_Init(CLookToRead* p);

typedef struct
{
    ISeqInStream s;
    ILookInStream* realStream;
} CSecToLook;

void SecToLook_CreateVTable(CSecToLook* p);

typedef struct
{
    ISeqInStream s;
    ILookInStream* realStream;
} CSecToRead;

void SecToRead_CreateVTable(CSecToRead* p);

typedef struct
{
    SRes(*Progress)(void* p, UInt64 inSize, UInt64 outSize);
    /* Returns: result. (result != SZ_OK) means break.
       Value (UInt64)(Int64)-1 for size means unknown value. */
} ICompressProgress;

typedef struct
{
    void* (*Alloc)(void* p, size_t size);
    void (*Free)(void* p, void* address); /* address can be 0 */
} ISzAlloc;

#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
#define IAlloc_Free(p, a) (p)->Free((p), a)

void* LzmaAllocMem(void* p, size_t size);
void LzmaFreeMem(void* p, void* address);

#endif



================================================
File: TitanEngine/TitanEngine.Breakpoints.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Breakpoints.h"
#include "Global.Debugger.h"
#include "Global.Engine.h"
#include "Global.Engine.Threading.h"
#include "Global.Engine.Importer.h"
#include "Global.Threader.h"

static long engineDefaultBreakPointType = UE_BREAKPOINT_INT3;
static BYTE UD2BreakPoint[2] = {0x0F, 0x0B};
static BYTE INT3BreakPoint = 0xCC;
static BYTE INT3LongBreakPoint[2] = {0xCD, 0x03};

__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType)
{
    if(DefaultBreakPointType == UE_BREAKPOINT_INT3 || DefaultBreakPointType == UE_BREAKPOINT_LONG_INT3 || DefaultBreakPointType == UE_BREAKPOINT_UD2)
        engineDefaultBreakPointType = DefaultBreakPointType;
    else if(DefaultBreakPointType == UE_BREAKPOINT_TYPE_INT3)
        engineDefaultBreakPointType = UE_BREAKPOINT_INT3;
    else if(DefaultBreakPointType == UE_BREAKPOINT_TYPE_LONG_INT3)
        engineDefaultBreakPointType = UE_BREAKPOINT_LONG_INT3;
    else if(DefaultBreakPointType == UE_BREAKPOINT_TYPE_UD2)
        engineDefaultBreakPointType = UE_BREAKPOINT_UD2;
}

__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    ULONG_PTR NumberOfBytesReadWritten = 0;
    DWORD MaximumBreakPoints = 0;
    BYTE ReadData[10] = {};
    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        const bool isSoftwareBpx = BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT || BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT;
        if(isSoftwareBpx && BreakPointBuffer.at(i).BreakPointAddress == bpxAddress)
        {
            if(BreakPointBuffer.at(i).BreakPointActive != UE_BPXINACTIVE)
            {
                if(ReadProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &ReadData[0], UE_MAX_BREAKPOINT_SIZE, &NumberOfBytesReadWritten))
                {
                    if(BreakPointBuffer.at(i).AdvancedBreakPointType == UE_BREAKPOINT_INT3 && ReadData[0] == INT3BreakPoint)
                        return true;
                    else if(BreakPointBuffer.at(i).AdvancedBreakPointType == UE_BREAKPOINT_LONG_INT3 && ReadData[0] == INT3LongBreakPoint[0] && ReadData[1] == INT3LongBreakPoint[1])
                        return true;
                    else if(BreakPointBuffer.at(i).AdvancedBreakPointType == UE_BREAKPOINT_UD2 && ReadData[0] == UD2BreakPoint[0] && ReadData[1] == UD2BreakPoint[1])
                        return true;
                    else //TODO: delete breakpoint from list?
                        return false;
                }
                else
                    return false;
            }
            else
                return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR NumberOfBytesReadWritten = 0;
    DWORD MaximumBreakPoints = 0;
    bool testWrite = false;
    DWORD OldProtect;
    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        if(BreakPointBuffer.at(i).BreakPointAddress == bpxAddress)
        {
            VirtualQueryEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
            OldProtect = MemInfo.Protect;
            VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, PAGE_EXECUTE_READWRITE, &OldProtect);
            if(BreakPointBuffer.at(i).BreakPointActive == UE_BPXINACTIVE && (BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT))
            {
                //re-read original byte(s)
                if(ReadProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).OriginalByte, BreakPointBuffer.at(i).BreakPointSize, 0))
                {
                    if(BreakPointBuffer.at(i).AdvancedBreakPointType == UE_BREAKPOINT_INT3)
                    {
                        if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &INT3BreakPoint, 1, &NumberOfBytesReadWritten))
                        {
                            FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
                            testWrite = true;
                        }
                    }
                    else if(BreakPointBuffer.at(i).AdvancedBreakPointType == UE_BREAKPOINT_LONG_INT3)
                    {
                        if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &INT3LongBreakPoint, 2, &NumberOfBytesReadWritten))
                        {
                            FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
                            testWrite = true;
                        }
                    }
                    else if(BreakPointBuffer.at(i).AdvancedBreakPointType == UE_BREAKPOINT_UD2)
                    {
                        if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &UD2BreakPoint, 2, &NumberOfBytesReadWritten))
                        {
                            FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
                            testWrite = true;
                        }
                    }
                    if(testWrite)
                    {
                        BreakPointBuffer.at(i).BreakPointActive = UE_BPXACTIVE;
                        VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, OldProtect, &OldProtect);
                        return true;
                    }
                    else
                    {
                        VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, OldProtect, &OldProtect);
                        return false;
                    }
                }
                else
                {
                    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, OldProtect, &OldProtect);
                    return false;
                }
            }
            else
            {
                VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, OldProtect, &OldProtect);
                return false;
            }
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR NumberOfBytesReadWritten = 0;
    DWORD MaximumBreakPoints = 0;
    DWORD OldProtect;
    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        if(BreakPointBuffer.at(i).BreakPointAddress == bpxAddress)
        {
            VirtualQueryEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
            OldProtect = MemInfo.Protect;
            VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, PAGE_EXECUTE_READWRITE, &OldProtect);
            if(BreakPointBuffer.at(i).BreakPointActive == UE_BPXACTIVE && (BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT))
            {
                if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &BreakPointBuffer.at(i).OriginalByte[0], BreakPointBuffer.at(i).BreakPointSize, &NumberOfBytesReadWritten))
                {
                    FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
                    BreakPointBuffer.at(i).BreakPointActive = UE_BPXINACTIVE;
                    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, OldProtect, &OldProtect);
                    return true;
                }
                else
                {
                    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, OldProtect, &OldProtect);
                    return false;
                }
            }
            else
            {
                VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(i).BreakPointSize, OldProtect, &OldProtect);
                return false;
            }
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    void* bpxDataPrt;
    PMEMORY_COMPARE_HANDLER bpxDataCmpPtr;
    ULONG_PTR NumberOfBytesReadWritten = 0;
    BYTE SelectedBreakPointType;
    DWORD checkBpxType;
    DWORD OldProtect;

    if(bpxCallBack == NULL)
    {
        return false;
    }
    int bpcount = (int)BreakPointBuffer.size();
    //search for breakpoint
    for(int i = 0; i < bpcount; i++)
    {
        if(BreakPointBuffer.at(i).BreakPointAddress == bpxAddress && BreakPointBuffer.at(i).BreakPointActive == UE_BPXACTIVE && (BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT || BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT))
            return false;
        else if(BreakPointBuffer.at(i).BreakPointAddress == bpxAddress && BreakPointBuffer.at(i).BreakPointActive == UE_BPXINACTIVE && (BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT || BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT))
        {
            lock.unlock();
            return EnableBPX(bpxAddress);
        }
    }
    //setup new breakpoint structure
    BreakPointDetail NewBreakPoint;
    memset(&NewBreakPoint, 0, sizeof(BreakPointDetail));
    if(bpxType < UE_BREAKPOINT_TYPE_INT3)
    {
        if(engineDefaultBreakPointType == UE_BREAKPOINT_LONG_INT3)
        {
            SelectedBreakPointType = UE_BREAKPOINT_LONG_INT3;
            NewBreakPoint.BreakPointSize = 2;
            bpxDataPrt = &INT3LongBreakPoint;
        }
        else if(engineDefaultBreakPointType == UE_BREAKPOINT_UD2)
        {
            SelectedBreakPointType = UE_BREAKPOINT_UD2;
            NewBreakPoint.BreakPointSize = 2;
            bpxDataPrt = &UD2BreakPoint;
        }
        else //default
        {
            SelectedBreakPointType = UE_BREAKPOINT_INT3;
            NewBreakPoint.BreakPointSize = 1;
            bpxDataPrt = &INT3BreakPoint;
        }
    }
    else
    {
        checkBpxType = bpxType >> 24;
        checkBpxType = checkBpxType << 24;
        if(checkBpxType == UE_BREAKPOINT_TYPE_INT3)
        {
            SelectedBreakPointType = UE_BREAKPOINT_INT3;
            NewBreakPoint.BreakPointSize = 1;
            bpxDataPrt = &INT3BreakPoint;
        }
        else if(checkBpxType == UE_BREAKPOINT_TYPE_LONG_INT3)
        {
            SelectedBreakPointType = UE_BREAKPOINT_LONG_INT3;
            NewBreakPoint.BreakPointSize = 2;
            bpxDataPrt = &INT3LongBreakPoint;
        }
        else if(checkBpxType == UE_BREAKPOINT_TYPE_UD2)
        {
            SelectedBreakPointType = UE_BREAKPOINT_UD2;
            NewBreakPoint.BreakPointSize = 2;
            bpxDataPrt = &UD2BreakPoint;
        }
    }
    //set breakpoint in process
    bpxDataCmpPtr = (PMEMORY_COMPARE_HANDLER)bpxDataPrt;
    if(!VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, NewBreakPoint.BreakPointSize, PAGE_EXECUTE_READWRITE, &OldProtect))
        return false;
    if(ReadProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &NewBreakPoint.OriginalByte[0], NewBreakPoint.BreakPointSize, &NumberOfBytesReadWritten))
    {
        if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, bpxDataPrt, NewBreakPoint.BreakPointSize, &NumberOfBytesReadWritten))
        {
            FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
            //add new breakpoint to the list
            NewBreakPoint.AdvancedBreakPointType = SelectedBreakPointType & 0xFF;
            NewBreakPoint.BreakPointActive = UE_BPXACTIVE;
            NewBreakPoint.BreakPointAddress = bpxAddress;
            NewBreakPoint.BreakPointType = bpxType & 0xFF;
            NewBreakPoint.ExecuteCallBack = (ULONG_PTR)bpxCallBack;
            BreakPointBuffer.push_back(NewBreakPoint);
            VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, NewBreakPoint.BreakPointSize, OldProtect, &OldProtect);
            return true;
        }
        else
        {
            VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, NewBreakPoint.BreakPointSize, OldProtect, &OldProtect);
            return false;
        }
    }
    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, NewBreakPoint.BreakPointSize, OldProtect, &OldProtect);
    return false;
}

__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    ULONG_PTR NumberOfBytesReadWritten = 0;
    DWORD OldProtect;
    int bpcount = (int)BreakPointBuffer.size();
    int found = -1;
    for(int i = 0; i < bpcount; i++)
    {
        if(BreakPointBuffer.at(i).BreakPointAddress == bpxAddress && (BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT || BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT))
        {
            found = i;
            break;
        }
    }
    if(found == -1) //not found
        return false;
    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(found).BreakPointSize, PAGE_EXECUTE_READWRITE, &OldProtect);
    if(IsBPXEnabled(bpxAddress))
    {
        if(!WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, &BreakPointBuffer.at(found).OriginalByte[0], BreakPointBuffer.at(found).BreakPointSize, &NumberOfBytesReadWritten))
        {
            VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(found).BreakPointSize, OldProtect, &OldProtect);
            return false;
        }
    }
    FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)bpxAddress, BreakPointBuffer.at(found).BreakPointSize, OldProtect, &OldProtect);
    BreakPointBuffer.erase(BreakPointBuffer.begin() + found);
    return true;
}

__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress)
{
    //TODO: remove?
    return DeleteBPX(bpxAddress);
}

__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack)
{
    ULONG_PTR APIAddress = NULL;
    if(szDLLName && szAPIName)
    {
        APIAddress = EngineGetProcAddressRemote(0, szDLLName, szAPIName); //get remote proc address
        if(APIAddress)
        {
            if(bpxPlace == UE_APIEND)
            {
                int i = 0;
                int len = 0;
                unsigned char CmdBuffer[MAXIMUM_INSTRUCTION_SIZE];
                if(!_stricmp(szDLLName, "kernel32.dll"))
                {
                    ULONG_PTR APIAddress_ = EngineGetProcAddressRemote(0, "kernelbase.dll", szAPIName);
                    if(APIAddress_)
                    {
                        bool KernelBase = true;
                        do //search for forwarding indicators
                        {
                            i += len;
                            if(!MemoryReadSafe(dbgProcessInformation.hProcess, (void*)(APIAddress + i), CmdBuffer, sizeof(CmdBuffer), 0))
                                return false;
                            if(CmdBuffer[0] == 0xCC || CmdBuffer[0] == 0x90) //padding
                            {
                                KernelBase = false; //failed to find forward indicator
                                break;
                            }
                            len = StaticLengthDisassemble(CmdBuffer);
                        }
#ifdef _WIN64
                        while(!(CmdBuffer[0] == 0x48 && CmdBuffer[1] == 0xFF && CmdBuffer[2] == 0x25));
#else
                        while(!(CmdBuffer[0] == 0xFF && CmdBuffer[1] == 0x25));
#endif //_WIN64
                        if(KernelBase)
                            APIAddress = APIAddress_;
                        i = 0;
                        len = 0;
                    }
                }
                do  //search for RET
                {
                    i += len;
                    if(!MemoryReadSafe(dbgProcessInformation.hProcess, (void*)(APIAddress + i), CmdBuffer, sizeof(CmdBuffer), 0))
                        return false;
                    len = StaticLengthDisassemble(CmdBuffer);
                }
                while(CmdBuffer[0] != 0xC3 && CmdBuffer[0] != 0xC2);
                APIAddress += i;
            }
            return SetBPX(APIAddress, bpxType, bpxCallBack);
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace)
{
    ULONG_PTR APIAddress = NULL;
    if(szDLLName && szAPIName)
    {
        APIAddress = EngineGetProcAddressRemote(0, szDLLName, szAPIName); //get remote proc address
        if(APIAddress)
        {
            if(bpxPlace == UE_APIEND)
            {
                int i = 0;
                int len = 0;
                unsigned char CmdBuffer[MAXIMUM_INSTRUCTION_SIZE];
                if(!_stricmp(szDLLName, "kernel32.dll"))
                {
                    ULONG_PTR APIAddress_ = EngineGetProcAddressRemote(0, "kernelbase.dll", szAPIName);
                    if(APIAddress_)
                    {
                        bool KernelBase = true;
                        do //search for forwarding indicators
                        {
                            i += len;
                            if(!MemoryReadSafe(dbgProcessInformation.hProcess, (void*)(APIAddress + i), CmdBuffer, sizeof(CmdBuffer), 0))
                                return false;
                            if(CmdBuffer[0] == 0xCC || CmdBuffer[0] == 0x90) //padding
                            {
                                KernelBase = false; //failed to find forward indicator
                                break;
                            }
                            len = StaticLengthDisassemble(CmdBuffer);
                        }
#ifdef _WIN64
                        while(!(CmdBuffer[0] == 0x48 && CmdBuffer[1] == 0xFF && CmdBuffer[2] == 0x25));
#else
                        while(!(CmdBuffer[0] == 0xFF && CmdBuffer[1] == 0x25));
#endif //_WIN64
                        if(KernelBase)
                            APIAddress = APIAddress_;
                        i = 0;
                        len = 0;
                    }
                }
                do  //search for RET
                {
                    i += len;
                    if(!MemoryReadSafe(dbgProcessInformation.hProcess, (void*)(APIAddress + i), CmdBuffer, sizeof(CmdBuffer), 0))
                        return false;
                    len = StaticLengthDisassemble(CmdBuffer);
                }
                while(CmdBuffer[0] != 0xC3 && CmdBuffer[0] != 0xC2);
                APIAddress += i;
            }
            return DeleteBPX(APIAddress);
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace)
{
    //TODO: remove?
    return DeleteAPIBreakPoint(szDLLName, szAPIName, bpxPlace);
}

__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack)
{
    return SetMemoryBPXEx(MemoryStart, SizeOfMemory, UE_MEMORY, false, bpxCallBack);
}

__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack)
{
    struct TempMemoryBreakpointDetails
    {
        ULONG_PTR addr;
        DWORD currentPageProtect;
        MemoryBreakpointPageDetail data;
    };

    CriticalSectionLocker lock(LockBreakPointBuffer);
    bool isSuccess = true;
    DWORD oldProtect;

    // Note: memory breakpoints cannot intersect.
    // Check that there are no other MemBPs in the address range [MemoryStart, MemoryStart+SizeOfMemory)
    int bpcount = (int)BreakPointBuffer.size();
    for(int i = 0; i < bpcount; i++)
    {
        auto bpAddr = BreakPointBuffer.at(i).BreakPointAddress;
        auto bpSize = BreakPointBuffer.at(i).BreakPointSize;
        auto bpType = BreakPointBuffer.at(i).BreakPointType;
        bool isMem = bpType == UE_MEMORY || bpType == UE_MEMORY_READ || bpType == UE_MEMORY_WRITE || bpType == UE_MEMORY_EXECUTE;

        if (isMem && bpAddr < (MemoryStart + SizeOfMemory) && bpAddr + bpSize > MemoryStart)
        {
            return false; // the place is taken
        }
    }

    // Set a proper protection (e.g. PAGE_GUARD) for all pages in the range
    std::vector<TempMemoryBreakpointDetails> breakpointInfos;
    MemoryBreakpointPageDetail pageData;

    auto pageStart = ALIGN_DOWN_BY(MemoryStart, TITANENGINE_PAGESIZE);
    auto pageEnd = ALIGN_UP_BY(MemoryStart + SizeOfMemory, TITANENGINE_PAGESIZE);
    for(ULONG_PTR page = pageStart; page < pageEnd; page += TITANENGINE_PAGESIZE)
    {
        // Save the current page protection in case of a failure
        MEMORY_BASIC_INFORMATION memInfo;
        if(!VirtualQueryEx(dbgProcessInformation.hProcess, (LPCVOID)page, &memInfo, sizeof(memInfo)))
        {
            isSuccess = false;
            break;
        }

        // Update page data and increment a BP counter
        auto found = MemoryBreakpointPages.find(page);
        if(found == MemoryBreakpointPages.end())
        {
            // It's the first memory BP on this page
            pageData.origProtect = memInfo.Protect;
            pageData.accessBps = pageData.readBps = pageData.writeBps = pageData.executeBps = 0;
        }
        else
        {
            // There are other memory BPs on this page
            pageData = found->second; // original protection stays the same
        }

        switch(BreakPointType)
        {
        case UE_MEMORY: // READ + WRITE + EXECUTE
            pageData.accessBps += 1;
            break;
        case UE_MEMORY_READ:
            pageData.readBps += 1;
            break;
        case UE_MEMORY_WRITE:
            pageData.writeBps += 1;
            break;
        case UE_MEMORY_EXECUTE:
            pageData.executeBps += 1;
            break;
        default:    // unreachable
            break;
        }

        // Get a proper MemBp page protection option and apply it
        pageData.newProtect = GetPageProtectionForMemoryBreakpoint(pageData);
        if(!VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)page, TITANENGINE_PAGESIZE, pageData.newProtect, &oldProtect))
        {
            isSuccess = false;
            break;
        }

        TempMemoryBreakpointDetails tempInfo;
        tempInfo.addr = page;
        tempInfo.currentPageProtect = memInfo.Protect;
        tempInfo.data = pageData;
        breakpointInfos.push_back(tempInfo);
    }

    // If changing the page protections failed, attempt to revert the applied protections back
    if(!isSuccess)
    {
        for(const auto & page : breakpointInfos)
            VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)page.addr, TITANENGINE_PAGESIZE, page.currentPageProtect, &oldProtect);
        return false;
    }

    // Save the page data
    for(const auto & page : breakpointInfos)
        MemoryBreakpointPages[page.addr] = page.data;

    // Add a new breakpoint
    BreakPointDetail NewBreakPoint;
    memset(&NewBreakPoint, 0, sizeof(BreakPointDetail));
    NewBreakPoint.BreakPointActive = UE_BPXACTIVE;
    NewBreakPoint.BreakPointAddress = MemoryStart;
    NewBreakPoint.BreakPointSize = SizeOfMemory;
    NewBreakPoint.BreakPointType = BreakPointType;
    NewBreakPoint.MemoryBpxRestoreOnHit = (BYTE)RestoreOnHit;
    NewBreakPoint.ExecuteCallBack = (ULONG_PTR)bpxCallBack;
    BreakPointBuffer.push_back(NewBreakPoint);
    return true;
}

__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    bool isSuccess = true;

    // find the breakpoint
    int nFoundBp = -1;
    size_t bpcount = BreakPointBuffer.size();
    for(size_t i = 0; i < bpcount; i++)
    {
        auto bpAddr = BreakPointBuffer.at(i).BreakPointAddress;
        auto bpType = BreakPointBuffer.at(i).BreakPointType;
        bool isMem = bpType == UE_MEMORY || bpType == UE_MEMORY_READ || bpType == UE_MEMORY_WRITE || bpType == UE_MEMORY_EXECUTE;

        if(isMem && bpAddr == MemoryStart)
        {
            nFoundBp = (int)i;
            break;
        }
    }

    if(nFoundBp == -1)
        return false; // not found

    int memBpType = BreakPointBuffer.at(nFoundBp).BreakPointType;
    SizeOfMemory = BreakPointBuffer.at(nFoundBp).BreakPointSize; // ignore the given size, x64dbg may be lying

    //delete the memory breakpoint from the pages
    auto pageStart = ALIGN_DOWN_BY(MemoryStart, TITANENGINE_PAGESIZE);
    auto pageEnd = ALIGN_UP_BY(MemoryStart + SizeOfMemory, TITANENGINE_PAGESIZE);
    for(ULONG_PTR pageAddr = pageStart; pageAddr < pageEnd; pageAddr += TITANENGINE_PAGESIZE)
    {
        auto foundPageData = MemoryBreakpointPages.find(pageAddr);
        if(foundPageData == MemoryBreakpointPages.end())
            continue; // should not happen

        // Decrement a BP counter
        auto & pageData = foundPageData->second;
        switch(memBpType)
        {
        case UE_MEMORY: // READ + WRITE + EXECUTE
            pageData.accessBps -= 1;
            break;
        case UE_MEMORY_READ:
            pageData.readBps -= 1;
            break;
        case UE_MEMORY_WRITE:
            pageData.writeBps -= 1;
            break;
        case UE_MEMORY_EXECUTE:
            pageData.executeBps -= 1;
            break;
        default:    // unreachable
            break;
        }

        DWORD newProtect;
        const bool noMoreBps = 0 == (pageData.accessBps + pageData.readBps + pageData.writeBps + pageData.executeBps);
        if(noMoreBps)
        {
            // There are no more BPs on this page. Remove the page data.
            newProtect = pageData.origProtect;
            MemoryBreakpointPages.erase(foundPageData);
        }
        else
        {
            // Some BPs are still here. According to their types, reapply page protection.
            pageData.newProtect = GetPageProtectionForMemoryBreakpoint(pageData);
            newProtect = pageData.newProtect;
        }

        DWORD oldProtect;
        if(!VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)pageAddr, TITANENGINE_PAGESIZE, newProtect, &oldProtect))
            isSuccess = false;
    }

    //remove breakpoint from list
    BreakPointBuffer.erase(BreakPointBuffer.begin() + nFoundBp);

    return isSuccess;
}

__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex)
{
    return EngineIsThereFreeHardwareBreakSlot(RegisterIndex);
}

__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack)
{
    HWBP_SIZE hwbpSize;
    HWBP_MODE hwbpMode;
    HWBP_TYPE hwbpType;
    int hwbpIndex = -1;
    DR7 dr7;

    switch(bpxSize)
    {
    case UE_HARDWARE_SIZE_1:
        hwbpSize = SIZE_1;
        break;
    case UE_HARDWARE_SIZE_2:
        hwbpSize = SIZE_2;
        if((bpxAddress % 2) != 0)
            return false;
        break;
    case UE_HARDWARE_SIZE_4:
        hwbpSize = SIZE_4;
        if((bpxAddress % 4) != 0)
            return false;
        break;
    case UE_HARDWARE_SIZE_8:
        hwbpSize = SIZE_8;
        if((bpxAddress % 8) != 0)
            return false;
        break;
    default:
        return false;
    }

    if(!IndexOfRegister)
    {
        if(!DebugRegister[0].DrxEnabled)
            IndexOfRegister = UE_DR0;
        else if(!DebugRegister[1].DrxEnabled)
            IndexOfRegister = UE_DR1;
        else if(!DebugRegister[2].DrxEnabled)
            IndexOfRegister = UE_DR2;
        else if(!DebugRegister[3].DrxEnabled)
            IndexOfRegister = UE_DR3;
        else
            return false;
    }

    switch(IndexOfRegister)
    {
    case UE_DR0:
        hwbpIndex = 0;
        break;
    case UE_DR1:
        hwbpIndex = 1;
        break;
    case UE_DR2:
        hwbpIndex = 2;
        break;
    case UE_DR3:
        hwbpIndex = 3;
        break;
    default:
        return false;
    }

    uintdr7((ULONG_PTR)GetContextData(UE_DR7), &dr7);

    DebugRegister[hwbpIndex].DrxExecution = false;

    switch(bpxType)
    {
    case UE_HARDWARE_EXECUTE:
        hwbpSize = SIZE_1;
        hwbpType = TYPE_EXECUTE;
        DebugRegister[hwbpIndex].DrxExecution = true;
        break;
    case UE_HARDWARE_WRITE:
        hwbpType = TYPE_WRITE;
        break;
    case UE_HARDWARE_READWRITE:
        hwbpType = TYPE_READWRITE;
        break;
    default:
        return false;
    }

    hwbpMode = MODE_LOCAL;

    dr7.HWBP_MODE[hwbpIndex] = hwbpMode;
    dr7.HWBP_SIZE[hwbpIndex] = hwbpSize;
    dr7.HWBP_TYPE[hwbpIndex] = hwbpType;

    for(unsigned int i = 0; i < hListThread.size(); i++)
    {
        SetContextDataEx(hListThread.at(i).hThread, UE_DR7, dr7uint(&dr7)); //NOTE: MUST SET THIS FIRST FOR X64!
        SetContextDataEx(hListThread.at(i).hThread, IndexOfRegister, bpxAddress);
    }

    DebugRegister[hwbpIndex].DrxBreakPointType = bpxType;
    DebugRegister[hwbpIndex].DrxBreakPointSize = bpxSize;
    DebugRegister[hwbpIndex].DrxEnabled = true;
    DebugRegister[hwbpIndex].DrxBreakAddress = (ULONG_PTR)bpxAddress;
    DebugRegister[hwbpIndex].DrxCallBack = (ULONG_PTR)bpxCallBack;

    return true;
}

__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister)
{
    HWBP_SIZE hwbpSize;
    HWBP_MODE hwbpMode;
    HWBP_TYPE hwbpType;
    int hwbpIndex = -1;
    DR7 dr7;

    switch(bpxSize)
    {
    case UE_HARDWARE_SIZE_1:
        hwbpSize = SIZE_1;
        break;
    case UE_HARDWARE_SIZE_2:
        hwbpSize = SIZE_2;
        if((bpxAddress % 2) != 0)
            return false;
        break;
    case UE_HARDWARE_SIZE_4:
        hwbpSize = SIZE_4;
        if((bpxAddress % 4) != 0)
            return false;
        break;
    case UE_HARDWARE_SIZE_8:
        hwbpSize = SIZE_8;
        if((bpxAddress % 8) != 0)
            return false;
        break;
    default:
        return false;
    }

    if(!IndexOfRegister)
    {
        if(!DebugRegister[0].DrxEnabled)
            IndexOfRegister = UE_DR0;
        else if(!DebugRegister[1].DrxEnabled)
            IndexOfRegister = UE_DR1;
        else if(!DebugRegister[2].DrxEnabled)
            IndexOfRegister = UE_DR2;
        else if(!DebugRegister[3].DrxEnabled)
            IndexOfRegister = UE_DR3;
        else
            return false;
    }

    if(IndexOfSelectedRegister)
        *IndexOfSelectedRegister = IndexOfRegister;

    switch(IndexOfRegister)
    {
    case UE_DR0:
        hwbpIndex = 0;
        break;
    case UE_DR1:
        hwbpIndex = 1;
        break;
    case UE_DR2:
        hwbpIndex = 2;
        break;
    case UE_DR3:
        hwbpIndex = 3;
        break;
    default:
        return false;
    }

    uintdr7((ULONG_PTR)GetContextDataEx(hActiveThread, UE_DR7), &dr7);

    DebugRegister[hwbpIndex].DrxExecution = false;

    switch(bpxType)
    {
    case UE_HARDWARE_EXECUTE:
        hwbpSize = SIZE_1;
        hwbpType = TYPE_EXECUTE;
        DebugRegister[hwbpIndex].DrxExecution = true;
        break;
    case UE_HARDWARE_WRITE:
        hwbpType = TYPE_WRITE;
        break;
    case UE_HARDWARE_READWRITE:
        hwbpType = TYPE_READWRITE;
        break;
    default:
        return false;
    }

    hwbpMode = MODE_LOCAL;

    dr7.HWBP_MODE[hwbpIndex] = hwbpMode;
    dr7.HWBP_SIZE[hwbpIndex] = hwbpSize;
    dr7.HWBP_TYPE[hwbpIndex] = hwbpType;

    SetContextDataEx(hActiveThread, UE_DR7, dr7uint(&dr7));
    SetContextDataEx(hActiveThread, IndexOfRegister, (ULONG_PTR)bpxAddress);

    DebugRegister[hwbpIndex].DrxBreakPointType = bpxType;
    DebugRegister[hwbpIndex].DrxBreakPointSize = bpxSize;
    DebugRegister[hwbpIndex].DrxEnabled = true;
    DebugRegister[hwbpIndex].DrxBreakAddress = (ULONG_PTR)bpxAddress;
    DebugRegister[hwbpIndex].DrxCallBack = (ULONG_PTR)bpxCallBack;

    return true;
}

__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister)
{
    ULONG_PTR HardwareBPX = NULL;
    ULONG_PTR bpxAddress = NULL;

    if(IndexOfRegister == UE_DR0)
    {
        HardwareBPX = (ULONG_PTR)GetContextData(UE_DR7);
        HardwareBPX = HardwareBPX & ~(1 << 0);
        HardwareBPX = HardwareBPX & ~(1 << 1);
        for(unsigned int i = 0; i < hListThread.size(); i++)
        {
            SetContextDataEx(hListThread.at(i).hThread, UE_DR0, bpxAddress);
            SetContextDataEx(hListThread.at(i).hThread, UE_DR7, HardwareBPX);
        }
        DebugRegister[0].DrxEnabled = false;
        DebugRegister[0].DrxBreakAddress = NULL;
        DebugRegister[0].DrxCallBack = NULL;
        return true;
    }
    else if(IndexOfRegister == UE_DR1)
    {
        HardwareBPX = (ULONG_PTR)GetContextData(UE_DR7);
        HardwareBPX = HardwareBPX & ~(1 << 2);
        HardwareBPX = HardwareBPX & ~(1 << 3);
        for(unsigned int i = 0; i < hListThread.size(); i++)
        {
            SetContextDataEx(hListThread.at(i).hThread, UE_DR1, bpxAddress);
            SetContextDataEx(hListThread.at(i).hThread, UE_DR7, HardwareBPX);
        }
        DebugRegister[1].DrxEnabled = false;
        DebugRegister[1].DrxBreakAddress = NULL;
        DebugRegister[1].DrxCallBack = NULL;
        return true;
    }
    else if(IndexOfRegister == UE_DR2)
    {
        HardwareBPX = (ULONG_PTR)GetContextData(UE_DR7);
        HardwareBPX = HardwareBPX & ~(1 << 4);
        HardwareBPX = HardwareBPX & ~(1 << 5);
        for(unsigned int i = 0; i < hListThread.size(); i++)
        {
            SetContextDataEx(hListThread.at(i).hThread, UE_DR2, bpxAddress);
            SetContextDataEx(hListThread.at(i).hThread, UE_DR7, HardwareBPX);
        }
        DebugRegister[2].DrxEnabled = false;
        DebugRegister[2].DrxBreakAddress = NULL;
        DebugRegister[2].DrxCallBack = NULL;
        return true;
    }
    else if(IndexOfRegister == UE_DR3)
    {
        HardwareBPX = (ULONG_PTR)GetContextData(UE_DR7);
        HardwareBPX = HardwareBPX & ~(1 << 6);
        HardwareBPX = HardwareBPX & ~(1 << 7);
        for(unsigned int i = 0; i < hListThread.size(); i++)
        {
            SetContextDataEx(hListThread.at(i).hThread, UE_DR3, bpxAddress);
            SetContextDataEx(hListThread.at(i).hThread, UE_DR7, HardwareBPX);
        }
        DebugRegister[3].DrxEnabled = false;
        DebugRegister[3].DrxBreakAddress = NULL;
        DebugRegister[3].DrxCallBack = NULL;
        return true;
    }
    else
    {
        return false;
    }
    return false;
}

__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption)
{
    CriticalSectionLocker lock(LockBreakPointBuffer);
    int bpcount = (int)BreakPointBuffer.size();
    if(RemoveOption == UE_OPTION_REMOVEALL)
    {
        for(int i = bpcount - 1; i > -1; i--)
        {
            if(BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT)
            {
                DeleteBPX((ULONG_PTR)BreakPointBuffer.at(i).BreakPointAddress);
            }
            else if(BreakPointBuffer.at(i).BreakPointType == UE_MEMORY ||
                    BreakPointBuffer.at(i).BreakPointType == UE_MEMORY_READ ||
                    BreakPointBuffer.at(i).BreakPointType == UE_MEMORY_WRITE ||
                    BreakPointBuffer.at(i).BreakPointType == UE_MEMORY_EXECUTE)
            {
                RemoveMemoryBPX((ULONG_PTR)BreakPointBuffer.at(i).BreakPointAddress, BreakPointBuffer.at(i).BreakPointSize);
            }
        }
        DeleteHardwareBreakPoint(UE_DR0);
        DeleteHardwareBreakPoint(UE_DR1);
        DeleteHardwareBreakPoint(UE_DR2);
        DeleteHardwareBreakPoint(UE_DR3);
        return true;
    }
    else if(RemoveOption == UE_OPTION_DISABLEALL)
    {
        for(int i = bpcount - 1; i > -1; i--)
        {
            if((BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT) && BreakPointBuffer.at(i).BreakPointActive == UE_BPXACTIVE)
            {
                DisableBPX((ULONG_PTR)BreakPointBuffer.at(i).BreakPointAddress);
            }
            else if(BreakPointBuffer.at(i).BreakPointType == UE_MEMORY ||
                    BreakPointBuffer.at(i).BreakPointType == UE_MEMORY_READ ||
                    BreakPointBuffer.at(i).BreakPointType == UE_MEMORY_WRITE ||
                    BreakPointBuffer.at(i).BreakPointType == UE_MEMORY_EXECUTE)
            {
                RemoveMemoryBPX((ULONG_PTR)BreakPointBuffer.at(i).BreakPointAddress, BreakPointBuffer.at(i).BreakPointSize);
            }
        }
        return true;
    }
    else if(RemoveOption == UE_OPTION_REMOVEALLDISABLED)
    {
        for(int i = bpcount - 1; i > -1; i--)
        {
            if((BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT) && BreakPointBuffer.at(i).BreakPointActive == UE_BPXINACTIVE)
            {
                DeleteBPX((ULONG_PTR)BreakPointBuffer.at(i).BreakPointAddress);
            }
        }
        return true;
    }
    else if(RemoveOption == UE_OPTION_REMOVEALLENABLED)
    {
        for(int i = bpcount - 1; i > -1; i--)
        {
            if((BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT) && BreakPointBuffer.at(i).BreakPointActive == UE_BPXACTIVE)
            {
                DeleteBPX((ULONG_PTR)BreakPointBuffer.at(i).BreakPointAddress);
            }
        }
        return true;
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.Debugger.Context.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "Global.Engine.h"
#include "Global.Handle.h"
#include "Global.Engine.Threading.h"
#include "Global.Engine.Context.h"

__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext)
{
    int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext->x87fpu.StatusWord);
    DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);
    int i;

    for(i = 0; i < 8; i++)
        mmx[i] = * ((uint64_t*) GetRegisterAreaOf87register(titcontext->RegisterArea, x87r0_position, i));
}

__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext)
{
    /*
    GET Actual TOP register from StatusWord to order the FPUx87registers like in the FPU internal order.
    The TOP field (bits 13-11) is where the FPU keeps track of which of its 80-bit registers is at the TOP.
    The register number for the FPU's internal numbering system of the 80-bit registers would be displayed in that field.
    When the programmer specifies one of the FPU 80-bit registers ST(x) in an instruction, the FPU adds (modulo 8) the ST number
    supplied to the value in this TOP field to determine in which of its registers the required data is located.
    */

    int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext->x87fpu.StatusWord);
    DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

    for(int i = 0; i < 8; i++)
    {
        memcpy(x87FPURegisters[i].data, GetRegisterAreaOf87register(titcontext->RegisterArea, x87r0_position, i), 10);
        x87FPURegisters[i].st_value = GetSTValueFromIndex(x87r0_position, i);
        x87FPURegisters[i].tag = (int)((titcontext->x87fpu.TagWord >> (i * 2)) & 0x3);
    }
}

__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea)
{
    if(FPUSaveArea)
    {
        CONTEXT DBGContext;
        memset(&DBGContext, 0, sizeof(CONTEXT));
        DBGContext.ContextFlags = CONTEXT_ALL | CONTEXT_FLOATING_POINT;

        if(SuspendThread(hActiveThread) == (DWORD) - 1)
            return false;

        if(!GetThreadContext(hActiveThread, &DBGContext))
        {
            ResumeThread(hActiveThread);
            return false;
        }
        ResumeThread(hActiveThread);
#ifndef _WIN64
        memcpy(FPUSaveArea, &DBGContext.FloatSave, sizeof(FLOATING_SAVE_AREA));
#else
        memcpy(FPUSaveArea, &DBGContext.FltSave, sizeof(XMM_SAVE_AREA32));
#endif
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext)
{
    bool returnf;

    if(SuspendThread(hActiveThread) == (DWORD) - 1)
        return false;

    returnf = _SetFullContextDataEx(hActiveThread, titcontext, false);

    ResumeThread(hActiveThread);

    return returnf;
}

__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext)
{
    bool returnf;

    if(SuspendThread(hActiveThread) == (DWORD) - 1)
        return false;

    returnf = _GetFullContextDataEx(hActiveThread, titcontext, true);

    ResumeThread(hActiveThread);

    return returnf;
}

__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister)
{
    ULONG_PTR retValue = 0;
    TITAN_ENGINE_CONTEXT_t titcontext;

    if(SuspendThread(hActiveThread) == (DWORD) - 1)
        return false;

    memset(&titcontext, 0, sizeof(titcontext));

    if(! _GetFullContextDataEx(hActiveThread, & titcontext, false))
    {
        ResumeThread(hActiveThread);
        return false;
    }
    ResumeThread(hActiveThread);

#ifdef _WIN64 //x64
    if(IndexOfRegister == UE_EAX)
    {
        retValue = titcontext.cax & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_EBX)
    {
        retValue = titcontext.cbx & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_ECX)
    {
        retValue = titcontext.ccx & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_EDX)
    {
        retValue = titcontext.cdx & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_EDI)
    {
        retValue = titcontext.cdi & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_ESI)
    {
        retValue = titcontext.csi & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_EBP)
    {
        retValue = titcontext.cbp & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_ESP)
    {
        retValue = titcontext.csp & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_EIP)
    {
        retValue = titcontext.cip & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_EFLAGS)
    {
        retValue = titcontext.eflags & 0xFFFFFFFF;
    }
    else if(IndexOfRegister == UE_RAX)
    {
        retValue = titcontext.cax;
    }
    else if(IndexOfRegister == UE_RBX)
    {
        retValue = titcontext.cbx;
    }
    else if(IndexOfRegister == UE_RCX)
    {
        retValue = titcontext.ccx;
    }
    else if(IndexOfRegister == UE_RDX)
    {
        retValue = titcontext.cdx;
    }
    else if(IndexOfRegister == UE_RDI)
    {
        retValue = titcontext.cdi;
    }
    else if(IndexOfRegister == UE_RSI)
    {
        retValue = titcontext.csi;
    }
    else if(IndexOfRegister == UE_RBP)
    {
        retValue = titcontext.cbp;
    }
    else if(IndexOfRegister == UE_RSP)
    {
        retValue = titcontext.csp;
    }
    else if(IndexOfRegister == UE_RIP)
    {
        retValue = titcontext.cip;
    }
    else if(IndexOfRegister == UE_RFLAGS)
    {
        retValue = titcontext.eflags;
    }
    else if(IndexOfRegister == UE_R8)
    {
        retValue = titcontext.r8;
    }
    else if(IndexOfRegister == UE_R9)
    {
        retValue = titcontext.r9;
    }
    else if(IndexOfRegister == UE_R10)
    {
        retValue = titcontext.r10;
    }
    else if(IndexOfRegister == UE_R11)
    {
        retValue = titcontext.r11;
    }
    else if(IndexOfRegister == UE_R12)
    {
        retValue = titcontext.r12;
    }
    else if(IndexOfRegister == UE_R13)
    {
        retValue = titcontext.r13;
    }
    else if(IndexOfRegister == UE_R14)
    {
        retValue = titcontext.r14;
    }
    else if(IndexOfRegister == UE_R15)
    {
        retValue = titcontext.r15;
    }
    else if(IndexOfRegister == UE_CIP)
    {
        retValue = titcontext.cip;
    }
    else if(IndexOfRegister == UE_CSP)
    {
        retValue = titcontext.csp;
    }
#else //x86
    if(IndexOfRegister == UE_EAX)
    {
        retValue = titcontext.cax;
    }
    else if(IndexOfRegister == UE_EBX)
    {
        retValue = titcontext.cbx;
    }
    else if(IndexOfRegister == UE_ECX)
    {
        retValue = titcontext.ccx;
    }
    else if(IndexOfRegister == UE_EDX)
    {
        retValue = titcontext.cdx;
    }
    else if(IndexOfRegister == UE_EDI)
    {
        retValue = titcontext.cdi;
    }
    else if(IndexOfRegister == UE_ESI)
    {
        retValue = titcontext.csi;
    }
    else if(IndexOfRegister == UE_EBP)
    {
        retValue = titcontext.cbp;
    }
    else if(IndexOfRegister == UE_ESP)
    {
        retValue = titcontext.csp;
    }
    else if(IndexOfRegister == UE_EIP)
    {
        retValue = titcontext.cip;
    }
    else if(IndexOfRegister == UE_CIP)
    {
        retValue = titcontext.cip;
    }
    else if(IndexOfRegister == UE_CSP)
    {
        retValue = titcontext.csp;
    }
#endif
    else if(IndexOfRegister == UE_X87_STATUSWORD)
    {
        retValue = titcontext.x87fpu.StatusWord;
    }
    else if(IndexOfRegister == UE_X87_CONTROLWORD)
    {
        retValue = titcontext.x87fpu.ControlWord;
    }
    else if(IndexOfRegister == UE_X87_TAGWORD)
    {
        retValue = titcontext.x87fpu.TagWord;
    }
    else if(IndexOfRegister == UE_MXCSR)
    {
        retValue = titcontext.MxCsr;
    }
    else if(IndexOfRegister == UE_EFLAGS)
    {
        retValue = titcontext.eflags;
    }
    else if(IndexOfRegister == UE_DR0)
    {
        retValue = titcontext.dr0;
    }
    else if(IndexOfRegister == UE_DR1)
    {
        retValue = titcontext.dr1;
    }
    else if(IndexOfRegister == UE_DR2)
    {
        retValue = titcontext.dr2;
    }
    else if(IndexOfRegister == UE_DR3)
    {
        retValue = titcontext.dr3;
    }
    else if(IndexOfRegister == UE_DR6)
    {
        retValue = titcontext.dr6;
    }
    else if(IndexOfRegister == UE_DR7)
    {
        retValue = titcontext.dr7;
    }
    else if(IndexOfRegister == UE_SEG_GS)
    {
        retValue = titcontext.gs;
    }
    else if(IndexOfRegister == UE_SEG_FS)
    {
        retValue = titcontext.fs;
    }
    else if(IndexOfRegister == UE_SEG_ES)
    {
        retValue = titcontext.es;
    }
    else if(IndexOfRegister == UE_SEG_DS)
    {
        retValue = titcontext.ds;
    }
    else if(IndexOfRegister == UE_SEG_CS)
    {
        retValue = titcontext.cs;
    }
    else if(IndexOfRegister == UE_SEG_SS)
    {
        retValue = titcontext.ss;
    }
    return retValue;
}

__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister)
{
    HANDLE hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
    ULONG_PTR ContextReturn = GetContextDataEx(hActiveThread, IndexOfRegister);
    EngineCloseHandle(hActiveThread);
    return ContextReturn;
}

__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea)
{
    if(FPUSaveArea)
    {
        CONTEXT DBGContext;
        memset(&DBGContext, 0, sizeof(CONTEXT));
        DBGContext.ContextFlags = CONTEXT_ALL | CONTEXT_FLOATING_POINT;

        if(SuspendThread(hActiveThread) == (DWORD) - 1)
            return false;

        if(!GetThreadContext(hActiveThread, &DBGContext))
        {
            ResumeThread(hActiveThread);
            return false;
        }
#ifndef _WIN64
        memcpy(&DBGContext.FloatSave, FPUSaveArea, sizeof(FLOATING_SAVE_AREA));
#else
        memcpy(&DBGContext.FltSave, FPUSaveArea, sizeof(XMM_SAVE_AREA32));
#endif
        if(SetThreadContext(hActiveThread, &DBGContext))
        {
            ResumeThread(hActiveThread);
            return true;
        }
        ResumeThread(hActiveThread);
    }
    return false;
}

__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue)
{
    TITAN_ENGINE_CONTEXT_t titcontext;
    bool returnf;
    bool avx_priority = false;

    if(SuspendThread(hActiveThread) == (DWORD) - 1)
        return false;

    memset(&titcontext, 0, sizeof(titcontext));

    if(! _GetFullContextDataEx(hActiveThread, & titcontext, IndexOfRegister >= UE_MXCSR))
    {
        ResumeThread(hActiveThread);
        return false;
    }

#ifdef _WIN64 //x64
    if(IndexOfRegister == UE_EAX)
    {
        NewRegisterValue = titcontext.cax - (DWORD)titcontext.cax + NewRegisterValue;
        titcontext.cax = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EBX)
    {
        NewRegisterValue = titcontext.cbx - (DWORD)titcontext.cbx + NewRegisterValue;
        titcontext.cbx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_ECX)
    {
        NewRegisterValue = titcontext.ccx - (DWORD)titcontext.ccx + NewRegisterValue;
        titcontext.ccx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EDX)
    {
        NewRegisterValue = titcontext.cdx - (DWORD)titcontext.cdx + NewRegisterValue;
        titcontext.cdx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EDI)
    {
        NewRegisterValue = titcontext.cdi - (DWORD)titcontext.cdi + NewRegisterValue;
        titcontext.cdi = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_ESI)
    {
        NewRegisterValue = titcontext.csi - (DWORD)titcontext.csi + NewRegisterValue;
        titcontext.csi = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EBP)
    {
        NewRegisterValue = titcontext.cbp - (DWORD)titcontext.cbp + NewRegisterValue;
        titcontext.cbp = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_ESP)
    {
        NewRegisterValue = titcontext.csp - (DWORD)titcontext.csp + NewRegisterValue;
        titcontext.csp = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EIP)
    {
        NewRegisterValue = titcontext.cip - (DWORD)titcontext.cip + NewRegisterValue;
        titcontext.cip = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EFLAGS)
    {
        titcontext.eflags = (DWORD)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RAX)
    {
        titcontext.cax = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RBX)
    {
        titcontext.cbx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RCX)
    {
        titcontext.ccx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RDX)
    {
        titcontext.cdx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RDI)
    {
        titcontext.cdi = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RSI)
    {
        titcontext.csi = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RBP)
    {
        titcontext.cbp = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RSP)
    {
        titcontext.csp = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RIP)
    {
        titcontext.cip = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_RFLAGS)
    {
        titcontext.eflags = (unsigned int) NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R8)
    {
        titcontext.r8 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R9)
    {
        titcontext.r9 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R10)
    {
        titcontext.r10 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R11)
    {
        titcontext.r11 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R12)
    {
        titcontext.r12 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R13)
    {
        titcontext.r13 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R14)
    {
        titcontext.r14 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_R15)
    {
        titcontext.r15 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_CIP)
    {
        titcontext.cip = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_CSP)
    {
        titcontext.csp = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_XMM8)
    {
        memcpy(& (titcontext.XmmRegisters[8]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM9)
    {
        memcpy(& (titcontext.XmmRegisters[9]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM10)
    {
        memcpy(& (titcontext.XmmRegisters[10]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM11)
    {
        memcpy(& (titcontext.XmmRegisters[11]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM12)
    {
        memcpy(& (titcontext.XmmRegisters[12]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM13)
    {
        memcpy(& (titcontext.XmmRegisters[13]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM14)
    {
        memcpy(& (titcontext.XmmRegisters[14]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM15)
    {
        memcpy(& (titcontext.XmmRegisters[15]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_YMM8)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[8]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM9)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[9]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM10)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[10]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM11)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[11]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM12)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[12]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM13)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[13]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM14)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[14]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM15)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[15]), (void*) NewRegisterValue, 32);
    }
#else //x86
    if(IndexOfRegister == UE_EAX)
    {
        titcontext.cax = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EBX)
    {
        titcontext.cbx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_ECX)
    {
        titcontext.ccx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EDX)
    {
        titcontext.cdx = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EDI)
    {
        titcontext.cdi = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_ESI)
    {
        titcontext.csi = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EBP)
    {
        titcontext.cbp = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_ESP)
    {
        titcontext.csp = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EIP)
    {
        titcontext.cip = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_EFLAGS)
    {
        titcontext.eflags = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_CIP)
    {
        titcontext.cip = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_CSP)
    {
        titcontext.csp = NewRegisterValue;
    }
#endif
    else if(IndexOfRegister == UE_DR0)
    {
        titcontext.dr0 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_DR1)
    {
        titcontext.dr1 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_DR2)
    {
        titcontext.dr2 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_DR3)
    {
        titcontext.dr3 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_DR6)
    {
        titcontext.dr6 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_DR7)
    {
        titcontext.dr7 = NewRegisterValue;
    }
    else if(IndexOfRegister == UE_SEG_GS)
    {
        titcontext.gs = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_SEG_FS)
    {
        titcontext.fs = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_SEG_ES)
    {
        titcontext.es = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_SEG_DS)
    {
        titcontext.ds = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_SEG_CS)
    {
        titcontext.cs = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_SEG_SS)
    {
        titcontext.ss = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_X87_STATUSWORD)
    {
        titcontext.x87fpu.StatusWord = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_X87_CONTROLWORD)
    {
        titcontext.x87fpu.ControlWord = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_X87_TAGWORD)
    {
        titcontext.x87fpu.TagWord = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_MXCSR)
    {
        titcontext.MxCsr = (unsigned short)NewRegisterValue;
    }
    else if(IndexOfRegister == UE_XMM0)
    {
        memcpy(& (titcontext.XmmRegisters[0]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM1)
    {
        memcpy(& (titcontext.XmmRegisters[1]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM2)
    {
        memcpy(& (titcontext.XmmRegisters[2]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM3)
    {
        memcpy(& (titcontext.XmmRegisters[3]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM4)
    {
        memcpy(& (titcontext.XmmRegisters[4]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM5)
    {
        memcpy(& (titcontext.XmmRegisters[5]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM6)
    {
        memcpy(& (titcontext.XmmRegisters[6]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_XMM7)
    {
        memcpy(& (titcontext.XmmRegisters[7]), (void*) NewRegisterValue, 16);
    }
    else if(IndexOfRegister == UE_MMX0)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 0)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_MMX1)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 1)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_MMX2)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 2)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_MMX3)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 3)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_MMX4)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 4)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_MMX5)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 5)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_MMX6)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 6)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_MMX7)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 7)), (char*) NewRegisterValue, 8);
    }
    else if(IndexOfRegister == UE_x87_r0)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 0)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_x87_r1)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 1)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_x87_r2)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 2)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_x87_r3)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 3)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_x87_r4)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 4)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_x87_r5)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 5)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_x87_r6)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 6)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_x87_r7)
    {
        int STInTopStack = GetSTInTOPStackFromStatusWord(titcontext.x87fpu.StatusWord);
        DWORD x87r0_position = Getx87r0PositionInRegisterArea(STInTopStack);

        memcpy(((uint64_t*) GetRegisterAreaOf87register(titcontext.RegisterArea, x87r0_position, 7)), (char*) NewRegisterValue, 10);
    }
    else if(IndexOfRegister == UE_YMM0)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[0]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM1)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[1]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM2)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[2]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM3)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[3]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM4)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[4]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM5)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[5]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM6)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[6]), (void*) NewRegisterValue, 32);
    }
    else if(IndexOfRegister == UE_YMM7)
    {
        avx_priority = true;
        memcpy(& (titcontext.YmmRegisters[7]), (void*) NewRegisterValue, 32);
    }
    else
    {
        ResumeThread(hActiveThread);
        return false;
    }

    returnf = _SetFullContextDataEx(hActiveThread, &titcontext, avx_priority);

    ResumeThread(hActiveThread);

    return returnf;
}

__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue)
{
    HANDLE hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
    bool ContextReturn = SetContextDataEx(hActiveThread, IndexOfRegister, NewRegisterValue);
    EngineCloseHandle(hActiveThread);
    return ContextReturn;
}

__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext)
{
    if(InitXState() == false)
        return false;

    DWORD64 FeatureMask = _GetEnabledXStateFeatures();
    if((FeatureMask & XSTATE_MASK_AVX) == 0)
        return false;

    DWORD ContextSize = 0;
    BOOL Success = _InitializeContext(NULL,
                                      CONTEXT_ALL | CONTEXT_XSTATE,
                                      NULL,
                                      &ContextSize);

    if((Success == TRUE) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        return false;

    DynBuf dataBuffer(ContextSize);
    PVOID Buffer = dataBuffer.GetPtr();
    if(Buffer == NULL)
        return false;

    PCONTEXT Context;
    Success = _InitializeContext(Buffer,
                                 CONTEXT_ALL | CONTEXT_XSTATE,
                                 &Context,
                                 &ContextSize);
    if(Success == FALSE)
        return false;

    if(_SetXStateFeaturesMask(Context, XSTATE_MASK_AVX) == FALSE)
        return false;

    if(GetThreadContext(hActiveThread, Context) == FALSE)
        return false;

    if(_GetXStateFeaturesMask(Context, &FeatureMask) == FALSE)
        return false;

    DWORD FeatureLength;
    XmmRegister_t* Sse = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_LEGACY_SSE, &FeatureLength);
    XmmRegister_t* Avx = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_AVX, NULL);
    int NumberOfRegisters = FeatureLength / sizeof(Sse[0]);

    if(Sse != NULL) //If the feature is unsupported by the processor it will return NULL
    {
        for(int i = 0; i < NumberOfRegisters; i++)
            Sse[i] = titcontext->YmmRegisters[i].Low;
    }

    if(Avx != NULL) //If the feature is unsupported by the processor it will return NULL
    {
        for(int i = 0; i < NumberOfRegisters; i++)
            Avx[i] = titcontext->YmmRegisters[i].High;
    }

    return (SetThreadContext(hActiveThread, Context) == TRUE);
}

__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext)
{
    if(InitXState() == false)
        return false;

    DWORD64 FeatureMask = _GetEnabledXStateFeatures();
    if((FeatureMask & XSTATE_MASK_AVX) == 0)
        return false;

    DWORD ContextSize = 0;
    BOOL Success = _InitializeContext(NULL,
                                      CONTEXT_ALL | CONTEXT_XSTATE,
                                      NULL,
                                      &ContextSize);

    if((Success == TRUE) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        return false;

    DynBuf dataBuffer(ContextSize);
    PVOID Buffer = dataBuffer.GetPtr();
    if(Buffer == NULL)
        return false;

    PCONTEXT Context;
    Success = _InitializeContext(Buffer,
                                 CONTEXT_ALL | CONTEXT_XSTATE,
                                 &Context,
                                 &ContextSize);
    if(Success == FALSE)
        return false;

    if(_SetXStateFeaturesMask(Context, XSTATE_MASK_AVX) == FALSE)
        return false;

    if(GetThreadContext(hActiveThread, Context) == FALSE)
        return false;

    if(_GetXStateFeaturesMask(Context, &FeatureMask) == FALSE)
        return false;

    DWORD FeatureLength;
    XmmRegister_t* Sse = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_LEGACY_SSE, &FeatureLength);
    XmmRegister_t* Avx = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_AVX, NULL);
    int NumberOfRegisters = FeatureLength / sizeof(Sse[0]);

    if(Sse != NULL) //If the feature is unsupported by the processor it will return NULL
    {
        for(int i = 0; i < NumberOfRegisters; i++)
            titcontext->YmmRegisters[i].Low = Sse[i];
    }

    if(Avx != NULL) //If the feature is unsupported by the processor it will return NULL
    {
        for(int i = 0; i < NumberOfRegisters; i++)
            titcontext->YmmRegisters[i].High = Avx[i];
    }

    return true;
}

// AVX-512 constants
#ifndef XSTATE_MASK_AVX512
#define XSTATE_AVX512_KMASK                 (5)
#define XSTATE_AVX512_ZMM_H                 (6)
#define XSTATE_AVX512_ZMM                   (7)
#define XSTATE_MASK_AVX512                  ((1ui64 << (XSTATE_AVX512_KMASK)) | \
                                             (1ui64 << (XSTATE_AVX512_ZMM_H)) | \
                                             (1ui64 << (XSTATE_AVX512_ZMM)))
#endif

static bool SetAVX512ContextFallbackToAVX(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext) {
	// Fall back to using AVX and ignore the rest
	TITAN_ENGINE_CONTEXT_t Avx;
	memset(&Avx, 0, sizeof(Avx));
	for (int i = 0; i < _countof(Avx.YmmRegisters); i++) {
		Avx.YmmRegisters[i] = titcontext->ZmmRegisters[i].Low;
	}
	return SetAVXContext(hActiveThread, &Avx);
}

__declspec(dllexport) bool TITCALL SetAVX512Context(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext)
{
	if (InitXState() == false)
		return false;

	DWORD64 FeatureMask = _GetEnabledXStateFeatures();
	if ((FeatureMask & XSTATE_MASK_AVX512) == 0)
		return SetAVX512ContextFallbackToAVX(hActiveThread, titcontext);

	DWORD ContextSize = 0;
	BOOL Success = _InitializeContext(NULL,
		CONTEXT_ALL | CONTEXT_XSTATE,
		NULL,
		&ContextSize);

	if ((Success == TRUE) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
		return false;

	DynBuf dataBuffer(ContextSize);
	PVOID Buffer = dataBuffer.GetPtr();
	if (Buffer == NULL)
		return false;

	PCONTEXT Context;
	Success = _InitializeContext(Buffer,
		CONTEXT_ALL | CONTEXT_XSTATE,
		&Context,
		&ContextSize);
	if (Success == FALSE)
		return false;

	if (_SetXStateFeaturesMask(Context, XSTATE_MASK_AVX | XSTATE_MASK_AVX512) == FALSE)
		return SetAVX512ContextFallbackToAVX(hActiveThread, titcontext);

	if (GetThreadContext(hActiveThread, Context) == FALSE)
		return false;

	if (_GetXStateFeaturesMask(Context, &FeatureMask) == FALSE)
		return false;

	DWORD FeatureLengthSse;
	DWORD FeatureLengthAvx;
	DWORD FeatureLengthAvx512_KMASK;
	DWORD FeatureLengthAvx512_ZMM_H;
	DWORD FeatureLengthAvx512_ZMM;
	XmmRegister_t* Sse = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_LEGACY_SSE, &FeatureLengthSse);
	XmmRegister_t* Avx = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_AVX, &FeatureLengthAvx);
	ULONGLONG* Avx512_KMASK = (ULONGLONG*)_LocateXStateFeature(Context, XSTATE_AVX512_KMASK, &FeatureLengthAvx512_KMASK);
	ZmmRegister_t* Avx512_ZMM = (ZmmRegister_t *)_LocateXStateFeature(Context, XSTATE_AVX512_ZMM, &FeatureLengthAvx512_ZMM);
	YmmRegister_t* Avx512_ZMM_H = (YmmRegister_t *)_LocateXStateFeature(Context, XSTATE_AVX512_ZMM_H, &FeatureLengthAvx512_ZMM_H);

	if (Sse != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthSse / sizeof(XmmRegister_t), _countof(titcontext->ZmmRegisters)); i++)
			Sse[i] = titcontext->ZmmRegisters[i].Low.Low;
	}

	if (Avx != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx / sizeof(XmmRegister_t), _countof(titcontext->ZmmRegisters)); i++)
			Avx[i] = titcontext->ZmmRegisters[i].Low.High;
	}

	if (Avx512_ZMM_H != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx512_ZMM_H / sizeof(YmmRegister_t), _countof(titcontext->ZmmRegisters)); i++)
			Avx512_ZMM_H[i] = titcontext->ZmmRegisters[i].High;
	}

	if (Avx512_ZMM != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx512_ZMM / sizeof(ZmmRegister_t), _countof(titcontext->ZmmRegisters) - FeatureLengthAvx / sizeof(XmmRegister_t)); i++)
			Avx512_ZMM[i] = titcontext->ZmmRegisters[i + FeatureLengthAvx / sizeof(XmmRegister_t)];
	}

	if (Avx512_KMASK != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx512_KMASK / sizeof(ULONGLONG), _countof(titcontext->Opmask)); i++)
			Avx512_KMASK[i] = titcontext->Opmask[i];
	}

	return (SetThreadContext(hActiveThread, Context) == TRUE);
}

static bool GetAVX512ContextFallbackToAVX(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext)
{
	// Fall back to using AVX and fill the rest with 0
	TITAN_ENGINE_CONTEXT_t Avx;
	memset(titcontext, 0, sizeof(*titcontext));
	if (GetAVXContext(hActiveThread, &Avx)) {
		for (int i = 0; i < _countof(Avx.YmmRegisters); i++)
			titcontext->ZmmRegisters[i].Low = Avx.YmmRegisters[i];
		return true;
	}
	else {
		return false;
	}
}

__declspec(dllexport) bool TITCALL GetAVX512Context(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext)
{
	if (InitXState() == false)
		return false;

	DWORD64 FeatureMask = _GetEnabledXStateFeatures();
	if ((FeatureMask & XSTATE_MASK_AVX512) == 0) //XSTATE_MASK_AVX512
		return GetAVX512ContextFallbackToAVX(hActiveThread, titcontext);

	DWORD ContextSize = 0;
	BOOL Success = _InitializeContext(NULL,
		CONTEXT_ALL | CONTEXT_XSTATE,
		NULL,
		&ContextSize);

	if ((Success == TRUE) || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
		return false;

	DynBuf dataBuffer(ContextSize);
	PVOID Buffer = dataBuffer.GetPtr();
	if (Buffer == NULL)
		return false;

	PCONTEXT Context;
	Success = _InitializeContext(Buffer,
		CONTEXT_ALL | CONTEXT_XSTATE,
		&Context,
		&ContextSize);
	if (Success == FALSE)
		return false;

	if (_SetXStateFeaturesMask(Context, XSTATE_MASK_AVX | XSTATE_MASK_AVX512) == FALSE)
		return GetAVX512ContextFallbackToAVX(hActiveThread, titcontext);

	if (GetThreadContext(hActiveThread, Context) == FALSE)
		return false;

	if (_GetXStateFeaturesMask(Context, &FeatureMask) == FALSE)
		return false;

	DWORD FeatureLengthSse;
	DWORD FeatureLengthAvx;
	DWORD FeatureLengthAvx512_KMASK;
	DWORD FeatureLengthAvx512_ZMM_H;
	DWORD FeatureLengthAvx512_ZMM;
	XmmRegister_t* Sse = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_LEGACY_SSE, &FeatureLengthSse);
	XmmRegister_t* Avx = (XmmRegister_t*)_LocateXStateFeature(Context, XSTATE_AVX, &FeatureLengthAvx);
	ULONGLONG* Avx512_KMASK = (ULONGLONG*)_LocateXStateFeature(Context, XSTATE_AVX512_KMASK, &FeatureLengthAvx512_KMASK);
	ZmmRegister_t* Avx512_ZMM = (ZmmRegister_t *)_LocateXStateFeature(Context, XSTATE_AVX512_ZMM, &FeatureLengthAvx512_ZMM);
	YmmRegister_t* Avx512_ZMM_H = (YmmRegister_t *)_LocateXStateFeature(Context, XSTATE_AVX512_ZMM_H, &FeatureLengthAvx512_ZMM_H);

	if (Sse != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthSse / sizeof(XmmRegister_t), _countof(titcontext->ZmmRegisters)); i++)
			titcontext->ZmmRegisters[i].Low.Low = Sse[i];
	}

	if (Avx != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx / sizeof(XmmRegister_t), _countof(titcontext->ZmmRegisters)); i++)
			titcontext->ZmmRegisters[i].Low.High = Avx[i];
	}

	if (Avx512_ZMM_H != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx512_ZMM_H / sizeof(YmmRegister_t), _countof(titcontext->ZmmRegisters)); i++)
			titcontext->ZmmRegisters[i].High = Avx512_ZMM_H[i];
	}

	if (Avx512_ZMM != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx512_ZMM / sizeof(ZmmRegister_t), _countof(titcontext->ZmmRegisters) - FeatureLengthAvx / sizeof(XmmRegister_t)); i++)
			titcontext->ZmmRegisters[i + FeatureLengthAvx / sizeof(XmmRegister_t)] = Avx512_ZMM[i];
	}

	if (Avx512_KMASK != NULL) //If the feature is unsupported by the processor it will return NULL
	{
		for (int i = 0; i < MIN(FeatureLengthAvx512_KMASK / sizeof(ULONGLONG), _countof(titcontext->Opmask)); i++)
			titcontext->Opmask[i] = Avx512_KMASK[i];
	}

	return true;
}



================================================
File: TitanEngine/TitanEngine.Debugger.Control.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "Global.Handle.h"
#include "Global.Threader.h"
#include "Global.Librarian.h"
#include "Global.Engine.h"

__declspec(dllexport) void TITCALL ForceClose()
{
    //manage process list
    ClearProcessList();
    //manage thread list
    ClearThreadList();
    //manage library list
    int libcount = (int)hListLibrary.size();
    for(int i = 0; i < libcount; i++)
    {
        if(hListLibrary.at(i).hFileMappingView != NULL)
        {
            UnmapViewOfFile(hListLibrary.at(i).hFileMappingView);
            EngineCloseHandle(hListLibrary.at(i).hFileMapping);
        }
    }
    ClearLibraryList();

    if(!engineProcessIsNowDetached)
    {
        StopDebug();
    }
    RtlZeroMemory(&dbgProcessInformation, sizeof PROCESS_INFORMATION);
    if(DebugDebuggingDLL)
        DeleteFileW(szDebuggerName);
    DebugDebuggingDLL = false;
    DebugExeFileEntryPointCallBack = NULL;
}

__declspec(dllexport) void TITCALL StepInto(LPVOID StepCallBack)
{
    EnterCriticalSection(&engineStepActiveCr);
    if (!engineStepActive)
    {
        ULONG_PTR ueCurrentPosition = GetContextData(UE_CIP);
        unsigned char instr[16];
        MemoryReadSafe(dbgProcessInformation.hProcess, (void*)ueCurrentPosition, instr, sizeof(instr), 0);
        char* DisassembledString = (char*)StaticDisassembleEx(ueCurrentPosition, (LPVOID)instr);
        if (strstr(DisassembledString, "PUSHF"))
            StepOver(StepCallBack);
        else if (strstr(DisassembledString, "POP SS") || strstr(DisassembledString, "MOV SS")) //prevent the 'PUSH SS', 'POP SS' step trick
        {
            ueCurrentPosition += StaticLengthDisassemble((void*)instr);
            SetBPX(ueCurrentPosition, UE_BREAKPOINT_TYPE_INT3 + UE_SINGLESHOOT, StepCallBack);
        }
        else
        {
            CONTEXT myDBGContext;
            HANDLE hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
            myDBGContext.ContextFlags = ContextControlFlags;
            GetThreadContext(hActiveThread, &myDBGContext);
            myDBGContext.EFlags |= UE_TRAP_FLAG;
            SetThreadContext(hActiveThread, &myDBGContext);
            EngineCloseHandle(hActiveThread);
            engineStepActive = true;
            engineStepCallBack = StepCallBack;
            engineStepCount = 0;
        }
    }
    LeaveCriticalSection(&engineStepActiveCr);
}

__declspec(dllexport) void TITCALL StepOver(LPVOID StepCallBack)
{
    ULONG_PTR ueCurrentPosition = GetContextData(UE_CIP);
    unsigned char instr[16];
    MemoryReadSafe(dbgProcessInformation.hProcess, (void*)ueCurrentPosition, instr, sizeof(instr), 0);
    char* DisassembledString = (char*)StaticDisassembleEx(ueCurrentPosition, (LPVOID)instr);
    if(strstr(DisassembledString, "CALL") || strstr(DisassembledString, "REP") || strstr(DisassembledString, "PUSHF"))
    {
        ueCurrentPosition += StaticLengthDisassemble((void*)instr);
        SetBPX(ueCurrentPosition, UE_BREAKPOINT_TYPE_INT3 + UE_SINGLESHOOT, StepCallBack);
    }
    else
        StepInto(StepCallBack);
}

__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal)
{
    DebugStepFinal = StepFinal;
    StepOutCallBack = StepOut;
    StepOver(StepOutStepCallBack);
}

__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack)
{
    StepInto(StepCallBack);
    engineStepCount = StepCount - 1; //We already stepped once
}

__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode)
{
    if(SetDbgCode != DBG_CONTINUE)
    {
        DBGCode = DBG_EXCEPTION_NOT_HANDLED;
    }
    else
    {
        DBGCode = DBG_CONTINUE;
    }
}



================================================
File: TitanEngine/TitanEngine.Debugger.Data.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"

//TODO: never changed LOL
static DWORD CurrentExceptionsNumber = 0;

__declspec(dllexport) void TITCALL ClearExceptionNumber()
{
    CurrentExceptionsNumber = 0;
}

__declspec(dllexport) long TITCALL CurrentExceptionNumber()
{
    return(CurrentExceptionsNumber);
}

__declspec(dllexport) void* TITCALL GetDebugData()
{
    return(&DBGEvent);
}

__declspec(dllexport) void* TITCALL GetTerminationData()
{
    return(&TerminateDBGEvent);
}

__declspec(dllexport) long TITCALL GetExitCode()
{
    return(ProcessExitCode);
}

__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress()
{
    return((ULONG_PTR)DebugDebuggingDLLBase);
}

__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress()
{
    return (ULONG_PTR)DebugDebuggingMainModuleBase;
}

__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack)
{
    if(ExceptionId == UE_CH_BREAKPOINT)
    {
        DBGCustomHandler->chBreakPoint = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_SINGLESTEP)
    {
        DBGCustomHandler->chSingleStep = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_ACCESSVIOLATION)
    {
        DBGCustomHandler->chAccessViolation = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_ILLEGALINSTRUCTION)
    {
        DBGCustomHandler->chIllegalInstruction = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_NONCONTINUABLEEXCEPTION)
    {
        DBGCustomHandler->chNonContinuableException = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_ARRAYBOUNDSEXCEPTION)
    {
        DBGCustomHandler->chArrayBoundsException = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_FLOATDENORMALOPERAND)
    {
        DBGCustomHandler->chFloatDenormalOperand = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_FLOATDEVIDEBYZERO)
    {
        DBGCustomHandler->chFloatDevideByZero = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_INTEGERDEVIDEBYZERO)
    {
        DBGCustomHandler->chIntegerDevideByZero = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_INTEGEROVERFLOW)
    {
        DBGCustomHandler->chIntegerOverflow = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_PRIVILEGEDINSTRUCTION)
    {
        DBGCustomHandler->chPrivilegedInstruction = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_PAGEGUARD)
    {
        DBGCustomHandler->chPageGuard = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_EVERYTHINGELSE)
    {
        DBGCustomHandler->chEverythingElse = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_CREATETHREAD)
    {
        DBGCustomHandler->chCreateThread = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_EXITTHREAD)
    {
        DBGCustomHandler->chExitThread = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_CREATEPROCESS)
    {
        DBGCustomHandler->chCreateProcess = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_EXITPROCESS)
    {
        DBGCustomHandler->chExitProcess = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_LOADDLL)
    {
        DBGCustomHandler->chLoadDll = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_UNLOADDLL)
    {
        DBGCustomHandler->chUnloadDll = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_OUTPUTDEBUGSTRING)
    {
        DBGCustomHandler->chOutputDebugString = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_AFTEREXCEPTIONPROCESSING)
    {
        DBGCustomHandler->chAfterException = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_SYSTEMBREAKPOINT)
    {
        DBGCustomHandler->chSystemBreakpoint = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_UNHANDLEDEXCEPTION)
    {
        DBGCustomHandler->chUnhandledException = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_RIPEVENT)
    {
        DBGCustomHandler->chRipEvent = (ULONG_PTR)CallBack;
    }
    else if(ExceptionId == UE_CH_DEBUGEVENT)
    {
        DBGCustomHandler->chDebugEvent = (ULONG_PTR)CallBack;
    }
}

__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation()
{
    return(&dbgProcessInformation);
}

__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation()
{
    return(&dbgStartupInfo);
}

__declspec(dllexport) bool TITCALL IsFileBeingDebugged()
{
    return(engineFileIsBeingDebugged);
}

__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages)
{

    if(DisplayErrorMessages)
    {
        SetErrorMode(NULL);
    }
    else
    {
        SetErrorMode(SEM_FAILCRITICALERRORS);
    }
}


================================================
File: TitanEngine/TitanEngine.Debugger.DebugLoop.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "Global.Handle.h"
#include "Global.Engine.h"
#include "Global.Breakpoints.h"
#include "Global.Threader.h"
#include "Global.Librarian.h"
#include "Global.TLS.h"
#include <unordered_map>
#include <functional>

#define UE_MODULEx86 0x2000;
#define UE_MODULEx64 0x2000;

static void engineStep()
{
    EnterCriticalSection(&engineStepActiveCr);
    if (engineStepActive)
    {
        DBGCode = DBG_CONTINUE;
        if (engineStepCount == 0)
        {
            typedef void(TITCALL* fCustomBreakPoint)(void);
            auto cbStep = fCustomBreakPoint(engineStepCallBack);
            engineStepActive = false;
            engineStepCallBack = NULL;
            LeaveCriticalSection(&engineStepActiveCr);
            cbStep();
        }
        else
        {
            SingleStep(engineStepCount, engineStepCallBack);
            LeaveCriticalSection(&engineStepActiveCr);
        }
    }
    else
    {
        LeaveCriticalSection(&engineStepActiveCr);
    }
}

__declspec(dllexport) void TITCALL DebugLoop()
{
    bool FirstBPX = true;
    bool ResetBPX = false;
    bool PushfBPX = false;
    bool BreakDBG = false;
    bool ResetHwBPX = false;
    bool ResetMemBPX = false;
    bool SecondChance = false;
    bool hListProcessFirst = true;
    bool hListThreadFirst = true;
    bool hListLibraryFirst = true;
    PLIBRARY_ITEM_DATAW hLoadedLibData = NULL;
    PLIBRARY_BREAK_DATA ptrLibrarianData = NULL;
    typedef void(TITCALL * fCustomBreakPoint)(void);
    typedef void(TITCALL * fCustomHandler)(void* SpecialDBG);
    typedef void(TITCALL * fFindOEPHandler)(LPPROCESS_INFORMATION fProcessInfo, LPVOID fCallBack);
    fCustomHandler myCustomHandler;
    fCustomBreakPoint myCustomBreakPoint;
    SIZE_T ResetBPXSize = 0;
    ULONG_PTR ResetBPXAddressTo =  0;
    std::function<void()> ResetMemBpxCallback;
    ULONG_PTR NumberOfBytesReadWritten = 0;
    HANDLE hActiveThread;
    DWORD OldProtect;
    DWORD DebugRegisterXId = NULL;
    HARDWARE_DATA DebugRegisterX;
    wchar_t DLLDebugFileName[512];
    char szAnsiLibraryName[MAX_PATH];
    ULONG_PTR DLLPatchAddress;
    LPVOID DBGEntryPoint;

    wchar_t* szTranslatedNativeName;

    DWORD ThreadBeingProcessed = 0;
    std::unordered_map<DWORD, THREAD_ITEM_DATA> SuspendedThreads;
    bool IsDbgReplyLaterSupported = false;

    // Check if DBG_REPLY_LATER is supported based on Windows version (Windows 10, version 1507 or above)
    // https://www.gaijin.at/en/infos/windows-version-numbers
    const uint32_t NtBuildNumber = *(uint32_t*)(0x7FFE0000 + 0x260);
    if(NtBuildNumber != 0 && NtBuildNumber >= 10240)
    {
        IsDbgReplyLaterSupported = engineSafeStep;
    }

    DBGFileHandle = NULL;
    DBGCode = DBG_CONTINUE;
    engineFakeDLLHandle = NULL;
    DebugRegister[0].DrxEnabled = false;
    DebugRegister[1].DrxEnabled = false;
    DebugRegister[2].DrxEnabled = false;
    DebugRegister[3].DrxEnabled = false;
    engineProcessIsNowDetached = false;
    engineResumeProcessIfNoThreadIsActive = false;
    memset(&DBGEvent, 0, sizeof(DEBUG_EVENT));
    memset(&TerminateDBGEvent, 0, sizeof(DEBUG_EVENT));
    memset(&DLLDebugFileName, 0, sizeof(DLLDebugFileName));
    engineFileIsBeingDebugged = true;

    while(!BreakDBG) //actual debug loop
    {
        bool synchronizedStep = false;
        // Fix based on work by https://github.com/number201724
        if(!WaitForDebugEvent(&DBGEvent, 100))
        {
            if(engineProcessIsNowDetached)
            {
                DebugActiveProcessStop(dbgProcessInformation.dwProcessId);
                DebugAttachedToProcess = false;
                break;
            }
            if(WaitForSingleObject(dbgProcessInformation.hProcess, 0) == WAIT_OBJECT_0)
            {
                DBGEvent.dwDebugEventCode = EXIT_PROCESS_DEBUG_EVENT;
                DBGEvent.dwProcessId = dbgProcessInformation.dwProcessId;
                DBGEvent.dwThreadId = dbgProcessInformation.dwThreadId;
                if(!GetExitCodeProcess(dbgProcessInformation.hProcess, &DBGEvent.u.ExitProcess.dwExitCode))
                    DBGEvent.u.ExitProcess.dwExitCode = 0xFFFFFFFF;
            }
            else
            {
                // Regular timeout, wait again
                continue;
            }
        }

        if(IsDbgReplyLaterSupported)
        {
            if(DBGEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
            {
                // Check if there is a thread processing a single step
                if(ThreadBeingProcessed != 0 && DBGEvent.dwThreadId != ThreadBeingProcessed)
                {
                    // Reply to the dbg event later
                    DBGCode = DBG_REPLY_LATER;

                    goto continue_dbg_event;
                }
            }
            else if(DBGEvent.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT)
            {
                if(ThreadBeingProcessed != 0 && DBGEvent.dwThreadId == ThreadBeingProcessed)
                {
                    // Resume the other threads since the thread being processed is exiting
                    for(auto & itr : SuspendedThreads)
                        ResumeThread(itr.second.hThread);

                    SuspendedThreads.clear();
                    ThreadBeingProcessed = 0;
                }
            }
        }

        //Debug event custom handler
        if(DBGCustomHandler->chDebugEvent != NULL)
        {
            myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chDebugEvent);
            myCustomHandler(&DBGEvent);
        }

        //Debug event
        switch(DBGEvent.dwDebugEventCode)
        {
        case CREATE_PROCESS_DEBUG_EVENT:
        {
            // HACK: when hollowing the process the debug event still delivers the original image base
            if(engineDisableAslr && !DebugDebuggingDLL && DebugModuleImageBase != 0)
            {
                auto startAddress = ULONG_PTR(DBGEvent.u.CreateProcessInfo.lpStartAddress);
                if(startAddress)
                {
                    startAddress -= ULONG_PTR(DBGEvent.u.CreateProcessInfo.lpBaseOfImage);
                    startAddress += DebugModuleImageBase;
                    DBGEvent.u.CreateProcessInfo.lpStartAddress = LPTHREAD_START_ROUTINE(startAddress);
                }
                DBGEvent.u.CreateProcessInfo.lpBaseOfImage = LPVOID(DebugModuleImageBase);
            }

            bool attachBreakpoint = false;
            if(DBGFileHandle == NULL) //we didn't set the handle yet (initial process)
            {
                DBGEntryPoint = DBGEvent.u.CreateProcessInfo.lpStartAddress;
                DBGFileHandle = DBGEvent.u.CreateProcessInfo.hFile;
                DebugDebuggingMainModuleBase = (ULONG_PTR) DBGEvent.u.CreateProcessInfo.lpBaseOfImage;
                if(DebugAttachedToProcess)  //we attached, set information
                {
                    dbgProcessInformation.hProcess = DBGEvent.u.CreateProcessInfo.hProcess;
                    dbgProcessInformation.hThread = DBGEvent.u.CreateProcessInfo.hThread;
                    dbgProcessInformation.dwThreadId = NULL;
                    if(engineAttachedProcessDebugInfo != NULL)
                    {
                        RtlMoveMemory(engineAttachedProcessDebugInfo, &dbgProcessInformation, sizeof PROCESS_INFORMATION);
                    }
                    attachBreakpoint = true;
                }
                if(DebugDebuggingDLL) //the DLL loader just started, set DLL names
                {
#if defined(_WIN64)
                    DLLPatchAddress = (ULONG_PTR)DBGEvent.u.CreateProcessInfo.lpBaseOfImage;
                    DLLPatchAddress = (ULONG_PTR)DLLPatchAddress + UE_MODULEx64;
#else
                    DLLPatchAddress = (ULONG_PTR)DBGEvent.u.CreateProcessInfo.lpBaseOfImage;
                    DLLPatchAddress = (ULONG_PTR)DLLPatchAddress + UE_MODULEx86;
#endif
                    if(DebugReserveModuleBase) //reserve original image base
                    {
                        VirtualAllocEx(dbgProcessInformation.hProcess, (void*)DebugReserveModuleBase, 0x1000, MEM_RESERVE, PAGE_READWRITE); //return value nt used, yea just ignore. return value doesnt matter and there is no possible fix when failed :D this is only used to make sure DLL loads on another image base
                    }
                }
                if(hListProcessFirst) //clear process list
                    ClearProcessList();
                hListProcessFirst = false;

                if(hListThreadFirst) //clear thread list
                    ClearThreadList();
                hListThreadFirst = false;
                //update thread list
                THREAD_ITEM_DATA NewThreadData;
                memset(&NewThreadData, 0, sizeof(THREAD_ITEM_DATA));
                NewThreadData.dwThreadId = DBGEvent.dwThreadId;
                NewThreadData.hThread = DBGEvent.u.CreateProcessInfo.hThread;
                NewThreadData.ThreadStartAddress = (void*)DBGEvent.u.CreateProcessInfo.lpStartAddress;
                NewThreadData.ThreadLocalBase = (void*)DBGEvent.u.CreateProcessInfo.lpThreadLocalBase;
                hListThread.push_back(NewThreadData);
            }
            //update process list
            PROCESS_ITEM_DATA NewProcessItem;
            memset(&NewProcessItem, 0, sizeof(PROCESS_ITEM_DATA));
            NewProcessItem.hFile = DBGEvent.u.CreateProcessInfo.hFile;
            NewProcessItem.hProcess = DBGEvent.u.CreateProcessInfo.hProcess;
            NewProcessItem.hThread = DBGEvent.u.CreateProcessInfo.hThread;
            NewProcessItem.dwProcessId = DBGEvent.dwProcessId;
            NewProcessItem.dwThreadId = DBGEvent.dwThreadId;
            NewProcessItem.BaseOfImage = (void*)DBGEvent.u.CreateProcessInfo.lpBaseOfImage;
            NewProcessItem.ThreadStartAddress = (void*)DBGEvent.u.CreateProcessInfo.lpStartAddress;
            NewProcessItem.ThreadLocalBase = (void*)DBGEvent.u.CreateProcessInfo.lpThreadLocalBase;
            hListProcess.push_back(NewProcessItem);

            //process created callback
            if(DBGCustomHandler->chCreateProcess != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chCreateProcess);
                myCustomHandler(&DBGEvent.u.CreateProcessInfo);
            }

            if(DBGFileHandle)
                EngineCloseHandle(DBGFileHandle); //close file handle

            // Call the attach breakpoint
            if(attachBreakpoint)
            {
                myCustomBreakPoint = (fCustomBreakPoint)(DebugAttachedProcessCallBack);
                myCustomBreakPoint();
            }
        }
        break;

        case EXIT_PROCESS_DEBUG_EVENT:
        {
            ProcessExitCode = DBGEvent.u.ExitProcess.dwExitCode;
            DBGCode = DBG_CONTINUE;
            if(DBGEvent.dwProcessId == dbgProcessInformation.dwProcessId) //main process closed
                BreakDBG = true;

            //exit process handler
            if(DBGCustomHandler->chExitProcess != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chExitProcess);
                myCustomHandler(&DBGEvent.u.ExitProcess);
            }
        }
        break;

        case CREATE_THREAD_DEBUG_EVENT:
        {
            //maintain thread list
            THREAD_ITEM_DATA NewThreadData;
            memset(&NewThreadData, 0, sizeof(THREAD_ITEM_DATA));
            NewThreadData.dwThreadId = DBGEvent.dwThreadId;
            NewThreadData.hThread = DBGEvent.u.CreateThread.hThread;
            NewThreadData.ThreadStartAddress = (void*)DBGEvent.u.CreateThread.lpStartAddress;
            NewThreadData.ThreadLocalBase = (void*)DBGEvent.u.CreateThread.lpThreadLocalBase;
            hListThread.push_back(NewThreadData);

            //Set hardware breakpoints to all threads
            HANDLE hThread = NewThreadData.hThread;
            if(DebugRegister[0].DrxEnabled)
                SetHardwareBreakPointEx(hThread, DebugRegister[0].DrxBreakAddress, UE_DR0, DebugRegister[0].DrxBreakPointType, DebugRegister[0].DrxBreakPointSize, (void*)DebugRegister[0].DrxCallBack, 0);
            if(DebugRegister[1].DrxEnabled)
                SetHardwareBreakPointEx(hThread, DebugRegister[1].DrxBreakAddress, UE_DR1, DebugRegister[1].DrxBreakPointType, DebugRegister[1].DrxBreakPointSize, (void*)DebugRegister[1].DrxCallBack, 0);
            if(DebugRegister[2].DrxEnabled)
                SetHardwareBreakPointEx(hThread, DebugRegister[2].DrxBreakAddress, UE_DR2, DebugRegister[2].DrxBreakPointType, DebugRegister[2].DrxBreakPointSize, (void*)DebugRegister[2].DrxCallBack, 0);
            if(DebugRegister[3].DrxEnabled)
                SetHardwareBreakPointEx(hThread, DebugRegister[3].DrxBreakAddress, UE_DR3, DebugRegister[3].DrxBreakPointType, DebugRegister[3].DrxBreakPointSize, (void*)DebugRegister[3].DrxCallBack, 0);
            if(ResetHwBPX)
            {
                SetHardwareBreakPoint(DebugRegisterX.DrxBreakAddress, DebugRegisterXId, DebugRegisterX.DrxBreakPointType, DebugRegisterX.DrxBreakPointSize, (void*)DebugRegisterX.DrxCallBack);
                ResetHwBPX = false;
            }

            //custom handler
            if(DBGCustomHandler->chCreateThread != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chCreateThread);
                myCustomHandler(&DBGEvent.u.CreateThread);
            }
        }
        break;

        case EXIT_THREAD_DEBUG_EVENT:
        {
            //custom handler
            if(DBGCustomHandler->chExitThread != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chExitThread);
                myCustomHandler(&DBGEvent.u.ExitThread);
            }
            if(engineExitThreadOneShootCallBack != NULL)
            {
                myCustomHandler = (fCustomHandler)(engineExitThreadOneShootCallBack);
                myCustomHandler(&DBGEvent.u.ExitThread);
                engineExitThreadOneShootCallBack = NULL;
            }

            //maintain thread list
            for(unsigned int i = 0; i < hListThread.size(); i++)
            {
                if(hListThread.at(i).dwThreadId == DBGEvent.dwThreadId) //found the thread to remove
                {
                    hListThread.erase(hListThread.begin() + i);
                    break;
                }
            }
        }
        break;

        case LOAD_DLL_DEBUG_EVENT:
        {
            //maintain library list
            if(hListLibraryFirst)
                ClearLibraryList();
            hListLibraryFirst = false;
            LIBRARY_ITEM_DATAW NewLibraryData;
            memset(&NewLibraryData, 0, sizeof(LIBRARY_ITEM_DATAW));
            NewLibraryData.BaseOfDll = DBGEvent.u.LoadDll.lpBaseOfDll;

            // Query remote DLL path
            if(GetMappedFileNameW(dbgProcessInformation.hProcess, DBGEvent.u.LoadDll.lpBaseOfDll, DLLDebugFileName, sizeof(DLLDebugFileName) / sizeof(wchar_t)))
            {
                int i = lstrlenW(DLLDebugFileName);
                while(DLLDebugFileName[i] != '\\' && i)
                    i--;
                if(DebugDebuggingDLL)
                {
                    if(lstrcmpiW(&DLLDebugFileName[i + 1], DebugDebuggingDLLFileName) == NULL)
                    {
                        CloseHandle(DebugDLLFileMapping); //close file mapping handle
                        SetBPX(DebugModuleEntryPoint + (ULONG_PTR)DBGEvent.u.LoadDll.lpBaseOfDll, UE_SINGLESHOOT, DebugModuleEntryPointCallBack);
                        DebugDebuggingDLLBase = (ULONG_PTR)DBGEvent.u.LoadDll.lpBaseOfDll;
                    }
                    /*else if(lstrcmpiW(&DLLDebugFileName[i+1], DebugDebuggingDLLReserveFileName) == NULL)
                    {
                        if((ULONG_PTR)DBGEvent.u.LoadDll.lpBaseOfDll != DebugModuleImageBase)
                        {
                            VirtualAllocEx(dbgProcessInformation.hProcess, (void*)DebugModuleImageBase, 0x1000, MEM_RESERVE, PAGE_READWRITE);
                        }
                    }*/
                }
                if(engineFakeDLLHandle == NULL)
                {
                    if(_wcsicmp(&DLLDebugFileName[i + 1], L"kernel32.dll") == NULL)
                    {
                        engineFakeDLLHandle = (ULONG_PTR)DBGEvent.u.LoadDll.lpBaseOfDll;
                    }
                }
                lstrcpyW(NewLibraryData.szLibraryName, &DLLDebugFileName[i + 1]);
                szTranslatedNativeName = (wchar_t*)TranslateNativeNameW(DLLDebugFileName);
                if(szTranslatedNativeName != nullptr)
                {
                    lstrcpyW(NewLibraryData.szLibraryPath, szTranslatedNativeName);
                    VirtualFree((void*)szTranslatedNativeName, NULL, MEM_RELEASE);
                }
                RtlZeroMemory(szAnsiLibraryName, sizeof(szAnsiLibraryName));
                WideCharToMultiByte(CP_ACP, NULL, NewLibraryData.szLibraryName, -1, szAnsiLibraryName, sizeof szAnsiLibraryName, NULL, NULL);

                //library breakpoint
                for(int i = (int)LibrarianData.size() - 1; i >= 0; i--)
                {
                    ptrLibrarianData = &LibrarianData.at(i);
                    if(!_stricmp(ptrLibrarianData->szLibraryName, szAnsiLibraryName))
                    {
                        if(ptrLibrarianData->bpxType == UE_ON_LIB_LOAD || ptrLibrarianData->bpxType == UE_ON_LIB_ALL)
                        {
                            myCustomHandler = (fCustomHandler)(ptrLibrarianData->bpxCallBack);
                            myCustomHandler(&DBGEvent.u.LoadDll);
                            if(ptrLibrarianData->bpxSingleShoot)
                            {
                                LibrarianRemoveBreakPoint(ptrLibrarianData->szLibraryName, ptrLibrarianData->bpxType);
                            }
                        }
                    }
                }
            }

            //maintain library list
            hListLibrary.push_back(NewLibraryData);

            //loadDLL callback
            if(DBGCustomHandler->chLoadDll != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chLoadDll);
                myCustomHandler(&DBGEvent.u.LoadDll);
            }

            if(DBGEvent.u.LoadDll.hFile)
                EngineCloseHandle(DBGEvent.u.LoadDll.hFile); //close file handle
        }
        break;

        case UNLOAD_DLL_DEBUG_EVENT:
        {
            //unload DLL callback
            if(DBGCustomHandler->chUnloadDll != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chUnloadDll);
                myCustomHandler(&DBGEvent.u.UnloadDll);
            }

            //library breakpoint
            hLoadedLibData = (PLIBRARY_ITEM_DATAW)LibrarianGetLibraryInfoEx(DBGEvent.u.UnloadDll.lpBaseOfDll);
            if(hLoadedLibData)
            {
                RtlZeroMemory(szAnsiLibraryName, sizeof(szAnsiLibraryName));
                WideCharToMultiByte(CP_ACP, NULL, hLoadedLibData->szLibraryName, -1, szAnsiLibraryName, sizeof szAnsiLibraryName, NULL, NULL);

                for(int i = (int)LibrarianData.size() - 1; i >= 0; i--)
                {
                    ptrLibrarianData = &LibrarianData.at(i);
                    if(!_stricmp(ptrLibrarianData->szLibraryName, szAnsiLibraryName))
                    {
                        if(ptrLibrarianData->bpxType == UE_ON_LIB_UNLOAD || ptrLibrarianData->bpxType == UE_ON_LIB_ALL)
                        {
                            myCustomHandler = (fCustomHandler)(ptrLibrarianData->bpxCallBack);
                            myCustomHandler(&DBGEvent.u.UnloadDll);
                            if(ptrLibrarianData->bpxSingleShoot)
                            {
                                LibrarianRemoveBreakPoint(ptrLibrarianData->szLibraryName, ptrLibrarianData->bpxType);
                            }
                        }
                    }
                }
            }

            //maintain library list
            for(unsigned int i = 0; i < hListLibrary.size(); i++)
            {
                if(hListLibrary.at(i).BaseOfDll == DBGEvent.u.UnloadDll.lpBaseOfDll)
                {
                    if(hListLibrary.at(i).hFileMappingView != NULL)
                    {
                        UnmapViewOfFile(hListLibrary.at(i).hFileMappingView);
                        EngineCloseHandle(hListLibrary.at(i).hFileMapping);
                    }
                    hListLibrary.erase(hListLibrary.begin() + i);
                    break;
                }
            }
        }
        break;

        case OUTPUT_DEBUG_STRING_EVENT:
        {
            //http://maximumcrack.wordpress.com/2009/06/22/outputdebugstring-awesomeness/ (the final advice is incorrect, but still helpful)
            DBGCode = DBG_EXCEPTION_NOT_HANDLED; //pass exception to debuggee
            //debug string callback
            if(DBGCustomHandler->chOutputDebugString != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chOutputDebugString);
                myCustomHandler(&DBGEvent.u.DebugString);
            }
        }
        break;

        case EXCEPTION_DEBUG_EVENT:
        {
            DBGCode = DBG_EXCEPTION_NOT_HANDLED; //let the debuggee handle exceptions per default

            if(DBGCustomHandler->chEverythingElse != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chEverythingElse);
                myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
            }
            if(DBGEvent.u.Exception.dwFirstChance == FALSE) //second chance exception
            {
                //NOTE: unclear behavious of ->Pass<- all exceptions (not to debuggee, but to debugger)
                if(!enginePassAllExceptions)
                {
                    DBGCode = DBG_CONTINUE;
                }
                else
                {
                    DBGCode = DBG_EXCEPTION_NOT_HANDLED; //let debuggee handle the exception
                }
                RtlMoveMemory(&TerminateDBGEvent, &DBGEvent, sizeof DEBUG_EVENT);
            }

            //handle different exception codes
            switch(DBGEvent.u.Exception.ExceptionRecord.ExceptionCode)
            {
            case STATUS_BREAKPOINT:
            {
                bool bFoundBreakPoint = false;
                BreakPointDetail FoundBreakPoint;
                int bpcount = (int)BreakPointBuffer.size();
                for(int i = 0; i < bpcount; i++)
                {
                    if(BreakPointBuffer.at(i).BreakPointAddress == (ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress - (BreakPointBuffer.at(i).BreakPointSize - 1) &&
                            (BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT) &&
                            BreakPointBuffer.at(i).BreakPointActive == UE_BPXACTIVE)
                    {
                        FoundBreakPoint = BreakPointBuffer.at(i);
                        bFoundBreakPoint = true;
                        break;
                    }
                }
                if(bFoundBreakPoint) //breakpoint found
                {
                    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, FoundBreakPoint.BreakPointSize, PAGE_EXECUTE_READWRITE, &OldProtect);
                    if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, &FoundBreakPoint.OriginalByte[0], FoundBreakPoint.BreakPointSize, &NumberOfBytesReadWritten))
                    {
                        FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
                        DBGCode = DBG_CONTINUE;
                        hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
                        CONTEXT myDBGContext;
                        myDBGContext.ContextFlags = ContextControlFlags;
                        GetThreadContext(hActiveThread, &myDBGContext);
                        if (FoundBreakPoint.BreakPointType != UE_SINGLESHOOT)
                        {
                            myDBGContext.EFlags |= UE_TRAP_FLAG;
                            synchronizedStep = true;
                        }
#if defined(_WIN64)
                        myDBGContext.Rip = myDBGContext.Rip - FoundBreakPoint.BreakPointSize;
#else
                        myDBGContext.Eip = myDBGContext.Eip - FoundBreakPoint.BreakPointSize;
#endif
                        SetThreadContext(hActiveThread, &myDBGContext);
                        EngineCloseHandle(hActiveThread);
                        VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, FoundBreakPoint.BreakPointSize, OldProtect, &OldProtect);

                        if(FoundBreakPoint.BreakPointType == UE_SINGLESHOOT)
                        {
                            DeleteBPX((ULONG_PTR)FoundBreakPoint.BreakPointAddress);
                            ResetBPXSize = FoundBreakPoint.BreakPointSize - 1;
                            ResetBPXAddressTo = NULL;
                            ResetBPX = false;
                        }
                        else
                        {
                            // if the current instruction pushes the flags, erase the trap flag from the stack after its execution
                            ULONG_PTR ueCurrentPosition = FoundBreakPoint.BreakPointAddress;
                            unsigned char instr[16];
                            MemoryReadSafe(dbgProcessInformation.hProcess, (void*)ueCurrentPosition, instr, sizeof(instr), 0);
                            char* DisassembledString = (char*)StaticDisassembleEx(ueCurrentPosition, (LPVOID)instr);
                            if(strstr(DisassembledString, "PUSHF"))
                                PushfBPX = true;
                        }

                        //execute callback
                        myCustomBreakPoint = (fCustomBreakPoint)((LPVOID)FoundBreakPoint.ExecuteCallBack);
                        myCustomBreakPoint();

                        if(FoundBreakPoint.BreakPointType != UE_SINGLESHOOT)
                        {
                            DisableBPX((ULONG_PTR)FoundBreakPoint.BreakPointAddress);
                            ResetBPXSize = FoundBreakPoint.BreakPointSize - 1;
                            ResetBPXAddressTo = (ULONG_PTR)FoundBreakPoint.BreakPointAddress;
                            ResetBPX = true;
                        }
                    }
                    else
                        VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, FoundBreakPoint.BreakPointSize, OldProtect, &OldProtect);
                }
                else //breakpoint not in list
                {
                    if(DebugAttachedToProcess || !FirstBPX) //program generated a breakpoint exception
                    {
                        DBGCode = DBG_EXCEPTION_NOT_HANDLED;
                        if(DBGCustomHandler->chBreakPoint != NULL)
                        {
                            myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chBreakPoint);
                            myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                        }
                    }
                    else //system breakpoint
                    {
                        FirstBPX = false;
                        DBGCode = DBG_CONTINUE;
                        if(engineAutoHideFromDebugger)
                        {
                            HideDebugger(dbgProcessInformation.hProcess, UE_HIDE_PEBONLY);
                        }
                        if(DebugExeFileEntryPointCallBack != NULL) //set entry breakpoint
                        {
                            SetBPX((ULONG_PTR)DBGEntryPoint, UE_SINGLESHOOT, DebugExeFileEntryPointCallBack);
                        }
                        if(engineTLSBreakOnCallBack) //set TLS callback breakpoints
                        {
                            for(unsigned int i = 0; i < tlsCallBackList.size(); i++)
                                SetBPX(tlsCallBackList.at(i), UE_SINGLESHOOT, (LPVOID)engineTLSBreakOnCallBackAddress);
                            ClearTlsCallBackList();
                            engineTLSBreakOnCallBackAddress = NULL;
                            engineTLSBreakOnCallBack = false;
                        }

                        //system breakpoint callback
                        if(DBGCustomHandler->chSystemBreakpoint != NULL)
                        {
                            myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chSystemBreakpoint);
                            myCustomHandler(&DBGEvent);
                        }
                    }
                }
            }
            break;

            case STATUS_SINGLE_STEP:
            {
                if(IsDbgReplyLaterSupported)
                {
                    // Resume the other threads since we are done processing the single step
                    for(auto & itr : SuspendedThreads)
                        ResumeThread(itr.second.hThread);

                    SuspendedThreads.clear();
                    ThreadBeingProcessed = 0;
                }

                if(ResetBPX == true || ResetHwBPX == true || ResetMemBPX == true) //restore breakpoints (internal step)
                {
                    DBGCode = DBG_CONTINUE;
                    if(PushfBPX) //remove trap flag from stack
                    {
                        PushfBPX = false;
                        void* csp = (void*)GetContextData(UE_CSP);
                        ULONG_PTR data = 0;
                        ReadProcessMemory(dbgProcessInformation.hProcess, csp, &data, sizeof(ULONG_PTR), 0);
                        data &= ~UE_TRAP_FLAG;
                        WriteProcessMemory(dbgProcessInformation.hProcess, csp, &data, sizeof(ULONG_PTR), 0);
                    }
                    if(ResetBPX) //restore 'normal' breakpoint
                    {
                        if(ResetBPXAddressTo + ResetBPXSize != (ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress)
                        {
                            EnableBPX(ResetBPXAddressTo);
                            ResetBPXAddressTo = NULL;
                            ResetBPX = false;
                            engineStep();
                        }
                        else
                        {
                            {
                                hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
                                CONTEXT myDBGContext;
                                myDBGContext.ContextFlags = ContextControlFlags;
                                GetThreadContext(hActiveThread, &myDBGContext);
                                myDBGContext.EFlags |= UE_TRAP_FLAG;
                                synchronizedStep = true;
                                SetThreadContext(hActiveThread, &myDBGContext);
                                EngineCloseHandle(hActiveThread);
                            }
                        }
                    }
                    if(ResetHwBPX) //restore hardware breakpoint
                    {
                        ResetHwBPX = false;
                        SetHardwareBreakPoint(DebugRegisterX.DrxBreakAddress, DebugRegisterXId, DebugRegisterX.DrxBreakPointType, DebugRegisterX.DrxBreakPointSize, (LPVOID)DebugRegisterX.DrxCallBack);
                        engineStep();
                    }
                    if(ResetMemBPX) //restore memory breakpoint
                    {
                        ResetMemBPX = false;
                        ResetMemBpxCallback();
                        engineStep();
                    }
                }
                else //no resetting needed (debugger reached hardware breakpoint or the user stepped)
                {
                    //handle hardware breakpoints
                    hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
                    CONTEXT myDBGContext;
                    myDBGContext.ContextFlags = CONTEXT_DEBUG_REGISTERS | ContextControlFlags;
                    GetThreadContext(hActiveThread, &myDBGContext);
                    if((ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress == myDBGContext.Dr0 || (myDBGContext.Dr6 & 0x1))
                    {
                        if(DebugRegister[0].DrxEnabled)
                        {
                            DBGCode = DBG_CONTINUE;
                            {
                                myDBGContext.EFlags |= UE_TRAP_FLAG;
                                synchronizedStep = true;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                            myCustomHandler = (fCustomHandler)(DebugRegister[0].DrxCallBack);
                            myCustomHandler((void*)myDBGContext.Dr0);
                            if(DebugRegister[0].DrxEnabled)
                            {
                                memcpy(&DebugRegisterX, &DebugRegister[0], sizeof(HARDWARE_DATA));
                                DebugRegisterXId = UE_DR0;
                                DeleteHardwareBreakPoint(UE_DR0);
                                ResetHwBPX = true;
                            }
                            else
                            {
                                GetThreadContext(hActiveThread, &myDBGContext);
                                myDBGContext.EFlags &= ~UE_TRAP_FLAG;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                        }
                        else
                        {
                            DBGCode = DBG_EXCEPTION_NOT_HANDLED;
                        }
                    }
                    else if((ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress == myDBGContext.Dr1 || (myDBGContext.Dr6 & 0x2))
                    {
                        if(DebugRegister[1].DrxEnabled)
                        {
                            DBGCode = DBG_CONTINUE;
                            {
                                myDBGContext.EFlags |= UE_TRAP_FLAG;
                                synchronizedStep = true;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                            myCustomHandler = (fCustomHandler)(DebugRegister[1].DrxCallBack);
                            myCustomHandler((void*)myDBGContext.Dr1);
                            if(DebugRegister[1].DrxEnabled)
                            {
                                memcpy(&DebugRegisterX, &DebugRegister[1], sizeof(HARDWARE_DATA));
                                DebugRegisterXId = UE_DR1;
                                DeleteHardwareBreakPoint(UE_DR1);
                                ResetHwBPX = true;
                            }
                            else
                            {
                                GetThreadContext(hActiveThread, &myDBGContext);
                                myDBGContext.EFlags &= ~UE_TRAP_FLAG;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                        }
                        else
                        {
                            DBGCode = DBG_EXCEPTION_NOT_HANDLED;
                        }
                    }
                    else if((ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress == myDBGContext.Dr2 || (myDBGContext.Dr6 & 0x4))
                    {
                        if(DebugRegister[2].DrxEnabled)
                        {
                            DBGCode = DBG_CONTINUE;
                            {
                                myDBGContext.EFlags |= UE_TRAP_FLAG;
                                synchronizedStep = true;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                            myCustomHandler = (fCustomHandler)(DebugRegister[2].DrxCallBack);
                            myCustomHandler((void*)myDBGContext.Dr2);
                            if(DebugRegister[2].DrxEnabled)
                            {
                                memcpy(&DebugRegisterX, &DebugRegister[2], sizeof(HARDWARE_DATA));
                                DebugRegisterXId = UE_DR2;
                                DeleteHardwareBreakPoint(UE_DR2);
                                ResetHwBPX = true;
                            }
                            else
                            {
                                GetThreadContext(hActiveThread, &myDBGContext);
                                myDBGContext.EFlags &= ~UE_TRAP_FLAG;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                        }
                        else
                        {
                            DBGCode = DBG_EXCEPTION_NOT_HANDLED;
                        }
                    }
                    else if((ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress == myDBGContext.Dr3 || (myDBGContext.Dr6 & 0x8))
                    {
                        if(DebugRegister[3].DrxEnabled)
                        {
                            DBGCode = DBG_CONTINUE;
                            {
                                myDBGContext.EFlags |= UE_TRAP_FLAG;
                                synchronizedStep = true;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                            myCustomHandler = (fCustomHandler)(DebugRegister[3].DrxCallBack);
                            myCustomHandler((void*)myDBGContext.Dr3);
                            if(DebugRegister[3].DrxEnabled)
                            {
                                memcpy(&DebugRegisterX, &DebugRegister[3], sizeof(HARDWARE_DATA));
                                DebugRegisterXId = UE_DR3;
                                DeleteHardwareBreakPoint(UE_DR3);
                                ResetHwBPX = true;
                            }
                            else
                            {
                                GetThreadContext(hActiveThread, &myDBGContext);
                                myDBGContext.EFlags &= ~UE_TRAP_FLAG;
                                SetThreadContext(hActiveThread, &myDBGContext);
                            }
                        }
                        else
                        {
                            DBGCode = DBG_EXCEPTION_NOT_HANDLED;
                        }
                    }
                    else //debuggee generated exception
                    {
                        DBGCode = DBG_EXCEPTION_NOT_HANDLED;
                    }
                    EngineCloseHandle(hActiveThread);
                    if(ResetHwBPX) //a hardware breakpoint was reached
                    {
                        ULONG_PTR ueCurrentPosition = GetContextData(UE_CIP);
                        unsigned char instr[16];
                        MemoryReadSafe(dbgProcessInformation.hProcess, (void*)ueCurrentPosition, instr, sizeof(instr), 0);
                        char* DisassembledString = (char*)StaticDisassembleEx(ueCurrentPosition, (LPVOID)instr);
                        if(strstr(DisassembledString, "PUSHF"))
                            PushfBPX = true;
                    }
                    engineStep();
                }
                if(DBGCode == DBG_EXCEPTION_NOT_HANDLED) //NOTE: only call the chSingleStep callback when the debuggee generated the exception
                {
                    if(DBGCustomHandler->chSingleStep != NULL)
                    {
                        myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chSingleStep);
                        myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                    }
                }
            }
            break;

            case STATUS_GUARD_PAGE_VIOLATION:
            case STATUS_ACCESS_VIOLATION:
            {
                //  Plan (making sure the breakpoint is valid):
                // 1) Check if one of our BPs falls into the access address
                // 2) Check if this breakpoint is of the right type (READ, WRITE, etc)
                // 3) Somehow check if the exception wasn't maliciosly caused by the debugged program
                // 4) If all are true (i.e. the BP is ours):
                //      call the user callback, restore the original protection, single-step, put our protection back
                //    if not:
                //      - don't call the user callback
                //      - restore the protection if there are still our BPs on this page OR pass the exception to the debuggee

                DBGCode = DBG_EXCEPTION_NOT_HANDLED;
                ResetMemBPX = false;
                bool bCallUserCallback = false; // when we hit a correct BP

                // Access Types: 0 - read, 1 - write, 8 - execute (dep violation)
                ULONG_PTR accessType = DBGEvent.u.Exception.ExceptionRecord.ExceptionInformation[0];
                ULONG_PTR accessAddr = DBGEvent.u.Exception.ExceptionRecord.ExceptionInformation[1];
                ULONG_PTR currentPageAddr = ALIGN_DOWN_BY(accessAddr, TITANENGINE_PAGESIZE);
                bool isAccessViolation = DBGEvent.u.Exception.ExceptionRecord.ExceptionCode == STATUS_ACCESS_VIOLATION;


                // Part 1.
                // Find the breakpoint which was hit (if any)
                bool bFoundBreakPoint = false;
                BreakPointDetail foundBreakPoint;
                size_t bpcount = BreakPointBuffer.size();
                for(size_t i = 0; i < bpcount; i++)
                {
                    ULONG_PTR bpAddr = BreakPointBuffer.at(i).BreakPointAddress;
                    auto bpType = BreakPointBuffer.at(i).BreakPointType;
                    bool isMemBp = bpType == UE_MEMORY || bpType == UE_MEMORY_READ || bpType == UE_MEMORY_WRITE || bpType == UE_MEMORY_EXECUTE;
                    bool isActive = BreakPointBuffer.at(i).BreakPointActive == UE_BPXACTIVE;

                    if(isActive && isMemBp && accessAddr >= bpAddr && accessAddr < (bpAddr + BreakPointBuffer.at(i).BreakPointSize))
                    {
                        foundBreakPoint = BreakPointBuffer.at(i);
                        bFoundBreakPoint = true;
                        break;
                    }
                }

                auto hitPage = MemoryBreakpointPages.find(currentPageAddr);
                if(!bFoundBreakPoint)
                {
                    // There were no BPs at the accessed address.
                    // But this page may still contain our BPs somewhere else
                    if(hitPage != MemoryBreakpointPages.end())
                    {
                        // There is a breakpoint! Maybe it caused this exception?
                        // We should restore the page protection and continue execution.
                        ResetMemBPX = true;
                    }
                    else
                    {
                        // There are no breakpoints (our BP could not cause this exception).
                        // So don't do anything at all and pass the exception to the debuggee.
                    }
                }
                else if(hitPage == MemoryBreakpointPages.end())
                {
                    // Inconsistent page data; should never happen
                }
                else
                {
                    // The debuggee actually hit one of our breakpoints
                    MemoryBreakpointPageDetail pageData = hitPage->second;

                    // Part 2.
                    // Ensure that the access type was correct.
                    bool isCorrectAccessType = false;
                    switch(foundBreakPoint.BreakPointType)
                    {
                    case UE_MEMORY: // READ | WRITE | EXECUTE
                        isCorrectAccessType = true; // all access types are fine
                        break;
                    case UE_MEMORY_READ:
                        isCorrectAccessType = accessType == 0; // READ
                        break;
                    case UE_MEMORY_WRITE:
                        isCorrectAccessType = accessType == 1; // WRITE
                        break;
                    case UE_MEMORY_EXECUTE:
                        isCorrectAccessType = (accessType == 8 || accessType == 0) // EXECUTE or READ (when DEP is disabled/unsupported?)
                                              && accessAddr == (ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress;
                        break;
                    default:
                        isCorrectAccessType = false; // unreachable
                        break;
                    }

                    // Part 2.5.
                    // Maybe the debuggee intentially generated this exception OR changed the page protection?
                    //  In that case we shouldn't handle the exception.
                    //
                    // Sanity checks: the type of the exception loosely corresponds to the page protection we originally set.
                    bool bpTypeIsGuardPage = (pageData.newProtect & PAGE_GUARD) != 0;
                    if(bpTypeIsGuardPage && isAccessViolation || !bpTypeIsGuardPage && !isAccessViolation)
                    {
                        // We wouldn't make a BP with this kind of protection. Pass the exception to the debuggee.
                    }
                    else if(isAccessViolation  // STATUS_ACCESS_VIOLATION
                            && (accessType == 1 /*WRITE*/ && pageData.writeBps == 0 || accessType == 8 /*EXECUTE*/ && pageData.executeBps == 0)
                            && (pageData.newProtect & 0xFF) != PAGE_NOACCESS)
                    {
                        // The STATUS_ACCESS_VIOLATION exception was on Write (or Execute), but there is no BP on Write (or Execute).
                        // Probably the debuggee directly caused the exception. Don't handle it.
                    }
                    else if(!isAccessViolation  // STATUS_GUARD_PAGE_VIOLATION
                            && pageData.accessBps == 0 && pageData.readBps == 0     // no ACCESS and READ bps
                            && (pageData.executeBps == 0 || !bpTypeIsGuardPage))    // no EXECUTE bps (when implemented via guard pages)
                    {
                        // The STATUS_GUARD_PAGE_VIOLATION exception was within a page that had no BPs on READ, ACCESS,
                        //  and EXECUTE (and DEP is disabled, otherwise we wouldn't use the guard pages). Pass it on.
                    }
                    else if(!isCorrectAccessType)
                    {
                        // The access type was wrong, i.e. this is not "exactly" our breakpoint.
                        // Potentially, we could get here from our BP (e.g. by writing into a page with only a READ bp)
                        // Restore the protection and move on.
                        ResetMemBPX = true;
                    }
                    else
                    {
                        // Part 3.
                        // This was indeed our breakpoint, and of the right type, too. We can call the user callback now.
                        bCallUserCallback = true;

                        if(!foundBreakPoint.MemoryBpxRestoreOnHit)
                        {
                            // BP was singleshot and should be removed
                            RemoveMemoryBPX(foundBreakPoint.BreakPointAddress, foundBreakPoint.BreakPointSize);
                        }

                        // Even though this breakpoint might be singleshot, we still temporarily remove the protection
                        //  because there can be other breakpoints on this page that won't let us execute the current instruction normally
                        ResetMemBPX = true;
                    }
                }

                // Part 4
                //
                // At this point, if we want to restore the breakpoint, we should temporarily put the original
                // protection back. The problem is that the original protection might not allow us to continue execution
                // (e.g. when we put a WRITE bp on a page originally marked READONLY). In some cases, it may lead to
                // an infinite loop (single-stepping might fail and call this handler, which will try to automatically
                // single-step again and end up at this exact place, and so on). So if we are sure that resetting the BP is not a good idea,
                // we just pass the exception on. Or maybe it's better to set PAGE_EXECUTE_READWRITE and simply continue?
                DWORD originalProtect = hitPage->second.origProtect;
                if(ResetMemBPX && (bCallUserCallback || IsMemoryAccessAllowed(originalProtect, accessType)))
                {
                    // Mini Plan:
                    // 1) Set a protection option that would allow us to normally execute the instruction that caused this exception
                    // 2) Single-step (execute the instruction)
                    // 3) Restore the previous protection (i.e. our memory breakpoint)

                    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)currentPageAddr, TITANENGINE_PAGESIZE, originalProtect, &OldProtect);

                    if(bCallUserCallback)
                    {
                        myCustomHandler = (fCustomHandler)(foundBreakPoint.ExecuteCallBack);
                        myCustomHandler((void*)accessAddr);
                    }

                    ResetMemBpxCallback = [currentPageAddr]
                    {
                        // We have successfully executed the instruction!
                        // But by this point the breakpoint could have been removed in a callback.
                        // We should check if it's still here (or some of our other breakpoints),
                        //  otherwise there's no need to restore the protection.

                        auto hitPage = MemoryBreakpointPages.find(currentPageAddr);
                        if(hitPage != MemoryBreakpointPages.end())
                        {
                            // The BP still exists OR it's been removed and a new one added
                            auto & pageData = hitPage->second;
                            DWORD oldProtect = 0;
                            VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)currentPageAddr, TITANENGINE_PAGESIZE, pageData.newProtect, &oldProtect);
                        }
                    };

                    // We've handled the exception
                    DBGCode = DBG_CONTINUE;

                    // Use the trap flag to schedule the page protection restoration on the next single-step event
                    synchronizedStep = true;
                    hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
                    CONTEXT myDBGContext;
                    myDBGContext.ContextFlags = ContextControlFlags;
                    GetThreadContext(hActiveThread, &myDBGContext);
                    myDBGContext.EFlags |= UE_TRAP_FLAG;
                    SetThreadContext(hActiveThread, &myDBGContext);
                    EngineCloseHandle(hActiveThread);

                    // Prevent the trap flag from leaking to the stack (by erasing it right after executing PUSHF)
                    ULONG_PTR ueCurrentPosition = GetContextData(UE_CIP);
                    unsigned char instr[16];
                    MemoryReadSafe(dbgProcessInformation.hProcess, (void*)ueCurrentPosition, instr, sizeof(instr), nullptr);
                    char* DisassembledString = (char*)StaticDisassembleEx(ueCurrentPosition, (LPVOID)instr);
                    if(strstr(DisassembledString, "PUSHF"))
                        PushfBPX = true;
                }


                // Debuggee generated the GUARD_PAGE or ACCESS_VIOLATION exception
                if(DBGCode == DBG_EXCEPTION_NOT_HANDLED)
                {
                    if(isAccessViolation)
                    {
                        if(DBGCustomHandler->chAccessViolation != NULL)
                        {
                            myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chAccessViolation);
                            myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                        }
                    }
                    else
                    {
                        if(DBGCustomHandler->chPageGuard != NULL)
                        {
                            myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chPageGuard);
                            myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                        }
                    }
                }
            }
            break;

            case STATUS_ILLEGAL_INSTRUCTION:
            {
                //UD2 breakpoint
                bool bFoundBreakPoint = false;
                BreakPointDetail FoundBreakPoint;
                int bpcount = (int)BreakPointBuffer.size();
                for(int i = 0; i < bpcount; i++)
                {
                    if(BreakPointBuffer.at(i).BreakPointAddress == (ULONG_PTR)DBGEvent.u.Exception.ExceptionRecord.ExceptionAddress &&
                            (BreakPointBuffer.at(i).BreakPointType == UE_BREAKPOINT || BreakPointBuffer.at(i).BreakPointType == UE_SINGLESHOOT) &&
                            BreakPointBuffer.at(i).BreakPointActive == UE_BPXACTIVE)
                    {
                        FoundBreakPoint = BreakPointBuffer.at(i);
                        bFoundBreakPoint = true;
                        break;
                    }
                }
                if(bFoundBreakPoint) //found ud2 breakpoint
                {
                    VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, FoundBreakPoint.BreakPointSize, PAGE_EXECUTE_READWRITE, &OldProtect);
                    if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, &FoundBreakPoint.OriginalByte[0], FoundBreakPoint.BreakPointSize, &NumberOfBytesReadWritten))
                    {
                        FlushInstructionCache(dbgProcessInformation.hProcess, NULL, 0);
                        DBGCode = DBG_CONTINUE;

                        {
                            hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
                            CONTEXT myDBGContext;
                            myDBGContext.ContextFlags = ContextControlFlags;
                            GetThreadContext(hActiveThread, &myDBGContext);
                            if (FoundBreakPoint.BreakPointType != UE_SINGLESHOOT)
                            {
                                myDBGContext.EFlags |= UE_TRAP_FLAG;
                                synchronizedStep = true;
                            }
                            SetThreadContext(hActiveThread, &myDBGContext);
                            EngineCloseHandle(hActiveThread);
                        }

                        VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, FoundBreakPoint.BreakPointSize, OldProtect, &OldProtect);

                        if(FoundBreakPoint.BreakPointType == UE_SINGLESHOOT)
                        {
                            DeleteBPX((ULONG_PTR)FoundBreakPoint.BreakPointAddress);
                            ResetBPXSize = FoundBreakPoint.BreakPointSize - 1;
                            ResetBPXAddressTo = NULL;
                            ResetBPX = false;
                        }
                        else
                        {
                            // if the current instruction pushes the flags, erase the trap flag from the stack after its execution
                            ULONG_PTR ueCurrentPosition = FoundBreakPoint.BreakPointAddress;
                            unsigned char instr[16];
                            MemoryReadSafe(dbgProcessInformation.hProcess, (void*)ueCurrentPosition, instr, sizeof(instr), 0);
                            char* DisassembledString = (char*)StaticDisassembleEx(ueCurrentPosition, (LPVOID)instr);
                            if(strstr(DisassembledString, "PUSHF"))
                                PushfBPX = true;
                        }

                        //execute callback
                        myCustomBreakPoint = (fCustomBreakPoint)((LPVOID)FoundBreakPoint.ExecuteCallBack);
                        myCustomBreakPoint();

                        if(FoundBreakPoint.BreakPointType != UE_SINGLESHOOT)
                        {
                            DisableBPX((ULONG_PTR)FoundBreakPoint.BreakPointAddress);
                            ResetBPXSize = FoundBreakPoint.BreakPointSize - 1;
                            ResetBPXAddressTo = (ULONG_PTR)FoundBreakPoint.BreakPointAddress;
                            ResetBPX = true;
                        }
                    }
                    else
                        VirtualProtectEx(dbgProcessInformation.hProcess, (LPVOID)FoundBreakPoint.BreakPointAddress, FoundBreakPoint.BreakPointSize, OldProtect, &OldProtect);
                }
                else
                    DBGCode = DBG_EXCEPTION_NOT_HANDLED;

                //application-generated exception
                if(DBGCode == DBG_EXCEPTION_NOT_HANDLED)
                {
                    if(DBGCustomHandler->chIllegalInstruction != NULL)
                    {
                        myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chIllegalInstruction);
                        myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                    }
                }
            }
            break;

            case STATUS_NONCONTINUABLE_EXCEPTION:
            {
                if(DBGCustomHandler->chNonContinuableException != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chNonContinuableException);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }
            break;

            case STATUS_ARRAY_BOUNDS_EXCEEDED:
            {
                if(DBGCustomHandler->chArrayBoundsException != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chArrayBoundsException);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }
            break;

            case STATUS_FLOAT_DENORMAL_OPERAND:
            {
                if(DBGCustomHandler->chFloatDenormalOperand != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chFloatDenormalOperand);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }
            break;

            case STATUS_FLOAT_DIVIDE_BY_ZERO:
            {
                if(DBGCustomHandler->chFloatDevideByZero != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chFloatDevideByZero);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }
            break;

            case STATUS_INTEGER_DIVIDE_BY_ZERO:
            {
                if(DBGCustomHandler->chIntegerDevideByZero != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chIntegerDevideByZero);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }
            break;

            case STATUS_INTEGER_OVERFLOW:
            {
                if(DBGCustomHandler->chIntegerOverflow != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chIntegerOverflow);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }
            break;

            case STATUS_PRIVILEGED_INSTRUCTION:
            {
                if(DBGCustomHandler->chPrivilegedInstruction != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chPrivilegedInstruction);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }
            break;
            }

            //general unhandled exception callback
            if(DBGCode == DBG_EXCEPTION_NOT_HANDLED)
            {
                engineStepActive = false;

                if(DBGCustomHandler->chUnhandledException != NULL)
                {
                    myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chUnhandledException);
                    myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
                }
            }

            //general after-exception callback (includes debugger exceptions)
            if(DBGCustomHandler->chAfterException != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chAfterException);
                myCustomHandler(&DBGEvent.u.Exception.ExceptionRecord);
            }
        }
        break;

        case RIP_EVENT:
        {
            DBGCode = DBG_EXCEPTION_NOT_HANDLED; //fix an anti-debug trick
            //rip event callback
            if(DBGCustomHandler->chRipEvent != NULL)
            {
                myCustomHandler = (fCustomHandler)((LPVOID)DBGCustomHandler->chRipEvent);
                myCustomHandler(&DBGEvent);
            }
        }
        break;
        }

        if(IsDbgReplyLaterSupported && DBGEvent.dwDebugEventCode != EXIT_THREAD_DEBUG_EVENT)
        {
            hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, DBGEvent.dwThreadId);
            if(hActiveThread != NULL)
            {
                // If TF is set (single step), then suspend all the other threads
                if(synchronizedStep)
                {
                    ThreadBeingProcessed = DBGEvent.dwThreadId;

                    for(auto & Thread : hListThread)
                    {
                        // Do not suspend the current thread
                        if(ThreadBeingProcessed == Thread.dwThreadId)
                            continue;

                        // Check if the thread is already suspended
                        if (SuspendedThreads.count(Thread.dwThreadId) != 0)
                            continue;

                        if (SuspendThread(Thread.hThread) != -1)
                            SuspendedThreads.emplace(Thread.dwThreadId, Thread);
                    }
                }

                EngineCloseHandle(hActiveThread);
            }
        }

continue_dbg_event:

        if(engineResumeProcessIfNoThreadIsActive)
        {
            if(!ThreaderIsAnyThreadActive())
            {
                ThreaderResumeProcess();
            }
        }
        if(!ContinueDebugEvent(DBGEvent.dwProcessId, DBGEvent.dwThreadId, DBGCode)) //continue debugging
        {
            break;
        }
        if(engineProcessIsNowDetached)
        {
            DebugActiveProcessStop(dbgProcessInformation.dwProcessId);
            DebugAttachedToProcess = false;
            break;
        }
        if(!ThreaderGetThreadInfo(0, DBGEvent.dwThreadId)) //switch thread
            DBGEvent.dwThreadId = dbgProcessInformation.dwThreadId;
    }

    if(!SecondChance) //debugger didn't close with a second chance exception (normal exit)
    {
        RtlMoveMemory(&TerminateDBGEvent, &DBGEvent, sizeof DEBUG_EVENT);
    }
    ForceClose();
    engineFileIsBeingDebugged = false;
    DebuggerReset();
}

__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut)
{
    SetDebugLoopTimeOut(TimeOut);
    DebugLoop();
    SetDebugLoopTimeOut(INFINITE);
}

__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut)
{
    __debugbreak();
}



================================================
File: TitanEngine/TitanEngine.Debugger.Helper.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"

static char szParameterString[512];

__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize)
{

    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR ueNumberOfBytesRW = NULL;
    DWORD StringReadSize = NULL;

    if(MaximumStringSize == NULL)
    {
        MaximumStringSize = 512;
    }
    VirtualQueryEx(hProcess, (LPVOID)StringAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
    if((int)((ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize - (ULONG_PTR)StringAddress) < MaximumStringSize)
    {
        StringReadSize = (DWORD)((ULONG_PTR)StringAddress - (ULONG_PTR)MemInfo.BaseAddress);
        VirtualQueryEx(hProcess, (LPVOID)((ULONG_PTR)StringAddress + (ULONG_PTR)MemInfo.RegionSize), &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        if(MemInfo.State == MEM_COMMIT)
        {
            StringReadSize = MaximumStringSize;
        }
    }
    else
    {
        StringReadSize = MaximumStringSize;
    }
    RtlZeroMemory(StringStorage, MaximumStringSize);
    if(ReadProcessMemory(hProcess, (LPVOID)StringAddress, StringStorage, StringReadSize, &ueNumberOfBytesRW))
    {
        return true;
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType)
{

    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR ueNumberOfBytesRW = NULL;
    ULONG_PTR StackReadBuffer = NULL;
    ULONG_PTR StackFinalBuffer = NULL;
    ULONG_PTR StackReadAddress = NULL;
    DWORD StackSecondReadSize = NULL;
    DWORD StackReadSize = 512;
    DWORD StringReadSize = 512;
    bool ValueIsPointer = false;

    if(ParameterType == UE_PARAMETER_BYTE)
    {
        StackReadSize = 1;
    }
    else if(ParameterType == UE_PARAMETER_WORD)
    {
        StackReadSize = 2;
    }
    else if(ParameterType == UE_PARAMETER_DWORD)
    {
        StackReadSize = 4;
    }
    else if(ParameterType == UE_PARAMETER_QWORD)
    {
        StackReadSize = 8;
    }
    else
    {
        if(ParameterType >= UE_PARAMETER_PTR_BYTE && ParameterType <= UE_PARAMETER_UNICODE)
        {
            ValueIsPointer = true;
        }
        if(ParameterType == UE_PARAMETER_PTR_BYTE)
        {
            StackSecondReadSize = 1;
        }
        else if(ParameterType == UE_PARAMETER_PTR_WORD)
        {
            StackSecondReadSize = 2;
        }
        else if(ParameterType == UE_PARAMETER_PTR_DWORD)
        {
            StackSecondReadSize = 4;
        }
        else if(ParameterType == UE_PARAMETER_PTR_QWORD)
        {
            StackSecondReadSize = 8;
        }
        else
        {
            StackSecondReadSize = 0;
        }
        StackReadSize = sizeof ULONG_PTR;
    }
    if(FunctionType >= UE_FUNCTION_STDCALL && FunctionType <= UE_FUNCTION_CCALL_CALL && FunctionType != UE_FUNCTION_FASTCALL_RET)
    {
        StackReadAddress = (ULONG_PTR)GetContextData(UE_CSP);
        if(FunctionType != UE_FUNCTION_FASTCALL_CALL)
        {
            StackReadAddress = StackReadAddress + (ParameterNumber * sizeof ULONG_PTR);
            if(FunctionType >= UE_FUNCTION_STDCALL_CALL)
            {
                StackReadAddress = StackReadAddress - sizeof ULONG_PTR;
            }
        }
        else
        {
            if(ParameterNumber <= 4)
            {
                if(!ValueIsPointer)
                {
                    if(ParameterNumber == 1)
                    {
                        return((ULONG_PTR)GetContextData(UE_RCX));
                    }
                    else if(ParameterNumber == 2)
                    {
                        return((ULONG_PTR)GetContextData(UE_RDX));
                    }
                    else if(ParameterNumber == 3)
                    {
                        return((ULONG_PTR)GetContextData(UE_R8));
                    }
                    else if(ParameterNumber == 4)
                    {
                        return((ULONG_PTR)GetContextData(UE_R9));
                    }
                }
                else
                {
                    if(ParameterNumber == 1)
                    {
                        StackReadAddress = (ULONG_PTR)GetContextData(UE_RCX);
                    }
                    else if(ParameterNumber == 2)
                    {
                        StackReadAddress = (ULONG_PTR)GetContextData(UE_RDX);
                    }
                    else if(ParameterNumber == 3)
                    {
                        StackReadAddress = (ULONG_PTR)GetContextData(UE_R8);
                    }
                    else if(ParameterNumber == 4)
                    {
                        StackReadAddress = (ULONG_PTR)GetContextData(UE_R9);
                    }
                }
            }
            else
            {
                StackReadAddress = StackReadAddress + 0x20 + ((ParameterNumber - 4) * sizeof ULONG_PTR) - sizeof ULONG_PTR;
            }
        }
        if(ReadProcessMemory(hProcess, (LPVOID)StackReadAddress, &StackReadBuffer, sizeof ULONG_PTR, &ueNumberOfBytesRW))
        {
            if(!ValueIsPointer)
            {
                RtlMoveMemory((LPVOID)((ULONG_PTR)&StackFinalBuffer + sizeof ULONG_PTR - StackReadSize), (LPVOID)((ULONG_PTR)&StackReadBuffer + sizeof ULONG_PTR - StackReadSize), StackReadSize);
            }
            else
            {
                StackReadAddress = StackReadBuffer;
                if(StackSecondReadSize > NULL)
                {
                    if(ReadProcessMemory(hProcess, (LPVOID)StackReadAddress, &StackReadBuffer, sizeof ULONG_PTR, &ueNumberOfBytesRW))
                    {
                        RtlMoveMemory((LPVOID)((ULONG_PTR)&StackFinalBuffer + sizeof ULONG_PTR - StackSecondReadSize), (LPVOID)((ULONG_PTR)&StackReadBuffer + sizeof ULONG_PTR - StackSecondReadSize), StackSecondReadSize);
                    }
                    else
                    {
                        return(-1);
                    }
                }
                else
                {
                    VirtualQueryEx(hProcess, (LPVOID)StackReadAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
                    if((ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize - StackReadAddress < 512)
                    {
                        StringReadSize = (DWORD)((ULONG_PTR)StackReadAddress - (ULONG_PTR)MemInfo.BaseAddress);
                        VirtualQueryEx(hProcess, (LPVOID)(StackReadAddress + (ULONG_PTR)MemInfo.RegionSize), &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
                        if(MemInfo.State == MEM_COMMIT)
                        {
                            StringReadSize = 512;
                        }
                    }
                    RtlZeroMemory(&szParameterString, 512);
                    if(ReadProcessMemory(hProcess, (LPVOID)StackReadAddress, &szParameterString, StringReadSize, &ueNumberOfBytesRW))
                    {
                        return((ULONG_PTR)&szParameterString);
                    }
                    else
                    {
                        return(-1);
                    }
                }
            }
            return(StackFinalBuffer);
        }
        else
        {
            return(-1);
        }
    }
    return(-1);
}
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps)
{

    char ReadMemory[MAXIMUM_INSTRUCTION_SIZE] = {0};
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR ueNumberOfBytesRead = NULL;
    PMEMORY_CMP_HANDLER CompareMemory;
    ULONG_PTR TargetedAddress = NULL;
    DWORD CurrentInstructionSize;
    int ReadMemData = NULL;
    BYTE ReadByteData = NULL;

    if(hProcess != NULL)
    {
        VirtualQueryEx(hProcess, (LPVOID)InstructionAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        if(MemInfo.RegionSize > NULL)
        {
            if(ReadProcessMemory(hProcess, (LPVOID)InstructionAddress, ReadMemory, MAXIMUM_INSTRUCTION_SIZE, &ueNumberOfBytesRead))
            {
                CompareMemory = (PMEMORY_CMP_HANDLER)ReadMemory;
                CurrentInstructionSize = StaticLengthDisassemble(ReadMemory);
                if(CompareMemory->DataByte[0] == 0xE9 && CurrentInstructionSize == 5)
                {
                    RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)ReadMemory + 1), 4);
                    TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] == 0xEB && CurrentInstructionSize == 2)
                {
                    RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)ReadMemory + 1), 1);
                    if(ReadByteData > 0x7F)
                    {
                        ReadByteData = 0xFF - ReadByteData;
                        ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
                    }
                    else
                    {
                        ReadMemData = ReadByteData;
                    }
                    TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] == 0xE3 && CurrentInstructionSize == 2)
                {
                    RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)ReadMemory + 1), 1);
                    if(ReadByteData > 0x7F)
                    {
                        ReadByteData = 0xFF - ReadByteData;
                        ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
                    }
                    else
                    {
                        ReadMemData = ReadByteData;
                    }
                    TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] >= 0x71 && CompareMemory->DataByte[0] <= 0x7F && CurrentInstructionSize == 2)
                {
                    RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)ReadMemory + 1), 1);
                    if(ReadByteData > 0x7F)
                    {
                        ReadByteData = 0xFF - ReadByteData;
                        ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
                    }
                    TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] >= 0xE0 && CompareMemory->DataByte[0] <= 0xE2 && CurrentInstructionSize == 2)
                {
                    RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)ReadMemory + 1), 1);
                    if(ReadByteData > 0x7F)
                    {
                        ReadByteData = 0xFF - ReadByteData;
                        ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
                    }
                    else
                    {
                        ReadMemData = ReadByteData;
                    }
                    TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] == 0x0F && CompareMemory->DataByte[1] >= 0x81 && CompareMemory->DataByte[1] <= 0x8F && CurrentInstructionSize == 6)
                {
                    RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)ReadMemory + 2), 4);
                    TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] == 0x0F && CompareMemory->DataByte[1] >= 0x81 && CompareMemory->DataByte[1] <= 0x8F && CurrentInstructionSize == 4)
                {
                    ReadMemData = 0;
                    RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)ReadMemory + 2), 2);
                    TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] == 0xE8 && CurrentInstructionSize == 5 && JustJumps == false)
                {
                    RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)ReadMemory + 1), 4);
                    TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
                }
                else if(CompareMemory->DataByte[0] == 0xFF && CompareMemory->DataByte[1] == 0x25 && CurrentInstructionSize == 6)
                {
                    RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)ReadMemory + 2), 4);
                    TargetedAddress = ReadMemData;
                    if(sizeof HANDLE == 8)
                    {
                        TargetedAddress = TargetedAddress + InstructionAddress;
                    }
                }
                else if(CompareMemory->DataByte[0] == 0xFF && CompareMemory->DataByte[1] == 0x15 && CurrentInstructionSize == 6 && JustJumps == false)
                {
                    RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)ReadMemory + 2), 4);
                    TargetedAddress = ReadMemData;
                    if(sizeof HANDLE == 8)
                    {
                        TargetedAddress = TargetedAddress + InstructionAddress;
                    }
                }
                else if(CompareMemory->DataByte[0] == 0xFF && CompareMemory->DataByte[1] != 0x64 && CompareMemory->DataByte[1] >= 0x60 && CompareMemory->DataByte[1] <= 0x67 && CurrentInstructionSize == 3)
                {
                    ReadMemData = 0;
                    RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)ReadMemory + 2), 1);
                    TargetedAddress = ReadMemData;
                    if(CompareMemory->DataByte[1] == 0x60)
                    {
                        TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EAX);
                    }
                    else if(CompareMemory->DataByte[1] == 0x61)
                    {
                        TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_ECX);
                    }
                    else if(CompareMemory->DataByte[1] == 0x62)
                    {
                        TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EDX);
                    }
                    else if(CompareMemory->DataByte[1] == 0x63)
                    {
                        TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EBX);
                    }
                    else if(CompareMemory->DataByte[1] == 0x65)
                    {
                        TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EBP);
                    }
                    else if(CompareMemory->DataByte[1] == 0x66)
                    {
                        TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_ESI);
                    }
                    else if(CompareMemory->DataByte[1] == 0x67)
                    {
                        TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EDI);
                    }
                    ReadProcessMemory(hProcess, (LPVOID)TargetedAddress, &TargetedAddress, 4, &ueNumberOfBytesRead);
                }
            }
            return((ULONG_PTR)TargetedAddress);
        }
        return(NULL);
    }
    else
    {
        CompareMemory = (PMEMORY_CMP_HANDLER)InstructionAddress;
        CurrentInstructionSize = StaticLengthDisassemble((LPVOID)InstructionAddress);
        if(CompareMemory->DataByte[0] == 0xE9 && CurrentInstructionSize == 5)
        {
            RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)InstructionAddress + 1), 4);
            TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] == 0xEB && CurrentInstructionSize == 2)
        {
            RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)InstructionAddress + 1), 1);
            if(ReadByteData > 0x7F)
            {
                ReadByteData = 0xFF - ReadByteData;
                ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
            }
            else
            {
                ReadMemData = ReadByteData;
            }
            TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] == 0xE3 && CurrentInstructionSize == 2)
        {
            RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)InstructionAddress + 1), 1);
            if(ReadByteData > 0x7F)
            {
                ReadByteData = 0xFF - ReadByteData;
                ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
            }
            else
            {
                ReadMemData = ReadByteData;
            }
            TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] >= 0x71 && CompareMemory->DataByte[0] <= 0x7F && CurrentInstructionSize == 2)
        {
            RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)InstructionAddress + 1), 1);
            if(ReadByteData > 0x7F)
            {
                ReadByteData = 0xFF - ReadByteData;
                ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
            }
            TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] >= 0xE0 && CompareMemory->DataByte[0] <= 0xE2 && CurrentInstructionSize == 2)
        {
            RtlMoveMemory(&ReadByteData, (LPVOID)((ULONG_PTR)InstructionAddress + 1), 1);
            if(ReadByteData > 0x7F)
            {
                ReadByteData = 0xFF - ReadByteData;
                ReadMemData = NULL - ReadByteData - CurrentInstructionSize + 1;
            }
            else
            {
                ReadMemData = ReadByteData;
            }
            TargetedAddress = InstructionAddress + ReadMemData + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] == 0x0F && CompareMemory->DataByte[1] >= 0x81 && CompareMemory->DataByte[1] <= 0x8F && CurrentInstructionSize == 6)
        {
            RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)InstructionAddress + 2), 4);
            TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] == 0x0F && CompareMemory->DataByte[1] >= 0x81 && CompareMemory->DataByte[1] <= 0x8F && CurrentInstructionSize == 4)
        {
            ReadMemData = 0;
            RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)InstructionAddress + 2), 2);
            TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] == 0xE8 && CurrentInstructionSize == 5 && JustJumps == false)
        {
            RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)InstructionAddress + 1), 4);
            TargetedAddress = ReadMemData + InstructionAddress + CurrentInstructionSize;
        }
        else if(CompareMemory->DataByte[0] == 0xFF && CompareMemory->DataByte[1] == 0x25 && CurrentInstructionSize == 6)
        {
            RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)InstructionAddress + 2), 4);
            TargetedAddress = ReadMemData;
            if(sizeof HANDLE == 8)
            {
                TargetedAddress = TargetedAddress + InstructionAddress;
            }
        }
        else if(CompareMemory->DataByte[0] == 0xFF && CompareMemory->DataByte[1] == 0x15 && CurrentInstructionSize == 6 && JustJumps == false)
        {
            RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)InstructionAddress + 2), 4);
            TargetedAddress = ReadMemData;
            if(sizeof HANDLE == 8)
            {
                TargetedAddress = TargetedAddress + InstructionAddress;
            }
        }
        else if(CompareMemory->DataByte[0] == 0xFF && CompareMemory->DataByte[1] != 0x64 && CompareMemory->DataByte[1] >= 0x60 && CompareMemory->DataByte[1] <= 0x67 && CurrentInstructionSize == 3)
        {
            ReadMemData = 0;
            RtlMoveMemory(&ReadMemData, (LPVOID)((ULONG_PTR)InstructionAddress + 2), 1);
            TargetedAddress = ReadMemData;
            if(CompareMemory->DataByte[1] == 0x60)
            {
                TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EAX);
            }
            else if(CompareMemory->DataByte[1] == 0x61)
            {
                TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_ECX);
            }
            else if(CompareMemory->DataByte[1] == 0x62)
            {
                TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EDX);
            }
            else if(CompareMemory->DataByte[1] == 0x63)
            {
                TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EBX);
            }
            else if(CompareMemory->DataByte[1] == 0x65)
            {
                TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EBP);
            }
            else if(CompareMemory->DataByte[1] == 0x66)
            {
                TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_ESI);
            }
            else if(CompareMemory->DataByte[1] == 0x67)
            {
                TargetedAddress = TargetedAddress + (ULONG_PTR)GetContextData(UE_EDI);
            }
            RtlMoveMemory(&TargetedAddress, (LPVOID)((ULONG_PTR)TargetedAddress), 4);
        }
        return((ULONG_PTR)TargetedAddress);
    }
    return(NULL);
}
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress)
{
    return((ULONG_PTR)GetJumpDestinationEx(hProcess, InstructionAddress, false));
}
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags)
{
    ULONG_PTR ThreadCIP = NULL;
    DWORD ThreadEflags = NULL;
    char* DisassembledString;
    bool bCF = false;
    bool bPF = false;
    bool bAF = false;
    bool bZF = false;
    bool bSF = false;
    bool bTF = false;
    bool bIF = false;
    bool bDF = false;
    bool bOF = false;

    if(hProcess != NULL && (hThread || RegFlags))
    {
        if(InstructionAddress == NULL)
        {
            ThreadCIP = (ULONG_PTR)GetContextDataEx(hThread, UE_CIP);
        }
        else
        {
            ThreadCIP = InstructionAddress;
        }
        if(RegFlags == NULL)
        {
            ThreadEflags = (DWORD)GetContextDataEx(hThread, UE_EFLAGS);
        }
        else
        {
            ThreadEflags = (DWORD)RegFlags;
        }
        DisassembledString = (char*)DisassembleEx(hProcess, (LPVOID)ThreadCIP, true);
        if(DisassembledString != NULL)
        {
            if(ThreadEflags & (1 << 0))
            {
                bCF = true;
            }
            if(ThreadEflags & (1 << 2))
            {
                bPF = true;
            }
            if(ThreadEflags & (1 << 4))
            {
                bAF = true;
            }
            if(ThreadEflags & (1 << 6))
            {
                bZF = true;
            }
            if(ThreadEflags & (1 << 7))
            {
                bSF = true;
            }
            if(ThreadEflags & (1 << 8))
            {
                bTF = true;
            }
            if(ThreadEflags & (1 << 9))
            {
                bIF = true;
            }
            if(ThreadEflags & (1 << 10))
            {
                bDF = true;
            }
            if(ThreadEflags & (1 << 11))
            {
                bOF = true;
            }
            if(lstrcmpiA(DisassembledString, "RET") == NULL)
            {
                return (true);
            }
            else if(lstrcmpiA(DisassembledString, "RETF") == NULL)
            {
                return (true);
            }
            else if(lstrcmpiA(DisassembledString, "JMP") == NULL)
            {
                return true;
            }
            else if(lstrcmpiA(DisassembledString, "JA") == NULL)
            {
                if(bCF == false && bZF == false)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JAE") == NULL)
            {
                if(!bCF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JB") == NULL)
            {
                if(bCF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JBE") == NULL)
            {
                if(bCF == true || bZF == true)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JC") == NULL)
            {
                if(bCF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JCXZ") == NULL)
            {
                if((WORD)GetContextDataEx(hThread, UE_ECX) == NULL)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JECXZ") == NULL)
            {
                if((DWORD)GetContextDataEx(hThread, UE_ECX) == NULL)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JRCXZ") == NULL)
            {
                if((ULONG_PTR)GetContextDataEx(hThread, UE_RCX) == NULL)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JZ") == NULL)
            {
                if(bZF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNZ") == NULL)
            {
                if(!bZF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JE") == NULL)
            {
                if(bZF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNE") == NULL)
            {
                if(!bZF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JG") == NULL)
            {
                if(bZF == false && bSF == bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JGE") == NULL)
            {
                if(bSF == bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JL") == NULL)
            {
                if(bSF != bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JLE") == NULL)
            {
                if(bZF == true || bSF != bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNA") == NULL)
            {
                if(bCF == true || bZF == true)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNAE") == NULL)
            {
                if(bCF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNB") == NULL)
            {
                if(!bCF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNBE") == NULL)
            {
                if(bCF == false && bZF == false)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNC") == NULL)
            {
                if(!bCF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNG") == NULL)
            {
                if(bZF == true || bSF != bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNGE") == NULL)
            {
                if(bSF != bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNL") == NULL)
            {
                if(bSF == bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNLE") == NULL)
            {
                if(bZF == false && bSF == bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNO") == NULL)
            {
                if(!bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNP") == NULL)
            {
                if(!bPF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JNS") == NULL)
            {
                if(!bSF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JO") == NULL)
            {
                if(bOF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JP") == NULL)
            {
                if(bPF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JPE") == NULL)
            {
                if(bPF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JPO") == NULL)
            {
                if(!bPF)
                {
                    return true;
                }
            }
            else if(lstrcmpiA(DisassembledString, "JS") == NULL)
            {
                if(bSF)
                {
                    return true;
                }
            }
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute()
{
    return(IsJumpGoingToExecuteEx(dbgProcessInformation.hProcess, dbgProcessInformation.hThread, NULL, NULL));
}



================================================
File: TitanEngine/TitanEngine.Debugger.Memory.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "Global.Breakpoints.h"

__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard)
{
    if(!MemoryToCheck || !PatternToMatch || !SizeOfPatternToMatch || !SizeOfMemoryToCheck)
        return false;

    BYTE intWildCard = 0;
    LPVOID ueReadBuffer = NULL;
    DynBuf ueReadBuf;
    SIZE_T ueNumberOfBytesRead = 0;
    MEMORY_BASIC_INFORMATION memoryInformation = {};
    PMEMORY_COMPARE_HANDLER memCmp = (PMEMORY_COMPARE_HANDLER)MemoryToCheck;
    PMEMORY_COMPARE_HANDLER memPattern = (PMEMORY_COMPARE_HANDLER)PatternToMatch;

    if(WildCard == NULL)
    {
        WildCard = &intWildCard;
    }

    if(SizeOfMemoryToCheck >= SizeOfPatternToMatch)
    {
        if(hProcess != GetCurrentProcess())
        {
            ueReadBuffer = ueReadBuf.Allocate(SizeOfMemoryToCheck);
            if(ueReadBuffer && ReadProcessMemory(hProcess, MemoryToCheck, ueReadBuffer, SizeOfMemoryToCheck, &ueNumberOfBytesRead))
            {
                if(ueNumberOfBytesRead == 0)
                {
                    if(VirtualQueryEx(hProcess, MemoryToCheck, &memoryInformation, sizeof memoryInformation) != NULL)
                    {
                        SizeOfMemoryToCheck = (int)((ULONG_PTR)memoryInformation.BaseAddress + memoryInformation.RegionSize - (ULONG_PTR)MemoryToCheck);
                        if(!ReadProcessMemory(hProcess, MemoryToCheck, ueReadBuffer, SizeOfMemoryToCheck, &ueNumberOfBytesRead))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        return false;
                    }
                }
            }

            memCmp = (PMEMORY_COMPARE_HANDLER)ueReadBuffer;
        }
    }

    if(memCmp)
    {
        for(int i = 0; i < SizeOfMemoryToCheck && i < SizeOfPatternToMatch; i++)
        {
            if(memCmp->Array.bArrayEntry[i] != memPattern->Array.bArrayEntry[i] && memPattern->Array.bArrayEntry[i] != *WildCard)
            {
                return false;
            }
        }
    }

    return true;
}

__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard)
{

    if(dbgProcessInformation.hProcess != NULL)
    {
        return(MatchPatternEx(dbgProcessInformation.hProcess, MemoryToCheck, SizeOfMemoryToCheck, PatternToMatch, SizeOfPatternToMatch, WildCard));
    }
    else
    {
        return(MatchPatternEx(GetCurrentProcess(), MemoryToCheck, SizeOfMemoryToCheck, PatternToMatch, SizeOfPatternToMatch, WildCard));
    }
}

__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard)
{
    if(!hProcess || !MemoryStart || !MemorySize || !SearchPattern || !PatternSize)
        return 0;

    ULONG_PTR Return = NULL;
    LPVOID ueReadBuffer = NULL;
    DynBuf ueReadBuf;
    PUCHAR SearchBuffer = NULL;
    PUCHAR CompareBuffer = NULL;
    MEMORY_BASIC_INFORMATION memoryInformation = {};
    ULONG_PTR ueNumberOfBytesRead = NULL;
    LPVOID currentSearchPosition = NULL;
    DWORD currentSizeOfSearch = NULL;
    BYTE nWildCard = NULL;

    if(WildCard == NULL)
    {
        WildCard = &nWildCard;
    }

    if(hProcess != GetCurrentProcess())
    {
        ueReadBuffer = ueReadBuf.Allocate(MemorySize);
        if(ueReadBuffer && !MemoryReadSafe(hProcess, MemoryStart, ueReadBuffer, MemorySize, &ueNumberOfBytesRead))
        {
            if(ueNumberOfBytesRead == NULL)
            {
                if(VirtualQueryEx(hProcess, MemoryStart, &memoryInformation, sizeof memoryInformation) != NULL)
                {
                    MemorySize = (DWORD)((ULONG_PTR)memoryInformation.BaseAddress + memoryInformation.RegionSize - (ULONG_PTR)MemoryStart);
                    if(!MemoryReadSafe(hProcess, MemoryStart, ueReadBuffer, MemorySize, &ueNumberOfBytesRead))
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
        }

        SearchBuffer = (PUCHAR)ueReadBuffer;
    }
    else
    {
        SearchBuffer = (PUCHAR)MemoryStart;
    }

    CompareBuffer = (PUCHAR)SearchPattern;

    DWORD i, j;
    for(i = 0; i < MemorySize && Return == NULL; i++)
    {
        for(j = 0; j < PatternSize; j++)
        {
            if(CompareBuffer[j] != *(PUCHAR)WildCard && SearchBuffer[i + j] != CompareBuffer[j])
            {
                break;
            }
        }
        if(j == PatternSize)
        {
            Return = (ULONG_PTR)MemoryStart + i;
        }
    }

    return Return;
}

extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard)
{

    if(dbgProcessInformation.hProcess != NULL)
    {
        return(FindEx(dbgProcessInformation.hProcess, MemoryStart, MemorySize, SearchPattern, PatternSize, WildCard));
    }
    else
    {
        return(FindEx(GetCurrentProcess(), MemoryStart, MemorySize, SearchPattern, PatternSize, WildCard));
    }
}

__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte)
{

    unsigned int i;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR ueNumberOfBytesRead;
    BYTE defFillByte = 0x90;
    DWORD OldProtect;

    if(hProcess != NULL)
    {
        if(FillByte == NULL)
        {
            FillByte = &defFillByte;
        }
        VirtualQueryEx(hProcess, MemoryStart, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        OldProtect = MemInfo.Protect;
        VirtualProtectEx(hProcess, MemoryStart, MemorySize, PAGE_EXECUTE_READWRITE, &OldProtect);
        for(i = 0; i < MemorySize; i++)
        {
            WriteProcessMemory(hProcess, MemoryStart, FillByte, 1, &ueNumberOfBytesRead);
            MemoryStart = (LPVOID)((ULONG_PTR)MemoryStart + 1);
        }
        VirtualProtectEx(hProcess, MemoryStart, MemorySize, OldProtect, &OldProtect);
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte)
{

    if(dbgProcessInformation.hProcess != NULL)
    {
        return(FillEx(dbgProcessInformation.hProcess, MemoryStart, MemorySize, FillByte));
    }
    else
    {
        return(FillEx(GetCurrentProcess(), MemoryStart, MemorySize, FillByte));
    }
}

__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP)
{

    unsigned int i, recalcSize;
    LPVOID lpMemoryStart = MemoryStart;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR ueNumberOfBytesRead;
    BYTE FillByte = 0x90;
    DWORD OldProtect;

    if(hProcess != NULL)
    {
        VirtualQueryEx(hProcess, MemoryStart, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        OldProtect = MemInfo.Protect;
        VirtualProtectEx(hProcess, MemoryStart, MemorySize, PAGE_EXECUTE_READWRITE, &OldProtect);

        if(MemorySize - ReplaceSize != NULL)
        {
            recalcSize = abs((long)(MemorySize - ReplaceSize));
            if(AppendNOP)
            {
                WriteProcessMemory(hProcess, MemoryStart, ReplacePattern, ReplaceSize, &ueNumberOfBytesRead);
                lpMemoryStart = (LPVOID)((ULONG_PTR)MemoryStart + ReplaceSize);
                for(i = 0; i < recalcSize; i++)
                {
                    WriteProcessMemory(hProcess, lpMemoryStart, &FillByte, 1, &ueNumberOfBytesRead);
                    lpMemoryStart = (LPVOID)((ULONG_PTR)lpMemoryStart + 1);
                }
            }
            else if(PrependNOP)
            {
                lpMemoryStart = MemoryStart;
                for(i = 0; i < recalcSize; i++)
                {
                    WriteProcessMemory(hProcess, lpMemoryStart, &FillByte, 1, &ueNumberOfBytesRead);
                    lpMemoryStart = (LPVOID)((ULONG_PTR)lpMemoryStart + 1);
                }
                WriteProcessMemory(hProcess, lpMemoryStart, ReplacePattern, ReplaceSize, &ueNumberOfBytesRead);
            }
            else
            {
                WriteProcessMemory(hProcess, MemoryStart, ReplacePattern, ReplaceSize, &ueNumberOfBytesRead);
            }
        }
        else
        {
            WriteProcessMemory(hProcess, MemoryStart, ReplacePattern, ReplaceSize, &ueNumberOfBytesRead);
        }
        VirtualProtectEx(hProcess, MemoryStart, MemorySize, OldProtect, &OldProtect);
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP)
{

    if(dbgProcessInformation.hProcess != NULL)
    {
        return(PatchEx(dbgProcessInformation.hProcess, MemoryStart, MemorySize, ReplacePattern, ReplaceSize, AppendNOP, PrependNOP));
    }
    else
    {
        return(PatchEx(GetCurrentProcess(), MemoryStart, MemorySize, ReplacePattern, ReplaceSize, AppendNOP, PrependNOP));
    }
}

__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard)
{

    unsigned int i;
    ULONG_PTR ueNumberOfBytesRead;
    ULONG_PTR CurrentFoundPattern;
    LPVOID cMemoryStart = MemoryStart;
    DWORD cMemorySize = MemorySize;
    DynBuf lpReadMem;
    LPVOID lpReadMemory = lpReadMem.Allocate(PatternSize);

    CurrentFoundPattern = (ULONG_PTR)FindEx(hProcess, cMemoryStart, cMemorySize, SearchPattern, PatternSize, WildCard);
    NumberOfRepetitions--;
    while(CurrentFoundPattern != NULL && NumberOfRepetitions != NULL)
    {
        if(ReadProcessMemory(hProcess, (LPVOID)CurrentFoundPattern, lpReadMemory, PatternSize, &ueNumberOfBytesRead))
        {
            for(i = 0; i < ReplaceSize; i++)
            {
                if(memcmp((LPVOID)((ULONG_PTR)ReplacePattern + i), WildCard, 1) != NULL)
                {
                    RtlMoveMemory((LPVOID)((ULONG_PTR)lpReadMemory + i), (LPVOID)((ULONG_PTR)ReplacePattern + i), 1);
                }
            }
            PatchEx(hProcess, (LPVOID)CurrentFoundPattern, PatternSize, lpReadMemory, ReplaceSize, true, false);
        }
        cMemoryStart = (LPVOID)(CurrentFoundPattern + PatternSize);
        cMemorySize = (DWORD)((ULONG_PTR)MemoryStart + MemorySize - CurrentFoundPattern);
        CurrentFoundPattern = (ULONG_PTR)FindEx(hProcess, cMemoryStart, cMemorySize, SearchPattern, PatternSize, WildCard);
        NumberOfRepetitions--;
    }
    if(NumberOfRepetitions != NULL)
    {
        return false;
    }
    else
    {
        return true;
    }
}

__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard)
{

    if(dbgProcessInformation.hProcess != NULL)
    {
        return(ReplaceEx(dbgProcessInformation.hProcess, MemoryStart, MemorySize, SearchPattern, PatternSize, NumberOfRepetitions, ReplacePattern, ReplaceSize, WildCard));
    }
    else
    {
        return(ReplaceEx(GetCurrentProcess(), MemoryStart, MemorySize, SearchPattern, PatternSize, NumberOfRepetitions, ReplacePattern, ReplaceSize, WildCard));
    }
}

//what should this function do:
//- do all possible effort to read memory
//- filter out breakpoints
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead)
{
    SIZE_T ueNumberOfBytesRead = 0;
    SIZE_T* pNumBytes = 0;
    DWORD dwProtect = 0;
    bool retValue = false;

    //read memory
    if((hProcess == 0) || (lpBaseAddress == 0) || (lpBuffer == 0) || (nSize == 0))
    {
        return false;
    }

    if(!lpNumberOfBytesRead)
    {
        pNumBytes = &ueNumberOfBytesRead;
    }
    else
    {
        pNumBytes = lpNumberOfBytesRead;
    }

    if(!ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, pNumBytes))
    {
        CriticalSectionLocker memProtectLock(LockMemoryProtection);

        // try to temporarily change the page protections to PAGE_EXECUTE_READ
        std::vector<MEMORY_BASIC_INFORMATION> memRegions;
        MEMORY_BASIC_INFORMATION memInfo;
        ULONG_PTR endAddr = (ULONG_PTR)lpBaseAddress + nSize;
        for(ULONG_PTR page = ALIGN_DOWN_BY(lpBaseAddress, TITANENGINE_PAGESIZE); page < endAddr; page += memInfo.RegionSize)
        {
            if(0 == VirtualQueryEx(hProcess, (LPCVOID)page, &memInfo, sizeof memInfo))
                break; // failure ('VirtualProtectEx' will fail too)
            memRegions.push_back(memInfo);
        }

        if(VirtualProtectEx(hProcess, lpBaseAddress, nSize, PAGE_EXECUTE_READ, &dwProtect))
        {
            if(ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, pNumBytes))
            {
                retValue = true;
            }

            for(const auto & info : memRegions)
            {
                ULONG_PTR size = info.RegionSize;
                if(endAddr < (ULONG_PTR)info.BaseAddress + info.RegionSize)
                    size = endAddr - (ULONG_PTR)info.BaseAddress;
                VirtualProtectEx(hProcess, info.BaseAddress, size, info.Protect, &dwProtect);
            }
        }
    }
    else
    {
        retValue = true;
    }

    //filter breakpoints
    if(retValue)
        BreakPointPostReadFilter((ULONG_PTR)lpBaseAddress, (unsigned char*)lpBuffer, nSize);

    return retValue;
}

//what should this function do:
//- do all possible effort to write memory
//- re-set breakpoints when overwritten
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten)
{
    SIZE_T ueNumberOfBytesWritten = 0;
    SIZE_T* pNumBytes = 0;
    DWORD dwProtect = 0;
    bool retValue = false;

    //read memory
    if((hProcess == 0) || (lpBaseAddress == 0) || (lpBuffer == 0) || (nSize == 0))
    {
        return false;
    }

    CriticalSectionLocker lock(LockBreakPointBuffer); //thread-safe
    //disable breakpoints that interfere with the memory to write
    BreakPointPreWriteFilter((ULONG_PTR)lpBaseAddress, nSize);

    if(!lpNumberOfBytesWritten)
    {
        pNumBytes = &ueNumberOfBytesWritten;
    }
    else
    {
        pNumBytes = lpNumberOfBytesWritten;
    }

    if(!WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, pNumBytes) || *pNumBytes < nSize)
    {
        CriticalSectionLocker memProtectLock(LockMemoryProtection);

        // try to temporarily change the page protections to PAGE_EXECUTE_READWRITE
        std::vector<MEMORY_BASIC_INFORMATION> memRegions;
        MEMORY_BASIC_INFORMATION memInfo;
        ULONG_PTR endAddr = (ULONG_PTR)lpBaseAddress + nSize;
        for(ULONG_PTR page = ALIGN_DOWN_BY(lpBaseAddress, TITANENGINE_PAGESIZE); page < endAddr; page += memInfo.RegionSize)
        {
            if(0 == VirtualQueryEx(hProcess, (LPCVOID)page, &memInfo, sizeof memInfo))
                break; // failure
            memRegions.push_back(memInfo);
        }

        if(VirtualProtectEx(hProcess, lpBaseAddress, nSize, PAGE_EXECUTE_READWRITE, &dwProtect))
        {
            if(WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, pNumBytes))
            {
                retValue = true;
            }

            for(const auto & info : memRegions)
            {
                ULONG_PTR size = info.RegionSize;
                if(endAddr < (ULONG_PTR)info.BaseAddress + info.RegionSize)
                    size = endAddr - (ULONG_PTR)info.BaseAddress;
                VirtualProtectEx(hProcess, info.BaseAddress, size, info.Protect, &dwProtect);
            }
        }
    }
    else
    {
        retValue = true;
    }

    //re-enable breakpoints that interfere with the memory to write
    BreakPointPostWriteFilter((ULONG_PTR)lpBaseAddress, nSize);

    return retValue;
}



================================================
File: TitanEngine/TitanEngine.Debugger.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "Global.Engine.h"
#include "Global.Handle.h"
#include "Global.Threader.h"
#include "Global.Engine.Hider.h"

static wchar_t szBackupDebuggedFileName[512];

// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder)
{
    wchar_t* PtrUniFileName = NULL;
    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t* PtrUniCommandLine = NULL;
    wchar_t uniCommandLine[MAX_PATH] = {};
    wchar_t* PtrUniCurrentFolder = NULL;
    wchar_t uniCurrentFolder[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCommandLine, lstrlenA(szCommandLine) + 1, uniCommandLine, sizeof(uniCommandLine) / (sizeof(uniCommandLine[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCurrentFolder, lstrlenA(szCurrentFolder) + 1, uniCurrentFolder, sizeof(uniCurrentFolder) / (sizeof(uniCurrentFolder[0])));
        if(szFileName != NULL)
        {
            PtrUniFileName = &uniFileName[0];
        }
        if(szCommandLine != NULL)
        {
            PtrUniCommandLine = &uniCommandLine[0];
        }
        if(szCurrentFolder != NULL)
        {
            PtrUniCurrentFolder = &uniCurrentFolder[0];
        }
        return(InitDebugW(PtrUniFileName, PtrUniCommandLine, PtrUniCurrentFolder));
    }
    else
    {
        return NULL;
    }
}

static bool ProcessRelocations(char* imageCopy, ULONG_PTR imageSize, ULONG_PTR newImageBase, ULONG_PTR & oldImageBase)
{
    auto pnth = RtlImageNtHeader(imageCopy);
    if(pnth == nullptr)
        return false;

    // Put the new base in the header
    oldImageBase = pnth->OptionalHeader.ImageBase;
    pnth->OptionalHeader.ImageBase = newImageBase;

    // Nothing to do if relocations are stripped
    if(pnth->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED)
        return true;

    // Nothing to do if there are no relocations
    const auto & relocDir = pnth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    if(relocDir.Size == 0 || relocDir.VirtualAddress == 0)
        return true;

    // Process the relocations
    auto delta = newImageBase - oldImageBase;
    auto relocationItr = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)imageCopy + relocDir.VirtualAddress);
    auto relocationEnd = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)relocationItr + relocDir.Size);

    while(relocationItr < relocationEnd && relocationItr->SizeOfBlock > 0)
    {
        auto count = (relocationItr->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
        auto address = (ULONG_PTR)imageCopy + relocationItr->VirtualAddress;
        auto typeOffset = (PUSHORT)(relocationItr + 1);

        relocationItr = LdrProcessRelocationBlock(address, (ULONG)count, typeOffset, delta);
        if(relocationItr == nullptr)
            return false;
    }
    return true;
}

static bool RelocateImage(HANDLE hProcess, PVOID imageBase, SIZE_T imageSize)
{
    constexpr auto pageSize = 0x1000;
    std::vector<bool> writeback(imageSize / pageSize);
    // allocate a local copy of the mapped image
    auto imageCopy = (char*)VirtualAlloc(0, imageSize, MEM_COMMIT, PAGE_READWRITE);
    if(imageCopy == nullptr)
        return false;

    // read all the pages
    for(size_t i = 0; i < writeback.size(); i++)
    {
        auto offset = i * pageSize;
        SIZE_T read = 0;
        if(NT_SUCCESS(NtReadVirtualMemory(hProcess, (char*)imageBase + offset, imageCopy + offset, pageSize, &read)))
            writeback[i] = true;
    }

    // perform the actual relocations
    ULONG_PTR oldImageBase = 0;
    auto success = ProcessRelocations(imageCopy, imageSize, (ULONG_PTR)imageBase, oldImageBase);

    // write back the pages
    auto memWrite = [hProcess](PVOID ptr, LPCVOID data, SIZE_T size)
    {
        // Make the page writable
        ULONG oldProtect = 0;
        if(NT_SUCCESS(NtProtectVirtualMemory(hProcess, &ptr, &size, PAGE_READWRITE, &oldProtect)))
        {
            // Write the memory
            SIZE_T written = 0;
            if(NT_SUCCESS(NtWriteVirtualMemory(hProcess, ptr, data, size, &written)))
            {
                // Restore the old protection
                return NT_SUCCESS(NtProtectVirtualMemory(hProcess, &ptr, &size, oldProtect, &oldProtect));
            }
        }
        return false;
    };
    for(size_t i = 0; i < writeback.size(); i++)
    {
        if(writeback[i])
        {
            auto offset = pageSize * i;
            if(!memWrite((char*)imageBase + offset, imageCopy + offset, pageSize))
                success = false;
        }
    }

    // Create a copy of the header at the original image base
    // The kernel uses it in ZwCreateThread to get the stack size for example
    if(success)
    {
        success = false;
        auto oldPage = (LPVOID)oldImageBase;
        if(VirtualAllocEx(hProcess, oldPage, pageSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE))
        {
            if(memWrite(oldPage, imageCopy, pageSize))
            {
                DWORD oldProtect = 0;
                if(VirtualProtectEx(hProcess, oldPage, pageSize, PAGE_READONLY, &oldProtect))
                    success = true;
            }
        }
    }

    // Free the copy of the image
    VirtualFree(imageCopy, imageSize, MEM_DECOMMIT);

    return success;
}

static bool HollowProcessWithoutASLR(const wchar_t* szFileName, PROCESS_INFORMATION & pi)
{
    bool success = false;
    auto hFile = CreateFileW(szFileName, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // Retrieve image base and entry point
        DebugModuleImageBase = GetPE32DataW(szFileName, 0, UE_IMAGEBASE);
        DebugModuleEntryPoint = GetPE32DataW(szFileName, 0, UE_OEP);

        auto hMapping = CreateFileMappingW(hFile, nullptr, SEC_IMAGE | PAGE_READONLY, 0, 0, nullptr);
        if (hMapping)
        {
            CONTEXT ctx;
            ctx.ContextFlags = CONTEXT_ALL;
            if (GetThreadContext(pi.hThread, &ctx))
            {
                PVOID imageBase;
                // TODO: support wow64 processes
#ifdef _WIN64
                auto& pebRegister = ctx.Rdx;
                auto& entryPointRegister = ctx.Rcx;
#else
                auto& pebRegister = ctx.Ebx;
                auto& entryPointRegister = ctx.Eax;
#endif // _WIN64
                if (ReadProcessMemory(pi.hProcess, (char*)pebRegister + offsetof(PEB, ImageBaseAddress), &imageBase, sizeof(PVOID), nullptr))
                {
                    if (ULONG_PTR(imageBase) == DebugModuleImageBase)
                    {
                        // Already at the right base
                        success = true;
                    }
                    else
                    {
                        auto status = NtUnmapViewOfSection(pi.hProcess, imageBase);
                        if (status == STATUS_SUCCESS)
                        {
                            SIZE_T viewSize = 0;
                            imageBase = PVOID(DebugModuleImageBase);
                            status = NtMapViewOfSection(hMapping, pi.hProcess, &imageBase, 0, 0, nullptr, &viewSize, ViewUnmap, 0, PAGE_READONLY);
                            if (status == STATUS_CONFLICTING_ADDRESSES)
                            {
                                // Remap in a random location (otherwise the process will crash)
                                imageBase = 0;
                                status = NtMapViewOfSection(hMapping, pi.hProcess, &imageBase, 0, 0, nullptr, &viewSize, ViewUnmap, 0, PAGE_READONLY);
                            }
                            if (status == STATUS_SUCCESS || status == STATUS_IMAGE_NOT_AT_BASE)
                            {
                                auto pebOk = WriteProcessMemory(pi.hProcess, (char*)pebRegister + offsetof(PEB, ImageBaseAddress), &imageBase, sizeof(PVOID), nullptr);
                                auto relocatedOk = RelocateImage(pi.hProcess, imageBase, viewSize);
                                if (pebOk && relocatedOk)
                                {
                                    auto expectedBase = DebugModuleImageBase == ULONG_PTR(imageBase);
                                    DebugModuleImageBase = ULONG_PTR(imageBase);
                                    entryPointRegister = DebugModuleImageBase + DebugModuleEntryPoint;
                                    if (SetThreadContext(pi.hThread, &ctx))
                                    {
                                        success = expectedBase;
#ifndef _WIN64
                                        // For Wow64 processes, also adjust the 64-bit PEB
                                        if (IsThisProcessWow64() && !WriteProcessMemory(pi.hProcess, (char*)pebRegister - 0x1000 + 0x10, &imageBase, sizeof(PVOID), nullptr))
                                            success = false;
#endif // _WIN64
                                    }
                                }
                            }
                        }
                    }
                }
            }

            CloseHandle(hMapping);
        }

        CloseHandle(hFile);
    }

    if(!success)
    {
        DebugModuleImageBase = 0;
    }

    return success;
}

__declspec(dllexport) void* TITCALL InitDebugW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder)
{
    int creationFlags = CREATE_NEW_CONSOLE | DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS;

    if(DebugDebuggingDLL)
    {
        creationFlags |= CREATE_NO_WINDOW;
        creationFlags |= CREATE_SUSPENDED;
    }
    else if(engineRemoveConsoleForDebugee)
    {
        creationFlags |= CREATE_NO_WINDOW;
    }
    else if(engineDisableAslr)
    {
        creationFlags = CREATE_NEW_CONSOLE | CREATE_SUSPENDED;
    }

    wchar_t* szFileNameCreateProcess;
    wchar_t* szCommandLineCreateProcess;
    std::wstring createWithCmdLine;
    if(szCommandLine == NULL || !lstrlenW(szCommandLine))
    {
        szCommandLineCreateProcess = 0;
        szFileNameCreateProcess = szFileName;
    }
    else
    {
        createWithCmdLine.push_back('\"');
        createWithCmdLine.append(szFileName);
        createWithCmdLine.push_back('\"');
        createWithCmdLine.push_back(' ');
        createWithCmdLine.append(szCommandLine);
        szCommandLineCreateProcess = (wchar_t*)createWithCmdLine.c_str();
        szFileNameCreateProcess = 0;
    }
    int retries = 0;
retry_no_aslr:
    // Temporarily disable the debug privilege so the child doesn't inherit it (this evades debugger detection)
    if(engineEnableDebugPrivilege)
        EngineSetDebugPrivilege(GetCurrentProcess(), false);
    auto createProcessResult = CreateProcessW(szFileNameCreateProcess, szCommandLineCreateProcess, NULL, NULL, false, creationFlags, NULL, szCurrentFolder, &dbgStartupInfo, &dbgProcessInformation);
    if(engineEnableDebugPrivilege)
        EngineSetDebugPrivilege(GetCurrentProcess(), true);
    if(createProcessResult)
    {
        if(engineDisableAslr)
        {
            if (!HollowProcessWithoutASLR(szFileName, dbgProcessInformation))
            {
                TerminateThread(dbgProcessInformation.hThread, STATUS_CONFLICTING_ADDRESSES);
                TerminateProcess(dbgProcessInformation.hProcess, STATUS_CONFLICTING_ADDRESSES);
                if (retries++ < 10)
                    goto retry_no_aslr;
                memset(&dbgProcessInformation, 0, sizeof(PROCESS_INFORMATION));
                return nullptr;
            }
            else
            {
                DebugActiveProcess_(dbgProcessInformation.dwProcessId);
                DebugSetProcessKillOnExit(TRUE);
                ResumeThread(dbgProcessInformation.hThread);
            }
        }
        DebugAttachedToProcess = false;
        DebugAttachedProcessCallBack = NULL;
        return &dbgProcessInformation;
    }
    else
    {
        DWORD lastError = GetLastError();
        memset(&dbgProcessInformation, 0, sizeof(PROCESS_INFORMATION));
        SetLastError(lastError);
        return 0;
    }
}

__declspec(dllexport) void* TITCALL InitNativeDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder)
{
    wchar_t* PtrUniFileName = NULL;
    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t* PtrUniCommandLine = NULL;
    wchar_t uniCommandLine[MAX_PATH] = {};
    wchar_t* PtrUniCurrentFolder = NULL;
    wchar_t uniCurrentFolder[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCommandLine, lstrlenA(szCommandLine) + 1, uniCommandLine, sizeof(uniCommandLine) / (sizeof(uniCommandLine[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCurrentFolder, lstrlenA(szCurrentFolder) + 1, uniCurrentFolder, sizeof(uniCurrentFolder) / (sizeof(uniCurrentFolder[0])));
        if(szFileName != NULL)
        {
            PtrUniFileName = &uniFileName[0];
        }
        if(szCommandLine != NULL)
        {
            PtrUniCommandLine = &uniCommandLine[0];
        }
        if(szCurrentFolder != NULL)
        {
            PtrUniCurrentFolder = &uniCurrentFolder[0];
        }
        return(InitNativeDebugW(PtrUniFileName, PtrUniCommandLine, PtrUniCurrentFolder));
    }
    else
    {
        return NULL;
    }
}

__declspec(dllexport) void* TITCALL InitNativeDebugW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder)
{
    typedef
    NTSTATUS
    (NTAPI *
     t_RtlCreateProcessParametersEx)(
         _Out_ PRTL_USER_PROCESS_PARAMETERS * pProcessParameters,
         _In_ PUNICODE_STRING ImagePathName,
         _In_opt_ PUNICODE_STRING DllPath,
         _In_opt_ PUNICODE_STRING CurrentDirectory,
         _In_opt_ PUNICODE_STRING CommandLine,
         _In_opt_ PVOID Environment,
         _In_opt_ PUNICODE_STRING WindowTitle,
         _In_opt_ PUNICODE_STRING DesktopInfo,
         _In_opt_ PUNICODE_STRING ShellInfo,
         _In_opt_ PUNICODE_STRING RuntimeData,
         _In_ ULONG Flags
     );

    typedef
    NTSTATUS
    (NTAPI *
     t_NtCreateUserProcess)(
         _Out_ PHANDLE ProcessHandle,
         _Out_ PHANDLE ThreadHandle,
         _In_ ACCESS_MASK ProcessDesiredAccess,
         _In_ ACCESS_MASK ThreadDesiredAccess,
         _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
         _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
         _In_ ULONG ProcessFlags,
         _In_ ULONG ThreadFlags,
         _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
         _Inout_ PPS_CREATE_INFO CreateInfo,
         _In_ PPS_ATTRIBUTE_LIST AttributeList
     );

    HMODULE Ntdll = GetModuleHandleW(L"ntdll.dll");
    t_RtlCreateProcessParametersEx fnRtlCreateProcessParametersEx =
        (t_RtlCreateProcessParametersEx)GetProcAddress(Ntdll, "RtlCreateProcessParametersEx");
    t_NtCreateUserProcess fnNtCreateUserProcess =
        (t_NtCreateUserProcess)GetProcAddress(Ntdll, "NtCreateUserProcess");

    // NtCreateUserProcess requires Vista or higher
    if(fnRtlCreateProcessParametersEx == NULL || fnNtCreateUserProcess == NULL)
    {
        RtlSetLastWin32Error(ERROR_NOT_SUPPORTED);
        return NULL;
    }

    RtlZeroMemory(&dbgProcessInformation, sizeof(PROCESS_INFORMATION));
    HANDLE ProcessHandle = NULL, ThreadHandle = NULL;
    UNICODE_STRING CommandLine = { 0 };
    PUNICODE_STRING PtrCurrentDirectory = NULL;

    // Convert the application path to its NT equivalent
    UNICODE_STRING ImagePath, NtImagePath;
    RtlInitUnicodeString(&ImagePath, szFileName);
    if(!RtlDosPathNameToNtPathName_U(ImagePath.Buffer,
                                     &NtImagePath,
                                     NULL,
                                     NULL))
    {
        RtlSetLastWin32Error(ERROR_PATH_NOT_FOUND);
        return NULL;
    }

    // Convert command line and directory to UNICODE_STRING if present
    SIZE_T ArgumentsLength = szCommandLine != NULL ? lstrlenW(szCommandLine) : 0;
    SIZE_T BufferSize = ImagePath.Length + ((ArgumentsLength + 4) * sizeof(wchar_t));
    CommandLine.Buffer = (PWSTR)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, BufferSize);
    CommandLine.MaximumLength = (USHORT)BufferSize;
    RtlAppendUnicodeToString(&CommandLine, L"\"");
    RtlAppendUnicodeStringToString(&CommandLine, &ImagePath);
    RtlAppendUnicodeToString(&CommandLine, L"\"");
    if(ArgumentsLength > 0)
    {
        RtlAppendUnicodeToString(&CommandLine, L" ");
        RtlAppendUnicodeToString(&CommandLine, szCommandLine);
    }

    if(szCurrentFolder != NULL && lstrlenW(szCurrentFolder) > 0)
    {
        UNICODE_STRING WorkingDirectory;
        RtlInitUnicodeString(&WorkingDirectory, szCurrentFolder);
        PtrCurrentDirectory = &WorkingDirectory;
    }

    // Create the process parameter block
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters = NULL;
    PRTL_USER_PROCESS_PARAMETERS OwnParameters = NtCurrentPeb()->ProcessParameters;
    NTSTATUS Status = fnRtlCreateProcessParametersEx(&ProcessParameters,
                      &ImagePath,
                      NULL,                        // Create a new DLL path
                      PtrCurrentDirectory,
                      &CommandLine,
                      NULL,                        // If null, a new environment will be created
                      &ImagePath,                  // Window title is the exe path - needed for console apps
                      &OwnParameters->DesktopInfo, // Copy our desktop name
                      NULL,
                      NULL,
                      RTL_USER_PROCESS_PARAMETERS_NORMALIZED);
    if(!NT_SUCCESS(Status))
        goto finished;

    // Clear the current directory because we're not inheriting handles
    ProcessParameters->CurrentDirectory.Handle = NULL;

    // Default to CREATE_NEW_CONSOLE behaviour
    ProcessParameters->ConsoleHandle = HANDLE_CREATE_NEW_CONSOLE;
    ProcessParameters->ShowWindowFlags = STARTF_USESHOWWINDOW | SW_SHOWDEFAULT;

    // Create a debug port object
    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);
    HANDLE DebugPort = NULL;
    Status = NtCreateDebugObject(&DebugPort,
                                 DEBUG_ALL_ACCESS,
                                 &ObjectAttributes,
                                 DEBUG_KILL_ON_CLOSE);
    if(!NT_SUCCESS(Status))
    {
        RtlDestroyProcessParameters(ProcessParameters);
        goto finished;
    }

    // Store the debug port handle in our TEB. The kernel uses this field
    NtCurrentTeb()->DbgSsReserved[1] = DebugPort;

    // Initialize the PS_CREATE_INFO structure
    PS_CREATE_INFO CreateInfo;
    RtlZeroMemory(&CreateInfo, sizeof(CreateInfo));
    CreateInfo.Size = sizeof(CreateInfo);
    CreateInfo.State = PsCreateInitialState;
    CreateInfo.InitState.u1.s1.WriteOutputOnExit = TRUE;
    CreateInfo.InitState.u1.s1.DetectManifest = TRUE;
    CreateInfo.InitState.u1.s1.ProhibitedImageCharacteristics = 0; // Normally: IMAGE_FILE_DLL (disallow executing DLLs)
    CreateInfo.InitState.AdditionalFileAccess = FILE_READ_ATTRIBUTES | FILE_READ_DATA;

    // Initialize the PS_ATTRIBUTE_LIST that contains the process creation attributes
    const SIZE_T NumAttributes = 3;
    const SIZE_T AttributesSize = sizeof(SIZE_T) + NumAttributes * sizeof(PS_ATTRIBUTE);
    PPS_ATTRIBUTE_LIST AttributeList = reinterpret_cast<PPS_ATTRIBUTE_LIST>(
                                           RtlAllocateHeap(RtlProcessHeap(),
                                                   HEAP_ZERO_MEMORY, // Not optional
                                                   AttributesSize));
    AttributeList->TotalLength = AttributesSize;

    // In: NT style absolute image path. This is the only required attribute
    ULONG N = 0;
    AttributeList->Attributes[N].Attribute = PS_ATTRIBUTE_IMAGE_NAME;
    AttributeList->Attributes[N].Size = NtImagePath.Length;
    AttributeList->Attributes[N].Value = reinterpret_cast<ULONG_PTR>(NtImagePath.Buffer);

    // In: debug port
    N++;
    AttributeList->Attributes[N].Attribute = PS_ATTRIBUTE_DEBUG_PORT;
    AttributeList->Attributes[N].Size = sizeof(HANDLE);
    AttributeList->Attributes[N].Value = reinterpret_cast<ULONG_PTR>(DebugPort);

    // Out: client ID
    N++;
    CLIENT_ID Cid;
    PCLIENT_ID ClientId = &Cid;
    AttributeList->Attributes[N].Attribute = PS_ATTRIBUTE_CLIENT_ID;
    AttributeList->Attributes[N].Size = sizeof(CLIENT_ID);
    AttributeList->Attributes[N].Value = reinterpret_cast<ULONG_PTR>(ClientId);

    // Set process and thread flags
    ULONG NtProcessFlags = PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT; // Same as DEBUG_ONLY_THIS_PROCESS. DEBUG_PROCESS is implied by the debug port
    ULONG NtThreadFlags = THREAD_CREATE_FLAGS_CREATE_SUSPENDED; // Always set this, because we need to do some bookkeeping before resuming

    // Create the process
    Status = fnNtCreateUserProcess(&ProcessHandle,
                                   &ThreadHandle,
                                   MAXIMUM_ALLOWED,
                                   MAXIMUM_ALLOWED,
                                   NULL,
                                   NULL,
                                   NtProcessFlags,
                                   NtThreadFlags,
                                   ProcessParameters,
                                   &CreateInfo,
                                   AttributeList);

    RtlFreeHeap(RtlProcessHeap(), 0, AttributeList);
    RtlDestroyProcessParameters(ProcessParameters);

    if(!NT_SUCCESS(Status))
        goto finished;

    // Success. Convert what we got back to a PROCESS_INFORMATION structure
    dbgProcessInformation.hProcess = ProcessHandle;
    dbgProcessInformation.hThread = ThreadHandle;
    dbgProcessInformation.dwProcessId = HandleToULong(ClientId->UniqueProcess);
    dbgProcessInformation.dwThreadId = HandleToULong(ClientId->UniqueThread);

finished:
    RtlFreeHeap(RtlProcessHeap(), 0, NtImagePath.Buffer);

    if(CommandLine.Buffer != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, CommandLine.Buffer);

    if(ProcessHandle != NULL)
    {
        // Close the file and section handles we got back from the kernel
        NtClose(CreateInfo.SuccessState.FileHandle);
        NtClose(CreateInfo.SuccessState.SectionHandle);

        // If we failed, terminate the process
        if(!NT_SUCCESS(Status))
        {
            BOOLEAN CloseDebugPort = DebugPort != NULL &&
                                     ((NtThreadFlags & PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT) != 0);

            if(CloseDebugPort)
            {
                NtRemoveProcessDebug(ProcessHandle, DebugPort);
                NtClose(DebugPort);
                NtCurrentTeb()->DbgSsReserved[1] = NULL;
            }

            NtTerminateProcess(ProcessHandle, Status);
        }
        else
        {
            // Otherwise resume the process now
            NtResumeThread(ThreadHandle, NULL);
        }
    }

    DebugAttachedToProcess = false;
    DebugAttachedProcessCallBack = NULL;

    return &dbgProcessInformation;
}

__declspec(dllexport) void* TITCALL InitDebugEx(char* szFileName, char* szCommandLine, char* szCurrentFolder, LPVOID EntryCallBack)
{
    DebugExeFileEntryPointCallBack = EntryCallBack;
    return(InitDebug(szFileName, szCommandLine, szCurrentFolder));
}

__declspec(dllexport) void* TITCALL InitDebugExW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder, LPVOID EntryCallBack)
{
    DebugExeFileEntryPointCallBack = EntryCallBack;
    return(InitDebugW(szFileName, szCommandLine, szCurrentFolder));
}

__declspec(dllexport) void* TITCALL InitDLLDebug(char* szFileName, bool ReserveModuleBase, char* szCommandLine, char* szCurrentFolder, LPVOID EntryCallBack)
{

    wchar_t* PtrUniFileName = NULL;
    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t* PtrUniCommandLine = NULL;
    wchar_t uniCommandLine[MAX_PATH] = {};
    wchar_t* PtrUniCurrentFolder = NULL;
    wchar_t uniCurrentFolder[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCommandLine, lstrlenA(szCommandLine) + 1, uniCommandLine, sizeof(uniCommandLine) / (sizeof(uniCommandLine[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCurrentFolder, lstrlenA(szCurrentFolder) + 1, uniCurrentFolder, sizeof(uniCurrentFolder) / (sizeof(uniCurrentFolder[0])));
        if(szFileName != NULL)
        {
            PtrUniFileName = &uniFileName[0];
        }
        if(szCommandLine != NULL)
        {
            PtrUniCommandLine = &uniCommandLine[0];
        }
        if(szCurrentFolder != NULL)
        {
            PtrUniCurrentFolder = &uniCurrentFolder[0];
        }
        return(InitDLLDebugW(PtrUniFileName, ReserveModuleBase, PtrUniCommandLine, PtrUniCurrentFolder, EntryCallBack));
    }
    else
    {
        return NULL;
    }
}

static bool TryExtractDllLoader(bool failedBefore = false)
{
    wchar_t* szPath = wcsrchr(szDebuggerName, L'\\');
    if(szPath)
        szPath[1] = '\0';
    wchar_t DLLLoaderName[64] = L"";
#ifdef _WIN64
    wsprintfW(DLLLoaderName, L"DLLLoader64_%.4X.exe", GetTickCount() & 0xFFFF);
#else
    wsprintfW(DLLLoaderName, L"DLLLoader32_%.4X.exe", GetTickCount() & 0xFFFF);
#endif //_WIN64
    lstrcatW(szDebuggerName, DLLLoaderName);
#ifdef _WIN64
    if(EngineExtractResource("LOADERX64", szDebuggerName))
#else
    if(EngineExtractResource("LOADERX86", szDebuggerName))
#endif //_WIN64
        return true;
    return !failedBefore &&
           GetModuleFileNameW(engineHandle, szDebuggerName, _countof(szDebuggerName)) &&
           TryExtractDllLoader(true);
}

__declspec(dllexport) void* TITCALL InitDLLDebugW(wchar_t* szFileName, bool ReserveModuleBase, wchar_t* szCommandLine, wchar_t* szCurrentFolder, LPVOID EntryCallBack)
{
    memset(szDebuggerName, 0, sizeof(szDebuggerName));
    if(lstrlenW(szFileName) < sizeof(szDebuggerName))
    {
        memset(szBackupDebuggedFileName, 0, sizeof(szBackupDebuggedFileName));
        lstrcpyW(szBackupDebuggedFileName, szFileName);
        szFileName = &szBackupDebuggedFileName[0];
    }
    lstrcpyW(szDebuggerName, szFileName);
    if(TryExtractDllLoader())
    {
        DebugDebuggingDLL = true;
        int i = lstrlenW(szFileName);
        while(szFileName[i] != '\\' && i)
            i--;
        DebugDebuggingDLLBase = NULL;
        DebugDebuggingMainModuleBase = NULL;
        DebugDebuggingDLLFullFileName = szFileName;
        DebugDebuggingDLLFileName = &szFileName[i + 1];
        DebugModuleImageBase = (ULONG_PTR)GetPE32DataW(szFileName, NULL, UE_IMAGEBASE);
        DebugModuleEntryPoint = (ULONG_PTR)GetPE32DataW(szFileName, NULL, UE_OEP);
        DebugModuleEntryPointCallBack = EntryCallBack;
        DebugReserveModuleBase = 0;
        if(ReserveModuleBase)
            DebugReserveModuleBase = DebugModuleImageBase;
        PPROCESS_INFORMATION ReturnValue = (PPROCESS_INFORMATION)InitDebugW(szDebuggerName, szCommandLine, szCurrentFolder);
        wchar_t szName[256] = L"";
        swprintf(szName, 256, L"Local\\szLibraryName%X", (unsigned int)ReturnValue->dwProcessId);
        DebugDLLFileMapping = CreateFileMappingW(INVALID_HANDLE_VALUE, 0, PAGE_READWRITE, 0, 512 * sizeof(wchar_t), szName);
        if(DebugDLLFileMapping)
        {
            wchar_t* szLibraryPathMapping = (wchar_t*)MapViewOfFile(DebugDLLFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 512 * sizeof(wchar_t));
            if(szLibraryPathMapping)
            {
                wcscpy(szLibraryPathMapping, DebugDebuggingDLLFullFileName);
                UnmapViewOfFile(szLibraryPathMapping);
            }
        }
        ResumeThread(ReturnValue->hThread);
        return ReturnValue;
    }
    return 0;
}

__declspec(dllexport) bool TITCALL StopDebug()
{
    bool result = false;
    HANDLE hProcess = TitanOpenProcess(PROCESS_TERMINATE, FALSE, dbgProcessInformation.dwProcessId);
    if(hProcess)
    {
        TerminateProcess(hProcess, 0);
        CloseHandle(hProcess);
        result = true;
    }

    HANDLE hThread = TitanOpenThread(THREAD_TERMINATE, FALSE, dbgProcessInformation.dwThreadId);
    if(hThread)
    {
        TerminateThread(hThread, 0);
        CloseHandle(hThread);
        Sleep(10); //allow thread switching
        result = true;
    }
    return result;
}

__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack)
{
    LPVOID funcDebugSetProcessKillOnExit = NULL;

    if(ProcessId != NULL && dbgProcessInformation.hProcess == NULL)
    {
        if(DebugActiveProcess_(ProcessId))
        {
            DebugSetProcessKillOnExit(KillOnExit);
            DebugDebuggingDLL = false;
            DebugAttachedToProcess = true;
            DebugAttachedProcessCallBack = (ULONG_PTR)CallBack;
            engineAttachedProcessDebugInfo = DebugInfo;
            dbgProcessInformation.dwProcessId = ProcessId;
            DebugLoop();
            DebugAttachedToProcess = false;
            DebugAttachedProcessCallBack = NULL;
            return true;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId)
{
    RemoveAllBreakPoints(UE_OPTION_REMOVEALL);
    engineProcessIsNowDetached = true; // Request detach
    return true;
}

__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId)
{
    ThreaderPauseProcess();
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
    {
        HANDLE hActiveThread = EngineOpenThread(THREAD_GETSETSUSPEND, false, hListThread.at(i).dwThreadId);
        CONTEXT myDBGContext;
        myDBGContext.ContextFlags = ContextControlFlags;
        GetThreadContext(hActiveThread, &myDBGContext);
        myDBGContext.EFlags &= ~UE_TRAP_FLAG;
        myDBGContext.EFlags &= ~UE_RESUME_FLAG;
        SetThreadContext(hActiveThread, &myDBGContext);
        EngineCloseHandle(hActiveThread);
    }
    ThreaderResumeProcess();
    return DetachDebugger(ProcessId);
}

__declspec(dllexport) void TITCALL AutoDebugEx(char* szFileName, bool ReserveModuleBase, char* szCommandLine, char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack)
{

    wchar_t* PtrUniFileName = NULL;
    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t* PtrUniCommandLine = NULL;
    wchar_t uniCommandLine[MAX_PATH] = {};
    wchar_t* PtrUniCurrentFolder = NULL;
    wchar_t uniCurrentFolder[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCommandLine, lstrlenA(szCommandLine) + 1, uniCommandLine, sizeof(uniCommandLine) / (sizeof(uniCommandLine[0])));
        MultiByteToWideChar(CP_ACP, NULL, szCurrentFolder, lstrlenA(szCurrentFolder) + 1, uniCurrentFolder, sizeof(uniCurrentFolder) / (sizeof(uniCurrentFolder[0])));
        if(szFileName != NULL)
        {
            PtrUniFileName = &uniFileName[0];
        }
        if(szCommandLine != NULL)
        {
            PtrUniCommandLine = &uniCommandLine[0];
        }
        if(szCurrentFolder != NULL)
        {
            PtrUniCurrentFolder = &uniCurrentFolder[0];
        }
        return(AutoDebugExW(PtrUniFileName, ReserveModuleBase, PtrUniCommandLine, PtrUniCurrentFolder, TimeOut, EntryCallBack));
    }
}

__declspec(dllexport) void TITCALL AutoDebugExW(wchar_t* szFileName, bool ReserveModuleBase, wchar_t* szCommandLine, wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack)
{
    DebugReserveModuleBase = 0;
    DWORD ThreadId;
    DWORD ExitCode = 0;
    HANDLE hSecondThread;
    bool FileIsDll = false;
#if !defined(_WIN64)
    PE32Struct PEStructure;
#else
    PE64Struct PEStructure;
#endif

    if(TimeOut == NULL)
    {
        TimeOut = INFINITE;
    }

    if(szFileName != NULL)
    {
        RtlZeroMemory(&expertDebug, sizeof ExpertDebug);
        expertDebug.ExpertModeActive = true;
        expertDebug.szFileName = szFileName;
        expertDebug.szCommandLine = szCommandLine;
        expertDebug.szCurrentFolder = szCurrentFolder;
        expertDebug.ReserveModuleBase = ReserveModuleBase;
        expertDebug.EntryCallBack = EntryCallBack;
        GetPE32DataExW(szFileName, (LPVOID)&PEStructure);
        if(PEStructure.Characteristics & 0x2000)
        {
            FileIsDll = true;
        }
        SetDebugLoopTimeOut(TimeOut);
        hSecondThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)DebugLoopInSecondThread, (LPVOID)FileIsDll, NULL, &ThreadId);
        WaitForSingleObject(hSecondThread, INFINITE);
        if(GetExitCodeThread(hSecondThread, &ExitCode))
        {
            if(ExitCode == -1)
            {
                ForceClose();
            }
        }
        RtlZeroMemory(&expertDebug, sizeof ExpertDebug);
        SetDebugLoopTimeOut(INFINITE);
    }
}



================================================
File: TitanEngine/TitanEngine.Disassembler.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "distorm.h"

static char engineDisassembledInstruction[128];

#if !defined(_WIN64)
_DecodeType DecodingType = Decode32Bits;
#else
_DecodeType DecodingType = Decode64Bits;
#endif


SIZE_T IsBadReadPtrRemote(HANDLE hProcess, const VOID* lp, SIZE_T length)
{
    MEMORY_BASIC_INFORMATION MemInfo = {0};
    ULONG_PTR section = 0;

    if(VirtualQueryEx(hProcess, lp, &MemInfo, sizeof(MEMORY_BASIC_INFORMATION)))
    {
        if(MemInfo.State == MEM_COMMIT)
        {
            SIZE_T res = (SIZE_T)MemInfo.BaseAddress + (SIZE_T)MemInfo.RegionSize - (SIZE_T)lp;
            if(res >= length)
            {
                return length; //good
            }
            else
            {
                section = ((ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)MemInfo.RegionSize);

                do
                {
                    if(VirtualQueryEx(hProcess, (LPVOID)section, &MemInfo, sizeof(MEMORY_BASIC_INFORMATION)))
                    {
                        if(MemInfo.State == MEM_COMMIT)
                        {
                            res += MemInfo.RegionSize;
                        }
                        else
                        {
                            return res; //this is bad
                        }
                    }
                    else
                    {
                        return res; //this is bad
                    }

                    section += (ULONG_PTR)MemInfo.RegionSize;

                }
                while(res < length);

                return length; //good
            }
        }

    }

    return 0;
}

__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress)
{
    _DecodedInst engineDecodedInstructions[1];
    unsigned int DecodedInstructionsCount = 0;

    int MaxDisassmSize = MAXIMUM_INSTRUCTION_SIZE; // (int)IsBadReadPtrRemote(GetCurrentProcess(), DisassmAddress, MAXIMUM_INSTRUCTION_SIZE);
    if(MaxDisassmSize)
    {
        if(distorm_decode((ULONG_PTR)DisassmStart, (const unsigned char*)DisassmAddress, MaxDisassmSize, DecodingType, engineDecodedInstructions, _countof(engineDecodedInstructions), &DecodedInstructionsCount) != DECRES_INPUTERR)
        {
            RtlZeroMemory(engineDisassembledInstruction, sizeof(engineDisassembledInstruction));

            lstrcpyA(engineDisassembledInstruction, (LPCSTR)engineDecodedInstructions[0].mnemonic.p);
            if(engineDecodedInstructions[0].size != NULL)
            {
                lstrcatA(engineDisassembledInstruction, " ");
            }
            lstrcatA(engineDisassembledInstruction, (LPCSTR)engineDecodedInstructions[0].operands.p);
            return((char*)engineDisassembledInstruction);
        }
    }

    return 0;
}

__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress)
{
    return StaticDisassembleEx((ULONG_PTR)DisassmAddress, DisassmAddress);
}

__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType)
{
    _DecodedInst engineDecodedInstructions[1];
    unsigned int DecodedInstructionsCount = 0;
    BYTE readBuffer[MAXIMUM_INSTRUCTION_SIZE] = {0};

    if(hProcess != NULL)
    {
        int MaxDisassmSize = MAXIMUM_INSTRUCTION_SIZE; // (int)IsBadReadPtrRemote(hProcess, DisassmAddress, sizeof(readBuffer));

        if(MaxDisassmSize)
        {
            BOOL rpm = MemoryReadSafe(hProcess, DisassmAddress, readBuffer, MaxDisassmSize, 0);
            if(rpm)
            {
                if(distorm_decode((ULONG_PTR)DisassmAddress, readBuffer, MaxDisassmSize, DecodingType, engineDecodedInstructions, _countof(engineDecodedInstructions), &DecodedInstructionsCount) != DECRES_INPUTERR)
                {
                    RtlZeroMemory(engineDisassembledInstruction, sizeof(engineDisassembledInstruction));

                    lstrcpyA(engineDisassembledInstruction, (LPCSTR)engineDecodedInstructions[0].mnemonic.p);
                    if(!ReturnInstructionType)
                    {
                        if(engineDecodedInstructions[0].size != NULL)
                        {
                            lstrcatA(engineDisassembledInstruction, " ");
                        }
                        lstrcatA(engineDisassembledInstruction, (LPCSTR)engineDecodedInstructions[0].operands.p);
                    }
                    return((char*)engineDisassembledInstruction);
                }

            }
        }
    }

    return 0;
}

__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress)
{
    return(DisassembleEx(dbgProcessInformation.hProcess, DisassmAddress, false));
}

__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress)
{
    return LengthDisassembleEx(GetCurrentProcess(), DisassmAddress);
}

__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress)
{
    unsigned int DecodedInstructionsCount = 0;
    _CodeInfo decomposerCi = {0};
    _DInst decomposerResult[1] = {0};
    BYTE readBuffer[MAXIMUM_INSTRUCTION_SIZE] = {0}; //The maximum length of an Intel 64 and IA-32 instruction remains 15 bytes, but we are generous

    if(hProcess != NULL)
    {
        int MaxDisassmSize = (int)IsBadReadPtrRemote(hProcess, DisassmAddress, sizeof(readBuffer));

        if(MaxDisassmSize && MemoryReadSafe(hProcess, (LPVOID)DisassmAddress, readBuffer, MaxDisassmSize, 0))
        {
            decomposerCi.code = readBuffer;
            decomposerCi.codeLen = MaxDisassmSize;
            decomposerCi.dt = DecodingType;
            decomposerCi.codeOffset = (LONG_PTR)DisassmAddress;

            if(distorm_decompose(&decomposerCi, decomposerResult, _countof(decomposerResult), &DecodedInstructionsCount) != DECRES_INPUTERR)
            {
                if(decomposerResult[0].flags != FLAG_NOT_DECODABLE)
                {
                    return decomposerResult[0].size;
                }
            }
        }
    }

    return -1;
}

__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress)
{
    return LengthDisassembleEx(dbgProcessInformation.hProcess, DisassmAddress);
}



================================================
File: TitanEngine/TitanEngine.Dumper.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Handle.h"

//TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, char* szDumpFileName, ULONG_PTR EntryPoint)
{
    wchar_t uniDumpFileName[MAX_PATH] = {0};
    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, -1, uniDumpFileName, _countof(uniDumpFileName));
        return DumpProcessW(hProcess, ImageBase, uniDumpFileName, EntryPoint);
    }
    return false;
}

__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, wchar_t* szDumpFileName, ULONG_PTR EntryPoint)
{
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_DOS_HEADER DOSFixHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_NT_HEADERS32 PEFixHeader32;
    PIMAGE_NT_HEADERS64 PEFixHeader64;
    PIMAGE_SECTION_HEADER PEFixSection;
    ULONG_PTR ueNumberOfBytesRead = 0;
    DWORD uedNumberOfBytesRead = 0;
    DWORD SizeOfImageDump = 0;
    int NumberOfSections = 0;
    BOOL FileIs64 = false;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD RealignedVirtualSize = 0;
    ULONG_PTR ProcReadBase = 0;
    LPVOID ReadBase = ImageBase;
    SIZE_T CalculatedHeaderSize = NULL;
    SIZE_T AlignedHeaderSize = NULL;
    DynBuf ueReadBuf, ueCopyBuf;
    LPVOID ueReadBuffer = ueReadBuf.Allocate(0x2000);
    LPVOID ueCopyBuffer = ueCopyBuf.Allocate(0x2000);

    if(ReadProcessMemory(hProcess, ImageBase, ueReadBuffer, 0x1000, &ueNumberOfBytesRead))
    {
        //ReadProcessMemory
        DOSHeader = (PIMAGE_DOS_HEADER)ueReadBuffer;
        PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);

        if((DOSHeader->e_lfanew > 0x500) || (DOSHeader->e_magic != IMAGE_DOS_SIGNATURE) || (PEHeader32->Signature != IMAGE_NT_SIGNATURE))
        {
            return false;
        }

        CalculatedHeaderSize = DOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS64) + (sizeof(IMAGE_SECTION_HEADER) * PEHeader32->FileHeader.NumberOfSections);

        if(CalculatedHeaderSize > 0x1000)
        {
            if(CalculatedHeaderSize % 0x1000 != NULL)
            {
                AlignedHeaderSize = ((CalculatedHeaderSize / 0x1000) + 1) * 0x1000;
            }
            else
            {
                AlignedHeaderSize = CalculatedHeaderSize;
            }
            ueReadBuffer = ueReadBuf.Allocate(AlignedHeaderSize);
            ueCopyBuffer = ueCopyBuf.Allocate(AlignedHeaderSize);
            if(!ReadProcessMemory(hProcess, ImageBase, ueReadBuffer, AlignedHeaderSize, &ueNumberOfBytesRead))
            {
                return false;
            }
            else
            {
                DOSHeader = (PIMAGE_DOS_HEADER)ueReadBuffer;
            }
        }
        else
        {
            CalculatedHeaderSize = 0x1000;
            AlignedHeaderSize = 0x1000;
        }
        if(EngineValidateHeader((ULONG_PTR)ueReadBuffer, hProcess, ImageBase, DOSHeader, false))
        {
            //EngineValidateHeader
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
            {
                FileIs64 = true;
            }
            else
            {
                return false;
            }
            if(!FileIs64)
            {
                //PE32 Handler
                NumberOfSections = PEHeader32->FileHeader.NumberOfSections;
                NumberOfSections++;
                if(PEHeader32->OptionalHeader.SizeOfImage % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                {
                    SizeOfImageDump = ((PEHeader32->OptionalHeader.SizeOfImage / PEHeader32->OptionalHeader.SectionAlignment)) * PEHeader32->OptionalHeader.SectionAlignment;
                }
                else
                {
                    SizeOfImageDump = ((PEHeader32->OptionalHeader.SizeOfImage / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment;
                }
                SizeOfImageDump = SizeOfImageDump - (DWORD)AlignedHeaderSize;
                EngineCreatePathForFileW(szDumpFileName);
                hFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if(hFile != INVALID_HANDLE_VALUE)
                {
                    if(ReadProcessMemory(hProcess, ImageBase, ueCopyBuffer, AlignedHeaderSize, &ueNumberOfBytesRead))
                    {
                        if(ueCopyBuffer)
                        {
                            DOSFixHeader = (PIMAGE_DOS_HEADER)ueCopyBuffer;
                            PEFixHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSFixHeader + DOSFixHeader->e_lfanew);
                            PEFixSection = IMAGE_FIRST_SECTION(PEFixHeader32);
                            if(PEFixHeader32->OptionalHeader.FileAlignment > 0x200)
                            {
                                PEFixHeader32->OptionalHeader.FileAlignment = PEHeader32->OptionalHeader.SectionAlignment;
                            }
                            PEFixHeader32->OptionalHeader.AddressOfEntryPoint = (DWORD)(EntryPoint - (ULONG_PTR)ImageBase);
                            PEFixHeader32->OptionalHeader.ImageBase = (DWORD)((ULONG_PTR)ImageBase);
                            for(int i = NumberOfSections; i >= 1; i--)
                            {
                                PEFixSection->PointerToRawData = PEFixSection->VirtualAddress;
                                RealignedVirtualSize = (PEFixSection->Misc.VirtualSize / PEHeader32->OptionalHeader.SectionAlignment) * PEHeader32->OptionalHeader.SectionAlignment;
                                if(RealignedVirtualSize < PEFixSection->Misc.VirtualSize)
                                {
                                    RealignedVirtualSize = RealignedVirtualSize + PEHeader32->OptionalHeader.SectionAlignment;
                                }
                                PEFixSection->SizeOfRawData = RealignedVirtualSize;
                                PEFixSection->Misc.VirtualSize = RealignedVirtualSize;
                                PEFixSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PEFixSection + IMAGE_SIZEOF_SECTION_HEADER);
                            }
                            WriteFile(hFile, ueCopyBuffer, (DWORD)AlignedHeaderSize, &uedNumberOfBytesRead, NULL);
                            ReadBase = (LPVOID)((ULONG_PTR)ReadBase + AlignedHeaderSize - TITANENGINE_PAGESIZE);
                            while(SizeOfImageDump > NULL)
                            {
                                ProcReadBase = (ULONG_PTR)ReadBase + TITANENGINE_PAGESIZE;
                                ReadBase = (LPVOID)ProcReadBase;
                                if(SizeOfImageDump >= TITANENGINE_PAGESIZE)
                                {
                                    RtlZeroMemory(ueCopyBuffer, AlignedHeaderSize);

                                    MemoryReadSafe(hProcess, ReadBase, ueCopyBuffer, TITANENGINE_PAGESIZE, &ueNumberOfBytesRead);

                                    WriteFile(hFile, ueCopyBuffer, TITANENGINE_PAGESIZE, &uedNumberOfBytesRead, NULL);
                                    SizeOfImageDump = SizeOfImageDump - TITANENGINE_PAGESIZE;
                                }
                                else
                                {
                                    RtlZeroMemory(ueCopyBuffer, AlignedHeaderSize);

                                    MemoryReadSafe(hProcess, ReadBase, ueCopyBuffer, SizeOfImageDump, &ueNumberOfBytesRead);

                                    WriteFile(hFile, ueCopyBuffer, SizeOfImageDump, &uedNumberOfBytesRead, NULL);
                                    SizeOfImageDump = NULL;
                                }
                            }
                            EngineCloseHandle(hFile);
                            return true;
                        }
                    }
                }
            }//PE32 Handler
            else
            {
                //PE64 Handler
                NumberOfSections = PEHeader64->FileHeader.NumberOfSections;
                NumberOfSections++;
                if(PEHeader64->OptionalHeader.SizeOfImage % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                {
                    SizeOfImageDump = ((PEHeader64->OptionalHeader.SizeOfImage / PEHeader64->OptionalHeader.SectionAlignment)) * PEHeader64->OptionalHeader.SectionAlignment;
                }
                else
                {
                    SizeOfImageDump = ((PEHeader64->OptionalHeader.SizeOfImage / PEHeader64->OptionalHeader.SectionAlignment) + 1) * PEHeader64->OptionalHeader.SectionAlignment;
                }
                SizeOfImageDump = SizeOfImageDump - (DWORD)AlignedHeaderSize;
                EngineCreatePathForFileW(szDumpFileName);
                hFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if(hFile != INVALID_HANDLE_VALUE)
                {
                    if(ReadProcessMemory(hProcess, ImageBase, ueCopyBuffer, AlignedHeaderSize, &ueNumberOfBytesRead))
                    {
                        if(ueCopyBuffer)
                        {
                            DOSFixHeader = (PIMAGE_DOS_HEADER)ueCopyBuffer;
                            PEFixHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSFixHeader + DOSFixHeader->e_lfanew);
                            PEFixSection = IMAGE_FIRST_SECTION(PEFixHeader64);
                            if(PEFixHeader64->OptionalHeader.FileAlignment > 0x200)
                            {
                                PEFixHeader64->OptionalHeader.FileAlignment = PEHeader64->OptionalHeader.SectionAlignment;
                            }
                            PEFixHeader64->OptionalHeader.AddressOfEntryPoint = (DWORD)(EntryPoint - (ULONG_PTR)ImageBase);
                            PEFixHeader64->OptionalHeader.ImageBase = (DWORD64)((ULONG_PTR)ImageBase);
                            for(int i = NumberOfSections; i >= 1; i--)
                            {
                                PEFixSection->PointerToRawData = PEFixSection->VirtualAddress;
                                RealignedVirtualSize = (PEFixSection->Misc.VirtualSize / PEHeader64->OptionalHeader.SectionAlignment) * PEHeader64->OptionalHeader.SectionAlignment;
                                if(RealignedVirtualSize < PEFixSection->Misc.VirtualSize)
                                {
                                    RealignedVirtualSize = RealignedVirtualSize + PEHeader64->OptionalHeader.SectionAlignment;
                                }
                                PEFixSection->SizeOfRawData = RealignedVirtualSize;
                                PEFixSection->Misc.VirtualSize = RealignedVirtualSize;
                                PEFixSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PEFixSection + IMAGE_SIZEOF_SECTION_HEADER);
                            }
                            WriteFile(hFile, ueCopyBuffer, (DWORD)AlignedHeaderSize, &uedNumberOfBytesRead, NULL);
                            ReadBase = (LPVOID)((ULONG_PTR)ReadBase + (DWORD)AlignedHeaderSize - TITANENGINE_PAGESIZE);
                            while(SizeOfImageDump > NULL)
                            {
                                ProcReadBase = (ULONG_PTR)ReadBase + TITANENGINE_PAGESIZE;
                                ReadBase = (LPVOID)ProcReadBase;
                                if(SizeOfImageDump >= TITANENGINE_PAGESIZE)
                                {
                                    RtlZeroMemory(ueCopyBuffer, AlignedHeaderSize);

                                    MemoryReadSafe(hProcess, ReadBase, ueCopyBuffer, TITANENGINE_PAGESIZE, &ueNumberOfBytesRead);

                                    WriteFile(hFile, ueCopyBuffer, TITANENGINE_PAGESIZE, &uedNumberOfBytesRead, NULL);
                                    SizeOfImageDump = SizeOfImageDump - TITANENGINE_PAGESIZE;
                                }
                                else
                                {
                                    RtlZeroMemory(ueCopyBuffer, AlignedHeaderSize);

                                    MemoryReadSafe(hProcess, ReadBase, ueCopyBuffer, SizeOfImageDump, &ueNumberOfBytesRead);

                                    WriteFile(hFile, ueCopyBuffer, SizeOfImageDump, &uedNumberOfBytesRead, NULL);
                                    SizeOfImageDump = NULL;
                                }
                            }
                            EngineCloseHandle(hFile);
                            return true;
                        }
                    }
                }
            }//PE64 Handler
        }//EngineValidateHeader
    }//ReadProcessMemory

    if(hFile != INVALID_HANDLE_VALUE)
    {
        EngineCloseHandle(hFile);
    }

    return false;
}

__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, char* szDumpFileName, ULONG_PTR EntryPoint)
{
    wchar_t uniDumpFileName[MAX_PATH] = {0};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, -1, uniDumpFileName, _countof(uniDumpFileName));
        return(DumpProcessExW(ProcessId, ImageBase, uniDumpFileName, EntryPoint));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, wchar_t* szDumpFileName, ULONG_PTR EntryPoint)
{
    HANDLE hProcess = 0;
    bool ReturnValue = false;

    hProcess = EngineOpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, ProcessId);
    if(hProcess)
    {
        ReturnValue = DumpProcessW(hProcess, ImageBase, szDumpFileName, EntryPoint);
        EngineCloseHandle(hProcess);
        return ReturnValue;
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, char* szDumpFileName)
{
    wchar_t uniDumpFileName[MAX_PATH] = {0};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, -1, uniDumpFileName, _countof(uniDumpFileName));
        return(DumpMemoryW(hProcess, MemoryStart, MemorySize, uniDumpFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, wchar_t* szDumpFileName)
{
    ULONG_PTR ueNumberOfBytesRead = 0;
    DWORD uedNumberOfBytesRead = 0;
    HANDLE hFile = 0;
    LPVOID ReadBase = MemoryStart;
    ULONG_PTR ProcReadBase = (ULONG_PTR)ReadBase;
    char ueCopyBuffer[0x2000] = {0};

    EngineCreatePathForFileW(szDumpFileName);
    hFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        while(MemorySize > NULL)
        {
            ReadBase = (LPVOID)ProcReadBase;
            if(MemorySize >= 0x1000)
            {
                RtlZeroMemory(ueCopyBuffer, 0x2000);

                MemoryReadSafe(hProcess, ReadBase, ueCopyBuffer, 0x1000, &ueNumberOfBytesRead);

                WriteFile(hFile, ueCopyBuffer, 0x1000, &uedNumberOfBytesRead, NULL);
                MemorySize = MemorySize - 0x1000;
            }
            else
            {
                RtlZeroMemory(ueCopyBuffer, 0x2000);

                MemoryReadSafe(hProcess, ReadBase, ueCopyBuffer, MemorySize, &ueNumberOfBytesRead);

                WriteFile(hFile, ueCopyBuffer, (DWORD)MemorySize, &uedNumberOfBytesRead, NULL);
                MemorySize = NULL;
            }
            ProcReadBase = (ULONG_PTR)ReadBase + 0x1000;
        }
        EngineCloseHandle(hFile);
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, char* szDumpFileName)
{
    wchar_t uniDumpFileName[MAX_PATH] = {0};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, -1, uniDumpFileName, _countof(uniDumpFileName));
        return(DumpMemoryExW(ProcessId, MemoryStart, MemorySize, uniDumpFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, wchar_t* szDumpFileName)
{
    HANDLE hProcess = 0;
    bool ReturnValue = false;

    hProcess = EngineOpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, ProcessId);
    if(hProcess)
    {
        ReturnValue = DumpMemoryW(hProcess, MemoryStart, MemorySize, szDumpFileName);
        EngineCloseHandle(hProcess);
        return ReturnValue;
    }

    return false;
}

__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, char* szDumpFolder, bool DumpAboveImageBaseOnly)
{
    wchar_t uniDumpFolder[MAX_PATH] = {0};

    if(szDumpFolder != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFolder, -1, uniDumpFolder, _countof(uniDumpFolder));
        return(DumpRegionsW(hProcess, uniDumpFolder, DumpAboveImageBaseOnly));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly)
{
    int i;
    DWORD cbNeeded = NULL;
    wchar_t szDumpName[MAX_PATH];
    wchar_t szDumpFileName[MAX_PATH];
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR DumpAddress = NULL;
    HMODULE EnumeratedModules[1024] = {0};
    bool AddressIsModuleBase = false;

    if(hProcess != NULL)
    {
        if(!EnumProcessModules(hProcess, EnumeratedModules, sizeof(EnumeratedModules), &cbNeeded))
        {
            return false;
        }

        while(VirtualQueryEx(hProcess, (LPVOID)DumpAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION) != NULL)
        {
            AddressIsModuleBase = false;
            for(i = 0; i < (int)(cbNeeded / sizeof(HMODULE)); i++)
            {
                if(EnumeratedModules[i] == (HMODULE)MemInfo.AllocationBase)
                {
                    AddressIsModuleBase = true;
                    i = 1024;
                }
                else if(EnumeratedModules[i] == 0)
                {
                    i = 1024;
                }
            }
            if(!(MemInfo.Protect & PAGE_NOACCESS) && AddressIsModuleBase == false)
            {
                if(DumpAboveImageBaseOnly == false || (DumpAboveImageBaseOnly == true && EnumeratedModules[0] < (HMODULE)MemInfo.BaseAddress))
                {
                    RtlZeroMemory(&szDumpName, MAX_PATH);
                    RtlZeroMemory(&szDumpFileName, MAX_PATH);
                    lstrcpyW(szDumpFileName, szDumpFolder);
                    if(szDumpFileName[lstrlenW(szDumpFileName) - 1] != L'\\')
                    {
                        szDumpFileName[lstrlenW(szDumpFileName)] = L'\\';
                    }
                    wsprintfW(szDumpName, L"Dump-%x_%x.dmp", (ULONG_PTR)MemInfo.BaseAddress, (ULONG_PTR)MemInfo.RegionSize);
                    lstrcatW(szDumpFileName, szDumpName);
                    DumpMemoryW(hProcess, (LPVOID)MemInfo.BaseAddress, (ULONG_PTR)MemInfo.RegionSize, szDumpFileName);
                }
            }
            DumpAddress = DumpAddress + (ULONG_PTR)MemInfo.RegionSize;
        }
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, char* szDumpFolder, bool DumpAboveImageBaseOnly)
{
    wchar_t uniDumpFolder[MAX_PATH] = {0};

    if(szDumpFolder != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFolder, -1, uniDumpFolder, _countof(uniDumpFolder));
        return(DumpRegionsExW(ProcessId, uniDumpFolder, DumpAboveImageBaseOnly));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly)
{
    HANDLE hProcess = 0;
    bool ReturnValue = false;

    hProcess = EngineOpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, ProcessId);
    if(hProcess)
    {
        ReturnValue = DumpRegionsW(hProcess, szDumpFolder, DumpAboveImageBaseOnly);
        EngineCloseHandle(hProcess);
        return ReturnValue;
    }

    return false;
}

__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, char* szDumpFileName)
{
    wchar_t uniDumpFileName[MAX_PATH] = {0};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, -1, uniDumpFileName, _countof(uniDumpFileName));
        return(DumpModuleW(hProcess, ModuleBase, uniDumpFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, wchar_t* szDumpFileName)
{

    int i;
    DWORD cbNeeded = NULL;
    MODULEINFO RemoteModuleInfo;
    HMODULE EnumeratedModules[1024] = {0};

    if(EnumProcessModules(hProcess, EnumeratedModules, sizeof(EnumeratedModules), &cbNeeded))
    {
        for(i = 0; i < (int)(cbNeeded / sizeof(HMODULE)); i++)
        {
            if(EnumeratedModules[i] == (HMODULE)ModuleBase)
            {
                if(GetModuleInformation(hProcess, (HMODULE)EnumeratedModules[i], &RemoteModuleInfo, sizeof(MODULEINFO)))
                {
                    return(DumpMemoryW(hProcess, (LPVOID)EnumeratedModules[i], RemoteModuleInfo.SizeOfImage, szDumpFileName));
                }
            }
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, char* szDumpFileName)
{
    wchar_t uniDumpFileName[MAX_PATH] = {0};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, -1, uniDumpFileName, _countof(uniDumpFileName));
        return(DumpModuleExW(ProcessId, ModuleBase, uniDumpFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, wchar_t* szDumpFileName)
{

    HANDLE hProcess = 0;
    bool ReturnValue = false;

    hProcess = EngineOpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, ProcessId);
    if(hProcess) //If the function fails, the return value is NULL. To get extended error information, call GetLastError.
    {
        ReturnValue = DumpModuleW(hProcess, ModuleBase, szDumpFileName);
        EngineCloseHandle(hProcess);
        return ReturnValue;
    }

    return false;
}



================================================
File: TitanEngine/TitanEngine.Engine.Simplification.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Simplification.h"
#include "Global.Garbage.h"

// TitanEngine.Engine.Simplification.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(char* szFileName, char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack)
{
    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t uniUnpackedFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        if(szUnpackedFileName == NULL)
        {
            return EngineUnpackerInitializeW(uniFileName, NULL, DoLogData, DoRealignFile, DoMoveOverlay, EntryCallBack);
        }
        else
        {
            MultiByteToWideChar(CP_ACP, NULL, szUnpackedFileName, lstrlenA(szUnpackedFileName) + 1, uniUnpackedFileName, sizeof(uniUnpackedFileName) / (sizeof(uniUnpackedFileName[0])));
            EngineUnpackerInitializeW(uniFileName, uniUnpackedFileName, DoLogData, DoRealignFile, DoMoveOverlay, EntryCallBack);
        }
    }
}

__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(wchar_t* szFileName, wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack)
{
    int i, j;
    wchar_t TempBackBuffer[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        RtlZeroMemory(&szEngineUnpackerSnapShot1[0], MAX_PATH * 2);
        RtlZeroMemory(&szEngineUnpackerSnapShot2[0], MAX_PATH * 2);
        RtlZeroMemory(&EngineUnpackerFileStatus, sizeof FILE_STATUS_INFO);
        if(IsPE32FileValidExW(szFileName, UE_DEPTH_DEEP, &EngineUnpackerFileStatus))
        {
            if(!EngineUnpackerFileStatus.FileIsDLL)
            {
                pEngineUnpackerProcessHandle = (LPPROCESS_INFORMATION)InitDebugExW(szFileName, NULL, NULL, EntryCallBack);
            }
            else
            {
                pEngineUnpackerProcessHandle = (LPPROCESS_INFORMATION)InitDLLDebugW(szFileName, true, NULL, NULL, EntryCallBack);
            }
            if(pEngineUnpackerProcessHandle != NULL)
            {
                lstrcpyW(szEngineUnpackerInputFile, szFileName);
                if(szUnpackedFileName != NULL)
                {
                    lstrcpyW(szEngineUnpackerOutputFile, szUnpackedFileName);
                }
                else
                {
                    lstrcpyW(TempBackBuffer, szFileName);
                    i = lstrlenW(TempBackBuffer);
                    while(TempBackBuffer[i] != 0x2E)
                    {
                        i--;
                    }
                    TempBackBuffer[i] = 0x00;
                    j = i + 1;
                    wsprintfW(szEngineUnpackerOutputFile, L"%s.unpacked.%s", &TempBackBuffer[0], &TempBackBuffer[j]);
                }
                EngineUnpackerOptionRealingFile = DoRealignFile;
                EngineUnpackerOptionMoveOverlay = DoMoveOverlay;
                EngineUnpackerOptionRelocationFix = false;
                EngineUnpackerOptionLogData = DoLogData;
                EngineUnpackerOptionUnpackedOEP = NULL;
                EngineUnpackerFileImporterInit = false;
                if(EngineUnpackerOptionLogData)
                {
                    EngineAddUnpackerWindowLogMessage("-> Unpack started...");
                }
                EngineUnpackerBreakInfo.clear();
                DebugLoop();
            }
        }
    }
}

__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2)
{
    ULONG_PTR fPatternLocation;
    DWORD fBreakPointType = UE_BREAKPOINT;
    UnpackerInformation fUnpackerInformation = {};

    if((int)SearchStart == UE_UNPACKER_CONDITION_SEARCH_FROM_EP)
    {
        if(EngineUnpackerFileStatus.FileIsDLL)
        {
            SearchStart = (void*)((ULONG_PTR)GetPE32DataW(szEngineUnpackerInputFile, NULL, UE_OEP) + (ULONG_PTR)GetDebuggedDLLBaseAddress());
        }
        else
        {
            SearchStart = (void*)((ULONG_PTR)GetPE32DataW(szEngineUnpackerInputFile, NULL, UE_OEP) + (ULONG_PTR)GetDebuggedFileBaseAddress());
        }
    }

    if(SearchSize == NULL)
    {
        SearchSize = 0x1000;
    }

    fPatternLocation = (ULONG_PTR)FindEx(pEngineUnpackerProcessHandle->hProcess, SearchStart, SearchSize, SearchPattern, PatternSize, NULL);
    if(fPatternLocation != NULL)
    {
        if(SingleBreak)
        {
            fBreakPointType = UE_SINGLESHOOT;
        }

        fPatternLocation = fPatternLocation + (int)PatternDelta;
        fUnpackerInformation.Parameter1 = Parameter1;
        fUnpackerInformation.Parameter2 = Parameter2;
        fUnpackerInformation.SingleBreak = SingleBreak;
        fUnpackerInformation.BreakPointAddress = fPatternLocation;

        if(BreakType == UE_UNPACKER_CONDITION_LOADLIBRARY)
        {
            if(SetBPX(fPatternLocation, UE_BREAKPOINT, &EngineSimplifyLoadLibraryCallBack))
            {
                EngineUnpackerBreakInfo.push_back(fUnpackerInformation);
                return true;
            }
        }
        else if(BreakType == UE_UNPACKER_CONDITION_GETPROCADDRESS)
        {
            if(SetBPX(fPatternLocation, UE_BREAKPOINT, &EngineSimplifyGetProcAddressCallBack))
            {
                EngineUnpackerBreakInfo.push_back(fUnpackerInformation);
                return true;
            }
        }
        else if(BreakType == UE_UNPACKER_CONDITION_ENTRYPOINTBREAK)
        {
            if(SetBPX(fPatternLocation, UE_BREAKPOINT, &EngineSimplifyGetProcAddressCallBack))
            {
                EngineUnpackerBreakInfo.push_back(fUnpackerInformation);
                return true;
            }
        }
        else if(BreakType == UE_UNPACKER_CONDITION_RELOCSNAPSHOT1)
        {
            if(SetBPX(fPatternLocation, UE_BREAKPOINT, &EngineSimplifyMakeSnapshotCallBack))
            {
                fUnpackerInformation.SnapShotNumber = 1;
                EngineUnpackerBreakInfo.push_back(fUnpackerInformation);
                return true;
            }
        }
        else if(BreakType == UE_UNPACKER_CONDITION_RELOCSNAPSHOT2)
        {
            if(SetBPX(fPatternLocation, UE_BREAKPOINT, &EngineSimplifyMakeSnapshotCallBack))
            {
                fUnpackerInformation.SnapShotNumber = 2;
                EngineUnpackerBreakInfo.push_back(fUnpackerInformation);
                return true;
            }
        }
        else
        {
            if(SetBPX(fPatternLocation, fBreakPointType, (void*)BreakType))
            {
                EngineUnpackerBreakInfo.push_back(fUnpackerInformation);
                return true;
            }
        }
    }

    return false;
}

__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress)
{
    EngineUnpackerOptionUnpackedOEP = UnpackedEntryPointAddress;
}

__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking()
{
    EngineSimplifyEntryPointCallBack();
    EmptyGarbage();
}



================================================
File: TitanEngine/TitanEngine.Engine.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Mapping.h"
#include "Global.Engine.Hook.h"
#include "Global.Engine.GUI.h"
#include "Global.Debugger.h"

// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet)
{

    if(VariableId == UE_ENGINE_ALOW_MODULE_LOADING)
    {
        engineAlowModuleLoading = VariableSet;
    }
    else if(VariableId == UE_ENGINE_AUTOFIX_FORWARDERS)
    {
        engineCheckForwarders = VariableSet;
    }
    else if(VariableId == UE_ENGINE_PASS_ALL_EXCEPTIONS)
    {
        enginePassAllExceptions = VariableSet;
    }
    else if(VariableId == UE_ENGINE_NO_CONSOLE_WINDOW)
    {
        engineRemoveConsoleForDebugee = VariableSet;
    }
    else if(VariableId == UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS)
    {
        engineBackupForCriticalFunctions = VariableSet;
    }
    else if(VariableId == UE_ENGINE_RESET_CUSTOM_HANDLER)
    {
        engineResetCustomHandler = VariableSet;
    }
    else if(VariableId == UE_ENGINE_SET_DEBUG_PRIVILEGE)
    {
        engineEnableDebugPrivilege = VariableSet;
        EngineSetDebugPrivilege(GetCurrentProcess(), VariableSet);
    }
    else if(VariableId == UE_ENGINE_SAFE_ATTACH)
    {
        engineSafeAttach = VariableSet;
    }
    else if(VariableId == UE_ENGINE_MEMBP_ALT)
    {
        engineMembpAlt = VariableSet;
    }
    else if(VariableId == UE_ENGINE_DISABLE_ASLR)
    {
        engineDisableAslr = VariableSet;
    }
    else if (VariableId == UE_ENGINE_SAFE_STEP)
    {
        engineSafeStep = VariableSet;
    }
}

__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(char* szFileName, char* szOutputFolder, bool LogCreatedFiles)
{

    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t uniOutputFolder[MAX_PATH] = {};

    if(szFileName != NULL && szOutputFolder != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szOutputFolder, lstrlenA(szOutputFolder) + 1, uniOutputFolder, sizeof(uniOutputFolder) / (sizeof(uniOutputFolder[0])));
        return(EngineCreateMissingDependenciesW(uniFileName, uniOutputFolder, LogCreatedFiles));
    }
    else
    {
        return(NULL);
    }
}

__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(wchar_t* szFileName, wchar_t* szOutputFolder, bool LogCreatedFiles)
{

    char* ImportDllName;
    wchar_t ImportDllNameW[512];
    wchar_t BuildExportName[512];
    PIMAGE_THUNK_DATA32 ImportThunkX86;
    PIMAGE_THUNK_DATA64 ImportThunkX64;
    PIMAGE_IMPORT_DESCRIPTOR ImportPointer;
    ULONG_PTR ImportTableAddress = NULL;
    ULONG_PTR ImportThunkName = NULL;
    DWORD ImportThunkAddress = NULL;
    ULONG_PTR ImageBase = NULL;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    BOOL FileIs64;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(DOSHeader->e_lfanew < 0x1000 - 108)
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(LogCreatedFiles)
            {
                if(engineDependencyFiles != NULL)
                {
                    VirtualFree(engineDependencyFiles, NULL, MEM_RELEASE);
                }
                engineDependencyFiles = VirtualAlloc(NULL, 20 * 1024, MEM_COMMIT, PAGE_READWRITE);
                engineDependencyFilesCWP = engineDependencyFiles;
            }
            if(!FileIs64)
            {
                ImageBase = (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase;
                ImportTableAddress = (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
                ImportTableAddress = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportTableAddress + ImageBase, true);
                ImportPointer = (PIMAGE_IMPORT_DESCRIPTOR)ImportTableAddress;
                while(ImportPointer && ImportPointer->FirstThunk != NULL)
                {
                    ImportDllName = (PCHAR)((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportPointer->Name + ImageBase, true));
                    if(ImportDllName)
                    {
                        MultiByteToWideChar(CP_ACP, NULL, ImportDllName, lstrlenA(ImportDllName) + 1, ImportDllNameW, sizeof(ImportDllNameW) / (sizeof(ImportDllNameW[0])));
                        if(!EngineIsDependencyPresentW(ImportDllNameW, szFileName, szOutputFolder))
                        {
                            RtlZeroMemory(&BuildExportName, sizeof(BuildExportName));
                            lstrcatW(BuildExportName, szOutputFolder);
                            if(BuildExportName[lstrlenW(BuildExportName) - 1] != 0x5C)
                            {
                                BuildExportName[lstrlenW(BuildExportName)] = 0x5C;
                            }
                            lstrcatW(BuildExportName, ImportDllNameW);
                            if(LogCreatedFiles)
                            {
                                RtlMoveMemory(engineDependencyFilesCWP, &BuildExportName, lstrlenW(BuildExportName) * 2);
                                engineDependencyFilesCWP = (LPVOID)((ULONG_PTR)engineDependencyFilesCWP + (lstrlenW(BuildExportName) * 2) + 2);
                            }
                            EngineExtractResource("MODULEx86", BuildExportName);
                            ExporterInit(20 * 1024, (ULONG_PTR)GetPE32DataW(BuildExportName, NULL, UE_IMAGEBASE), NULL, ImportDllName);
                            ImportThunkAddress = ImportPointer->FirstThunk;
                            if(ImportPointer->OriginalFirstThunk != NULL)
                            {
                                ImportThunkX86 = (PIMAGE_THUNK_DATA32)((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportPointer->OriginalFirstThunk + ImageBase, true));
                            }
                            else
                            {
                                ImportThunkX86 = (PIMAGE_THUNK_DATA32)((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportPointer->FirstThunk + ImageBase, true));
                            }
                            while(ImportThunkX86 && ImportThunkX86->u1.Function != NULL)
                            {
                                if(ImportThunkX86->u1.Ordinal & IMAGE_ORDINAL_FLAG32)
                                {
                                    ExporterAddNewOrdinalExport(ImportThunkX86->u1.Ordinal ^ IMAGE_ORDINAL_FLAG32, 0x1000);
                                }
                                else
                                {
                                    ImportThunkName = (ULONG_PTR)(ConvertVAtoFileOffset(FileMapVA, ImportThunkX86->u1.AddressOfData + ImageBase, true) + 2);
                                    if(ImportThunkName)
                                        ExporterAddNewExport((PCHAR)ImportThunkName, 0x1000);
                                }
                                ImportThunkX86 = (PIMAGE_THUNK_DATA32)((ULONG_PTR)ImportThunkX86 + 4);
                                ImportThunkAddress = ImportThunkAddress + 4;
                            }
                            ExporterBuildExportTableExW(BuildExportName, ".export");
                        }
                        ImportPointer = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportPointer + sizeof IMAGE_IMPORT_DESCRIPTOR);
                    }
                }
            }
            else
            {
                ImageBase = (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase;
                ImportTableAddress = (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
                ImportTableAddress = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportTableAddress + ImageBase, true);
                ImportPointer = (PIMAGE_IMPORT_DESCRIPTOR)ImportTableAddress;
                while(ImportPointer && ImportPointer->FirstThunk != NULL)
                {
                    ImportDllName = (PCHAR)((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportPointer->Name + ImageBase, true));
                    if(ImportDllName)
                    {
                        MultiByteToWideChar(CP_ACP, NULL, ImportDllName, lstrlenA(ImportDllName) + 1, ImportDllNameW, sizeof(ImportDllNameW) / (sizeof(ImportDllNameW[0])));
                        if(!EngineIsDependencyPresentW(ImportDllNameW, szFileName, szOutputFolder))
                        {
                            RtlZeroMemory(&BuildExportName, sizeof(BuildExportName));
                            lstrcatW(BuildExportName, szOutputFolder);
                            if(BuildExportName[lstrlenW(BuildExportName) - 1] != 0x5C)
                            {
                                BuildExportName[lstrlenW(BuildExportName)] = 0x5C;
                            }
                            lstrcatW(BuildExportName, ImportDllNameW);
                            if(LogCreatedFiles)
                            {
                                RtlMoveMemory(engineDependencyFilesCWP, &BuildExportName, lstrlenW(BuildExportName) * 2);
                                engineDependencyFilesCWP = (LPVOID)((ULONG_PTR)engineDependencyFilesCWP + (lstrlenW(BuildExportName) * 2) + 2);
                            }
                            EngineExtractResource("MODULEx64", BuildExportName);
                            ExporterInit(20 * 1024, (ULONG_PTR)GetPE32DataW(BuildExportName, NULL, UE_IMAGEBASE), NULL, ImportDllName);
                            ImportThunkAddress = ImportPointer->FirstThunk;
                            if(ImportPointer->OriginalFirstThunk != NULL)
                            {
                                ImportThunkX64 = (PIMAGE_THUNK_DATA64)((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportPointer->OriginalFirstThunk + ImageBase, true));
                            }
                            else
                            {
                                ImportThunkX64 = (PIMAGE_THUNK_DATA64)((ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, ImportPointer->FirstThunk + ImageBase, true));
                            }
                            while(ImportThunkX64 && ImportThunkX64->u1.Function != NULL)
                            {
                                if(ImportThunkX64->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
                                {
                                    ExporterAddNewOrdinalExport((DWORD)(ImportThunkX64->u1.Ordinal ^ IMAGE_ORDINAL_FLAG64), 0x1000);
                                }
                                else
                                {
                                    ImportThunkName = (ULONG_PTR)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(ImportThunkX64->u1.AddressOfData + ImageBase), true) + 2);
                                    if(ImportThunkName)
                                        ExporterAddNewExport((PCHAR)ImportThunkName, 0x1000);
                                }
                                ImportThunkX64 = (PIMAGE_THUNK_DATA64)((ULONG_PTR)ImportThunkX64 + 8);
                                ImportThunkAddress = ImportThunkAddress + 8;
                            }
                            ExporterBuildExportTableExW(BuildExportName, ".export");
                        }
                        ImportPointer = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportPointer + sizeof IMAGE_IMPORT_DESCRIPTOR);
                    }
                }
            }
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return true;
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess)
{

    if(hProcess != NULL)
    {
        SetAPIBreakPoint("ntdll.dll", "LdrLoadDll", UE_BREAKPOINT, UE_APIEND, (LPVOID)&EngineFakeLoadLibraryReturn);
        SetAPIBreakPoint("ntdll.dll", "LdrGetProcedureAddress", UE_BREAKPOINT, UE_APIEND, (LPVOID)&EngineFakeGetProcAddressReturn);
    }
    return false;
}

__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies()
{

    wchar_t szTempName[MAX_PATH];
    wchar_t szTempFolder[MAX_PATH];

    if(engineDependencyFiles != NULL)
    {
        engineDependencyFilesCWP = engineDependencyFiles;
        while(*((char*)engineDependencyFilesCWP) != 0)
        {
            RtlZeroMemory(&szTempName, sizeof szTempName);
            RtlZeroMemory(&szTempFolder, sizeof szTempFolder);
            if(GetTempPathW(MAX_PATH, szTempFolder) < MAX_PATH)
            {
                if(GetTempFileNameW(szTempFolder, L"DeleteTempGenFile", GetTickCount(), szTempName))
                {
                    DeleteFileW(szTempName);
                    if(!MoveFileW((LPCWSTR)engineDependencyFilesCWP, szTempName))
                    {
                        DeleteFileW((LPCWSTR)engineDependencyFilesCWP);
                    }
                    else
                    {
                        DeleteFileW(szTempName);
                    }
                }
            }
            engineDependencyFilesCWP = (LPVOID)((ULONG_PTR)engineDependencyFilesCWP + (lstrlenW((PWCHAR)engineDependencyFilesCWP) * 2) + 2);
        }
        VirtualFree(engineDependencyFiles, NULL, MEM_RELEASE);
        engineDependencyFiles = NULL;
        engineDependencyFilesCWP = NULL;
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(char* WindowUnpackerTitle, char* WindowUnpackerLongTitle, char* WindowUnpackerName, char* WindowUnpackerAuthor, void* StartUnpackingCallBack)
{
    if(!WindowUnpackerTitle || !WindowUnpackerLongTitle || !WindowUnpackerName || !WindowUnpackerAuthor || !StartUnpackingCallBack)
        return false;
    EngineStartUnpackingCallBack = StartUnpackingCallBack;
    lstrcpyA(szWindowUnpackerTitle, WindowUnpackerTitle);
    lstrcpyA(szWindowUnpackerLongTitle, WindowUnpackerLongTitle);
    lstrcpyA(szWindowUnpackerAuthor, WindowUnpackerAuthor);
    lstrcpyA(szWindowUnpackerName, WindowUnpackerName);
    if(DialogBoxParamA((HINSTANCE)engineHandle, MAKEINTRESOURCEA(IDD_MAINWINDOW), NULL, (DLGPROC)EngineWndProc, NULL) != -1)
    {
        return true;
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(char* szLogMessage)
{
    int cSelect;

    SendMessageA(EngineBoxHandle, LB_ADDSTRING, NULL, (LPARAM)szLogMessage);
    cSelect = (int)SendMessageA(EngineBoxHandle, LB_GETCOUNT, NULL, NULL);
    cSelect--;
    SendMessageA(EngineBoxHandle, LB_SETCURSEL, (WPARAM)cSelect, NULL);
}

__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize)
{
    int blub = 1;
    switch(StructureType)
    {
    case UE_STRUCT_PE32STRUCT:
        return (sizeof(PE32Struct) == StructureSize);
    case UE_STRUCT_PE64STRUCT:
        return (sizeof(PE64Struct) == StructureSize);
    case UE_STRUCT_PESTRUCT:
        return (sizeof(PEStruct) == StructureSize);
    case UE_STRUCT_IMPORTENUMDATA:
        return (sizeof(ImportEnumData) == StructureSize);
    case UE_STRUCT_THREAD_ITEM_DATA:
        return (sizeof(THREAD_ITEM_DATA) == StructureSize);
    case UE_STRUCT_LIBRARY_ITEM_DATA:
        return (sizeof(LIBRARY_ITEM_DATA) == StructureSize);
    case UE_STRUCT_LIBRARY_ITEM_DATAW:
        return (sizeof(LIBRARY_ITEM_DATAW) == StructureSize);
    case UE_STRUCT_PROCESS_ITEM_DATA:
        return (sizeof(PROCESS_ITEM_DATA) == StructureSize);
    case UE_STRUCT_HANDLERARRAY:
        return (sizeof(HandlerArray) == StructureSize);
    case UE_STRUCT_HOOK_ENTRY:
        return (sizeof(HOOK_ENTRY) == StructureSize);
    case UE_STRUCT_FILE_STATUS_INFO:
        return (sizeof(FILE_STATUS_INFO) == StructureSize);
    case UE_STRUCT_FILE_FIX_INFO:
        return (sizeof(FILE_FIX_INFO) == StructureSize);
    case UE_STRUCT_X87FPUREGISTER:
        return (sizeof(x87FPURegister_t) == StructureSize);
    case UE_STRUCT_X87FPU:
        return (sizeof(x87FPU_t) == StructureSize);
    case UE_STRUCT_TITAN_ENGINE_CONTEXT:
        return (sizeof(TITAN_ENGINE_CONTEXT_t) == StructureSize);
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.Exporter.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Mapping.h"
#include "Global.Engine.h"

static LPVOID expTableData = NULL;
static LPVOID expTableDataCWP = NULL;
static ULONG_PTR expImageBase = 0;
static DWORD expExportNumber = 0;
static bool expNamePresent = false;
static DWORD expExportAddress[1000];
static DWORD expSortedNamePointers[1000];
static ULONG_PTR expNamePointers[1000];
static DWORD expNameHashes[1000];
static WORD expOrdinals[1000];
static IMAGE_EXPORT_DIRECTORY expExportData;

// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup()
{

    int i = NULL;

    for(i = 0; i < 1000; i++)
    {
        expExportAddress[i] = 0;
        expSortedNamePointers[i] = 0;
        expNamePointers[i] = 0;
        expNameHashes[i] = 0;
        expOrdinals[i] = 0;
    }
    //RtlZeroMemory(&szExportFileName, 512);
    RtlZeroMemory(&expExportData, sizeof IMAGE_EXPORT_DIRECTORY);
    VirtualFree(expTableData, NULL, MEM_RELEASE);
    expExportNumber = NULL;
    expTableData = NULL;
    expImageBase = NULL;
}
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase)
{
    expImageBase = ImageBase;
}
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, char* szExportModuleName)
{

    if(expTableData != NULL)
    {
        ExporterCleanup();
    }
    expExportData.Base = ExportOrdinalBase;
    expTableData = VirtualAlloc(NULL, MemorySize, MEM_COMMIT, PAGE_READWRITE);
    if(szExportModuleName != NULL)
    {
        RtlMoveMemory(expTableData, szExportModuleName, lstrlenA(szExportModuleName));
        expTableDataCWP = (LPVOID)((ULONG_PTR)expTableData + lstrlenA(szExportModuleName) + 2);
        expNamePresent = true;
    }
    else
    {
        expTableDataCWP = expTableData;
        expNamePresent = false;
    }
    expImageBase = ImageBase;
}
__declspec(dllexport) bool TITCALL ExporterAddNewExport(char* szExportName, DWORD ExportRelativeAddress)
{

    unsigned int i;
    DWORD NameHash;

    if(expTableDataCWP != NULL && szExportName != NULL)
    {
        NameHash = (DWORD)EngineHashString(szExportName);
        for(i = 0; i < expExportNumber; i++)
        {
            if(expNameHashes[i] == NameHash)
            {
                return true;
            }
        }
        expExportAddress[expExportNumber] = ExportRelativeAddress;
        expNamePointers[expExportNumber] = (ULONG_PTR)expTableDataCWP;
        expNameHashes[expExportNumber] = (DWORD)EngineHashString(szExportName);
        expOrdinals[expExportNumber] = (WORD)(expExportNumber);
        RtlMoveMemory(expTableDataCWP, szExportName, lstrlenA(szExportName));
        expTableDataCWP = (LPVOID)((ULONG_PTR)expTableDataCWP + lstrlenA(szExportName) + 2);
        expExportNumber++;
        return true;
    }
    return false;
}
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress)
{

    unsigned int i = NULL;
    char szExportFunctionName[512];

    RtlZeroMemory(&szExportFunctionName, 512);
    if(expTableDataCWP != NULL)
    {
        if(expExportNumber == NULL)
        {
            expExportData.Base = OrdinalNumber;
            wsprintfA(szExportFunctionName, "Func%d", expExportNumber + 1);
            return(ExporterAddNewExport(szExportFunctionName, ExportRelativeAddress));
        }
        else
        {
            if(OrdinalNumber == expExportData.Base + expExportNumber - 1)
            {
                wsprintfA(szExportFunctionName, "Func%d", expExportNumber + 1);
                return(ExporterAddNewExport(szExportFunctionName, ExportRelativeAddress));
            }
            else if(OrdinalNumber > expExportData.Base + expExportNumber - 1)
            {
                for(i = expExportData.Base + expExportNumber - 1; i <= OrdinalNumber; i++)
                {
                    RtlZeroMemory(&szExportFunctionName, 512);
                    wsprintfA(szExportFunctionName, "Func%d", expExportNumber + 1);
                    ExporterAddNewExport(szExportFunctionName, ExportRelativeAddress);
                }
                return true;
            }
            else
            {
                return true;
            }
        }
    }
    return false;
}
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount()
{
    return(expExportNumber);
}
__declspec(dllexport) long TITCALL ExporterEstimatedSize()
{

    DWORD EstimatedSize = NULL;

    EstimatedSize = (DWORD)((ULONG_PTR)expTableDataCWP - (ULONG_PTR)expTableData);
    EstimatedSize = EstimatedSize + (expExportNumber * 12) + sizeof IMAGE_EXPORT_DIRECTORY;
    return(EstimatedSize);
}
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA)
{

    unsigned int i = NULL;
    unsigned int j = NULL;
    LPVOID expBuildExportDataOld;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    LPVOID expBuildExportData;
    DynBuf expBuildExportDyn;
    LPVOID expBuildExportDataCWP;
    DWORD StorePlaceRVA = (DWORD)ConvertFileOffsetToVA(FileMapVA, StorePlace, false);
    ULONG_PTR TempULONG;
    DWORD TempDWORD;
    BOOL FileIs64 = false;

    if(expTableDataCWP != NULL)
    {
        expBuildExportData = expBuildExportDyn.Allocate(ExporterEstimatedSize());
        expBuildExportDataCWP = (LPVOID)((ULONG_PTR)expBuildExportData + sizeof IMAGE_EXPORT_DIRECTORY);

        expExportData.NumberOfNames = expExportNumber;
        expExportData.NumberOfFunctions = expExportNumber;
        for(i = 0; i < expExportNumber; i++)
        {
            for(j = 0; j < expExportNumber; j++)
            {
                if(lstrcmpiA((PCHAR)expNamePointers[i], (PCHAR)expNamePointers[j]) < NULL)
                {
                    TempULONG = expNamePointers[j];
                    expNamePointers[j] = expNamePointers[i];
                    expNamePointers[i] = TempULONG;
                    TempDWORD = expExportAddress[j];
                    expExportAddress[j] = expExportAddress[i];
                    expExportAddress[i] = TempDWORD;
                }
            }
        }

        if(expNamePresent)
        {
            expExportData.Name = StorePlaceRVA + (DWORD)((ULONG_PTR)expBuildExportDataCWP - (ULONG_PTR)expBuildExportData);
            RtlMoveMemory(expBuildExportDataCWP, (LPVOID)expTableData, lstrlenA((PCHAR)expTableData));
            expBuildExportDataCWP = (LPVOID)((ULONG_PTR)expBuildExportDataCWP + lstrlenA((PCHAR)expTableData) + 2);
        }
        for(i = 0; i < expExportNumber; i++)
        {
            RtlMoveMemory(expBuildExportDataCWP, (LPVOID)expNamePointers[i], lstrlenA((PCHAR)expNamePointers[i]));
            expBuildExportDataOld = expBuildExportDataCWP;
            expBuildExportDataCWP = (LPVOID)((ULONG_PTR)expBuildExportDataCWP + lstrlenA((PCHAR)expNamePointers[i]) + 2);
            expSortedNamePointers[i] = (DWORD)((ULONG_PTR)expBuildExportDataOld - (ULONG_PTR)expBuildExportData) + StorePlaceRVA;
        }
        expExportData.AddressOfFunctions = StorePlaceRVA + (DWORD)((ULONG_PTR)expBuildExportDataCWP - (ULONG_PTR)expBuildExportData);
        RtlMoveMemory(expBuildExportDataCWP, &expExportAddress, 4 * expExportNumber);
        expBuildExportDataCWP = (LPVOID)((ULONG_PTR)expBuildExportDataCWP + 4 * expExportNumber);
        expExportData.AddressOfNames = StorePlaceRVA + (DWORD)((ULONG_PTR)expBuildExportDataCWP - (ULONG_PTR)expBuildExportData);
        RtlMoveMemory(expBuildExportDataCWP, &expSortedNamePointers, 4 * expExportNumber);
        expBuildExportDataCWP = (LPVOID)((ULONG_PTR)expBuildExportDataCWP + 4 * expExportNumber);
        expExportData.AddressOfNameOrdinals = StorePlaceRVA + (DWORD)((ULONG_PTR)expBuildExportDataCWP - (ULONG_PTR)expBuildExportData);
        RtlMoveMemory(expBuildExportDataCWP, &expOrdinals, 2 * expExportNumber);
        expBuildExportDataCWP = (LPVOID)((ULONG_PTR)expBuildExportDataCWP + 2 * expExportNumber);
        RtlMoveMemory(expBuildExportData, &expExportData, sizeof IMAGE_EXPORT_DIRECTORY);

        RtlMoveMemory((LPVOID)StorePlace, expBuildExportData, (DWORD)((ULONG_PTR)expBuildExportDataCWP - (ULONG_PTR)expBuildExportData));

        if(FileMapVA != NULL)
        {
            DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
            if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
            {
                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                if(PEHeader32->OptionalHeader.Magic == 0x10B)
                {
                    FileIs64 = false;
                }
                else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                {
                    FileIs64 = true;
                }
                else
                {
                    return false;
                }
                if(!FileIs64)
                {
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = (DWORD)StorePlaceRVA;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = (DWORD)((ULONG_PTR)expBuildExportDataCWP - (ULONG_PTR)expBuildExportData);
                }
                else
                {
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = (DWORD)StorePlaceRVA;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = (DWORD)((ULONG_PTR)expBuildExportDataCWP - (ULONG_PTR)expBuildExportData);
                }
            }
        }
        ExporterCleanup();
        return true;
    }
    return false;
}
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(char* szExportFileName, char* szSectionName)
{

    wchar_t uniExportFileName[MAX_PATH] = {};

    if(szExportFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szExportFileName, lstrlenA(szExportFileName) + 1, uniExportFileName, sizeof(uniExportFileName) / (sizeof(uniExportFileName[0])));
        return(ExporterBuildExportTableExW(uniExportFileName, szSectionName));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(wchar_t* szExportFileName, char* szSectionName)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    DWORD NewSectionVO = NULL;
    DWORD NewSectionFO = NULL;
    bool ReturnValue = false;

    if(ExporterGetAddedExportCount() > NULL)
    {
        NewSectionVO = AddNewSectionW(szExportFileName, szSectionName, ExporterEstimatedSize());
        if(MapFileExW(szExportFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
        {
            NewSectionFO = (DWORD)ConvertVAtoFileOffset(FileMapVA, NewSectionVO + (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMAGEBASE), true);
            if(NewSectionFO)
                ReturnValue = ExporterBuildExportTable(NewSectionFO, FileMapVA);
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            if(ReturnValue)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(char* szFileName)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(ExporterLoadExportTableW(uniFileName));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(wchar_t* szFileName)
{

    unsigned int i = 0;
    unsigned int j = 0;
    unsigned int n = 0;
    unsigned int x = 0;
    bool ExportPresent = false;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    PEXPORTED_DATA ExportedFunctions;
    PEXPORTED_DATA ExportedFunctionNames;
    PEXPORTED_DATA_WORD ExportedFunctionOrdinals;
    char* ExportName = NULL;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                {
                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase), true));
                    if(PEExports)
                    {
                        ExportedFunctions = (PEXPORTED_DATA)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEExports->AddressOfFunctions + PEHeader32->OptionalHeader.ImageBase), true));
                        if(ExportedFunctions)
                        {
                            ExporterInit(50 * 1024, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, PEExports->Base, NULL);
                            ExportPresent = true;
                        }
                    }
                }
            }
            else
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                {
                    PEExports = (PIMAGE_EXPORT_DIRECTORY)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader64->OptionalHeader.ImageBase), true));
                    if(PEExports)
                    {
                        ExportedFunctions = (PEXPORTED_DATA)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEExports->AddressOfFunctions + PEHeader64->OptionalHeader.ImageBase), true));
                        if(ExportedFunctions)
                        {
                            ExporterInit(50 * 1024, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, PEExports->Base, NULL);
                            ExportPresent = true;
                        }
                    }
                }
            }
            if(ExportPresent)
            {
                for(n = 0; n <= PEExports->NumberOfNames; n++)
                {
                    ExportPresent = false;
                    x = n;
                    if(!FileIs64)
                    {
                        ExportedFunctionNames = (PEXPORTED_DATA)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEExports->AddressOfNames + PEHeader32->OptionalHeader.ImageBase), true));
                        ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEExports->AddressOfNameOrdinals + PEHeader32->OptionalHeader.ImageBase), true));
                    }
                    else
                    {
                        ExportedFunctionNames = (PEXPORTED_DATA)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEExports->AddressOfNames + PEHeader64->OptionalHeader.ImageBase), true));
                        ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEExports->AddressOfNameOrdinals + PEHeader64->OptionalHeader.ImageBase), true));
                    }
                    if(ExportedFunctionNames && ExportedFunctionOrdinals)
                    {
                        for(j = 0; j <= PEExports->NumberOfNames; j++)
                        {
                            if(ExportedFunctionOrdinals->OrdinalNumber != x)
                            {
                                ExportedFunctionOrdinals = (PEXPORTED_DATA_WORD)((ULONG_PTR)ExportedFunctionOrdinals + 2);
                            }
                            else
                            {
                                ExportPresent = true;
                                break;
                            }
                        }
                        if(ExportPresent)
                        {
                            ExportedFunctionNames = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctionNames + j * 4);
                            if(!FileIs64)
                            {
                                ExportName = (char*)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(ExportedFunctionNames->ExportedItem + PEHeader32->OptionalHeader.ImageBase), true));
                            }
                            else
                            {
                                ExportName = (char*)(ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(ExportedFunctionNames->ExportedItem + PEHeader64->OptionalHeader.ImageBase), true));
                            }
                            if(ExportName)
                                ExporterAddNewExport(ExportName, ExportedFunctions->ExportedItem);
                        }
                        ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + 4);
                    }
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    else
    {
        return false;
    }
    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    return false;
}



================================================
File: TitanEngine/TitanEngine.Handler.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Handle.h"
#include "Global.Engine.h"

bool NtQuerySysHandleInfo(DynBuf & buf)
{
    ULONG RequiredSize = NULL;

    buf.Allocate(sizeof(SYSTEM_HANDLE_INFORMATION));

    NtQuerySystemInformation(SystemHandleInformation, buf.GetPtr(), (ULONG)buf.Size(), &RequiredSize);

    buf.Allocate(RequiredSize + sizeof(SYSTEM_HANDLE_INFORMATION));

    return (NtQuerySystemInformation(SystemHandleInformation, buf.GetPtr(), (ULONG)buf.Size(), &RequiredSize) >= 0);
}


// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId)
{
    int HandleCount = 0;

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;

    LPVOID QuerySystemBuffer = hinfo.GetPtr();

    PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)QuerySystemBuffer;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO pHandle = HandleInfo->Handles;

    for(ULONG i = 0; i < HandleInfo->NumberOfHandles; i++)
    {
        if((DWORD)pHandle->UniqueProcessId == ProcessId)
        {
            HandleCount++;
        }

        pHandle++;
    }

    return HandleCount;
}
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle)
{
    bool HandleActive = false;

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return false;

    LPVOID QuerySystemBuffer = hinfo.GetPtr();

    PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)QuerySystemBuffer;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO pHandle = HandleInfo->Handles;


    for(ULONG i = 0; i < HandleInfo->NumberOfHandles; i++)
    {
        if((DWORD)pHandle->UniqueProcessId == ProcessId && (HANDLE)pHandle->HandleValue == hHandle)
        {
            HandleActive = true;
            break;
        }

        pHandle++;
    }

    return HandleActive;
}
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName)
{
    bool NameFound = false;
    HANDLE myHandle = NULL;
    ULONG RequiredSize = NULL;
    char ObjectNameInfo[0x1000] = {0};
    POBJECT_NAME_INFORMATION pObjectNameInfo = (POBJECT_NAME_INFORMATION)ObjectNameInfo;
    LPVOID HandleFullName = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
    {
        VirtualFree(HandleFullName, NULL, MEM_RELEASE);
        return 0;
    }
    LPVOID QuerySystemBuffer = hinfo.GetPtr();

    PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)QuerySystemBuffer;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO pHandle = HandleInfo->Handles;

    for(ULONG i = 0; i < HandleInfo->NumberOfHandles; i++)
    {
        if((DWORD)pHandle->UniqueProcessId == ProcessId && (HANDLE)pHandle->HandleValue == hHandle)
        {
            if(pHandle->GrantedAccess != 0x0012019F) //Filter, because this GrantedAccess type can cause deadlocks!
            {
                if(DuplicateHandle(hProcess, hHandle, GetCurrentProcess(), &myHandle, NULL, FALSE, DUPLICATE_SAME_ACCESS))
                {
                    NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, sizeof(ObjectNameInfo), &RequiredSize);
                    ZeroMemory(HandleFullName, 0x1000);
                    if(pObjectNameInfo->Name.Length != NULL)
                    {
                        wcscpy((wchar_t*)HandleFullName, pObjectNameInfo->Name.Buffer);
                        NameFound = true;
                        if(TranslateName)
                        {
                            LPVOID tmpHandleFullName = TranslateNativeNameW((wchar_t*)HandleFullName);
                            if(tmpHandleFullName != NULL)
                            {
                                VirtualFree(HandleFullName, NULL, MEM_RELEASE);
                                HandleFullName = tmpHandleFullName;
                            }
                        }
                    }
                    EngineCloseHandle(myHandle);
                    break;
                }
            }
        }

        pHandle++;
    }

    if(!NameFound)
    {
        VirtualFree(HandleFullName, NULL, MEM_RELEASE);
        return(NULL);
    }
    else
    {
        return(HandleFullName);
    }
}
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName)
{
    wchar_t* name = (wchar_t*)HandlerGetHandleNameW(hProcess, ProcessId, hHandle, TranslateName);

    if(name)
    {
        LPVOID HandleFullName = VirtualAlloc(NULL, wcslen(name) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        WideCharToMultiByte(CP_ACP, NULL, name, -1, (LPSTR)HandleFullName, (int)wcslen(name) + 1, NULL, NULL);
        VirtualFree(name, NULL, MEM_RELEASE);

        return HandleFullName;
    }

    return 0;
}
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount)
{

    HANDLE myHandle = NULL;
    ULONG RequiredSize = NULL;
    ULONG TotalHandleCount = NULL;
    unsigned int HandleCount = NULL;
    PNTDLL_QUERY_HANDLE_INFO HandleInfo;

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;
    LPVOID QuerySystemBuffer = hinfo.GetPtr();

    RtlMoveMemory(&TotalHandleCount, QuerySystemBuffer, sizeof ULONG);
    QuerySystemBuffer = (LPVOID)((ULONG_PTR)QuerySystemBuffer + 4);
    HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)QuerySystemBuffer;
    while(TotalHandleCount > NULL)
    {
        if(HandleInfo->ProcessId == ProcessId && HandleCount < MaxHandleCount)
        {
            myHandle = (HANDLE)HandleInfo->hHandle;
            RtlMoveMemory(HandleBuffer, &myHandle, sizeof HANDLE);
            HandleBuffer = (LPVOID)((ULONG_PTR)HandleBuffer + sizeof HANDLE);
            HandleCount++;
        }
        HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)((ULONG_PTR)HandleInfo + sizeof NTDLL_QUERY_HANDLE_INFO);
        TotalHandleCount--;
    }
    return(HandleCount);
}
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn)
{

    HANDLE myHandle = NULL;
    ULONG RequiredSize = NULL;
    ULONG TotalHandleCount = NULL;
    PNTDLL_QUERY_HANDLE_INFO HandleInfo;
    OBJECT_BASIC_INFORMATION ObjectBasicInfo;
    char HandleFullData[0x1000] = {0};
    LPVOID HandleNameData = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);
    POBJECT_TYPE_INFORMATION pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)HandleFullData;
    bool DontFreeStringMemory = false;
    ULONG_PTR ReturnData = NULL;


    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;
    LPVOID QuerySystemBuffer = hinfo.GetPtr();

    RtlMoveMemory(&TotalHandleCount, QuerySystemBuffer, sizeof ULONG);
    QuerySystemBuffer = (LPVOID)((ULONG_PTR)QuerySystemBuffer + 4);
    HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)QuerySystemBuffer;
    while(TotalHandleCount > NULL)
    {
        if(HandleInfo->ProcessId == ProcessId && (HANDLE)HandleInfo->hHandle == hHandle)
        {
            if(DuplicateHandle(hProcess, hHandle, GetCurrentProcess(), &myHandle, NULL, false, DUPLICATE_SAME_ACCESS))
            {
                RtlZeroMemory(&ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION);
                NtQueryObject(myHandle, ObjectBasicInformation, &ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION, &RequiredSize);
                if(InformationReturn == UE_OPTION_HANDLER_RETURN_HANDLECOUNT)
                {
                    ReturnData = (ULONG_PTR)ObjectBasicInfo.HandleCount;
                }
                else if(InformationReturn == UE_OPTION_HANDLER_RETURN_ACCESS)
                {
                    ReturnData = (ULONG_PTR)HandleInfo->GrantedAccess;
                }
                else if(InformationReturn == UE_OPTION_HANDLER_RETURN_FLAGS)
                {
                    ReturnData = (ULONG_PTR)HandleInfo->Flags;
                }
                else if(InformationReturn == UE_OPTION_HANDLER_RETURN_TYPENAME)
                {
                    //if(!(HandleInfo->GrantedAccess & SYNCHRONIZE) || ((HandleInfo->GrantedAccess & SYNCHRONIZE) && ((WORD)HandleInfo->GrantedAccess != 0x19F9))){// && (WORD)HandleInfo->GrantedAccess != 0x89))){
                    if(HandleInfo->GrantedAccess != 0x0012019F)
                    {
                        RtlZeroMemory(HandleFullData, sizeof(HandleFullData));
                        NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, 8, &RequiredSize);
                        NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, RequiredSize, &RequiredSize);
                        RtlZeroMemory(HandleNameData, 0x1000);
                        if(pObjectTypeInfo->TypeName.Length != NULL)
                        {
                            WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectTypeInfo->TypeName.Buffer, -1, (LPSTR)HandleNameData, 0x1000, NULL, NULL);
                            ReturnData = (ULONG_PTR)HandleNameData;
                            DontFreeStringMemory = true;
                        }
                    }
                }
                else if(InformationReturn == UE_OPTION_HANDLER_RETURN_TYPENAME_UNICODE)
                {
                    //if(!(HandleInfo->GrantedAccess & SYNCHRONIZE) || ((HandleInfo->GrantedAccess & SYNCHRONIZE) && ((WORD)HandleInfo->GrantedAccess != 0x19F9))){// && (WORD)HandleInfo->GrantedAccess != 0x89))){
                    if(HandleInfo->GrantedAccess != 0x0012019F)
                    {
                        RtlZeroMemory(HandleFullData, sizeof(HandleFullData));
                        NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, 8, &RequiredSize);
                        NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, RequiredSize, &RequiredSize);
                        RtlZeroMemory(HandleNameData, 0x1000);
                        if(pObjectTypeInfo->TypeName.Length != NULL)
                        {
                            //WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectTypeInfo->TypeName.Buffer, -1, (LPSTR)HandleNameData, 0x1000, NULL, NULL);
                            lstrcpyW((wchar_t*)HandleNameData, (wchar_t*)pObjectTypeInfo->TypeName.Buffer);
                            ReturnData = (ULONG_PTR)HandleNameData;
                            DontFreeStringMemory = true;
                        }
                    }
                }
                EngineCloseHandle(myHandle);
                break;
            }
        }
        HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)((ULONG_PTR)HandleInfo + sizeof NTDLL_QUERY_HANDLE_INFO);
        TotalHandleCount--;
    }
    if(!DontFreeStringMemory)
    {
        VirtualFree(HandleNameData, NULL, MEM_RELEASE);
    }
    return(ReturnData);
}
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle)
{

    HANDLE myHandle;

    if(hProcess != NULL)
    {
        DuplicateHandle(hProcess, hHandle, GetCurrentProcess(), &myHandle, NULL, false, DUPLICATE_CLOSE_SOURCE);
        EngineCloseHandle(myHandle);
    }
    return false;
}
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount)
{

    wchar_t uniFileOrFolderName[MAX_PATH] = {};

    if(szFileOrFolderName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileOrFolderName, lstrlenA(szFileOrFolderName) + 1, uniFileOrFolderName, sizeof(uniFileOrFolderName) / (sizeof(uniFileOrFolderName[0])));
        return(HandlerEnumerateLockHandlesW(uniFileOrFolderName, NameIsFolder, NameIsTranslated, HandleDataBuffer, MaxHandleCount));
    }
    else
    {
        return(NULL);
    }
}
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount)
{

    int FoundHandles = NULL;
    HANDLE hProcess = NULL;
    HANDLE myHandle = NULL;
    HANDLE CopyHandle = NULL;
    ULONG RequiredSize = NULL;
    ULONG TotalHandleCount = NULL;
    DWORD LastProcessId = NULL;

    PNTDLL_QUERY_HANDLE_INFO HandleInfo;
    OBJECT_BASIC_INFORMATION ObjectBasicInfo;
    char ObjectNameInfo[0x2000] = {0};
    POBJECT_NAME_INFORMATION pObjectNameInfo = (POBJECT_NAME_INFORMATION)ObjectNameInfo;
    char HandleFullNameB[0x1000] = {0};
    LPVOID HandleFullName = HandleFullNameB;
    int LenFileOrFolderName = lstrlenW(szFileOrFolderName);
    LPVOID tmpHandleFullName = NULL;

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;
    LPVOID QuerySystemBuffer = hinfo.GetPtr();


    RtlMoveMemory(&TotalHandleCount, QuerySystemBuffer, sizeof ULONG);
    QuerySystemBuffer = (LPVOID)((ULONG_PTR)QuerySystemBuffer + 4);
    HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)QuerySystemBuffer;
    while(TotalHandleCount > NULL)
    {
        if(LastProcessId != HandleInfo->ProcessId)
        {
            if(hProcess != NULL)
            {
                EngineCloseHandle(hProcess);
            }
            hProcess = EngineOpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE, false, HandleInfo->ProcessId);
            LastProcessId = HandleInfo->ProcessId;
        }
        if(hProcess != NULL)
        {
            //if(!(HandleInfo->GrantedAccess & SYNCHRONIZE) || ((HandleInfo->GrantedAccess & SYNCHRONIZE) && ((WORD)HandleInfo->GrantedAccess != 0x19F9))){// && (WORD)HandleInfo->GrantedAccess != 0x89))){
            if(HandleInfo->GrantedAccess != 0x0012019F)
            {
                if(DuplicateHandle(hProcess, (HANDLE)HandleInfo->hHandle, GetCurrentProcess(), &myHandle, NULL, false, DUPLICATE_SAME_ACCESS))
                {
                    RtlZeroMemory(&ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION);
                    NtQueryObject(myHandle, ObjectBasicInformation, &ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION, &RequiredSize);
                    NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, 8, &RequiredSize);
                    NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, RequiredSize, &RequiredSize);
                    RtlZeroMemory(HandleFullName, 0x1000);
                    if(pObjectNameInfo->Name.Length != NULL)
                    {
                        //WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectNameInfo->Name.Buffer, -1, (LPSTR)HandleFullName, 0x1000, NULL, NULL);
                        lstrcpyW((wchar_t*)HandleFullName, (wchar_t*)pObjectNameInfo->Name.Buffer);
                        if(NameIsTranslated)
                        {
                            tmpHandleFullName = TranslateNativeNameW((wchar_t*)HandleFullName);
                            if(tmpHandleFullName != NULL)
                            {
                                HandleFullName = tmpHandleFullName;
                            }
                        }
                        if(NameIsFolder)
                        {
                            if(lstrlenW((LPCWSTR)HandleFullName) > LenFileOrFolderName)
                            {
                                RtlZeroMemory((LPVOID)((ULONG_PTR)HandleFullName + LenFileOrFolderName * 2), 2);
                            }
                        }
                        if(lstrcmpiW((LPCWSTR)HandleFullName, szFileOrFolderName) == NULL && MaxHandleCount > NULL)
                        {
                            RtlMoveMemory(HandleDataBuffer, &HandleInfo->ProcessId, sizeof ULONG);
                            HandleDataBuffer = (LPVOID)((ULONG_PTR)HandleDataBuffer + sizeof ULONG);
                            CopyHandle = (HANDLE)HandleInfo->hHandle;
                            RtlMoveMemory(HandleDataBuffer, &CopyHandle, sizeof HANDLE);
                            HandleDataBuffer = (LPVOID)((ULONG_PTR)HandleDataBuffer + sizeof HANDLE);
                            FoundHandles++;
                            MaxHandleCount--;
                        }
                    }
                    EngineCloseHandle(myHandle);
                }
            }
        }
        HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)((ULONG_PTR)HandleInfo + sizeof NTDLL_QUERY_HANDLE_INFO);
        TotalHandleCount--;
    }

    return(FoundHandles);
}
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated)
{

    wchar_t uniFileOrFolderName[MAX_PATH] = {};

    if(szFileOrFolderName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileOrFolderName, lstrlenA(szFileOrFolderName) + 1, uniFileOrFolderName, sizeof(uniFileOrFolderName) / (sizeof(uniFileOrFolderName[0])));
        return(HandlerCloseAllLockHandlesW(uniFileOrFolderName, NameIsFolder, NameIsTranslated));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated)
{

    bool AllHandled = true;
    HANDLE hProcess = NULL;
    HANDLE myHandle = NULL;
    HANDLE CopyHandle = NULL;
    ULONG RequiredSize = NULL;
    ULONG TotalHandleCount = NULL;
    DWORD LastProcessId = NULL;
    PNTDLL_QUERY_HANDLE_INFO HandleInfo;
    OBJECT_BASIC_INFORMATION ObjectBasicInfo;
    char ObjectNameInfo[0x2000] = {0};
    POBJECT_NAME_INFORMATION pObjectNameInfo = (POBJECT_NAME_INFORMATION)ObjectNameInfo;
    char HandleFullNameB[0x1000] = {0};
    LPVOID HandleFullName = HandleFullNameB;
    int LenFileOrFolderName = lstrlenW(szFileOrFolderName);
    LPVOID tmpHandleFullName = NULL;


    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;
    LPVOID QuerySystemBuffer = hinfo.GetPtr();


    RtlMoveMemory(&TotalHandleCount, QuerySystemBuffer, sizeof ULONG);
    QuerySystemBuffer = (LPVOID)((ULONG_PTR)QuerySystemBuffer + 4);
    HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)QuerySystemBuffer;
    while(TotalHandleCount > NULL)
    {
        if(LastProcessId != HandleInfo->ProcessId)
        {
            if(hProcess != NULL)
            {
                EngineCloseHandle(hProcess);
            }
            hProcess = EngineOpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE, false, HandleInfo->ProcessId);
            LastProcessId = HandleInfo->ProcessId;
        }
        if(hProcess != NULL)
        {
            //if(!(HandleInfo->GrantedAccess & SYNCHRONIZE) || ((HandleInfo->GrantedAccess & SYNCHRONIZE) && ((WORD)HandleInfo->GrantedAccess != 0x19F9))){// && (WORD)HandleInfo->GrantedAccess != 0x89))){
            if(HandleInfo->GrantedAccess != 0x0012019F)
            {
                if(DuplicateHandle(hProcess, (HANDLE)HandleInfo->hHandle, GetCurrentProcess(), &myHandle, NULL, false, DUPLICATE_SAME_ACCESS))
                {
                    RtlZeroMemory(&ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION);
                    NtQueryObject(myHandle, ObjectBasicInformation, &ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION, &RequiredSize);
                    NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, 8, &RequiredSize);
                    NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, RequiredSize, &RequiredSize);
                    RtlZeroMemory(HandleFullName, 0x1000);
                    if(pObjectNameInfo->Name.Length != NULL)
                    {
                        //WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectNameInfo->Name.Buffer, -1, (LPSTR)HandleFullName, 0x1000, NULL, NULL);
                        lstrcpyW((wchar_t*)HandleFullName, (wchar_t*)pObjectNameInfo->Name.Buffer);
                        if(NameIsTranslated)
                        {
                            tmpHandleFullName = TranslateNativeNameW((wchar_t*)HandleFullName);
                            if(tmpHandleFullName != NULL)
                            {
                                HandleFullName = tmpHandleFullName;
                            }
                        }
                        if(NameIsFolder)
                        {
                            if(lstrlenW((LPCWSTR)HandleFullName) > LenFileOrFolderName)
                            {
                                RtlZeroMemory((LPVOID)((ULONG_PTR)HandleFullName + LenFileOrFolderName * 2), 2);
                            }
                        }
                        if(lstrcmpiW((LPCWSTR)HandleFullName, szFileOrFolderName) == NULL)
                        {
                            if(!HandlerCloseRemoteHandle(hProcess, (HANDLE)HandleInfo->hHandle))
                            {
                                AllHandled = false;
                            }
                        }
                    }
                    EngineCloseHandle(myHandle);
                }
            }
        }
        HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)((ULONG_PTR)HandleInfo + sizeof NTDLL_QUERY_HANDLE_INFO);
        TotalHandleCount--;
    }

    return AllHandled;
}
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated)
{

    wchar_t uniFileOrFolderName[MAX_PATH] = {};

    if(szFileOrFolderName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileOrFolderName, lstrlenA(szFileOrFolderName) + 1, uniFileOrFolderName, sizeof(uniFileOrFolderName) / (sizeof(uniFileOrFolderName[0])));
        return(HandlerIsFileLockedW(uniFileOrFolderName, NameIsFolder, NameIsTranslated));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated)
{

    HANDLE hProcess = NULL;
    HANDLE myHandle = NULL;
    HANDLE CopyHandle = NULL;
    ULONG RequiredSize = NULL;
    ULONG TotalHandleCount = NULL;
    DWORD LastProcessId = NULL;

    PNTDLL_QUERY_HANDLE_INFO HandleInfo;
    OBJECT_BASIC_INFORMATION ObjectBasicInfo;
    char ObjectNameInfo[0x2000] = {0};
    POBJECT_NAME_INFORMATION pObjectNameInfo = (POBJECT_NAME_INFORMATION)ObjectNameInfo;
    char HandleFullNameB[0x1000] = {0};
    LPVOID HandleFullName = HandleFullNameB;
    int LenFileOrFolderName = lstrlenW(szFileOrFolderName);
    LPVOID tmpHandleFullName = NULL;

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;
    LPVOID QuerySystemBuffer = hinfo.GetPtr();


    RtlMoveMemory(&TotalHandleCount, QuerySystemBuffer, sizeof ULONG);
    QuerySystemBuffer = (LPVOID)((ULONG_PTR)QuerySystemBuffer + 4);
    HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)QuerySystemBuffer;
    while(TotalHandleCount > NULL)
    {
        if(LastProcessId != HandleInfo->ProcessId)
        {
            if(hProcess != NULL)
            {
                EngineCloseHandle(hProcess);
            }
            hProcess = EngineOpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE, false, HandleInfo->ProcessId);
            LastProcessId = HandleInfo->ProcessId;
        }
        if(hProcess != NULL)
        {
            //if(!(HandleInfo->GrantedAccess & SYNCHRONIZE) || ((HandleInfo->GrantedAccess & SYNCHRONIZE) && ((WORD)HandleInfo->GrantedAccess != 0x19F9))){// && (WORD)HandleInfo->GrantedAccess != 0x89))){
            if(HandleInfo->GrantedAccess != 0x0012019F)
            {
                if(DuplicateHandle(hProcess, (HANDLE)HandleInfo->hHandle, GetCurrentProcess(), &myHandle, NULL, false, DUPLICATE_SAME_ACCESS))
                {
                    RtlZeroMemory(&ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION);
                    NtQueryObject(myHandle, ObjectBasicInformation, &ObjectBasicInfo, sizeof OBJECT_BASIC_INFORMATION, &RequiredSize);
                    NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, 8, &RequiredSize);
                    NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, RequiredSize, &RequiredSize);
                    RtlZeroMemory(HandleFullName, 0x1000);
                    if(pObjectNameInfo->Name.Length != NULL)
                    {
                        //WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectNameInfo->Name.Buffer, -1, (LPSTR)HandleFullName, 0x1000, NULL, NULL);
                        lstrcpyW((wchar_t*)HandleFullName, (wchar_t*)pObjectNameInfo->Name.Buffer);
                        if(NameIsTranslated)
                        {
                            tmpHandleFullName = TranslateNativeNameW((wchar_t*)HandleFullName);
                            if(tmpHandleFullName != NULL)
                            {
                                HandleFullName = tmpHandleFullName;
                            }
                        }
                        if(NameIsFolder)
                        {
                            if(lstrlenW((LPCWSTR)HandleFullName) > LenFileOrFolderName)
                            {
                                RtlZeroMemory((LPVOID)((ULONG_PTR)HandleFullName + LenFileOrFolderName * 2), 2);
                            }
                        }
                        if(lstrcmpiW((LPCWSTR)HandleFullName, szFileOrFolderName) == NULL)
                        {
                            EngineCloseHandle(myHandle);
                            return true;
                        }
                    }
                    EngineCloseHandle(myHandle);
                }
            }
        }
        HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)((ULONG_PTR)HandleInfo + sizeof NTDLL_QUERY_HANDLE_INFO);
        TotalHandleCount--;
    }
    return false;

}
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount)
{

    HANDLE myHandle = NULL;
    HANDLE copyHandle = NULL;
    ULONG RequiredSize = NULL;
    ULONG TotalHandleCount = NULL;
    unsigned int HandleCount = NULL;

    PNTDLL_QUERY_HANDLE_INFO HandleInfo;
    char HandleFullData[0x1000] = {0};
    char HandleNameDataB[0x1000] = {0};
    LPVOID HandleNameData = HandleNameDataB;
    POBJECT_TYPE_INFORMATION pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)HandleFullData;

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;
    LPVOID QuerySystemBuffer = hinfo.GetPtr();

    RtlMoveMemory(&TotalHandleCount, QuerySystemBuffer, sizeof ULONG);
    QuerySystemBuffer = (LPVOID)((ULONG_PTR)QuerySystemBuffer + 4);
    HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)QuerySystemBuffer;
    while(TotalHandleCount > NULL)
    {
        if(HandleInfo->ProcessId == ProcessId && HandleCount < MaxHandleCount)
        {
            //if(!(HandleInfo->GrantedAccess & SYNCHRONIZE) || ((HandleInfo->GrantedAccess & SYNCHRONIZE) && ((WORD)HandleInfo->GrantedAccess != 0x19F9))){// && (WORD)HandleInfo->GrantedAccess != 0x89))){
            if(HandleInfo->GrantedAccess != 0x0012019F)
            {
                if(DuplicateHandle(hProcess, (HANDLE)HandleInfo->hHandle, GetCurrentProcess(), &myHandle, NULL, false, DUPLICATE_SAME_ACCESS))
                {
                    RtlZeroMemory(HandleFullData, sizeof(HandleFullData));
                    NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, 8, &RequiredSize);
                    NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, RequiredSize, &RequiredSize);
                    RtlZeroMemory(HandleNameData, 0x1000);
                    if(pObjectTypeInfo->TypeName.Length != NULL)
                    {
                        WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectTypeInfo->TypeName.Buffer, -1, (LPSTR)HandleNameData, 0x1000, NULL, NULL);
                        if(lstrcmpiA((LPCSTR)HandleNameData, "Mutant") == NULL)
                        {
                            copyHandle = (HANDLE)HandleInfo->hHandle;
                            RtlMoveMemory(HandleBuffer, &copyHandle, sizeof HANDLE);
                            HandleBuffer = (LPVOID)((ULONG_PTR)HandleBuffer + sizeof HANDLE);
                            HandleCount++;
                        }
                    }
                    EngineCloseHandle(myHandle);
                }
            }
        }
        HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)((ULONG_PTR)HandleInfo + sizeof NTDLL_QUERY_HANDLE_INFO);
        TotalHandleCount--;
    }
    return(HandleCount);

}
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, char* szMutexString)
{

    wchar_t uniMutexString[MAX_PATH] = {};

    if(szMutexString != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szMutexString, lstrlenA(szMutexString) + 1, uniMutexString, sizeof(uniMutexString) / (sizeof(uniMutexString[0])));
        return((ULONG_PTR)HandlerGetOpenMutexHandleW(hProcess, ProcessId, uniMutexString));
    }
    else
    {
        return(NULL);
    }
}
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, wchar_t* szMutexString)
{
    if(!szMutexString || lstrlenW(szMutexString) >= 512)
        return 0;
    int i;
    HANDLE myHandle;
    char HandleBuffer[0x1000] = {0};
    LPVOID cHandleBuffer = HandleBuffer;
    int OpenHandleCount = HandlerEnumerateOpenMutexes(hProcess, ProcessId, HandleBuffer, 0x1000 / sizeof HANDLE);
    wchar_t RealMutexName[512] = L"\\BaseNamedObjects\\";
    wchar_t* HandleName;

    if(OpenHandleCount > NULL)
    {
        lstrcatW(RealMutexName, szMutexString);
        for(i = 0; i < OpenHandleCount; i++)
        {
            RtlMoveMemory(&myHandle, cHandleBuffer, sizeof HANDLE);
            HandleName = (wchar_t*)HandlerGetHandleNameW(hProcess, ProcessId, myHandle, true);
            if(HandleName != NULL)
            {
                if(lstrcmpiW(HandleName, RealMutexName) == NULL)
                {
                    return((ULONG_PTR)myHandle);
                }
            }
            cHandleBuffer = (LPVOID)((ULONG_PTR)cHandleBuffer + sizeof HANDLE);
        }
    }
    return(NULL);
}
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(char* szMutexString)
{
    wchar_t uniMutexString[MAX_PATH] = {0};

    if(szMutexString != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szMutexString, -1, uniMutexString, _countof(uniMutexString));
        return(HandlerGetProcessIdWhichCreatedMutexW(uniMutexString));
    }
    else
    {
        return(NULL);
    }
}
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(wchar_t* szMutexString)
{
    if(!szMutexString || wcslen(szMutexString) >= 450)
        return 0;
    HANDLE hProcess = NULL;
    DWORD ReturnData = NULL;
    HANDLE myHandle = NULL;
    ULONG RequiredSize = NULL;
    DWORD LastProcessId = NULL;
    ULONG TotalHandleCount = NULL;
    PNTDLL_QUERY_HANDLE_INFO HandleInfo;
    char HandleFullData[0x1000] = {0};
    char HandleNameData[0x1000] = {0};
    POBJECT_TYPE_INFORMATION pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)HandleFullData;
    char ObjectNameInfo[0x2000] = {0};
    POBJECT_NAME_INFORMATION pObjectNameInfo = (POBJECT_NAME_INFORMATION)ObjectNameInfo;
    wchar_t RealMutexName[512] = L"\\BaseNamedObjects\\";


    lstrcatW(RealMutexName, szMutexString);

    DynBuf hinfo;
    if(!NtQuerySysHandleInfo(hinfo))
        return 0;
    LPVOID QuerySystemBuffer = hinfo.GetPtr();

    RtlMoveMemory(&TotalHandleCount, QuerySystemBuffer, sizeof ULONG);
    QuerySystemBuffer = (LPVOID)((ULONG_PTR)QuerySystemBuffer + 4);
    HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)QuerySystemBuffer;
    while(TotalHandleCount > NULL)
    {
        if(LastProcessId != HandleInfo->ProcessId)
        {
            if(hProcess != NULL)
            {
                EngineCloseHandle(hProcess);
            }
            hProcess = EngineOpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE, FALSE, HandleInfo->ProcessId);
            LastProcessId = HandleInfo->ProcessId;
        }
        if(hProcess != NULL)
        {
            //if(!(HandleInfo->GrantedAccess & SYNCHRONIZE) || ((HandleInfo->GrantedAccess & SYNCHRONIZE) && ((WORD)HandleInfo->GrantedAccess != 0x19F9))){// && (WORD)HandleInfo->GrantedAccess != 0x89))){
            if(HandleInfo->GrantedAccess != 0x0012019F)
            {
                if(DuplicateHandle(hProcess, (HANDLE)HandleInfo->hHandle, GetCurrentProcess(), &myHandle, NULL, false, DUPLICATE_SAME_ACCESS))
                {
                    RtlZeroMemory(HandleFullData, sizeof(HandleFullData));
                    NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, 8, &RequiredSize);
                    NtQueryObject(myHandle, ObjectTypeInformation, HandleFullData, RequiredSize, &RequiredSize);
                    RtlZeroMemory(HandleNameData, sizeof(HandleNameData));
                    if(pObjectTypeInfo->TypeName.Length != NULL)
                    {
                        //WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectTypeInfo->TypeName.Buffer, -1, (LPSTR)HandleNameData, 0x1000, NULL, NULL);
                        lstrcpyW((wchar_t*)HandleNameData, (wchar_t*)pObjectNameInfo->Name.Buffer);
                        if(lstrcmpiW((LPCWSTR)HandleNameData, L"Mutant") == NULL)
                        {
                            NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, 8, &RequiredSize);
                            NtQueryObject(myHandle, ObjectNameInformation, ObjectNameInfo, RequiredSize, &RequiredSize);
                            RtlZeroMemory(HandleNameData, sizeof(HandleNameData));
                            if(pObjectNameInfo->Name.Length != NULL)
                            {
                                //WideCharToMultiByte(CP_ACP, NULL, (LPCWSTR)pObjectNameInfo->Name.Buffer, -1, (LPSTR)HandleNameData, 0x1000, NULL, NULL);
                                lstrcpyW((wchar_t*)HandleNameData, (wchar_t*)pObjectNameInfo->Name.Buffer);
                                if(lstrcmpiW((LPCWSTR)HandleNameData, RealMutexName) == NULL)
                                {
                                    ReturnData = HandleInfo->ProcessId;
                                    break;
                                }
                            }
                        }
                    }
                    EngineCloseHandle(myHandle);
                }
            }
        }
        HandleInfo = (PNTDLL_QUERY_HANDLE_INFO)((ULONG_PTR)HandleInfo + sizeof NTDLL_QUERY_HANDLE_INFO);
        TotalHandleCount--;
    }
    return(ReturnData);

}



================================================
File: TitanEngine/TitanEngine.Hider.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.Hider.h"

// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess)
{
    ULONG RequiredLen = 0;
    void* PebAddress = 0;
    PROCESS_BASIC_INFORMATION myProcessBasicInformation[5] = {0};

    if(NtQueryInformationProcess(hProcess, ProcessBasicInformation, myProcessBasicInformation, sizeof(PROCESS_BASIC_INFORMATION), &RequiredLen) == STATUS_SUCCESS)
    {
        PebAddress = (void*)myProcessBasicInformation->PebBaseAddress;
    }
    else
    {
        if(NtQueryInformationProcess(hProcess, ProcessBasicInformation, myProcessBasicInformation, RequiredLen, &RequiredLen) == STATUS_SUCCESS)
        {
            PebAddress = (void*)myProcessBasicInformation->PebBaseAddress;
        }
    }

    return PebAddress;
}

__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread)
{
    ULONG RequiredLen = 0;
    void* TebAddress = 0;
    THREAD_BASIC_INFORMATION myThreadBasicInformation[5] = {0};

    if(NtQueryInformationThread(hThread, ThreadBasicInformation, myThreadBasicInformation, sizeof(THREAD_BASIC_INFORMATION), &RequiredLen) == STATUS_SUCCESS)
    {
        TebAddress = (void*)myThreadBasicInformation->TebBaseAddress;
    }
    else
    {
        if(NtQueryInformationThread(hThread, ThreadBasicInformation, myThreadBasicInformation, RequiredLen, &RequiredLen) == STATUS_SUCCESS)
        {
            TebAddress = (void*)myThreadBasicInformation->TebBaseAddress;
        }
    }

    return TebAddress;
}

__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread)
{
    //TODO: this might return garbage on Windows 10
#ifndef _WIN64
    if(IsThisProcessWow64())
    {
        //Only WOW64 processes have 2 PEBs and 2 TEBs
        DWORD teb32 = (DWORD)GetTEBLocation(hThread);
        if(teb32)
        {
            teb32 -= 0x2000; //TEB64 before TEB32
            return (void*)teb32;
        }
    }
#endif //_WIN64
    return 0;
}

__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess)
{
    void* PebAddress = 0;
#ifndef _WIN64
    if(IsThisProcessWow64())
    {
        typedef NTSTATUS(WINAPI * t_NtWow64QueryInformationProcess64)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
        static auto _NtWow64QueryInformationProcess64 = (t_NtWow64QueryInformationProcess64)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtWow64QueryInformationProcess64");
        if(_NtWow64QueryInformationProcess64)
        {
            struct PROCESS_BASIC_INFORMATION64
            {
                DWORD ExitStatus;
                DWORD64 PebBaseAddress;
                DWORD64 AffinityMask;
                DWORD BasePriority;
                DWORD64 UniqueProcessId;
                DWORD64 InheritedFromUniqueProcessId;
            } myProcessBasicInformation[5];

            ULONG RequiredLen = 0;

            if(_NtWow64QueryInformationProcess64(hProcess, ProcessBasicInformation, myProcessBasicInformation, sizeof(PROCESS_BASIC_INFORMATION64), &RequiredLen) == STATUS_SUCCESS)
            {
                PebAddress = (void*)myProcessBasicInformation->PebBaseAddress;
            }
            else
            {
                if(_NtWow64QueryInformationProcess64(hProcess, ProcessBasicInformation, myProcessBasicInformation, RequiredLen, &RequiredLen) == STATUS_SUCCESS)
                {
                    PebAddress = (void*)myProcessBasicInformation->PebBaseAddress;
                }
            }
        }
    }
#endif //_WIN64
    return PebAddress;
}

__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel)
{
    return ChangeHideDebuggerState(hProcess, PatchAPILevel, true);
}

__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel)
{
    return ChangeHideDebuggerState(hProcess, PatchAPILevel, false);
}



================================================
File: TitanEngine/TitanEngine.Hooks.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Debugger.h"
#include "Global.Threader.h"
#include "Global.Engine.h"
#include "Global.Handle.h"
#include "Global.Mapping.h"

// Global.Engine.Hooks:
static std::vector<HOOK_ENTRY> hookEntry;
static DWORD buffPatchedEntrySize = 0x3000;
static void* CwpBuffPatchedEntry;
static void* buffPatchedEntry;

// Internal.Engine.Hook.functions:
static bool ProcessHookScanAddNewHook(PHOOK_ENTRY HookDetails, void* ptrOriginalInstructions, PLIBRARY_ITEM_DATAW ModuleInformation, DWORD SizeOfImage)
{
    HOOK_ENTRY MyhookEntry = {};

    RtlMoveMemory(&MyhookEntry, HookDetails, sizeof HOOK_ENTRY);
    hookEntry.push_back(MyhookEntry);
    return true;
}

// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart)
{
    if(dbgProcessInformation.hProcess == NULL) //TODO: check
    {
        if(!TransitionStart || ThreaderImportRunningThreadData(GetCurrentProcessId()))
        {
            int threadcount = (int)hListThread.size();
            for(int i = 0; i < threadcount; i++)
            {
                PTHREAD_ITEM_DATA hListThreadPtr = &hListThread.at(i);
                if(hListThreadPtr->hThread != INVALID_HANDLE_VALUE)
                {
                    if(TransitionStart)
                    {
                        if(hListThreadPtr->dwThreadId != GetCurrentThreadId())
                        {
                            SuspendThread(hListThreadPtr->hThread);
                            ULONG_PTR CurrentIP = (ULONG_PTR)GetContextDataEx(hListThreadPtr->hThread, UE_CIP);
                            PMEMORY_COMPARE_HANDLER myHookAddressArray = (PMEMORY_COMPARE_HANDLER)HookAddressArray;
                            for(int j = 0; j < NumberOfHooks; j++)
                            {
#if defined (_WIN64)
                                ULONG_PTR HookAddress = (ULONG_PTR)myHookAddressArray->Array.qwArrayEntry[0];
                                myHookAddressArray = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)myHookAddressArray + sizeof ULONG_PTR);
#else
                                ULONG_PTR HookAddress = (ULONG_PTR)myHookAddressArray->Array.dwArrayEntry[0];
                                myHookAddressArray = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)myHookAddressArray + sizeof ULONG_PTR);
#endif
                                while(CurrentIP >= (ULONG_PTR)HookAddress && CurrentIP <= (ULONG_PTR)HookAddress + 5)
                                {
                                    ResumeThread(hListThreadPtr->hThread);
                                    Sleep(5);
                                    SuspendThread(hListThreadPtr->hThread);
                                    CurrentIP = (ULONG_PTR)GetContextDataEx(hListThreadPtr->hThread, UE_CIP);
                                    j = 0;
                                }
                            }
                        }
                    }
                    else
                    {
                        ResumeThread(hListThreadPtr->hThread);
                        EngineCloseHandle(hListThreadPtr->hThread);
                    }
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart)
{
    void* aHookAddress[1];
    aHookAddress[0] = HookAddress;

    return(HooksSafeTransitionEx(&aHookAddress[0], sizeof aHookAddress, TransitionStart));
}

__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress)
{
    for(unsigned int i = 0; i < hookEntry.size(); i++)
    {
        if(hookEntry[i].HookAddress == HookAddress && hookEntry[i].IATHook == false && hookEntry[i].HookIsEnabled == true)
        {
            return true;
        }
    }
    return false;
}

__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress)
{
    for(unsigned int i = 0; i < hookEntry.size(); i++)
    {
        if(hookEntry[i].HookAddress == HookAddress)
        {
            return(hookEntry[i].PatchedEntry);
        }
    }
    return(NULL);
}

__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress)
{
    for(unsigned int i = 0; i < hookEntry.size(); i++)
    {
        if(hookEntry[i].HookAddress == HookAddress)
        {
            return(&hookEntry[i]);
        }
    }
    return(NULL);
}

__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType)
{
#if !defined(_WIN64)
    int j;
    unsigned int i;
#endif
    HOOK_ENTRY myHook = {};
    DWORD CalculatedRealingJump;
    ULONG_PTR x64CalculatedRealingJump;
    ULONG_PTR RealignAddressTarget;
    int ProcessedBufferSize = NULL;
    int CurrentInstructionSize = NULL;
    PMEMORY_COMPARE_HANDLER WriteMemory = (PMEMORY_COMPARE_HANDLER)CwpBuffPatchedEntry;
    PMEMORY_COMPARE_HANDLER CompareMemory;
#if !defined(_WIN64)
    PMEMORY_COMPARE_HANDLER RelocateMemory;
#endif
    void* cHookAddress = HookAddress;
    DWORD OldProtect = PAGE_READONLY;
    void* TempBuffPatchedEntry;
    bool returnData;

    x64CalculatedRealingJump = NULL;
    if(buffPatchedEntry == NULL || (ULONG_PTR)CwpBuffPatchedEntry - (ULONG_PTR)buffPatchedEntry + TEE_MAXIMUM_HOOK_SIZE > buffPatchedEntrySize)
    {
        buffPatchedEntrySize = buffPatchedEntrySize + 0x1000;
        CwpBuffPatchedEntry = (void*)((ULONG_PTR)CwpBuffPatchedEntry - (ULONG_PTR)buffPatchedEntry);
        TempBuffPatchedEntry = VirtualAlloc(NULL, buffPatchedEntrySize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if(TempBuffPatchedEntry != NULL)
        {
            if(hookEntry.size() > NULL)
            {
                RtlMoveMemory(TempBuffPatchedEntry, buffPatchedEntry, (ULONG_PTR)CwpBuffPatchedEntry);
            }
#if !defined(_WIN64)
            for(i = 0; i < hookEntry.size(); i++)
            {
                hookEntry[i].PatchedEntry = (void*)((ULONG_PTR)hookEntry[i].PatchedEntry - (ULONG_PTR)buffPatchedEntry + (ULONG_PTR)TempBuffPatchedEntry);
                CalculatedRealingJump = (DWORD)((ULONG_PTR)hookEntry[i].PatchedEntry - (ULONG_PTR)hookEntry[i].HookAddress - 5);
                RtlMoveMemory(&hookEntry[i].HookBytes[1], &CalculatedRealingJump, 4);
                if(hookEntry[i].RelocationCount > NULL)
                {
                    for(j = 0; j < hookEntry[i].RelocationCount; j++)
                    {
                        CompareMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)buffPatchedEntry + hookEntry[i].RelocationInfo[j]);
                        RelocateMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)TempBuffPatchedEntry + hookEntry[i].RelocationInfo[j]);
                        CurrentInstructionSize = StaticLengthDisassemble((void*)CompareMemory);
                        RealignAddressTarget = (ULONG_PTR)GetJumpDestination(GetCurrentProcess(), (ULONG_PTR)CompareMemory);
                        if(RealignAddressTarget != NULL)
                        {
                            if(CompareMemory->Array.bArrayEntry[0] == 0xE9 && CurrentInstructionSize == 5)
                            {
                                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)RelocateMemory - CurrentInstructionSize);
                                RtlMoveMemory(&RelocateMemory->Array.bArrayEntry[1], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                            }
                            else if(CompareMemory->Array.bArrayEntry[0] >= 0x70 && CompareMemory->Array.bArrayEntry[0] <= 0x7F && CurrentInstructionSize == 2)
                            {
                                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)RelocateMemory - CurrentInstructionSize);
                                RtlMoveMemory(&RelocateMemory->Array.bArrayEntry[2], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                            }
                            else if(CompareMemory->Array.bArrayEntry[0] == 0x0F && CompareMemory->Array.bArrayEntry[1] >= 0x80 && CompareMemory->Array.bArrayEntry[1] <= 0x8F && CurrentInstructionSize == 6)
                            {
                                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)RelocateMemory - CurrentInstructionSize);
                                RtlMoveMemory(&RelocateMemory->Array.bArrayEntry[2], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                            }
                            else if(CompareMemory->Array.bArrayEntry[0] == 0xE8 && CurrentInstructionSize == 5)
                            {
                                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)RelocateMemory - CurrentInstructionSize);
                                RtlMoveMemory(&RelocateMemory->Array.bArrayEntry[1], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                            }
                        }
                    }
                }
            }
#endif
            if(hookEntry.size() > NULL)
            {
                VirtualFree(buffPatchedEntry, NULL, MEM_RELEASE);
            }
            CwpBuffPatchedEntry = (void*)((ULONG_PTR)CwpBuffPatchedEntry + (ULONG_PTR)TempBuffPatchedEntry);
            WriteMemory = (PMEMORY_COMPARE_HANDLER)CwpBuffPatchedEntry;
            buffPatchedEntry = TempBuffPatchedEntry;
        }
    }
    while(ProcessedBufferSize < TEE_MAXIMUM_HOOK_INSERT_SIZE)
    {
        CompareMemory = (PMEMORY_COMPARE_HANDLER)cHookAddress;
        CurrentInstructionSize = StaticLengthDisassemble(cHookAddress);
        RealignAddressTarget = (ULONG_PTR)GetJumpDestination(GetCurrentProcess(), (ULONG_PTR)cHookAddress);
        if(RealignAddressTarget != NULL)
        {
            if(CompareMemory->Array.bArrayEntry[0] == 0xE9 && CurrentInstructionSize == 5)
            {
                if(cHookAddress == HookAddress)
                {
                    if(HooksIsAddressRedirected(HookAddress))
                    {
                        if(HooksRemoveRedirection(HookAddress, false))
                        {
                            returnData = HooksInsertNewRedirection(HookAddress, RedirectTo, HookType);
                            if(returnData)
                            {
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)WriteMemory - CurrentInstructionSize);
                WriteMemory->Array.bArrayEntry[0] = 0xE9;
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[1], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                myHook.RelocationInfo[myHook.RelocationCount] = (DWORD)((ULONG_PTR)WriteMemory - (ULONG_PTR)buffPatchedEntry);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + CurrentInstructionSize);
                myHook.RelocationCount++;
            }
            else if(CompareMemory->Array.bArrayEntry[0] == 0xEB && CurrentInstructionSize == 2)
            {
                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)WriteMemory - 5);
                WriteMemory->Array.bArrayEntry[0] = 0xE9;
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[1], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                myHook.RelocationInfo[myHook.RelocationCount] = (DWORD)((ULONG_PTR)WriteMemory - (ULONG_PTR)buffPatchedEntry);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + 5);
                myHook.RelocationCount++;
            }
            else if(CompareMemory->Array.bArrayEntry[0] >= 0x70 && CompareMemory->Array.bArrayEntry[0] <= 0x7F && CurrentInstructionSize == 2)
            {
#if !defined(_WIN64)
                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)WriteMemory - 6);
                WriteMemory->Array.bArrayEntry[0] = 0x0F;
                WriteMemory->Array.bArrayEntry[1] = CompareMemory->Array.bArrayEntry[0] + 0x10;
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[2], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                myHook.RelocationInfo[myHook.RelocationCount] = (DWORD)((ULONG_PTR)WriteMemory - (ULONG_PTR)buffPatchedEntry);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + 6);
                myHook.RelocationCount++;
#else
                x64CalculatedRealingJump = RealignAddressTarget;
                WriteMemory->Array.bArrayEntry[0] = CompareMemory->Array.bArrayEntry[0];
                WriteMemory->Array.bArrayEntry[1] = 0x02;
                WriteMemory->Array.bArrayEntry[2] = 0xEB;
                WriteMemory->Array.bArrayEntry[3] = 0x0E;
                WriteMemory->Array.bArrayEntry[4] = 0xFF;
                WriteMemory->Array.bArrayEntry[5] = 0x25;
                RtlZeroMemory(&WriteMemory->Array.bArrayEntry[6], 4);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[10], &x64CalculatedRealingJump, sizeof x64CalculatedRealingJump);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + 18);
#endif
            }
            else if(CompareMemory->Array.bArrayEntry[0] == 0x0F && CompareMemory->Array.bArrayEntry[1] >= 0x80 && CompareMemory->Array.bArrayEntry[1] <= 0x8F && CurrentInstructionSize == 6)
            {
#if !defined(_WIN64)
                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)WriteMemory - CurrentInstructionSize);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[0], &CompareMemory->Array.bArrayEntry[0], 2);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[2], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                myHook.RelocationInfo[myHook.RelocationCount] = (DWORD)((ULONG_PTR)WriteMemory - (ULONG_PTR)buffPatchedEntry);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + CurrentInstructionSize);
                myHook.RelocationCount++;
#else
                x64CalculatedRealingJump = RealignAddressTarget;
                WriteMemory->Array.bArrayEntry[0] = CompareMemory->Array.bArrayEntry[0];
                WriteMemory->Array.bArrayEntry[1] = CompareMemory->Array.bArrayEntry[1];
                WriteMemory->Array.bArrayEntry[2] = 0x02;
                WriteMemory->Array.bArrayEntry[3] = 0x00;
                WriteMemory->Array.bArrayEntry[4] = 0x00;
                WriteMemory->Array.bArrayEntry[5] = 0x00;
                WriteMemory->Array.bArrayEntry[6] = 0xEB;
                WriteMemory->Array.bArrayEntry[7] = 0x0E;
                WriteMemory->Array.bArrayEntry[8] = 0xFF;
                WriteMemory->Array.bArrayEntry[9] = 0x25;
                RtlZeroMemory(&WriteMemory->Array.bArrayEntry[10], 4);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[14], &x64CalculatedRealingJump, sizeof x64CalculatedRealingJump);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + 22);
#endif
            }
            else if(CompareMemory->Array.bArrayEntry[0] == 0xE8 && CurrentInstructionSize == 5)
            {
                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)WriteMemory - CurrentInstructionSize);
                WriteMemory->Array.bArrayEntry[0] = 0xE8;
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[1], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                myHook.RelocationInfo[myHook.RelocationCount] = (DWORD)((ULONG_PTR)WriteMemory - (ULONG_PTR)buffPatchedEntry);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + CurrentInstructionSize);
                myHook.RelocationCount++;
#if defined(_WIN64)
            }
            else if(CompareMemory->Array.bArrayEntry[0] == 0xFF && (CompareMemory->Array.bArrayEntry[1] == 0x15 || CompareMemory->Array.bArrayEntry[1] == 0x25) && CurrentInstructionSize == 6)
            {
                CalculatedRealingJump = (DWORD)((ULONG_PTR)RealignAddressTarget - (ULONG_PTR)WriteMemory - CurrentInstructionSize);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[0], &CompareMemory->Array.bArrayEntry[0], 2);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[2], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + CurrentInstructionSize);
#endif
            }
            else
            {
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[0], cHookAddress, CurrentInstructionSize);
                WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + CurrentInstructionSize);
            }
        }
        else
        {
            RtlMoveMemory(&WriteMemory->Array.bArrayEntry[0], cHookAddress, CurrentInstructionSize);
            WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + CurrentInstructionSize);
        }
        cHookAddress = (void*)((ULONG_PTR)cHookAddress + CurrentInstructionSize);
        ProcessedBufferSize = ProcessedBufferSize + CurrentInstructionSize;
    }
    if(ProcessedBufferSize >= TEE_MAXIMUM_HOOK_INSERT_SIZE)
    {
        WriteMemory->Array.bArrayEntry[0] = 0xFF;
        WriteMemory->Array.bArrayEntry[1] = 0x25;
#if !defined(_WIN64)
        CalculatedRealingJump = (DWORD)((ULONG_PTR)WriteMemory + 6);
#else
        CalculatedRealingJump = NULL;
#endif
        RtlMoveMemory(&WriteMemory->Array.bArrayEntry[2], &CalculatedRealingJump, sizeof CalculatedRealingJump);
        RtlMoveMemory(&WriteMemory->Array.bArrayEntry[6], &cHookAddress, sizeof CalculatedRealingJump);
        WriteMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)WriteMemory + 6 + sizeof ULONG_PTR);
        myHook.HookIsEnabled = true;
        myHook.HookType = (BYTE)HookType;
        myHook.HookAddress = HookAddress;
        myHook.RedirectionAddress = RedirectTo;
        myHook.PatchedEntry = CwpBuffPatchedEntry;
        myHook.HookSize = TEE_MAXIMUM_HOOK_SIZE;
        RtlMoveMemory(&myHook.OriginalBytes[0], HookAddress, TEE_MAXIMUM_HOOK_SIZE);
        CalculatedRealingJump = (DWORD)((ULONG_PTR)RedirectTo - (ULONG_PTR)HookAddress);
        CwpBuffPatchedEntry = (void*)((ULONG_PTR)WriteMemory);
        WriteMemory = (PMEMORY_COMPARE_HANDLER)HookAddress;
        if(HookType == TEE_HOOK_NRM_JUMP)
        {
#if !defined(_WIN64)
            CalculatedRealingJump = CalculatedRealingJump - 5;
            if(VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
            {
                WriteMemory->Array.bArrayEntry[0] = 0xE9;
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[1], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                RtlMoveMemory(&myHook.HookBytes[0], HookAddress, TEE_MAXIMUM_HOOK_SIZE);
                VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                hookEntry.push_back(myHook);
                return true;
            }
#else
            if(VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
            {
                WriteMemory->Array.bArrayEntry[0] = 0xFF;
                WriteMemory->Array.bArrayEntry[1] = 0x25;
                RtlZeroMemory(&WriteMemory->Array.bArrayEntry[2], 4);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[6], &RedirectTo, sizeof RedirectTo);
                RtlMoveMemory(&myHook.HookBytes[0], HookAddress, TEE_MAXIMUM_HOOK_SIZE);
                VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                hookEntry.push_back(myHook);
                return true;
            }
#endif
        }
        else if(HookType == TEE_HOOK_NRM_CALL)
        {
#if !defined(_WIN64)
            CalculatedRealingJump = CalculatedRealingJump - 5;
            if(VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
            {
                WriteMemory->Array.bArrayEntry[0] = 0xE8;
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[1], &CalculatedRealingJump, sizeof CalculatedRealingJump);
                RtlMoveMemory(&myHook.HookBytes[0], HookAddress, TEE_MAXIMUM_HOOK_SIZE);
                VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                hookEntry.push_back(myHook);
                return true;
            }
#else
            if(VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
            {
                WriteMemory->Array.bArrayEntry[0] = 0xFF;
                WriteMemory->Array.bArrayEntry[1] = 0x15;
                RtlZeroMemory(&WriteMemory->Array.bArrayEntry[2], 4);
                RtlMoveMemory(&WriteMemory->Array.bArrayEntry[6], &RedirectTo, sizeof RedirectTo);
                RtlMoveMemory(&myHook.HookBytes[0], HookAddress, TEE_MAXIMUM_HOOK_SIZE);
                VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                hookEntry.push_back(myHook);
                return true;
            }
#endif
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, char* szHookFunction, LPVOID RedirectTo)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_IMPORT_DESCRIPTOR ImportIID;
    PIMAGE_THUNK_DATA32 ThunkData32;
    PIMAGE_THUNK_DATA64 ThunkData64;
    DWORD OldProtect = PAGE_READONLY;
    ULONG_PTR CurrentThunk;
    HOOK_ENTRY myHook = {};
    BOOL FileIs64;

    if(FileMapVA != NULL && LoadedModuleBase != NULL)
    {
        myHook.IATHook = true;
        myHook.HookIsEnabled = true;
        myHook.HookType = TEE_HOOK_IAT;
        myHook.HookSize = sizeof ULONG_PTR;
        myHook.RedirectionAddress = RedirectTo;
        myHook.IATHookModuleBase = (void*)LoadedModuleBase;
        myHook.IATHookNameHash = EngineHashString(szHookFunction);
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return false;
            }
            if(!FileIs64)
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                {
                    ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase), true);
                    __try
                    {
                        while(ImportIID->FirstThunk != NULL)
                        {
                            if(ImportIID->OriginalFirstThunk != NULL)
                            {
                                ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + PEHeader32->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                            }
                            else
                            {
                                ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader32->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                            }
                            while(ThunkData32 && ThunkData32->u1.AddressOfData != NULL)
                            {
                                if(!(ThunkData32->u1.Ordinal & IMAGE_ORDINAL_FLAG32))
                                {
                                    if(lstrcmpiA((char*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ThunkData32->u1.AddressOfData + 2 + PEHeader32->OptionalHeader.ImageBase), true), szHookFunction) == NULL)
                                    {
                                        myHook.HookAddress = (void*)(CurrentThunk + LoadedModuleBase);
                                        if(VirtualProtect(myHook.HookAddress, myHook.HookSize, PAGE_EXECUTE_READWRITE, &OldProtect))
                                        {
                                            RtlMoveMemory(&myHook.OriginalBytes[0], myHook.HookAddress, myHook.HookSize);
                                            RtlMoveMemory(&myHook.HookBytes[0], &myHook.RedirectionAddress, myHook.HookSize);
                                            RtlMoveMemory(myHook.HookAddress, &myHook.RedirectionAddress, myHook.HookSize);
                                            VirtualProtect(myHook.HookAddress, myHook.HookSize, OldProtect, &OldProtect);
                                        }
                                        hookEntry.push_back(myHook);
                                    }
                                }
                                CurrentThunk = CurrentThunk + 4;
                                ThunkData32 = (PIMAGE_THUNK_DATA32)((ULONG_PTR)ThunkData32 + sizeof IMAGE_THUNK_DATA32);
                            }
                            ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                        }
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        return false;
                    }
                }
            }
            else
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                {
                    ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader64->OptionalHeader.ImageBase), true);
                    __try
                    {
                        while(ImportIID->FirstThunk != NULL)
                        {
                            if(ImportIID->OriginalFirstThunk != NULL)
                            {
                                ThunkData64 = (PIMAGE_THUNK_DATA64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + PEHeader64->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->OriginalFirstThunk;
                            }
                            else
                            {
                                ThunkData64 = (PIMAGE_THUNK_DATA64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader64->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                            }
                            while(ThunkData64 && ThunkData64->u1.AddressOfData != NULL)
                            {
                                if(!(ThunkData64->u1.Ordinal & IMAGE_ORDINAL_FLAG64))
                                {
                                    if(lstrcmpiA((char*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ThunkData64->u1.AddressOfData + 2 + PEHeader64->OptionalHeader.ImageBase), true), szHookFunction) == NULL)
                                    {
                                        myHook.HookAddress = (void*)(CurrentThunk + LoadedModuleBase);
                                        if(VirtualProtect(myHook.HookAddress, myHook.HookSize, PAGE_EXECUTE_READWRITE, &OldProtect))
                                        {
                                            RtlMoveMemory(&myHook.OriginalBytes[0], myHook.HookAddress, myHook.HookSize);
                                            RtlMoveMemory(&myHook.HookBytes[0], &myHook.RedirectionAddress, myHook.HookSize);
                                            RtlMoveMemory(myHook.HookAddress, &myHook.RedirectionAddress, myHook.HookSize);
                                            VirtualProtect(myHook.HookAddress, myHook.HookSize, OldProtect, &OldProtect);
                                        }
                                        hookEntry.push_back(myHook);
                                    }
                                }
                                CurrentThunk = CurrentThunk + 8;
                                ThunkData64 = (PIMAGE_THUNK_DATA64)((ULONG_PTR)ThunkData64 + sizeof IMAGE_THUNK_DATA64);
                            }
                            ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                        }
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
    return false;
}

__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(char* szModuleName, char* szHookFunction, LPVOID RedirectTo)
{
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    DWORD NewSectionVO = NULL;
    DWORD NewSectionFO = NULL;
    HMODULE SelectedModule = NULL;

    SelectedModule = GetModuleHandleA(szModuleName);
    if(SelectedModule != NULL)
    {
        if(MapFileEx(szModuleName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
        {
            if(HooksInsertNewIATRedirectionEx(FileMapVA, (ULONG_PTR)SelectedModule, szHookFunction, RedirectTo))
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            }
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll)
{
    DWORD OldProtect = PAGE_READONLY;

    if(!RemoveAll)
    {
        for(unsigned int i = 0; i < hookEntry.size(); i++)
        {
            if(hookEntry[i].HookAddress == HookAddress && hookEntry[i].IATHook == false)
            {
                if(VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                {
                    RtlMoveMemory(HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                    VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                    hookEntry.erase(hookEntry.begin() + i);
                    return true;
                }
            }
        }
        return false;
    }
    else
    {
        for(unsigned int i = 0; i < hookEntry.size(); i++)
        {
            if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
            {
                RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
            }
        }
        hookEntry.clear();
        return true;
    }
}

__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase)
{
    int j = NULL;
    unsigned int i = (unsigned int)hookEntry.size();
    DWORD OldProtect = PAGE_READONLY;
    MODULEINFO RemoteModuleInfo;

    if(GetModuleInformation(GetCurrentProcess(), ModuleBase, &RemoteModuleInfo, sizeof MODULEINFO))
    {
        while(i > NULL)
        {
            if((ULONG_PTR)hookEntry[i].HookAddress >= (ULONG_PTR)ModuleBase && (ULONG_PTR)hookEntry[i].HookAddress <= (ULONG_PTR)ModuleBase + RemoteModuleInfo.SizeOfImage)
            {
                if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                {
                    RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                    VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                    hookEntry.erase(hookEntry.begin() + i);
                    j++;
                }
            }
            i--;
        }
        if(j == NULL)
        {
            return false;
        }
    }
    else
    {
        return false;
    }
    return true;
}

__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(char* szModuleName, char* szHookFunction, bool RemoveAll)
{
    unsigned int i = (unsigned int)hookEntry.size() - 1;
    DWORD OldProtect = PAGE_READONLY;
    HMODULE ModuleBase = GetModuleHandleA(szModuleName);
    DWORD FunctionNameHash = EngineHashString(szHookFunction);

    if(ModuleBase != NULL)
    {
        while(i > 0)
        {
            if((hookEntry[i].IATHookModuleBase == (void*)ModuleBase && RemoveAll == true) || (hookEntry[i].IATHookNameHash == FunctionNameHash && hookEntry[i].IATHook == true))
            {
                if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                {
                    RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                    VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                    hookEntry.erase(hookEntry.begin() + i);
                }
            }
            i--;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll)
{
    DWORD OldProtect = PAGE_READONLY;

    if(!DisableAll)
    {
        for(unsigned int i = 0; i < hookEntry.size(); i++)
        {
            if(hookEntry[i].HookAddress == HookAddress && hookEntry[i].HookIsEnabled == true)
            {
                if(VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                {
                    RtlMoveMemory(HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                    VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                    hookEntry[i].HookIsEnabled = false;
                    return true;
                }
            }
        }
        return false;
    }
    else
    {
        for(unsigned int i = 0; i < hookEntry.size(); i++)
        {
            if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
            {
                RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                hookEntry[i].HookIsEnabled = false;
            }
        }
        return true;
    }
}

__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase)
{
    int j = NULL;
    unsigned int i = (unsigned int)hookEntry.size();
    DWORD OldProtect = PAGE_READONLY;
    MODULEINFO RemoteModuleInfo;

    if(GetModuleInformation(GetCurrentProcess(), ModuleBase, &RemoteModuleInfo, sizeof MODULEINFO))
    {
        while(i > NULL)
        {
            if((ULONG_PTR)hookEntry[i].HookAddress >= (ULONG_PTR)ModuleBase && (ULONG_PTR)hookEntry[i].HookAddress <= (ULONG_PTR)ModuleBase + RemoteModuleInfo.SizeOfImage)
            {
                if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                {
                    RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                    VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                    hookEntry[i].HookIsEnabled = false;
                    j++;
                }
            }
            i--;
        }
        if(j == NULL)
        {
            return false;
        }
    }
    else
    {
        return false;
    }
    return true;
}

__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(char* szModuleName, char* szHookFunction, bool DisableAll)
{
    unsigned int i = (unsigned int)hookEntry.size() - 1;
    DWORD OldProtect = PAGE_READONLY;
    HMODULE ModuleBase = GetModuleHandleA(szModuleName);
    DWORD FunctionNameHash = EngineHashString(szHookFunction);

    if(ModuleBase != NULL)
    {
        while(i > 0)
        {
            if((hookEntry[i].IATHookModuleBase == (void*)ModuleBase && DisableAll == true) || (hookEntry[i].IATHookNameHash == FunctionNameHash && hookEntry[i].IATHook == true))
            {
                if(hookEntry[i].HookIsEnabled)
                {
                    if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                    {
                        RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].OriginalBytes, hookEntry[i].HookSize);
                        VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                        hookEntry[i].HookIsEnabled = false;
                    }
                }
            }
            i--;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll)
{
    DWORD OldProtect = PAGE_READONLY;

    if(!EnableAll)
    {
        for(unsigned int i = 0; i < hookEntry.size(); i++)
        {
            if(hookEntry[i].HookAddress == HookAddress && hookEntry[i].HookIsEnabled == false)
            {
                if(VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                {
                    RtlMoveMemory(HookAddress, &hookEntry[i].HookBytes, hookEntry[i].HookSize);
                    VirtualProtect(HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                    hookEntry[i].HookIsEnabled = true;
                    return true;
                }
            }
        }
        return false;
    }
    else
    {
        for(unsigned int i = 0; i < hookEntry.size(); i++)
        {
            if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
            {
                RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].HookBytes, hookEntry[i].HookSize);
                VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                hookEntry[i].HookIsEnabled = true;
            }
        }
        return true;
    }
}

__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase)
{
    int j = NULL;
    unsigned int i = (unsigned int)hookEntry.size();
    DWORD OldProtect = PAGE_READONLY;
    MODULEINFO RemoteModuleInfo;

    if(GetModuleInformation(GetCurrentProcess(), ModuleBase, &RemoteModuleInfo, sizeof MODULEINFO))
    {
        while(i > NULL)
        {
            if((ULONG_PTR)hookEntry[i].HookAddress >= (ULONG_PTR)ModuleBase && (ULONG_PTR)hookEntry[i].HookAddress <= (ULONG_PTR)ModuleBase + RemoteModuleInfo.SizeOfImage)
            {
                if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                {
                    RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].HookBytes, hookEntry[i].HookSize);
                    VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                    hookEntry[i].HookIsEnabled = true;
                    j++;
                }
            }
            i--;
        }
        if(j == NULL)
        {
            return false;
        }
    }
    else
    {
        return false;
    }
    return true;
}

__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(char* szModuleName, char* szHookFunction, bool EnableAll)
{
    unsigned int i = (unsigned int)hookEntry.size() - 1;
    DWORD OldProtect = PAGE_READONLY;
    HMODULE ModuleBase = GetModuleHandleA(szModuleName);
    DWORD FunctionNameHash = EngineHashString(szHookFunction);

    if(ModuleBase != NULL)
    {
        while(i > 0)
        {
            if((hookEntry[i].IATHookModuleBase == (void*)ModuleBase && EnableAll == true) || (hookEntry[i].IATHookNameHash == FunctionNameHash && hookEntry[i].IATHook == true))
            {
                if(!hookEntry[i].HookIsEnabled)
                {
                    if(VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, PAGE_EXECUTE_READWRITE, &OldProtect))
                    {
                        RtlMoveMemory(hookEntry[i].HookAddress, &hookEntry[i].HookBytes, hookEntry[i].HookSize);
                        VirtualProtect(hookEntry[i].HookAddress, TEE_MAXIMUM_HOOK_SIZE, OldProtect, &OldProtect);
                        hookEntry[i].HookIsEnabled = true;
                    }
                }
            }
            i--;
        }
    }
    return false;
}

__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack)
{
    unsigned int i;
    bool FileIs64 = false;
    bool FileError = false;
    void* pOriginalInstruction;
    bool ManuallyMapped = false;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    HANDLE hProcess = GetCurrentProcess();
    LIBRARY_ITEM_DATA RemoteLibInfo = {};
    PLIBRARY_ITEM_DATA pRemoteLibInfo = (PLIBRARY_ITEM_DATA)LibrarianGetLibraryInfoEx((void*)ModuleBase);
    typedef bool(TITCALL * fEnumCallBack)(PHOOK_ENTRY HookDetails, void* ptrOriginalInstructions, PLIBRARY_ITEM_DATA ModuleInformation, DWORD SizeOfImage);
    fEnumCallBack myEnumCallBack = (fEnumCallBack)CallBack;
    BYTE CheckHookMemory[TEE_MAXIMUM_HOOK_SIZE];
    PMEMORY_COMPARE_HANDLER ExportedFunctions;
    PMEMORY_COMPARE_HANDLER FunctionMemory;
    ULONG_PTR lpNumberOfBytesWritten;
    HOOK_ENTRY MyhookEntry = {};
    ULONG_PTR HookDestination;
    MODULEINFO ModuleInfo;
    BYTE HookType = NULL;
    DWORD hSize;

    if(pRemoteLibInfo == NULL)
    {
        RemoteLibInfo.BaseOfDll = (void*)ModuleBase;
        GetModuleBaseNameA(hProcess, ModuleBase, &RemoteLibInfo.szLibraryName[0], MAX_PATH);
        GetModuleFileNameExA(hProcess, ModuleBase, &RemoteLibInfo.szLibraryPath[0], MAX_PATH);
        RemoteLibInfo.hFile = CreateFileA(RemoteLibInfo.szLibraryPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(RemoteLibInfo.hFile != INVALID_HANDLE_VALUE)
        {
            RemoteLibInfo.hFileMapping = CreateFileMappingA(RemoteLibInfo.hFile, NULL, 2, NULL, GetFileSize(RemoteLibInfo.hFile, NULL), NULL);
            if(RemoteLibInfo.hFileMapping != NULL)
            {
                RemoteLibInfo.hFileMappingView = MapViewOfFile(RemoteLibInfo.hFileMapping, 4, NULL, NULL, NULL);
                if(RemoteLibInfo.hFileMappingView == NULL)
                {
                    CloseHandle(RemoteLibInfo.hFile);
                    CloseHandle(RemoteLibInfo.hFileMapping);
                    FileError = true;
                }
                else
                {
                    ManuallyMapped = true;
                }
            }
            else
            {
                CloseHandle(RemoteLibInfo.hFile);
                FileError = true;
            }
        }
        else
        {
            FileError = true;
        }
    }
    else
    {
        RtlMoveMemory(&RemoteLibInfo, pRemoteLibInfo, sizeof LIBRARY_ITEM_DATA);
    }
    if(!FileError)
    {
        hSize = GetFileSize(RemoteLibInfo.hFile, NULL);
        GetModuleInformation(hProcess, ModuleBase, &ModuleInfo, sizeof MODULEINFO);
        DOSHeader = (PIMAGE_DOS_HEADER)RemoteLibInfo.hFileMappingView;
        __try
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                FileError = true;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            FileError = true;
        }
        if(!FileError)
        {
            FunctionMemory = (PMEMORY_COMPARE_HANDLER)&CheckHookMemory[0];
            if(!FileIs64)
            {
                __try
                {
                    if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                    {
                        PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertVAtoFileOffsetEx((ULONG_PTR)RemoteLibInfo.hFileMappingView, hSize, PEHeader32->OptionalHeader.ImageBase, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, true, true);
                        if(PEExports != NULL)
                        {
                            ExportedFunctions = (PMEMORY_COMPARE_HANDLER)(ConvertVAtoFileOffsetEx((ULONG_PTR)RemoteLibInfo.hFileMappingView, hSize, PEHeader32->OptionalHeader.ImageBase, PEExports->AddressOfFunctions, true, true));
                            for(i = 0; i < PEExports->NumberOfFunctions; i++)
                            {
                                if(ReadProcessMemory(hProcess, (void*)((ULONG_PTR)RemoteLibInfo.BaseOfDll + ExportedFunctions->Array.dwArrayEntry[i]), &CheckHookMemory[0], TEE_MAXIMUM_HOOK_SIZE, &lpNumberOfBytesWritten))
                                {
                                    if(FunctionMemory->Array.bArrayEntry[0] == 0xE9 || FunctionMemory->Array.bArrayEntry[0] == 0xE8)
                                    {
                                        HookDestination = (ULONG_PTR)GetJumpDestination(hProcess, (ULONG_PTR)RemoteLibInfo.BaseOfDll + ExportedFunctions->Array.dwArrayEntry[i]);
                                        if(HookDestination >= (ULONG_PTR)RemoteLibInfo.BaseOfDll && HookDestination <= (ULONG_PTR)RemoteLibInfo.BaseOfDll + (ULONG_PTR)ModuleInfo.SizeOfImage)
                                        {
                                            if(CallBack != NULL)
                                            {
                                                if(FunctionMemory->Array.bArrayEntry[0] == 0xE9)
                                                {
                                                    HookType = TEE_HOOK_NRM_JUMP;
                                                }
                                                else
                                                {
                                                    HookType = TEE_HOOK_NRM_CALL;
                                                }
                                                MyhookEntry.HookSize = 5;
                                                MyhookEntry.HookType = HookType;
                                                MyhookEntry.HookIsEnabled = true;
                                                MyhookEntry.RedirectionAddress = (void*)HookDestination;
                                                MyhookEntry.HookAddress = (void*)((ULONG_PTR)RemoteLibInfo.BaseOfDll + ExportedFunctions->Array.dwArrayEntry[i]);
                                                pOriginalInstruction = (void*)ConvertVAtoFileOffsetEx((ULONG_PTR)RemoteLibInfo.hFileMappingView, hSize, PEHeader32->OptionalHeader.ImageBase, ExportedFunctions->Array.dwArrayEntry[i], true, true);
                                                RtlZeroMemory(&MyhookEntry.HookBytes[0], TEE_MAXIMUM_HOOK_SIZE);
                                                RtlMoveMemory(&MyhookEntry.HookBytes[0], &CheckHookMemory[0], MyhookEntry.HookSize);
                                                RtlZeroMemory(&MyhookEntry.OriginalBytes[0], TEE_MAXIMUM_HOOK_SIZE);
                                                RtlMoveMemory(&MyhookEntry.OriginalBytes[0], pOriginalInstruction, MyhookEntry.HookSize);
                                                RelocaterRelocateMemoryBlock((ULONG_PTR)RemoteLibInfo.hFileMappingView, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase + ExportedFunctions->Array.dwArrayEntry[i], &MyhookEntry.OriginalBytes[0], MyhookEntry.HookSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)RemoteLibInfo.BaseOfDll);
                                                if(!myEnumCallBack(&MyhookEntry, pOriginalInstruction, &RemoteLibInfo, ModuleInfo.SizeOfImage))
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {

                }
            }
            else
            {
                __try
                {
                    if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                    {
                        PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertVAtoFileOffsetEx((ULONG_PTR)RemoteLibInfo.hFileMappingView, hSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress, true, true);
                        if(PEExports != NULL)
                        {
                            ExportedFunctions = (PMEMORY_COMPARE_HANDLER)(ConvertVAtoFileOffsetEx((ULONG_PTR)RemoteLibInfo.hFileMappingView, hSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, PEExports->AddressOfFunctions, true, true));
                            for(i = 0; i < PEExports->NumberOfFunctions; i++)
                            {
                                if(ReadProcessMemory(hProcess, (void*)((ULONG_PTR)RemoteLibInfo.BaseOfDll + ExportedFunctions->Array.dwArrayEntry[i]), &CheckHookMemory[0], TEE_MAXIMUM_HOOK_SIZE, &lpNumberOfBytesWritten))
                                {
                                    if(FunctionMemory->Array.bArrayEntry[0] == 0xE9 || FunctionMemory->Array.bArrayEntry[0] == 0xE8)
                                    {
                                        HookDestination = (ULONG_PTR)GetJumpDestination(hProcess, (ULONG_PTR)RemoteLibInfo.BaseOfDll + ExportedFunctions->Array.dwArrayEntry[i]);
                                        if(HookDestination >= (ULONG_PTR)RemoteLibInfo.BaseOfDll && HookDestination <= (ULONG_PTR)RemoteLibInfo.BaseOfDll + (ULONG_PTR)ModuleInfo.SizeOfImage)
                                        {
                                            if(CallBack != NULL)
                                            {
                                                if(FunctionMemory->Array.bArrayEntry[0] == 0xE9)
                                                {
                                                    HookType = TEE_HOOK_NRM_JUMP;
                                                }
                                                else
                                                {
                                                    HookType = TEE_HOOK_NRM_CALL;
                                                }
                                                MyhookEntry.HookSize = 5;
                                                MyhookEntry.HookType = HookType;
                                                MyhookEntry.HookIsEnabled = true;
                                                MyhookEntry.RedirectionAddress = (void*)HookDestination;
                                                MyhookEntry.HookAddress = (void*)((ULONG_PTR)RemoteLibInfo.BaseOfDll + ExportedFunctions->Array.dwArrayEntry[i]);
                                                pOriginalInstruction = (void*)ConvertVAtoFileOffsetEx((ULONG_PTR)RemoteLibInfo.hFileMappingView, hSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, ExportedFunctions->Array.dwArrayEntry[i], true, true);
                                                RtlZeroMemory(&MyhookEntry.HookBytes[0], TEE_MAXIMUM_HOOK_SIZE);
                                                RtlMoveMemory(&MyhookEntry.HookBytes[0], &CheckHookMemory[0], MyhookEntry.HookSize);
                                                RtlZeroMemory(&MyhookEntry.OriginalBytes[0], TEE_MAXIMUM_HOOK_SIZE);
                                                RtlMoveMemory(&MyhookEntry.OriginalBytes[0], pOriginalInstruction, MyhookEntry.HookSize);
                                                RelocaterRelocateMemoryBlock((ULONG_PTR)RemoteLibInfo.hFileMappingView, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase + ExportedFunctions->Array.dwArrayEntry[i], &MyhookEntry.OriginalBytes[0], MyhookEntry.HookSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)RemoteLibInfo.BaseOfDll);
                                                if(!myEnumCallBack(&MyhookEntry, pOriginalInstruction, &RemoteLibInfo, ModuleInfo.SizeOfImage))
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {

                }
            }
        }
        if(ManuallyMapped)
        {
            if(UnmapViewOfFile(RemoteLibInfo.hFileMappingView))
            {
                CloseHandle(RemoteLibInfo.hFileMapping);
                CloseHandle(RemoteLibInfo.hFile);
            }
        }
    }
}

__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack)
{
    unsigned int i;
    DWORD cbNeeded = 0;
    HMODULE EnumeratedModules[1024] = {0};

    hookEntry.clear();
    if(EnumProcessModules(GetCurrentProcess(), EnumeratedModules, sizeof(EnumeratedModules), &cbNeeded))
    {
        for(i = 1; i < (cbNeeded / sizeof(HMODULE)); i++)
        {
            HooksScanModuleMemory(EnumeratedModules[i], CallBack);
        }
    }
}

__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx()
{
    HooksScanEntireProcessMemory(&ProcessHookScanAddNewHook);
}



================================================
File: TitanEngine/TitanEngine.Importer.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Mapping.h"
#include "Global.Engine.h"
#include "Global.Librarian.h"
#include "Global.Engine.Importer.h"
#include "Global.Debugger.h"
#include "scylla_wrapper.h"

// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(char* szDLLName, ULONG_PTR FirstThunk)
{
    wchar_t uniDLLName[MAX_PATH] = {};

    MultiByteToWideChar(CP_ACP, NULL, szDLLName, lstrlenA(szDLLName) + 1, uniDLLName, sizeof(uniDLLName) / (sizeof(uniDLLName[0])));

    scylla_addModule(uniDLLName, FirstThunk);
}

__declspec(dllexport) void TITCALL ImporterAddNewAPI(char* szAPIName, ULONG_PTR ThunkValue)
{
    wchar_t uniAPIName[MAX_PATH] = {};

    MultiByteToWideChar(CP_ACP, NULL, szAPIName, lstrlenA(szAPIName) + 1, uniAPIName, sizeof(uniAPIName) / (sizeof(uniAPIName[0])));

    scylla_addImport(uniAPIName, ThunkValue);
}

__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue)
{
    ImporterAddNewAPI((char*)(OrdinalNumber & ~IMAGE_ORDINAL_FLAG), ThunkValue);
}

__declspec(dllexport) long TITCALL ImporterGetAddedDllCount()
{
    return scylla_getModuleCount();
}

__declspec(dllexport) long TITCALL ImporterGetAddedAPICount()
{
    return scylla_getImportCount();
}

__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap)
{
    return (scylla_fixMappedDump(StorePlace, FileMapVA, hFileMap) == SCY_ERROR_SUCCESS);
}

__declspec(dllexport) long TITCALL ImporterEstimatedSize()
{
    return scylla_estimatedIATSize();
}

__declspec(dllexport) bool TITCALL ImporterExportIATEx(char* szDumpFileName, char* szExportFileName, char* szSectionName)
{
    wchar_t uniExportFileName[MAX_PATH] = {};
    wchar_t uniDumpFileName[MAX_PATH] = {};
    wchar_t uniSectionName[MAX_PATH] = {};
    if(szExportFileName != NULL && szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szExportFileName, lstrlenA(szExportFileName) + 1, uniExportFileName, sizeof(uniExportFileName) / (sizeof(uniExportFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, lstrlenA(szDumpFileName) + 1, uniDumpFileName, sizeof(uniDumpFileName) / (sizeof(uniDumpFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szSectionName, lstrlenA(szSectionName) + 1, uniSectionName, sizeof(uniSectionName) / (sizeof(uniSectionName[0])));
        return ImporterExportIATExW(uniDumpFileName, uniExportFileName, uniSectionName);
    }
    return false;
}

__declspec(dllexport) bool TITCALL ImporterExportIATExW(wchar_t* szDumpFileName, wchar_t* szExportFileName, wchar_t* szSectionName)
{
    return (scylla_fixDump(szDumpFileName, szExportFileName, szSectionName) == SCY_ERROR_SUCCESS);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(char* szAPIName)
{
    return scylla_findImportWriteLocation(szAPIName);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber)
{
    return scylla_findOrdinalImportWriteLocation(OrdinalNumber);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation)
{
    return scylla_findImportNameByWriteLocation(APIWriteLocation);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation)
{
    return scylla_findModuleNameByWriteLocation(APIWriteLocation);
}

__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress)
{
    return ImporterGetDLLNameFromDebugee(GetCurrentProcess(), APIAddress);
}

__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress)
{
    return ImporterGetDLLNameFromDebugeeW(GetCurrentProcess(), APIAddress);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return EngineGetAddressRemote(hProcess, APIAddress);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(char* szDLLName, char* szAPIName)
{
    return EngineGetProcAddressRemote(0, szDLLName, szAPIName);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return EngineGetAddressLocal(hProcess, APIAddress);
}

__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress)
{
    ULONG_PTR moduleBase = EngineGetModuleBaseRemote(hProcess, APIAddress);
    if(moduleBase)
    {
        static char szModuleName[MAX_PATH] = "";
        if(GetModuleFileNameExA(hProcess, (HMODULE)moduleBase, szModuleName, _countof(szModuleName)))
            return szModuleName;
    }
    return 0;
}

__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress)
{
    ULONG_PTR moduleBase = EngineGetModuleBaseRemote(hProcess, APIAddress);
    if(moduleBase)
    {
        static wchar_t szModuleName[MAX_PATH] = L"";
        if(GetModuleFileNameExW(hProcess, (HMODULE)moduleBase, szModuleName, _countof(szModuleName)))
            return szModuleName;
    }
    return 0;
}

__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, WCHAR* szModuleName)
{
    return (void*)EngineGetModuleBaseRemote(hProcess, szModuleName);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, char* szModuleName)
{
    return EngineGetModuleBaseRemote(hProcess, szModuleName);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase)
{
    return EngineGetAddressRemote(hProcess, (ULONG_PTR)LocalModuleBase);
}

__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress)
{
    return ImporterGetAPINameFromDebugee(GetCurrentProcess(), APIAddress);
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress)
{
    return ImporterGetAPIOrdinalNumberFromDebugee(GetCurrentProcess(), APIAddress);
}

__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList)
{
    //TODO: remove?
    return ImporterGetAPIName(APIAddress);
}

__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress)
{
    static char APIName[5000] = "";
    if(EngineGetAPINameRemote(hProcess, APIAddress, APIName, _countof(APIName), 0))
        return APIName;
    return 0;
}

__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return EngineGetAPIOrdinalRemote(hProcess, APIAddress);
}

__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList)
{
    //TODO: remove?
    return((DWORD)EngineGlobalAPIHandler(NULL, DLLBasesList, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_DLLINDEX));
}

__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList)
{
    //TODO: remove?
    return((DWORD)EngineGlobalAPIHandler(hProcess, DLLBasesList, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_DLLINDEX));
}

__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress)
{
    if((ULONG_PTR)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLINDEX) > NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return((LPVOID)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_APINAME));
}
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return((LPVOID)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLNAME));
}
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList)
{
    //TODO: remove?
    return((DWORD)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLINDEX));
}
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return((DWORD)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_FORWARDER_API_ORDINAL_NUMBER));
}
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return((ULONG_PTR)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_NEAREST_APIADDRESS));
}
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress)
{
    return((LPVOID)EngineGlobalAPIHandler(hProcess, NULL, APIAddress, NULL, UE_OPTION_IMPORTER_RETURN_NEAREST_APINAME));
}
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(char* szOriginalFile, char* szDumpFile)
{

    wchar_t uniDumpFile[MAX_PATH] = {};
    wchar_t uniOriginalFile[MAX_PATH] = {};

    if(szOriginalFile != NULL && szDumpFile != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFile, lstrlenA(szDumpFile) + 1, uniDumpFile, sizeof(uniDumpFile) / (sizeof(uniDumpFile[0])));
        MultiByteToWideChar(CP_ACP, NULL, szOriginalFile, lstrlenA(szOriginalFile) + 1, uniOriginalFile, sizeof(uniOriginalFile) / (sizeof(uniOriginalFile[0])));
        return(ImporterCopyOriginalIATW(uniOriginalFile, uniDumpFile));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(wchar_t* szOriginalFile, wchar_t* szDumpFile)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    BOOL FileIs64;
    HANDLE FileHandle = 0;
    DWORD FileSize;
    HANDLE FileMap = 0;
    ULONG_PTR FileMapVA;
    HANDLE FileHandle1 = 0;
    DWORD FileSize1;
    HANDLE FileMap1 = 0;
    ULONG_PTR FileMapVA1;
    ULONG_PTR IATPointer;
    ULONG_PTR IATWritePointer;
    ULONG_PTR IATCopyStart;
    DWORD IATSection;
    DWORD IATCopySize;
    DWORD IATHeaderData;

    if(MapFileExW(szOriginalFile, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        if(MapFileExW(szDumpFile, UE_ACCESS_ALL, &FileHandle1, &FileSize1, &FileMap1, &FileMapVA1, NULL))
        {
            DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
            if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
            {
                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                if(PEHeader32->OptionalHeader.Magic == 0x10B)
                {
                    FileIs64 = false;
                }
                else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                {
                    FileIs64 = true;
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    UnMapFileEx(FileHandle1, FileSize1, FileMap1, FileMapVA1);
                    return false;
                }
                if(!FileIs64)
                {
                    IATPointer = (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase);
                }
                else
                {
                    IATPointer = (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader64->OptionalHeader.ImageBase);
                }
                IATSection = GetPE32SectionNumberFromVA(FileMapVA, IATPointer);
                IATPointer = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, IATPointer, true);
                if((int)IATSection >= NULL)
                {
                    IATWritePointer = (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA1, IATSection, UE_SECTIONRAWOFFSET) + FileMapVA1;
                    IATCopyStart = (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, IATSection, UE_SECTIONRAWOFFSET) + FileMapVA;
                    IATCopySize = (DWORD)GetPE32DataFromMappedFile(FileMapVA1, IATSection, UE_SECTIONRAWSIZE);
                    __try
                    {
                        RtlMoveMemory((LPVOID)IATWritePointer, (LPVOID)IATCopyStart, IATCopySize);
                        IATHeaderData = (DWORD)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMPORTTABLEADDRESS);
                        SetPE32DataForMappedFile(FileMapVA1, NULL, UE_IMPORTTABLEADDRESS, (ULONG_PTR)IATHeaderData);
                        IATHeaderData = (DWORD)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMPORTTABLESIZE);
                        SetPE32DataForMappedFile(FileMapVA1, NULL, UE_IMPORTTABLESIZE, (ULONG_PTR)IATHeaderData);
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        UnMapFileEx(FileHandle1, FileSize1, FileMap1, FileMapVA1);
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        UnMapFileEx(FileHandle1, FileSize1, FileMap1, FileMapVA1);
                        return false;
                    }
                }
            }
            UnMapFileEx(FileHandle1, FileSize1, FileMap1, FileMapVA1);
        }
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    }

    return false;
}
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(char* szFileName)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(ImporterLoadImportTableW(uniFileName));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(wchar_t* szFileName)
{
    //TODO scylla enable
    return false;
    /*
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_IMPORT_DESCRIPTOR ImportIID;
    PIMAGE_THUNK_DATA32 ThunkData32;
    PIMAGE_THUNK_DATA64 ThunkData64;
    ULONG_PTR CurrentThunk;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                {
                    ImporterInit(MAX_IMPORT_ALLOC, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase);
                    ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase), true);
                    __try
                    {
                        while(ImportIID->FirstThunk != NULL)
                        {
                            ImporterAddNewDll((char*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->Name + PEHeader32->OptionalHeader.ImageBase), true), NULL);
                            if(ImportIID->OriginalFirstThunk != NULL)
                            {
                                ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + PEHeader32->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                            }
                            else
                            {
                                ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader32->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                            }
                            while(ThunkData32->u1.AddressOfData != NULL)
                            {
                                if(ThunkData32->u1.Ordinal & IMAGE_ORDINAL_FLAG32)
                                {
                                    ImporterAddNewAPI((char*)(ThunkData32->u1.Ordinal ^ IMAGE_ORDINAL_FLAG32), (ULONG_PTR)CurrentThunk + PEHeader32->OptionalHeader.ImageBase);
                                }
                                else
                                {
                                    ImporterAddNewAPI((char*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ThunkData32->u1.AddressOfData + 2 + PEHeader32->OptionalHeader.ImageBase), true), (ULONG_PTR)CurrentThunk + PEHeader32->OptionalHeader.ImageBase);
                                }
                                CurrentThunk = CurrentThunk + 4;
                                ThunkData32 = (PIMAGE_THUNK_DATA32)((ULONG_PTR)ThunkData32 + sizeof IMAGE_THUNK_DATA32);
                            }
                            ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                        }
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        ImporterCleanup();
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
            }
            else
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                {
                    ImporterInit(MAX_IMPORT_ALLOC, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase);
                    ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader64->OptionalHeader.ImageBase), true);
                    __try
                    {
                        while(ImportIID->FirstThunk != NULL)
                        {
                            ImporterAddNewDll((char*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->Name + PEHeader64->OptionalHeader.ImageBase), true), NULL);
                            if(ImportIID->OriginalFirstThunk != NULL)
                            {
                                ThunkData64 = (PIMAGE_THUNK_DATA64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + PEHeader64->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->OriginalFirstThunk;
                            }
                            else
                            {
                                ThunkData64 = (PIMAGE_THUNK_DATA64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader64->OptionalHeader.ImageBase), true);
                                CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                            }
                            while(ThunkData64->u1.AddressOfData != NULL)
                            {
                                if(ThunkData64->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
                                {
                                    ImporterAddNewAPI((char*)(ThunkData64->u1.Ordinal ^ (ULONG_PTR)IMAGE_ORDINAL_FLAG64), (ULONG_PTR)CurrentThunk + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase);
                                }
                                else
                                {
                                    ImporterAddNewAPI((char*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((ULONG_PTR)ThunkData64->u1.AddressOfData + 2 + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), true), (ULONG_PTR)CurrentThunk + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase);
                                }
                                CurrentThunk = CurrentThunk + 8;
                                ThunkData64 = (PIMAGE_THUNK_DATA64)((ULONG_PTR)ThunkData64 + sizeof IMAGE_THUNK_DATA64);
                            }
                            ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                        }
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        ImporterCleanup();
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    else
    {
        return false;
    }
    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    return false;
    */
}
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(char* szOriginalFile, char* szDumpFile, char* szSectionName)
{
    /*
    if(ImporterLoadImportTable(szOriginalFile))
    {
        return(ImporterExportIATEx(szDumpFile, szSectionName));
    }*/
    return false;
}
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(wchar_t* szOriginalFile, wchar_t* szDumpFile, char* szSectionName)
{
    /*
    if(ImporterLoadImportTableW(szOriginalFile))
    {
        return(ImporterExportIATExW(szDumpFile, szSectionName));
    }*/
    return false;
}
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(ImporterAutoSearchIATW(ProcessId, uniFileName, SearchStart, pIATStart, pIATSize));
    }
}
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessId, wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize)
{
    ULONG_PTR iatStart = NULL;
    DWORD iatSize = NULL;

    scylla_searchIAT(ProcessId, iatStart, iatSize, SearchStart, false);

    //we also try to automatically read imports so following call to ExportIAT has a chance
    if(iatStart != NULL && iatSize != NULL)
    {
        scylla_getImports(iatStart, iatSize, ProcessId);
    }

    RtlMoveMemory(pIATStart, &iatStart, sizeof ULONG_PTR);
    RtlMoveMemory(pIATSize, &iatSize, sizeof ULONG_PTR);

    return;
}
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize)
{

    wchar_t szTempName[MAX_PATH];
    wchar_t szTempFolder[MAX_PATH];

    RtlZeroMemory(&szTempName, sizeof szTempName);
    RtlZeroMemory(&szTempFolder, sizeof szTempFolder);
    if(GetTempPathW(MAX_PATH, szTempFolder) < MAX_PATH)
    {
        if(GetTempFileNameW(szTempFolder, L"DumpTemp", GetTickCount() + 102, szTempName))
        {
            HANDLE hProcess = EngineOpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, ProcessId);

            DumpProcessW(hProcess, (LPVOID)ImageBase, szTempName, NULL);
            ImporterAutoSearchIATW(ProcessId, szTempName, SearchStart, pIATStart, pIATSize);
            DeleteFileW(szTempName);
        }
    }
}
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack)
{
    return scylla_enumImportTree(EnumCallBack);
}
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, char* szDumpedFile, char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback)
{

    wchar_t uniDumpedFile[MAX_PATH] = {};
    wchar_t uniSectionName[MAX_PATH] = {};

    if(szDumpedFile != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpedFile, lstrlenA(szDumpedFile) + 1, uniDumpedFile, sizeof(uniDumpedFile) / (sizeof(uniDumpedFile[0])));
        MultiByteToWideChar(CP_ACP, NULL, szSectionName, lstrlenA(szSectionName) + 1, uniSectionName, sizeof(uniSectionName) / (sizeof(uniSectionName[0])));
        return(ImporterAutoFixIATExW(ProcessId, uniDumpedFile, uniSectionName, DumpRunningProcess, RealignFile, EntryPointAddress, ImageBase, SearchStart, TryAutoFix, FixEliminations, UnknownPointerFixCallback));
    }
    else
    {
        return(NULL);   // Critical error! *just to be safe, but it should never happen!
    }
}
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, wchar_t* szDumpedFile, wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback)
{
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR iatStart = NULL;
    DWORD iatSize = NULL;
    WCHAR IatFixFileName[MAX_PATH];
    WCHAR DumpFileName[MAX_PATH];

    lstrcpyW(DumpFileName, szDumpedFile);

    WCHAR* Extension = wcsrchr(DumpFileName, L'.');
    WCHAR Bak = *Extension;
    *Extension = 0;
    lstrcpyW(IatFixFileName, DumpFileName);
    *Extension = Bak;
    lstrcatW(IatFixFileName, L"_scy");
    lstrcatW(IatFixFileName, Extension);
    lstrcatW(DumpFileName, Extension);

    //do we need to dump first?
    if(DumpRunningProcess)
    {
        HANDLE hProcess = EngineOpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, ProcessId);

        if(!DumpProcessW(hProcess, (LPVOID)ImageBase, szDumpedFile, EntryPointAddress))
        {
            return(NULL);   // Critical error! *just to be safe, but it should never happen!
        }
    }

    //we need to fix iat, thats for sure
    int ret = scylla_searchIAT(ProcessId, iatStart, iatSize, SearchStart, false);

    if(ret != SCY_ERROR_SUCCESS)
    {
        if(ret == SCY_ERROR_PROCOPEN)
        {
            return (0x401); //error proc terminated
        }
        if(ret == SCY_ERROR_IATNOTFOUND || ret == SCY_ERROR_IATSEARCH)
        {
            return (0x405); //no API found
        }
    }

    scylla_getImports(iatStart, iatSize, ProcessId, UnknownPointerFixCallback);

    if(!scylla_importsValid())
    {
        return (0x405);
    }

    ret = scylla_fixDump(szDumpedFile, IatFixFileName, szSectionName);

    if(ret == SCY_ERROR_IATWRITE)
    {
        return (0x407);
    }

    //do we need to realign ?
    if(RealignFile)
    {
        if(MapFileExW(szDumpedFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
        {
            FileSize = RealignPE(FileMapVA, FileSize, NULL);
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        }
        else
        {
            return(0x406);  // Success, but realign failed!
        }
    }
    return(0x400);  // Success!
}
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, char* szDumpedFile, ULONG_PTR SearchStart)
{
    return(ImporterAutoFixIATEx(ProcessId, szDumpedFile, ".RL!TEv2", false, false, NULL, NULL, SearchStart, false, false, NULL));
}
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, wchar_t* szDumpedFile, ULONG_PTR SearchStart)
{
    return(ImporterAutoFixIATExW(ProcessId, szDumpedFile, L".RL!TEv2", false, false, NULL, NULL, SearchStart, false, false, NULL));
}
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr)
{
    return scylla_cutImport(apiAddr);
}



================================================
File: TitanEngine/TitanEngine.Injector.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Injector.h"

// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, char* szLibraryFile, bool WaitForThreadExit)
{

    wchar_t uniLibraryFile[MAX_PATH] = {};

    if(szLibraryFile != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szLibraryFile, lstrlenA(szLibraryFile) + 1, uniLibraryFile, sizeof(uniLibraryFile) / (sizeof(uniLibraryFile[0])));
        return(RemoteLoadLibraryW(hProcess, uniLibraryFile, WaitForThreadExit));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, wchar_t* szLibraryFile, bool WaitForThreadExit)
{

    int i;
    InjectCodeData APIData;
    LPVOID remStringData;
    LPVOID remCodeData;
    ULONG_PTR remInjectSize = (ULONG_PTR)((ULONG_PTR)&injectedRemoteFreeLibrary - (ULONG_PTR)&injectedRemoteLoadLibrary);

    ULONG_PTR NumberOfBytesWritten;
    DWORD ThreadId;
    HANDLE hThread;
    DWORD ExitCode;

    if(hProcess != NULL)
    {
        RtlZeroMemory(&APIData, sizeof InjectCodeData);
        APIData.fLoadLibrary = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryW"));
        APIData.fFreeLibrary = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "FreeLibrary"));
        APIData.fGetModuleHandle = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetModuleHandleW"));
        APIData.fGetProcAddress = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetProcAddress"));
        APIData.fVirtualFree = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "VirtualFree"));
        APIData.fExitProcess = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitProcess"));
        remCodeData = VirtualAllocEx(hProcess, NULL, remInjectSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        remStringData = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);
        if(WriteProcessMemory(hProcess, (LPVOID)((ULONG_PTR)remStringData + sizeof InjectCodeData), (LPCVOID)szLibraryFile, lstrlenW(szLibraryFile) * 2, &NumberOfBytesWritten))
        {
            WriteProcessMemory(hProcess, remStringData, &APIData, sizeof InjectCodeData, &NumberOfBytesWritten);
            WriteProcessMemory(hProcess, remCodeData, (LPCVOID)&injectedRemoteLoadLibrary, remInjectSize, &NumberOfBytesWritten);
            if(WaitForThreadExit)
            {
                hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, CREATE_SUSPENDED, &ThreadId);

                NtSetInformationThread(hThread, ThreadHideFromDebugger, NULL, NULL);

                ResumeThread(hThread);
                WaitForSingleObject(hThread, INFINITE);
                VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
                VirtualFreeEx(hProcess, remStringData, NULL, MEM_RELEASE);
                if(GetExitCodeThread(hThread, &ExitCode))
                {
                    if(ExitCode == NULL)
                    {
                        return false;
                    }
                }
            }
            else
            {
                hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, NULL, &ThreadId);
                for(i = 0; i < UE_MAX_RESERVED_MEMORY_LEFT; i++)
                {
                    if(engineReservedMemoryLeft[i] == NULL)
                    {
                        break;
                    }
                }
                engineReservedMemoryLeft[i] = (ULONG_PTR)remCodeData;
                engineReservedMemoryProcess = hProcess;
                ThreaderSetCallBackForNextExitThreadEvent((LPVOID)&injectedTerminator);
            }
            return true;
        }
        else
        {
            VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
            VirtualFreeEx(hProcess, remStringData, NULL, MEM_RELEASE);
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, char* szLibraryFile, bool WaitForThreadExit)
{

    wchar_t uniLibraryFile[MAX_PATH] = {};

    if(szLibraryFile != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szLibraryFile, lstrlenA(szLibraryFile) + 1, uniLibraryFile, sizeof(uniLibraryFile) / (sizeof(uniLibraryFile[0])));
        return(RemoteFreeLibraryW(hProcess, hModule, uniLibraryFile, WaitForThreadExit));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, wchar_t* szLibraryFile, bool WaitForThreadExit)
{

    int i;
    InjectCodeData APIData;
    LPVOID remStringData;
    LPVOID remCodeData;
    ULONG_PTR remInjectSize1 = (ULONG_PTR)((ULONG_PTR)&injectedExitProcess - (ULONG_PTR)&injectedRemoteFreeLibrarySimple);
    ULONG_PTR remInjectSize2 = (ULONG_PTR)((ULONG_PTR)&injectedRemoteFreeLibrarySimple - (ULONG_PTR)&injectedRemoteFreeLibrary);
    ULONG_PTR NumberOfBytesWritten;
    DWORD ThreadId;
    HANDLE hThread;
    DWORD ExitCode;

    if(hProcess != NULL)
    {
        RtlZeroMemory(&APIData, sizeof InjectCodeData);
        APIData.fLoadLibrary = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryW"));
        APIData.fFreeLibrary = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "FreeLibrary"));
        APIData.fGetModuleHandle = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetModuleHandleW"));
        APIData.fGetProcAddress = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetProcAddress"));
        APIData.fVirtualFree = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "VirtualFree"));
        APIData.fExitProcess = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitProcess"));
        APIData.fFreeLibraryHandle = hModule;
        remCodeData = VirtualAllocEx(hProcess, NULL, remInjectSize1, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if(hModule == NULL)
        {
            remStringData = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);
            if(WriteProcessMemory(hProcess, (LPVOID)((ULONG_PTR)remStringData + sizeof InjectCodeData), (LPCVOID)szLibraryFile, lstrlenW(szLibraryFile) * 2, &NumberOfBytesWritten))
            {
                WriteProcessMemory(hProcess, remStringData, &APIData, sizeof InjectCodeData, &NumberOfBytesWritten);
                WriteProcessMemory(hProcess, remCodeData, (LPCVOID)&injectedRemoteFreeLibrarySimple, remInjectSize1, &NumberOfBytesWritten);
                if(WaitForThreadExit)
                {
                    hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, CREATE_SUSPENDED, &ThreadId);

                    NtSetInformationThread(hThread, ThreadHideFromDebugger, NULL, NULL);

                    ResumeThread(hThread);
                    WaitForSingleObject(hThread, INFINITE);
                    VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
                    VirtualFreeEx(hProcess, remStringData, NULL, MEM_RELEASE);
                    if(GetExitCodeThread(hThread, &ExitCode))
                    {
                        if(ExitCode == NULL)
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, NULL, &ThreadId);
                    for(i = 0; i < UE_MAX_RESERVED_MEMORY_LEFT; i++)
                    {
                        if(engineReservedMemoryLeft[i] == NULL)
                        {
                            break;
                        }
                    }
                    engineReservedMemoryLeft[i] = (ULONG_PTR)remCodeData;
                    engineReservedMemoryProcess = hProcess;
                    ThreaderSetCallBackForNextExitThreadEvent((LPVOID)&injectedTerminator);
                }
                return true;
            }
            else
            {
                VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
                VirtualFreeEx(hProcess, remStringData, NULL, MEM_RELEASE);
            }
        }
        else
        {
            remStringData = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);
            if(WriteProcessMemory(hProcess, remStringData, &APIData, sizeof InjectCodeData, &NumberOfBytesWritten))
            {
                WriteProcessMemory(hProcess, remCodeData, (LPCVOID)&injectedRemoteFreeLibrary, remInjectSize2, &NumberOfBytesWritten);
                if(WaitForThreadExit)
                {
                    hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, CREATE_SUSPENDED, &ThreadId);
                    NtSetInformationThread(hThread, ThreadHideFromDebugger, NULL, NULL);
                    ResumeThread(hThread);
                    WaitForSingleObject(hThread, INFINITE);
                    VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
                    if(GetExitCodeThread(hThread, &ExitCode))
                    {
                        if(ExitCode == NULL)
                        {
                            return false;
                        }
                    }
                }
                else
                {
                    hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, NULL, &ThreadId);
                    for(i = 0; i < UE_MAX_RESERVED_MEMORY_LEFT; i++)
                    {
                        if(engineReservedMemoryLeft[i] == NULL)
                        {
                            break;
                        }
                    }
                    engineReservedMemoryLeft[i] = (ULONG_PTR)remCodeData;
                    engineReservedMemoryProcess = hProcess;
                    ThreaderSetCallBackForNextExitThreadEvent((LPVOID)&injectedTerminator);
                }
                return true;
            }
            else
            {
                VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
                VirtualFreeEx(hProcess, remStringData, NULL, MEM_RELEASE);
            }
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode)
{

    InjectCodeData APIData;
    LPVOID remCodeData;
    LPVOID remStringData;
    ULONG_PTR remInjectSize = (ULONG_PTR)((ULONG_PTR)&injectedTerminator - (ULONG_PTR)&injectedExitProcess);
    ULONG_PTR NumberOfBytesWritten;
    DWORD ThreadId;
    HANDLE hThread;

    if(hProcess != NULL)
    {
        RtlZeroMemory(&APIData, sizeof InjectCodeData);
        APIData.fLoadLibrary = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA"));
        APIData.fFreeLibrary = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "FreeLibrary"));
        APIData.fGetModuleHandle = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetModuleHandleA"));
        APIData.fGetProcAddress = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetProcAddress"));
        APIData.fVirtualFree = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "VirtualFree"));
        APIData.fExitProcess = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitProcess"));
        APIData.fExitProcessCode = ExitCode;
        remStringData = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);
        remCodeData = VirtualAllocEx(hProcess, NULL, remInjectSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if(WriteProcessMemory(hProcess, remCodeData, (LPCVOID)&injectedExitProcess, remInjectSize, &NumberOfBytesWritten))
        {
            WriteProcessMemory(hProcess, remStringData, &APIData, sizeof InjectCodeData, &NumberOfBytesWritten);
            hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, NULL, &ThreadId);
            VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
            return true;
        }
        else
        {
            VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
            VirtualFreeEx(hProcess, remStringData, NULL, MEM_RELEASE);
        }
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.Librarian.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Librarian.h"

static LIBRARY_ITEM_DATA LibraryInfoData = {};

// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack)
{
    LIBRARY_BREAK_DATA NewLibrarianData;
    memset(&NewLibrarianData, 0, sizeof(LIBRARY_BREAK_DATA));
    lstrcpyA(NewLibrarianData.szLibraryName, szLibraryName);
    NewLibrarianData.bpxCallBack = bpxCallBack;
    NewLibrarianData.bpxSingleShoot = SingleShoot;
    NewLibrarianData.bpxType = bpxType;
    LibrarianData.push_back(NewLibrarianData);

    return true;
}

__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(char* szLibraryName, DWORD bpxType)
{
    for(int i = (int)LibrarianData.size() - 1; i >= 0; i--)
    {
        if(!_stricmp(szLibraryName, LibrarianData.at(i).szLibraryName) && (LibrarianData.at(i).bpxType == bpxType || bpxType == UE_ON_LIB_ALL))
        {
            LibrarianData.erase(LibrarianData.begin() + i);
        }
    }

    return true;
}

__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(char* szLibraryName)
{
    if(!szLibraryName)
        return NULL;

    wchar_t uniLibraryName[MAX_PATH] = {};
    PLIBRARY_ITEM_DATAW LibInfo;
    MultiByteToWideChar(CP_ACP, NULL, szLibraryName, lstrlenA(szLibraryName) + 1, uniLibraryName, sizeof(uniLibraryName) / (sizeof(uniLibraryName[0])));
    LibInfo = (PLIBRARY_ITEM_DATAW)LibrarianGetLibraryInfoW(uniLibraryName);
    if(LibInfo)
    {
        RtlZeroMemory(&LibraryInfoData, sizeof LIBRARY_ITEM_DATA);
        LibraryInfoData.hFile = LibInfo->hFile;
        LibraryInfoData.BaseOfDll = LibInfo->BaseOfDll;
        LibraryInfoData.hFileMapping = LibInfo->hFileMapping;
        LibraryInfoData.hFileMappingView = LibInfo->hFileMappingView;
        WideCharToMultiByte(CP_ACP, NULL, LibInfo->szLibraryName, -1, &LibraryInfoData.szLibraryName[0], sizeof LibraryInfoData.szLibraryName, NULL, NULL);
        WideCharToMultiByte(CP_ACP, NULL, LibInfo->szLibraryPath, -1, &LibraryInfoData.szLibraryPath[0], sizeof LibraryInfoData.szLibraryPath, NULL, NULL);

        return((void*)&LibraryInfoData);
    }

    return NULL;
}

__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(wchar_t* szLibraryName)
{
    static LIBRARY_ITEM_DATAW LibraryInfo;
    memset(&LibraryInfo, 0, sizeof(LIBRARY_ITEM_DATAW));

    for(unsigned int i = 0; i < hListLibrary.size(); i++)
    {
        if(hListLibrary.at(i).hFile != INVALID_HANDLE_VALUE && !lstrcmpiW(hListLibrary.at(i).szLibraryName, szLibraryName))
        {
            memcpy(&LibraryInfo, &hListLibrary.at(i), sizeof(LIBRARY_ITEM_DATAW));
            return &LibraryInfo;
        }
    }

    return NULL;
}

__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll)
{
    PLIBRARY_ITEM_DATAW LibInfo;
    LibInfo = (PLIBRARY_ITEM_DATAW)LibrarianGetLibraryInfoExW(BaseOfDll);
    if(LibInfo)
    {
        RtlZeroMemory(&LibraryInfoData, sizeof LIBRARY_ITEM_DATA);
        LibraryInfoData.hFile = LibInfo->hFile;
        LibraryInfoData.BaseOfDll = LibInfo->BaseOfDll;
        LibraryInfoData.hFileMapping = LibInfo->hFileMapping;
        LibraryInfoData.hFileMappingView = LibInfo->hFileMappingView;
        WideCharToMultiByte(CP_ACP, NULL, LibInfo->szLibraryName, -1, &LibraryInfoData.szLibraryName[0], sizeof LibraryInfoData.szLibraryName, NULL, NULL);
        WideCharToMultiByte(CP_ACP, NULL, LibInfo->szLibraryPath, -1, &LibraryInfoData.szLibraryPath[0], sizeof LibraryInfoData.szLibraryPath, NULL, NULL);

        return (void*)&LibraryInfoData;
    }

    return NULL;
}

__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll)
{
    static LIBRARY_ITEM_DATAW LibraryData;
    memset(&LibraryData, 0, sizeof(LIBRARY_ITEM_DATAW));

    for(unsigned int i = 0; i < hListLibrary.size(); i++)
    {
        if(hListLibrary.at(i).hFile != INVALID_HANDLE_VALUE && hListLibrary.at(i).BaseOfDll == BaseOfDll)
        {
            memcpy(&LibraryData, &hListLibrary.at(i), sizeof(LIBRARY_ITEM_DATAW));

            return &LibraryData;
        }
    }

    return NULL;
}

__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack)
{
    if(!EnumCallBack)
        return;

    typedef void(TITCALL * fEnumCallBack)(LPVOID fLibraryDetail);
    fEnumCallBack myEnumCallBack = (fEnumCallBack)EnumCallBack;

    for(unsigned int i = 0; i < hListLibrary.size(); i++)
    {
        if(hListLibrary.at(i).hFile != INVALID_HANDLE_VALUE)
        {
            __try
            {
                LIBRARY_ITEM_DATA myLibraryInfoData;
                memset(&myLibraryInfoData, 0, sizeof(LIBRARY_ITEM_DATA));
                myLibraryInfoData.hFile = hListLibrary.at(i).hFile;
                myLibraryInfoData.BaseOfDll = hListLibrary.at(i).BaseOfDll;
                myLibraryInfoData.hFileMapping = hListLibrary.at(i).hFileMapping;
                myLibraryInfoData.hFileMappingView = hListLibrary.at(i).hFileMappingView;
                WideCharToMultiByte(CP_ACP, NULL, hListLibrary.at(i).szLibraryName, -1, &myLibraryInfoData.szLibraryName[0], sizeof(myLibraryInfoData.szLibraryName), NULL, NULL);
                WideCharToMultiByte(CP_ACP, NULL, hListLibrary.at(i).szLibraryPath, -1, &myLibraryInfoData.szLibraryPath[0], sizeof(myLibraryInfoData.szLibraryPath), NULL, NULL);
                myEnumCallBack(&myLibraryInfoData);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                break;
            }
        }
    }
}

__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack)
{
    if(!EnumCallBack)
        return;

    typedef void(TITCALL * fEnumCallBack)(LPVOID fLibraryDetail);
    fEnumCallBack myEnumCallBack = (fEnumCallBack)EnumCallBack;

    for(unsigned int i = 0; i < hListLibrary.size(); i++)
    {
        if(hListLibrary.at(i).hFile != INVALID_HANDLE_VALUE)
        {
            __try
            {
                myEnumCallBack(&hListLibrary.at(i));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                break;
            }
        }
    }
}



================================================
File: TitanEngine/TitanEngine.OEPFinder.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.OEPFinder.h"

// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit()
{
    RemoveAllBreakPoints(UE_OPTION_REMOVEALL);
}
__declspec(dllexport) bool TITCALL FindOEPGenerically(char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(FindOEPGenericallyW(uniFileName, TraceInitCallBack, CallBack));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack)
{

    int i;

    if(GenericOEPFileInitW(szFileName, TraceInitCallBack, CallBack))
    {
        InitDebugExW(szFileName, NULL, NULL, &GenericOEPTraceInit);
        DebugLoop();
        for(i = 0; i < glbEntryTracerData.SectionNumber; i++)
        {
            VirtualFree(glbEntryTracerData.SectionData[i].AllocatedSection, NULL, MEM_RELEASE);
        }
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.PE.Convert.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"

__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert)
{
    if(!FileMapVA)
        return -2;

    PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
    if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
    {
        PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        BOOL FileIs64;
        if(PEHeader32->OptionalHeader.Magic == 0x10B)
            FileIs64 = false;
        else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            FileIs64 = true;
        else
            return -2;

        if(!FileIs64) //x86
        {
            __try
            {
                ULONG_PTR ConvertAddress = AddressToConvert - PEHeader32->OptionalHeader.ImageBase;
                PIMAGE_SECTION_HEADER PESections = IMAGE_FIRST_SECTION(PEHeader32);
                DWORD SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                DWORD FoundInSection = -1;
                while(SectionNumber > 0)
                {
                    if(PESections->VirtualAddress <= ConvertAddress && ConvertAddress < PESections->VirtualAddress + max(PESections->Misc.VirtualSize, PESections->SizeOfRawData))
                    {
                        FoundInSection = PEHeader32->FileHeader.NumberOfSections - SectionNumber;
                    }
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                    SectionNumber--;
                }
                return FoundInSection;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return -2;
            }
        }
        else //x64
        {
            __try
            {
                ULONG_PTR ConvertAddress = AddressToConvert - (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase;
                PIMAGE_SECTION_HEADER PESections = IMAGE_FIRST_SECTION(PEHeader64);
                DWORD SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                DWORD FoundInSection = -1;
                while(SectionNumber > 0)
                {
                    if(PESections->VirtualAddress <= ConvertAddress && ConvertAddress < PESections->VirtualAddress + max(PESections->Misc.VirtualSize, PESections->SizeOfRawData))
                    {
                        FoundInSection = PEHeader64->FileHeader.NumberOfSections - SectionNumber;
                    }
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                    SectionNumber--;
                }
                return FoundInSection;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return -2;
            }
        }
    }
    return -2;
}
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType)
{
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    ULONG_PTR ConvertedAddress = 0;
    ULONG_PTR ConvertAddress = 0;
    BOOL FileIs64;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return(0);
            }
            if(!FileIs64)
            {
                ConvertAddress = (DWORD)((DWORD)AddressToConvert - PEHeader32->OptionalHeader.ImageBase);
                if(ConvertAddress < PEHeader32->OptionalHeader.SectionAlignment)
                {
                    ConvertedAddress = ConvertAddress;
                }
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->VirtualAddress <= ConvertAddress && ConvertAddress < PESections->VirtualAddress + max(PESections->Misc.VirtualSize, PESections->SizeOfRawData))
                        {
                            if(ConvertAddress - PESections->VirtualAddress <= PESections->SizeOfRawData)
                            {
                                ConvertedAddress = PESections->PointerToRawData + (ConvertAddress - PESections->VirtualAddress);
                            }
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress != NULL)
                        {
                            ConvertedAddress += FileMapVA;
                        }
                        else if(ConvertAddress == NULL)
                        {
                            ConvertedAddress = FileMapVA;
                        }
                    }
                    return ConvertedAddress;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(0);
                }
            }
            else
            {
                ConvertAddress = (DWORD)(AddressToConvert - PEHeader64->OptionalHeader.ImageBase);
                if(ConvertAddress < PEHeader64->OptionalHeader.SectionAlignment)
                {
                    ConvertedAddress = ConvertAddress;
                }
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->VirtualAddress <= ConvertAddress && ConvertAddress < PESections->VirtualAddress + max(PESections->Misc.VirtualSize, PESections->SizeOfRawData))
                        {
                            if(ConvertAddress - PESections->VirtualAddress <= PESections->SizeOfRawData)
                            {
                                ConvertedAddress = PESections->PointerToRawData + (ConvertAddress - PESections->VirtualAddress);
                            }
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress != NULL)
                        {
                            ConvertedAddress += FileMapVA;
                        }
                        else if(ConvertAddress == NULL)
                        {
                            ConvertedAddress = FileMapVA;
                        }
                    }
                    return(ConvertedAddress);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(0);
                }
            }
        }
        else
        {
            return(0);
        }
    }
    return(0);
}
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    ULONG_PTR ConvertedAddress = 0;
    ULONG_PTR ConvertAddress = 0;
    BOOL FileIs64;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return(0);
            }
            if(!FileIs64)
            {
                if(!AddressIsRVA)
                {
                    if(ImageBase == NULL)
                    {
                        ConvertAddress = (DWORD)((DWORD)AddressToConvert - PEHeader32->OptionalHeader.ImageBase);
                    }
                    else
                    {
                        ConvertAddress = (DWORD)((DWORD)AddressToConvert - ImageBase);
                    }
                }
                else
                {
                    ConvertAddress = (DWORD)AddressToConvert;
                }
                if(ConvertAddress < PEHeader32->OptionalHeader.SectionAlignment)
                {
                    ConvertedAddress = ConvertAddress;
                }
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->VirtualAddress <= ConvertAddress && ConvertAddress < PESections->VirtualAddress + max(PESections->Misc.VirtualSize, PESections->SizeOfRawData))
                        {
                            if(ConvertAddress - PESections->VirtualAddress <= PESections->SizeOfRawData)
                            {
                                ConvertedAddress = PESections->PointerToRawData + (ConvertAddress - PESections->VirtualAddress);
                            }
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress != NULL)
                        {
                            ConvertedAddress = ConvertedAddress + FileMapVA;
                        }
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress >= FileMapVA && ConvertedAddress <= FileMapVA + FileSize)
                        {
                            return((ULONG_PTR)ConvertedAddress);
                        }
                        else
                        {
                            return(NULL);
                        }
                    }
                    else
                    {
                        if(ConvertedAddress > NULL && ConvertedAddress <= FileSize)
                        {
                            return((ULONG_PTR)ConvertedAddress);
                        }
                        else
                        {
                            return(NULL);
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(NULL);
                }
            }
            else
            {
                if(!AddressIsRVA)
                {
                    if(ImageBase == NULL)
                    {
                        ConvertAddress = (DWORD)(AddressToConvert - PEHeader64->OptionalHeader.ImageBase);
                    }
                    else
                    {
                        ConvertAddress = (DWORD)(AddressToConvert - ImageBase);
                    }
                }
                else
                {
                    ConvertAddress = (DWORD)AddressToConvert;
                }
                if(ConvertAddress < PEHeader64->OptionalHeader.SectionAlignment)
                {
                    ConvertedAddress = ConvertAddress;
                }
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->VirtualAddress <= ConvertAddress && ConvertAddress < PESections->VirtualAddress + max(PESections->Misc.VirtualSize, PESections->SizeOfRawData))
                        {
                            if(ConvertAddress - PESections->VirtualAddress <= PESections->SizeOfRawData)
                            {
                                ConvertedAddress = PESections->PointerToRawData + (ConvertAddress - PESections->VirtualAddress);
                            }
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress != NULL)
                        {
                            ConvertedAddress = ConvertedAddress + FileMapVA;
                        }
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress >= FileMapVA && ConvertedAddress <= FileMapVA + FileSize)
                        {
                            return((ULONG_PTR)ConvertedAddress);
                        }
                        else
                        {
                            return(NULL);
                        }
                    }
                    else
                    {
                        if(ConvertedAddress > NULL && ConvertedAddress <= FileSize)
                        {
                            return((ULONG_PTR)ConvertedAddress);
                        }
                        else
                        {
                            return(NULL);
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(NULL);
                }
            }
        }
        else
        {
            return(0);
        }
    }
    return(0);
}
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    ULONG_PTR ConvertedAddress = 0;
    ULONG_PTR ConvertAddress = 0;
    BOOL FileIs64;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return(0);
            }
            if(!FileIs64)
            {
                ConvertAddress = (DWORD)((DWORD)AddressToConvert - FileMapVA);
                if(ConvertAddress < PEHeader32->OptionalHeader.FileAlignment)
                {
                    ConvertedAddress = ConvertAddress;
                }
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->PointerToRawData <= ConvertAddress && ConvertAddress <= PESections->PointerToRawData + PESections->SizeOfRawData)
                        {
                            ConvertedAddress = PESections->VirtualAddress + (ConvertAddress - PESections->PointerToRawData);
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress != NULL)
                        {
                            ConvertedAddress = ConvertedAddress + PEHeader32->OptionalHeader.ImageBase;
                        }
                    }
                    else if(ConvertAddress == NULL)
                    {
                        ConvertedAddress = PEHeader32->OptionalHeader.ImageBase;
                    }
                    return(ConvertedAddress);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(0);
                }
            }
            else
            {
                ConvertAddress = (DWORD)(AddressToConvert - FileMapVA);
                if(ConvertAddress < PEHeader64->OptionalHeader.FileAlignment)
                {
                    ConvertedAddress = ConvertAddress;
                }
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->PointerToRawData <= ConvertAddress && ConvertAddress <= PESections->PointerToRawData + PESections->SizeOfRawData)
                        {
                            ConvertedAddress = PESections->VirtualAddress + (ConvertAddress - PESections->PointerToRawData);
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    if(ReturnType)
                    {
                        if(ConvertedAddress != NULL)
                        {
                            ConvertedAddress = ConvertedAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase;
                        }
                    }
                    else if(ConvertAddress == NULL)
                    {
                        ConvertedAddress = (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase;
                    }
                    return(ConvertedAddress);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(0);
                }
            }
        }
        else
        {
            return(0);
        }
    }
    return(0);
}
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType)
{

    ULONG_PTR ConvertedAddress = NULL;
    DWORD cnvSectionAlignment = NULL;
    ULONG_PTR cnvImageBase = NULL;
    DWORD cnvSizeOfImage = NULL;

    if(FileMapVA != NULL)
    {
        if(ImageBase == NULL)
        {
            cnvImageBase = (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMAGEBASE);
        }
        else
        {
            cnvImageBase = ImageBase;
        }
        cnvSizeOfImage = (DWORD)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_SIZEOFIMAGE);
        cnvSectionAlignment = (DWORD)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_SECTIONALIGNMENT);
        ConvertedAddress = (ULONG_PTR)ConvertFileOffsetToVA(FileMapVA, AddressToConvert, ReturnType);
        if(ReturnType)
        {
            if(ConvertedAddress >= cnvImageBase + cnvSectionAlignment && ConvertedAddress <= cnvImageBase + cnvSizeOfImage)
            {
                return((ULONG_PTR)ConvertedAddress);
            }
            else
            {
                return(NULL);
            }
        }
        else
        {
            if(ConvertedAddress >= cnvSectionAlignment && ConvertedAddress <= cnvSizeOfImage)
            {
                return((ULONG_PTR)ConvertedAddress);
            }
            else
            {
                return(NULL);
            }
        }
    }
    return(NULL);
}



================================================
File: TitanEngine/TitanEngine.PE.Data.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Mapping.h"

__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    BOOL FileIs64;
    static char sectionName[9] = "";

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
            {
                FileIs64 = true;
            }
            else
            {
                return(0);
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                if(WhichData < UE_SECTIONNAME)
                {
                    if(WhichData == UE_PE_OFFSET)
                    {
                        return(DOSHeader->e_lfanew);
                    }
                    else if(WhichData == UE_IMAGEBASE)
                    {
                        return(PEHeader32->OptionalHeader.ImageBase);
                    }
                    else if(WhichData == UE_OEP)
                    {
                        return(PEHeader32->OptionalHeader.AddressOfEntryPoint);
                    }
                    else if(WhichData == UE_BASEOFCODE)
                    {
                        return(PEHeader32->OptionalHeader.BaseOfCode);
                    }
                    else if(WhichData == UE_BASEOFDATA)
                    {
                        return(PEHeader32->OptionalHeader.BaseOfData);
                    }
                    else if(WhichData == UE_SIZEOFIMAGE)
                    {
                        return(PEHeader32->OptionalHeader.SizeOfImage);
                    }
                    else if(WhichData == UE_SIZEOFHEADERS)
                    {
                        return(PEHeader32->OptionalHeader.SizeOfHeaders);
                    }
                    else if(WhichData == UE_SIZEOFOPTIONALHEADER)
                    {
                        return(PEHeader32->FileHeader.SizeOfOptionalHeader);
                    }
                    else if(WhichData == UE_SECTIONALIGNMENT)
                    {
                        return(PEHeader32->OptionalHeader.SectionAlignment);
                    }
                    else if(WhichData == UE_IMPORTTABLEADDRESS)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
                    }
                    else if(WhichData == UE_IMPORTTABLESIZE)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);
                    }
                    else if(WhichData == UE_RESOURCETABLEADDRESS)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);
                    }
                    else if(WhichData == UE_RESOURCETABLESIZE)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size);
                    }
                    else if(WhichData == UE_EXPORTTABLEADDRESS)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
                    }
                    else if(WhichData == UE_EXPORTTABLESIZE)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);
                    }
                    else if(WhichData == UE_TLSTABLEADDRESS)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                    }
                    else if(WhichData == UE_TLSTABLESIZE)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size);
                    }
                    else if(WhichData == UE_RELOCATIONTABLEADDRESS)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
                    }
                    else if(WhichData == UE_RELOCATIONTABLESIZE)
                    {
                        return(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
                    }
                    else if(WhichData == UE_TIMEDATESTAMP)
                    {
                        return(PEHeader32->FileHeader.TimeDateStamp);
                    }
                    else if(WhichData == UE_SECTIONNUMBER)
                    {
                        return(PEHeader32->FileHeader.NumberOfSections);
                    }
                    else if(WhichData == UE_CHECKSUM)
                    {
                        return(PEHeader32->OptionalHeader.CheckSum);
                    }
                    else if(WhichData == UE_SUBSYSTEM)
                    {
                        return(PEHeader32->OptionalHeader.Subsystem);
                    }
                    else if(WhichData == UE_CHARACTERISTICS)
                    {
                        return(PEHeader32->FileHeader.Characteristics);
                    }
                    else if(WhichData == UE_NUMBEROFRVAANDSIZES)
                    {
                        return(PEHeader32->OptionalHeader.NumberOfRvaAndSizes);
                    }
                    else if(WhichData == UE_DLLCHARACTERISTICS)
                    {
                        return(PEHeader32->OptionalHeader.DllCharacteristics);
                    }
                    else
                    {
                        return(0);
                    }
                }
                else
                {
                    if(SectionNumber >= WhichSection)
                    {
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + WhichSection * IMAGE_SIZEOF_SECTION_HEADER);
                        if(WhichData == UE_SECTIONNAME)
                        {
                            memcpy(sectionName, PESections->Name, 8);
                            return (ULONG_PTR)sectionName;
                        }
                        else if(WhichData == UE_SECTIONVIRTUALOFFSET)
                        {
                            return(PESections->VirtualAddress);
                        }
                        else if(WhichData == UE_SECTIONVIRTUALSIZE)
                        {
                            return(PESections->Misc.VirtualSize);
                        }
                        else if(WhichData == UE_SECTIONRAWOFFSET)
                        {
                            return(PESections->PointerToRawData);
                        }
                        else if(WhichData == UE_SECTIONRAWSIZE)
                        {
                            return(PESections->SizeOfRawData);
                        }
                        else if(WhichData == UE_SECTIONFLAGS)
                        {
                            return(PESections->Characteristics);
                        }
                        else
                        {
                            return(0);
                        }
                    }
                }
                return(0);
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                if(WhichData < UE_SECTIONNAME)
                {
                    if(WhichData == UE_PE_OFFSET)
                    {
                        return(DOSHeader->e_lfanew);
                    }
                    else if(WhichData == UE_IMAGEBASE)
                    {
                        return (ULONG_PTR)(PEHeader64->OptionalHeader.ImageBase);
                    }
                    else if(WhichData == UE_OEP)
                    {
                        return(PEHeader64->OptionalHeader.AddressOfEntryPoint);
                    }
                    else if(WhichData == UE_BASEOFCODE)
                    {
                        return(PEHeader64->OptionalHeader.BaseOfCode);
                    }
                    /* non-existent in IMAGE_OPTIONAL_HEADER64
                    else if(WhichData == UE_BASEOFDATA)
                    {
                        return(PEHeader64->OptionalHeader.BaseOfData);
                    }*/
                    else if(WhichData == UE_SIZEOFIMAGE)
                    {
                        return(PEHeader64->OptionalHeader.SizeOfImage);
                    }
                    else if(WhichData == UE_SIZEOFHEADERS)
                    {
                        return(PEHeader64->OptionalHeader.SizeOfHeaders);
                    }
                    else if(WhichData == UE_SIZEOFOPTIONALHEADER)
                    {
                        return(PEHeader64->FileHeader.SizeOfOptionalHeader);
                    }
                    else if(WhichData == UE_SECTIONALIGNMENT)
                    {
                        return(PEHeader64->OptionalHeader.SectionAlignment);
                    }
                    else if(WhichData == UE_IMPORTTABLEADDRESS)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
                    }
                    else if(WhichData == UE_IMPORTTABLESIZE)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);
                    }
                    else if(WhichData == UE_RESOURCETABLEADDRESS)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);
                    }
                    else if(WhichData == UE_RESOURCETABLESIZE)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size);
                    }
                    else if(WhichData == UE_EXPORTTABLEADDRESS)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
                    }
                    else if(WhichData == UE_EXPORTTABLESIZE)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);
                    }
                    else if(WhichData == UE_TLSTABLEADDRESS)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                    }
                    else if(WhichData == UE_TLSTABLESIZE)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size);
                    }
                    else if(WhichData == UE_RELOCATIONTABLEADDRESS)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
                    }
                    else if(WhichData == UE_RELOCATIONTABLESIZE)
                    {
                        return(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);
                    }
                    else if(WhichData == UE_TIMEDATESTAMP)
                    {
                        return(PEHeader64->FileHeader.TimeDateStamp);
                    }
                    else if(WhichData == UE_SECTIONNUMBER)
                    {
                        return(PEHeader64->FileHeader.NumberOfSections);
                    }
                    else if(WhichData == UE_CHECKSUM)
                    {
                        return(PEHeader64->OptionalHeader.CheckSum);
                    }
                    else if(WhichData == UE_SUBSYSTEM)
                    {
                        return(PEHeader64->OptionalHeader.Subsystem);
                    }
                    else if(WhichData == UE_CHARACTERISTICS)
                    {
                        return(PEHeader64->FileHeader.Characteristics);
                    }
                    else if(WhichData == UE_NUMBEROFRVAANDSIZES)
                    {
                        return(PEHeader64->OptionalHeader.NumberOfRvaAndSizes);
                    }
                    else if(WhichData == UE_DLLCHARACTERISTICS)
                    {
                        return(PEHeader64->OptionalHeader.DllCharacteristics);
                    }
                    else
                    {
                        return(0);
                    }
                }
                else
                {
                    if(SectionNumber >= WhichSection)
                    {
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + WhichSection * IMAGE_SIZEOF_SECTION_HEADER);
                        if(WhichData == UE_SECTIONNAME)
                        {
                            memcpy(sectionName, PESections->Name, 8);
                            return (ULONG_PTR)sectionName;
                        }
                        else if(WhichData == UE_SECTIONVIRTUALOFFSET)
                        {
                            return(PESections->VirtualAddress);
                        }
                        else if(WhichData == UE_SECTIONVIRTUALSIZE)
                        {
                            return(PESections->Misc.VirtualSize);
                        }
                        else if(WhichData == UE_SECTIONRAWOFFSET)
                        {
                            return(PESections->PointerToRawData);
                        }
                        else if(WhichData == UE_SECTIONRAWSIZE)
                        {
                            return(PESections->SizeOfRawData);
                        }
                        else if(WhichData == UE_SECTIONFLAGS)
                        {
                            return(PESections->Characteristics);
                        }
                        else
                        {
                            return(0);
                        }
                    }
                }
                return(0);
            }
        }
        else
        {
            return(0);
        }
    }
    return(0);
}
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(char* szFileName, DWORD WhichSection, DWORD WhichData)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileEx(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = GetPE32DataFromMappedFile(FileMapVA, WhichSection, WhichData);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        return(ReturnValue);
    }
    else
    {
        return(0);
    }
}
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = GetPE32DataFromMappedFile(FileMapVA, WhichSection, WhichData);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        return(ReturnValue);
    }
    else
    {
        return(0);
    }
}
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    BOOL FileIs64;
    PPE32Struct PE32Structure = (PPE32Struct)DataStorage;
    PPE64Struct PE64Structure = (PPE64Struct)DataStorage;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return false;
            }
            if(!FileIs64)
            {
                PE32Structure->PE32Offset = DOSHeader->e_lfanew;
                PE32Structure->ImageBase = PEHeader32->OptionalHeader.ImageBase;
                PE32Structure->OriginalEntryPoint = PEHeader32->OptionalHeader.AddressOfEntryPoint;
                PE32Structure->BaseOfCode = PEHeader32->OptionalHeader.BaseOfCode;
                PE32Structure->BaseOfData = PEHeader32->OptionalHeader.BaseOfData;
                PE32Structure->NtSizeOfImage = PEHeader32->OptionalHeader.SizeOfImage;
                PE32Structure->NtSizeOfHeaders = PEHeader32->OptionalHeader.SizeOfHeaders;
                PE32Structure->SizeOfOptionalHeaders = PEHeader32->FileHeader.SizeOfOptionalHeader;
                PE32Structure->FileAlignment = PEHeader32->OptionalHeader.FileAlignment;
                PE32Structure->SectionAligment = PEHeader32->OptionalHeader.SectionAlignment;
                PE32Structure->ImportTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
                PE32Structure->ImportTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
                PE32Structure->ResourceTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                PE32Structure->ResourceTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                PE32Structure->ExportTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                PE32Structure->ExportTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                PE32Structure->TLSTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                PE32Structure->TLSTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                PE32Structure->RelocationTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                PE32Structure->RelocationTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                PE32Structure->TimeDateStamp = PEHeader32->FileHeader.TimeDateStamp;
                PE32Structure->SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                PE32Structure->CheckSum = PEHeader32->OptionalHeader.CheckSum;
                PE32Structure->SubSystem = PEHeader32->OptionalHeader.Subsystem;
                PE32Structure->Characteristics = PEHeader32->FileHeader.Characteristics;
                PE32Structure->NumberOfRvaAndSizes = PEHeader32->OptionalHeader.NumberOfRvaAndSizes;
                return true;
            }
            else
            {
                PE64Structure->PE64Offset = DOSHeader->e_lfanew;
                PE64Structure->ImageBase = PEHeader64->OptionalHeader.ImageBase;
                PE64Structure->OriginalEntryPoint = PEHeader64->OptionalHeader.AddressOfEntryPoint;
                PE64Structure->BaseOfCode = PEHeader32->OptionalHeader.BaseOfCode;
                PE64Structure->BaseOfData = PEHeader32->OptionalHeader.BaseOfData;
                PE64Structure->NtSizeOfImage = PEHeader64->OptionalHeader.SizeOfImage;
                PE64Structure->NtSizeOfHeaders = PEHeader64->OptionalHeader.SizeOfHeaders;
                PE64Structure->SizeOfOptionalHeaders = PEHeader64->FileHeader.SizeOfOptionalHeader;
                PE64Structure->FileAlignment = PEHeader64->OptionalHeader.FileAlignment;
                PE64Structure->SectionAligment = PEHeader64->OptionalHeader.SectionAlignment;
                PE64Structure->ImportTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
                PE64Structure->ImportTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
                PE64Structure->ResourceTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                PE64Structure->ResourceTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                PE64Structure->ExportTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                PE64Structure->ExportTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                PE64Structure->TLSTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                PE64Structure->TLSTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                PE64Structure->RelocationTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                PE64Structure->RelocationTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                PE64Structure->TimeDateStamp = PEHeader64->FileHeader.TimeDateStamp;
                PE64Structure->SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                PE64Structure->CheckSum = PEHeader64->OptionalHeader.CheckSum;
                PE64Structure->SubSystem = PEHeader64->OptionalHeader.Subsystem;
                PE64Structure->Characteristics = PEHeader64->FileHeader.Characteristics;
                PE64Structure->NumberOfRvaAndSizes = PEHeader64->OptionalHeader.NumberOfRvaAndSizes;
                return true;
            }
        }
        else
        {
            return false;
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL GetPE32DataEx(char* szFileName, LPVOID DataStorage)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileEx(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = GetPE32DataFromMappedFileEx(FileMapVA, DataStorage);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL GetPE32DataExW(wchar_t* szFileName, LPVOID DataStorage)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = GetPE32DataFromMappedFileEx(FileMapVA, DataStorage);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    BOOL FileIs64;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return false;
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    if(WhichData < UE_SECTIONNAME)
                    {
                        if(WhichData == UE_PE_OFFSET)
                        {
                            DOSHeader->e_lfanew = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_IMAGEBASE)
                        {
                            PEHeader32->OptionalHeader.ImageBase = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_OEP)
                        {
                            PEHeader32->OptionalHeader.AddressOfEntryPoint = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_BASEOFCODE)
                        {
                            PEHeader32->OptionalHeader.BaseOfCode = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_BASEOFDATA)
                        {
                            PEHeader32->OptionalHeader.BaseOfData = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SIZEOFIMAGE)
                        {
                            PEHeader32->OptionalHeader.SizeOfImage = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SIZEOFHEADERS)
                        {
                            PEHeader32->OptionalHeader.SizeOfHeaders = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SIZEOFOPTIONALHEADER)
                        {
                            PEHeader32->FileHeader.SizeOfOptionalHeader = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SECTIONALIGNMENT)
                        {
                            PEHeader32->OptionalHeader.SectionAlignment = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_IMPORTTABLEADDRESS)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_IMPORTTABLESIZE)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RESOURCETABLEADDRESS)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RESOURCETABLESIZE)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_EXPORTTABLEADDRESS)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_EXPORTTABLESIZE)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_TLSTABLEADDRESS)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_TLSTABLESIZE)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RELOCATIONTABLEADDRESS)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RELOCATIONTABLESIZE)
                        {
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_TIMEDATESTAMP)
                        {
                            PEHeader32->FileHeader.TimeDateStamp = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SECTIONNUMBER)
                        {
                            PEHeader32->FileHeader.NumberOfSections = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_CHECKSUM)
                        {
                            PEHeader32->OptionalHeader.CheckSum = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SUBSYSTEM)
                        {
                            PEHeader32->OptionalHeader.Subsystem = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_CHARACTERISTICS)
                        {
                            PEHeader32->FileHeader.Characteristics = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_NUMBEROFRVAANDSIZES)
                        {
                            PEHeader32->OptionalHeader.NumberOfRvaAndSizes = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_DLLCHARACTERISTICS)
                        {
                            PEHeader32->OptionalHeader.DllCharacteristics = (WORD)NewDataValue;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        if(WhichSection <= SectionNumber)
                        {
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + WhichSection * IMAGE_SIZEOF_SECTION_HEADER);
                            if(WhichData == UE_SECTIONNAME)
                            {
                                memcpy(PESections->Name, (void*)NewDataValue, 8);
                                return true;
                            }
                            else if(WhichData == UE_SECTIONVIRTUALOFFSET)
                            {
                                PESections->VirtualAddress = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONVIRTUALSIZE)
                            {
                                PESections->Misc.VirtualSize = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONRAWOFFSET)
                            {
                                PESections->PointerToRawData = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONRAWSIZE)
                            {
                                PESections->SizeOfRawData = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONFLAGS)
                            {
                                PESections->Characteristics = (DWORD)NewDataValue;
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return false;
                }
                return false;
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    if(WhichData < UE_SECTIONNAME)
                    {
                        if(WhichData == UE_PE_OFFSET)
                        {
                            DOSHeader->e_lfanew = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_IMAGEBASE)
                        {
                            PEHeader64->OptionalHeader.ImageBase = NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_OEP)
                        {
                            PEHeader64->OptionalHeader.AddressOfEntryPoint = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_BASEOFCODE)
                        {
                            PEHeader64->OptionalHeader.BaseOfCode = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_BASEOFDATA)
                        {
                            //non-existant in IMAGE_OPTIONAL_HEADER64
                            return false;
                        }
                        else if(WhichData == UE_SIZEOFIMAGE)
                        {
                            PEHeader64->OptionalHeader.SizeOfImage = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SIZEOFHEADERS)
                        {
                            PEHeader64->OptionalHeader.SizeOfHeaders = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SIZEOFOPTIONALHEADER)
                        {
                            PEHeader64->FileHeader.SizeOfOptionalHeader = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SECTIONALIGNMENT)
                        {
                            PEHeader64->OptionalHeader.SectionAlignment = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_IMPORTTABLEADDRESS)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_IMPORTTABLESIZE)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RESOURCETABLEADDRESS)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RESOURCETABLESIZE)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_EXPORTTABLEADDRESS)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_EXPORTTABLESIZE)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_TLSTABLEADDRESS)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_TLSTABLESIZE)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RELOCATIONTABLEADDRESS)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_RELOCATIONTABLESIZE)
                        {
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_TIMEDATESTAMP)
                        {
                            PEHeader64->FileHeader.TimeDateStamp = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SECTIONNUMBER)
                        {
                            PEHeader64->FileHeader.NumberOfSections = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_CHECKSUM)
                        {
                            PEHeader64->OptionalHeader.CheckSum = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_SUBSYSTEM)
                        {
                            PEHeader64->OptionalHeader.Subsystem = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_CHARACTERISTICS)
                        {
                            PEHeader64->FileHeader.Characteristics = (WORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_NUMBEROFRVAANDSIZES)
                        {
                            PEHeader64->OptionalHeader.NumberOfRvaAndSizes = (DWORD)NewDataValue;
                            return true;
                        }
                        else if(WhichData == UE_DLLCHARACTERISTICS)
                        {
                            PEHeader64->OptionalHeader.DllCharacteristics = (WORD)NewDataValue;
                            return true;
                        }
                        else
                        {
                            return(0);
                        }
                    }
                    else
                    {
                        if(WhichSection <= SectionNumber)
                        {
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + WhichSection * IMAGE_SIZEOF_SECTION_HEADER);
                            if(WhichData == UE_SECTIONNAME)
                            {
                                return false;
                            }
                            else if(WhichData == UE_SECTIONVIRTUALOFFSET)
                            {
                                PESections->VirtualAddress = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONVIRTUALSIZE)
                            {
                                PESections->Misc.VirtualSize = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONRAWOFFSET)
                            {
                                PESections->PointerToRawData = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONRAWSIZE)
                            {
                                PESections->SizeOfRawData = (DWORD)NewDataValue;
                                return true;
                            }
                            else if(WhichData == UE_SECTIONFLAGS)
                            {
                                PESections->Characteristics = (DWORD)NewDataValue;
                                return true;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return false;
                }
                return false;
            }
        }
        else
        {
            return false;
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL SetPE32Data(char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileEx(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = SetPE32DataForMappedFile(FileMapVA, WhichSection, WhichData, NewDataValue);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL SetPE32DataW(wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = SetPE32DataForMappedFile(FileMapVA, WhichSection, WhichData, NewDataValue);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    BOOL FileIs64;
    PPE32Struct PE32Structure = (PPE32Struct)DataStorage;
    PPE64Struct PE64Structure = (PPE64Struct)DataStorage;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return false;
            }
            if(!FileIs64)
            {
                __try
                {
                    DOSHeader->e_lfanew = PE32Structure->PE32Offset;
                    PEHeader32->OptionalHeader.ImageBase = PE32Structure->ImageBase;
                    PEHeader32->OptionalHeader.AddressOfEntryPoint = PE32Structure->OriginalEntryPoint;
                    PEHeader32->OptionalHeader.BaseOfCode = PE32Structure->BaseOfCode;
                    PEHeader32->OptionalHeader.BaseOfData = PE32Structure->BaseOfData;
                    PEHeader32->OptionalHeader.SizeOfImage = PE32Structure->NtSizeOfImage;
                    PEHeader32->OptionalHeader.SizeOfHeaders = PE32Structure->NtSizeOfHeaders;
                    PEHeader32->FileHeader.SizeOfOptionalHeader = PE32Structure->SizeOfOptionalHeaders;
                    PEHeader32->OptionalHeader.FileAlignment = PE32Structure->FileAlignment;
                    PEHeader32->OptionalHeader.SectionAlignment = PE32Structure->SectionAligment;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = PE32Structure->ImportTableAddress;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = PE32Structure->ImportTableSize;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = PE32Structure->ResourceTableAddress;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = PE32Structure->ResourceTableSize;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = PE32Structure->ExportTableAddress;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = PE32Structure->ExportTableSize;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = PE32Structure->TLSTableAddress;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = PE32Structure->TLSTableSize;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = PE32Structure->RelocationTableAddress;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = PE32Structure->RelocationTableSize;
                    PEHeader32->FileHeader.TimeDateStamp = PE32Structure->TimeDateStamp;
                    PEHeader32->FileHeader.NumberOfSections = PE32Structure->SectionNumber;
                    PEHeader32->OptionalHeader.CheckSum = PE32Structure->CheckSum;
                    PEHeader32->OptionalHeader.Subsystem = PE32Structure->SubSystem;
                    PEHeader32->FileHeader.Characteristics = PE32Structure->Characteristics;
                    PEHeader32->OptionalHeader.NumberOfRvaAndSizes = PE32Structure->NumberOfRvaAndSizes;
                    return true;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return false;
                }
            }
            else
            {
                __try
                {
                    DOSHeader->e_lfanew = PE64Structure->PE64Offset;
                    PEHeader64->OptionalHeader.ImageBase = PE64Structure->ImageBase;
                    PEHeader64->OptionalHeader.AddressOfEntryPoint = PE64Structure->OriginalEntryPoint;
                    PEHeader64->OptionalHeader.BaseOfCode = PE64Structure->BaseOfCode;
                    PEHeader64->OptionalHeader.SizeOfImage = PE64Structure->NtSizeOfImage;
                    PEHeader64->OptionalHeader.SizeOfHeaders = PE64Structure->NtSizeOfHeaders;
                    PEHeader64->FileHeader.SizeOfOptionalHeader = PE64Structure->SizeOfOptionalHeaders;
                    PEHeader64->OptionalHeader.FileAlignment = PE64Structure->FileAlignment;
                    PEHeader64->OptionalHeader.SectionAlignment = PE64Structure->SectionAligment;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = PE64Structure->ImportTableAddress;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = PE64Structure->ImportTableSize;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = PE64Structure->ResourceTableAddress;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = PE64Structure->ResourceTableSize;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = PE64Structure->ExportTableAddress;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = PE64Structure->ExportTableSize;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = PE64Structure->TLSTableAddress;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = PE64Structure->TLSTableSize;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = PE64Structure->RelocationTableAddress;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = PE64Structure->RelocationTableSize;
                    PEHeader64->FileHeader.TimeDateStamp = PE64Structure->TimeDateStamp;
                    PEHeader64->FileHeader.NumberOfSections = PE64Structure->SectionNumber;
                    PEHeader64->OptionalHeader.CheckSum = PE64Structure->CheckSum;
                    PEHeader64->OptionalHeader.Subsystem = PE64Structure->SubSystem;
                    PEHeader64->FileHeader.Characteristics = PE64Structure->Characteristics;
                    PEHeader64->OptionalHeader.NumberOfRvaAndSizes = PE64Structure->NumberOfRvaAndSizes;
                    return true;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return false;
                }
            }
        }
        else
        {
            return false;
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL SetPE32DataEx(char* szFileName, LPVOID DataStorage)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileEx(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = SetPE32DataForMappedFileEx(FileMapVA, DataStorage);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL SetPE32DataExW(wchar_t* szFileName, LPVOID DataStorage)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    ULONG_PTR ReturnValue = 0;

    if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = SetPE32DataForMappedFileEx(FileMapVA, DataStorage);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL IsFileDLL(char* szFileName, ULONG_PTR FileMapVA)
{

    if(szFileName != NULL)
    {
        if((DWORD)GetPE32Data(szFileName, NULL, UE_CHARACTERISTICS) & 0x2000)
        {
            return true;
        }
    }
    else if(FileMapVA != NULL)
    {
        if((DWORD)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_CHARACTERISTICS) & 0x2000)
        {
            return true;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL IsFileDLLW(wchar_t* szFileName, ULONG_PTR FileMapVA)
{

    if(szFileName != NULL)
    {
        if((DWORD)GetPE32DataW(szFileName, NULL, UE_CHARACTERISTICS) & 0x2000)
        {
            return true;
        }
    }
    else if(FileMapVA != NULL)
    {
        if((DWORD)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_CHARACTERISTICS) & 0x2000)
        {
            return true;
        }
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.PE.Fixer.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Mapping.h"
#include "Global.Realigner.h"

__declspec(dllexport) bool TITCALL IsPE32FileValidEx(char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(IsPE32FileValidExW(uniFileName, CheckDepth, FileStatusInfo));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL IsPE32FileValidExW(wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo)
{
    unsigned int i;
    ULONG_PTR ReadData = NULL;
    DWORD ReadSize = 0;
    WORD ReadDataWORD = 0;
    ULONG_PTR hSimulatedFileLoad;
    long SectionNumber = 0;
    DWORD SectionAttributes = 0;
    ULONG_PTR ConvertedAddress = NULL;
    DWORD CorrectedImageSize = 0;
    DWORD SectionVirtualSize = 0;
    DWORD SectionVirtualSizeFixed = 0;
    DWORD NumberOfSections = 0;
    FILE_STATUS_INFO myFileStatusInfo;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    PIMAGE_TLS_DIRECTORY32 PETls32;
    PIMAGE_TLS_DIRECTORY64 PETls64;
    PIMAGE_IMPORT_DESCRIPTOR ImportIID;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR BoundIID;
    PIMAGE_THUNK_DATA32 ThunkData32;
    PIMAGE_THUNK_DATA64 ThunkData64;
    bool hLoadedModuleSimulated = false;
    HMODULE hLoadedModule;
    ULONG_PTR ImportNamePtr;
    ULONG_PTR CurrentThunk;
    BOOL FileIsDLL = false;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    WORD ResourceNamesTable[22] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24};

    RtlZeroMemory(&myFileStatusInfo, sizeof FILE_STATUS_INFO);
    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        myFileStatusInfo.OveralEvaluation = UE_RESULT_FILE_OK;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->Signature == 0x4550 && PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->Signature == 0x4550 && PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
                myFileStatusInfo.FileIs64Bit = true;
            }
            else
            {
                myFileStatusInfo.OveralEvaluation = UE_RESULT_FILE_INVALID_FORMAT;
                myFileStatusInfo.SignaturePE = UE_FIELD_BROKEN_NON_FIXABLE;
                if(FileStatusInfo != NULL)
                {
                    RtlMoveMemory(FileStatusInfo, &myFileStatusInfo, sizeof FILE_STATUS_INFO);
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                /*
                    x86 Surface check
                */
                __try
                {
                    if(PEHeader32->OptionalHeader.SizeOfImage % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                    {
                        CorrectedImageSize = ((PEHeader32->OptionalHeader.SizeOfImage / PEHeader32->OptionalHeader.SectionAlignment)) * PEHeader32->OptionalHeader.SectionAlignment;
                    }
                    else
                    {
                        CorrectedImageSize = ((PEHeader32->OptionalHeader.SizeOfImage / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment;
                    }
                    if(PEHeader32->OptionalHeader.SectionAlignment != NULL && PEHeader32->OptionalHeader.SectionAlignment >= PEHeader32->OptionalHeader.FileAlignment)
                    {
                        myFileStatusInfo.SectionAlignment = UE_FIELD_OK;
                        if(PEHeader32->OptionalHeader.SizeOfImage % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                        {
                            myFileStatusInfo.SizeOfImage = UE_FIELD_OK;
                        }
                        else
                        {
                            if(CorrectedImageSize < PEHeader32->OptionalHeader.AddressOfEntryPoint)
                            {
                                myFileStatusInfo.SizeOfImage = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                myFileStatusInfo.SizeOfImage = UE_FIELD_FIXABLE_NON_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.SectionAlignment = UE_FIELD_FIXABLE_CRITICAL;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.SectionAlignment, true);
                    if(PEHeader32->OptionalHeader.ImageBase % 0x1000 == NULL)
                    {
                        myFileStatusInfo.ImageBase = UE_FIELD_OK;
                    }
                    else
                    {
                        myFileStatusInfo.ImageBase = UE_FIELD_BROKEN_NON_FIXABLE;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImageBase, true);
                    if(PEHeader32->OptionalHeader.FileAlignment % 2 == NULL)
                    {
                        myFileStatusInfo.FileAlignment = UE_FIELD_OK;
                    }
                    else
                    {
                        myFileStatusInfo.FileAlignment = UE_FIELD_FIXABLE_CRITICAL;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.FileAlignment, false);
                    /*
                        Get the console flag
                    */
                    if(PEHeader32->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)
                    {
                        myFileStatusInfo.FileIsConsole = true;
                    }
                    /*
                        Export and relocation checks [for DLL and EXE]
                    */
                    if(PEHeader32->FileHeader.Characteristics & 0x2000)
                    {
                        /*
                            Export table check
                        */
                        FileIsDLL = true;
                        myFileStatusInfo.FileIsDLL = true;
                        if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_EXPORT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                        {
                            if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
                                    {
                                        PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertedAddress;
                                        if(PEExports->AddressOfFunctions > CorrectedImageSize || PEExports->AddressOfFunctions + 4 * PEExports->NumberOfFunctions > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else if(PEExports->AddressOfNameOrdinals > CorrectedImageSize || PEExports->AddressOfNameOrdinals + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else if(PEExports->AddressOfNames > CorrectedImageSize || PEExports->AddressOfNames + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else if(PEExports->Name > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else
                                        {
                                            if(CheckDepth == UE_DEPTH_DEEP)
                                            {
                                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEExports->AddressOfFunctions + PEHeader32->OptionalHeader.ImageBase, false, true);
                                                if(ConvertedAddress != NULL)
                                                {
                                                    for(i = 0; i < PEExports->NumberOfFunctions; i++)
                                                    {
                                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                                        if(ReadData > CorrectedImageSize || ReadData < PEHeader32->OptionalHeader.SectionAlignment)
                                                        {
                                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            i = PEExports->NumberOfFunctions;
                                                        }
                                                        else
                                                        {
                                                            ConvertedAddress = ConvertedAddress + 4;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEExports->AddressOfNames + PEHeader32->OptionalHeader.ImageBase, false, true);
                                                if(ConvertedAddress != NULL)
                                                {
                                                    for(i = 0; i < PEExports->NumberOfNames; i++)
                                                    {
                                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                                        if(ReadData > CorrectedImageSize || ReadData < PEHeader32->OptionalHeader.SectionAlignment)
                                                        {
                                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            i = PEExports->NumberOfNames;
                                                        }
                                                        else
                                                        {
                                                            ConvertedAddress = ConvertedAddress + 4;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                    }
                                }
                                else
                                {
                                    myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ExportTable, true);
                        }
                        else
                        {
                            myFileStatusInfo.ExportTable = UE_FIELD_NOT_PRESET;
                        }
                        /*
                            Relocation table check
                        */
                        if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != NULL)
                        {
                            if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size))
                                    {
                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                        RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        while(ReadData != NULL)
                                        {
                                            ReadSize = ReadSize - 8;
                                            ConvertedAddress = ConvertedAddress + 8;
                                            while(ReadSize > NULL)
                                            {
                                                RtlMoveMemory(&ReadDataWORD, (LPVOID)ConvertedAddress, 2);
                                                if(ReadDataWORD > 0xCFFF)
                                                {
                                                    myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE;
                                                }
                                                ConvertedAddress = ConvertedAddress + 2;
                                                ReadSize = ReadSize - 2;
                                            }
                                            RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                            RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        }
                                    }
                                    else
                                    {
                                        myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE;
                                    }
                                }
                                else
                                {
                                    myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE;
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.RelocationTable, true);
                        }
                        else
                        {
                            myFileStatusInfo.RelocationTable = UE_FIELD_NOT_PRESET_WARNING;
                        }
                    }
                    else
                    {
                        /*
                            Export table check
                        */
                        if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_EXPORT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                        {
                            if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
                                    {
                                        PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertedAddress;
                                        if(PEExports->AddressOfFunctions > CorrectedImageSize || PEExports->AddressOfFunctions + 4 * PEExports->NumberOfFunctions > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                        else if(PEExports->AddressOfNameOrdinals > CorrectedImageSize || PEExports->AddressOfNameOrdinals + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                        else if(PEExports->AddressOfNames > CorrectedImageSize || PEExports->AddressOfNames + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                        else if(PEExports->Name > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                    }
                                    else
                                    {
                                        myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                    }
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ExportTable, false);
                        }
                        else
                        {
                            myFileStatusInfo.ExportTable = UE_FIELD_NOT_PRESET;
                        }
                        /*
                            Relocation table check
                        */
                        if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != NULL)
                        {
                            if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                {
                                    myFileStatusInfo.RelocationTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.RelocationTable, false);
                        }
                        else
                        {
                            myFileStatusInfo.RelocationTable = UE_FIELD_NOT_PRESET;
                        }
                    }
                    /*
                        Import table check
                    */
                    if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_IMPORT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress > CorrectedImageSize)
                        {
                            myFileStatusInfo.ImportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.ImportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase);
                                if(SectionNumber < 0x7FFFFFFF)
                                {
                                    SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                                    if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE || SectionAttributes & IMAGE_SCN_MEM_WRITE || SectionAttributes & IMAGE_SCN_CNT_INITIALIZED_DATA)
                                    {
                                        myFileStatusInfo.ImportTableSection = UE_FIELD_OK;
                                    }
                                    else
                                    {
                                        myFileStatusInfo.ImportTableSection = UE_FIELD_FIXABLE_CRITICAL;
                                    }
                                    if(CheckDepth == UE_DEPTH_DEEP)
                                    {
                                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                                        {
                                            ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase), false, true);
                                            while(myFileStatusInfo.ImportTableData == UE_FIELD_OK && ImportIID->FirstThunk != NULL)
                                            {
                                                hLoadedModule = NULL;
                                                ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->Name + PEHeader32->OptionalHeader.ImageBase), false, true);
                                                if(ImportNamePtr != NULL)
                                                {
                                                    if(!EngineIsDependencyPresent((char*)ImportNamePtr, NULL, NULL))
                                                    {
                                                        myFileStatusInfo.MissingDependencies = true;
                                                        hLoadedModuleSimulated = false;
                                                    }
                                                    else
                                                    {
                                                        hLoadedModuleSimulated = false;
                                                        hLoadedModule = GetModuleHandleA((char*)ImportNamePtr);
                                                        if(hLoadedModule == NULL)
                                                        {
                                                            hLoadedModule = (HMODULE)EngineSimulateDllLoader(GetCurrentProcess(), (char*)ImportNamePtr);
                                                            hLoadedModuleSimulated = true;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                                if(ImportIID->OriginalFirstThunk != NULL)
                                                {
                                                    ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + PEHeader32->OptionalHeader.ImageBase), false, true);
                                                    CurrentThunk = (ULONG_PTR)ImportIID->OriginalFirstThunk;
                                                }
                                                else
                                                {
                                                    ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader32->OptionalHeader.ImageBase), false, true);
                                                    CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                                                }
                                                if(ThunkData32 != NULL)
                                                {
                                                    while(myFileStatusInfo.ImportTableData == UE_FIELD_OK && ThunkData32->u1.AddressOfData != NULL)
                                                    {
                                                        if(ThunkData32->u1.Ordinal & IMAGE_ORDINAL_FLAG32)
                                                        {
                                                            if((int)(ThunkData32->u1.Ordinal ^ IMAGE_ORDINAL_FLAG32) >= 0x10000)
                                                            {
                                                                myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ThunkData32->u1.AddressOfData + 2 + PEHeader32->OptionalHeader.ImageBase), false, true);
                                                            if(ImportNamePtr != NULL)
                                                            {
                                                                if(!EngineIsValidReadPtrEx((LPVOID)ImportNamePtr, 8))
                                                                {
                                                                    myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                                }
                                                                else
                                                                {
                                                                    if(hLoadedModule != NULL)
                                                                    {
                                                                        if(EngineGetProcAddress((ULONG_PTR)hLoadedModule, (char*)ImportNamePtr) == NULL)
                                                                        {
                                                                            myFileStatusInfo.MissingDeclaredAPIs = true;
                                                                            SetOverallFileStatus(&myFileStatusInfo, UE_FIELD_FIXABLE_CRITICAL, true);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            else
                                                            {
                                                                myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            }
                                                        }
                                                        CurrentThunk = CurrentThunk + 4;
                                                        ThunkData32 = (PIMAGE_THUNK_DATA32)((ULONG_PTR)ThunkData32 + sizeof IMAGE_THUNK_DATA32);
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                                if(hLoadedModuleSimulated)
                                                {
                                                    VirtualFree((LPVOID)hLoadedModule, NULL, MEM_RELEASE);
                                                }
                                                ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    myFileStatusInfo.ImportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                }
                            }
                        }
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImportTable, true);
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImportTableData, true);
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImportTableSection, true);
                    }
                    else
                    {
                        myFileStatusInfo.ImportTable = UE_FIELD_NOT_PRESET;
                    }
                    /*
                        TLS table check
                    */
                    if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_TLS && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                            else
                            {
                                PETls32 = (PIMAGE_TLS_DIRECTORY32)ConvertedAddress;
                                if(PETls32->StartAddressOfRawData != NULL && (PETls32->StartAddressOfRawData < PEHeader32->OptionalHeader.ImageBase || PETls32->StartAddressOfRawData > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                else if(PETls32->EndAddressOfRawData != NULL && (PETls32->EndAddressOfRawData < PEHeader32->OptionalHeader.ImageBase || PETls32->EndAddressOfRawData > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                else if(PETls32->AddressOfIndex != NULL && (PETls32->AddressOfIndex < PEHeader32->OptionalHeader.ImageBase || PETls32->AddressOfIndex > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                else if(PETls32->AddressOfCallBacks != NULL && (PETls32->AddressOfCallBacks < PEHeader32->OptionalHeader.ImageBase || PETls32->AddressOfCallBacks > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                if(PETls32->AddressOfCallBacks != NULL && CheckDepth == UE_DEPTH_DEEP)
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PETls32->AddressOfCallBacks + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress != NULL)
                                    {
                                        while(ReadData != NULL)
                                        {
                                            RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                            if(ReadData < PEHeader32->OptionalHeader.ImageBase || ReadData > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase)
                                            {
                                                myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                            }
                                            ConvertedAddress = ConvertedAddress + 4;
                                        }
                                    }
                                }
                            }
                        }
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.TLSTable, false);
                    }
                    else
                    {
                        myFileStatusInfo.TLSTable = UE_FIELD_NOT_PRESET;
                    }
                    /*
                        Load config table check
                    */
                    if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress != NULL)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.LoadConfigTable = UE_FIELD_FIXABLE_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.LoadConfigTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.LoadConfigTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.LoadConfigTable, false);
                    /*
                        Bound import table check
                    */
                    if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress != NULL)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + FileMapVA;
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                            else
                            {
                                BoundIID = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)ConvertedAddress;
                                while(BoundIID->TimeDateStamp != NULL)
                                {
                                    if(BoundIID->OffsetModuleName > PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size)
                                    {
                                        myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                                    }
                                    else if(!EngineIsPointedMemoryString(ConvertedAddress + BoundIID->OffsetModuleName))
                                    {
                                        myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                                    }
                                    BoundIID = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((ULONG_PTR)BoundIID + sizeof IMAGE_BOUND_IMPORT_DESCRIPTOR);
                                }
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.BoundImportTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.BoundImportTable, false);
                    /*
                        IAT check
                    */
                    if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_IAT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress != NULL)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.IATTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.IATTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.IATTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.IATTable, false);
                    /*
                        COM header check
                    */
                    if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress != NULL)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.COMHeaderTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.COMHeaderTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.COMHeaderTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.COMHeaderTable, false);
                    /*
                        Resource header check
                    */
                    if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_RESOURCE && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress != NULL)
                    {
                        if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.ResourceTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize || ConvertedAddress - FileMapVA + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > FileSize)
                            {
                                myFileStatusInfo.ResourceTable = UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED;
                            }
                            if(CheckDepth == UE_DEPTH_DEEP)
                            {
                                hSimulatedFileLoad = (ULONG_PTR)EngineSimulateNtLoaderW(szFileName);
                                if(hSimulatedFileLoad != NULL)
                                {
                                    for(i = 0; i < 22; i++)
                                    {
                                        if(myFileStatusInfo.ResourceData == UE_FIELD_OK)
                                        {
                                            EnumResourceNamesA((HMODULE)hSimulatedFileLoad, MAKEINTRESOURCEA(ResourceNamesTable[i]), (ENUMRESNAMEPROCA)EngineValidateResource, (ULONG_PTR)&myFileStatusInfo.ResourceData);
                                        }
                                        else
                                        {
                                            i = 22;
                                        }
                                    }
                                    VirtualFree((LPVOID)hSimulatedFileLoad, NULL, MEM_RELEASE);
                                }
                            }
                        }
                        if(myFileStatusInfo.ResourceTable == UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED && myFileStatusInfo.ResourceData == UE_FIELD_OK)
                        {
                            myFileStatusInfo.ResourceTable = UE_FIELD_OK;
                        }
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ResourceTable, true);
                    }
                    else
                    {
                        myFileStatusInfo.ResourceTable = UE_FIELD_NOT_PRESET;
                    }
                    /*
                        Section check
                    */
                    PESections = IMAGE_FIRST_SECTION(PEHeader32);
                    NumberOfSections = PEHeader32->FileHeader.NumberOfSections;
                    while(NumberOfSections > NULL)
                    {
                        SectionVirtualSize = PESections->VirtualAddress + PESections->Misc.VirtualSize;
                        if(PESections->Misc.VirtualSize % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                        {
                            SectionVirtualSizeFixed = SectionVirtualSize;
                        }
                        else
                        {
                            SectionVirtualSizeFixed = PESections->VirtualAddress + (((PESections->Misc.VirtualSize / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment);
                        }
                        if(NumberOfSections > 1)
                        {
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + sizeof IMAGE_SECTION_HEADER);
                            if(SectionVirtualSize > PESections->VirtualAddress || SectionVirtualSizeFixed > PESections->VirtualAddress)
                            {
                                myFileStatusInfo.SectionTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                        }
                        NumberOfSections--;
                    }
                    if(PESections->PointerToRawData + PESections->SizeOfRawData > FileSize && PESections->SizeOfRawData != NULL)
                    {
                        myFileStatusInfo.SectionTable = UE_FIELD_BROKEN_NON_FIXABLE;
                    }
                    SectionVirtualSizeFixed = SectionVirtualSizeFixed + 0xF000;
                    if(PEHeader32->OptionalHeader.SizeOfImage > SectionVirtualSizeFixed)
                    {
                        myFileStatusInfo.SizeOfImage = UE_FIELD_FIXABLE_CRITICAL;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.SizeOfImage, true);
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.SectionTable, true);
                    /*
                        Entry point check
                    */
                    SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader32->OptionalHeader.AddressOfEntryPoint + PEHeader32->OptionalHeader.ImageBase);
                    if(SectionNumber != -1)
                    {
                        SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                        if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE)
                        {
                            myFileStatusInfo.EntryPoint = UE_FIELD_OK;
                        }
                        else
                        {
                            myFileStatusInfo.EntryPoint = UE_FIELD_BROKEN_NON_CRITICAL;
                        }
                    }
                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.AddressOfEntryPoint + PEHeader32->OptionalHeader.ImageBase, false, true);
                    if(ConvertedAddress == NULL)
                    {
                        myFileStatusInfo.EntryPoint = UE_FIELD_BROKEN_NON_FIXABLE;
                    }
                    else
                    {
                        ReadData = NULL;
                        if(memcmp(&ReadData, (LPVOID)ConvertedAddress, 4) == NULL)
                        {
                            myFileStatusInfo.EntryPoint = UE_FIELD_BROKEN_NON_FIXABLE;
                        }
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.EntryPoint, true);
                    /*
                        Return data
                    */
                    if(FileStatusInfo != NULL)
                    {
                        RtlMoveMemory(FileStatusInfo, &myFileStatusInfo, sizeof FILE_STATUS_INFO);
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(myFileStatusInfo.OveralEvaluation == UE_RESULT_FILE_OK)
                    {
                        return true;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    myFileStatusInfo.EvaluationTerminatedByException = true;
                    myFileStatusInfo.OveralEvaluation = UE_RESULT_FILE_INVALID_FORMAT;
                    myFileStatusInfo.SignaturePE = UE_FIELD_BROKEN_NON_FIXABLE;
                    if(FileStatusInfo != NULL)
                    {
                        RtlMoveMemory(FileStatusInfo, &myFileStatusInfo, sizeof FILE_STATUS_INFO);
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
            else
            {
                /*
                    x64 Surface check
                */
                __try
                {
                    if(PEHeader64->OptionalHeader.SizeOfImage % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                    {
                        CorrectedImageSize = ((PEHeader64->OptionalHeader.SizeOfImage / PEHeader64->OptionalHeader.SectionAlignment)) * PEHeader64->OptionalHeader.SectionAlignment;
                    }
                    else
                    {
                        CorrectedImageSize = ((PEHeader64->OptionalHeader.SizeOfImage / PEHeader64->OptionalHeader.SectionAlignment) + 1) * PEHeader64->OptionalHeader.SectionAlignment;
                    }
                    if(PEHeader64->OptionalHeader.SectionAlignment != NULL && PEHeader64->OptionalHeader.SectionAlignment >= PEHeader64->OptionalHeader.FileAlignment)
                    {
                        myFileStatusInfo.SectionAlignment = UE_FIELD_OK;
                        if(PEHeader64->OptionalHeader.SizeOfImage % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                        {
                            myFileStatusInfo.SizeOfImage = UE_FIELD_OK;
                        }
                        else
                        {
                            if(CorrectedImageSize < PEHeader64->OptionalHeader.AddressOfEntryPoint)
                            {
                                myFileStatusInfo.SizeOfImage = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                myFileStatusInfo.SizeOfImage = UE_FIELD_FIXABLE_NON_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.SectionAlignment = UE_FIELD_FIXABLE_CRITICAL;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.SectionAlignment, true);
                    if((ULONG_PTR)PEHeader64->OptionalHeader.ImageBase % 0x1000 == NULL)
                    {
                        myFileStatusInfo.ImageBase = UE_FIELD_OK;
                    }
                    else
                    {
                        myFileStatusInfo.ImageBase = UE_FIELD_BROKEN_NON_FIXABLE;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImageBase, true);
                    if(PEHeader64->OptionalHeader.FileAlignment % 2 == NULL)
                    {
                        myFileStatusInfo.FileAlignment = UE_FIELD_OK;
                    }
                    else
                    {
                        myFileStatusInfo.FileAlignment = UE_FIELD_FIXABLE_CRITICAL;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.FileAlignment, false);
                    /*
                        Get the console flag
                    */
                    if(PEHeader64->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)
                    {
                        myFileStatusInfo.FileIsConsole = true;
                    }
                    /*
                        Export and relocation checks [for DLL and EXE]
                    */
                    if(PEHeader64->FileHeader.Characteristics & 0x2000)
                    {
                        /*
                            Export table check
                        */
                        FileIsDLL = true;
                        myFileStatusInfo.FileIsDLL = true;
                        if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_EXPORT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                        {
                            if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
                                    {
                                        PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertedAddress;
                                        if(PEExports->AddressOfFunctions > CorrectedImageSize || PEExports->AddressOfFunctions + 4 * PEExports->NumberOfFunctions > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else if(PEExports->AddressOfNameOrdinals > CorrectedImageSize || PEExports->AddressOfNameOrdinals + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else if(PEExports->AddressOfNames > CorrectedImageSize || PEExports->AddressOfNames + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else if(PEExports->Name > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                        }
                                        else
                                        {
                                            if(CheckDepth == UE_DEPTH_DEEP)
                                            {
                                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEExports->AddressOfFunctions + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                                if(ConvertedAddress != NULL)
                                                {
                                                    for(i = 0; i < PEExports->NumberOfFunctions; i++)
                                                    {
                                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                                        if(ReadData > CorrectedImageSize || ReadData < PEHeader64->OptionalHeader.SectionAlignment)
                                                        {
                                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            i = PEExports->NumberOfFunctions;
                                                        }
                                                        else
                                                        {
                                                            ConvertedAddress = ConvertedAddress + 4;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEExports->AddressOfNames + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                                if(ConvertedAddress != NULL)
                                                {
                                                    for(i = 0; i < PEExports->NumberOfNames; i++)
                                                    {
                                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                                        if(ReadData > CorrectedImageSize || ReadData < PEHeader64->OptionalHeader.SectionAlignment)
                                                        {
                                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            i = PEExports->NumberOfNames;
                                                        }
                                                        else
                                                        {
                                                            ConvertedAddress = ConvertedAddress + 4;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                    }
                                }
                                else
                                {
                                    myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ExportTable, true);
                        }
                        else
                        {
                            myFileStatusInfo.ExportTable = UE_FIELD_NOT_PRESET;
                        }
                        /*
                            Relocation table check
                        */
                        if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != NULL)
                        {
                            if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size))
                                    {
                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                        RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        while(ReadData != NULL)
                                        {
                                            ReadSize = ReadSize - 8;
                                            ConvertedAddress = ConvertedAddress + 8;
                                            while(ReadSize > NULL)
                                            {
                                                RtlMoveMemory(&ReadDataWORD, (LPVOID)ConvertedAddress, 2);
                                                if(ReadDataWORD > 0xCFFF)
                                                {
                                                    myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE;
                                                }
                                                ConvertedAddress = ConvertedAddress + 2;
                                                ReadSize = ReadSize - 2;
                                            }
                                            RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                            RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        }
                                    }
                                    else
                                    {
                                        myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE;
                                    }
                                }
                                else
                                {
                                    myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE;
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.RelocationTable, true);
                        }
                        else
                        {
                            myFileStatusInfo.RelocationTable = UE_FIELD_NOT_PRESET_WARNING;
                        }
                    }
                    else
                    {
                        /*
                            Export table check
                        */
                        if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_EXPORT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                        {
                            if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
                                    {
                                        PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertedAddress;
                                        if(PEExports->AddressOfFunctions > CorrectedImageSize || PEExports->AddressOfFunctions + 4 * PEExports->NumberOfFunctions > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                        else if(PEExports->AddressOfNameOrdinals > CorrectedImageSize || PEExports->AddressOfNameOrdinals + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                        else if(PEExports->AddressOfNames > CorrectedImageSize || PEExports->AddressOfNames + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                        else if(PEExports->Name > CorrectedImageSize)
                                        {
                                            myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                        }
                                    }
                                    else
                                    {
                                        myFileStatusInfo.ExportTable = UE_FIELD_BROKEN_NON_CRITICAL;
                                    }
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ExportTable, false);
                        }
                        else
                        {
                            myFileStatusInfo.ExportTable = UE_FIELD_NOT_PRESET;
                        }
                        /*
                            Relocation table check
                        */
                        if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != NULL)
                        {
                            if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > CorrectedImageSize)
                            {
                                myFileStatusInfo.RelocationTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                {
                                    myFileStatusInfo.RelocationTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                                }
                            }
                            SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.RelocationTable, false);
                        }
                        else
                        {
                            myFileStatusInfo.RelocationTable = UE_FIELD_NOT_PRESET;
                        }
                    }
                    /*
                        Import table check
                    */
                    if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_IMPORT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress > CorrectedImageSize)
                        {
                            myFileStatusInfo.ImportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.ImportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                            }
                            else
                            {
                                SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase);
                                if(SectionNumber >= NULL)
                                {
                                    SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                                    if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE || SectionAttributes & IMAGE_SCN_MEM_WRITE || SectionAttributes & IMAGE_SCN_CNT_INITIALIZED_DATA)
                                    {
                                        myFileStatusInfo.ImportTableSection = UE_FIELD_OK;
                                    }
                                    else
                                    {
                                        myFileStatusInfo.ImportTableSection = UE_FIELD_FIXABLE_CRITICAL;
                                    }
                                    if(CheckDepth == UE_DEPTH_DEEP)
                                    {
                                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                                        {
                                            ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)(ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                            while(myFileStatusInfo.ImportTableData == UE_FIELD_OK && ImportIID->FirstThunk != NULL)
                                            {
                                                hLoadedModule = NULL;
                                                ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)(ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->Name + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                                if(ImportNamePtr != NULL)
                                                {
                                                    if(!EngineIsDependencyPresent((char*)ImportNamePtr, NULL, NULL))
                                                    {
                                                        myFileStatusInfo.MissingDependencies = true;
                                                        hLoadedModuleSimulated = false;
                                                    }
                                                    else
                                                    {
                                                        hLoadedModuleSimulated = false;
                                                        hLoadedModule = GetModuleHandleA((char*)ImportNamePtr);
                                                        if(hLoadedModule == NULL)
                                                        {
                                                            hLoadedModule = (HMODULE)EngineSimulateDllLoader(GetCurrentProcess(), (char*)ImportNamePtr);
                                                            hLoadedModuleSimulated = true;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                                if(ImportIID->OriginalFirstThunk != NULL)
                                                {
                                                    ThunkData64 = (PIMAGE_THUNK_DATA64)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                                    CurrentThunk = (ULONG_PTR)ImportIID->OriginalFirstThunk;
                                                }
                                                else
                                                {
                                                    ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader32->OptionalHeader.ImageBase), false, true);
                                                    CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                                                }
                                                if(ThunkData64 != NULL)
                                                {
                                                    while(myFileStatusInfo.ImportTableData == UE_FIELD_OK && ThunkData64->u1.AddressOfData != NULL)
                                                    {
                                                        if(ThunkData64->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
                                                        {
                                                            if((int)(ThunkData64->u1.Ordinal ^ IMAGE_ORDINAL_FLAG64) >= 0x10000)
                                                            {
                                                                myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)(ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ThunkData64->u1.AddressOfData + 2 + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                                            if(ImportNamePtr != NULL)
                                                            {
                                                                if(!EngineIsValidReadPtrEx((LPVOID)ImportNamePtr, 8))
                                                                {
                                                                    myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                                }
                                                                else
                                                                {
                                                                    if(hLoadedModule != NULL)
                                                                    {
                                                                        if(EngineGetProcAddress((ULONG_PTR)hLoadedModule, (char*)ImportNamePtr) == NULL)
                                                                        {
                                                                            myFileStatusInfo.MissingDeclaredAPIs = true;
                                                                            SetOverallFileStatus(&myFileStatusInfo, UE_FIELD_FIXABLE_CRITICAL, true);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            else
                                                            {
                                                                myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                            }
                                                        }
                                                        CurrentThunk = CurrentThunk + 8;
                                                        ThunkData64 = (PIMAGE_THUNK_DATA64)((ULONG_PTR)ThunkData64 + sizeof IMAGE_THUNK_DATA64);
                                                    }
                                                }
                                                else
                                                {
                                                    myFileStatusInfo.ImportTableData = UE_FIELD_BROKEN_NON_FIXABLE;
                                                }
                                                if(hLoadedModuleSimulated)
                                                {
                                                    VirtualFree((LPVOID)hLoadedModule, NULL, MEM_RELEASE);
                                                }
                                                ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    myFileStatusInfo.ImportTable = UE_FIELD_BROKEN_NON_FIXABLE;
                                }
                            }
                        }
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImportTable, true);
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImportTableData, true);
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ImportTableSection, true);
                    }
                    else
                    {
                        myFileStatusInfo.ImportTable = UE_FIELD_NOT_PRESET;
                    }
                    /*
                        TLS table check
                    */
                    if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_TLS && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                            else
                            {
                                PETls64 = (PIMAGE_TLS_DIRECTORY64)ConvertedAddress;
                                if(PETls64->StartAddressOfRawData != NULL && (PETls64->StartAddressOfRawData < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->StartAddressOfRawData > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                else if(PETls64->EndAddressOfRawData != NULL && (PETls64->EndAddressOfRawData < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->EndAddressOfRawData > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                else if(PETls64->AddressOfIndex != NULL && (PETls64->AddressOfIndex < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->AddressOfIndex > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                else if(PETls64->AddressOfCallBacks != NULL && (PETls64->AddressOfCallBacks < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->AddressOfCallBacks > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                {
                                    myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                }
                                if(PETls64->AddressOfCallBacks != NULL && CheckDepth == UE_DEPTH_DEEP)
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, (ULONG_PTR)PETls64->AddressOfCallBacks + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress != NULL)
                                    {
                                        while(ReadData != NULL)
                                        {
                                            RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 8);
                                            if(ReadData < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || ReadData > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase)
                                            {
                                                myFileStatusInfo.TLSTable = UE_FIELD_FIXABLE_CRITICAL;
                                            }
                                            ConvertedAddress = ConvertedAddress + 8;
                                        }
                                    }
                                }
                            }
                        }
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.TLSTable, false);
                    }
                    else
                    {
                        myFileStatusInfo.TLSTable = UE_FIELD_NOT_PRESET;
                    }
                    /*
                        Load config table check
                    */
                    if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress != NULL)
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.LoadConfigTable = UE_FIELD_FIXABLE_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.LoadConfigTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.LoadConfigTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.LoadConfigTable, false);
                    /*
                        Bound import table check
                    */
                    if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress != NULL)
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + FileMapVA;
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                            else
                            {
                                BoundIID = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)ConvertedAddress;
                                while(BoundIID->TimeDateStamp != NULL)
                                {
                                    if(BoundIID->OffsetModuleName > PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size)
                                    {
                                        myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                                    }
                                    else if(!EngineIsPointedMemoryString(ConvertedAddress + BoundIID->OffsetModuleName))
                                    {
                                        myFileStatusInfo.BoundImportTable = UE_FIELD_FIXABLE_CRITICAL;
                                    }
                                    BoundIID = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((ULONG_PTR)BoundIID + sizeof IMAGE_BOUND_IMPORT_DESCRIPTOR);
                                }
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.BoundImportTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.BoundImportTable, false);
                    /*
                        IAT check
                    */
                    if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_IAT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress != NULL)
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.IATTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.IATTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.IATTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.IATTable, false);
                    /*
                        COM header check
                    */
                    if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress != NULL)
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.COMHeaderTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                            {
                                myFileStatusInfo.COMHeaderTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                            }
                        }
                    }
                    else
                    {
                        myFileStatusInfo.COMHeaderTable = UE_FIELD_NOT_PRESET;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.COMHeaderTable, false);
                    /*
                        Resource header check
                    */
                    if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_RESOURCE && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress != NULL)
                    {
                        if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > CorrectedImageSize)
                        {
                            myFileStatusInfo.ResourceTable = UE_FIELD_FIXABLE_NON_CRITICAL;
                        }
                        else
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                            if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize || ConvertedAddress - FileMapVA + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > FileSize)
                            {
                                myFileStatusInfo.ResourceTable = UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED;
                            }
                            if(CheckDepth == UE_DEPTH_DEEP)
                            {
                                hSimulatedFileLoad = (ULONG_PTR)EngineSimulateNtLoaderW(szFileName);
                                if(hSimulatedFileLoad != NULL)
                                {
                                    for(i = 0; i < 22; i++)
                                    {
                                        if(myFileStatusInfo.ResourceData == UE_FIELD_OK)
                                        {
                                            EnumResourceNamesA((HMODULE)hSimulatedFileLoad, MAKEINTRESOURCEA(ResourceNamesTable[i]), (ENUMRESNAMEPROCA)EngineValidateResource, (ULONG_PTR)&myFileStatusInfo.ResourceData);
                                        }
                                        else
                                        {
                                            i = 22;
                                        }
                                    }
                                    VirtualFree((LPVOID)hSimulatedFileLoad, NULL, MEM_RELEASE);
                                }
                            }
                        }
                        if(myFileStatusInfo.ResourceTable == UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED && myFileStatusInfo.ResourceData == UE_FIELD_OK)
                        {
                            myFileStatusInfo.ResourceTable = UE_FIELD_OK;
                        }
                        SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.ResourceTable, true);
                    }
                    else
                    {
                        myFileStatusInfo.ResourceTable = UE_FIELD_NOT_PRESET;
                    }
                    /*
                        Section check
                    */
                    PESections = IMAGE_FIRST_SECTION(PEHeader64);
                    NumberOfSections = PEHeader64->FileHeader.NumberOfSections;
                    while(NumberOfSections > NULL)
                    {
                        SectionVirtualSize = PESections->VirtualAddress + PESections->Misc.VirtualSize;
                        if(PESections->Misc.VirtualSize % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                        {
                            SectionVirtualSizeFixed = SectionVirtualSize;
                        }
                        else
                        {
                            SectionVirtualSizeFixed = PESections->VirtualAddress + (((PESections->Misc.VirtualSize / PEHeader64->OptionalHeader.SectionAlignment) + 1) * PEHeader64->OptionalHeader.SectionAlignment);
                        }
                        if(NumberOfSections > 1)
                        {
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + sizeof IMAGE_SECTION_HEADER);
                            if(SectionVirtualSize > PESections->VirtualAddress || SectionVirtualSizeFixed > PESections->VirtualAddress)
                            {
                                myFileStatusInfo.SectionTable = UE_FIELD_FIXABLE_CRITICAL;
                            }
                        }
                        NumberOfSections--;
                    }
                    if(PESections->PointerToRawData + PESections->SizeOfRawData > FileSize && PESections->SizeOfRawData != NULL)
                    {
                        myFileStatusInfo.SectionTable = UE_FIELD_BROKEN_NON_FIXABLE;
                    }
                    SectionVirtualSizeFixed = SectionVirtualSizeFixed + 0xF000;
                    if(PEHeader64->OptionalHeader.SizeOfImage > SectionVirtualSizeFixed)
                    {
                        myFileStatusInfo.SizeOfImage = UE_FIELD_FIXABLE_CRITICAL;
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.SizeOfImage, true);
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.SectionTable, true);
                    /*
                        Entry point check
                    */
                    SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader64->OptionalHeader.AddressOfEntryPoint + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase);
                    if(SectionNumber != -1)
                    {
                        SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                        if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE)
                        {
                            myFileStatusInfo.EntryPoint = UE_FIELD_OK;
                        }
                        else
                        {
                            myFileStatusInfo.EntryPoint = UE_FIELD_BROKEN_NON_CRITICAL;
                        }
                    }
                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.AddressOfEntryPoint + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                    if(ConvertedAddress == NULL)
                    {
                        myFileStatusInfo.EntryPoint = UE_FIELD_BROKEN_NON_FIXABLE;
                    }
                    else
                    {
                        ReadData = NULL;
                        if(memcmp(&ReadData, (LPVOID)ConvertedAddress, 4) == NULL)
                        {
                            myFileStatusInfo.EntryPoint = UE_FIELD_BROKEN_NON_FIXABLE;
                        }
                    }
                    SetOverallFileStatus(&myFileStatusInfo, myFileStatusInfo.EntryPoint, true);
                    /*
                        Return data
                    */
                    if(FileStatusInfo != NULL)
                    {
                        RtlMoveMemory(FileStatusInfo, &myFileStatusInfo, sizeof FILE_STATUS_INFO);
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(myFileStatusInfo.OveralEvaluation == UE_RESULT_FILE_OK)
                    {
                        return true;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    myFileStatusInfo.EvaluationTerminatedByException = true;
                    myFileStatusInfo.OveralEvaluation = UE_RESULT_FILE_INVALID_FORMAT;
                    myFileStatusInfo.SignaturePE = UE_FIELD_BROKEN_NON_FIXABLE;
                    if(FileStatusInfo != NULL)
                    {
                        RtlMoveMemory(FileStatusInfo, &myFileStatusInfo, sizeof FILE_STATUS_INFO);
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
        }
        else
        {
            myFileStatusInfo.OveralEvaluation = UE_RESULT_FILE_INVALID_FORMAT;
            myFileStatusInfo.SignatureMZ = UE_FIELD_BROKEN_NON_FIXABLE;
            if(FileStatusInfo != NULL)
            {
                RtlMoveMemory(FileStatusInfo, &myFileStatusInfo, sizeof FILE_STATUS_INFO);
            }
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    if(FileStatusInfo != NULL)
    {
        RtlMoveMemory(FileStatusInfo, &myFileStatusInfo, sizeof FILE_STATUS_INFO);
    }
    return false;
}
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(FixBrokenPE32FileExW(uniFileName, FileStatusInfo, FileFixInfo));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo)
{
    if(!FileFixInfo)
        return false;
    DWORD ReadData = NULL;
    DWORD ReadSize = NULL;
    WORD ReadDataWORD = NULL;
    ULONG_PTR ReadDataQWORD = NULL;
    DWORD OrdinalBase = NULL;
    DWORD OrdinalCount = NULL;
    long SectionNumber = NULL;
    DWORD SectionAttributes = NULL;
    ULONG_PTR ConvertedAddress = NULL;
    DWORD CorrectedImageSize = NULL;
    DWORD SectionVirtualSize = NULL;
    DWORD SectionVirtualSizeFixed = NULL;
    DWORD NumberOfSections = NULL;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    PIMAGE_TLS_DIRECTORY32 PETls32;
    PIMAGE_TLS_DIRECTORY64 PETls64;
    PIMAGE_IMPORT_DESCRIPTOR ImportIID;
    PIMAGE_THUNK_DATA32 ThunkData32;
    PIMAGE_THUNK_DATA64 ThunkData64;
    PFILE_STATUS_INFO myFileStatusInfo = (PFILE_STATUS_INFO)FileStatusInfo;
    PFILE_FIX_INFO myFileFixInfo = (PFILE_FIX_INFO)FileFixInfo; //can bad point
    bool hLoadedModuleSimulated = false;
    HMODULE hLoadedModule;
    ULONG_PTR ImportNamePtr;
    ULONG_PTR CurrentThunk;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    bool FileFixed = true;
    bool FeatureFixed = false;

    FILE_STATUS_INFO filestatusinfo; //for internal use

    if(myFileStatusInfo == NULL) //here check for myfilestrus..ah lol, youre right
    {
        myFileStatusInfo = &filestatusinfo;
        IsPE32FileValidExW(szFileName, UE_DEPTH_DEEP, myFileStatusInfo);
    }
    if(myFileFixInfo->FileFixPerformed == false && myFileStatusInfo->OveralEvaluation == UE_RESULT_FILE_INVALID_BUT_FIXABLE)
    {
        if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
        {
            myFileFixInfo->OveralEvaluation = UE_RESULT_FILE_INVALID_AND_NON_FIXABLE;
            DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
            if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
            {
                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                if(PEHeader32->Signature == 0x4550 && PEHeader32->OptionalHeader.Magic == 0x10B)
                {
                    FileIs64 = false;
                }
                else if(PEHeader32->Signature == 0x4550 && PEHeader32->OptionalHeader.Magic == 0x20B)
                {
                    FileIs64 = true;
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                if(myFileStatusInfo->SignatureMZ != UE_FIELD_OK)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                else if(myFileStatusInfo->SignaturePE != UE_FIELD_OK)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                else if(myFileStatusInfo->SectionAlignment != UE_FIELD_OK)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                else if(myFileStatusInfo->FileAlignment != UE_FIELD_OK)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                else if(myFileStatusInfo->ImportTable != UE_FIELD_OK)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                else if(myFileStatusInfo->ImportTableData != UE_FIELD_OK)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                if(!FileIs64)
                {
                    /*
                        x86 Surface check
                    */
                    __try
                    {
                        if(PEHeader32->OptionalHeader.SizeOfImage % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                        {
                            CorrectedImageSize = (PEHeader32->OptionalHeader.SizeOfImage / PEHeader32->OptionalHeader.SectionAlignment) * PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        else
                        {
                            CorrectedImageSize = ((PEHeader32->OptionalHeader.SizeOfImage / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        /*
                            Fixing import table
                        */
                        if(myFileStatusInfo->MissingDeclaredAPIs)
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                            SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase);
                            if(SectionNumber >= NULL)
                            {
                                SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                                if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE || SectionAttributes & IMAGE_SCN_MEM_WRITE || SectionAttributes & IMAGE_SCN_CNT_INITIALIZED_DATA)
                                {
                                    // Should not execute!
                                }
                                else
                                {
                                    if(!SetPE32DataForMappedFile(FileMapVA, SectionAttributes, UE_SECTIONFLAGS, 0xE0000020))
                                    {
                                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                        return false;
                                    }
                                }
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                                {
                                    ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase), false, true);
                                    while(ImportIID->FirstThunk != NULL)
                                    {
                                        hLoadedModule = NULL;
                                        ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->Name + PEHeader32->OptionalHeader.ImageBase), false, true);
                                        if(ImportNamePtr != NULL)
                                        {
                                            if(!EngineIsDependencyPresent((char*)ImportNamePtr, NULL, NULL))
                                            {
                                                hLoadedModuleSimulated = false;
                                            }
                                            else
                                            {
                                                hLoadedModuleSimulated = false;
                                                hLoadedModule = GetModuleHandleA((char*)ImportNamePtr);
                                                if(hLoadedModule == NULL)
                                                {
                                                    hLoadedModule = (HMODULE)EngineSimulateDllLoader(GetCurrentProcess(), (char*)ImportNamePtr);
                                                    hLoadedModuleSimulated = true;
                                                }
                                            }
                                        }
                                        if(ImportIID->OriginalFirstThunk != NULL)
                                        {
                                            ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + PEHeader32->OptionalHeader.ImageBase), false, true);
                                            CurrentThunk = (ULONG_PTR)ImportIID->OriginalFirstThunk;
                                        }
                                        else
                                        {
                                            ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader32->OptionalHeader.ImageBase), false, true);
                                            CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                                        }
                                        if(ThunkData32 != NULL)
                                        {
                                            while(ThunkData32->u1.AddressOfData != NULL)
                                            {
                                                if(ThunkData32->u1.Ordinal & IMAGE_ORDINAL_FLAG32)
                                                {
                                                    if((int)(ThunkData32->u1.Ordinal ^ IMAGE_ORDINAL_FLAG32) >= 0x10000)
                                                    {
                                                        FileFixed = false;
                                                    }
                                                }
                                                else
                                                {
                                                    ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ThunkData32->u1.AddressOfData + 2 + PEHeader32->OptionalHeader.ImageBase), false, true);
                                                    if(ImportNamePtr != NULL)
                                                    {
                                                        if(EngineIsValidReadPtrEx((LPVOID)ImportNamePtr, 8))
                                                        {
                                                            if(hLoadedModule != NULL)
                                                            {
                                                                if(EngineGetProcAddress((ULONG_PTR)hLoadedModule, (char*)ImportNamePtr) == NULL)
                                                                {
                                                                    OrdinalBase = NULL;
                                                                    OrdinalCount = NULL;
                                                                    if(EngineGetLibraryOrdinalData((ULONG_PTR)hLoadedModule, &OrdinalBase, &OrdinalCount))
                                                                    {
                                                                        if(OrdinalBase != NULL && OrdinalCount != NULL)
                                                                        {
                                                                            ThunkData32->u1.Ordinal = (OrdinalBase + 1) ^ IMAGE_ORDINAL_FLAG32;
                                                                        }
                                                                        else
                                                                        {
                                                                            FileFixed = false;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                CurrentThunk = CurrentThunk + 4;
                                                ThunkData32 = (PIMAGE_THUNK_DATA32)((ULONG_PTR)ThunkData32 + sizeof IMAGE_THUNK_DATA32);
                                            }
                                        }
                                        if(hLoadedModuleSimulated)
                                        {
                                            VirtualFree((LPVOID)hLoadedModule, NULL, MEM_RELEASE);
                                        }
                                        ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                                    }
                                }
                            }
                        }
                        /*
                            Fixing Export table
                        */
                        if(myFileStatusInfo->ExportTable == UE_FIELD_NOT_PRESET_WARNING)
                        {
                            FileFixed = false;
                        }
                        else if(myFileFixInfo->DontFixExports == false && myFileStatusInfo->ExportTable != UE_FIELD_OK && myFileStatusInfo->ExportTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_EXPORT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                            {
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedExports = true;
                                    myFileFixInfo->OriginalExportTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                                    myFileFixInfo->OriginalExportTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = NULL;
                                }
                                else
                                {
                                    FeatureFixed = true;
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress != NULL)
                                    {
                                        if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
                                        {
                                            PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertedAddress;
                                            if(PEExports->AddressOfFunctions > CorrectedImageSize || PEExports->AddressOfFunctions + 4 * PEExports->NumberOfFunctions > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            else if(PEExports->AddressOfNameOrdinals > CorrectedImageSize || PEExports->AddressOfNameOrdinals + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            else if(PEExports->AddressOfNames > CorrectedImageSize || PEExports->AddressOfNames + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            else if(PEExports->Name > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            if(!FeatureFixed)
                                            {
                                                myFileFixInfo->StrippedExports = true;
                                                myFileFixInfo->OriginalExportTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                                                myFileFixInfo->OriginalExportTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                                                PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = NULL;
                                                PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = NULL;
                                            }
                                        }
                                        else
                                        {
                                            myFileFixInfo->StrippedExports = true;
                                            myFileFixInfo->OriginalExportTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                                            myFileFixInfo->OriginalExportTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = NULL;
                                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = NULL;
                                        }
                                    }
                                }
                            }
                        }
                        /*
                            Fixing Relocation table
                        */
                        if(myFileStatusInfo->FileIsDLL == true && myFileStatusInfo->RelocationTable == UE_FIELD_BROKEN_NON_FIXABLE)
                        {
                            FileFixed = false;
                        }
                        else if(myFileFixInfo->DontFixRelocations == false && myFileStatusInfo->RelocationTable != UE_FIELD_OK)
                        {
                            if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > CorrectedImageSize)
                            {
                                if(myFileStatusInfo->FileIsDLL)
                                {
                                    FileFixed = false;
                                }
                                else
                                {
                                    myFileFixInfo->StrippedRelocation = true;
                                    myFileFixInfo->OriginalRelocationTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                                    myFileFixInfo->OriginalRelocationTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = NULL;
                                }
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size))
                                    {
                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                        RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        while(ReadData != NULL)
                                        {
                                            ReadSize = ReadSize - 8;
                                            ConvertedAddress = ConvertedAddress + 8;
                                            while(ReadSize > NULL)
                                            {
                                                RtlMoveMemory(&ReadDataWORD, (LPVOID)ConvertedAddress, 2);
                                                if(ReadDataWORD > 0xCFFF)
                                                {
                                                    RtlZeroMemory((LPVOID)ConvertedAddress, 2);
                                                }
                                                ConvertedAddress = ConvertedAddress + 2;
                                                ReadSize = ReadSize - 2;
                                            }
                                            RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                            RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        }
                                    }
                                    else
                                    {
                                        if(myFileStatusInfo->FileIsDLL)
                                        {
                                            FileFixed = false;
                                        }
                                        else
                                        {
                                            myFileFixInfo->StrippedRelocation = true;
                                            myFileFixInfo->OriginalRelocationTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                                            myFileFixInfo->OriginalRelocationTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = NULL;
                                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = NULL;
                                        }
                                    }
                                }
                                else
                                {
                                    if(myFileStatusInfo->FileIsDLL)
                                    {
                                        FileFixed = false;
                                    }
                                    else
                                    {
                                        myFileFixInfo->StrippedRelocation = true;
                                        myFileFixInfo->OriginalRelocationTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                                        myFileFixInfo->OriginalRelocationTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = NULL;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = NULL;
                                    }
                                }
                            }
                        }
                        else if(myFileStatusInfo->RelocationTable == UE_FIELD_OK)
                        {
                            // Filter case!
                        }
                        else
                        {
                            FileFixed = false;
                        }
                        /*
                            Fixing Resource table
                        */
                        if(myFileFixInfo->DontFixResources == false && myFileStatusInfo->ResourceData != UE_FIELD_OK && myFileStatusInfo->ResourceData != UE_FIELD_NOT_PRESET)
                        {
                            myFileFixInfo->StrippedResources = true;
                            myFileFixInfo->OriginalResourceTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                            myFileFixInfo->OriginalResourceTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = NULL;
                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = NULL;
                        }
                        else if(myFileFixInfo->DontFixResources == false && myFileStatusInfo->ResourceTable != UE_FIELD_OK && myFileStatusInfo->ResourceTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_RESOURCE && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress != NULL)
                            {
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedResources = true;
                                    myFileFixInfo->OriginalResourceTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                                    myFileFixInfo->OriginalResourceTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize || ConvertedAddress - FileMapVA + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > FileSize)
                                    {
                                        myFileFixInfo->StrippedResources = true;
                                        myFileFixInfo->OriginalResourceTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                                        myFileFixInfo->OriginalResourceTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = NULL;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fixing TLS table
                        */
                        if(myFileFixInfo->DontFixTLS == false && myFileStatusInfo->TLSTable != UE_FIELD_OK && myFileStatusInfo->TLSTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_TLS && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                            {
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedTLS = true;
                                    myFileFixInfo->OriginalTLSTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                                    myFileFixInfo->OriginalTLSTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedTLS = true;
                                        myFileFixInfo->OriginalTLSTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                                        myFileFixInfo->OriginalTLSTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                                    }
                                    else
                                    {
                                        FeatureFixed = true;
                                        PETls32 = (PIMAGE_TLS_DIRECTORY32)ConvertedAddress;
                                        if(PETls32->StartAddressOfRawData != NULL && (PETls32->StartAddressOfRawData < PEHeader32->OptionalHeader.ImageBase || PETls32->StartAddressOfRawData > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        else if(PETls32->EndAddressOfRawData != NULL && (PETls32->EndAddressOfRawData < PEHeader32->OptionalHeader.ImageBase || PETls32->EndAddressOfRawData > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        else if(PETls32->AddressOfIndex != NULL && (PETls32->AddressOfIndex < PEHeader32->OptionalHeader.ImageBase || PETls32->AddressOfIndex > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        else if(PETls32->AddressOfCallBacks != NULL && (PETls32->AddressOfCallBacks < PEHeader32->OptionalHeader.ImageBase || PETls32->AddressOfCallBacks > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        if(!FeatureFixed)
                                        {
                                            myFileFixInfo->StrippedTLS = true;
                                            myFileFixInfo->OriginalTLSTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                                            myFileFixInfo->OriginalTLSTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                                            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                                        }
                                        else
                                        {
                                            if(PETls32->AddressOfCallBacks != NULL)
                                            {
                                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PETls32->AddressOfCallBacks + PEHeader32->OptionalHeader.ImageBase, false, true);
                                                if(ConvertedAddress != NULL)
                                                {
                                                    while(ReadData != NULL)
                                                    {
                                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                                        if(ReadData < PEHeader32->OptionalHeader.ImageBase || ReadData > CorrectedImageSize + PEHeader32->OptionalHeader.ImageBase)
                                                        {
                                                            RtlZeroMemory((LPVOID)ConvertedAddress, 4);
                                                        }
                                                        ConvertedAddress = ConvertedAddress + 4;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        /*
                            Fix Load config table
                        */
                        if(myFileFixInfo->DontFixLoadConfig == false && myFileStatusInfo->LoadConfigTable != UE_FIELD_OK && myFileStatusInfo->LoadConfigTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress != NULL)
                            {
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedLoadConfig = true;
                                    myFileFixInfo->OriginalLoadConfigTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
                                    myFileFixInfo->OriginalLoadConfigTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedLoadConfig = true;
                                        myFileFixInfo->OriginalLoadConfigTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
                                        myFileFixInfo->OriginalLoadConfigTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = NULL;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix Bound import table
                        */
                        if(myFileFixInfo->DontFixBoundImports == false && myFileStatusInfo->BoundImportTable != UE_FIELD_OK && myFileStatusInfo->BoundImportTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress != NULL)
                            {
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedBoundImports = true;
                                    myFileFixInfo->OriginalBoundImportTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
                                    myFileFixInfo->OriginalBoundImportTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedBoundImports = true;
                                        myFileFixInfo->OriginalBoundImportTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
                                        myFileFixInfo->OriginalBoundImportTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix IAT
                        */
                        if(myFileFixInfo->DontFixIAT == false && myFileStatusInfo->IATTable != UE_FIELD_OK && myFileStatusInfo->IATTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_IAT && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress != NULL)
                            {
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedIAT = true;
                                    myFileFixInfo->OriginalImportAddressTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
                                    myFileFixInfo->OriginalImportAddressTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedIAT = true;
                                        myFileFixInfo->OriginalImportAddressTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
                                        myFileFixInfo->OriginalImportAddressTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix COM header
                        */
                        if(myFileFixInfo->DontFixCOM == false && myFileStatusInfo->COMHeaderTable != UE_FIELD_OK && myFileStatusInfo->COMHeaderTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR && PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress != NULL)
                            {
                                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress > CorrectedImageSize || PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedCOM = true;
                                    myFileFixInfo->OriginalCOMTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
                                    myFileFixInfo->OriginalCOMTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = NULL;
                                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + PEHeader32->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedCOM = true;
                                        myFileFixInfo->OriginalCOMTableAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
                                        myFileFixInfo->OriginalCOMTableSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = NULL;
                                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix sections and SizeOfImage
                        */
                        if(myFileStatusInfo->SectionTable != UE_FIELD_OK || myFileStatusInfo->SizeOfImage != UE_FIELD_OK)
                        {
                            PESections = IMAGE_FIRST_SECTION(PEHeader32);
                            NumberOfSections = PEHeader32->FileHeader.NumberOfSections;
                            while(NumberOfSections > NULL)
                            {
                                SectionVirtualSize = PESections->VirtualAddress + PESections->Misc.VirtualSize;
                                if(PESections->Misc.VirtualSize % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                                {
                                    SectionVirtualSizeFixed = SectionVirtualSize;
                                }
                                else
                                {
                                    SectionVirtualSizeFixed = PESections->VirtualAddress + (((PESections->Misc.VirtualSize / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment);
                                }
                                if(NumberOfSections > 1)
                                {
                                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + sizeof IMAGE_SECTION_HEADER);
                                    if(SectionVirtualSize > PESections->VirtualAddress || SectionVirtualSizeFixed > PESections->VirtualAddress)
                                    {
                                        PESections->Misc.VirtualSize = SectionVirtualSizeFixed;
                                    }
                                }
                                NumberOfSections--;
                            }
                            if(PESections->PointerToRawData + PESections->SizeOfRawData > FileSize && PESections->SizeOfRawData != NULL)
                            {
                                PESections->SizeOfRawData = FileSize - PESections->PointerToRawData;
                            }
                            if(myFileStatusInfo->SizeOfImage != UE_FIELD_OK)
                            {
                                SectionVirtualSizeFixed = SectionVirtualSizeFixed + 0xF000;
                                if(PEHeader32->OptionalHeader.SizeOfImage > SectionVirtualSizeFixed)
                                {
                                    PEHeader32->OptionalHeader.SizeOfImage = SectionVirtualSizeFixed - 0xF000;
                                }
                            }
                        }
                        /*
                            Entry point check
                        */
                        if(myFileStatusInfo->EntryPoint != UE_FIELD_OK)
                        {
                            SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader32->OptionalHeader.AddressOfEntryPoint + (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase);
                            if(SectionNumber != -1)
                            {
                                SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                                if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE)
                                {
                                    // Should never execute
                                }
                                else
                                {
                                    if(!SetPE32DataForMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS, 0xE0000020))
                                    {
                                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                        return false;
                                    }
                                }
                            }
                        }
                        /*
                            Fix end
                        */
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(FileFixed)
                        {
                            myFileFixInfo->OveralEvaluation = UE_RESULT_FILE_OK;
                            myFileFixInfo->FileFixPerformed = FileFixed;
                        }
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        myFileFixInfo->FixingTerminatedByException = true;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    /*
                        x64 Surface check
                    */
                    __try
                    {
                        if(PEHeader64->OptionalHeader.SizeOfImage % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                        {
                            CorrectedImageSize = (PEHeader64->OptionalHeader.SizeOfImage / PEHeader64->OptionalHeader.SectionAlignment) * PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        else
                        {
                            CorrectedImageSize = ((PEHeader64->OptionalHeader.SizeOfImage / PEHeader64->OptionalHeader.SectionAlignment) + 1) * PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        /*
                            Fixing import table
                        */
                        if(myFileStatusInfo->MissingDeclaredAPIs)
                        {
                            ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                            SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase);
                            if(SectionNumber >= NULL)
                            {
                                SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                                if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE || SectionAttributes & IMAGE_SCN_MEM_WRITE || SectionAttributes & IMAGE_SCN_CNT_INITIALIZED_DATA)
                                {
                                    // Should not execute!
                                }
                                else
                                {
                                    if(!SetPE32DataForMappedFile(FileMapVA, SectionAttributes, UE_SECTIONFLAGS, 0xE0000020))
                                    {
                                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                        return false;
                                    }
                                }
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != NULL)
                                {
                                    ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                    while(ImportIID->FirstThunk != NULL)
                                    {
                                        hLoadedModule = NULL;
                                        ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->Name + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                        if(ImportNamePtr != NULL)
                                        {
                                            if(!EngineIsDependencyPresent((char*)ImportNamePtr, NULL, NULL))
                                            {
                                                hLoadedModuleSimulated = false;
                                            }
                                            else
                                            {
                                                hLoadedModuleSimulated = false;
                                                hLoadedModule = GetModuleHandleA((char*)ImportNamePtr);
                                                if(hLoadedModule == NULL)
                                                {
                                                    hLoadedModule = (HMODULE)EngineSimulateDllLoader(GetCurrentProcess(), (char*)ImportNamePtr);
                                                    hLoadedModuleSimulated = true;
                                                }
                                            }
                                        }
                                        if(ImportIID->OriginalFirstThunk != NULL)
                                        {
                                            ThunkData64 = (PIMAGE_THUNK_DATA64)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->OriginalFirstThunk + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                            CurrentThunk = (ULONG_PTR)ImportIID->OriginalFirstThunk;
                                        }
                                        else
                                        {
                                            ThunkData32 = (PIMAGE_THUNK_DATA32)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ImportIID->FirstThunk + PEHeader32->OptionalHeader.ImageBase), false, true);
                                            CurrentThunk = (ULONG_PTR)ImportIID->FirstThunk;
                                        }
                                        if(ThunkData64 != NULL)
                                        {
                                            while(ThunkData64->u1.AddressOfData != NULL)
                                            {
                                                if(ThunkData64->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
                                                {
                                                    if((int)(ThunkData64->u1.Ordinal ^ IMAGE_ORDINAL_FLAG64) >= 0x10000)
                                                    {
                                                        FileFixed = false;
                                                    }
                                                }
                                                else
                                                {
                                                    ImportNamePtr = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, (ULONG_PTR)((ULONG_PTR)ThunkData64->u1.AddressOfData + 2 + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase), false, true);
                                                    if(ImportNamePtr != NULL)
                                                    {
                                                        if(EngineIsValidReadPtrEx((LPVOID)ImportNamePtr, 8))
                                                        {
                                                            if(hLoadedModule != NULL)
                                                            {
                                                                if(EngineGetProcAddress((ULONG_PTR)hLoadedModule, (char*)ImportNamePtr) == NULL)
                                                                {
                                                                    OrdinalBase = NULL;
                                                                    OrdinalCount = NULL;
                                                                    if(EngineGetLibraryOrdinalData((ULONG_PTR)hLoadedModule, &OrdinalBase, &OrdinalCount))
                                                                    {
                                                                        if(OrdinalBase != NULL && OrdinalCount != NULL)
                                                                        {
                                                                            ThunkData64->u1.Ordinal = (OrdinalBase + 1) ^ IMAGE_ORDINAL_FLAG64;
                                                                        }
                                                                        else
                                                                        {
                                                                            FileFixed = false;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                CurrentThunk = CurrentThunk + 8;
                                                ThunkData64 = (PIMAGE_THUNK_DATA64)((ULONG_PTR)ThunkData64 + sizeof IMAGE_THUNK_DATA64);
                                            }
                                        }
                                        if(hLoadedModuleSimulated)
                                        {
                                            VirtualFree((LPVOID)hLoadedModule, NULL, MEM_RELEASE);
                                        }
                                        ImportIID = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)ImportIID + sizeof IMAGE_IMPORT_DESCRIPTOR);
                                    }
                                }
                            }
                        }
                        /*
                            Fixing Export table
                        */
                        if(myFileStatusInfo->ExportTable == UE_FIELD_NOT_PRESET_WARNING)
                        {
                            FileFixed = false;
                        }
                        else if(myFileFixInfo->DontFixExports == false && myFileStatusInfo->ExportTable != UE_FIELD_OK && myFileStatusInfo->ExportTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_EXPORT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != NULL)
                            {
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedExports = true;
                                    myFileFixInfo->OriginalExportTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                                    myFileFixInfo->OriginalExportTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = NULL;
                                }
                                else
                                {
                                    FeatureFixed = true;
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress != NULL)
                                    {
                                        if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
                                        {
                                            PEExports = (PIMAGE_EXPORT_DIRECTORY)ConvertedAddress;
                                            if(PEExports->AddressOfFunctions > CorrectedImageSize || PEExports->AddressOfFunctions + 4 * PEExports->NumberOfFunctions > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            else if(PEExports->AddressOfNameOrdinals > CorrectedImageSize || PEExports->AddressOfNameOrdinals + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            else if(PEExports->AddressOfNames > CorrectedImageSize || PEExports->AddressOfNames + 4 * PEExports->NumberOfNames > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            else if(PEExports->Name > CorrectedImageSize)
                                            {
                                                FeatureFixed = false;
                                            }
                                            if(!FeatureFixed)
                                            {
                                                myFileFixInfo->StrippedExports = true;
                                                myFileFixInfo->OriginalExportTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                                                myFileFixInfo->OriginalExportTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                                                PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = NULL;
                                                PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = NULL;
                                            }
                                        }
                                        else
                                        {
                                            myFileFixInfo->StrippedExports = true;
                                            myFileFixInfo->OriginalExportTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
                                            myFileFixInfo->OriginalExportTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
                                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = NULL;
                                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = NULL;
                                        }
                                    }
                                }
                            }
                        }
                        /*
                            Fixing Relocation table
                        */
                        if(myFileStatusInfo->FileIsDLL == true && myFileStatusInfo->RelocationTable == UE_FIELD_BROKEN_NON_FIXABLE)
                        {
                            FileFixed = false;
                        }
                        else if(myFileFixInfo->DontFixRelocations == false && myFileStatusInfo->RelocationTable != UE_FIELD_OK)
                        {
                            if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size > CorrectedImageSize)
                            {
                                if(myFileStatusInfo->FileIsDLL)
                                {
                                    FileFixed = false;
                                }
                                else
                                {
                                    myFileFixInfo->StrippedRelocation = true;
                                    myFileFixInfo->OriginalRelocationTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                                    myFileFixInfo->OriginalRelocationTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = NULL;
                                }
                            }
                            else
                            {
                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                if(ConvertedAddress != NULL)
                                {
                                    if(EngineIsValidReadPtrEx((LPVOID)ConvertedAddress, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size))
                                    {
                                        RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                        RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        while(ReadData != NULL)
                                        {
                                            ReadSize = ReadSize - 8;
                                            ConvertedAddress = ConvertedAddress + 8;
                                            while(ReadSize > NULL)
                                            {
                                                RtlMoveMemory(&ReadDataWORD, (LPVOID)ConvertedAddress, 2);
                                                if(ReadDataWORD > 0xCFFF)
                                                {
                                                    RtlZeroMemory((LPVOID)ConvertedAddress, 2);
                                                }
                                                ConvertedAddress = ConvertedAddress + 2;
                                                ReadSize = ReadSize - 2;
                                            }
                                            RtlMoveMemory(&ReadData, (LPVOID)ConvertedAddress, 4);
                                            RtlMoveMemory(&ReadSize, (LPVOID)(ConvertedAddress + 4), 4);
                                        }
                                    }
                                    else
                                    {
                                        if(myFileStatusInfo->FileIsDLL)
                                        {
                                            FileFixed = false;
                                        }
                                        else
                                        {
                                            myFileFixInfo->StrippedRelocation = true;
                                            myFileFixInfo->OriginalRelocationTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                                            myFileFixInfo->OriginalRelocationTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = NULL;
                                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = NULL;
                                        }
                                    }
                                }
                                else
                                {
                                    if(myFileStatusInfo->FileIsDLL)
                                    {
                                        FileFixed = false;
                                    }
                                    else
                                    {
                                        myFileFixInfo->StrippedRelocation = true;
                                        myFileFixInfo->OriginalRelocationTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
                                        myFileFixInfo->OriginalRelocationTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = NULL;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = NULL;
                                    }
                                }
                            }
                        }
                        else if(myFileStatusInfo->RelocationTable == UE_FIELD_OK)
                        {
                            // Filter case!
                        }
                        else
                        {
                            FileFixed = false;
                        }
                        /*
                            Fixing Resource table
                        */
                        if(myFileFixInfo->DontFixResources == false && myFileStatusInfo->ResourceData != UE_FIELD_OK && myFileStatusInfo->ResourceData != UE_FIELD_NOT_PRESET)
                        {
                            myFileFixInfo->StrippedResources = true;
                            myFileFixInfo->OriginalResourceTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                            myFileFixInfo->OriginalResourceTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = NULL;
                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = NULL;
                        }
                        else if(myFileFixInfo->DontFixResources == false && myFileStatusInfo->ResourceTable != UE_FIELD_OK && myFileStatusInfo->ResourceTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_RESOURCE && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress != NULL)
                            {
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedResources = true;
                                    myFileFixInfo->OriginalResourceTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                                    myFileFixInfo->OriginalResourceTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize || ConvertedAddress - FileMapVA + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size > FileSize)
                                    {
                                        myFileFixInfo->StrippedResources = true;
                                        myFileFixInfo->OriginalResourceTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
                                        myFileFixInfo->OriginalResourceTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = NULL;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fixing TLS table
                        */
                        if(myFileFixInfo->DontFixTLS == false && myFileStatusInfo->TLSTable != UE_FIELD_OK && myFileStatusInfo->TLSTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_TLS && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                            {
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedTLS = true;
                                    myFileFixInfo->OriginalTLSTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                                    myFileFixInfo->OriginalTLSTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedTLS = true;
                                        myFileFixInfo->OriginalTLSTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                                        myFileFixInfo->OriginalTLSTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                                    }
                                    else
                                    {
                                        FeatureFixed = true;
                                        PETls64 = (PIMAGE_TLS_DIRECTORY64)ConvertedAddress;
                                        if(PETls64->StartAddressOfRawData != NULL && (PETls64->StartAddressOfRawData < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->StartAddressOfRawData > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        else if(PETls64->EndAddressOfRawData != NULL && (PETls64->EndAddressOfRawData < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->EndAddressOfRawData > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        else if(PETls64->AddressOfIndex != NULL && (PETls64->AddressOfIndex < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->AddressOfIndex > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        else if(PETls64->AddressOfCallBacks != NULL && (PETls64->AddressOfCallBacks < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || PETls64->AddressOfCallBacks > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase))
                                        {
                                            FeatureFixed = false;
                                        }
                                        if(!FeatureFixed)
                                        {
                                            myFileFixInfo->StrippedTLS = true;
                                            myFileFixInfo->OriginalTLSTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                                            myFileFixInfo->OriginalTLSTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
                                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                                            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                                        }
                                        else
                                        {
                                            if(PETls64->AddressOfCallBacks != NULL)
                                            {
                                                ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, (ULONG_PTR)PETls64->AddressOfCallBacks + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                                if(ConvertedAddress != NULL)
                                                {
                                                    while(ReadData != NULL)
                                                    {
                                                        RtlMoveMemory(&ReadDataQWORD, (LPVOID)ConvertedAddress, 8);
                                                        if(ReadDataQWORD < (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase || ReadDataQWORD > CorrectedImageSize + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase)
                                                        {
                                                            RtlZeroMemory((LPVOID)ConvertedAddress, 8);
                                                        }
                                                        ConvertedAddress = ConvertedAddress + 8;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        /*
                            Fix Load config table
                        */
                        if(myFileFixInfo->DontFixLoadConfig == false && myFileStatusInfo->LoadConfigTable != UE_FIELD_OK && myFileStatusInfo->LoadConfigTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress != NULL)
                            {
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedLoadConfig = true;
                                    myFileFixInfo->OriginalLoadConfigTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
                                    myFileFixInfo->OriginalLoadConfigTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedLoadConfig = true;
                                        myFileFixInfo->OriginalLoadConfigTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
                                        myFileFixInfo->OriginalLoadConfigTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = NULL;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix Bound import table
                        */
                        if(myFileFixInfo->DontFixBoundImports == false && myFileStatusInfo->BoundImportTable != UE_FIELD_OK && myFileStatusInfo->BoundImportTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress != NULL)
                            {
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedBoundImports = true;
                                    myFileFixInfo->OriginalBoundImportTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
                                    myFileFixInfo->OriginalBoundImportTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedBoundImports = true;
                                        myFileFixInfo->OriginalBoundImportTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
                                        myFileFixInfo->OriginalBoundImportTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix IAT
                        */
                        if(myFileFixInfo->DontFixIAT == false && myFileStatusInfo->IATTable != UE_FIELD_OK && myFileStatusInfo->IATTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_IAT && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress != NULL)
                            {
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedIAT = true;
                                    myFileFixInfo->OriginalImportAddressTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
                                    myFileFixInfo->OriginalImportAddressTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedIAT = true;
                                        myFileFixInfo->OriginalImportAddressTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
                                        myFileFixInfo->OriginalImportAddressTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = NULL;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix COM header
                        */
                        if(myFileFixInfo->DontFixCOM == false && myFileStatusInfo->COMHeaderTable != UE_FIELD_OK && myFileStatusInfo->COMHeaderTable != UE_FIELD_NOT_PRESET)
                        {
                            if(PEHeader64->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR && PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress != NULL)
                            {
                                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress > CorrectedImageSize || PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size > CorrectedImageSize)
                                {
                                    myFileFixInfo->StrippedCOM = true;
                                    myFileFixInfo->OriginalCOMTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
                                    myFileFixInfo->OriginalCOMTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = NULL;
                                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size = NULL;
                                }
                                else
                                {
                                    ConvertedAddress = (ULONG_PTR)ConvertVAtoFileOffsetEx(FileMapVA, FileSize, NULL, PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase, false, true);
                                    if(ConvertedAddress == NULL || ConvertedAddress - FileMapVA > FileSize)
                                    {
                                        myFileFixInfo->StrippedCOM = true;
                                        myFileFixInfo->OriginalCOMTableAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
                                        myFileFixInfo->OriginalCOMTableSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = NULL;
                                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size = NULL;
                                    }
                                }
                            }
                        }
                        /*
                            Fix sections and SizeOfImage
                        */
                        if(myFileStatusInfo->SectionTable != UE_FIELD_OK || myFileStatusInfo->SizeOfImage != UE_FIELD_OK)
                        {
                            PESections = IMAGE_FIRST_SECTION(PEHeader64);
                            NumberOfSections = PEHeader64->FileHeader.NumberOfSections;
                            while(NumberOfSections > NULL)
                            {
                                SectionVirtualSize = PESections->VirtualAddress + PESections->Misc.VirtualSize;
                                if(PESections->Misc.VirtualSize % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                                {
                                    SectionVirtualSizeFixed = SectionVirtualSize;
                                }
                                else
                                {
                                    SectionVirtualSizeFixed = PESections->VirtualAddress + (((PESections->Misc.VirtualSize / PEHeader64->OptionalHeader.SectionAlignment) + 1) * PEHeader64->OptionalHeader.SectionAlignment);
                                }
                                if(NumberOfSections > 1)
                                {
                                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + sizeof IMAGE_SECTION_HEADER);
                                    if(SectionVirtualSize > PESections->VirtualAddress || SectionVirtualSizeFixed > PESections->VirtualAddress)
                                    {
                                        PESections->Misc.VirtualSize = SectionVirtualSizeFixed;
                                    }
                                }
                                NumberOfSections--;
                            }
                            if(PESections->PointerToRawData + PESections->SizeOfRawData > FileSize && PESections->SizeOfRawData != NULL)
                            {
                                PESections->SizeOfRawData = FileSize - PESections->PointerToRawData;
                            }
                            if(myFileStatusInfo->SizeOfImage != UE_FIELD_OK)
                            {
                                SectionVirtualSizeFixed = SectionVirtualSizeFixed + 0xF000;
                                if(PEHeader64->OptionalHeader.SizeOfImage > SectionVirtualSizeFixed)
                                {
                                    PEHeader64->OptionalHeader.SizeOfImage = SectionVirtualSizeFixed - 0xF000;
                                }
                            }
                        }
                        /*
                            Entry point check
                        */
                        if(myFileStatusInfo->EntryPoint != UE_FIELD_OK)
                        {
                            SectionNumber = GetPE32SectionNumberFromVA(FileMapVA, PEHeader64->OptionalHeader.AddressOfEntryPoint + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase);
                            if(SectionNumber != -1)
                            {
                                SectionAttributes = (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS);
                                if(SectionAttributes & IMAGE_SCN_MEM_EXECUTE || SectionAttributes & IMAGE_SCN_CNT_CODE)
                                {
                                    // Should never execute
                                }
                                else
                                {
                                    if(!SetPE32DataForMappedFile(FileMapVA, SectionNumber, UE_SECTIONFLAGS, 0xE0000020))
                                    {
                                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                        return false;
                                    }
                                }
                            }
                        }
                        /*
                            Fix end
                        */
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(FileFixed)
                        {
                            myFileFixInfo->OveralEvaluation = UE_RESULT_FILE_OK;
                            myFileFixInfo->FileFixPerformed = FileFixed;
                        }
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        myFileFixInfo->FixingTerminatedByException = true;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
        }
    }
    else if(myFileFixInfo->FileFixPerformed)
    {
        if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
        {
            DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
            if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
            {
                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                if(PEHeader32->Signature == 0x4550 && PEHeader32->OptionalHeader.Magic == 0x10B)
                {
                    FileIs64 = false;
                }
                else if(PEHeader32->Signature == 0x4550 && PEHeader32->OptionalHeader.Magic == 0x20B)
                {
                    FileIs64 = true;
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
                if(!FileIs64)
                {
                    if(myFileFixInfo->StrippedRelocation)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = myFileFixInfo->OriginalRelocationTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = myFileFixInfo->OriginalRelocationTableSize;
                    }
                    if(myFileFixInfo->StrippedExports)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = myFileFixInfo->OriginalExportTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = myFileFixInfo->OriginalExportTableSize;
                    }
                    if(myFileFixInfo->StrippedResources)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = myFileFixInfo->OriginalResourceTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = myFileFixInfo->OriginalResourceTableSize;
                    }
                    if(myFileFixInfo->StrippedTLS)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = myFileFixInfo->OriginalTLSTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = myFileFixInfo->OriginalTLSTableSize;
                    }
                    if(myFileFixInfo->StrippedLoadConfig)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = myFileFixInfo->OriginalLoadConfigTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = myFileFixInfo->OriginalLoadConfigTableSize;
                    }
                    if(myFileFixInfo->StrippedBoundImports)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = myFileFixInfo->OriginalBoundImportTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = myFileFixInfo->OriginalBoundImportTableSize;
                    }
                    if(myFileFixInfo->StrippedIAT)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = myFileFixInfo->OriginalImportAddressTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = myFileFixInfo->OriginalImportAddressTableSize;
                    }
                    if(myFileFixInfo->StrippedCOM)
                    {
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = myFileFixInfo->OriginalCOMTableAddress;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size = myFileFixInfo->OriginalCOMTableSize;
                    }
                }
                else
                {
                    if(myFileFixInfo->StrippedRelocation)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = myFileFixInfo->OriginalRelocationTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = myFileFixInfo->OriginalRelocationTableSize;
                    }
                    if(myFileFixInfo->StrippedExports)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = myFileFixInfo->OriginalExportTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = myFileFixInfo->OriginalExportTableSize;
                    }
                    if(myFileFixInfo->StrippedResources)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = myFileFixInfo->OriginalResourceTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = myFileFixInfo->OriginalResourceTableSize;
                    }
                    if(myFileFixInfo->StrippedTLS)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = myFileFixInfo->OriginalTLSTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = myFileFixInfo->OriginalTLSTableSize;
                    }
                    if(myFileFixInfo->StrippedLoadConfig)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = myFileFixInfo->OriginalLoadConfigTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = myFileFixInfo->OriginalLoadConfigTableSize;
                    }
                    if(myFileFixInfo->StrippedBoundImports)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = myFileFixInfo->OriginalBoundImportTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = myFileFixInfo->OriginalBoundImportTableSize;
                    }
                    if(myFileFixInfo->StrippedIAT)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = myFileFixInfo->OriginalImportAddressTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = myFileFixInfo->OriginalImportAddressTableSize;
                    }
                    if(myFileFixInfo->StrippedCOM)
                    {
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = myFileFixInfo->OriginalCOMTableAddress;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size = myFileFixInfo->OriginalCOMTableSize;
                    }
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return true;
            }
        }
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.PE.Overlay.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Handle.h"
#include "Global.Mapping.h"
#include "Global.Engine.h"

static char* szSharedOverlay = 0;
static wchar_t* szSharedOverlayW = 0;

__declspec(dllexport) bool TITCALL FindOverlay(char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(FindOverlayW(uniFileName, OverlayStart, OverlaySize));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL FindOverlayW(wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    DWORD SectionRawOffset = 0;
    DWORD SectionRawSize = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->PointerToRawData >= SectionRawOffset)
                        {
                            if(PESections->SizeOfRawData != NULL || (SectionRawOffset != PESections->PointerToRawData))
                            {
                                SectionRawSize = PESections->SizeOfRawData;
                            }
                            SectionRawOffset = PESections->PointerToRawData;
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(SectionRawOffset + SectionRawSize < FileSize)
                    {
                        if(OverlayStart != NULL && OverlaySize != NULL)
                        {
                            *OverlayStart = (DWORD)(SectionRawOffset + SectionRawSize);
                            *OverlaySize = (DWORD)(FileSize - SectionRawOffset - SectionRawSize);
                        }
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        if(PESections->PointerToRawData >= SectionRawOffset)
                        {
                            if(PESections->SizeOfRawData != NULL || (SectionRawOffset != PESections->PointerToRawData))
                            {
                                SectionRawSize = PESections->SizeOfRawData;
                            }
                            SectionRawOffset = PESections->PointerToRawData;
                        }
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(SectionRawOffset + SectionRawSize < FileSize)
                    {
                        if(OverlayStart != NULL && OverlaySize != NULL)
                        {
                            *OverlayStart = (DWORD)(SectionRawOffset + SectionRawSize);
                            *OverlaySize = (DWORD)(FileSize - SectionRawOffset - SectionRawSize);
                        }
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL ExtractOverlay(char* szFileName, char* szExtactedFileName)
{

    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t uniExtactedFileName[MAX_PATH] = {};

    if(szFileName != NULL && szExtactedFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szExtactedFileName, lstrlenA(szExtactedFileName) + 1, uniExtactedFileName, sizeof(uniExtactedFileName) / (sizeof(uniExtactedFileName[0])));
        return(ExtractOverlayW(uniFileName, uniExtactedFileName));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL ExtractOverlayW(wchar_t* szFileName, wchar_t* szExtactedFileName)
{

    HANDLE hFile = 0;
    HANDLE hFileWrite = 0;
    BOOL Return = false;
    DWORD OverlayStart = 0;
    DWORD OverlaySize = 0;
    DWORD ueNumberOfBytesRead = 0;
    char ueReadBuffer[0x2000] = {0};

    Return = FindOverlayW(szFileName, &OverlayStart, &OverlaySize);
    if(Return)
    {
        hFile = CreateFileW(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile != INVALID_HANDLE_VALUE)
        {
            EngineCreatePathForFileW(szExtactedFileName);
            hFileWrite = CreateFileW(szExtactedFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFileWrite != INVALID_HANDLE_VALUE)
            {
                SetFilePointer(hFile, OverlayStart, NULL, FILE_BEGIN);
                while(OverlaySize > 0)
                {
                    RtlZeroMemory(ueReadBuffer, sizeof(ueReadBuffer));

                    if(OverlaySize > 0x1000)
                    {
                        if(ReadFile(hFile, ueReadBuffer, 0x1000, &ueNumberOfBytesRead, NULL))
                        {
                            if(!WriteFile(hFileWrite, ueReadBuffer, 0x1000, &ueNumberOfBytesRead, NULL))
                                return false;
                        }
                        else
                        {
                            return false;
                        }

                        OverlaySize = OverlaySize - 0x1000;
                    }
                    else
                    {
                        if(ReadFile(hFile, ueReadBuffer, OverlaySize, &ueNumberOfBytesRead, NULL))
                        {
                            if(!WriteFile(hFileWrite, ueReadBuffer, OverlaySize, &ueNumberOfBytesRead, NULL))
                                return false;
                        }
                        else
                        {
                            return false;
                        }

                        OverlaySize = 0;
                    }
                }
                EngineCloseHandle(hFile);
                EngineCloseHandle(hFileWrite);
                return true;
            }
            else
            {
                EngineCloseHandle(hFile);
                return false;
            }
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL AddOverlay(char* szFileName, char* szOverlayFileName)
{

    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t uniOverlayFileName[MAX_PATH] = {};

    if(szFileName != NULL && szOverlayFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szOverlayFileName, lstrlenA(szOverlayFileName) + 1, uniOverlayFileName, sizeof(uniOverlayFileName) / (sizeof(uniOverlayFileName[0])));
        return(AddOverlayW(uniFileName, uniOverlayFileName));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL AddOverlayW(wchar_t* szFileName, wchar_t* szOverlayFileName)
{

    HANDLE hFile = 0;
    HANDLE hFileRead = 0;
    DWORD FileSize = 0;
    DWORD OverlaySize = 0;
    ULONG_PTR ueNumberOfBytesRead = 0;
    DWORD uedNumberOfBytesRead = 0;
    char ueReadBuffer[0x2000] = {0};

    hFile = CreateFileW(szFileName, GENERIC_READ + GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        hFileRead = CreateFileW(szOverlayFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFileRead != INVALID_HANDLE_VALUE)
        {
            FileSize = GetFileSize(hFile, NULL);
            OverlaySize = GetFileSize(hFileRead, NULL);
            SetFilePointer(hFile, FileSize, NULL, FILE_BEGIN);
            while(OverlaySize > 0)
            {
                RtlZeroMemory(ueReadBuffer, sizeof(ueReadBuffer));

                if(OverlaySize > 0x1000)
                {
                    if(ReadFile(hFileRead, ueReadBuffer, 0x1000, &uedNumberOfBytesRead, NULL))
                    {
                        if(!WriteFile(hFile, ueReadBuffer, 0x1000, &uedNumberOfBytesRead, NULL))
                            return false;
                    }
                    else
                    {
                        return false;
                    }

                    OverlaySize = OverlaySize - 0x1000;
                }
                else
                {
                    if(ReadFile(hFileRead, ueReadBuffer, OverlaySize, &uedNumberOfBytesRead, NULL))
                    {
                        if(!WriteFile(hFile, ueReadBuffer, OverlaySize, &uedNumberOfBytesRead, NULL))
                            return false;
                    }
                    else
                    {
                        return false;
                    }

                    OverlaySize = 0;
                }
            }
            EngineCloseHandle(hFile);
            EngineCloseHandle(hFileRead);
            return true;
        }
        else
        {
            EngineCloseHandle(hFile);
            return false;
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL CopyOverlay(char* szInFileName, char* szOutFileName)
{

    wchar_t uniInFileName[MAX_PATH] = {};
    wchar_t uniOutFileName[MAX_PATH] = {};

    if(szInFileName != NULL && szOutFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szInFileName, lstrlenA(szInFileName) + 1, uniInFileName, sizeof(uniInFileName) / (sizeof(uniInFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szOutFileName, lstrlenA(szOutFileName) + 1, uniOutFileName, sizeof(uniOutFileName) / (sizeof(uniOutFileName[0])));
        return(CopyOverlayW(uniInFileName, uniOutFileName));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL CopyOverlayW(wchar_t* szInFileName, wchar_t* szOutFileName)
{

    wchar_t szTempName[MAX_PATH] = {};
    wchar_t szTempFolder[MAX_PATH] = {};

    if(GetTempPathW(MAX_PATH, szTempFolder) < MAX_PATH)
    {
        if(GetTempFileNameW(szTempFolder, L"OverlayTemp", GetTickCount() + 101, szTempName))
        {
            if(ExtractOverlayW(szInFileName, szTempName))
            {
                AddOverlayW(szOutFileName, szTempName);
                DeleteFileW(szTempName);
                return true;
            }
        }
    }
    return false;
}
__declspec(dllexport) bool TITCALL RemoveOverlay(char* szFileName)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(RemoveOverlayW(uniFileName));
    }
    else
    {
        return false;
    }
}
__declspec(dllexport) bool TITCALL RemoveOverlayW(wchar_t* szFileName)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    DWORD OverlayStart = 0;
    DWORD OverlaySize = 0;

    if(FindOverlayW(szFileName, &OverlayStart, &OverlaySize))
    {
        if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
        {
            FileSize = FileSize - OverlaySize;
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return true;
        }
    }
    return false;
}

__declspec(dllexport) void TITCALL SetSharedOverlay(char* szFileName)
{
    szSharedOverlay = szFileName;
}
__declspec(dllexport) void TITCALL SetSharedOverlayW(wchar_t* szFileName)
{
    szSharedOverlayW = szFileName;
}
__declspec(dllexport) char* TITCALL GetSharedOverlay()
{
    return(szSharedOverlay);
}
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW()
{
    return(szSharedOverlayW);
}



================================================
File: TitanEngine/TitanEngine.PE.Section.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Handle.h"
#include "Global.Mapping.h"
#include "Global.Garbage.h"

__declspec(dllexport) bool TITCALL ExtractSection(char* szFileName, char* szDumpFileName, DWORD SectionNumber)
{
    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t uniDumpFileName[MAX_PATH] = {};

    if(szFileName != NULL && szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, lstrlenA(szDumpFileName) + 1, uniDumpFileName, sizeof(uniDumpFileName) / (sizeof(uniDumpFileName[0])));
        return(ExtractSectionW(uniFileName, uniDumpFileName, SectionNumber));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL ExtractSectionW(wchar_t* szFileName, wchar_t* szDumpFileName, DWORD SectionNumber)
{
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD NumberOfBytesWritten;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    HANDLE hFile;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                if(SectionNumber <= PEHeader32->FileHeader.NumberOfSections)
                {
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + SectionNumber * IMAGE_SIZEOF_SECTION_HEADER);
                    EngineCreatePathForFileW(szDumpFileName);
                    hFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                    if(hFile != INVALID_HANDLE_VALUE)
                    {
                        __try
                        {
                            WriteFile(hFile, (LPCVOID)(FileMapVA + PESections->PointerToRawData), PESections->SizeOfRawData, &NumberOfBytesWritten, NULL);
                            EngineCloseHandle(hFile);
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            EngineCloseHandle(hFile);
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            DeleteFileW(szDumpFileName);
                            return false;
                        }
                    }
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                if(SectionNumber <= PEHeader64->FileHeader.NumberOfSections)
                {
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + SectionNumber * IMAGE_SIZEOF_SECTION_HEADER);
                    EngineCreatePathForFileW(szDumpFileName);
                    hFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                    if(hFile != INVALID_HANDLE_VALUE)
                    {
                        __try
                        {
                            WriteFile(hFile, (LPCVOID)(FileMapVA + PESections->PointerToRawData), PESections->SizeOfRawData, &NumberOfBytesWritten, NULL);
                            EngineCloseHandle(hFile);
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            EngineCloseHandle(hFile);
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            DeleteFileW(szDumpFileName);
                            return false;
                        }
                    }
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL ResortFileSections(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(ResortFileSectionsW(uniFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL ResortFileSectionsW(wchar_t* szFileName)
{
    int i = 0;
    int j = 0;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};
    ULONG_PTR fileSectionData[MAXIMUM_SECTION_NUMBER][3];
    ULONG_PTR fileSectionTemp;
    LPVOID sortedFileName;
    DynBuf sortedFileNameBuf;

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return false;
            }
            if(!FileIs64)
            {
                sortedFileName = sortedFileNameBuf.Allocate(FileSize);
                if(sortedFileName)
                {
                    RtlMoveMemory(sortedFileName, (LPVOID)FileMapVA, FileSize);
                    SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                    PESections = IMAGE_FIRST_SECTION(PEHeader32);
                    while(SectionNumber > 0)
                    {
                        fileSectionData[i][0] = (ULONG_PTR)(PESections->PointerToRawData);
                        fileSectionData[i][1] = PESections->SizeOfRawData;
                        fileSectionData[i][2] = PEHeader32->FileHeader.NumberOfSections - SectionNumber;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                        i++;
                    }
                    for(j = 0; j < PEHeader32->FileHeader.NumberOfSections; j++)
                    {
                        for(i = 0; i < PEHeader32->FileHeader.NumberOfSections; i++)
                        {
                            if(fileSectionData[i][0] > fileSectionData[j][0])
                            {
                                fileSectionTemp = fileSectionData[j][0];
                                fileSectionData[j][0] = fileSectionData[i][0];
                                fileSectionData[i][0] = fileSectionTemp;
                                fileSectionTemp = fileSectionData[j][1];
                                fileSectionData[j][1] = fileSectionData[i][1];
                                fileSectionData[i][1] = fileSectionTemp;
                            }
                        }
                    }
                    for(i = 0; i < PEHeader32->FileHeader.NumberOfSections; i++)
                    {
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PEHeader32 - FileMapVA + (ULONG_PTR)sortedFileName + PEHeader32->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER) + 4);
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + fileSectionData[i][2] * IMAGE_SIZEOF_SECTION_HEADER);
                        RtlMoveMemory((LPVOID)((ULONG_PTR)sortedFileName + fileSectionData[i][0]), (LPVOID)((ULONG_PTR)FileMapVA + PESections->PointerToRawData), fileSectionData[i][1]);
                        PESections->PointerToRawData = (DWORD)fileSectionData[i][0];
                        PESections->SizeOfRawData = (DWORD)fileSectionData[i][1];
                    }
                    RtlMoveMemory((LPVOID)FileMapVA, sortedFileName, FileSize);
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return true;
                        }
                        else
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return false;
                        }
                    }
                    else
                    {
                        return true;
                    }
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
            else
            {
                sortedFileName = sortedFileNameBuf.Allocate(FileSize);
                if(sortedFileName)
                {
                    RtlMoveMemory(sortedFileName, (LPVOID)FileMapVA, FileSize);
                    SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                    PESections = IMAGE_FIRST_SECTION(PEHeader64);
                    while(SectionNumber > 0)
                    {
                        fileSectionData[i][0] = (ULONG_PTR)(PESections->PointerToRawData);
                        fileSectionData[i][1] = PESections->SizeOfRawData;
                        fileSectionData[i][2] = PEHeader64->FileHeader.NumberOfSections - SectionNumber;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                        i++;
                    }
                    for(j = 0; j < PEHeader64->FileHeader.NumberOfSections; j++)
                    {
                        for(i = 0; i < PEHeader64->FileHeader.NumberOfSections; i++)
                        {
                            if(fileSectionData[i][0] > fileSectionData[j][0])
                            {
                                fileSectionTemp = fileSectionData[j][0];
                                fileSectionData[j][0] = fileSectionData[i][0];
                                fileSectionData[i][0] = fileSectionTemp;
                                fileSectionTemp = fileSectionData[j][1];
                                fileSectionData[j][1] = fileSectionData[i][1];
                                fileSectionData[i][1] = fileSectionTemp;
                            }
                        }
                    }
                    for(i = 0; i < PEHeader64->FileHeader.NumberOfSections; i++)
                    {
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PEHeader64 - FileMapVA + (ULONG_PTR)sortedFileName + PEHeader64->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER) + 4);
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + fileSectionData[i][2] * IMAGE_SIZEOF_SECTION_HEADER);
                        RtlMoveMemory((LPVOID)((ULONG_PTR)sortedFileName + fileSectionData[i][0]), (LPVOID)((ULONG_PTR)FileMapVA + PESections->PointerToRawData), fileSectionData[i][1]);
                        PESections->PointerToRawData = (DWORD)fileSectionData[i][0];
                        PESections->SizeOfRawData = (DWORD)fileSectionData[i][1];
                    }
                    RtlMoveMemory((LPVOID)FileMapVA, sortedFileName, FileSize);
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return true;
                        }
                        else
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return false;
                        }
                    }
                    else
                    {
                        return true;
                    }
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return false;
        }
    }
    RemoveGarbageItem(szBackupItem, true);
    return false;
}

__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(MakeAllSectionsRWEW(uniFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(wchar_t* szFileName)
{
    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return false;
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        PESections->Characteristics = 0xE0000020;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return true;
                        }
                        else
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return false;
                        }
                    }
                    else
                    {
                        return true;
                    }
                    return true;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    while(SectionNumber > 0)
                    {
                        PESections->Characteristics = 0xE0000020;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        SectionNumber--;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return true;
                        }
                        else
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return false;
                        }
                    }
                    else
                    {
                        return true;
                    }
                    return true;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return false;
        }
    }
    RemoveGarbageItem(szBackupItem, true);
    return false;
}

__declspec(dllexport) long TITCALL AddNewSectionEx(char* szFileName, char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(AddNewSectionExW(uniFileName, szSectionName, SectionSize, SectionAttributes, SectionContent, ContentSize));
    }
    else
    {
        return NULL;
    }
}

__declspec(dllexport) long TITCALL AddNewSectionExW(wchar_t* szFileName, char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize)
{
    bool OverlayHasBeenRemoved = false;
    wchar_t szBackupOverlayFile[MAX_PATH] = {};
    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNameLength = 0;
    DWORD NewSectionVirtualOffset = 0;
    DWORD FileResizeValue = 0;
    DWORD LastSectionRawSize = 0;
    DWORD alignedSectionSize = 0;
    DWORD NtSizeOfImage = 0;
    DWORD SectionNumber = 0;
    DWORD SpaceLeft = 0;
    LPVOID NameOffset;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    DWORD OldFileSize = 0;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(ContentSize < SectionSize && ContentSize != 0)
    {
        ContentSize = SectionSize;
    }
    else if(ContentSize > SectionSize)
    {
        SectionSize = ContentSize;
    }

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
        if(FindOverlayW(szBackupFile, NULL, NULL))
        {
            if(!FillGarbageItem(szBackupItem, NULL, &szBackupOverlayFile, sizeof szBackupItem))
            {
                RtlZeroMemory(&szBackupOverlayFile, sizeof szBackupOverlayFile);
            }
            else
            {
                if(ExtractOverlayW(szBackupFile, szBackupOverlayFile) && RemoveOverlayW(szBackupFile))
                {
                    OverlayHasBeenRemoved = true;
                }
            }
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        OldFileSize = FileSize;
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return(0);
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    alignedSectionSize = ((DWORD)SectionSize / PEHeader32->OptionalHeader.FileAlignment) * PEHeader32->OptionalHeader.FileAlignment;
                    if(alignedSectionSize < SectionSize)
                    {
                        SectionSize = alignedSectionSize + PEHeader32->OptionalHeader.FileAlignment;
                    }
                    else
                    {
                        SectionSize = alignedSectionSize;
                    }
                    SpaceLeft = PESections->PointerToRawData - (SectionNumber * IMAGE_SIZEOF_SECTION_HEADER) - DOSHeader->e_lfanew - sizeof IMAGE_NT_HEADERS32;
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                    LastSectionRawSize = (PESections->SizeOfRawData / PEHeader32->OptionalHeader.FileAlignment) * PEHeader32->OptionalHeader.FileAlignment;
                    if(LastSectionRawSize < PESections->SizeOfRawData)
                    {
                        LastSectionRawSize = LastSectionRawSize + PEHeader32->OptionalHeader.FileAlignment;
                    }
                    LastSectionRawSize = LastSectionRawSize - PESections->SizeOfRawData;
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    FileResizeValue = LastSectionRawSize + SectionSize;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return(0);
                }
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    alignedSectionSize = ((DWORD)SectionSize / PEHeader64->OptionalHeader.FileAlignment) * PEHeader64->OptionalHeader.FileAlignment;
                    if(alignedSectionSize < SectionSize)
                    {
                        SectionSize = alignedSectionSize + PEHeader64->OptionalHeader.FileAlignment;
                    }
                    else
                    {
                        SectionSize = alignedSectionSize;
                    }
                    SpaceLeft = PESections->PointerToRawData - (SectionNumber * IMAGE_SIZEOF_SECTION_HEADER) - DOSHeader->e_lfanew - sizeof IMAGE_NT_HEADERS64;
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                    LastSectionRawSize = (PESections->SizeOfRawData / PEHeader64->OptionalHeader.FileAlignment) * PEHeader64->OptionalHeader.FileAlignment;
                    if(LastSectionRawSize < PESections->SizeOfRawData)
                    {
                        LastSectionRawSize = LastSectionRawSize + PEHeader64->OptionalHeader.FileAlignment;
                    }
                    LastSectionRawSize = LastSectionRawSize - PESections->SizeOfRawData;
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    FileResizeValue = LastSectionRawSize + SectionSize;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return(0);
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return(0);
        }
    }
    if(SpaceLeft > IMAGE_SIZEOF_SECTION_HEADER)
    {
        if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, FileResizeValue))
        {
            DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
            if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
            {
                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                if(PEHeader32->OptionalHeader.Magic == 0x10B)
                {
                    FileIs64 = false;
                }
                else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                {
                    FileIs64 = true;
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return(0);
                }
                if(!FileIs64)
                {
                    __try
                    {
                        if(SectionSize == 0)
                        {
                            SectionSize = PEHeader32->OptionalHeader.FileAlignment;
                        }
                        alignedSectionSize = ((DWORD)SectionSize / PEHeader32->OptionalHeader.SectionAlignment) * PEHeader32->OptionalHeader.SectionAlignment;
                        if(alignedSectionSize < SectionSize)
                        {
                            alignedSectionSize = alignedSectionSize + PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        PESections = IMAGE_FIRST_SECTION(PEHeader32);
                        SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                        PEHeader32->FileHeader.NumberOfSections = PEHeader32->FileHeader.NumberOfSections + 1;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                        NewSectionVirtualOffset = PESections->VirtualAddress + (PESections->Misc.VirtualSize / PEHeader32->OptionalHeader.SectionAlignment) * PEHeader32->OptionalHeader.SectionAlignment;
                        if(NewSectionVirtualOffset < PESections->VirtualAddress + PESections->Misc.VirtualSize)
                        {
                            NewSectionVirtualOffset = NewSectionVirtualOffset + PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        PESections->SizeOfRawData = PESections->SizeOfRawData + LastSectionRawSize;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader32->OptionalHeader.SizeOfImage = NewSectionVirtualOffset + alignedSectionSize;
                        NameOffset = &PESections->Name;
                        if(lstrlenA(szSectionName) >= 8)
                        {
                            SectionNameLength = 8;
                        }
                        else
                        {
                            SectionNameLength = lstrlenA(szSectionName);
                        }
                        RtlMoveMemory(NameOffset, szSectionName, SectionNameLength);
                        if(SectionAttributes == 0)
                        {
                            PESections->Characteristics = 0xE0000020;
                        }
                        else
                        {
                            PESections->Characteristics = (DWORD)(SectionAttributes);
                        }
                        PESections->Misc.VirtualSize = alignedSectionSize;
                        PESections->SizeOfRawData = (DWORD)(SectionSize);
                        PESections->VirtualAddress = NewSectionVirtualOffset;
                        PESections->PointerToRawData = OldFileSize + LastSectionRawSize;
                        if(SectionContent != NULL)
                        {
                            RtlMoveMemory((LPVOID)(FileMapVA + OldFileSize), SectionContent, ContentSize);
                        }
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(szBackupItem[0] != NULL)
                        {
                            if(CopyFileW(szBackupFile, szFileName, false))
                            {
                                if(OverlayHasBeenRemoved && !AddOverlayW(szFileName, szBackupOverlayFile))
                                {
                                    RemoveGarbageItem(szBackupItem, true);
                                    return(0);
                                }
                                RemoveGarbageItem(szBackupItem, true);
                                return(NewSectionVirtualOffset);
                            }
                            else
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return(0);
                            }
                        }
                        else
                        {
                            return(NewSectionVirtualOffset);
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        RemoveGarbageItem(szBackupItem, true);
                        return(0);
                    }
                }
                else
                {
                    __try
                    {
                        if(SectionSize == 0)
                        {
                            SectionSize = PEHeader64->OptionalHeader.FileAlignment;
                        }
                        alignedSectionSize = ((DWORD)SectionSize / PEHeader64->OptionalHeader.SectionAlignment) * PEHeader64->OptionalHeader.SectionAlignment;
                        if(alignedSectionSize < SectionSize)
                        {
                            alignedSectionSize = alignedSectionSize + PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        PESections = IMAGE_FIRST_SECTION(PEHeader64);
                        SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                        PEHeader32->FileHeader.NumberOfSections = PEHeader32->FileHeader.NumberOfSections + 1;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                        NewSectionVirtualOffset = PESections->VirtualAddress + (PESections->Misc.VirtualSize / PEHeader64->OptionalHeader.SectionAlignment) * PEHeader64->OptionalHeader.SectionAlignment;
                        if(NewSectionVirtualOffset < PESections->VirtualAddress + PESections->Misc.VirtualSize)
                        {
                            NewSectionVirtualOffset = NewSectionVirtualOffset + PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        PESections->SizeOfRawData = PESections->SizeOfRawData + LastSectionRawSize;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader64->OptionalHeader.SizeOfImage = NewSectionVirtualOffset + alignedSectionSize;
                        NameOffset = &PESections->Name;
                        if(lstrlenA(szSectionName) >= 8)
                        {
                            SectionNameLength = 8;
                        }
                        else
                        {
                            SectionNameLength = lstrlenA(szSectionName);
                        }
                        RtlMoveMemory(NameOffset, szSectionName, SectionNameLength);
                        if(SectionAttributes == 0)
                        {
                            PESections->Characteristics = 0xE0000020;
                        }
                        else
                        {
                            PESections->Characteristics = (DWORD)(SectionAttributes);
                        }
                        PESections->Misc.VirtualSize = alignedSectionSize;
                        PESections->SizeOfRawData = (DWORD)(SectionSize);
                        PESections->VirtualAddress = NewSectionVirtualOffset;
                        PESections->PointerToRawData = OldFileSize + LastSectionRawSize;
                        if(SectionContent != NULL)
                        {
                            RtlMoveMemory((LPVOID)(FileMapVA + OldFileSize), SectionContent, ContentSize);
                        }
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(szBackupItem[0] != NULL)
                        {
                            if(CopyFileW(szBackupFile, szFileName, false))
                            {
                                if(OverlayHasBeenRemoved && !AddOverlayW(szFileName, szBackupOverlayFile))
                                {
                                    RemoveGarbageItem(szBackupItem, true);
                                    return(0);
                                }
                                RemoveGarbageItem(szBackupItem, true);
                                return(NewSectionVirtualOffset);
                            }
                            else
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return(0);
                            }
                        }
                        else
                        {
                            return(NewSectionVirtualOffset);
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        RemoveGarbageItem(szBackupItem, true);
                        return(0);
                    }
                }
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return(0);
            }
        }
    }
    RemoveGarbageItem(szBackupItem, true);
    return(0);
}

__declspec(dllexport) long TITCALL AddNewSection(char* szFileName, char* szSectionName, DWORD SectionSize)
{
    return AddNewSectionEx(szFileName, szSectionName, SectionSize, NULL, NULL, NULL);
}

__declspec(dllexport) long TITCALL AddNewSectionW(wchar_t* szFileName, char* szSectionName, DWORD SectionSize)
{
    return AddNewSectionExW(szFileName, szSectionName, SectionSize, NULL, NULL, NULL);
}

__declspec(dllexport) bool TITCALL ResizeLastSection(char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(ResizeLastSectionW(uniFileName, NumberOfExpandBytes, AlignResizeData));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL ResizeLastSectionW(wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData)
{
    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    DWORD SectionRawSize = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NumberOfExpandBytes))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                FileSize = FileSize - NumberOfExpandBytes;
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return false;
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                SectionNumber--;
                PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + SectionNumber * IMAGE_SIZEOF_SECTION_HEADER);
                __try
                {
                    if(AlignResizeData)
                    {
                        SectionRawSize = PESections->SizeOfRawData;
                        if((PESections->SizeOfRawData + NumberOfExpandBytes) % PEHeader32->OptionalHeader.FileAlignment == NULL)
                        {
                            PESections->SizeOfRawData = (((PESections->SizeOfRawData + NumberOfExpandBytes) / PEHeader32->OptionalHeader.FileAlignment)) * PEHeader32->OptionalHeader.FileAlignment;
                        }
                        else
                        {
                            PESections->SizeOfRawData = (((PESections->SizeOfRawData + NumberOfExpandBytes) / PEHeader32->OptionalHeader.FileAlignment) + 1) * PEHeader32->OptionalHeader.FileAlignment;
                        }
                        if(SectionRawSize > 0x7FFFFFFF)
                        {
                            SectionRawSize = NULL;
                        }
                        SectionRawSize = PESections->SizeOfRawData - SectionRawSize - NumberOfExpandBytes;
                        PEHeader32->OptionalHeader.SizeOfImage = PEHeader32->OptionalHeader.SizeOfImage - PESections->Misc.VirtualSize;
                        if((PESections->Misc.VirtualSize + NumberOfExpandBytes + SectionRawSize) % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                        {
                            PESections->Misc.VirtualSize = (((PESections->Misc.VirtualSize + NumberOfExpandBytes + SectionRawSize) / PEHeader32->OptionalHeader.SectionAlignment)) * PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        else
                        {
                            PESections->Misc.VirtualSize = (((PESections->Misc.VirtualSize + NumberOfExpandBytes + SectionRawSize) / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        PEHeader32->OptionalHeader.SizeOfImage = PEHeader32->OptionalHeader.SizeOfImage + PESections->Misc.VirtualSize;
                        if(SectionRawSize > NULL)
                        {
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, SectionRawSize);
                        }
                    }
                    else
                    {
                        PESections->SizeOfRawData = PESections->SizeOfRawData + NumberOfExpandBytes;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        RemoveGarbageItem(szBackupItem, true);
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        return true;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                SectionNumber--;
                PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + SectionNumber * IMAGE_SIZEOF_SECTION_HEADER);
                __try
                {
                    if(AlignResizeData)
                    {
                        SectionRawSize = PESections->SizeOfRawData;
                        if((PESections->SizeOfRawData + NumberOfExpandBytes) % PEHeader64->OptionalHeader.FileAlignment == NULL)
                        {
                            PESections->SizeOfRawData = (((PESections->SizeOfRawData + NumberOfExpandBytes) / PEHeader64->OptionalHeader.FileAlignment)) * PEHeader64->OptionalHeader.FileAlignment;
                        }
                        else
                        {
                            PESections->SizeOfRawData = (((PESections->SizeOfRawData + NumberOfExpandBytes) / PEHeader64->OptionalHeader.FileAlignment) + 1) * PEHeader64->OptionalHeader.FileAlignment;
                        }
                        if(SectionRawSize > 0x7FFFFFFF)
                        {
                            SectionRawSize = NULL;
                        }
                        SectionRawSize = PESections->SizeOfRawData - SectionRawSize - NumberOfExpandBytes;
                        PEHeader64->OptionalHeader.SizeOfImage = PEHeader64->OptionalHeader.SizeOfImage - PESections->Misc.VirtualSize;
                        if((PESections->Misc.VirtualSize + NumberOfExpandBytes) % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                        {
                            PESections->Misc.VirtualSize = (((PESections->Misc.VirtualSize + NumberOfExpandBytes + SectionRawSize) / PEHeader32->OptionalHeader.SectionAlignment)) * PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        else
                        {
                            PESections->Misc.VirtualSize = (((PESections->Misc.VirtualSize + NumberOfExpandBytes + SectionRawSize) / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        PEHeader64->OptionalHeader.SizeOfImage = PEHeader64->OptionalHeader.SizeOfImage + PESections->Misc.VirtualSize;
                        if(SectionRawSize > NULL)
                        {
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, SectionRawSize);
                        }
                    }
                    else
                    {
                        PESections->SizeOfRawData = PESections->SizeOfRawData + NumberOfExpandBytes;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return true;
                        }
                        else
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return false;
                        }
                    }
                    else
                    {
                        return true;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
        }
        else
        {
            FileSize = FileSize - NumberOfExpandBytes;
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return false;
        }
    }
    RemoveGarbageItem(szBackupItem, true);
    return false;
}

__declspec(dllexport) bool TITCALL DeleteLastSection(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(DeleteLastSectionW(uniFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL DeleteLastSectionW(wchar_t* szFileName)
{
    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return false;
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                __try
                {
                    if(SectionNumber > 1)
                    {
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader32->OptionalHeader.SizeOfImage = PEHeader32->OptionalHeader.SizeOfImage - PESections->Misc.VirtualSize;
                        FileSize = PESections->PointerToRawData;
                        RtlZeroMemory(PESections, IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader32->FileHeader.NumberOfSections--;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(szBackupItem[0] != NULL)
                        {
                            if(CopyFileW(szBackupFile, szFileName, false))
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return true;
                            }
                            else
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return false;
                            }
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        RemoveGarbageItem(szBackupItem, true);
                        return false;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                __try
                {
                    if(SectionNumber > 1)
                    {
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + (SectionNumber - 1) * IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader64->OptionalHeader.SizeOfImage = PEHeader64->OptionalHeader.SizeOfImage - PESections->Misc.VirtualSize;
                        FileSize = PESections->PointerToRawData;
                        RtlZeroMemory(PESections, IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader64->FileHeader.NumberOfSections--;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(szBackupItem[0] != NULL)
                        {
                            if(CopyFileW(szBackupFile, szFileName, false))
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return true;
                            }
                            else
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return false;
                            }
                        }
                        else
                        {
                            return true;
                        }
                    }
                    else
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        RemoveGarbageItem(szBackupItem, true);
                        return false;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return false;
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return false;
        }
    }
    RemoveGarbageItem(szBackupItem, true);
    return false;
}

__declspec(dllexport) bool TITCALL DeleteLastSectionEx(char* szFileName, DWORD NumberOfSections)
{
    while(NumberOfSections > 0)
    {
        DeleteLastSection(szFileName);
        NumberOfSections--;
    }
    return true;
}

__declspec(dllexport) bool TITCALL DeleteLastSectionExW(wchar_t* szFileName, DWORD NumberOfSections)
{
    while(NumberOfSections > 0)
    {
        DeleteLastSectionW(szFileName);
        NumberOfSections--;
    }
    return true;
}

__declspec(dllexport) bool TITCALL WipeSection(char* szFileName, int WipeSectionNumber, bool RemovePhysically)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(WipeSectionW(uniFileName, WipeSectionNumber, RemovePhysically));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL WipeSectionW(wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically)
{
    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD NewVirtualSectionSize = 0;
    DWORD NewSectionRawPointer = 0;
    DWORD OldSectionDataRawPtr = 0;
    DWORD OldSectionDataPtr = 0;
    DWORD CurrentSectionPSize = 0;
    DWORD WipeSectionVirSize = 0;
    DWORD WipeSectionSize = 0;
    DWORD SectionDataPtr = 0;
    DWORD FileAlignment = 0;
    int SectionNumber = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            ULONG_PTR WipeRawSize = GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONRAWSIZE);
            if(!WipeRawSize)
                RemovePhysically = false;
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return false;
            }
            if(!FileIs64)
            {
                if(WipeSectionNumber != -1 && WipeSectionNumber <= PEHeader32->FileHeader.NumberOfSections)
                {
                    WipeSectionVirSize = (DWORD)GetPE32DataFromMappedFile(FileMapVA, WipeSectionNumber, UE_SECTIONVIRTUALSIZE);
                    WipeSectionSize = (DWORD)GetPE32DataFromMappedFile(FileMapVA, WipeSectionNumber, UE_SECTIONRAWSIZE);
                    PESections = IMAGE_FIRST_SECTION(PEHeader32);
                    FileAlignment = PEHeader32->OptionalHeader.FileAlignment;
                    __try
                    {
                        while(SectionNumber < PEHeader32->FileHeader.NumberOfSections)
                        {
                            if(SectionNumber == WipeSectionNumber - 1)
                            {
                                CurrentSectionPSize = PESections->SizeOfRawData;
                                if(CurrentSectionPSize % FileAlignment == NULL)
                                {
                                    CurrentSectionPSize = ((CurrentSectionPSize / FileAlignment)) * FileAlignment;
                                }
                                else
                                {
                                    CurrentSectionPSize = ((CurrentSectionPSize / FileAlignment) + 1) * FileAlignment;
                                }
                                PESections->SizeOfRawData = CurrentSectionPSize;
                                WipeSectionVirSize = WipeSectionVirSize + PESections->Misc.VirtualSize;
                                if(WipeSectionVirSize % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                                {
                                    WipeSectionVirSize = ((WipeSectionVirSize / PEHeader32->OptionalHeader.SectionAlignment)) * PEHeader32->OptionalHeader.SectionAlignment;
                                }
                                else
                                {
                                    WipeSectionVirSize = ((WipeSectionVirSize / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment;
                                }
                                PESections->Misc.VirtualSize = WipeSectionVirSize;
                                CurrentSectionPSize = CurrentSectionPSize - PESections->SizeOfRawData;
                                WipeSectionSize = WipeSectionSize - CurrentSectionPSize;
                            }
                            else if(SectionNumber > WipeSectionNumber)
                            {
                                RtlMoveMemory((LPVOID)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER), (LPVOID)PESections, IMAGE_SIZEOF_SECTION_HEADER);
                            }
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            SectionNumber++;
                        }
                        RtlZeroMemory((LPVOID)PESections, IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader32->FileHeader.NumberOfSections--;
                        if(RemovePhysically)
                        {
                            FileSize = RealignPE(FileMapVA, FileSize, NULL);
                        }
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(szBackupItem[0] != NULL)
                        {
                            if(CopyFileW(szBackupFile, szFileName, false))
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return true;
                            }
                            else
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return false;
                            }
                        }
                        else
                        {
                            return true;
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        RemoveGarbageItem(szBackupItem, true);
                        return false;
                    }
                }
            }
            else
            {
                if(WipeSectionNumber != -1 && WipeSectionNumber <= PEHeader64->FileHeader.NumberOfSections)
                {
                    WipeSectionVirSize = (DWORD)GetPE32DataFromMappedFile(FileMapVA, WipeSectionNumber, UE_SECTIONVIRTUALOFFSET);
                    WipeSectionVirSize = WipeSectionVirSize + (DWORD)GetPE32DataFromMappedFile(FileMapVA, WipeSectionNumber, UE_SECTIONVIRTUALSIZE);
                    if(WipeSectionVirSize % PEHeader32->OptionalHeader.SectionAlignment == NULL)
                    {
                        WipeSectionVirSize = ((WipeSectionVirSize / PEHeader32->OptionalHeader.SectionAlignment)) * PEHeader32->OptionalHeader.SectionAlignment;
                    }
                    else
                    {
                        WipeSectionVirSize = ((WipeSectionVirSize / PEHeader32->OptionalHeader.SectionAlignment) + 1) * PEHeader32->OptionalHeader.SectionAlignment;
                    }
                    WipeSectionSize = (DWORD)GetPE32DataFromMappedFile(FileMapVA, WipeSectionNumber, UE_SECTIONRAWSIZE);
                    PESections = IMAGE_FIRST_SECTION(PEHeader64);
                    FileAlignment = PEHeader64->OptionalHeader.FileAlignment;
                    __try
                    {
                        while(SectionNumber < PEHeader64->FileHeader.NumberOfSections)
                        {
                            if(SectionNumber == WipeSectionNumber - 1)
                            {
                                CurrentSectionPSize = PESections->SizeOfRawData;
                                if(CurrentSectionPSize % FileAlignment == NULL)
                                {
                                    CurrentSectionPSize = ((CurrentSectionPSize / FileAlignment)) * FileAlignment;
                                }
                                else
                                {
                                    CurrentSectionPSize = ((CurrentSectionPSize / FileAlignment) + 1) * FileAlignment;
                                }
                                PESections->SizeOfRawData = CurrentSectionPSize;
                                WipeSectionVirSize = WipeSectionVirSize + PESections->Misc.VirtualSize;
                                if(WipeSectionVirSize % PEHeader64->OptionalHeader.SectionAlignment == NULL)
                                {
                                    WipeSectionVirSize = ((WipeSectionVirSize / PEHeader64->OptionalHeader.SectionAlignment)) * PEHeader64->OptionalHeader.SectionAlignment;
                                }
                                else
                                {
                                    WipeSectionVirSize = ((WipeSectionVirSize / PEHeader64->OptionalHeader.SectionAlignment) + 1) * PEHeader64->OptionalHeader.SectionAlignment;
                                }
                                PESections->Misc.VirtualSize = WipeSectionVirSize;
                                CurrentSectionPSize = CurrentSectionPSize - PESections->SizeOfRawData;
                                WipeSectionSize = WipeSectionSize - CurrentSectionPSize;
                            }
                            else if(SectionNumber > WipeSectionNumber)
                            {
                                RtlMoveMemory((LPVOID)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER), (LPVOID)PESections, IMAGE_SIZEOF_SECTION_HEADER);
                            }
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            SectionNumber++;
                        }
                        RtlZeroMemory((LPVOID)PESections, IMAGE_SIZEOF_SECTION_HEADER);
                        PEHeader64->FileHeader.NumberOfSections--;
                        if(RemovePhysically)
                        {
                            FileSize = RealignPE(FileMapVA, FileSize, NULL);
                        }
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        if(szBackupItem[0] != NULL)
                        {
                            if(CopyFileW(szBackupFile, szFileName, false))
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return true;
                            }
                            else
                            {
                                RemoveGarbageItem(szBackupItem, true);
                                return false;
                            }
                        }
                        else
                        {
                            return true;
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        RemoveGarbageItem(szBackupItem, true);
                        return false;
                    }
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return false;
        }
    }
    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    RemoveGarbageItem(szBackupItem, true);
    return false;
}



================================================
File: TitanEngine/TitanEngine.PE.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Handle.h"
#include "Global.Engine.h"

__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, char* szDebuggedFileName)
{

    wchar_t uniDebuggedFileName[MAX_PATH] = {};

    if(szDebuggedFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDebuggedFileName, lstrlenA(szDebuggedFileName) + 1, uniDebuggedFileName, sizeof(uniDebuggedFileName) / (sizeof(uniDebuggedFileName[0])));
        return(PastePEHeaderW(hProcess, ImageBase, uniDebuggedFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, wchar_t* szDebuggedFileName)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    IMAGE_NT_HEADERS32 RemotePEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    IMAGE_NT_HEADERS64 RemotePEHeader64;
    ULONG_PTR ueNumberOfBytesRead = 0;
    DWORD uedNumberOfBytesRead = 0;
    DWORD FileSize = 0;
    DWORD PEHeaderSize = 0;
    ULONG_PTR dwImageBase = (ULONG_PTR)ImageBase;
    BOOL FileIs64 = false;
    HANDLE hFile = 0;
    SIZE_T CalculatedHeaderSize = NULL;
    DynBuf ueReadBuf;
    LPVOID ueReadBuffer = ueReadBuf.Allocate(0x2000);
    DWORD OldProtect = PAGE_READWRITE;

    hFile = CreateFileW(szDebuggedFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        FileSize = GetFileSize(hFile, NULL);
        if(FileSize < 0x1000)
        {
            if(!ReadFile(hFile, ueReadBuffer, FileSize, &uedNumberOfBytesRead, NULL))
                return false;
        }
        else
        {
            if(!ReadFile(hFile, ueReadBuffer, 0x1000, &uedNumberOfBytesRead, NULL))
                return false;
        }
        if(FileSize > 0x200)
        {
            DOSHeader = (PIMAGE_DOS_HEADER)ueReadBuffer;
            if(EngineValidateHeader((ULONG_PTR)ueReadBuffer, hProcess, ImageBase, DOSHeader, false))
            {
                PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                CalculatedHeaderSize = DOSHeader->e_lfanew + sizeof IMAGE_DOS_HEADER + sizeof IMAGE_NT_HEADERS64;
                if(CalculatedHeaderSize > 0x1000)
                {
                    SetFilePointer(hFile, NULL, NULL, FILE_BEGIN);
                    ueReadBuffer = ueReadBuf.Allocate(CalculatedHeaderSize);
                    if(!ReadFile(hFile, ueReadBuffer, (DWORD)CalculatedHeaderSize, &uedNumberOfBytesRead, NULL))
                    {
                        EngineCloseHandle(hFile);
                        return false;
                    }
                }
                if(PEHeader32->OptionalHeader.Magic == 0x10B)
                {
                    if(ReadProcessMemory(hProcess, (LPVOID)((ULONG_PTR)ImageBase + DOSHeader->e_lfanew), &RemotePEHeader32, sizeof IMAGE_NT_HEADERS32, &ueNumberOfBytesRead))
                    {
                        PEHeaderSize = PEHeader32->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER + PEHeader32->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER) + 4;
                        FileIs64 = false;
                    }
                }
                else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                {
                    if(ReadProcessMemory(hProcess, (LPVOID)((ULONG_PTR)ImageBase + DOSHeader->e_lfanew), &RemotePEHeader64, sizeof IMAGE_NT_HEADERS32, &ueNumberOfBytesRead))
                    {
                        PEHeaderSize = PEHeader64->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER + PEHeader64->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER) + 4;
                        FileIs64 = true;
                    }
                }
                else
                {
                    EngineCloseHandle(hFile);
                    return false;
                }
                if(!FileIs64)
                {
                    PEHeader32->OptionalHeader.ImageBase = (DWORD)(dwImageBase);
                    if(VirtualProtectEx(hProcess, ImageBase, PEHeaderSize, PAGE_READWRITE, &OldProtect))
                    {
                        if(WriteProcessMemory(hProcess, ImageBase, ueReadBuffer, PEHeaderSize, &ueNumberOfBytesRead))
                        {
                            EngineCloseHandle(hFile);
                            VirtualProtectEx(hProcess, ImageBase, PEHeaderSize, OldProtect, &OldProtect);
                            return true;
                        }
                        else
                        {
                            EngineCloseHandle(hFile);
                            return false;
                        }
                    }
                    else
                    {
                        EngineCloseHandle(hFile);
                        return false;
                    }
                }
                else
                {
                    PEHeader64->OptionalHeader.ImageBase = dwImageBase;
                    if(VirtualProtectEx(hProcess, ImageBase, PEHeaderSize, PAGE_READWRITE, &OldProtect))
                    {
                        if(WriteProcessMemory(hProcess, ImageBase, ueReadBuffer, PEHeaderSize, &ueNumberOfBytesRead))
                        {
                            EngineCloseHandle(hFile);
                            VirtualProtectEx(hProcess, ImageBase, PEHeaderSize, OldProtect, &OldProtect);
                            return true;
                        }
                        else
                        {
                            EngineCloseHandle(hFile);
                            return false;
                        }
                    }
                    else
                    {
                        EngineCloseHandle(hFile);
                        return false;
                    }
                }
            }
            else
            {
                EngineCloseHandle(hFile);
                return false;
            }
        }
        else
        {
            EngineCloseHandle(hFile);
            return false;
        }
    }
    else
    {
        EngineCloseHandle(hFile);
        return false;
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.Process.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Handle.h"
#include "Global.Engine.h"

// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(char* szImageName)
{
    wchar_t uniImageName[MAX_PATH] = {0};

    if(szImageName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szImageName, -1, uniImageName, _countof(uniImageName));
        return(GetActiveProcessIdW(uniImageName));
    }
    else
    {
        return(NULL);
    }
}

__declspec(dllexport) long TITCALL GetActiveProcessIdW(wchar_t* szImageName)
{

    int i;
    wchar_t* szTranslatedProcName;
    DWORD bProcessId[1024] = {};
    wchar_t szProcessPath[1024] = {};
    DWORD cbNeeded = NULL;
    HANDLE hProcess;
    wchar_t* nameOnly = 0;

    if(EnumProcesses(bProcessId, sizeof(bProcessId), &cbNeeded))
    {
        for(i = 0; i < (int)(cbNeeded / sizeof(DWORD)); i++)
        {
            if(bProcessId[i] != NULL)
            {
                hProcess = EngineOpenProcess(PROCESS_QUERY_INFORMATION, false, bProcessId[i]);
                if(hProcess != NULL)
                {
                    if(GetProcessImageFileNameW(hProcess, szProcessPath, _countof(szProcessPath)) > NULL)
                    {
                        szTranslatedProcName = (wchar_t*)TranslateNativeNameW(szProcessPath);
                        lstrcpyW(szProcessPath, szTranslatedProcName);
                        VirtualFree((void*)szTranslatedProcName, NULL, MEM_RELEASE);
                        EngineCloseHandle(hProcess);

                        if(_wcsicmp(szProcessPath, szImageName) == 0)
                        {
                            return(bProcessId[i]);
                        }
                        else
                        {
                            nameOnly = wcsrchr(szProcessPath, L'\\');
                            if(nameOnly)
                            {
                                nameOnly++;
                                if(_wcsicmp(nameOnly, szImageName) == 0)
                                {
                                    return(bProcessId[i]);
                                }
                            }
                        }
                    }
                    else
                    {
                        EngineCloseHandle(hProcess);
                    }
                }
            }
        }
    }
    return(NULL);
}

__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(char* szLibraryName, void* EnumFunction)
{

    int i;
    int j;
    typedef void(TITCALL * fEnumFunction)(DWORD ProcessId, HMODULE ModuleBaseAddress);
    fEnumFunction myEnumFunction = (fEnumFunction)EnumFunction;
    HMODULE EnumeratedModules[1024] = {0};
    DWORD bProcessId[1024] = {0};
    char szModuleName[1024] = {0};
    DWORD pProcessIdCount = NULL;
    DWORD cbNeeded = 0;
    HANDLE hProcess;

    if(EnumFunction != NULL)
    {
        if(EnumProcesses(bProcessId, sizeof(bProcessId), &pProcessIdCount))
        {
            for(i = 0; i < (int)(pProcessIdCount / sizeof(DWORD)); i++)
            {
                if(bProcessId[i] != NULL)
                {
                    hProcess = EngineOpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 0, bProcessId[i]);
                    if(hProcess != NULL)
                    {
                        RtlZeroMemory(EnumeratedModules, sizeof(EnumeratedModules));
                        if(EnumProcessModules(hProcess, (HMODULE*)EnumeratedModules, sizeof(EnumeratedModules), &cbNeeded))
                        {
                            for(j = 0; j < (int)(cbNeeded / sizeof(HMODULE)); j++)
                            {
                                if(EnumeratedModules[j] != NULL)
                                {
                                    if(GetModuleBaseNameA(hProcess, EnumeratedModules[j], szModuleName, _countof(szModuleName)) > NULL)
                                    {
                                        if(lstrcmpiA(szModuleName, szLibraryName) == NULL)
                                        {
                                            __try
                                            {
                                                myEnumFunction(bProcessId[i], EnumeratedModules[j]);
                                            }
                                            __except(EXCEPTION_EXECUTE_HANDLER)
                                            {
                                                EngineCloseHandle(hProcess);
                                                return;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        EngineCloseHandle(hProcess);
                    }
                }
            }
        }
    }
}

__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId)
{
    return EngineOpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
}

__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId)
{
    return EngineOpenThread(dwDesiredAccess, bInheritHandle, dwThreadId);
}


================================================
File: TitanEngine/TitanEngine.Realigner.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Mapping.h"
#include "Global.Garbage.h"

// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {0};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, -1, uniFileName, _countof(uniFileName));
        return FixHeaderCheckSumW(uniFileName);
    }
    else
    {
        return 0;
    }
}

__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(wchar_t* szFileName)
{
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    bool retVal = false;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, 0))
    {
        DWORD HeaderSum;
        DWORD CheckSum;
        if(CheckSumMappedFile((PVOID)FileMapVA, FileSize, &HeaderSum, &CheckSum))
        {
            retVal = SetPE32DataW(szFileName, NULL, UE_CHECKSUM, (ULONG_PTR)CheckSum);
        }
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    }
    return retVal;
}

__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD NewVirtualSectionSize = 0;
    DWORD NewSectionRawPointer = 0;
    DWORD OldSectionDataRawPtr = 0;
    DWORD OldSectionDataPtr = 0;
    DWORD SectionDataPtr = 0;
    DWORD SectionNumber = 0;
    DWORD CurrentSection = 0;
    DWORD FileAlignment = 0;
    BOOL FileIs64;

    if(FileMapVA != NULL)
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return(-1);
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                FileAlignment = PEHeader32->OptionalHeader.FileAlignment;
                if(FileAlignment == 0x1000)
                {
                    FileAlignment = 0x200;
                }
                __try
                {
                    PEHeader32->OptionalHeader.FileAlignment = FileAlignment;
                    while(SectionNumber > 0)
                    {
                        SectionDataPtr = PESections->PointerToRawData + PESections->SizeOfRawData;
                        if(PESections->SizeOfRawData > NULL)
                        {
                            SectionDataPtr--;
                            while(*(PUCHAR)(FileMapVA + SectionDataPtr) == 0x00 && SectionDataPtr > PESections->PointerToRawData)
                            {
                                SectionDataPtr--;
                            }
                        }
                        SectionDataPtr = SectionDataPtr - PESections->PointerToRawData;
                        OldSectionDataPtr = SectionDataPtr;
                        SectionDataPtr = (SectionDataPtr / FileAlignment) * FileAlignment;
                        if(SectionDataPtr < OldSectionDataPtr)
                        {
                            SectionDataPtr = SectionDataPtr + FileAlignment;
                        }
                        if(CurrentSection == NULL)
                        {
                            PEHeader32->OptionalHeader.SizeOfHeaders = PESections->PointerToRawData;
                            PEHeader32->OptionalHeader.SectionAlignment = PESections->VirtualAddress;
                            PESections->SizeOfRawData = SectionDataPtr;
                        }
                        else
                        {
                            OldSectionDataRawPtr = PESections->PointerToRawData;
                            PESections->SizeOfRawData = SectionDataPtr;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                            NewSectionRawPointer = PESections->PointerToRawData + PESections->SizeOfRawData;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            PESections->PointerToRawData = NewSectionRawPointer;
                            RtlMoveMemory((LPVOID)((ULONG_PTR)FileMapVA + NewSectionRawPointer), (LPVOID)((ULONG_PTR)FileMapVA + OldSectionDataRawPtr), SectionDataPtr);
                        }
                        NewVirtualSectionSize = (PESections->Misc.VirtualSize / PEHeader32->OptionalHeader.SectionAlignment) * PEHeader32->OptionalHeader.SectionAlignment;
                        if(NewVirtualSectionSize < PESections->Misc.VirtualSize)
                        {
                            NewVirtualSectionSize = NewVirtualSectionSize + PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        PESections->Misc.VirtualSize = NewVirtualSectionSize;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        CurrentSection++;
                        SectionNumber--;
                    }
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                    return(PESections->PointerToRawData + PESections->SizeOfRawData);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(-1);
                }
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                FileAlignment = PEHeader64->OptionalHeader.FileAlignment;
                if(FileAlignment == 0x1000)
                {
                    FileAlignment = 0x200;
                }
                __try
                {
                    PEHeader64->OptionalHeader.FileAlignment = FileAlignment;
                    while(SectionNumber > 0)
                    {
                        SectionDataPtr = PESections->PointerToRawData + PESections->SizeOfRawData;
                        if(PESections->SizeOfRawData > NULL)
                        {
                            SectionDataPtr--;
                            while(*(PUCHAR)(FileMapVA + SectionDataPtr) == 0x00 && SectionDataPtr > PESections->PointerToRawData)
                            {
                                SectionDataPtr--;
                            }
                        }
                        SectionDataPtr = SectionDataPtr - PESections->PointerToRawData;
                        OldSectionDataPtr = SectionDataPtr;
                        SectionDataPtr = (SectionDataPtr / FileAlignment) * FileAlignment;
                        if(SectionDataPtr < OldSectionDataPtr)
                        {
                            SectionDataPtr = SectionDataPtr + FileAlignment;
                        }
                        if(CurrentSection == NULL)
                        {
                            PEHeader64->OptionalHeader.SizeOfHeaders = PESections->PointerToRawData;
                            PEHeader64->OptionalHeader.SectionAlignment = PESections->VirtualAddress;
                            PESections->SizeOfRawData = SectionDataPtr;
                        }
                        else
                        {
                            OldSectionDataRawPtr = PESections->PointerToRawData;
                            PESections->SizeOfRawData = SectionDataPtr;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                            NewSectionRawPointer = PESections->PointerToRawData + PESections->SizeOfRawData;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            PESections->PointerToRawData = NewSectionRawPointer;
                            RtlMoveMemory((LPVOID)((ULONG_PTR)FileMapVA + NewSectionRawPointer), (LPVOID)((ULONG_PTR)FileMapVA + OldSectionDataRawPtr), SectionDataPtr);
                        }
                        NewVirtualSectionSize = (PESections->Misc.VirtualSize / PEHeader64->OptionalHeader.SectionAlignment) * PEHeader64->OptionalHeader.SectionAlignment;
                        if(NewVirtualSectionSize < PESections->Misc.VirtualSize)
                        {
                            NewVirtualSectionSize = NewVirtualSectionSize + PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        PESections->Misc.VirtualSize = NewVirtualSectionSize;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        CurrentSection++;
                        SectionNumber--;
                    }
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                    return(PESections->PointerToRawData + PESections->SizeOfRawData);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return(-1);
                }
            }
        }
        else
        {
            return(-1);
        }
    }
    return(-1);
}
__declspec(dllexport) long TITCALL RealignPEEx(char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(RealignPEExW(uniFileName, RealingFileSize, ForcedFileAlignment));
    }
    else
    {
        return(-1);
    }
}
__declspec(dllexport) long TITCALL RealignPEExW(wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment)
{

    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD NewVirtualSectionSize = 0;
    DWORD NewSectionRawPointer = 0;
    DWORD OldSectionDataRawPtr = 0;
    DWORD OldSectionDataPtr = 0;
    DWORD SectionDataPtr = 0;
    DWORD SectionNumber = 0;
    DWORD CurrentSection = 0;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return(-1);
            }
            if(!FileIs64)
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader32);
                SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                if(ForcedFileAlignment == 0x0)
                {
                    ForcedFileAlignment = 0x200;
                }
                __try
                {
                    PEHeader32->OptionalHeader.FileAlignment = ForcedFileAlignment;
                    while(SectionNumber > 0)
                    {
                        SectionDataPtr = PESections->PointerToRawData + PESections->SizeOfRawData;
                        if(PESections->SizeOfRawData > NULL)
                        {
                            SectionDataPtr--;
                            while(*(PUCHAR)(FileMapVA + SectionDataPtr) == 0x00 && SectionDataPtr > PESections->PointerToRawData)
                            {
                                SectionDataPtr--;
                            }
                        }
                        SectionDataPtr = SectionDataPtr - PESections->PointerToRawData;
                        OldSectionDataPtr = SectionDataPtr;
                        SectionDataPtr = (SectionDataPtr / ForcedFileAlignment) * ForcedFileAlignment;
                        if(SectionDataPtr < OldSectionDataPtr)
                        {
                            SectionDataPtr = SectionDataPtr + ForcedFileAlignment;
                        }
                        if(CurrentSection == NULL)
                        {
                            PEHeader32->OptionalHeader.SizeOfHeaders = PESections->PointerToRawData;
                            PEHeader32->OptionalHeader.SectionAlignment = PESections->VirtualAddress;
                            PESections->SizeOfRawData = SectionDataPtr;
                        }
                        else
                        {
                            OldSectionDataRawPtr = PESections->PointerToRawData;
                            PESections->SizeOfRawData = SectionDataPtr;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                            NewSectionRawPointer = PESections->PointerToRawData + PESections->SizeOfRawData;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            PESections->PointerToRawData = NewSectionRawPointer;
                            RtlMoveMemory((LPVOID)((ULONG_PTR)FileMapVA + NewSectionRawPointer), (LPVOID)((ULONG_PTR)FileMapVA + OldSectionDataRawPtr), SectionDataPtr);
                        }
                        NewVirtualSectionSize = (PESections->Misc.VirtualSize / PEHeader32->OptionalHeader.SectionAlignment) * PEHeader32->OptionalHeader.SectionAlignment;
                        if(NewVirtualSectionSize < PESections->Misc.VirtualSize)
                        {
                            NewVirtualSectionSize = NewVirtualSectionSize + PEHeader32->OptionalHeader.SectionAlignment;
                        }
                        PESections->Misc.VirtualSize = NewVirtualSectionSize;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        CurrentSection++;
                        SectionNumber--;
                    }
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                    if(RealingFileSize == NULL)
                    {
                        FileSize = PESections->PointerToRawData + PESections->SizeOfRawData;
                    }
                    else
                    {
                        FileSize = RealingFileSize;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return(FileSize);
                        }
                        else
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return(-1);
                        }
                    }
                    else
                    {
                        return(FileSize);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return(-1);
                }
            }
            else
            {
                PESections = IMAGE_FIRST_SECTION(PEHeader64);
                SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                if(ForcedFileAlignment == 0x0)
                {
                    ForcedFileAlignment = 0x200;
                }
                __try
                {
                    PEHeader64->OptionalHeader.FileAlignment = ForcedFileAlignment;
                    while(SectionNumber > 0)
                    {
                        SectionDataPtr = PESections->PointerToRawData + PESections->SizeOfRawData;
                        if(PESections->SizeOfRawData > NULL)
                        {
                            SectionDataPtr--;
                            while(*(PUCHAR)(FileMapVA + SectionDataPtr) == 0x00 && SectionDataPtr > PESections->PointerToRawData)
                            {
                                SectionDataPtr--;
                            }
                        }
                        SectionDataPtr = SectionDataPtr - PESections->PointerToRawData;
                        OldSectionDataPtr = SectionDataPtr;
                        SectionDataPtr = (SectionDataPtr / ForcedFileAlignment) * ForcedFileAlignment;
                        if(SectionDataPtr < OldSectionDataPtr)
                        {
                            SectionDataPtr = SectionDataPtr + ForcedFileAlignment;
                        }
                        if(CurrentSection == NULL)
                        {
                            PEHeader64->OptionalHeader.SizeOfHeaders = PESections->PointerToRawData;
                            PEHeader64->OptionalHeader.SectionAlignment = PESections->VirtualAddress;
                            PESections->SizeOfRawData = SectionDataPtr;
                        }
                        else
                        {
                            OldSectionDataRawPtr = PESections->PointerToRawData;
                            PESections->SizeOfRawData = SectionDataPtr;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                            NewSectionRawPointer = PESections->PointerToRawData + PESections->SizeOfRawData;
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            PESections->PointerToRawData = NewSectionRawPointer;
                            RtlMoveMemory((LPVOID)((ULONG_PTR)FileMapVA + NewSectionRawPointer), (LPVOID)((ULONG_PTR)FileMapVA + OldSectionDataRawPtr), SectionDataPtr);
                        }
                        NewVirtualSectionSize = (PESections->Misc.VirtualSize / PEHeader64->OptionalHeader.SectionAlignment) * PEHeader64->OptionalHeader.SectionAlignment;
                        if(NewVirtualSectionSize < PESections->Misc.VirtualSize)
                        {
                            NewVirtualSectionSize = NewVirtualSectionSize + PEHeader64->OptionalHeader.SectionAlignment;
                        }
                        PESections->Misc.VirtualSize = NewVirtualSectionSize;
                        PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                        CurrentSection++;
                        SectionNumber--;
                    }
                    PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections - IMAGE_SIZEOF_SECTION_HEADER);
                    if(RealingFileSize == NULL)
                    {
                        FileSize = PESections->PointerToRawData + PESections->SizeOfRawData;
                    }
                    else
                    {
                        FileSize = RealingFileSize;
                    }
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    if(szBackupItem[0] != NULL)
                    {
                        if(CopyFileW(szBackupFile, szFileName, false))
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return(FileSize);
                        }
                        else
                        {
                            RemoveGarbageItem(szBackupItem, true);
                            return(-1);
                        }
                    }
                    else
                    {
                        return(FileSize);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return(-1);
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return(-1);
        }
    }
    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    RemoveGarbageItem(szBackupItem, true);
    return(-1);
}



================================================
File: TitanEngine/TitanEngine.Relocator.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Mapping.h"
#include "Global.Engine.h"
#include "Global.Garbage.h"

static LPVOID RelocationData = NULL;
LPVOID RelocationLastPage = NULL;
LPVOID RelocationStartPosition = NULL;
LPVOID RelocationWritePosition = NULL;
ULONG_PTR RelocationOldImageBase;
ULONG_PTR RelocationNewImageBase;

// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup()
{

    if(RelocationData != NULL)
    {
        VirtualFree(RelocationData, NULL, MEM_RELEASE);
        RelocationLastPage = NULL;
        RelocationStartPosition = NULL;
        RelocationWritePosition = NULL;
        RelocationOldImageBase = NULL;
        RelocationNewImageBase = NULL;
    }
}

__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase)
{

    if(RelocationData != NULL)
    {
        VirtualFree(RelocationData, NULL, MEM_RELEASE);
    }
    RelocationData = VirtualAlloc(NULL, MemorySize, MEM_COMMIT, PAGE_READWRITE);
    RelocationLastPage = NULL;
    RelocationStartPosition = RelocationData;
    RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationData + 8);
    RelocationOldImageBase = OldImageBase;
    RelocationNewImageBase = NewImageBase;
}

__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState)
{

    MEMORY_BASIC_INFORMATION MemInfo;
    DWORD CompareDummy = NULL;
    DWORD CopyDummy = NULL;

    VirtualQueryEx(hProcess, (LPVOID)RelocateAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
    if(MemInfo.BaseAddress != RelocationLastPage || RelocationLastPage == NULL)
    {
        RelocationLastPage = MemInfo.BaseAddress;
        if(memcmp(RelocationStartPosition, &CompareDummy, 4) == NULL)
        {
            CopyDummy = (DWORD)((ULONG_PTR)MemInfo.BaseAddress - (ULONG_PTR)RelocationNewImageBase);
            RtlMoveMemory(RelocationStartPosition, &CopyDummy, 4);
        }
        else
        {
            CopyDummy = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationStartPosition);
            if(CopyDummy % 4 == NULL)
            {
                RtlMoveMemory((LPVOID)((ULONG_PTR)RelocationStartPosition + 4), &CopyDummy, 4);
            }
            else
            {
                RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationWritePosition + 2);
                CopyDummy = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationStartPosition);
                if(CopyDummy % 4 == NULL)
                {
                    RtlMoveMemory((LPVOID)((ULONG_PTR)RelocationStartPosition + 4), &CopyDummy, 4);
                }
                else
                {
                    RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationWritePosition + 2);
                    CopyDummy = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationStartPosition);
                    RtlMoveMemory((LPVOID)((ULONG_PTR)RelocationStartPosition + 4), &CopyDummy, 4);
                }
            }
            RelocationStartPosition = RelocationWritePosition;
            CopyDummy = (DWORD)((ULONG_PTR)RelocationLastPage - (ULONG_PTR)RelocationNewImageBase);
            RtlMoveMemory(RelocationWritePosition, &CopyDummy, 4);
            RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationWritePosition + 8);
        }
    }
#if !defined(_WIN64)
    CopyDummy = (DWORD)((RelocateAddress - (ULONG_PTR)RelocationLastPage) ^ 0x3000);
#else
    CopyDummy = (DWORD)((RelocateAddress - (ULONG_PTR)RelocationLastPage) ^ 0x8000);
#endif
    RtlMoveMemory(RelocationWritePosition, &CopyDummy, 2);
    RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationWritePosition + 2);
}

__declspec(dllexport) long TITCALL RelocaterEstimatedSize()
{
    return((DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationData + 8));
}

__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    BOOL FileIs64 = false;
    DWORD CopyDummy = NULL;

    __try
    {
        if((ULONG_PTR)RelocationStartPosition != -1)
        {
            CopyDummy = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationStartPosition);
            if(CopyDummy % 4 == NULL)
            {
                RtlMoveMemory((LPVOID)((ULONG_PTR)RelocationStartPosition + 4), &CopyDummy, 4);
            }
            else
            {
                RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationWritePosition + 2);
                CopyDummy = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationStartPosition);
                if(CopyDummy % 4 == NULL)
                {
                    RtlMoveMemory((LPVOID)((ULONG_PTR)RelocationStartPosition + 4), &CopyDummy, 4);
                }
                else
                {
                    RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationWritePosition + 2);
                    CopyDummy = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationStartPosition);
                    RtlMoveMemory((LPVOID)((ULONG_PTR)RelocationStartPosition + 4), &CopyDummy, 4);
                }
            }
        }
        RtlMoveMemory((LPVOID)StorePlace, RelocationData, (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationData));
        VirtualFree(RelocationData, NULL, MEM_RELEASE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return false;
    }

    DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
    if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
    {
        PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        if(PEHeader32->OptionalHeader.Magic == 0x10B)
        {
            FileIs64 = false;
        }
        else if(PEHeader32->OptionalHeader.Magic == 0x20B)
        {
            FileIs64 = true;
        }
        else
        {
            RelocationData = NULL;
            return false;
        }
        if(!FileIs64)
        {
            PEHeader32->OptionalHeader.ImageBase = (DWORD)RelocationNewImageBase;
            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = StorePlaceRVA;
            PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationData);
        }
        else
        {
            PEHeader64->OptionalHeader.ImageBase = (ULONG_PTR)RelocationNewImageBase;
            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = StorePlaceRVA;
            PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = (DWORD)((ULONG_PTR)RelocationWritePosition - (ULONG_PTR)RelocationData);
        }
        RelocationData = NULL;
        return true;
    }
    RelocationData = NULL;
    return false;
}

__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(char* szFileName, char* szSectionName)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(RelocaterExportRelocationExW(uniFileName, szSectionName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(wchar_t* szFileName, char* szSectionName)
{

    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    DWORD NewSectionVO = NULL;
    DWORD NewSectionFO = NULL;
    bool ReturnValue = false;

    if(RelocaterEstimatedSize() > NULL)
    {
        NewSectionVO = AddNewSectionW(szFileName, szSectionName, RelocaterEstimatedSize());
        if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
        {
            NewSectionFO = (DWORD)ConvertVAtoFileOffset(FileMapVA, NewSectionVO + (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMAGEBASE), true);
            if(NewSectionFO)
                ReturnValue = RelocaterExportRelocation(NewSectionFO, NewSectionVO, FileMapVA);
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            if(ReturnValue)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize)
{

    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR ueNumberOfBytesRead = NULL;
    DWORD OldProtect;

    if(RelocationData != NULL)
    {
        VirtualQueryEx(hProcess, (LPVOID)MemoryStart, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        OldProtect = MemInfo.Protect;
        VirtualProtectEx(hProcess, (LPVOID)MemoryStart, MemorySize, PAGE_EXECUTE_READWRITE, &OldProtect);
        if(ReadProcessMemory(hProcess, (LPVOID)MemoryStart, RelocationData, MemorySize, &ueNumberOfBytesRead))
        {
            RelocationWritePosition = (LPVOID)((ULONG_PTR)RelocationData + MemorySize);
            RelocationStartPosition = (LPVOID)(-1);
            return true;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage)
{

    MEMORY_BASIC_INFORMATION MemInfo;
    LPVOID ReadMemoryStorage = NULL;
    LPVOID mReadMemoryStorage = NULL;
    ULONG_PTR ueNumberOfBytesRead = NULL;
    DWORD CompareDummy = NULL;
    DWORD RelocationBase = NULL;
    DWORD RelocationSize = NULL;
    DWORD OldProtect;
    DynBuf mem;

    if(RelocationData != NULL)
    {
        VirtualQueryEx(hProcess, (LPVOID)MemoryStart, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        OldProtect = MemInfo.Protect;
        VirtualQueryEx(hProcess, (LPVOID)MemInfo.BaseAddress, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
        if(MemInfo.RegionSize < MemorySize || MemorySize == NULL)
        {
            MemorySize = MemInfo.RegionSize;
        }
        VirtualProtectEx(hProcess, (LPVOID)MemoryStart, MemorySize, PAGE_EXECUTE_READWRITE, &OldProtect);
        ReadMemoryStorage = mem.Allocate(MemorySize);
        mReadMemoryStorage = ReadMemoryStorage;
        if(ReadProcessMemory(hProcess, (LPVOID)MemoryStart, ReadMemoryStorage, MemorySize, &ueNumberOfBytesRead))
        {
            RtlMoveMemory(&RelocationBase, ReadMemoryStorage, 4);
            RtlMoveMemory(&RelocationSize, (LPVOID)((ULONG_PTR)ReadMemoryStorage + 4), 4);
            while(memcmp(ReadMemoryStorage, &CompareDummy, 4) != NULL && RelocationBase < NtSizeOfImage && RelocationSize < 0x2000)
            {
                ReadMemoryStorage = (LPVOID)((ULONG_PTR)ReadMemoryStorage + RelocationSize);
                RtlMoveMemory(&RelocationBase, ReadMemoryStorage, 4);
                RtlMoveMemory(&RelocationSize, (LPVOID)((ULONG_PTR)ReadMemoryStorage + 4), 4);
            }
            return(RelocaterGrabRelocationTable(hProcess, MemoryStart, (DWORD)((ULONG_PTR)ReadMemoryStorage - (ULONG_PTR)mReadMemoryStorage)));
        }
        else
        {
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize)
{
    return(DumpMemory(hProcess, MemoryStart, MemorySize, szSaveFileName));
}

__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize)
{
    return(DumpMemoryW(hProcess, MemoryStart, MemorySize, szSaveFileName));
}

__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, char* szDumpFile1, char* szDumpFile2, ULONG_PTR MemStart)
{

    wchar_t uniDumpFile1[MAX_PATH] = {};
    wchar_t uniDumpFile2[MAX_PATH] = {};

    if(szDumpFile1 != NULL && szDumpFile2 != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFile1, lstrlenA(szDumpFile1) + 1, uniDumpFile1, sizeof(uniDumpFile1) / (sizeof(uniDumpFile1[0])));
        MultiByteToWideChar(CP_ACP, NULL, szDumpFile2, lstrlenA(szDumpFile2) + 1, uniDumpFile2, sizeof(uniDumpFile2) / (sizeof(uniDumpFile2[0])));
        return(RelocaterCompareTwoSnapshotsW(hProcess, LoadedImageBase, NtSizeOfImage, uniDumpFile1, uniDumpFile2, MemStart));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, wchar_t* szDumpFile1, wchar_t* szDumpFile2, ULONG_PTR MemStart)
{

    int i = NULL;
    ULONG_PTR DeltaByte = NULL;
    int RelativeBase = NULL;
    ULONG_PTR ReadData = NULL;
    HANDLE FileHandle1;
    DWORD FileSize1;
    HANDLE FileMap1;
    ULONG_PTR FileMapVA1;
    HANDLE FileHandle2;
    DWORD FileSize2;
    HANDLE FileMap2;
    ULONG_PTR FileMapVA2;
    DWORD SearchSize;
    LPVOID Search1;
    LPVOID Search2;
    DWORD bkSearchSize;
    LPVOID bkSearch1;
    LPVOID bkSearch2;

    if(MapFileExW(szDumpFile1, UE_ACCESS_READ, &FileHandle1, &FileSize1, &FileMap1, &FileMapVA1, NULL))
    {
        if(MapFileExW(szDumpFile2, UE_ACCESS_READ, &FileHandle2, &FileSize2, &FileMap2, &FileMapVA2, NULL))
        {
            if(RelocationOldImageBase != NULL && RelocationNewImageBase != NULL && RelocationOldImageBase != RelocationNewImageBase)
            {
                __try
                {
                    if(RelocationOldImageBase > RelocationNewImageBase)
                    {
                        DeltaByte = (ULONG_PTR)((ULONG_PTR)RelocationOldImageBase - (ULONG_PTR)RelocationNewImageBase);
                    }
                    else
                    {
                        DeltaByte = (ULONG_PTR)((ULONG_PTR)RelocationNewImageBase - (ULONG_PTR)RelocationOldImageBase);
                    }
                    while((BYTE)DeltaByte == NULL)
                    {
                        DeltaByte = DeltaByte / 0x10;
                        i++;
                    }
                    DeltaByte = i - 1;
                    Search1 = (LPVOID)FileMapVA1;
                    Search2 = (LPVOID)FileMapVA2;
                    NtSizeOfImage = NtSizeOfImage + LoadedImageBase;
                    SearchSize = FileSize2;
                    SearchSize--;
                    while((int)SearchSize > NULL)
                    {
                        if(memcmp(Search1, Search2, 1) != 0)
                        {
                            i = sizeof HANDLE;
                            RelativeBase = NULL;
                            bkSearch1 = Search1;
                            bkSearch2 = Search2;
                            bkSearchSize = SearchSize;
                            if(Search1 >= (void*)((ULONG_PTR)FileMapVA1 + DeltaByte))
                            {
                                Search1 = (LPVOID)((ULONG_PTR)Search1 - DeltaByte);
                                Search2 = (LPVOID)((ULONG_PTR)Search2 - DeltaByte);
                                SearchSize = SearchSize + (DWORD)DeltaByte;
                            }
                            while(i > NULL && RelativeBase == NULL)
                            {
                                RtlMoveMemory(&ReadData, Search2, sizeof HANDLE);
                                if(ReadData >= LoadedImageBase && ReadData <= NtSizeOfImage)
                                {
                                    RelativeBase++;
                                }
                                else
                                {
                                    Search1 = (LPVOID)((ULONG_PTR)Search1 + 1);
                                    Search2 = (LPVOID)((ULONG_PTR)Search2 + 1);
                                    SearchSize = SearchSize - 1;
                                    i--;
                                }
                            }
                            if(RelativeBase == NULL)
                            {
                                Search1 = bkSearch1;
                                Search2 = bkSearch2;
                                SearchSize = bkSearchSize;
                            }
                            else
                            {
                                RelocaterAddNewRelocation(hProcess, MemStart + ((ULONG_PTR)Search2 - (ULONG_PTR)FileMapVA2), NULL);
                                Search1 = (LPVOID)((ULONG_PTR)Search1 + sizeof HANDLE - 1);
                                Search2 = (LPVOID)((ULONG_PTR)Search2 + sizeof HANDLE - 1);
                                SearchSize = SearchSize - sizeof HANDLE + 1;
                            }
                        }
                        Search1 = (LPVOID)((ULONG_PTR)Search1 + 1);
                        Search2 = (LPVOID)((ULONG_PTR)Search2 + 1);
                        SearchSize = SearchSize - 1;
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    RelocaterCleanup();
                    UnMapFileEx(FileHandle2, FileSize2, FileMap2, FileMapVA2);
                    UnMapFileEx(FileHandle1, FileSize1, FileMap1, FileMapVA1);
                    return false;
                }
            }
            UnMapFileEx(FileHandle2, FileSize2, FileMap2, FileMapVA2);
        }
        UnMapFileEx(FileHandle1, FileSize1, FileMap1, FileMapVA1);
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(char* szFileName, ULONG_PTR NewImageBase)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(RelocaterChangeFileBaseW(uniFileName, NewImageBase));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(wchar_t* szFileName, ULONG_PTR NewImageBase)
{

    DWORD RelocSize;
    ULONG_PTR RelocData;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    DWORD CompareDummy = NULL;
    DWORD RelocDelta = NULL;
    DWORD RelocDeltaSize = NULL;
    WORD RelocAddressData = NULL;
    ULONG_PTR RelocWriteAddress = NULL;
    ULONG_PTR RelocWriteData = NULL;
    DWORD64 RelocWriteData64 = NULL;
    wchar_t szBackupFile[MAX_PATH] = {};
    wchar_t szBackupItem[MAX_PATH] = {};

    if(engineBackupForCriticalFunctions && CreateGarbageItem(&szBackupItem, sizeof szBackupItem))
    {
        if(!FillGarbageItem(szBackupItem, szFileName, &szBackupFile, sizeof szBackupItem))
        {
            RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
            lstrcpyW(szBackupFile, szFileName);
        }
    }
    else
    {
        RtlZeroMemory(&szBackupItem, sizeof szBackupItem);
        lstrcpyW(szBackupFile, szFileName);
    }
    if(MapFileExW(szBackupFile, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return false;
            }
            if(!FileIs64)
            {
                if(PEHeader32->OptionalHeader.ImageBase == (DWORD)NewImageBase)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return true;
                }
                RelocData = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.ImageBase), true);
                RelocSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
            }
            else
            {
                if((ULONG_PTR)PEHeader64->OptionalHeader.ImageBase == NewImageBase)
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    RemoveGarbageItem(szBackupItem, true);
                    return true;
                }
                RelocData = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader64->OptionalHeader.ImageBase), true);
                RelocSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
            }
            __try
            {
                while(memcmp((LPVOID)RelocData, &CompareDummy, 4))
                {
                    RtlMoveMemory(&RelocDelta, (LPVOID)RelocData, 4);
                    RtlMoveMemory(&RelocDeltaSize, (LPVOID)((ULONG_PTR)RelocData + 4), 4);
                    RelocDeltaSize = RelocDeltaSize - 8;
                    RelocData = RelocData + 8;
                    while(RelocDeltaSize > NULL)
                    {
                        RtlMoveMemory(&RelocAddressData, (LPVOID)RelocData, 2);
                        if(RelocAddressData != NULL)
                        {
                            if(RelocAddressData & 0x8000)
                            {
                                RelocAddressData = RelocAddressData ^ 0x8000;
                                RelocWriteAddress = (ULONG_PTR)(RelocAddressData + RelocDelta);
                                RelocWriteAddress = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)((DWORD64)PEHeader64->OptionalHeader.ImageBase + RelocWriteAddress), true);
                                RtlMoveMemory(&RelocWriteData64, (LPVOID)RelocWriteAddress, 8);
                                RelocWriteData64 = RelocWriteData64 - (DWORD64)PEHeader64->OptionalHeader.ImageBase + (DWORD64)NewImageBase;
                                RtlMoveMemory((LPVOID)RelocWriteAddress, &RelocWriteData64, 8);
                            }
                            else if(RelocAddressData & 0x3000)
                            {
                                RelocAddressData = RelocAddressData ^ 0x3000;
                                RelocWriteAddress = (ULONG_PTR)(RelocAddressData + RelocDelta);
                                RelocWriteAddress = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, PEHeader32->OptionalHeader.ImageBase + RelocWriteAddress, true);
                                RtlMoveMemory(&RelocWriteData, (LPVOID)RelocWriteAddress, 4);
                                RelocWriteData = RelocWriteData - PEHeader32->OptionalHeader.ImageBase + NewImageBase;
                                RtlMoveMemory((LPVOID)RelocWriteAddress, &RelocWriteData, 4);
                            }
                        }
                        RelocDeltaSize = RelocDeltaSize - 2;
                        RelocData = RelocData + 2;
                    }
                }
                if(!FileIs64)
                {
                    PEHeader32->OptionalHeader.ImageBase = (DWORD)NewImageBase;
                }
                else
                {
                    PEHeader64->OptionalHeader.ImageBase = (ULONG_PTR)NewImageBase;
                }
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                if(szBackupItem[0] != NULL)
                {
                    if(CopyFileW(szBackupFile, szFileName, false))
                    {
                        RemoveGarbageItem(szBackupItem, true);
                        return true;
                    }
                    else
                    {
                        RemoveGarbageItem(szBackupItem, true);
                        return false;
                    }
                }
                else
                {
                    return true;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                RemoveGarbageItem(szBackupItem, true);
                return false;
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            RemoveGarbageItem(szBackupItem, true);
            return false;
        }
    }
    RemoveGarbageItem(szBackupItem, true);
    return false;
}

__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase)
{

    BOOL FileIs64;
    DWORD RelocSize;
    ULONG_PTR RelocData;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    DWORD CompareDummy = NULL;
    DWORD RelocDelta = NULL;
    DWORD RelocDeltaSize = NULL;
    WORD RelocAddressData = NULL;
    ULONG_PTR RelocWriteAddress = NULL;
    ULONG_PTR RelocWriteData = NULL;
    DWORD64 RelocWriteData64 = NULL;

    DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
    MemoryLocation = MemoryLocation - CurrentLoadedBase;
    if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
    {
        PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
        if(PEHeader32->OptionalHeader.Magic == 0x10B)
        {
            FileIs64 = false;
        }
        else if(PEHeader32->OptionalHeader.Magic == 0x20B)
        {
            FileIs64 = true;
        }
        else
        {
            return false;
        }
        if(!FileIs64)
        {
            if(PEHeader32->OptionalHeader.ImageBase == (DWORD)RelocateBase)
            {
                return true;
            }
            RelocData = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader32->OptionalHeader.ImageBase), true);
            RelocSize = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
        }
        else
        {
            if((ULONG_PTR)PEHeader64->OptionalHeader.ImageBase == RelocateBase)
            {
                return true;
            }
            RelocData = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + PEHeader64->OptionalHeader.ImageBase), true);
            RelocSize = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
        }
        __try
        {
            while(memcmp((LPVOID)RelocData, &CompareDummy, 4))
            {
                RtlMoveMemory(&RelocDelta, (LPVOID)RelocData, 4);
                RtlMoveMemory(&RelocDeltaSize, (LPVOID)((ULONG_PTR)RelocData + 4), 4);
                RelocDeltaSize = RelocDeltaSize - 8;
                RelocData = RelocData + 8;
                while(RelocDeltaSize > NULL)
                {
                    RtlMoveMemory(&RelocAddressData, (LPVOID)RelocData, 2);
                    if(RelocAddressData != NULL)
                    {
                        if(RelocAddressData & 0x8000)
                        {
                            RelocAddressData = RelocAddressData ^ 0x8000;
                            if(RelocAddressData >= MemoryLocation && RelocAddressData < MemoryLocation + RelocateMemorySize)
                            {
                                RelocWriteAddress = (ULONG_PTR)(RelocAddressData + RelocDelta - MemoryLocation + (ULONG_PTR)RelocateMemory);
                                RtlMoveMemory(&RelocWriteData64, (LPVOID)RelocWriteAddress, 8);
                                RelocWriteData64 = RelocWriteData64 - (DWORD64)PEHeader64->OptionalHeader.ImageBase + (DWORD64)RelocateBase;
                                RtlMoveMemory((LPVOID)RelocWriteAddress, &RelocWriteData64, 8);
                            }
                        }
                        else if(RelocAddressData & 0x3000)
                        {
                            RelocAddressData = RelocAddressData ^ 0x3000;
                            if(RelocAddressData >= MemoryLocation && RelocAddressData < MemoryLocation + RelocateMemorySize)
                            {
                                RelocWriteAddress = (ULONG_PTR)(RelocAddressData + RelocDelta - MemoryLocation + (ULONG_PTR)RelocateMemory);
                                RtlMoveMemory(&RelocWriteData, (LPVOID)RelocWriteAddress, 4);
                                RelocWriteData = RelocWriteData - PEHeader32->OptionalHeader.ImageBase + RelocateBase;
                                RtlMoveMemory((LPVOID)RelocWriteAddress, &RelocWriteData, 4);
                            }
                        }
                    }
                    RelocDeltaSize = RelocDeltaSize - 2;
                    RelocData = RelocData + 2;
                }
            }
            return true;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return false;
        }
    }
    else
    {
        return false;
    }
    return false;
}

__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(char* szFileName)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(RelocaterWipeRelocationTableW(uniFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(wchar_t* szFileName)
{

    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    DWORD WipeSectionNumber = NULL;
    ULONG_PTR Characteristics;
    BOOL FileIs64;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != NULL)
                {
                    Characteristics = (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_CHARACTERISTICS) ^ 1;
                    SetPE32DataForMappedFile(FileMapVA, NULL, UE_CHARACTERISTICS, Characteristics);
                    WipeSectionNumber = GetPE32SectionNumberFromVA(FileMapVA, (ULONG_PTR)((ULONG_PTR)PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + (ULONG_PTR)PEHeader32->OptionalHeader.ImageBase));
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return(WipeSectionW(szFileName, (int)WipeSectionNumber, true));
                }
            }
            else
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != NULL)
                {
                    Characteristics = (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_CHARACTERISTICS) ^ 1;
                    SetPE32DataForMappedFile(FileMapVA, NULL, UE_CHARACTERISTICS, Characteristics);
                    WipeSectionNumber = GetPE32SectionNumberFromVA(FileMapVA, (ULONG_PTR)((ULONG_PTR)PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + (ULONG_PTR)PEHeader64->OptionalHeader.ImageBase));
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return(WipeSectionW(szFileName, (int)WipeSectionNumber, true));
                }
            }
        }
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.Resourcer.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Mapping.h"
#include "Global.Engine.h"
#include "Global.Handle.h"

// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(char* szFileName)
{
    return((ULONG_PTR)EngineSimulateNtLoader(szFileName));
}

__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(wchar_t* szFileName)
{
    return((ULONG_PTR)EngineSimulateNtLoaderW(szFileName));
}

__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase)
{
    if(VirtualFree(LoadedFileBase, NULL, MEM_RELEASE))
    {
        return true;
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, char* szResourceType, char* szResourceName, char* szExtractedFileName)
{

    HRSRC hResource;
    HGLOBAL hResourceGlobal;
    DWORD ResourceSize;
    LPVOID ResourceData;
    DWORD NumberOfBytesWritten;
    HANDLE hOutFile;

    hResource = FindResourceA(hFile, (LPCSTR)szResourceName, (LPCSTR)szResourceType);
    if(hResource != NULL)
    {
        hResourceGlobal = LoadResource(hFile, hResource);
        if(hResourceGlobal != NULL)
        {
            ResourceSize = SizeofResource(hFile, hResource);
            ResourceData = LockResource(hResourceGlobal);
            EngineCreatePathForFile(szExtractedFileName);
            hOutFile = CreateFileA(szExtractedFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hOutFile != INVALID_HANDLE_VALUE)
            {
                WriteFile(hOutFile, ResourceData, ResourceSize, &NumberOfBytesWritten, NULL);
                EngineCloseHandle(hOutFile);
            }
            else
            {
                return false;
            }
        }
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(char* szFileName, char* szResourceType, char* szResourceName, char* szExtractedFileName)
{
    HMODULE hFile = NULL;
    bool bReturn;

    hFile = LoadLibraryA(szFileName);
    if(hFile != NULL)
    {
        bReturn = ResourcerExtractResourceFromFileEx(hFile, szResourceType, szResourceName, szExtractedFileName);
        FreeLibrary(hFile);
        if(bReturn)
        {
            return true;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(wchar_t* szFileName, char* szResourceType, char* szResourceName, char* szExtractedFileName)
{
    HMODULE hFile = NULL;
    bool bReturn;

    hFile = LoadLibraryW(szFileName);
    if(hFile != NULL)
    {
        bReturn = ResourcerExtractResourceFromFileEx(hFile, szResourceType, szResourceName, szExtractedFileName);
        FreeLibrary(hFile);
        if(bReturn)
        {
            return true;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL ResourcerFindResource(char* szFileName, char* szResourceType, DWORD ResourceType, char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize)
{

    wchar_t uniFileName[MAX_PATH] = {};
    wchar_t* PtrResourceType = NULL;
    wchar_t uniResourceType[MAX_PATH] = {};
    wchar_t* PtrResourceName = NULL;
    wchar_t uniResourceName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        if(szResourceName != NULL)
        {
            MultiByteToWideChar(CP_ACP, NULL, szResourceName, lstrlenA(szResourceName) + 1, uniResourceName, sizeof(uniResourceName) / (sizeof(uniResourceName[0])));
        }
        else
        {
            PtrResourceType = &uniResourceType[0];
        }
        if(szResourceType != NULL)
        {
            MultiByteToWideChar(CP_ACP, NULL, szResourceType, lstrlenA(szResourceType) + 1, uniResourceType, sizeof(uniResourceType) / (sizeof(uniResourceType[0])));
        }
        else
        {
            PtrResourceName = &uniResourceName[0];
        }
        return(ResourcerFindResourceW(uniFileName, PtrResourceType, ResourceType, PtrResourceName, ResourceName, ResourceLanguage, pResourceData, pResourceSize));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL ResourcerFindResourceW(wchar_t* szFileName, wchar_t* szResourceType, DWORD ResourceType, wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize)
{

    bool ReturnValue;
    ULONG_PTR FileMapVA;
    HANDLE FileHandle;
    HANDLE FileMap;
    DWORD FileSize;

    if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ReturnValue = ResourcerFindResourceEx(FileMapVA, FileSize, szResourceType, ResourceType, szResourceName, ResourceName, ResourceLanguage, pResourceData, pResourceSize);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
    }
    else
    {
        return false;
    }
    return false;
}

__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, wchar_t* szResourceType, DWORD ResourceType, wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize)
{

    int i, j, n;
    wchar_t* uniResourceName;
    wchar_t* uniResourceType;
    PIMAGE_RESOURCE_DIRECTORY PEResource;
    PIMAGE_RESOURCE_DIRECTORY PEResourcePtr;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY PEResourceDir;
    PIMAGE_RESOURCE_DIRECTORY PESubResourcePtr1;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY PEResourceDir1;
    PIMAGE_RESOURCE_DIRECTORY PESubResourcePtr2;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY PEResourceDir2;
    PIMAGE_RESOURCE_DATA_ENTRY PEResourceItem;

    __try
    {
        if(FileMapVA != NULL && FileSize != NULL)
        {
            PEResource = (PIMAGE_RESOURCE_DIRECTORY)(ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMAGEBASE), (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_RESOURCETABLEADDRESS), true, true));
            if(PEResource != NULL)
            {
                PEResourceDir = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResource + sizeof IMAGE_RESOURCE_DIRECTORY);
                i = PEResource->NumberOfIdEntries + PEResource->NumberOfNamedEntries;
                PEResourcePtr = PEResource;
                while(i > NULL)
                {
                    PESubResourcePtr1 = (PIMAGE_RESOURCE_DIRECTORY)((ULONG_PTR)PEResourcePtr + (PEResourceDir->OffsetToData ^ IMAGE_RESOURCE_DATA_IS_DIRECTORY));
                    PEResourceDir1 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PESubResourcePtr1 + sizeof IMAGE_RESOURCE_DIRECTORY);
                    j = PESubResourcePtr1->NumberOfIdEntries + PESubResourcePtr1->NumberOfNamedEntries;
                    uniResourceType = (wchar_t*)((ULONG_PTR)PEResourcePtr + PEResourceDir->NameOffset);
                    if(((bool)PEResourceDir->NameIsString == true && EngineCompareResourceString(uniResourceType, szResourceType) == true) || ((bool)PEResourceDir->NameIsString == false && PEResourceDir->Id == ResourceType))
                    {
                        while(j > NULL)
                        {
                            PESubResourcePtr2 = (PIMAGE_RESOURCE_DIRECTORY)((ULONG_PTR)PEResourcePtr + (PEResourceDir1->OffsetToData ^ IMAGE_RESOURCE_DATA_IS_DIRECTORY));
                            PEResourceDir2 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PESubResourcePtr2 + sizeof IMAGE_RESOURCE_DIRECTORY);
                            n = PESubResourcePtr2->NumberOfIdEntries + PESubResourcePtr2->NumberOfNamedEntries;
                            uniResourceName = (wchar_t*)((ULONG_PTR)PEResourcePtr + PEResourceDir1->NameOffset);
                            if(((bool)PEResourceDir1->NameIsString == true && EngineCompareResourceString(uniResourceName, szResourceName) == true) || ((bool)PEResourceDir1->NameIsString == false && PEResourceDir1->Id == ResourceName))
                            {
                                while(n > NULL)
                                {
                                    PEResourceItem = (PIMAGE_RESOURCE_DATA_ENTRY)((ULONG_PTR)PEResourcePtr + PEResourceDir2->OffsetToData);
                                    if(ResourceLanguage == UE_RESOURCE_LANGUAGE_ANY || ResourceLanguage == PEResourceDir2->Id)
                                    {
                                        *pResourceData = PEResourceItem->OffsetToData;
                                        *pResourceSize = PEResourceItem->Size;
                                        return true;
                                    }
                                    PEResourceDir2 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir2 + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY);
                                    n--;
                                }
                            }
                            else
                            {
                                PEResourceDir2 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir2 + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY * n);
                            }
                            PEResourceDir1 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir1 + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY);
                            j--;
                        }
                    }
                    else
                    {
                        PEResourceDir1 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir1 + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY * j);
                    }
                    PEResourceDir = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY);
                    i--;
                }
            }
        }
        else
        {
            return false;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

    }
    return false;
}

__declspec(dllexport) void TITCALL ResourcerEnumerateResource(char* szFileName, void* CallBack)
{

    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        ResourcerEnumerateResourceW(uniFileName, CallBack);
    }
}

__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(wchar_t* szFileName, void* CallBack)
{

    ULONG_PTR FileMapVA;
    HANDLE FileHandle;
    HANDLE FileMap;
    DWORD FileSize;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        ResourcerEnumerateResourceEx(FileMapVA, FileSize, CallBack);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
    }
}

__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack)
{

    int i, j, n;
    wchar_t* pUniResourceName;
    wchar_t* pUniResourceType;
    PIMAGE_RESOURCE_DIRECTORY PEResource;
    PIMAGE_RESOURCE_DIRECTORY PEResourcePtr;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY PEResourceDir;
    PIMAGE_RESOURCE_DIRECTORY PESubResourcePtr1;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY PEResourceDir1;
    PIMAGE_RESOURCE_DIRECTORY PESubResourcePtr2;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY PEResourceDir2;
    PIMAGE_RESOURCE_DATA_ENTRY PEResourceItem;
    typedef bool(TITCALL * fResourceEnumerator)(wchar_t* szResourceType, DWORD ResourceType, wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, DWORD ResourceData, DWORD ResourceSize);
    fResourceEnumerator myResourceEnumerator = (fResourceEnumerator)CallBack;

    __try
    {
        if(CallBack != NULL)
        {
            if(FileMapVA != NULL && FileSize != NULL)
            {
                PEResource = (PIMAGE_RESOURCE_DIRECTORY)(ConvertVAtoFileOffsetEx(FileMapVA, FileSize, (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMAGEBASE), (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_RESOURCETABLEADDRESS), true, true));
                if(PEResource != NULL)
                {
                    PEResourceDir = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResource + sizeof IMAGE_RESOURCE_DIRECTORY);
                    i = PEResource->NumberOfIdEntries + PEResource->NumberOfNamedEntries;
                    PEResourcePtr = PEResource;
                    while(i > NULL)
                    {
                        PESubResourcePtr1 = (PIMAGE_RESOURCE_DIRECTORY)((ULONG_PTR)PEResourcePtr + (PEResourceDir->OffsetToData ^ IMAGE_RESOURCE_DATA_IS_DIRECTORY));
                        PEResourceDir1 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PESubResourcePtr1 + sizeof IMAGE_RESOURCE_DIRECTORY);
                        j = PESubResourcePtr1->NumberOfIdEntries + PESubResourcePtr1->NumberOfNamedEntries;
                        while(j > NULL)
                        {
                            PESubResourcePtr2 = (PIMAGE_RESOURCE_DIRECTORY)((ULONG_PTR)PEResourcePtr + (PEResourceDir1->OffsetToData ^ IMAGE_RESOURCE_DATA_IS_DIRECTORY));
                            PEResourceDir2 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PESubResourcePtr2 + sizeof IMAGE_RESOURCE_DIRECTORY);
                            n = PESubResourcePtr2->NumberOfIdEntries + PESubResourcePtr2->NumberOfNamedEntries;
                            while(n > NULL)
                            {
                                wchar_t uniResourceName[MAX_PATH] = {};
                                wchar_t uniResourceType[MAX_PATH] = {};
                                PEResourceItem = (PIMAGE_RESOURCE_DATA_ENTRY)((ULONG_PTR)PEResourcePtr + PEResourceDir2->OffsetToData);
                                if(PEResourceDir->NameIsString)
                                {
                                    WORD resourceTypeLen = *(WORD*)((ULONG_PTR)PEResourcePtr + PEResourceDir->NameOffset);
                                    wcsncpy(uniResourceType, (wchar_t*)((ULONG_PTR)PEResourcePtr + PEResourceDir->NameOffset) + 1, resourceTypeLen);
                                    pUniResourceType = uniResourceType;
                                }
                                else
                                {
                                    pUniResourceType = NULL;
                                }
                                if(PEResourceDir1->NameIsString)
                                {
                                    WORD resourceNameLen = *(WORD*)((ULONG_PTR)PEResourcePtr + PEResourceDir1->NameOffset);
                                    wcsncpy(uniResourceName, (wchar_t*)((ULONG_PTR)PEResourcePtr + PEResourceDir1->NameOffset) + 1, resourceNameLen);
                                    pUniResourceName = uniResourceName;
                                }
                                else
                                {
                                    pUniResourceName = NULL;
                                }
                                if(!myResourceEnumerator(pUniResourceType, PEResourceDir->Id, pUniResourceName, PEResourceDir1->Id, PEResourceDir2->Id, PEResourceItem->OffsetToData, PEResourceItem->Size))
                                {
                                    return;
                                }
                                PEResourceDir2 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir2 + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY);
                                n--;
                            }
                            PEResourceDir1 = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir1 + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY);
                            j--;
                        }
                        PEResourceDir = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((ULONG_PTR)PEResourceDir + sizeof IMAGE_RESOURCE_DIRECTORY_ENTRY);
                        i--;
                    }
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

    }
}



================================================
File: TitanEngine/TitanEngine.Static.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Mapping.h"
#include "Global.Handle.h"
#include "Global.Engine.h"
#include "Global.Engine.Hash.h"

// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA)
{
    if(!SimulateLoad)
    {
        if(MapFileEx(szFileName, DesiredAccess, FileHandle, LoadedSize, FileMap, FileMapVA, NULL))
        {
            return true;
        }
    }
    else
    {
        *FileMapVA = (ULONG_PTR)ResourcerLoadFileForResourceUse(szFileName);
        if(*FileMapVA != NULL)
        {
            *LoadedSize = (DWORD)GetPE32DataFromMappedFile(*FileMapVA, NULL, UE_SIZEOFIMAGE);
            *FileHandle = NULL;
            *FileMap = NULL;

            return true;
        }
    }

    return false;
}

__declspec(dllexport) bool TITCALL StaticFileLoadW(wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA)
{
    if(!SimulateLoad)
    {
        if(MapFileExW(szFileName, DesiredAccess, FileHandle, LoadedSize, FileMap, FileMapVA, NULL))
        {
            return true;
        }
    }
    else
    {
        *FileMapVA = (ULONG_PTR)ResourcerLoadFileForResourceUseW(szFileName);
        if(*FileMapVA != NULL)
        {
            *LoadedSize = (DWORD)GetPE32DataFromMappedFile(*FileMapVA, NULL, UE_SIZEOFIMAGE);
            *FileHandle = NULL;
            *FileMap = NULL;

            return true;
        }
    }

    return false;
}

__declspec(dllexport) bool TITCALL StaticFileUnload(char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(StaticFileUnloadW(uniFileName, CommitChanges, FileHandle, LoadedSize, FileMap, FileMapVA));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL StaticFileUnloadW(wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA)
{
    DWORD PeHeaderSize;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_SECTION_HEADER PESections;
    DWORD SectionNumber = 0;
    DWORD SectionRawOffset = 0;
    DWORD SectionRawSize = 0;
    BOOL FileIs64;
    HANDLE myFileHandle;
    DWORD myFileSize;
    HANDLE myFileMap;
    ULONG_PTR myFileMapVA;

    if(FileHandle != NULL && FileMap != NULL)
    {
        UnMapFileEx(FileHandle, LoadedSize, FileMap, FileMapVA);

        return true;
    }
    else
    {
        if(!CommitChanges)
        {
            return ResourcerFreeLoadedFile((LPVOID)FileMapVA);
        }
        else
        {
            if(MapFileExW(szFileName, UE_ACCESS_ALL, &myFileHandle, &myFileSize, &myFileMap, &myFileMapVA, NULL))
            {
                DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
                if(DOSHeader->e_lfanew < 0x1000 - 108)
                {
                    PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                    PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);

                    if(PEHeader32->OptionalHeader.Magic == 0x10B)
                    {
                        FileIs64 = false;
                    }
                    else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                    {
                        FileIs64 = true;
                    }
                    else
                    {
                        ResourcerFreeLoadedFile((LPVOID)FileMapVA);
                        UnMapFileEx(myFileHandle, myFileSize, myFileMap, myFileMapVA);

                        return false;
                    }

                    if(!FileIs64)
                    {
                        PeHeaderSize = PEHeader32->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_SECTION_HEADER) * PEHeader32->FileHeader.NumberOfSections;
                        PESections = IMAGE_FIRST_SECTION(PEHeader32);
                        SectionNumber = PEHeader32->FileHeader.NumberOfSections;
                        RtlMoveMemory((LPVOID)myFileMapVA, (LPVOID)FileMapVA, PeHeaderSize);

                        while(SectionNumber > 0)
                        {
                            RtlMoveMemory((LPVOID)((ULONG_PTR)myFileMapVA + PESections->PointerToRawData), (LPVOID)(FileMapVA + PESections->VirtualAddress), PESections->SizeOfRawData);
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            SectionNumber--;
                        }

                        ResourcerFreeLoadedFile((LPVOID)FileMapVA);
                        UnMapFileEx(myFileHandle, myFileSize, myFileMap, myFileMapVA);

                        return true;
                    }
                    else
                    {
                        PeHeaderSize = PEHeader64->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_SECTION_HEADER) * PEHeader64->FileHeader.NumberOfSections;
                        PESections = IMAGE_FIRST_SECTION(PEHeader64);
                        SectionNumber = PEHeader64->FileHeader.NumberOfSections;
                        RtlMoveMemory((LPVOID)myFileMapVA, (LPVOID)FileMapVA, PeHeaderSize);

                        while(SectionNumber > 0)
                        {
                            RtlMoveMemory((LPVOID)((ULONG_PTR)myFileMapVA + PESections->PointerToRawData), (LPVOID)(FileMapVA + PESections->VirtualAddress), PESections->SizeOfRawData);
                            PESections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)PESections + IMAGE_SIZEOF_SECTION_HEADER);
                            SectionNumber--;
                        }
                        ResourcerFreeLoadedFile((LPVOID)FileMapVA);
                        UnMapFileEx(myFileHandle, myFileSize, myFileMap, myFileMapVA);

                        return true;
                    }
                }
                else
                {
                    ResourcerFreeLoadedFile((LPVOID)FileMapVA);
                    UnMapFileEx(myFileHandle, myFileSize, myFileMap, myFileMapVA);

                    return false;
                }
            }
        }
    }

    return false;
}

__declspec(dllexport) bool TITCALL StaticFileOpen(char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));

        return StaticFileOpenW(uniFileName, DesiredAccess, FileHandle, FileSizeLow, FileSizeHigh);
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL StaticFileOpenW(wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh)
{
    __try
    {
        *FileHandle = CreateFileW(szFileName, DesiredAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(FileHandle != INVALID_HANDLE_VALUE)
        {
            *FileSizeLow = GetFileSize(*FileHandle, FileSizeHigh);

            return true;
        }
        else
        {
            return false;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size)
{
    DWORD rfNumberOfBytesRead;

    if(SetFilePointer(FileHandle, FilePositionLow, (PLONG)FilePositionHigh, FILE_BEGIN) != INVALID_SET_FILE_POINTER)
    {
        if(ReadFile(FileHandle, Buffer, Size, &rfNumberOfBytesRead, NULL))
        {
            if(rfNumberOfBytesRead == Size)
            {
                return true;
            }
            else
            {
                RtlZeroMemory(Buffer, Size);
            }
        }
    }

    return false;
}

__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle)
{
    EngineCloseHandle(FileHandle);
}

__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey)
{
    DWORD LoopCount = NULL;
    BYTE DataByte = NULL;
    WORD DataWord = NULL;
    DWORD DataDword = NULL;
    ULONG64 DataQword = NULL;

    //ignore too big stuff
    if(DecryptionKeySize > sizeof(ULONG_PTR))
        return;

    if(MemoryStart != NULL && MemorySize > NULL)
    {
        LoopCount = MemorySize / DecryptionKeySize;
        while(LoopCount > NULL)
        {
            if(DecryptionType == UE_STATIC_DECRYPTOR_XOR)
            {
                if(DecryptionKeySize == UE_STATIC_KEY_SIZE_1)
                {
                    RtlMoveMemory(&DataByte, MemoryStart, UE_STATIC_KEY_SIZE_1);
                    DataByte = DataByte ^ (BYTE)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataByte, UE_STATIC_KEY_SIZE_1);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_2)
                {
                    RtlMoveMemory(&DataWord, MemoryStart, UE_STATIC_KEY_SIZE_2);
                    DataWord = DataWord ^ (WORD)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataWord, UE_STATIC_KEY_SIZE_2);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_4)
                {
                    RtlMoveMemory(&DataDword, MemoryStart, UE_STATIC_KEY_SIZE_4);
                    DataDword = DataDword ^ (DWORD)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataDword, UE_STATIC_KEY_SIZE_4);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_8)
                {
                    RtlMoveMemory(&DataQword, MemoryStart, UE_STATIC_KEY_SIZE_8);
                    DataQword = DataQword ^ (ULONG_PTR)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataQword, UE_STATIC_KEY_SIZE_8);
                }
            }
            else if(DecryptionType == UE_STATIC_DECRYPTOR_SUB)
            {
                if(DecryptionKeySize == UE_STATIC_KEY_SIZE_1)
                {
                    RtlMoveMemory(&DataByte, MemoryStart, UE_STATIC_KEY_SIZE_1);
                    DataByte = DataByte - (BYTE)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataByte, UE_STATIC_KEY_SIZE_1);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_2)
                {
                    RtlMoveMemory(&DataWord, MemoryStart, UE_STATIC_KEY_SIZE_2);
                    DataWord = DataWord - (WORD)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataWord, UE_STATIC_KEY_SIZE_2);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_4)
                {
                    RtlMoveMemory(&DataDword, MemoryStart, UE_STATIC_KEY_SIZE_4);
                    DataDword = DataDword - (DWORD)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataDword, UE_STATIC_KEY_SIZE_4);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_8)
                {
                    RtlMoveMemory(&DataQword, MemoryStart, UE_STATIC_KEY_SIZE_8);
                    DataQword = DataQword - (ULONG_PTR)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataQword, UE_STATIC_KEY_SIZE_8);
                }
            }
            else if(DecryptionType == UE_STATIC_DECRYPTOR_ADD)
            {
                if(DecryptionKeySize == UE_STATIC_KEY_SIZE_1)
                {
                    RtlMoveMemory(&DataByte, MemoryStart, UE_STATIC_KEY_SIZE_1);
                    DataByte = DataByte + (BYTE)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataByte, UE_STATIC_KEY_SIZE_1);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_2)
                {
                    RtlMoveMemory(&DataWord, MemoryStart, UE_STATIC_KEY_SIZE_2);
                    DataWord = DataWord + (WORD)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataWord, UE_STATIC_KEY_SIZE_2);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_4)
                {
                    RtlMoveMemory(&DataDword, MemoryStart, UE_STATIC_KEY_SIZE_4);
                    DataDword = DataDword + (DWORD)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataDword, UE_STATIC_KEY_SIZE_4);
                }
                else if(DecryptionKeySize == UE_STATIC_KEY_SIZE_8)
                {
                    RtlMoveMemory(&DataQword, MemoryStart, UE_STATIC_KEY_SIZE_8);
                    DataQword = DataQword + (ULONG_PTR)DecryptionKey;
                    RtlMoveMemory(MemoryStart, &DataQword, UE_STATIC_KEY_SIZE_8);
                }
            }
            MemoryStart = (LPVOID)((ULONG_PTR)MemoryStart + DecryptionKeySize);
            LoopCount--;
        }
    }
}

__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack)
{
    DWORD LoopCount = NULL;
    typedef bool(TITCALL * fStaticCallBack)(void* sMemoryStart, int sKeySize);
    fStaticCallBack myStaticCallBack = (fStaticCallBack)DecryptionCallBack;

    if(MemoryStart != NULL && MemorySize > NULL)
    {
        LoopCount = MemorySize / DecryptionKeySize;
        while(LoopCount > NULL)
        {
            __try
            {
                if(!myStaticCallBack(MemoryStart, (int)DecryptionKeySize))
                {
                    break;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                break;
            }
            MemoryStart = (LPVOID)((ULONG_PTR)MemoryStart + DecryptionKeySize);
            LoopCount--;
        }
    }
}

__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack)
{
    DWORD LoopCount = NULL;
    typedef bool(TITCALL * fStaticCallBack)(void* sMemoryStart, int sKeySize);
    fStaticCallBack myStaticCallBack = (fStaticCallBack)DecryptionCallBack;

    if(MemoryStart != NULL && MemorySize > NULL)
    {
        if(SpecDecryptionType == UE_STATIC_DECRYPTOR_BACKWARD)
        {
            MemoryStart = (LPVOID)((ULONG_PTR)MemoryStart + MemorySize - DecryptionKeySize);
        }
        LoopCount = MemorySize / DecryptionKeySize;
        while(LoopCount > NULL)
        {
            __try
            {
                if(!myStaticCallBack(MemoryStart, (int)DecryptionKeySize))
                {
                    break;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                break;
            }

            if(SpecDecryptionType == UE_STATIC_DECRYPTOR_BACKWARD)
            {
                MemoryStart = (LPVOID)((ULONG_PTR)MemoryStart - DecryptionKeySize);
            }
            else
            {
                MemoryStart = (LPVOID)((ULONG_PTR)MemoryStart + DecryptionKeySize);
            }

            LoopCount--;
        }
    }
}

__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey)
{
    if(!SimulateLoad)
    {
        StaticMemoryDecrypt((LPVOID)((ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONRAWOFFSET) + FileMapVA), (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONRAWSIZE), DecryptionType, DecryptionKeySize, DecryptionKey);
    }
    else
    {
        StaticMemoryDecrypt((LPVOID)((ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONVIRTUALOFFSET) + FileMapVA), (DWORD)GetPE32DataFromMappedFile(FileMapVA, SectionNumber, UE_SECTIONRAWSIZE), DecryptionType, DecryptionKeySize, DecryptionKey);
    }
}

__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm)
{
    if(!Source || !Destination)
        return false;
    ELzmaStatus lzStatus;
    CLzmaProps lzProps = {};
    ISzAlloc lzAlloc = {&LzmaAllocMem, &LzmaFreeMem};

    if(Algorithm == UE_STATIC_APLIB)
    {
        if(aP_depack_asm_safe(Source, SourceSize, Destination, DestinationSize) != APLIB_ERROR)
        {
            return true;
        }
        else if(aPsafe_depack(Source, SourceSize, Destination, DestinationSize) != APLIB_ERROR)
        {
            return true;
        }
    }
    else if(Algorithm == UE_STATIC_LZMA)
    {
        if(LzmaDecode((unsigned char*)Destination, (size_t*)DestinationSize, (unsigned char*)Source, (size_t*)SourceSize, (unsigned char*)&lzProps, LZMA_PROPS_SIZE, LZMA_FINISH_ANY, &lzStatus, &lzAlloc) == SZ_OK)
        {
            return true;
        }
    }

    return false;
}

__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, char* szDumpFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, lstrlenA(szDumpFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(StaticRawMemoryCopyW(hFile, FileMapVA, VitualAddressToCopy, Size, AddressIsRVA, uniFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, wchar_t* szDumpFileName)
{
    DWORD SizeToRead;
    HANDLE hReadFile;
    HANDLE hWriteFile;
    //LPVOID ueCopyBuf;
    char ueCopyBuffer[0x1000] = {0};
    ULONG_PTR AddressToCopy;
    DWORD rfNumberOfBytesRead;

    if(FileMapVA != NULL)
    {
        if(DuplicateHandle(GetCurrentProcess(), hFile, GetCurrentProcess(), &hReadFile, NULL, false, DUPLICATE_SAME_ACCESS))
        {
            if(AddressIsRVA)
            {
                VitualAddressToCopy = VitualAddressToCopy + (ULONG_PTR)GetPE32DataFromMappedFile(FileMapVA, NULL, UE_IMAGEBASE);
                AddressToCopy = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, VitualAddressToCopy, false);
            }
            else
            {
                AddressToCopy = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, VitualAddressToCopy, false);
            }

            if(SetFilePointer(hReadFile, (long)AddressToCopy, NULL, FILE_BEGIN) != INVALID_SET_FILE_POINTER)
            {
                EngineCreatePathForFileW(szDumpFileName);
                hWriteFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if(hWriteFile != INVALID_HANDLE_VALUE)
                {
                    if(Size < sizeof(ueCopyBuffer))
                    {
                        SizeToRead = Size;
                    }
                    else
                    {
                        SizeToRead = sizeof(ueCopyBuffer);
                    }
                    while((int)Size > NULL)
                    {
                        if(ReadFile(hFile, ueCopyBuffer, SizeToRead, &rfNumberOfBytesRead, NULL) && rfNumberOfBytesRead == SizeToRead)
                        {
                            WriteFile(hWriteFile, ueCopyBuffer, SizeToRead, &rfNumberOfBytesRead, NULL);
                            if(Size > sizeof(ueCopyBuffer))
                            {
                                Size = Size - sizeof(ueCopyBuffer);
                            }
                            else if(SizeToRead != Size)
                            {
                                if(ReadFile(hFile, ueCopyBuffer, Size, &rfNumberOfBytesRead, NULL) && rfNumberOfBytesRead == SizeToRead)
                                {
                                    WriteFile(hWriteFile, ueCopyBuffer, Size, &rfNumberOfBytesRead, NULL);
                                }
                                else
                                {
                                    WriteFile(hWriteFile, ueCopyBuffer, rfNumberOfBytesRead, &rfNumberOfBytesRead, NULL);
                                }
                                SizeToRead = Size;
                                Size = NULL;
                            }
                            else
                            {
                                SizeToRead = Size;
                                Size = NULL;
                            }
                        }
                        else
                        {
                            WriteFile(hWriteFile, ueCopyBuffer, rfNumberOfBytesRead, &rfNumberOfBytesRead, NULL);
                            Size = NULL;
                        }
                    }

                    EngineCloseHandle(hReadFile);
                    EngineCloseHandle(hWriteFile);

                    return true;
                }
            }
            EngineCloseHandle(hReadFile);
        }
    }

    return false;
}

__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, char* szDumpFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, lstrlenA(szDumpFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return(StaticRawMemoryCopyExW(hFile, RawAddressToCopy, Size, uniFileName));
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, wchar_t* szDumpFileName)
{
    DWORD SizeToRead;
    HANDLE hReadFile;
    HANDLE hWriteFile;
    char ueCopyBuffer[0x1000] = {0};
    DWORD rfNumberOfBytesRead;

    if(DuplicateHandle(GetCurrentProcess(), hFile, GetCurrentProcess(), &hReadFile, NULL, false, DUPLICATE_SAME_ACCESS))
    {
        if(SetFilePointer(hReadFile, (long)(RawAddressToCopy), NULL, FILE_BEGIN) != INVALID_SET_FILE_POINTER)
        {
            EngineCreatePathForFileW(szDumpFileName);
            hWriteFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hWriteFile != INVALID_HANDLE_VALUE)
            {
                if(Size < sizeof(ueCopyBuffer))
                {
                    SizeToRead = Size;
                }
                else
                {
                    SizeToRead = sizeof(ueCopyBuffer);
                }
                while((int)Size > 0)
                {
                    if(ReadFile(hFile, ueCopyBuffer, SizeToRead, &rfNumberOfBytesRead, NULL) && rfNumberOfBytesRead == SizeToRead)
                    {
                        WriteFile(hWriteFile, ueCopyBuffer, SizeToRead, &rfNumberOfBytesRead, NULL);
                        if(Size > sizeof(ueCopyBuffer))
                        {
                            Size = Size - sizeof(ueCopyBuffer);
                        }
                        else if(SizeToRead != Size)
                        {
                            if(ReadFile(hFile, ueCopyBuffer, Size, &rfNumberOfBytesRead, NULL) && rfNumberOfBytesRead == SizeToRead)
                            {
                                WriteFile(hWriteFile, ueCopyBuffer, Size, &rfNumberOfBytesRead, NULL);
                            }
                            else
                            {
                                WriteFile(hWriteFile, ueCopyBuffer, rfNumberOfBytesRead, &rfNumberOfBytesRead, NULL);
                            }
                            SizeToRead = Size;
                            Size = 0;
                        }
                        else
                        {
                            SizeToRead = Size;
                            Size = 0;
                        }
                    }
                    else
                    {
                        WriteFile(hWriteFile, ueCopyBuffer, rfNumberOfBytesRead, &rfNumberOfBytesRead, NULL);
                        Size = 0;
                    }
                }

                EngineCloseHandle(hReadFile);
                EngineCloseHandle(hWriteFile);

                return true;
            }
        }

        EngineCloseHandle(hReadFile);
    }

    return false;
}

__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, char* szDumpFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szDumpFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szDumpFileName, lstrlenA(szDumpFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));

        return StaticRawMemoryCopyEx64W(hFile, RawAddressToCopy, Size, uniFileName);
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, wchar_t* szDumpFileName)
{
    DWORD SizeToRead;
    HANDLE hReadFile;
    HANDLE hWriteFile;
    char ueCopyBuffer[0x1000] = {0};
    DWORD rfNumberOfBytesRead;
    long FilePosLow;
    long FilePosHigh;

    if(DuplicateHandle(GetCurrentProcess(), hFile, GetCurrentProcess(), &hReadFile, NULL, false, DUPLICATE_SAME_ACCESS))
    {
        FilePosLow = (DWORD)RawAddressToCopy;
        RtlMoveMemory(&FilePosHigh, (void*)((ULONG_PTR)(&RawAddressToCopy) + 4), 4);
        if(SetFilePointer(hReadFile, FilePosLow, &FilePosHigh, FILE_BEGIN) != INVALID_SET_FILE_POINTER)
        {
            EngineCreatePathForFileW(szDumpFileName);
            hWriteFile = CreateFileW(szDumpFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hWriteFile != INVALID_HANDLE_VALUE)
            {
                if(Size < 0x1000)
                {
                    SizeToRead = (DWORD)Size;
                }
                else
                {
                    SizeToRead = 0x1000;
                }
                while(Size != NULL)
                {
                    if(ReadFile(hFile, ueCopyBuffer, SizeToRead, &rfNumberOfBytesRead, NULL) && rfNumberOfBytesRead == SizeToRead)
                    {
                        WriteFile(hWriteFile, ueCopyBuffer, SizeToRead, &rfNumberOfBytesRead, NULL);
                        if(Size > 0x1000)
                        {
                            Size = Size - 0x1000;
                        }
                        else if((DWORD64)SizeToRead != Size)
                        {
                            if(ReadFile(hFile, ueCopyBuffer, (DWORD)Size, &rfNumberOfBytesRead, NULL) && rfNumberOfBytesRead == SizeToRead)
                            {
                                WriteFile(hWriteFile, ueCopyBuffer, (DWORD)Size, &rfNumberOfBytesRead, NULL);
                            }
                            else
                            {
                                WriteFile(hWriteFile, ueCopyBuffer, rfNumberOfBytesRead, &rfNumberOfBytesRead, NULL);
                            }

                            SizeToRead = (DWORD)Size;
                            Size = NULL;
                        }
                        else
                        {
                            SizeToRead = (DWORD)Size;
                            Size = NULL;
                        }
                    }
                    else
                    {
                        WriteFile(hWriteFile, ueCopyBuffer, rfNumberOfBytesRead, &rfNumberOfBytesRead, NULL);
                        Size = NULL;
                    }
                }

                EngineCloseHandle(hReadFile);
                EngineCloseHandle(hWriteFile);

                return true;
            }
        }
    }

    EngineCloseHandle(hReadFile);

    return false;
}

__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm)
{
#define MD5LEN 16
#define SHA1LEN 20
#define HASH_MAX_LENGTH 20

    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    HANDLE hFile = NULL;
    DWORD rgbHash[HASH_MAX_LENGTH / 4];
    DWORD cbHash = 0;
    DWORD crc32 = -1;
    ALG_ID hashAlgo;

    if(Algorithm != UE_STATIC_HASH_CRC32)
    {
        if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, NULL))  //CRYPT_VERIFYCONTEXT
        {
            if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
            {
                return false;
            }
        }
        if(Algorithm == UE_STATIC_HASH_MD5)
        {
            hashAlgo = CALG_MD5;
        }
        else
        {
            hashAlgo = CALG_SHA;
        }
        if(!CryptCreateHash(hProv, hashAlgo, NULL, NULL, &hHash))
        {
            CryptReleaseContext(hProv, NULL);

            return false;
        }
        else
        {
            if(!CryptHashData(hHash, (const BYTE*)MemoryToHash, SizeOfMemory, NULL))
            {
                CryptReleaseContext(hProv, NULL);
                CryptDestroyHash(hHash);

                return false;
            }
        }
        if(Algorithm == UE_STATIC_HASH_MD5)
        {
            cbHash = MD5LEN;
            if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)&rgbHash[0], &cbHash, NULL))
            {
                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);

                return false;
            }
            else
            {
                rgbHash[0] = _byteswap_ulong(rgbHash[0]);
                rgbHash[1] = _byteswap_ulong(rgbHash[1]);
                rgbHash[2] = _byteswap_ulong(rgbHash[2]);
                rgbHash[3] = _byteswap_ulong(rgbHash[3]);

                __try
                {
                    if(OutputString)
                    {
                        wsprintfA((char*)HashDigest, "%08X%08X%08X%08X", rgbHash[0], rgbHash[1], rgbHash[2], rgbHash[3]);
                    }
                    else
                    {
                        RtlMoveMemory(HashDigest, &rgbHash[0], MD5LEN / 4);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    CryptDestroyHash(hHash);
                    CryptReleaseContext(hProv, NULL);

                    return false;
                }

                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);

                return true;
            }
        }
        else if(Algorithm == UE_STATIC_HASH_SHA1)
        {
            cbHash = SHA1LEN;
            if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)&rgbHash[0], &cbHash, NULL))
            {
                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);

                return false;
            }
            else
            {
                rgbHash[0] = _byteswap_ulong(rgbHash[0]);
                rgbHash[1] = _byteswap_ulong(rgbHash[1]);
                rgbHash[2] = _byteswap_ulong(rgbHash[2]);
                rgbHash[3] = _byteswap_ulong(rgbHash[3]);
                rgbHash[4] = _byteswap_ulong(rgbHash[4]);
                __try
                {
                    if(OutputString)
                    {
                        wsprintfA((char*)HashDigest, "%08X%08X%08X%08X%08X", rgbHash[0], rgbHash[1], rgbHash[2], rgbHash[3], rgbHash[4]);
                    }
                    else
                    {
                        RtlMoveMemory(HashDigest, &rgbHash[0], SHA1LEN / 4);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    CryptDestroyHash(hHash);
                    CryptReleaseContext(hProv, NULL);

                    return false;
                }

                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);

                return true;
            }
        }
    }
    else
    {
        EngineCrc32PartialCRC(&crc32, (unsigned char*)MemoryToHash, (unsigned long)SizeOfMemory);
        crc32 = crc32 ^ 0xFFFFFFFF;
        if(OutputString)
        {
            wsprintfA((char*)HashDigest, "%08X", crc32);
        }
        else
        {
            RtlMoveMemory(HashDigest, &crc32, sizeof crc32);
        }

        return true;
    }

    return false;
}

__declspec(dllexport) bool TITCALL StaticHashFile(char* szFileName, char* HashDigest, bool OutputString, int Algorithm)
{
    wchar_t uniFileName[MAX_PATH] = {};

    if(szFileName != NULL)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));

        return StaticHashFileW(uniFileName, HashDigest, OutputString, Algorithm);
    }
    else
    {
        return false;
    }
}

__declspec(dllexport) bool TITCALL StaticHashFileW(wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm)
{
#define MD5LEN 16
#define SHA1LEN 20
#define HASH_MAX_LENGTH 20

    bool bResult = true;
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    HANDLE hFile = NULL;
    BYTE rgbFile[1024];
    DWORD cbRead = 0;
    DWORD rgbHash[HASH_MAX_LENGTH / 4];
    DWORD cbHash = 0;
    DWORD crc32 = -1;
    ALG_ID hashAlgo;

    hFile = CreateFileW(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if(hFile == INVALID_HANDLE_VALUE || HashDigest == NULL)
    {
        return false;
    }
    if(Algorithm != UE_STATIC_HASH_CRC32)
    {
        if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, NULL))  //CRYPT_VERIFYCONTEXT
        {
            if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
            {
                CloseHandle(hFile);

                return false;
            }
        }
        if(Algorithm == UE_STATIC_HASH_MD5)
        {
            hashAlgo = CALG_MD5;
        }
        else
        {
            hashAlgo = CALG_SHA;
        }
        if(!CryptCreateHash(hProv, hashAlgo, NULL, NULL, &hHash))
        {
            CloseHandle(hFile);
            CryptReleaseContext(hProv, NULL);

            return false;
        }
        while(bResult)
        {
            if(!ReadFile(hFile, rgbFile, 1024, &cbRead, NULL))
            {
                bResult = false;
            }
            else if(cbRead == NULL)
            {
                break;
            }
            if(!CryptHashData(hHash, rgbFile, cbRead, NULL))
            {
                CryptReleaseContext(hProv, NULL);
                CryptDestroyHash(hHash);
                CloseHandle(hFile);

                return false;
            }
        }
        if(!bResult)
        {
            CryptReleaseContext(hProv, NULL);
            CryptDestroyHash(hHash);
            CloseHandle(hFile);

            return false;
        }
        if(Algorithm == UE_STATIC_HASH_MD5)
        {
            cbHash = MD5LEN;
            if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)&rgbHash[0], &cbHash, NULL))
            {
                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);
                CloseHandle(hFile);

                return false;
            }
            else
            {
                rgbHash[0] = _byteswap_ulong(rgbHash[0]);
                rgbHash[1] = _byteswap_ulong(rgbHash[1]);
                rgbHash[2] = _byteswap_ulong(rgbHash[2]);
                rgbHash[3] = _byteswap_ulong(rgbHash[3]);

                __try
                {
                    if(OutputString)
                    {
                        wsprintfA(HashDigest, "%08X%08X%08X%08X", rgbHash[0], rgbHash[1], rgbHash[2], rgbHash[3]);
                    }
                    else
                    {
                        RtlMoveMemory(HashDigest, &rgbHash[0], MD5LEN / 4);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    CryptDestroyHash(hHash);
                    CryptReleaseContext(hProv, NULL);
                    CloseHandle(hFile);

                    return false;
                }
                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);
                CloseHandle(hFile);

                return true;
            }
        }
        else if(Algorithm == UE_STATIC_HASH_SHA1)
        {
            cbHash = SHA1LEN;
            if(!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)&rgbHash[0], &cbHash, NULL))
            {
                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);
                CloseHandle(hFile);

                return false;
            }
            else
            {
                rgbHash[0] = _byteswap_ulong(rgbHash[0]);
                rgbHash[1] = _byteswap_ulong(rgbHash[1]);
                rgbHash[2] = _byteswap_ulong(rgbHash[2]);
                rgbHash[3] = _byteswap_ulong(rgbHash[3]);
                rgbHash[4] = _byteswap_ulong(rgbHash[4]);

                __try
                {
                    if(OutputString)
                    {
                        wsprintfA(HashDigest, "%08X%08X%08X%08X%08X", rgbHash[0], rgbHash[1], rgbHash[2], rgbHash[3], rgbHash[4]);
                    }
                    else
                    {
                        RtlMoveMemory(HashDigest, &rgbHash[0], SHA1LEN / 4);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    CryptDestroyHash(hHash);
                    CryptReleaseContext(hProv, NULL);
                    CloseHandle(hFile);

                    return false;
                }
                CryptDestroyHash(hHash);
                CryptReleaseContext(hProv, NULL);
                CloseHandle(hFile);

                return true;
            }
        }
    }
    else
    {
        while(bResult)
        {
            if(!ReadFile(hFile, rgbFile, 1024, &cbRead, NULL))
            {
                bResult = false;
            }
            else if(cbRead == NULL)
            {
                break;
            }

            EngineCrc32PartialCRC(&crc32, (unsigned char*)&rgbFile[0], cbRead);
        }
        crc32 = crc32 ^ 0xFFFFFFFF;
        if(OutputString)
        {
            wsprintfA(HashDigest, "%08X", crc32);
        }
        else
        {
            RtlMoveMemory(HashDigest, &crc32, sizeof crc32);
        }

        CloseHandle(hFile);

        return true;
    }

    CloseHandle(hFile);

    return false;
}


================================================
File: TitanEngine/TitanEngine.TLS.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Mapping.h"
#include "Global.Debugger.h"
#include "Global.TLS.h"

static bool engineBackupTLSx64 = false;
static IMAGE_TLS_DIRECTORY32 engineBackupTLSDataX86 = {};
static IMAGE_TLS_DIRECTORY64 engineBackupTLSDataX64 = {};
static DWORD engineBackupNumberOfCallBacks = NULL;
static std::vector<ULONG_PTR> engineBackupArrayOfCallBacks;
static DWORD engineBackupTLSAddress = NULL;

// TitanEngine.TLS.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack)
{
    ULONG_PTR* ReadArrayOfCallBacks = (ULONG_PTR*)ArrayOfCallBacks;

    if(NumberOfCallBacks && EngineIsValidReadPtrEx(ReadArrayOfCallBacks, sizeof(ULONG_PTR)*NumberOfCallBacks) && bpxCallBack)
    {
        ClearTlsCallBackList(); //clear TLS cb list
        for(unsigned int i = 0; i < NumberOfCallBacks; i++)
            tlsCallBackList.push_back(ReadArrayOfCallBacks[i]);
        engineTLSBreakOnCallBackAddress = (ULONG_PTR)bpxCallBack;
        engineTLSBreakOnCallBack = true;
        return true;
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSGrabCallBackData(char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks)
{
    wchar_t uniFileName[MAX_PATH] = {};
    if(szFileName)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return TLSGrabCallBackDataW(uniFileName, ArrayOfCallBacks, NumberOfCallBacks);
    }
    return false;
}
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks)
{
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            DWORD NumberOfTLSCallBacks = 0;
            PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            bool FileIs64;
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64) //x86
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader32->OptionalHeader.ImageBase + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                    PIMAGE_TLS_DIRECTORY32 TLSDirectoryX86 = (PIMAGE_TLS_DIRECTORY32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                    if(TLSDirectoryX86 && TLSDirectoryX86->AddressOfCallBacks != NULL)
                    {
                        ULONG_PTR TLSCompareData = 0;
                        ULONG_PTR TLSCallBackAddress = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryX86->AddressOfCallBacks, true);
                        if(TLSCallBackAddress)
                        {
                            while(memcmp((LPVOID)TLSCallBackAddress, &TLSCompareData, sizeof ULONG_PTR) != NULL)
                            {
                                if(ArrayOfCallBacks)
                                {
                                    RtlMoveMemory(ArrayOfCallBacks, (LPVOID)TLSCallBackAddress, sizeof ULONG_PTR);
                                    ArrayOfCallBacks = (LPVOID)((ULONG_PTR)ArrayOfCallBacks + sizeof ULONG_PTR);
                                }
                                TLSCallBackAddress = TLSCallBackAddress + sizeof ULONG_PTR;
                                NumberOfTLSCallBacks++;
                            }
                            if(NumberOfCallBacks)
                                *NumberOfCallBacks = NumberOfTLSCallBacks;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        else
                        {
                            if(NumberOfCallBacks)
                                *NumberOfCallBacks = 0;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return false;
                        }
                    }
                    else
                    {
                        if(NumberOfCallBacks)
                            *NumberOfCallBacks = 0;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    if(NumberOfCallBacks)
                        *NumberOfCallBacks = 0;
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
            else //x64
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader64->OptionalHeader.ImageBase + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                    PIMAGE_TLS_DIRECTORY64 TLSDirectoryX64 = (PIMAGE_TLS_DIRECTORY64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                    if(TLSDirectoryX64 && TLSDirectoryX64->AddressOfCallBacks != NULL)
                    {
                        ULONG_PTR TLSCompareData = NULL;
                        ULONG_PTR TLSCallBackAddress = (ULONG_PTR)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryX64->AddressOfCallBacks, true);
                        if(TLSCallBackAddress)
                        {
                            while(memcmp((LPVOID)TLSCallBackAddress, &TLSCompareData, sizeof ULONG_PTR) != NULL)
                            {
                                if(ArrayOfCallBacks)
                                {
                                    RtlMoveMemory(ArrayOfCallBacks, (LPVOID)TLSCallBackAddress, sizeof ULONG_PTR);
                                    ArrayOfCallBacks = (LPVOID)((ULONG_PTR)ArrayOfCallBacks + sizeof ULONG_PTR);
                                }
                                TLSCallBackAddress = TLSCallBackAddress + sizeof ULONG_PTR;
                                NumberOfTLSCallBacks++;
                            }
                            if(NumberOfCallBacks)
                                *NumberOfCallBacks = NumberOfTLSCallBacks;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        else
                        {
                            if(NumberOfCallBacks)
                                *NumberOfCallBacks = 0;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return false;
                        }
                    }
                    else
                    {
                        if(NumberOfCallBacks)
                            *NumberOfCallBacks = 0;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    if(NumberOfCallBacks)
                        *NumberOfCallBacks = 0;
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
        }
        else
        {
            if(NumberOfCallBacks)
                *NumberOfCallBacks = 0;
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(char* szFileName, LPVOID bpxCallBack)
{
    wchar_t uniFileName[MAX_PATH] = {};
    if(szFileName)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return TLSBreakOnCallBackExW(uniFileName, bpxCallBack);
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(wchar_t* szFileName, LPVOID bpxCallBack)
{
    DWORD NumberOfCallBacks;
    if(TLSGrabCallBackDataW(szFileName, NULL, &NumberOfCallBacks))
    {
        DynBuf TlsArrayOfCallBacks(NumberOfCallBacks * sizeof(ULONG_PTR));
        if(TLSGrabCallBackDataW(szFileName, TlsArrayOfCallBacks.GetPtr(), &NumberOfCallBacks))
        {
            return TLSBreakOnCallBack(TlsArrayOfCallBacks.GetPtr(), NumberOfCallBacks, bpxCallBack);
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSRemoveCallback(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};
    if(szFileName)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return TLSRemoveCallbackW(uniFileName);
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(wchar_t* szFileName)
{
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            bool FileIs64;
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    __try
                    {
                        ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader32->OptionalHeader.ImageBase + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                        PIMAGE_TLS_DIRECTORY32 TLSDirectoryX86 = (PIMAGE_TLS_DIRECTORY32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                        if(TLSDirectoryX86->AddressOfCallBacks != NULL)
                        {
                            TLSDirectoryX86->AddressOfCallBacks = NULL;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        else
                        {
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return false;
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
            else
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    __try
                    {
                        ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader64->OptionalHeader.ImageBase + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                        PIMAGE_TLS_DIRECTORY64 TLSDirectoryX64 = (PIMAGE_TLS_DIRECTORY64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                        if(TLSDirectoryX64->AddressOfCallBacks != NULL)
                        {
                            TLSDirectoryX64->AddressOfCallBacks = NULL;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        else
                        {
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return false;
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSRemoveTable(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};
    if(szFileName)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return TLSRemoveTableW(uniFileName);
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSRemoveTableW(wchar_t* szFileName)
{
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            bool FileIs64;
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64)
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    __try
                    {
                        ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader32->OptionalHeader.ImageBase + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                        PIMAGE_TLS_DIRECTORY32 TLSDirectoryX86 = (PIMAGE_TLS_DIRECTORY32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                        PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                        RtlZeroMemory(TLSDirectoryX86, sizeof IMAGE_TLS_DIRECTORY32);
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
            else
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    __try
                    {
                        ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader64->OptionalHeader.ImageBase + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                        PIMAGE_TLS_DIRECTORY64 TLSDirectoryX64 = (PIMAGE_TLS_DIRECTORY64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = NULL;
                        PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = NULL;
                        RtlZeroMemory(TLSDirectoryX64, sizeof IMAGE_TLS_DIRECTORY64);
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return true;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSBackupData(char* szFileName)
{
    wchar_t uniFileName[MAX_PATH] = {};
    if(szFileName)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return TLSBackupDataW(uniFileName);
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSBackupDataW(wchar_t* szFileName)
{
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    if(MapFileExW(szFileName, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, FileHandle, NULL, DOSHeader, true))
        {
            DWORD NumberOfTLSCallBacks = NULL;
            engineBackupTLSAddress = NULL;
            RtlZeroMemory(&engineBackupTLSDataX86, sizeof IMAGE_TLS_DIRECTORY32);
            RtlZeroMemory(&engineBackupTLSDataX64, sizeof IMAGE_TLS_DIRECTORY64);
            ClearTlsVector(&engineBackupArrayOfCallBacks); //clear backup array

            std::vector<ULONG_PTR>* ArrayOfCallBacks = &engineBackupArrayOfCallBacks;
            LPDWORD NumberOfCallBacks = &engineBackupNumberOfCallBacks;

            PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            bool FileIs64;
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                return false;
            }
            if(!FileIs64) //x86
            {
                if(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    __try
                    {
                        engineBackupTLSx64 = false;
                        engineBackupTLSAddress = PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                        ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader32->OptionalHeader.ImageBase + PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                        PIMAGE_TLS_DIRECTORY32 TLSDirectoryX86 = (PIMAGE_TLS_DIRECTORY32)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                        RtlMoveMemory(&engineBackupTLSDataX86, (LPVOID)TLSDirectoryX86, sizeof IMAGE_TLS_DIRECTORY32);
                        if(TLSDirectoryX86->AddressOfCallBacks != NULL)
                        {
                            ULONG_PTR TLSCompareData = 0;
                            ULONG_PTR* TLSCallBackAddress = (ULONG_PTR*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryX86->AddressOfCallBacks, true);
                            while(memcmp((LPVOID)TLSCallBackAddress, &TLSCompareData, sizeof ULONG_PTR) != NULL)
                            {
                                ArrayOfCallBacks->push_back(*TLSCallBackAddress);
                                TLSCallBackAddress++; //next callback
                                NumberOfTLSCallBacks++;
                            }
                            *NumberOfCallBacks = NumberOfTLSCallBacks;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        else
                        {
                            *NumberOfCallBacks = NULL;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return false;
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        *NumberOfCallBacks = NULL;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    *NumberOfCallBacks = NULL;
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
            else //x64
            {
                if(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress != NULL)
                {
                    __try
                    {
                        engineBackupTLSx64 = true;
                        engineBackupTLSAddress = PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
                        ULONG_PTR TLSDirectoryAddress = (ULONG_PTR)((ULONG_PTR)PEHeader64->OptionalHeader.ImageBase + PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
                        PIMAGE_TLS_DIRECTORY64 TLSDirectoryX64 = (PIMAGE_TLS_DIRECTORY64)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryAddress, true);
                        RtlMoveMemory(&engineBackupTLSDataX64, (LPVOID)TLSDirectoryX64, sizeof IMAGE_TLS_DIRECTORY64);
                        if(TLSDirectoryX64->AddressOfCallBacks != NULL)
                        {
                            ULONG_PTR TLSCompareData = 0;
                            ULONG_PTR* TLSCallBackAddress = (ULONG_PTR*)ConvertVAtoFileOffset(FileMapVA, (ULONG_PTR)TLSDirectoryX64->AddressOfCallBacks, true);
                            while(memcmp((LPVOID)TLSCallBackAddress, &TLSCompareData, sizeof ULONG_PTR) != NULL)
                            {
                                ArrayOfCallBacks->push_back(*TLSCallBackAddress);
                                TLSCallBackAddress++; //next callback
                                NumberOfTLSCallBacks++;
                            }
                            *NumberOfCallBacks = NumberOfTLSCallBacks;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return true;
                        }
                        else
                        {
                            *NumberOfCallBacks = NULL;
                            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                            return false;
                        }
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        *NumberOfCallBacks = NULL;
                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                        return false;
                    }
                }
                else
                {
                    *NumberOfCallBacks = NULL;
                    UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                    return false;
                }
            }
        }
        else
        {
            UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSRestoreData()
{
    ULONG_PTR ueNumberOfBytesRead = NULL;
    if(dbgProcessInformation.hProcess != NULL && engineBackupTLSAddress != NULL)
    {
        if(engineBackupTLSx64)
        {
            if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)(engineBackupTLSAddress + GetDebuggedFileBaseAddress()), &engineBackupTLSDataX64, sizeof IMAGE_TLS_DIRECTORY64, &ueNumberOfBytesRead))
            {
                if(engineBackupTLSDataX64.AddressOfCallBacks != NULL && engineBackupNumberOfCallBacks != NULL)
                {
                    DynBuf BackupData(sizeof(ULONG_PTR)*engineBackupArrayOfCallBacks.size());
                    ULONG_PTR* Backup = (ULONG_PTR*)BackupData.GetPtr();
                    for(unsigned int i = 0; i < engineBackupArrayOfCallBacks.size(); i++)
                        Backup[i] = engineBackupArrayOfCallBacks.at(i);
                    if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)(engineBackupTLSDataX64.AddressOfCallBacks + GetDebuggedFileBaseAddress()), Backup, BackupData.Size(), &ueNumberOfBytesRead))
                    {
                        engineBackupTLSAddress = NULL;
                        return true;
                    }
                }
                else
                {
                    engineBackupTLSAddress = NULL;
                    return true;
                }
            }
        }
        else
        {
            if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)(engineBackupTLSAddress + GetDebuggedFileBaseAddress()), &engineBackupTLSDataX86, sizeof IMAGE_TLS_DIRECTORY32, &ueNumberOfBytesRead))
            {
                if(engineBackupTLSDataX86.AddressOfCallBacks != NULL && engineBackupNumberOfCallBacks != NULL)
                {
                    DynBuf BackupData(sizeof(ULONG_PTR)*engineBackupArrayOfCallBacks.size());
                    ULONG_PTR* Backup = (ULONG_PTR*)BackupData.GetPtr();
                    for(unsigned int i = 0; i < engineBackupArrayOfCallBacks.size(); i++)
                        Backup[i] = engineBackupArrayOfCallBacks.at(i);
                    if(WriteProcessMemory(dbgProcessInformation.hProcess, (LPVOID)(engineBackupTLSDataX86.AddressOfCallBacks + GetDebuggedFileBaseAddress()), Backup, BackupData.Size(), &ueNumberOfBytesRead))
                    {
                        engineBackupTLSAddress = NULL;
                        return true;
                    }
                }
                else
                {
                    engineBackupTLSAddress = NULL;
                    return true;
                }
            }
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks)
{
    if(FileMapVA != NULL)
    {
        PIMAGE_DOS_HEADER DOSHeader = (PIMAGE_DOS_HEADER)FileMapVA;
        if(EngineValidateHeader(FileMapVA, NULL, NULL, DOSHeader, true))
        {
            PIMAGE_NT_HEADERS32 PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            PIMAGE_NT_HEADERS64 PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
            bool FileIs64;
            ULONG_PTR TLSWriteData = StorePlaceRVA;
            if(PEHeader32->OptionalHeader.Magic == 0x10B)
            {
                FileIs64 = false;
            }
            else if(PEHeader32->OptionalHeader.Magic == 0x20B)
            {
                FileIs64 = true;
            }
            else
            {
                return false;
            }
            if(!FileIs64)
            {
                __try
                {
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = (DWORD)StorePlaceRVA;
                    PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = sizeof IMAGE_TLS_DIRECTORY32;
                    PIMAGE_TLS_DIRECTORY32 TLSDirectoryX86 = (PIMAGE_TLS_DIRECTORY32)StorePlace;
                    TLSDirectoryX86->StartAddressOfRawData = (DWORD)TLSWriteData;
                    TLSDirectoryX86->EndAddressOfRawData = (DWORD)TLSWriteData + 0x10;
                    TLSDirectoryX86->AddressOfIndex = (DWORD)TLSWriteData + 0x14;
                    TLSDirectoryX86->AddressOfCallBacks = (DWORD)TLSWriteData  + sizeof IMAGE_TLS_DIRECTORY32 + 8;
                    RtlMoveMemory((LPVOID)(StorePlace + sizeof IMAGE_TLS_DIRECTORY32 + 8), ArrayOfCallBacks, NumberOfCallBacks * 4);
                    return true;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return false;
                }
            }
            else
            {
                __try
                {
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = (DWORD)StorePlaceRVA;
                    PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = sizeof IMAGE_TLS_DIRECTORY64;
                    PIMAGE_TLS_DIRECTORY64 TLSDirectoryX64 = (PIMAGE_TLS_DIRECTORY64)StorePlace;
                    TLSDirectoryX64->StartAddressOfRawData = TLSWriteData;
                    TLSDirectoryX64->EndAddressOfRawData = TLSWriteData + 0x20;
                    TLSDirectoryX64->AddressOfIndex = TLSWriteData + 0x28;
                    TLSDirectoryX64->AddressOfCallBacks = TLSWriteData  + sizeof IMAGE_TLS_DIRECTORY64 + 12;
                    RtlMoveMemory((LPVOID)(StorePlace + sizeof IMAGE_TLS_DIRECTORY64 + 12), ArrayOfCallBacks, NumberOfCallBacks * 8);
                    return true;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return false;
                }
            }
        }
        else
        {
            return false;
        }
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(char* szFileName, char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks)
{
    wchar_t uniFileName[MAX_PATH] = {};
    if(szFileName)
    {
        MultiByteToWideChar(CP_ACP, NULL, szFileName, lstrlenA(szFileName) + 1, uniFileName, sizeof(uniFileName) / (sizeof(uniFileName[0])));
        return TLSBuildNewTableExW(uniFileName, szSectionName, ArrayOfCallBacks, NumberOfCallBacks);
    }
    return false;
}

__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(wchar_t* szFileName, char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks)
{
    ULONG_PTR tlsImageBase = (ULONG_PTR)GetPE32DataW(szFileName, NULL, UE_IMAGEBASE);
    DWORD NewSectionVO = AddNewSectionW(szFileName, szSectionName, sizeof IMAGE_TLS_DIRECTORY64 * 2);
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;
    if(MapFileExW(szFileName, UE_ACCESS_ALL, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
    {
        DWORD NewSectionFO = (DWORD)ConvertVAtoFileOffset(FileMapVA, NewSectionVO + tlsImageBase, true);
        bool ReturnValue = false;
        if(NewSectionFO)
            ReturnValue = TLSBuildNewTable(FileMapVA, NewSectionFO, NewSectionVO, ArrayOfCallBacks, NumberOfCallBacks);
        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
        if(ReturnValue)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    return false;
}



================================================
File: TitanEngine/TitanEngine.Threader.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Handle.h"
#include "Global.Engine.h"
#include "Global.Threader.h"
#include "Global.Debugger.h"

void updateThreadList(THREAD_ITEM_DATA* NewThreadData)
{
    bool notInList = true;
    int count = (int)hListThread.size();

    for(int i = 0; i < count; i++)
    {
        if(hListThread.at(i).dwThreadId == NewThreadData->dwThreadId)
        {
            notInList = false;
            CloseHandle(NewThreadData->hThread); //handle not needed
            hListThread.at(i).BasePriority = NewThreadData->BasePriority;
            hListThread.at(i).ContextSwitches = NewThreadData->ContextSwitches;
            hListThread.at(i).Priority = NewThreadData->Priority;
            hListThread.at(i).TebAddress = NewThreadData->TebAddress;
            hListThread.at(i).ThreadStartAddress = NewThreadData->ThreadStartAddress;
            hListThread.at(i).WaitReason = NewThreadData->WaitReason;
            hListThread.at(i).WaitTime = NewThreadData->WaitTime;
            hListThread.at(i).ThreadState = NewThreadData->ThreadState;
            break;
        }
    }

    if(notInList)
    {
        hListThread.push_back(*NewThreadData);
    }
}

// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId)
{
    bool updateList = false;
    DWORD dwProcessId = 0;

    if(ProcessId == NULL && dbgProcessInformation.hProcess != NULL)
    {
        updateList = true;
        dwProcessId = GetProcessId(dbgProcessInformation.hProcess);
    }
    else if(ProcessId != NULL && dbgProcessInformation.hProcess != NULL)
    {
        updateList = true;
        dwProcessId = ProcessId;
    }
    else if(ProcessId != NULL && dbgProcessInformation.hProcess == NULL)
    {
        updateList = false;
        dwProcessId = ProcessId;
    }
    else if(ProcessId == NULL && dbgProcessInformation.hProcess == NULL)
    {
        return false;
    }

    if(updateList == false)
    {
        std::vector<THREAD_ITEM_DATA>().swap(hListThread); //clear thread list
    }


    THREAD_ITEM_DATA NewThreadData;
    ULONG retLength = 0;
    ULONG bufferLength = 1;
    PSYSTEM_PROCESS_INFORMATION pBuffer = (PSYSTEM_PROCESS_INFORMATION)malloc(bufferLength);
    PSYSTEM_PROCESS_INFORMATION pIter;
    PSYSTEM_THREAD_INFORMATION pIterThread;

    if(NtQuerySystemInformation(SystemProcessInformation, pBuffer, bufferLength, &retLength) == STATUS_INFO_LENGTH_MISMATCH)
    {
        free(pBuffer);
        bufferLength = retLength + sizeof(SYSTEM_PROCESS_INFORMATION);
        pBuffer = (PSYSTEM_PROCESS_INFORMATION)malloc(bufferLength);
        if(!pBuffer)
            return false;

        if(NtQuerySystemInformation(SystemProcessInformation, pBuffer, bufferLength, &retLength) != STATUS_SUCCESS)
        {
            return false;
        }
    }
    else
    {
        return false;
    }

    pIter = pBuffer;

    while(TRUE)
    {
        if(pIter->UniqueProcessId == (HANDLE)dwProcessId)
        {
            pIterThread = &pIter->Threads[0];
            for(ULONG i = 0; i < pIter->NumberOfThreads; i++)
            {
                ZeroMemory(&NewThreadData, sizeof(THREAD_ITEM_DATA));

                NewThreadData.BasePriority = pIterThread->BasePriority;
                NewThreadData.ContextSwitches = pIterThread->ContextSwitches;
                NewThreadData.Priority = pIterThread->Priority;
                NewThreadData.BasePriority = pIterThread->BasePriority;
                //NewThreadData.ThreadStartAddress = pIterThread->StartAddress; <- wrong value
                NewThreadData.ThreadState = pIterThread->ThreadState;
                NewThreadData.WaitReason = pIterThread->WaitReason;
                NewThreadData.WaitTime = pIterThread->WaitTime;
                NewThreadData.dwThreadId = (DWORD)pIterThread->ClientId.UniqueThread;

                NewThreadData.hThread = EngineOpenThread(THREAD_ALL_ACCESS, FALSE, NewThreadData.dwThreadId);
                if(NewThreadData.hThread)
                {
                    NewThreadData.TebAddress = GetTEBLocation(NewThreadData.hThread);

                    PVOID startAddress = 0;
                    if(NtQueryInformationThread(NewThreadData.hThread, ThreadQuerySetWin32StartAddress, &startAddress, sizeof(PVOID), NULL) == STATUS_SUCCESS)
                    {
                        NewThreadData.ThreadStartAddress = startAddress;
                    }
                }

                if(updateList == false)
                {
                    hListThread.push_back(NewThreadData);
                }
                else
                {
                    updateThreadList(&NewThreadData);
                }

                pIterThread++;
            }

            break;
        }

        if(pIter->NextEntryOffset == 0)
        {
            break;
        }
        else
        {
            pIter = (PSYSTEM_PROCESS_INFORMATION)((DWORD_PTR)pIter + (DWORD_PTR)pIter->NextEntryOffset);
        }
    }

    free(pBuffer);
    return (hListThread.size() > 0);
}

__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId)
{
    if(!hThread && !ThreadId)
        return NULL;
    static THREAD_ITEM_DATA ThreadData;
    memset(&ThreadData, 0, sizeof(THREAD_ITEM_DATA));
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
        if(hListThread.at(i).hThread == hThread || hListThread.at(i).dwThreadId == ThreadId)
        {
            memcpy(&ThreadData, &hListThread.at(i), sizeof(THREAD_ITEM_DATA));
            return &ThreadData;
        }
    return NULL;
}

__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack)
{
    typedef void(TITCALL * fEnumCallBack)(LPVOID fThreadDetail);
    fEnumCallBack myEnumCallBack = (fEnumCallBack)EnumCallBack;
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
    {
        __try
        {
            myEnumCallBack(&hListThread.at(i));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            break;
        }
    }
}

__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread)
{
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
        if(hListThread.at(i).hThread == hThread && SuspendThread(hThread) != -1)
            return true;
    return false;
}

__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread)
{
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
        if(hListThread.at(i).hThread == hThread && ResumeThread(hThread) != -1)
            return true;
    return false;
}

__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode)
{
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
        if(hListThread.at(i).hThread == hThread && TerminateThread(hThread, ThreadExitCode) != NULL)
        {
            hListThread.erase(hListThread.begin() + i);
            return true;
        }
    return false;
}

__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning)
{
    bool ret = true;
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
    {
        DWORD suspended;
        if(LeaveMainRunning && hListThread.at(i).hThread != dbgProcessInformation.hThread)
            suspended = SuspendThread(hListThread.at(i).hThread);
        else
            suspended = SuspendThread(hListThread.at(i).hThread);
        if(suspended == -1)
            ret = false;
    }
    return ret;
}

__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused)
{
    bool ret = true;
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
    {
        DWORD resumed;
        if(LeaveMainPaused && hListThread.at(i).hThread != dbgProcessInformation.hThread)
            resumed = ResumeThread(hListThread.at(i).hThread);
        else
            resumed = ResumeThread(hListThread.at(i).hThread);
        if(resumed == -1)
            ret = false;
    }
    return ret;
}

__declspec(dllexport) bool TITCALL ThreaderPauseProcess()
{
    return ThreaderPauseAllThreads(false);
}

__declspec(dllexport) bool TITCALL ThreaderResumeProcess()
{
    return ThreaderResumeAllThreads(false);
}

__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId)
{
    return ThreaderCreateRemoteThreadEx(dbgProcessInformation.hProcess, ThreadStartAddress, AutoCloseTheHandle, ThreadPassParameter, ThreadId);
}

__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize)
{
    return ThreaderInjectAndExecuteCodeEx(dbgProcessInformation.hProcess, InjectCode, StartDelta, InjectSize);
}

__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId)
{
    if(hProcess != NULL)
    {
        if(!AutoCloseTheHandle)
        {
            return (ULONG_PTR)CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)ThreadStartAddress, ThreadPassParameter, NULL, ThreadId);
        }
        else
        {
            HANDLE myThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)ThreadStartAddress, ThreadPassParameter, NULL, ThreadId);
            EngineCloseHandle(myThread);
            return NULL;
        }
    }
    return NULL;
}

__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize)
{
    if(hProcess != NULL)
    {
        LPVOID ThreadBase = VirtualAllocEx(hProcess, NULL, InjectSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        ULONG_PTR ueNumberOfBytesRead = 0;
        if(WriteProcessMemory(hProcess, ThreadBase, InjectCode, InjectSize, &ueNumberOfBytesRead))
        {
            ThreaderCreateRemoteThread((ULONG_PTR)((ULONG_PTR)InjectCode + StartDelta), true, NULL, NULL);
            return true;
        }
        else
            return false;
    }
    return false;
}

__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack)
{
    engineExitThreadOneShootCallBack = exitThreadCallBack;
}

__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread)
{
    CONTEXT myDBGContext;
    memset(&myDBGContext, 0, sizeof(CONTEXT));
    myDBGContext.ContextFlags = CONTEXT_ALL;
    return !!GetThreadContext(hThread, &myDBGContext);
}

__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread)
{
    if(SuspendThread(hThread)) //if previous suspend count is above 0 (which means thread is suspended)
    {
        ResumeThread(hThread); //decrement suspend count
        return false; //meaning the thread is not active
    }
    ResumeThread(hThread); //decrement suspend count
    return true;
}

__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive()
{
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
        if(ThreaderIsThreadActive(hListThread.at(i).hThread))
            return true;
    return false;
}

__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads()
{
    if(ThreaderPauseProcess())
    {
        engineResumeProcessIfNoThreadIsActive = true;
        return true;
    }
    return false;
}

__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId)
{
    int threadcount = (int)hListThread.size();
    for(int i = 0; i < threadcount; i++)
        if(hListThread.at(i).dwThreadId == ThreadId)
            return (ULONG_PTR)hListThread.at(i).hThread;
    return 0;
}

__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread()
{
    LPDEBUG_EVENT myDBGEvent = (LPDEBUG_EVENT)GetDebugData();

    return (myDBGEvent->dwThreadId == dbgProcessInformation.dwThreadId);
}



================================================
File: TitanEngine/TitanEngine.Tracer.cpp
================================================
#include "stdafx.h"
#include "definitions.h"
#include "Global.Engine.h"
#include "Global.Debugger.h"
#include "Global.Mapping.h"
#include "Global.Engine.Hash.h"
#include "Global.Injector.h"


// Global.Engine.Tracer.functions:
static ULONG_PTR EngineGlobalTracerHandler1(HANDLE hProcess, ULONG_PTR AddressToTrace, bool HashInstructions, DWORD InputNumberOfInstructions)
{

    SIZE_T memSize = 0;
    int NumberOfInstructions = 0;
    int LengthOfValidInstruction = 0;
    int CurrentNumberOfInstructions = 0;
    MEMORY_BASIC_INFORMATION MemInfo;
    DynBuf tracmem;
    LPVOID TraceMemory, cTraceMemory;
    ULONG_PTR ueNumberOfBytesRead = NULL;
    DWORD LastPushValue = NULL;
    ULONG_PTR TraceStartAddress;
    ULONG_PTR TraceTestAddress;
    ULONG_PTR TraceTestReadAddress;
    DWORD CurrentInstructionSize;
    PMEMORY_CMP_HANDLER CompareMemory;
    PMEMORY_COMPARE_HANDLER longCompareMemory;
    DWORD InstructionHash = NULL;
    bool FoundValidAPI = false;
    bool SkipThisInstruction = false;
    bool LoopCondition = true;
    bool SkipHashing = false;
    BYTE EmptyCall[5] = {0xE8, 0x00, 0x00, 0x00, 0x00};

    if(VirtualQueryEx(hProcess, (LPVOID)AddressToTrace, &MemInfo, sizeof MEMORY_BASIC_INFORMATION) != NULL)
    {
        if(MemInfo.RegionSize > NULL)
        {
            memSize = MemInfo.RegionSize;
            if(memSize > 0x4000)
            {
                memSize = 0x4000;
            }
            TraceMemory = tracmem.Allocate(memSize);
            cTraceMemory = TraceMemory;
            if(ReadProcessMemory(hProcess, (LPVOID)MemInfo.BaseAddress, TraceMemory, memSize, &ueNumberOfBytesRead))
            {
                TraceStartAddress = AddressToTrace - (ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)TraceMemory;
                if(HashInstructions && InputNumberOfInstructions > NULL)
                {
                    LoopCondition = true;
                }
                else
                {
                    LoopCondition = false;
                }

                while(LoopCondition)
                {
                    SkipHashing = false;
                    SkipThisInstruction = false;
                    CompareMemory = (PMEMORY_CMP_HANDLER)TraceStartAddress;
                    CurrentInstructionSize = StaticLengthDisassemble((LPVOID)TraceStartAddress);
                    CurrentNumberOfInstructions++;
                    /*
                        Long JUMP (0xE9)
                    */
                    if(HashInstructions == false && CompareMemory->DataByte[0] == 0xE9 && CurrentInstructionSize == 5)
                    {
                        TraceTestAddress = (ULONG_PTR)GetJumpDestination(NULL, TraceStartAddress) - (ULONG_PTR)TraceMemory + (ULONG_PTR)MemInfo.BaseAddress;
                        if(TraceTestAddress <= (ULONG_PTR)MemInfo.BaseAddress || TraceTestAddress >= (ULONG_PTR)MemInfo.BaseAddress + MemInfo.RegionSize)
                        {
                            if(LengthOfValidInstruction == NULL)
                            {
                                if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress) != NULL)
                                {
                                    FoundValidAPI = true;
                                    break;
                                }
                            }
                            if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress) != NULL)
                            {
                                FoundValidAPI = true;
                                break;
                            }
                            else
                            {
                                if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress - LengthOfValidInstruction) != NULL)
                                {
                                    FoundValidAPI = true;
                                    TraceTestAddress = TraceTestAddress - LengthOfValidInstruction;
                                    break;
                                }
                            }
                        }
                        /*
                            Near JUMP (0xFF25)
                        */
                    }
                    else if(HashInstructions == false && CompareMemory->DataByte[0] == 0xFF && CompareMemory->DataByte[1] == 0x25 && CurrentInstructionSize == 6)
                    {
                        TraceTestAddress = (ULONG_PTR)GetJumpDestination(NULL, TraceStartAddress);
                        if(ReadProcessMemory(hProcess, (LPVOID)TraceTestAddress, &TraceTestAddress, 4, &ueNumberOfBytesRead))
                        {
                            if(TraceTestAddress <= (ULONG_PTR)MemInfo.BaseAddress || TraceTestAddress >= (ULONG_PTR)MemInfo.BaseAddress + MemInfo.RegionSize)
                            {
                                if(LengthOfValidInstruction == NULL)
                                {
                                    if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress) != NULL)
                                    {
                                        FoundValidAPI = true;
                                        break;
                                    }
                                }
                                if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress) != NULL)
                                {
                                    FoundValidAPI = true;
                                    break;
                                }
                                else
                                {
                                    if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress - LengthOfValidInstruction) != NULL)
                                    {
                                        FoundValidAPI = true;
                                        TraceTestAddress = TraceTestAddress - LengthOfValidInstruction;
                                        break;
                                    }
                                }
                            }
                        }
                        /*
                            PUSH then RET (0x68 ???????? 0xC3)
                        */
                    }
                    else if(HashInstructions == false && CompareMemory->DataByte[0] == 0x68 && CompareMemory->DataByte[5] == 0xC3 && CurrentInstructionSize == 5)
                    {
                        longCompareMemory = (PMEMORY_COMPARE_HANDLER)((ULONG_PTR)CompareMemory + 1);
                        TraceTestAddress = (DWORD)(longCompareMemory->Array.dwArrayEntry[0]);
                        if(ReadProcessMemory(hProcess, (LPVOID)TraceTestAddress, &TraceTestReadAddress, 4, &ueNumberOfBytesRead))
                        {
                            if(TraceTestAddress <= (ULONG_PTR)MemInfo.BaseAddress || TraceTestAddress >= (ULONG_PTR)MemInfo.BaseAddress + MemInfo.RegionSize)
                            {
                                if(LengthOfValidInstruction == NULL)
                                {
                                    if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress) != NULL)
                                    {
                                        FoundValidAPI = true;
                                        break;
                                    }
                                }
                                if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress) != NULL)
                                {
                                    FoundValidAPI = true;
                                    break;
                                }
                                else
                                {
                                    if(ImporterGetAPINameFromDebugee(hProcess, TraceTestAddress - LengthOfValidInstruction) != NULL)
                                    {
                                        FoundValidAPI = true;
                                        TraceTestAddress = TraceTestAddress - LengthOfValidInstruction;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                TraceStartAddress = TraceStartAddress - (ULONG_PTR)MemInfo.BaseAddress + (ULONG_PTR)TraceMemory;
                            }
                        }
                        /*
                            CALL (0xE8)
                        */
                    }
                    else if(HashInstructions == true && CompareMemory->DataByte[0] == 0xE8 && CurrentInstructionSize == 5)
                    {
                        SkipHashing = true;
                        InstructionHash = EngineHashMemory((char*)&EmptyCall, CurrentInstructionSize, InstructionHash);
                        /*
                            PUSH (0x68)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0x68 && CurrentInstructionSize == 5)
                    {
                        LastPushValue = (DWORD)(CompareMemory->DataByte[1] + CompareMemory->DataByte[2] * 0x1000 + CompareMemory->DataByte[3] * 0x100000 + CompareMemory->DataByte[4] * 0x10000000);
                        /*
                            ADD BYTE PTR[AL],AL (0x00, 0x00) -> End of page!
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0x00 && CurrentInstructionSize == 2)
                    {
                        FoundValidAPI = false;
                        break;
                        /*
                            RET (0xC3)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xC3 && CurrentInstructionSize == 1)
                    {
                        NumberOfInstructions++;
                        break;
                        /*
                            RET (0xC2)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xC2 && CurrentInstructionSize == 3)
                    {
                        NumberOfInstructions++;
                        break;
                        /*
                            Short JUMP (0xEB)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xEB && CurrentInstructionSize == 2)
                    {
                        TraceStartAddress = TraceStartAddress + CompareMemory->DataByte[1];
                        SkipThisInstruction = true;
                        /*
                            CLC (0xF8)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xF8 && CurrentInstructionSize == 1)
                    {
                        SkipThisInstruction = true;
                        /*
                            STC (0xF9)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xF9 && CurrentInstructionSize == 1)
                    {
                        SkipThisInstruction = true;
                        /*
                            NOP (0x90)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0x90 && CurrentInstructionSize == 1)
                    {
                        SkipThisInstruction = true;
                        /*
                            FNOP (0xD9 0xD0)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xD9 && CompareMemory->DataByte[1] == 0xD0 && CurrentInstructionSize == 2)
                    {
                        SkipThisInstruction = true;
                        /*
                            Multiple MOV
                        */
                    }
                    else if(CompareMemory->DataByte[0] >= 0x8A && CompareMemory->DataByte[0] <= 0x8B)
                    {
                        /*
                            MOV EAX,EAX (0x8B 0xC8)
                        */
                        if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xC8 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV EBX,EBX (0x8B 0xC9)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xC9 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                        MOV ECX,ECX (0x8B 0xDB)
                        */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xDB && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            MOV (0x8B 0xED)
                           */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xED && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;

                        }
                        /*
                                MOV (0x8B 0xF6)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xF6 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                        MOV (0x8B 0xE4)
                        */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xE4 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                        MOV EDX,EDX (0x8B 0xD2)
                        */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xD2 && CurrentNumberOfInstructions != 1 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV EDI,EDI (0x8B 0xFF)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xFF && CurrentNumberOfInstructions != 1 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV AL,AL (0x8A 0xC0)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xC0 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV BL,BL (0x8A 0xDB)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xDB && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV CL,CL (0x8A 0xC9)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xC9 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            MOV (0x8A 0xD2)
                           */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xD2 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV (0x8A 0xE4)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xE4 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            MOV (0x8A 0xED)
                           */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xED && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV (0x8A 0xFF)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xFF && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV (0x8A 0xF6)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8A && CompareMemory->DataByte[1] == 0xF6 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            MOV AX,AX (0x8B 0xC0)
                           */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xC0 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            MOV (0x8B 0xDB)
                           */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xDB && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV (0x8B 0xC9)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xC9 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                                MOV (0x8B 0xF6)
                            */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xF6 && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            MOV (0x8B 0xED)
                           */
                        else if(CompareMemory->DataByte[0] == 0x8B && CompareMemory->DataByte[1] == 0xED && CurrentInstructionSize == 2)
                        {
                            SkipThisInstruction = true;
                        }
                    }
                    /*
                            RDTSC (0x0F 0x31)
                        */
                    else if(CompareMemory->DataByte[0] == 0x0F && CompareMemory->DataByte[1] == 0x31 && CurrentInstructionSize == 2)
                    {
                        SkipThisInstruction = true;
                        /*
                            CPUID (0x0F 0xA2)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0x0F && CompareMemory->DataByte[1] == 0xA2 && CurrentInstructionSize == 2)
                    {
                        SkipThisInstruction = true;
                        /*
                            XCHG EAX,EAX (0x87 0xC0)
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0x87 && CompareMemory->DataByte[1] == 0xC0 && CurrentInstructionSize == 2)
                    {
                        SkipThisInstruction = true;
                        /*
                            SHL EAX,0 - SHL EDI,0 && SHR EAX,0 - SHR EDI,0
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xC1 && CurrentInstructionSize == 3)
                    {
                        if(CompareMemory->DataByte[1] >= 0xE0 && CompareMemory->DataByte[1] <= 0xEF && CompareMemory->DataByte[2] == 0x00)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            ROR EAX,0 - ROR EDI,0 && ROL EAX,0 - ROL EDI,0
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0xC1 && CurrentInstructionSize == 3)
                    {
                        if(CompareMemory->DataByte[1] >= 0xC0 && CompareMemory->DataByte[1] <= 0xCF && CompareMemory->DataByte[2] == 0x00)
                        {
                            SkipThisInstruction = true;
                        }
                        /*
                            LEA EAX,DWORD PTR[EAX] -> LEA EDI,DWORD PTR[EDI]
                        */
                    }
                    else if(CompareMemory->DataByte[0] == 0x8D && CurrentInstructionSize == 2)
                    {
                        if(CompareMemory->DataByte[1] == 0x00 || CompareMemory->DataByte[1] == 0x09 || CompareMemory->DataByte[1] == 0x1B || CompareMemory->DataByte[1] == 0x12)
                        {
                            SkipThisInstruction = true;
                        }
                        if(CompareMemory->DataByte[1] == 0x36 || CompareMemory->DataByte[1] == 0x3F)
                        {
                            SkipThisInstruction = true;
                        }
                        if(CompareMemory->DataByte[1] == 0x6D && CompareMemory->DataByte[2] == 0x00)
                        {
                            SkipThisInstruction = true;
                        }
                    }
                    if(!SkipThisInstruction)
                    {
                        if(HashInstructions == true && SkipHashing == false)
                        {
                            InstructionHash = EngineHashMemory((char*)TraceStartAddress, CurrentInstructionSize, InstructionHash);
                        }
                        LengthOfValidInstruction = LengthOfValidInstruction + CurrentInstructionSize;
                        NumberOfInstructions++;
                    }
                    if(HashInstructions)
                    {
                        InputNumberOfInstructions--;
                        if(InputNumberOfInstructions > NULL)
                        {
                            LoopCondition = true;
                        }
                        else
                        {
                            LoopCondition = false;
                        }
                    }
                    else
                    {
                        if(CurrentNumberOfInstructions < 1000 && FoundValidAPI == false)
                        {
                            LoopCondition = true;
                        }
                        else
                        {
                            LoopCondition = false;
                        }
                    }
                    TraceStartAddress = TraceStartAddress + CurrentInstructionSize;
                }
                if(!HashInstructions)
                {
                    if(FoundValidAPI == true)
                    {
                        return((ULONG_PTR)TraceTestAddress);
                    }
                    else if(CurrentNumberOfInstructions < 1000)
                    {
                        if(ImporterGetAPINameFromDebugee(hProcess, LastPushValue) != NULL)
                        {
                            return((ULONG_PTR)LastPushValue);
                        }
                        else if(ImporterGetAPINameFromDebugee(hProcess, LastPushValue - LengthOfValidInstruction) != NULL)
                        {
                            return((ULONG_PTR)(LastPushValue - LengthOfValidInstruction));
                        }
                        return((DWORD)NumberOfInstructions);
                    }
                }
                else
                {
                    return((DWORD)InstructionHash);
                }
            }
            else
            {
            }
        }
    }
    return(NULL);
}

// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit()
{
    return;     // UE 1.5 compatibility mode
}

__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace)
{
    return((ULONG_PTR)EngineGlobalTracerHandler1(hProcess, AddressToTrace, false, NULL));
}

__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions)
{

    unsigned int i = 0;
    unsigned int j = 0;
    DWORD Dummy = NULL;
    MODULEINFO RemoteModuleInfo;
    ULONG_PTR EnumeratedModules[0x2000] = {0};
    ULONG_PTR LoadedModules[1000][4] = {0};
    char RemoteDLLName[MAX_PATH];
    HANDLE hLoadedModule = NULL;
    HANDLE ModuleHandle = NULL;
    PIMAGE_DOS_HEADER DOSHeader;
    PIMAGE_NT_HEADERS32 PEHeader32;
    PIMAGE_NT_HEADERS64 PEHeader64;
    PIMAGE_EXPORT_DIRECTORY PEExports;
    PEXPORTED_DATA ExportedFunctions;
    ULONG_PTR APIFoundAddress = NULL;
    bool ValidateHeader = false;
    bool FileIs64 = false;
    bool FoundAPI = false;
    DWORD CompareHash = NULL;
    DWORD TestHash = NULL;

    if(InputNumberOfInstructions > NULL)
    {
        CompareHash = (DWORD)EngineGlobalTracerHandler1(hProcess, AddressToTrace, true, InputNumberOfInstructions);
    }
    else
    {
        InputNumberOfInstructions = (DWORD)TracerLevel1(hProcess, AddressToTrace);
        if(InputNumberOfInstructions < 1000)
        {
            CompareHash = (DWORD)EngineGlobalTracerHandler1(hProcess, AddressToTrace, true, InputNumberOfInstructions);
        }
        else
        {
            return(NULL);
        }
    }

    if(hProcess == NULL)
    {
        if(dbgProcessInformation.hProcess == NULL)
        {
            hProcess = GetCurrentProcess();
        }
        else
        {
            hProcess = dbgProcessInformation.hProcess;
        }
    }
    if(EnumProcessModules(hProcess, (HMODULE*)EnumeratedModules, sizeof(EnumeratedModules), &Dummy))
    {
        i++;
        while(FoundAPI == false && EnumeratedModules[i] != NULL)
        {
            ValidateHeader = false;
            RtlZeroMemory(&RemoteDLLName, MAX_PATH);
            GetModuleFileNameExA(hProcess, (HMODULE)EnumeratedModules[i], (LPSTR)RemoteDLLName, MAX_PATH);
            if(GetModuleHandleA(RemoteDLLName) == NULL)
            {
                RtlZeroMemory(&RemoteDLLName, MAX_PATH);
                GetModuleBaseNameA(hProcess, (HMODULE)EnumeratedModules[i], (LPSTR)RemoteDLLName, MAX_PATH);
                if(GetModuleHandleA(RemoteDLLName) == NULL)
                {
                    if(engineAlowModuleLoading)
                    {
                        hLoadedModule = LoadLibraryA(RemoteDLLName);
                        if(hLoadedModule != NULL)
                        {
                            LoadedModules[i][0] = EnumeratedModules[i];
                            LoadedModules[i][1] = (ULONG_PTR)hLoadedModule;
                            LoadedModules[i][2] = 1;
                        }
                    }
                    else
                    {
                        hLoadedModule = (HANDLE)EngineSimulateDllLoader(hProcess, RemoteDLLName);
                        if(hLoadedModule != NULL)
                        {
                            LoadedModules[i][0] = EnumeratedModules[i];
                            LoadedModules[i][1] = (ULONG_PTR)hLoadedModule;
                            LoadedModules[i][2] = 1;
                            ValidateHeader = true;
                        }
                    }
                }
                else
                {
                    LoadedModules[i][0] = EnumeratedModules[i];
                    LoadedModules[i][1] = (ULONG_PTR)GetModuleHandleA(RemoteDLLName);
                    LoadedModules[i][2] = 0;
                }
            }
            else
            {
                LoadedModules[i][0] = EnumeratedModules[i];
                LoadedModules[i][1] = (ULONG_PTR)GetModuleHandleA(RemoteDLLName);
                LoadedModules[i][2] = 0;
            }

            if(!FoundAPI)
            {
                DOSHeader = (PIMAGE_DOS_HEADER)LoadedModules[i][1];
                RtlZeroMemory(&RemoteModuleInfo, sizeof MODULEINFO);
                GetModuleInformation(hProcess, (HMODULE)LoadedModules[i][1], &RemoteModuleInfo, sizeof MODULEINFO);
                if(ValidateHeader || EngineValidateHeader((ULONG_PTR)LoadedModules[i][1], hProcess, RemoteModuleInfo.lpBaseOfDll, DOSHeader, false))
                {
                    PEHeader32 = (PIMAGE_NT_HEADERS32)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                    PEHeader64 = (PIMAGE_NT_HEADERS64)((ULONG_PTR)DOSHeader + DOSHeader->e_lfanew);
                    if(PEHeader32->OptionalHeader.Magic == 0x10B)
                    {
                        FileIs64 = false;
                    }
                    else if(PEHeader32->OptionalHeader.Magic == 0x20B)
                    {
                        FileIs64 = true;
                    }
                    else
                    {
                        return(NULL);
                    }
                    if(!FileIs64)
                    {
                        PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                        ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                    }
                    else
                    {
                        PEExports = (PIMAGE_EXPORT_DIRECTORY)(PEHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + LoadedModules[i][1]);
                        ExportedFunctions = (PEXPORTED_DATA)(PEExports->AddressOfFunctions + LoadedModules[i][1]);
                    }
                    for(j = 0; j < PEExports->NumberOfFunctions; j++)
                    {
                        TestHash = (DWORD)EngineGlobalTracerHandler1(hProcess, (ULONG_PTR)(ExportedFunctions->ExportedItem + LoadedModules[i][1]), true, InputNumberOfInstructions);
                        if(TestHash == CompareHash)
                        {
                            APIFoundAddress = (ULONG_PTR)(ExportedFunctions->ExportedItem + LoadedModules[i][0]);
                            FoundAPI = true;
                        }
                        ExportedFunctions = (PEXPORTED_DATA)((ULONG_PTR)ExportedFunctions + 4);
                    }
                }
            }
            i++;
        }
        i = 1;
        while(EnumeratedModules[i] != NULL)
        {
            if(engineAlowModuleLoading)
            {
                if(LoadedModules[i][2] == 1)
                {
                    FreeLibrary((HMODULE)LoadedModules[i][1]);
                }
            }
            else
            {
                if(LoadedModules[i][2] == 1)
                {
                    VirtualFree((void*)LoadedModules[i][1], NULL, MEM_RELEASE);
                }
            }
            i++;
        }
    }
    return((ULONG_PTR)APIFoundAddress);
}
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace)
{

    int i, j;
    MEMORY_BASIC_INFORMATION MemInfo;
    DWORD KnownRedirectionIndex = NULL;
    ULONG_PTR ueNumberOfBytesRead = NULL;
    PMEMORY_CMP_HANDLER cMem;
    DWORD MemoryHash = NULL;
    DWORD MaximumReadSize = 0;
    DWORD TestAddressX86;
    DynBuf tracemem;
    LPVOID TraceMemory;
    bool HashCheck = false;

    VirtualQueryEx(hProcess, (LPVOID)AddressToTrace, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
    if(MemInfo.RegionSize > NULL)
    {
        MaximumReadSize = (DWORD)((ULONG_PTR)MemInfo.AllocationBase + MemInfo.RegionSize - AddressToTrace);
        if(MaximumReadSize > 0x1000)
        {
            MaximumReadSize = 0x1000;
            HashCheck = true;
        }
        else if(MaximumReadSize > 256)
        {
            HashCheck = true;
        }
        if(sizeof HANDLE == 4)
        {
            TraceMemory = tracemem.Allocate(MaximumReadSize);
            if(!TraceMemory)
            {
                return (NULL);
            }
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TraceMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                cMem = (PMEMORY_CMP_HANDLER)TraceMemory;
                if(cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x01 && ((cMem->DataByte[3] >= 0x50 && cMem->DataByte[3] <= 0x5F) || cMem->DataByte[3] == 0x6A || cMem->DataByte[3] == 0x68))
                {
                    KnownRedirectionIndex = NULL;               // ; PeX 0.99 fail safe!
                }
                else if(cMem->DataByte[0] == 0x68 && cMem->DataByte[5] == 0x81 && cMem->DataByte[12] == 0xC3)
                {
                    KnownRedirectionIndex = 1;                  //  ; RLP 0.7.4 & CryptoPeProtector 0.9.x & ACProtect
                    /*  ;$ ==>    >  68 904B4013     PUSH 13404B90
                        ;$+5      >  812C24 0A9E589B SUB DWORD PTR SS:[ESP],9B589E0A
                        ;$+C      >  C3              RET
                        ;$+D      >  68 E21554DF     PUSH DF5415E2
                        ;$+12     >  813424 B6DCB2A8 XOR DWORD PTR SS:[ESP],A8B2DCB6
                        ;$+19     >  C3              RET
                        ;$+1A     >  68 34B2C6B1     PUSH B1C6B234
                        ;$+1F     >  810424 4A2C21C6 ADD DWORD PTR SS:[ESP],C6212C4A
                        ;$+26     >  C3              RET */
                }
                else if(cMem->DataByte[0] == 0xFF && cMem->DataByte[1] == 0x25)
                {
                    KnownRedirectionIndex = 2;                  //  ; tELock 0.80 - 0.85
                    //  ;$ ==>    >- FF25 48018E00   JMP NEAR DWORD PTR DS:[8E0148]
                }
                else if((cMem->DataByte[0] == 0xFF && cMem->DataByte[1] == 0x35) || (cMem->DataByte[1] == 0xFF && cMem->DataByte[2] == 0x35) && (cMem->DataByte[8] == 0xC3 || cMem->DataByte[9] == 0xC3))
                {
                    KnownRedirectionIndex = 3;                  //  ; tELock 0.90 - 0.95
                    /*  ;$ ==>    >  FF35 AE018E00   PUSH DWORD PTR DS:[8E01AE]               ; kernel32.InitializeCriticalSection
                        ;$+6      >  A8 C3           TEST AL,0C3
                        ;$+8      >  C3              RET
                        ;$+9      >  F9              STC
                        ;$+A      >  FF35 B2018E00   PUSH DWORD PTR DS:[8E01B2]               ; kernel32.VirtualFree
                        ;$+10     >  80FA C3         CMP DL,0C3
                        ;$+13     >  C3              RET */
                }
                else if(cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x01 && cMem->DataByte[2] == 0xC9 && cMem->DataByte[3] == 0x60 && cMem->DataByte[4] == 0x0F && cMem->DataByte[5] == 0x31)
                {
                    KnownRedirectionIndex = 8;                  //  ; AlexProtector 1.x
                    /*  ;$ ==>    > /EB 01           JMP SHORT 008413F9
                        ;$+2      > |C9              LEAVE
                        ;$+3      > \60              PUSHAD
                        ;$+4      >  0F31            RDTSC
                        ;$+6      >  EB 01           JMP SHORT 008413FF
                        ;$+8      >  C9              LEAVE
                        ;$+9      >  8BD8            MOV EBX,EAX
                        ;$+B      >  EB 01           JMP SHORT 00841404
                        ;...
                        ;$+33     >  68 E9B9D477     PUSH USER32.PostQuitMessage
                        ;$+38     >  EB 01           JMP SHORT 00841431
                        ;$+3A     >- E9 C3EB01E9     JMP E985FFF8 */
                }
                else if((cMem->DataByte[0] == 0x0B && cMem->DataByte[1] == 0xC5) || (cMem->DataByte[0] == 0x05 && cMem->DataByte[5] == 0xB8 && cMem->DataByte[10] == 0xEB && cMem->DataByte[11] == 0x02))
                {
                    KnownRedirectionIndex = 5;                  //  ; tELock 0.99 - 1.0 Private!
                    /*  ;008E0122    05 F9DEBE71     ADD EAX,71BEDEF9
                        ;008E0127    B8 28018E00     MOV EAX,8E0128
                        ;008E012C    EB 02           JMP SHORT 008E0130
                        ;008E012E    CD 20           INT 20
                        ;008E0130    05 18000000     ADD EAX,18
                        ;008E0135    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;008E0137    35 22018E00     XOR EAX,8E0122
                        ;008E013C    90              NOP
                        ;008E013D    90              NOP
                        ;008E013E    50              PUSH EAX
                        ;008E013F    C3              RET
                        ;
                        ;00850036    13C4            ADC EAX,ESP
                        ;00850038    E8 0A000000     CALL 00850047
                        ;0085003D    90              NOP
                        ;0085003E    1BC2            SBB EAX,EDX
                        ;00850040    E9 09000000     JMP 0085004E
                        ;00850045    1BC3            SBB EAX,EBX
                        ;00850047    83F8 74         CMP EAX,74
                        ;0085004A    C3              RET
                        ;0085004B    98              CWDE
                        ;0085004C    33C7            XOR EAX,EDI
                        ;0085004E    D6              SALC
                        ;0085004F    B8 50008500     MOV EAX,850050
                        ;00850054    EB 02           JMP SHORT 00850058
                        ;00850056    CD 20           INT 20
                        ;00850058    05 18000000     ADD EAX,18
                        ;0085005D    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;0085005F    35 36008500     XOR EAX,850036
                        ;00850064    90              NOP
                        ;00850065    90              NOP
                        ;00850066    50              PUSH EAX
                        ;00850067    C3              RET */
                }
                else if((cMem->DataByte[0] == 0x13 && cMem->DataByte[1] == 0xC4 && cMem->DataByte[2] == 0xE8) || (cMem->DataByte[0] == 0x83 && cMem->DataByte[3] == 0xE8))
                {
                    KnownRedirectionIndex = 5;                  //  ; tELock 0.99 - 1.0 Private!
                }
                else if((cMem->DataByte[0] == 0xB8 || cMem->DataByte[0] == 0x1D || cMem->DataByte[0] == 0x0D || cMem->DataByte[0] == 0x2D) && cMem->DataByte[5] == 0xB8 && cMem->DataByte[10] == 0xEB && cMem->DataByte[11] == 0x02)
                {
                    KnownRedirectionIndex = 5;                  //  ; tELock 0.99 - 1.0 Private!
                    /*  ;011F0000    B8 2107F205     MOV EAX,5F20721
                        ;011F0005    B8 06008D00     MOV EAX,8D0006
                        ;011F000A    EB 02           JMP SHORT 011F000E
                        ;011F000C    CD 20           INT 20
                        ;011F000E    05 18000000     ADD EAX,18
                        ;011F0013    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;011F0015    35 00008D00     XOR EAX,8D0000
                        ;011F001A    90              NOP
                        ;011F001B    90              NOP
                        ;011F001C    50              PUSH EAX
                        ;011F001D    C3              RET
                        ;
                        ;01360000    1D A508F205     SBB EAX,5F208A5
                        ;01360005    B8 28008D00     MOV EAX,8D0028
                        ;0136000A    EB 02           JMP SHORT 0136000E
                        ;0136000C    CD 20           INT 20
                        ;0136000E    05 18000000     ADD EAX,18
                        ;01360013    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;01360015    35 22008D00     XOR EAX,8D0022
                        ;0136001A    90              NOP
                        ;0136001B    90              NOP
                        ;0136001C    50              PUSH EAX
                        ;0136001D    C3              RET
                        ;
                        ;014B0000    0D F918F205     OR EAX,5F218F9
                        ;014B0005    B8 4A008D00     MOV EAX,8D004A
                        ;014B000A    EB 02           JMP SHORT 014B000E
                        ;014B000C    CD 20           INT 20
                        ;014B000E    05 18000000     ADD EAX,18
                        ;014B0013    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;014B0015    35 44008D00     XOR EAX,8D0044
                        ;014B001A    90              NOP
                        ;014B001B    90              NOP
                        ;014B001C    50              PUSH EAX
                        ;014B001D    C3              RET
                        ;
                        ;01750000    2D 0B37F205     SUB EAX,5F2370B
                        ;01750005    B8 8E008D00     MOV EAX,8D008E
                        ;0175000A    EB 02           JMP SHORT 0175000E
                        ;0175000C    CD 20           INT 20
                        ;0175000E    05 18000000     ADD EAX,18
                        ;01750013    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;01750015    35 88008D00     XOR EAX,8D0088
                        ;0175001A    90              NOP
                        ;0175001B    90              NOP
                        ;0175001C    50              PUSH EAX
                        ;0175001D    C3              RET
                        ;
                        ;019F0000    0BC4            OR EAX,ESP
                        ;019F0002    F9              STC
                        ;019F0003    E8 0B000000     CALL 019F0013
                        ;019F0008    90              NOP
                        ;019F0009    13C4            ADC EAX,ESP
                        ;019F000B    E9 0A000000     JMP 019F001A
                        ;019F0010    F9              STC
                        ;019F0011    13C3            ADC EAX,EBX
                        ;019F0013    98              CWDE
                        ;019F0014    03C2            ADD EAX,EDX
                        ;019F0016    C3              RET
                        ;
                        ;01B40000    48              DEC EAX
                        ;01B40001    E8 0D000000     CALL 01B40013
                        ;01B40006    03C5            ADD EAX,EBP
                        ;01B40008    FC              CLD
                        ;01B40009    E9 0A000000     JMP 01B40018
                        ;01B4000E    35 D82FF205     XOR EAX,5F22FD8
                        ;01B40013    C1C8 9A         ROR EAX,9A
                        ;01B40016    C3              RET */
                }
                else if((cMem->DataByte[0] == 0x0B && cMem->DataByte[1] == 0xC4 && cMem->DataByte[2] == 0xF9 && cMem->DataByte[3] == 0xE8) || (cMem->DataByte[0] == 0x48 && cMem->DataByte[1] == 0xE8))
                {
                    KnownRedirectionIndex = 5;                  //  ; tELock 0.99 - 1.0 Private!
                }
                else if((cMem->DataByte[0] == 0xB8 && cMem->DataByte[5] == 0xE8 && cMem->DataByte[10] == 0xF9 && cMem->DataByte[11] == 0xE9) && (cMem->DataByte[0] == 0xE8 && cMem->DataByte[1] == 0x0B && cMem->DataByte[10] == 0xE9 && cMem->DataByte[11] == 0x05 && cMem->DataByte[15] == 0x90 && cMem->DataByte[16] == 0xC3))
                {
                    KnownRedirectionIndex = 5;                  //  ; tELock 0.99 - 1.0 Private!
                    /*  ;01C90000    B8 B853F205     MOV EAX,5F253B8
                        ;01C90005    E8 07000000     CALL 01C90011
                        ;01C9000A    F9              STC
                        ;01C9000B    E9 07000000     JMP 01C90017
                        ;01C90010    90              NOP
                        ;01C90011    23C3            AND EAX,EBX
                        ;01C90013    C3              RET
                        ;
                        ;00A40022    1BC2            SBB EAX,EDX
                        ;00A40024    E8 08000000     CALL 00A40031
                        ;00A40029    40              INC EAX
                        ;00A4002A    E9 09000000     JMP 00A40038
                        ;00A4002F    33C7            XOR EAX,EDI
                        ;00A40031    C1E8 92         SHR EAX,92
                        ;00A40034    C3              RET
                        ;00A40035    83E0 25         AND EAX,25
                        ;00A40038    25 E5AE65DD     AND EAX,DD65AEE5
                        ;00A4003D    B8 3E00A400     MOV EAX,0A4003E
                        ;00A40042    EB 02           JMP SHORT 00A40046
                        ;00A40044    CD 20           INT 20
                        ;00A40046    05 18000000     ADD EAX,18
                        ;00A4004B    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;00A4004D    35 2200A400     XOR EAX,0A40022
                        ;00A40052    90              NOP
                        ;00A40053    90              NOP
                        ;00A40054    50              PUSH EAX
                        ;00A40055    C3              RET
                        ;
                        ;00A4005A    E8 0B000000     CALL 00A4006A
                        ;00A4005F    15 06F265DD     ADC EAX,DD65F206
                        ;00A40064    E9 05000000     JMP 00A4006E
                        ;00A40069    90              NOP
                        ;00A4006A    C3              RET
                        ;00A4006B    1BC5            SBB EAX,EBP
                        ;00A4006D    40              INC EAX
                        ;00A4006E    1BC0            SBB EAX,EAX
                        ;00A40070    F9              STC
                        ;00A40071    B8 7200A400     MOV EAX,0A40072
                        ;00A40076    EB 02           JMP SHORT 00A4007A
                        ;00A40078    CD 20           INT 20
                        ;00A4007A    05 18000000     ADD EAX,18
                        ;00A4007F    8B00            MOV EAX,DWORD PTR DS:[EAX]
                        ;00A40081    35 5A00A400     XOR EAX,0A4005A
                        ;00A40086    90              NOP
                        ;00A40087    90              NOP
                        ;00A40088    50              PUSH EAX
                        ;00A40089    C3              RET */
                }
                else if(cMem->DataByte[0] == 0x1B && cMem->DataByte[1] == 0xC2 && cMem->DataByte[2] == 0xE8 && cMem->DataByte[3] == 0x08 && cMem->DataByte[7] == 0x40 && cMem->DataByte[8] == 0xE9 && cMem->DataByte[9] == 0x09 && cMem->DataByte[10] == 0x00)
                {
                    KnownRedirectionIndex = 5;                  //  ; tELock 0.99 - 1.0 Private!
                }
                else if(cMem->DataByte[0] == 0x68 && cMem->DataByte[5] == 0xE9)
                {
                    RtlMoveMemory(&TestAddressX86, &cMem->DataByte[1], 4);
                    if(TestAddressX86 > AddressToTrace)
                    {
                        if(ImporterGetAPIName((ULONG_PTR)TestAddressX86) != NULL)
                        {
                            KnownRedirectionIndex = 6;          //  ; ReCrypt 0.74
                            /*  ;001739F1    68 E9D9D477     PUSH User32.EndDialog
                                ;001739F6  ^ E9 FDFEFFFF     JMP 001738F8 */
                        }
                    }
                }
                else if((cMem->DataByte[0] == 0xE8 && cMem->DataByte[5] == 0x58 && cMem->DataByte[6] == 0xEB && cMem->DataByte[7] == 0x01) || (cMem->DataByte[0] == 0xC8 && cMem->DataByte[4] == 0xE8 && cMem->DataByte[9] == 0x5B))
                {
                    KnownRedirectionIndex = 7;                  //  ; Orien 2.1x
                    /* ;GetCommandLineA
                    ;$ ==>    >/$  E8 00000000     CALL crackme_.0040DF8F
                    ;$+5      >|$  58              POP EAX
                    ;$+6      >|.  EB 01           JMP SHORT crackme_.0040DF93
                    ;$+8      >|   B8              DB B8
                    ;$+9      >|>  85DB            TEST EBX,EBX
                    ;$+B      >|.  2D 8F1F0000     SUB EAX,1F8F
                    ;$+10     >|.  EB 01           JMP SHORT crackme_.0040DF9D
                    ;$+12     >|   A8              DB A8
                    ;$+13     >|>  8D80 F0550000   LEA EAX,DWORD PTR DS:[EAX+55F0]
                    ;$+19     >\.  C3              RET
                    ;GetCommandLineW
                    ;$ ==>    > .  E8 00000000     CALL crackme_.0040DFA9
                    ;$+5      >/$  58              POP EAX
                    ;$+6      >|.  EB 01           JMP SHORT crackme_.0040DFAD
                    ;$+8      >|   B8              DB B8
                    ;$+9      >|>  85DB            TEST EBX,EBX
                    ;$+B      >|.  2D A91F0000     SUB EAX,1FA9
                    ;$+10     >|.  EB 01           JMP SHORT crackme_.0040DFB7
                    ;$+12     >|   A8              DB A8
                    ;$+13     >|>  8D80 F4560000   LEA EAX,DWORD PTR DS:[EAX+56F4]
                    ;$+19     >\.  C3              RET
                    ;ExitProcess
                    ;$ ==>    > $  C8 000000       ENTER 0,0
                    ;$+4      > .  E8 00000000     CALL crackme_.0040DF2A
                    ;$+9      > $  5B              POP EBX
                    ;$+A      > .  EB 01           JMP SHORT crackme_.0040DF2E
                    ;$+C      >    B8              DB B8
                    ;$+D      > >  85DB            TEST EBX,EBX
                    ;$+F      > .  81EB 2A1F0000   SUB EBX,1F2A
                    ;$+15     > .  EB 01           JMP SHORT crackme_.0040DF39
                    ;$+17     >    A8              DB A8
                    ;$+18     > >  8D83 4D310000   LEA EAX,DWORD PTR DS:[EBX+314D]
                    ;$+1E     > .  8038 00         CMP BYTE PTR DS:[EAX],0
                    ;$+21     > .  74 29           JE SHORT crackme_.0040DF6D
                    ;$+23     > .  EB 01           JMP SHORT crackme_.0040DF47
                    ;$+25     >    A8              DB A8
                    ;$+26     > >  8D93 55380000   LEA EDX,DWORD PTR DS:[EBX+3855]
                    ;$+2C     > .  E8 01000000     CALL crackme_.0040DF53
                    ;$+31     >    E9              DB E9
                    ;$+32     > $  83EC FC         SUB ESP,-4
                    ;$+35     > .  6A 00           PUSH 0
                    ;$+37     > .  52              PUSH EDX
                    ;$+38     > .  50              PUSH EAX
                    ;$+39     > .  6A 00           PUSH 0
                    ;$+3B     > .  E8 05000000     CALL crackme_.0040DF66
                    ;$+40     > .  EB 0A           JMP SHORT crackme_.0040DF6D
                    ;$+42     >    88              DB 88
                    ;$+43     >    FC              DB FC
                    ;$+44     >    B6              DB B6
                    ;$+45     > $  FFA3 FF3A0000   JMP NEAR DWORD PTR DS:[EBX+3AFF]
                    ;$+4B     >    CD              DB CD
                    ;$+4C     > >  E8 01000000     CALL crackme_.0040DF73
                    ;$+51     >    E9              DB E9
                    ;$+52     > $  83EC FC         SUB ESP,-4
                    ;$+55     > .  FF75 08         PUSH DWORD PTR SS:[EBP+8]
                    ;$+58     > .  E8 05000000     CALL crackme_.0040DF83
                    ;$+5D     > .  EB 0A           JMP SHORT crackme_.0040DF8A
                    ;$+5F     >    88              DB 88
                    ;$+60     >    FC              DB FC
                    ;$+61     >    B6              DB B6
                    ;$+62     > $  FFA3 BF3A0000   JMP NEAR DWORD PTR DS:[EBX+3ABF] */
                }
                else if((cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x01 && cMem->DataByte[2] == 0x66 && cMem->DataByte[3] == 0x1B) || (cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x02 && cMem->DataByte[2] == 0xCD && cMem->DataByte[3] == 0x20) || (cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x01 && cMem->DataByte[2] == 0xB8 && cMem->DataByte[3] == 0xEB))
                {
                    KnownRedirectionIndex = 4;                  // ; tELock 0.96 - 0.98
                    /* ;(BYTE PTR[ESI] == 0EBh && (BYTE PTR[ESI+3] == 0EBh || BYTE PTR[ESI+2] == 0EBh))
                    ;017B0000    0BE4            OR ESP,ESP
                    ;017B0002    75 01           JNZ SHORT 017B0005
                    ;
                    ;15940000    85E4            TEST ESP,ESP
                    ;15940002    79 03           JNS SHORT 15940007
                    ;
                    ;008E0359    B8 8DE44500     MOV EAX,45E48D
                    ;008E035E    90              NOP
                    ;008E035F    FF30            PUSH DWORD PTR DS:[EAX]
                    ;008E0361    C3              RET
                    ;
                    ;008F0033    B8 AF008F00     MOV EAX,8F00AF
                    ;008F0038    40              INC EAX
                    ;008F0039    FF30            PUSH DWORD PTR DS:[EAX]
                    ;008F003B    C3              RET
                    ;
                    ;008E02F7    B8 20078E00     MOV EAX,8E0720
                    ;008E02FC    FF20            JMP NEAR DWORD PTR DS:[EAX] */
                }
                else if((cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x03 && cMem->DataByte[2] == 0xFF && cMem->DataByte[3] == 0xEB) || (cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x01 && cMem->DataByte[2] == 0xB8 && cMem->DataByte[3] == 0x05) || (cMem->DataByte[0] == 0xEB && cMem->DataByte[1] == 0x02 && cMem->DataByte[2] == 0xFF && cMem->DataByte[3] == 0x20))
                {
                    KnownRedirectionIndex = 4;                  // ; tELock 0.96 - 0.98
                }
                else if((cMem->DataByte[0] == 0xF9 || cMem->DataByte[0] == 0xF8) || (cMem->DataByte[0] == 0x0B && cMem->DataByte[1] == 0xE4) || (cMem->DataByte[0] == 0x85 && cMem->DataByte[1] == 0xE4))
                {
                    KnownRedirectionIndex = 4;                  // ; tELock 0.96 - 0.98
                }
                else if(cMem->DataByte[0] == 0xEB && (cMem->DataByte[1] > NULL && cMem->DataByte[1] < 4))
                {
                    i = 2;
                    j = 30;
                    while(j > NULL)
                    {
                        if(cMem->DataByte[i] == 0xB8 && (cMem->DataByte[i + 5] == 0x40 || cMem->DataByte[i + 5] == 0x90) && cMem->DataByte[i + 6] == 0xFF && cMem->DataByte[i + 7] == 0x30 && cMem->DataByte[i + 8] == 0xC3)
                        {
                            KnownRedirectionIndex = 4;          // ; tELock 0.96 - 0.98
                            j = 1;
                        }
                        i++;
                        j--;
                    }
                }
                else if(HashCheck)
                {
                    if(cMem->DataByte[0] == 0x9C || cMem->DataByte[0] == 0xEB)
                    {
                        MemoryHash = EngineHashMemory((char*)TraceMemory, 192, MemoryHash);
                        if(MemoryHash == 0x5AF7E209 || MemoryHash == 0xEB480CAC || MemoryHash == 0x86218561 || MemoryHash == 0xCA9ABD85)
                        {
                            KnownRedirectionIndex = 9;          // ; SVKP 1.x
                        }
                        else if(MemoryHash == 0xF1F84A98 || MemoryHash == 0x91823290 || MemoryHash == 0xBEE6BAA0 || MemoryHash == 0x79603232)
                        {
                            KnownRedirectionIndex = 9;          // ; SVKP 1.x
                        }
                    }
                }
                return(KnownRedirectionIndex);
            }
            else
            {
            }
        }
    }
    return(NULL);
}
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId)
{

    int i = NULL;
    DWORD TestAddressX86;
    DWORD ReadAddressX86;
    DWORD MemoryHash = NULL;
    PMEMORY_CMP_HANDLER cMem;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG_PTR ueNumberOfBytesRead = NULL;
    char TracerReadMemory[0x1000] = {0};
    DWORD MaximumReadSize = 0x1000;
    cMem = (PMEMORY_CMP_HANDLER)TracerReadMemory;

    VirtualQueryEx(hProcess, (LPVOID)AddressToTrace, &MemInfo, sizeof MEMORY_BASIC_INFORMATION);
    if(MemInfo.RegionSize > NULL)
    {
        MaximumReadSize = (DWORD)((ULONG_PTR)MemInfo.BaseAddress + MemInfo.RegionSize - AddressToTrace);
        if(MaximumReadSize > 0x1000)
        {
            MaximumReadSize = 0x1000;
        }
    }
    if(RedirectionId == NULL)
    {
        RedirectionId = (DWORD)TracerDetectRedirection(hProcess, AddressToTrace);
    }
    if(RedirectionId == 1)                                              //  TracerFix_ACProtect
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                RtlMoveMemory(&TestAddressX86, &cMem->DataByte[1], 4);
                if(cMem->DataByte[5] == 0x81 && cMem->DataByte[6] == 0x2C)
                {
                    RtlMoveMemory(&ReadAddressX86, &cMem->DataByte[8], 4);
                    TestAddressX86 = TestAddressX86 - ReadAddressX86;
                }
                else if(cMem->DataByte[5] == 0x81 && cMem->DataByte[6] == 0x34)
                {
                    RtlMoveMemory(&ReadAddressX86, &cMem->DataByte[8], 4);
                    TestAddressX86 = TestAddressX86 ^ ReadAddressX86;
                }
                else if(cMem->DataByte[5] == 0x81 && cMem->DataByte[6] == 0x04)
                {
                    RtlMoveMemory(&ReadAddressX86, &cMem->DataByte[8], 4);
                    TestAddressX86 = TestAddressX86 + ReadAddressX86;
                }
                return((DWORD)TestAddressX86);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 2)                                         //  TracerFix_tELock_varA
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                RtlMoveMemory(&TestAddressX86, &cMem->DataByte[2], 4);
                if(ReadProcessMemory(hProcess, (LPVOID)TestAddressX86, &TestAddressX86, 4, &ueNumberOfBytesRead))
                {
                    return((DWORD)TestAddressX86);
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 3)                                         //  TracerFix_tELock_varB
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                if(cMem->DataByte[0] == 0xFF && cMem->DataByte[1] == 0x35)
                {
                    RtlMoveMemory(&TestAddressX86, &cMem->DataByte[2], 4);
                }
                else
                {
                    RtlMoveMemory(&TestAddressX86, &cMem->DataByte[3], 4);
                }
                if(ReadProcessMemory(hProcess, (LPVOID)TestAddressX86, &TestAddressX86, 4, &ueNumberOfBytesRead))
                {
                    return((DWORD)TestAddressX86);
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 4)                                         //  TracerFix_tELock_varC
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                i = 100;
                if(cMem->DataByte[0] == 0xEB && (cMem->DataByte[1] > 0 && cMem->DataByte[1] < 4))
                {
                    cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem + cMem->DataByte[1] + 2);
                }
                while(i > NULL && (cMem->DataByte[0] == 0xFF && (cMem->DataByte[1] == 0x20 || cMem->DataByte[1] == 0x30)))
                {
                    cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem + 1);
                    i--;
                }
                if(i != NULL && cMem->DataByte[0] == 0xFF && cMem->DataByte[1] == 0x20)
                {
                    if(cMem->DataByte[2] != 0x90)
                    {
                        cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem + 1);
                        while(i > NULL && (cMem->DataByte[0] == 0xFF && (cMem->DataByte[1] == 0x20 || cMem->DataByte[1] == 0x30)))
                        {
                            cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem + 1);
                            i--;
                        }
                    }
                }
                if(i != NULL && cMem->DataByte[0] == 0xFF && cMem->DataByte[1] == 0x30)
                {
                    cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem - 6);
                    if(cMem->DataByte[0] == 0xB8)
                    {
                        RtlMoveMemory(&TestAddressX86, &cMem->DataByte[1], 4);
                        if(cMem->DataByte[5] == 0x40)
                        {
                            TestAddressX86++;
                        }
                    }
                    else
                    {
                        RtlMoveMemory(&TestAddressX86, &cMem->DataByte[2], 4);
                    }
                    if(ReadProcessMemory(hProcess, (LPVOID)TestAddressX86, &TestAddressX86, 4, &ueNumberOfBytesRead))
                    {
                        return((DWORD)TestAddressX86);
                    }
                }
                else if(i != NULL && cMem->DataByte[0] == 0xFF && cMem->DataByte[1] == 0x20)
                {
                    cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem - 6);
                    RtlMoveMemory(&TestAddressX86, &cMem->DataByte[2], 4);
                    if(ReadProcessMemory(hProcess, (LPVOID)TestAddressX86, &TestAddressX86, 4, &ueNumberOfBytesRead))
                    {
                        return((DWORD)TestAddressX86);
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 5)                                         //  TracerFix_tELock_varD
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                i = 100;
                while(i > NULL && (cMem->DataByte[0] != 0x50 || cMem->DataByte[1] != 0xC3))
                {
                    cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem + 1);
                    i--;
                }
                if(i != NULL && cMem->DataByte[0] == 0x50 && cMem->DataByte[1] == 0xC3)
                {
                    cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem - 0x16);
                    RtlMoveMemory(&ReadAddressX86, &cMem->DataByte[0x10], 4);
                    RtlMoveMemory(&TestAddressX86, &cMem->DataByte[0], 4);
                    TestAddressX86 = TestAddressX86 + 0x18;
                    if(ReadProcessMemory(hProcess, (LPVOID)TestAddressX86, &TestAddressX86, 4, &ueNumberOfBytesRead))
                    {
                        TestAddressX86 = TestAddressX86 ^ ReadAddressX86;
                        return((DWORD)TestAddressX86);
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 6)                                         //  TracerFix_ReCrypt
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                RtlMoveMemory(&TestAddressX86, &cMem->DataByte[1], 4);
                return((DWORD)TestAddressX86);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 7)                                         //  TracerFix_Orien
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                if(cMem->DataByte[0] == 0xE8)
                {
                    RtlMoveMemory(&ReadAddressX86, &cMem->DataByte[0x15], 4);
                    if(ReadAddressX86 == 0x55F0)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetCommandLineA"));
                    }
                    else
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetCommandLineW"));
                    }
                    return((DWORD)TestAddressX86);
                }
                else if(cMem->DataByte[0] == 0xC8)
                {
                    TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitProcess"));
                    return((DWORD)TestAddressX86);
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 8)                                         //  TracerFix_AlexProtector
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                cMem = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cMem + 0x34);
                RtlMoveMemory(&TestAddressX86, &cMem->DataByte[0], 4);
                return((DWORD)TestAddressX86);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    else if(RedirectionId == 9 && MaximumReadSize > 192)                //  TracerFix_SVKP
    {
        __try
        {
            if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, TracerReadMemory, MaximumReadSize, &ueNumberOfBytesRead))
            {
                if(cMem->DataByte[0] == 0x9C || cMem->DataByte[0] == 0xEB)
                {
                    MemoryHash = EngineHashMemory((char*)TracerReadMemory, 192, MemoryHash);
                    if(MemoryHash == 0x5AF7E209)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetCommandLineA"));
                    }
                    else if(MemoryHash == 0xEB480CAC)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitProcess"));
                    }
                    else if(MemoryHash == 0x86218561)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetCurrentProcess"));
                    }
                    else if(MemoryHash == 0xCA9ABD85)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetVersion"));
                    }
                    else if(MemoryHash == 0xF1F84A98)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetVersionExA"));
                    }
                    else if(MemoryHash == 0x91823290)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetModuleHandleA"));
                    }
                    else if(MemoryHash == 0xBEE6BAA0)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("user32.dll"), "MessageBoxA"));
                    }
                    else if(MemoryHash == 0x79603232)
                    {
                        TestAddressX86 = (DWORD)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetModuleHandleA"));
                    }
                    return((DWORD)TestAddressX86);
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return(NULL);
        }
    }
    return(NULL);
}

// TitanEngine.Tracer.functions:
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, char* szPluginName, ULONG_PTR AddressToTrace)
{

    int szLenght = NULL;
    HMODULE hImpRecModule = NULL;
    ULONG_PTR fImpRecTrace = NULL;
    PMEMORY_CMP_HANDLER cmpModuleName;
    ULONG_PTR remInjectSize = (ULONG_PTR)((ULONG_PTR)&injectedRemoteLoadLibrary - (ULONG_PTR)&injectedImpRec);
    char szModuleName[0x1100] = {0};
    char szGarbageFile[0x1100] = {0};
    LPVOID cModuleName = szModuleName;
    ULONG_PTR NumberOfBytesWritten;
    InjectImpRecCodeData APIData;
    DWORD TracedAddress = NULL;
    DWORD TraceAddress = NULL;
    LPVOID remStringData;
    LPVOID remCodeData;
    DWORD ThreadId;
    HANDLE hThread;
    DWORD ExitCode;
    HANDLE FileHandle;
    DWORD FileSize;
    HANDLE FileMap;
    ULONG_PTR FileMapVA;

    if(GetModuleFileNameA(engineHandle, (LPCH)szModuleName, sizeof(szModuleName) - 0x100) > NULL)
    {
        cModuleName = (LPVOID)((ULONG_PTR)cModuleName + lstrlenA((LPCSTR)szModuleName));
        cmpModuleName = (PMEMORY_CMP_HANDLER)(cModuleName);
        while(cmpModuleName->DataByte[0] != 0x5C)
        {
            cmpModuleName = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cmpModuleName - 1);
        }
        cmpModuleName = (PMEMORY_CMP_HANDLER)((ULONG_PTR)cmpModuleName + 1);
        cmpModuleName->DataByte[0] = 0x00;
        lstrcpyA((LPSTR)szGarbageFile, (LPCSTR)szModuleName);
        lstrcatA((LPSTR)szGarbageFile, "garbage\\ImpRec.txt");
        lstrcatA((LPSTR)szModuleName, "imports\\ImpRec\\");
        lstrcatA((LPSTR)szModuleName, szPluginName);
        if(ReadProcessMemory(hProcess, (LPVOID)AddressToTrace, &TraceAddress, 4, &NumberOfBytesWritten))
        {
            if(RemoteLoadLibrary(hProcess, (char*)szModuleName, true))
            {
                hImpRecModule = LoadLibraryA((char*)szModuleName);
                if(hImpRecModule != NULL)
                {
                    fImpRecTrace = (ULONG_PTR)GetProcAddress(hImpRecModule, "Trace");
                    if(fImpRecTrace != NULL)
                    {
                        fImpRecTrace = fImpRecTrace - (ULONG_PTR)hImpRecModule;
                        remCodeData = VirtualAllocEx(hProcess, NULL, remInjectSize, MEM_COMMIT, PAGE_READWRITE);
                        remStringData = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);
                        RtlZeroMemory(&APIData, sizeof InjectImpRecCodeData);
                        APIData.fTrace = fImpRecTrace + (ULONG_PTR)ImporterGetRemoteDLLBase(hProcess, hImpRecModule);
                        APIData.AddressToTrace = (ULONG_PTR)TraceAddress;
                        APIData.fCreateFileA = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "CreateFileA"));
                        APIData.fCreateFileMappingA = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "CreateFileMappingA"));
                        APIData.fCloseHandle = (ULONG_PTR)ImporterGetRemoteAPIAddress(hProcess, (ULONG_PTR)GetProcAddress(GetModuleHandleA("kernel32.dll"), "CloseHandle"));
                        if(WriteProcessMemory(hProcess, remCodeData, (LPCVOID)&injectedImpRec, remInjectSize, &NumberOfBytesWritten))
                        {
                            WriteProcessMemory(hProcess, remStringData, &APIData, sizeof InjectImpRecCodeData, &NumberOfBytesWritten);
                            WriteProcessMemory(hProcess, (LPVOID)((ULONG_PTR)remStringData + sizeof InjectImpRecCodeData), (LPCVOID)szGarbageFile, lstrlenA((LPSTR)szGarbageFile), &NumberOfBytesWritten);
                            hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remCodeData, remStringData, CREATE_SUSPENDED, &ThreadId);

                            NtSetInformationThread(hThread, ThreadHideFromDebugger, NULL, NULL);

                            ResumeThread(hThread);
                            WaitForSingleObject(hThread, INFINITE);
                            if(GetExitCodeThread(hThread, &ExitCode))
                            {
                                if(ExitCode != NULL)
                                {
                                    if(MapFileEx((char*)szGarbageFile, UE_ACCESS_READ, &FileHandle, &FileSize, &FileMap, &FileMapVA, NULL))
                                    {
                                        RtlMoveMemory(&TracedAddress, (LPVOID)FileMapVA, 4);
                                        UnMapFileEx(FileHandle, FileSize, FileMap, FileMapVA);
                                    }
                                    if(!DeleteFileA((LPCSTR)szGarbageFile))
                                    {
                                        HandlerCloseAllLockHandles((char*)szGarbageFile, false, true);
                                        DeleteFileA((LPCSTR)szGarbageFile);
                                    }
                                }
                            }
                        }
                        RemoteFreeLibrary(hProcess, NULL, (char*)szModuleName, true);
                        VirtualFreeEx(hProcess, remCodeData, NULL, MEM_RELEASE);
                        VirtualFreeEx(hProcess, remStringData, NULL, MEM_RELEASE);
                    }
                    else
                    {
                        RemoteFreeLibrary(hProcess, NULL, (char*)szModuleName, true);
                    }
                    FreeLibrary(hImpRecModule);
                }
            }
        }
    }
    return(TracedAddress);
}


================================================
File: TitanEngine/TitanEngine.TranslateName.cpp
================================================
#include "stdafx.h"
#include "definitions.h"

// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(char* szNativeName)
{
    void* TranslatedName = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE); //pointer is returned
    char szDeviceName[3] = "A:";
    char szDeviceCOMName[5] = "COM0";
    int CurrentDeviceLen;

    while(szDeviceName[0] <= 0x5A)
    {
        RtlZeroMemory(TranslatedName, 0x1000);
        if(QueryDosDeviceA(szDeviceName, (LPSTR)TranslatedName, 0x1000) > NULL)
        {
            CurrentDeviceLen = lstrlenA((LPSTR)TranslatedName);
            lstrcatA((LPSTR)TranslatedName, (LPCSTR)(szNativeName + CurrentDeviceLen));
            if(lstrcmpiA((LPCSTR)TranslatedName, szNativeName) == NULL)
            {
                RtlZeroMemory(TranslatedName, 0x1000);
                lstrcatA((LPSTR)TranslatedName, szDeviceName);
                lstrcatA((LPSTR)TranslatedName, (LPCSTR)(szNativeName + CurrentDeviceLen));
                return(TranslatedName);
            }
        }
        szDeviceName[0]++;
    }

    while(szDeviceCOMName[3] <= 0x39)
    {
        RtlZeroMemory(TranslatedName, 0x1000);
        if(QueryDosDeviceA(szDeviceCOMName, (LPSTR)TranslatedName, 0x1000) > NULL)
        {
            CurrentDeviceLen = lstrlenA((LPSTR)TranslatedName);
            lstrcatA((LPSTR)TranslatedName, (LPCSTR)(szNativeName + CurrentDeviceLen));
            if(lstrcmpiA((LPCSTR)TranslatedName, szNativeName) == NULL)
            {
                RtlZeroMemory(TranslatedName, 0x1000);
                lstrcatA((LPSTR)TranslatedName, szDeviceCOMName);
                lstrcatA((LPSTR)TranslatedName, (LPCSTR)(szNativeName + CurrentDeviceLen));
                return(TranslatedName);
            }
        }
        szDeviceCOMName[3]++;
    }

    VirtualFree(TranslatedName, NULL, MEM_RELEASE);

    return NULL;
}

__declspec(dllexport) void* TITCALL TranslateNativeNameW(wchar_t* szNativeName)
{
    void* TranslatedName = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE); //pointer is returned
    wchar_t szDeviceName[3] = L"A:";
    wchar_t szDeviceCOMName[5] = L"COM0";
    int CurrentDeviceLen;

    while(szDeviceName[0] <= 0x5A)
    {
        RtlZeroMemory(TranslatedName, 0x1000);
        if(QueryDosDeviceW(szDeviceName, (LPWSTR)TranslatedName, MAX_PATH * 2) > NULL)
        {
            CurrentDeviceLen = lstrlenW((LPWSTR)TranslatedName);
            lstrcatW((LPWSTR)TranslatedName, (LPCWSTR)(szNativeName + CurrentDeviceLen));
            if(lstrcmpiW((LPCWSTR)TranslatedName, szNativeName) == NULL)
            {
                RtlZeroMemory(TranslatedName, 0x1000);
                lstrcatW((LPWSTR)TranslatedName, szDeviceName);
                lstrcatW((LPWSTR)TranslatedName, (LPWSTR)(szNativeName + CurrentDeviceLen));
                return(TranslatedName);
            }
        }
        szDeviceName[0]++;
    }

    while(szDeviceCOMName[3] <= 0x39)
    {
        RtlZeroMemory(TranslatedName, 0x1000);
        if(QueryDosDeviceW(szDeviceCOMName, (LPWSTR)TranslatedName, MAX_PATH * 2) > NULL)
        {
            CurrentDeviceLen = lstrlenW((LPWSTR)TranslatedName);
            lstrcatW((LPWSTR)TranslatedName, (LPCWSTR)(szNativeName + CurrentDeviceLen));
            if(lstrcmpiW((LPCWSTR)TranslatedName, szNativeName) == NULL)
            {
                RtlZeroMemory(TranslatedName, 0x1000);
                lstrcatW((LPWSTR)TranslatedName, szDeviceCOMName);
                lstrcatW((LPWSTR)TranslatedName, (LPWSTR)(szNativeName + CurrentDeviceLen));
                return(TranslatedName);
            }
        }
        szDeviceCOMName[3]++;
    }

    VirtualFree(TranslatedName, NULL, MEM_RELEASE);

    return NULL;
}


================================================
File: TitanEngine/TitanEngine.cbp
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="TitanEngine" />
		<Option pch_mode="2" />
		<Option compiler="msvc10" />
		<Build>
			<Target title="x32">
				<Option output="../Release/x32/TitanEngine" imp_lib="$(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).a" def_file="$(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).def" prefix_auto="1" extension_auto="1" />
				<Option object_output="obj/x32" />
				<Option type="3" />
				<Option compiler="msvc10" />
				<Option createDefFile="1" />
				<Option createStaticLib="1" />
				<Compiler>
					<Add option="/DWIN32" />
					<Add option="/DNDEBUG" />
					<Add option="/D_WINDOWS" />
					<Add option="/D_USRDLL" />
					<Add option="/DUNPACKERENGINE_EXPORTS" />
				</Compiler>
				<Linker>
					<Add option="/DEF:TitanEngine.def" />
					<Add library=".\scylla_wrapper_x86.lib" />
					<Add library=".\distorm_x86.lib" />
					<Add library="Imagehlp.lib" />
					<Add library="psapi.lib" />
				</Linker>
			</Target>
			<Target title="x64">
				<Option output="../Release/x64/TitanEngine" imp_lib="$(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).a" def_file="$(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).def" prefix_auto="1" extension_auto="1" />
				<Option object_output="obj/x64" />
				<Option type="3" />
				<Option compiler="microsoft_visual_c_2010_x64" />
				<Option createDefFile="1" />
				<Option createStaticLib="1" />
				<Compiler>
					<Add option="/DWIN32" />
					<Add option="/DNDEBUG" />
					<Add option="/D_WINDOWS" />
					<Add option="/D_USRDLL" />
					<Add option="/DUNPACKERENGINE_EXPORTS" />
				</Compiler>
				<Linker>
					<Add library=".\scylla_wrapper_x64.lib" />
					<Add library=".\distorm_x64.lib" />
					<Add library="Imagehlp.lib" />
					<Add library="psapi.lib" />
				</Linker>
			</Target>
		</Build>
		<Linker>
			<Add library="user32" />
			<Add library="advapi32" />
			<Add library="comdlg32" />
			<Add library="shell32" />
		</Linker>
		<Unit filename="Global.Breakpoints.cpp" />
		<Unit filename="Global.Breakpoints.h" />
		<Unit filename="Global.Debugger.cpp" />
		<Unit filename="Global.Debugger.h" />
		<Unit filename="Global.Engine.Extension.cpp" />
		<Unit filename="Global.Engine.Extension.h" />
		<Unit filename="Global.Engine.GUI.cpp" />
		<Unit filename="Global.Engine.GUI.h" />
		<Unit filename="Global.Engine.Hash.cpp" />
		<Unit filename="Global.Engine.Hash.h" />
		<Unit filename="Global.Engine.Hider.cpp" />
		<Unit filename="Global.Engine.Hider.h" />
		<Unit filename="Global.Engine.Hook.cpp" />
		<Unit filename="Global.Engine.Hook.h" />
		<Unit filename="Global.Engine.Importer.cpp" />
		<Unit filename="Global.Engine.Importer.h" />
		<Unit filename="Global.Engine.Simplification.cpp" />
		<Unit filename="Global.Engine.Simplification.h" />
		<Unit filename="Global.Engine.Threading.cpp" />
		<Unit filename="Global.Engine.Threading.h" />
		<Unit filename="Global.Engine.cpp" />
		<Unit filename="Global.Engine.h" />
		<Unit filename="Global.Garbage.cpp" />
		<Unit filename="Global.Garbage.h" />
		<Unit filename="Global.Handle.cpp" />
		<Unit filename="Global.Handle.h" />
		<Unit filename="Global.Helper.cpp" />
		<Unit filename="Global.Helper.h" />
		<Unit filename="Global.Injector.cpp" />
		<Unit filename="Global.Injector.h" />
		<Unit filename="Global.Librarian.cpp" />
		<Unit filename="Global.Librarian.h" />
		<Unit filename="Global.Mapping.cpp" />
		<Unit filename="Global.Mapping.h" />
		<Unit filename="Global.OEPFinder.cpp" />
		<Unit filename="Global.OEPFinder.h" />
		<Unit filename="Global.Realigner.cpp" />
		<Unit filename="Global.Realigner.h" />
		<Unit filename="Global.TLS.cpp" />
		<Unit filename="Global.TLS.h" />
		<Unit filename="Global.Threader.cpp" />
		<Unit filename="Global.Threader.h" />
		<Unit filename="LzmaDec.cpp" />
		<Unit filename="LzmaDec.h" />
		<Unit filename="LzmaTypes.h" />
		<Unit filename="TitanEngine.Breakpoints.cpp" />
		<Unit filename="TitanEngine.Debugger.Context.cpp" />
		<Unit filename="TitanEngine.Debugger.Control.cpp" />
		<Unit filename="TitanEngine.Debugger.Data.cpp" />
		<Unit filename="TitanEngine.Debugger.DebugLoop.cpp" />
		<Unit filename="TitanEngine.Debugger.Helper.cpp" />
		<Unit filename="TitanEngine.Debugger.Memory.cpp" />
		<Unit filename="TitanEngine.Debugger.cpp" />
		<Unit filename="TitanEngine.Disassembler.cpp" />
		<Unit filename="TitanEngine.Dumper.cpp" />
		<Unit filename="TitanEngine.Engine.Simplification.cpp" />
		<Unit filename="TitanEngine.Engine.cpp" />
		<Unit filename="TitanEngine.Exporter.cpp" />
		<Unit filename="TitanEngine.Handler.cpp" />
		<Unit filename="TitanEngine.Hider.cpp" />
		<Unit filename="TitanEngine.Hooks.cpp" />
		<Unit filename="TitanEngine.Importer.cpp" />
		<Unit filename="TitanEngine.Injector.cpp" />
		<Unit filename="TitanEngine.Librarian.cpp" />
		<Unit filename="TitanEngine.OEPFinder.cpp" />
		<Unit filename="TitanEngine.PE.Convert.cpp" />
		<Unit filename="TitanEngine.PE.Data.cpp" />
		<Unit filename="TitanEngine.PE.Fixer.cpp" />
		<Unit filename="TitanEngine.PE.Overlay.cpp" />
		<Unit filename="TitanEngine.PE.Section.cpp" />
		<Unit filename="TitanEngine.PE.cpp" />
		<Unit filename="TitanEngine.Process.cpp" />
		<Unit filename="TitanEngine.Realigner.cpp" />
		<Unit filename="TitanEngine.Relocator.cpp" />
		<Unit filename="TitanEngine.Resourcer.cpp" />
		<Unit filename="TitanEngine.Static.cpp" />
		<Unit filename="TitanEngine.TLS.cpp" />
		<Unit filename="TitanEngine.Threader.cpp" />
		<Unit filename="TitanEngine.Tracer.cpp" />
		<Unit filename="TitanEngine.TranslateName.cpp" />
		<Unit filename="TitanEngine.cpp" />
		<Unit filename="TitanEngine.rc">
			<Option compilerVar="WINDRES" />
		</Unit>
		<Unit filename="aplib.h" />
		<Unit filename="definitions.h" />
		<Unit filename="distorm.h" />
		<Unit filename="ntdll.h" />
		<Unit filename="resource.h" />
		<Unit filename="scylla_wrapper.h" />
		<Unit filename="stdafx.cpp" />
		<Unit filename="stdafx.h" />
		<Unit filename="targetver.h" />
		<Extensions>
			<code_completion />
			<envvars />
			<debugger />
		</Extensions>
	</Project>
</CodeBlocks_project_file>



================================================
File: TitanEngine/TitanEngine.cpp
================================================
#include "stdafx.h"
#include "stdafx.h"
#include "Global.Engine.h"
#include "Global.Garbage.h"
#include "Global.Injector.h"
#include "Global.Engine.Threading.h"
#include "Global.Debugger.h"

// Global.Engine.Entry:
BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    switch(fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        engineHandle = hinstDLL;
        InitializeCriticalSection(&engineStepActiveCr);
        EngineInit();
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break; //this bug has been here since 2010
    case DLL_PROCESS_DETACH:
        CriticalSectionLocker::Deinitialize(); //delete critical sections
        break;
    }
    return TRUE;
}


================================================
File: TitanEngine/TitanEngine.def
================================================
LIBRARY "TitanEngine"
EXPORTS
DumpProcess
DumpProcessW
DumpProcessEx
DumpProcessExW
DumpMemory
DumpMemoryW
DumpMemoryEx
DumpMemoryExW
DumpRegions
DumpRegionsW
DumpRegionsEx
DumpRegionsExW
DumpModule
DumpModuleW
DumpModuleEx
DumpModuleExW
PastePEHeader
PastePEHeaderW
ExtractSection
ExtractSectionW
ResortFileSections
ResortFileSectionsW
FindOverlay
FindOverlayW
ExtractOverlay
ExtractOverlayW
AddOverlay
AddOverlayW
CopyOverlay
CopyOverlayW
RemoveOverlay
RemoveOverlayW
MakeAllSectionsRWE
MakeAllSectionsRWEW
AddNewSection
AddNewSectionW
AddNewSectionEx
AddNewSectionExW
ResizeLastSection
ResizeLastSectionW
SetSharedOverlay
SetSharedOverlayW
GetSharedOverlay
GetSharedOverlayW
DeleteLastSection
DeleteLastSectionW
DeleteLastSectionEx
DeleteLastSectionExW
GetPE32SectionNumberFromVA
ConvertVAtoFileOffset
ConvertVAtoFileOffsetEx
ConvertFileOffsetToVA
ConvertFileOffsetToVAEx
MemoryReadSafe
MemoryWriteSafe
GetPE32Data
GetPE32DataW
GetPE32DataFromMappedFile
GetPE32DataEx
GetPE32DataExW
GetPE32DataFromMappedFileEx
SetPE32Data
SetPE32DataW
SetPE32DataForMappedFile
SetPE32DataEx
SetPE32DataExW
SetPE32DataForMappedFileEx
IsFileDLL
IsFileDLLW
WipeSection
WipeSectionW
RealignPE
RealignPEEx
RealignPEExW
IsPE32FileValidEx
IsPE32FileValidExW
FixBrokenPE32FileEx
FixBrokenPE32FileExW
FixHeaderCheckSum
FixHeaderCheckSumW
InitDebug
InitDebugW
InitNativeDebug
InitNativeDebugW
InitDebugEx
InitDebugExW
InitDLLDebug
InitDLLDebugW
StopDebug
SetBPXOptions
IsBPXEnabled
SetBPX
DisableBPX
EnableBPX
DeleteBPX
SafeDeleteBPX
RemoveAllBreakPoints
SetMemoryBPX
SetMemoryBPXEx
RemoveMemoryBPX
SetAPIBreakPoint
DeleteAPIBreakPoint
SafeDeleteAPIBreakPoint
GetContextData
GetContextDataEx
GetContextFPUDataEx
SetContextData
SetContextDataEx
SetContextFPUDataEx
ClearExceptionNumber
CurrentExceptionNumber
StaticLengthDisassemble
LengthDisassemble
LengthDisassembleEx
StaticDisassemble
StaticDisassembleEx
DisassembleEx
Disassemble
MatchPatternEx
MatchPattern
FindEx
Find
FillEx
Fill
PatchEx
Patch
ReplaceEx
Replace
GetDebugData
GetTerminationData
GetExitCode
SetCustomHandler
ForceClose
SetNextDbgContinueStatus
DebugLoop
DebugLoopEx
StepInto
StepOver
SingleStep
SetHardwareBreakPoint
SetHardwareBreakPointEx
GetUnusedHardwareBreakPointRegister
DeleteHardwareBreakPoint
AttachDebugger
DetachDebugger
DetachDebuggerEx
GetDebuggedDLLBaseAddress
GetDebuggedFileBaseAddress
GetRemoteString
GetFunctionParameter
GetJumpDestination
GetJumpDestinationEx
IsJumpGoingToExecuteEx
IsJumpGoingToExecute
SetDebugLoopTimeOut
TitanGetProcessInformation
GetProcessInformation = TitanGetProcessInformation
TitanGetStartupInformation
GetStartupInformation = TitanGetStartupInformation
AutoDebugEx
AutoDebugExW
IsFileBeingDebugged
SetErrorModel
ImporterAddNewDll
ImporterAddNewAPI
ImporterAddNewOrdinalAPI
ImporterExportIAT
ImporterExportIATEx
ImporterExportIATExW
ImporterEstimatedSize
ImporterGetAddedDllCount
ImporterGetAddedAPICount
ImporterFindAPIWriteLocation
ImporterFindOrdinalAPIWriteLocation
ImporterFindAPIByWriteLocation
ImporterFindDLLByWriteLocation
ImporterGetDLLName
ImporterGetDLLNameW
ImporterGetAPIName
ImporterGetAPINameEx
ImporterGetAPIOrdinalNumber
ImporterGetRemoteAPIAddress
ImporterGetRemoteAPIAddressEx
ImporterGetLocalAPIAddress
ImporterGetDLLNameFromDebugee
ImporterGetDLLNameFromDebugeeW
ImporterGetAPINameFromDebugee
ImporterGetAPIOrdinalNumberFromDebugee
ImporterGetDLLIndexEx
ImporterGetDLLIndex
ImporterGetRemoteDLLBase
ImporterGetRemoteDLLBaseEx
ImporterGetRemoteDLLBaseExW
ImporterIsForwardedAPI
ImporterAutoSearchIAT
ImporterAutoSearchIATW
ImporterAutoSearchIATEx
ImporterAutoFixIATEx
ImporterAutoFixIATExW
ImporterAutoFixIAT
ImporterAutoFixIATW
ImporterIsForwardedAPI
ImporterGetForwardedAPIName
ImporterGetForwardedDLLName
ImporterGetForwardedDLLIndex
ImporterGetForwardedAPIOrdinalNumber
ImporterGetNearestAPIAddress
ImporterGetNearestAPIName
ImporterCopyOriginalIAT
ImporterCopyOriginalIATW
ImporterLoadImportTable
ImporterLoadImportTableW
ImporterMoveOriginalIAT
ImporterMoveOriginalIATW
ImporterEnumAddedData
ImporterDeleteAPI
HooksSafeTransition
HooksSafeTransitionEx
HooksIsAddressRedirected
HooksGetTrampolineAddress
HooksGetHookEntryDetails
HooksInsertNewRedirection
HooksInsertNewIATRedirection
HooksInsertNewIATRedirectionEx
HooksRemoveRedirection
HooksRemoveRedirectionsForModule
HooksRemoveIATRedirection
HooksDisableRedirection
HooksDisableRedirectionsForModule
HooksDisableIATRedirection
HooksEnableRedirection
HooksEnableRedirectionsForModule
HooksEnableIATRedirection
HooksScanModuleMemory
HooksScanEntireProcessMemory
HooksScanEntireProcessMemoryEx
GetPEBLocation
GetPEBLocation64
GetTEBLocation
GetTEBLocation64
HideDebugger
UnHideDebugger
RelocaterInit
RelocaterCleanup
RelocaterAddNewRelocation
RelocaterEstimatedSize
RelocaterExportRelocation
RelocaterExportRelocationEx
RelocaterExportRelocationExW
RelocaterGrabRelocationTable
RelocaterGrabRelocationTableEx
RelocaterMakeSnapshot
RelocaterMakeSnapshotW
RelocaterCompareTwoSnapshots
RelocaterCompareTwoSnapshotsW
RelocaterChangeFileBase
RelocaterChangeFileBaseW
RelocaterRelocateMemoryBlock
RelocaterWipeRelocationTable
RelocaterWipeRelocationTableW
ExporterInit
ExporterCleanup
ExporterSetImageBase
ExporterAddNewExport
ExporterAddNewOrdinalExport
ExporterGetAddedExportCount
ExporterEstimatedSize
ExporterBuildExportTable
ExporterBuildExportTableEx
ExporterBuildExportTableExW
ExporterLoadExportTable
ExporterLoadExportTableW
LibrarianSetBreakPoint
LibrarianRemoveBreakPoint
LibrarianGetLibraryInfo
LibrarianGetLibraryInfoW
LibrarianGetLibraryInfoEx
LibrarianGetLibraryInfoExW
LibrarianEnumLibraryInfo
LibrarianEnumLibraryInfoW
SetEngineVariable
TLSRemoveCallback
TLSRemoveCallbackW
TLSRemoveTable
TLSRemoveTableW
TLSBuildNewTable
TLSBuildNewTableEx
TLSBuildNewTableExW
TLSGrabCallBackData
TLSGrabCallBackDataW
TLSBackupData
TLSBackupDataW
TLSRestoreData
TLSBreakOnCallBack
TLSBreakOnCallBackEx
TLSBreakOnCallBackExW
ResourcerLoadFileForResourceUse
ResourcerLoadFileForResourceUseW
ResourcerFreeLoadedFile
ResourcerExtractResourceFromFileEx
ResourcerExtractResourceFromFile
ResourcerExtractResourceFromFileW
ResourcerEnumerateResource
ResourcerEnumerateResourceW
ResourcerEnumerateResourceEx
ResourcerFindResource
ResourcerFindResourceW
ResourcerFindResourceEx
TracerInit
TracerLevel1
HashTracerLevel1
TracerDetectRedirection
TracerFixKnownRedirection
TracerFixRedirectionViaImpRecPlugin
ThreaderImportRunningThreadData
ThreaderEnumThreadInfo
ThreaderGetThreadInfo
ThreaderPauseThread
ThreaderResumeThread
ThreaderTerminateThread
ThreaderPauseAllThreads
ThreaderResumeAllThreads
ThreaderPauseProcess
ThreaderResumeProcess
ThreaderCreateRemoteThread
ThreaderCreateRemoteThreadEx
ThreaderInjectAndExecuteCode
ThreaderInjectAndExecuteCodeEx
ThreaderSetCallBackForNextExitThreadEvent
ThreaderIsExceptionInMainThread
ThreaderIsThreadStillRunning
ThreaderIsThreadActive
ThreaderIsAnyThreadActive
ThreaderExecuteOnlyInjectedThreads
ThreaderGetOpenHandleForThread
StaticFileLoad
StaticFileLoadW
StaticFileUnload
StaticFileUnloadW
StaticFileOpen
StaticFileOpenW
StaticFileGetContent
StaticFileClose
StaticMemoryDecrypt
StaticMemoryDecryptEx
StaticMemoryDecryptSpecial
StaticSectionDecrypt
StaticMemoryDecompress
StaticRawMemoryCopyW
StaticRawMemoryCopy
StaticRawMemoryCopyEx
StaticRawMemoryCopyExW
StaticRawMemoryCopyEx64
StaticRawMemoryCopyEx64W
StaticHashMemory
StaticHashFileW
StaticHashFile
TranslateNativeName
TranslateNativeNameW
HandlerGetActiveHandleCount
HandlerIsHandleOpen
HandlerGetHandleName
HandlerGetHandleNameW
HandlerEnumerateOpenHandles
HandlerGetHandleDetails
HandlerCloseRemoteHandle
HandlerCloseAllLockHandlesW
HandlerEnumerateLockHandles
HandlerEnumerateLockHandlesW
HandlerIsFileLocked
HandlerIsFileLockedW
HandlerCloseAllLockHandles
HandlerEnumerateOpenMutexes
HandlerGetOpenMutexHandle
HandlerGetOpenMutexHandleW
HandlerGetProcessIdWhichCreatedMutex
HandlerGetProcessIdWhichCreatedMutexW
RemoteLoadLibrary
RemoteLoadLibraryW
RemoteFreeLibrary
RemoteFreeLibraryW
RemoteExitProcess
FindOEPInit
FindOEPGenerically
FindOEPGenericallyW
GetActiveProcessId
GetActiveProcessIdW
EnumProcessesWithLibrary
TitanOpenProcess
EngineFakeMissingDependencies
EngineDeleteCreatedDependencies
EngineCreateMissingDependencies
EngineCreateMissingDependenciesW
EngineCreateUnpackerWindow
EngineAddUnpackerWindowLogMessage
EngineCheckStructAlignment
EngineUnpackerInitialize
EngineUnpackerInitializeW
EngineUnpackerSetEntryPointAddress
EngineUnpackerSetBreakCondition
EngineUnpackerFinalizeUnpacking


================================================
File: TitanEngine/TitanEngine.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// BINARY
//

LOADERX86               BINARY                  "..\\TitanEngineLoaders\\LibraryLoader\\x32\\LibraryLoader.exe"
LOADERX64               BINARY                  "..\\TitanEngineLoaders\\LibraryLoader\\x64\\LibraryLoader.exe"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_MAINWINDOW DIALOGEX 0, 0, 255, 168
STYLE DS_SETFONT | DS_MODALFRAME | DS_3DLOOK | DS_NOFAILCREATE | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_ACCEPTFILES
CAPTION "[ TitanEngine2 ]"
FONT 8, "Verdana", 0, 0, 0x1
BEGIN
    CONTROL         "Realign PE32 file [Recommended, but it can produce invalid files]",IDC_REALING,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,6,119,241,14
    EDITTEXT        IDC_FILENAME,43,18,163,12,ES_AUTOHSCROLL | ES_READONLY | NOT WS_BORDER | NOT WS_TABSTOP,WS_EX_STATICEDGE
    CTEXT           "- TitanEngine2 unpacker -",IDD_UNPACKERTITLE,3,2,250,10,SS_SUNKEN | NOT WS_GROUP,WS_EX_STATICEDGE
    LTEXT           "[Filename]",112,3,18,36,10
    GROUPBOX        "Unpack execution messages",113,3,35,250,112
    LISTBOX         IDC_LISTBOX,6,44,243,75,LBS_NOINTEGRALHEIGHT | NOT WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_TABSTOP,WS_EX_STATICEDGE
    PUSHBUTTON      "UnPack",IDC_UNPACK,71,151,60,14,BS_CENTER | BS_VCENTER
    PUSHBUTTON      "Browse",IDC_BROWSE,211,16,40,14,BS_CENTER | BS_VCENTER
    PUSHBUTTON      "About",IDC_ABOUT,131,151,60,14
    PUSHBUTTON      "Exit",IDC_EXIT,191,151,60,14
    CONTROL         131,IDC_STATIC,"Static",SS_BITMAP,6,154,46,9
    CONTROL         "Copy file overlay [Recommended for all SFX files]",IDC_COPYOVERLAY,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,6,131,241,14
END


/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDB_BITMAP2             BITMAP                  "LOGO.bmp"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "FileDescription", "TitanEngine"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "LegalCopyright", "Community"
            VALUE "ProductName", "TitanEngine"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON2               ICON                    "MAINICON.ico"

/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_MAINWINDOW, DIALOG
    BEGIN
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED




================================================
File: TitanEngine/TitanEngine.vcproj
================================================
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="TitanEngine"
	ProjectGUID="{9C7B8246-FDDA-48C7-9634-044969701E40}"
	RootNamespace="TitanEngine"
	Keyword="Win32Proj"
	TargetFrameworkVersion="196613"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				EnableIntrinsicFunctions="false"
				FavorSizeOrSpeed="1"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="0"
				StructMemberAlignment="1"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="4"
				CallingConvention="0"
				CompileAs="2"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="&quot;$(ProjectDir)distorm_x86.lib&quot; Imagehlp.lib psapi.lib"
				OutputFile="$(OutDir)\TitanEngine.dll"
				LinkIncremental="2"
				IgnoreAllDefaultLibraries="false"
				ModuleDefinitionFile="$(ProjectDir)TitanEngine.def"
				AddModuleNamesToAssembly=""
				GenerateDebugInformation="true"
				GenerateMapFile="false"
				MapExports="false"
				SubSystem="2"
				OptimizeReferences="0"
				ResourceOnlyDLL="false"
				SetChecksum="false"
				TargetMachine="1"
				CLRThreadAttribute="0"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				StructMemberAlignment="1"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="3"
				CallingConvention="2"
				CompileAs="2"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="&quot;$(ProjectDir)distorm_x64.lib&quot; Imagehlp.lib psapi.lib"
				OutputFile="$(OutDir)\TitanEngine.dll"
				LinkIncremental="2"
				IgnoreAllDefaultLibraries="false"
				ModuleDefinitionFile="$(ProjectDir)TitanEngine.def"
				GenerateDebugInformation="true"
				GenerateMapFile="false"
				MapExports="false"
				SubSystem="2"
				ResourceOnlyDLL="false"
				SetChecksum="false"
				TargetMachine="17"
				CLRThreadAttribute="2"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				EnableIntrinsicFunctions="false"
				WholeProgramOptimization="false"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS"
				RuntimeLibrary="0"
				StructMemberAlignment="1"
				EnableFunctionLevelLinking="false"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="3"
				CallingConvention="0"
				CompileAs="2"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="&quot;$(ProjectDir)distorm_x86.lib&quot; Imagehlp.lib psapi.lib"
				ModuleDefinitionFile="$(ProjectDir)TitanEngine.def"
				GenerateDebugInformation="false"
				LinkTimeCodeGeneration="0"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				EnableIntrinsicFunctions="true"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS"
				RuntimeLibrary="0"
				StructMemberAlignment="1"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="&quot;$(ProjectDir)distorm_x64.lib&quot; Imagehlp.lib psapi.lib"
				OutputFile="$(OutDir)\TitanEngine.dll"
				LinkIncremental="1"
				IgnoreAllDefaultLibraries="false"
				ModuleDefinitionFile="$(ProjectDir)TitanEngine.def"
				GenerateDebugInformation="false"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				SetChecksum="true"
				FixedBaseAddress="1"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\dllmain.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="0"
						CompileAsManaged="0"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="0"
						CompileAsManaged="0"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="0"
						CompileAsManaged="0"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="0"
						CompileAsManaged="0"
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath=".\stdafx.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath=".\TitanEngine.cpp"
				>
			</File>
			<Filter
				Name="ThirdParty"
				>
				<File
					RelativePath=".\LzmaDec.cpp"
					>
				</File>
			</Filter>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\resource.h"
				>
			</File>
			<File
				RelativePath=".\stdafx.h"
				>
			</File>
			<File
				RelativePath=".\targetver.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
			<File
				RelativePath=".\TitanEngine.rc"
				>
			</File>
			<Filter
				Name="Binary"
				>
				<File
					RelativePath="..\TitanEngineLoaders\LibraryLoader\x64\Release\LibraryLoader.exe"
					>
				</File>
				<File
					RelativePath="..\TitanEngineLoaders\LibraryLoader\Release\LibraryLoader.exe"
					>
				</File>
				<File
					RelativePath="..\TitanEngineLoaders\ReserveLibrary\Release\ReserveLibrary.dll"
					>
				</File>
				<File
					RelativePath="..\TitanEngineLoaders\ReserveLibrary\x64\Release\ReserveLibrary.dll"
					>
				</File>
			</Filter>
			<Filter
				Name="Images"
				>
				<File
					RelativePath=".\HEADER.BMP"
					>
				</File>
				<File
					RelativePath=".\LOGO.bmp"
					>
				</File>
				<File
					RelativePath=".\MAINICON.ico"
					>
				</File>
			</Filter>
		</Filter>
		<File
			RelativePath=".\ReadMe.txt"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>



================================================
File: TitanEngine/TitanEngine.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9C7B8246-FDDA-48C7-9634-044969701E40}</ProjectGuid>
    <RootNamespace>TitanEngine</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(IntDir)x32\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\$(IntDir)x32\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\x32\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\x32\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\x64\</OutDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\$(Configuration)\x64\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\x64\</IntDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\x64\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <PreprocessorDefinitions>WINVER=0x0501;_WIN32_WINNT=0x0501;NTDDI_VERSION=0x05010000;WIN32;NDEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>Cdecl</CallingConvention>
      <CompileAs>CompileAsCpp</CompileAs>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>
      </OmitFramePointers>
      <ExceptionHandling>Sync</ExceptionHandling>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalOptions>/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>$(ProjectDir)ntdll_x86.lib;$(SolutionDir)$(Platform)\Release-Lib\scylla_wrapper_x86.lib;$(ProjectDir)distorm_x86.lib;Imagehlp.lib;psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>$(ProjectDir)TitanEngine.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalOptions>/ignore:4197 /PDBALTPATH:%_PDB% %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>manifest.xml</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <PreprocessorDefinitions>WINVER=0x0501;_WIN32_WINNT=0x0501;NTDDI_VERSION=0x05010000;WIN32;NDEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>Cdecl</CallingConvention>
      <CompileAs>CompileAsCpp</CompileAs>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <OmitFramePointers>
      </OmitFramePointers>
      <ExceptionHandling>Sync</ExceptionHandling>
      <AdditionalOptions>/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>$(ProjectDir)ntdll_x86.lib;$(SolutionDir)$(Platform)\Release-Lib\scylla_wrapper_x86.lib;$(ProjectDir)distorm_x86.lib;Imagehlp.lib;psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>$(ProjectDir)TitanEngine.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalOptions>/ignore:4197 /PDBALTPATH:%_PDB% %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>manifest.xml</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Full</Optimization>
      <PreprocessorDefinitions>WINVER=0x0502;_WIN32_WINNT=0x0502;NTDDI_VERSION=0x05020000;_AMD64_;_WIN64;NDEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalOptions>/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>$(ProjectDir)ntdll_x64.lib;$(SolutionDir)$(Platform)\Release-Lib\scylla_wrapper_x64.lib;$(ProjectDir)distorm_x64.lib;Imagehlp.lib;psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)TitanEngine.dll</OutputFile>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <ModuleDefinitionFile>$(ProjectDir)TitanEngine.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>false</FixedBaseAddress>
      <TargetMachine>MachineX64</TargetMachine>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
      <AdditionalOptions>/ignore:4197 /PDBALTPATH:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>manifest.xml</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WINVER=0x0502;_WIN32_WINNT=0x0502;NTDDI_VERSION=0x05020000;_AMD64_;_WIN64;NDEBUG;_WINDOWS;_USRDLL;UNPACKERENGINE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <AdditionalOptions>/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>$(ProjectDir)ntdll_x64.lib;$(SolutionDir)$(Platform)\Release-Lib\scylla_wrapper_x64.lib;$(ProjectDir)distorm_x64.lib;Imagehlp.lib;psapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)TitanEngine.dll</OutputFile>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <ModuleDefinitionFile>$(ProjectDir)TitanEngine.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>false</FixedBaseAddress>
      <TargetMachine>MachineX64</TargetMachine>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
      <AdditionalOptions>/ignore:4197 /PDBALTPATH:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>manifest.xml</AdditionalManifestFiles>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Global.Breakpoints.cpp" />
    <ClCompile Include="Global.Debugger.cpp" />
    <ClCompile Include="Global.Engine.Context.cpp" />
    <ClCompile Include="Global.Engine.cpp" />
    <ClCompile Include="Global.Engine.Hash.cpp" />
    <ClCompile Include="Global.Engine.Hider.cpp" />
    <ClCompile Include="Global.Engine.Hook.cpp" />
    <ClCompile Include="Global.Engine.Importer.cpp" />
    <ClCompile Include="Global.Engine.Simplification.cpp" />
    <ClCompile Include="Global.Engine.Threading.cpp" />
    <ClCompile Include="Global.Garbage.cpp" />
    <ClCompile Include="Global.Handle.cpp" />
    <ClCompile Include="Global.Helper.cpp" />
    <ClCompile Include="Global.Injector.cpp" />
    <ClCompile Include="Global.Librarian.cpp" />
    <ClCompile Include="Global.Mapping.cpp" />
    <ClCompile Include="Global.OEPFinder.cpp" />
    <ClCompile Include="Global.Realigner.cpp" />
    <ClCompile Include="Global.Threader.cpp" />
    <ClCompile Include="Global.Engine.GUI.cpp" />
    <ClCompile Include="Global.TLS.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="TitanEngine.Breakpoints.cpp" />
    <ClCompile Include="TitanEngine.cpp" />
    <ClCompile Include="LzmaDec.cpp" />
    <ClCompile Include="TitanEngine.Debugger.Context.cpp" />
    <ClCompile Include="TitanEngine.Debugger.Control.cpp" />
    <ClCompile Include="TitanEngine.Debugger.cpp" />
    <ClCompile Include="TitanEngine.Debugger.Data.cpp" />
    <ClCompile Include="TitanEngine.Debugger.Helper.cpp" />
    <ClCompile Include="TitanEngine.Debugger.Memory.cpp" />
    <ClCompile Include="TitanEngine.Disassembler.cpp" />
    <ClCompile Include="TitanEngine.Dumper.cpp" />
    <ClCompile Include="TitanEngine.Engine.cpp" />
    <ClCompile Include="TitanEngine.Engine.Simplification.cpp" />
    <ClCompile Include="TitanEngine.Exporter.cpp" />
    <ClCompile Include="TitanEngine.Handler.cpp" />
    <ClCompile Include="TitanEngine.Hider.cpp" />
    <ClCompile Include="TitanEngine.Hooks.cpp" />
    <ClCompile Include="TitanEngine.Importer.cpp" />
    <ClCompile Include="TitanEngine.Injector.cpp" />
    <ClCompile Include="TitanEngine.Librarian.cpp" />
    <ClCompile Include="TitanEngine.OEPFinder.cpp" />
    <ClCompile Include="TitanEngine.PE.Convert.cpp" />
    <ClCompile Include="TitanEngine.PE.cpp" />
    <ClCompile Include="TitanEngine.PE.Fixer.cpp" />
    <ClCompile Include="TitanEngine.Process.cpp" />
    <ClCompile Include="TitanEngine.Realigner.cpp" />
    <ClCompile Include="TitanEngine.Relocator.cpp" />
    <ClCompile Include="TitanEngine.Resourcer.cpp" />
    <ClCompile Include="TitanEngine.Static.cpp" />
    <ClCompile Include="TitanEngine.Threader.cpp" />
    <ClCompile Include="TitanEngine.TLS.cpp" />
    <ClCompile Include="TitanEngine.Tracer.cpp" />
    <ClCompile Include="TitanEngine.TranslateName.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\SDK\C\TitanEngine.h" />
    <ClInclude Include="aplib.h" />
    <ClInclude Include="definitions.h" />
    <ClInclude Include="distorm.h" />
    <ClInclude Include="Global.Breakpoints.h" />
    <ClInclude Include="Global.Debugger.h" />
    <ClInclude Include="Global.Engine.Context.h" />
    <ClInclude Include="Global.Engine.h" />
    <ClInclude Include="Global.Engine.Hider.h" />
    <ClInclude Include="Global.Engine.Hook.h" />
    <ClInclude Include="Global.Engine.Importer.h" />
    <ClInclude Include="Global.Engine.Simplification.h" />
    <ClInclude Include="Global.Engine.Threading.h" />
    <ClInclude Include="Global.Garbage.h" />
    <ClInclude Include="Global.Handle.h" />
    <ClInclude Include="Global.Helper.h" />
    <ClInclude Include="Global.Injector.h" />
    <ClInclude Include="Global.Librarian.h" />
    <ClInclude Include="Global.Mapping.h" />
    <ClInclude Include="Global.OEPFinder.h" />
    <ClInclude Include="Global.Realigner.h" />
    <ClInclude Include="Global.Threader.h" />
    <ClInclude Include="Global.Engine.GUI.h" />
    <ClInclude Include="Global.TLS.h" />
    <ClInclude Include="LzmaDec.h" />
    <ClInclude Include="LzmaTypes.h" />
    <ClInclude Include="ntdll.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="scylla_wrapper.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="TitanEngine.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\TitanEngineLoaders\LibraryLoader\x32\LibraryLoader.exe" />
    <None Include="..\TitanEngineLoaders\LibraryLoader\x64\LibraryLoader.exe" />
    <None Include="Global.Engine.Hash.h" />
    <None Include="LOGO.bmp" />
    <None Include="MAINICON.ico" />
    <ClCompile Include="TitanEngine.PE.Data.cpp" />
    <ClCompile Include="TitanEngine.PE.Section.cpp">
      <FileType>Document</FileType>
    </ClCompile>
    <ClCompile Include="TitanEngine.PE.Overlay.cpp">
      <FileType>Document</FileType>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.DebugLoop.cpp">
      <FileType>Document</FileType>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\scylla_wrapper_dll\scylla_wrapper\scylla_wrapper.vcxproj">
      <Project>{f874b1b3-8ef7-4df1-9889-57098e08a51c}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: TitanEngine/TitanEngine.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Source Files\ThirdParty">
      <UniqueIdentifier>{bf918bb7-d305-4123-9e17-3f28f4796516}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
    <Filter Include="Resource Files\Binary">
      <UniqueIdentifier>{0f4957c0-547f-4f5e-8133-a34644b29c2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files\Images">
      <UniqueIdentifier>{b4e0243e-1a54-40fe-be40-e7cc7a16c3e1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\TitanEngine">
      <UniqueIdentifier>{e6d39ee2-6c2c-444f-a68e-26a14ba4b11a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\TitanEngine">
      <UniqueIdentifier>{11622163-c50b-481a-9db8-1993dc220a72}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\ThirdParty">
      <UniqueIdentifier>{db6d0b8a-e5c1-4a1e-9157-5818612589f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\SDK">
      <UniqueIdentifier>{78336e4f-e571-4dd2-8769-e408515a5493}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\SDK\C">
      <UniqueIdentifier>{2efe2f1a-4ee7-4249-a67c-c51a63aa8f0d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LzmaDec.cpp">
      <Filter>Source Files\ThirdParty</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Dumper.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Mapping.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Handle.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.Hash.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.PE.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.PE.Section.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.PE.Overlay.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.PE.Data.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.PE.Convert.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Realigner.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Realigner.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.PE.Fixer.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.Hider.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Hider.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Relocator.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Resourcer.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Threader.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Threader.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Debugger.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Disassembler.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Breakpoints.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Breakpoints.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.Context.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.Memory.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.Helper.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.Data.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.DebugLoop.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Librarian.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.TLS.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Debugger.Control.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.OEPFinder.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.OEPFinder.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Importer.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Hooks.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Tracer.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Exporter.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Librarian.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Process.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.TLS.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.TranslateName.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Handler.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Injector.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Injector.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Static.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Engine.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.Hook.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.GUI.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.Simplification.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="TitanEngine.Engine.Simplification.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Garbage.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.Threading.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.Importer.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Helper.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
    <ClCompile Include="Global.Engine.Context.cpp">
      <Filter>Source Files\TitanEngine</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="definitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Global.Mapping.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Handle.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Realigner.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.Hider.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Threader.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Debugger.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Breakpoints.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Librarian.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.TLS.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.OEPFinder.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Injector.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.Hook.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.GUI.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.Simplification.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Garbage.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.Threading.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="ntdll.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Global.Helper.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="ntdll.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.Importer.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="aplib.h">
      <Filter>Header Files\ThirdParty</Filter>
    </ClInclude>
    <ClInclude Include="distorm.h">
      <Filter>Header Files\ThirdParty</Filter>
    </ClInclude>
    <ClInclude Include="LzmaDec.h">
      <Filter>Header Files\ThirdParty</Filter>
    </ClInclude>
    <ClInclude Include="LzmaTypes.h">
      <Filter>Header Files\ThirdParty</Filter>
    </ClInclude>
    <ClInclude Include="scylla_wrapper.h">
      <Filter>Header Files\ThirdParty</Filter>
    </ClInclude>
    <ClInclude Include="..\SDK\C\TitanEngine.h">
      <Filter>Header Files\SDK\C</Filter>
    </ClInclude>
    <ClInclude Include="Global.Engine.Context.h">
      <Filter>Header Files\TitanEngine</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="TitanEngine.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\TitanEngineLoaders\LibraryLoader\x64\LibraryLoader.exe">
      <Filter>Resource Files\Binary</Filter>
    </None>
    <None Include="..\TitanEngineLoaders\LibraryLoader\x32\LibraryLoader.exe">
      <Filter>Resource Files\Binary</Filter>
    </None>
    <None Include="LOGO.bmp">
      <Filter>Resource Files\Images</Filter>
    </None>
    <None Include="MAINICON.ico">
      <Filter>Resource Files\Images</Filter>
    </None>
    <None Include="Global.Engine.Hash.h">
      <Filter>Header Files\TitanEngine</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: TitanEngine/TitanEngine.workspace
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_workspace_file>
	<Workspace title="Workspace">
		<Project filename="TitanEngine.cbp" />
	</Workspace>
</CodeBlocks_workspace_file>



================================================
File: TitanEngine/aplib.h
================================================
/*
 * aPLib compression library  -  the smaller the better :)
 *
 * COFF format header file
 *
 * Copyright (c) 1998-2014 Joergen Ibsen
 * All Rights Reserved
 *
 * http://www.ibsensoftware.com/
 */

#ifndef APLIB_H_INCLUDED
#define APLIB_H_INCLUDED

#define APLIB_CONVENTION

#ifdef __cplusplus
extern "C" {
#endif

#ifndef APLIB_ERROR
# define APLIB_ERROR ((unsigned int) (-1))
#endif

unsigned int APLIB_CONVENTION aP_pack(const void* source,
                                      void* destination,
                                      unsigned int length,
                                      void* workmem,
                                      int (__cdecl* callback)(unsigned int, unsigned int, unsigned int, void*),
                                      void* cbparam);

unsigned int APLIB_CONVENTION aP_workmem_size(unsigned int inputsize);

unsigned int APLIB_CONVENTION aP_max_packed_size(unsigned int inputsize);

unsigned int APLIB_CONVENTION aP_depack_asm(const void* source, void* destination);

unsigned int APLIB_CONVENTION aP_depack_asm_fast(const void* source, void* destination);

inline unsigned int APLIB_CONVENTION aP_depack_asm_safe(const void* source,
        unsigned int srclen,
        void* destination,
        unsigned int dstlen)
{
    return 0;
}

unsigned int APLIB_CONVENTION aP_crc32(const void* source, unsigned int length);

unsigned int APLIB_CONVENTION aPsafe_pack(const void* source,
        void* destination,
        unsigned int length,
        void* workmem,
        int (__cdecl* callback)(unsigned int, unsigned int, unsigned int, void*),
        void* cbparam);

unsigned int APLIB_CONVENTION aPsafe_check(const void* source);

unsigned int APLIB_CONVENTION aPsafe_get_orig_size(const void* source);

inline unsigned int APLIB_CONVENTION aPsafe_depack(const void* source,
        unsigned int srclen,
        void* destination,
        unsigned int dstlen)
{
    return 0;
}

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* APLIB_H_INCLUDED */



================================================
File: TitanEngine/definitions.h
================================================
#ifndef definitions_h__
#define definitions_h__

#define TITCALL

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(char* szFileName, char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(wchar_t* szFileName, wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(char* szFileName, char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(wchar_t* szFileName, wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(char* szFileName, char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(wchar_t* szFileName, wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(char* szInFileName, char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(wchar_t* szInFileName, wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(char* szFileName, char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(wchar_t* szFileName, char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(char* szFileName, char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(wchar_t* szFileName, char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(char* szFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(wchar_t* szFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, char* szDumpFile1, char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, wchar_t* szDumpFile1, wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(ULONG_PTR FileMapVA, char* szResourceType, char* szResourceName, char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(char* szFileName, char* szResourceType, char* szResourceName, char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(wchar_t* szFileName, char* szResourceType, char* szResourceName, char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(char* szFileName, char* szResourceType, DWORD ResourceType, char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(wchar_t* szFileName, wchar_t* szResourceType, DWORD ResourceType, wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, wchar_t* szResourceType, DWORD ResourceType, wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebugW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(char* szFileName, char* szCommandLine, char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(char* szFileName, bool ReserveModuleBase, char* szCommandLine, char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(wchar_t* szFileName, bool ReserveModuleBase, wchar_t* szCommandLine, wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetAVX512Context(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVX512Context(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_AVX512_t* titcontext);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(char* szFileName, bool ReserveModuleBase, char* szCommandLine, char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(wchar_t* szFileName, bool ReserveModuleBase, wchar_t* szCommandLine, wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(char* szDumpFileName, char* szExportFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(wchar_t* szDumpFileName, wchar_t* szExportFileName, wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(char* szDLLName, char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, WCHAR* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(char* szOriginalFile, char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(wchar_t* szOriginalFile, wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(char* szOriginalFile, char* szDumpFile, char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(wchar_t* szOriginalFile, wchar_t* szDumpFile, char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, char* szDumpedFile, char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, wchar_t* szDumpedFile, wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(char* szModuleName, char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(char* szModuleName, char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(char* szModuleName, char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(char* szModuleName, char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(char* szExportFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(wchar_t* szExportFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(char* szFileName, char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(wchar_t* szFileName, char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(char* szFileName, char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(wchar_t* szFileName, wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(char* szFileName, char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(wchar_t* szFileName, wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(char* WindowUnpackerTitle, char* WindowUnpackerLongTitle, char* WindowUnpackerName, char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);

#ifdef __cplusplus
}
#endif /*__cplusplus*/


#endif // definitions_h__




================================================
File: TitanEngine/distorm.h
================================================
/* diStorm3 3.3 */

/*
distorm.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2012 Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef DISTORM_H
#define DISTORM_H

/*
 * 64 bit offsets support:
 * If the diStorm library you use was compiled with 64 bits offsets,
 * make sure you compile your own code with the following macro set:
 * SUPPORT_64BIT_OFFSET
 * Otherwise comment it out, or you will get a linker error of an unresolved symbol...
 * Turned on by default!
 */

#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))
/* Define this macro for outer projects by default. */
#define SUPPORT_64BIT_OFFSET
#endif

/* TINYC has a problem with some 64bits library functions, so ignore 64 bit offsets. */
#ifdef __TINYC__
#undef SUPPORT_64BIT_OFFSET
#endif

/* If your compiler doesn't support stdint.h, define your own 64 bits type. */
#ifdef SUPPORT_64BIT_OFFSET
#ifdef _MSC_VER
#define OFFSET_INTEGER unsigned __int64
#else
#include <stdint.h>
#define OFFSET_INTEGER uint64_t
#endif
#else
/* 32 bit offsets are used. */
#define OFFSET_INTEGER unsigned long
#endif

#ifdef _MSC_VER
/* Since MSVC isn't shipped with stdint.h, we will have our own: */
typedef signed __int64      int64_t;
typedef unsigned __int64    uint64_t;
typedef signed __int32      int32_t;
typedef unsigned __int32    uint32_t;
typedef signed __int16      int16_t;
typedef unsigned __int16    uint16_t;
typedef signed __int8       int8_t;
typedef unsigned __int8     uint8_t;
#endif

/* Support C++ compilers */
#ifdef __cplusplus
extern "C" {
#endif


/* ***  Helper Macros  *** */

/* Get the ISC of the instruction, used with the definitions below. */
#define META_GET_ISC(meta) (((meta) >> 3) & 0x1f)
#define META_SET_ISC(di, isc) (((di)->meta) |= ((isc) << 3))
/* Get the flow control flags of the instruction, see 'features for decompose' below. */
#define META_GET_FC(meta) ((meta) & 0x7)

/* Get the target address of a branching instruction. O_PC operand type. */
#define INSTRUCTION_GET_TARGET(di) ((_OffsetType)(((di)->addr + (di)->imm.addr + (di)->size)))
/* Get the target address of a RIP-relative memory indirection. */
#define INSTRUCTION_GET_RIP_TARGET(di) ((_OffsetType)(((di)->addr + (di)->disp + (di)->size)))

/*
 * Operand Size or Adderss size are stored inside the flags:
 * 0 - 16 bits
 * 1 - 32 bits
 * 2 - 64 bits
 * 3 - reserved
 *
 * If you call these set-macros more than once, you will have to clean the bits before doing so.
 */
#define FLAG_SET_OPSIZE(di, size) ((di->flags) |= (((size) & 3) << 8))
#define FLAG_SET_ADDRSIZE(di, size) ((di->flags) |= (((size) & 3) << 10))
#define FLAG_GET_OPSIZE(flags) (((flags) >> 8) & 3)
#define FLAG_GET_ADDRSIZE(flags) (((flags) >> 10) & 3)
/* To get the LOCK/REPNZ/REP prefixes. */
#define FLAG_GET_PREFIX(flags) ((flags) & 7)

/*
 * Macros to extract segment registers from 'segment':
 */
#define SEGMENT_DEFAULT 0x80
#define SEGMENT_SET(di, seg) ((di->segment) |= seg)
#define SEGMENT_GET(segment) (((segment) == R_NONE) ? R_NONE : ((segment) & 0x7f))
#define SEGMENT_IS_DEFAULT(segment) (((segment) & SEGMENT_DEFAULT) == SEGMENT_DEFAULT)


/* Decodes modes of the disassembler, 16 bits or 32 bits or 64 bits for AMD64, x86-64. */
typedef enum
{
    Decode16Bits = 0, Decode32Bits = 1, Decode64Bits = 2
}
_DecodeType;

typedef OFFSET_INTEGER _OffsetType;

typedef struct
{
    _OffsetType codeOffset, nextOffset; /* nextOffset is OUT only. */
    const uint8_t* code;
    int codeLen; /* Using signed integer makes it easier to detect an underflow. */
    _DecodeType dt;
    unsigned int features;
} _CodeInfo;

typedef enum { O_NONE, O_REG, O_IMM, O_IMM1, O_IMM2, O_DISP, O_SMEM, O_MEM, O_PC, O_PTR } _OperandType;

typedef union
{
    /* Used by O_IMM: */
    int8_t sbyte;
    uint8_t byte;
    int16_t sword;
    uint16_t word;
    int32_t sdword;
    uint32_t dword;
    int64_t sqword; /* All immediates are SIGN-EXTENDED to 64 bits! */
    uint64_t qword;

    /* Used by O_PC: (Use GET_TARGET_ADDR).*/
    _OffsetType addr; /* It's a relative offset as for now. */

    /* Used by O_PTR: */
    struct
    {
        uint16_t seg;
        /* Can be 16 or 32 bits, size is in ops[n].size. */
        uint32_t off;
    } ptr;

    /* Used by O_IMM1 (i1) and O_IMM2 (i2). ENTER instruction only. */
    struct
    {
        uint32_t i1;
        uint32_t i2;
    } ex;
} _Value;

typedef struct
{
    /* Type of operand:
        O_NONE: operand is to be ignored.
        O_REG: index holds global register index.
        O_IMM: instruction.imm.
        O_IMM1: instruction.imm.ex.i1.
        O_IMM2: instruction.imm.ex.i2.
        O_DISP: memory dereference with displacement only, instruction.disp.
        O_SMEM: simple memory dereference with optional displacement (a single register memory dereference).
        O_MEM: complex memory dereference (optional fields: s/i/b/disp).
        O_PC: the relative address of a branch instruction (instruction.imm.addr).
        O_PTR: the absolute target address of a far branch instruction (instruction.imm.ptr.seg/off).
    */
    uint8_t type; /* _OperandType */

    /* Index of:
        O_REG: holds global register index
        O_SMEM: holds the 'base' register. E.G: [ECX], [EBX+0x1234] are both in operand.index.
        O_MEM: holds the 'index' register. E.G: [EAX*4] is in operand.index.
    */
    uint8_t index;

    /* Size of:
        O_REG: register
        O_IMM: instruction.imm
        O_IMM1: instruction.imm.ex.i1
        O_IMM2: instruction.imm.ex.i2
        O_DISP: instruction.disp
        O_SMEM: size of indirection.
        O_MEM: size of indirection.
        O_PC: size of the relative offset
        O_PTR: size of instruction.imm.ptr.off (16 or 32)
    */
    uint16_t size;
} _Operand;

#define OPCODE_ID_NONE 0
/* Instruction could not be disassembled. */
#define FLAG_NOT_DECODABLE ((uint16_t)-1)
/* The instruction locks memory access. */
#define FLAG_LOCK (1 << 0)
/* The instruction is prefixed with a REPNZ. */
#define FLAG_REPNZ (1 << 1)
/* The instruction is prefixed with a REP, this can be a REPZ, it depends on the specific instruction. */
#define FLAG_REP (1 << 2)
/* Indicates there is a hint taken for Jcc instructions only. */
#define FLAG_HINT_TAKEN (1 << 3)
/* Indicates there is a hint non-taken for Jcc instructions only. */
#define FLAG_HINT_NOT_TAKEN (1 << 4)
/* The Imm value is signed extended. */
#define FLAG_IMM_SIGNED (1 << 5)
/* The destination operand is writable. */
#define FLAG_DST_WR (1 << 6)
/* The instruction uses RIP-relative indirection. */
#define FLAG_RIP_RELATIVE (1 << 7)

/* No register was defined. */
#define R_NONE ((uint8_t)-1)

#define REGS64_BASE 0
#define REGS32_BASE 16
#define REGS16_BASE 32
#define REGS8_BASE 48
#define REGS8_REX_BASE 64
#define SREGS_BASE 68
#define FPUREGS_BASE 75
#define MMXREGS_BASE 83
#define SSEREGS_BASE 91
#define AVXREGS_BASE 107
#define CREGS_BASE 123
#define DREGS_BASE 132

#define OPERANDS_NO (4)

typedef struct
{
    /* Used by ops[n].type == O_IMM/O_IMM1&O_IMM2/O_PTR/O_PC. Its size is ops[n].size. */
    _Value imm;
    /* Used by ops[n].type == O_SMEM/O_MEM/O_DISP. Its size is dispSize. */
    uint64_t disp;
    /* Virtual address of first byte of instruction. */
    _OffsetType addr;
    /* General flags of instruction, holds prefixes and more, if FLAG_NOT_DECODABLE, instruction is invalid. */
    uint16_t flags;
    /* Unused prefixes mask, for each bit that is set that prefix is not used (LSB is byte [addr + 0]). */
    uint16_t unusedPrefixesMask;
    /* Mask of registers that were used in the operands, only used for quick look up, in order to know *some* operand uses that register class. */
    uint16_t usedRegistersMask;
    /* ID of opcode in the global opcode table. Use for mnemonic look up. */
    uint16_t opcode;
    /* Up to four operands per instruction, ignored if ops[n].type == O_NONE. */
    _Operand ops[OPERANDS_NO];
    /* Size of the whole instruction. */
    uint8_t size;
    /* Segment information of memory indirection, default segment, or overriden one, can be -1. Use SEGMENT macros. */
    uint8_t segment;
    /* Used by ops[n].type == O_MEM. Base global register index (might be R_NONE), scale size (2/4/8), ignored for 0 or 1. */
    uint8_t base, scale;
    uint8_t dispSize;
    /* Meta defines the instruction set class, and the flow control flags. Use META macros. */
    uint8_t meta;
    /* The CPU flags that the instruction operates upon. */
    uint8_t modifiedFlagsMask, testedFlagsMask, undefinedFlagsMask;
} _DInst;

#ifndef DISTORM_LIGHT

/* Static size of strings. Do not change this value. Keep Python wrapper in sync. */
#define MAX_TEXT_SIZE (48)
typedef struct
{
    unsigned int length;
    unsigned char p[MAX_TEXT_SIZE]; /* p is a null terminated string. */
} _WString;

/*
 * Old decoded instruction structure in text format.
 * Used only for backward compatibility with diStorm64.
 * This structure holds all information the disassembler generates per instruction.
 */
typedef struct
{
    _WString mnemonic; /* Mnemonic of decoded instruction, prefixed if required by REP, LOCK etc. */
    _WString operands; /* Operands of the decoded instruction, up to 3 operands, comma-seperated. */
    _WString instructionHex; /* Hex dump - little endian, including prefixes. */
    unsigned int size; /* Size of decoded instruction. */
    _OffsetType offset; /* Start offset of the decoded instruction. */
} _DecodedInst;

#endif /* DISTORM_LIGHT */

/* Register masks for quick look up, each mask indicates one of a register-class that is being used in some operand. */
#define RM_AX 1     /* AL, AH, AX, EAX, RAX */
#define RM_CX 2     /* CL, CH, CX, ECX, RCX */
#define RM_DX 4     /* DL, DH, DX, EDX, RDX */
#define RM_BX 8     /* BL, BH, BX, EBX, RBX */
#define RM_SP 0x10  /* SPL, SP, ESP, RSP */
#define RM_BP 0x20  /* BPL, BP, EBP, RBP */
#define RM_SI 0x40  /* SIL, SI, ESI, RSI */
#define RM_DI 0x80  /* DIL, DI, EDI, RDI */
#define RM_FPU 0x100 /* ST(0) - ST(7) */
#define RM_MMX 0x200 /* MM0 - MM7 */
#define RM_SSE 0x400 /* XMM0 - XMM15 */
#define RM_AVX 0x800 /* YMM0 - YMM15 */
#define RM_CR 0x1000 /* CR0, CR2, CR3, CR4, CR8 */
#define RM_DR 0x2000 /* DR0, DR1, DR2, DR3, DR6, DR7 */
/* RIP should be checked using the 'flags' field and FLAG_RIP_RELATIVE.
 * Segments should be checked using the segment macros.
 * For now R8 - R15 are not supported and non general purpose registers map into same RM.
 */

/* CPU Flags that instructions modify, test or undefine. */
#define D_ZF 1 /* Zero */
#define D_SF 2 /* Sign */
#define D_CF 4 /* Carry */
#define D_OF 8 /* Overflow */
#define D_PF 0x10 /* Parity */
#define D_AF 0x20 /* Auxilary */
#define D_DF 0x40 /* Direction */
#define D_IF 0x80 /* Interrupt */

/*
 * Instructions Set classes:
 * if you want a better understanding of the available classes, look at disOps project, file: x86sets.py.
 */
/* Indicates the instruction belongs to the General Integer set. */
#define ISC_INTEGER 1
/* Indicates the instruction belongs to the 387 FPU set. */
#define ISC_FPU 2
/* Indicates the instruction belongs to the P6 set. */
#define ISC_P6 3
/* Indicates the instruction belongs to the MMX set. */
#define ISC_MMX 4
/* Indicates the instruction belongs to the SSE set. */
#define ISC_SSE 5
/* Indicates the instruction belongs to the SSE2 set. */
#define ISC_SSE2 6
/* Indicates the instruction belongs to the SSE3 set. */
#define ISC_SSE3 7
/* Indicates the instruction belongs to the SSSE3 set. */
#define ISC_SSSE3 8
/* Indicates the instruction belongs to the SSE4.1 set. */
#define ISC_SSE4_1 9
/* Indicates the instruction belongs to the SSE4.2 set. */
#define ISC_SSE4_2 10
/* Indicates the instruction belongs to the AMD's SSE4.A set. */
#define ISC_SSE4_A 11
/* Indicates the instruction belongs to the 3DNow! set. */
#define ISC_3DNOW 12
/* Indicates the instruction belongs to the 3DNow! Extensions set. */
#define ISC_3DNOWEXT 13
/* Indicates the instruction belongs to the VMX (Intel) set. */
#define ISC_VMX 14
/* Indicates the instruction belongs to the SVM (AMD) set. */
#define ISC_SVM 15
/* Indicates the instruction belongs to the AVX (Intel) set. */
#define ISC_AVX 16
/* Indicates the instruction belongs to the FMA (Intel) set. */
#define ISC_FMA 17
/* Indicates the instruction belongs to the AES/AVX (Intel) set. */
#define ISC_AES 18
/* Indicates the instruction belongs to the CLMUL (Intel) set. */
#define ISC_CLMUL 19

/* Features for decompose: */
#define DF_NONE 0
/* The decoder will limit addresses to a maximum of 16 bits. */
#define DF_MAXIMUM_ADDR16 1
/* The decoder will limit addresses to a maximum of 32 bits. */
#define DF_MAXIMUM_ADDR32 2
/* The decoder will return only flow control instructions (and filter the others internally). */
#define DF_RETURN_FC_ONLY 4
/* The decoder will stop and return to the caller when the instruction 'CALL' (near and far) was decoded. */
#define DF_STOP_ON_CALL 8
/* The decoder will stop and return to the caller when the instruction 'RET' (near and far) was decoded. */
#define DF_STOP_ON_RET 0x10
/* The decoder will stop and return to the caller when the instruction system-call/ret was decoded. */
#define DF_STOP_ON_SYS 0x20
/* The decoder will stop and return to the caller when any of the branch 'JMP', (near and far) instructions were decoded. */
#define DF_STOP_ON_UNC_BRANCH 0x40
/* The decoder will stop and return to the caller when any of the conditional branch instruction were decoded. */
#define DF_STOP_ON_CND_BRANCH 0x80
/* The decoder will stop and return to the caller when the instruction 'INT' (INT, INT1, INTO, INT 3) was decoded. */
#define DF_STOP_ON_INT 0x100
/* The decoder will stop and return to the caller when any of the 'CMOVxx' instruction was decoded. */
#define DF_STOP_ON_CMOV 0x200
/* The decoder will stop and return to the caller when any flow control instruction was decoded. */
#define DF_STOP_ON_FLOW_CONTROL (DF_STOP_ON_CALL | DF_STOP_ON_RET | DF_STOP_ON_SYS | DF_STOP_ON_UNC_BRANCH | DF_STOP_ON_CND_BRANCH | DF_STOP_ON_INT | DF_STOP_ON_CMOV)

/* Indicates the instruction is not a flow-control instruction. */
#define FC_NONE 0
/* Indicates the instruction is one of: CALL, CALL FAR. */
#define FC_CALL 1
/* Indicates the instruction is one of: RET, IRET, RETF. */
#define FC_RET 2
/* Indicates the instruction is one of: SYSCALL, SYSRET, SYSENTER, SYSEXIT. */
#define FC_SYS 3
/* Indicates the instruction is one of: JMP, JMP FAR. */
#define FC_UNC_BRANCH 4
/*
 * Indicates the instruction is one of:
 * JCXZ, JO, JNO, JB, JAE, JZ, JNZ, JBE, JA, JS, JNS, JP, JNP, JL, JGE, JLE, JG, LOOP, LOOPZ, LOOPNZ.
 */
#define FC_CND_BRANCH 5
/* Indiciates the instruction is one of: INT, INT1, INT 3, INTO, UD2. */
#define FC_INT 6
/* Indicates the instruction is one of: CMOVxx. */
#define FC_CMOV 7

/* Return code of the decoding function. */
typedef enum { DECRES_NONE, DECRES_SUCCESS, DECRES_MEMORYERR, DECRES_INPUTERR, DECRES_FILTERED } _DecodeResult;

/* Define the following interface functions only for outer projects. */
#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))

/* distorm_decode
 * Input:
 *         offset - Origin of the given code (virtual address that is), NOT an offset in code.
 *         code - Pointer to the code buffer to be disassembled.
 *         length - Amount of bytes that should be decoded from the code buffer.
 *         dt - Decoding mode, 16 bits (Decode16Bits), 32 bits (Decode32Bits) or AMD64 (Decode64Bits).
 *         result - Array of type _DecodeInst which will be used by this function in order to return the disassembled instructions.
 *         maxInstructions - The maximum number of entries in the result array that you pass to this function, so it won't exceed its bound.
 *         usedInstructionsCount - Number of the instruction that successfully were disassembled and written to the result array.
 * Output: usedInstructionsCount will hold the number of entries used in the result array
 *         and the result array itself will be filled with the disassembled instructions.
 * Return: DECRES_SUCCESS on success (no more to disassemble), DECRES_INPUTERR on input error (null code buffer, invalid decoding mode, etc...),
 *         DECRES_MEMORYERR when there are not enough entries to use in the result array, BUT YOU STILL have to check for usedInstructionsCount!
 * Side-Effects: Even if the return code is DECRES_MEMORYERR, there might STILL be data in the
 *               array you passed, this function will try to use as much entries as possible!
 * Notes:  1)The minimal size of maxInstructions is 15.
 *         2)You will have to synchronize the offset,code and length by yourself if you pass code fragments and not a complete code block!
 */
#ifdef SUPPORT_64BIT_OFFSET

_DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
#define distorm_decompose distorm_decompose64

#ifndef DISTORM_LIGHT
/* If distorm-light is defined, we won't export these text-formatting functionality. */
_DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
#define distorm_decode distorm_decode64
#define distorm_format distorm_format64
#endif /*DISTORM_LIGHT*/

#else /*SUPPORT_64BIT_OFFSET*/

_DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
#define distorm_decompose distorm_decompose32

#ifndef DISTORM_LIGHT
/* If distorm-light is defined, we won't export these text-formatting functionality. */
_DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
#define distorm_decode distorm_decode32
#define distorm_format distorm_format32
#endif /*DISTORM_LIGHT*/

#endif

/*
 * distorm_version
 * Input:
 *        none
 *
 * Output: unsigned int - version of compiled library.
 */
unsigned int distorm_version();

#endif /* DISTORM_STATIC */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#endif /* DISTORM_H */



================================================
File: TitanEngine/manifest.xml
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <dependency>
    <dependentAssembly>
      <assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"/>
    </dependentAssembly>
  </dependency>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel
          level="asInvoker"
          uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>


================================================
File: TitanEngine/ntdll.h
================================================
#ifndef _NTDLL_H
#define _NTDLL_H

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WIN32_NO_STATUS
#define WIN32_NO_STATUS
#endif
#include <Windows.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
#include <intrin.h>

#define NT_SUCCESS(Status)              ((NTSTATUS)(Status) >= 0)
#define NT_ERROR(Status)                ((((ULONG)(Status)) >> 30) == 3)

#define FASTCALL __fastcall

#ifndef _Reserved_
#define _Reserved_
#endif

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define MIN(a,b)    (((a) < (b)) ? (a) : (b))
#define MAX(a,b)    (((a) > (b)) ? (a) : (b))

typedef LONG NTSTATUS, *PNTSTATUS;
typedef LONG KPRIORITY, *PKPRIORITY;
typedef ULONG LOGICAL, *PLOGICAL;

typedef struct _CLIENT_ID
{
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

enum KPROCESSOR_MODE
{
    KernelMode,
    UserMode
};

typedef enum _KTHREAD_STATE
{
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState
} KTHREAD_STATE, *PKTHREAD_STATE;

typedef enum _KWAIT_REASON
{
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    MaximumWaitReason
} KWAIT_REASON;

typedef enum _EVENT_TYPE
{
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef enum _TIMER_TYPE
{
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _WAIT_TYPE
{
    WaitAll,
    WaitAny,
    WaitNotification,
    WaitDequeue
} WAIT_TYPE;

typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

#define HARDERROR_OVERRIDE_ERRORMODE        0x10000000

typedef enum _HARDERROR_RESPONSE_OPTION
{
    OptionAbortRetryIgnore,
    OptionOk,
    OptionOkCancel,
    OptionRetryCancel,
    OptionYesNo,
    OptionYesNoCancel,
    OptionShutdownSystem,
    OptionOkNoWait,
    OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION, *PHARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE
{
    ResponseReturnToCaller,
    ResponseNotHandled,
    ResponseAbort,
    ResponseCancel,
    ResponseIgnore,
    ResponseNo,
    ResponseOk,
    ResponseRetry,
    ResponseYes,
    ResponseTryAgain,
    ResponseContinue
} HARDERROR_RESPONSE, *PHARDERROR_RESPONSE;

typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
typedef const UNICODE_STRING* PCUNICODE_STRING;

#define DECLARE_UNICODE_STRING_SIZE(_var, _size) \
WCHAR _var ## _buffer[_size]; \
__pragma(warning(push)) \
__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
UNICODE_STRING _var = { 0, (_size) * sizeof(WCHAR) , _var ## _buffer } \
__pragma(warning(pop))

#define DECLARE_STATIC_UNICODE_STRING_SIZE(_var, _size) \
WCHAR _var ## _buffer[_size]; \
__pragma(warning(push)) \
__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
static UNICODE_STRING _var = { 0, (_size) * sizeof(WCHAR) , _var ## _buffer } \
__pragma(warning(pop))

#if defined(__clang__)
#define RTL_CONSTANT_STRING(s) \
__pragma(clang diagnostic push) \
__pragma(clang diagnostic ignored "-Wwritable-strings") \
{ sizeof(s) - sizeof((s)[0]), sizeof(s), s } \
__pragma(clang diagnostic pop)
#else
#define RTL_CONSTANT_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PWSTR)s }
#define RTL_CONSTANT_ANSI_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PSTR)s }
#endif

FORCEINLINE
VOID
RtlInitEmptyUnicodeString(
    _Out_ PUNICODE_STRING UnicodeString,
    _In_ PWCHAR Buffer,
    _In_ USHORT BufferSize)
{
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = BufferSize;
    UnicodeString->Buffer = Buffer;
}

typedef struct _STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} ANSI_STRING, *PANSI_STRING;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION
{
    ULONG SessionId;
    ULONG SizeOfBuf;
    PVOID Buffer;
} SYSTEM_SESSION_PROCESS_INFORMATION, *PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
{
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef struct _LDT_INFORMATION
{
    ULONG Start;
    ULONG Length;
    LDT_ENTRY LdtEntries[1];
} PROCESS_LDT_INFORMATION, *PPROCESS_LDT_INFORMATION;

typedef struct _KERNEL_USER_TIMES
{
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize; // Since Vista
    ULONG HardFaultCount; // Since Windows 7
    ULONG NumberOfThreadsHighWatermark; // Since Windows 7
    ULONGLONG CycleTime; // Since Windows 7
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey; // Since Vista (requires SystemExtendedProcessInformation)
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _PROCESS_SESSION_INFORMATION
{
    ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;

// File attribute values
#define FILE_ATTRIBUTE_READONLY                 0x00000001
#define FILE_ATTRIBUTE_HIDDEN                   0x00000002
#define FILE_ATTRIBUTE_SYSTEM                   0x00000004

#define FILE_ATTRIBUTE_DIRECTORY                0x00000010
#define FILE_ATTRIBUTE_ARCHIVE                  0x00000020
#define FILE_ATTRIBUTE_DEVICE                   0x00000040
#define FILE_ATTRIBUTE_NORMAL                   0x00000080

#define FILE_ATTRIBUTE_TEMPORARY                0x00000100
#define FILE_ATTRIBUTE_SPARSE_FILE              0x00000200
#define FILE_ATTRIBUTE_REPARSE_POINT            0x00000400
#define FILE_ATTRIBUTE_COMPRESSED               0x00000800

#define FILE_ATTRIBUTE_OFFLINE                  0x00001000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED      0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED                0x00004000

#define FILE_ATTRIBUTE_INTEGRITY_STREAM         0x00008000
#define FILE_ATTRIBUTE_VIRTUAL                  0x00010000
#define FILE_ATTRIBUTE_NO_SCRUB_DATA            0x00020000

#define FILE_ATTRIBUTE_EA                       0x00040000
#define FILE_ATTRIBUTE_PINNED                   0x00080000
#define FILE_ATTRIBUTE_UNPINNED                 0x00100000
#define FILE_ATTRIBUTE_RECALL_ON_OPEN           0x00040000
#define FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS    0x00400000

#if NTDDI_VERSION < NTDDI_WIN8
#define FILE_ATTRIBUTE_VALID_FLAGS              0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS          0x000031a7
#elif NTDDI_VERSION < NTDDI_WIN10_RS2
#define FILE_ATTRIBUTE_VALID_FLAGS              0x0002ffb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS          0x000231a7
#else
#define FILE_ATTRIBUTE_VALID_FLAGS              0x005affb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS          0x001a31a7
#endif

// File create disposition values
#define FILE_SUPERSEDE                          0x00000000
#define FILE_OPEN                               0x00000001
#define FILE_CREATE                             0x00000002
#define FILE_OPEN_IF                            0x00000003
#define FILE_OVERWRITE                          0x00000004
#define FILE_OVERWRITE_IF                       0x00000005
#define FILE_MAXIMUM_DISPOSITION                0x00000005

// File create/open option flags
#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#if NTDDI_VERSION >= NTDDI_WIN7
#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000
#define FILE_DISALLOW_EXCLUSIVE                 0x00020000
#endif
#if NTDDI_VERSION >= NTDDI_WIN8
#define FILE_SESSION_AWARE                      0x00040000
#endif

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

// Named pipe type flags
#define FILE_PIPE_BYTE_STREAM_TYPE              0x00000000
#define FILE_PIPE_MESSAGE_TYPE                  0x00000001
#define FILE_PIPE_ACCEPT_REMOTE_CLIENTS         0x00000000
#define FILE_PIPE_REJECT_REMOTE_CLIENTS         0x00000002
#define FILE_PIPE_TYPE_VALID_MASK               0x00000003

// Named pipe completion mode flags
#define FILE_PIPE_QUEUE_OPERATION               0x00000000
#define FILE_PIPE_COMPLETE_OPERATION            0x00000001

// Named pipe read mode flags
#define FILE_PIPE_BYTE_STREAM_MODE              0x00000000
#define FILE_PIPE_MESSAGE_MODE                  0x00000001

// NamedPipeConfiguration flags
#define FILE_PIPE_INBOUND                       0x00000000
#define FILE_PIPE_OUTBOUND                      0x00000001
#define FILE_PIPE_FULL_DUPLEX                   0x00000002

// NamedPipeState flags
#define FILE_PIPE_DISCONNECTED_STATE            0x00000001
#define FILE_PIPE_LISTENING_STATE               0x00000002
#define FILE_PIPE_CONNECTED_STATE               0x00000003
#define FILE_PIPE_CLOSING_STATE                 0x00000004

// NamedPipeEnd flags
#define FILE_PIPE_CLIENT_END                    0x00000000
#define FILE_PIPE_SERVER_END                    0x00000001

typedef struct _FILE_BASIC_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION
{
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

// Privileges
#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_CREATE_SYMBOLIC_LINK_PRIVILEGE

typedef struct _THREAD_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef struct _MEMORY_REGION_INFORMATION
{
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG Reserved : 26;
        } s;
    } u;
    SIZE_T RegionSize;
    SIZE_T CommitSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _SECTION_BASIC_INFORMATION
{
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION
{
    PVOID TransferAddress; // Entry point
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union
    {
        struct
        {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        } s1;
        ULONG SubSystemVersion;
    } u1;
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        } s2;
        ULONG OperatingSystemVersion;
    } u2;
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        } s3;
    } u3;
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION
{
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageReturnFlowGuardEnabled : 1;
            ULONG ImageReturnFlowGuardStrict : 1;
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG Reserved : 29;
        } s;
    } u;
} SECTION_INTERNAL_IMAGE_INFORMATION, *PSECTION_INTERNAL_IMAGE_INFORMATION;

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

// https://stackoverflow.com/questions/36961152/detect-windows-kit-8-0-and-windows-kit-8-1-sdks
#if defined(WINAPI_PARTITION_APP)
#if defined(WINAPI_FAMILY_SYSTEM)
#define USING_WINDOWS_10_SDK
#elif (WINAPI_PARTITION_APP == 0x00000002) || (WINAPI_PARTITION_APP == 1)
#define USING_WINDOWS_8_x_SDK
#endif
#endif

// This struct was included in winnt.h starting in the Windows 8.0 SDK
#if !(defined(USING_WINDOWS_8_x_SDK) || defined(USING_WINDOWS_10_SDK))
typedef struct _EXCEPTION_REGISTRATION_RECORD
{
    _EXCEPTION_REGISTRATION_RECORD* Next;
    _EXCEPTION_DISPOSITION Handler;
} EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;
#endif

#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT            0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN                           0x00000002

#define LDR_GET_PROCEDURE_ADDRESS_EX_DONT_RECORD_FORWARDER  0x00000001

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS           0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY                  0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID            0
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED      1
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED  2

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS         0x00000001

typedef struct _LDR_RESOURCE_INFO
{
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG_PTR Language;
} LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

typedef struct _LDR_ENUM_RESOURCE_INFO
{
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG_PTR Language;
    PVOID Data;
    SIZE_T Size;
    ULONG_PTR Reserved;
} LDR_ENUM_RESOURCE_INFO, *PLDR_ENUM_RESOURCE_INFO;

#define LDR_FIND_RESOURCE_LANGUAGE_CAN_FALLBACK             0x00000000
#define LDR_FIND_RESOURCE_LANGUAGE_EXACT                    0x00000004
#define LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION         0x00000008

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
{
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _OBJECT_BASIC_INFORMATION
{
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[ 3 ];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION
{
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex; // Since Windows 8.1
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION
{
    ULONG NumberOfTypes;
    OBJECT_TYPE_INFORMATION TypeInformation[1];
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

typedef struct _DBGKM_EXCEPTION
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD
{
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS
{
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD
{
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS
{
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL
{
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL
{
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE
{
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD
{
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS
{
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE
{
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union
    {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

typedef struct _DBGSS_THREAD_DATA
{
    struct _DBGSS_THREAD_DATA* Next;
    HANDLE ThreadHandle;
    HANDLE ProcessHandle;
    ULONG ProcessId;
    ULONG ThreadId;
    BOOLEAN HandleMarked;
} DBGSS_THREAD_DATA, *PDBGSS_THREAD_DATA;

#define DbgSsSetThreadData(d) \
    NtCurrentTeb()->DbgSsReserved[0] = d

#define DbgSsGetThreadData() \
    ((PDBGSS_THREAD_DATA)NtCurrentTeb()->DbgSsReserved[0])

typedef USHORT RTL_ATOM, *PRTL_ATOM;
typedef long SECURITY_STATUS;

typedef struct _RTL_SPLAY_LINKS
{
    struct _RTL_SPLAY_LINKS* Parent;
    struct _RTL_SPLAY_LINKS* LeftChild;
    struct _RTL_SPLAY_LINKS* RightChild;
} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;

#define RtlInitializeSplayLinks(Links) \
{ \
    PRTL_SPLAY_LINKS _SplayLinks; \
    _SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
    _SplayLinks->Parent = _SplayLinks; \
    _SplayLinks->LeftChild = NULL; \
    _SplayLinks->RightChild = NULL; \
}

typedef struct _PREFIX_TABLE_ENTRY
{
    SHORT NodeTypeCode;
    SHORT NameLength;
    struct _PREFIX_TABLE_ENTRY* NextPrefixTree;
    RTL_SPLAY_LINKS Links;
    PANSI_STRING Prefix;
} PREFIX_TABLE_ENTRY, *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE
{
    SHORT NodeTypeCode;
    SHORT NameLength;
    PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE, *PPREFIX_TABLE;

typedef struct _RTL_BITMAP
{
    ULONG SizeOfBitMap;
    PULONG Buffer;
} RTL_BITMAP, *PRTL_BITMAP;

typedef struct _RTL_BITMAP_RUN
{
    ULONG StartingIndex;
    ULONG NumberOfBits;
} RTL_BITMAP_RUN, *PRTL_BITMAP_RUN;

typedef enum
{
    RtlBsdItemVersionNumber = 0x00,
    RtlBsdItemProductType,
    RtlBsdItemAabEnabled,
    RtlBsdItemAabTimeout,
    RtlBsdItemBootGood,
    RtlBsdItemBootShutdown,
    RtlBsdItemMax
} RTL_BSD_ITEM_TYPE, *PRTL_BSD_ITEM_TYPE;

#define DUPLICATE_CLOSE_SOURCE      0x00000001
#define DUPLICATE_SAME_ACCESS       0x00000002
#define DUPLICATE_SAME_ATTRIBUTES   0x00000004

#define RTL_WALK_MAX_STACK_DEPTH    128

// These cannot be ORed together
#define RTL_WALK_KERNEL_MODE_STACK  0x00000000 // Kernel mode callers only
#define RTL_WALK_USER_MODE_STACK    0x00000001
#define RTL_WALK_TRACE_HANDLES      0x00000300

typedef struct _RTL_PROCESS_VERIFIER_OPTIONS
{
    ULONG SizeStruct;
    ULONG Option;
    UCHAR OptionData[1];
} RTL_PROCESS_VERIFIER_OPTIONS, *PRTL_PROCESS_VERIFIER_OPTIONS;

typedef struct _RTL_DEBUG_INFORMATION
{
    HANDLE SectionHandleClient;
    PVOID ViewBaseClient;
    PVOID ViewBaseTarget;
    ULONG_PTR ViewBaseDelta;
    HANDLE EventPairClient;
    HANDLE EventPairTarget;
    HANDLE TargetProcessId;
    HANDLE TargetThreadHandle;
    ULONG Flags;
    SIZE_T OffsetFree;
    SIZE_T CommitSize;
    SIZE_T ViewSize;
    union
    {
        PRTL_PROCESS_MODULES Modules;
        PRTL_PROCESS_MODULE_INFORMATION_EX ModulesEx;
    };
    struct _RTL_PROCESS_BACKTRACES* BackTraces;
    struct _RTL_PROCESS_HEAPS* Heaps;
    struct _RTL_PROCESS_LOCKS* Locks;
    PVOID SpecificHeap;
    HANDLE TargetProcessHandle;
    PRTL_PROCESS_VERIFIER_OPTIONS VerifierOptions;
    PVOID ProcessHeap;
    HANDLE CriticalSectionHandle;
    HANDLE CriticalSectionOwnerThread;
    PVOID Reserved[4];
} RTL_DEBUG_INFORMATION, *PRTL_DEBUG_INFORMATION;

typedef
VOID
(*PPS_APC_ROUTINE)(
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
);

typedef struct _RTLP_CURDIR_REF* PRTLP_CURDIR_REF;

typedef struct _RTL_RELATIVE_NAME_U
{
    UNICODE_STRING RelativeName;
    HANDLE ContainingDirectory;
    PRTLP_CURDIR_REF CurDirRef;
} RTL_RELATIVE_NAME_U, *PRTL_RELATIVE_NAME_U;

typedef enum _RTL_PATH_TYPE
{
    RtlPathTypeUnknown,
    RtlPathTypeUncAbsolute,
    RtlPathTypeDriveAbsolute,
    RtlPathTypeDriveRelative,
    RtlPathTypeRooted,
    RtlPathTypeRelative,
    RtlPathTypeLocalDevice,
    RtlPathTypeRootLocalDevice,
} RTL_PATH_TYPE;

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

typedef struct _CURDIR
{
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _LDR_SERVICE_TAG_RECORD
{
    struct _LDR_SERVICE_TAG_RECORD* Next;
    ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, *PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
    PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, *PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE
{
    LdrModulesMerged = -5,
    LdrModulesInitError = -4,
    LdrModulesSnapError = -3,
    LdrModulesUnloaded = -2,
    LdrModulesUnloading = -1,
    LdrModulesPlaceHolder = 0,
    LdrModulesMapping = 1,
    LdrModulesMapped = 2,
    LdrModulesWaitingForDependencies = 3,
    LdrModulesSnapping = 4,
    LdrModulesSnapped = 5,
    LdrModulesCondensed = 6,
    LdrModulesReadyToInit = 7,
    LdrModulesInitializing = 8,
    LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
    LIST_ENTRY Modules;
    PLDR_SERVICE_TAG_RECORD ServiceTagList;
    ULONG LoadCount;
    ULONG LoadWhileUnloadingCount;
    ULONG LowestLink;
    union
    {
        LDRP_CSLIST Dependencies;
        SINGLE_LIST_ENTRY RemovalLink;
    };
    LDRP_CSLIST IncomingDependencies;
    LDR_DDAG_STATE State;
    SINGLE_LIST_ENTRY CondenseLink;
    ULONG PreorderNumber;
} LDR_DDAG_NODE, *PLDR_DDAG_NODE;

typedef struct _LDR_DEPENDENCY_RECORD
{
    SINGLE_LIST_ENTRY DependencyLink;
    PLDR_DDAG_NODE DependencyNode;
    SINGLE_LIST_ENTRY IncomingDependencyLink;
    PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, *PLDR_DEPENDENCY_RECORD;

typedef enum _LDR_DLL_LOAD_REASON
{
    LoadReasonStaticDependency,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

#define LDRP_PACKAGED_BINARY            0x00000001
#define LDRP_IMAGE_DLL                  0x00000004
#define LDRP_LOAD_IN_PROGRESS           0x00001000
#define LDRP_ENTRY_PROCESSED            0x00004000
#define LDRP_DONT_CALL_FOR_THREADS      0x00040000
#define LDRP_PROCESS_ATTACH_CALLED      0x00080000
#define LDRP_PROCESS_ATTACH_FAILED      0x00100000
#define LDRP_IMAGE_NOT_AT_BASE          0x00200000 // Vista and below
#define LDRP_COR_IMAGE                  0x00400000
#define LDRP_DONT_RELOCATE              0x00800000
#define LDRP_REDIRECTED                 0x10000000
#define LDRP_COMPAT_DATABASE_PROCESSED  0x80000000

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, DdagNode)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN7 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, BaseNameHashValue)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN8 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, ImplicitPathOptions)

#define RTL_BALANCED_NODE_RESERVED_PARENT_MASK 3

typedef struct _RTL_BALANCED_NODE
{
    union
    {
        struct _RTL_BALANCED_NODE* Children[2];
        struct
        {
            struct _RTL_BALANCED_NODE* Left;
            struct _RTL_BALANCED_NODE* Right;
        } s;
    };
    union
    {
        UCHAR Red : 1;
        UCHAR Balance : 2;
        ULONG_PTR ParentValue;
    } u;
} RTL_BALANCED_NODE, *PRTL_BALANCED_NODE;

typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    };
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        UCHAR FlagGroup[4];
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1;
            ULONG MarkedForRemoval : 1;
            ULONG ImageDll : 1;
            ULONG LoadNotificationsSent : 1;
            ULONG TelemetryEntryProcessed : 1;
            ULONG ProcessStaticImport : 1;
            ULONG InLegacyLists : 1;
            ULONG InIndexes : 1;
            ULONG ShimDll : 1;
            ULONG InExceptionTable : 1;
            ULONG ReservedFlags1 : 2;
            ULONG LoadInProgress : 1;
            ULONG LoadConfigProcessed : 1;
            ULONG EntryProcessed : 1;
            ULONG ProtectDelayLoad : 1;
            ULONG ReservedFlags3 : 2;
            ULONG DontCallForThreads : 1;
            ULONG ProcessAttachCalled : 1;
            ULONG ProcessAttachFailed : 1;
            ULONG CorDeferredValidate : 1;
            ULONG CorImage : 1;
            ULONG DontRelocate : 1;
            ULONG CorILOnly : 1;
            ULONG ReservedFlags5 : 3;
            ULONG Redirected : 1;
            ULONG ReservedFlags6 : 2;
            ULONG CompatDatabaseProcessed : 1;
        } s;
    } u;
    USHORT ObsoleteLoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
    struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
    PVOID Lock;
    PLDR_DDAG_NODE DdagNode;
    LIST_ENTRY NodeModuleLink;
    struct _LDRP_LOAD_CONTEXT* LoadContext;
    PVOID ParentDllBase;
    PVOID SwitchBackContext;
    RTL_BALANCED_NODE BaseAddressIndexNode;
    RTL_BALANCED_NODE MappingInfoIndexNode;
    ULONG_PTR OriginalBase;
    LARGE_INTEGER LoadTime;
    ULONG BaseNameHashValue;
    LDR_DLL_LOAD_REASON LoadReason;
    ULONG ImplicitPathOptions;
    ULONG ReferenceCount;
    ULONG DependentLoadFlags;
    UCHAR SigningLevel; // Since Windows 10 RS2
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _INITIAL_TEB
{
    struct
    {
        PVOID OldStackBase;
        PVOID OldStackLimit;
    } OldInitialTeb;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackAllocationBase;
} INITIAL_TEB, *PINITIAL_TEB;

typedef struct _IO_STATUS_BLOCK
{
    union
    {
        NTSTATUS Status;
        PVOID Pointer;
    };
    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef
VOID
(NTAPI*
 PIO_APC_ROUTINE)(
     _In_ PVOID ApcContext,
     _In_ PIO_STATUS_BLOCK IoStatusBlock,
     _In_ ULONG Reserved
 );

typedef struct _FILE_IO_COMPLETION_INFORMATION
{
    PVOID KeyContext;
    PVOID ApcContext;
    IO_STATUS_BLOCK IoStatusBlock;
} FILE_IO_COMPLETION_INFORMATION, *PFILE_IO_COMPLETION_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION
{
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

#ifdef __cplusplus
typedef enum _PRIORITY_CLASS : UCHAR
{
    Undefined,
    Idle,
    Normal,
    High,
    Realtime,
    BelowNormal,
    AboveNormal
} PRIORITY_CLASS;
#else
typedef UCHAR PRIORITY_CLASS;
#endif

typedef struct _PROCESS_PRIORITY_CLASS
{
    BOOLEAN Foreground;
    PRIORITY_CLASS PriorityClass;
} PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;

typedef struct _PS_ATTRIBUTE
{
    ULONG_PTR Attribute;                // PROC_THREAD_ATTRIBUTE_XXX | PROC_THREAD_ATTRIBUTE_XXX modifiers, see ProcThreadAttributeValue macro and Windows Internals 6 (372)
    SIZE_T Size;                        // Size of Value or *ValuePtr
    union
    {
        ULONG_PTR Value;                // Reserve 8 bytes for data (such as a Handle or a data pointer)
        PVOID ValuePtr;                 // data pointer
    };
    PSIZE_T ReturnLength;               // Either 0 or specifies size of data returned to caller via "ValuePtr"
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST
{
    SIZE_T TotalLength;                 // sizeof(PS_ATTRIBUTE_LIST)
    PS_ATTRIBUTE Attributes[2];         // Depends on how many attribute entries should be supplied to NtCreateUserProcess
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef struct _PS_MEMORY_RESERVE
{
    PVOID ReserveAddress;
    SIZE_T ReserveSize;
} PS_MEMORY_RESERVE, *PPS_MEMORY_RESERVE;

#define PS_ATTRIBUTE_NUMBER_MASK    0x0000ffff
#define PS_ATTRIBUTE_THREAD         0x00010000 // Attribute may be used with thread creation
#define PS_ATTRIBUTE_INPUT          0x00020000 // Attribute is input only
#define PS_ATTRIBUTE_ADDITIVE       0x00040000 // Attribute may be "accumulated", e.g. bitmasks, counters, etc.

typedef enum _PS_ATTRIBUTE_NUM
{
    PsAttributeParentProcess,                   // in HANDLE
    PsAttributeDebugPort,                       // in HANDLE
    PsAttributeToken,                           // in HANDLE
    PsAttributeClientId,                        // out PCLIENT_ID
    PsAttributeTebAddress,                      // out PTEB
    PsAttributeImageName,                       // in PWSTR
    PsAttributeImageInfo,                       // out PSECTION_IMAGE_INFORMATION
    PsAttributeMemoryReserve,                   // in PPS_MEMORY_RESERVE
    PsAttributePriorityClass,                   // in UCHAR
    PsAttributeErrorMode,                       // in ULONG
    PsAttributeStdHandleInfo,                   // in PPS_STD_HANDLE_INFO
    PsAttributeHandleList,                      // in PHANDLE
    PsAttributeGroupAffinity,                   // in PGROUP_AFFINITY
    PsAttributePreferredNode,                   // in PUSHORT
    PsAttributeIdealProcessor,                  // in PPROCESSOR_NUMBER
    PsAttributeUmsThread,                       // see MSDN UpdateProceThreadAttributeList (CreateProcessW) - in PUMS_CREATE_THREAD_ATTRIBUTES
    PsAttributeMitigationOptions,               // in UCHAR
    PsAttributeProtectionLevel,                 // in ULONG
    PsAttributeSecureProcess,                   // since THRESHOLD (Virtual Secure Mode, Device Guard)
    PsAttributeJobList,
    PsAttributeChildProcessPolicy,              // since THRESHOLD2
    PsAttributeAllApplicationPackagesPolicy,    // since REDSTONE
    PsAttributeWin32kFilter,
    PsAttributeSafeOpenPromptOriginClaim,
    PsAttributeBnoIsolation,
    PsAttributeDesktopAppPolicy,
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Additive) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Additive) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE) // 0x60000
#define PS_ATTRIBUTE_DEBUG_PORT \
    PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE) // 0x60001
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE) // 0x60002
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE) // 0x10003
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE) // 0x10004
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE) // 0x20005
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE) // 0x6
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE) // 0x20007
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE) // 0x20008
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE) // 0x20009
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE) // 0x2000A
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE) // 0x2000B
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE) // 0x2000C
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE) // 0x2000D
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE) // 0x2000E
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE) // 0x60010
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, FALSE) // 0x20011

typedef enum _PS_STD_HANDLE_STATE
{
    PsNeverDuplicate,
    PsRequestDuplicate, // Duplicate standard handles specified by PseudoHandleMask, and only if StdHandleSubsystemType matches the image subsystem
    PsAlwaysDuplicate, // Always duplicate standard handles
    PsMaxStdHandleStates
} PS_STD_HANDLE_STATE;

#define HANDLE_DETACHED_PROCESS     ((HANDLE)-1)
#define HANDLE_CREATE_NEW_CONSOLE   ((HANDLE)-2)
#define HANDLE_CREATE_NO_WINDOW     ((HANDLE)-3)

#define PS_STD_INPUT_HANDLE         0x1
#define PS_STD_OUTPUT_HANDLE        0x2
#define PS_STD_ERROR_HANDLE         0x4

typedef struct _PS_STD_HANDLE_INFO
{
    union
    {
        ULONG Flags;
        struct
        {
            ULONG StdHandleState : 2; // PS_STD_HANDLE_STATE
            ULONG PseudoHandleMask : 3; // PS_STD_*
        } s;
    };
    ULONG StdHandleSubsystemType;
} PS_STD_HANDLE_INFO, *PPS_STD_HANDLE_INFO;

typedef struct _PS_BNO_ISOLATION_PARAMETERS
{
    UNICODE_STRING IsolationPrefix;
    ULONG HandleCount;
    PVOID* Handles;
    BOOLEAN IsolationEnabled;
} PS_BNO_ISOLATION_PARAMETERS, *PPS_BNO_ISOLATION_PARAMETERS;

typedef enum _PS_MITIGATION_OPTION
{
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE
{
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName, // Debugger specified
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO
{
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        // PsCreateInitialState
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                } s1;
            } u1;
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        // PsCreateFailOnSectionCreate
        struct
        {
            HANDLE FileHandle;
        } FailSection;

        // PsCreateFailExeFormat
        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        // PsCreateFailExeName
        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        // PsCreateSuccess
        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1; // From Image File Execution Options
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                } s2;
            } u2;
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

#define PROCESS_CREATE_FLAGS_BREAKAWAY              0x00000001
#define PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT       0x00000002
#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES        0x00000004
#define PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00000008
#define PROCESS_CREATE_FLAGS_LARGE_PAGES            0x00000010

// Only usable with NtCreateUserProcess (Vista+):
#define PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL  0x00000020
#define PROCESS_CREATE_FLAGS_PROTECTED_PROCESS      0x00000040 // Only allowed if the calling process is itself protected
#define PROCESS_CREATE_FLAGS_CREATE_SESSION         0x00000080
#define PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT    0x00000100

typedef enum _MEMORY_RESERVE_TYPE
{
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

typedef struct _PROCESS_HANDLE_TRACING_ENABLE
{
    ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, *PPROCESS_HANDLE_TRACING_ENABLE;

#define PROCESS_HANDLE_TRACING_MAX_SLOTS 0x20000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX
{
    ULONG Flags;
    ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, *PPROCESS_HANDLE_TRACING_ENABLE_EX;

// Source: http://processhacker.sourceforge.net
typedef enum _PROCESSINFOCLASS
{
    ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
    ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
    ProcessIoCounters, // q: IO_COUNTERS
    ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
    ProcessTimes, // q: KERNEL_USER_TIMES
    ProcessBasePriority, // s: KPRIORITY
    ProcessRaisePriority, // s: ULONG
    ProcessDebugPort, // q: HANDLE
    ProcessExceptionPort, // s: HANDLE
    ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
    ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
    ProcessLdtSize, // s: PROCESS_LDT_SIZE
    ProcessDefaultHardErrorMode, // qs: ULONG
    ProcessIoPortHandlers, // (kernel-mode only)
    ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
    ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
    ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
    ProcessWx86Information,
    ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
    ProcessAffinityMask, // s: KAFFINITY
    ProcessPriorityBoost, // qs: ULONG
    ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
    ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
    ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
    ProcessWow64Information, // q: ULONG_PTR
    ProcessImageFileName, // q: UNICODE_STRING
    ProcessLUIDDeviceMapsEnabled, // q: ULONG
    ProcessBreakOnTermination, // qs: ULONG
    ProcessDebugObjectHandle, // q: HANDLE // 30
    ProcessDebugFlags, // qs: ULONG
    ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
    ProcessIoPriority, // qs: IO_PRIORITY_HINT
    ProcessExecuteFlags, // qs: ULONG
    ProcessResourceManagement,
    ProcessCookie, // q: ULONG
    ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
    ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
    ProcessPagePriority, // q: ULONG
    ProcessInstrumentationCallback, // 40
    ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
    ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
    ProcessImageFileNameWin32, // q: UNICODE_STRING
    ProcessImageFileMapping, // q: HANDLE (input)
    ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
    ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
    ProcessGroupInformation, // q: USHORT[]
    ProcessTokenVirtualizationEnabled, // s: ULONG
    ProcessConsoleHostProcess, // q: ULONG_PTR
    ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
    ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
    ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
    ProcessDynamicFunctionTableInformation,
    ProcessHandleCheckingMode,
    ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
    ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
    ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
    ProcessHandleTable, // since WINBLUE
    ProcessCheckStackExtentsMode,
    ProcessCommandLineInformation, // q: UNICODE_STRING // 60
    ProcessProtectionInformation, // q: PS_PROTECTION
    ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
    ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
    ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
    ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
    ProcessDefaultCpuSetsInformation,
    ProcessAllowedCpuSetsInformation,
    ProcessSubsystemProcess,
    ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
    ProcessInPrivate, // since THRESHOLD2 // 70
    ProcessRaiseUMExceptionOnInvalidHandleClose,
    ProcessIumChallengeResponse,
    ProcessChildProcessInformation, // PROCESS_CHILD_PROCESS_INFORMATION
    ProcessHighGraphicsPriorityInformation,
    ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ProcessEnergyValues, // PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
    ProcessActivityThrottleState, // PROCESS_ACTIVITY_THROTTLE_STATE
    ProcessActivityThrottlePolicy, // PROCESS_ACTIVITY_THROTTLE_POLICY
    ProcessWin32kSyscallFilterInformation,
    ProcessDisableSystemAllowedCpuSets,
    ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
    ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
    MaxProcessInfoClass
} PROCESSINFOCLASS;

// Source: http://processhacker.sourceforge.net
typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation, // not implemented
    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation, // q: RTL_PROCESS_MODULES
    SystemLocksInformation, // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation, // not implemented
    SystemNonPagedPoolInformation, // not implemented
    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation, // q
    SystemVdmBopInformation, // not implemented // 20
    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation, // not implemented
    SystemLoadGdiDriverInformation, // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented
    SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0, // not implemented
    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation, // s (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation, // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation, // q
    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
    SystemSessionCreate, // not implemented
    SystemSessionDetach, // not implemented
    SystemSessionInformation, // not implemented
    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend, // s (kernel-mode only)
    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap, // q
    SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment, // q
    SystemComPlusPackage, // q; s
    SystemNumaAvailableMemory, // 60
    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
    SystemEmulationBasicInformation, // q
    SystemEmulationProcessorInformation,
    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation, // q: ULONG
    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation, // q; s
    SystemObjectSecurityMode, // q // 70
    SystemWatchdogTimerHandler, // s (kernel-mode only)
    SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
    SystemWow64SharedInformationObsolete, // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s (kernel-mode only)
    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation, // not implemented
    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
    SystemVerifierCancellationInformation, // not implemented // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation, // q; s (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation, // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation, // q; s (kernel-mode only)
    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
    SystemPrefetchPatchInformation, // not implemented
    SystemVerifierFaultsInformation, // s (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
    SystemNumaProximityNodeInformation, // q
    SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s
    SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
    SystemStoreInformation, // q; s // SmQueryStoreInformation
    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
    SystemNativeBasicInformation, // not implemented
    SystemSpare1, // not implemented
    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation, // q
    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,
    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingCallback,
    SystemConsoleInformation, // q: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
    SystemThrottleNotificationInformation,
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation,
    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
    SystemSpare0,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation, // 150
    SystemSoftRebootInformation,
    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation,
    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation,
    SystemEdidInformation,
    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags,
    SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation,
    SystemDmaProtectionInformation, // q: SYSTEM_DMA_PROTECTION_INFORMATION
    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation,
    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation, // 180
    SystemSupportedProcessorArchitectures,
    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition,
    SystemKernelDebuggingAllowed,
    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef enum _OBJECT_INFORMATION_CLASS
{
    ObjectBasicInformation, // OBJECT_BASIC_INFORMATION
    ObjectNameInformation, // OBJECT_NAME_INFORMATION
    ObjectTypeInformation, // OBJECT_TYPE_INFORMATION
    ObjectTypesInformation, // OBJECT_TYPES_INFORMATION
    ObjectHandleFlagInformation, // OBJECT_HANDLE_FLAG_INFORMATION
    ObjectSessionInformation,
    ObjectSessionObjectInformation,
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

//Source: http://processhacker.sourceforge.net
typedef enum _THREADINFOCLASS
{
    ThreadBasicInformation, // q: THREAD_BASIC_INFORMATION
    ThreadTimes, // q: KERNEL_USER_TIMES
    ThreadPriority, // s: KPRIORITY
    ThreadBasePriority, // s: LONG
    ThreadAffinityMask, // s: KAFFINITY
    ThreadImpersonationToken, // s: HANDLE
    ThreadDescriptorTableEntry, // q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
    ThreadEnableAlignmentFaultFixup, // s: BOOLEAN
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress, // q: PVOID
    ThreadZeroTlsCell, // 10
    ThreadPerformanceCount, // q: LARGE_INTEGER
    ThreadAmILastThread, // q: ULONG
    ThreadIdealProcessor, // s: ULONG
    ThreadPriorityBoost, // qs: ULONG
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending, // q: ULONG
    ThreadHideFromDebugger, // s: void
    ThreadBreakOnTermination, // qs: ULONG
    ThreadSwitchLegacyState,
    ThreadIsTerminated, // q: ULONG // 20
    ThreadLastSystemCall, // q: THREAD_LAST_SYSCALL_INFORMATION
    ThreadIoPriority, // qs: IO_PRIORITY_HINT
    ThreadCycleTime, // q: THREAD_CYCLE_TIME_INFORMATION
    ThreadPagePriority, // q: ULONG
    ThreadActualBasePriority,
    ThreadTebInformation, // q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context, // q: WOW64_CONTEXT
    ThreadGroupInformation, // q: GROUP_AFFINITY // 30
    ThreadUmsInformation, // q: THREAD_UMS_INFORMATION
    ThreadCounterProfiling,
    ThreadIdealProcessorEx, // q: PROCESSOR_NUMBER
    ThreadCpuAccountingInformation, // since WIN8
    ThreadSuspendCount, // since WINBLUE
    ThreadHeterogeneousCpuPolicy, // q: KHETERO_CPU_POLICY // since THRESHOLD
    ThreadContainerId, // q: GUID
    ThreadNameInformation, // qs: THREAD_NAME_INFORMATION
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation, // q: SYSTEM_THREAD_INFORMATION // 40
    ThreadActualGroupAffinity, // since THRESHOLD2
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity,
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    MaxThreadInfoClass
} THREADINFOCLASS;

typedef enum _FSINFOCLASS
{
    FileFsVolumeInformation         = 1,    // FILE_FS_VOLUME_INFORMATION
    FileFsLabelInformation          = 2,    // FILE_FS_LABEL_INFORMATION
    FileFsSizeInformation           = 3,    // FILE_FS_SIZE_INFORMATION
    FileFsDeviceInformation         = 4,    // FILE_FS_DEVICE_INFORMATION
    FileFsAttributeInformation      = 5,    // FILE_FS_ATTRIBUTE_INFORMATION
    FileFsControlInformation        = 6,    // FILE_FS_CONTROL_INFORMATION
    FileFsFullSizeInformation       = 7,    // FILE_FS_FULL_SIZE_INFORMATION
    FileFsObjectIdInformation       = 8,    // FILE_FS_OBJECTID_INFORMATION
    FileFsDriverPathInformation     = 9,    // FILE_FS_DRIVER_PATH_INFORMATION
    FileFsVolumeFlagsInformation    = 10,   // FILE_FS_VOLUME_FLAGS_INFORMATION
    FileFsSectorSizeInformation     = 11,   // FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8
    FileFsDataCopyInformation       = 12,   // FILE_FS_DATA_COPY_INFORMATION
    FileFsMetadataSizeInformation   = 13,   // FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef enum _MEMORY_INFORMATION_CLASS
{
    MemoryBasicInformation, // MEMORY_BASIC_INFORMATION
    MemoryWorkingSetInformation, // MEMORY_WORKING_SET_INFORMATION
    MemoryMappedFilenameInformation, // UNICODE_STRING
    MemoryRegionInformation, // MEMORY_REGION_INFORMATION
    MemoryWorkingSetExInformation, // MEMORY_WORKING_SET_EX_INFORMATION
    MemorySharedCommitInformation, // MEMORY_SHARED_COMMIT_INFORMATION
    MemoryImageInformation, // MEMORY_IMAGE_INFORMATION
    MemoryRegionInformationEx,
    MemoryPrivilegedBasicInformation
} MEMORY_INFORMATION_CLASS;

typedef enum _SECTION_INFORMATION_CLASS
{
    SectionBasicInformation,
    SectionImageInformation,
    SectionRelocationInformation, // name:wow64:whNtQuerySection_SectionRelocationInformation
    SectionOriginalBaseInformation, // PVOID BaseAddress
    SectionInternalImageInformation, // SECTION_INTERNAL_IMAGE_INFORMATION // since REDSTONE2
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

// Boot condition flags (NtInitializeRegistry)
#define REG_INIT_BOOT_SM                0x0000
#define REG_INIT_BOOT_SETUP             0x0001
#define REG_INIT_BOOT_ACCEPTED_BASE     0x0002
#define REG_INIT_BOOT_ACCEPTED_MAX      REG_INIT_BOOT_ACCEPTED_BASE + 999

#define REG_MAX_KEY_VALUE_NAME_LENGTH   32767
#define REG_MAX_KEY_NAME_LENGTH         512

typedef enum _KEY_INFORMATION_CLASS
{
    KeyBasicInformation, // KEY_BASIC_INFORMATION
    KeyNodeInformation, // KEY_NODE_INFORMATION
    KeyFullInformation, // KEY_FULL_INFORMATION
    KeyNameInformation, // KEY_NAME_INFORMATION
    KeyCachedInformation, // KEY_CACHED_INFORMATION
    KeyFlagsInformation, // KEY_FLAGS_INFORMATION
    KeyVirtualizationInformation, // KEY_VIRTUALIZATION_INFORMATION
    KeyHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
    KeyTrustInformation, // KEY_TRUST_INFORMATION
    KeyLayerInformation, // KEY_LAYER_INFORMATION
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef struct _KEY_BASIC_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG NameLength;
    WCHAR Name[1];
    // ...
    // WCHAR Class[1];
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG ClassOffset;
    ULONG ClassLength;
    ULONG SubKeys;
    ULONG MaxNameLen;
    ULONG MaxClassLen;
    ULONG Values;
    ULONG MaxValueNameLen;
    ULONG MaxValueDataLen;
    WCHAR Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_NAME_INFORMATION
{
    ULONG NameLength;
    WCHAR Name[1];
} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG SubKeys;
    ULONG MaxNameLen;
    ULONG Values;
    ULONG MaxValueNameLen;
    ULONG MaxValueDataLen;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;

typedef struct _KEY_FLAGS_INFORMATION
{
    ULONG UserFlags;
} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;

typedef struct _KEY_VIRTUALIZATION_INFORMATION
{
    ULONG VirtualizationCandidate : 1; // Tells whether the key is part of the virtualization namespace scope (only HKLM\Software for now).
    ULONG VirtualizationEnabled : 1; // Tells whether virtualization is enabled on this key. Can be 1 only if above flag is 1.
    ULONG VirtualTarget : 1; // Tells if the key is a virtual key. Can be 1 only if above 2 are 0. Valid only on the virtual store key handles.
    ULONG VirtualStore : 1; // Tells if the key is a part of the virtual store path. Valid only on the virtual store key handles.
    ULONG VirtualSource : 1; // Tells if the key has ever been virtualized, can be 1 only if VirtualizationCandidate is 1.
    ULONG Reserved : 27;
} KEY_VIRTUALIZATION_INFORMATION, *PKEY_VIRTUALIZATION_INFORMATION;

// private
typedef struct _KEY_TRUST_INFORMATION
{
    ULONG TrustedKey : 1;
    ULONG Reserved : 31;
} KEY_TRUST_INFORMATION, *PKEY_TRUST_INFORMATION;

// private
typedef struct _KEY_LAYER_INFORMATION
{
    ULONG IsTombstone;
    ULONG IsSupersedeLocal;
    ULONG IsSupersedeTree;
    ULONG ClassIsInherited;
    ULONG Reserved;
} KEY_LAYER_INFORMATION, *PKEY_LAYER_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS
{
    KeyWriteTimeInformation, // KEY_WRITE_TIME_INFORMATION
    KeyWow64FlagsInformation, // KEY_WOW64_FLAGS_INFORMATION
    KeyControlFlagsInformation, // KEY_CONTROL_FLAGS_INFORMATION
    KeySetVirtualizationInformation, // KEY_SET_VIRTUALIZATION_INFORMATION
    KeySetDebugInformation,
    KeySetHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef struct _KEY_WOW64_FLAGS_INFORMATION
{
    ULONG UserFlags;
} KEY_WOW64_FLAGS_INFORMATION, *PKEY_WOW64_FLAGS_INFORMATION;

typedef struct _KEY_HANDLE_TAGS_INFORMATION
{
    ULONG HandleTags;
} KEY_HANDLE_TAGS_INFORMATION, *PKEY_HANDLE_TAGS_INFORMATION;

typedef struct _KEY_CONTROL_FLAGS_INFORMATION
{
    ULONG ControlFlags;
} KEY_CONTROL_FLAGS_INFORMATION, *PKEY_CONTROL_FLAGS_INFORMATION;

typedef struct _KEY_SET_VIRTUALIZATION_INFORMATION
{
    ULONG VirtualTarget : 1;
    ULONG VirtualStore : 1;
    ULONG VirtualSource : 1; // true if key has been virtualized at least once
    ULONG Reserved : 29;
} KEY_SET_VIRTUALIZATION_INFORMATION, *PKEY_SET_VIRTUALIZATION_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS
{
    KeyValueBasicInformation, // KEY_VALUE_BASIC_INFORMATION
    KeyValueFullInformation, // KEY_VALUE_FULL_INFORMATION
    KeyValuePartialInformation, // KEY_VALUE_PARTIAL_INFORMATION
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64, // KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
    KeyValueLayerInformation, // KEY_VALUE_LAYER_INFORMATION
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataOffset;
    ULONG DataLength;
    ULONG NameLength;
    WCHAR Name[1];
    // ...
    // UCHAR Data[1];
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION
{
    ULONG TitleIndex;
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
{
    ULONG Type;
    ULONG DataLength;
    UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

// private
typedef struct _KEY_VALUE_LAYER_INFORMATION
{
    ULONG IsTombstone;
    ULONG Reserved;
} KEY_VALUE_LAYER_INFORMATION, *PKEY_VALUE_LAYER_INFORMATION;

typedef struct _KEY_VALUE_ENTRY
{
    PUNICODE_STRING ValueName;
    ULONG DataLength;
    ULONG DataOffset;
    ULONG Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _REG_ACTION
{
    KeyAdded,
    KeyRemoved,
    KeyModified
} REG_ACTION;

typedef struct _REG_NOTIFY_INFORMATION
{
    ULONG NextEntryOffset;
    REG_ACTION Action;
    ULONG KeyLength;
    WCHAR Key[1];
} REG_NOTIFY_INFORMATION, *PREG_NOTIFY_INFORMATION;

typedef struct _KEY_PID_ARRAY
{
    HANDLE PID;
    UNICODE_STRING KeyName;
} KEY_PID_ARRAY, *PKEY_PID_ARRAY;

typedef struct _KEY_OPEN_SUBKEYS_INFORMATION
{
    ULONG Count;
    KEY_PID_ARRAY KeyArray[1];
} KEY_OPEN_SUBKEYS_INFORMATION, *PKEY_OPEN_SUBKEYS_INFORMATION;

typedef enum _SYSDBG_COMMAND
{
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall,
    SysDbgClearSpecialCalls,
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion,
    SysDbgReadVirtual,
    SysDbgWriteVirtual,
    SysDbgReadPhysical,
    SysDbgWritePhysical,
    SysDbgReadControlSpace,
    SysDbgWriteControlSpace,
    SysDbgReadIoSpace,
    SysDbgWriteIoSpace,
    SysDbgReadMsr,
    SysDbgWriteMsr,
    SysDbgReadBusData,
    SysDbgWriteBusData,
    SysDbgCheckLowMemory,
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef enum _DEBUGOBJECTINFOCLASS
{
    DebugObjectFlags = 1,
    MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;

//Source: http://processhacker.sourceforge.net
typedef enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation = 1, // FILE_DIRECTORY_INFORMATION
    FileFullDirectoryInformation, // FILE_FULL_DIR_INFORMATION
    FileBothDirectoryInformation, // FILE_BOTH_DIR_INFORMATION
    FileBasicInformation, // FILE_BASIC_INFORMATION
    FileStandardInformation, // FILE_STANDARD_INFORMATION
    FileInternalInformation, // FILE_INTERNAL_INFORMATION
    FileEaInformation, // FILE_EA_INFORMATION
    FileAccessInformation, // FILE_ACCESS_INFORMATION
    FileNameInformation, // FILE_NAME_INFORMATION
    FileRenameInformation, // FILE_RENAME_INFORMATION // 10
    FileLinkInformation, // FILE_LINK_INFORMATION
    FileNamesInformation, // FILE_NAMES_INFORMATION
    FileDispositionInformation, // FILE_DISPOSITION_INFORMATION
    FilePositionInformation, // FILE_POSITION_INFORMATION
    FileFullEaInformation, // FILE_FULL_EA_INFORMATION
    FileModeInformation, // FILE_MODE_INFORMATION
    FileAlignmentInformation, // FILE_ALIGNMENT_INFORMATION
    FileAllInformation, // FILE_ALL_INFORMATION
    FileAllocationInformation, // FILE_ALLOCATION_INFORMATION
    FileEndOfFileInformation, // FILE_END_OF_FILE_INFORMATION // 20
    FileAlternateNameInformation, // FILE_NAME_INFORMATION
    FileStreamInformation, // FILE_STREAM_INFORMATION
    FilePipeInformation, // FILE_PIPE_INFORMATION
    FilePipeLocalInformation, // FILE_PIPE_LOCAL_INFORMATION
    FilePipeRemoteInformation, // FILE_PIPE_REMOTE_INFORMATION
    FileMailslotQueryInformation, // FILE_MAILSLOT_QUERY_INFORMATION
    FileMailslotSetInformation, // FILE_MAILSLOT_SET_INFORMATION
    FileCompressionInformation, // FILE_COMPRESSION_INFORMATION
    FileObjectIdInformation, // FILE_OBJECTID_INFORMATION
    FileCompletionInformation, // FILE_COMPLETION_INFORMATION // 30
    FileMoveClusterInformation, // FILE_MOVE_CLUSTER_INFORMATION
    FileQuotaInformation, // FILE_QUOTA_INFORMATION
    FileReparsePointInformation, // FILE_REPARSE_POINT_INFORMATION
    FileNetworkOpenInformation, // FILE_NETWORK_OPEN_INFORMATION
    FileAttributeTagInformation, // FILE_ATTRIBUTE_TAG_INFORMATION
    FileTrackingInformation, // FILE_TRACKING_INFORMATION
    FileIdBothDirectoryInformation, // FILE_ID_BOTH_DIR_INFORMATION
    FileIdFullDirectoryInformation, // FILE_ID_FULL_DIR_INFORMATION
    FileValidDataLengthInformation, // FILE_VALID_DATA_LENGTH_INFORMATION
    FileShortNameInformation, // FILE_NAME_INFORMATION // 40
    FileIoCompletionNotificationInformation, // FILE_IO_COMPLETION_NOTIFICATION_INFORMATION // since VISTA
    FileIoStatusBlockRangeInformation, // FILE_IOSTATUSBLOCK_RANGE_INFORMATION
    FileIoPriorityHintInformation, // FILE_IO_PRIORITY_HINT_INFORMATION
    FileSfioReserveInformation, // FILE_SFIO_RESERVE_INFORMATION
    FileSfioVolumeInformation, // FILE_SFIO_VOLUME_INFORMATION
    FileHardLinkInformation, // FILE_LINKS_INFORMATION
    FileProcessIdsUsingFileInformation, // FILE_PROCESS_IDS_USING_FILE_INFORMATION
    FileNormalizedNameInformation, // FILE_NAME_INFORMATION
    FileNetworkPhysicalNameInformation, // FILE_NETWORK_PHYSICAL_NAME_INFORMATION
    FileIdGlobalTxDirectoryInformation, // FILE_ID_GLOBAL_TX_DIR_INFORMATION // since WIN7 // 50
    FileIsRemoteDeviceInformation, // FILE_IS_REMOTE_DEVICE_INFORMATION
    FileUnusedInformation,
    FileNumaNodeInformation, // FILE_NUMA_NODE_INFORMATION
    FileStandardLinkInformation, // FILE_STANDARD_LINK_INFORMATION
    FileRemoteProtocolInformation, // FILE_REMOTE_PROTOCOL_INFORMATION
    FileRenameInformationBypassAccessCheck, // (kernel-mode only); FILE_RENAME_INFORMATION // since WIN8
    FileLinkInformationBypassAccessCheck, // (kernel-mode only); FILE_LINK_INFORMATION
    FileVolumeNameInformation, // FILE_VOLUME_NAME_INFORMATION
    FileIdInformation, // FILE_ID_INFORMATION
    FileIdExtdDirectoryInformation, // FILE_ID_EXTD_DIR_INFORMATION
    FileReplaceCompletionInformation, // FILE_COMPLETION_INFORMATION // since WINBLUE
    FileHardLinkFullIdInformation, // FILE_LINK_ENTRY_FULL_ID_INFORMATION
    FileIdExtdBothDirectoryInformation, // FILE_ID_EXTD_BOTH_DIR_INFORMATION // since THRESHOLD
    FileDispositionInformationEx, // FILE_DISPOSITION_INFO_EX // since REDSTONE
    FileRenameInformationEx,
    FileRenameInformationExBypassAccessCheck,
    FileDesiredStorageClassInformation, // FILE_DESIRED_STORAGE_CLASS_INFORMATION // since REDSTONE2
    FileStatInformation, // FILE_STAT_INFORMATION
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef struct _SYSTEM_BASIC_INFORMATION
{
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _FILE_PIPE_PEEK_BUFFER
{
    ULONG NamedPipeState;
    ULONG ReadDataAvailable;
    ULONG NumberOfMessages;
    ULONG MessageLength;
    CHAR Data[1];
} FILE_PIPE_PEEK_BUFFER, *PFILE_PIPE_PEEK_BUFFER;

typedef struct _NAMED_PIPE_CREATE_PARAMETERS
{
    ULONG NamedPipeType;
    ULONG ReadMode;
    ULONG CompletionMode;
    ULONG MaximumInstances;
    ULONG InboundQuota;
    ULONG OutboundQuota;
    LARGE_INTEGER DefaultTimeout;
    BOOLEAN TimeoutSpecified;
} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;

typedef struct _FILE_NETWORK_OPEN_INFORMATION
{
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION
{
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef struct _SYSTEM_CONSOLE_INFORMATION
{
    ULONG DriverLoaded : 1;
    ULONG Spare : 31;
} SYSTEM_CONSOLE_INFORMATION, *PSYSTEM_CONSOLE_INFORMATION;

typedef struct _KSYSTEM_TIME
{
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

typedef struct _PROCESS_ACCESS_TOKEN
{
    HANDLE Token; // Needs TOKEN_ASSIGN_PRIMARY access
    HANDLE Thread; // Handle to initial/only thread; needs THREAD_QUERY_INFORMATION access
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

#ifdef __cplusplus
typedef enum _PS_PROTECTED_TYPE : UCHAR
{
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;
#else
typedef UCHAR PS_PROTECTED_TYPE;
#endif

#ifdef __cplusplus
typedef enum _PS_PROTECTED_SIGNER : UCHAR
{
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;
#else
typedef UCHAR PS_PROTECTED_SIGNER;
#endif

typedef struct _PS_PROTECTION
{
    union
    {
        struct
        {
            PS_PROTECTED_TYPE Type : 3;
            BOOLEAN Audit : 1;
            PS_PROTECTED_SIGNER Signer : 4;
        } s;
        UCHAR Level;
    };
} PS_PROTECTION, *PPS_PROTECTION;

#define RTL_CREATE_ENVIRONMENT_TRANSLATE            0x1 // Translate from multi-byte to Unicode
#define RTL_CREATE_ENVIRONMENT_TRANSLATE_FROM_OEM   0x2 // Translate from OEM to Unicode (Translate flag must also be set)
#define RTL_CREATE_ENVIRONMENT_EMPTY                0x4 // Create empty environment block

typedef struct _RTL_BUFFER
{
    PUCHAR Buffer;
    PUCHAR StaticBuffer;
    SIZE_T Size;
    SIZE_T StaticSize;
    SIZE_T ReservedForAllocatedSize; // for future doubling
    PVOID ReservedForIMalloc; // for future pluggable growth
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER
{
    UNICODE_STRING String;
    RTL_BUFFER ByteBuffer;
    UCHAR MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PWCHAR Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG_PTR EnvironmentSize;
    ULONG_PTR EnvironmentVersion;
    PVOID PackageDependencyData;
    ULONG ProcessGroupId;
    ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

#define RTL_USER_PROCESS_PARAMETERS_NORMALIZED              0x01
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_USER            0x02
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_KERNEL          0x04
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_SERVER          0x08
#define RTL_USER_PROCESS_PARAMETERS_RESERVE_1MB             0x20
#define RTL_USER_PROCESS_PARAMETERS_RESERVE_16MB            0x40
#define RTL_USER_PROCESS_PARAMETERS_CASE_SENSITIVE          0x80
#define RTL_USER_PROCESS_PARAMETERS_DISABLE_HEAP_DECOMMIT   0x100
#define RTL_USER_PROCESS_PARAMETERS_DLL_REDIRECTION_LOCAL   0x1000
#define RTL_USER_PROCESS_PARAMETERS_APP_MANIFEST_PRESENT    0x2000
#define RTL_USER_PROCESS_PARAMETERS_IMAGE_KEY_MISSING       0x4000
#define RTL_USER_PROCESS_PARAMETERS_NX_OPTIN                0x20000

typedef struct _RTL_USER_PROCESS_INFORMATION
{
    ULONG Length;
    HANDLE Process;
    HANDLE Thread;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

// Handle tag bits for PEB stdio file handles
#define PEB_STDIO_HANDLE_NATIVE     0
#define PEB_STDIO_HANDLE_SUBSYS     1
#define PEB_STDIO_HANDLE_PM         2
#define PEB_STDIO_HANDLE_RESERVED   3

#define GDI_HANDLE_BUFFER_SIZE32    34
#define GDI_HANDLE_BUFFER_SIZE64    60

#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

typedef struct _PEB_LDR_DATA
{
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _ACTIVATION_CONTEXT_STACK
{
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame;
    LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;

typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        } s1;
    } u1;

    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ReservedBits0 : 25;
        } s2;
    } u2;
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    } u3;
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];

    PVOID ReadOnlySharedMemoryBase;
    PVOID SharedData; // HotpatchInformation
    PVOID* ReadOnlyStaticServerData;

    PVOID AnsiCodePageData; // PCPTABLEINFO
    PVOID OemCodePageData; // PCPTABLEINFO
    PVOID UnicodeCaseTableData; // PNLSTABLEINFO

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID* ProcessHeaps; // PHEAP

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ActiveProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo; // APPCOMPAT_EXE_DATA

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID ProcessAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP
    PVOID SystemDefaultActivationContextData; // ACTIVATION_CONTEXT_DATA
    PVOID SystemAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP

    SIZE_T MinimumStackCommit;

    PVOID* FlsCallback;
    LIST_ENTRY FlsListHead;
    PVOID FlsBitmap;
    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    ULONG FlsHighIndex;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;
    PVOID pUnused; // pContextData
    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        } s3;
    } u4;
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
    PVOID TppWorkerpListLock;
    LIST_ENTRY TppWorkerpList;
    PVOID WaitOnAddressHashTable[128];
    PVOID TelemetryCoverageHeader; // REDSTONE3
    ULONG CloudFileFlags;
} PEB, *PPEB;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH
{
    ULONG Offset;
    ULONG_PTR HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME* Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef struct _TEB
{
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
    PVOID SystemReserved1[30];
#else
    PVOID SystemReserved1[26];
#endif
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderReserved[11];
    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK ActivationStack;

    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
    ULONG_PTR InstrumentationCallbackSp;
    ULONG_PTR InstrumentationCallbackPreviousPc;
    ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
    ULONG TxFsContext;
#endif
    BOOLEAN InstrumentationCallbackDisabled;
#ifndef _WIN64
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
#endif
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _WIN64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID PerflibData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        } s1;
    } u1;

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR ReservedForCodeCoverage;
    PVOID ThreadPoolData;
    PVOID* TlsExpansionSlots;
#ifdef _WIN64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    USHORT HeapVirtualAffinity;
    USHORT LowFragHeapDataSlot;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    } u2;
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SpareSameTebBits : 1;
        } s2;
    } u3;

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
} TEB, *PTEB;

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
{
    StandardDesign,
    NEC98x86,
    EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#define PROCESSOR_FEATURE_MAX       64

#define MAX_WOW64_SHARED_ENTRIES    16

#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON  1
#define NX_SUPPORT_POLICY_OPTIN     2
#define NX_SUPPORT_POLICY_OPTOUT    3

#pragma pack(push, 4)
typedef struct _KUSER_SHARED_DATA
{
    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;

    ULONG CryptoExponent;

    ULONG TimeZoneId;
    ULONG LargePageMinimum;
    ULONG AitSamplingValue;
    ULONG AppCompatFlag;
    ULONGLONG RNGSeedVersion;
    ULONG GlobalValidationRunlevel;
    LONG TimeZoneBiasStamp;

    ULONG NtBuildNumber;
    ULONG NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];

    ULONG Reserved1;
    ULONG Reserved3;

    volatile ULONG TimeSlip;

    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG BootId;

    LARGE_INTEGER SystemExpirationDate;

    ULONG SuiteMask;

    BOOLEAN KdDebuggerEnabled;
    union
    {
        UCHAR MitigationPolicies;
        struct
        {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        } s1;
    } u1;
    UCHAR Reserved6[2];

    volatile ULONG ActiveConsoleId;

    volatile ULONG DismountCount;

    ULONG ComPlusPackage;

    ULONG LastSystemRITEventTickCount;

    ULONG NumberOfPhysicalPages;

    BOOLEAN SafeBootMode;
    UCHAR VirtualizationFlags;
    UCHAR Reserved12[2];

    union
    {
        ULONG SharedDataFlags;
        struct
        {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG SpareBits : 22;
        } s2;
    } u2;
    ULONG DataFlagsPad[1];

    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;
    ULONG SystemCall;
    ULONG SystemCallPad0;
    ULONGLONG SystemCallPad[2];

    union
    {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        ULONG ReservedTickCountOverlay[3];
    };
    ULONG TickCountPad[1];

    ULONG Cookie;
    ULONG CookiePad[1];

    LONGLONG ConsoleSessionForegroundProcessId;
    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;

    USHORT UnparkedProcessorCount;
    ULONG EnclaveFeatureMask[4];
    ULONG Reserved8;
    USHORT UserModeGlobalLogger[16];
    ULONG ImageFileExecutionOptions;

    ULONG LangGenerationCount;
    ULONGLONG Reserved4;
    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;
    union
    {
        USHORT QpcData;
        struct
        {
            UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        } s3;
    } u3;

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;
    XSTATE_CONFIGURATION XState;
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#pragma pack(pop)

#ifdef __cplusplus
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x14, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x20, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x2c, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x2e, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x30, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dc, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x310, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3d8, "Offset check");
#endif

#if !defined(_KERNEL_MODE) && !defined(KERNELMODE)
#define USER_SHARED_DATA            0x7FFE0000
#define SharedUserData              ((KUSER_SHARED_DATA * const)USER_SHARED_DATA)
#else
#if defined(_M_IX86)
#define KI_USER_SHARED_DATA     0xFFDF0000
#elif defined (_M_AMD64)
#define KI_USER_SHARED_DATA     0xFFFFF78000000000Ui64
#elif defined (_M_ARM)
#define KI_USER_SHARED_DATA     0xFFFF9000
#elif defined(M_ARM64)
#define KI_USER_SHARED_DATA     0xFFFFF78000000000Ui64
#endif
#define SharedUserData              ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)
#endif

typedef struct _PROCESS_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
    SIZE_T Size; // Set to sizeof structure on input
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        } s;
    } u;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
{
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PTEB TebBase; // Since Vista
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

#ifndef FIELD_OFFSET
#if !defined(__clang__)
#define FIELD_OFFSET(type, field)   ((LONG)(LONG_PTR)&(((type *)0)->field))
#else
#define FIELD_OFFSET(type, field)   ((LONG)__builtin_offsetof(type, field))
#endif
#endif
#ifndef UFIELD_OFFSET
#if !defined(__clang__)
#define UFIELD_OFFSET(type, field)  ((ULONG)(LONG_PTR)&(((type *)0)->field))
#else
#define UFIELD_OFFSET(type, field)  ((ULONG)__builtin_offsetof(type, field))
#endif
#endif

#define PTR_ADD_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) + (ULONG_PTR)(Offset)))
#define PTR_SUB_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) - (ULONG_PTR)(Offset)))
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~(Align - 1))
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))

#define InitializeObjectAttributes( p, n, a, r, s ) {   \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

#define OBJ_INHERIT                                 0x00000002L
#define OBJ_PERMANENT                               0x00000010L
#define OBJ_EXCLUSIVE                               0x00000020L
#define OBJ_CASE_INSENSITIVE                        0x00000040L
#define OBJ_OPENIF                                  0x00000080L
#define OBJ_OPENLINK                                0x00000100L
#define OBJ_KERNEL_HANDLE                           0x00000200L
#define OBJ_FORCE_ACCESS_CHECK                      0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP           0x00000800
#define OBJ_DONT_REPARSE                            0x00001000
#define OBJ_VALID_ATTRIBUTES                        0x00001FF2

#if NTDDI_VERSION >= NTDDI_VISTA
#define THREAD_ALL_ACCESS                           (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                                    0xFFFF)
#else
#define THREAD_ALL_ACCESS                           (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                                    0x3FF)
#endif

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED        0x00000001
#define THREAD_CREATE_FLAGS_SUPPRESS_DLLMAINS       0x00000002
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER      0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 // ?
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET  0x00000020 // ?
#define THREAD_CREATE_FLAGS_INITIAL_THREAD          0x00000080

#define DEBUG_READ_EVENT                            0x0001
#define DEBUG_PROCESS_ASSIGN                        0x0002
#define DEBUG_SET_INFORMATION                       0x0004
#define DEBUG_QUERY_INFORMATION                     0x0008

#define DEBUG_ALL_ACCESS                            (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                                    DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
                                                    DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE                         0x1

#ifndef IO_COMPLETION_QUERY_STATE
#define IO_COMPLETION_QUERY_STATE                   0x0001
#endif
#ifndef IO_COMPLETION_MODIFY_STATE
#define IO_COMPLETION_MODIFY_STATE                  0x0002
#endif
#ifndef IO_COMPLETION_ALL_ACCESS
#define IO_COMPLETION_ALL_ACCESS                    (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                                    IO_COMPLETION_QUERY_STATE | IO_COMPLETION_MODIFY_STATE)
#endif

#ifndef SEMAPHORE_ALL_ACCESS
#define SEMAPHORE_QUERY_STATE                       0x0001
#define SEMAPHORE_MODIFY_STATE                      0x0002

#define SEMAPHORE_ALL_ACCESS                        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                                    SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE)
#endif

#ifndef MUTANT_ALL_ACCESS
#define MUTANT_QUERY_STATE                          0x0001

#define MUTANT_ALL_ACCESS                           (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                                    MUTANT_QUERY_STATE)
#endif

#ifndef EVENT_ALL_ACCESS
#define EVENT_QUERY_STATE                           0x0001
#define EVENT_MODIFY_STATE                          0x0002

#define EVENT_ALL_ACCESS                            (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                                    EVENT_QUERY_STATE | EVENT_MODIFY_STATE)
#endif

#define KEYEDEVENT_WAIT                             0x0001
#define KEYEDEVENT_WAKE                             0x0002
#define KEYEDEVENT_ALL_ACCESS                       (STANDARD_RIGHTS_REQUIRED | \
                                                    KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

#define DIRECTORY_QUERY                             0x0001
#define DIRECTORY_TRAVERSE                          0x0002
#define DIRECTORY_CREATE_OBJECT                     0x0004
#define DIRECTORY_CREATE_SUBDIRECTORY               0x0008

#define DIRECTORY_ALL_ACCESS                        (STANDARD_RIGHTS_REQUIRED | \
                                                    DIRECTORY_QUERY | DIRECTORY_TRAVERSE | \
                                                    DIRECTORY_CREATE_OBJECT | DIRECTORY_CREATE_SUBDIRECTORY)

#define SYMBOLIC_LINK_QUERY                         0x0001

#define SYMBOLIC_LINK_ALL_ACCESS                    (STANDARD_RIGHTS_REQUIRED | \
                                                    SYMBOLIC_LINK_QUERY)

#ifndef TOKEN_ALL_ACCESS
#define TOKEN_ASSIGN_PRIMARY                        0x0001
#define TOKEN_DUPLICATE                             0x0002
#define TOKEN_IMPERSONATE                           0x0004
#define TOKEN_QUERY                                 0x0008
#define TOKEN_QUERY_SOURCE                          0x0010
#define TOKEN_ADJUST_PRIVILEGES                     0x0020
#define TOKEN_ADJUST_GROUPS                         0x0040
#define TOKEN_ADJUST_DEFAULT                        0x0080
#define TOKEN_ADJUST_SESSIONID                      0x0100

#define TOKEN_ALL_ACCESS_P                          (STANDARD_RIGHTS_REQUIRED | \
                                                    TOKEN_ASSIGN_PRIMARY | \
                                                    TOKEN_DUPLICATE | \
                                                    TOKEN_IMPERSONATE | \
                                                    TOKEN_QUERY | \
                                                    TOKEN_QUERY_SOURCE | \
                                                    TOKEN_ADJUST_PRIVILEGES | \
                                                    TOKEN_ADJUST_GROUPS | \
                                                    TOKEN_ADJUST_DEFAULT)

#define TOKEN_ALL_ACCESS                            (TOKEN_ALL_ACCESS_P | \
                                                    TOKEN_ADJUST_SESSIONID)
#endif

#define WORKER_FACTORY_RELEASE_WORKER               0x0001
#define WORKER_FACTORY_WAIT                         0x0002
#define WORKER_FACTORY_SET_INFORMATION              0x0004
#define WORKER_FACTORY_QUERY_INFORMATION            0x0008
#define WORKER_FACTORY_READY_WORKER                 0x0010
#define WORKER_FACTORY_SHUTDOWN                     0x0020

#define WORKER_FACTORY_ALL_ACCESS                   (STANDARD_RIGHTS_REQUIRED | \
                                                    WORKER_FACTORY_RELEASE_WORKER | \
                                                    WORKER_FACTORY_WAIT | \
                                                    WORKER_FACTORY_SET_INFORMATION | \
                                                    WORKER_FACTORY_QUERY_INFORMATION | \
                                                    WORKER_FACTORY_READY_WORKER | \
                                                    WORKER_FACTORY_SHUTDOWN)

#define NtCurrentProcess        ((HANDLE)(LONG_PTR)-1)
#define NtCurrentThread         ((HANDLE)(LONG_PTR)-2)
#define NtCurrentPeb()          (NtCurrentTeb()->ProcessEnvironmentBlock)
#define NtCurrentProcessId()    (NtCurrentTeb()->ClientId.UniqueProcess)
#define NtCurrentThreadId()     (NtCurrentTeb()->ClientId.UniqueThread)
#define RtlProcessHeap()        (NtCurrentPeb()->ProcessHeap)

typedef struct _RTL_HEAP_ENTRY
{
    SIZE_T Size;
    USHORT Flags;
    USHORT AllocatorBackTraceIndex;
    union
    {
        struct
        {
            SIZE_T Settable;
            ULONG Tag;
        } s1;
        struct
        {
            SIZE_T CommittedSize;
            PVOID FirstBlock;
        } s2;
    } u;
} RTL_HEAP_ENTRY, *PRTL_HEAP_ENTRY;

#define RTL_HEAP_BUSY               (USHORT)0x0001
#define RTL_HEAP_SEGMENT            (USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE     (USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1     (USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2     (USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3     (USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS     (USHORT)0x00e0
#define RTL_HEAP_UNCOMMITTED_RANGE  (USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY    (USHORT)0x0200

typedef struct _RTL_HEAP_TAG
{
    ULONG NumberOfAllocations;
    ULONG NumberOfFrees;
    SIZE_T BytesAllocated;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[24];
} RTL_HEAP_TAG, *PRTL_HEAP_TAG;

typedef struct _RTL_HEAP_INFORMATION
{
    PVOID BaseAddress;
    ULONG Flags;
    USHORT EntryOverhead;
    USHORT CreatorBackTraceIndex;
    SIZE_T BytesAllocated;
    SIZE_T BytesCommitted;
    ULONG NumberOfTags;
    ULONG NumberOfEntries;
    ULONG NumberOfPseudoTags;
    ULONG PseudoTagGranularity;
    ULONG Reserved[5];
    PRTL_HEAP_TAG Tags;
    PRTL_HEAP_ENTRY Entries;
} RTL_HEAP_INFORMATION, *PRTL_HEAP_INFORMATION;

typedef struct _RTL_PROCESS_HEAPS
{
    ULONG NumberOfHeaps;
    RTL_HEAP_INFORMATION Heaps[1];
} RTL_PROCESS_HEAPS, *PRTL_PROCESS_HEAPS;

typedef
NTSTATUS
(NTAPI*
 PRTL_HEAP_COMMIT_ROUTINE)(
     _In_ PVOID Base,
     _Inout_ PVOID* CommitAddress,
     _Inout_ PSIZE_T CommitSize
 );

typedef struct _RTL_HEAP_PARAMETERS
{
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#define HEAP_SETTABLE_USER_VALUE 0x00000100
#define HEAP_SETTABLE_USER_FLAG1 0x00000200
#define HEAP_SETTABLE_USER_FLAG2 0x00000400
#define HEAP_SETTABLE_USER_FLAG3 0x00000800
#define HEAP_SETTABLE_USER_FLAGS 0x00000e00

#define HEAP_CLASS_0 0x00000000 // Process heap
#define HEAP_CLASS_1 0x00001000 // Private heap
#define HEAP_CLASS_2 0x00002000 // Kernel heap
#define HEAP_CLASS_3 0x00003000 // GDI heap
#define HEAP_CLASS_4 0x00004000 // User heap
#define HEAP_CLASS_5 0x00005000 // Console heap
#define HEAP_CLASS_6 0x00006000 // User desktop heap
#define HEAP_CLASS_7 0x00007000 // CSR shared heap
#define HEAP_CLASS_8 0x00008000 // CSR port heap
#define HEAP_CLASS_MASK 0x0000f000

typedef struct _RTL_HEAP_TAG_INFO
{
    ULONG NumberOfAllocations;
    ULONG NumberOfFrees;
    SIZE_T BytesAllocated;
} RTL_HEAP_TAG_INFO, *PRTL_HEAP_TAG_INFO;

#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS

typedef struct _RTL_HEAP_WALK_ENTRY
{
    PVOID DataAddress;
    SIZE_T DataSize;
    UCHAR OverheadBytes;
    UCHAR SegmentIndex;
    USHORT Flags;
    union
    {
        struct
        {
            SIZE_T Settable;
            USHORT TagIndex;
            USHORT AllocatorBackTraceIndex;
            ULONG Reserved[2];
        } Block;
        struct
        {
            ULONG CommittedSize;
            ULONG UnCommittedSize;
            PVOID FirstEntry;
            PVOID LastEntry;
        } Segment;
    };
} RTL_HEAP_WALK_ENTRY, *PRTL_HEAP_WALK_ENTRY;

// HEAP_INFORMATION_CLASS. winnt.h is incomplete
#define HeapCompatibilityInformation 0x0 // q; s: ULONG
#define HeapEnableTerminationOnCorruption 0x1 // q; s: NULL
#define HeapExtendedInformation 0x2 // q; s: HEAP_EXTENDED_INFORMATION
#define HeapOptimizeResources 0x3 // q; s: HEAP_OPTIMIZE_RESOURCES_INFORMATION 
#define HeapTaggingInformation 0x4
#define HeapStackDatabase 0x5
#define HeapDetailedFailureInformation 0x80000001
#define HeapSetDebuggingInformation 0x80000002 // q; s: HEAP_DEBUGGING_INFORMATION

typedef struct _PROCESS_HEAP_INFORMATION
{
    ULONG_PTR ReserveSize;
    ULONG_PTR CommitSize;
    ULONG NumberOfHeaps;
    ULONG_PTR FirstHeapInformationOffset;
} PROCESS_HEAP_INFORMATION, *PPROCESS_HEAP_INFORMATION;

typedef struct _HEAP_INFORMATION
{
    ULONG_PTR Address;
    ULONG Mode;
    ULONG_PTR ReserveSize;
    ULONG_PTR CommitSize;
    ULONG_PTR FirstRegionInformationOffset;
    ULONG_PTR NextHeapInformationOffset;
} HEAP_INFORMATION, *PHEAP_INFORMATION;

typedef struct _HEAP_EXTENDED_INFORMATION
{
    HANDLE Process;
    ULONG_PTR Heap;
    ULONG Level;
    PVOID CallbackRoutine;
    PVOID CallbackContext;
    PROCESS_HEAP_INFORMATION ProcessHeapInformation;
    HEAP_INFORMATION HeapInformation;
} HEAP_EXTENDED_INFORMATION, *PHEAP_EXTENDED_INFORMATION;

typedef
NTSTATUS
(NTAPI*
 PRTL_HEAP_LEAK_ENUMERATION_ROUTINE)(
     _In_ LONG Reserved,
     _In_ PVOID HeapHandle,
     _In_ PVOID BaseAddress,
     _In_ SIZE_T BlockSize,
     _In_ ULONG StackTraceDepth,
     _In_ PVOID* StackTrace
 );

typedef struct _HEAP_DEBUGGING_INFORMATION
{
    PVOID InterceptorFunction;
    USHORT InterceptorValue;
    ULONG ExtendedOptions;
    ULONG StackTraceDepth;
    SIZE_T MinTotalBlockSize;
    SIZE_T MaxTotalBlockSize;
    PRTL_HEAP_LEAK_ENUMERATION_ROUTINE HeapLeakEnumerationRoutine;
} HEAP_DEBUGGING_INFORMATION, *PHEAP_DEBUGGING_INFORMATION;

typedef
NTSTATUS
(NTAPI*
 PRTL_ENUM_HEAPS_ROUTINE)(
     _In_ PVOID HeapHandle,
     _In_ PVOID Parameter
 );

typedef
NTSTATUS
(NTAPI*
 PUSER_THREAD_START_ROUTINE)(
     _In_ PVOID ThreadParameter
 );

#define LDR_FORMAT_MESSAGE_FROM_SYSTEM_MESSAGE_TABLE    11

#define RTL_ERRORMODE_NOGPFAULTERRORBOX                 0x0020
#define RTL_ERRORMODE_NOOPENFILEERRORBOX                0x0040

#define RTL_ACQUIRE_PRIVILEGE_REVERT                    0x00000001
#define RTL_ACQUIRE_PRIVILEGE_PROCESS                   0x00000002

typedef
VOID
(NTAPI*
 PLDR_IMPORT_MODULE_CALLBACK)(
     _In_ PVOID Parameter,
     _In_ PSTR ModuleName
 );

typedef struct _LDR_IMPORT_CALLBACK_INFO
{
    PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine;
    PVOID ImportCallbackParameter;
} LDR_IMPORT_CALLBACK_INFO, *PLDR_IMPORT_CALLBACK_INFO;

typedef struct _LDR_SECTION_INFO
{
    HANDLE SectionHandle;
    ACCESS_MASK DesiredAccess;
    POBJECT_ATTRIBUTES ObjectAttributes;
    ULONG SectionPageProtection;
    ULONG AllocationAttributes;
} LDR_SECTION_INFO, *PLDR_SECTION_INFO;

typedef struct _LDR_VERIFY_IMAGE_INFO
{
    ULONG Size;
    ULONG Flags;
    LDR_IMPORT_CALLBACK_INFO CallbackInfo;
    LDR_SECTION_INFO SectionInfo;
    USHORT ImageCharacteristics;
} LDR_VERIFY_IMAGE_INFO, *PLDR_VERIFY_IMAGE_INFO;

typedef enum _SEMAPHORE_INFORMATION_CLASS
{
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION
{
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

typedef enum _TIMER_INFORMATION_CLASS
{
    TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION
{
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef
VOID
(NTAPI*
 PTIMER_APC_ROUTINE)(
     _In_ PVOID TimerContext,
     _In_ ULONG TimerLowValue,
     _In_ LONG TimerHighValue
 );

typedef enum _TIMER_SET_INFORMATION_CLASS
{
    TimerSetCoalescableTimer,
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

typedef struct _TIMER_SET_COALESCABLE_TIMER_INFO
{
    _In_ LARGE_INTEGER DueTime;
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine;
    _In_opt_ PVOID TimerContext;
    _In_opt_ struct _COUNTED_REASON_CONTEXT* WakeContext;
    _In_opt_ ULONG Period;
    _In_ ULONG TolerableDelay;
    _Out_opt_ PBOOLEAN PreviousState;
} TIMER_SET_COALESCABLE_TIMER_INFO, *PTIMER_SET_COALESCABLE_TIMER_INFO;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
    ULONG64 Version;
    UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
    PVOID pValue;
    ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
    UNICODE_STRING Name;
    USHORT ValueType;
    USHORT Reserved;
    ULONG Flags;
    ULONG ValueCount;
    union
    {
        PLONG64 pInt64;
        PULONG64 pUint64;
        PUNICODE_STRING pString;
        PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1    1
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION       TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
    USHORT Version;
    USHORT Reserved;
    ULONG AttributeCount;
    union
    {
        PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

typedef enum _FILTER_BOOT_OPTION_OPERATION
{
    FilterBootOptionOperationOpenSystemStore,
    FilterBootOptionOperationSetElement,
    FilterBootOptionOperationDeleteElement,
    FilterBootOptionOperationMax
} FILTER_BOOT_OPTION_OPERATION;

typedef enum _IO_SESSION_EVENT
{
    IoSessionEventIgnore,
    IoSessionEventCreated,
    IoSessionEventTerminated,
    IoSessionEventConnected,
    IoSessionEventDisconnected,
    IoSessionEventLogon,
    IoSessionEventLogoff,
    IoSessionEventMax
} IO_SESSION_EVENT;

typedef enum _IO_SESSION_STATE
{
    IoSessionStateCreated,
    IoSessionStateInitialized,
    IoSessionStateConnected,
    IoSessionStateDisconnected,
    IoSessionStateDisconnectedLoggedOn,
    IoSessionStateLoggedOn,
    IoSessionStateLoggedOff,
    IoSessionStateTerminated,
    IoSessionStateMax
} IO_SESSION_STATE;

typedef struct _PORT_MESSAGE PORT_MESSAGE, *PPORT_MESSAGE;
typedef struct _TP_ALPC TP_ALPC, *PTP_ALPC;

typedef
VOID
(NTAPI*
 PTP_ALPC_CALLBACK)(
     _Inout_ PTP_CALLBACK_INSTANCE Instance,
     _Inout_opt_ PVOID Context,
     _In_ PTP_ALPC Alpc
 );

typedef
VOID
(NTAPI*
 PTP_ALPC_CALLBACK_EX)(
     _Inout_ PTP_CALLBACK_INSTANCE Instance,
     _Inout_opt_ PVOID Context,
     _In_ PTP_ALPC Alpc,
     _In_ PVOID ApcContext
 );

typedef
VOID
(NTAPI*
 PTP_IO_CALLBACK)(
     _Inout_ PTP_CALLBACK_INSTANCE Instance,
     _Inout_opt_ PVOID Context,
     _In_ PVOID ApcContext,
     _In_ PIO_STATUS_BLOCK IoSB,
     _In_ PTP_IO Io
 );

typedef enum _IO_COMPLETION_INFORMATION_CLASS
{
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION
{
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

typedef enum _WORKERFACTORYINFOCLASS
{
    WorkerFactoryTimeout,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation, // 10
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters, // since THRESHOLD
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION
{
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

typedef struct _BOOT_ENTRY
{
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[1];
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_ENTRY_LIST
{
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

typedef struct _BOOT_OPTIONS
{
    ULONG Version;
    ULONG Length;
    ULONG Timeout;
    ULONG CurrentBootEntryId;
    ULONG NextBootEntryId;
    WCHAR HeadlessRedirection[1];
} BOOT_OPTIONS, *PBOOT_OPTIONS;

typedef struct _FILE_PATH
{
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[1];
} FILE_PATH, *PFILE_PATH;

typedef struct _EFI_DRIVER_ENTRY
{
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG FriendlyNameOffset;
    ULONG DriverFilePathOffset;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;

typedef struct _EFI_DRIVER_ENTRY_LIST
{
    ULONG NextEntryOffset;
    EFI_DRIVER_ENTRY DriverEntry;
} EFI_DRIVER_ENTRY_LIST, *PEFI_DRIVER_ENTRY_LIST;

FORCEINLINE
VOID
InitializeListHead(
    _Out_ PLIST_ENTRY ListHead
)
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

FORCEINLINE
BOOLEAN
IsListEmpty(
    _In_ PLIST_ENTRY ListHead
)
{
    return ListHead->Flink == ListHead;
}

FORCEINLINE
BOOLEAN
RemoveEntryList(
    _In_ PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Flink = Entry->Flink;
    PLIST_ENTRY Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;

    return Flink == Blink;
}

FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Entry = ListHead->Flink;
    PLIST_ENTRY Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;

    return Entry;
}

FORCEINLINE
PLIST_ENTRY
RemoveTailList(
    _Inout_ PLIST_ENTRY ListHead
)
{
    PLIST_ENTRY Entry = ListHead->Blink;
    PLIST_ENTRY Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;

    return Entry;
}

FORCEINLINE
VOID
InsertTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}

FORCEINLINE
VOID
InsertHeadList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY Entry
)
{
    PLIST_ENTRY Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}

FORCEINLINE
VOID
AppendTailList(
    _Inout_ PLIST_ENTRY ListHead,
    _Inout_ PLIST_ENTRY ListToAppend
)
{
    PLIST_ENTRY ListEnd = ListHead->Blink;

    ListHead->Blink->Flink = ListToAppend;
    ListHead->Blink = ListToAppend->Blink;
    ListToAppend->Blink->Flink = ListHead;
    ListToAppend->Blink = ListEnd;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
PopEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead
)
{
    PSINGLE_LIST_ENTRY FirstEntry = ListHead->Next;

    if(FirstEntry)
        ListHead->Next = FirstEntry->Next;

    return FirstEntry;
}

FORCEINLINE
VOID
PushEntryList(
    _Inout_ PSINGLE_LIST_ENTRY ListHead,
    _Inout_ PSINGLE_LIST_ENTRY Entry
)
{
    Entry->Next = ListHead->Next;
    ListHead->Next = Entry;
}

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritObjectTable,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ BOOLEAN InJob
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags,
    _In_ ULONG ThreadFlags,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_ PPS_ATTRIBUTE_LIST AttributeList
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_ PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_ PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_opt_ PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_opt_ PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_ PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_opt_ PVOID SystemInformation,
    _In_ ULONG SystemInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_ PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_ PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendProcess(
    _In_ HANDLE ProcessHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeProcess(
    _In_ HANDLE ProcessHandle
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSignalAndWaitForSingleObject(
    _In_ HANDLE SignalHandle,
    _In_ HANDLE WaitHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_ PHANDLE Handles,
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects32(
    _In_ ULONG Count,
    _In_ PHANDLE Handles,
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE UserApcReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushWriteBuffer(
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _Out_ PIO_STATUS_BLOCK IoStatus
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_ PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtYieldExecution(
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClose(
    _In_ HANDLE Handle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_BASIC_INFORMATION FileInformation
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID Buffer,
    _In_ ULONG Length
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FS_INFORMATION_CLASS FsInformationClass
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_opt_ PVOID EaBuffer,
    _In_ ULONG EaLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFileEx(
    _In_ HANDLE FileHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelSynchronousIoFile(
    _In_ HANDLE ThreadHandle,
    _In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG ReturnedLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextProcess(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewProcessHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextThread(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Flags,
    _Out_ PHANDLE NewThreadHandle
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _Out_ PCLIENT_ID ClientId,
    _In_ PCONTEXT ThreadContext,
    _In_ PINITIAL_TEB InitialTeb,
    _In_ BOOLEAN CreateSuspended
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ PUSER_THREAD_START_ROUTINE StartRoutine,
    _In_opt_ PVOID Argument,
    _In_ ULONG CreateFlags,
    _In_opt_ ULONG_PTR ZeroBits,
    _In_opt_ SIZE_T StackSize,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList
);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterThreadTerminatePort(
    _In_ HANDLE PortHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseHardError(
    _In_ NTSTATUS ErrorStatus,
    _In_ ULONG NumberOfParameters,
    _In_opt_ ULONG UnicodeStringParameterMask,
    _In_ PULONG_PTR Parameters,
    _In_ HARDERROR_RESPONSE_OPTION ResponseOption,
    _Out_ PHARDERROR_RESPONSE Response
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_ PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ CONST VOID* Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_ PULONG_PTR UserPfnArray
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_ PULONG_PTR UserPfnArray
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
    _In_ PVOID* VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_ PULONG_PTR UserPfnArray
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_ PULONG_PTR UserPfnArray
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_ PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAreMappedFilesTheSame(
    _In_ PVOID File1MappedAsAnImage,
    _In_ PVOID File2MappedAsFile
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ FILE_NOTIFY_INFORMATION Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID Buffer,
    _In_ ULONG Length
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_ PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_opt_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
    _In_ HANDLE Object
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
    _In_ HANDLE Handle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferLength,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
    _Out_ PLARGE_INTEGER SystemTime
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemTime(
    _In_opt_ PLARGE_INTEGER SystemTime,
    _Out_opt_ PLARGE_INTEGER PreviousTime
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimerResolution(
    _Out_ PULONG MaximumTime,
    _Out_ PULONG MinimumTime,
    _Out_ PULONG CurrentTime
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerResolution(
    _In_ ULONG DesiredTime,
    _In_ BOOLEAN SetResolution,
    _Out_ PULONG ActualTime
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCounter,
    _Out_opt_ PLARGE_INTEGER PerformanceFrequency
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateLocallyUniqueId(
    _Out_ PLUID Luid
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetUuidSeed(
    _In_ PCHAR Seed
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUuids(
    _Out_ PULARGE_INTEGER Time,
    _Out_ PULONG Range,
    _Out_ PULONG Sequence,
    _Out_ PCHAR Seed
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClearEvent(
    _In_ HANDLE EventHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FS_INFORMATION_CLASS FsInformationClass
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition
);

#if NTDDI_VERSION >= PNTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

#if NTDDI_VERSION >= PNTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle
);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteKey(
    _In_ HANDLE KeyHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_ PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_ PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_ PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_ PVOID Data,
    _In_ ULONG DataSize
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_ PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_ PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_ PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_ PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushKey(
    _In_ HANDLE KeyHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompactKeys(
    _In_ ULONG Count,
    _In_ PHANDLE KeyArray
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompressKey(
    _In_ HANDLE Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplaceKey(
    _In_ POBJECT_ATTRIBUTES NewFile,
    _In_ HANDLE TargetHandle,
    _In_ POBJECT_ATTRIBUTES OldFile
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveMergedKeys(
    _In_ HANDLE HighPrecedenceKeyHandle,
    _In_ HANDLE LowPrecedenceKeyHandle,
    _In_ HANDLE FileHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRestoreKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Flags
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeMultipleKeys(
    _In_ HANDLE MasterKeyHandle,
    _In_opt_ ULONG Count,
    _In_ POBJECT_ATTRIBUTES SubordinateObjects,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeys(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _Out_ PULONG HandleCount
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeysEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG BufferLength,
    _Out_ PVOID Buffer,
    _Out_ PULONG RequiredSize
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeRegistry(
    _In_ USHORT BootCondition
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
    _In_ HANDLE KeyHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockProductActivationKeys(
    _Inout_opt_ ULONG* pPrivateVer,
    _Out_opt_ ULONG* pSafeMode
);

#if NTDDI_VERSION >= PNTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeRegistry(
    _In_ ULONG TimeOutInSeconds
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawRegistry(
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDelayExecution(
    _In_ BOOLEAN Alertable,
    _In_ PLARGE_INTEGER DelayInterval
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCallbackReturn(
    _In_ PVOID OutputBuffer,
    _In_ ULONG OutputLength,
    _In_ NTSTATUS Status
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
VOID
NTAPI
NtFlushProcessWriteBuffers(
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForDebugEvent(
    _In_ HANDLE DebugObjectHandle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugContinue(
    _In_ HANDLE DebugObjectHandle,
    _In_ PCLIENT_ID ClientId,
    _In_ NTSTATUS ContinueStatus
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationDebugObject(
    _In_ HANDLE DebugObjectHandle,
    _In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    _In_ PVOID DebugInformation,
    _In_ ULONG DebugInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_opt_ PTOKEN_PRIVILEGES PreviousState,
    _Out_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_ PTOKEN_GROUPS PreviousState,
    _Out_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_ PVOID TokenInformation,
    _In_ ULONG TokenInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityAttributesToken(
    _In_ HANDLE TokenHandle,
    _In_reads_opt_(NumberOfAttributes) PUNICODE_STRING Attributes,
    _In_ ULONG NumberOfAttributes,
    _Out_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION Buffer,
    _In_ ULONG Length,
    _Out_ PULONG ReturnLength
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_ PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_ PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_ PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG Count
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_ PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID* KeyContext,
    _Out_ PVOID* ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
    _In_ ULONG Count,
    _Out_ PULONG NumEntriesRemoved,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_ BOOLEAN Alertable
);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeSession(
    _In_ HANDLE SessionHandle,
    _In_ ULONG ChangeSequenceNumber,
    _In_ PLARGE_INTEGER ChangeTimeStamp,
    _In_ IO_SESSION_EVENT Event,
    _In_ IO_SESSION_STATE NewState,
    _In_ IO_SESSION_STATE PreviousState,
    _In_ PVOID Payload,
    _In_ ULONG PayloadSize
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertThread(
    _In_ HANDLE ThreadHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTestAlert(
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_ PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN ResumeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_ PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength
);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_ PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForKeyedEvent(
    _In_ HANDLE KeyedEventHandle,
    _In_ PVOID KeyValue,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUmsThreadYield(
    _In_ PVOID SchedulerParam
);
#endif

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG CommitStrength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_opt_ ULONG OpenOptions
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameTransactionManager(
    _In_ PUNICODE_STRING LogFileName,
    _In_ LPGUID ExistingTransactionManagerGuid
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollforwardTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverTransactionManager(
    _In_ HANDLE TransactionManagerHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransactionManager(
    _In_ HANDLE TransactionManagerHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _Out_ PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransactionManager(
    _In_opt_ HANDLE TmHandle,
    _In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
    _In_ PVOID TransactionManagerInformation,
    _In_ ULONG TransactionManagerInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateTransactionObject(
    _In_opt_ HANDLE RootObjectHandle,
    _In_ KTMOBJECT_TYPE QueryType,
    _Inout_updates_bytes_(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
    _In_ ULONG ObjectCursorLength,
    _Out_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG IsolationLevel,
    _In_opt_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _Out_ PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
    _In_ PVOID TransactionInformation,
    _In_ ULONG TransactionInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _Out_ PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationEnlistment(
    _In_opt_ HANDLE EnlistmentHandle,
    _In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
    _In_ PVOID EnlistmentInformation,
    _In_ ULONG EnlistmentInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PVOID EnlistmentKey
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadOnlyEnlistment(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackComplete(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSinglePhaseReject(
    _In_ HANDLE EnlistmentHandle,
    _In_opt_ PLARGE_INTEGER TmVirtualClock
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_ LPGUID RmGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverResourceManager(
    _In_ HANDLE ResourceManagerHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNotificationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _Out_ PTRANSACTION_NOTIFICATION TransactionNotification,
    _In_ ULONG NotificationLength,
    _In_opt_ PLARGE_INTEGER Timeout,
    _Out_opt_ PULONG ReturnLength,
    _In_ ULONG Asynchronous,
    _In_opt_ ULONG_PTR AsynchronousContext
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _Out_ PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationResourceManager(
    _In_ HANDLE ResourceManagerHandle,
    _In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
    _In_ PVOID ResourceManagerInformation,
    _In_ ULONG ResourceManagerInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterProtocolAddressInformation(
    _In_ HANDLE ResourceManager,
    _In_ PCRM_PROTOCOL_ID ProtocolId,
    _In_ ULONG ProtocolInformationSize,
    _In_ PVOID ProtocolInformation,
    _In_opt_ ULONG CreateOptions
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationComplete(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ ULONG BufferLength,
    _In_ PVOID Buffer
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationFailed(
    _In_ HANDLE ResourceManagerHandle,
    _In_ ULONG RequestCookie,
    _In_ NTSTATUS PropStatus
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawTransactions(
);
#endif

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PUSER_THREAD_START_ROUTINE StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_ PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _In_ PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG* PendingWorkerCount
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWorkerFactoryWorkerReady(
    _In_ HANDLE WorkerFactoryHandle
);
#endif

#if NTDDI_VERSION >= NTDDI_VISTA
#if NTDDI_VERSION >= NTDDI_WIN8 || defined(_WIN64)
// Windows 8+ declaration, but can be used on any x64 Windows Vista+
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForWorkViaWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Out_ PFILE_IO_COMPLETION_INFORMATION MiniPacket,
    _In_ ULONG Count,
    _Out_ PULONG NumEntriesRemoved,
    _In_ PLARGE_INTEGER Unknown // Wrong type (but works)
);
#else
// Windows Vista/7 x86
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForWorkViaWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Out_ PFILE_IO_COMPLETION_INFORMATION MiniPacket
);
#endif
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _Out_ PWSTR VariableValue,
    _In_ USHORT ValueLength,
    _Out_opt_ PUSHORT ReturnLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValue(
    _In_ PUNICODE_STRING VariableName,
    _In_ PUNICODE_STRING VariableValue
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ LPGUID VendorGuid,
    _Out_ PVOID Value,
    _Inout_ PULONG ValueLength,
    _Out_opt_ PULONG Attributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValueEx(
    _In_ PUNICODE_STRING VariableName,
    _In_ LPGUID VendorGuid,
    _In_ PVOID Value,
    _In_ ULONG ValueLength,
    _In_ ULONG Attributes
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateSystemEnvironmentValuesEx(
    _In_ ULONG InformationClass,
    _Out_ PVOID Buffer,
    _Inout_ PULONG BufferLength
);

#if NTDDI_VERSION >= NTDDI_VISTA

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddBootEntry(
    _In_ PBOOT_ENTRY BootEntry,
    _Out_opt_ PULONG Id
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteBootEntry(
    _In_ ULONG Id
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyBootEntry(
    _In_ PBOOT_ENTRY BootEntry
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootOptions(
    _Out_writes_bytes_opt_(*BootOptionsLength) PBOOT_OPTIONS BootOptions,
    _Inout_ PULONG BootOptionsLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootOptions(
    _In_ PBOOT_OPTIONS BootOptions,
    _In_ ULONG FieldsToChange
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTranslateFilePath(
    _In_ PFILE_PATH InputFilePath,
    _In_ ULONG OutputType,
    _Out_writes_bytes_opt_(*OutputFilePathLength) PFILE_PATH OutputFilePath,
    _Inout_opt_ PULONG OutputFilePathLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry,
    _Out_opt_ PULONG Id
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteDriverEntry(
    _In_ ULONG Id
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyDriverEntry(
    _In_ PEFI_DRIVER_ENTRY DriverEntry
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateDriverEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDriverEntryOrder(
    _Out_writes_opt_(*Count) PULONG Ids,
    _Inout_ PULONG Count
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDriverEntryOrder(
    _In_reads_(Count) PULONG Ids,
    _In_ ULONG Count
);

#endif

#if NTDDI_VERSION >= NTDDI_WIN7

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSerializeBoot(
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnableLastKnownGood(
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDisableLastKnownGood(
);

#endif

NTSYSAPI
ULONG
__cdecl
DbgPrint(
    _In_ PCH Format,
    ...
);

NTSYSAPI
ULONG
__cdecl
DbgPrintEx(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ PCSTR Format,
    ...
);

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
);

NTSYSAPI
HANDLE
NTAPI
DbgUiGetThreadDebugObject(
);

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
    _In_ HANDLE DebugObject
);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiWaitStateChange(
    _Out_ PDBGUI_WAIT_STATE_CHANGE StateChange,
    _In_opt_ PLARGE_INTEGER Timeout
);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
    _In_ PCLIENT_ID AppClientId,
    _In_ NTSTATUS ContinueStatus
);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
    _In_ HANDLE Process
);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
    _In_ HANDLE Process
);

NTSYSAPI
VOID
NTAPI
DbgUiRemoteBreakin(
    _In_ PVOID Context
);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiIssueRemoteBreakin(
    _In_ HANDLE Process
);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConvertStateChangeStructure(
    _In_ PDBGUI_WAIT_STATE_CHANGE StateChange,
    _Out_ DEBUG_EVENT* DebugEvent
);

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_ PVOID* DllHandle
);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_ PVOID* DllHandle
);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_opt_ PVOID* DllHandle
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
    _In_ PVOID Base,
    _Out_ PVOID* DllHandle
);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID* DllHandle
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ CONST PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID* ProcedureAddress
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID* ProcedureAddress,
    _In_ ULONG Flags
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG* Disposition,
    _Out_ PVOID* Cookie
);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie
);

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff
);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
    _In_ PVOID DllHandle
);

NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllHandle
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
    _In_ PUNICODE_STRING SubKey,
    _In_ BOOLEAN Wow64,
    _Out_ PHANDLE NewKeyHandle
);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR ValueName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ReturnedLength
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksum(
    _In_ HANDLE ImageFileHandle,
    _In_opt_ PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine,
    _In_ PVOID ImportCallbackParameter,
    _Out_opt_ PUSHORT ImageCharacteristics
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksumEx(
    _In_ HANDLE ImageFileHandle,
    _Inout_ PLDR_VERIFY_IMAGE_INFO VerifyInfo
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ CONST LDR_RESOURCE_INFO* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DIRECTORY* ResourceDirectory
);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ CONST LDR_RESOURCE_INFO* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry
);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceEx_U(
    _In_opt_ ULONG Flags,
    _In_ PVOID DllHandle,
    _In_ CONST LDR_RESOURCE_INFO* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry
);

NTSYSAPI
VOID
NTAPI
RtlAssert(
    _In_ PVOID VoidFailedAssertion,
    _In_ PVOID VoidFileName,
    _In_ ULONG LineNumber,
    _In_opt_ PSTR MutableMessage
);

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
    _In_ NTSTATUS Status
);

NTSYSAPI
VOID
NTAPI
RtlRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlConnectToSm(
    _In_ PUNICODE_STRING ApiPortName,
    _In_ HANDLE ApiPortHandle,
    _In_ DWORD ProcessImageType,
    _Out_ PHANDLE SmssConnection
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSendMsgToSm(
    _In_ HANDLE ApiPortHandle,
    _In_ PPORT_MESSAGE MessageData
);

NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterThreadWithCsrss(
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
);

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
);

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection
);
#endif

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    _Out_ PRTL_CRITICAL_SECTION CriticalSection
);

NTSYSAPI
VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    _Out_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount
);

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    _Inout_ PRTL_CRITICAL_SECTION CriticalSection
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
BOOL
NTAPI
RtlQueryPerformanceFrequency(
    _Out_ PLARGE_INTEGER Frequency
);
#else
FORCEINLINE
BOOL
NTAPI
RtlQueryPerformanceFrequency(
    _Out_ PLARGE_INTEGER Frequency
)
{
    LARGE_INTEGER _;
    return NT_SUCCESS(NtQueryPerformanceCounter(&_,
                      Frequency));
}
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
BOOL
NTAPI
RtlQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCount
);
#else
FORCEINLINE
BOOL
NTAPI
RtlQueryPerformanceCounter(
    _Out_ PLARGE_INTEGER PerformanceCount
)
{
    return NT_SUCCESS(NtQueryPerformanceCounter(PerformanceCount,
                      NULL));
}
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_ PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_ PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_ PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_ PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize
);

NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_opt_ SIZE_T ReserveSize,
    _In_opt_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters
);

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    _Inout_ PVOID HeapHandle
);

NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _In_ SIZE_T Size
);

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_opt_ ULONG Flags,
    _Inout_opt_ PVOID BaseAddress
);

NTSYSAPI
NTSTATUS
NTAPI
RtlWalkHeap(
    _In_ PVOID HeapHandle,
    _Inout_ PRTL_HEAP_WALK_ENTRY Entry
);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength
);

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress
);

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags
);

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly
);

NTSYSAPI
BOOLEAN
NTAPI
RtlLockHeap(
    _In_ PVOID HeapHandle
);

NTSYSAPI
BOOLEAN
NTAPI
RtlUnlockHeap(
    _In_ PVOID HeapHandle
);

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Inout_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size
);

NTSYSAPI
BOOLEAN
NTAPI
RtlGetUserInfoHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _Out_opt_ PVOID* UserValue,
    _Out_opt_ PULONG UserFlags
);

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserValueHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ PVOID UserValue
);

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserFlagsHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress,
    _In_ ULONG UserFlagsReset,
    _In_ ULONG UserFlagsSet
);

NTSYSAPI
ULONG
NTAPI
RtlCreateTagHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_opt_ PWSTR TagPrefix,
    _In_ PWSTR TagNames
);

NTSYSAPI
PWSTR
NTAPI
RtlQueryTagHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ USHORT TagIndex,
    _In_ BOOLEAN ResetCounters,
    _Out_opt_ PRTL_HEAP_TAG_INFO TagInfo
);

NTSYSAPI
SIZE_T
NTAPI
RtlCompactHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags
);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress
);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateProcessHeaps(
);

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID* ProcessHeaps
);

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter
);

NTSYSAPI
ULONG
NTAPI
RtlUniform(
    _Inout_ PULONG Seed
);

NTSYSAPI
ULONG
NTAPI
RtlRandom(
    _Inout_ PULONG Seed
);

NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
    _Inout_ PULONG Seed
);

NTSYSAPI
NTSTATUS
NTAPI
RtlFindMessage(
    _In_ PVOID DllHandle,
    _In_ ULONG MessageTableId,
    _In_ ULONG MessageLanguageId,
    _In_ ULONG MessageId,
    _Out_ PMESSAGE_RESOURCE_ENTRY* MessageEntry
);

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatMessage(
    _In_ PCWSTR MessageFormat,
    _In_ ULONG MaximumWidth,
    _In_ BOOLEAN IgnoreInserts,
    _In_ BOOLEAN ArgumentsAreAnsi,
    _In_ BOOLEAN ArgumentsAreAnArray,
    _In_ va_list* Arguments,
    _Out_ PWSTR Buffer,
    _In_ ULONG Length,
    _Out_opt_ PULONG ReturnLength
);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    _In_ NTSTATUS Status
);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
);

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status
);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    _In_ LONG Win32Error
);

NTSYSAPI
VOID
NTAPI
RtlRestoreLastWin32Error(
    _In_ LONG Win32Error
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
ULONG
NTAPI
RtlGetThreadErrorMode(
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetThreadErrorMode(
    _In_ ULONG NewMode,
    _Out_opt_ PULONG OldMode
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
);

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PWSTR SourceString
);

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
    _Out_ PANSI_STRING DestinationString,
    _In_opt_ PSTR SourceString
);

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCUNICODE_STRING SourceString
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PCWSTR Source
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    _Inout_ PANSI_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
);

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    _Inout_ PANSI_STRING AnsiString
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
    _Out_ PACL* Dacl
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID* Environment
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
    _In_ PVOID SourceEnv,
    _Out_ PVOID* Environment,
    _In_ ULONG Flags
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    _In_ PVOID Environment
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    _In_ PVOID Environment,
    _Out_opt_ PVOID* PreviousEnvironment
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVar(
    _In_opt_ PWSTR* Environment,
    _In_ PWSTR Name,
    _In_ SIZE_T NameLength,
    _In_ PWSTR Value,
    _In_ SIZE_T ValueLength
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    _In_opt_ PVOID* Environment,
    _In_ PUNICODE_STRING Name,
    _In_ PUNICODE_STRING Value
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable(
    _In_opt_ PVOID Environment,
    _In_ PWSTR Name,
    _In_ SIZE_T NameLength,
    _Out_ PWSTR Value,
    _In_ SIZE_T ValueLength,
    _Out_ PSIZE_T ReturnLength
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Name,
    _Out_ PUNICODE_STRING Value
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_ PWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_ PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Source,
    _Out_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentStrings(
    _In_ PWCHAR NewEnvironment,
    _In_ SIZE_T NewEnvironmentSize
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags // Pass RTL_USER_PROCESS_PARAMETERS_NORMALIZED to keep parameters normalized
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
);

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlNormalizeProcessParams(
    _Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
);

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlDeNormalizeProcessParams(
    _Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG AttributesDeprecated,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE TokenHandle, // used to be ExceptionPort
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_opt_ ULONG ZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T CommittedStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDosApplyFileIsolationRedirection_Ustr(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING OriginalName,
    _In_ PUNICODE_STRING Extension,
    _Inout_ PUNICODE_STRING StaticString,
    _Inout_ PUNICODE_STRING DynamicString,
    _Inout_ PUNICODE_STRING* NewName,
    _In_ PULONG NewFlags,
    _In_ PSIZE_T FileNameSize,
    _In_ PSIZE_T RequiredLength
);

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID ImageBase
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    _In_opt_ ULONG Flags,
    _In_ PVOID Base,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS* OutHeaders
);
#endif

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    _In_ PVOID ImageBase,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size
);

NTSYSAPI
PVOID
NTAPI
RtlPcToFileHeader(
    _In_ PVOID PcValue,
    _Out_ PVOID* BaseOfImage
);

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress
);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva
);

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva,
    _Inout_opt_ PIMAGE_SECTION_HEADER* LastRvaSection
);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessHeapInformation(
    _Inout_ PRTL_DEBUG_INFORMATION Buffer
);

NTSYSAPI
PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
    _In_opt_ ULONG MaximumCommit,
    _In_ BOOLEAN UseEventPair
);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    _In_ HANDLE UniqueProcessId,
    _In_ ULONG Flags,
    _Inout_ PRTL_DEBUG_INFORMATION Buffer
);

#ifdef _WIN64
NTSYSAPI
VOID
WINAPI
RtlRestoreContext(
    _In_ PCONTEXT ContextRecord,
    _In_opt_ PEXCEPTION_RECORD ExceptionRecord
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlAcquirePrivilege(
    _In_ PULONG Privilege,
    _In_ ULONG NumPriv,
    _In_ ULONG Flags,
    _Out_ PVOID* ReturnedState
);

NTSYSAPI
VOID
NTAPI
RtlReleasePrivilege(
    _In_ PVOID StatePointer
);
#endif

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
    _In_ PWSTR FileName,
    _In_ ULONG BufferLength,
    _Out_ PWSTR Buffer,
    _Out_opt_ PWSTR* FilePart
);

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR* FilePart,
    _Reserved_ PVOID Reserved
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToRelativeNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR* FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDosPathNameToRelativeNtPathName_U_WithStatus(
    _In_ PWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR* FilePart,
    _Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
);
#endif

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
    _In_ PCWSTR Path
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlGetFullPathName_UstrEx(
    _In_ PUNICODE_STRING FileName,
    _In_opt_ PUNICODE_STRING StaticString,
    _In_opt_ PUNICODE_STRING DynamicString,
    _Out_opt_ PUNICODE_STRING* StringUsed,
    _Out_opt_ PSIZE_T FilePartSize,
    _Out_opt_ PBOOLEAN NameInvalid,
    _Out_ RTL_PATH_TYPE* PathType,
    _Out_opt_ PSIZE_T LengthNeeded
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentDirectory_U(
    _In_ PUNICODE_STRING PathName
);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
VOID
NTAPI
RtlReleaseRelativeName(
    _In_ PRTL_RELATIVE_NAME_U RelativeName
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
    _In_ ULONG Flags,
    _Inout_ PRTL_UNICODE_STRING_BUFFER Path,
    _Out_opt_ PULONG Disposition,
    _Inout_opt_ PWSTR* FilePart
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock
);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock
);

NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock
);
#endif

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain(
    _Out_ PVOID* Callers,
    _In_ ULONG Count,
    _In_ ULONG Flags
);

NTSYSAPI
PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PANSI_STRING FullName
);

NTSYSAPI
VOID
NTAPI
PfxInitialize(
    _Out_ PPREFIX_TABLE PrefixTable
);

NTSYSAPI
BOOLEAN
NTAPI
PfxInsertPrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PANSI_STRING Prefix,
    _Out_ PPREFIX_TABLE_ENTRY PrefixTableEntry
);

NTSYSAPI
VOID
NTAPI
PfxRemovePrefix(
    _In_ PPREFIX_TABLE PrefixTable,
    _In_ PPREFIX_TABLE_ENTRY PrefixTableEntry
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    _In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Inout_ PULONG BufferLength
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_ PVOID AceList,
    _In_ ULONG AceListLength
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAtomToAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ PWSTR AtomName,
    _Inout_opt_ PRTL_ATOM Atom
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    PUNICODE_STRING Destination,
    PCUNICODE_STRING Source
);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
    _In_ ACCESS_MASK GrantedAccess,
    _In_ ACCESS_MASK DesiredAccess
);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG Length
);

NTSYSAPI
VOID
NTAPI
RtlCaptureContext(
    _Out_ PCONTEXT ContextRecord
);

NTSYSAPI
USHORT
NTAPI
RtlCaptureStackBackTrace(
    _In_ ULONG FramesToSkip,
    _In_ ULONG FramesToCapture,
    _Out_ PVOID* BackTrace,
    _Out_opt_ PULONG BackTraceHash
);

NTSYSAPI
VOID
NTAPI
RtlClearAllBits(
    _In_ PRTL_BITMAP BitMapHeader
);

NTSYSAPI
VOID
NTAPI
RtlClearBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG NumberToClear
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSystemVolumeInformationFolder(
    _In_ PCUNICODE_STRING VolumeRootPath
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
    _In_ PCUNICODE_STRING Altitude1,
    _In_ PCUNICODE_STRING Altitude2
);
#endif

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
);

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length
);

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    _Inout_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString
);

NTSYSAPI
VOID
NTAPI
RtlCopyLuid(
    _Out_ PLUID DestinationLuid,
    _In_ PLUID SourceLuid
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _Out_ PSID DestinationSid,
    _In_ PSID SourceSid
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    _Out_ PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAtomTable(
    _In_ ULONG NumberOfBuckets,
    _Out_ PVOID* AtomTableHandle
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragment(
    _In_ USHORT CompressionFormat,
    _Out_ PUCHAR UncompressedFragment,
    _In_ ULONG UncompressedFragmentSize,
    _In_ PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG FragmentOffset,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace
);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlDelete(
    _In_ PRTL_SPLAY_LINKS Links
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAtomFromAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom
);

NTSYSAPI
VOID
NTAPI
RtlDeleteNoSplay(
    _In_ PRTL_SPLAY_LINKS Links,
    _Inout_ PRTL_SPLAY_LINKS* Root
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString
);

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    _In_ ULONG Flags,
    _In_ UNICODE_STRING* StringIn,
    _Out_ UNICODE_STRING* StringOut
);

NTSYSAPI
NTSTATUS
NTAPI
RtlEmptyAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ BOOLEAN IncludePinnedAtoms
);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2
);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
    _In_ PANSI_STRING String1,
    _In_ PANSI_STRING String2,
    _In_ BOOLEAN CaseInSensitive
);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive
);

NTSYSAPI
ULONG
NTAPI
RtlFindClearBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
);

NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
);

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns(
    _In_ PRTL_BITMAP BitMapHeader,
    _Out_ PRTL_BITMAP_RUN RunArray,
    _In_ ULONG SizeOfRunArray,
    _In_ BOOLEAN LocateLongestRuns
);

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG FromIndex,
    _In_ PULONG StartingRunIndex
);

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit(
    _In_ ULONGLONG Set
);

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ PULONG StartingIndex
);

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit(
    _In_ ULONGLONG Set
);

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG FromIndex,
    _In_ PULONG StartingRunIndex
);

NTSYSAPI
ULONG
NTAPI
RtlFindSetBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
);

NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG NumberToFind,
    _In_ ULONG HintIndex
);

NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    _Out_ PVOID* CallersAddress,
    _Out_ PVOID* CallersCaller
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Out_ PACL* Dacl,
    _Out_ PBOOLEAN DaclDefaulted
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID* Group,
    _Out_ PBOOLEAN GroupDefaulted
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID* Owner,
    _Out_ PBOOLEAN OwnerDefaulted
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL* Sacl,
    _Out_ PBOOLEAN SaclDefaulted
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSetBootStatusData(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Get,
    _In_ RTL_BSD_ITEM_TYPE DataItem,
    _In_ PVOID DataBuffer,
    _In_ ULONG DataBufferLength,
    _Out_opt_ PULONG ByteRead
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateBootStatusDataFile(
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    _Out_ PRTL_OSVERSIONINFOW lpVersionInformation
);

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    _In_ PUNICODE_STRING GuidString,
    _Out_ GUID* Guid
);

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    _In_ UNICODE_STRING* String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue
);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount
);

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount
);

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
);

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
    _In_ PSID Sid
);

NTSYSAPI
NTSTATUS
NTAPI
RtlLockBootStatusData(
    _Out_ PHANDLE BootStatusDataHandle
);

NTSYSAPI
NTSTATUS
NTAPI
RtlLookupAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ PWSTR AtomName,
    _Out_opt_ PRTL_ATOM Atom
);

NTSYSAPI
NTSTATUS
NTAPI
RtlMapSecurityErrorToNtStatus(
    _In_ SECURITY_STATUS Error
);

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
    _Out_ PWCH UnicodeString,
    _In_ ULONG MaxBytesInUnicodeString,
    _Out_opt_ PULONG BytesInUnicodeString,
    _In_ PCSTR MultiByteString,
    _In_ ULONG BytesInMultiByteString
);

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
    _Out_ PULONG BytesInUnicodeString,
    _In_ PCSTR MultiByteString,
    _In_ ULONG BytesInMultiByteString
);

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits(
    _In_ PRTL_BITMAP BitMapHeader
);

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits(
    _In_ PRTL_BITMAP BitMapHeader
);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAtomInAtomTable(
    _In_ PVOID AtomTableHandle,
    _In_ RTL_ATOM Atom,
    _Out_opt_ PULONG AtomUsage,
    _Out_opt_ PULONG AtomFlags,
    _Inout_opt_ PWSTR AtomName,
    _Inout_opt_ PULONG AtomNameLength
);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor(
    _In_ PRTL_SPLAY_LINKS Links
);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor(
    _In_ PRTL_SPLAY_LINKS Links
);

NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
    _In_ UCHAR Seed,
    _Inout_ PUNICODE_STRING String
);

NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
    _In_opt_ PUCHAR Seed,
    _Inout_ PUNICODE_STRING String
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
    _In_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    _Inout_ PULONG AbsoluteSecurityDescriptorSize,
    _Out_ PACL Dacl,
    _Inout_ PULONG DaclSize,
    _Out_ PACL Sacl,
    _Inout_ PULONG SaclSize,
    _Out_opt_ PSID Owner,
    _Inout_ PULONG OwnerSize,
    _Out_opt_ PSID PrimaryGroup,
    _Inout_ PULONG PrimaryGroupSize
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD2(
    _Inout_ PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    _Inout_ PULONG pBufferSize
);

NTSYSAPI
VOID
NTAPI
RtlSetAllBits(
    _In_ PRTL_BITMAP BitMapHeader
);

NTSYSAPI
VOID
NTAPI
RtlSetBits(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG StartingIndex,
    _In_ ULONG NumberToSet
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN DaclPresent,
    _In_opt_ PACL Dacl,
    _In_ BOOLEAN DaclDefaulted
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID Group,
    _In_opt_ BOOLEAN GroupDefaulted
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
    _Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted
);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN SaclPresent,
    _In_opt_ PACL Sacl,
    _In_opt_ BOOLEAN SaclDefaulted
);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSplay(
    _Inout_ PRTL_SPLAY_LINKS Links
);

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    _In_ REFGUID Guid,
    _Out_ PUNICODE_STRING GuidString
);

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
    _In_ PSID Sid
);

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority
);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor(
    _In_ PRTL_SPLAY_LINKS Links
);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor(
    _In_ PRTL_SPLAY_LINKS Links
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
BOOLEAN
NTAPI
RtlTestBit(
    _In_ PRTL_BITMAP BitMapHeader,
    _In_ ULONG BitNumber
);
#endif

NTSYSAPI
VOID
NTAPI
RtlUnlockBootStatusData(
    _In_ HANDLE BootStatusDataHandle
);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    _Out_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision
);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    _In_ ULONG SecurityDescriptorLength,
    _In_ SECURITY_INFORMATION RequiredInformation
);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor
);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
    _In_ PSID Sid
);

NTSYSAPI
NTSTATUS
NTAPI
RtlVerifyVersionInfo(
    _In_ RTL_OSVERSIONINFOEXW VersionInfo,
    _In_ ULONG TypeMask,
    _In_ ULONGLONG ConditionMask
);

NTSYSAPI
ULONGLONG
NTAPI
VerSetConditionMask(
    _In_ ULONGLONG ConditionMask,
    _In_ ULONG TypeMask,
    _In_ UCHAR Condition
);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
TpAllocPool(
    _Out_ PTP_POOL* PoolReturn,
    _Reserved_ PVOID Reserved
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpDisablePoolCallbackChecks(
    _Inout_ PTP_POOL Pool
);
#endif

NTSYSAPI
VOID
NTAPI
TpReleasePool(
    _Inout_ PTP_POOL Pool
);

NTSYSAPI
VOID
NTAPI
TpSetPoolMaxThreads(
    _Inout_ PTP_POOL Pool,
    _In_ LONG MaxThreads
);

NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolMinThreads(
    _Inout_ PTP_POOL Pool,
    _In_ LONG MinThreads
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpQueryPoolStackInformation(
    _In_ PTP_POOL Pool,
    _Out_ PTP_POOL_STACK_INFORMATION PoolStackInformation
);

NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolStackInformation(
    _Inout_ PTP_POOL Pool,
    _In_ PTP_POOL_STACK_INFORMATION PoolStackInformation
);
#endif

NTSYSAPI
NTSTATUS
NTAPI
TpAllocCleanupGroup(
    _Out_ PTP_CLEANUP_GROUP* CleanupGroupReturn
);

NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroup(
    _Inout_ PTP_CLEANUP_GROUP CleanupGroup
);

NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroupMembers(
    _Inout_ PTP_CLEANUP_GROUP CleanupGroup,
    _In_ LOGICAL CancelPendingCallbacks,
    _Inout_opt_ PVOID CleanupParameter
);

NTSYSAPI
NTSTATUS
NTAPI
TpSimpleTryPost(
    _In_ PTP_SIMPLE_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocWork(
    _Out_ PTP_WORK* WorkReturn,
    _In_ PTP_WORK_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
);

NTSYSAPI
VOID
NTAPI
TpReleaseWork(
    _Inout_ PTP_WORK Work
);

NTSYSAPI
VOID
NTAPI
TpPostWork(
    _Inout_ PTP_WORK Work
);

NTSYSAPI
VOID
NTAPI
TpWaitForWork(
    _Inout_ PTP_WORK Work,
    _In_ LOGICAL CancelPendingCallbacks
);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocTimer(
    _Out_ PTP_TIMER* Timer,
    _In_ PTP_TIMER_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
);

NTSYSAPI
VOID
NTAPI
TpReleaseTimer(
    _Inout_ PTP_TIMER Timer
);

NTSYSAPI
VOID
NTAPI
TpSetTimer(
    _Inout_ PTP_TIMER Timer,
    _In_opt_ PLARGE_INTEGER DueTime,
    _In_ LONG Period,
    _In_opt_ LONG WindowLength
);

NTSYSAPI
LOGICAL
NTAPI
TpIsTimerSet(
    _In_ PTP_TIMER Timer
);

NTSYSAPI
VOID
NTAPI
TpWaitForTimer(
    _Inout_ PTP_TIMER Timer,
    _In_ LOGICAL CancelPendingCallbacks
);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocWait(
    _Out_ PTP_WAIT* WaitReturn,
    _In_ PTP_WAIT_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
);

NTSYSAPI
VOID
NTAPI
TpReleaseWait(
    _Inout_ PTP_WAIT Wait
);

NTSYSAPI
VOID
NTAPI
TpSetWait(
    _Inout_ PTP_WAIT Wait,
    _In_opt_ HANDLE Handle,
    _In_opt_ PLARGE_INTEGER Timeout
);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocIoCompletion(
    _Out_ PTP_IO* IoReturn,
    _In_ HANDLE File,
    _In_ PTP_IO_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
);

NTSYSAPI
VOID
NTAPI
TpWaitForIoCompletion(
    _Inout_ PTP_IO Io,
    _In_ LOGICAL CancelPendingCallbacks
);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletion(
    _Out_ PTP_ALPC* AlpcReturn,
    _In_ HANDLE AlpcPort,
    _In_ PTP_ALPC_CALLBACK Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletionEx(
    _Out_ PTP_ALPC* AlpcReturn,
    _In_ HANDLE AlpcPort,
    _In_ PTP_ALPC_CALLBACK_EX Callback,
    _Inout_opt_ PVOID Context,
    _In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
);
#endif

NTSYSAPI
VOID
NTAPI
TpReleaseAlpcCompletion(
    _Inout_ PTP_ALPC Alpc
);

NTSYSAPI
VOID
NTAPI
TpWaitForAlpcCompletion(
    _Inout_ PTP_ALPC Alpc
);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpAlpcRegisterCompletionList(
    _Inout_ PTP_ALPC Alpc
);

NTSYSAPI
NTSTATUS
NTAPI
TpAlpcUnregisterCompletionList(
    _Inout_ PTP_ALPC Alpc
);
#endif

#ifdef __cplusplus
};
#endif

#endif // _NTDLL_H



================================================
File: TitanEngine/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by TitanEngine.rc
//
#define ID_MANIFEST_RESOURCE            1
#define IDD_UNPACKERTITLE               101
#define IDD_MAINWINDOW                  103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDI_MYUNPACKER                  107
#define IDI_SMALL                       108
#define IDC_MYUNPACKER                  109
#define IDI_ICON2                       113
#define IDR_MAINFRAME                   128
#define IDB_BITMAP1                     130
#define IDB_BITMAP2                     131
#define IDI_ICON1                       132
#define IDC_REALING                     700
#define IDC_UNPACK                      701
#define IDC_BROWSE                      702
#define IDC_ABOUT                       703
#define IDC_EXIT                        704
#define IDC_FILENAME                    705
#define IDC_COPYOVERLAY                 706
#define IDC_LISTBOX                     800

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif



================================================
File: TitanEngine/scylla_wrapper.h
================================================
#include "stdafx.h"

/* Scylla definitions */
const BYTE SCY_ERROR_SUCCESS = 0;
const BYTE SCY_ERROR_PROCOPEN = -1;
const BYTE SCY_ERROR_IATWRITE = -2;
const BYTE SCY_ERROR_IATSEARCH = -3;
const BYTE SCY_ERROR_IATNOTFOUND = -4;

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/
//iat exports
int scylla_searchIAT(DWORD pid, DWORD_PTR & iatStart, DWORD & iatSize, DWORD_PTR searchStart, bool advancedSearch);
int scylla_getImports(DWORD_PTR iatAddr, DWORD iatSize, DWORD pid, LPVOID invalidImportCallback = NULL);
bool scylla_addModule(const WCHAR* moduleName, DWORD_PTR firstThunkRVA);
bool scylla_addImport(const WCHAR* importName, DWORD_PTR thunkVA);
bool scylla_importsValid();
bool scylla_cutImport(DWORD_PTR apiAddr);
int scylla_fixDump(WCHAR* dumpFile, WCHAR* iatFixFile, WCHAR* sectionName = L".scy");
int scylla_fixMappedDump(DWORD_PTR iatVA, DWORD_PTR FileMapVA, HANDLE hFileMap);
int scylla_getModuleCount();
int scylla_getImportCount();
void scylla_enumImportTree(LPVOID enumCallBack);
long scylla_estimatedIATSize();
DWORD_PTR scylla_findImportWriteLocation(char* importName);
DWORD_PTR scylla_findOrdinalImportWriteLocation(DWORD_PTR ordinalNumber);
DWORD_PTR scylla_findImportNameByWriteLocation(DWORD_PTR thunkVA);
DWORD_PTR scylla_findModuleNameByWriteLocation(DWORD_PTR thunkVA);

//dumper exports
bool scylla_dumpProcessW(DWORD_PTR pid, const WCHAR* fileToDump, DWORD_PTR imagebase, DWORD_PTR entrypoint, const WCHAR* fileResult);
bool scylla_dumpProcessA(DWORD_PTR pid, const char* fileToDump, DWORD_PTR imagebase, DWORD_PTR entrypoint, const char* fileResult);

//rebuilder exports
bool scylla_rebuildFileW(const WCHAR* fileToRebuild, BOOL removeDosStub, BOOL updatePeHeaderChecksum, BOOL createBackup);
bool scylla_rebuildFileA(const char* fileToRebuild, BOOL removeDosStub, BOOL updatePeHeaderChecksum, BOOL createBackup);
#ifdef __cplusplus
}
#endif /*__cplusplus*/

/* Scylla definitions */



================================================
File: TitanEngine/stdafx.cpp
================================================
#include "stdafx.h"



================================================
File: TitanEngine/stdafx.h
================================================
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include "targetver.h"

// Build switches
//#define TITANENGINE_BUILD_ASM_LIB

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers

// Allow including Windows.h without bringing in a redefined and outdated subset of NTSTATUSes.
// To get NTSTATUS defines, #undef WIN32_NO_STATUS after Windows.h and then #include <ntstatus.h>
#define WIN32_NO_STATUS

// Windows Header Files:
#include <windows.h>

#include <imagehlp.h>
#include <wincrypt.h>
#include <psapi.h>
#include <commdlg.h>
#include <shellapi.h>
#include <tlhelp32.h>


//stl/crt
#include <vector>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>

#ifndef _Out_writes_opt_
#define _Out_writes_opt_(x)
#endif

#ifndef _In_reads_
#define _In_reads_(x)
#endif

#ifndef _Inout_updates_bytes_
#define _Inout_updates_bytes_(x)
#endif

#ifndef _Out_writes_bytes_opt_
#define _Out_writes_bytes_opt_(X)
#endif

//#include <winternl.h>
#include "ntdll.h"
#include "aplib.h"
#include "LzmaDec.h"

#include "Global.Helper.h"

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) // ntsubauth

// Engine.Internal:
#define TITANENGINE_PAGESIZE (0x1000)
#define MAX_IMPORT_ALLOC (256 * 256)
#define MAX_RELOC_ALLOC (1024 * 1024)
#define UE_MAX_RESERVED_MEMORY_LEFT (32)
#define MAXIMUM_SECTION_NUMBER (32)
#define MAX_DECODE_INSTRUCTIONS (32)
#define MAX_INSTRUCTIONS (1000)
#define MAXIMUM_BREAKPOINTS (1000)
#define MAXIMUM_INSTRUCTION_SIZE (16) //maximum instruction size == 16
#define MAX_RET_SEARCH_INSTRUCTIONS (100)

#define UE_TRAP_FLAG (0x100)
#define UE_RESUME_FLAG (0x10000)

#define UE_OPTION_IMPORTER_REALIGN_LOCAL_APIADDRESS 0
#define UE_OPTION_IMPORTER_REALIGN_APIADDRESS 1
#define UE_OPTION_IMPORTER_RETURN_APINAME 2 //no kernelbase
#define UE_OPTION_IMPORTER_RETURN_APIADDRESS 3
#define UE_OPTION_IMPORTER_RETURN_DLLNAME 4 //no kernelbase
#define UE_OPTION_IMPORTER_RETURN_DLLINDEX 5
#define UE_OPTION_IMPORTER_RETURN_DLLBASE 6
#define UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLNAME 7
#define UE_OPTION_IMPORTER_RETURN_FORWARDER_DLLINDEX 8
#define UE_OPTION_IMPORTER_RETURN_FORWARDER_APINAME 9
#define UE_OPTION_IMPORTER_RETURN_FORWARDER_API_ORDINAL_NUMBER 10
#define UE_OPTION_IMPORTER_RETURN_NEAREST_APIADDRESS 11
#define UE_OPTION_IMPORTER_RETURN_NEAREST_APINAME 12
#define UE_OPTION_IMPORTER_RETURN_API_ORDINAL_NUMBER 13

#pragma pack(push)
#pragma pack(1)

//EngineCheckStructAlignment
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
	YmmRegister_t Low; //AVX part
	YmmRegister_t High; //AVX-512 part
} ZmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

typedef struct
{
#ifdef _WIN64
	ZmmRegister_t ZmmRegisters[32];
#else // x86
	ZmmRegister_t ZmmRegisters[8];
#endif
	ULONGLONG Opmask[8];
} TITAN_ENGINE_CONTEXT_AVX512_t;

typedef struct
{
    ULONG_PTR BreakPointAddress;
    ULONG_PTR Parameter1;
    ULONG_PTR Parameter2;
    int SnapShotNumber;
    bool SingleBreak;
} UnpackerInformation, *PUnpackerInformation;

typedef struct
{
    bool ExpertModeActive;
    wchar_t* szFileName;
    bool ReserveModuleBase;
    wchar_t* szCommandLine;
    wchar_t* szCurrentFolder;
    LPVOID EntryCallBack;
} ExpertDebug, *PExpertDebug;

typedef struct
{
    ULONG_PTR fLoadLibrary;
    ULONG_PTR fFreeLibrary;
    ULONG_PTR fGetModuleHandle;
    ULONG_PTR fGetProcAddress;
    ULONG_PTR fVirtualFree;
    ULONG_PTR fExitProcess;
    HMODULE fFreeLibraryHandle;
    DWORD fExitProcessCode;
} InjectCodeData, *PInjectCodeData;

typedef struct
{
    ULONG_PTR fTrace;
    ULONG_PTR fCreateFileA;
    ULONG_PTR fCloseHandle;
    ULONG_PTR fCreateFileMappingA;
    ULONG_PTR AddressToTrace;
} InjectImpRecCodeData, *PInjectImpRecCodeData;

#define UE_MAX_BREAKPOINT_SIZE 2
#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

typedef struct
{
    BYTE BreakPointActive;
    ULONG_PTR BreakPointAddress;
    SIZE_T BreakPointSize;
    BYTE OriginalByte[UE_MAX_BREAKPOINT_SIZE];
    int BreakPointType;
    int AdvancedBreakPointType;
    int MemoryBpxRestoreOnHit;
    ULONG_PTR ExecuteCallBack;
} BreakPointDetail, *PBreakPointDetail;

typedef struct
{
    // Numbers of active BPs the page contains for each type
    uint16_t accessBps, readBps, writeBps, executeBps;

    DWORD origProtect;  // original protection before any BPs were applied
    DWORD newProtect;   // current protection including all enabled BPs
} MemoryBreakpointPageDetail;

typedef struct
{
    ULONG_PTR DrxBreakAddress;
    ULONG_PTR DrxCallBack;
    DWORD DrxBreakPointType;
    DWORD DrxBreakPointSize;
    bool DrxEnabled;
    bool DrxExecution;
} HARDWARE_DATA, *PHARDWARE_DATA;

enum HWBP_MODE
{
    MODE_DISABLED = 0, //00
    MODE_LOCAL = 1, //01
    MODE_GLOBAL = 2 //10
};

enum HWBP_TYPE
{
    TYPE_EXECUTE = 0, //00
    TYPE_WRITE = 1, //01
    TYPE_READWRITE = 3 //11
};

enum HWBP_SIZE
{
    SIZE_1 = 0, //00
    SIZE_2 = 1, //01
    SIZE_8 = 2, //10
    SIZE_4 = 3 //11
};

struct DR7
{
    BYTE HWBP_MODE[4];
    BYTE HWBP_TYPE[4];
    BYTE HWBP_SIZE[4];
};

#define BITSET(a,x) (a|=1<<x)
#define BITCLEAR(a,x) (a&=~(1<<x))
#define BITTOGGLE(a,x) (a^=1<<x)
#define BITGET(a,x) (a&(1<<x))

typedef struct
{
    ULONG_PTR chBreakPoint;
    ULONG_PTR chSingleStep;
    ULONG_PTR chAccessViolation;
    ULONG_PTR chIllegalInstruction;
    ULONG_PTR chNonContinuableException;
    ULONG_PTR chArrayBoundsException;
    ULONG_PTR chFloatDenormalOperand;
    ULONG_PTR chFloatDevideByZero;
    ULONG_PTR chIntegerDevideByZero;
    ULONG_PTR chIntegerOverflow;
    ULONG_PTR chPrivilegedInstruction;
    ULONG_PTR chPageGuard;
    ULONG_PTR chEverythingElse;
    ULONG_PTR chCreateThread;
    ULONG_PTR chExitThread;
    ULONG_PTR chCreateProcess;
    ULONG_PTR chExitProcess;
    ULONG_PTR chLoadDll;
    ULONG_PTR chUnloadDll;
    ULONG_PTR chOutputDebugString;
    ULONG_PTR chAfterException;
    ULONG_PTR chSystemBreakpoint;
    ULONG_PTR chUnhandledException;
    ULONG_PTR chRipEvent;
    ULONG_PTR chDebugEvent;
} CustomHandler, *PCustomHandler;

typedef struct
{
    DWORD OrdinalBase;
    DWORD NumberOfExportFunctions;
    char FileName[512];
} EXPORT_DATA, *PEXPORT_DATA;

typedef struct
{
    DWORD ExportedItem;
} EXPORTED_DATA, *PEXPORTED_DATA;

typedef struct
{
    WORD OrdinalNumber;
} EXPORTED_DATA_WORD, *PEXPORTED_DATA_WORD;

typedef struct
{
    BYTE DataByte[50];
} MEMORY_CMP_HANDLER, *PMEMORY_CMP_HANDLER;

typedef struct
{
    BYTE DataByte;
} MEMORY_CMP_BYTE_HANDLER, *PMEMORY_CMP_BYTE_HANDLER;

typedef struct MEMORY_COMPARE_HANDLER
{
    union
    {
        BYTE bArrayEntry[1];
        WORD wArrayEntry[1];
        DWORD dwArrayEntry[1];
        DWORD64 qwArrayEntry[1];
    } Array;
} MEMORY_COMPARE_HANDLER, *PMEMORY_COMPARE_HANDLER;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

typedef struct
{
    char szLibraryName[128];
    void* bpxCallBack;
    bool bpxSingleShoot;
    int bpxType;
} LIBRARY_BREAK_DATA, *PLIBRARY_BREAK_DATA;

#define TEE_MAXIMUM_HOOK_SIZE 14
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5
#define TEE_MAXIMUM_HOOK_RELOCS 7

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

// Engine.External:
#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9
#define UE_ENGINE_SAFE_ATTACH 10
#define UE_ENGINE_MEMBP_ALT 11
#define UE_ENGINE_DISABLE_ASLR 12
#define UE_ENGINE_SAFE_STEP 13

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4
#define UE_OPTION_HANDLER_RETURN_TYPENAME_UNICODE 5

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#ifdef _WIN64
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct
{
    void* AllocatedSection;
    DWORD SectionVirtualOffset;
    DWORD SectionVirtualSize;
    DWORD SectionAttributes;
    DWORD SectionDataHash;
    bool AccessedAlready;
    bool WriteCheckMode;
} TracerSectionData, *PTracerSectionData;

typedef struct
{
    int SectionNumber;
    TracerSectionData SectionData[MAXIMUM_SECTION_NUMBER];
    int OriginalEntryPointNum;
    ULONG_PTR OriginalImageBase;
    ULONG_PTR OriginalEntryPoint;
    ULONG_PTR LoadedImageBase;
    ULONG_PTR SizeOfImage;
    ULONG_PTR CurrentIntructionPointer;
    ULONG_PTR MemoryAccessedFrom;
    ULONG_PTR MemoryAccessed;
    ULONG_PTR AccessType;
    void* InitCallBack;
    void* EPCallBack;
    bool FileIsDLL;
    bool FileIs64bit;
} GenericOEPTracerData, *PGenericOEPTracerData;

// UnpackEngine.Handler:


/*typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType,
    NonPagedPoolSession,
    PagedPoolSession,
    NonPagedPoolMustSucceedSession,
    DontUseThisTypeSession,
    NonPagedPoolCacheAlignedSession,
    PagedPoolCacheAlignedSession,
    NonPagedPoolCacheAlignedMustSSession
} POOL_TYPE;*/

typedef struct
{
    ULONG ProcessId;
    UCHAR ObjectTypeNumber;
    UCHAR Flags; // 0x01 = PROTECT_FROM_CLOSE, 0x02 = INHERIT
    USHORT hHandle;
    PVOID Object;
    ACCESS_MASK GrantedAccess;
} NTDLL_QUERY_HANDLE_INFO, *PNTDLL_QUERY_HANDLE_INFO;



typedef void (*PPEBLOCKROUTINE)(
    PVOID PebLock
);

/*typedef struct _PEB_LDR_DATA {
  ULONG                   Length;
  BOOLEAN                 Initialized;
  PVOID                   SsHandle;
  LIST_ENTRY              InLoadOrderModuleList;
  LIST_ENTRY              InMemoryOrderModuleList;
  LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;*/

/*typedef struct _RTL_DRIVE_LETTER_CURDIR {
  USHORT                  Flags;
  USHORT                  Length;
  ULONG                   TimeStamp;
  UNICODE_STRING          DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
  ULONG                   MaximumLength;
  ULONG                   Length;
  ULONG                   Flags;
  ULONG                   DebugFlags;
  PVOID                   ConsoleHandle;
  ULONG                   ConsoleFlags;
  HANDLE                  StdInputHandle;
  HANDLE                  StdOutputHandle;
  HANDLE                  StdErrorHandle;
  UNICODE_STRING          CurrentDirectoryPath;
  HANDLE                  CurrentDirectoryHandle;
  UNICODE_STRING          DllPath;
  UNICODE_STRING          ImagePathName;
  UNICODE_STRING          CommandLine;
  PVOID                   Environment;
  ULONG                   StartingPositionLeft;
  ULONG                   StartingPositionTop;
  ULONG                   Width;
  ULONG                   Height;
  ULONG                   CharWidth;
  ULONG                   CharHeight;
  ULONG                   ConsoleTextAttributes;
  ULONG                   WindowFlags;
  ULONG                   ShowWindowFlags;
  UNICODE_STRING          WindowTitle;
  UNICODE_STRING          DesktopName;
  UNICODE_STRING          ShellInfo;
  UNICODE_STRING          RuntimeData;
  RTL_DRIVE_LETTER_CURDIR DLCurrentDirectory[0x20];
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;*/



///////////////////////////////////////////////////////////////////////////////////////
//Evolution of Process Environment Block (PEB) http://blog.rewolf.pl/blog/?p=573
//March 2, 2013 / ReWolf posted in programming, reverse engineering, source code, x64 /

template <class T>
struct LIST_ENTRY_T
{
    T Flink;
    T Blink;
};

template <class T>
struct UNICODE_STRING_T
{
    union
    {
        struct
        {
            WORD Length;
            WORD MaximumLength;
        };
        T dummy;
    };
    T _Buffer;
};

template <class T, class NGF, int A>
struct _PEB_T
{
    union
    {
        struct
        {
            BYTE InheritedAddressSpace;
            BYTE ReadImageFileExecOptions;
            BYTE BeingDebugged;
            BYTE _SYSTEM_DEPENDENT_01;
        };
        T dummy01;
    };
    T Mutant;
    T ImageBaseAddress;
    T Ldr;
    T ProcessParameters;
    T SubSystemData;
    T ProcessHeap;
    T FastPebLock;
    T _SYSTEM_DEPENDENT_02;
    T _SYSTEM_DEPENDENT_03;
    T _SYSTEM_DEPENDENT_04;
    union
    {
        T KernelCallbackTable;
        T UserSharedInfoPtr;
    };
    DWORD SystemReserved;
    DWORD _SYSTEM_DEPENDENT_05;
    T _SYSTEM_DEPENDENT_06;
    T TlsExpansionCounter;
    T TlsBitmap;
    DWORD TlsBitmapBits[2];
    T ReadOnlySharedMemoryBase;
    T _SYSTEM_DEPENDENT_07;
    T ReadOnlyStaticServerData;
    T AnsiCodePageData;
    T OemCodePageData;
    T UnicodeCaseTableData;
    DWORD NumberOfProcessors;
    union
    {
        DWORD NtGlobalFlag;
        NGF dummy02;
    };
    LARGE_INTEGER CriticalSectionTimeout;
    T HeapSegmentReserve;
    T HeapSegmentCommit;
    T HeapDeCommitTotalFreeThreshold;
    T HeapDeCommitFreeBlockThreshold;
    DWORD NumberOfHeaps;
    DWORD MaximumNumberOfHeaps;
    T ProcessHeaps;

    //FULL PEB not needed
    T GdiSharedHandleTable;
    T ProcessStarterHelper;
    DWORD GdiDCAttributeList;
    T LoaderLock;
    DWORD OSMajorVersion;
    DWORD OSMinorVersion;
    WORD OSBuildNumber;
    WORD OSCSDVersion;
    DWORD OSPlatformId;
    DWORD ImageSubsystem;
    DWORD ImageSubsystemMajorVersion;
    T ImageSubsystemMinorVersion;
    union
    {
        T ImageProcessAffinityMask;
        T ActiveProcessAffinityMask;
    };
    T GdiHandleBuffer[A];
    T PostProcessInitRoutine;
    T TlsExpansionBitmap;
    DWORD TlsExpansionBitmapBits[32];
    T SessionId;
    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    T pShimData;
    T AppCompatInfo;
    UNICODE_STRING_T<T> CSDVersion;
    T ActivationContextData;
    T ProcessAssemblyStorageMap;
    T SystemDefaultActivationContextData;
    T SystemAssemblyStorageMap;
    T MinimumStackCommit;
};

typedef _PEB_T<DWORD, DWORD64, 34> PEB32;
typedef _PEB_T<DWORD64, DWORD, 30> PEB64;

#ifdef _WIN64
typedef PEB64 PEB_CURRENT;
#else
typedef PEB32 PEB_CURRENT;
#endif

//GetThreadContext:
// - The handle must have THREAD_GET_CONTEXT access to the thread.
// - WOW64: The handle must also have THREAD_QUERY_INFORMATION access.
//SetThreadContext:
// - The handle must have the THREAD_SET_CONTEXT access right to the thread.
//SuspendThread/ResumeThread:
// - The handle must have the THREAD_SUSPEND_RESUME access right.
#define THREAD_GETSETSUSPEND (THREAD_SUSPEND_RESUME | THREAD_SET_CONTEXT | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION)

#pragma pack(pop)



================================================
File: TitanEngine/targetver.h
================================================
#pragma once

// The following macros define the minimum required platform.  The minimum required platform
// is the earliest version of Windows, Internet Explorer etc. that has the necessary features to run
// your application.  The macros work by enabling all features available on platform versions up to and
// including the version specified.

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER                          // Specifies that the minimum required platform is Windows Vista.
#define WINVER 0x0600           // Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT            // Specifies that the minimum required platform is Windows Vista.
#define _WIN32_WINNT 0x0600     // Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINDOWS          // Specifies that the minimum required platform is Windows 98.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE                       // Specifies that the minimum required platform is Internet Explorer 7.0.
#define _WIN32_IE 0x0700        // Change this to the appropriate value to target other versions of IE.
#endif



================================================
File: TitanEngineLoaders/LibraryLoader/LibraryLoader.cpp
================================================
#include <windows.h>

wchar_t szLibraryPath[512];

int main()
{
    memset(szLibraryPath, 0, sizeof(szLibraryPath));
    wchar_t szName[256] = L"";
    wsprintfW(szName, L"Local\\szLibraryName%X", (unsigned int)GetCurrentProcessId());
    HANDLE hMapFile = OpenFileMappingW(FILE_MAP_READ, false, szName);
    if(hMapFile)
    {
        const wchar_t* szLibraryPathMapping = (const wchar_t*)MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, sizeof(szLibraryPath));
        if(szLibraryPathMapping)
        {
            lstrcpyW(szLibraryPath, szLibraryPathMapping);
            UnmapViewOfFile(szLibraryPathMapping);
        }
        CloseHandle(hMapFile);
    }
    if(szLibraryPath[0])
        return (LoadLibraryW(szLibraryPath) != NULL);
    return 0;
}



================================================
File: TitanEngineLoaders/LibraryLoader/LibraryLoader.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibraryLoader", "LibraryLoader.vcxproj", "{92C90AAD-036E-474D-902C-CFD1E7422899}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|Win32.ActiveCfg = Release|Win32
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|Win32.Build.0 = Release|Win32
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|x64.ActiveCfg = Release|x64
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: TitanEngineLoaders/LibraryLoader/LibraryLoader.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="LibraryLoader.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{92C90AAD-036E-474D-902C-CFD1E7422899}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>LibraryLoader</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v100</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v100</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v100</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v100</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(ProjectDir)x32\</OutDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(ProjectName)</TargetName>
    <OutDir>$(ProjectDir)x64\</OutDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)ntdll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StructMemberAlignment>1Byte</StructMemberAlignment>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)ntdll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>1Byte</StructMemberAlignment>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalLibraryDirectories>$(SolutionDir)ntdll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>1Byte</StructMemberAlignment>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(SolutionDir)ntdll;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: TitanEngineLoaders/LibraryLoader/LibraryLoader.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="LibraryLoader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>




================================================
File: hooks/README.md
================================================
# hooks

This contains two binaries `AStyleHelper.exe` and `AStyle.dll` to format any code before you commit.

If you are unsure about the integrity of the files, don't hesitate to contact me (mrexodia). The source code is available [here](https://github.com/mrexodia/AStyleHelper). The version of `AStyle.dll` is compiled from `AStyle_2.06_windows.zip` which came from [Sourceforge](https://sourceforge.net/projects/astyle/files/astyle/astyle%202.06/AStyle_2.06_windows.zip/download).


================================================
File: hooks/AStyleHelper.exe.config
================================================
<?xml version="1.0"?>
<configuration>
<configSections>
    <sectionGroup name="applicationSettings" type="System.Configuration.ApplicationSettingsGroup, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" >
        <section name="AStyleHelper.Properties.Settings" type="System.Configuration.ClientSettingsSection, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
    </sectionGroup>
</configSections>
<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/></startup>
    <applicationSettings>
        <AStyleHelper.Properties.Settings>
            <setting name="Pattern" serializeAs="String">
                <value>*.c;*.h;*.cpp;*.hpp</value>
            </setting>
            <setting name="Options" serializeAs="String">
                <value>style=allman, convert-tabs, align-pointer=type, align-reference=middle, indent=spaces, indent-col1-comments, pad-oper, unpad-paren, keep-one-line-blocks, close-templates</value>
            </setting>
            <setting name="Ignore" serializeAs="String">
                <value />
            </setting>
            <setting name="License" serializeAs="String">
                <value />
            </setting>
        </AStyleHelper.Properties.Settings>
    </applicationSettings>
</configuration>



================================================
File: hooks/pre-commit
================================================
#!/bin/sh
#
# Simple script to auto-format every source file before committing.
#

#check if the formatter is present
if [ ! -f ./hooks/AStyleHelper.exe ]; then
    echo "AStyleHelper not found!"
    exit 0
fi

#format the code
"./hooks/AStyleHelper.exe" Silent

#exit when nothing needs to be done
if [ $? == 0 ]; then
    exit 0
fi

#stage the formatted files (when staged in this commit)
gitFiles=$(git diff-index --name-only --cached HEAD)
if [[ -n "${gitFiles}" ]]; then
    for fname in $gitFiles; do
        git add --all -- "${fname}"
    done
fi

#cancel commit if the changes were undone by the formatting
gitFiles=$(git diff-index --name-only --cached HEAD)
if [ -z "$gitFiles" ]; then
    "./hooks/AStyleHelper.exe" "After formatting, no files were staged..."
    exit 1
fi




================================================
File: .github/workflows/build.yml
================================================
name: Visual Studio

on: [push, pull_request]

jobs:
  build:
    # Skip building pull requests from the same repository
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository) }}
    runs-on: windows-2019
    steps:
    - name: Checkout
      uses: actions/checkout@v2
      with:
        submodules: recursive
    
    - name: Add msbuild to PATH
      uses: microsoft/setup-msbuild@v1.0.2
    
    - name: Build
      run: |
        msbuild.exe ${{ github.event.repository.name }}.sln /m /verbosity:minimal /t:Rebuild /p:Configuration=Release /p:Platform=x64
        msbuild.exe ${{ github.event.repository.name }}.sln /m /verbosity:minimal /t:Rebuild /p:Configuration=Release /p:Platform=Win32
    
    - uses: actions/upload-artifact@v2
      with:
        name: ${{ github.event.repository.name }}-${{ github.sha }}
        path: Release/
    
    - name: Compress artifacts
      uses: papeloto/action-zip@v1
      if: ${{ startsWith(github.ref, 'refs/tags/') }}
      with:
        files: Release/
        dest: ${{ github.event.repository.name }}-${{ github.sha }}.zip

    - name: Release
      uses: softprops/action-gh-release@v1
      if: ${{ startsWith(github.ref, 'refs/tags/') }}
      with:
        prerelease: ${{ !startsWith(github.ref, 'refs/tags/v') || contains(github.ref, '-pre') }}
        files: ${{ github.event.repository.name }}-${{ github.sha }}.zip
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


Directory structure:
└── xxeption-specterobfuscator/
    ├── README.md
    └── Obfuscator/
        ├── Obfuscator.sln
        └── Obfuscator/
            ├── App.config
            ├── App.xaml
            ├── App.xaml.cs
            ├── MainWindow.xaml
            ├── MainWindow.xaml.cs
            ├── Obfuscator.csproj
            ├── Helpers/
            │   ├── InjectHelper.cs
            │   └── LeetRandom.cs
            ├── Internal/
            │   ├── Core.cs
            │   ├── Classes/
            │   │   ├── Logger.cs
            │   │   ├── LvAssembly.cs
            │   │   ├── Rule.cs
            │   │   ├── SpectreContext.cs
            │   │   └── Utils.cs
            │   └── Interfaces/
            │       └── IProtector.cs
            ├── Properties/
            │   ├── AssemblyInfo.cs
            │   ├── Resources.Designer.cs
            │   ├── Resources.resx
            │   ├── Settings.Designer.cs
            │   └── Settings.settings
            ├── Protections/
            │   ├── Analysis/
            │   │   └── AntiILDasmProtection.cs
            │   ├── Assembly/
            │   │   └── RenameProtection.cs
            │   └── Constants/
            │       ├── ConstantMutation.cs
            │       └── ConstantProtection.cs
            ├── Runtime/
            │   └── ConstantRuntime.cs
            ├── bin/
            │   └── Debug/
            └── obj/
                └── Debug/
                    ├── App.baml
                    ├── App.g.cs
                    ├── App.g.i.cs
                    ├── DesignTimeResolveAssemblyReferences.cache
                    ├── DesignTimeResolveAssemblyReferencesInput.cache
                    ├── MainWindow.baml
                    ├── MainWindow.g.cs
                    ├── MainWindow.g.i.cs
                    ├── Obfuscator.Properties.Resources.resources
                    ├── Obfuscator.csproj.CoreCompileInputs.cache
                    ├── Obfuscator.csproj.FileListAbsolute.txt
                    ├── Obfuscator.csproj.GenerateResource.cache
                    ├── Obfuscator.csprojResolveAssemblyReference.cache
                    ├── Obfuscator.g.resources
                    ├── Obfuscator_Content.g.i.cs
                    ├── Obfuscator_MarkupCompile.cache
                    ├── Obfuscator_MarkupCompile.i.cache
                    ├── Obfuscator_MarkupCompile.lref
                    └── TempPE/

================================================
File: README.md
================================================
# SpecterObfuscator
This Application will obfuscate your .NET Assembly


# Features
-Symbol Renaming <br />
-AntiILDasm<br />
-Constant Protection<br />
-Constant Mutation<br />


# Information
This is a free Obfuscator, so you'll only get support on my discord https://discord.gg/JcnfV2p.
It isn't that safe. If you search a safe solution come and view : https://discord.gg/JcnfV2p


# Pictures

![alt text](https://github.com/jokebeatz/SpectreObfuscator/blob/master/specter.PNG)


# Credits
0xd4d for dnlib



================================================
File: Obfuscator/Obfuscator.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27428.2015
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Obfuscator", "Obfuscator\Obfuscator.csproj", "{67645A35-5640-4508-9117-FAFB426ABB86}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnlib", "..\..\..\Desktop\yck\dnlib-master\src\dnlib.csproj", "{FDFC1237-143F-4919-8318-4926901F4639}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug_ThreadSafe|Any CPU = Debug_ThreadSafe|Any CPU
		Debug|Any CPU = Debug|Any CPU
		Release_ThreadSafe|Any CPU = Release_ThreadSafe|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{67645A35-5640-4508-9117-FAFB426ABB86}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{67645A35-5640-4508-9117-FAFB426ABB86}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{67645A35-5640-4508-9117-FAFB426ABB86}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{67645A35-5640-4508-9117-FAFB426ABB86}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{67645A35-5640-4508-9117-FAFB426ABB86}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{67645A35-5640-4508-9117-FAFB426ABB86}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{67645A35-5640-4508-9117-FAFB426ABB86}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{67645A35-5640-4508-9117-FAFB426ABB86}.Release|Any CPU.Build.0 = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug_ThreadSafe|Any CPU.Build.0 = Debug_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release_ThreadSafe|Any CPU.ActiveCfg = Release_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release_ThreadSafe|Any CPU.Build.0 = Release_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D93B6202-44A2-4679-B220-64F7D50557EA}
	EndGlobalSection
EndGlobal



================================================
File: Obfuscator/Obfuscator/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
</configuration>


================================================
File: Obfuscator/Obfuscator/App.xaml
================================================
ï»¿<Application x:Class="Obfuscator.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:Obfuscator"
             StartupUri="MainWindow.xaml">
    
    <Application.Resources>
        <Style x:Key="GridViewColumnHeaderStyle1" TargetType="{x:Type GridViewColumnHeader}">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type GridViewColumnHeader}">
                        <Border BorderThickness="0,0,0,1" BorderBrush="Orange" Background="Transparent">
                            <TextBlock x:Name="ContentHeader" Text="{TemplateBinding Content}" Padding="350,5,5,0" Width="{TemplateBinding Width}" TextAlignment="Center" />
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
            <Setter Property="OverridesDefaultStyle" Value="True" />
            <Setter Property="Foreground" Value="White" />
            <Setter Property="FontFamily" Value="Segoe UI" />
            <Setter Property="FontSize" Value="12" />
        </Style>

        <Style x:Key="SpecterButton" TargetType="Button">
            <Setter Property="OverridesDefaultStyle" Value="True"/>
            <Setter Property="Margin" Value="5"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border Name="border" 
                            BorderThickness="1"
                            Padding="4,2" 
                            BorderBrush="DarkGray"
                            CornerRadius="3" 
                            Background="{TemplateBinding Background}">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center" />
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter TargetName="border" Property="Background" Value="Orange" />
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Application.Resources>
</Application>



================================================
File: Obfuscator/Obfuscator/App.xaml.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace Obfuscator
{
    /// <summary>
    /// Interaktionslogik fÃ¼r "App.xaml"
    /// </summary>
    public partial class App : Application
    {
    }
}



================================================
File: Obfuscator/Obfuscator/MainWindow.xaml
================================================
ï»¿<Window x:Name="w" x:Class="Obfuscator.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:Obfuscator"
        mc:Ignorable="d"
        Title="Specter Obfuscator" Height="450" Width="800" Background="#FF131313" ResizeMode="NoResize">
    <Grid>
        <TabControl Background="#FF131313">
            <TabControl.Resources>
                <Style TargetType="TabItem">
                    <Setter Property="Template">
                        <Setter.Value>
                            <ControlTemplate TargetType="TabItem">
                                <Grid Name="Panel">
                                    <ContentPresenter x:Name="ContentSite"
                                        VerticalAlignment="Center"
                                        HorizontalAlignment="Center"
                                        ContentSource="Header"
                                        Margin="10,2"/>
                                </Grid>
                                <ControlTemplate.Triggers>
                                    <Trigger Property="IsSelected" Value="True">
                                        <Setter TargetName="Panel" Property="Background" Value="Orange" />
                                    </Trigger>
                                    <Trigger Property="IsSelected" Value="False">
                                        <Setter TargetName="Panel" Property="Background" Value="#FF252424" />
                                    </Trigger>
                                </ControlTemplate.Triggers>
                            </ControlTemplate>
                        </Setter.Value>
                    </Setter>
                </Style>
            </TabControl.Resources>
            <TabItem Header="Dashboard" Foreground = "White">
                <Grid HorizontalAlignment="Left" Height="394" Margin="0,-1,-5,-3" VerticalAlignment="Top" Width="789">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="519*"/>
                        <ColumnDefinition Width="271*"/>
                    </Grid.ColumnDefinitions>
                    <ListView  AllowDrop="True" x:Name="lvassemblys"  Background="#FF252424" HorizontalAlignment="Left" Height="322" VerticalAlignment="Top" Width="761" Foreground="White" BorderBrush="#FF252424" Margin="6,56,0,0" Drop="lvassemblys_Drop" Grid.ColumnSpan="2">
                        <ListView.View>
                            <GridView ColumnHeaderContainerStyle="{StaticResource GridViewColumnHeaderStyle1}">
                                <GridViewColumn Header="Path" DisplayMemberBinding="{Binding Path}"/>
                            </GridView>
                        </ListView.View>
                        <ListView.ItemContainerStyle>
                            <Style TargetType="ListViewItem">
                                <EventSetter Event="PreviewMouseLeftButtonDown" Handler="ListViewItem_PreviewMouseLeftButtonDown" />
                            </Style>
                        </ListView.ItemContainerStyle>
                        <Label Content="Label" HorizontalAlignment="Left" VerticalAlignment="Top"/>
                    </ListView>
                    <Button  x:Name="btnDel" FontSize="14" Background ="Orange" Foreground="White" Content="DEL" HorizontalAlignment="Left" Margin="164.5,28,0,0" VerticalAlignment="Top" Width="84.5" Height="23.5" Padding="1" UseLayoutRounding="False" Grid.Column="1" Click="btnDel_Click" IsEnabled="False"/>
                    <TextBox x:Name="tbout" HorizontalAlignment="Left" Height="23" Margin="10,28,0,0" TextWrapping="Wrap" Text="Output" VerticalAlignment="Top" Width="402" RenderTransformOrigin="0.526,0.347"/>
                    <Button  x:Name="btnOfd" FontSize="14" Background ="Orange" Foreground="White" Content="..." HorizontalAlignment="Left" Margin="423.5,27.5,0,0" VerticalAlignment="Top" Width="84.5" Height="23.5" Padding="1" UseLayoutRounding="False" Click="btnOfd_Click" IsEnabled="False"/>
                </Grid>
            </TabItem>
            <TabItem Header="Settings" Foreground="White" >
                <Grid HorizontalAlignment="Left" Height="398" Margin="0,-2,-2,-6" VerticalAlignment="Top" Width="786" RenderTransformOrigin="0.413,0.65">
                    <TabControl TabStripPlacement="Left" Background="#FF131313" HorizontalAlignment="Left" Height="388" VerticalAlignment="Top" Width="776">
                        <TabItem Foreground="White" Header="Assembly">
                            <StackPanel HorizontalAlignment="Left" Height="377" Margin="4,0,0,0" VerticalAlignment="Top" Width="687">
                                <Button x:Name="btnRenamer" Style="{StaticResource SpecterButton}" Margin="8,5,12,5" Content="Enable Renamer" Background="#FF252424" Click="btnRenamer_Click"/>

                            </StackPanel>
                        </TabItem>
                        <TabItem Foreground="White" Header="Constants" Background="#FF131313">
                            <StackPanel HorizontalAlignment="Left" Height="377" Margin="4,0,0,0" VerticalAlignment="Top" Width="687">
                                <Button x:Name="btnEnableConstantProtection" Style="{StaticResource SpecterButton}" Margin="8,5,12,5" Content="Enable Constant Protection" Background="#FF252424" Click="btnEnableConstantProtection_Click"/>
                                <Button x:Name="btnEnableConstantMutation" Style="{StaticResource SpecterButton}" Margin="8,5,12,5" Content="Enable Constant Mutation" Background="#FF252424" Click="btnEnableConstantMutation_Click"/>

                            </StackPanel>
                        </TabItem>
                        <TabItem Foreground="White" Header="Analysis" Background="#FF131313">
                            <StackPanel HorizontalAlignment="Left" Height="377" Margin="4,0,0,0" VerticalAlignment="Top" Width="687">
                                <Button x:Name="btnAntiILDasm" Style="{StaticResource SpecterButton}" Margin="8,5,12,5" Content="Enable AntiILDasm" Click="btnAntiILDasm_Click" Background="#FF252424"/>

                            </StackPanel>
                        </TabItem>
                    </TabControl>
                </Grid>
            </TabItem>
            <TabItem Header="Obfuscate" Foreground="White" >
                <WrapPanel HorizontalAlignment="Left" Height="392" Margin="0,-1" VerticalAlignment="Top" Width="784">
                    <RichTextBox x:FieldModifier="public" x:Name="rtlog" HorizontalAlignment="Left" Height="354" VerticalAlignment="Top" Width="434" Background="#FF252424" Foreground="Orange" Margin="20,20,0,30" FontSize="10" FontFamily="Simplified Arabic Fixed">
                        <FlowDocument>
                            <Paragraph>
                                <Run Text=""/>
                            </Paragraph>
                        </FlowDocument>
                    </RichTextBox>
                    <Button VerticalAlignment="Top"  x:Name="btnObf" Style="{StaticResource SpecterButton}" Margin="20" Content="Obfuscate" Background="#FF252424" Height="62" Width="286" RenderTransformOrigin="0.5,0.5" Padding="10,0,0,0" Click="btnObf_Click">
                        <Button.RenderTransform>
                            <TransformGroup>
                                <ScaleTransform/>
                                <SkewTransform/>
                                <RotateTransform Angle="-0.11"/>
                                <TranslateTransform/>
                            </TransformGroup>
                        </Button.RenderTransform>
                    </Button>
                </WrapPanel>
            </TabItem>
        </TabControl>
    </Grid>
</Window>



================================================
File: Obfuscator/Obfuscator/MainWindow.xaml.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Writer;
using Microsoft.Win32;
using Obfuscator.Internal;
using Obfuscator.Internal.Classes;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace Obfuscator
{
    /// <summary>
    /// Interaktionslogik fÃ¼r MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            lvassemblys.Items.RemoveAt(0);


        }
        #region Rules
        private bool enable_antiildasm = false;
        private bool enable_constantprotection = false;
        private bool enable_constantmutation = false;
        private bool enable_renamer = false;
        #endregion
        private BrushConverter bc = new BrushConverter();
        private List<string> assemblys = new List<string>();
        private Dictionary<string, string> dict =
           new Dictionary<string, string>();

        private void btnObf_Click(object sender, RoutedEventArgs e)
        {
            foreach (var item in lvassemblys.Items)
            {
                var current = item as LvAssembly;
                try
                {
                    AssemblyDef asm = AssemblyDef.Load(current.Path);
                    SpectreContext spctx = new SpectreContext(asm);
                    var rule = new Rule(enable_renamer, enable_antiildasm, enable_constantprotection, enable_constantmutation);
                    new Core(spctx, rule).DoObfuscation();
                    var opts = new ModuleWriterOptions(spctx.ManifestModule);
                    opts.Logger = DummyLogger.NoThrowInstance;
                    foreach (var path in dict)
                    {
                        if(path.Key.Equals(current.Path))
                        asm.Write(path.Value, opts);
                    }
                }
                catch (Exception) { throw; }

            }
        }

   

        private void lvassemblys_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop, true))
            {
                string[] droppedFilePaths = e.Data.GetData(DataFormats.FileDrop, true) as string[];
                foreach (var path in droppedFilePaths)
                {
                    if (File.Exists(path)) this.lvassemblys.Items.Add(new LvAssembly { Path = path }); else continue;
                }
            }
        }

        private void ListViewItem_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            var item = sender as ListViewItem;
            if (item != null && item.IsSelected)
            {
                btnDel.IsEnabled = true;
                btnOfd.IsEnabled = true;
                foreach (var path in dict)
                {
                    var current = lvassemblys.SelectedItem as LvAssembly;
                    if (path.Key.Equals(current.Path))
                        tbout.Text = path.Value;
                }
            }
        }

        private void btnDel_Click(object sender, RoutedEventArgs e)
        {
            lvassemblys.Items.Remove(lvassemblys.SelectedItem);
            btnDel.IsEnabled = false;
        }

        private void btnAntiILDasm_Click(object sender, RoutedEventArgs e)
        {
            if (btnAntiILDasm.Background == Brushes.Orange)
            {
                btnAntiILDasm.Background = (Brush)bc.ConvertFrom("#FF252424");
                enable_antiildasm = false;
            }
            else
            {
                btnAntiILDasm.Background = Brushes.Orange;
                enable_antiildasm = true;
            }
        }

        private void btnEnableConstantProtection_Click(object sender, RoutedEventArgs e)
        {
            if (btnEnableConstantProtection.Background == Brushes.Orange)
            {
                btnEnableConstantProtection.Background = (Brush)bc.ConvertFrom("#FF252424");
                enable_constantprotection = false;
            }
            else
            {
                btnEnableConstantProtection.Background = Brushes.Orange;
                enable_constantprotection = true;
            }
        }
        private void btnEnableConstantMutation_Click(object sender, RoutedEventArgs e)
        {
            if (btnEnableConstantMutation.Background == Brushes.Orange)
            {
                btnEnableConstantMutation.Background = (Brush)bc.ConvertFrom("#FF252424");
                enable_constantmutation = false;
            }
            else
            {
                btnEnableConstantMutation.Background = Brushes.Orange;
                enable_constantmutation = true;
            }
        }

        private void btnRenamer_Click(object sender, RoutedEventArgs e)
        {
            if (btnRenamer.Background == Brushes.Orange)
            {
                btnRenamer.Background = (Brush)bc.ConvertFrom("#FF252424");
                enable_renamer = false;
            }
            else
            {
                btnRenamer.Background = Brushes.Orange;
                enable_renamer = true;
            }
        }

        private void btnOfd_Click(object sender, RoutedEventArgs e)
        {
            SaveFileDialog sfd = new SaveFileDialog();
            if(sfd.ShowDialog() == true)
            {
                var current = lvassemblys.SelectedItem as LvAssembly;
                dict.Add(current.Path, sfd.FileName);
            }

        }
    }
}



================================================
File: Obfuscator/Obfuscator/Obfuscator.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{67645A35-5640-4508-9117-FAFB426ABB86}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>Obfuscator</RootNamespace>
    <AssemblyName>Obfuscator</AssemblyName>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>false</DebugSymbols>
    <DebugType>none</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>specter.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="Helpers\InjectHelper.cs" />
    <Compile Include="Helpers\LeetRandom.cs" />
    <Compile Include="Internal\Classes\Logger.cs" />
    <Compile Include="Internal\Classes\LvAssembly.cs" />
    <Compile Include="Internal\Classes\Rule.cs" />
    <Compile Include="Internal\Classes\Utils.cs" />
    <Compile Include="Protections\Analysis\AntiILDasmProtection.cs" />
    <Compile Include="Protections\Assembly\RenameProtection.cs" />
    <Compile Include="Protections\Constants\ConstantMutation.cs" />
    <Compile Include="Protections\Constants\ConstantProtection.cs" />
    <Compile Include="Runtime\ConstantRuntime.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Internal\Classes\SpectreContext.cs" />
    <Compile Include="Internal\Core.cs" />
    <Compile Include="Internal\Interfaces\IProtector.cs" />
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\..\..\Desktop\yck\dnlib-master\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <Resource Include="specter.ico" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
File: Obfuscator/Obfuscator/Helpers/InjectHelper.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Helpers
{
        public static class InjectHelper
        {
            /// <summary>
            ///     Clones the specified origin TypeDef.
            /// </summary>
            /// <param name="origin">The origin TypeDef.</param>
            /// <returns>The cloned TypeDef.</returns>
            static TypeDefUser Clone(TypeDef origin)
            {
                var ret = new TypeDefUser(origin.Namespace, origin.Name);
                ret.Attributes = origin.Attributes;

                if (origin.ClassLayout != null)
                    ret.ClassLayout = new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);

                foreach (GenericParam genericParam in origin.GenericParameters)
                    ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

                return ret;
            }

            /// <summary>
            ///     Clones the specified origin MethodDef.
            /// </summary>
            /// <param name="origin">The origin MethodDef.</param>
            /// <returns>The cloned MethodDef.</returns>
            static MethodDefUser Clone(MethodDef origin)
            {
                var ret = new MethodDefUser(origin.Name, null, origin.ImplAttributes, origin.Attributes);

                foreach (GenericParam genericParam in origin.GenericParameters)
                    ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

                return ret;
            }

            /// <summary>
            ///     Clones the specified origin FieldDef.
            /// </summary>
            /// <param name="origin">The origin FieldDef.</param>
            /// <returns>The cloned FieldDef.</returns>
            static FieldDefUser Clone(FieldDef origin)
            {
                var ret = new FieldDefUser(origin.Name, null, origin.Attributes);
                return ret;
            }

            /// <summary>
            ///     Populates the context mappings.
            /// </summary>
            /// <param name="typeDef">The origin TypeDef.</param>
            /// <param name="ctx">The injection context.</param>
            /// <returns>The new TypeDef.</returns>
            static TypeDef PopulateContext(TypeDef typeDef, InjectContext ctx)
            {
                TypeDef ret;
                IDnlibDef existing;
                if (!ctx.Map.TryGetValue(typeDef, out existing))
                {
                    ret = Clone(typeDef);
                    ctx.Map[typeDef] = ret;
                }
                else
                    ret = (TypeDef)existing;

                foreach (TypeDef nestedType in typeDef.NestedTypes)
                    ret.NestedTypes.Add(PopulateContext(nestedType, ctx));

                foreach (MethodDef method in typeDef.Methods)
                    ret.Methods.Add((MethodDef)(ctx.Map[method] = Clone(method)));

                foreach (FieldDef field in typeDef.Fields)
                    ret.Fields.Add((FieldDef)(ctx.Map[field] = Clone(field)));

                return ret;
            }

            /// <summary>
            ///     Copies the information from the origin type to injected type.
            /// </summary>
            /// <param name="typeDef">The origin TypeDef.</param>
            /// <param name="ctx">The injection context.</param>
            static void CopyTypeDef(TypeDef typeDef, InjectContext ctx)
            {
                var newTypeDef = (TypeDef)ctx.Map[typeDef];

                newTypeDef.BaseType = (ITypeDefOrRef)ctx.Importer.Import(typeDef.BaseType);

                foreach (InterfaceImpl iface in typeDef.Interfaces)
                    newTypeDef.Interfaces.Add(new InterfaceImplUser((ITypeDefOrRef)ctx.Importer.Import(iface.Interface)));
            }

            /// <summary>
            ///     Copies the information from the origin method to injected method.
            /// </summary>
            /// <param name="methodDef">The origin MethodDef.</param>
            /// <param name="ctx">The injection context.</param>
            static void CopyMethodDef(MethodDef methodDef, InjectContext ctx)
            {
                var newMethodDef = (MethodDef)ctx.Map[methodDef];

                newMethodDef.Signature = ctx.Importer.Import(methodDef.Signature);
                newMethodDef.Parameters.UpdateParameterTypes();

                if (methodDef.ImplMap != null)
                    newMethodDef.ImplMap = new ImplMapUser(new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);

                foreach (CustomAttribute ca in methodDef.CustomAttributes)
                    newMethodDef.CustomAttributes.Add(new CustomAttribute((ICustomAttributeType)ctx.Importer.Import(ca.Constructor)));

                if (methodDef.HasBody)
                {
                    newMethodDef.Body = new CilBody(methodDef.Body.InitLocals, new List<Instruction>(), new List<ExceptionHandler>(), new List<Local>());
                    newMethodDef.Body.MaxStack = methodDef.Body.MaxStack;

                    var bodyMap = new Dictionary<object, object>();

                    foreach (Local local in methodDef.Body.Variables)
                    {
                        var newLocal = new Local(ctx.Importer.Import(local.Type));
                        newMethodDef.Body.Variables.Add(newLocal);
                        bodyMap[local] = newLocal;
                    }

                    foreach (Instruction instr in methodDef.Body.Instructions)
                    {
                        var newInstr = new Instruction(instr.OpCode, instr.Operand);
                        if (newInstr.Operand is IType)
                            newInstr.Operand = ctx.Importer.Import((IType)newInstr.Operand);

                        else if (newInstr.Operand is IMethod)
                            newInstr.Operand = ctx.Importer.Import((IMethod)newInstr.Operand);

                        else if (newInstr.Operand is IField)
                            newInstr.Operand = ctx.Importer.Import((IField)newInstr.Operand);

                        newMethodDef.Body.Instructions.Add(newInstr);
                        bodyMap[instr] = newInstr;
                    }

                    foreach (Instruction instr in newMethodDef.Body.Instructions)
                    {
                        if (instr.Operand != null && bodyMap.ContainsKey(instr.Operand))
                            instr.Operand = bodyMap[instr.Operand];

                        else if (instr.Operand is Instruction[])
                            instr.Operand = ((Instruction[])instr.Operand).Select(target => (Instruction)bodyMap[target]).ToArray();
                    }

                    foreach (ExceptionHandler eh in methodDef.Body.ExceptionHandlers)
                        newMethodDef.Body.ExceptionHandlers.Add(new ExceptionHandler(eh.HandlerType)
                        {
                            CatchType = eh.CatchType == null ? null : (ITypeDefOrRef)ctx.Importer.Import(eh.CatchType),
                            TryStart = (Instruction)bodyMap[eh.TryStart],
                            TryEnd = (Instruction)bodyMap[eh.TryEnd],
                            HandlerStart = (Instruction)bodyMap[eh.HandlerStart],
                            HandlerEnd = (Instruction)bodyMap[eh.HandlerEnd],
                            FilterStart = eh.FilterStart == null ? null : (Instruction)bodyMap[eh.FilterStart]
                        });

                    newMethodDef.Body.SimplifyMacros(newMethodDef.Parameters);
                }
            }

            /// <summary>
            ///     Copies the information from the origin field to injected field.
            /// </summary>
            /// <param name="fieldDef">The origin FieldDef.</param>
            /// <param name="ctx">The injection context.</param>
            static void CopyFieldDef(FieldDef fieldDef, InjectContext ctx)
            {
                var newFieldDef = (FieldDef)ctx.Map[fieldDef];

                newFieldDef.Signature = ctx.Importer.Import(fieldDef.Signature);
            }

            /// <summary>
            ///     Copies the information to the injected definitions.
            /// </summary>
            /// <param name="typeDef">The origin TypeDef.</param>
            /// <param name="ctx">The injection context.</param>
            /// <param name="copySelf">if set to <c>true</c>, copy information of <paramref name="typeDef" />.</param>
            static void Copy(TypeDef typeDef, InjectContext ctx, bool copySelf)
            {
                if (copySelf)
                    CopyTypeDef(typeDef, ctx);

                foreach (TypeDef nestedType in typeDef.NestedTypes)
                    Copy(nestedType, ctx, true);

                foreach (MethodDef method in typeDef.Methods)
                    CopyMethodDef(method, ctx);

                foreach (FieldDef field in typeDef.Fields)
                    CopyFieldDef(field, ctx);
            }

            /// <summary>
            ///     Injects the specified TypeDef to another module.
            /// </summary>
            /// <param name="typeDef">The source TypeDef.</param>
            /// <param name="target">The target module.</param>
            /// <returns>The injected TypeDef.</returns>
            public static TypeDef Inject(TypeDef typeDef, ModuleDef target)
            {
                var ctx = new InjectContext(typeDef.Module, target);
                PopulateContext(typeDef, ctx);
                Copy(typeDef, ctx, true);
                return (TypeDef)ctx.Map[typeDef];
            }

            /// <summary>
            ///     Injects the specified MethodDef to another module.
            /// </summary>
            /// <param name="methodDef">The source MethodDef.</param>
            /// <param name="target">The target module.</param>
            /// <returns>The injected MethodDef.</returns>
            public static MethodDef Inject(MethodDef methodDef, ModuleDef target)
            {
                var ctx = new InjectContext(methodDef.Module, target);
                ctx.Map[methodDef] = Clone(methodDef);
                CopyMethodDef(methodDef, ctx);
                return (MethodDef)ctx.Map[methodDef];
            }

            /// <summary>
            ///     Injects the members of specified TypeDef to another module.
            /// </summary>
            /// <param name="typeDef">The source TypeDef.</param>
            /// <param name="newType">The new type.</param>
            /// <param name="target">The target module.</param>
            /// <returns>Injected members.</returns>
            public static IEnumerable<IDnlibDef> Inject(TypeDef typeDef, TypeDef newType, ModuleDef target)
            {
                var ctx = new InjectContext(typeDef.Module, target);
                ctx.Map[typeDef] = newType;
                PopulateContext(typeDef, ctx);
                Copy(typeDef, ctx, false);
                return ctx.Map.Values.Except(new[] { newType });
            }

            /// <summary>
            ///     Context of the injection process.
            /// </summary>
            class InjectContext : ImportResolver
            {
                /// <summary>
                ///     The mapping of origin definitions to injected definitions.
                /// </summary>
                public readonly Dictionary<IDnlibDef, IDnlibDef> Map = new Dictionary<IDnlibDef, IDnlibDef>();

                /// <summary>
                ///     The module which source type originated from.
                /// </summary>
                public readonly ModuleDef OriginModule;

                /// <summary>
                ///     The module which source type is being injected to.
                /// </summary>
                public readonly ModuleDef TargetModule;

                /// <summary>
                ///     The importer.
                /// </summary>
                readonly Importer importer;

                /// <summary>
                ///     Initializes a new instance of the <see cref="InjectContext" /> class.
                /// </summary>
                /// <param name="module">The origin module.</param>
                /// <param name="target">The target module.</param>
                public InjectContext(ModuleDef module, ModuleDef target)
                {
                    OriginModule = module;
                    TargetModule = target;
                    importer = new Importer(target, ImporterOptions.TryToUseTypeDefs);
                    importer.Resolver = this;
                }

                /// <summary>
                ///     Gets the importer.
                /// </summary>
                /// <value>The importer.</value>
                public Importer Importer
                {
                    get { return importer; }
                }

                /// <inheritdoc />
                public override TypeDef Resolve(TypeDef typeDef)
                {
                    if (Map.ContainsKey(typeDef))
                        return (TypeDef)Map[typeDef];
                    return null;
                }

                /// <inheritdoc />
                public override MethodDef Resolve(MethodDef methodDef)
                {
                    if (Map.ContainsKey(methodDef))
                        return (MethodDef)Map[methodDef];
                    return null;
                }

                /// <inheritdoc />
                public override FieldDef Resolve(FieldDef fieldDef)
                {
                    if (Map.ContainsKey(fieldDef))
                        return (FieldDef)Map[fieldDef];
                    return null;
                }
            }
        }
    }







================================================
File: Obfuscator/Obfuscator/Helpers/LeetRandom.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Helpers
{
    class LeetRandom
    {

        public static Random rnd = new Random();

    }
}



================================================
File: Obfuscator/Obfuscator/Internal/Core.cs
================================================
ï»¿using Obfuscator.Internal.Classes;
using Obfuscator.Internal.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace Obfuscator.Internal
{
    class Core
    {
        private SpectreContext spctx;
        private Rule rule;
        private List<IProtector> Tasks = new List<IProtector>();
        public Core(SpectreContext spctx, Rule rule)
        {
            this.spctx = spctx;
            this.rule = rule;
        }

        public void DoObfuscation()
        {
            rule.AddTasksToList();
            Tasks = rule.GetTasks();
            Console.WriteLine(Tasks.Count.ToString());
            if (!(Tasks.Count == 0))
                RunTasks();
            else { throw new Exception("You have to select at least one module!"); }
        }
        private void RunTasks()
        {
            foreach(IProtector prot in Tasks)
            {
                try
                {
                    Logger.Log("Current Module: " + prot.Name + "\n" + "Description: " + prot.Descrption + "\n" +"Protectiontype: " + prot.ProtectionType  +"\n");
                    Logger.Log("Injecting..." + "\n");
                    prot.InjectPhase(spctx);
                    Logger.Log("Protecting..." + "\n");
                    prot.ProtectionPhase(spctx);
                    Logger.Log("Finished with " + prot.Name + "\n");
                }
                catch (Exception ex)
                {
                    Logger.Log(ex.StackTrace);
                }
            }

            
        }

    }
}



================================================
File: Obfuscator/Obfuscator/Internal/Classes/Logger.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace Obfuscator.Internal.Classes
{
    class Logger
    {
        public static void Log(string msg)
        {
            foreach (Window window in Application.Current.Windows)
            {
                if (window.GetType() == typeof(MainWindow))
                {
                    (window as MainWindow).rtlog.AppendText(msg);
                }
            }
        }
    }
}



================================================
File: Obfuscator/Obfuscator/Internal/Classes/LvAssembly.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Internal.Classes
{
    class LvAssembly
    {

        public string Path { get; set; }
    }
}



================================================
File: Obfuscator/Obfuscator/Internal/Classes/Rule.cs
================================================
ï»¿using Obfuscator.Internal.Interfaces;
using Obfuscator.Protections.Analysis;
using Obfuscator.Protections.Assembly;
using Obfuscator.Protections.Constants;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Internal.Classes
{
    class Rule
    {
        private bool enable_renamer = false;
        private bool enable_antiildasm = false;
        private bool enable_constantprotection = false;
        private bool enable_constantmutation = false;

        private List<IProtector> TaskList = new List<IProtector>();
        public Rule(bool enable_renamer, bool enable_antiildasm, bool enable_constantprotection, bool enable_constantmutation)
        {
            this.enable_renamer = enable_renamer;
            this.enable_antiildasm = enable_antiildasm;
            this.enable_constantprotection = enable_constantprotection;
            this.enable_constantmutation = enable_constantmutation;
            this.enable_renamer = enable_renamer;
        }

        public void AddTasksToList()
        {
            if (enable_antiildasm) TaskList.Add(new AntiILDasmProtection());
            if (enable_constantmutation) TaskList.Add(new ConstantMutation());
            if (enable_constantprotection) TaskList.Add(new ConstantProtection());
            if (enable_renamer) TaskList.Add(new RenameProtection());


        }

        public List<IProtector> GetTasks()
        {
            return TaskList;
        }

    }

}



================================================
File: Obfuscator/Obfuscator/Internal/Classes/SpectreContext.cs
================================================
ï»¿using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Internal.Classes
{
    class SpectreContext
    {
        public AssemblyDef Assembly;
        public ModuleDef ManifestModule;
        public TypeDef GlobalType;
        public Importer Imp;
        public MethodDef cctor;

        public SpectreContext(AssemblyDef asm)
        {
            this.Assembly = asm;
            this.ManifestModule = asm.ManifestModule;
            this.GlobalType = this.ManifestModule.GlobalType;
            this.Imp = new Importer(ManifestModule);
            this.cctor = this.GlobalType.FindOrCreateStaticConstructor();
        }

      


    }
}



================================================
File: Obfuscator/Obfuscator/Internal/Classes/Utils.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Internal.Classes
{
    class Utils
    {

    }

}



================================================
File: Obfuscator/Obfuscator/Internal/Interfaces/IProtector.cs
================================================
ï»¿using Obfuscator.Internal.Classes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Internal.Interfaces
{


    interface IProtector
    {
        string Name { get; }
        string Descrption { get; }
        string ProtectionType { get; }
        void InjectPhase(SpectreContext spctx);
        void ProtectionPhase(SpectreContext spctx);
        

    }
}




================================================
File: Obfuscator/Obfuscator/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// Allgemeine Informationen Ã¼ber eine Assembly werden Ã¼ber die folgenden
// Attribute gesteuert. Ã„ndern Sie diese Attributwerte, um die Informationen zu Ã¤ndern,
// die einer Assembly zugeordnet sind.
[assembly: AssemblyTitle("Obfuscator")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Obfuscator")]
[assembly: AssemblyCopyright("Copyright Â©  2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Durch Festlegen von ComVisible auf FALSE werden die Typen in dieser Assembly
// fÃ¼r COM-Komponenten unsichtbar.  Wenn Sie auf einen Typ in dieser Assembly von
// COM aus zugreifen mÃ¼ssen, sollten Sie das ComVisible-Attribut fÃ¼r diesen Typ auf "True" festlegen.
[assembly: ComVisible(false)]

//Um mit dem Erstellen lokalisierbarer Anwendungen zu beginnen, legen Sie
//<UICulture>ImCodeVerwendeteKultur</UICulture> in der .csproj-Datei
//in einer <PropertyGroup> fest.  Wenn Sie in den Quelldateien beispielsweise Deutsch
//(Deutschland) verwenden, legen Sie <UICulture> auf \"de-DE\" fest.  Heben Sie dann die Auskommentierung
//des nachstehenden NeutralResourceLanguage-Attributs auf.  Aktualisieren Sie "en-US" in der nachstehenden Zeile,
//sodass es mit der UICulture-Einstellung in der Projektdatei Ã¼bereinstimmt.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //Speicherort der designspezifischen RessourcenwÃ¶rterbÃ¼cher
                                     //(wird verwendet, wenn eine Ressource auf der Seite nicht gefunden wird,
                                     // oder in den Anwendungsressourcen-WÃ¶rterbÃ¼chern nicht gefunden werden kann.)
    ResourceDictionaryLocation.SourceAssembly //Speicherort des generischen RessourcenwÃ¶rterbuchs
                                              //(wird verwendet, wenn eine Ressource auf der Seite nicht gefunden wird,
                                              // designspezifischen RessourcenwÃ¶rterbuch nicht gefunden werden kann.)
)]


// Versionsinformationen fÃ¼r eine Assembly bestehen aus den folgenden vier Werten:
//
//      Hauptversion
//      Nebenversion
//      Buildnummer
//      Revision
//
// Sie kÃ¶nnen alle Werte angeben oder Standardwerte fÃ¼r die Build- und Revisionsnummern verwenden,
// Ã¼bernehmen, indem Sie "*" eingeben:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: Obfuscator/Obfuscator/Properties/Resources.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion: 4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen fehlerhaftes Verhalten verursachen und gehen verloren, wenn
//     der Code neu generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Obfuscator.Properties
{


    /// <summary>
    ///   Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
    /// </summary>
    // Diese Klasse wurde von der StronglyTypedResourceBuilder-Klasse
    // Ã¼ber ein Tool wie ResGen oder Visual Studio automatisch generiert.
    // Um einen Member hinzuzufÃ¼gen oder zu entfernen, bearbeiten Sie die .ResX-Datei und fÃ¼hren dann ResGen
    // mit der Option /str erneut aus, oder erstellen Sie Ihr VS-Projekt neu.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Gibt die zwischengespeicherte ResourceManager-Instanz zurÃ¼ck, die von dieser Klasse verwendet wird.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Obfuscator.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Ãœberschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads fÃ¼r alle
        ///   Ressourcenlookups, die diese stark typisierte Ressourcenklasse verwenden.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}



================================================
File: Obfuscator/Obfuscator/Properties/Resources.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: Obfuscator/Obfuscator/Properties/Settings.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Obfuscator.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}



================================================
File: Obfuscator/Obfuscator/Properties/Settings.settings
================================================
ï»¿<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>


================================================
File: Obfuscator/Obfuscator/Protections/Analysis/AntiILDasmProtection.cs
================================================
ï»¿using dnlib.DotNet;
using Obfuscator.Internal.Classes;
using Obfuscator.Internal.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Protections.Analysis
{
    class AntiILDasmProtection : IProtector
    {
        string IProtector.Name => "AntiILDasmProtection";
        string IProtector.Descrption => "Will prevent users from using ildasm on target application";
        string IProtector.ProtectionType => "Analysis";

        

    
        public void InjectPhase(SpectreContext spctx) {}

        public void ProtectionPhase(SpectreContext spctx)
        {
            var ManifestModule = spctx.ManifestModule;
            //Create Ref
            TypeRef supressref = ManifestModule.CorLibTypes.GetTypeRef("System.Runtime.CompilerServices", "SuppressIldasmAttribute"); 
            var ctorRef = new MemberRefUser(ManifestModule, ".ctor", MethodSig.CreateInstance(ManifestModule.CorLibTypes.Void), supressref);

            var supressattribute = new CustomAttribute(ctorRef);
            //add Attribute
            ManifestModule.CustomAttributes.Add(supressattribute);
        }

    }
}



================================================
File: Obfuscator/Obfuscator/Protections/Assembly/RenameProtection.cs
================================================
﻿using dnlib.DotNet;
using Obfuscator.Helpers;
using Obfuscator.Internal.Classes;
using Obfuscator.Internal.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Protections.Assembly
{
    class RenameProtection : IProtector
    {
        string IProtector.Name => "RenameProtection";
        string IProtector.Descrption => "Will rename all symbols";
        string IProtector.ProtectionType => "Assembly";

        public void InjectPhase(SpectreContext spctx) { }

        private enum RenameMode
        {
            ASCII = 0,
            UNREADABLE = 1
        }

        class Utils
        {
            public static string GenerateName(RenameMode rm)
            {
                string ascii = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                string unreadable = "✓ ✔ ☑ ♥ ❤ ❥ ❣ ☂ ☔ ☎ ☏ ☒ ☘ ☠ ☹ ☺ ☻ ♬ ♻ ♲ ♿ ⚠ ☃ ʚϊɞ ✖ ✗ ✘ ♒ ♬ ✄ ✂ ✆ ✉ ✦ ✧ ♱ ♰ ♂ ♀ ☿ ❤ ❥ ❦ ❧ ™ ® © ♡ ♦ ♢ ♔ ♕ ♚ ♛ ★ ☆ ✮ ✯ ☄ ☾ ☽ ☼ ☀ ☁ ☂ ☃ ☻ ☺ ☹ ۞ ۩ εїз ☎ ☏ ¢ ☚ ☛ ☜ ☝ ☞ ☟ ✍ ✌ ☢ ☣ ☠ ☮ ☯ ♠ ♤ ♣ ♧ ♥࿂ ე ჳ ᆡ ༄ ♨ ๑ ❀ ✿ ψ ♆ ☪ ☭ ♪ ♩ ♫ ℘ ℑ ℜ ℵ ♏ η α ʊ ϟ ღ ツ 回 ₪ ™ © ® ¿ ¡ № ⇨ ❝ ❞ ℃ƺ ◠ ◡ ╭ ╮ ╯ ╰ ★ ☆ ⊙¤ ㊣★☆♀◆◇◣◢◥▲▼△▽⊿◤ ◥▆ ▇ █ █ ■ ";
                if (rm == RenameMode.ASCII)
                    return RandomString(LeetRandom.rnd.Next(0, 20), ascii);
                else
                    return RandomString(LeetRandom.rnd.Next(0, 20), unreadable);

            }
            private static string RandomString(int length, string chars)
            {
                return new string(Enumerable.Repeat(chars, length)
                  .Select(s => s[LeetRandom.rnd.Next(s.Length)]).ToArray());
            }
            public static bool CanRename(TypeDef type)
            {
                if (type.IsGlobalModuleType)
                    return false;
                try
                {
                    if (type.Namespace.Contains("My"))
                        return false;
                }
                catch { }

                if (type.Interfaces.Count > 0)
                    return false;
                if (type.IsSpecialName)
                    return false;
                if (type.IsRuntimeSpecialName)
                    return false;
                else
                    return true;
            }
            public static bool CanRename(MethodDef method)
            {
                if (method.IsConstructor)
                    return false;
                /* if (method.GetType().GetInterfaces().Count() > 0)
                     return false; */
                if (method.IsFamily)
                    return false;
                if (method.IsRuntimeSpecialName)
                    return false;
                if (method.DeclaringType.IsForwarder)
                    return false;
                else
                    return true;
            }
            public static bool CanRename(FieldDef field)
            {

                if (field.IsRuntimeSpecialName)
                    return false;
                if (field.IsLiteral && field.DeclaringType.IsEnum)
                    return false;

                else
                    return true;
            }
            public static bool CanRename(EventDef ev)
            {
                if (ev.IsRuntimeSpecialName)
                    return false;
                else
                    return true;
            }
        }


        public void ProtectionPhase(SpectreContext spctx)
        {
            RenameMode mode = RenameMode.UNREADABLE;
            foreach (ModuleDef module in spctx.Assembly.Modules)
            {
                foreach (TypeDef type in module.Types)
                {
                    if (Utils.CanRename(type))
                        type.Name = Utils.GenerateName(mode);

                    foreach (MethodDef method in type.Methods)
                    {
                        if (Utils.CanRename(method))
                            method.Name = Utils.GenerateName(mode);

                        foreach (var param in method.Parameters)
                            param.Name = Utils.GenerateName(mode);
                    }
                    foreach (FieldDef field in type.Fields)
                        if (Utils.CanRename(field))
                            field.Name = Utils.GenerateName(mode);

                    foreach (EventDef eventf in type.Events)
                        if (Utils.CanRename(eventf))
                            eventf.Name = Utils.GenerateName(mode);

                }
            }
        }
    }
}



================================================
File: Obfuscator/Obfuscator/Protections/Constants/ConstantMutation.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuscator.Helpers;
using Obfuscator.Internal.Classes;
using Obfuscator.Internal.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Protections.Constants
{
    class ConstantMutation : IProtector

    {
        string IProtector.Name => "Constant Mutation";
        string IProtector.Descrption => "Will mutate all numeric values";
        string IProtector.ProtectionType => "Constant";

        private CilBody body;
        public void InjectPhase(SpectreContext spctx) { }


        public void ProtectionPhase(SpectreContext spctx)
        {
            foreach (ModuleDef module in spctx.Assembly.Modules)
            {
                foreach (TypeDef type in module.Types)
                {
                    foreach (MethodDef method in type.Methods)
                    {
                        if (!method.HasBody) continue;
                        if (method.HasBody) if (!method.Body.HasInstructions) continue;

                        body = method.Body;
                        for (int i = 0; i < body.Instructions.Count; i++)
                        {
                            if (body.Instructions[i].IsLdcI4())
                            {
                                Mutate(spctx, method, i);
                                i += 2;
                            }

                        }
                        body.SimplifyBranches();
                        body.OptimizeBranches();

                    }
                }
            }
        }
        private void Mutate(SpectreContext spctx, MethodDef method, int i)
        {
            body = method.Body;
            int rndkey = LeetRandom.rnd.Next(0, int.MaxValue);
            int newoperand = body.Instructions[i].GetLdcI4Value() + rndkey;
            body.Instructions[i] = Instruction.CreateLdcI4(newoperand);
            body.Instructions.Insert(i + 1, Instruction.CreateLdcI4(rndkey));
            body.Instructions.Insert(i + 2, OpCodes.Sub.ToInstruction());

        }


    }
}



================================================
File: Obfuscator/Obfuscator/Protections/Constants/ConstantProtection.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Obfuscator.Helpers;
using Obfuscator.Internal.Classes;
using Obfuscator.Internal.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Protections.Constants
{
    class ConstantProtection : IProtector
    {
        string IProtector.Name => "ConstantProtection";
        string IProtector.Descrption => "Will encode all numeric and string values";
        string IProtector.ProtectionType => "Constant";



        private CilBody body;
        private MethodDef decryptionmethod;
        public void InjectPhase(SpectreContext spctx) {

            ModuleDefMD typeModule = ModuleDefMD.Load(typeof(Runtime.ConstantRuntime).Module);
            TypeDef typeDef = typeModule.ResolveTypeDef(MDToken.ToRID(typeof(Runtime.ConstantRuntime).MetadataToken));
            IEnumerable<IDnlibDef> members = InjectHelper.Inject(typeDef, spctx.GlobalType, spctx.ManifestModule);

            decryptionmethod = (MethodDef)members.Single(method => method.Name == "DecodeNum");

        }



        public void ProtectionPhase(SpectreContext spctx)
        {
            foreach (ModuleDef module in spctx.Assembly.Modules)
            {
                foreach (TypeDef type in module.Types)
                {
                    foreach (MethodDef method in type.Methods)
                    {
                        if (!method.HasBody) continue;
                        if (method.HasBody) if (!method.Body.HasInstructions) continue;

                        body = method.Body;
                        for (int i = 0; i < body.Instructions.Count; i++)
                        {
                            if (body.Instructions[i].IsLdcI4())
                            {
                                EncodeNumeric(spctx,method, i);
                                i += 2;
                            }

                        }
                        body.SimplifyBranches();
                        body.OptimizeBranches();

                    }
                }
            }
        }

      
        private void EncodeNumeric(SpectreContext spctx, MethodDef method, int i)
        {
            body = method.Body;
            int key = LeetRandom.rnd.Next(0, int.MaxValue);

            FieldDef field = new FieldDefUser(Guid.NewGuid().ToString(), new FieldSig(spctx.ManifestModule.CorLibTypes.Int32), FieldAttributes.Public | FieldAttributes.Static);
            //Add Field
            spctx.GlobalType.Fields.Add(field);
            int cctorbdycount = spctx.cctor.Body.Instructions.Count;
            //Init Field
            spctx.cctor.Body.Instructions.Insert(cctorbdycount - 1, Instruction.Create(OpCodes.Stsfld, field));
            spctx.cctor.Body.Instructions.Insert(cctorbdycount - 1, Instruction.CreateLdcI4(key));

            int operand = body.Instructions[i].GetLdcI4Value();
            int newoperand = EncodeNum(operand, key);
            body.Instructions[i] = Instruction.CreateLdcI4(newoperand);
            body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Ldsfld, field)); // insert int field
            body.Instructions.Insert(i + 2, Instruction.Create(OpCodes.Call, decryptionmethod));

        }

        private unsafe int EncodeNum(int num, int key)
        {

            int sub = sizeof(DateTime) - sizeof(TimeSpan);
            int num2 = num - sub;
            int xored = num ^ key;

            return xored;

        }

    }
}



================================================
File: Obfuscator/Obfuscator/Runtime/ConstantRuntime.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Obfuscator.Runtime
{
    public static class ConstantRuntime
    {
        public static unsafe int DecodeNum(int num, int key)
        {
            int sub = sizeof(DateTime) - sizeof(TimeSpan);
            int num2 = num + sub;
            int xored = num ^ key;

            return xored;

        }
    }
}




================================================
File: Obfuscator/Obfuscator/obj/Debug/App.baml
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/App.g.cs
================================================
ï»¿#pragma checksum "..\..\App.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "F78B621A7A9663F04D24FE07BBE170A2040514D5"
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Obfuscator;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace Obfuscator {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            
            #line 5 "..\..\App.xaml"
            this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
            System.Uri resourceLocater = new System.Uri("/Obfuscator;component/app.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\App.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public static void Main() {
            Obfuscator.App app = new Obfuscator.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}




================================================
File: Obfuscator/Obfuscator/obj/Debug/App.g.i.cs
================================================
ï»¿#pragma checksum "..\..\App.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "F78B621A7A9663F04D24FE07BBE170A2040514D5"
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Obfuscator;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace Obfuscator {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            
            #line 5 "..\..\App.xaml"
            this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
            System.Uri resourceLocater = new System.Uri("/Obfuscator;component/app.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\App.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public static void Main() {
            Obfuscator.App app = new Obfuscator.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}




================================================
File: Obfuscator/Obfuscator/obj/Debug/DesignTimeResolveAssemblyReferences.cache
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/DesignTimeResolveAssemblyReferencesInput.cache
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/MainWindow.baml
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/MainWindow.g.cs
================================================
ï»¿#pragma checksum "..\..\MainWindow.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "DF8416A55B5249F30464486263A2B3C1B3A2616D"
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Obfuscator;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace Obfuscator {
    
    
    /// <summary>
    /// MainWindow
    /// </summary>
    public partial class MainWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector, System.Windows.Markup.IStyleConnector {
        
        
        #line 1 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal Obfuscator.MainWindow w;
        
        #line default
        #line hidden
        
        
        #line 42 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.ListView lvassemblys;
        
        #line default
        #line hidden
        
        
        #line 55 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnDel;
        
        #line default
        #line hidden
        
        
        #line 56 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.TextBox tbout;
        
        #line default
        #line hidden
        
        
        #line 57 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnOfd;
        
        #line default
        #line hidden
        
        
        #line 65 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnRenamer;
        
        #line default
        #line hidden
        
        
        #line 71 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnEnableConstantProtection;
        
        #line default
        #line hidden
        
        
        #line 72 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnEnableConstantMutation;
        
        #line default
        #line hidden
        
        
        #line 78 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnAntiILDasm;
        
        #line default
        #line hidden
        
        /// <summary>
        /// rtlog Name Field
        /// </summary>
        
        #line 87 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        public System.Windows.Controls.RichTextBox rtlog;
        
        #line default
        #line hidden
        
        
        #line 94 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnObf;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/Obfuscator;component/mainwindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\MainWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            this.w = ((Obfuscator.MainWindow)(target));
            return;
            case 2:
            this.lvassemblys = ((System.Windows.Controls.ListView)(target));
            
            #line 42 "..\..\MainWindow.xaml"
            this.lvassemblys.Drop += new System.Windows.DragEventHandler(this.lvassemblys_Drop);
            
            #line default
            #line hidden
            return;
            case 4:
            this.btnDel = ((System.Windows.Controls.Button)(target));
            
            #line 55 "..\..\MainWindow.xaml"
            this.btnDel.Click += new System.Windows.RoutedEventHandler(this.btnDel_Click);
            
            #line default
            #line hidden
            return;
            case 5:
            this.tbout = ((System.Windows.Controls.TextBox)(target));
            return;
            case 6:
            this.btnOfd = ((System.Windows.Controls.Button)(target));
            
            #line 57 "..\..\MainWindow.xaml"
            this.btnOfd.Click += new System.Windows.RoutedEventHandler(this.btnOfd_Click);
            
            #line default
            #line hidden
            return;
            case 7:
            this.btnRenamer = ((System.Windows.Controls.Button)(target));
            
            #line 65 "..\..\MainWindow.xaml"
            this.btnRenamer.Click += new System.Windows.RoutedEventHandler(this.btnRenamer_Click);
            
            #line default
            #line hidden
            return;
            case 8:
            this.btnEnableConstantProtection = ((System.Windows.Controls.Button)(target));
            
            #line 71 "..\..\MainWindow.xaml"
            this.btnEnableConstantProtection.Click += new System.Windows.RoutedEventHandler(this.btnEnableConstantProtection_Click);
            
            #line default
            #line hidden
            return;
            case 9:
            this.btnEnableConstantMutation = ((System.Windows.Controls.Button)(target));
            
            #line 72 "..\..\MainWindow.xaml"
            this.btnEnableConstantMutation.Click += new System.Windows.RoutedEventHandler(this.btnEnableConstantMutation_Click);
            
            #line default
            #line hidden
            return;
            case 10:
            this.btnAntiILDasm = ((System.Windows.Controls.Button)(target));
            
            #line 78 "..\..\MainWindow.xaml"
            this.btnAntiILDasm.Click += new System.Windows.RoutedEventHandler(this.btnAntiILDasm_Click);
            
            #line default
            #line hidden
            return;
            case 11:
            this.rtlog = ((System.Windows.Controls.RichTextBox)(target));
            return;
            case 12:
            this.btnObf = ((System.Windows.Controls.Button)(target));
            
            #line 94 "..\..\MainWindow.xaml"
            this.btnObf.Click += new System.Windows.RoutedEventHandler(this.btnObf_Click);
            
            #line default
            #line hidden
            return;
            }
            this._contentLoaded = true;
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        void System.Windows.Markup.IStyleConnector.Connect(int connectionId, object target) {
            System.Windows.EventSetter eventSetter;
            switch (connectionId)
            {
            case 3:
            eventSetter = new System.Windows.EventSetter();
            eventSetter.Event = System.Windows.UIElement.PreviewMouseLeftButtonDownEvent;
            
            #line 50 "..\..\MainWindow.xaml"
            eventSetter.Handler = new System.Windows.Input.MouseButtonEventHandler(this.ListViewItem_PreviewMouseLeftButtonDown);
            
            #line default
            #line hidden
            ((System.Windows.Style)(target)).Setters.Add(eventSetter);
            break;
            }
        }
    }
}




================================================
File: Obfuscator/Obfuscator/obj/Debug/MainWindow.g.i.cs
================================================
ï»¿#pragma checksum "..\..\MainWindow.xaml" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "DF8416A55B5249F30464486263A2B3C1B3A2616D"
//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using Obfuscator;
using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace Obfuscator {
    
    
    /// <summary>
    /// MainWindow
    /// </summary>
    public partial class MainWindow : System.Windows.Window, System.Windows.Markup.IComponentConnector, System.Windows.Markup.IStyleConnector {
        
        
        #line 1 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal Obfuscator.MainWindow w;
        
        #line default
        #line hidden
        
        
        #line 42 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.ListView lvassemblys;
        
        #line default
        #line hidden
        
        
        #line 55 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnDel;
        
        #line default
        #line hidden
        
        
        #line 56 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.TextBox tbout;
        
        #line default
        #line hidden
        
        
        #line 57 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnOfd;
        
        #line default
        #line hidden
        
        
        #line 65 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnRenamer;
        
        #line default
        #line hidden
        
        
        #line 71 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnEnableConstantProtection;
        
        #line default
        #line hidden
        
        
        #line 72 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnEnableConstantMutation;
        
        #line default
        #line hidden
        
        
        #line 78 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnAntiILDasm;
        
        #line default
        #line hidden
        
        /// <summary>
        /// rtlog Name Field
        /// </summary>
        
        #line 87 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        public System.Windows.Controls.RichTextBox rtlog;
        
        #line default
        #line hidden
        
        
        #line 94 "..\..\MainWindow.xaml"
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        internal System.Windows.Controls.Button btnObf;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/Obfuscator;component/mainwindow.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\MainWindow.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            this.w = ((Obfuscator.MainWindow)(target));
            return;
            case 2:
            this.lvassemblys = ((System.Windows.Controls.ListView)(target));
            
            #line 42 "..\..\MainWindow.xaml"
            this.lvassemblys.Drop += new System.Windows.DragEventHandler(this.lvassemblys_Drop);
            
            #line default
            #line hidden
            return;
            case 4:
            this.btnDel = ((System.Windows.Controls.Button)(target));
            
            #line 55 "..\..\MainWindow.xaml"
            this.btnDel.Click += new System.Windows.RoutedEventHandler(this.btnDel_Click);
            
            #line default
            #line hidden
            return;
            case 5:
            this.tbout = ((System.Windows.Controls.TextBox)(target));
            return;
            case 6:
            this.btnOfd = ((System.Windows.Controls.Button)(target));
            
            #line 57 "..\..\MainWindow.xaml"
            this.btnOfd.Click += new System.Windows.RoutedEventHandler(this.btnOfd_Click);
            
            #line default
            #line hidden
            return;
            case 7:
            this.btnRenamer = ((System.Windows.Controls.Button)(target));
            
            #line 65 "..\..\MainWindow.xaml"
            this.btnRenamer.Click += new System.Windows.RoutedEventHandler(this.btnRenamer_Click);
            
            #line default
            #line hidden
            return;
            case 8:
            this.btnEnableConstantProtection = ((System.Windows.Controls.Button)(target));
            
            #line 71 "..\..\MainWindow.xaml"
            this.btnEnableConstantProtection.Click += new System.Windows.RoutedEventHandler(this.btnEnableConstantProtection_Click);
            
            #line default
            #line hidden
            return;
            case 9:
            this.btnEnableConstantMutation = ((System.Windows.Controls.Button)(target));
            
            #line 72 "..\..\MainWindow.xaml"
            this.btnEnableConstantMutation.Click += new System.Windows.RoutedEventHandler(this.btnEnableConstantMutation_Click);
            
            #line default
            #line hidden
            return;
            case 10:
            this.btnAntiILDasm = ((System.Windows.Controls.Button)(target));
            
            #line 78 "..\..\MainWindow.xaml"
            this.btnAntiILDasm.Click += new System.Windows.RoutedEventHandler(this.btnAntiILDasm_Click);
            
            #line default
            #line hidden
            return;
            case 11:
            this.rtlog = ((System.Windows.Controls.RichTextBox)(target));
            return;
            case 12:
            this.btnObf = ((System.Windows.Controls.Button)(target));
            
            #line 94 "..\..\MainWindow.xaml"
            this.btnObf.Click += new System.Windows.RoutedEventHandler(this.btnObf_Click);
            
            #line default
            #line hidden
            return;
            }
            this._contentLoaded = true;
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        void System.Windows.Markup.IStyleConnector.Connect(int connectionId, object target) {
            System.Windows.EventSetter eventSetter;
            switch (connectionId)
            {
            case 3:
            eventSetter = new System.Windows.EventSetter();
            eventSetter.Event = System.Windows.UIElement.PreviewMouseLeftButtonDownEvent;
            
            #line 50 "..\..\MainWindow.xaml"
            eventSetter.Handler = new System.Windows.Input.MouseButtonEventHandler(this.ListViewItem_PreviewMouseLeftButtonDown);
            
            #line default
            #line hidden
            ((System.Windows.Style)(target)).Setters.Add(eventSetter);
            break;
            }
        }
    }
}




================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator.Properties.Resources.resources
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator.csproj.CoreCompileInputs.cache
================================================
d51c522c6b69834bc6bead85bbfc540b4b82f6c1



================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator.csproj.FileListAbsolute.txt
================================================
C:\Users\lool\source\repos\Obfuscator\Obfuscator\bin\Debug\Obfuscator.exe.config
C:\Users\lool\source\repos\Obfuscator\Obfuscator\bin\Debug\Obfuscator.exe
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator.csprojResolveAssemblyReference.cache
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\MainWindow.g.cs
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\App.g.cs
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator_MarkupCompile.cache
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator_MarkupCompile.lref
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\MainWindow.baml
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator.g.resources
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator.Properties.Resources.resources
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator.csproj.GenerateResource.cache
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator.csproj.CoreCompileInputs.cache
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator.exe
C:\Users\lool\source\repos\Obfuscator\Obfuscator\bin\Debug\dnlib.dll
C:\Users\lool\source\repos\Obfuscator\Obfuscator\bin\Debug\dnlib.pdb
C:\Users\lool\source\repos\Obfuscator\Obfuscator\bin\Debug\dnlib.xml
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\Obfuscator.csproj.CopyComplete
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\App.baml



================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator.csproj.GenerateResource.cache
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator.csprojResolveAssemblyReference.cache
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator.g.resources
================================================
[Non-text file]


================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator_Content.g.i.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Windows.Resources.AssemblyAssociatedContentFileAttribute("specter.ico")]





================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator_MarkupCompile.cache
================================================
ï»¿Obfuscator


winexe
C#
.cs
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\
Obfuscator
none
false
DEBUG;TRACE
C:\Users\lool\source\repos\Obfuscator\Obfuscator\App.xaml
11151548125

19940835345
141717754218
MainWindow.xaml;

False




================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator_MarkupCompile.i.cache
================================================
ï»¿Obfuscator


winexe
C#
.cs
C:\Users\lool\source\repos\Obfuscator\Obfuscator\obj\Debug\
Obfuscator
none
false
DEBUG;TRACE
C:\Users\lool\source\repos\Obfuscator\Obfuscator\App.xaml
11151548125

23-1920099197
141717754218
MainWindow.xaml;

False




================================================
File: Obfuscator/Obfuscator/obj/Debug/Obfuscator_MarkupCompile.lref
================================================
ï»¿
FC:\Users\lool\source\repos\Obfuscator\Obfuscator\App.xaml;;
FC:\Users\lool\source\repos\Obfuscator\Obfuscator\MainWindow.xaml;;





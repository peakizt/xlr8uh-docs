Directory structure:
└── x64dbg-interobfu/
    ├── README.md
    ├── InterObfu.sln
    ├── LICENSE
    ├── install.bat
    ├── .editorconfig
    ├── InterObfu/
    │   ├── Assemble.h
    │   ├── Convert.cpp
    │   ├── Convert.h
    │   ├── Instruction.h
    │   ├── InterObfu.vcxproj
    │   ├── InterObfu.vcxproj.filters
    │   ├── Memory.h
    │   ├── Opcode.h
    │   ├── Operand.h
    │   ├── Pattern.h
    │   ├── Peephole.h
    │   ├── Register.h
    │   ├── Segment.h
    │   ├── State.h
    │   ├── ToString.cpp
    │   ├── Utils.h
    │   ├── Value.h
    │   ├── aho-corasick.h
    │   ├── main.cpp
    │   ├── XEDParse/
    │   │   └── XEDParse.h
    │   └── capstone_wrapper/
    └── hooks/
        ├── README.md
        ├── AStyle.dll.sig
        ├── AStyleWhore.exe.sig
        └── pre-commit

================================================
File: README.md
================================================
# InterObfu

Intermediate x86 instruction representation for use in obfuscation/deobfuscation.

**This code will probably be part of a paper, so please treat it with care.**


================================================
File: InterObfu.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "InterObfu", "InterObfu\InterObfu.vcxproj", "{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Debug|Win32.ActiveCfg = Debug|Win32
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Debug|Win32.Build.0 = Debug|Win32
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Debug|x64.ActiveCfg = Debug|x64
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Debug|x64.Build.0 = Debug|x64
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Release|Win32.ActiveCfg = Release|Win32
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Release|Win32.Build.0 = Release|Win32
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Release|x64.ActiveCfg = Release|x64
		{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: LICENSE
================================================
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.


================================================
File: install.bat
================================================
@echo off
echo Run this to install the auto-format hook.
copy hooks\pre-commit .git\hooks\pre-commit


================================================
File: .editorconfig
================================================
; Top-most EditorConfig file
root = true

; Windows-style newlines
[*]
end_of_line = CRLF

; Tab indentation
[*.{cpp,h}]
indent_style = space
tab_width = 4


================================================
File: InterObfu/Assemble.h
================================================
#pragma once

#include "Convert.h"
#include "XEDParse/XEDParse.h"

#ifdef _WIN64
#pragma comment(lib, "XEDParse/XEDParse_x64.lib")
#pragma comment(lib, "capstone_wrapper/capstone/capstone_x64.lib")
#else
#pragma comment(lib, "XEDParse/XEDParse_x86.lib")
#pragma comment(lib, "capstone_wrapper/capstone/capstone_x86.lib")
#endif //_WIN64

static Instruction Assemble(const std::string & text, int mode = 32, uint64_t addr = 0)
{
    Instruction result(X86_INS_NOP);
    XEDPARSE XEDParse;
    XEDParse.x64 = mode == 64;
    XEDParse.cip = addr;
    strncpy_s(XEDParse.instr, text.c_str(), _TRUNCATE);
    if(XEDParseAssemble(&XEDParse) == XEDPARSE_OK)
    {
        csh handle;
        if(cs_open(CS_ARCH_X86, mode == 32 ? CS_MODE_32 : CS_MODE_64, &handle) == CS_ERR_OK)
        {
            cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);
            const uint8_t* data = XEDParse.dest;
            cs_insn* insn = cs_malloc(handle);
            size_t codeSize = size_t(XEDParse.dest_size);
            uint64_t addr64 = addr;
            if(cs_disasm_iter(handle, &data, &codeSize, &addr64, insn))
                result = FromCapstone(insn);
            else
                puts("cs_disasm_iter failed!");
            cs_free(insn, 1);
            cs_close(&handle);
        }
        else
            puts("cs_open failed!");
    }
    else
        printf("XEDParse error: %s\n", XEDParse.error);
    return result;
}


================================================
File: InterObfu/Convert.cpp
================================================
#include "Convert.h"

std::unordered_map<std::string, Register::Registers> Converter::mstr2reg;
std::unordered_map<Register::Registers, std::string> Converter::mreg2str;
std::unordered_map<std::string, Opcode::Mnemonics> Converter::mstr2ins;
std::unordered_map<Opcode::Mnemonics, std::string> Converter::mins2str;

void Converter::init()
{
    csh handle;
    if(cs_open(CS_ARCH_X86, CS_MODE_32, &handle) == CS_ERR_OK)
    {
        for(auto i = 0; i < int(X86_REG_ENDING); i++)
        {
            if(i == X86_REG_INVALID)
                continue;
            auto regname = cs_reg_name(handle, i);
            if(!regname)
                __debugbreak(); //invalid register
            mstr2reg[regname] = Register::Registers(i);
            mreg2str[Register::Registers(i)] = regname;
        }

        for(auto i = 0; i < int(X86_INS_ENDING); i++)
        {
            if(i == X86_INS_INVALID)
                continue;
            auto insname = cs_insn_name(handle, i);
            if(!insname)
                __debugbreak(); //invalid instruction
            mstr2ins[insname] = Opcode::Mnemonics(i);
            mins2str[Opcode::Mnemonics(i)] = insname;
        }
    }
    cs_close(&handle);
}

Register::Registers Converter::str2reg(const std::string & str)
{
    return k2v(mstr2reg, str);
}

std::string Converter::reg2str(Register::Registers reg)
{
    return k2v(mreg2str, reg);
}

Opcode::Mnemonics Converter::str2ins(const std::string & str)
{
    return k2v(mstr2ins, str);
}

std::string Converter::ins2str(Opcode::Mnemonics ins)
{
    return k2v(mins2str, ins);
}


================================================
File: InterObfu/Convert.h
================================================
#pragma once

#include "Instruction.h"
#include "capstone_wrapper/capstone_wrapper.h"
#include <unordered_map>

class Converter
{
    Converter() = delete;

    static std::unordered_map<std::string, Register::Registers> mstr2reg;
    static std::unordered_map<Register::Registers, std::string> mreg2str;
    static std::unordered_map<std::string, Opcode::Mnemonics> mstr2ins;
    static std::unordered_map<Opcode::Mnemonics, std::string> mins2str;

    template<typename K, typename V>
    static V k2v(const std::unordered_map<K, V> & m, const K & k)
    {
        if(m.empty())
            __debugbreak(); //map not initialized
        auto found = m.find(k);
        return found == m.end() ? V() : found->second;
    }

public:
    static void init();
    static Register::Registers str2reg(const std::string & str);
    static std::string reg2str(Register::Registers reg);
    static Opcode::Mnemonics str2ins(const std::string & str);
    static std::string ins2str(Opcode::Mnemonics ins);
};

inline Register::Registers convertReg(x86_reg reg)
{
    if(int(X86_REG_R15W) != int(Register::R15W))
        __debugbreak();
    return Register::Registers(reg);
}

inline Segment::Segments convertSeg(x86_reg reg)
{
    switch(reg)
    {
    case X86_REG_INVALID:
        return Segment::INVALID;
    case X86_REG_CS:
        return Segment::CS;
    case X86_REG_SS:
        return Segment::SS;
    case X86_REG_DS:
        return Segment::DS;
    case X86_REG_ES:
        return Segment::ES;
    case X86_REG_FS:
        return Segment::FS;
    case X86_REG_GS:
        return Segment::GS;
    default:
        __debugbreak();
    }
    return Segment::INVALID;
}

inline Instruction FromCapstone(const cs_insn* insn)
{
    auto instr = Instruction(insn->id);
    auto detail = insn->detail;
    for(auto i = 0; i < detail->regs_read_count; i++)
        instr.regs_read.push_back(Register(convertReg(x86_reg(detail->regs_read[i]))));
    for(auto i = 0; i < detail->regs_write_count; i++)
        instr.regs_written.push_back(Register(convertReg(x86_reg(detail->regs_write[i]))));
    for(auto i = 0; i < detail->groups_count; i++)
        instr.groups.push_back(detail->groups[i]);
    const auto & x86 = detail->x86;
    memcpy(instr.prefix, x86.prefix, sizeof(instr.prefix));
    instr.address = insn->address;
    instr.size = insn->size;
    memcpy(instr.bytes, insn->bytes, sizeof(instr.bytes));
    instr.eflags = x86.eflags;
    instr.opCount = x86.op_count;
    for(auto i = 0; i < instr.opCount; i++)
    {
        const auto & op = x86.operands[i];
        switch(op.type)
        {
        case X86_OP_REG:
            instr.operands[i] = Operand(Register(convertReg(op.reg)));
            break;
        case X86_OP_IMM:
            instr.operands[i] = Operand(Value(op.imm));
            break;
        case X86_OP_MEM:
            instr.operands[i] = Operand(Memory(
                                            Segment(convertSeg(op.mem.segment)),
                                            Register(convertReg(op.mem.base)),
                                            Register(convertReg(op.mem.index)),
                                            Value(op.mem.scale),
                                            Value(op.mem.disp)));
            break;
        default:
            __debugbreak();
        }
        instr.operands[i].size = Value(op.size);
        instr.operands[i].access = op.access;
    }
    return instr;
}



================================================
File: InterObfu/Instruction.h
================================================
#pragma once

#include "Utils.h"
#include "Opcode.h"
#include "Value.h"
#include "Operand.h"

struct Instruction
{
    Opcode opcode;

    int opCount;
    Operand operands[4];

    std::vector<Register> regs_read;
    std::vector<Register> regs_written;
    std::vector<uint8_t> groups;
    uint8_t prefix[4];
    uint64_t address = 0;
    uint16_t size = 0;
    uint8_t bytes[16];
    uint64_t eflags = 0;

    CompareFunction<Instruction> compare = nullptr;

    explicit Instruction()
        : opCount(0) { }

    explicit Instruction(CompareFunction<Instruction> compare)
        : opCount(0), compare(compare) { }

    explicit Instruction(Opcode::Mnemonics mnem, int opCount = 0)
        : opcode(mnem),
          opCount(opCount) { }

    explicit Instruction(Opcode::Mnemonics mnem, Operand op1, Operand op2, Operand op3, Operand op4)
        : Instruction(mnem, 4)
    {
        operands[0] = op1;
        operands[1] = op2;
        operands[2] = op3;
        operands[3] = op4;
    }

    explicit Instruction(Opcode::Mnemonics mnem, Operand op1, Operand op2, Operand op3)
        : Instruction(mnem, 3)
    {
        operands[0] = op1;
        operands[1] = op2;
        operands[2] = op3;
    }

    explicit Instruction(Opcode::Mnemonics mnem, Operand op1, Operand op2)
        : Instruction(mnem, 2)
    {
        operands[0] = op1;
        operands[1] = op2;
    }

    explicit Instruction(Opcode::Mnemonics mnem, Operand op1)
        : Instruction(mnem, 1)
    {
        operands[0] = op1;
    }

    Operand & operator[](size_t index)
    {
#ifdef _DEBUG
        if(index >= _countof(operands) || index >= size_t(opCount))
            __debugbreak();
#endif //_DEBUG
        return operands[index];
    }

    const Operand & operator[](size_t index) const
    {
#ifdef _DEBUG
        if(index >= _countof(operands) || index >= size_t(opCount))
            __debugbreak();
#endif //_DEBUG
        return operands[index];
    }

    bool Equals(const Instruction & other, State & state) const
    {
        if(compare)
            return compare(*this, other, state);
        if(other.compare)
            return other.compare(other, *this, state);

        if(!opcode.Equals(other.opcode, state))
            return false;

        if(opCount != other.opCount)
            return false;
        for(auto i = 0; i < opCount; i++)
            if(!operands[i].Equals(other.operands[i], state))
                return false;
        return true;
    }

    bool operator==(const Instruction & other) const = delete;

    OPNEQ(Instruction);

    std::string ToString() const;
};



================================================
File: InterObfu/InterObfu.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C5291DA7-5AB6-4EBF-AFE5-57B153FD197D}</ProjectGuid>
    <RootNamespace>InterObfu</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="aho-corasick.h" />
    <ClInclude Include="Assemble.h" />
    <ClInclude Include="Convert.h" />
    <ClInclude Include="Instruction.h" />
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Opcode.h" />
    <ClInclude Include="Operand.h" />
    <ClInclude Include="Pattern.h" />
    <ClInclude Include="Peephole.h" />
    <ClInclude Include="Register.h" />
    <ClInclude Include="Segment.h" />
    <ClInclude Include="State.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="Value.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Convert.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="ToString.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: InterObfu/InterObfu.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Instruction.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Opcode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Operand.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Register.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Segment.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Value.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="State.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Pattern.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Convert.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="aho-corasick.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Peephole.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Assemble.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Convert.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ToString.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>


================================================
File: InterObfu/Memory.h
================================================
#pragma once

#include "Utils.h"
#include "Segment.h"

struct Memory
{
    Segment seg;
    Register base;
    Register index;
    Value scale; //TODO: is this the right way?
    Value disp;

    CompareFunction<Memory> compare = nullptr;

    explicit Memory() { }

    explicit Memory(CompareFunction<Memory> compare)
        : compare(compare) { }

    explicit Memory(Segment seg, Register base, Register index, Value scale, Value disp)
        : seg(seg),
          base(base),
          index(index),
          scale(scale),
          disp(disp) { }

    explicit Memory(Register base, Register index, Value scale, Value disp)
        : Memory(Segment(), base, index, scale, disp) { }

    explicit Memory(Value disp)
        : Memory(Register(), Register(), Value(), disp) { }

    bool Equals(const Memory & other, State & state) const
    {
        if(compare)
            return compare(*this, other, state);
        if(other.compare)
            return other.compare(other, *this, state);

        return seg.Equals(other.seg, state) &&
               base.Equals(other.base, state) &&
               index.Equals(other.index, state) &&
               scale.Equals(other.scale, state) &&
               disp.Equals(other.disp, state);
    }

    bool operator==(const Memory & other) const = delete;

    OPNEQ(Memory);

    std::string ToString() const;
};


================================================
File: InterObfu/Opcode.h
================================================
#pragma once

#include "Utils.h"

struct Opcode
{
    using Mnemonics = int;

    Mnemonics mnem;

    CompareFunction<Opcode> compare = nullptr;

    explicit Opcode()
        : mnem(0) { }

    explicit Opcode(CompareFunction<Opcode> compare)
        : mnem(0), compare(compare) { }

    explicit Opcode(Mnemonics mnem)
        : mnem(mnem) { }

    bool Equals(const Opcode & other, State & state) const
    {
        if(compare)
            return compare(*this, other, state);
        if(other.compare)
            return other.compare(other, *this, state);

        return mnem == other.mnem;
    }

    bool operator==(const Opcode & other) const = delete;

    OPNEQ(Opcode);

    std::string ToString() const;
};


================================================
File: InterObfu/Operand.h
================================================
#pragma once

#include "Utils.h"
#include "Register.h"
#include "Value.h"
#include "Memory.h"

struct Operand
{
    enum Types
    {
        Invalid,
        Reg,
        Imm,
        Mem
    };

    Types type;
    Register reg;
    Value imm;
    Memory mem;

    Value size;
    uint8_t access = 0;

    CompareFunction<Operand> compare = nullptr;

    explicit Operand()
        : type(Invalid) { }

    explicit Operand(CompareFunction<Operand> compare)
        : type(Invalid), compare(compare) { }

    explicit Operand(const Register & reg)
        : type(Reg),
          reg(reg) { }

    explicit Operand(Register::Registers reg)
        : Operand(Register(reg)) { }

    explicit Operand(const Value & imm)
        : type(Imm),
          imm(imm) { }

    explicit Operand(const Memory & mem)
        : type(Mem),
          mem(mem) { }

    bool Equals(const Operand & other, State & state) const
    {
        if(compare)
            return compare(*this, other, state);
        if(other.compare)
            return other.compare(other, *this, state);

        if(type != other.type)
            return false;
        switch(type)
        {
        case Invalid:
            return true;
        case Reg:
            return reg.Equals(other.reg, state);
        case Imm:
            return imm.Equals(other.imm, state);
        case Mem:
            return mem.Equals(other.mem, state);
        default:
            return false;
        }
    }

    bool operator==(const Operand & other) const = delete;

    OPNEQ(Operand);

    std::string ToString() const;
};


================================================
File: InterObfu/Pattern.h
================================================
#pragma once

#include "Instruction.h"
#include "State.h"
#include "Assemble.h"

struct Pattern
{
    int priority = 0;
    State state;
    std::vector<Instruction> instrs;
    std::vector<std::function<Instruction(const State &)>> repls;

    //This function append the replacement instructions to 'out'.
    //It should use state to replace the correct registers etc.
    bool Produce(std::vector<Instruction> & out) const
    {
        for(const auto & repl : repls)
            out.push_back(repl(state));
        return true;
    }

    int64_t Search(const std::vector<Instruction> & data, size_t start = 0)
    {
        state.Clear();
        if(instrs.size() > data.size() - start)
            return -1;
        for(size_t i = start, pos = 0; i < data.size(); i++)
        {
            if(data[i].Equals(instrs[pos], state))
            {
                pos++;
                if(pos == instrs.size())
                    return i - instrs.size() + 1;
            }
            else
            {
                i -= pos;
                pos = 0; //reset current pattern position
                state.Clear(); //clear the state
            }
        }
        return -1;
    }

    bool Match(const std::vector<Instruction> & data, size_t start)
    {
        state.Clear();
        if(instrs.size() > data.size() - start)
            return false;
        for(size_t i = start, pos = 0; i < data.size(); i++)
        {
            if(data[i].Equals(instrs[pos], state))
            {
                pos++;
                if(pos == instrs.size())
                    return true;
            }
            else
                break;
        }
        return false;
    }

    void Add(const Instruction & instr)
    {
        instrs.push_back(instr);
    }

    void Add(const std::string & instr, int mode = 32, uint64_t addr = 0)
    {
        instrs.push_back(Assemble(instr, mode, addr));
    }
};



================================================
File: InterObfu/Peephole.h
================================================
#pragma once

#include "Pattern.h"
#include "Convert.h"
#include "aho-corasick.h"
#include "Assemble.h"

class Peephole
{
public:
    explicit Peephole(std::vector<Pattern> & patterns)
        : mPatterns(patterns)
    {
        preprocessTrie();
    }

    bool Optimize(const std::vector<Instruction> & in, std::vector<Instruction> & out)
    {
        out.clear();
        if(in.empty()) //empty input cannot be optimized
            return false;

        //Use Aho-Corasick to find all mnemonic matches in O(n + r) with n = in.size(), r = results.size()
        auto results = mTrie.parse_text(preprocessIn(in));

        if(results.empty()) //no patterns found = not optimized
            return false;

        /*puts("results (unfiltered):");
        for(auto & r : results)
            printf("%u:%d-%d \"%s\"\n", r.get_index(), int(r.get_start()), int(r.get_end()), prettyPrint(r.get_keyword()).c_str());
        puts("");*/

        //This creates a map from (match start) -> (result index).
        //Before considering a result it is checked with a predicate.
        //On conflicting (match start) we use a predicate.

        auto validPredicate = [this, &in](const aho_corasick::emit<Mnem> & result) //is r a valid result?
        {
            //Check the wildcard pattern in O(m) with m = r.size()
            return mPatterns[result.get_index()].Match(in, result.get_start());
        };

        auto betterPredicate = [this](const aho_corasick::emit<Mnem> & a, const aho_corasick::emit<Mnem> & b) //is a better than b?
        {
            //make sure to first compare on equality and if not, return the compare

            if(a.size() != b.size()) //longer patterns are always better
                return a.size() > b.size();

            if(a.get_start() != b.get_start()) //patterns that start earlier are better
                return a.get_start() < b.get_start();

            const auto & pa = mPatterns.at(a.get_index());
            const auto & pb = mPatterns.at(b.get_index());
            if(pa.priority != pb.priority) //patterns with higher priority are better
                return pa.priority > pb.priority;

            if(pa.repls.size() != pb.repls.size()) //shorter replacements are better
                return pa.repls.size() < pb.repls.size();

            return false; //both patterns are equal
        };

        //Drop fake matches (mnemonic only, not operands) in O(r * x) with r = results.size(), x = max(results[i].size())
        std::unordered_map<size_t, size_t> best;
        best.reserve(results.size());
        for(size_t i = 0; i < results.size(); i++)
        {
            const auto & result = results.at(i);
            if(!validPredicate(result)) //skip invalid results
                continue;
            auto found = best.find(result.get_start());
            if(found == best.end()) //add the current result if not found
                best[result.get_start()] = i;
            else if(betterPredicate(result, results[found->second])) //replace if the current result better
                found->second = i;
        }

        if(best.empty()) //no patterns found = not optimized
            return false;

        /*puts("results (filtered):");
        for(const auto & it : best)
        {
            const auto & r = results[it.second];
            printf("%u:%d-%d \"%s\"\n", r.get_index(), int(r.get_start()), int(r.get_end()), prettyPrint(r.get_keyword()).c_str());
        }
        puts("");*/

        //Construct the output in O(i) with i = in.size()
        //TODO: if patterns overlap the first is taken and the overlaps are ignored
        out.reserve(in.size());
        for(size_t i = 0; i < in.size();)
        {
            auto found = best.find(i);
            if(found != best.end()) //current instruction is the start of a match
            {
                const auto & result = results.at(found->second);
                auto & pattern = mPatterns[result.get_index()];
                pattern.Match(in, i); //match to get the correct state
                std::vector<Instruction> product;
                if(!pattern.Produce(product))
                    __debugbreak(); //pattern replacement production failure (invalid pattern?)
                for(const auto & p : product)
                    out.push_back(p);
                i += pattern.instrs.size();
            }
            else //current instruction is not the start of a match
                out.push_back(in.at(i++));
        }

        return true;
    }

private:
    using Mnem = Opcode::Mnemonics;

    std::vector<Pattern> & mPatterns;
    aho_corasick::basic_trie<Mnem> mTrie;

    static std::string prettyPrint(const std::basic_string<Mnem> & keyword)
    {
        std::string result;
        for(auto & mnem : keyword)
        {
            if(!result.empty())
                result.push_back(';');
            result.append(Converter::ins2str(mnem));
        }
        return result;
    }

    static std::basic_string<Mnem> preprocessIn(const std::vector<Instruction> & in)
    {
        std::basic_string<Mnem> text;
        text.resize(in.size());
        for(size_t i = 0; i < in.size(); i++)
        {
            if(in[i].opcode.mnem == X86_INS_INVALID)
                __debugbreak(); //wildcards are not allowed
            text[i] = in[i].opcode.mnem;
        }
        return text;
    }

    void preprocessTrie()
    {
        //Construct the Aho-Corasick trie in O(m) with m = mPatterns.size()
        std::basic_string<Mnem> keyword;
        for(const auto & pattern : mPatterns)
        {
            keyword.clear();
            for(const auto & instr : pattern.instrs)
            {
                if(instr.opcode.mnem == X86_INS_INVALID)
                    __debugbreak(); //wildcards are not allowed
                keyword.push_back(instr.opcode.mnem);
            }
            mTrie.insert(keyword);
        }
    }
};



================================================
File: InterObfu/Register.h
================================================
#pragma once

#include "Utils.h"

struct Register
{
    enum Registers
    {
        INVALID = 0,
        AH, AL, AX, BH, BL,
        BP, BPL, BX, CH, CL,
        CS, CX, DH, DI, DIL,
        DL, DS, DX, EAX, EBP,
        EBX, ECX, EDI, EDX, EFLAGS,
        EIP, EIZ, ES, ESI, ESP,
        FPSW, FS, GS, IP, RAX,
        RBP, RBX, RCX, RDI, RDX,
        RIP, RIZ, RSI, RSP, SI,
        SIL, SP, SPL, SS, CR0,
        CR1, CR2, CR3, CR4, CR5,
        CR6, CR7, CR8, CR9, CR10,
        CR11, CR12, CR13, CR14, CR15,
        DR0, DR1, DR2, DR3, DR4,
        DR5, DR6, DR7, DR8, DR9,
        DR10, DR11, DR12, DR13, DR14,
        DR15, FP0, FP1, FP2, FP3,
        FP4, FP5, FP6, FP7,
        K0, K1, K2, K3, K4,
        K5, K6, K7, MM0, MM1,
        MM2, MM3, MM4, MM5, MM6,
        MM7, R8, R9, R10, R11,
        R12, R13, R14, R15,
        ST0, ST1, ST2, ST3,
        ST4, ST5, ST6, ST7,
        XMM0, XMM1, XMM2, XMM3, XMM4,
        XMM5, XMM6, XMM7, XMM8, XMM9,
        XMM10, XMM11, XMM12, XMM13, XMM14,
        XMM15, XMM16, XMM17, XMM18, XMM19,
        XMM20, XMM21, XMM22, XMM23, XMM24,
        XMM25, XMM26, XMM27, XMM28, XMM29,
        XMM30, XMM31, YMM0, YMM1, YMM2,
        YMM3, YMM4, YMM5, YMM6, YMM7,
        YMM8, YMM9, YMM10, YMM11, YMM12,
        YMM13, YMM14, YMM15, YMM16, YMM17,
        YMM18, YMM19, YMM20, YMM21, YMM22,
        YMM23, YMM24, YMM25, YMM26, YMM27,
        YMM28, YMM29, YMM30, YMM31, ZMM0,
        ZMM1, ZMM2, ZMM3, ZMM4, ZMM5,
        ZMM6, ZMM7, ZMM8, ZMM9, ZMM10,
        ZMM11, ZMM12, ZMM13, ZMM14, ZMM15,
        ZMM16, ZMM17, ZMM18, ZMM19, ZMM20,
        ZMM21, ZMM22, ZMM23, ZMM24, ZMM25,
        ZMM26, ZMM27, ZMM28, ZMM29, ZMM30,
        ZMM31, R8B, R9B, R10B, R11B,
        R12B, R13B, R14B, R15B, R8D,
        R9D, R10D, R11D, R12D, R13D,
        R14D, R15D, R8W, R9W, R10W,
        R11W, R12W, R13W, R14W, R15W,
        ENDING
    };

    Registers reg;

    CompareFunction<Register> compare = nullptr;

    explicit Register()
        : reg(INVALID) { }

    explicit Register(CompareFunction<Register> compare)
        : reg(INVALID), compare(compare) { }

    explicit Register(Registers reg)
        : reg(reg) { }

    bool Equals(const Register & other, State & state) const
    {
        if(compare)
            return compare(*this, other, state);
        if(other.compare)
            return other.compare(other, *this, state);

        return reg == other.reg;
    }

    bool operator==(const Register & other) const = delete;

    OPNEQ(Register);

    std::string ToString() const;

    int Size() const
    {
        switch(reg)
        {
        case RAX:
        case RBX:
        case RCX:
        case RDX:
        case RBP:
        case RSP:
        case RSI:
        case RDI:
        case R8:
        case R9:
        case R10:
        case R11:
        case R12:
        case R13:
        case R14:
        case R15:
            return sizeof(uint64_t);
        case EAX:
        case EBX:
        case ECX:
        case EDX:
        case EBP:
        case ESP:
        case ESI:
        case EDI:
        case R8D:
        case R9D:
        case R10D:
        case R11D:
        case R12D:
        case R13D:
        case R14D:
        case R15D:
            return sizeof(uint32_t);
        case AX:
        case BX:
        case CX:
        case DX:
        case BP:
        case SP:
        case SI:
        case DI:
        case R8W:
        case R9W:
        case R10W:
        case R11W:
        case R12W:
        case R13W:
        case R14W:
        case R15W:
            return sizeof(uint16_t);
        case AH:
        case AL:
        case BH:
        case BL:
        case CH:
        case CL:
        case DH:
        case DL:
        case BPL:
        case SPL:
        case SIL:
        case DIL:
        case R8B:
        case R9B:
        case R10B:
        case R11B:
        case R12B:
        case R13B:
        case R14B:
        case R15B:
            return sizeof(uint8_t);
        default:
            __debugbreak();
        }
        return 0;
    }

    int Offset() const
    {
        switch(reg)
        {
        case AH:
        case BH:
        case CH:
        case DH:
            return 1;
        default:
            return 0;
        }
    }
};


================================================
File: InterObfu/Segment.h
================================================
#pragma once

#include "Utils.h"

struct Segment
{
    enum Segments
    {
        INVALID,
        CS,
        SS,
        DS,
        ES,
        FS,
        GS
    };

    Segments seg;

    CompareFunction<Segment> compare = nullptr;

    explicit Segment()
        : seg(INVALID) { }

    explicit Segment(Segments seg)
        : seg(seg) { }

    explicit Segment(CompareFunction<Segment> compare)
        : seg(INVALID), compare(compare) { }

    bool Equals(const Segment & other, State & state) const
    {
        if(compare)
            return compare(*this, other, state);
        if(other.compare)
            return other.compare(other, *this, state);

        return seg == other.seg;
    }

    bool operator==(const Segment & other) const = delete;

    OPNEQ(Segment);

    std::string ToString() const;
};


================================================
File: InterObfu/State.h
================================================
#pragma once

#include "Opcode.h"
#include "Memory.h"
#include "Value.h"
#include "Register.h"

template<typename T>
static bool Wildcard(const T &, const T &, State &)
{
    return true;
}

struct State
{
    template<typename T>
    struct StateValue
    {
        explicit StateValue()
            : set(false) { }

        explicit StateValue(const T & value)
            : set(true), val(value) { }

        operator bool() const
        {
            return set;
        }

        T & operator=(const T & value)
        {
            set = true;
            return val = value;
        }

        const T & operator()() const
        {
            return val;
        }

        bool Equals(const T & other, State & state) const
        {
            return val.Equals(other, state);
        }

        bool operator==(const T & other) const = delete;

        OPNEQ(T);

    private:
        bool set;
        T val;
    };

    static const int MaxStateCount = 4;

    StateValue<Operand> operands[MaxStateCount];
    StateValue<Register> registers[MaxStateCount];
    StateValue<Value> values[MaxStateCount];
    StateValue<Memory> memorys[MaxStateCount];
    StateValue<Opcode> opcodes[MaxStateCount];

    explicit State()
    {
        Clear();
    }

    void Clear()
    {
        for(auto i = 0; i < MaxStateCount; i++)
        {
            operands[i] = StateValue<Operand>();
            registers[i] = StateValue<Register>();
            values[i] = StateValue<Value>();
            memorys[i] = StateValue<Memory>();
            opcodes[i] = StateValue<Opcode>();
        }
    }

    static CompareFunction<Segment> SegWild()
    {
        return Wildcard<Segment>;
    }

    static CompareFunction<Register> RegWild()
    {
        return Wildcard<Register>;
    }

    static CompareFunction<Value> ValWild()
    {
        return Wildcard<Value>;
    }

    static CompareFunction<Operand> MakeOperandN(int index)
    {
        return [index](const Operand & aThis, const Operand & bOther, State & state)
        {
            if(state.operands[index]) //already matched before
                return state.operands[index].Equals(bOther, state);
            state.operands[index] = bOther;
            return true;
        };
    }

    static CompareFunction<Register> MakeRegisterN(int index)
    {
        return [index](const Register & aThis, const Register & bOther, State & state)
        {
            if(state.registers[index]) //already matched before
                return state.registers[index].Equals(bOther, state);
            state.registers[index] = bOther;
            return true;
        };
    }

    static CompareFunction<Register> MakeRegisterSize(int bitsize)
    {
        return [bitsize](const Register & aThis, const Register & bOther, State & state)
        {
            return bOther.Size() * 8 == bitsize;
        };
    }

    static CompareFunction<Memory> MakeMemoryN(int index)
    {
        return [index](const Memory & aThis, const Memory & bOther, State & state)
        {
            if(state.memorys[index]) //already matched before
                return state.memorys[index].Equals(bOther, state);
            state.memorys[index] = bOther;
            return true;
        };
    }

    static CompareFunction<Value> MakeValueN(int index)
    {
        return [index](const Value & aThis, const Value & bOther, State & state)
        {
            if(state.values[index]) //already matched before
                return state.values[index].Equals(bOther, state);
            state.values[index] = bOther;
            return true;
        };
    }

    static CompareFunction<Opcode> MakeOpcodeN(int index)
    {
        return [index](const Opcode & aThis, const Opcode & bOther, State & state)
        {
            if(state.opcodes[index]) //already matched before
                return state.opcodes[index].Equals(bOther, state);
            state.opcodes[index] = bOther;
            return true;
        };
    }

    static CompareFunction<Opcode> MakeOpcodeList(int opIndex, const std::vector<Opcode::Mnemonics> & possible)
    {
        return [opIndex, possible](const Opcode & aThis, const Opcode & bOther, State & state)
        {
            if(!state.opcodes[opIndex]) //didn't match yet
            {
                for(auto & mnem : possible)
                {
                    if(mnem == bOther.mnem)
                    {
                        state.opcodes[opIndex] = bOther;
                        return true;
                    }
                }
                return false;
            }
            else //matched before
                return true;
        };
    }
};



================================================
File: InterObfu/ToString.cpp
================================================
#include "Instruction.h"
#include "Convert.h"

std::string Value::ToString() const
{
    char value[31] = "";
    sprintf_s(value, "0x%llX", val);
    return value;
}

std::string Segment::ToString() const
{
    switch(seg)
    {
    case CS:
        return "cs";
    case SS:
        return "ss";
    case DS:
        return "ds";
    case ES:
        return "es";
    case FS:
        return "fs";
    case GS:
        return "gs";
    default:
        return "?";
    }
}

std::string Register::ToString() const
{
    auto str = Converter::reg2str(reg);
    return str.empty() ? "?" : str;
}

std::string Opcode::ToString() const
{
    auto str = Converter::ins2str(mnem);
    return str.empty() ? "?" : str;
}

std::string Memory::ToString() const
{
    std::string str;
    str.push_back('[');
    str.append(base.ToString());
    str.push_back('+');
    str.append(index.ToString());
    str.push_back('*');
    str.append(scale.ToString());
    str.push_back('+');
    str.append(disp.ToString());
    str.push_back(']');
    return str;
}

std::string Operand::ToString() const
{
    switch(type)
    {
    case Reg:
        return reg.ToString();
    case Imm:
        return imm.ToString();
    case Mem:
        return mem.ToString();
    default:
        return "?";
    }
}

std::string Instruction::ToString() const
{
    std::string str;
    str.append(opcode.ToString());

    if(opCount)
        str.push_back(' ');
    for(auto i = 0; i < opCount; i++)
    {
        if(i)
        {
            str.push_back(',');
            str.push_back(' ');
        }
        str.append(operands[i].ToString());
    }
    return str;
}








================================================
File: InterObfu/Utils.h
================================================
#pragma once

#include <functional>
#include <vector>

struct State;

template<typename T>
using CompareFunction = std::function<bool(const T &, const T &, State &)>;

#define OPNEQ(T) bool operator!=(const T & other) const = delete


================================================
File: InterObfu/Value.h
================================================
#pragma once

#include <stdint.h>
#include "Utils.h"

struct Value
{
    int64_t val;
    CompareFunction<Value> compare = nullptr;

    explicit Value()
        : val(0) { }

    explicit Value(CompareFunction<Value> compare)
        : val(0), compare(compare) { }

    explicit Value(int64_t val)
        : val(val) { }

    bool Equals(const Value & other, State & state) const
    {
        if(compare)
            return compare(*this, other, state);
        if(other.compare)
            return other.compare(other, *this, state);

        return val == other.val;
    }

    bool operator==(const Value & other) const = delete;

    OPNEQ(Value);

    std::string ToString() const;
};


================================================
File: InterObfu/aho-corasick.h
================================================
/*
* Copyright (C) 2015 Christopher Gilbert.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

//Taken from: https://github.com/blockchaindev/aho_corasick

#ifndef AHO_CORASICK_HPP
#define AHO_CORASICK_HPP

#include <algorithm>
#include <cctype>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <queue>
#include <utility>
#include <vector>

namespace aho_corasick
{

    // class interval
    class interval
    {
        size_t d_start;
        size_t d_end;

    public:
        interval(size_t start, size_t end)
            : d_start(start)
            , d_end(end) {}

        size_t get_start() const { return d_start; }
        size_t get_end() const { return d_end; }
        size_t size() const { return d_end - d_start + 1; }

        bool overlaps_with(const interval & other) const
        {
            return d_start <= other.d_end && d_end >= other.d_start;
        }

        bool overlaps_with(size_t point) const
        {
            return d_start <= point && point <= d_end;
        }

        bool operator <(const interval & other) const
        {
            return get_start() < other.get_start();
        }

        bool operator !=(const interval & other) const
        {
            return get_start() != other.get_start() || get_end() != other.get_end();
        }

        bool operator ==(const interval & other) const
        {
            return get_start() == other.get_start() && get_end() == other.get_end();
        }
    };

    // class interval_tree
    template<typename T>
    class interval_tree
    {
    public:
        using interval_collection = std::vector<T>;

    private:
        // class node
        class node
        {
            enum direction
            {
                LEFT, RIGHT
            };
            using node_ptr = std::unique_ptr<node>;

            size_t              d_point;
            node_ptr            d_left;
            node_ptr            d_right;
            interval_collection d_intervals;

        public:
            node(const interval_collection & intervals)
                : d_point(0)
                , d_left(nullptr)
                , d_right(nullptr)
                , d_intervals()
            {
                d_point = determine_median(intervals);
                interval_collection to_left, to_right;
                for(const auto & i : intervals)
                {
                    if(i.get_end() < d_point)
                    {
                        to_left.push_back(i);
                    }
                    else if(i.get_start() > d_point)
                    {
                        to_right.push_back(i);
                    }
                    else
                    {
                        d_intervals.push_back(i);
                    }
                }
                if(to_left.size() > 0)
                {
                    d_left.reset(new node(to_left));
                }
                if(to_right.size() > 0)
                {
                    d_right.reset(new node(to_right));
                }
            }

            size_t determine_median(const interval_collection & intervals) const
            {
                size_t start = -1;
                size_t end = -1;
                for(const auto & i : intervals)
                {
                    size_t cur_start = i.get_start();
                    size_t cur_end = i.get_end();
                    if(start == -1 || cur_start < start)
                    {
                        start = cur_start;
                    }
                    if(end == -1 || cur_end > end)
                    {
                        end = cur_end;
                    }
                }
                return (start + end) / 2;
            }

            interval_collection find_overlaps(const T & i)
            {
                interval_collection overlaps;
                if(d_point < i.get_start())
                {
                    add_to_overlaps(i, overlaps, find_overlapping_ranges(d_right, i));
                    add_to_overlaps(i, overlaps, check_right_overlaps(i));
                }
                else if(d_point > i.get_end())
                {
                    add_to_overlaps(i, overlaps, find_overlapping_ranges(d_left, i));
                    add_to_overlaps(i, overlaps, check_left_overlaps(i));
                }
                else
                {
                    add_to_overlaps(i, overlaps, d_intervals);
                    add_to_overlaps(i, overlaps, find_overlapping_ranges(d_left, i));
                    add_to_overlaps(i, overlaps, find_overlapping_ranges(d_right, i));
                }
                return interval_collection(overlaps);
            }

        protected:
            void add_to_overlaps(const T & i, interval_collection & overlaps, interval_collection new_overlaps) const
            {
                for(const auto & cur : new_overlaps)
                {
                    if(cur != i)
                    {
                        overlaps.push_back(cur);
                    }
                }
            }

            interval_collection check_left_overlaps(const T & i) const
            {
                return interval_collection(check_overlaps(i, LEFT));
            }

            interval_collection check_right_overlaps(const T & i) const
            {
                return interval_collection(check_overlaps(i, RIGHT));
            }

            interval_collection check_overlaps(const T & i, direction d) const
            {
                interval_collection overlaps;
                for(const auto & cur : d_intervals)
                {
                    switch(d)
                    {
                    case LEFT:
                        if(cur.get_start() <= i.get_end())
                        {
                            overlaps.push_back(cur);
                        }
                        break;
                    case RIGHT:
                        if(cur.get_end() >= i.get_start())
                        {
                            overlaps.push_back(cur);
                        }
                        break;
                    }
                }
                return interval_collection(overlaps);
            }

            interval_collection find_overlapping_ranges(node_ptr & node, const T & i) const
            {
                if(node)
                {
                    return interval_collection(node->find_overlaps(i));
                }
                return interval_collection();
            }
        };
        node d_root;

    public:
        interval_tree(const interval_collection & intervals)
            : d_root(intervals) {}

        interval_collection remove_overlaps(const interval_collection & intervals)
        {
            interval_collection result(intervals.begin(), intervals.end());
            std::sort(result.begin(), result.end(), [](const T & a, const T & b) -> bool
            {
                if(b.size() - a.size() == 0)
                {
                    return a.get_start() > b.get_start();
                }
                return a.size() > b.size();
            });
            std::set<T> remove_tmp;
            for(const auto & i : result)
            {
                if(remove_tmp.find(i) != remove_tmp.end())
                {
                    continue;
                }
                auto overlaps = find_overlaps(i);
                for(const auto & overlap : overlaps)
                {
                    remove_tmp.insert(overlap);
                }
            }
            for(const auto & i : remove_tmp)
            {
                result.erase(
                    std::find(result.begin(), result.end(), i)
                );
            }
            std::sort(result.begin(), result.end(), [](const T & a, const T & b) -> bool
            {
                return a.get_start() < b.get_start();
            });
            return interval_collection(result);
        }

        interval_collection find_overlaps(const T & i)
        {
            return interval_collection(d_root.find_overlaps(i));
        }
    };

    // class emit
    template<typename CharType>
    class emit : public interval
    {
    public:
        typedef std::basic_string<CharType>  string_type;
        typedef std::basic_string<CharType> & string_ref_type;

    private:
        string_type d_keyword;
        size_t      d_index = 0;

    public:
        emit()
            : interval(-1, -1)
            , d_keyword() {}

        emit(size_t start, size_t end, string_type keyword, size_t index)
            : interval(start, end)
            , d_keyword(keyword), d_index(index) {}

        string_type get_keyword() const { return string_type(d_keyword); }
        size_t get_index() const { return d_index; }
        bool is_empty() const { return (get_start() == -1 && get_end() == -1); }
    };

    // class token
    template<typename CharType>
    class token
    {
    public:
        enum token_type
        {
            TYPE_FRAGMENT,
            TYPE_MATCH,
        };

        using string_type = std::basic_string<CharType>;
        using string_ref_type = std::basic_string<CharType> & ;
        using emit_type = emit<CharType>;

    private:
        token_type  d_type;
        string_type d_fragment;
        emit_type   d_emit;

    public:
        token(string_ref_type fragment)
            : d_type(TYPE_FRAGMENT)
            , d_fragment(fragment)
            , d_emit() {}

        token(string_ref_type fragment, const emit_type & e)
            : d_type(TYPE_MATCH)
            , d_fragment(fragment)
            , d_emit(e) {}

        bool is_match() const { return (d_type == TYPE_MATCH); }
        string_type get_fragment() const { return string_type(d_fragment); }
        emit_type get_emit() const { return d_emit; }
    };

    // class state
    template<typename CharType>
    class state
    {
    public:
        typedef state<CharType>*                 ptr;
        typedef std::unique_ptr<state<CharType>> unique_ptr;
        typedef std::basic_string<CharType>      string_type;
        typedef std::basic_string<CharType>   &  string_ref_type;
        typedef std::pair<string_type, size_t>   key_index;
        typedef std::set<key_index>              string_collection;
        typedef std::vector<ptr>                 state_collection;
        typedef std::vector<CharType>            transition_collection;

    private:
        size_t                         d_depth;
        ptr                            d_root;
        std::map<CharType, unique_ptr> d_success;
        ptr                            d_failure;
        string_collection              d_emits;

    public:
        state() : state(0) {}

        state(size_t depth)
            : d_depth(depth)
            , d_root(depth == 0 ? this : nullptr)
            , d_success()
            , d_failure(nullptr)
            , d_emits() {}

        ptr next_state(CharType character) const
        {
            return next_state(character, false);
        }

        ptr next_state_ignore_root_state(CharType character) const
        {
            return next_state(character, true);
        }

        ptr add_state(CharType character)
        {
            auto next = next_state_ignore_root_state(character);
            if(next == nullptr)
            {
                next = new state<CharType>(d_depth + 1);
                d_success[character].reset(next);
            }
            return next;
        }

        size_t get_depth() const { return d_depth; }

        void add_emit(string_ref_type keyword, size_t index)
        {
            d_emits.insert(std::make_pair(keyword, index));
        }

        void add_emit(const string_collection & emits)
        {
            for(const auto & e : emits)
            {
                string_type str(e.first);
                add_emit(str, e.second);
            }
        }

        string_collection get_emits() const { return d_emits; }

        ptr failure() const { return d_failure; }

        void set_failure(ptr fail_state) { d_failure = fail_state; }

        state_collection get_states() const
        {
            state_collection result;
            for(auto it = d_success.cbegin(); it != d_success.cend(); ++it)
            {
                result.push_back(it->second.get());
            }
            return state_collection(result);
        }

        transition_collection get_transitions() const
        {
            transition_collection result;
            for(auto it = d_success.cbegin(); it != d_success.cend(); ++it)
            {
                result.push_back(it->first);
            }
            return transition_collection(result);
        }

    private:
        ptr next_state(CharType character, bool ignore_root_state) const
        {
            ptr result = nullptr;
            auto found = d_success.find(character);
            if(found != d_success.end())
            {
                result = found->second.get();
            }
            else if(!ignore_root_state && d_root != nullptr)
            {
                result = d_root;
            }
            return result;
        }
    };

    template<typename CharType>
    class basic_trie
    {
    public:
        using string_type = std::basic_string <CharType>;
        using string_ref_type = std::basic_string<CharType> & ;

        typedef state<CharType>         state_type;
        typedef state<CharType>*        state_ptr_type;
        typedef token<CharType>         token_type;
        typedef emit<CharType>          emit_type;
        typedef std::vector<token_type> token_collection;
        typedef std::vector<emit_type>  emit_collection;

        class config
        {
            bool d_allow_overlaps;
            bool d_only_whole_words;
            bool d_case_insensitive;

        public:
            config()
                : d_allow_overlaps(true)
                , d_only_whole_words(false)
                , d_case_insensitive(false) {}

            bool is_allow_overlaps() const { return d_allow_overlaps; }
            void set_allow_overlaps(bool val) { d_allow_overlaps = val; }

            bool is_only_whole_words() const { return d_only_whole_words; }
            void set_only_whole_words(bool val) { d_only_whole_words = val; }

            bool is_case_insensitive() const { return d_case_insensitive; }
            void set_case_insensitive(bool val) { d_case_insensitive = val; }
        };

    private:
        std::unique_ptr<state_type> d_root;
        config                      d_config;
        bool                        d_constructed_failure_states;
        size_t                      d_num_keywords = 0;

    public:
        basic_trie() : basic_trie(config()) {}

        basic_trie(const config & c)
            : d_root(new state_type())
            , d_config(c)
            , d_constructed_failure_states(false) {}

        basic_trie & case_insensitive()
        {
            d_config.set_case_insensitive(true);
            return (*this);
        }

        basic_trie & remove_overlaps()
        {
            d_config.set_allow_overlaps(false);
            return (*this);
        }

        basic_trie & only_whole_words()
        {
            d_config.set_only_whole_words(true);
            return (*this);
        }

        void insert(string_type keyword)
        {
            if(keyword.empty())
                return;
            state_ptr_type cur_state = d_root.get();
            for(const auto & ch : keyword)
            {
                cur_state = cur_state->add_state(ch);
            }
            cur_state->add_emit(keyword, d_num_keywords++);
        }

        template<class InputIterator>
        void insert(InputIterator first, InputIterator last)
        {
            for(InputIterator it = first; first != last; ++it)
            {
                insert(*it);
            }
        }

        token_collection tokenise(string_type text)
        {
            token_collection tokens;
            auto collected_emits = parse_text(text);
            size_t last_pos = -1;
            for(const auto & e : collected_emits)
            {
                if(e.get_start() - last_pos > 1)
                {
                    tokens.push_back(create_fragment(e, text, last_pos));
                }
                tokens.push_back(create_match(e, text));
                last_pos = e.get_end();
            }
            if(text.size() - last_pos > 1)
            {
                tokens.push_back(create_fragment(typename token_type::emit_type(), text, last_pos));
            }
            return token_collection(tokens);
        }

        emit_collection parse_text(string_type text)
        {
            check_construct_failure_states();
            size_t pos = 0;
            state_ptr_type cur_state = d_root.get();
            emit_collection collected_emits;
            for(auto c : text)
            {
                if(d_config.is_case_insensitive())
                {
                    c = std::tolower(c);
                }
                cur_state = get_state(cur_state, c);
                store_emits(pos, cur_state, collected_emits);
                pos++;
            }
            if(d_config.is_only_whole_words())
            {
                remove_partial_matches(text, collected_emits);
            }
            if(!d_config.is_allow_overlaps())
            {
                interval_tree<emit_type> tree(typename interval_tree<emit_type>::interval_collection(collected_emits.begin(), collected_emits.end()));
                auto tmp = tree.remove_overlaps(collected_emits);
                collected_emits.swap(tmp);
            }
            return emit_collection(collected_emits);
        }

    private:
        token_type create_fragment(const typename token_type::emit_type & e, string_ref_type text, size_t last_pos) const
        {
            auto start = last_pos + 1;
            auto end = (e.is_empty()) ? text.size() : e.get_start();
            auto len = end - start;
            typename token_type::string_type str(text.substr(start, len));
            return token_type(str);
        }

        token_type create_match(const typename token_type::emit_type & e, string_ref_type text) const
        {
            auto start = e.get_start();
            auto end = e.get_end() + 1;
            auto len = end - start;
            typename token_type::string_type str(text.substr(start, len));
            return token_type(str, e);
        }

        void remove_partial_matches(string_ref_type search_text, emit_collection & collected_emits) const
        {
            size_t size = search_text.size();
            emit_collection remove_emits;
            for(const auto & e : collected_emits)
            {
                if((e.get_start() == 0 || !std::isalpha(search_text.at(e.get_start() - 1))) &&
                        (e.get_end() + 1 == size || !std::isalpha(search_text.at(e.get_end() + 1)))
                  )
                {
                    continue;
                }
                remove_emits.push_back(e);
            }
            for(auto & e : remove_emits)
            {
                collected_emits.erase(
                    std::find(collected_emits.begin(), collected_emits.end(), e)
                );
            }
        }

        state_ptr_type get_state(state_ptr_type cur_state, CharType c) const
        {
            state_ptr_type result = cur_state->next_state(c);
            while(result == nullptr)
            {
                cur_state = cur_state->failure();
                result = cur_state->next_state(c);
            }
            return result;
        }

        void check_construct_failure_states()
        {
            if(!d_constructed_failure_states)
            {
                construct_failure_states();
            }
        }

        void construct_failure_states()
        {
            std::queue<state_ptr_type> q;
            for(auto & depth_one_state : d_root->get_states())
            {
                depth_one_state->set_failure(d_root.get());
                q.push(depth_one_state);
            }
            d_constructed_failure_states = true;

            while(!q.empty())
            {
                auto cur_state = q.front();
                for(const auto & transition : cur_state->get_transitions())
                {
                    state_ptr_type target_state = cur_state->next_state(transition);
                    q.push(target_state);

                    state_ptr_type trace_failure_state = cur_state->failure();
                    while(trace_failure_state->next_state(transition) == nullptr)
                    {
                        trace_failure_state = trace_failure_state->failure();
                    }
                    state_ptr_type new_failure_state = trace_failure_state->next_state(transition);
                    target_state->set_failure(new_failure_state);
                    target_state->add_emit(new_failure_state->get_emits());
                }
                q.pop();
            }
        }

        void store_emits(size_t pos, state_ptr_type cur_state, emit_collection & collected_emits) const
        {
            auto emits = cur_state->get_emits();
            if(!emits.empty())
            {
                for(const auto & str : emits)
                {
                    auto emit_str = typename emit_type::string_type(str.first);
                    collected_emits.push_back(emit_type(pos - emit_str.size() + 1, pos, emit_str, str.second));
                }
            }
        }
    };

    typedef basic_trie<char>     trie;
    typedef basic_trie<wchar_t>  wtrie;


} // namespace aho_corasick

#endif // AHO_CORASICK_HPP


================================================
File: InterObfu/main.cpp
================================================
#include "Instruction.h"
#include <cstdio>
#include "State.h"
#include "Pattern.h"
#include "Assemble.h"
#include "Peephole.h"

struct WildcardImm : Value
{
    explicit WildcardImm()
        : Value([](const Value & a, const Value & b, State & state)
    {
        return true;
    }) { }
};

void basicTest()
{
    //representation of "push 0x300"
    auto push300 = Instruction(X86_INS_PUSH, Operand(Value(0x300)));

    //representation of "push imm"
    auto pushImm = Instruction(X86_INS_PUSH, Operand(WildcardImm()));

    Instruction push300_;
    push300_.opcode.mnem = X86_INS_PUSH;
    push300_.opCount = 1;
    push300_.operands[0].type = Operand::Imm;
    push300_.operands[0].imm.val = 0x300;

    State s;
    printf("equal: %d %d %d\n", push300.Equals(push300_, s), push300.Equals(pushImm, s), pushImm.Equals(push300, s));

    //representation of "mov eax, ebx"
    Instruction movReg;
    movReg.opcode.mnem = X86_INS_MOV;
    movReg.opCount = 2;
    movReg.operands[0].type = Operand::Reg;
    movReg.operands[0].reg.reg = Register::EAX;
    movReg.operands[1].type = Operand::Reg;
    movReg.operands[1].reg.reg = Register::EBX;

    //representation of "mov [ebx + 0x401000], 0x3"
    Instruction movMem;
    movMem.opcode.mnem = X86_INS_MOV;
    movMem.opCount = 2;
    movMem.operands[0].type = Operand::Mem;
    movMem.operands[0].mem.base.reg = Register::EBX;
    movMem.operands[0].mem.disp.val = 0x401000;
    movMem.operands[1].type = Operand::Imm;
    movMem.operands[1].imm.val = 0x3;

    Pattern pattern1;
    //push reg2
    auto pushReg = Instruction(X86_INS_PUSH, Operand(Register(State::MakeRegisterN(2))));
    pattern1.Add(pushReg);
    //mov [memory1], 0x3
    auto movMemImm1 = Instruction(X86_INS_MOV, Operand(Memory(State::MakeMemoryN(1))), Operand(Value(3)));
    pattern1.Add(movMemImm1);

    Pattern pattern2;
    //mov [base1 + index2 * 1 + 0], imm1
    auto base1 = Register(State::MakeRegisterN(1));
    auto index2 = Register(State::MakeRegisterN(2));
    auto movMemImm2 = Instruction(X86_INS_MOV, Operand(Memory(base1, index2, Value(1), Value(0))), Operand(Value(State::MakeValueN(1))));
    pattern2.Add(movMemImm2);
    //xor reg1, reg2
    auto xorRegReg = Instruction(X86_INS_XOR, Operand(Register(State::MakeRegisterN(1))), Operand(Register(State::MakeRegisterN(2))));
    pattern2.Add(xorRegReg);
}

void checkEqual(const Instruction & a, const Instruction & b)
{
    State s;
    if(a.Equals(b, s))
        puts("a == b");
    else
        puts("a != b");
}

void matchTest2()
{
    std::vector<Instruction> ins1;
    ins1.push_back(Assemble("xor eax, 0"));
    ins1.push_back(Assemble("nop"));
    ins1.push_back(Assemble("push ecx"));
    ins1.push_back(Assemble("push eax"));
    ins1.push_back(Assemble("pop ecx"));
    ins1.push_back(Assemble("nop"));

    Pattern pat1;
    pat1.Add(Instruction(X86_INS_PUSH, Operand(Register(State::MakeRegisterN(1))))); //push reg1
    pat1.Add(Instruction(X86_INS_POP, Operand(Register(State::MakeRegisterN(2))))); //pop reg2
    printf("match1: %lld\n", pat1.Search(ins1));

    std::vector<Instruction> ins2;
    ins2.push_back(Assemble("xor eax, 0"));
    ins2.push_back(Assemble("push ecx"));
    ins2.push_back(Assemble("push edx"));
    ins2.push_back(Assemble("pop edx"));
    ins2.push_back(Assemble("nop"));

    Pattern pat2;
    pat2.Add(Instruction(X86_INS_PUSH, Operand(Register(State::MakeRegisterN(1))))); //push reg1
    pat2.Add(Instruction(X86_INS_POP, Operand(Register(State::MakeRegisterN(1))))); //pop reg1
    printf("match2: %lld\n", pat2.Search(ins2));

    std::vector<Instruction> ins3;
    ins3.push_back(Assemble("mov dword ptr ds:[eax+ebx*2], ecx"));
    ins3.push_back(Assemble("mov ecx, dword ptr ds:[eax+ebx*2]"));

    Pattern pat3;
    pat3.Add(Instruction(X86_INS_MOV, Operand(Memory(State::MakeMemoryN(1))), Operand(State::MakeOperandN(1)))); //mov memory1, op1
    pat3.Add(Instruction(X86_INS_MOV, Operand(State::MakeOperandN(1)), Operand(Memory(State::MakeMemoryN(1))))); //mov op1, memory1
    printf("match3: %lld\n", pat3.Search(ins3));
}

void matchTest()
{
    auto movEaxEbx = Assemble("mov eax, ebx");
    auto movRcxRcx = Assemble("mov rcx, rcx", 64);

    State s;
    //mov reg1, reg2
    auto movReg1Reg2 = Instruction(X86_INS_MOV, Operand(Register(State::MakeRegisterN(1))), Operand(Register(State::MakeRegisterN(2))));
    checkEqual(movEaxEbx, movReg1Reg2);
    s.Clear();

    //mov reg1, reg1
    auto movReg1Reg1 = Instruction(X86_INS_MOV, Operand(Register(State::MakeRegisterN(1))), Operand(Register(State::MakeRegisterN(1))));
    checkEqual(movEaxEbx, movReg1Reg1);
    s.Clear();

    checkEqual(movRcxRcx, movReg1Reg1);
}

#include "aho-corasick.h"

void testAhoCorasick()
{
    /*
    var dict = new[] {"a", "ab", "bab", "bc", "bca", "c", "caa"};
    var haystack = "abccab"
    a = X86_INS_MOV
    b = X86_INS_PUSH
    c = X86_INS_XOR
    */

    std::basic_string<char> input("abccab");
    puts("input:");
    puts(input.c_str());
    puts("");

    aho_corasick::basic_trie<char> trie;
    //trie.remove_overlaps(); //this has undesired behavior because it's not fine-grained enough
    auto dict = std::vector<std::string> {"a", "ab", "bab", "bc", "bca", "c", "caa"};
    puts("strings:");
    unsigned index = 0;
    for(auto & d : dict)
    {
        printf("%u:%s\n", index++, d.c_str());
        trie.insert(d);
    }
    puts("");

    auto results = trie.parse_text(input);
    puts("results (unfiltered):");
    for(auto & r : results)
        printf("%u:%d-%d \"%s\"\n", r.get_index(), int(r.get_start()), int(r.get_end()), r.get_keyword().c_str());
    puts("");

    //This creates a map from (match start) -> (result index).
    //Before considering a result it is checked with a predicate.
    //On conflicting (match start) we use a predicate.

    auto validPredicate = [](const aho_corasick::emit<char> & r) //is r a valid result?
    {
        return true; //TODO: implement by trying a full pattern match with wildcards
    };

    auto betterPredicate = [](const aho_corasick::emit<char> & a, const aho_corasick::emit<char> & b) //is a better than b?
    {
        if(a.size() > b.size()) //longer patterns are always better
            return true;
        return a.get_start() < b.get_start(); //patterns that start earlier are better
    };

    std::unordered_map<size_t, size_t> best;
    best.reserve(results.size());
    for(size_t i = 0; i < results.size(); i++)
    {
        const auto & r = results.at(i);
        if(!validPredicate(r)) //skip invalid results
            continue;
        auto found = best.find(r.get_start());
        if(found == best.end()) //add the current result if not found
            best[r.get_start()] = i;
        else if(betterPredicate(r, results[found->second])) //replace if the current result better
            found->second = i;
    }

    //TODO: overlapping results should be filtered with the betterPredicate

    puts("results (filtered):");
    for(const auto & it : best)
    {
        const auto & r = results[it.second];
        printf("%u:%d-%d \"%s\"\n", r.get_index(), int(r.get_start()), int(r.get_end()), r.get_keyword().c_str());
    }
    puts("");
}

void testConverter()
{
    Converter::init();

    if(Converter::reg2str(Converter::str2reg("eax")) == "eax")
        puts("register 1 ok!");
    else
        puts("register 1 failed...");
    if(Converter::str2reg("asd") == Register::INVALID)
        puts("register 2 ok!");
    else
        puts("register 2 failed...");
    if(Converter::reg2str(Register::Registers(-1)).empty())
        puts("register 3 ok!");
    else
        puts("register 3 failed...");

    if(Converter::ins2str(Converter::str2ins("push")) == "push")
        puts("instruction 1 ok!");
    else
        puts("instruction 1 failed...");
    if(Converter::str2ins("asd") == X86_INS_INVALID)
        puts("instruction 2 ok!");
    else
        puts("instruction 2 failed...");
    if(Converter::ins2str(Opcode::Mnemonics(-1)).empty())
        puts("instruction 3 ok!");
    else
        puts("instruction 3 failed...");
}

void testPeephole()
{
    std::vector<Instruction> ins1;
    ins1.push_back(Assemble("push eax"));
    ins1.push_back(Assemble("shl eax, 0"));
    ins1.push_back(Assemble("push edx"));
    ins1.push_back(Assemble("push ecx"));
    ins1.push_back(Assemble("pop ecx"));
    ins1.push_back(Assemble("pop edx"));
    ins1.push_back(Assemble("pop ecx"));
    ins1.push_back(Assemble("mov eax, 0x1234"));
    ins1.push_back(Assemble("push edi"));
    ins1.push_back(Assemble("xor dword ptr [esp], eax"));
    ins1.push_back(Assemble("pop edi"));

    std::vector<Pattern> patterns;

    {
        Pattern pat1;
        pat1.Add(Instruction(X86_INS_SHL,
                             Operand(Register(State::MakeRegisterN(1))),
                             Operand(Value(0))));
        patterns.push_back(pat1);
        puts("pattern 1:\n shl reg1, 0\n");
    }

    {
        Pattern pat2;
        pat2.Add(Instruction(X86_INS_PUSH,
                             Operand(Register(State::MakeRegisterN(1)))));
        pat2.Add(Instruction(X86_INS_POP,
                             Operand(Register(State::MakeRegisterN(1)))));
        patterns.push_back(pat2);
        puts("pattern 2:\n push reg1\n pop reg1\n");
    }

    {
        Pattern pat3;
        pat3.Add(Instruction(X86_INS_PUSH,
                             Operand(Register(State::MakeRegisterN(1)))));
        pat3.Add(Instruction(X86_INS_POP,
                             Operand(Register(State::MakeRegisterN(2)))));
        pat3.repls.push_back([](const State & state)
        {
            return Instruction(X86_INS_MOV,
                               Operand(state.registers[2]()),
                               Operand(state.registers[1]()));
        });
        patterns.push_back(pat3);
        puts("pattern 3:\n push reg1\n pop reg2");
        puts("replace 3:\n mov reg2, reg1\n");
    }

    {
        Pattern pat4;
        pat4.Add(Instruction(X86_INS_PUSH,
                             Operand(Register(State::MakeRegisterN(1)))));
        pat4.Add(Instruction(X86_INS_XOR,
                             Operand(Memory(Segment(State::SegWild()),
                                            Register(Register::ESP),
                                            Register(Register::INVALID),
                                            Value(1),
                                            Value(0))),
                             Operand(Register(State::MakeRegisterN(2)))));
        pat4.Add(Instruction(X86_INS_POP,
                             Operand(Register(State::MakeRegisterN(1)))));
        pat4.repls.push_back([](const State & state)
        {
            return Instruction(X86_INS_XOR, Operand(state.registers[1]()), Operand(state.registers[2]()));
        });
        patterns.push_back(pat4);
        puts("pattern 4:\n push reg1\n xor [esp], reg2\n pop reg1");
        puts("replace 4:\n xor reg1, reg2\n");
    }

    Converter::init();
    Peephole peephole(patterns);
    const auto MaxPasses = 1000;
    auto printInstrs = [](const std::vector<Instruction> & instrs)
    {
        for(auto & instr : instrs)
            printf(" %s\n", instr.ToString().c_str());
        puts("");
    };
    puts("input:");
    printInstrs(ins1);
    for(auto i = 0; i < MaxPasses; i++)
    {
        std::vector<Instruction> optimized;
        if(!peephole.Optimize(ins1, optimized))
            break;
        ins1 = optimized;
        printf("pass %d:\n", i + 1);
        printInstrs(ins1);
    }
    /*puts("output:");
    printInstrs(ins1);*/
}

int main()
{
    testPeephole();
    //testAhoCorasick();
    //basicTest();
    //matchTest();
    //matchTest2();
    //testConverter();

    system("pause");

    return 0;
}


================================================
File: InterObfu/XEDParse/XEDParse.h
================================================
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H




================================================
File: hooks/README.md
================================================
# hooks

This contains two binaries `AStyleWhore.exe` and `AStyle.dll` to format any code before you commit. They are signed with GPG.

To verify:

```
gpg --verify AStyle.dll.sig AStyle.dll
gpg: Signature made 07/08/16 06:01:39 W. Europe Daylight Time using RSA key ID AA0073B4
gpg: Good signature from "Duncan Ogilvie <mr.exodia.tpodt@gmail.com>" [ultimate]

gpg --verify AStyleWhore.exe.sig AStyleWhore.exe
gpg: Signature made 07/08/16 06:01:42 W. Europe Daylight Time using RSA key ID AA0073B4
gpg: Good signature from "Duncan Ogilvie <mr.exodia.tpodt@gmail.com>" [ultimate]
```

The *key ID* should match the last 8 characters of the signature of [this commit](https://github.com/x64dbg/x64dbg/commit/c855c15fd79870312ea5b4a1fbf3cb0dd8ae6240).

Git hashes are:

```
git ls-files -s
100644 6ef20910c6ab4e94cc2270e289a5b73d712c9c50 0       AStyle.dll
100644 5ea8a5daf0580e030406cedb83fb73ca9c187138 0       AStyle.dll.sig
100644 10dd63522b059eb3a43c01b35b807a9d50b5034d 0       AStyleWhore.exe
100644 d910d7ff178703b1452bc717491e5c24b9db1945 0       AStyleWhore.exe.sig
100644 0706138f1ec594c0b5d41978900b9d45cd2d99d7 0       pre-commit
```

If you are unsure about the integrity of the files, don't hesitate to contact me (mrexodia). The source code is available at [BitBucket](https://bitbucket.org/mrexodia/astylewhore). The version of `AStyle.dll` is compiled from `AStyle_2.04_windows.zip` which came from [Sourceforge](https://sourceforge.net/projects/astyle/files/astyle/astyle%202.04/AStyle_2.04_windows.zip/download).


================================================
File: hooks/AStyle.dll.sig
================================================
[Non-text file]


================================================
File: hooks/AStyleWhore.exe.sig
================================================
[Non-text file]


================================================
File: hooks/pre-commit
================================================
#!/bin/sh
#
# Simple script to auto-format every source file before committing.
#

#check if the formatter is present
if [ ! -f ./hooks/AStyleWhore.exe ]; then
    echo "AStyleWhore not found!"
    exit 0
fi

#format the code
"./hooks/AStyleWhore.exe" Silent

#exit when nothing needs to be done
if [ $? == 0 ]; then
    exit 0
fi

#stage the formatted files (when staged in this commit)
gitFiles=$(git diff-index --name-only --cached HEAD)
if [[ -n "${gitFiles}" ]]; then
    for fname in $gitFiles; do
        git add --all -- "${fname}"
    done
fi

#cancel commit if the changes were undone by the formatting
gitFiles=$(git diff-index --name-only --cached HEAD)
if [ -z "$gitFiles" ]; then
    "./hooks/AStyleWhore.exe" "After formatting, no files were staged..."
    exit 1
fi



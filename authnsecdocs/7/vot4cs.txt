Directory structure:
└── tum-i22-vot4cs/
    ├── README.md
    ├── LICENSE
    ├── README_TOOL.txt
    ├── CodeVirtualization-Console/
    │   ├── CodeVirtualization-Console.sln
    │   ├── CodeVirtualization-Console/
    │   │   ├── App.config
    │   │   ├── App2.config
    │   │   ├── CodeVirtualization-Console.csproj
    │   │   ├── Program.cs
    │   │   ├── VirtualizationHandler.cs
    │   │   ├── VisualStudioSolutionHandler.cs
    │   │   ├── packages.config
    │   │   ├── Context/
    │   │   │   ├── VirtualData.cs
    │   │   │   ├── VirtualOperation.cs
    │   │   │   └── VirtualizationContext.cs
    │   │   ├── Properties/
    │   │   │   └── AssemblyInfo.cs
    │   │   ├── RefactoringVisitors/
    │   │   │   ├── ComposedAssignmentVisitor.cs
    │   │   │   ├── ConditionalExpressionVisitor.cs
    │   │   │   ├── FormatInsertTabRightVisitor.cs
    │   │   │   ├── LocalDeclarationConstantForceType.cs
    │   │   │   ├── MethodRefactoringVisitor.cs
    │   │   │   ├── RenameVisitor.cs
    │   │   │   ├── TriviaRemovalVisitor.cs
    │   │   │   ├── IfRefactoring/
    │   │   │   │   ├── IfBranchesRefactoringVisitor.cs
    │   │   │   │   └── IfConditionRefactoringVisitor.cs
    │   │   │   ├── LoopRefactoring/
    │   │   │   │   ├── DoWhileConditionRefactoringVisitor.cs
    │   │   │   │   ├── ForConditionRefactoringVisitor.cs
    │   │   │   │   ├── ForEachConditionRefactoringVisitor.cs
    │   │   │   │   ├── LoopBodyRefactoringVisitor.cs
    │   │   │   │   └── WhileConditionRefactoringVisitor.cs
    │   │   │   ├── OperationSimplifiers/
    │   │   │   │   ├── AdditiveOperationSimplifierVisitor.cs
    │   │   │   │   ├── ComparisonSignSimplifierVisitor.cs
    │   │   │   │   ├── InvocationExpressionSimplifier.cs
    │   │   │   │   ├── MemberAccessExpressionSimplifier.cs
    │   │   │   │   ├── MultiplicativeOperationSimplifierVisitor.cs
    │   │   │   │   ├── ParenthesisOperationSimplifierVisitor.cs
    │   │   │   │   └── PrePostOperationVisitor.cs
    │   │   │   ├── SwitchRefactoring/
    │   │   │   │   ├── SwitchBreakRefactoring.cs
    │   │   │   │   ├── SwitchConditionRefactoring.cs
    │   │   │   │   ├── SwitchSectionRefactoring.cs
    │   │   │   │   └── SwitchStatementRefactoring.cs
    │   │   │   └── TryCatch/
    │   │   │       └── TryCatchRefactoringVisitor.cs
    │   │   ├── TypingVisitors/
    │   │   │   ├── MethodExplicitTypeVisitor.cs
    │   │   │   └── VarTypeReplaceVisitor.cs
    │   │   ├── Utils/
    │   │   │   ├── ListExtensions.cs
    │   │   │   ├── SyntaxFactoryExtensions.cs
    │   │   │   └── VirtualizationAttribute.cs
    │   │   └── VirtualizationVisitors/
    │   │       ├── AssignmentDataVirtualizationVisitor.cs
    │   │       ├── ClassVirtualizationVisitor.cs
    │   │       ├── ConstantValueVisitor.cs
    │   │       ├── LocalDeclarationExtractorVisitor.cs
    │   │       ├── LocalVariableUsageDataVirtVisitor.cs
    │   │       ├── MethodParamsExtractorVisitor.cs
    │   │       ├── MethodVirtualizationVisitor.cs
    │   │       └── StatementsExtractorVisitor.cs
    │   └── .vs/
    │       └── CodeVirtualization-Console/
    │           └── v14/
    └── ConsoleCalculator/
        ├── ConsoleCalculator.sln
        ├── ConsoleCalculator.tss
        └── ConsoleCalculator/
            ├── App.config
            ├── Car.cs
            ├── ConsoleCalculator.csproj
            ├── CustomizedRunProjectSettings.rtflow.xml
            ├── MonitoringSettings.rtflow.xml
            ├── Program.cs
            ├── Values1.txt
            ├── packages.config
            ├── Performance/
            │   ├── PerformanceTests.cs
            │   ├── BinarySearch/
            │   │   ├── BinarySearchTests.cs
            │   │   ├── BinarySearch_Iterative.cs
            │   │   ├── BinarySearch_Iterative_class.cs
            │   │   ├── BinarySearch_Iterative_class_default.cs
            │   │   ├── BinarySearch_Iterative_ctrl_flow.cs
            │   │   ├── BinarySearch_Iterative_method.cs
            │   │   ├── BinarySearch_Iterative_method_default.cs
            │   │   ├── BinarySearch_Iterative_method_modified.cs
            │   │   ├── BinarySearch_Recursive.cs
            │   │   ├── BinarySearch_Recursive_class.cs
            │   │   ├── BinarySearch_Recursive_class_default.cs
            │   │   ├── BinarySearch_Recursive_ctrl_flow.cs
            │   │   ├── BinarySearch_Recursive_method.cs
            │   │   ├── BinarySearch_Recursive_method_default.cs
            │   │   └── BinarySearch_Recursive_method_modified.cs
            │   ├── Factorial/
            │   │   └── FactorialTests.cs
            │   ├── ForLoop/
            │   │   ├── ForLoop_Tests.cs
            │   │   ├── ForLoop_op2_in1.cs
            │   │   ├── ForLoop_op3_in1.cs
            │   │   ├── ForLoop_op4_in1.cs
            │   │   ├── ForLoop_op4_in1_0.cs
            │   │   ├── ForLoop_op4_in2.cs
            │   │   ├── ForLoop_op4_in3.cs
            │   │   ├── ForLoop_op4_in4.cs
            │   │   └── ForLoop_op4_in5.cs
            │   └── QuickSort/
            │       ├── QuickSortIterative.cs
            │       ├── QuickSortIterative_class.cs
            │       ├── QuickSortIterative_class_default.cs
            │       ├── QuickSortIterative_ctrl_flow.cs
            │       ├── QuickSortIterative_method.cs
            │       ├── QuickSortIterative_method_default.cs
            │       ├── QuickSortIterative_method_modified.cs
            │       ├── QuickSortRecursive.cs
            │       ├── QuickSortRecursive_class.cs
            │       ├── QuickSortRecursive_class_default.cs
            │       ├── QuickSortRecursive_ctrl_flow.cs
            │       ├── QuickSortRecursive_method.cs
            │       ├── QuickSortRecursive_method_default.cs
            │       ├── QuickSortRecursive_method_modified.cs
            │       └── QuickSortTests.cs
            ├── Properties/
            │   └── AssemblyInfo.cs
            ├── Tracing/
            │   ├── BasicOperations.cs
            │   └── TraceLoopTests.cs
            ├── VirtCode/
            │   ├── CodeBasicTests.cs
            │   ├── CodeBranchTests.cs
            │   └── CodeLoopTests.cs
            └── VirtData/
                ├── BasicTests.cs
                ├── BranchTests.cs
                ├── ConditionalExpressionTests.cs
                ├── DelegatesTests.cs
                ├── ExceptionTests.cs
                ├── ExtensionsTests.cs
                ├── FieldTests.cs
                ├── FileOperations.cs
                ├── LambdaTests.cs
                ├── ListInterfaces.cs
                └── LoopTests.cs

================================================
File: README.md
================================================
# vot4cs
A Virtualization Obfuscation Tool for C# programs

==== USAGE ====

Usage: <tool> <config-file> <solution-file>
- tool: the .exe binary file
- config-file: an app.config file (see example bellow)
- solution-file: a Visual Studio .sln file containing the project to be obfuscated

 .\CodeVirtualization-Console\App2.config 	.\ConsoleCalculator\ConsoleCalculator.sln

==== OBFUSCATION CONFIGURATIONS ====

example: .\CodeVirtualization-Console\CodeVirtualization-Console\App2.config

key="CODE_IDENTIFIER" value="virtualCode2" 
key="DATA_IDENTIFIER" value="virtualData2" 
key="DEFAULT_MOST_FREQUENT_OPERATION" value="true" 
key="INSTRUCTION_SIZE_POSTFIX" value="30" 
key="INSTRUCTION_SIZE_PREFIX" value="30" 
key="INSTRUCTION_SIZE_OFFSET" value="20" 
key="MAX_INVOCATIONS" value="1" 
key="MAX_OPERANDS" value="2" 
key="MAX_JUNK_CODE" value="10" 
key="MAX_DATA_KEY" value="3999" 
key="MAX_CODE_KEY" value="99999" 
key="MIN_SWITCH_KEY" value="1000" 
key="MAX_SWITCH_KEY" value="9999" 
key="VPC_IDENTIFIER" value="virtualVpc" 


Mark a method for virtualization with the following annotation:


==== LANGUAGE FEATURES NOT SUPPORTED ====

- try/catch
- foreach 
- ref,
- struct


==== OBFUSCATION TOOL FOLDER: CodeVirtualization-Console ====

- contains the source code of the virtualization obfuscation tool



==== EXAMPLES FOLDER: ConsoleCalculator ====

- contains sample methods which can be obfuscated with the tool
- contains source code used for the performance evaluation of the virtualization



================================================
File: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
File: README_TOOL.txt
================================================
==== USAGE ====
Usage: <tool> <config-file> <solution-file>
- tool: the .exe binary file
- config-file: an app.config file (see example bellow)
- solution-file: a Visual Studio .sln file containing the project to be obfuscated

 .\CodeVirtualization-Console\App2.config 	.\ConsoleCalculator\ConsoleCalculator.sln

==== OBFUSCATION CONFIGURATIONS ====
example: .\CodeVirtualization-Console\CodeVirtualization-Console\App2.config

key="CODE_IDENTIFIER" value="virtualCode2" 
key="DATA_IDENTIFIER" value="virtualData2" 
key="DEFAULT_MOST_FREQUENT_OPERATION" value="true" 
key="INSTRUCTION_SIZE_POSTFIX" value="30" 
key="INSTRUCTION_SIZE_PREFIX" value="30" 
key="INSTRUCTION_SIZE_OFFSET" value="20" 
key="MAX_INVOCATIONS" value="1" 
key="MAX_OPERANDS" value="2" 
key="MAX_JUNK_CODE" value="10" 
key="MAX_DATA_KEY" value="3999" 
key="MAX_CODE_KEY" value="99999" 
key="MIN_SWITCH_KEY" value="1000" 
key="MAX_SWITCH_KEY" value="9999" 
key="VPC_IDENTIFIER" value="virtualVpc" 


Mark a method for virtualization with the following annotation:


==== LANGUAGE FEATURES NOT SUPPORTED ====
- try/catch
- foreach 
- ref,
- struct


==== OBFUSCATION TOOL FOLDER: CodeVirtualization-Console ====
- contains the source code of the virtualization obfuscation tool



==== EXAMPLES FOLDER: ConsoleCalculator ====
- contains sample methods which can be obfuscated with the tool
- contains source code used for the performance evaluation of the virtualization





================================================
File: CodeVirtualization-Console/CodeVirtualization-Console.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.22823.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "CodeVirtualization-Console", "CodeVirtualization-Console\CodeVirtualization-Console.csproj", "{29BC5F29-5C47-4975-A676-5318535DCDB7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{29BC5F29-5C47-4975-A676-5318535DCDB7}.Debug|x86.ActiveCfg = Debug|x86
		{29BC5F29-5C47-4975-A676-5318535DCDB7}.Debug|x86.Build.0 = Debug|x86
		{29BC5F29-5C47-4975-A676-5318535DCDB7}.Release|x86.ActiveCfg = Release|x86
		{29BC5F29-5C47-4975-A676-5318535DCDB7}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <appSettings>   
    <add key="CODE_IDENTIFIER" value="virtualCode" />
    <add key="DATA_IDENTIFIER" value="virtualData" />
    <add key="DEFAULT_MOST_FREQUENT_OPERATION" value="true" />
    <add key="INSTRUCTION_SIZE_POSTFIX" value="30" />
    <add key="INSTRUCTION_SIZE_PREFIX" value="30" />
    <add key="INSTRUCTION_SIZE_OFFSET" value="20" />
    <add key="MAX_INVOCATIONS" value="1" />
    <add key="MAX_OPERANDS" value="2" />
    <add key="MAX_JUNK_CODE" value="10" />
    <add key="MAX_DATA_KEY" value="3999" />
    <add key="MAX_CODE_KEY" value="99999" />
    <add key="MIN_SWITCH_KEY" value="1000" />
    <add key="MAX_SWITCH_KEY" value="9999" />
    <add key="VPC_IDENTIFIER" value="virtualVpc" />
  </appSettings>
</configuration>


================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/App2.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <appSettings>   
    <add key="CODE_IDENTIFIER" value="virtualCode2" />
    <add key="DATA_IDENTIFIER" value="virtualData2" />
    <add key="DEFAULT_MOST_FREQUENT_OPERATION" value="true" />
    <add key="INSTRUCTION_SIZE_POSTFIX" value="30" />
    <add key="INSTRUCTION_SIZE_PREFIX" value="30" />
    <add key="INSTRUCTION_SIZE_OFFSET" value="20" />
    <add key="MAX_INVOCATIONS" value="1" />
    <add key="MAX_OPERANDS" value="2" />
    <add key="MAX_JUNK_CODE" value="10" />
    <add key="MAX_DATA_KEY" value="3999" />
    <add key="MAX_CODE_KEY" value="99999" />
    <add key="MIN_SWITCH_KEY" value="1000" />
    <add key="MAX_SWITCH_KEY" value="9999" />
    <add key="VPC_IDENTIFIER" value="virtualVpc" />
  </appSettings>
</configuration>


================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/CodeVirtualization-Console.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">x86</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{29BC5F29-5C47-4975-A676-5318535DCDB7}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>CodeVirtualization_Console</RootNamespace>
    <AssemblyName>CodeVirtualization-Console</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <PlatformTarget>x86</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System" />
    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.AttributedModel, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.Convention, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.Hosting, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.Runtime, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.TypedParts, Version=1.0.27.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.27\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Configuration" />
    <Reference Include="System.Core" />
    <Reference Include="System.Data" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Xml" />
    <Reference Include="System.Xml.Linq" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Context\VirtualOperation.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="RefactoringVisitors\LoopRefactoring\DoWhileConditionRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\LoopRefactoring\ForEachConditionRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\OperationSimplifiers\ComparisonSignSimplifierVisitor.cs" />
    <Compile Include="RefactoringVisitors\SwitchRefactoring\SwitchBreakRefactoring.cs" />
    <Compile Include="RefactoringVisitors\SwitchRefactoring\SwitchStatementRefactoring.cs" />
    <Compile Include="RefactoringVisitors\SwitchRefactoring\SwitchSectionRefactoring.cs" />
    <Compile Include="RefactoringVisitors\SwitchRefactoring\SwitchConditionRefactoring.cs" />
    <Compile Include="RefactoringVisitors\IfRefactoring\IfBranchesRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\LoopRefactoring\ForConditionRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\OperationSimplifiers\AdditiveOperationSimplifierVisitor.cs" />
    <Compile Include="RefactoringVisitors\OperationSimplifiers\MemberAccessExpressionSimplifier.cs" />
    <Compile Include="RefactoringVisitors\OperationSimplifiers\InvocationExpressionSimplifier.cs" />
    <Compile Include="RefactoringVisitors\LocalDeclarationConstantForceType.cs" />
    <Compile Include="RefactoringVisitors\OperationSimplifiers\ParenthesisOperationSimplifierVisitor.cs" />
    <Compile Include="RefactoringVisitors\OperationSimplifiers\MultiplicativeOperationSimplifierVisitor.cs" />
    <Compile Include="RefactoringVisitors\RenameVisitor.cs" />
    <Compile Include="RefactoringVisitors\LoopRefactoring\WhileConditionRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\IfRefactoring\IfConditionRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\LoopRefactoring\LoopBodyRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\MethodRefactoringVisitor.cs" />
    <Compile Include="RefactoringVisitors\TryCatch\TryCatchRefactoringVisitor.cs" />
    <Compile Include="TypingVisitors\MethodExplicitTypeVisitor.cs" />
    <Compile Include="TypingVisitors\VarTypeReplaceVisitor.cs" />
    <Compile Include="Utils\ListExtensions.cs" />
    <Compile Include="Utils\SyntaxFactoryExtensions.cs" />
    <Compile Include="Context\VirtualData.cs" />
    <Compile Include="Context\VirtualizationContext.cs" />
    <Compile Include="Utils\VirtualizationAttribute.cs" />
    <Compile Include="VirtualizationHandler.cs" />
    <Compile Include="VirtualizationVisitors\AssignmentDataVirtualizationVisitor.cs" />
    <Compile Include="RefactoringVisitors\ComposedAssignmentVisitor.cs" />
    <Compile Include="RefactoringVisitors\FormatInsertTabRightVisitor.cs" />
    <Compile Include="RefactoringVisitors\ConditionalExpressionVisitor.cs" />
    <Compile Include="VirtualizationVisitors\ClassVirtualizationVisitor.cs" />
    <Compile Include="VirtualizationVisitors\MethodParamsExtractorVisitor.cs" />
    <Compile Include="VirtualizationVisitors\LocalDeclarationExtractorVisitor.cs" />
    <Compile Include="VirtualizationVisitors\LocalVariableUsageDataVirtVisitor.cs" />
    <Compile Include="VirtualizationVisitors\MethodVirtualizationVisitor.cs" />
    <Compile Include="VirtualizationVisitors\ConstantValueVisitor.cs" />
    <Compile Include="RefactoringVisitors\OperationSimplifiers\PrePostOperationVisitor.cs" />
    <Compile Include="VirtualizationVisitors\StatementsExtractorVisitor.cs" />
    <Compile Include="RefactoringVisitors\TriviaRemovalVisitor.cs" />
    <Compile Include="VisualStudioSolutionHandler.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App2.config" />
    <None Include="App.config" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <Analyzer Include="..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.Analyzers.dll" />
    <Analyzer Include="..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.CSharp.Analyzers.dll" />
  </ItemGroup>
  <ItemGroup>
    <WCFMetadata Include="Service References\" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Program.cs
================================================
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CodeVirtualization_Console
{
    class Program
    {
        static void Main(string[] args)
        {

            if (!setConfigFileAtRuntime(args))
                return;
        
            if (args.Length < 2)
            {
                Console.WriteLine("Please specify a solultion (.sln) file:");
                Console.WriteLine("Usage: <tool> <config-file> <solution-file>");
                return;
            }
            var dir = Environment.CurrentDirectory;
            string pathToSolution = args[1];

            Console.WriteLine("path to solution: {0}", pathToSolution);

            IEnumerable<Project> projects = null;
            try
            {
                projects = VisualStudioSolutionHandler.GetProjects(pathToSolution);
            }
            catch (Exception e)
            {
                Console.WriteLine("INVALID path to solution: {0}", pathToSolution);
                return;
            }

            foreach (var project in projects)
            {
                                
                var compilation = VisualStudioSolutionHandler.GetProjectCompilation(project);

                var syntaxTrees = compilation.SyntaxTrees;
                foreach (var syntaxTree in syntaxTrees)
                {                    
                    var model = compilation.GetSemanticModel(syntaxTree, true);
                    Document doc = project.GetDocument(syntaxTree);

                    var virtualizationContext = new VirtualizationContext();
                    virtualizationContext.semanticModel = model;
                    virtualizationContext.project = project;
                    virtualizationContext.document = doc;
                    virtualizationContext.compilation = compilation;
                    virtualizationContext.workspace = VisualStudioSolutionHandler.workspace;

                    var virtualizationHandler = new VirtualizationHandler(virtualizationContext);                    
                    virtualizationHandler.VirtualizeProject();                    
                }

            }

            Console.WriteLine();
            Console.WriteLine(">>OK: Virtualization Complete!");
            Console.ReadKey();
        }

       
        private static bool setConfigFileAtRuntime(string[] args)
        {
            string runtimeconfigfile;

            if (args.Length == 0)
            {                
                Console.WriteLine("Please specify a config file:");
                Console.WriteLine("Usage: <tool> <config-file> <solution-file>");
               
                return false;
            }

            runtimeconfigfile = args[0];

            // Specify config settings at runtime.
            var configMap = new ExeConfigurationFileMap();
            configMap.ExeConfigFilename = runtimeconfigfile;
            var config = ConfigurationManager.OpenMappedExeConfiguration(configMap, ConfigurationUserLevel.None);


            //VPC_IDENTIFIER
            try
            {
                var vpcIdentifier = config.AppSettings.Settings["VPC_IDENTIFIER"];
                if (vpcIdentifier != null)
                {
                    VirtualizationContext.VPC_IDENTIFIER = vpcIdentifier.Value;
                }
                Console.WriteLine("VPC_IDENTIFIER: {0}", VirtualizationContext.VPC_IDENTIFIER);
            }
            catch (Exception e)
            {
                VirtualizationContext.VPC_IDENTIFIER = "xyc";
                Console.WriteLine("VPC_IDENTIFIER: {0} (default)", VirtualizationContext.VPC_IDENTIFIER);
            }


            //CODE_IDENTIFIER
            try
            {
                var codeIdentifier = config.AppSettings.Settings["CODE_IDENTIFIER"];
                if (codeIdentifier != null)
                {
                    VirtualizationContext.CODE_IDENTIFIER = codeIdentifier.Value;
                }
                Console.WriteLine("CODE_IDENTIFIER: {0}", VirtualizationContext.CODE_IDENTIFIER);
            }
            catch (Exception e)
            {
                VirtualizationContext.CODE_IDENTIFIER = "bcd";
                Console.WriteLine("CODE_IDENTIFIER: {0} (default)", VirtualizationContext.CODE_IDENTIFIER);
            }
           

            //DATA_IDENTIFIER
            try
            {
                var dataIdentifier = config.AppSettings.Settings["DATA_IDENTIFIER"];
                if (dataIdentifier != null)
                {
                    VirtualizationContext.DATA_IDENTIFIER = dataIdentifier.Value;
                }
                Console.WriteLine("DATA_IDENTIFIER: {0}", VirtualizationContext.DATA_IDENTIFIER);
            }
            catch (Exception e)
            {
                VirtualizationContext.DATA_IDENTIFIER = "def";
                Console.WriteLine("DATA_IDENTIFIER: {0} (default)", VirtualizationContext.DATA_IDENTIFIER);
            }
            

            //DEFAULT_MOST_FREQUENT_OPERATION
            try
            {
                var defaultMostFrequent = config.AppSettings.Settings["DEFAULT_MOST_FREQUENT_OPERATION"];
                if (defaultMostFrequent != null)
                {
                    VirtualizationContext.DEFAULT_MOST_FREQUENT_OPERATION = Boolean.Parse(defaultMostFrequent.Value);
                }
                Console.WriteLine("DEFAULT_MOST_FREQUENT_OPERATION: {0}", VirtualizationContext.DEFAULT_MOST_FREQUENT_OPERATION);
            }
            catch (Exception e)
            {
                VirtualizationContext.DEFAULT_MOST_FREQUENT_OPERATION = true;
                Console.WriteLine("DEFAULT_MOST_FREQUENT_OPERATION: {0} (default)", VirtualizationContext.DEFAULT_MOST_FREQUENT_OPERATION);
            }

            //INSTRUCTION_SIZE_POSTFIX
            try
            {
                var instructionPostfix = config.AppSettings.Settings["INSTRUCTION_SIZE_POSTFIX"];
                if (instructionPostfix != null)
                {
                    VirtualizationContext.INSTRUCTION_SIZE_POSTFIX = Int32.Parse(instructionPostfix.Value);
                }
                Console.WriteLine("INSTRUCTION_SIZE_POSTFIX: {0}", VirtualizationContext.INSTRUCTION_SIZE_POSTFIX);
            }
            catch (Exception e)
            {
                VirtualizationContext.INSTRUCTION_SIZE_POSTFIX = 30;
                Console.WriteLine("INSTRUCTION_SIZE_POSTFIX: {0} (default)", VirtualizationContext.INSTRUCTION_SIZE_POSTFIX);
            }


            //INSTRUCTION_SIZE_PREFIX
            try
            {
                var instructionPrefix = config.AppSettings.Settings["INSTRUCTION_SIZE_PREFIX"];
                if (instructionPrefix != null)
                {
                    VirtualizationContext.INSTRUCTION_SIZE_PREFIX = Int32.Parse(instructionPrefix.Value);
                }
                Console.WriteLine("INSTRUCTION_SIZE_PREFIX: {0}", VirtualizationContext.INSTRUCTION_SIZE_PREFIX);
            }
            catch (Exception e)
            {
                VirtualizationContext.INSTRUCTION_SIZE_PREFIX = 20;
                Console.WriteLine("INSTRUCTION_SIZE_PREFIX: {0} (default)", VirtualizationContext.INSTRUCTION_SIZE_PREFIX);
            }

            //INSTRUCTION_SIZE_OFFSET
            try
            {
                var instructionSizeOffset = config.AppSettings.Settings["INSTRUCTION_SIZE_OFFSET"];
                if (instructionSizeOffset != null)
                {
                    VirtualizationContext.INSTRUCTION_SIZE_OFFSET = Int32.Parse(instructionSizeOffset.Value);
                }
                Console.WriteLine("INSTRUCTION_SIZE_OFFSET: {0}", VirtualizationContext.INSTRUCTION_SIZE_OFFSET);
            }
            catch (Exception e)
            {
                VirtualizationContext.INSTRUCTION_SIZE_OFFSET = 20;
                Console.WriteLine("INSTRUCTION_SIZE_OFFSET: {0} (default)", VirtualizationContext.INSTRUCTION_SIZE_OFFSET);
            }


            //MAX_INVOCATIONS
            try
            {
                var maxInvocations = config.AppSettings.Settings["MAX_INVOCATIONS"];
                if (maxInvocations != null)
                {
                    VirtualizationContext.MAX_INVOCATIONS = Int32.Parse(maxInvocations.Value);
                }
                Console.WriteLine("MAX_INVOCATIONS: {0}", VirtualizationContext.MAX_INVOCATIONS);
            }
            catch (Exception e)
            {
                VirtualizationContext.MAX_INVOCATIONS = 1;
                Console.WriteLine("MAX_INVOCATIONS: {0} (default)", VirtualizationContext.MAX_INVOCATIONS);
            }

            //MAX_OPERANDS
            try
            {
                var maxOperands = config.AppSettings.Settings["MAX_OPERANDS"];
                if (maxOperands != null)
                {
                    VirtualizationContext.MAX_OPERANDS = Int32.Parse(maxOperands.Value);
                }
                Console.WriteLine("MAX_OPERANDS: {0}", VirtualizationContext.MAX_OPERANDS);
            }
            catch (Exception e)
            {
                VirtualizationContext.MAX_OPERANDS = 1;
                Console.WriteLine("MAX_OPERANDS: {0} (default)", VirtualizationContext.MAX_OPERANDS);
            }

            //MAX_JUNK_CODE
            try
            {
                var maxJunkCode = config.AppSettings.Settings["MAX_JUNK_CODE"];
                if (maxJunkCode != null)
                {
                    VirtualizationContext.MAX_JUNK_CODE = Int32.Parse(maxJunkCode.Value);
                }
                Console.WriteLine("MAX_JUNK_CODE: {0}", VirtualizationContext.MAX_JUNK_CODE);
            }
            catch (Exception e)
            {
                VirtualizationContext.MAX_JUNK_CODE = 10;
                Console.WriteLine("MAX_JUNK_CODE: {0} (default)", VirtualizationContext.MAX_JUNK_CODE);
            }

            //MAX_DATA_KEY
            try
            {
                var maxDataKey = config.AppSettings.Settings["MAX_DATA_KEY"];
                if (maxDataKey != null)
                {
                    VirtualizationContext.MAX_DATA_KEY = Int32.Parse(maxDataKey.Value);
                }
                Console.WriteLine("MAX_DATA_KEY: {0}", VirtualizationContext.MAX_DATA_KEY);
            }
            catch (Exception e)
            {
                VirtualizationContext.MAX_DATA_KEY = 3999;
                Console.WriteLine("MAX_DATA_KEY: {0} (default)", VirtualizationContext.MAX_DATA_KEY);
            }


            //MAX_CODE_KEY
            try
            {
                var maxCodeKey = config.AppSettings.Settings["MAX_CODE_KEY"];
                if (maxCodeKey != null)
                {
                    VirtualizationContext.MAX_CODE_KEY = Int32.Parse(maxCodeKey.Value);
                }
                Console.WriteLine("MAX_CODE_KEY: {0}", VirtualizationContext.MAX_CODE_KEY);
            }
            catch (Exception e)
            {
                VirtualizationContext.MAX_CODE_KEY = 99999;
                Console.WriteLine("MAX_CODE_KEY: {0} (default)", VirtualizationContext.MAX_CODE_KEY);
            }


            //MIN_SWITCH_KEY
            try
            {
                var minSwitchKey = config.AppSettings.Settings["MIN_SWITCH_KEY"];
                if (minSwitchKey != null)
                {
                    VirtualizationContext.MIN_SWITCH_KEY = Int32.Parse(minSwitchKey.Value);
                }
                Console.WriteLine("MIN_SWITCH_KEY: {0}", VirtualizationContext.MIN_SWITCH_KEY);
            }
            catch (Exception e)
            {
                VirtualizationContext.MIN_SWITCH_KEY = 1000;
                Console.WriteLine("MIN_SWITCH_KEY: {0} (default)", VirtualizationContext.MIN_SWITCH_KEY);
            }

            //MAX_SWITCH_KEY
            try
            {
                var maxSwitchKey = config.AppSettings.Settings["MAX_SWITCH_KEY"];
                if (maxSwitchKey != null)
                {
                    VirtualizationContext.MAX_SWITCH_KEY = Int32.Parse(maxSwitchKey.Value);
                }
                Console.WriteLine("MAX_SWITCH_KEY: {0}", VirtualizationContext.MAX_SWITCH_KEY);
            }
            catch (Exception e)
            {
                VirtualizationContext.MAX_SWITCH_KEY = 9999;
                Console.WriteLine("MAX_SWITCH_KEY: {0} (default)", VirtualizationContext.MAX_SWITCH_KEY);
            }

            return true;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationHandler.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeVirtualization_Console.RefactoringVisitors;
using CodeVirtualization_Console.TypingVisitors;
using CodeVirtualization_Console.VirtualizationVisitors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace CodeVirtualization_Console
{
    class VirtualizationHandler
    {
        private VirtualizationContext _virtualizationContext;

        public VirtualizationHandler(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public void VirtualizeProject()
        {
            var tree = _virtualizationContext.semanticModel.SyntaxTree;

            var classVirtualizationVisitor = new ClassVirtualizationVisitor(_virtualizationContext);

            var methodRefactoringVisitor = new MethodRefactoringVisitor(_virtualizationContext);
            var methodExplicitTypeVisitor = new MethodExplicitTypeVisitor(_virtualizationContext);

            SyntaxNode newSource = tree.GetRoot();
            _virtualizationContext.currentRoot = newSource;

            //REFACTORING
            newSource = methodRefactoringVisitor.Visit(newSource);
           _virtualizationContext.UpdateCompilation(newSource);
            
            //EXPLICIT_TYPE
            newSource = methodExplicitTypeVisitor.Visit(newSource);
            _virtualizationContext.UpdateCompilation(newSource);

            //VIRTUALIZATION
            newSource = classVirtualizationVisitor.Visit(newSource);


            if (!_virtualizationContext.currentRoot.Equals(newSource.SyntaxTree.GetRoot()))
                _virtualizationContext.currentRoot = newSource.SyntaxTree.GetRoot();

            if (!newSource.Equals(tree.GetRoot()))
            {
                Console.WriteLine(tree.FilePath);
                File.WriteAllText(tree.FilePath, newSource.ToFullString());
            }

        }





        
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VisualStudioSolutionHandler.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;

namespace CodeVirtualization_Console
{
    class VisualStudioSolutionHandler
    {
        // start Roslyn workspace
        public static MSBuildWorkspace workspace = MSBuildWorkspace.Create();

        public static IEnumerable<Project> GetProjects(string pathToSolution)
        {
            

            // open solution we want to analyze
            Solution solutionToAnalyze =
                workspace.OpenSolutionAsync(pathToSolution).Result;

            var projects = solutionToAnalyze.Projects;

            return projects;   
        }


        public static Compilation GetProjectCompilation(Project project)
        {
            // get the project's compilation
            // compilation contains all the types of the 
            // project and the projects referenced by 
            // our project. 
            Compilation projectCompilation =
                project.GetCompilationAsync().Result;                  

            return projectCompilation;
        }

        
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Microsoft.CodeAnalysis.Analyzers" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.Composition" version="1.0.27" targetFramework="net45" userInstalled="true" />
  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="net45" userInstalled="true" />
  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="net45" userInstalled="true" />
</packages>


================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Context/VirtualData.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console
{
    class VirtualData
    {

        public readonly List<SyntaxAnnotation> Annotations = new List<SyntaxAnnotation>();

        public int Index { get; set; }

        public string Name { get; set; }

        public string Type { get; set; }

        public SyntaxNode Node { get; set; }

        public StatementSyntax Statement { get; set; }

        private ExpressionSyntax _defaultValue;
        public ExpressionSyntax DefaultValue
        {
            get
            {
                if (_defaultValue == null)
                    DefaultValue = null;
                return _defaultValue;
            }
            set
            {
                if (value == null)
                    _defaultValue = SyntaxFactoryExtensions.DefaultRandomValue(Type);
                else
                    _defaultValue = value;
            }
        }

        public bool IsConstant
        {
            get
            {
                var found = Annotations.Where(a => a.Kind.Equals("type")).FirstOrDefault(a => a.Data.Equals("constant"));
                if (found == null)
                    return false;
                return true;
            }
        }
        
         
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Context/VirtualOperation.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Context
{
    internal class VirtualOperation
    {        
        /// <summary>
        /// maintain the meta-information about each data element that is used in a virtual operation
        /// </summary>
        private readonly List<Tuple<string, string, string>> Data = new List<Tuple<string, string, string>>();

        /// <summary>
        /// maintain the meta-information about each fake data element that is used in a virtual operation
        /// </summary>
        private readonly List<Tuple<string, string, string>> FakeData = new List<Tuple<string, string, string>>();

        /// <summary>
        /// each unique instruction has a different size offset used to randomize the value of the instruction size
        /// </summary>
        public int InstructionSizeOffset = 0;

        public readonly List<StatementSyntax> Statetements = new List<StatementSyntax>();

        public int Key { get; set; }

        private int _size;
        public int Size
        {
            get
            {
                if (_size == 0)
                {
                    _size = VirtualizationContext.INSTRUCTION_SIZE_POSTFIX + VirtualizationContext.INSTRUCTION_SIZE_PREFIX +
                        InstructionSizeOffset;
                }
                return _size;
            }
            set { _size = value; }
        } 

        public string Signature { get; set; } = "";

        public string Name { get; set; } = "";

        public string UniqueName { get; set; } = "";

        private static Dictionary<int, int> AppearanceFrequency = new Dictionary<int, int>();


        public int Frequency => GetAppearanceCount(Key);

        public static int MaxFrequencyKey => maxFrequencyKey;

        private static int maxFrequency = -1;
        private static int maxFrequencyKey = -1;

        public VirtualOperation()
        {
            OffsetKeys = new List<string>();
            OffsetKeys.Add("" + 0); // statement key is always on position 0
        }

        

        public static void MarkAppearance(int key)
        {
            if (!AppearanceFrequency.ContainsKey(key))
            {
                AppearanceFrequency.Add(key, 1);
                if (maxFrequencyKey == -1)
                {
                    maxFrequencyKey = key;
                    maxFrequency = 1;
                }
            }
            else
            {
                int appeared = GetAppearanceCount(key);
                appeared++;
                AppearanceFrequency[key] = appeared;
                if (appeared > maxFrequency)
                {
                    maxFrequency = appeared;
                    maxFrequencyKey = key;
                }
            }
        }

        public static int GetAppearanceCount(int key)
        {
            int appeared = 0;
            AppearanceFrequency.TryGetValue(key, out appeared);
            return appeared;
        }

        /// <summary>
        /// values used to offset the VPC value for the virtual operation which is composed of multiple statements
        /// </summary>
        public List<string> OffsetKeys { get; set; }

        public void AddOffsetKey(string key)
        {
            OffsetKeys.Add(key);
        }

        public bool OffsetKeyUsed(string key)
        {
            return OffsetKeys.Contains(key);
        }

        private StatementSyntax syntax;
        /// <summary>
        /// the expression with randomized positions for paramenters
        /// </summary>
        public StatementSyntax Syntax
        {
            get { return syntax;}
            set
            {
                if (staticSyntax == null)
                {
                    staticSyntax = value; //default initialization
                }
                syntax = value;                
            }
        }

        /// <summary>
        /// the expression with consecutive positions for parameters
        /// </summary>
        private StatementSyntax staticSyntax;
        public StatementSyntax StaticSyntax
        {
            get { return staticSyntax; }
            set
            {
                staticSyntax = value;
            }
        }

        public void AddData(string name, string dataIndex, string vpcOffset)
        {
            Data.Add(new Tuple<string, string, string>(name, dataIndex, vpcOffset));
            OffsetKeys.Add(vpcOffset);
            Size++;
        }

        public void AddData(string name, int dataIndex, int vpcOffset)
        {
            AddData(name, "" + dataIndex, "" + vpcOffset);
        }

        public bool ReplaceStatement(StatementSyntax oldStatement, StatementSyntax newStatement)
        {
            int position = Statetements.IndexOf(oldStatement);
            if (position == -1)
                return false;
            Statetements[position] = newStatement;
            return true;
        }
        
        public void AddFakeData(string name, int dataIndex, int vpcOffset)
        {
            FakeData.Add(new Tuple<string, string, string>(name, "" + dataIndex, "" + vpcOffset));
        }

        public void AddStatement(StatementSyntax value)
        {
            Statetements.Add(value);
        }

        public List<Tuple<string, string, string>> GetData()
        {
            return Data;
        }

        public List<Tuple<string, string, string>> GetFakeData()
        {
            return FakeData;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Context/VirtualizationContext.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeVirtualization_Console.Context;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace CodeVirtualization_Console
{
    /// <summary>
    /// Use this attribute to mark obfuscation on a method
    /// [Obfuscation(Exclude = false, Feature = "virtualization; method/class; refactor; debug; readable")]
    /// </summary>
    internal class VirtualizationContext
    {
        //new
        #region INPUT_PARAMS
        public static readonly bool COMPILED_INTERPRETER = false; //TODO: compiled lambda expression interpreter not implemented

        /// <summary>
        /// the number of dummy code values inserted into a virtual operation
        /// </summary>
        public static int MAX_JUNK_CODE;

        public static int MAX_JUNK_STATEMENTS = 0; //TODO: MAX_JUNK_STATEMENTS not implemented
        public static bool DEFAULT_MOST_FREQUENT_OPERATION ;
        /// <summary>
        /// For example, statement  sum = 1 + 2 + 3 + 4 + 5 + 6;
        /// will be split into sub-statements which have maximum N operands
        /// Minimum value: 2 
        /// Default value: 2
        /// </summary>
        public static int MAX_OPERANDS;
        /// <summary>
        /// Minimum value: 1 
        /// Default value: 1
        /// </summary>
        public static int MAX_INVOCATIONS; 

        /// <summary>
        /// the size of the bytecode instruction
        /// </summary>
        public static int   INSTRUCTION_SIZE_POSTFIX;
        /// <summary>
        /// add the end of any instruction there can be overlapping between junk code or param from the next instruction
        /// </summary>
        public static int INSTRUCTION_SIZE_PREFIX;

        /// <summary>
        /// size of random empty positions considered for each unique instruction
        /// actual_instruction_size = INSTRUCTION_SIZE_POSTFIX + INSTRUCTION_SIZE_PREFIX + INSTRUCTION_SIZE_OFFSET
        /// </summary>
        public static int INSTRUCTION_SIZE_OFFSET;

        #endregion


        /* virtualization obfuscation variables identifiers */
        public static string DATA_IDENTIFIER;
        public static string CODE_IDENTIFIER ;
        public static string VPC_IDENTIFIER ;

        public static String Instance_INTERPRETER = "InstanceInterpreterVirtualization";
        public static String Class_INTERPRETER = "ClassInterpreterVirtualization";

        internal SemanticModel semanticModel;
        internal Project project;
        internal Document document;
        public Compilation compilation;
        public SyntaxNode currentRoot;

        private static int internalUniqueId = 0;
        public static int UniqueId => internalUniqueId++;
//        public int DataIndex => dataIndex++;

        /// <summary>
        /// initialization data for each method 
        /// </summary>
        public readonly List<VirtualData> data;

        /// <summary>
        /// list of code operands unique for each method
        /// </summary>
        public readonly List<VirtualOperation> code;

        /// <summary>
        /// list of code instructions unique for each interpreter
        /// </summary>
        public readonly List<VirtualOperation> Operations;

        private string VirtualizationLevel;
        public bool IsInstanceLevel => VirtualizationLevel.Equals("class-instance");
        public bool IsClassLevel => VirtualizationLevel.Equals("class-static");
        public bool IsMethodLevel => VirtualizationLevel.Equals("method");

        public void SetMethodLevelVirtualization()
        {
            VirtualizationLevel = "method";
        }

        public void SetInstanceLevelVirtualization()
        {
            VirtualizationLevel = "class-instance";
        }

        public void SetClassLevelVirtualization()
        {
            VirtualizationLevel = "class-static";
        }

        public String InterpreterIdentifier()
        {
            if (IsInstanceLevel)
                return VirtualizationContext.Instance_INTERPRETER;
            if (IsClassLevel)
                return VirtualizationContext.Class_INTERPRETER;
            return "";
        }

        /// <summary>
        /// Use this attribute to mark obfuscation on a method
        /// [Obfuscation(Exclude = false, Feature = "virtualization; method/class; refactor; debug")]
        /// 
        /// possible features:
        /// virtualization - signifies virtualization obfuscation
        /// method - add the interpreter inside the method
        /// class - add the interpreter at the class level
        /// refactor - only perform refactoring without virtualization (for debugging only)
        /// debug - to be decided...
        /// readable - adds comments to statements
        /// </summary>
        /// 
        public List<string> Options ;

        public static int InstructionSizeOffsetRand()
        {
            return GetRandom(0, INSTRUCTION_SIZE_OFFSET);
        }
        

        public static int MIN_SWITCH_KEY ;
        public static int MAX_SWITCH_KEY ;

        public int SWITCH_KEY
        {
            get { return GetRandomUnique(MIN_SWITCH_KEY, MAX_SWITCH_KEY); }
        }

        public static int MAX_DATA_KEY;
        public int DataIndex
        {
            get { return GetRandomUnique(0, MAX_DATA_KEY); }
        }

        public int DataIndexFake
        {
            get { return GetRandom(0, MAX_DATA_KEY); }
        }

        public static int MAX_CODE_KEY;
        public int CodeIndex
        {
            get { return GetRandomUnique(0, MAX_CODE_KEY); }
        }

        public int CodeIndexFake
        {
            get { return GetRandom(0, MAX_CODE_KEY); }
        }


        public VirtualizationContext()
        {
            Random = new Random();
            data = new List<VirtualData>();
            code = new List<VirtualOperation>();
            Operations = new List<VirtualOperation>();
            Options = new List<string>() {"method"};            
        }

        public void SetClassLevelOn()
        {
            if (!ClassLevelOn)
            {
                Options.Remove("method");
                Options.Add("class");
            }
        }

        public bool RefactoringOn => Options.Contains("refactor");
        public bool MethodLevelOn => Options.Contains("method");
        public bool ClassLevelOn => Options.Contains("class");
        public bool DebugOn => Options.Contains("debug");
        public bool ReadableOn => Options.Contains("readable");

        private static Random Random = new Random();
        public MSBuildWorkspace workspace;

        public void UpdateSemanticModel(SyntaxNode node)
        {
            var tree = node.Parent.SyntaxTree;
            UpdateSemanticModel(tree);
        }

        public void UpdateSemanticModel(SyntaxTree tree)
        {
            semanticModel = compilation.GetSemanticModel(tree);
        }

        public void UpdateCompilation(SyntaxNode newSource)
        {
            var oldSyntaxTree = semanticModel.SyntaxTree;
            var newSyntaxTree = newSource.SyntaxTree;
            var newCompilation = compilation.ReplaceSyntaxTree(oldSyntaxTree, newSyntaxTree);
            var newSemanticModel = newCompilation.GetSemanticModel(newSyntaxTree);

            compilation = newCompilation;
            semanticModel = newSemanticModel;
            currentRoot = newSemanticModel.SyntaxTree.GetRoot();
        }


        public void Reset()
        {
            data.Clear();
            code.Clear();
        }

        public static int GetRandom(int low, int high)
        {
            if (high < low)
            {
                int aux = low;
                low = high;
                high = aux;
            }        

            int value = Random.Next(low, high);
            return value;
        }

        public static int GetRandom()
        {
            int value = Random.Next();
            return value;
        }

        private List<int> randomSwitchKeyList = new List<int>();
        private int GetRandomUnique()
        {
            int generated = Random.Next();
            while (randomSwitchKeyList.Contains(generated))
                generated = Random.Next();
            randomSwitchKeyList.Add(generated);
            return generated;
        }

        private int GetRandomUnique(int min, int max)
        {
            int generated = Random.Next(min, max);
            while (randomSwitchKeyList.Contains(generated))
                generated = Random.Next(min, max);
            randomSwitchKeyList.Add(generated);
            return generated;
        }

        //DATA array index

        private List<int> randomDataKeyList = new List<int>();
        private int GetRandomDataUnique()
        {
            int generated = Random.Next();
            while (randomDataKeyList.Contains(generated))
                generated = Random.Next();
            randomDataKeyList.Add(generated);
            return generated;
        }

        private int GetRandomDataUnique(int min, int max)
        {
            int generated = Random.Next(min, max);
            while (randomDataKeyList.Contains(generated))
                generated = Random.Next(min, max);
            randomDataKeyList.Add(generated);
            return generated;
        }

        //CODE array index

        private List<int> randomCodeKeyList = new List<int>();
        private int GetRandomCodeUnique()
        {
            int generated = Random.Next();
            while (randomCodeKeyList.Contains(generated))
                generated = Random.Next();
            randomCodeKeyList.Add(generated);
            return generated;
        }

        private int GetRandomCodeUnique(int min, int max)
        {
            int generated = Random.Next(min, max);
            while (randomCodeKeyList.Contains(generated))
                generated = Random.Next(min, max);
            randomCodeKeyList.Add(generated);
            return generated;
        }

        public static int RandomInstructionPosition()
        {
            int generated = Random.Next(-INSTRUCTION_SIZE_PREFIX, INSTRUCTION_SIZE_POSTFIX);            
            return generated;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CodeVirtualization-Console")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("CodeVirtualization-Console")]
[assembly: AssemblyCopyright("Copyright Â©  2015")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/ComposedAssignmentVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Visitors
{
    /// <summary>
    /// Transforms
    /// a += b to a = a + b;
    /// Does the same for:  *=, -=, &=, |=, /=, >>=, 
    /// <<=, ^=, %=
    /// </summary>
    class ComposedAssignmentVisitor : CSharpSyntaxRewriter
    {
        public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
        {
            var expressionCheck = node.Expression;
            bool and = (expressionCheck.Kind() == SyntaxKind.AndAssignmentExpression);
            bool or = (expressionCheck.Kind() == SyntaxKind.OrAssignmentExpression);
            bool sub = (expressionCheck.Kind() == SyntaxKind.SubtractAssignmentExpression);
            bool add = (expressionCheck.Kind() == SyntaxKind.AddAssignmentExpression);
            bool mult = (expressionCheck.Kind() == SyntaxKind.MultiplyAssignmentExpression);
            bool div = (expressionCheck.Kind() == SyntaxKind.DivideAssignmentExpression);
            bool rightShift = (expressionCheck.Kind() == SyntaxKind.RightShiftAssignmentExpression);
            bool leftShift = (expressionCheck.Kind() == SyntaxKind.LeftShiftAssignmentExpression);
            bool xor = (expressionCheck.Kind() == SyntaxKind.ExclusiveOrAssignmentExpression);
            bool modulo = (expressionCheck.Kind() == SyntaxKind.ModuloAssignmentExpression);

            bool condition = and || or || sub || add || mult || div || rightShift || leftShift || xor || modulo;
            if (!condition)
                return node;

            SyntaxKind newOperation = SyntaxKind.AddExpression;
            if (and)
                newOperation = SyntaxKind.BitwiseAndExpression; 
            else if (or)
                newOperation = SyntaxKind.BitwiseOrExpression;
            else if (sub)
                newOperation = SyntaxKind.SubtractExpression;
            else if (add)
                newOperation = SyntaxKind.AddExpression;
            else if (mult)
                newOperation = SyntaxKind.MultiplyExpression;
            else if (div)
                newOperation = SyntaxKind.DivideExpression;
            else if (leftShift)
                newOperation = SyntaxKind.LeftShiftExpression;
            else if (rightShift)
                newOperation = SyntaxKind.RightShiftExpression;
            else if (xor)
                newOperation = SyntaxKind.ExclusiveOrExpression;
            else if (modulo)
                newOperation = SyntaxKind.ModuloExpression;

            var expression = expressionCheck as AssignmentExpressionSyntax;
            var left = expression.Left.WithoutTrivia();
            var right = expression.Right.WithoutTrivia();
            var newRight = SyntaxFactory.BinaryExpression(newOperation, left, right);
            var assignment = SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, left, newRight);
            var newExpression = SyntaxFactory.ExpressionStatement(assignment)
                .NormalizeWhitespace().WithTriviaFrom(node);
            return newExpression;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            oldBody = (BlockSyntax)this.Visit(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/ConditionalExpressionVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.VirtualizationVisitors
{
    class ConditionalExpressionVisitor : CSharpSyntaxRewriter
    {
        private static int CONDITION_COUNTER = 0;
        private static string CONDITION_VAR = "var_conditional_";

        private static string ConditionIdentifier
        {
            get { return CONDITION_VAR + CONDITION_COUNTER++; }
        }

        private readonly List<ExpressionSyntax> markedNodes = new List<ExpressionSyntax>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>>();


        public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
        {
            //             throw new NotImplementedException("Virtualization: conditional expression - a ? true : false not supported");
            //TODO: this is a naive implementation, i.e. it treats only simple cases, not recursive ones



            var conditionExpression = node.Condition;

            string conditionVarIdentifier = ConditionIdentifier;
            var newConditionVar = SyntaxFactoryExtensions.LocalVariableDeclaration(conditionVarIdentifier,
                conditionExpression, SyntaxKind.BoolKeyword).NormalizeWhitespace().WithTriviaFrom(node);
            var newCondition = SyntaxFactory.IdentifierName(conditionVarIdentifier).WithTriviaFrom(conditionExpression);

            ExpressionStatementSyntax parentExpression = (ExpressionStatementSyntax) GetParentExpression(node);
            markedNodes.Add(parentExpression.Expression);
//            p
//
//            var trueBranch = node.WhenTrue;
//            var falseBranch = node.WhenFalse;
//                        
//            var statement = SyntaxFactory.IfStatement(newCondition, SyntaxFactory.ExpressionStatement(trueBranch), SyntaxFactory.ElseClause(SyntaxFactory.ExpressionStatement(falseBranch)));
//
//            replacementNodes.Add(new Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>(condition, newCondition, newConditionVar));

            return node;
        }

        private SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                || (node.Kind() == SyntaxKind.ReturnStatement)
                )
                if (node.Parent != null)
                    if (node.Parent.Kind() == SyntaxKind.Block)
                        return node;

            return GetParentExpression(node.Parent);
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            oldBody = oldBody.TrackNodes(this.markedNodes);
            foreach (var tuple in this.replacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);
                if (currentA != null)
                {
                    var ifStatement = currentA.Parent;
                    oldBody = oldBody.InsertNodesBefore(ifStatement, new List<SyntaxNode>() { tuple.Item3 });
                    var currentB = oldBody.GetCurrentNode(tuple.Item1);
                    oldBody = oldBody.ReplaceNode(currentB, tuple.Item2);
                }
            }
            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/FormatInsertTabRightVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Visitors
{
    class FormatInsertTabRightVisitor : CSharpSyntaxRewriter
    {

        //        public override SyntaxNode Visit(SyntaxNode node)
        //        {
        //            SyntaxNode newNode = base.Visit(node);
        //            if (newNode == null)
        //                return node;
        ////            newNode = node.WithLeadingTrivia(node.GetLeadingTrivia().Add(SyntaxFactory.Tab));
        //            return newNode;
        //        }

//        public override SyntaxToken VisitToken(SyntaxToken token)
//        {
//            var visitedToken =  base.VisitToken(token);
//            visitedToken = AddTab(visitedToken);
//            return visitedToken;
//        }

        public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
        {
            SyntaxNode newNode = base.VisitSwitchSection(node);
            newNode = AddTab(newNode);
            return newNode;
        }

        public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
        {
            SyntaxNode newNode = base.VisitIfStatement(node);
            newNode = AddTab(newNode);
            var newIfStatement = newNode as IfStatementSyntax;

            var trueBranch = (StatementSyntax) this.Visit(node.Statement);
            var falseBranch = (ElseClauseSyntax) this.Visit(node.Else);
            newIfStatement = newIfStatement.WithStatement(trueBranch).WithElse(falseBranch);

            return newIfStatement;
        }

        public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
        {
            SyntaxNode newNode = base.VisitSwitchStatement(node);
            newNode = AddTab(newNode);
            var newSwitch = newNode as SwitchStatementSyntax;
            var openLeadingTrivia = newSwitch.OpenBraceToken.LeadingTrivia;
            openLeadingTrivia = openLeadingTrivia.Add(SyntaxFactory.Tab);
            newSwitch = newSwitch.WithOpenBraceToken(
                newSwitch.OpenBraceToken.WithLeadingTrivia(openLeadingTrivia));
            var closeLeadingTrivia = newSwitch.CloseBraceToken.LeadingTrivia;
            closeLeadingTrivia = closeLeadingTrivia.Add(SyntaxFactory.Tab);
            newSwitch = newSwitch.WithCloseBraceToken(
                newSwitch.CloseBraceToken.WithLeadingTrivia(closeLeadingTrivia));

            return newSwitch;
        }

        public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
        {
            SyntaxNode newNode = base.VisitExpressionStatement(node);
            newNode = AddTab(newNode);
            return newNode;
        }

        public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
        {
            SyntaxNode newNode = base.VisitContinueStatement(node);
            newNode = AddTab(newNode);
            return newNode;
        }

        public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
        {
            SyntaxNode newNode = base.VisitReturnStatement(node);
            newNode = AddTab(newNode);
            return newNode;
        }

        public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
        {
            SyntaxNode newNode = base.VisitBreakStatement(node);
            newNode = AddTab(newNode);
            return newNode;
        }

        private SyntaxNode AddTab(SyntaxNode node)
        {
            SyntaxNode newNode = node;
            if (newNode == null)
                return node;
            var leadingTriviaList = node.GetLeadingTrivia();
            var trailingTriviaList = node.GetTrailingTrivia();
            leadingTriviaList = leadingTriviaList.Add(SyntaxFactory.Tab);//.Add(SyntaxFactory.Space).Add(SyntaxFactory.Space).Add(SyntaxFactory.Space).Add(SyntaxFactory.Space);
            newNode = node.WithLeadingTrivia(leadingTriviaList)
                .WithTrailingTrivia(trailingTriviaList);

            return newNode;
        }

        private SyntaxToken AddTab(SyntaxToken node)
        {
            SyntaxToken newNode = node;
            if (newNode == null)
                return node;
            var leadingTriviaList = node.LeadingTrivia;
            var trailingTriviaList = node.TrailingTrivia;
            leadingTriviaList = leadingTriviaList.Add(SyntaxFactory.Tab);//.Add(SyntaxFactory.Space).Add(SyntaxFactory.Space).Add(SyntaxFactory.Space).Add(SyntaxFactory.Space);
            newNode = node.WithLeadingTrivia(leadingTriviaList)
                .WithTrailingTrivia(trailingTriviaList);

            return newNode;
        }

        public static readonly FormatInsertTabRightVisitor Instance = new FormatInsertTabRightVisitor();

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/LocalDeclarationConstantForceType.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    /// force cast to avoid casting errors at conversion: e.g. int -> object -> double not allowed!
    /// create expression with default value for double, float, long
    internal class LocalDeclarationConstantForceType : CSharpSyntaxRewriter
    {
        private VirtualizationContext _virtualizationContext;

        private readonly List<ExpressionSyntax> markedNodes =
           new List<ExpressionSyntax>();
        private readonly List<Tuple<ExpressionSyntax, ExpressionSyntax>> replacementNodes =
            new List<Tuple<ExpressionSyntax, ExpressionSyntax>>();


        public LocalDeclarationConstantForceType(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
        {
            string declaredType = node.Declaration.Type.ToString();

            bool basicType = SyntaxFactoryExtensions.IsBasicType(declaredType);
            if (!basicType)
                return node;

            if (declaredType.Equals("int"))
                return node;
            if (declaredType.Equals("bool"))
                return node;
            if (declaredType.Equals("char"))
                return node;
            if (declaredType.Equals("string"))
                return node;

            foreach (var variable in node.Declaration.Variables)
            {
                if (variable.Initializer == null)
                    continue;
                var oldRightValue = variable.Initializer.Value;
                markedNodes.Add(oldRightValue);

                var newRightValue = SyntaxFactory.BinaryExpression(SyntaxKind.AddExpression, oldRightValue,
                    SyntaxFactoryExtensions.DefaultValue(declaredType));
                replacementNodes.Add(new Tuple<ExpressionSyntax, ExpressionSyntax> (oldRightValue, newRightValue));
            }

            return node;
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            oldBody = oldBody.TrackNodes(this.markedNodes);
            foreach (var tuple in this.replacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);
                if (currentA != null)
                {                                        
                    oldBody = oldBody.ReplaceNode(currentA, tuple.Item2);
                }
            }
            return oldBody;
        }



        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/MethodRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeVirtualization_Console.RefactoringVisitors.LoopRefactoring;
using CodeVirtualization_Console.RefactoringVisitors.TryCatch;
using CodeVirtualization_Console.VirtualizationVisitors;
using CodeVirtualization_Console.Visitors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    internal class MethodRefactoringVisitor : CSharpSyntaxRewriter
    {

        private const int METHOD_MIN_STATEMENTS = 2;
        private VirtualizationContext _virtualizationContext;

        public MethodRefactoringVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax method)
        {
            var marked = ClassVirtualizationVisitor.MarkedForVirtualization(method);
            if (!marked.Item1)
                return method;

            if (method.Body.DescendantNodes().OfType<StatementSyntax>().Count() <= METHOD_MIN_STATEMENTS)
            {
                return method;
            }

            _virtualizationContext.Options = marked.Item2;
            var oldBody = method.Body;

            Debug.WriteLine("Method to be Refactored: " + method.Identifier);

            //WARNING: Do Not Change Order!
            var localDeclarationForceType = new LocalDeclarationConstantForceType(_virtualizationContext);

            // must be before: comparison simplifier, IF refactoring
            var switchConditionRefactoringVisitor = new SwitchConditionRefactoringVisitor();
            var switchSectionRefactoringVisitor = new SwitchSectionRefactoringVisitor();
            var switchStatementRefactoringVisitor = new SwitchStatementRefactoringVisitor();

            var comparisonSignSimplifier = new ComparisonSignSimplifierVisitor();
            var conditionalExpressionVisitor = new ConditionalExpressionVisitor();
            var ifBranchRefactoringVisitor = new IfBranchesRefactoringVisitor();
            var loopBodyRefactoringVisitor = new LoopBodyRefactoringVisitor();
            var ifConditionRefactoringVisitor = new IfConditionRefactoringVisitor();
            var forConditionRefactoringVisitor = new ForConditionRefactoringVisitor();
            var whileConditionRefactoringVisitor = new WhileConditionRefactoringVisitor();
            var doWhileConditionRefactoringVisitor = new DoWhileConditionRefactoringVisitor();
            var composedAssignmentVisitor = new ComposedAssignmentVisitor();
            var prePostOperationVisitor = new PrePostOperationVisitor();

            var tryCatchVisitor = new TryCatchRefactoringVisitor(_virtualizationContext);

            var parenthesisOperationVisitor = new ParenthesisOperationSimplifierVisitor(_virtualizationContext);
            var multiplicativeOperationVisitor = new MultiplicativeOperationSimplifierVisitor(_virtualizationContext);
            var additiveOperationVisitor = new AdditiveOperationSimplifierVisitor(_virtualizationContext);
            var invocationExpressionVisitor = new InvocationExpressionSimplifier();
            var memberAccessExpresionVisitor = new MemberAccessExpressionSimplifier();
            
            oldBody = (BlockSyntax)localDeclarationForceType.Refactor(oldBody);

            oldBody = (BlockSyntax)switchConditionRefactoringVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax)switchSectionRefactoringVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax)switchStatementRefactoringVisitor.Refactor(oldBody);

            //IF branch before condition
            oldBody = (BlockSyntax) conditionalExpressionVisitor.Visit(oldBody);
            oldBody = (BlockSyntax) comparisonSignSimplifier.Visit(oldBody);
            oldBody = (BlockSyntax) ifBranchRefactoringVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax) ifConditionRefactoringVisitor.Refactor(oldBody);
            

            oldBody = (BlockSyntax)loopBodyRefactoringVisitor.Refactor(oldBody);
            //FOR before while!
            oldBody = (BlockSyntax) forConditionRefactoringVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax) doWhileConditionRefactoringVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax) whileConditionRefactoringVisitor.Refactor(oldBody);

            oldBody = (BlockSyntax)tryCatchVisitor.Visit(oldBody);

            oldBody = (BlockSyntax)composedAssignmentVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax)parenthesisOperationVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax)multiplicativeOperationVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax)additiveOperationVisitor.Refactor(oldBody);


            oldBody = (BlockSyntax)prePostOperationVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax)invocationExpressionVisitor.Refactor(oldBody);
            oldBody = (BlockSyntax)memberAccessExpresionVisitor.Refactor(oldBody);

            string returnType = method.ReturnType.ToString();
            if (returnType.Equals("void"))
                oldBody = AddReturnToVoidMethod(oldBody);
           

            var updatedMethod = method.ReplaceNode(method.Body, oldBody);

            //TODO: fix formatting
            //            oldBody = (BlockSyntax) Formatter.Format(oldBody, texts, VisualStudioSolutionHandler.workspace);
            updatedMethod = updatedMethod.NormalizeWhitespace().WithTriviaFrom(method);

//            Console.WriteLine("Method Refactored: " + method.Identifier);
            Debug.WriteLine("Method Refactored: " + method.Identifier);

            return updatedMethod;
        }

        /// <summary>
        /// If the method is void, in order to exit the interpreter, the body of the method must contain a return statement with random expression;
        /// </summary>
        /// <param name="leadingTrivia"></param>
        /// <param name="oldBody"></param>
        /// <returns>return 1;</returns>
        private BlockSyntax AddReturnToVoidMethod(BlockSyntax oldBody)
        {
            var expression = SyntaxFactoryExtensions.NumericLiteralExpression(_virtualizationContext.DataIndexFake);
            //class level interpreter
            var returnStatement = SyntaxFactory.ReturnStatement(expression).NormalizeWhitespace();

            if (_virtualizationContext.MethodLevelOn)
            {
                returnStatement = SyntaxFactory.ReturnStatement();
            }

            var list = oldBody.Statements;
            list = list.Add(returnStatement);
            oldBody = oldBody.WithStatements(list);

            return oldBody;
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/RenameVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    class RenameVisitor : CSharpSyntaxRewriter
    {
        private string oldName;
        private string newName;

        public RenameVisitor(string oldName, string newName)
        {
            this.oldName = oldName;
            this.newName = newName;
        }

        public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
        {
            string name = node.Identifier.ValueText;
            if (!name.Equals(oldName))
                return node;

            var newIdentifier = SyntaxFactory.IdentifierName(newName).WithTriviaFrom(node);
            return newIdentifier;
        }

        public override SyntaxToken VisitToken(SyntaxToken token)
        {
            if(token.Kind() != SyntaxKind.IdentifierToken)
                return token;
            string name = token.ValueText;
            if (!name.Equals(oldName))
                return token;

            var newToken = SyntaxFactory.Identifier(newName);
            return newToken;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/TriviaRemovalVisitor.cs
================================================
ï»¿using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;

namespace CodeVirtualization_Console.Visitors
{
    class TriviaRemovalVisitor : CSharpSyntaxRewriter
    {

        public static readonly TriviaRemovalVisitor Instance = new TriviaRemovalVisitor();

        public override SyntaxNode Visit(SyntaxNode node)
        {
            node = base.Visit(node);
            if (node == null)
                return node;
            node = node.WithoutTrivia();
            
            return node;
        }

        
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/IfRefactoring/IfBranchesRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeVirtualization_Console.Visitors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    /// <summary>
    /// Adds block paranthesis to body if only one statement in either branches
    /// </summary>
    class IfBranchesRefactoringVisitor : CSharpSyntaxRewriter
    {
        
        public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
        {
            var nodeVisited = node;
            var trueTrailing = nodeVisited.GetTrailingTrivia();
            var trueLeading = nodeVisited.GetLeadingTrivia();
            var trueBranch = nodeVisited.Statement;
            var trueBlock = ToBlockSyntax(trueBranch, trueLeading, trueTrailing);
            if (!trueBranch.Equals(trueBlock))
                nodeVisited = nodeVisited.WithStatement(trueBlock);

            var falseBranch = nodeVisited.Else;
            if (falseBranch == null)
                return nodeVisited;

            var falseLeading = falseBranch.GetLeadingTrivia();
            var falseTrailing = falseBranch.GetTrailingTrivia();
            var falseStatement = falseBranch.Statement ;
            var falseBlock = ToBlockSyntax(falseStatement, falseLeading, falseTrailing);
            if (!falseStatement.Equals(falseBlock))
            {
                falseBranch = falseBranch.WithStatement(falseBlock);
                nodeVisited = nodeVisited.WithElse(falseBranch);
            }

            return nodeVisited;
        }


        private BlockSyntax ToBlockSyntax(StatementSyntax body, SyntaxTriviaList leading, SyntaxTriviaList trailing)
        {

            //TODO: fix trivia
            var bracketLeadingTrivia = leading.Insert(0, SyntaxFactory.EndOfLine(Environment.NewLine));
            List<StatementSyntax> statements = new List<StatementSyntax>();
            if (body.Kind() == SyntaxKind.Block)
            {
                body = (StatementSyntax)Visit(body);
                return (BlockSyntax) body;
            }
            else
            {
                var leadingTrivia = body.GetLeadingTrivia();
                body = (StatementSyntax) Visit(body);
                statements.Add(body);   
            }
            
            BlockSyntax block = SyntaxFactory.Block(statements);
            
            block = block.WithOpenBraceToken(
                SyntaxFactory.Token(SyntaxKind.OpenBraceToken)
                    .WithLeadingTrivia(bracketLeadingTrivia)
                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                    );
            block = block.WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken).
                WithLeadingTrivia(bracketLeadingTrivia).
                WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)));

            return block;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            oldBody = (BlockSyntax)this.Visit(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/IfRefactoring/IfConditionRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    class IfConditionRefactoringVisitor : CSharpSyntaxRewriter
    {
        private static int CONDITION_COUNTER = 0;
        private static string CONDITION_VAR = "var_ifCondition_";

        private static string ConditionIdentifier
        {
            get { return CONDITION_VAR + CONDITION_COUNTER++; }
        }

        private readonly List<ExpressionSyntax> markedNodes = new List<ExpressionSyntax>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>>();


        public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
        {
            var nodeVisited = (IfStatementSyntax) base.VisitIfStatement(node);
            
            var condition = nodeVisited.Condition;
            if (condition.Kind() == SyntaxKind.IdentifierName)
                return nodeVisited;

            string conditionVarIdentifier = ConditionIdentifier;
            var newConditionVar = SyntaxFactoryExtensions.LocalVariableDeclaration(conditionVarIdentifier,
                condition, SyntaxKind.BoolKeyword).NormalizeWhitespace().WithTriviaFrom(nodeVisited);
            var newCondition = SyntaxFactory.IdentifierName(conditionVarIdentifier).WithTriviaFrom(condition);

            markedNodes.Add(condition);
            replacementNodes.Add(new Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>(condition, newCondition, newConditionVar));

            return nodeVisited;
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            oldBody = oldBody.TrackNodes(this.markedNodes);
            foreach (var tuple in this.replacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);
                if (currentA != null)
                {
                    var ifStatement = currentA.Parent;
                    oldBody = oldBody.InsertNodesBefore(ifStatement, new List<SyntaxNode>() { tuple.Item3});
                    var currentB = oldBody.GetCurrentNode(tuple.Item1);
                    oldBody = oldBody.ReplaceNode(currentB, tuple.Item2);
                }
            }
            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/LoopRefactoring/DoWhileConditionRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors.LoopRefactoring
{
    class DoWhileConditionRefactoringVisitor : CSharpSyntaxRewriter
    {
        private static int CONDITION_COUNTER = 0;
        private static string CONDITION_VAR = "var_doWhileCondition_";

        private static string ConditionIdentifier
        {
            get { return CONDITION_VAR + CONDITION_COUNTER++; }
        }

        private SyntaxNode currentWhileNode;

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax, DoStatementSyntax>> whileReplacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax, DoStatementSyntax>>();

        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> continueStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();
        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> breakStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();

        public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
        {
            currentWhileNode = node;
            continueStatements.Add(currentWhileNode, new List<SyntaxNode>());
            breakStatements.Add(currentWhileNode, new List<SyntaxNode>());
            var nodeVisited = (DoStatementSyntax) base.VisitDoStatement(node);
            
            var condition = nodeVisited.Condition;
            if (condition.Kind() == SyntaxKind.IdentifierName)  //check if the code was formatted before to while(condition)
                return nodeVisited; //return if already refactored 
            
            string conditionVarIdentifier = ConditionIdentifier;
            var newConditionVar = SyntaxFactoryExtensions.LocalVariableDeclaration(conditionVarIdentifier,
                condition, SyntaxKind.BoolKeyword).NormalizeWhitespace().WithTriviaFrom(nodeVisited);
            var newCondition = SyntaxFactory.IdentifierName(conditionVarIdentifier).WithTriviaFrom(condition);

            markedNodes.Add(condition);
            markedNodes.Add(node);
            whileReplacementNodes.Add(new Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax, DoStatementSyntax>(condition, newCondition, newConditionVar, node));

            return nodeVisited;
        }

        public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
        {
            if (currentWhileNode == null)
                return node;
            continueStatements[currentWhileNode].Add(node);
            return node;
        }

        public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
        {
            if (currentWhileNode == null)
                return node;
            breakStatements[currentWhileNode].Add(node);
            return node;
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            List<SyntaxNode> nodesToTrack = this.markedNodes;
            var continueSts = continueStatements.SelectMany(x => x.Value);
            var breakSts = breakStatements.SelectMany(x => x.Value);
            nodesToTrack.AddRange(continueSts);
            nodesToTrack.AddRange(breakSts);
            oldBody = oldBody.TrackNodes(nodesToTrack);
            foreach (var tuple in this.whileReplacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);
                if (currentA != null)
                {
                    //create new statement
                    var localCondition = tuple.Item3 as LocalDeclarationStatementSyntax;
                    var initializer = localCondition.Declaration.Variables.First();
                    var updateCondition = SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(initializer.Identifier), initializer.Initializer.Value));

                    var whileStatement = currentA.Parent;                    
                    var trueCondition = SyntaxFactoryExtensions.LocalVariableDeclaration(initializer.Identifier.Text, SyntaxFactoryExtensions.BooleanLiteralExpression(true), SyntaxKind.BoolKeyword).NormalizeWhitespace().WithTriviaFrom(localCondition);
                    oldBody = oldBody.InsertNodesBefore(whileStatement, new List<SyntaxNode>() { trueCondition });
                    var currentB = oldBody.GetCurrentNode(tuple.Item1);
                    oldBody = oldBody.ReplaceNode(currentB, tuple.Item2);
                    //update continue statements
                    foreach (var cont in continueStatements[tuple.Item4])
                    {
                        var currentContinue = oldBody.GetCurrentNode(cont);
                        oldBody = oldBody.ReplaceNode(currentContinue, new List<SyntaxNode>() { updateCondition, cont });
                    }
                    //update break statements
                    foreach (var brk in breakStatements[tuple.Item4])
                    {
                        var currentBreak = oldBody.GetCurrentNode(brk);
                        var invalidateCondition = SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(initializer.Identifier), SyntaxFactoryExtensions.BooleanLiteralExpression(false)));
                        oldBody = oldBody.ReplaceNode(currentBreak, new List<SyntaxNode>() { invalidateCondition, SyntaxFactory.ContinueStatement() });
                    }
                    var currentWhile = oldBody.GetCurrentNode(tuple.Item4);
                    //modify body
                    var whileBody = currentWhile.Statement as BlockSyntax;
                    
                    var newStatements = whileBody.Statements.Add(updateCondition);
                    whileBody = whileBody.WithStatements(newStatements);
                    //convert DoWhile into While
                    var newWhile = SyntaxFactory.WhileStatement(SyntaxFactory.IdentifierName(initializer.Identifier), whileBody);
                    oldBody = oldBody.ReplaceNode(currentWhile, newWhile);
                }
            }
            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            whileReplacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/LoopRefactoring/ForConditionRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors.LoopRefactoring
{
    /// <summary>
    /// Refactors a FOR statemetn into a WHILE.
    /// FOR refactoring visitor must be called before the WHILE refactoring visitor
    /// </summary>
    class ForConditionRefactoringVisitor : CSharpSyntaxRewriter
    {
        private static int INDEX_VAR_COUNTER = 0;
        private static string INDEX_VAR = "var_forIndex_";

        private static string ConditionIdentifier
        {
            get { return INDEX_VAR + INDEX_VAR_COUNTER++; }
        }

        private SyntaxNode currentForNode;

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple< VariableDeclarationSyntax, ExpressionSyntax, ExpressionSyntax, ForStatementSyntax>> forReplacementNodes =
            new List<Tuple< VariableDeclarationSyntax, ExpressionSyntax, ExpressionSyntax, ForStatementSyntax>>();

        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> continueStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();
        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> breakStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();

        public override SyntaxNode VisitForStatement(ForStatementSyntax node)
        {
            currentForNode = node;
            continueStatements.Add(currentForNode, new List<SyntaxNode>());
            breakStatements.Add(currentForNode, new List<SyntaxNode>());
            var nodeVisited = (ForStatementSyntax)base.VisitForStatement(node);

            if (nodeVisited.Incrementors.Count() > 1)
                throw new NotImplementedException("Virtualization: No support for multiple incrementors in FOR");

            var indexer = nodeVisited.Declaration;
            var condition = nodeVisited.Condition;
            var incrementor = nodeVisited.Incrementors.First();

            markedNodes.Add(node);            
            forReplacementNodes.Add(new Tuple< VariableDeclarationSyntax, ExpressionSyntax, ExpressionSyntax, ForStatementSyntax>( indexer, condition, incrementor, node));

            return nodeVisited;
        }

        public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
        {
            if (currentForNode == null)
                return node;
            continueStatements[currentForNode].Add(node);
            return node;
        }

        public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
        {
            if (currentForNode == null)
                return node;
            breakStatements[currentForNode].Add(node);
            return node;
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            List<SyntaxNode> nodesToTrack = this.markedNodes;
            var continueSts = continueStatements.SelectMany(x => x.Value);
            var breakSts = breakStatements.SelectMany(x => x.Value);
            nodesToTrack.AddRange(continueSts);
            nodesToTrack.AddRange(breakSts);
            oldBody = oldBody.TrackNodes(nodesToTrack);

            foreach (var tuple in this.forReplacementNodes)
            {
                var currentFor = oldBody.GetCurrentNode(tuple.Item4);
                if (currentFor != null)
                {
                    string oldName = tuple.Item1.Variables.First().Identifier.ValueText;
                    string newName = ConditionIdentifier;
                    var renameVisitor = new RenameVisitor(oldName, newName);
                    var newIndexer = (VariableDeclarationSyntax)renameVisitor.Visit(tuple.Item1);

                    oldBody = oldBody.InsertNodesBefore(currentFor, new List<SyntaxNode>() { SyntaxFactory.LocalDeclarationStatement(newIndexer) });                    
                    var newCurrentFor = oldBody.GetCurrentNode(tuple.Item4);
                    //create while
                    var whileBody = currentFor.Statement as BlockSyntax;
                    //update continue statements
                    foreach (var cont in continueStatements[tuple.Item4])
                    {
                        var currentContinue = whileBody.GetCurrentNode(cont);
                        whileBody = whileBody.ReplaceNode(currentContinue, new List<SyntaxNode>() { SyntaxFactory.ExpressionStatement(tuple.Item3), cont });
                    }
                    //update break statements
                    foreach (var brk in breakStatements[tuple.Item4])
                    {
                        var currentBreak = whileBody.GetCurrentNode(brk);
                        whileBody = whileBody.ReplaceNode(currentBreak, new List<SyntaxNode>() { SyntaxFactory.ExpressionStatement(tuple.Item3), brk });
                    }
                    var newStatements = whileBody.Statements.Add(SyntaxFactory.ExpressionStatement(tuple.Item3));
                    whileBody = whileBody.WithStatements(newStatements);
                    var whileStatement = SyntaxFactory.WhileStatement(tuple.Item2, whileBody);
                    whileStatement = (WhileStatementSyntax)renameVisitor.Visit(whileStatement);

                    //updateFor
                    oldBody = oldBody.ReplaceNode(newCurrentFor, whileStatement);                    
                }
            }
            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            forReplacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/LoopRefactoring/ForEachConditionRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors.LoopRefactoring
{
    /// <summary>
    /// Refactors a FOR statemetn into a WHILE.
    /// FOR refactoring visitor must be called before the WHILE refactoring visitor
    /// </summary>
    class ForEachConditionRefactoringVisitor : CSharpSyntaxRewriter
    {
        private static int INDEX_VAR_COUNTER = 0;
        private static string INDEX_VAR = "var_forEachIndex_";

        private static string ConditionIdentifier
        {
            get { return INDEX_VAR + INDEX_VAR_COUNTER++; }
        }

        private SyntaxNode currentForNode;

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple< VariableDeclarationSyntax, ExpressionSyntax, ExpressionSyntax, ForStatementSyntax>> forReplacementNodes =
            new List<Tuple< VariableDeclarationSyntax, ExpressionSyntax, ExpressionSyntax, ForStatementSyntax>>();

        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> continueStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();
        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> breakStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();


        public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
        {
            currentForNode = node;
            continueStatements.Add(currentForNode, new List<SyntaxNode>());
            breakStatements.Add(currentForNode, new List<SyntaxNode>());
            var nodeVisited = (ForEachStatementSyntax)base.VisitForEachStatement(node);

//            node.Identifier;
//            node.Statement
//            var indexer = nodeVisited.Declaration;
//            var condition = nodeVisited.Condition;
//            var incrementor = nodeVisited.Incrementors.First();

//            markedNodes.Add(node);            
//            forReplacementNodes.Add(new Tuple< VariableDeclarationSyntax, ExpressionSyntax, ExpressionSyntax, ForStatementSyntax>( indexer, condition, incrementor, node));

            return nodeVisited;
        }

        public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
        {
            if (currentForNode == null)
                return node;
            continueStatements[currentForNode].Add(node);
            return node;
        }

        public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
        {
            if (currentForNode == null)
                return node;
            breakStatements[currentForNode].Add(node);
            return node;
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            List<SyntaxNode> nodesToTrack = this.markedNodes;
            var continueSts = continueStatements.SelectMany(x => x.Value);
            var breakSts = breakStatements.SelectMany(x => x.Value);
            nodesToTrack.AddRange(continueSts);
            nodesToTrack.AddRange(breakSts);
            oldBody = oldBody.TrackNodes(nodesToTrack);

            foreach (var tuple in this.forReplacementNodes)
            {
                var currentFor = oldBody.GetCurrentNode(tuple.Item4);
                if (currentFor != null)
                {
                    string oldName = tuple.Item1.Variables.First().Identifier.ValueText;
                    string newName = ConditionIdentifier;
                    var renameVisitor = new RenameVisitor(oldName, newName);
                    var newIndexer = (VariableDeclarationSyntax)renameVisitor.Visit(tuple.Item1);

                    oldBody = oldBody.InsertNodesBefore(currentFor, new List<SyntaxNode>() { SyntaxFactory.LocalDeclarationStatement(newIndexer) });                    
                    var newCurrentFor = oldBody.GetCurrentNode(tuple.Item4);
                    //create while
                    var whileBody = currentFor.Statement as BlockSyntax;
                    //update continue statements
                    foreach (var cont in continueStatements[tuple.Item4])
                    {
                        var currentContinue = whileBody.GetCurrentNode(cont);
                        whileBody = whileBody.ReplaceNode(currentContinue, new List<SyntaxNode>() { SyntaxFactory.ExpressionStatement(tuple.Item3), cont });
                    }
                    //update break statements
                    foreach (var brk in breakStatements[tuple.Item4])
                    {
                        var currentBreak = whileBody.GetCurrentNode(brk);
                        whileBody = whileBody.ReplaceNode(currentBreak, new List<SyntaxNode>() { SyntaxFactory.ExpressionStatement(tuple.Item3), brk });
                    }
                    var newStatements = whileBody.Statements.Add(SyntaxFactory.ExpressionStatement(tuple.Item3));
                    whileBody = whileBody.WithStatements(newStatements);
                    var whileStatement = SyntaxFactory.WhileStatement(tuple.Item2, whileBody);
                    whileStatement = (WhileStatementSyntax)renameVisitor.Visit(whileStatement);

                    //updateFor
                    oldBody = oldBody.ReplaceNode(newCurrentFor, whileStatement);                    
                }
            }
            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            forReplacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/LoopRefactoring/LoopBodyRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors.LoopRefactoring
{
    /// <summary>
    /// Adds parenthesis to body if only one statement in the loop
    /// </summary>
    class LoopBodyRefactoringVisitor : CSharpSyntaxRewriter
    {


        public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
        {
            var body = node.Statement;
            var bodyBlock = ToBlockSyntax(body);
            if (!bodyBlock.Equals(body))
                node = node.WithStatement(bodyBlock);
            return node;
        }

        public override SyntaxNode VisitForStatement(ForStatementSyntax node)
        {            
            var body = node.Statement;
            var bodyBlock = ToBlockSyntax(body);
            if (!bodyBlock.Equals(body))
                node = node.WithStatement(bodyBlock);
            return node;
        }

        public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
        {
            var body = node.Statement;
            var bodyBlock = ToBlockSyntax(body);
            if (!bodyBlock.Equals(body))
                node = node.WithStatement(bodyBlock);
            return node;
        }

        public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
        {
            var body = node.Statement;
            var bodyBlock = ToBlockSyntax(body);
            if (!bodyBlock.Equals(body))
                node = node.WithStatement(bodyBlock);
            return node;
        }

        private BlockSyntax ToBlockSyntax(StatementSyntax body)
        {
            List<StatementSyntax> statements = new List<StatementSyntax>();
            if (body.Kind() == SyntaxKind.Block)
            {
                body = (StatementSyntax)Visit(body);
                return (BlockSyntax)body;
            }
            else
            {
                var leadingTrivia = body.GetLeadingTrivia();
                body = (StatementSyntax)Visit(body);
                statements.Add(body);
            }

            BlockSyntax block = SyntaxFactory.Block(statements);

            block = block.WithOpenBraceToken(
                SyntaxFactory.Token(SyntaxKind.OpenBraceToken)
                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                    );
            block = block.WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken).
                WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)));

            return block;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            oldBody = (BlockSyntax)this.Visit(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/LoopRefactoring/WhileConditionRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors.LoopRefactoring
{
    class WhileConditionRefactoringVisitor : CSharpSyntaxRewriter
    {
        private static int CONDITION_COUNTER = 0;
        private static string CONDITION_VAR = "var_whileCondition_";

        private static string ConditionIdentifier
        {
            get { return CONDITION_VAR + CONDITION_COUNTER++; }
        }

        private SyntaxNode currentWhileNode;

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax, WhileStatementSyntax>> whileReplacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax, WhileStatementSyntax>>();

        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> continueStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();
        private readonly Dictionary<SyntaxNode, List<SyntaxNode>> breakStatements = new Dictionary<SyntaxNode, List<SyntaxNode>>();

        public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
        {
            currentWhileNode = node;
            continueStatements.Add(currentWhileNode, new List<SyntaxNode>());
            breakStatements.Add(currentWhileNode, new List<SyntaxNode>());
            var nodeVisited = (WhileStatementSyntax) base.VisitWhileStatement(node);
            
            var condition = nodeVisited.Condition;
            if (condition.Kind() == SyntaxKind.IdentifierName)  //check if the code was formatted before to while(condition)
                return nodeVisited;
            
            string conditionVarIdentifier = ConditionIdentifier;
            var newConditionVar = SyntaxFactoryExtensions.LocalVariableDeclaration(conditionVarIdentifier,
                condition, SyntaxKind.BoolKeyword).NormalizeWhitespace().WithTriviaFrom(nodeVisited);
            var newCondition = SyntaxFactory.IdentifierName(conditionVarIdentifier).WithTriviaFrom(condition);

            markedNodes.Add(condition);
            markedNodes.Add(node);
            whileReplacementNodes.Add(new Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax, WhileStatementSyntax>(condition, newCondition, newConditionVar, node));

            return nodeVisited;
        }

        public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
        {
            if (currentWhileNode == null)
                return node;
            continueStatements[currentWhileNode].Add(node);
            return node;
        }

        public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
        {
            if (currentWhileNode == null)
                return node;
            breakStatements[currentWhileNode].Add(node);
            return node;
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            List<SyntaxNode> nodesToTrack = this.markedNodes;
            var continueSts = continueStatements.SelectMany(x => x.Value);
            var breakSts = breakStatements.SelectMany(x => x.Value);
            nodesToTrack.AddRange(continueSts);
            nodesToTrack.AddRange(breakSts);
            oldBody = oldBody.TrackNodes(nodesToTrack);
            foreach (var tuple in this.whileReplacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);
                if (currentA != null)
                {
                    //create new statement
                    var localCondition = tuple.Item3 as LocalDeclarationStatementSyntax;
                    var initializer = localCondition.Declaration.Variables.First();
                    var updateCondition = SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(initializer.Identifier), initializer.Initializer.Value));

                    var whileStatement = currentA.Parent;
                    oldBody = oldBody.InsertNodesBefore(whileStatement, new List<SyntaxNode>() { tuple.Item3 });
                    var currentB = oldBody.GetCurrentNode(tuple.Item1);
                    oldBody = oldBody.ReplaceNode(currentB, tuple.Item2);
                    //update continue statements
                    foreach (var cont in continueStatements[tuple.Item4])
                    {
                        var currentContinue = oldBody.GetCurrentNode(cont);
                        oldBody = oldBody.ReplaceNode(currentContinue, new List<SyntaxNode>() { updateCondition, cont });
                    }
                    //update break statements
                    foreach (var brk in breakStatements[tuple.Item4])
                    {
                        var currentBreak = oldBody.GetCurrentNode(brk);
                        var invalidateCondition = SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                        SyntaxFactory.IdentifierName(initializer.Identifier), SyntaxFactoryExtensions.BooleanLiteralExpression(false)));
                        oldBody = oldBody.ReplaceNode(currentBreak, new List<SyntaxNode>() { invalidateCondition, SyntaxFactory.ContinueStatement() });
                    }
                    var currentWhile = oldBody.GetCurrentNode(tuple.Item4);
                    //modify body
                    var whileBody = currentWhile.Statement as BlockSyntax;
                    
                    var newStatements = whileBody.Statements.Add(updateCondition);
                    whileBody = whileBody.WithStatements(newStatements);
                    //updateWhile
                    var newWhile = currentWhile.WithStatement(whileBody);
                    oldBody = oldBody.ReplaceNode(currentWhile, newWhile);
                }
            }
            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            whileReplacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/OperationSimplifiers/AdditiveOperationSimplifierVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    /// <summary>
    /// transforms sum = a + b + c + d; into
    /// v1 = a + b; v2 = v1 + c; sum = v2 + d;
    /// Applied for + â€“
    /// </summary>
    class AdditiveOperationSimplifierVisitor : CSharpSyntaxRewriter
    {
        private VirtualizationContext virtualizationContext;
        private static int VAR_COUNTER = 0;
        private static string VAR_NAME = "addTemp_";

        private int bottomUp = 0;

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>>();

        public AdditiveOperationSimplifierVisitor(VirtualizationContext virtualizationContext)
        {
            this.virtualizationContext = virtualizationContext;
        }

        public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            node = (BinaryExpressionSyntax) base.VisitBinaryExpression(node);

            if ((node.Kind() != SyntaxKind.AddExpression) &&
                (node.Kind() != SyntaxKind.SubtractExpression)
                )
            {
                return node;
            }

            if (node.Parent.Kind() == SyntaxKind.SimpleAssignmentExpression)
            {
                bottomUp = 0;
                return node;
            }

            if (node.Parent.Kind() == SyntaxKind.EqualsValueClause)
            {
                bottomUp = 0;
                return node;
            }

            int markedNodesCount = markedNodes.Count();
            if (markedNodesCount > 0)
            {
                bottomUp++;
                return node;
            }

            if (bottomUp+2 < VirtualizationContext.MAX_OPERANDS)
            {
                bottomUp++;
                return node;
            }
                
            string tempName = VAR_NAME + VAR_COUNTER++;

            var tempVar = SyntaxFactoryExtensions.LocalVariableDeclaration(tempName, node);
            var tempIdentifier = SyntaxFactory.IdentifierName(tempName);
            var tuple = new Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>(node, tempIdentifier, tempVar);
            var parent = GetParentExpression(node);
            markedNodes.Add(parent);
            replacementNodes.Add(tuple);

            bottomUp ++;

            return node;
        }
        
        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() ==SyntaxKind.LocalDeclarationStatement)
                ||  (node.Kind() == SyntaxKind.ReturnStatement))
                if(node.Parent!=null)
                    if (node.Parent.Kind() == SyntaxKind.Block) 
                        return node;

            return GetParentExpression(node.Parent);
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            var markedNodesCount = markedNodes.Count;
            while (markedNodesCount > 0)
            {
                var firstExpression = replacementNodes[0];
                var firstParent = markedNodes[0];
                oldBody = oldBody.TrackNodes(new List<SyntaxNode>() { firstExpression.Item1, firstParent });
                var currentParent = oldBody.GetCurrentNode(firstParent);
                oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item3 });
                var currentExpression = oldBody.GetCurrentNode(firstExpression.Item1);
                oldBody = oldBody.ReplaceNode(currentExpression, firstExpression.Item2);

                oldBody = this.Refactor(oldBody);

                markedNodesCount = markedNodes.Count;
            }

            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            bottomUp = 0;

            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);
            return oldBody;
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/OperationSimplifiers/ComparisonSignSimplifierVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    class ComparisonSignSimplifierVisitor : CSharpSyntaxRewriter
    {


        public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            node = (BinaryExpressionSyntax) base.VisitBinaryExpression(node);

            var comparisonKind = node.Kind();
            if (comparisonKind == SyntaxKind.GreaterThanExpression)
            {
                comparisonKind = SyntaxKind.LessThanExpression;
            }
            else if (comparisonKind == SyntaxKind.GreaterThanOrEqualExpression)
            {
                comparisonKind = SyntaxKind.LessThanOrEqualExpression;
            }
            else
                return node;

            var left = node.Left;
            var right = node.Right;

            var inverted = SyntaxFactory.BinaryExpression(comparisonKind, right, left);
            node = inverted;

            return node;
        }



    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/OperationSimplifiers/InvocationExpressionSimplifier.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    /// <summary>
    /// Expression: var p1 = car.GetEngine().GetPistons().First().GetSize();
    /// is refactored to:
    /// 
    /// var e1 = car.GetEngine();
    /// var e2 = e1.GetPistons();
    /// var e3 = e2.First();
    /// var p1 = e3.GetSize();
    /// </summary>
    class InvocationExpressionSimplifier : CSharpSyntaxRewriter
    {
        private static int VAR_COUNTER = 0;
        private static string VAR_NAME = "invocationTemp_";

        private int bottomUp = 0;

        private static string TemporaryVarIdentifier
        {
            get { return VAR_NAME + VAR_COUNTER++; }
        }

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>>();

        public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
        {
            node = (InvocationExpressionSyntax) base.VisitInvocationExpression(node);

            if ((node.Kind() != SyntaxKind.InvocationExpression))
            {
                return node;
            }
            //only one invocation is skipped.
            if (node.Parent.Kind() == SyntaxKind.SimpleAssignmentExpression)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.EqualsValueClause)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.Block)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.ExpressionStatement)
                if (node.Parent.Parent.Kind() == SyntaxKind.Block)
                {
                    bottomUp = 0;
                    return node;
                }

            int markedNodesCount = markedNodes.Count();
            if (markedNodesCount > 0)
            {
                bottomUp++;
                return node;
            }

            if (bottomUp + 2 < VirtualizationContext.MAX_INVOCATIONS)
            {
                bottomUp++;
                return node;
            }

            string tempName = TemporaryVarIdentifier;

            var tempVar = SyntaxFactoryExtensions.LocalVariableDeclaration(tempName, node);
            var tempIdentifier = SyntaxFactory.IdentifierName(tempName);
            var tuple = new Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>(node, tempIdentifier, tempVar);
            var parent = GetParentExpression(node);
            markedNodes.Add(parent);
            replacementNodes.Add(tuple);
            bottomUp++;
            return node;
        }

        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                    || (node.Kind() == SyntaxKind.ReturnStatement))
                if (node.Parent != null)
                    if (node.Parent.Kind() == SyntaxKind.Block)
                        return node;

            return GetParentExpression(node.Parent);
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            var markedNodesCount = markedNodes.Count;
            while (markedNodesCount > 0)
            {
                var firstExpression = replacementNodes[0];
                var firstParent = markedNodes[0];
                oldBody = oldBody.TrackNodes(new List<SyntaxNode>() { firstExpression.Item1, firstParent });
                var currentParent = oldBody.GetCurrentNode(firstParent);
                oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item3 });
                var currentExpression = oldBody.GetCurrentNode(firstExpression.Item1);
                oldBody = oldBody.ReplaceNode(currentExpression, firstExpression.Item2);

                oldBody = this.Refactor(oldBody);

                markedNodesCount = markedNodes.Count;
            }

            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            bottomUp = 0;
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/OperationSimplifiers/MemberAccessExpressionSimplifier.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    /// <summary>
    /// Expression: var p1 = car.GetEngine().GetPistons().First().GetSize();
    /// is refactored to:
    /// 
    /// var e1 = car.GetEngine();
    /// var e2 = e1.GetPistons();
    /// var e3 = e2.First();
    /// var p1 = e3.GetSize();
    /// </summary>
    class MemberAccessExpressionSimplifier : CSharpSyntaxRewriter
    {
        private static int VAR_COUNTER = 0;
        private static string VAR_NAME = "memberTemp_";
        private int bottomUp = 0;
        private static string TemporaryVarIdentifier
        {
            get { return VAR_NAME + VAR_COUNTER++; }
        }

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>>();

        public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
        {
            
            node = (MemberAccessExpressionSyntax) base.VisitMemberAccessExpression(node);

            if ((node.Kind() != SyntaxKind.SimpleMemberAccessExpression))
            {
                return node;
            }
            //only one invocation is skipped.
            if (node.Parent.Kind() == SyntaxKind.SimpleAssignmentExpression)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.InvocationExpression)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.EqualsValueClause)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.Block)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.ExpressionStatement)
                if (node.Parent.Parent.Kind() == SyntaxKind.Block)
                {
                    bottomUp = 0;
                    return node;
                }


            int markedNodesCount = markedNodes.Count();
            if (markedNodesCount > 0)
            {
                bottomUp++;
                return node;
            }

            if (bottomUp + 2 < VirtualizationContext.MAX_OPERANDS)
            {
                bottomUp++;
//                return node;
            }

            string tempName = TemporaryVarIdentifier;

            var tempVar = SyntaxFactoryExtensions.LocalVariableDeclaration(tempName, node);
            var tempIdentifier = SyntaxFactory.IdentifierName(tempName);
            var tuple = new Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>(node, tempIdentifier, tempVar);
            var parent = GetParentExpression(node);
            markedNodes.Add(parent);
            replacementNodes.Add(tuple);
            bottomUp++;
            return node;
        }

        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                    || (node.Kind() == SyntaxKind.ReturnStatement))
                if (node.Parent != null)
                    if (node.Parent.Kind() == SyntaxKind.Block)
                        return node;

            return GetParentExpression(node.Parent);
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            var markedNodesCount = markedNodes.Count;
            while (markedNodesCount > 0)
            {
                var firstExpression = replacementNodes[0];
                var firstParent = markedNodes[0];
                oldBody = oldBody.TrackNodes(new List<SyntaxNode>() { firstExpression.Item1, firstParent });
                var currentParent = oldBody.GetCurrentNode(firstParent);
                oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item3 });
                var currentExpression = oldBody.GetCurrentNode(firstExpression.Item1);
                oldBody = oldBody.ReplaceNode(currentExpression, firstExpression.Item2);

                oldBody = this.Refactor(oldBody);

                markedNodesCount = markedNodes.Count;
            }

            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            bottomUp = 0;
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/OperationSimplifiers/MultiplicativeOperationSimplifierVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    /// <summary>
    /// transforms sum = a * b * c * d; into
    /// v1 = a * b; v2 = v1 * c; sum = v2 * d;
    /// Applied for * / %
    /// </summary>
    class MultiplicativeOperationSimplifierVisitor : CSharpSyntaxRewriter
    {
        private VirtualizationContext virtualizationContext;
        private static int VAR_COUNTER = 0;
        private static string VAR_NAME = "mulTemp_";

        private int bottomUp = 0;

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>>();

        public MultiplicativeOperationSimplifierVisitor(VirtualizationContext virtualizationContext)
        {
            this.virtualizationContext = virtualizationContext;
        }

        public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
        {
            node = (BinaryExpressionSyntax) base.VisitBinaryExpression(node);

            if ((node.Kind() != SyntaxKind.MultiplyExpression) && 
                (node.Kind() != SyntaxKind.DivideExpression) &&
                (node.Kind() != SyntaxKind.ModuloExpression)
                )
            {
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.SimpleAssignmentExpression)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.EqualsValueClause)
            {
                bottomUp = 0;
                return node;
            }

            int markedNodesCount = markedNodes.Count();
            if (markedNodesCount > 0)
            {
                bottomUp++;
                return node;
            }

            if (bottomUp + 2 < VirtualizationContext.MAX_OPERANDS)
            {
                bottomUp++;
//                return node;
            }

            string tempName = VAR_NAME + VAR_COUNTER++;

            var tempVar = SyntaxFactoryExtensions.LocalVariableDeclaration(tempName, node);
            var tempIdentifier = SyntaxFactory.IdentifierName(tempName);
            var tuple = new Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>(node, tempIdentifier, tempVar);
            var parent = GetParentExpression(node);
            markedNodes.Add(parent);
            replacementNodes.Add(tuple);

            bottomUp++;

            return node;
        }
        
        /// <summary>
        /// parent must be a block node.
        /// 
        /// IF, WHILE, FOR, SWITCH conditions are assumed to be extracted before operations are simplified.
        /// see order in MethodRefactoringVisitor.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                    || (node.Kind() == SyntaxKind.ReturnStatement) )
                if(node.Parent!=null)
                    if (node.Parent.Kind() == SyntaxKind.Block) 
                        return node;

            return GetParentExpression(node.Parent);
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            var markedNodesCount = markedNodes.Count;
            while (markedNodesCount > 0)
            {
                var firstExpression = replacementNodes[0];
                var firstParent = markedNodes[0];
                oldBody = oldBody.TrackNodes(new List<SyntaxNode>() { firstExpression.Item1, firstParent });
                var currentParent = oldBody.GetCurrentNode(firstParent);
                oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item3 });
                var currentExpression = oldBody.GetCurrentNode(firstExpression.Item1);
                oldBody = oldBody.ReplaceNode(currentExpression, firstExpression.Item2);

                oldBody = this.Refactor(oldBody);

                markedNodesCount = markedNodes.Count;
            }

            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            bottomUp = 0;
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);
            return oldBody;
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/OperationSimplifiers/ParenthesisOperationSimplifierVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    /// <summary>
    /// transforms sum = a * b * c * d; into
    /// v1 = a * b; v2 = v1 * c; sum = v2 * d;
    /// Applied for * / %
    /// </summary>
    class ParenthesisOperationSimplifierVisitor : CSharpSyntaxRewriter
    {
        private VirtualizationContext virtualizationContext;
        private static int VAR_COUNTER = 0;
        private static string VAR_NAME = "parTemp_";

        private int bottomUp = 0;

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>>();

        public ParenthesisOperationSimplifierVisitor(VirtualizationContext virtualizationContext)
        {
            this.virtualizationContext = virtualizationContext;
        }

        public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
        {
            node = (ParenthesizedExpressionSyntax) base.VisitParenthesizedExpression(node);

            if (node.Parent.Kind() == SyntaxKind.SimpleAssignmentExpression)
            {
                bottomUp = 0;
                return node;
            }
            if (node.Parent.Kind() == SyntaxKind.EqualsValueClause)
            {
                bottomUp = 0;
                return node;
            }

            int markedNodesCount = markedNodes.Count();
            if (markedNodesCount > 0)
            {
                bottomUp++;
                return node;
            }

            if (bottomUp + 2 < VirtualizationContext.MAX_OPERANDS)
            {
                bottomUp++;
                return node;
            }

            string tempName = VAR_NAME + VAR_COUNTER++;

            var tempVar = SyntaxFactoryExtensions.LocalVariableDeclaration(tempName, node.Expression);
            var tempIdentifier = SyntaxFactory.IdentifierName(tempName);
            var tuple = new Tuple<ExpressionSyntax, IdentifierNameSyntax, SyntaxNode>(node, tempIdentifier, tempVar);
            var parent = GetParentExpression(node);
            markedNodes.Add(parent);
            replacementNodes.Add(tuple);
            bottomUp++;
            return node;
        }
        
        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                || (node.Kind() == SyntaxKind.ReturnStatement))
                if (node.Parent!=null)
                    if (node.Parent.Kind() == SyntaxKind.Block) 
                        return node;

            return GetParentExpression(node.Parent);
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            var markedNodesCount = markedNodes.Count;
            while (markedNodesCount > 0)
            {
                var firstExpression = replacementNodes[0];
                var firstParent = markedNodes[0];
                oldBody = oldBody.TrackNodes(new List<SyntaxNode>() { firstExpression.Item1, firstParent });
                var currentParent = oldBody.GetCurrentNode(firstParent);
                oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item3 });
                var currentExpression = oldBody.GetCurrentNode(firstExpression.Item1);
                oldBody = oldBody.ReplaceNode(currentExpression, firstExpression.Item2);

                oldBody = this.Refactor(oldBody);

                markedNodesCount = markedNodes.Count;
            }

            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            bottomUp = 0;
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/OperationSimplifiers/PrePostOperationVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Visitors
{
    internal class PrePostOperationVisitor : CSharpSyntaxRewriter
    {
        private static int VAR_COUNTER = 0;
        private static string VAR_NAME = "prePostTemp_";

        private static string TemporaryVarIdentifier
        {
            get { return VAR_NAME + VAR_COUNTER++; }
        }

        private readonly List<SyntaxNode> markedNodes = new List<SyntaxNode>();

        private readonly List<Tuple<SyntaxNode, IdentifierNameSyntax, int, SyntaxNode, SyntaxNode>> replacementNodes =
            new List<Tuple<SyntaxNode, IdentifierNameSyntax, int, SyntaxNode, SyntaxNode>>();

        public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
        {
            node = (PrefixUnaryExpressionSyntax)base.VisitPrefixUnaryExpression(node);

            return VisitPrePostExpression(node, null);
        }

        public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
        {
            node = (PostfixUnaryExpressionSyntax) base.VisitPostfixUnaryExpression(node);

            return VisitPrePostExpression(null, node);
        }

        public SyntaxNode VisitPrePostExpression(PrefixUnaryExpressionSyntax pre, PostfixUnaryExpressionSyntax post)
        {
            SyntaxNode node = null;
            if (pre == null)
                node = post;
            if (post == null)
                node = pre;
            if (node == null)
                return node;

            bool postDecr = (node.Kind() == SyntaxKind.PostDecrementExpression);
            bool postIncr = (node.Kind() == SyntaxKind.PostIncrementExpression);
            bool preDecr = (node.Kind() == SyntaxKind.PreDecrementExpression);
            bool preIncr = (node.Kind() == SyntaxKind.PreIncrementExpression);

            bool condition = postDecr || postIncr || preDecr || preIncr;
            if (!condition) 
                return node;
            
            int markedNodesCount = markedNodes.Count();
            if (markedNodesCount > 0)
                return node;
            ExpressionSyntax operand = null;
            int operationType = 0; // 0 - pre, 1 - post
            if (postDecr || postIncr)
            {
                operationType = 1;
                operand = ((PostfixUnaryExpressionSyntax) node).Operand;
            }
            else
            {
                operand = ((PrefixUnaryExpressionSyntax)node).Operand;
            }
                

            string tempName = TemporaryVarIdentifier + "_" + operationType;

            StatementSyntax indexUpdate = null;
            if (postIncr || preIncr)
                indexUpdate = IncrementIndex(operand);
            else if (postDecr || preDecr)
                indexUpdate = DecrementIndex(operand);

            var tempVar = SyntaxFactoryExtensions.LocalVariableDeclaration(tempName, operand);
            var tempIdentifier = SyntaxFactory.IdentifierName(tempName);
            var tuple = new Tuple<SyntaxNode, IdentifierNameSyntax, int, SyntaxNode, SyntaxNode>(node, tempIdentifier, operationType, tempVar, indexUpdate);
            var parent = GetParentExpression(node);
            markedNodes.Add(parent);
            replacementNodes.Add(tuple);

            return node;
        }

        /// <summary>
        /// index = index + 1
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private ExpressionStatementSyntax IncrementIndex(ExpressionSyntax operand)
        {
            //create incremented variable
            var rightExpression = SyntaxFactory.BinaryExpression(SyntaxKind.AddExpression, operand, SyntaxFactoryExtensions.NumericLiteralExpression(1));
            var incrementedVariable = SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, operand, rightExpression));
            return incrementedVariable;
        }

        /// <summary>
        /// index = index - 1;
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        private ExpressionStatementSyntax DecrementIndex(ExpressionSyntax operand)
        {            
            var rightExpression = SyntaxFactory.BinaryExpression(SyntaxKind.SubtractExpression, operand, SyntaxFactoryExtensions.NumericLiteralExpression(1));
            var incrementedVariable = SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, operand, rightExpression));
            return incrementedVariable;
        }



        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            var markedNodesCount = markedNodes.Count;
            while (markedNodesCount > 0)
            {
                var firstExpression = replacementNodes[0];
                var firstParent = markedNodes[0];
                oldBody = oldBody.TrackNodes(new List<SyntaxNode>() { firstExpression.Item1, firstParent });
                
                //simple increment: index++; --index;
                if (firstExpression.Item1.Parent.Kind() == SyntaxKind.ExpressionStatement)
                {
                    var currentOperation = oldBody.GetCurrentNode(firstExpression.Item1);
                    var indexUpdate = ((ExpressionStatementSyntax) firstExpression.Item5).Expression;
                    oldBody = oldBody.ReplaceNode(currentOperation, indexUpdate);
                    oldBody = this.Refactor(oldBody);
                    markedNodesCount = markedNodes.Count;
                    continue;
                }

                if (firstExpression.Item3 == 0) //pre operation type
                {
                    var currentParent = oldBody.GetCurrentNode(firstParent);
                    oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item5 });
                    currentParent = oldBody.GetCurrentNode(firstParent);
                    oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item4 });                    
                }
                else //post opertion type
                {
                    var currentParent = oldBody.GetCurrentNode(firstParent);
                    oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item4 });
                    currentParent = oldBody.GetCurrentNode(firstParent);
                    oldBody = oldBody.InsertNodesBefore(currentParent, new List<SyntaxNode>() { firstExpression.Item5 });
                }

                var updatedOperation = oldBody.GetCurrentNode(firstExpression.Item1);
                oldBody = oldBody.ReplaceNode(updatedOperation, firstExpression.Item2);
                oldBody = this.Refactor(oldBody);
                markedNodesCount = markedNodes.Count;
            }

            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();

            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                || (node.Kind() == SyntaxKind.ReturnStatement)                
                )
                if (node.Parent != null)
                    if (node.Parent.Kind() == SyntaxKind.Block)
                        return node;

            return GetParentExpression(node.Parent);
        }


        public SyntaxNode template(SyntaxNode node)
        {

            //TODO: PostDecrementExpression
            //TODO: PostIncrementExpression
            int a = 0;
            int b = 0;
            int[] c = new int[30];

            a++;
            //becomes
            a = a + 1;

            b = a++;
           //becomes
            int a1 = a;
            a = a + 1;
            b = a1;

            b = c[a++];
            //becomes
            a1 = a;
            a = a + 1;
            b = c[a];

            b = c[a++] + c[a++];
            //becomes
            a1 = a;
            a = a + 1;
            int a2 = a + 1;
            a = a + 1;
            b = c[a1] + c[a2];

            //TODO: PreDecrementExpression
            //TODO: PreIncrementExpression
            b = ++a;
            //becomes
            a = a + 1;
            a1 = a;
            b = a1;

            b = c[++a] + c[++a];
            //becomes
            a = a + 1;
            a1 = a;
            a = a + 1;
            a2 = a;
            b = c[a1] + c[a2];

            return node;

        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/SwitchRefactoring/SwitchBreakRefactoring.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    class SwitchBreakRefactoringVisitor : CSharpSyntaxRewriter
    {

        public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
        {
            node = (BreakStatementSyntax) base.VisitBreakStatement(node);
            if (node == null)
                return node;

            bool inSwitch = IsSwitchParent(node);
            if (inSwitch)
                return null;

            return node;
        }


        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                    || (node.Kind() == SyntaxKind.ReturnStatement))
                if (node.Parent != null)
                    if (node.Parent.Kind() == SyntaxKind.Block)
                        return node;

            return GetParentExpression(node.Parent);
        }

        public bool IsSwitchParent(SyntaxNode node)
        {
            if (node == null)
                return false;
            if ((node.Kind() == SyntaxKind.SwitchSection))
                return true;
            if ((node.Kind() == SyntaxKind.WhileStatement))
                return false;
            if ((node.Kind() == SyntaxKind.ForEachStatement))
                return false;
            if ((node.Kind() == SyntaxKind.ForStatement))
                return false;
            if ((node.Kind() == SyntaxKind.DoStatement))
                return false;
            return IsSwitchParent(node.Parent);
        }

    
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/SwitchRefactoring/SwitchConditionRefactoring.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    class SwitchConditionRefactoringVisitor : CSharpSyntaxRewriter
    {
        private static int INDEX_VAR_COUNTER = 0;
        private static string INDEX_VAR = "switchCondition_";

        private static string ConditionIdentifier
        {
            get { return INDEX_VAR + INDEX_VAR_COUNTER++; }
        }

        private readonly List<ExpressionSyntax> markedNodes = new List<ExpressionSyntax>();

        private readonly List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>> replacementNodes =
            new List<Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>>();



        public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
        {
            node = (SwitchStatementSyntax) base.VisitSwitchStatement(node);

            var condition = node.Expression;

            if (condition.Kind() == SyntaxKind.IdentifierName)
                return node;

            string conditionVarIdentifier = ConditionIdentifier;
            var newConditionVar = SyntaxFactoryExtensions.LocalVariableDeclaration(conditionVarIdentifier,
                condition).NormalizeWhitespace().WithTriviaFrom(node);
            var newCondition = SyntaxFactory.IdentifierName(conditionVarIdentifier).WithTriviaFrom(condition);

            markedNodes.Add(condition);
            replacementNodes.Add(new Tuple<ExpressionSyntax, IdentifierNameSyntax, StatementSyntax>(condition, newCondition, newConditionVar));

            return node;
        }

       
 
        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            oldBody = oldBody.TrackNodes(this.markedNodes);
            foreach (var tuple in this.replacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);
                if (currentA != null)
                {
                    var ifStatement = currentA.Parent;
                    oldBody = oldBody.InsertNodesBefore(ifStatement, new List<SyntaxNode>() { tuple.Item3 });
                    var currentB = oldBody.GetCurrentNode(tuple.Item1);
                    oldBody = oldBody.ReplaceNode(currentB, tuple.Item2);
                }
            }
            return oldBody;
        }

        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/SwitchRefactoring/SwitchSectionRefactoring.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    class SwitchSectionRefactoringVisitor : CSharpSyntaxRewriter
    {
        public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
        {
            node = (SwitchSectionSyntax) base.VisitSwitchSection(node);
            
            var oldStatements = node.Statements;
            if (oldStatements.Count == 0) //empty case - used for fall-through
                return node;

            var caseTrailing = node.GetTrailingTrivia();
            var caseLeading = node.GetLeadingTrivia();
            var trueBlock = ToBlockSyntax(oldStatements, caseLeading, caseTrailing);
            node = node.WithStatements(trueBlock);

            return node;
        }

        private SyntaxList<StatementSyntax> ToBlockSyntax(SyntaxList<StatementSyntax> body, SyntaxTriviaList leading, SyntaxTriviaList trailing)
        {
            if (body.Count == 1)
            {
                var firstStatement = body[0];
                if (firstStatement.Kind() == SyntaxKind.Block)
                    return body;
            }
                     
            BlockSyntax block = SyntaxFactory.Block(body);
            var bracketLeadingTrivia = leading.Insert(0, SyntaxFactory.EndOfLine(Environment.NewLine));

            block = block.WithOpenBraceToken(
                SyntaxFactory.Token(SyntaxKind.OpenBraceToken)
                    .WithLeadingTrivia(bracketLeadingTrivia)
//                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                    );
            block = block.WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken).
                WithLeadingTrivia(bracketLeadingTrivia)
//                .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                );

            SyntaxList<StatementSyntax> list = new SyntaxList<StatementSyntax>();
            list = list.Add(block);

            return list;
        }


        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            oldBody = (BlockSyntax)this.Visit(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/SwitchRefactoring/SwitchStatementRefactoring.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors
{
    class SwitchStatementRefactoringVisitor : CSharpSyntaxRewriter
    {

        public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
        {
            var visitedNode = base.VisitSwitchStatement(node);
            if (visitedNode.Kind() != SyntaxKind.SwitchStatement)
                return visitedNode;

            node = visitedNode as SwitchStatementSyntax;

            var condition = node.Expression;
            var sections = node.Sections;

            var ifStatement = ChainIf(condition, sections);

            return ifStatement;
        }


        private IfStatementSyntax ChainIf(ExpressionSyntax condition, SyntaxList<SwitchSectionSyntax> sections)
        {
            List<StatementSyntax> transformedSections = new List<StatementSyntax>();

            //add default as the last section
            StatementSyntax defaultIf = null;
            foreach (var section in sections)
            {
                if (IsDefault(section))
                {
                    defaultIf = SectionToIf(condition, section);
                    continue;
                }
                var ifStatement = SectionToIf(condition, section);
                transformedSections.Add(ifStatement);
            }

            if(defaultIf != null)
                transformedSections.Add(defaultIf);

            if (transformedSections.Count == 1)
                return (IfStatementSyntax) transformedSections[0];

            IfStatementSyntax chainedIfStatement = null;
            for (int i = transformedSections.Count - 1; i >= 0; i--)
            {
                if (chainedIfStatement == null)
                {
                    var previousIfStatement = (IfStatementSyntax) transformedSections[i - 1];
                    var elseStatement = transformedSections[i];
                    chainedIfStatement = previousIfStatement.WithElse(SyntaxFactory.ElseClause(elseStatement));
                    i = i - 1;
                    continue;
                }
                var currentIfStatement = (IfStatementSyntax) transformedSections[i];
                chainedIfStatement = currentIfStatement.WithElse(SyntaxFactory.ElseClause(chainedIfStatement));
            }

            return chainedIfStatement;
        }

        private bool IsDefault(SwitchSectionSyntax section)
        {
            foreach (var label in section.Labels)
            {
                if (label.Keyword.Kind() == SyntaxKind.DefaultKeyword)
                {
                    return true;
                }
            }
            return false;
        }

        private StatementSyntax SectionToIf(ExpressionSyntax condition, SwitchSectionSyntax section)
        {
            SwitchBreakRefactoringVisitor breakRefactoring = new SwitchBreakRefactoringVisitor();
            var bodyList = section.Statements.First();
            bodyList = (StatementSyntax) breakRefactoring.Visit(bodyList);

            bool hasDefault = false;
            List<ExpressionSyntax> labelExpressions = new List<ExpressionSyntax>();
            
            foreach (var label in section.Labels)
            {
                if (label.Keyword.Kind() == SyntaxKind.DefaultKeyword)
                {
                    hasDefault = true;                    
                }
                    
                foreach (var child in label.ChildNodes())
                {                    
                    var labelCondition = (ExpressionSyntax) child;
                    if ((labelCondition.Kind() != SyntaxKind.NumericLiteralExpression) ||
                        (labelCondition.Kind() != SyntaxKind.StringLiteralExpression) ||
                        (labelCondition.Kind() != SyntaxKind.CharacterLiteralExpression) ||
                        (labelCondition.Kind() != SyntaxKind.SimpleMemberAccessExpression)
                        )
                    {
                        labelCondition = SyntaxFactory.ParenthesizedExpression(labelCondition).WithTriviaFrom(labelCondition);
                    }
                    labelExpressions.Add(labelCondition);
                    break;
                }
            }

            List<ExpressionSyntax> flagConditions = new List<ExpressionSyntax>();
            foreach (var expression in labelExpressions)
            {                
                var memberAccess = SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, condition,
                    SyntaxFactory.IdentifierName("Equals"));
                var arg = SyntaxFactory.Argument(expression);
                var argList = SyntaxFactory.SeparatedList<ArgumentSyntax>(new List<ArgumentSyntax>() {arg});
                
                var invocation = SyntaxFactory.InvocationExpression(memberAccess, SyntaxFactory.ArgumentList(argList));

                flagConditions.Add(invocation);
            }

            ExpressionSyntax ifCondition = SyntaxFactoryExtensions.BooleanLiteralExpression(true);            
            if (flagConditions.Count == 1)
                ifCondition = flagConditions[0];

            BinaryExpressionSyntax boolCondition = null;
            for (int i = 1; i < flagConditions.Count; i++)
            {
                var right = flagConditions[i];
                if (boolCondition == null)
                {
                    boolCondition = SyntaxFactory.BinaryExpression(SyntaxKind.LogicalOrExpression, flagConditions[0], right);
                }
                else
                    boolCondition = SyntaxFactory.BinaryExpression(SyntaxKind.LogicalOrExpression, boolCondition, right);
                ifCondition = boolCondition;
            }

            if (hasDefault)
            {
//                ifCondition = SyntaxFactory.BinaryExpression(SyntaxKind.LogicalOrExpression, ifCondition, SyntaxFactoryExtensions.BooleanLiteralExpression(true));
                return bodyList;
            }

            var ifStatement = SyntaxFactory.IfStatement(ifCondition, bodyList);
            return ifStatement;
        }


        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            oldBody = (BlockSyntax)this.Visit(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/RefactoringVisitors/TryCatch/TryCatchRefactoringVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.RefactoringVisitors.TryCatch
{
    class TryCatchRefactoringVisitor : CSharpSyntaxRewriter
    {

        private VirtualizationContext virtualizationContext;

        public TryCatchRefactoringVisitor(VirtualizationContext virtualizationContext)
        {
            this.virtualizationContext = virtualizationContext;
        }

        public override SyntaxNode VisitTryStatement(TryStatementSyntax node)
        {
            virtualizationContext.SetClassLevelOn();
            return base.VisitTryStatement(node);
        }

//        public override SyntaxNode VisitCatchClause(CatchClauseSyntax node)
//        {
//            return base.VisitCatchClause(node);
//        }
//
//        public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
//        {
//            return base.VisitCatchDeclaration(node);
//        }
//
//        public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
//        {
//            return base.VisitFinallyClause(node);
//        }
//
//        public override SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
//        {
//            return base.VisitCatchFilterClause(node);
//        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/TypingVisitors/MethodExplicitTypeVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeVirtualization_Console.VirtualizationVisitors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.TypingVisitors
{
    internal class MethodExplicitTypeVisitor : CSharpSyntaxRewriter
    {

        private const int METHOD_MIN_STATEMENTS = 2;
        private VirtualizationContext _virtualizationContext;

        public MethodExplicitTypeVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax method)
        {
            if (!ClassVirtualizationVisitor.MarkedForVirtualization(method).Item1)
                return method;

            if (method.Body.DescendantNodes().OfType<StatementSyntax>().Count() <= METHOD_MIN_STATEMENTS)
            {
                return method;
            }

            var oldBody = method.Body;

            var varTypeReplaceVisitor = new VarTypeReplaceVisitor(_virtualizationContext);

            oldBody = (BlockSyntax) varTypeReplaceVisitor.Refactor(oldBody);


            var updatedMethod = method.ReplaceNode(method.Body, oldBody);
            updatedMethod = updatedMethod.NormalizeWhitespace().WithTriviaFrom(method);

            return updatedMethod;
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/TypingVisitors/VarTypeReplaceVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.TypingVisitors
{
    class VarTypeReplaceVisitor : CSharpSyntaxRewriter
    {
        private VirtualizationContext _virtualizationContext;

        private readonly List<SyntaxNode> markedNodes =
           new List<SyntaxNode>();

        private readonly List<Tuple<ExpressionStatementSyntax, SyntaxNode, List<ExpressionStatementSyntax>>> replacementNodes =
            new List<Tuple<ExpressionStatementSyntax, SyntaxNode, List<ExpressionStatementSyntax>>>();

        public VarTypeReplaceVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
        {
            node = (LocalDeclarationStatementSyntax)base.VisitLocalDeclarationStatement(node);

            if (node.Declaration.Variables.Count != 1)
                return node;
            if (!node.Declaration.Type.ToString().Equals("var"))
                return node;

            var identifier = node.Declaration.Variables.First().Identifier.ValueText;
            var initializerValue = node.Declaration.Variables.First().Initializer.Value;
            var typeInfo = _virtualizationContext.semanticModel.GetTypeInfo(initializerValue).Type;
            string type = typeInfo.ToString();
            
            markedNodes.Add(node);
            var newVar = SyntaxFactoryExtensions.LocalVariableDeclaration(identifier, initializerValue, type);
            
            return newVar;
        }

        public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
        {
            node = (IdentifierNameSyntax) base.VisitIdentifierName(node);

            var parentExpression = GetParentExpression(node);
            var type = _virtualizationContext.semanticModel.GetTypeInfo(node);

            markedNodes.Add(node);
            return node;
        }


        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            //TODO: replace with auxiliary variable
            //TODO: insert auxiliary variables before
            //TODO: keep in mind the order 

            oldBody = oldBody.TrackNodes(this.markedNodes);
            foreach (var tuple in this.replacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);

                var replacedExpr = oldBody.ReplaceNode(currentA, tuple.Item2);
                oldBody = replacedExpr;
            }
            return oldBody;
        }


        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            replacementNodes.Clear();
            markedNodes.Clear();

            var visited = this.Visit(oldBody);
            oldBody = (BlockSyntax)visited;
            //            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if (node.Kind() == SyntaxKind.ExpressionStatement)
                return node;
            if (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                return node;
            if (node.Kind() == SyntaxKind.ForEachStatement)
                return node;

            return GetParentExpression(node.Parent);
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Utils/ListExtensions.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CodeVirtualization_Console.Utils
{
    public static class ListExtensions
    {

        public static void Shuffle<T>(this IList<T> list)
        {
            Random rng = new Random();
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = rng.Next(n + 1);
                T value = list[k];
                list[k] = list[n];
                list[n] = value;
            }
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Utils/SyntaxFactoryExtensions.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeVirtualization_Console.Context;
using CodeVirtualization_Console.Utils;
using CodeVirtualization_Console.Visitors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console
{
    class SyntaxFactoryExtensions
    {
        /* virtualization obfuscation variables identifiers */
        public static string DATA_IDENTIFIER = VirtualizationContext.DATA_IDENTIFIER;
        public static string CODE_IDENTIFIER = VirtualizationContext.CODE_IDENTIFIER;
        public static string VPC_IDENTIFIER = VirtualizationContext.VPC_IDENTIFIER;

        private static Random RandomGenerator = new Random();
        /// <summary>
        /// type identifier = initializer
        /// </summary>
        /// <param name="identifier"></param>
        /// <param name="value"></param>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static StatementSyntax LocalVariableDeclaration(string identifier, ExpressionSyntax initializer, SyntaxKind type)
        {
            var statement = SyntaxFactory.LocalDeclarationStatement
                (
                    SyntaxFactory.VariableDeclaration
                        (
                            SyntaxFactory.PredefinedType
                                (
                                    SyntaxFactory.Token
                                        (
                                            type
                                        )
                                )
                        )
                        .WithVariables
                        (
                            SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>
                                (
                                    SyntaxFactory.VariableDeclarator
                                        (
                                            SyntaxFactory.Identifier
                                                (
                                                    @"" + identifier
                                                )
                                        )
                                        .WithInitializer
                                        (
                                            SyntaxFactory.EqualsValueClause
                                                (
                                                    initializer
                                                )
                                                .WithEqualsToken
                                                (
                                                    SyntaxFactory.Token
                                                        (
                                                            SyntaxKind.EqualsToken
                                                        )
                                                )
                                        )
                                )
                        )
                ).NormalizeWhitespace()
                .WithSemicolonToken
                (
                    SyntaxFactory.Token
                        (
                            SyntaxKind.SemicolonToken
                        )
                );

            return statement;
        }

        /// <summary>
        /// var identifier = initializer
        /// </summary>
        /// <param name="identifier"></param>
        /// <param name="value"></param>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static StatementSyntax LocalVariableDeclaration(string identifier, ExpressionSyntax initializer)
        {
            var statement = SyntaxFactory.LocalDeclarationStatement
                (
                    SyntaxFactory.VariableDeclaration
                        (
                           SyntaxFactory.IdentifierName
                                        (
                                            @"var"
                                        )
                        )
                        .WithVariables
                        (
                            SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>
                                (
                                    SyntaxFactory.VariableDeclarator
                                        (
                                            SyntaxFactory.Identifier
                                                (
                                                    @"" + identifier
                                                )
                                        )
                                        .WithInitializer
                                        (
                                            SyntaxFactory.EqualsValueClause
                                                (
                                                    initializer
                                                )
                                                .WithEqualsToken
                                                (
                                                    SyntaxFactory.Token
                                                        (
                                                            SyntaxKind.EqualsToken
                                                        )
                                                )
                                        )
                                )
                        )
                ).NormalizeWhitespace()
                .WithSemicolonToken
                (
                    SyntaxFactory.Token
                        (
                            SyntaxKind.SemicolonToken
                        )
                );

            return statement;
        }

        /// <summary>
        /// type identifier = initializer
        /// </summary>
        /// <param name="identifier"></param>
        /// <param name="value"></param>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static StatementSyntax LocalVariableDeclaration(string identifier, ExpressionSyntax initializer, string type)
        {
            var statement = SyntaxFactory.LocalDeclarationStatement
                (
                    SyntaxFactory.VariableDeclaration
                        (
                           SyntaxFactory.IdentifierName
                                        (
                                            @"" + type
                                        )
                        )
                        .WithVariables
                        (
                            SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>
                                (
                                    SyntaxFactory.VariableDeclarator
                                        (
                                            SyntaxFactory.Identifier
                                                (
                                                    @"" + identifier
                                                )
                                        )
                                        .WithInitializer
                                        (
                                            SyntaxFactory.EqualsValueClause
                                                (
                                                    initializer
                                                )
                                                .WithEqualsToken
                                                (
                                                    SyntaxFactory.Token
                                                        (
                                                            SyntaxKind.EqualsToken
                                                        )
                                                )
                                        )
                                )
                        )
                ).NormalizeWhitespace()
                .WithSemicolonToken
                (
                    SyntaxFactory.Token
                        (
                            SyntaxKind.SemicolonToken
                        )
                );

            return statement;
        }

        /// <summary>
        /// type identifier = value
        /// </summary>
        /// <param name="identifier"></param>
        /// <param name="value"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public static StatementSyntax LocalVariableDeclaration(string identifier, int value, SyntaxKind type)
        {
            var statement = SyntaxFactory.LocalDeclarationStatement
                (
                    SyntaxFactory.VariableDeclaration
                        (
                            SyntaxFactory.PredefinedType
                                (
                                    SyntaxFactory.Token
                                        (
                                            type
                                        )
                                )
                        )
                        .WithVariables
                        (
                            SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>
                                (
                                    SyntaxFactory.VariableDeclarator
                                        (
                                            SyntaxFactory.Identifier
                                                (
                                                    @"" + identifier
                                                )
                                        )
                                        .WithInitializer
                                        (
                                            SyntaxFactory.EqualsValueClause
                                                (
                                                    SyntaxFactory.LiteralExpression
                                                        (
                                                            SyntaxKind.NumericLiteralExpression,
                                                            SyntaxFactory.Literal
                                                                (
                                                                    SyntaxFactory.TriviaList(),
                                                                    @"" + value,
                                                                    value,
                                                                    SyntaxFactory.TriviaList()
                                                                )
                                                        )
                                                )
                                                .WithEqualsToken
                                                (
                                                    SyntaxFactory.Token
                                                        (
                                                            SyntaxKind.EqualsToken
                                                        )
                                                )
                                        )
                                )
                        )
                ).NormalizeWhitespace()
                .WithSemicolonToken
                (
                    SyntaxFactory.Token
                        (
                            SyntaxKind.SemicolonToken
                        )
                );

            return statement;
        }

        public static StatementSyntax GenerateArrayDeclaration(string identifier, int size, SyntaxKind kind)
        {

            var arrayDeclaration = SyntaxFactory.VariableDeclaration(
                SyntaxFactory.ArrayType(
                    SyntaxFactory.PredefinedType(
                        SyntaxFactory.Token(
                            kind)))
                    .WithRankSpecifiers(
                        SyntaxFactory.SingletonList<ArrayRankSpecifierSyntax>(
                            SyntaxFactory.ArrayRankSpecifier(
                                SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                    SyntaxFactory.OmittedArraySizeExpression()
                                        .WithOmittedArraySizeExpressionToken(
                                            SyntaxFactory.Token(
                                                SyntaxKind.OmittedArraySizeExpressionToken))))
                                .WithOpenBracketToken(
                                    SyntaxFactory.Token(
                                        SyntaxKind.OpenBracketToken))
                                .WithCloseBracketToken(
                                    SyntaxFactory.Token(
                                        SyntaxKind.CloseBracketToken)))))
                .WithVariables(
                    SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>(
                        SyntaxFactory.VariableDeclarator(
                            SyntaxFactory.Identifier(
                                @"" + identifier))
                            .WithInitializer(
                                SyntaxFactory.EqualsValueClause(
                                    SyntaxFactory.ArrayCreationExpression(
                                        SyntaxFactory.ArrayType(
                                            SyntaxFactory.PredefinedType(
                                                SyntaxFactory.Token(
                                                    kind)))
                                            .WithRankSpecifiers(
                                                SyntaxFactory.SingletonList<ArrayRankSpecifierSyntax>(
                                                    SyntaxFactory.ArrayRankSpecifier(
                                                        SyntaxFactory
                                                            .SingletonSeparatedList<ExpressionSyntax>(
                                                                SyntaxFactory.LiteralExpression(
                                                                    SyntaxKind.NumericLiteralExpression,
                                                                    SyntaxFactory.Literal(
                                                                        SyntaxFactory.TriviaList(),
                                                                        @"" + size,
                                                                        size,
                                                                        SyntaxFactory.TriviaList()))))
                                                        .WithOpenBracketToken(
                                                            SyntaxFactory.Token(
                                                                SyntaxKind.OpenBracketToken))
                                                        .WithCloseBracketToken(
                                                            SyntaxFactory.Token(
                                                                SyntaxKind.CloseBracketToken)))))
                                        .WithNewKeyword(
                                            SyntaxFactory.Token(
                                                SyntaxKind.NewKeyword)))
                                    .WithEqualsToken(
                                        SyntaxFactory.Token(
                                            SyntaxKind.EqualsToken)))))

                .NormalizeWhitespace();
            ;

            LocalDeclarationStatementSyntax arrayNode = SyntaxFactory.LocalDeclarationStatement(arrayDeclaration).WithSemicolonToken
                (
                    SyntaxFactory.Token
                        (
                            SyntaxKind.SemicolonToken
                        )
                );
            return arrayNode;
        }

        public static StatementSyntax GetVirtualCodeAssignment(int index, int value)
        {
            return GetVirtualCodeAssignment(index, ""+value);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <returns>code[index] = value</returns>
        public static StatementSyntax GetVirtualCodeAssignment(int index, string value)
        {
            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @""  + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.LiteralExpression
                                                        (
                                                            SyntaxKind.NumericLiteralExpression,
                                                            SyntaxFactory.Literal
                                                            (
                                                                SyntaxFactory.TriviaList(),
                                                                @"" + index,
                                                                index,
                                                                SyntaxFactory.TriviaList()
                                                            )
                                                        )
                                            ))));
            
            var literalExpression = SyntaxFactory.LiteralExpression(
                SyntaxKind.NumericLiteralExpression,
                SyntaxFactory.Literal
                (
                    SyntaxFactory.TriviaList(),
                    @"" + value,
                    value,
                    SyntaxFactory.TriviaList()
                ));

            var assignementStatement = SyntaxFactory.ExpressionStatement(
                SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    codeAccess,
                    literalExpression));

            return assignementStatement;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>code[vpc++]</returns>
        public static ExpressionSyntax GetVirtualCodeAccessIncremented()
        {
            var vpcAccess = SyntaxFactory.IdentifierName
                (
                    @""  + VPC_IDENTIFIER
                );

            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @""  + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.PostfixUnaryExpression
                                            (SyntaxKind.PostIncrementExpression, vpcAccess)
                                            ))));

            return codeAccess;
        }

        /// <summary>
        /// code[vpc+index]
        /// </summary>
        /// <returns>code[vpc+index]</returns>
        public static ExpressionSyntax GetVirtualCodeAccessIndex(int index)
        {
            var vpcAccess = SyntaxFactory.IdentifierName
                (
                    @"" + VPC_IDENTIFIER
                );

            var indexIdentifier = SyntaxFactory.IdentifierName
                (
                    @"" + index
                );

            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @"" + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.BinaryExpression(SyntaxKind.AddExpression, vpcAccess, indexIdentifier)
                                            )
                                )));

            return codeAccess;
        }

        /// <summary>
        /// code[vpc]
        /// </summary>
        /// <returns>code[vpc]</returns>
        public static ExpressionSyntax GetVirtualCodeAccess()
        {
            var vpcAccess = SyntaxFactory.IdentifierName
                (
                    @"" + VPC_IDENTIFIER
                );


            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @"" + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(vpcAccess)
                                )));

            return codeAccess;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="identifier"></param>
        /// <param name="index"></param>
        /// <param name="rightValue"></param>
        /// <returns></returns>
        public static StatementSyntax ArrayElementInit(string identifier, int index, ExpressionSyntax rightValue)
        {
            var arrayAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @"" + identifier))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.LiteralExpression
                                    (
                                        SyntaxKind.NumericLiteralExpression,
                                        SyntaxFactory.Literal
                                        (
                                            SyntaxFactory.TriviaList(),
                                            @"" + index,
                                            index,
                                            SyntaxFactory.TriviaList()
                                        )
                                    )
                                ))));

            var assignementStatement = SyntaxFactory.ExpressionStatement(
                SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    arrayAccess,
                    rightValue));

            return assignementStatement;
        }
        /// <summary>
        /// data[code[vpc++]] = righValue
        /// </summary>
        /// <param name="rightValue"></param>
        /// <param name="annotations"></param>
        /// <returns></returns>
        public static ExpressionStatementSyntax DataVirtualAssignment(SyntaxNode rightValue, params SyntaxAnnotation[] annotations)
        {
            var vpcAccess = SyntaxFactory.IdentifierName
                (
                    @"" + VPC_IDENTIFIER
                );

            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @"" + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.PostfixUnaryExpression
                                            (SyntaxKind.PostIncrementExpression, vpcAccess)
                                            ))));

            var dataAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @"" + DATA_IDENTIFIER ))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                codeAccess))))
                .WithAdditionalAnnotations(annotations);

            var assignementStatement = SyntaxFactory.ExpressionStatement(
                SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    dataAccess,
                    (ExpressionSyntax)rightValue));
            
            return assignementStatement;
        }


        /// <summary>
        /// data[code[vpc++]] = (type) (righValue)
        /// </summary>
        /// <param name="rightValue"></param>
        /// <param name="annotations"></param>
        /// <returns></returns>
        public static ExpressionStatementSyntax DataVirtualAssignment(String type, SyntaxNode rightValue, params SyntaxAnnotation[] annotations)
        {
            var vpcAccess = SyntaxFactory.IdentifierName
                (
                    @""  + VPC_IDENTIFIER
                );

            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @""  + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.PostfixUnaryExpression
                                            (SyntaxKind.PostIncrementExpression, vpcAccess)
                                            ))));

            var dataAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @""  + DATA_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                codeAccess))))
                .WithAdditionalAnnotations(annotations);

            rightValue = SyntaxFactory.ParenthesizedExpression((ExpressionSyntax)rightValue);

            var newExpression = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName
                                                       (
                                                           @"" + type
                                                       ),
                                                          (ExpressionSyntax)rightValue
                                                      );

            var assignementStatement = SyntaxFactory.ExpressionStatement(
                SyntaxFactory.AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    dataAccess,
                    newExpression));

            return assignementStatement;
        }


        /// <summary>
        /// data[code[vpc++]]
        /// </summary>
        /// <returns></returns>
        public static ExpressionSyntax DataCodeVirtualAccess()
        {
            var vpcAccess = SyntaxFactory.IdentifierName
                (
                    @""  + VPC_IDENTIFIER
                );

            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @""  + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.PostfixUnaryExpression
                                            (SyntaxKind.PostIncrementExpression, vpcAccess)
                                            ))));

            var dataAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @""  + DATA_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                codeAccess))));

            return dataAccess;
        }

        /// <summary>
        /// data[code[vpc+(indexSkip)]]
        /// </summary>
        /// <returns></returns>
        public static ExpressionSyntax DataCodeVirtualAccess(string indexSkip)
        {
            var codeAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @"" + CODE_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                SyntaxFactory.BinaryExpression(
                                        SyntaxKind.AddExpression,
                                        SyntaxFactory.IdentifierName
                                        (
                                            @"" + VPC_IDENTIFIER
                                        ),
                                        SyntaxFactory.ParenthesizedExpression(
                                            SyntaxFactory.LiteralExpression
                                            (
                                                SyntaxKind.NumericLiteralExpression,
                                                SyntaxFactory.Literal
                                                (
                                                    SyntaxFactory.TriviaList(),
                                                    @"" + indexSkip,
                                                    indexSkip,
                                                    SyntaxFactory.TriviaList()
                                                )
                                            )
                                        )
                                    )
                                    ))));

            var dataAccess = SyntaxFactory.ElementAccessExpression(
                SyntaxFactory.IdentifierName(
                    @"" + DATA_IDENTIFIER))
                .WithArgumentList(
                    SyntaxFactory.BracketedArgumentList(
                        SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(
                            SyntaxFactory.Argument(
                                codeAccess))));

            return dataAccess;
        }


        public static ExpressionSyntax NumericLiteralExpression(int value)
        {
            var literalExpression = SyntaxFactory.LiteralExpression(
                SyntaxKind.NumericLiteralExpression,
                SyntaxFactory.Literal
                    (
                        SyntaxFactory.TriviaList(),
                        @"" + value,
                        value,
                        SyntaxFactory.TriviaList()
                    ));
            return literalExpression;
        }

        public static ExpressionSyntax NumericLiteralExpression(long value)
        {
            var literalExpression = SyntaxFactory.LiteralExpression(
                SyntaxKind.NumericLiteralExpression,
                SyntaxFactory.Literal
                    (
                        SyntaxFactory.TriviaList(),
                        @"" + value + "L",
                        value,
                        SyntaxFactory.TriviaList()
                    ));
            return literalExpression;
        }

        public static ExpressionSyntax NumericLiteralExpression(double value)
        {
            int pointIndex = ("" + value).IndexOf(".");
            string integerValue = "" + value;
            string decimalValue = "0";
            if (pointIndex > 0)
            {
                integerValue = ("" + value).Substring(0, pointIndex);
                decimalValue = ("" + value).Substring(pointIndex + 1);
            }
            
           var literalExpression = SyntaxFactory.LiteralExpression(
                SyntaxKind.NumericLiteralExpression,
                SyntaxFactory.Literal
                    (
                        SyntaxFactory.TriviaList(),
                        @"" + integerValue + "." +decimalValue,
                        value,
                        SyntaxFactory.TriviaList()
                    ));
            return literalExpression;
        }

        public static ExpressionSyntax NumericLiteralExpression(float value)
        {
            var literalExpression = SyntaxFactory.LiteralExpression(
                SyntaxKind.NumericLiteralExpression,
                SyntaxFactory.Literal
                    (
                        SyntaxFactory.TriviaList(),
                        @"" + value + "F",
                        value,
                        SyntaxFactory.TriviaList()
                    ));
            return literalExpression;
        }

        public static ExpressionSyntax StringLiteralExpression(string value)
        {
            var literalExpression = SyntaxFactory.LiteralExpression(
                SyntaxKind.StringLiteralExpression,
                SyntaxFactory.Literal
                    (
                        SyntaxFactory.TriviaList(),
                        @"" + value,
                        value,
                        SyntaxFactory.TriviaList()
                    ));
            return literalExpression;
        }

        public static ExpressionSyntax NullLiteralExpression()
        {
            var nullExpression = SyntaxFactory.LiteralExpression
                                   (
                                       SyntaxKind.NullLiteralExpression
                                   )
                                   .WithToken
                                   (
                                       SyntaxFactory.Token
                                       (
                                           SyntaxKind.NullKeyword
                                       )
                                   )
                                   .WithLeadingTrivia(SyntaxFactory.Space);
            return nullExpression;
        }
        

        public static ExpressionSyntax BooleanLiteralExpression(bool value)
        {
            ExpressionSyntax returnExpression;
            if(value)
                returnExpression = SyntaxFactory.LiteralExpression
                                    (
                                        SyntaxKind.TrueLiteralExpression
                                    )
                                    .WithToken
                                    (
                                        SyntaxFactory.Token
                                        (
                                            SyntaxKind.TrueKeyword
                                        )
                                    );
            else
                returnExpression = SyntaxFactory.LiteralExpression
                                    (
                                        SyntaxKind.FalseLiteralExpression
                                    )
                                    .WithToken
                                    (
                                        SyntaxFactory.Token
                                        (
                                            SyntaxKind.FalseKeyword
                                        )
                                    );
            return returnExpression;
        }

        public static StatementSyntax ReturnNullStatement()
        {
            var returnStatement = SyntaxFactory.ReturnStatement
                               (
                                   SyntaxFactory.LiteralExpression
                                   (
                                       SyntaxKind.NullLiteralExpression
                                   )
                                   .WithToken
                                   (
                                       SyntaxFactory.Token
                                       (
                                           SyntaxKind.NullKeyword
                                       )
                                   )
                                   .WithLeadingTrivia(SyntaxFactory.Space)
                               )
                               .WithReturnKeyword
                               (
                                   SyntaxFactory.Token
                                   (
                                       SyntaxKind.ReturnKeyword
                                   )
                               )
                               .WithSemicolonToken
                               (
                                   SyntaxFactory.Token
                                   (
                                       SyntaxKind.SemicolonToken
                                   )
                               );
            return returnStatement;
        }

        public static StatementSyntax ReturnZeroStatement()
        {
            var returnStatement = SyntaxFactory.ReturnStatement
                               (
                                   SyntaxFactory.LiteralExpression
                                        (
                                            SyntaxKind.NumericLiteralExpression,
                                            SyntaxFactory.Literal
                                            (
                                                SyntaxFactory.TriviaList(),
                                                @"0",
                                                0,
                                                SyntaxFactory.TriviaList()
                                            )
                                        ).WithLeadingTrivia(SyntaxFactory.Space)
                               )
                               .WithReturnKeyword
                               (
                                   SyntaxFactory.Token
                                   (
                                       SyntaxKind.ReturnKeyword
                                   )
                               )
                               .WithSemicolonToken
                               (
                                   SyntaxFactory.Token
                                   (
                                       SyntaxKind.SemicolonToken
                                   )
                               );
            return returnStatement;
        }

        public static StatementSyntax ReturnFalseStatement()
        {
            var returnStatement = SyntaxFactory.ReturnStatement
                               (
                                   SyntaxFactory.LiteralExpression
                                    (
                                        SyntaxKind.FalseLiteralExpression
                                    )
                                    .WithToken
                                    (
                                        SyntaxFactory.Token
                                        (
                                            SyntaxKind.FalseKeyword
                                        )
                                    ).WithLeadingTrivia(SyntaxFactory.Space)
                               )
                               .WithReturnKeyword
                               (
                                   SyntaxFactory.Token
                                   (
                                       SyntaxKind.ReturnKeyword
                                   )
                               )
                               .WithSemicolonToken
                               (
                                   SyntaxFactory.Token
                                   (
                                       SyntaxKind.SemicolonToken
                                   )
                               );
            return returnStatement;
        }

        public static StatementSyntax ReturnStatement(string type)
        {
            //TODO: treat char
            switch (type)
            {
                case "void":
                    return SyntaxFactory.ReturnStatement();
                case "bool":
                    return ReturnFalseStatement();
                case "byte":
                case "short":
                case "int":                                        
                case "double":
                case "float":
                case "long":
                    return ReturnZeroStatement();

                case "string":
                default:
                    return ReturnNullStatement();
            }

        }
        /// <summary>
        /// true: bool, byte, short, int, double, float, long, string
        /// false: otherwise
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static bool IsBasicType(string type)
        {
            //TODO: treat char
            switch (type)
            {
                case "bool":
                case "byte":
                case "enum":     
                case "UInt16":
                case "ushort":
                case "short":
                case "int":
                case "double":
                case "float":
                case "long":
                case "string":
                    return true;
                default:
                    return false;
            }

        }

        public static ExpressionSyntax DefaultValue(string type)
        {
            //TODO: treat char
            switch (type)
            {
                case "bool":
                    return BooleanLiteralExpression(false);
                case "byte":
                case "short":
                case "ushort":
                case "UInt16":
                case "int":
                    return NumericLiteralExpression(0);
                case "long":
                    return NumericLiteralExpression(0L);
                case "float":
                    return NumericLiteralExpression(0.0F);
                case "double":
                    return NumericLiteralExpression(0.0);
                case "string":
                    return StringLiteralExpression("");
                case "void":
                default:
                    return NullLiteralExpression();
            }
        }

        public static ExpressionSyntax DefaultRandomValue(string type)
        {
            //TODO: treat char
            switch (type)
            {
                case "bool":
                    return BooleanLiteralExpression(false);
                case "byte":
                    return NumericLiteralExpression((long)RandomGenerator.Next(0, 8));
                case "ushort":
                case "UInt16":
                    return NumericLiteralExpression((short)RandomGenerator.Next(0, 200));
                case "short":
                    return NumericLiteralExpression((short)RandomGenerator.Next(-100, 100));
                case "enum":
                case "int":
                    return NumericLiteralExpression(RandomGenerator.Next(-1000, 1000));
                case "long":
                    return NumericLiteralExpression((long) RandomGenerator.Next(-1000, 1000));
                case "float":
                    return NumericLiteralExpression((float) RandomGenerator.NextDouble());
                case "double":
                    return NumericLiteralExpression(RandomGenerator.NextDouble());
                case "string":
                    return StringLiteralExpression(RandomGenerator.Next() + "");
                case "void":                
                default:
                    return NullLiteralExpression();
            }
        }

        public static SwitchSectionSyntax SwitchKeySection(int key, VirtualOperation operation, SyntaxTrivia leadingTrivia, VirtualizationContext context = null, bool continueStatement = false)
        {
            var switchSection1 = SyntaxFactory.SwitchSection();
            SyntaxTrivia[] sectionTrivia = new[] { leadingTrivia, SyntaxFactory.Tab };
            SyntaxTrivia[] statementTrivia = new[] { leadingTrivia, SyntaxFactory.Tab, SyntaxFactory.Tab };
            var literalExpression = NumericLiteralExpression(key).WithLeadingTrivia(SyntaxFactory.Space);
            List<StatementSyntax> statements = new List<StatementSyntax>();
            bool isReturn = false;
            foreach (var statement in operation.Statetements)
            {
                var statementClean = statement.WithoutLeadingTrivia().WithoutTrailingTrivia();
                statementClean = statementClean.WithLeadingTrivia(statementTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));
                statements.Add(statementClean);
                if (statement.Kind() == SyntaxKind.ReturnStatement)
                {
                    isReturn = true;
                }
            }
            
            StatementSyntax finalStatement;
            if(!continueStatement)
                finalStatement = SyntaxFactory.BreakStatement().WithLeadingTrivia(statementTrivia);
            else
                finalStatement = SyntaxFactory.ContinueStatement().WithLeadingTrivia(statementTrivia);

            SyntaxTrivia[] trailingTrivia = new[] { SyntaxFactory.EndOfLine(Environment.NewLine) };
            if (context.ReadableOn)
            {
                trailingTrivia = new[] { SyntaxFactory.Comment(" //frequency"  + " " + operation.Frequency + " " + operation.Name), SyntaxFactory.EndOfLine(Environment.NewLine) };
            }

            SwitchLabelSyntax label1 = SyntaxFactory.CaseSwitchLabel(literalExpression)
                .WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                .WithLeadingTrivia(SyntaxFactory.Space)
                .WithTrailingTrivia(trailingTrivia);
            SwitchLabelSyntax[] labels1 = new SwitchLabelSyntax[] { label1 };
            
            if (!isReturn)
            {
                statements.Add(finalStatement);
            }
            StatementSyntax[] statements1 = statements.ToArray();

            switchSection1 = switchSection1.AddLabels(labels1);
            switchSection1 = switchSection1.AddStatements(statements1);
            switchSection1 = switchSection1.WithLeadingTrivia(sectionTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));

            return switchSection1;
        }

        public static SwitchSectionSyntax SwitchDefaultSection(VirtualOperation operation, SyntaxTrivia leadingTrivia, VirtualizationContext context = null, bool continueStatement = false, int defaultOperationFrequence = -1)
        {
            var switchSection1 = SyntaxFactory.SwitchSection();
            SyntaxTrivia[] sectionTrivia = new[] { leadingTrivia, SyntaxFactory.Tab };
            SyntaxTrivia[] statementTrivia = new[] { leadingTrivia, SyntaxFactory.Tab, SyntaxFactory.Tab };

            List<StatementSyntax> statements = new List<StatementSyntax>();
            bool isReturn = false;
            foreach (var statement in operation.Statetements)
            {
                var statementClean = statement.WithoutLeadingTrivia().WithoutTrailingTrivia();
                statementClean = statementClean.WithLeadingTrivia(statementTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));
                statements.Add(statementClean);
                if (statement.Kind() == SyntaxKind.ReturnStatement)
                {
                    isReturn = true;
                }
            }

            StatementSyntax finalStatement;
            if (!continueStatement)
                finalStatement = SyntaxFactory.BreakStatement().WithLeadingTrivia(statementTrivia);
            else
                finalStatement = SyntaxFactory.ContinueStatement().WithLeadingTrivia(statementTrivia);

            SyntaxTrivia[] trailingTrivia = new[] { SyntaxFactory.EndOfLine(Environment.NewLine) };
            if (context.ReadableOn)
            {
                trailingTrivia = new[] { SyntaxFactory.Comment(" //frequency" + " " + defaultOperationFrequence + " "+ operation.Name), SyntaxFactory.EndOfLine(Environment.NewLine) };
            }

            if (!isReturn)
            {
                statements.Add(finalStatement);
            }
            StatementSyntax[] statements1 = statements.ToArray();

            SwitchLabelSyntax label1 = SyntaxFactory.DefaultSwitchLabel()
                .WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                .WithLeadingTrivia(SyntaxFactory.Space)
                .WithTrailingTrivia(trailingTrivia);
            SwitchLabelSyntax[] labels1 = new SwitchLabelSyntax[] { label1 };
           
            switchSection1 = switchSection1.AddLabels(labels1);
            switchSection1 = switchSection1.AddStatements(statements1);
            switchSection1 = switchSection1.WithLeadingTrivia(sectionTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));

            return switchSection1;
        }


        public static StatementSyntax WhileTrue(SyntaxTrivia leadingTrivia, StatementSyntax[] statements)
        {
            BlockSyntax block = SyntaxFactory.Block(statements);
            block = block.WithOpenBraceToken(
                SyntaxFactory.Token(SyntaxKind.OpenBraceToken)
                    .WithLeadingTrivia(leadingTrivia)
//                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                    );
            block = block.WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken).WithLeadingTrivia(leadingTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)));
            block = (BlockSyntax) block.Accept(FormatInsertTabRightVisitor.Instance);

            var whileStatement = SyntaxFactory.WhileStatement(
                SyntaxFactory.Token(SyntaxKind.WhileKeyword),
                SyntaxFactory.Token(SyntaxKind.OpenParenToken),
                SyntaxFactoryExtensions.BooleanLiteralExpression(true),
                SyntaxFactory.Token(SyntaxKind.CloseParenToken)
                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)),
                
                block
                
            ).WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine), leadingTrivia);
                
            return whileStatement;
        }

        public static StatementSyntax SwitchBlockStatement(SyntaxTrivia leadingTrivia, VirtualizationContext context)
        {
            List<VirtualOperation> operations = context.Operations;
            VirtualOperation defaultOperation = new VirtualOperation();
            int defaultFrequency = 0;
            
            if (VirtualizationContext.DEFAULT_MOST_FREQUENT_OPERATION)
            {
                //get most frequent operation
                int mostFrequentKey = VirtualOperation.MaxFrequencyKey;
                var operation = operations.FirstOrDefault(_ => _.Key == mostFrequentKey);
                int defaultKey = -1;
                if (operation != null)
                {
                    defaultOperation = operation;
                    defaultFrequency = operation.Frequency;
                    defaultKey = operation.Key;
                }

//                var oldDefaultExpression = defaultOperation.Syntax;
//                var updatedDefaultExpression = RandomizeInstruction(oldDefaultExpression);
//                defaultOperation.Syntax = updatedDefaultExpression;
//                defaultOperation.ReplaceStatement(oldDefaultExpression, updatedDefaultExpression);

                List<VirtualOperation> operationsUpdated = new List<VirtualOperation>();
                foreach (var op in operations)
                {
                    if (op.Key == defaultKey)
                    {
                        //change the key for the most frequent while it is als referenced in code[]
                        op.Key = context.SWITCH_KEY;
//                        var newExpression = defaultOperation.Syntax;
//                        var baseExpression = op.Syntax;
//                        newExpression = UpdateAnnotationsInstruction(baseExpression, newExpression);
//                        op.ReplaceStatement(op.Syntax, newExpression);
//                        op.Syntax = defaultOperation.Syntax;
                    }
                    else
                    {
                        operationsUpdated.Add(op);
                    }
                }
                operations = operationsUpdated;
            }
            
            var codeAccess = GetVirtualCodeAccess();

            SyntaxList<SwitchSectionSyntax> sectionList = new SyntaxList<SwitchSectionSyntax>();
            int key = 0;

            Dictionary<int, VirtualOperation> uniqueOperations = new Dictionary<int, VirtualOperation>();            
            foreach (var statement in operations)
            {
                key = statement.Key;
                if (uniqueOperations.Keys.Contains(key))
                {
//                    var baseExpression = statement.Syntax;
//                    var newExpression = uniqueOperations[key].Syntax;
//                    newExpression = UpdateAnnotationsInstruction(statement.Syntax, newExpression);
//                    statement.Syntax = newExpression;
//                    statement.Size = uniqueOperations[key].Size;
//                    statement.ReplaceStatement(baseExpression, newExpression);
                    continue;
                }
                                                    
//                var oldExpression = statement.Syntax;
////                var updatedExpression = RandomizeInstruction(oldExpression);
//                var updatedExpression = RandomizeInstruction(oldExpression);
//                statement.Syntax = updatedExpression;
//                statement.ReplaceStatement(oldExpression, updatedExpression);
                uniqueOperations.Add(key,statement);
                var switchSection = SwitchKeySection(key, statement, leadingTrivia, context);
                sectionList = sectionList.Add(switchSection);
            }
            
            var defaultSection = SwitchDefaultSection(defaultOperation, leadingTrivia, context, false, defaultFrequency);
            sectionList = sectionList.Add(defaultSection);

            var shuffledList = sectionList.ToList();
            shuffledList.Shuffle();
            sectionList = new SyntaxList<SwitchSectionSyntax>();
            sectionList = sectionList.AddRange(shuffledList);

            var switchStatement = SyntaxFactory.SwitchStatement(
                SyntaxFactory.Token(SyntaxKind.SwitchKeyword),
                SyntaxFactory.Token(SyntaxKind.OpenParenToken),
                codeAccess,
                SyntaxFactory.Token(SyntaxKind.CloseParenToken).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)),
                SyntaxFactory.Token(SyntaxKind.OpenBraceToken).WithLeadingTrivia(leadingTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)),
                sectionList,
                SyntaxFactory.Token(SyntaxKind.CloseBraceToken).WithLeadingTrivia(leadingTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))).WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine), leadingTrivia);

            return switchStatement;
        }

        public static StatementSyntax RandomizeInstruction(StatementSyntax statement)
        {
            List<SyntaxNode> replacementNodes = new List<SyntaxNode>();
            //get all annotated nodes of kind code
            var annotadedNodes = statement.GetAnnotatedNodes("unique");            
//            statement = statement.TrackNodes(annotadedNodes);

            List<int> positions = new List<int>();
            positions.Add(0); // it is always the code of the next instruction

            Func<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode = new Func<SyntaxNode, SyntaxNode, SyntaxNode>( (old, updated) =>
            {
                List<SyntaxAnnotation> annotations = new List<SyntaxAnnotation>();
                var indexAnnotations = old.GetAnnotations("index");
                var nameAnnotations = old.GetAnnotations("name");
                var typeAnnotations = old.GetAnnotations("type");
                var uniqueAnnotations = old.GetAnnotations("unique");
                var codeAnnotations = old.GetAnnotations("code").ToList();
                if (codeAnnotations.Count() > 0)
                {   
                    var marker = codeAnnotations[0];
                    if(!marker.Data.Equals("undefined"))
                        return old;
                }

                annotations.AddRange(indexAnnotations);
                annotations.AddRange(nameAnnotations);
                annotations.AddRange(typeAnnotations);
                annotations.AddRange(uniqueAnnotations);
                int codeAnnotationIndex = -1;
                var paramIndex = VirtualizationContext.RandomInstructionPosition();
                while (positions.Contains(paramIndex))
                {
                    paramIndex = VirtualizationContext.RandomInstructionPosition();
                }
                positions.Add(paramIndex);
                SyntaxAnnotation codeIndexMarker = new SyntaxAnnotation("code", paramIndex + "");

                annotations.Add(codeIndexMarker);
                var dataCodeAccess = DataCodeVirtualAccess(paramIndex + "").WithAdditionalAnnotations(annotations);

                return dataCodeAccess;
            });
            var updatedStatement = statement.ReplaceNodes(annotadedNodes, computeReplacementNode);

            return updatedStatement;
        }

        public static StatementSyntax UpdateAnnotationsInstruction(StatementSyntax fromStatement, StatementSyntax toStatement, params string[] kinds)
        {
            //get all annotated nodes of kind code
            var fromAnnotadedNodes = fromStatement.GetAnnotatedNodes("unique").ToList();
            var toAnnotatedNodes = toStatement.GetAnnotatedNodes("unique").ToList();
            int index = 0;

            Func<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode = new Func<SyntaxNode, SyntaxNode, SyntaxNode>((old, updated) =>
            {
                List<SyntaxAnnotation> annotations = new List<SyntaxAnnotation>();
                foreach(string kind in kinds)
                {
                    var oldAnnotations = old.GetAnnotations(kind);
                    annotations.AddRange(oldAnnotations);
                }

//                var oldIndexAnnotations = old.GetAnnotations("index");
//                var oldNameAnnotations = old.GetAnnotations("name");
//                var oldTypeAnnotations = old.GetAnnotations("type");
//                var oldUniqueAnnotation = old.GetAnnotations("unique").FirstOrDefault();
                
//                annotations.AddRange(oldIndexAnnotations);
//                annotations.AddRange(oldNameAnnotations);
//                annotations.AddRange(oldTypeAnnotations);
//                annotations.Add(oldUniqueAnnotation);

                var newNode = toAnnotatedNodes[index++];
//                var oldCodeAnnotations = newNode.GetAnnotations("code");
//                annotations.AddRange(oldCodeAnnotations);

                var updatedNode = ClearAnnotations(newNode, kinds);
                updatedNode = updatedNode.WithAdditionalAnnotations(annotations);

                var oldIndexAnnotations1 = updatedNode.GetAnnotations("index");
                var oldNameAnnotations1 = updatedNode.GetAnnotations("name");
                var oldTypeAnnotations1 = updatedNode.GetAnnotations("type");
                var oldUniqueAnnotation1 = updatedNode.GetAnnotations("unique").FirstOrDefault();

                return updatedNode;
            });
            var updatedStatement = fromStatement.ReplaceNodes(fromAnnotadedNodes, computeReplacementNode);

            return updatedStatement;
        }


        private static SyntaxNode ClearAnnotations(SyntaxNode node, params string[] annotations)
        {
            var updatedNode = node;
            foreach (string annotation in annotations)
            {
                updatedNode = updatedNode.WithoutAnnotations(annotation);
            }
            return updatedNode;
        }

        /// <summary>
        /// identifier(vpc, data, code);
        /// </summary>
        /// <param name="identifier"></param>
        /// <returns></returns>
        public static ExpressionStatementSyntax InvocationDeclarationSyntax(string identifier)
        {
            var invocationExpressionStatement = SyntaxFactory.ExpressionStatement
                (
                    SyntaxFactory.InvocationExpression
                        (
                            SyntaxFactory.IdentifierName
                                (
                                    @"" + identifier
                                )
                        )
                        .WithArgumentList
                        (
                            SyntaxFactory.ArgumentList
                                (
                                    SyntaxFactory.SeparatedList<ArgumentSyntax>
                                        (
                                            new SyntaxNodeOrToken[]
                                            {
                                                SyntaxFactory.Argument
                                                    (
                                                        SyntaxFactory.IdentifierName
                                                            (
                                                                @"" + VirtualizationContext.VPC_IDENTIFIER
                                                            )
                                                    ),
                                                SyntaxFactory.Token
                                                    (
                                                        SyntaxKind.CommaToken
                                                    ),
                                                SyntaxFactory.Argument
                                                    (
                                                        SyntaxFactory.IdentifierName
                                                            (
                                                                @"" + VirtualizationContext.DATA_IDENTIFIER
                                                            )
                                                    ),
                                                SyntaxFactory.Token
                                                    (
                                                        SyntaxKind.CommaToken
                                                    ),
                                                SyntaxFactory.Argument
                                                    (
                                                        SyntaxFactory.IdentifierName
                                                            (
                                                                @"" + VirtualizationContext.CODE_IDENTIFIER
                                                            )
                                                    )
                                            }
                                        )
                                )
                        )
                ).NormalizeWhitespace();
            return invocationExpressionStatement;
        }


        /// <summary>
        /// private [static] object identifer (int vpc, object[] data, int[] code)
        /// </summary>
        /// <param name="identifier"></param>
        /// <param name="body"></param>
        /// <param name="isStatic"> default false</param>
        public static MethodDeclarationSyntax MethodDeclarationSyntax(string identifier, BlockSyntax body, bool isStatic = false)
        {
            var tokenList = SyntaxFactory.TokenList
                        (
                            SyntaxFactory.Token
                                (
                                    SyntaxKind.PrivateKeyword
                                )
                        );
            if (isStatic)
                tokenList = SyntaxFactory.TokenList
                    (
                        new[]
                        {
                            SyntaxFactory.Token
                                (
                                    SyntaxKind.PrivateKeyword
                                ),
                            SyntaxFactory.Token
                                (
                                    SyntaxKind.StaticKeyword
                                )
                        }
                    );

            var methodDeclaration = SyntaxFactory.MethodDeclaration
                (
                    SyntaxFactory.PredefinedType
                        (
                            SyntaxFactory.Token
                                (
                                    SyntaxKind.ObjectKeyword
                                )
                        ),
                    SyntaxFactory.Identifier
                        (
                            @"" + identifier
                        )
                )
                .WithModifiers
                (
                    SyntaxFactory.TokenList
                        (
                            tokenList
                        )
                )
                .WithParameterList
                (
                    SyntaxFactory.ParameterList
                        (
                            SyntaxFactory.SeparatedList<ParameterSyntax>
                                (
                                    new SyntaxNodeOrToken[]
                                    {
                                        SyntaxFactory.Parameter
                                            (
                                                SyntaxFactory.Identifier
                                                    (
                                                        @"" + VirtualizationContext.VPC_IDENTIFIER
                                                    )
                                            )
                                            .WithType
                                            (
                                                SyntaxFactory.PredefinedType
                                                    (
                                                        SyntaxFactory.Token
                                                            (
                                                                SyntaxKind.IntKeyword
                                                            )
                                                    )
                                            ),
                                        SyntaxFactory.Token
                                            (
                                                SyntaxKind.CommaToken
                                            ),
                                        SyntaxFactory.Parameter
                                            (
                                                SyntaxFactory.Identifier
                                                    (
                                                        @"" + VirtualizationContext.DATA_IDENTIFIER
                                                    )
                                            )
                                            .WithType
                                            (
                                                SyntaxFactory.ArrayType
                                                    (
                                                        SyntaxFactory.PredefinedType
                                                            (
                                                                SyntaxFactory.Token
                                                                    (
                                                                        SyntaxKind.ObjectKeyword
                                                                    )
                                                            )
                                                    )
                                                    .WithRankSpecifiers
                                                    (
                                                        SyntaxFactory.SingletonList<ArrayRankSpecifierSyntax>
                                                            (
                                                                SyntaxFactory.ArrayRankSpecifier
                                                                    (
                                                                        SyntaxFactory
                                                                            .SingletonSeparatedList<ExpressionSyntax>
                                                                            (
                                                                                SyntaxFactory.OmittedArraySizeExpression
                                                                                    ()
                                                                            )
                                                                    )
                                                            )
                                                    )
                                            ),
                                        SyntaxFactory.Token
                                            (
                                                SyntaxKind.CommaToken
                                            ),
                                        SyntaxFactory.Parameter
                                            (
                                                SyntaxFactory.Identifier
                                                    (
                                                        @"" + VirtualizationContext.CODE_IDENTIFIER
                                                    )
                                            )
                                            .WithType
                                            (
                                                SyntaxFactory.ArrayType
                                                    (
                                                        SyntaxFactory.PredefinedType
                                                            (
                                                                SyntaxFactory.Token
                                                                    (
                                                                        SyntaxKind.IntKeyword
                                                                    )
                                                            )
                                                    )
                                                    .WithRankSpecifiers
                                                    (
                                                        SyntaxFactory.SingletonList<ArrayRankSpecifierSyntax>
                                                            (
                                                                SyntaxFactory.ArrayRankSpecifier
                                                                    (
                                                                        SyntaxFactory
                                                                            .SingletonSeparatedList<ExpressionSyntax>
                                                                            (
                                                                                SyntaxFactory.OmittedArraySizeExpression
                                                                                    ()
                                                                            )
                                                                    )
                                                            )
                                                    )
                                            )
                                    }
                                )
                        )
                )
                .WithBody
                (
                    body
                );
            return methodDeclaration;
        }

        
    }

    

}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/Utils/VirtualizationAttribute.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace CodeVirtualization_Console.Utils
{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class VirtualizationObfuscationAttribute : System.Attribute
    {

        private bool Exclude = true;
        private string Level = "method";
        private bool Debug = false;

        public VirtualizationObfuscationAttribute(bool Exclude = false, string Level = "method", bool Debug = false)
        {
            this.Exclude = Exclude;
            this.Level = Level;
            this.Debug = Debug;
        }
    }

}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/AssignmentDataVirtualizationVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Visitors
{
    class AssignmentDataVirtualizationVisitor : CSharpSyntaxRewriter
    {

        private VirtualizationContext _virtualizationContext;
        private LocalVariableUsageDataVirtVisitor leftLocalVariableUsageVisitor;
        private LocalVariableUsageDataVirtVisitor rightLocalVariableVisitor;

        public AssignmentDataVirtualizationVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
            leftLocalVariableUsageVisitor = new LocalVariableUsageDataVirtVisitor(_virtualizationContext);
            leftLocalVariableUsageVisitor.CastEnabled = true;
            rightLocalVariableVisitor = new LocalVariableUsageDataVirtVisitor(_virtualizationContext);
        }

        public override SyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)
        {
            var node1 =  base.VisitAssignmentExpression(node);
            if (node1 == null)
                return node;
            if (!(node1 is AssignmentExpressionSyntax))
                return node;
            node = node1 as AssignmentExpressionSyntax;

            var newNode = node;
            var left = newNode.Left;
            var newLeft = leftLocalVariableUsageVisitor.Visit(left);
            newNode = newNode.ReplaceNode(left, newLeft);

            var right = newNode.Right;
            var newRight = rightLocalVariableVisitor.Visit(right);
            newNode = newNode.ReplaceNode(right, newRight);

            SyntaxAnnotation operationMarker = new SyntaxAnnotation("operation", "assignment1");
            newNode = newNode.WithAdditionalAnnotations(operationMarker);

            return newNode;
        }

        

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/ClassVirtualizationVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeVirtualization_Console.Context;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.VirtualizationVisitors
{
    class ClassVirtualizationVisitor : CSharpSyntaxRewriter
    {
        private VirtualizationContext _virtualizationContext;

        public ClassVirtualizationVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
        {
            node =  (ClassDeclarationSyntax) base.VisitClassDeclaration(node);

            var classMembers = node.Members.ToArray();

            var methodMembers = classMembers.OfType<MethodDeclarationSyntax>();
            if (methodMembers.Count() < 1)
                return node;

            List<Tuple<MethodDeclarationSyntax, List<string>, int>> staticClassLevelVirtualizedMethods = new List<Tuple< MethodDeclarationSyntax, List<string>, int>> ();
            List <Tuple< MethodDeclarationSyntax, List<string>, int>> instanceClassLevelVirtualizedMethods = new List<Tuple< MethodDeclarationSyntax, List<string>, int>> ();
            List <Tuple< MethodDeclarationSyntax, List<string>, int>> methodLevelVirtualizedMethods = new List<Tuple< MethodDeclarationSyntax, List<string>, int>> ();
            List<MethodDeclarationSyntax> methodsToRemove = new List<MethodDeclarationSyntax>();

            bool staticVirtualization = false;
//            foreach (var method in classMembers)
            for(int position =0; position < classMembers.Length; position++)
            {
                var member = classMembers[position];
                if (!(member is MethodDeclarationSyntax))
                    continue;
                var method = member as MethodDeclarationSyntax;

                staticVirtualization = false;
                var marked = MarkedForVirtualization(method);
                if (marked.Item1)
                {
                    methodsToRemove.Add(method);
                    if (marked.Item2.Contains("method"))
                    {
                        methodLevelVirtualizedMethods.Add(new Tuple<MethodDeclarationSyntax, List<string>, int>(method, marked.Item2, position));
                        continue;
                    }
                    
                    //class level virtualization    
                    foreach (var modifier in method.Modifiers)
                    {
                        if (modifier.Kind() == SyntaxKind.StaticKeyword)
                            staticVirtualization = true;
                    }

                    if (staticVirtualization)
                        staticClassLevelVirtualizedMethods.Add(new Tuple<MethodDeclarationSyntax, List<string>, int>(method, marked.Item2, position));
                    else
                        instanceClassLevelVirtualizedMethods.Add(new Tuple<MethodDeclarationSyntax, List<string>, int>(method, marked.Item2, position));
                }
            }

            if (methodsToRemove.Count == 0)
                return node;

            node = node.RemoveNodes(methodsToRemove, SyntaxRemoveOptions.KeepEndOfLine | SyntaxRemoveOptions.KeepExteriorTrivia );

            string className = node.Identifier.ValueText;
            VirtualizationContext.Class_INTERPRETER = "ClassInterpreterVirtualization_" + className + "_"+ _virtualizationContext.DataIndexFake;
            VirtualizationContext.Instance_INTERPRETER = "InstanceInterpreterVirtualization_" + className +"_" + _virtualizationContext.DataIndexFake;

            //local virtualization
            VirtualizeAtMethodLevel(methodLevelVirtualizedMethods, ref classMembers);
//            memberList = memberList.AddRange(virtualizedMethodLevel);

            //instance class virtualization
            VirtualizeAtClassInstanceLevel(instanceClassLevelVirtualizedMethods, ref classMembers);
//            memberList = memberList.AddRange(virtualizedInstanceClassLevel);

            //static class virtualization
            VirtualizeAtClassStaticLevel(staticClassLevelVirtualizedMethods, ref classMembers);
            //            memberList = memberList.AddRange(virtualizedStaticClassLevel);

            var memberList = SyntaxFactory.List<MemberDeclarationSyntax>();
            memberList = memberList.AddRange(classMembers);

            node = node.WithMembers(memberList).WithTriviaFrom(node);

            return node;
        }


        private void VirtualizeAtMethodLevel(List<Tuple<MethodDeclarationSyntax, List<string>, int>> methodLevelVirtualizedMethods, ref MemberDeclarationSyntax[] members)
        {
            if (_virtualizationContext.RefactoringOn)
                return;
            _virtualizationContext.SetMethodLevelVirtualization();
            
            List<MethodDeclarationSyntax> virtualizedMethodLevel = new List<MethodDeclarationSyntax>();
            if(methodLevelVirtualizedMethods.Count() == 0)
                return ;
            var methodVirtualiztionVisitor = new MethodVirtualizationVisitor(_virtualizationContext);
            
            foreach (var method in methodLevelVirtualizedMethods)
            {
                //call reset _virtualizationContext before each method so that the code[] and data[] do not overlap
                _virtualizationContext.Reset();
                _virtualizationContext.Options = method.Item2;                
                //VIRTUALIZATION
                var virtualizedMethod = (MethodDeclarationSyntax) methodVirtualiztionVisitor.Visit(method.Item1);
                members[method.Item3] = virtualizedMethod; //replace method
                virtualizedMethodLevel.Add(virtualizedMethod);
            }
            
        }

        private void VirtualizeAtClassStaticLevel(List<Tuple<MethodDeclarationSyntax, List<string>, int>> staticClassLevelVirtualizedMethods, ref MemberDeclarationSyntax[] members)
        {
            if (_virtualizationContext.RefactoringOn)
                return;
            //call reset _virtualizationContext before each method so that the code[] and data[] do not overlap
            _virtualizationContext.Operations.Clear();
            _virtualizationContext.SetClassLevelVirtualization();
            if (staticClassLevelVirtualizedMethods.Count() == 0)
                return ;
            var methodVirtualiztionVisitor = new MethodVirtualizationVisitor(_virtualizationContext);

            foreach (var method in staticClassLevelVirtualizedMethods)
            {
                //call reset _virtualizationContext before each method so that the code[] and data[] do not overlap
                _virtualizationContext.Reset();
                _virtualizationContext.Options = method.Item2;
                //VIRTUALIZATION
                var virtualizedMethod = (MethodDeclarationSyntax)methodVirtualiztionVisitor.Visit(method.Item1);
                members[method.Item3] = virtualizedMethod;
            }

            var membersExtended = members.ToList();
            List<StatementSyntax> statements = VirtualizationInterpreter(SyntaxFactory.Space, _virtualizationContext);
            BlockSyntax block = SyntaxFactory.Block(statements);
            var staticClassInterpeter = SyntaxFactoryExtensions.MethodDeclarationSyntax(_virtualizationContext.InterpreterIdentifier(), block, true).NormalizeWhitespace().WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));


            membersExtended.Add(staticClassInterpeter);

            members = membersExtended.ToArray();
        }

        private void VirtualizeAtClassInstanceLevel(List<Tuple<MethodDeclarationSyntax, List<string>, int>> instanceClassLevelVirtualizedMethods, ref MemberDeclarationSyntax[] members)
        {
            if (_virtualizationContext.RefactoringOn)
                return;
            //call reset _virtualizationContext before each method so that the code[] and data[] do not overlap
            _virtualizationContext.Operations.Clear();
            _virtualizationContext.SetInstanceLevelVirtualization();
            if (instanceClassLevelVirtualizedMethods.Count() == 0)
                return ;
            var methodVirtualiztionVisitor = new MethodVirtualizationVisitor(_virtualizationContext);
            foreach (var method in instanceClassLevelVirtualizedMethods)
            {
                _virtualizationContext.Reset();
                _virtualizationContext.Options = method.Item2;
                //VIRTUALIZATION
                var virtualizedMethod = (MethodDeclarationSyntax)methodVirtualiztionVisitor.Visit(method.Item1);
                members[method.Item3] = virtualizedMethod;
            }
            var membersExtended = members.ToList();
            
            List<StatementSyntax> statements = VirtualizationInterpreter(SyntaxFactory.Space, _virtualizationContext);
            BlockSyntax block = SyntaxFactory.Block(statements);
            var instanceClassInterpreter = SyntaxFactoryExtensions.MethodDeclarationSyntax(_virtualizationContext.InterpreterIdentifier(), block).NormalizeWhitespace().WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));
            membersExtended.Add(instanceClassInterpreter);

            members = membersExtended.ToArray();
        }



        private List<StatementSyntax> VirtualizationInterpreter(SyntaxTrivia leadingTrivia, VirtualizationContext context)
        {
            List<StatementSyntax> statements = new List<StatementSyntax>();
            var switchStatement =
                    SyntaxFactoryExtensions.SwitchBlockStatement(leadingTrivia, context)
                        .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)
                            );

            var whileTrueStatement = SyntaxFactoryExtensions.WhileTrue(leadingTrivia,
                new StatementSyntax[] { switchStatement })
                .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine),
                    SyntaxFactory.EndOfLine(Environment.NewLine));

            statements.Add(whileTrueStatement);
            
            var returnStatement = SyntaxFactoryExtensions.ReturnStatement("object")
                .WithLeadingTrivia(leadingTrivia)
                .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)).NormalizeWhitespace();

            statements.Add(returnStatement);
            return statements;
        }


        /// <summary>
        /// returns:
        /// Item1 (isMarkedForVirtualization), 
        /// Item2(virtualizationLevel), 
        /// Item3(isDebug)
        /// </summary>
        /// <param name="oldMethod"></param>
        /// <returns> name=Item1 (isMarkedForVirtualization), Item2(virtualizationLevel), Item3(isDebug)</returns>
        public static Tuple<bool, List<string>> MarkedForVirtualization(MethodDeclarationSyntax oldMethod)
        {
            string identifier = oldMethod.Identifier.ValueText;
            List<string> virtualizationAttributes = new List<string>();
            foreach (var attribute in oldMethod.AttributeLists)
            {
                var attributesList = attribute.Attributes;
                foreach (var attr in attributesList)
                {
                    virtualizationAttributes.Clear();
                    bool isMarked = true;
                    bool localVirtualization = false;

                    if (attr.ArgumentList == null)
                        continue;

                    foreach (var arg in attr.ArgumentList.Arguments)
                    {
                        var kindString  = arg.Kind().ToString();
                        if (arg.NameEquals == null)
                            continue;
                        string name = arg.NameEquals.Name.ToString();
                        string value = arg.Expression.ToString();
                        value = value.Substring(1, value.Length - 2);
                        if (name.Equals("Feature"))
                        {
                            String[] attributes = value.Split(';', '.', '-');
                            foreach (string va in attributes)
                            {
                                string option = va.ToLower().Trim(' ',';', '-');
                                if (option.Contains("virtualization"))
                                    localVirtualization = true;
                                virtualizationAttributes.Add(option);
                            }
                            
                        }
                        else if (name.Equals("Exclude"))
                        {
                            if (value.Contains("true"))
                            {
                                isMarked = false;
                            }
                        }
                    }

                    if (localVirtualization)
                    {
                        return new Tuple<bool, List<string>>(isMarked, virtualizationAttributes);
                    }
                }
            }

            return new Tuple<bool, List<string>>(false, virtualizationAttributes);
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/ConstantValueVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Visitors
{
    internal class ConstantValueVisitor : CSharpSyntaxRewriter
    {
        private VirtualizationContext _virtualizationContext;

        public List<LiteralExpressionSyntax> constants = new List<LiteralExpressionSyntax>();
        public readonly List<Tuple<LiteralExpressionSyntax, List<StatementSyntax>>> markedNodes =
            new List<Tuple<LiteralExpressionSyntax, List<StatementSyntax>>>();

        public ConstantValueVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
        {
            //cut child traversal
            return node;
        }

        public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
        {
            //cut child traversal
            return node;
        }

        public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
        {
            //cut child traversal
            return node;
        }

        public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
        {
            if (node.Kind() != SyntaxKind.UnaryMinusExpression)
            {
                return base.VisitPrefixUnaryExpression(node);
            }
            var expression = node.Operand;
            if (expression.Kind() != SyntaxKind.NumericLiteralExpression)
            {
                return base.VisitPrefixUnaryExpression(node);
            }

            CheckCastContex(node);

            string value = node.ToString();
            bool found = false;
            VirtualData constant = null;
            foreach (var data in _virtualizationContext.data)
            {
                if (value.Equals(data.Name))
                {
                    found = true;
                    constant = data;
                    break;
                }
            }
            if (!found)
            {
                int index = _virtualizationContext.DataIndex;
                string name = value;
                SyntaxAnnotation indexMarker = new SyntaxAnnotation("index", index + "");
                SyntaxAnnotation nameMarker = new SyntaxAnnotation("name", name);
                SyntaxAnnotation constantMarker = new SyntaxAnnotation("type", "constant");
                SyntaxAnnotation codeMarker = new SyntaxAnnotation("code", "undefined");
                SyntaxAnnotation uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);

                constant = new VirtualData();
                constant.Index = index;
                constant.Name = name;
                var typeInfo = _virtualizationContext.semanticModel.GetTypeInfo(node);
                var info = typeInfo.Type.ToString();
                constant.Type = info;
                constant.Node = node;
                constant.DefaultValue = node;
                constant.Annotations.Add(indexMarker);
                constant.Annotations.Add(nameMarker);
                constant.Annotations.Add(constantMarker);
                constant.Annotations.Add(codeMarker);
                constant.Annotations.Add(uniqueMarker);
                _virtualizationContext.data.Add(constant);
            }

            //            constants.Add(node);

            

            ExpressionSyntax newNode = SyntaxFactoryExtensions.DataCodeVirtualAccess();
            newNode = newNode.WithAdditionalAnnotations(constant.Annotations);
            ExpressionSyntax newExpression;
            if (CastEnabled)
            {
                newExpression = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName
                    (
                        @"" + constant.Type
                    ),
                    newNode
                    );
            }
            else
            {
                newExpression = newNode;
            }

            //TODO: add annotations + comments
            newExpression = newExpression.WithLeadingTrivia(node.GetLeadingTrivia())
                .WithTrailingTrivia(node.GetTrailingTrivia())
                ;

            return newExpression;
        }
        
        public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
        {
            var kind = node.Kind();
            if ( (kind != SyntaxKind.NumericLiteralExpression) &&
                 (kind != SyntaxKind.StringLiteralExpression) &&
                 (kind != SyntaxKind.FalseLiteralExpression) &&
                 (kind != SyntaxKind.TrueLiteralExpression) &&
                 (kind != SyntaxKind.CharacterLiteralExpression)
               )
                return node;

            CheckCastContex(node);

            string value = node.ToString();
            bool found = false;
            VirtualData constant = null ;
            string requiredType = GetRequiredType(node); //in the case of return statements
            if (requiredType.Equals("void"))
                requiredType = ""; // return statement was added as a refactoring "hack"

            var typeInfo = _virtualizationContext.semanticModel.GetTypeInfo(node);
            var declaredType = typeInfo.Type.ToString();

            foreach (var data in _virtualizationContext.data)
            {
                if (value.Equals(data.Name)) 
                {
                    if (requiredType.Equals("") && declaredType.Equals(data.Type))
                    {
                        found = true;
                        constant = data;
                        requiredType = declaredType;
                        break;
                    }
                    if (requiredType.Equals(data.Type))
                    {
                        found = true;
                        constant = data;
                        break;
                    }
                }                 
            }
            if (!found)
            {
                if(requiredType.Equals(""))
                    requiredType = declaredType;

                int index = _virtualizationContext.DataIndex;
                string name = value;
                SyntaxAnnotation dataIndexMarker = new SyntaxAnnotation("index", index + "");
                SyntaxAnnotation nameMarker = new SyntaxAnnotation("name", name);
                SyntaxAnnotation constantMarker = new SyntaxAnnotation("type", "constant");
                SyntaxAnnotation codeIndexMarker = new SyntaxAnnotation("code", "undefined");
                SyntaxAnnotation uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);

                constant = new VirtualData();
                constant.Index = index;
                constant.Name = name;
                var info = requiredType;
                
                constant.Type = info;
                constant.Node = node;
                constant.DefaultValue = node;
                constant.Annotations.Add(dataIndexMarker);
                constant.Annotations.Add(nameMarker);
                constant.Annotations.Add(constantMarker);
                constant.Annotations.Add(codeIndexMarker);
                constant.Annotations.Add(uniqueMarker);
                _virtualizationContext.data.Add(constant);
            }

          
            
            ExpressionSyntax newNode = SyntaxFactoryExtensions.DataCodeVirtualAccess();
            newNode = newNode.WithAdditionalAnnotations(constant.Annotations);
            ExpressionSyntax newExpression;
            if (CastEnabled)
            {
                newExpression = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName
                    (
                        @"" + constant.Type
                    ),
                    newNode
                    );
            }
            else
            {
                newExpression = newNode;
            }

            //TODO: add annotations + comments
            newExpression = newExpression.WithLeadingTrivia(node.GetLeadingTrivia())
                .WithTrailingTrivia(node.GetTrailingTrivia())
                ;

            return newExpression;
        }

        private bool IsUniqueInstructionIndex(string index, IEnumerable<SyntaxNode> nodes)
        {
            var newIndex = index;
            foreach (var annodatedNode in nodes)
            {
                var nameAnnotation = annodatedNode.GetAnnotations("code").FirstOrDefault();
                var usedIndex = nameAnnotation?.Data;
                if (newIndex.Equals(usedIndex))
                    return false;
            }

            return true ;
        }

        public bool CastEnabled { get; set; } = true;

        private void CheckCastContex(LiteralExpressionSyntax node)
        {
            var parent = node.Parent;
            if (parent is EqualsValueClauseSyntax)
                CastEnabled = false;
            else if (parent is AssignmentExpressionSyntax)
                CastEnabled = false;
            else
                CastEnabled = true;
        }

        private void CheckCastContex(PrefixUnaryExpressionSyntax node)
        {
            var parent = node.Parent;
            if (parent is EqualsValueClauseSyntax)
                CastEnabled = false;
            else if (parent is AssignmentExpressionSyntax)
                CastEnabled = false;
            else
                CastEnabled = true;
        }

        /// <summary>
        /// If the constant is the return argument of a method, extract the method return type
        /// to force casting from object.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public string GetRequiredType(SyntaxNode node)
        {
            if (node == null)
                return "";

            string requiredType = "";
            if (node.Parent != null)
            {                            
                if ((node.Parent.Kind() == SyntaxKind.ReturnStatement))
                {
                    var method = GetParentMethod(node.Parent) as MethodDeclarationSyntax;
                    if (method != null)
                    {
                        requiredType = method.ReturnType.ToString();
                    }
                }               
            }
            return requiredType;
        }

        public SyntaxNode GetParentExpression(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.ExpressionStatement) || (node.Kind() == SyntaxKind.LocalDeclarationStatement)
                || (node.Kind() == SyntaxKind.ReturnStatement)
                )
                if (node.Parent != null)
                    if (node.Parent.Kind() == SyntaxKind.Block)
                        return node;

            return GetParentExpression(node.Parent);
        }

        public SyntaxNode GetParentMethod(SyntaxNode node)
        {
            if (node == null)
                return node;
            if ((node.Kind() == SyntaxKind.MethodDeclaration))
                return node;

            return GetParentMethod(node.Parent);
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/LocalDeclarationExtractorVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console
{
    class LocalDeclarationExtractorVisitor : CSharpSyntaxRewriter
    {

        private VirtualizationContext _virtualizationContext;

        private readonly List<LocalDeclarationStatementSyntax> markedNodes =
            new List<LocalDeclarationStatementSyntax>();
        private readonly List<Tuple<LocalDeclarationStatementSyntax, List<StatementSyntax>>> replacementNodes =
            new List<Tuple<LocalDeclarationStatementSyntax, List<StatementSyntax>>>();

        public LocalDeclarationExtractorVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
        {
            var declaration = node;

            List<StatementSyntax> statements = new List<StatementSyntax>();
            markedNodes.Add(node);

            foreach (var variable in declaration.Declaration.Variables)
            {

                int index = _virtualizationContext.DataIndex;
                string name = variable.Identifier.Text;
                SyntaxAnnotation indexMarker = new SyntaxAnnotation("index", index + "");
                SyntaxAnnotation nameMarker = new SyntaxAnnotation("name", name);
                SyntaxAnnotation variableMarker = new SyntaxAnnotation("type", "variable");
                SyntaxAnnotation codeIndexMarker = new SyntaxAnnotation("code", "undefined");
                SyntaxAnnotation uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);

                var virtualData = new VirtualData();
                virtualData.Type = declaration.Declaration.Type.ToString();
                virtualData.Index = index;
                virtualData.Name = name;
                virtualData.Annotations.Add(indexMarker);
                virtualData.Annotations.Add(nameMarker);
                virtualData.Annotations.Add(variableMarker);
                virtualData.Annotations.Add(codeIndexMarker);
                virtualData.Annotations.Add(uniqueMarker);
                _virtualizationContext.data.Add(virtualData);

                //TODO: split for multiple variables in the same declaration
                var initializer = variable.Initializer;
                if (initializer == null)
                {
                    continue;
                }

                SyntaxNode rightValue;
               
                rightValue = initializer.DescendantNodes().First();
                ExpressionStatementSyntax newNode;
                if (SyntaxFactoryExtensions.IsBasicType(virtualData.Type))
                {                    
                        newNode = SyntaxFactoryExtensions.DataVirtualAssignment(rightValue, virtualData.Annotations.ToArray())
                        .WithLeadingTrivia(declaration.GetLeadingTrivia())
                        .WithTrailingTrivia(declaration.GetTrailingTrivia())
                    ;
                }
                else
                {
                    newNode = SyntaxFactoryExtensions.DataVirtualAssignment(virtualData.Type, rightValue, virtualData.Annotations.ToArray())
                        .WithLeadingTrivia(declaration.GetLeadingTrivia())
                        .WithTrailingTrivia(declaration.GetTrailingTrivia())
                    ;
                }

                virtualData.Node = newNode;
                virtualData.Statement = newNode;
                statements.Add(newNode);
            }

            replacementNodes.Add(new Tuple<LocalDeclarationStatementSyntax, List<StatementSyntax>>(node, statements));

            return node;
        }

        private BlockSyntax ReplaceNodes(BlockSyntax oldBody)
        {
            oldBody = oldBody.TrackNodes(this.markedNodes);
            foreach (var tuple in this.replacementNodes)
            {
                var currentA = oldBody.GetCurrentNode(tuple.Item1);

                var replacedExpr = oldBody.ReplaceNode(currentA, tuple.Item2);
                oldBody = replacedExpr;
            }
            return oldBody;
        }


        public BlockSyntax Refactor(BlockSyntax oldBody)
        {
            markedNodes.Clear();
            replacementNodes.Clear();
            oldBody = (BlockSyntax)this.Visit(oldBody);
            oldBody = this.ReplaceNodes(oldBody);

            return oldBody;
        }

    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/LocalVariableUsageDataVirtVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Visitors
{
    class LocalVariableUsageDataVirtVisitor : CSharpSyntaxRewriter
    {

        private VirtualizationContext _virtualizationContext;

        public LocalVariableUsageDataVirtVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public bool CastEnabled { get; set; } = true;

        public bool ParenthesizeEnabled { get; set; } = true;

        public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
        {
            CheckCastContex(node);
            CheckParenthesizeContex(node);

            var newNode = SyntaxFactoryExtensions.DataCodeVirtualAccess();
                
            string name = node.Identifier.Text;
            string typeText = "";
            bool found = false;
            VirtualData virtualData = null;
            foreach (var data in _virtualizationContext.data)
            {
                if (data.Name.Equals(name))
                {
                    typeText = data.Type;
                    found = true;
                    virtualData = data;
                    break;
                }
            }
            if (!found)
                return node;

            newNode = newNode.WithAdditionalAnnotations(virtualData.Annotations);

            var newExpression = newNode;
            if (CastEnabled)
            {
                newExpression = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName
                                                        (
                                                            @"" + typeText
                                                        ),
                                                           newNode
                                                       );
                
            }
            if(ParenthesizeEnabled)
                newExpression = SyntaxFactory.ParenthesizedExpression(newExpression);

            newExpression = newExpression.WithLeadingTrivia(node.GetLeadingTrivia())
                .WithTrailingTrivia(node.GetTrailingTrivia())
                ;

            return newExpression;
        }

        private void CheckCastContex(IdentifierNameSyntax node)
        {
            var parentCheck = node.Parent;
            if (parentCheck is AssignmentExpressionSyntax)
            {
                var parent = parentCheck as AssignmentExpressionSyntax;
                if (parent.Kind() == SyntaxKind.SimpleAssignmentExpression)
                {
                    var assignment = parent as AssignmentExpressionSyntax;
                    if (assignment.Right.IsEquivalentTo(node))
                        CastEnabled = true;
                    else
                        CastEnabled = false;
                }                    
            }
            else
                CastEnabled = true;
        }

        private void CheckParenthesizeContex(IdentifierNameSyntax node)
        {
            //TODO: check pointers
            var parent = node.Parent;
            if (parent.Kind() == SyntaxKind.SimpleMemberAccessExpression)
            {
                ParenthesizeEnabled = true;
            }
            else if (parent.Kind() == SyntaxKind.ElementAccessExpression)
            {
                ParenthesizeEnabled = true;
            }
            else
                ParenthesizeEnabled = false;
        }
    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/MethodParamsExtractorVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console
{
    class MethodParamsExtractorVisitor : CSharpSyntaxRewriter
    {

        private VirtualizationContext _virtualizationContext;

        private readonly List<LocalDeclarationStatementSyntax> markedNodes =
            new List<LocalDeclarationStatementSyntax>();
        private readonly List<Tuple<LocalDeclarationStatementSyntax, List<StatementSyntax>>> replacementNodes =
            new List<Tuple<LocalDeclarationStatementSyntax, List<StatementSyntax>>>();

        public MethodParamsExtractorVisitor(VirtualizationContext _virtualizationContext)
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitParameter(ParameterSyntax node)
        {
            bool isRef = node.Modifiers.Count(m => m.Kind() == SyntaxKind.RefKeyword) > 0;
            if (isRef)
            {
                throw new NotImplementedException("Virtualization: No support for REF parameter");
            }
            bool isOut = node.Modifiers.Count(m => m.Kind() == SyntaxKind.OutKeyword) > 0;
            if (isOut)
                throw new NotImplementedException("Virtualization: No support for OUT parameter");

            int index = _virtualizationContext.DataIndex;
            string name = node.Identifier.ToString();
            SyntaxAnnotation indexMarker = new SyntaxAnnotation("index", index + "");
            SyntaxAnnotation nameMarker = new SyntaxAnnotation("name", name);
            SyntaxAnnotation variableMarker = new SyntaxAnnotation("type", "variable");
            SyntaxAnnotation codeIndexMarker = new SyntaxAnnotation("code", "undefined");
            SyntaxAnnotation uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);

            var initializer = SyntaxFactory.IdentifierName(name);
            var virtualData = new VirtualData();
            virtualData.Type = node.Type.ToString();
            virtualData.Index = index;
            virtualData.Name = name;
            virtualData.Annotations.Add(indexMarker);
            virtualData.Annotations.Add(nameMarker);
            virtualData.Annotations.Add(variableMarker);
            virtualData.Annotations.Add(codeIndexMarker);
            virtualData.Annotations.Add(uniqueMarker);
            virtualData.DefaultValue = initializer;
            _virtualizationContext.data.Add(virtualData);

            return node;
        }


    }
}



================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/MethodVirtualizationVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using CodeVirtualization_Console.Context;
using CodeVirtualization_Console.Utils;
using CodeVirtualization_Console.VirtualizationVisitors;
using CodeVirtualization_Console.Visitors;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console
{
    internal class MethodVirtualizationVisitor : CSharpSyntaxRewriter
    {
        private const int METHOD_MIN_STATEMENTS = 2;
        private readonly VirtualizationContext _virtualizationContext;

        private static int unique_id = 0;
        private static int UNIQUE_ID => unique_id++;

        public MethodVirtualizationVisitor(VirtualizationContext _virtualizationContext) 
        {
            this._virtualizationContext = _virtualizationContext;
        }

        public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax method)
        {
            if (!ClassVirtualizationVisitor.MarkedForVirtualization(method).Item1)
                return method;

            if (method.Body.DescendantNodes().OfType<StatementSyntax>().Count() <= METHOD_MIN_STATEMENTS)
            {
                return method;
            }

            if (_virtualizationContext.RefactoringOn)
                return method;

            var oldBody = method.Body;

            var localDeclarationExtractorVisitor = new LocalDeclarationExtractorVisitor(_virtualizationContext);
            var assignmentVisitor = new AssignmentDataVirtualizationVisitor(_virtualizationContext);
            var localVariableUsageVisitor = new LocalVariableUsageDataVirtVisitor(_virtualizationContext);
            var constantValueVisitor = new ConstantValueVisitor(_virtualizationContext);
            var statementsExtractorVisitor = new StatementsExtractorVisitor();
            var parametersExtractorVisitor = new MethodParamsExtractorVisitor(_virtualizationContext);
            method = (MethodDeclarationSyntax) parametersExtractorVisitor.Visit(method);

            

            oldBody = (BlockSyntax)constantValueVisitor.Visit(oldBody);

            oldBody = localDeclarationExtractorVisitor.Refactor(oldBody);

            oldBody = (BlockSyntax) assignmentVisitor.Visit(oldBody);
            oldBody = (BlockSyntax) localVariableUsageVisitor.Visit(oldBody);

            var statements = new List<StatementSyntax>();

            int vpcRandomOffset = VirtualizationContext.INSTRUCTION_SIZE_PREFIX +
                                  VirtualizationContext.GetRandom(0, 100);

            int maxCodeKey = VirtualizationContext.GetRandom(VirtualizationContext.MAX_CODE_KEY + 1,
                VirtualizationContext.MAX_CODE_KEY + 1000);
            StatementSyntax codeNode = SyntaxFactoryExtensions.GenerateArrayDeclaration(VirtualizationContext.CODE_IDENTIFIER, maxCodeKey,
                SyntaxKind.IntKeyword);
            int maxDataKey = VirtualizationContext.GetRandom(VirtualizationContext.MAX_DATA_KEY + 1,
                VirtualizationContext.MAX_DATA_KEY + 1000);
            StatementSyntax dataNode = SyntaxFactoryExtensions.GenerateArrayDeclaration(VirtualizationContext.DATA_IDENTIFIER, maxDataKey,
                SyntaxKind.ObjectKeyword);
            StatementSyntax vpcNode = SyntaxFactoryExtensions.LocalVariableDeclaration(VirtualizationContext.VPC_IDENTIFIER, vpcRandomOffset, SyntaxKind.IntKeyword);

            SyntaxNode firstNode;
            BlockSyntax newBlock1;

            firstNode = oldBody.DescendantNodes().First();
            var leadingTrivia = firstNode.GetLeadingTrivia().Last();

            codeNode = codeNode.WithLeadingTrivia(leadingTrivia,
                SyntaxFactory.Comment("//Virtualization variables" + Environment.NewLine), leadingTrivia);
            codeNode = codeNode.WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));

            dataNode = dataNode.WithLeadingTrivia(leadingTrivia);
            dataNode = dataNode.WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));

            vpcNode = vpcNode.WithLeadingTrivia(leadingTrivia);
            vpcNode = vpcNode.WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));

            statements.Add(codeNode);
            statements.Add(dataNode);
            statements.Add(vpcNode);


            oldBody = (BlockSyntax) statementsExtractorVisitor.Visit(oldBody);
            var expressions = statementsExtractorVisitor.Statements;
            var expressionsToRemove = statementsExtractorVisitor.StatementsToRemove;

            //generate code[] sequence
            StatementsToVirtualOperation(expressionsToRemove);

            var interpreterStatements = new List<StatementSyntax>();
            if (_virtualizationContext.IsMethodLevel)
                MethodLevelInterpreter(leadingTrivia, interpreterStatements, method);
            else if (_virtualizationContext.IsClassLevel)
                ClassStaticLevelInterpreter(leadingTrivia, interpreterStatements, method);
            else if (_virtualizationContext.IsInstanceLevel)
                ClassInstanceLevelInterpreter(leadingTrivia, interpreterStatements, method);

            #region CODE_GENERATION

            List<StatementSyntax> dataInitStatements;
            List<StatementSyntax> codeInitStatements;

            List<StatementSyntax> virtualizationCodeStatements = new List<StatementSyntax>();            

            if (_virtualizationContext.ReadableOn)
            {
                dataInitStatements = DataInitReadable(leadingTrivia);
                codeInitStatements = CodeInitReadable(leadingTrivia, vpcRandomOffset);

                virtualizationCodeStatements.AddRange(dataInitStatements);
                virtualizationCodeStatements.AddRange(codeInitStatements);
            }
            else
            {
                var randomCodeInit = CodeInitRandom(leadingTrivia, maxCodeKey);

                dataInitStatements = DataInit(leadingTrivia);
                codeInitStatements = CodeInit(leadingTrivia, vpcRandomOffset);

                dataInitStatements.AddRange(codeInitStatements);
                dataInitStatements.Shuffle();

                virtualizationCodeStatements.AddRange(randomCodeInit);
                virtualizationCodeStatements.AddRange(dataInitStatements);

            }
            statements.AddRange(virtualizationCodeStatements);
            statements.AddRange(interpreterStatements);

            #endregion

            oldBody = oldBody.RemoveNodes(expressionsToRemove, SyntaxRemoveOptions.KeepNoTrivia);
            newBlock1 = oldBody.AddStatements(statements.ToArray());


            if (_virtualizationContext.DebugOn)
            {
                statements = new List<StatementSyntax>() {statements[0], statements[1], statements[2]};//keep code[], data[], vpc variables creation
                statements.AddRange(expressions.Cast<StatementSyntax>() );
                newBlock1 = oldBody.InsertNodesBefore(firstNode, statements);
            }

            var updatedMethod = method.ReplaceNode(method.Body, newBlock1);

            Console.WriteLine("Method Virtualized: " + method.Identifier);
            Debug.WriteLine("Method Virtualized: " + method.Identifier);
            return updatedMethod;
        }



        private void ClassStaticLevelInterpreter(SyntaxTrivia leadingTrivia, List<StatementSyntax> statements, MethodDeclarationSyntax method)
        {
            //invoke the class level static interpreter
            string returnType = method.ReturnType.ToString();
            var invokeInterpreter = SyntaxFactoryExtensions.InvocationDeclarationSyntax(VirtualizationContext.Class_INTERPRETER);
            if (!returnType.Equals("void"))
            {
                var castExpression = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + returnType), invokeInterpreter.Expression);
                var returnStatement = SyntaxFactory.ReturnStatement(castExpression).NormalizeWhitespace()
                    .WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine), leadingTrivia)
                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine), SyntaxFactory.EndOfLine(Environment.NewLine));
                statements.Add(returnStatement);
            }
            else
            {
                statements.Add(invokeInterpreter.WithLeadingTrivia(leadingTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)));
            }
        }

        private void ClassInstanceLevelInterpreter(SyntaxTrivia leadingTrivia, List<StatementSyntax> statements, MethodDeclarationSyntax method)
        {
            //invoke the class level instance interpreter
            string returnType = method.ReturnType.ToString();
            var invokeInterpreter = SyntaxFactoryExtensions.InvocationDeclarationSyntax(VirtualizationContext.Instance_INTERPRETER);
            if (!returnType.Equals("void"))
            {
                var castExpression = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + returnType), invokeInterpreter.Expression);
                var returnStatement = SyntaxFactory.ReturnStatement(castExpression).NormalizeWhitespace()
                    .WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine), leadingTrivia)
                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine), SyntaxFactory.EndOfLine(Environment.NewLine));
                statements.Add(returnStatement);
            }
            else
            {
                statements.Add(invokeInterpreter.WithLeadingTrivia(leadingTrivia).WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)));
            }
        }

        private void MethodLevelInterpreter(SyntaxTrivia leadingTrivia, List<StatementSyntax> statements, MethodDeclarationSyntax method)
        {
            var switchStatement =
                    SyntaxFactoryExtensions.SwitchBlockStatement(leadingTrivia, _virtualizationContext)
                        .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)
                            );

            var whileTrueStatement = SyntaxFactoryExtensions.WhileTrue(leadingTrivia,
                new StatementSyntax[] { switchStatement })
                .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine),
                    SyntaxFactory.EndOfLine(Environment.NewLine));

            statements.Add(whileTrueStatement);

            string returnType = method.ReturnType.ToString();
            if (!returnType.Equals("void"))
            {
                var returnStatement = SyntaxFactoryExtensions.ReturnStatement(returnType)
                .WithLeadingTrivia(leadingTrivia)
                .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine));
                statements.Add(returnStatement);
            }            
        }

        #region DATA_INIT
        /// <summary>
        /// 
        /// </summary>
        /// <param name="leadingTrivia"></param>
        /// <returns></returns>
        private List<StatementSyntax> DataInit(SyntaxTrivia leadingTrivia)
        {
            //TODO: refactor to data[] = { ..., ..., ... };
            List<StatementSyntax> statements = new List<StatementSyntax>();
            foreach (var data in this._virtualizationContext.data)
            {
                string type = data.Type;
                var rightValue = data.DefaultValue;
                //force cast to long/short to be recognized when stored to object
                //TODO: add other types for casting
                if (!type.Equals("int") && !type.Equals("bool") && !type.Equals("string"))
                {
                    rightValue = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + type),rightValue).NormalizeWhitespace();
                }

                var assignment = SyntaxFactoryExtensions.ArrayElementInit("data", data.Index, rightValue)
                    .WithLeadingTrivia(leadingTrivia)
                    .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine))
                ;
                statements.Add(assignment);
            }

            if (statements.Count > 0)
            {
                var firstInit = statements[0];
                var triviaList = firstInit.GetLeadingTrivia();
                triviaList = triviaList.Insert(0, leadingTrivia);
                firstInit = firstInit.WithLeadingTrivia(triviaList);
                statements[0] = firstInit;                
            }
            
            statements.Shuffle();

            return statements;
        }

        private List<StatementSyntax> DataInitReadable(SyntaxTrivia leadingTrivia)
        {
            List<StatementSyntax> statements = new List<StatementSyntax>();
            foreach (var data in this._virtualizationContext.data)
            {
                string type = data.Type;
                var rightValue = data.DefaultValue;
                //force cast to long/short to be recognized when stored to object
                //TODO: add other types for casting
                if (!type.Equals("int") && !type.Equals("bool") && !type.Equals("string"))
                {
                    rightValue = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + type), rightValue).NormalizeWhitespace();
                }

                var assignment = SyntaxFactoryExtensions.ArrayElementInit("data", data.Index, rightValue)
                    .WithLeadingTrivia(leadingTrivia)
                    .WithTrailingTrivia(SyntaxFactory.Comment(" //" + data.Name + " " + (data.IsConstant ? "constant" : ""))
                    , SyntaxFactory.EndOfLine(Environment.NewLine)
                    );
                statements.Add(assignment);
            }

            if (statements.Count > 0)
            {
                var firstInit = statements[0];
                var triviaList = firstInit.GetLeadingTrivia();
                triviaList = triviaList.Insert(0, SyntaxFactory.EndOfLine(Environment.NewLine));
                triviaList = triviaList.Insert(1, leadingTrivia);
                triviaList = triviaList.Insert(2, SyntaxFactory.Comment("//Data init" + Environment.NewLine));
                firstInit = firstInit.WithLeadingTrivia(triviaList);
                statements[0] = firstInit;
            }

            return statements;
        }
        #endregion

        #region CODE_INIT

        /// <summary>
        /// Initialize 10% of the code[] elements with random int values at random positions
        /// </summary>
        /// <param name="leadingTrivia"></param>
        /// <returns></returns>
        private List<StatementSyntax> CodeInitRandom(SyntaxTrivia leadingTrivia, int maxCodeSize)
        {
            var codeInitStatements = new List<StatementSyntax>();
            int numberOfElements = (int) (0.005*maxCodeSize); //initialize 10% of the elements
            int newLineMark = 6; //number of elements per line
            for(int index = 0; index < numberOfElements; index++)
            {
                int position = VirtualizationContext.GetRandom(0, maxCodeSize-1);
                int randomValue = VirtualizationContext.GetRandom(-1000,1500);
                var codeInit =
                    SyntaxFactoryExtensions.GetVirtualCodeAssignment(position, randomValue)                        
                        ;
                if (newLineMark == 0)
                {
                    codeInit =
                    SyntaxFactoryExtensions.GetVirtualCodeAssignment(position, randomValue)
                        .WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine), leadingTrivia)
                        ;
                    newLineMark = 6;
                }
                codeInitStatements.Add(codeInit);
                newLineMark --;
            }

            if (codeInitStatements.Count > 0)
            {
                var firstCodeInit = codeInitStatements[0];
                var triviaList = firstCodeInit.GetLeadingTrivia();
                triviaList = triviaList.Insert(0, SyntaxFactory.EndOfLine(Environment.NewLine));
                triviaList = triviaList.Insert(1, leadingTrivia);                
                firstCodeInit = firstCodeInit.WithLeadingTrivia(triviaList);
                codeInitStatements[0] = firstCodeInit;
            }

//            codeInitStatements.Shuffle();

            return codeInitStatements;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="leadingTrivia"></param>
        /// <returns></returns>
        private List<StatementSyntax> CodeInitReadable(SyntaxTrivia leadingTrivia, int vpcRandomOffset)
        {
            var codeInitStatements = new List<StatementSyntax>();
            int offset = vpcRandomOffset;
            int index = 0;
            int codeIndex = offset;
            foreach (var code in _virtualizationContext.code)
            {
                
                int value = code.Key;
                var codeInit =
                    SyntaxFactoryExtensions.GetVirtualCodeAssignment(codeIndex, value)
                        .WithLeadingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine),leadingTrivia)
                        .WithTrailingTrivia(SyntaxFactory.Comment(" //" + code.Name +" # " + code.UniqueName), SyntaxFactory.EndOfLine(Environment.NewLine));
                codeInitStatements.Add(codeInit);

                var dataNodes = code.GetData();
                foreach (var data in dataNodes)
                {
                    var dataCodeIndex = codeIndex + Int32.Parse(data.Item3);
                    string dataIndex = data.Item2;
                    var dataInit =
                        SyntaxFactoryExtensions.GetVirtualCodeAssignment(dataCodeIndex, dataIndex)
                            .WithLeadingTrivia(leadingTrivia)
                            .WithTrailingTrivia(SyntaxFactory.Comment(" //" + data.Item1), SyntaxFactory.EndOfLine(Environment.NewLine))
                            ;
                    codeInitStatements.Add(dataInit);
                }

                //process fake data items
                var fakeDataNodes = code.GetFakeData();
                foreach (var data in fakeDataNodes)
                {
                    var dataCodeIndex = codeIndex + Int32.Parse(data.Item3);
                    string dataIndex = data.Item2;
                    var dataInit =
                        SyntaxFactoryExtensions.GetVirtualCodeAssignment(dataCodeIndex, dataIndex)
                            .WithLeadingTrivia(leadingTrivia)
                            .WithTrailingTrivia(SyntaxFactory.Comment(" //" + data.Item1), SyntaxFactory.EndOfLine(Environment.NewLine))
                            ;
                    codeInitStatements.Add(dataInit);
                }

                codeIndex += code.Size;
            }

            if (codeInitStatements.Count > 0)
            {
                var firstCodeInit = codeInitStatements[0];
                var triviaList = firstCodeInit.GetLeadingTrivia();
                triviaList = triviaList.Insert(0, SyntaxFactory.EndOfLine(Environment.NewLine));
                triviaList = triviaList.Insert(1, leadingTrivia);
                triviaList = triviaList.Insert(2, SyntaxFactory.Comment("//Code init" + Environment.NewLine));
                firstCodeInit = firstCodeInit.WithLeadingTrivia(triviaList);
                codeInitStatements[0] = firstCodeInit;
            }

            return codeInitStatements;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="leadingTrivia"></param>
        /// <returns></returns>
        private List<StatementSyntax> CodeInit(SyntaxTrivia leadingTrivia, int vpcRandomOffset)
        {
            var codeInitStatements = new List<StatementSyntax>();
            int offset = vpcRandomOffset;
            int index = 0;
            int codeIndex = offset;
            foreach (var code in _virtualizationContext.code)
            {

                int value = code.Key;
                var codeInit =
                    SyntaxFactoryExtensions.GetVirtualCodeAssignment(codeIndex, value)
                        ;
                codeInitStatements.Add(codeInit);

                var dataNodes = code.GetData();
                foreach (var data in dataNodes)
                {
                    var dataCodeIndex = codeIndex + Int32.Parse(data.Item3);
                    string dataIndex = data.Item2;
                    var dataInit =
                        SyntaxFactoryExtensions.GetVirtualCodeAssignment(dataCodeIndex, dataIndex)
                            
                            ;
                    codeInitStatements.Add(dataInit);
                }

                //process fake data items
                var fakeDataNodes = code.GetFakeData();
                foreach (var data in fakeDataNodes)
                {
                    var dataCodeIndex = codeIndex + Int32.Parse(data.Item3);
                    string dataIndex = data.Item2;
                    var dataInit =
                        SyntaxFactoryExtensions.GetVirtualCodeAssignment(dataCodeIndex, dataIndex)
                           
                            ;
                    codeInitStatements.Add(dataInit);
                }

                codeIndex += code.Size;
            }

//            if (codeInitStatements.Count > 0)
//            {
//                var firstCodeInit = codeInitStatements[0];
//                var triviaList = firstCodeInit.GetLeadingTrivia();
//                triviaList = triviaList.Insert(0, SyntaxFactory.EndOfLine(Environment.NewLine));
//                triviaList = triviaList.Insert(1, leadingTrivia);                
//                firstCodeInit = firstCodeInit.WithLeadingTrivia(triviaList);
//                codeInitStatements[0] = firstCodeInit;
//            }

            codeInitStatements.Shuffle();

            return codeInitStatements;
        }


        #endregion


        /// <summary>
        /// 
        /// </summary>
        /// <param name="expressions"></param>
        public void StatementsToVirtualOperation(IEnumerable<SyntaxNode> expressions)
        {
            foreach (var expression1 in expressions)
            {
                var expressionToProcess = expression1.NormalizeWhitespace() as StatementSyntax;

                if (expressionToProcess.Kind() == SyntaxKind.IfStatement)
                {
                    var ifStatement = expressionToProcess as IfStatementSyntax;
                    StatementsToVirtualOperation(ifStatement);
                    continue;
                }
                else if (expressionToProcess.Kind() == SyntaxKind.WhileStatement)
                {
                    var whileStatement = expressionToProcess as WhileStatementSyntax;
                    StatementsToVirtualOperation(whileStatement);
                    continue;
                }
                else if (expressionToProcess.Kind() == SyntaxKind.ContinueStatement)
                {
                    var continueStatement = expressionToProcess as ContinueStatementSyntax;
                    StatementsToVirtualOperation(continueStatement);
                    continue;
                }
                else if (expressionToProcess.Kind() == SyntaxKind.TryStatement)
                {
                    var tryStatement = expressionToProcess as TryStatementSyntax;
//                    StatementsToVirtualOperation(tryStatement);
                    continue;
                }

                StatementSyntax randomizedExpression = null;

                VirtualOperation foundVirtualOperation = null;
                foundVirtualOperation = new VirtualOperation();
                foundVirtualOperation.StaticSyntax = expressionToProcess;
                foundVirtualOperation.Key = -1;                

                var uniqueOperationSize = -1;
                foreach (var c in _virtualizationContext.Operations)
                {
                    var existing = c.StaticSyntax.WithoutTrivia();
                    var cleaned = expressionToProcess.WithoutTrivia();
                    var equivalent = existing.IsEquivalentTo(cleaned);
                    if (equivalent)
                    {
                        foundVirtualOperation.Key = c.Key;
                        foundVirtualOperation.Name = c.Name;
                        foundVirtualOperation.UniqueName = expressionToProcess.Kind() + "_" + UNIQUE_ID;
                        foundVirtualOperation.OffsetKeys = c.OffsetKeys;
                        var uniqueExpression = c.Syntax;
                        randomizedExpression = SyntaxFactoryExtensions.UpdateAnnotationsInstruction(expressionToProcess, uniqueExpression,"index", "unique", "name", "type");
                        foundVirtualOperation.Syntax = randomizedExpression;
                        uniqueOperationSize = c.Size;
                        foundVirtualOperation.InstructionSizeOffset = c.InstructionSizeOffset;
                        break;
                    }
                }

                if (foundVirtualOperation.Key == -1)
                {
                    foundVirtualOperation.Key = _virtualizationContext.SWITCH_KEY;
                    foundVirtualOperation.Name = expressionToProcess.Kind() + "_" + UNIQUE_ID;
                    foundVirtualOperation.UniqueName = foundVirtualOperation.Name;
                    foundVirtualOperation.InstructionSizeOffset = VirtualizationContext.InstructionSizeOffsetRand();
                    _virtualizationContext.Operations.Add(foundVirtualOperation);
                    randomizedExpression = SyntaxFactoryExtensions.RandomizeInstruction(expressionToProcess);
                    foundVirtualOperation.Syntax = randomizedExpression;
                }

                foundVirtualOperation.AddStatement(randomizedExpression);

                VirtualOperation.MarkAppearance(foundVirtualOperation.Key);
                var descendants = randomizedExpression.GetAnnotatedNodes("name");
                
                foreach (var use in descendants)
                {
                    var nameAnnotation = use.GetAnnotations("name").FirstOrDefault();
                    var name = nameAnnotation?.Data;
                    var indexAnnotation = use.GetAnnotations("index").FirstOrDefault();
                    var dataIndexString = indexAnnotation?.Data;
                    var codeAnnotation = use.GetAnnotations("code").FirstOrDefault();
                    var codeOffsetString = codeAnnotation?.Data;
                    foundVirtualOperation.AddData(name, dataIndexString, codeOffsetString);
                }

                AddDummyDataToOperation(foundVirtualOperation.Name, foundVirtualOperation);
                if (uniqueOperationSize == -1)
                {
                    uniqueOperationSize = foundVirtualOperation.Size;
                }
                
                int skipSize = uniqueOperationSize;
                foundVirtualOperation.Size = uniqueOperationSize;
                var vpcSkip = VpcSkip(skipSize); // 
                foundVirtualOperation.AddStatement(vpcSkip);

                _virtualizationContext.code.Add(foundVirtualOperation);
            }
        }

        ///vpc = vpc + skipSize;
        private ExpressionStatementSyntax VpcSkip(int size)
        {
            var vpcIdentifier1 = SyntaxFactory.IdentifierName(VirtualizationContext.VPC_IDENTIFIER);
            var jmpSize1 = SyntaxFactoryExtensions.NumericLiteralExpression(size);
            var modifyVpc1 = SyntaxFactory.AssignmentExpression(SyntaxKind.AddAssignmentExpression, vpcIdentifier1, jmpSize1);
            var cmodifyVpcSyntax1 = SyntaxFactory.ExpressionStatement(modifyVpc1);
            return cmodifyVpcSyntax1;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="continueStatement"></param>
        private void StatementsToVirtualOperation(ContinueStatementSyntax continueStatement)
        {
            int maxLoopTries = VirtualizationContext.INSTRUCTION_SIZE_POSTFIX + VirtualizationContext.INSTRUCTION_SIZE_PREFIX;
            int loopsLeft = maxLoopTries;
            List<int> positions = new List<int>();
            positions.Add(0); // it is always the code of the next instruction

            //compute jump size
            int jumpSize = 0;
            var operationCodes = _virtualizationContext.code;
            //search for the last loop
            for (int index = _virtualizationContext.code.Count - 1; index >= 0; index--)
            {
                var operation = _virtualizationContext.code[index];
                var opSize = operation.Size;
                jumpSize += opSize;
                if (operation.UniqueName.Contains("WhileStatementSyntax"))
                {
                    break;
                }
            }

            //store jump
            int continueDestinationIndex = _virtualizationContext.DataIndex;
            string continueDestinationName = "continueDestinationName" + continueDestinationIndex;
            SyntaxAnnotation indexMarker = new SyntaxAnnotation("index", continueDestinationIndex + "");
            SyntaxAnnotation nameMarker = new SyntaxAnnotation("name", continueDestinationName);
            SyntaxAnnotation variableMarker = new SyntaxAnnotation("type", "constant");
            SyntaxAnnotation codeMarker = new SyntaxAnnotation("code", "undefined");
            SyntaxAnnotation uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);

            var continueDestinationData = new VirtualData();
            continueDestinationData.Type = "int";
            continueDestinationData.Index = continueDestinationIndex;
            continueDestinationData.Name = continueDestinationName;
            continueDestinationData.DefaultValue = SyntaxFactoryExtensions.NumericLiteralExpression(0 - jumpSize); //
            continueDestinationData.Annotations.Add(indexMarker);
            continueDestinationData.Annotations.Add(nameMarker);
            continueDestinationData.Annotations.Add(variableMarker);
//            continueDestinationData.Annotations.Add(codeMarker);
            continueDestinationData.Annotations.Add(uniqueMarker);

            _virtualizationContext.data.Add(continueDestinationData);
            
            //vpc = vpc + data[code[vpc++]];
            var vpcIdentifier1 = SyntaxFactory.IdentifierName(VirtualizationContext.VPC_IDENTIFIER);
            var jmpFalseSize1 = SyntaxFactoryExtensions.DataCodeVirtualAccess();
            jmpFalseSize1 = jmpFalseSize1.WithAdditionalAnnotations(continueDestinationData.Annotations);
            jmpFalseSize1 = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName (@"" + "int"), jmpFalseSize1);
            var modifyVpc1 = SyntaxFactory.AssignmentExpression(SyntaxKind.AddAssignmentExpression, vpcIdentifier1, jmpFalseSize1);
            var cmodifyVpcSyntax1 = SyntaxFactory.ExpressionStatement(modifyVpc1);
            //StatementsToVirtualOperation(new List<SyntaxNode>() { cmodifyVpcSyntax1 });

            var expressionToProcess = cmodifyVpcSyntax1;
            StatementSyntax randomizedExpression = null;

            VirtualOperation foundVirtualOperation = null;
            foundVirtualOperation = new VirtualOperation();
            foundVirtualOperation.StaticSyntax = expressionToProcess;
            foundVirtualOperation.Key = -1;

            var uniqueOperationSize = -1;
            foreach (var c in _virtualizationContext.Operations)
            {
                var existing = c.StaticSyntax.WithoutTrivia();
                var cleaned = expressionToProcess.WithoutTrivia();
                var equivalent = existing.IsEquivalentTo(cleaned);
                if (equivalent)
                {
                    foundVirtualOperation.Key = c.Key;
                    foundVirtualOperation.Name = c.Name;
                    foundVirtualOperation.UniqueName = "Continue_" + expressionToProcess.Kind() + "_" + UNIQUE_ID;
                    foundVirtualOperation.OffsetKeys = c.OffsetKeys;
                    var uniqueExpression = c.Syntax;
                    randomizedExpression = SyntaxFactoryExtensions.UpdateAnnotationsInstruction(expressionToProcess, uniqueExpression, "index", "unique", "name", "type");
                    foundVirtualOperation.Syntax = randomizedExpression;
                    uniqueOperationSize = c.Size;
                    foundVirtualOperation.InstructionSizeOffset = c.InstructionSizeOffset;
                    break;
                }
            }

            if (foundVirtualOperation.Key == -1)
            {
                foundVirtualOperation.Key = _virtualizationContext.SWITCH_KEY;
                foundVirtualOperation.Name = "Continue_"+expressionToProcess.Kind() + "_" + UNIQUE_ID;
                foundVirtualOperation.UniqueName = foundVirtualOperation.Name;
                foundVirtualOperation.InstructionSizeOffset = VirtualizationContext.InstructionSizeOffsetRand();
                _virtualizationContext.Operations.Add(foundVirtualOperation);
                randomizedExpression = SyntaxFactoryExtensions.RandomizeInstruction(expressionToProcess);
                foundVirtualOperation.Syntax = randomizedExpression;
            }

            foundVirtualOperation.AddStatement(randomizedExpression);

            VirtualOperation.MarkAppearance(foundVirtualOperation.Key);
            var descendants = randomizedExpression.GetAnnotatedNodes("name");

            foreach (var use in descendants)
            {
                var nameAnnotation = use.GetAnnotations("name").FirstOrDefault();
                var name = nameAnnotation?.Data;
                var indexAnnotation = use.GetAnnotations("index").FirstOrDefault();
                var dataIndexString = indexAnnotation?.Data;
                var codeAnnotation = use.GetAnnotations("code").FirstOrDefault();
                var codeOffsetString = codeAnnotation?.Data;
                foundVirtualOperation.AddData(name, dataIndexString, codeOffsetString);
            }

            AddDummyDataToOperation(foundVirtualOperation.Name, foundVirtualOperation);
            if (uniqueOperationSize == -1)
            {
                uniqueOperationSize = foundVirtualOperation.Size;
            }

            int skipSize = uniqueOperationSize;
            foundVirtualOperation.Size = uniqueOperationSize;
            var vpcSkip = VpcSkip(skipSize); // 
//            foundVirtualOperation.AddStatement(vpcSkip);

            _virtualizationContext.code.Add(foundVirtualOperation);


        }

        /// <summary>
        /// Convert IF statement to special jump to location statement based on condition
        /// </summary>
        /// <param name="ifStatement"></param>
        public void StatementsToVirtualOperation(IfStatementSyntax ifStatement)
        {
            SyntaxAnnotation indexMarker;
            SyntaxAnnotation nameMarker;
            SyntaxAnnotation variableMarker;
            SyntaxAnnotation codeMarker;
            SyntaxAnnotation uniqueMarker;
            int maxLoopTries = VirtualizationContext.INSTRUCTION_SIZE_POSTFIX + VirtualizationContext.INSTRUCTION_SIZE_PREFIX;
            int loopsLeft = maxLoopTries;

            var ifConditionExpression = ifStatement.Condition;

            //create new virtual operation entry
            var conditionStatement = SyntaxFactory.ExpressionStatement(ifConditionExpression);
            VirtualOperation ifVirtualOperation = null;
            ifVirtualOperation = new VirtualOperation();
            ifVirtualOperation.StaticSyntax = conditionStatement;
            ifVirtualOperation.Key = -1;


            StatementSyntax randomizedExpression = null;
            var uniqueOperationSize = -1;
            //search for other IF operations that might have already been processed 
            foreach (var c in _virtualizationContext.Operations)
            {
                var existing = c.StaticSyntax.WithoutTrivia();
                var cleaned = conditionStatement.WithoutTrivia();
                var equivalent = existing.IsEquivalentTo(cleaned);
                if (equivalent)
                {
                    ifVirtualOperation.Key = c.Key;
                    ifVirtualOperation.Name = c.Name;
                    ifVirtualOperation.UniqueName = "IfStatementSyntax" + "_" + UNIQUE_ID;
                    ifVirtualOperation.OffsetKeys = c.OffsetKeys;
                    var uniqueExpression = c.Syntax;
                    
                    randomizedExpression = SyntaxFactoryExtensions.UpdateAnnotationsInstruction(conditionStatement, uniqueExpression, "index", "unique", "name", "type");
                    var updatedConditionStatement = SyntaxFactoryExtensions.UpdateAnnotationsInstruction(uniqueExpression, conditionStatement, "code");
                    ifVirtualOperation.StaticSyntax = conditionStatement;
                    ifConditionExpression = ((ExpressionStatementSyntax) randomizedExpression).Expression;
                    ifVirtualOperation.Syntax = randomizedExpression;
                    uniqueOperationSize = c.Size;
                    ifVirtualOperation.InstructionSizeOffset = c.InstructionSizeOffset;
                    break;
                }
            }

            List<int> positions = new List<int>();
            positions.Add(0); // it is always the code of the next instruction

            var jumpDestinationCodeIndex = -1;
            var trueBranchDestinationCodeIndex = -1;
            var falseBranchDestinationCodeIndex = -1;
            //if not found, generate unique switch key
            if (ifVirtualOperation.Key == -1)
            {
                ifVirtualOperation.Key = _virtualizationContext.SWITCH_KEY;
                ifVirtualOperation.Name = "IfStatementSyntax" + "_" + UNIQUE_ID;
                ifVirtualOperation.UniqueName = ifVirtualOperation.Name;
                _virtualizationContext.Operations.Add(ifVirtualOperation);
                ifVirtualOperation.InstructionSizeOffset = VirtualizationContext.InstructionSizeOffsetRand();
                //convert condition to randomized instruction position
                var modifiedExpression =
                    (ExpressionStatementSyntax) SyntaxFactoryExtensions.RandomizeInstruction(conditionStatement);
                var annotatedNodes = modifiedExpression.GetAnnotatedNodes("code").ToList();
                codeMarker = annotatedNodes[0].GetAnnotations("code").ToList()[0];

                if (codeMarker != null)
                {
                    int position = Int32.Parse(codeMarker.Data);
                    positions.Add(position);
                    ifConditionExpression = ifConditionExpression.WithoutAnnotations("code");
                    ifConditionExpression = ifConditionExpression.WithAdditionalAnnotations(codeMarker);
                }

                ifVirtualOperation.Syntax = modifiedExpression;
                ifConditionExpression = modifiedExpression.Expression;
            }
            else
            {
                jumpDestinationCodeIndex = Int32.Parse(ifVirtualOperation.OffsetKeys[1]);

                trueBranchDestinationCodeIndex = Int32.Parse(ifVirtualOperation.OffsetKeys[3]);
                falseBranchDestinationCodeIndex = Int32.Parse(ifVirtualOperation.OffsetKeys[4]);
                ifVirtualOperation.OffsetKeys.Clear();
                ifVirtualOperation.OffsetKeys.Add("0"); // 0 represents the offset of the instruction code. it is always 0
            }
            
            VirtualOperation.MarkAppearance(ifVirtualOperation.Key);
            _virtualizationContext.code.Add(ifVirtualOperation);
            int indexIfStatement = _virtualizationContext.code.Count;

            //construct the special JUMP_TO based on condition
            /*
                if Instruction 
                int jmpSize = condition ? sizeTrue : sizeFalse;
                vpc = vpc + jmpSize;
                                
             step 1: determine jump destination based on condition
                [e0] = [e1] ? [e2] : [e3]
                data[code[vpc+rand0]] = data[code[vpc+rand1]] ? data[code[vpc rand2]] : data[code[vpc+rand3]];                                
             step 2: increment vpc based on destination 
                  vpc = vpc + data[code[vpc+rand0]];                  
            */

            //contruct destination offset variable: [e0]
            if (jumpDestinationCodeIndex == -1)
            {
                jumpDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft = maxLoopTries;
                while (positions.Contains(jumpDestinationCodeIndex) && loopsLeft > 0)
                {
                    jumpDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                    loopsLeft --;
                }               
            }
            var jumpDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + jumpDestinationCodeIndex);  //[e0] variable for storing to which branch to jump
            positions.Add(jumpDestinationCodeIndex);

            //construct variable [e2] offset if branch TRUE
            if (trueBranchDestinationCodeIndex == -1)
            {
                trueBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft = maxLoopTries;
                while (positions.Contains(trueBranchDestinationCodeIndex) && loopsLeft > 0)
                {
                    trueBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                    loopsLeft--;
                }               
            }
            var trueBranchDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + trueBranchDestinationCodeIndex);
            trueBranchDestination = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"), trueBranchDestination);
            positions.Add(trueBranchDestinationCodeIndex);

            //construct variable [e3] offset if branch FALSE
            if (falseBranchDestinationCodeIndex == -1)
            {
                falseBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft = maxLoopTries;
                while (positions.Contains(falseBranchDestinationCodeIndex) && loopsLeft > 0)
                {
                    falseBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                    loopsLeft--;
                }                
            }
            var falseBranchDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + falseBranchDestinationCodeIndex);
            falseBranchDestination = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"), falseBranchDestination);
            positions.Add(falseBranchDestinationCodeIndex);

            //contruct destination VirtualData variable: [e0]
            int jumpDestinationIndex = _virtualizationContext.DataIndex;
            string jmpDestinationName = "jmpDestinationName_" + jumpDestinationIndex;
            indexMarker = new SyntaxAnnotation("index", jumpDestinationIndex + "");
            nameMarker = new SyntaxAnnotation("name", jmpDestinationName);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + jumpDestinationCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);

            var jumpDestinationData = new VirtualData();
            jumpDestinationData.Type = "int";
            jumpDestinationData.Index = jumpDestinationIndex;
            jumpDestinationData.Name = jmpDestinationName;
            jumpDestinationData.Annotations.Add(indexMarker);
            jumpDestinationData.Annotations.Add(nameMarker);
            jumpDestinationData.Annotations.Add(variableMarker);
            jumpDestinationData.Annotations.Add(codeMarker);
            jumpDestinationData.Annotations.Add(uniqueMarker);
            _virtualizationContext.data.Add(jumpDestinationData);
            jumpDestination = jumpDestination.WithAdditionalAnnotations(jumpDestinationData.Annotations);

            //contruct destination VirtualData variable: [e2] if branch TRUE
            int skipToTrueBranchIndex = _virtualizationContext.DataIndex;
            string skiptToTrueBrachName = "if_GoTo_True_" + skipToTrueBranchIndex;
            indexMarker = new SyntaxAnnotation("index", skipToTrueBranchIndex + "");
            nameMarker = new SyntaxAnnotation("name", skiptToTrueBrachName);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + trueBranchDestinationCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);
            var gotoTrueBranchData = new VirtualData();
            gotoTrueBranchData.Type = "int";
            gotoTrueBranchData.Index = skipToTrueBranchIndex;
            gotoTrueBranchData.Name = skiptToTrueBrachName;
            gotoTrueBranchData.Annotations.Add(indexMarker);
            gotoTrueBranchData.Annotations.Add(nameMarker);
            gotoTrueBranchData.Annotations.Add(variableMarker);
            gotoTrueBranchData.Annotations.Add(uniqueMarker);           
            _virtualizationContext.data.Add(gotoTrueBranchData);

            trueBranchDestination = trueBranchDestination.WithAdditionalAnnotations(gotoTrueBranchData.Annotations);

            //contruct destination VirtualData variable: [e3] if branch FALSE
            int skipToFalseBranchIndex = _virtualizationContext.DataIndex;
            string skiptToFalseBrachName = "if_GoTo_False_" + skipToFalseBranchIndex;
            indexMarker = new SyntaxAnnotation("index", skipToFalseBranchIndex + "");
            nameMarker = new SyntaxAnnotation("name", skiptToFalseBrachName);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + falseBranchDestinationCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);
            var gotoFalseBranchData = new VirtualData();
            gotoFalseBranchData.Type = "int";
            gotoFalseBranchData.Index = skipToFalseBranchIndex;
            gotoFalseBranchData.Name = skiptToFalseBrachName;
            gotoFalseBranchData.Annotations.Add(indexMarker);
            gotoFalseBranchData.Annotations.Add(nameMarker);
            gotoFalseBranchData.Annotations.Add(variableMarker);
            gotoFalseBranchData.Annotations.Add(uniqueMarker);
            _virtualizationContext.data.Add(gotoFalseBranchData);
            falseBranchDestination = falseBranchDestination.WithAdditionalAnnotations(gotoFalseBranchData.Annotations);

            var sizeCondition = SyntaxFactory.ConditionalExpression(ifConditionExpression, trueBranchDestination, falseBranchDestination);
            var computeSizeExpression = SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, jumpDestination, sizeCondition);
            var computedBranchDestionation = SyntaxFactory.ExpressionStatement(computeSizeExpression);
            ifVirtualOperation.AddStatement(computedBranchDestionation);
            ifVirtualOperation.AddData(jumpDestinationData.Name, jumpDestinationData.Index, jumpDestinationCodeIndex);

            AddDataToOperation(ifVirtualOperation, ifConditionExpression);           
            ifVirtualOperation.AddData(gotoTrueBranchData.Name, gotoTrueBranchData.Index, trueBranchDestinationCodeIndex); //true
            ifVirtualOperation.AddData(gotoFalseBranchData.Name, gotoFalseBranchData.Index, falseBranchDestinationCodeIndex); //false

            jumpDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + jumpDestinationCodeIndex);
            var computedJmpSize = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"), jumpDestination);
            var vpcIdentifier = SyntaxFactory.IdentifierName(VirtualizationContext.VPC_IDENTIFIER);
            var modifyVpc = SyntaxFactory.AssignmentExpression(SyntaxKind.AddAssignmentExpression, vpcIdentifier, computedJmpSize);
            var cmodifyVpcSyntax = SyntaxFactory.ExpressionStatement(modifyVpc);
            ifVirtualOperation.AddStatement(cmodifyVpcSyntax);

            var trueBranch = ifStatement.Statement;
            var statementsExtractorVisitor = new StatementsExtractorVisitor();
            statementsExtractorVisitor.Visit(trueBranch);
            var trueBranchStatements = statementsExtractorVisitor.StatementsToRemove;

            var falseBlockSizeCodeIndex = VirtualizationContext.RandomInstructionPosition();
            loopsLeft = maxLoopTries;
            while (positions.Contains(falseBlockSizeCodeIndex) && loopsLeft > 0)
            {
                falseBlockSizeCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft --;
            }
            positions.Add(falseBlockSizeCodeIndex);

            int falseBlockSizeIndex = _virtualizationContext.DataIndex;
            string ifFalseBlockSize = "if_FalseBlockSize_Skip_" + falseBlockSizeIndex;
            indexMarker = new SyntaxAnnotation("index", falseBlockSizeIndex + "");
            nameMarker = new SyntaxAnnotation("name", ifFalseBlockSize);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + falseBlockSizeCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);
            var falseBlockSkip = new VirtualData();
            falseBlockSkip.Type = "int";
            falseBlockSkip.Index = falseBlockSizeIndex;
            falseBlockSkip.Name = ifFalseBlockSize;
            falseBlockSkip.Annotations.Add(indexMarker);
            falseBlockSkip.Annotations.Add(nameMarker);
            falseBlockSkip.Annotations.Add(variableMarker);
            falseBlockSkip.Annotations.Add(uniqueMarker);
            _virtualizationContext.data.Add(falseBlockSkip);

            //vpc = vpc + data[code[vpc++]];
            var vpcIdentifier1 = SyntaxFactory.IdentifierName(VirtualizationContext.VPC_IDENTIFIER);
            var jmpFalseSize1 = SyntaxFactoryExtensions.DataCodeVirtualAccess();
            jmpFalseSize1 = jmpFalseSize1.WithAdditionalAnnotations(falseBlockSkip.Annotations);
            jmpFalseSize1 = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"),jmpFalseSize1);
            var modifyVpc1 = SyntaxFactory.AssignmentExpression(SyntaxKind.AddAssignmentExpression, vpcIdentifier1, jmpFalseSize1);
            var cmodifyVpcSyntax1 = SyntaxFactory.ExpressionStatement(modifyVpc1);

            trueBranchStatements.Add(cmodifyVpcSyntax1);
            StatementsToVirtualOperation(trueBranchStatements);
            int indexEndOfTrueBlock = _virtualizationContext.code.Count;

            string markerTrue = "#if_fake_true_added";
            Debug.WriteLine(markerTrue);
            AddDummyDataToOperation("fake-ifVirtualOperation", ifVirtualOperation);

            int trueBlockSize = 0;
            for (int i = indexIfStatement ; i < indexEndOfTrueBlock; i++)
            {
                var code = _virtualizationContext.code[i];
                trueBlockSize += code.Size;
            }

            //after IF header, goto False block start
            int gotoFalseOffset = ifVirtualOperation.Size + trueBlockSize ;
            gotoFalseBranchData.DefaultValue = SyntaxFactoryExtensions.NumericLiteralExpression(gotoFalseOffset); // 1 for vpc++ and 1 for [true size]
            Debug.WriteLine("#if_trueBlockSize " + trueBlockSize);

            var falseBranch = ifStatement.Else;
            statementsExtractorVisitor.Visit(falseBranch);
            var falseBranchStatements = statementsExtractorVisitor.StatementsToRemove;
            StatementsToVirtualOperation(falseBranchStatements);
            int falseBlockSize = 0;

            for (int i = indexEndOfTrueBlock ; i < _virtualizationContext.code.Count; i++)
            {
                var code = _virtualizationContext.code[i];
                falseBlockSize += code.Size;
            }

            //the jump sizes are available only after all the other statements have been processed

            //after the IF header, goto beginning of true block
            var gotoTrueOffset = ifVirtualOperation.Size;
            gotoTrueBranchData.DefaultValue = SyntaxFactoryExtensions.NumericLiteralExpression(gotoTrueOffset);

            //at the end of the true block, skip the false block
            int skipFalseBranchOffset = falseBlockSize ; // 1 for vpc++ 1 for next instruction
            falseBlockSkip.DefaultValue = SyntaxFactoryExtensions.NumericLiteralExpression(skipFalseBranchOffset);
            Debug.WriteLine("#falseBlockSize " + falseBlockSize);
        }

        public void StatementsToVirtualOperation(TryStatementSyntax tryStatement)
        {
            if (tryStatement == null)
                return;

            var interpreterInvocation = SyntaxFactoryExtensions.InvocationDeclarationSyntax(_virtualizationContext.InterpreterIdentifier());
            var returnStatement = SyntaxFactory.ReturnStatement(interpreterInvocation.Expression);
            List<StatementSyntax> statements = new List<StatementSyntax>();
            statements.Add(returnStatement);
            BlockSyntax virtualizedBlock = SyntaxFactory.Block(statements);


            var tryBlock = tryStatement.Block;
            var tryStatements = tryBlock.Statements;
            StatementsToVirtualOperation(tryStatements);

            var catchesList = tryStatement.Catches;
            foreach (var catchObj in catchesList)
            {
                var modifiedTry = SyntaxFactory.TryStatement();
                modifiedTry = modifiedTry.WithBlock(virtualizedBlock);
                var catchClause = SyntaxFactory.CatchClause(catchObj.Declaration, catchObj.Filter, virtualizedBlock);
                var catchList = new SyntaxList<CatchClauseSyntax>();
                catchList = catchList.Add(catchClause);
                modifiedTry = modifiedTry.WithCatches(catchList);
                VirtualOperation tryOperation = null;
                tryOperation = new VirtualOperation();
                tryOperation.Syntax = modifiedTry;
                tryOperation.Key = -1;
                tryOperation.Name = "Catch_"+catchObj.Declaration.ToString();
                tryOperation.AddStatement(modifiedTry);

                foreach (var c in _virtualizationContext.Operations)
                {
                    var existing = c.Syntax.WithoutTrivia();
                    var cleaned = modifiedTry.WithoutTrivia();
                    var equivalent = existing.IsEquivalentTo(cleaned);
                    if (equivalent)
                    {
                        tryOperation.Key = c.Key;
                        break;
                    }
                }

                if (tryOperation.Key == -1)
                {
                    tryOperation.Key = _virtualizationContext.SWITCH_KEY;
                    _virtualizationContext.Operations.Add(tryOperation);
                }
                VirtualOperation.MarkAppearance(tryOperation.Key);
                _virtualizationContext.code.Add(tryOperation);

                var catchBlock = catchObj.Block;
                var catchStatements = catchBlock.Statements;
                StatementsToVirtualOperation(catchStatements);
            }
            
        }

        public void StatementsToVirtualOperation(WhileStatementSyntax whileStatement)
        {
            SyntaxAnnotation indexMarker;
            SyntaxAnnotation nameMarker;
            SyntaxAnnotation variableMarker;
            SyntaxAnnotation codeMarker;
            SyntaxAnnotation uniqueMarker;
            int maxLoopTries = VirtualizationContext.INSTRUCTION_SIZE_POSTFIX + VirtualizationContext.INSTRUCTION_SIZE_PREFIX;
            int loopsLeft = maxLoopTries;
            
            //create new virtual operation entry
            var whileConditionExpression = whileStatement.Condition;
            var conditionStatement = SyntaxFactory.ExpressionStatement(whileConditionExpression);
            VirtualOperation whileVirtualOperation = null;
            whileVirtualOperation = new VirtualOperation
            {
                StaticSyntax = conditionStatement,
                Key = -1,
                Name = "WhileStatementSyntax" 
            };

            StatementSyntax randomizedExpression = null;
            var uniqueOperationSize = -1;
            //search for other IF operations that might have already been processed
            foreach (var c in _virtualizationContext.Operations)
            {
                var existing = c.StaticSyntax.WithoutTrivia();
                var cleaned = conditionStatement.WithoutTrivia();
                var equivalent = existing.IsEquivalentTo(cleaned);
                if (equivalent)
                {
                    whileVirtualOperation.Key = c.Key;
                    whileVirtualOperation.Name = c.Name;
                    whileVirtualOperation.UniqueName = "WhileStatementSyntax" + "_" + UNIQUE_ID;
                    whileVirtualOperation.OffsetKeys = c.OffsetKeys;
                    var uniqueExpression = c.Syntax;

                    randomizedExpression = SyntaxFactoryExtensions.UpdateAnnotationsInstruction(conditionStatement, uniqueExpression, "index", "unique", "name", "type");
                    var updatedConditionStatement = SyntaxFactoryExtensions.UpdateAnnotationsInstruction(uniqueExpression, conditionStatement, "code");
                    whileVirtualOperation.StaticSyntax = conditionStatement;
                    whileConditionExpression = ((ExpressionStatementSyntax)randomizedExpression).Expression;
                    whileVirtualOperation.Syntax = randomizedExpression;
                    uniqueOperationSize = c.Size;
                    whileVirtualOperation.InstructionSizeOffset = c.InstructionSizeOffset;
                    break;
                }
            }

            List<int> positions = new List<int>();
            positions.Add(0); // it is always the code of the next instruction

            var jumpDestinationCodeIndex = -1;
            var trueBranchDestinationCodeIndex = -1;
            var falseBranchDestinationCodeIndex = -1;

            //if not found, generate unique switch key
            if (whileVirtualOperation.Key == -1)
            {
                whileVirtualOperation.Key = _virtualizationContext.SWITCH_KEY;
                whileVirtualOperation.Name = "WhileStatementSyntax" + "_" + UNIQUE_ID;
                whileVirtualOperation.UniqueName = whileVirtualOperation.Name;
                _virtualizationContext.Operations.Add(whileVirtualOperation);
                whileVirtualOperation.InstructionSizeOffset = VirtualizationContext.InstructionSizeOffsetRand();
                //convert condition to randomized instruction position
                var modifiedExpression =
                    (ExpressionStatementSyntax)SyntaxFactoryExtensions.RandomizeInstruction(conditionStatement);
                var annotatedNodes = modifiedExpression.GetAnnotatedNodes("code").ToList();
                codeMarker = annotatedNodes[0].GetAnnotations("code").ToList()[0];

                if (codeMarker != null)
                {
                    int position = Int32.Parse(codeMarker.Data);
                    positions.Add(position);
                    whileConditionExpression = whileConditionExpression.WithoutAnnotations("code");
                    whileConditionExpression = whileConditionExpression.WithAdditionalAnnotations(codeMarker);
                }

                whileVirtualOperation.Syntax = modifiedExpression;
                whileConditionExpression = modifiedExpression.Expression;
            }
            else
            {
                jumpDestinationCodeIndex = Int32.Parse(whileVirtualOperation.OffsetKeys[1]);

                trueBranchDestinationCodeIndex = Int32.Parse(whileVirtualOperation.OffsetKeys[3]);
                falseBranchDestinationCodeIndex = Int32.Parse(whileVirtualOperation.OffsetKeys[4]);
                whileVirtualOperation.OffsetKeys.Clear();
                whileVirtualOperation.OffsetKeys.Add("0"); // 0 represents the offset of the instruction code. it is always 0
            }

            VirtualOperation.MarkAppearance(whileVirtualOperation.Key);
            _virtualizationContext.code.Add(whileVirtualOperation);
            int indexWhileStatement = _virtualizationContext.code.Count;

            //construct the special JUMP_TO based on condition
            /*
                if Instruction 
                int jmpSize = condition ? sizeTrue : sizeFalse;
                vpc = vpc + jmpSize;
                                
             step 1: determine jump destination based on condition
                [e0] = [e1] ? [e2] : [e3]
                data[code[vpc+rand0]] = data[code[vpc+rand1]] ? data[code[vpc rand2]] : data[code[vpc+rand3]];                                
             step 2: increment vpc based on destination 
                  vpc = vpc + data[code[vpc+rand0]];                  
            */

            //contruct destination offset variable: [e0]
            if (jumpDestinationCodeIndex == -1)
            {
                jumpDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft = maxLoopTries;
                while (positions.Contains(jumpDestinationCodeIndex) && loopsLeft > 0)
                {
                    jumpDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                    loopsLeft--;
                }
            }
            var jumpDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + jumpDestinationCodeIndex);  //[e0] variable for storing to which branch to jump
            positions.Add(jumpDestinationCodeIndex);

            //construct variable [e2] offset if branch TRUE
            if (trueBranchDestinationCodeIndex == -1)
            {
                trueBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft = maxLoopTries;
                while (positions.Contains(trueBranchDestinationCodeIndex) && loopsLeft > 0)
                {
                    trueBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                    loopsLeft--;
                }
            }
            var trueBranchDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + trueBranchDestinationCodeIndex);
            trueBranchDestination = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"), trueBranchDestination);
            positions.Add(trueBranchDestinationCodeIndex);

            //construct variable [e3] offset if branch FALSE
            if (falseBranchDestinationCodeIndex == -1)
            {
                falseBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft = maxLoopTries;
                while (positions.Contains(falseBranchDestinationCodeIndex) && loopsLeft > 0)
                {
                    falseBranchDestinationCodeIndex = VirtualizationContext.RandomInstructionPosition();
                    loopsLeft--;
                }
            }
            var falseBranchDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + falseBranchDestinationCodeIndex);
            falseBranchDestination = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"), falseBranchDestination);
            positions.Add(falseBranchDestinationCodeIndex);



            //contruct destination VirtualData variable: [e0]
            int jumpDestinationIndex = _virtualizationContext.DataIndex;
            string jmpDestinationName = "jmpWhileDestinationName_" + jumpDestinationIndex;
            indexMarker = new SyntaxAnnotation("index", jumpDestinationIndex + "");
            nameMarker = new SyntaxAnnotation("name", jmpDestinationName);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + jumpDestinationCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);

            var jumpDestinationData = new VirtualData();
            jumpDestinationData.Type = "int";
            jumpDestinationData.Index = jumpDestinationIndex;
            jumpDestinationData.Name = jmpDestinationName;
            jumpDestinationData.Annotations.Add(indexMarker);
            jumpDestinationData.Annotations.Add(nameMarker);
            jumpDestinationData.Annotations.Add(variableMarker);
            jumpDestinationData.Annotations.Add(codeMarker);
            jumpDestinationData.Annotations.Add(uniqueMarker);
            _virtualizationContext.data.Add(jumpDestinationData);
            jumpDestination = jumpDestination.WithAdditionalAnnotations(jumpDestinationData.Annotations);


            //contruct destination VirtualData variable: [e2] if branch TRUE
            int skipToTrueBranchIndex = _virtualizationContext.DataIndex;
            string skiptToTrueBrachName = "while_GoTo_True_" + skipToTrueBranchIndex;
            indexMarker = new SyntaxAnnotation("index", skipToTrueBranchIndex + "");
            nameMarker = new SyntaxAnnotation("name", skiptToTrueBrachName);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + trueBranchDestinationCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);
            var gotoTrueBranchData = new VirtualData();
            gotoTrueBranchData.Type = "int";
            gotoTrueBranchData.Index = skipToTrueBranchIndex;
            gotoTrueBranchData.Name = skiptToTrueBrachName;
            gotoTrueBranchData.Annotations.Add(indexMarker);
            gotoTrueBranchData.Annotations.Add(nameMarker);
            gotoTrueBranchData.Annotations.Add(variableMarker);
            gotoTrueBranchData.Annotations.Add(uniqueMarker);
            _virtualizationContext.data.Add(gotoTrueBranchData);
            trueBranchDestination = trueBranchDestination.WithAdditionalAnnotations(gotoTrueBranchData.Annotations);

            //contruct destination VirtualData variable: [e3] if branch FALSE
            int skipToFalseBranchIndex = _virtualizationContext.DataIndex;
            string skiptToFalseBrachName = "while_GoTo_False_" + skipToFalseBranchIndex;
            indexMarker = new SyntaxAnnotation("index", skipToFalseBranchIndex + "");
            nameMarker = new SyntaxAnnotation("name", skiptToFalseBrachName);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + falseBranchDestinationCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);
            var gotoFalseBranchData = new VirtualData();
            gotoFalseBranchData.Type = "int";
            gotoFalseBranchData.Index = skipToFalseBranchIndex;
            gotoFalseBranchData.Name = skiptToFalseBrachName;
            gotoFalseBranchData.Annotations.Add(indexMarker);
            gotoFalseBranchData.Annotations.Add(nameMarker);
            gotoFalseBranchData.Annotations.Add(variableMarker);
            gotoFalseBranchData.Annotations.Add(uniqueMarker);
            _virtualizationContext.data.Add(gotoFalseBranchData);
            falseBranchDestination = falseBranchDestination.WithAdditionalAnnotations(gotoFalseBranchData.Annotations);
            
            var sizeCondition = SyntaxFactory.ConditionalExpression(whileConditionExpression, trueBranchDestination, falseBranchDestination);
            var computeSizeExpression = SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, jumpDestination, sizeCondition);
            var computedBranchDestionation = SyntaxFactory.ExpressionStatement(computeSizeExpression);
            whileVirtualOperation.AddStatement(computedBranchDestionation);
            whileVirtualOperation.AddData(jumpDestinationData.Name, jumpDestinationData.Index, jumpDestinationCodeIndex); 

            AddDataToOperation(whileVirtualOperation, whileConditionExpression);
            whileVirtualOperation.AddData(gotoTrueBranchData.Name, gotoTrueBranchData.Index, trueBranchDestinationCodeIndex); //true 
            whileVirtualOperation.AddData(gotoFalseBranchData.Name, gotoFalseBranchData.Index, falseBranchDestinationCodeIndex); //false 


            jumpDestination = SyntaxFactoryExtensions.DataCodeVirtualAccess("" + jumpDestinationCodeIndex);
            var computedJmpSize = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"), jumpDestination);
            var vpcIdentifier = SyntaxFactory.IdentifierName(VirtualizationContext.VPC_IDENTIFIER);
            var modifyVpc = SyntaxFactory.AssignmentExpression(SyntaxKind.AddAssignmentExpression, vpcIdentifier, computedJmpSize);
            var cmodifyVpcSyntax = SyntaxFactory.ExpressionStatement(modifyVpc);
            whileVirtualOperation.AddStatement(cmodifyVpcSyntax);

            var trueBranch = whileStatement.Statement;
            var statementsExtractorVisitor = new StatementsExtractorVisitor();
            statementsExtractorVisitor.Visit(trueBranch);
            var trueBranchStatements = statementsExtractorVisitor.StatementsToRemove;            

            var falseBlockSizeCodeIndex = VirtualizationContext.RandomInstructionPosition();
            loopsLeft = maxLoopTries;
            while (positions.Contains(falseBlockSizeCodeIndex) && loopsLeft > 0)
            {
                falseBlockSizeCodeIndex = VirtualizationContext.RandomInstructionPosition();
                loopsLeft--;
            }
            positions.Add(falseBlockSizeCodeIndex);

            int falseBlockSizeIndex = _virtualizationContext.DataIndex;
            string ifFalseBlockSize = "while_FalseBlockSkip_" + falseBlockSizeIndex;
            indexMarker = new SyntaxAnnotation("index", falseBlockSizeIndex + "");
            nameMarker = new SyntaxAnnotation("name", ifFalseBlockSize);
            variableMarker = new SyntaxAnnotation("type", "constant");
            codeMarker = new SyntaxAnnotation("code", "" + falseBlockSizeCodeIndex);
            uniqueMarker = new SyntaxAnnotation("unique", "" + VirtualizationContext.UniqueId);
            var falseBlockSkip = new VirtualData();
            falseBlockSkip.Type = "int";
            falseBlockSkip.Index = falseBlockSizeIndex;
            falseBlockSkip.Name = ifFalseBlockSize;
            falseBlockSkip.Annotations.Add(indexMarker);
            falseBlockSkip.Annotations.Add(nameMarker);
            falseBlockSkip.Annotations.Add(variableMarker);
            falseBlockSkip.Annotations.Add(uniqueMarker);
            _virtualizationContext.data.Add(falseBlockSkip);


            //vpc = vpc + data[code[vpc++]];
            var vpcIdentifier1 = SyntaxFactory.IdentifierName(VirtualizationContext.VPC_IDENTIFIER);
            var jmpFalseSize1 = SyntaxFactoryExtensions.DataCodeVirtualAccess();
            jmpFalseSize1 = jmpFalseSize1.WithAdditionalAnnotations(falseBlockSkip.Annotations);
            jmpFalseSize1 = SyntaxFactory.CastExpression(SyntaxFactory.IdentifierName(@"" + "int"), jmpFalseSize1);
            var modifyVpc1 = SyntaxFactory.AssignmentExpression(SyntaxKind.AddAssignmentExpression, vpcIdentifier1, jmpFalseSize1);
            var cmodifyVpcSyntax1 = SyntaxFactory.ExpressionStatement(modifyVpc1);

            trueBranchStatements.Add(cmodifyVpcSyntax1);
            StatementsToVirtualOperation(trueBranchStatements);
            int indexEndOfTrueBlock = _virtualizationContext.code.Count;

            string markerTrue = "#while_fake_true_added";
            Debug.WriteLine(markerTrue);
            AddDummyDataToOperation("fake-whileVirtualOperation", whileVirtualOperation);

            int trueBlockSize = 0;
            for (int i = indexWhileStatement; i < indexEndOfTrueBlock; i++)
            {
                var code = _virtualizationContext.code[i];
                trueBlockSize += code.Size;
            }
            
            //the jump sizes are available only after all the other statements have been processed

            //after the IF header, goto beginning of true block
            var gotoTrueOffset = whileVirtualOperation.Size;
            gotoTrueBranchData.DefaultValue = SyntaxFactoryExtensions.NumericLiteralExpression(gotoTrueOffset);                                                                                                        //after IF header, goto False block start

            int gotoFalseOffset = whileVirtualOperation.Size + trueBlockSize;
            gotoFalseBranchData.DefaultValue = SyntaxFactoryExtensions.NumericLiteralExpression(gotoFalseOffset); // 1 for vpc++ and 1 for [true size]
            Debug.WriteLine("#while_trueBlockSize " + trueBlockSize);

           
            //at the end of the true block, go back to check condition
            int skipFalseBranchOffset = 0 - trueBlockSize - whileVirtualOperation.Size; // 1 for vpc++ 1 for next instruction
            falseBlockSkip.DefaultValue = SyntaxFactoryExtensions.NumericLiteralExpression(skipFalseBranchOffset);
            Debug.WriteLine("#while_falseBlockSize " + skipFalseBranchOffset);
        }

        private int AddDummyDataToOperation(string marker, VirtualOperation operation)
        {
            var dummyDataAdded = 0;

            for (int i = 0; i < VirtualizationContext.GetRandom(1, VirtualizationContext.MAX_JUNK_CODE); i++)
            {
                //inside virtual operation
                var dummyIndex = _virtualizationContext.DataIndexFake;
                var fakeDataOffset = VirtualizationContext.RandomInstructionPosition();
                while (operation.OffsetKeyUsed("" + fakeDataOffset))
                {
                    fakeDataOffset = VirtualizationContext.RandomInstructionPosition();
                }
                string name = "fake-" + marker +"_" +dummyIndex+"_"+fakeDataOffset;
                operation.AddFakeData(name, dummyIndex, fakeDataOffset);
                Debug.WriteLine(name);
                //inside data[] array
                var fakeData = new VirtualData();
                var fakeIndex = _virtualizationContext.DataIndex;
                fakeData.Type = "int";
                fakeData.Index = fakeIndex;
                fakeData.Name = "fake-" + fakeIndex;
                _virtualizationContext.data.Add(fakeData);
                //                Debug.WriteLine("fake-data" + fakeIndex);
                dummyDataAdded++;
            }
            return dummyDataAdded;
        }

        private int AddDummyDataToOperation(string marker, int index)
        {
            //add dummy data to last operation
            var lastOperation = _virtualizationContext.code[index];
            return AddDummyDataToOperation(marker, lastOperation);
        }

        public void AddDataToOperation(VirtualOperation operation, StatementSyntax node)
        {
            var descendants = node.GetAnnotatedNodes("name");            
            foreach (var use in descendants)
            {
                var nameAnnotation = use.GetAnnotations("name").FirstOrDefault();
                var name = nameAnnotation?.Data;
                var indexAnnotation = use.GetAnnotations("index").FirstOrDefault();
                var indexString = indexAnnotation?.Data;
                var typeAnnotation = use.GetAnnotations("type").FirstOrDefault();
                var typeString = typeAnnotation?.Data;
                var codeAnnotation = use.GetAnnotations("code").FirstOrDefault();
                var codeOffsetString = codeAnnotation?.Data;
                operation.AddData(name, indexString, codeOffsetString);
            }
        }

        public void AddDataToOperation(VirtualOperation operation, ExpressionSyntax node)
        {
            var descendants = node.GetAnnotatedNodes("name");

            foreach (var use in descendants)
            {
                var nameAnnotation = use.GetAnnotations("name").FirstOrDefault();
                var name = nameAnnotation?.Data;
                var indexAnnotation = use.GetAnnotations("index").FirstOrDefault();
                var indexString = indexAnnotation?.Data;
                var typeAnnotation = use.GetAnnotations("type").FirstOrDefault();
                var typeString = typeAnnotation?.Data;
                var codeAnnotation = use.GetAnnotations("code").FirstOrDefault();
                var codeOffsetString = codeAnnotation?.Data;
                operation.AddData(name, indexString, codeOffsetString);
            }
        }

    }

}




================================================
File: CodeVirtualization-Console/CodeVirtualization-Console/VirtualizationVisitors/StatementsExtractorVisitor.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CodeVirtualization_Console.Visitors
{
    class StatementsExtractorVisitor : CSharpSyntaxRewriter
    {
        private readonly List<SyntaxNode> statements = new List<SyntaxNode>();
        private readonly List<SyntaxNode> toRemoveStatements = new List<SyntaxNode>();
        private bool freshStatements = false;
        private bool freshToRemove = false;

        public override SyntaxNode Visit(SyntaxNode node)
        {
            freshStatements = true;
            freshToRemove = true;
            return base.Visit(node);
        }

        private List<SyntaxNode> statementsCopy = new List<SyntaxNode>();
        public List<SyntaxNode> Statements
        {
            get
            {
                if (freshStatements)
                {
                    statementsCopy = new List<SyntaxNode>(statements);
                    statements.Clear();
                    freshStatements = false;
                }
                return statementsCopy;
            }
        }

        private List<SyntaxNode> toRemoveCopy = new List<SyntaxNode>();
        public List<SyntaxNode> StatementsToRemove
        {
            get
            {
                if (freshToRemove)
                {
                    toRemoveCopy = new List<SyntaxNode>(toRemoveStatements);
                    toRemoveStatements.Clear();
                    freshToRemove = false;
                }
                return toRemoveCopy;
            }
        }

        public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
        {
            toRemoveStatements.Add(node);
            return node;
        }

        public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
        {
            toRemoveStatements.Add(node);
            return node;
        }

        public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
        {
            statements.Add(node);
            toRemoveStatements.Add(node);
            return node;
        }

        public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
        {
            statements.Add(node);
            toRemoveStatements.Add(node);
            return node;
        }

        public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
        {
            statements.Add(node);
            toRemoveStatements.Add(node);
            return node;
        }

        public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
        {
            statements.Add(node);
            toRemoveStatements.Add(node);
            return node;
        }

        public override SyntaxNode VisitTryStatement(TryStatementSyntax node)
        {
            //TODO: try/catch not supported!!!
            statements.Add(node);
            toRemoveStatements.Add(node);
            return node;
        }

        public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
        {
            //cut child traversal
            return node;
        }

        public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
        {
            //cut child traversal
            return node;
        }

        public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
        {
            //cut child traversal
            return node;
        }

    }
}




================================================
File: ConsoleCalculator/ConsoleCalculator.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.31101.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ConsoleCalculator", "ConsoleCalculator\ConsoleCalculator.csproj", "{DE1697B4-5AB7-46BB-ABEF-7E192F8D570D}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{831E055D-5DFD-4581-B771-EDC69FD23336}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DE1697B4-5AB7-46BB-ABEF-7E192F8D570D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DE1697B4-5AB7-46BB-ABEF-7E192F8D570D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DE1697B4-5AB7-46BB-ABEF-7E192F8D570D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DE1697B4-5AB7-46BB-ABEF-7E192F8D570D}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: ConsoleCalculator/ConsoleCalculator.tss
================================================
<?xml version="1.0"?>
<ArrayOfArrayOfArrayOfString xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />


================================================
File: ConsoleCalculator/ConsoleCalculator/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Composition.AttributedModel" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.0.30.0" newVersion="1.0.30.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Composition.Runtime" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.0.30.0" newVersion="1.0.30.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Composition.TypedParts" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.0.30.0" newVersion="1.0.30.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Composition.Hosting" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.0.30.0" newVersion="1.0.30.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>


================================================
File: ConsoleCalculator/ConsoleCalculator/Car.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConsoleCalculator;

namespace ConsoleCalculator
{
    class RangomGenerator
    {
        public static Random Rand = new Random();
    }
    

    interface ICarEvent
    {
        String eventHandler(string eventName);
        String ToString();
    }

    internal class Piston
    {
        private static int COUNTER = 1;

        public static string TYPE = "PISTON";

        public static int GetCounter() => COUNTER;

        private int order;
        private double size;
        private string id;

        public Piston(int order, double size, string id)
        {
            this.order = order;
            this.size = size;
            this.id = id;
        }

        public string GetId() => id;

        public double GetSize() => size;

        public int GetOrder() => order;

        public override String ToString()
        {
            string result = "";

            result = "#" + order + "_" + size + "_" + id;

            return result;
        }
    }


    internal class Engine
    {
        private static int COUNTER = 1;

        public static string TYPE = "ENGINE";

        public static int GetCounter() => COUNTER;  

        private List<Piston> pistons;
        private int size;
        private bool turbinePresent;
        private bool compressorPresent;

        private string serialNumber;

        public Engine(int pistons, int size, string serialNumber)
        {
            this.pistons = new List<Piston>();
            for (int i = 0; i < pistons; i++)
            {
                Piston p = new Piston(i + 1, ((double)size)/pistons, RangomGenerator.Rand.Next() + "");
                this.pistons.Add(p);
            }
            this.size = size;
            this.serialNumber = serialNumber;
        }

        public bool TurbineStatus { get; set; }
        public bool CompressorStatus { get; set; }

        public string SerialNumber 
        {
            get
            {
                return serialNumber;
            }
        }

        public List<Piston> GetPistons() => pistons;

        public Piston GetPiston(int order)
        {
            if (order <= 0)
                return null;
            if (order > pistons.Count)
                return null;
            return pistons[order];
        }

        public int GetEngineSize() => size;

    public override string ToString()
    {
        string result = "";
        string pistonsString = this.pistons.Aggregate("", (current, p) => current + (p.ToString() + " / "));
        result += "#" + serialNumber + "_" + size + "_pistons: " + pistonsString;
        return result;
    }
}

    internal class Car
    {

        public static Engine EngineType;

        private static int COUNTER = 1;

        public static string TYPE = "CAR";

        public static int GetCounter() => COUNTER;

        private List<ICarEvent> _events;
        private int _doors;

        public int Doors
        {
            get { return this._doors; }

            set { this._doors = value; }
        }

        private string _id;

        public string Id
        {
            get { return this._id; }
        }

        private Engine engine;

        public Car(string id, int doors)
        {            
            this._id = id;
            this._doors = doors;
            this._events = new List<ICarEvent>();
            this.engine = new Engine(RangomGenerator.Rand.Next(2,12), RangomGenerator.Rand.Next(), "" + RangomGenerator.Rand.Next());
            COUNTER++;
        }

        public Engine Engine2 { get; set; }

        public Engine Engine => engine;

        public Engine GetEngine()
        {
            return engine;
        }

        public override string ToString()
        {
            return string.Format("[{0}: doors {1}; engine {2}]", Id, Doors, engine);
        }

        public override bool Equals(object obj)
        {
            if (obj == null)
                return false;
            Car car = null;
            try
            {
                car = (Car) obj;
            }
            catch (InvalidCastException ex)
            {
                return false;
            }

            bool idOk = this.Id.Equals(car.Id);
            bool doorsOk = this.Doors.Equals(car.Doors);
            return idOk && doorsOk;
        }

        public void registerEvent(ICarEvent eventName)
        {
            _events.Add(eventName);
        }

        public void displayEvents()
        {
            Console.WriteLine(this + " events");
            foreach (ICarEvent ev in _events)
            {
                Console.WriteLine(ev);
            }
        }

    }


}


================================================
File: ConsoleCalculator/ConsoleCalculator/ConsoleCalculator.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Timestamp>$([System.DateTime]::Now.ToString("yyyy-MM-dd\THHmmss"))</Timestamp>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{DE1697B4-5AB7-46BB-ABEF-7E192F8D570D}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ConsoleCalculator</RootNamespace>
    <AssemblyName>ConsoleCalculator</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <Timestamp>$([System.DateTime]::Now.ToString("yyyy-MM-dd\THHmmss"))</Timestamp>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <Timestamp>$([System.DateTime]::Now.ToString("yyyy-MM-dd\THHmmss"))</Timestamp>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <NoWin32Manifest>true</NoWin32Manifest>
  </PropertyGroup>
  <PropertyGroup>
    <RunPostBuildEvent>Always</RunPostBuildEvent>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.CodeAnalysis, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.CSharp.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.CSharp.Workspaces.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.VisualBasic, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.VisualBasic.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.VisualBasic.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.VisualBasic.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.VisualBasic.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.VisualBasic.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.VisualBasic.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.VisualBasic.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.VisualBasic.Workspaces.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.VisualBasic.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.VisualBasic.Workspaces.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.VisualBasic.Workspaces.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.Workspaces, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="Microsoft.CodeAnalysis.Workspaces.Desktop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.CodeAnalysis.Workspaces.Common.1.0.0-rc2\lib\net45\Microsoft.CodeAnalysis.Workspaces.Desktop.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Collections.Immutable, Version=1.1.33.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Collections.Immutable.1.1.33-beta\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.AttributedModel, Version=1.0.30.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.30\lib\portable-net45+win8+wp8+wpa81\System.Composition.AttributedModel.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.Convention, Version=1.0.30.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.30\lib\portable-net45+win8+wp8+wpa81\System.Composition.Convention.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.Hosting, Version=1.0.30.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.30\lib\portable-net45+win8+wp8+wpa81\System.Composition.Hosting.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.Runtime, Version=1.0.30.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.30\lib\portable-net45+win8+wp8+wpa81\System.Composition.Runtime.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Composition.TypedParts, Version=1.0.30.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Composition.1.0.30\lib\portable-net45+win8+wp8+wpa81\System.Composition.TypedParts.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Core" />
    <Reference Include="System.Reflection.Metadata, Version=1.0.18.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.Metadata.1.0.18-beta\lib\portable-net45+win8\System.Reflection.Metadata.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Performance\BinarySearch\BinarySearchTests.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Iterative_ctrl_flow.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Recursive_ctrl_flow.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Recursive_class.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Recursive_class_default.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Recursive_method_modified.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Recursive_method_default.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Recursive_method.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Recursive.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Iterative_class_default.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Iterative_class.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Iterative_method_modified.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Iterative_method_default.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Iterative_method.cs" />
    <Compile Include="Performance\BinarySearch\BinarySearch_Iterative.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op4_in1_0.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op3_in1.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op2_in1.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op4_in5.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op4_in4.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op4_in3.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op4_in2.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_Tests.cs" />
    <Compile Include="Performance\QuickSort\QuickSortIterative_ctrl_flow.cs" />
    <Compile Include="Performance\QuickSort\QuickSortIterative_class.cs" />
    <Compile Include="Performance\QuickSort\QuickSortIterative_class_default.cs" />
    <Compile Include="Performance\QuickSort\QuickSortIterative_method_modified.cs" />
    <Compile Include="Performance\QuickSort\QuickSortIterative_method_default.cs" />
    <Compile Include="Performance\QuickSort\QuickSortIterative_method.cs" />
    <Compile Include="Performance\QuickSort\QuickSortRecursive_ctrl_flow.cs" />
    <Compile Include="Performance\QuickSort\QuickSortRecursive_method_default.cs" />
    <Compile Include="Performance\QuickSort\QuickSortRecursive_class.cs" />
    <Compile Include="Performance\QuickSort\QuickSortRecursive_class_default.cs" />
    <Compile Include="Performance\QuickSort\QuickSortRecursive_method_modified.cs" />
    <Compile Include="Performance\QuickSort\QuickSortRecursive_method.cs" />
    <Compile Include="Performance\QuickSort\QuickSortTests.cs" />
    <Compile Include="Performance\PerformanceTests.cs" />
    <Compile Include="Performance\Factorial\FactorialTests.cs" />
    <Compile Include="Performance\QuickSort\QuickSortIterative.cs" />
    <Compile Include="Performance\QuickSort\QuickSortRecursive.cs" />
    <Compile Include="Performance\ForLoop\ForLoop_op4_in1.cs" />
    <Compile Include="Tracing\BasicOperations.cs" />
    <Compile Include="Tracing\TraceLoopTests.cs" />
    <Compile Include="VirtCode\CodeBranchTests.cs" />
    <Compile Include="VirtCode\CodeBasicTests.cs" />
    <Compile Include="VirtCode\CodeLoopTests.cs" />
    <Compile Include="VirtData\BasicTests.cs" />
    <Compile Include="VirtData\BranchTests.cs" />
    <Compile Include="Car.cs" />
    <Compile Include="VirtData\ConditionalExpressionTests.cs" />
    <Compile Include="VirtData\DelegatesTests.cs" />
    <Compile Include="VirtData\ExceptionTests.cs" />
    <Compile Include="VirtData\ExtensionsTests.cs" />
    <Compile Include="VirtData\FieldTests.cs" />
    <Compile Include="VirtData\LambdaTests.cs" />
    <Compile Include="VirtData\ListInterfaces.cs" />
    <Compile Include="VirtData\LoopTests.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="VirtData\FileOperations.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <Analyzer Include="..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.Analyzers.dll" />
    <Analyzer Include="..\packages\Microsoft.CodeAnalysis.Analyzers.1.0.0-rc2\tools\analyzers\C#\Microsoft.CodeAnalysis.CSharp.Analyzers.dll" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.5">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.5 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
  </PropertyGroup>
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
 
  </Target>
  -->
</Project>


================================================
File: ConsoleCalculator/ConsoleCalculator/CustomizedRunProjectSettings.rtflow.xml
================================================
<SOAP-ENV:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
<SOAP-ENV:Body>
<a1:SerializableCustomizedRunProjectSettings id="ref-1" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<build_settings href="#ref-3"/>
</a1:SerializableCustomizedRunProjectSettings>
<SOAP-ENC:Array id="ref-3" SOAP-ENC:arrayType="a1:SerializableBuildSettings[1]" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<item href="#ref-4"/>
</SOAP-ENC:Array>
<a1:SerializableBuildSettings id="ref-4" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<configuration id="ref-5">Release</configuration>
<platform id="ref-6">Any CPU</platform>
<run_settings href="#ref-7"/>
</a1:SerializableBuildSettings>
<a1:SerializableCustomizedRunSettings id="ref-7" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<settings href="#ref-8"/>
</a1:SerializableCustomizedRunSettings>
<SOAP-ENC:Array id="ref-8" SOAP-ENC:arrayType="a1:SerializableCustomizedRunSettings+SerializableSettingValue[4]" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<item href="#ref-9"/>
<item href="#ref-10"/>
<item href="#ref-11"/>
<item href="#ref-12"/>
</SOAP-ENC:Array>
<a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue id="ref-9" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<name id="ref-13">StopMonitoringWhenCommandCompletes</name>
<value id="ref-14">True</value>
</a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue>
<a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue id="ref-10" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<name id="ref-15">Command</name>
<value id="ref-16">C:\_DEV_\thesis2015-SVN\source\ConsoleCalculator\ConsoleCalculator\bin\Release\ConsoleCalculator.exe</value>
</a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue>
<a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue id="ref-11" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<name id="ref-17">WorkingDirectory</name>
<value id="ref-18">C:\_DEV_\thesis2015-SVN\source\ConsoleCalculator\ConsoleCalculator\bin\Release</value>
</a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue>
<a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue id="ref-12" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<name id="ref-19">Arguments</name>
<value id="ref-20">1 3</value>
</a1:SerializableCustomizedRunSettings_x002B_SerializableSettingValue>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>



================================================
File: ConsoleCalculator/ConsoleCalculator/MonitoringSettings.rtflow.xml
================================================
<SOAP-ENV:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
<SOAP-ENV:Body>
<a1:SerializableMonitoringSettings id="ref-1" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<settings href="#ref-3"/>
</a1:SerializableMonitoringSettings>
<SOAP-ENC:Array id="ref-3" SOAP-ENC:arrayType="a1:SerializableMonitoringSettings+SerializableSettingValue[3]" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<item href="#ref-4"/>
<item href="#ref-5"/>
<item href="#ref-6"/>
</SOAP-ENC:Array>
<a1:SerializableMonitoringSettings_x002B_SerializableSettingValue id="ref-4" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<name id="ref-7">MonitoringFilter</name>
<value id="ref-8">Module == ConsoleCalculator.exe
|| (Class == BasicOperations &#38;&#38; Function == OperationOrder_1)</value>
</a1:SerializableMonitoringSettings_x002B_SerializableSettingValue>
<a1:SerializableMonitoringSettings_x002B_SerializableSettingValue id="ref-5" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<name id="ref-9">MonitoringMode</name>
<value id="ref-10">Full</value>
</a1:SerializableMonitoringSettings_x002B_SerializableSettingValue>
<a1:SerializableMonitoringSettings_x002B_SerializableSettingValue id="ref-6" xmlns:a1="http://schemas.microsoft.com/clr/assem/RuntimeFlow%2C%20Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">
<name id="ref-11">MonitoringStartup</name>
<value id="ref-12">True</value>
</a1:SerializableMonitoringSettings_x002B_SerializableSettingValue>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>



================================================
File: ConsoleCalculator/ConsoleCalculator/Program.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using ConsoleCalculator.Performance;
using ConsoleCalculator.Tracing;
using ConsoleCalculator.VirtCode;
using ConsoleCalculator.VirtData;

//ConfuserEx
//[assembly: Obfuscation(Exclude = false, Feature = "preset(minimum);+ctrl flow;-anti debug;+rename(mode=letters,flatten=false);")]
//[assembly: Obfuscation(Exclude = false, Feature = "rename(mode=debug)")]
namespace ConsoleCalculator
{
    //[assembly: Obfuscation(Exclude = true, Feature = "control flow protection: true")]
    ///
    /// In the case of objects I doubt the usefulness of adding them to the testData array.
    /// When used, I have to cast them. So the type of object immediately becomes visible again.
    /// One idea is to use local variables for the initialization.
    /// 
    /// !! An object is different than constants! The initialization of an object depends on the scope of its parameters.
    /// One could create an object only at a specific moment in the algorithm when some parameters have some specific value.
    /// It is impossible to extract that specific value out of that context.
    /// If the value could be extracted, this means that there is the possibility of static analysis.
    /// But the ctrl flow obfuscations prevents exactly against this possibility.
    /// Therefore it is not possible to extract local variables outside their specific context.

    //////
    //TODO: assign field
    //TODO: test struct
    //TODO: test enum
    //TODO: test final
    //TODO: test class constants
    //TODO: test linq statements
    //TODO: test threading
    //TODO: test scope, closures
    //TODO: test UI elements
    //Eazfuscator options
    //Disabling class and its members renaming
    //[System.Reflection.ObfuscationAttribute(Feature = "renaming", ApplyToMembers = true)]
    partial class Program
    {
        public static string[] args_in;

        public static int TEST_ID = 0;
        public static int TEST_FAILED = 0;
        //[assembly: Obfuscation(Exclude = true, Feature = "control flow protection: true")]
        public static void Main(string[] args)
        {
            args_in = args;

            Program p = new Program();
            LoopTests.RunLoopTests();
            BasicTests.RunBasicTests();
            ExceptionTests.RunExceptionTests();
            BranchTests.RunBranchTests();
            FieldTests.RunFieldTests();
            ExtensionsTests.RunExtenstionTests();
            LambdaTests.RunLambdaTests();
            DelegatesTests.RunDelegatesTests();
            FileOperations.RunReadFileTests();
            CodeBasicTests.RunBasicTests();
            CodeBranchTests.RunBranchTests();
            CodeLoopTests.RunLoopTests();

            PerformanceTests.RunLoopTests();

            BasicOperations.RunBasicTests();

            TraceLoopTests.RunLoopTests();

            ConditionalExpressionTests.RunBasicTests();

            TestReport();
            Console.ReadKey();
        }

        private static void TestReport()
        {
            string fail = ">>FAILED TESTS: " + TEST_FAILED;
            Console.WriteLine(fail);
            string success = ">>PASSED TESTS: " + (TEST_ID - TEST_FAILED);
            Console.WriteLine(success);
        }

        public static void Start_Check(string testName)
        {
            Console.WriteLine("\n" + Program.TEST_ID++ + " > " + testName);
        }

        public static void End_Check(string testName, bool condition)
        {
            if (!condition)
            {
                Console.Error.WriteLine(">> !!!" + testName + " fail !!!");
                Program.TEST_FAILED++;
            }

            Console.WriteLine(testName + " - " + condition);
            Console.WriteLine("---------------");
        }

    }

    
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Values1.txt
================================================
ï»¿4
8
15
16
23
42


================================================
File: ConsoleCalculator/ConsoleCalculator/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Microsoft.CodeAnalysis" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.Analyzers" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.Common" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.CSharp" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.CSharp.Workspaces" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.VisualBasic" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.VisualBasic.Workspaces" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.CodeAnalysis.Workspaces.Common" version="1.0.0-rc2" targetFramework="net45" userInstalled="true" />
  <package id="Microsoft.Composition" version="1.0.30" targetFramework="net45" userInstalled="true" />
  <package id="System.Collections.Immutable" version="1.1.33-beta" targetFramework="net45" userInstalled="true" />
  <package id="System.Reflection.Metadata" version="1.0.18-beta" targetFramework="net45" userInstalled="true" />
</packages>


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/PerformanceTests.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConsoleCalculator.Performance.QuickSort;
using ConsoleCalculator.VirtCode;

namespace ConsoleCalculator.Performance
{
    enum VirtualizationType
    {
        ORIGINAL,
        METHOD,
        METHOD_DEFAULT,
        METHOD_JUNK,
        CLASS,
        CLASS_DEFAULT,
        CLASS_JUNK
    }

    class PerformanceTests
    {

        public static void RunLoopTests()
        {

            //            FactorialTests.RunTests();

            QuickSortTests.RunTests();

            //BinarySearch.BinarySearchTests.RunTests();

            //            ForLoop.ForLoop_Tests.RunTests();
        }

       

    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearchTests.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator.Performance.BinarySearch
{
    class BinarySearchTests
    {
        static int ELEMENTS = (int) (4 * 1000000);
        private static int WARMUP = 10;
        private static int ITERATIONS = 100;
        private static int RUNS = 25;


        public static void RunTests()
        {
            int[] values = GenerateDataInt(ELEMENTS);

            List<int> data = new List<int>(values);
            List<int> keys = new List<int>();
            keys.Add(-1);
            Random rand = new Random();
            for (int i = 0; i < 1000; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                keys.Add(element);
            }
            keys.Add(values[ELEMENTS / 2]);
            keys.Add(values[ELEMENTS - 50]);
            keys.Add(values[ELEMENTS / 5]);
            keys.Add(values[ELEMENTS - 10]);
            keys.Add(values[ELEMENTS / 15]);
            keys.Add(values[ELEMENTS - 1000]);
            keys.Add(values[ELEMENTS / 25]);
            keys.Add(values[ELEMENTS - 10000]);
            keys.Add(values[ELEMENTS / 35]);
            keys.Add(values[ELEMENTS / 45]);
            keys.Add(values[ELEMENTS / 55]);
            keys.Add(values[ELEMENTS / 65]);
            keys.Add(values[ELEMENTS / 21]);
            keys.Add(values[ELEMENTS - 501]);
            keys.Add(values[ELEMENTS / 52]);
            keys.Add(values[ELEMENTS - 102]);
            keys.Add(values[ELEMENTS / 153]);
            keys.Add(values[ELEMENTS - 10001]);
            keys.Add(values[ELEMENTS / 252]);
//            keys.Add(values[ELEMENTS - 100001]);
            keys.Add(values[ELEMENTS / 325]);
            keys.Add(values[ELEMENTS / 453]);
            keys.Add(values[ELEMENTS / 525]);
            keys.Add(values[ELEMENTS / 651]);
            keys.Add(values[ELEMENTS / 2512]);
//            keys.Add(values[ELEMENTS - 1002001]);
            keys.Add(values[ELEMENTS / 3225]);
            keys.Add(values[ELEMENTS / 4353]);
            keys.Add(values[ELEMENTS / 5225]);
            keys.Add(values[ELEMENTS / 6151]);
            bool testsEnabled = true;
//           bool testsEnabled = false;

            if (testsEnabled)
            {
                Stopwatch timer = Stopwatch.StartNew();
                BinarySearch_ITERATIVE(data, keys);
                BinarySearch_RECURSIVE(data, keys);
                timer.Stop();
                TimeSpan timespan = timer.Elapsed;
                string time = String.Format("\n\n>>>>>  BinarySearch_Tests required    {0}    , sec",
                    timespan.TotalSeconds);
                Output(time);
            }
            else
            {
                IterativeCheck();
                RecursiveCheck();
            }
//


        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

        private static void BinarySearch_ITERATIVE(List<int> data, List<int> keys)
        {           
            BinarySearch_Iterative.testData = data;
            BinarySearch_Iterative.keys = keys;
            BinarySearch_Iterative.ITERATIONS = ITERATIONS;
            BinarySearch_Iterative.WARMUP = WARMUP;
            BinarySearch_Iterative.NUMBER_OF_RUNS = RUNS;
            BinarySearch_Iterative.RunTests();


            BinarySearch_Iterative_ctrl_flow.testData = data;
            BinarySearch_Iterative_ctrl_flow.keys = keys;
            BinarySearch_Iterative_ctrl_flow.ITERATIONS = ITERATIONS;
            BinarySearch_Iterative_ctrl_flow.WARMUP = WARMUP;
            BinarySearch_Iterative_ctrl_flow.NUMBER_OF_RUNS = RUNS;
            BinarySearch_Iterative_ctrl_flow.RunTests();

            //BinarySearch_Iterative_method.testData = data;
            //BinarySearch_Iterative_method.keys = keys;
            //BinarySearch_Iterative_method.ITERATIONS = ITERATIONS;
            //BinarySearch_Iterative_method.WARMUP = WARMUP;
            //BinarySearch_Iterative_method.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Iterative_method.RunTests();

            //BinarySearch_Iterative_method_default.testData = data;
            //BinarySearch_Iterative_method_default.keys = keys;
            //BinarySearch_Iterative_method_default.ITERATIONS = ITERATIONS;
            //BinarySearch_Iterative_method_default.WARMUP = WARMUP;
            //BinarySearch_Iterative_method_default.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Iterative_method_default.RunTests();

            BinarySearch_Iterative_method_modified.testData = data;
            BinarySearch_Iterative_method_modified.keys = keys;
            BinarySearch_Iterative_method_modified.ITERATIONS = ITERATIONS;
            BinarySearch_Iterative_method_modified.WARMUP = WARMUP;
            BinarySearch_Iterative_method_modified.NUMBER_OF_RUNS = RUNS;
            BinarySearch_Iterative_method_modified.RunTests();

            //BinarySearch_Iterative_class.testData = data;
            //BinarySearch_Iterative_class.keys = keys;
            //BinarySearch_Iterative_class.ITERATIONS = ITERATIONS;
            //BinarySearch_Iterative_class.WARMUP = WARMUP;
            //BinarySearch_Iterative_class.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Iterative_class.RunTests();

            //BinarySearch_Iterative_class_default.testData = data;
            //BinarySearch_Iterative_class_default.keys = keys;
            //BinarySearch_Iterative_class_default.ITERATIONS = ITERATIONS;
            //BinarySearch_Iterative_class_default.WARMUP = WARMUP;
            //BinarySearch_Iterative_class_default.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Iterative_class_default.RunTests();
        }

        private static void BinarySearch_RECURSIVE(List<int> data, List<int> keys)
        {
            BinarySearch_Recursive.testData = data;
            BinarySearch_Recursive.keys = keys;
            BinarySearch_Recursive.ITERATIONS = ITERATIONS;
            BinarySearch_Recursive.WARMUP = WARMUP;
            BinarySearch_Recursive.NUMBER_OF_RUNS = RUNS;
            BinarySearch_Recursive.RunTests();

            BinarySearch_Recursive_ctrl_flow.testData = data;
            BinarySearch_Recursive_ctrl_flow.keys = keys;
            BinarySearch_Recursive_ctrl_flow.ITERATIONS = ITERATIONS;
            BinarySearch_Recursive_ctrl_flow.WARMUP = WARMUP;
            BinarySearch_Recursive_ctrl_flow.NUMBER_OF_RUNS = RUNS;
            BinarySearch_Recursive_ctrl_flow.RunTests();

            //BinarySearch_Recursive_method.testData = data;
            //BinarySearch_Recursive_method.keys = keys;
            //BinarySearch_Recursive_method.ITERATIONS = ITERATIONS;
            //BinarySearch_Recursive_method.WARMUP = WARMUP;
            //BinarySearch_Recursive_method.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Recursive_method.RunTests();

            //BinarySearch_Recursive_method_default.testData = data;
            //BinarySearch_Recursive_method_default.keys = keys;
            //BinarySearch_Recursive_method_default.ITERATIONS = ITERATIONS;
            //BinarySearch_Recursive_method_default.WARMUP = WARMUP;
            //BinarySearch_Recursive_method_default.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Recursive_method_default.RunTests();

            BinarySearch_Recursive_method_modified.testData = data;
            BinarySearch_Recursive_method_modified.keys = keys;
            BinarySearch_Recursive_method_modified.ITERATIONS = ITERATIONS;
            BinarySearch_Recursive_method_modified.WARMUP = WARMUP;
            BinarySearch_Recursive_method_modified.NUMBER_OF_RUNS = RUNS;
            BinarySearch_Recursive_method_modified.RunTests();
                         
            //BinarySearch_Recursive_class.testData = data;
            //BinarySearch_Recursive_class.keys = keys;
            //BinarySearch_Recursive_class.ITERATIONS = ITERATIONS;
            //BinarySearch_Recursive_class.WARMUP = WARMUP;
            //BinarySearch_Recursive_class.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Recursive_class.RunTests();
                         
            //BinarySearch_Recursive_class_default.testData = data;
            //BinarySearch_Recursive_class_default.keys = keys;
            //BinarySearch_Recursive_class_default.ITERATIONS = ITERATIONS;
            //BinarySearch_Recursive_class_default.WARMUP = WARMUP;
            //BinarySearch_Recursive_class_default.NUMBER_OF_RUNS = RUNS;
            //BinarySearch_Recursive_class_default.RunTests();
        }

        private static void IterativeCheck()
        {
            BinarySearch_Iterative bs = new BinarySearch_Iterative();
            bs.BinarySearch_Check();

            BinarySearch_Iterative_ctrl_flow bs_ctrl = new BinarySearch_Iterative_ctrl_flow();
            bs_ctrl.BinarySearch_Check();

            //BinarySearch_Iterative_method bs_method = new BinarySearch_Iterative_method();
            //bs_method.BinarySearch_Check();

            //            BinarySearch_Iterative_method_default bs_method_default = new BinarySearch_Iterative_method_default();
            //            bs_method_default.BinarySearch_Check();
            //
            //
            BinarySearch_Iterative_method_modified bs_method_modified = new BinarySearch_Iterative_method_modified();
            bs_method_modified.BinarySearch_Check();

            //
            //            BinarySearch_Iterative_class bs_class = new BinarySearch_Iterative_class();
            //            bs_class.BinarySearch_Check();
            //
            //
            //            BinarySearch_Iterative_class_default bs_class_default = new BinarySearch_Iterative_class_default();
            //            bs_class_default.BinarySearch_Check();
        }


        private static void RecursiveCheck()
        {
            BinarySearch_Recursive bs = new BinarySearch_Recursive();
            bs.BinarySearch_Check();

            BinarySearch_Recursive_ctrl_flow bs_ctrl = new BinarySearch_Recursive_ctrl_flow();
            bs_ctrl.BinarySearch_Check();

            //BinarySearch_Recursive_method bs_method = new BinarySearch_Recursive_method();
            //bs_method.BinarySearch_Check();

            //            BinarySearch_Recursive_method_default bs_method_default = new BinarySearch_Recursive_method_default();
            //            bs_method_default.BinarySearch_Check();
            //
            //
            BinarySearch_Recursive_method_modified bs_method_modified = new BinarySearch_Recursive_method_modified();
            bs_method_modified.BinarySearch_Check();
            //
            ////
            //            BinarySearch_Recursive_class bs_class = new BinarySearch_Recursive_class();
            //            bs_class.BinarySearch_Check();
            ////
            ////
            //            BinarySearch_Recursive_class_default bs_class_default = new BinarySearch_Recursive_class_default();
            //            bs_class_default.BinarySearch_Check();
        }

        private static int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }


        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }
    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Iterative.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;

[assembly: Obfuscation(Exclude = true, Feature = "ctrl flow")]
namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Iterative
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Iterative bs = new BinarySearch_Iterative();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Iterative_original", BinarySearchIterative_original);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
{
    while (min <= max)
    {
        int mid = (min + max) / 2;
        if (key == inputArray[mid])
        {
            return mid;
        }
        else if (key < inputArray[mid])
        {
            max = mid - 1;
        }
        else
        {
            min = mid + 1;
        }
    }
    return -1;
}


        private static int BinarySearchIterative_1(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
public long FactorialIterative(int num)
{
    //Virtualization variables
    int[] code = new int[100754];
    object[] data = new object[4475];
    int vpc = 24;

    //Data init
    data[273]=num; //num 
    data[3111]=1 ; //1 constant
    data[1815]=(long)0L; //0L constant
    data[2356]=0; //0 constant
    data[1214]=(long)1; //1 constant
    data[2024]=2; //2 constant
    data[1843]=(long)-973L; //result 
    data[3026]=false; //var_ifCondition_0 
    data[3249]=-84; //var_forIndex_0 
    data[2894]=false; //var_whileCondition_0 
    data[1011]=-496; //jmpDestinationName_1011 constant
    data[812]=57; //if_GoTo_True_812 constant
    data[2881]=180; //if_GoTo_False_2881 constant
    data[552]=497; //if_FalseBlockSize_Skip_552 constant
    data[638]=-614; //jmpWhileDestinationName_638 constant
    data[3371]=57; //while_GoTo_True_3371 constant
    data[2097]=318; //while_GoTo_False_2097 constant
    data[1090]=-318; //while_FalseBlockSkip_1090 constant

    //Code init

    code[24]=7887; //ExpressionStatement_0 # ExpressionStatement_0
    code[46]=1843; //result
    code[18]=3111; //1
    code[44]=1815; //0L

    code[80]=9058; //ExpressionStatement_1 # ExpressionStatement_1
    code[106]=3026; //var_ifCondition_0
    code[74]=273; //num
    code[97]=2356; //0

    code[136]=6442; //IfStatementSyntax_2 # IfStatementSyntax_2
    code[121]=1011; //jmpDestinationName_1011
    code[153]=3026; //var_ifCondition_0
    code[147]=812; //if_GoTo_True_812
    code[160]=2881; //if_GoTo_False_2881

    code[193]=7902; //ReturnStatement_3 # ReturnStatement_3
    code[196]=1214; //1

    code[253]=9095; //ExpressionStatement_4 # ExpressionStatement_4
    code[266]=552; //if_FalseBlockSize_Skip_552

    code[316]=3105; //ExpressionStatement_5 # ExpressionStatement_5
    code[300]=3249; //var_forIndex_0
    code[302]=2024; //2

    code[368]=7369; //ExpressionStatement_6 # ExpressionStatement_6
    code[397]=2894; //var_whileCondition_0
    code[391]=3249; //var_forIndex_0
    code[393]=273; //num

    code[435]=6442; //IfStatementSyntax_2 # WhileStatementSyntax_7
    code[420]=638; //jmpWhileDestinationName_638
    code[452]=2894; //var_whileCondition_0
    code[446]=3371; //while_GoTo_True_3371
    code[459]=2097; //while_GoTo_False_2097

    code[492]=1086; //ExpressionStatement_8 # ExpressionStatement_8
    code[476]=1843; //result
    code[479]=1843; //result
    code[497]=3249; //var_forIndex_0

    code[559]=1402; //ExpressionStatement_9 # ExpressionStatement_9
    code[574]=3249; //var_forIndex_0
    code[564]=3249; //var_forIndex_0
    code[558]=3111; //1

    code[623]=7369; //ExpressionStatement_6 # ExpressionStatement_10
    code[652]=2894; //var_whileCondition_0
    code[646]=3249; //var_forIndex_0
    code[648]=273; //num

    code[690]=9095; //ExpressionStatement_4 # ExpressionStatement_11
    code[703]=1090; //while_FalseBlockSkip_1090

    code[753]=7902; //ReturnStatement_3 # ReturnStatement_12
    code[756]=1843; //result

    return (long)InstanceInterpreterVirtualization_BinarySearch_Iterative_3054(vpc, data, code);

}

        private Car car;

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array(int b)
{
    //Virtualization variables
    int[] code = new int[100871];
    object[] data = new object[4401];
    int vpc = 66;

    //Data init
    data[2398]=b; //b 
    data[74]="" ; //"" constant
    data[2180]=3 ; //3 constant
    data[2297]=4 ; //4 constant
    data[406]="[" ; //"[" constant
    data[2495]="]"; //"]" constant
    data[1704]=1; //1 constant
    data[3722]=0; //0 constant
    data[744]="_" ; //"_" constant
    data[1065]="~"; //"~" constant
    data[1339]="#"; //"#" constant
    data[3213]=1455568598; //sum 
    data[2875]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[3913]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[3695]=(ConsoleCalculator.Piston)null; //invocationTemp_2 
    data[3747]=(double)0.571546291267288; //p1 
    data[2296]=(ConsoleCalculator.Engine)null; //invocationTemp_3 
    data[3498]=(ConsoleCalculator.Engine)null; //invocationTemp_4 
    data[3558]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_5 
    data[2375]=-55; //memberTemp_0 
    data[2155]=(ConsoleCalculator.Piston)null; //invocationTemp_6 
    data[898]=1145075257; //invocationTemp_7 
    data[3841]=945632379; //r 
    data[3941]=(string[])null; //dst 
    data[1983]=313; //var_forIndex_1 
    data[1675]=200; //invocationTemp_8 
    data[651]=false; //var_whileCondition_1 
    data[1296]=-570; //invocationTemp_9 
    data[1509]=-909; //memberTemp_1 
    data[2780]=-841; //jmpWhileDestinationName_2780 constant
    data[2915]=57; //while_GoTo_True_2915 constant
    data[737]=563; //while_GoTo_False_737 constant
    data[2784]=-563; //while_FalseBlockSkip_2784 constant

    //Code init

    code[66]=6244; //ExpressionStatement_13 # ExpressionStatement_13
    code[87]=3213; //sum
    code[94]=74; //""
    code[62]=2180; //3
    code[54]=2297; //4
    code[65]=74; //""

    code[132]=2386; //ExpressionStatement_14 # ExpressionStatement_14
    code[123]=2875; //invocationTemp_0

    code[202]=3169; //ExpressionStatement_15 # ExpressionStatement_15
    code[218]=3913; //invocationTemp_1
    code[211]=2875; //invocationTemp_0

    code[271]=7779; //ExpressionStatement_16 # ExpressionStatement_16
    code[256]=3695; //invocationTemp_2
    code[280]=3913; //invocationTemp_1

    code[335]=1545; //ExpressionStatement_17 # ExpressionStatement_17
    code[344]=3747; //p1
    code[345]=3695; //invocationTemp_2

    code[402]=6460; //ExpressionStatement_18 # ExpressionStatement_18
    code[422]=3213; //sum
    code[405]=3213; //sum
    code[388]=406; //"["
    code[386]=3747; //p1
    code[429]=2495; //"]"

    code[473]=2386; //ExpressionStatement_14 # ExpressionStatement_19
    code[464]=2296; //invocationTemp_3

    code[543]=2386; //ExpressionStatement_14 # ExpressionStatement_20
    code[534]=3498; //invocationTemp_4

    code[613]=3169; //ExpressionStatement_15 # ExpressionStatement_21
    code[629]=3558; //invocationTemp_5
    code[622]=3498; //invocationTemp_4

    code[682]=4960; //ExpressionStatement_22 # ExpressionStatement_22
    code[711]=2375; //memberTemp_0
    code[663]=3558; //invocationTemp_5

    code[745]=6619; //ExpressionStatement_23 # ExpressionStatement_23
    code[753]=2155; //invocationTemp_6
    code[768]=2296; //invocationTemp_3
    code[756]=2375; //memberTemp_0
    code[765]=1704; //1

    code[812]=8351; //ExpressionStatement_24 # ExpressionStatement_24
    code[816]=898; //invocationTemp_7
    code[793]=2155; //invocationTemp_6

    code[882]=7644; //ExpressionStatement_25 # ExpressionStatement_25
    code[871]=3213; //sum
    code[862]=3213; //sum
    code[889]=898; //invocationTemp_7

    code[946]=3105; //ExpressionStatement_5 # ExpressionStatement_26
    code[930]=3841; //r
    code[932]=74; //""

    code[998]=5282; //ExpressionStatement_27 # ExpressionStatement_27
    code[1014]=3941; //dst
    code[993]=2398; //b

    code[1066]=3105; //ExpressionStatement_5 # ExpressionStatement_28
    code[1050]=1983; //var_forIndex_1
    code[1052]=3722; //0

    code[1118]=5554; //ExpressionStatement_29 # ExpressionStatement_29
    code[1128]=1675; //invocationTemp_8
    code[1144]=2398; //b

    code[1188]=5419; //ExpressionStatement_30 # ExpressionStatement_30
    code[1196]=651; //var_whileCondition_1
    code[1210]=1983; //var_forIndex_1
    code[1217]=1675; //invocationTemp_8

    code[1257]=6442; //IfStatementSyntax_2 # WhileStatementSyntax_31
    code[1242]=2780; //jmpWhileDestinationName_2780
    code[1274]=651; //var_whileCondition_1
    code[1268]=2915; //while_GoTo_True_2915
    code[1281]=737; //while_GoTo_False_737

    code[1314]=6265; //ExpressionStatement_32 # ExpressionStatement_32
    code[1339]=3213; //sum
    code[1297]=3213; //sum
    code[1322]=744; //"_"
    code[1319]=1983; //var_forIndex_1
    code[1300]=744; //"_"

    code[1373]=7644; //ExpressionStatement_25 # ExpressionStatement_33
    code[1362]=3213; //sum
    code[1353]=3213; //sum
    code[1380]=1065; //"~"

    code[1437]=9034; //ExpressionStatement_34 # ExpressionStatement_34
    code[1444]=3841; //r
    code[1462]=3841; //r
    code[1461]=3213; //sum
    code[1436]=1339; //"#"

    code[1499]=4502; //ExpressionStatement_35 # ExpressionStatement_35
    code[1522]=3941; //dst
    code[1487]=1983; //var_forIndex_1
    code[1523]=3213; //sum

    code[1554]=1402; //ExpressionStatement_9 # ExpressionStatement_36
    code[1569]=1983; //var_forIndex_1
    code[1559]=1983; //var_forIndex_1
    code[1553]=1704; //1

    code[1618]=5554; //ExpressionStatement_29 # ExpressionStatement_37
    code[1628]=1296; //invocationTemp_9
    code[1644]=2398; //b

    code[1688]=5419; //ExpressionStatement_30 # ExpressionStatement_38
    code[1696]=651; //var_whileCondition_1
    code[1710]=1983; //var_forIndex_1
    code[1717]=1296; //invocationTemp_9

    code[1757]=9095; //ExpressionStatement_4 # ExpressionStatement_39
    code[1770]=2784; //while_FalseBlockSkip_2784

    code[1820]=7019; //ExpressionStatement_40 # ExpressionStatement_40
    code[1840]=1509; //memberTemp_1
    code[1848]=3941; //dst

    code[1878]=8015; //ExpressionStatement_41 # ExpressionStatement_41
    code[1883]=3213; //sum
    code[1877]=3213; //sum
    code[1879]=1339; //"#"
    code[1904]=1509; //memberTemp_1

    code[1937]=8233; //ReturnStatement_42 # ReturnStatement_42
    code[1931]=3213; //sum

    return (string)InstanceInterpreterVirtualization_BinarySearch_Iterative_3054(vpc, data, code);

}

        private int ReturnArg_Array(int val)
        {
            return val;
        }

        private static int BinarySearchIterative_obfuscated(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Iterative_original";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "20_300_160_-1";
            string sortedObfuscatedHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private object InstanceInterpreterVirtualization_BinarySearch_Iterative_3054(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 9095:  //frequency 3 ExpressionStatement_4
                vpc += (int)data[code[vpc + (13)]];
                vpc += 63;
                break;
            case 7887:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (22)]] = (int)data[code[vpc + (-6)]] + (long)data[code[vpc + (20)]];
                vpc += 56;
                break;
            case 7902:  //frequency 2 ReturnStatement_3
                return (long)data[code[vpc + (3)]];
                vpc += 60;
            case 6460:  //frequency 1 ExpressionStatement_18
                data[code[vpc + (20)]] = (string)data[code[vpc + (3)]] + (string)data[code[vpc + (-14)]] + (double)data[code[vpc + (-16)]] + (string)data[code[vpc + (27)]];
                vpc += 71;
                break;
            case 7779:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (-15)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (9)]]).First());
                vpc += 64;
                break;
            case 7644:  //frequency 2 ExpressionStatement_25
                data[code[vpc + (-11)]] = (string)data[code[vpc + (-20)]] + (string)data[code[vpc + (7)]];
                vpc += 64;
                break;
            case 8351:  //frequency 1 ExpressionStatement_24
                data[code[vpc + (4)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-19)]]).ToString();
                vpc += 70;
                break;
            case 4502:  //frequency 1 ExpressionStatement_35
                ((string[])data[code[vpc + (23)]])[(int)data[code[vpc + (-12)]]] = (string)data[code[vpc + (24)]];
                vpc += 55;
                break;
            case 6244:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (21)]] = (string)data[code[vpc + (28)]] + (int)data[code[vpc + (-4)]] + (int)data[code[vpc + (-12)]] + (string)data[code[vpc + (-1)]];
                vpc += 66;
                break;
            case 6265:  //frequency 1 ExpressionStatement_32
                data[code[vpc + (25)]] = (string)data[code[vpc + (-17)]] + (string)data[code[vpc + (8)]] + (int)data[code[vpc + (5)]] + (string)data[code[vpc + (-14)]];
                vpc += 59;
                break;
            case 7019:  //frequency 1 ExpressionStatement_40
                data[code[vpc + (20)]] = ((string[])data[code[vpc + (28)]]).Length;
                vpc += 58;
                break;
            case 2386:  //frequency 3 ExpressionStatement_14
                data[code[vpc + (-9)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 70;
                break;
            case 1086:  //frequency 1 ExpressionStatement_8
                data[code[vpc + (-16)]] = (long)data[code[vpc + (-13)]] * (int)data[code[vpc + (5)]];
                vpc += 67;
                break;
            case 3105:  //frequency 3 ExpressionStatement_5
                data[code[vpc + (-16)]] = data[code[vpc + (-14)]];
                vpc += 52;
                break;
            case 6619:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (8)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (23)]]).GetPiston((int)data[code[vpc + (11)]] - (int)data[code[vpc + (20)]]));
                vpc += 67;
                break;
            case 9058:  //frequency 1 ExpressionStatement_1
                data[code[vpc + (26)]] = (int)data[code[vpc + (-6)]] == (int)data[code[vpc + (17)]];
                vpc += 56;
                break;
            case 7369:  //frequency 2 ExpressionStatement_6
                data[code[vpc + (29)]] = (int)data[code[vpc + (23)]] <= (int)data[code[vpc + (25)]];
                vpc += 67;
                break;
            case 3169:  //frequency 2 ExpressionStatement_15
                data[code[vpc + (16)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (9)]]).GetPistons());
                vpc += 69;
                break;
            default:  //frequency 0 
                break;
            case 8015:  //frequency 1 ExpressionStatement_41
                data[code[vpc + (5)]] = (string)data[code[vpc + (-1)]] + (string)data[code[vpc + (1)]] + (int)data[code[vpc + (26)]];
                vpc += 59;
                break;
            case 6442:  //frequency 3 IfStatementSyntax_2
                data[code[vpc + (-15)]] = (bool)data[code[vpc + (17)]] ? (int)data[code[vpc + (11)]] : (int)data[code[vpc + (24)]];
                vpc += (int)data[code[vpc + (-15)]];
                break;
            case 1545:  //frequency 1 ExpressionStatement_17
                data[code[vpc + (9)]] = ((ConsoleCalculator.Piston)data[code[vpc + (10)]]).GetSize();
                vpc += 67;
                break;
            case 1402:  //frequency 2 ExpressionStatement_9
                data[code[vpc + (15)]] = (int)data[code[vpc + (5)]] + (int)data[code[vpc + (-1)]];
                vpc += 64;
                break;
            case 9034:  //frequency 1 ExpressionStatement_34
                data[code[vpc + (7)]] = (string)data[code[vpc + (25)]] + (string)data[code[vpc + (24)]] + (string)data[code[vpc + (-1)]];
                vpc += 62;
                break;
            case 5554:  //frequency 2 ExpressionStatement_29
                data[code[vpc + (10)]] = ReturnArg_Array((int)data[code[vpc + (26)]]);
                vpc += 70;
                break;
            case 8233:  //frequency 1 ReturnStatement_42
                return (string)data[code[vpc + (-6)]];
                vpc += 56;
            case 5419:  //frequency 2 ExpressionStatement_30
                data[code[vpc + (8)]] = (int)data[code[vpc + (22)]] < (int)data[code[vpc + (29)]];
                vpc += 69;
                break;
            case 4960:  //frequency 1 ExpressionStatement_22
                data[code[vpc + (29)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-19)]]).Count;
                vpc += 63;
                break;
            case 5282:  //frequency 1 ExpressionStatement_27
                data[code[vpc + (16)]] = (string[])(new string[(int)data[code[vpc + (-5)]]]);
                vpc += 68;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Iterative_class.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Iterative_class
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Iterative_class bs = new BinarySearch_Iterative_class();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
//            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Iterative_class", BinarySearchIterative_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

//         [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]
private static int BinarySearchIterative_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100279];
    object[] data = new object[4278];
    int vpc = 62;

    code[12417]=705;code[22400]=-251;code[13606]=260;code[1151]=-851;code[29108]=895;code[76376]=1483;
    code[61196]=1491;code[43010]=861;code[13985]=543;code[62136]=-662;code[13988]=-340;code[96878]=-830;
    code[18362]=-323;code[22025]=1446;code[54421]=238;code[59488]=-618;code[88761]=486;code[52629]=1387;
    code[19009]=-789;code[4558]=-931;code[50090]=313;code[64892]=-591;code[99857]=42;code[59753]=571;
    code[80573]=379;code[6480]=1066;code[86950]=356;code[78105]=1148;code[71799]=-612;code[11713]=1161;
    code[28532]=-918;code[51834]=987;code[16539]=521;code[10854]=-962;code[47293]=184;code[55657]=-863;
    code[57358]=479;code[63749]=535;code[61897]=1005;code[7248]=914;code[67718]=477;code[17547]=1477;
    code[43184]=916;code[28685]=-144;code[81805]=663;code[23964]=-915;code[97038]=-548;code[74551]=166;
    code[833]=1130;code[100163]=-32;code[30980]=450;code[15741]=-177;code[99937]=-976;code[25542]=-312;
    code[90945]=-589;code[24287]=1284;code[8322]=-123;code[18972]=733;code[86038]=314;code[36538]=-4;
    code[32331]=914;code[20035]=1015;code[23560]=301;code[8750]=-23;code[85057]=-577;code[60764]=912;
    code[80567]=712;code[45823]=-763;code[43526]=1113;code[99723]=52;code[51323]=-974;code[43677]=627;
    code[42435]=-187;code[95392]=542;code[99451]=-876;code[61022]=206;code[48909]=501;code[6508]=357;
    code[38155]=-124;code[9487]=189;code[92496]=1159;code[42840]=844;code[56020]=192;code[11056]=-5;
    code[89641]=-765;code[26015]=-969;code[53285]=1358;code[88906]=-221;code[33110]=371;code[38414]=1274;
    code[57105]=176;code[40039]=995;code[56222]=-692;code[27817]=-493;code[62178]=1284;code[71650]=-792;
    code[75289]=296;code[49996]=620;code[58503]=744;code[9277]=1365;code[21562]=383;code[72488]=1243;
    code[79272]=489;code[95373]=360;code[71584]=882;code[21360]=1079;code[97033]=-538;code[90889]=129;
    code[46567]=572;code[17755]=87;code[20020]=1268;code[78014]=1450;code[38071]=-560;code[26249]=-969;
    code[44604]=-404;code[73040]=580;code[45736]=92;code[69658]=-960;code[74965]=254;code[775]=1411;
    code[17287]=832;code[49049]=1167;code[70270]=1206;code[11600]=414;code[61394]=-884;code[18426]=1386;
    code[52222]=643;code[74854]=-231;code[77742]=856;code[51935]=536;code[33512]=1345;code[9981]=188;
    code[2479]=451;code[37681]=326;code[49164]=1225;code[70632]=1406;code[62295]=-470;code[26349]=166;
    code[41929]=1277;code[28017]=242;code[6057]=739;code[40163]=-5;code[5485]=934;code[11188]=996;
    code[69241]=-33;code[24162]=-988;code[98652]=-17;code[63227]=-415;code[63527]=-966;code[84455]=-700;
    code[50828]=462;code[7579]=805;code[34322]=-448;code[33414]=-229;code[39569]=-301;code[89209]=1160;
    code[46461]=-948;code[55556]=595;code[53930]=753;code[42186]=-374;code[47038]=442;code[84253]=-742;
    code[65101]=748;code[98159]=-431;code[58344]=-929;code[83539]=10;code[6901]=-602;code[99289]=188;
    code[62203]=696;code[5605]=1084;code[44193]=1007;code[40527]=26;code[49865]=-59;code[54303]=1407;
    code[84161]=1480;code[69819]=1330;code[59468]=478;code[65283]=1324;code[74686]=1430;code[7307]=606;
    code[24287]=-737;code[72861]=-86;code[44803]=213;code[79762]=-240;code[3085]=-804;code[1803]=1148;
    code[64727]=467;code[81233]=664;code[17336]=73;code[60780]=-319;code[15842]=-961;code[38971]=474;
    code[33336]=1252;code[81361]=193;code[50968]=-850;code[73264]=620;code[60725]=32;code[59305]=-162;
    code[7677]=-905;code[96650]=-970;code[58292]=-407;code[93471]=901;code[97695]=1092;code[28746]=-986;
    code[78351]=1462;code[75905]=-212;code[36709]=1000;code[48612]=-435;code[71866]=-658;code[3355]=364;
    code[67573]=-205;code[79797]=1426;code[34897]=-76;code[25449]=-420;code[99843]=186;code[59100]=-664;
    code[46704]=485;code[69310]=1301;code[8410]=569;code[61707]=238;code[61598]=1013;code[69799]=307;
    code[30418]=38;code[28282]=1012;code[93093]=-87;code[62046]=1348;code[480]=44;code[33912]=-342;
    code[44296]=1404;code[41381]=510;code[58472]=-865;code[1031]=-234;code[39683]=555;code[85182]=930;
    code[10950]=410;code[14273]=-779;code[52307]=344;code[93416]=1171;code[62367]=-319;code[66897]=1331;
    code[8806]=121;code[30483]=576;code[85831]=624;code[13020]=-881;code[25660]=69;code[48008]=-695;
    code[21590]=-973;code[91497]=399;code[79732]=-27;code[12780]=702;code[56750]=275;code[69792]=-90;
    code[22347]=325;code[41910]=167;code[48775]=174;code[64313]=-578;code[29534]=200;code[51800]=-664;
    code[75240]=-51;code[45198]=864;code[49383]=1004;code[51755]=703;code[8577]=-950;code[87582]=276;
    code[62721]=-71;code[7354]=-419;code[14553]=1465;code[36770]=444;code[75469]=1349;code[40873]=-186;
    code[23249]=657;code[56293]=965;code[78872]=-227;code[82999]=838;code[49578]=944;code[81188]=38;
    code[94127]=-47;code[18908]=910;code[99667]=-964;code[27929]=-494;code[65847]=1268;code[84373]=-714;
    code[39748]=21;code[2408]=-229;code[11368]=1346;code[38295]=1025;code[97492]=-688;code[51551]=1073;
    code[24097]=824;code[89726]=939;code[19296]=-655;code[1628]=1118;code[56354]=645;code[29469]=909;
    code[79974]=506;code[58549]=844;code[66325]=-488;code[67110]=-189;code[82386]=116;code[39087]=-56;
    code[28636]=298;code[62361]=389;code[39714]=1498;code[44429]=1034;code[86984]=-103;code[52539]=-341;
    code[12022]=256;code[1033]=296;code[89352]=1484;code[55434]=845;code[11523]=-349;code[51232]=277;
    code[35589]=609;code[14938]=918;code[45685]=-527;code[792]=984;code[34110]=292;code[49173]=682;
    code[51769]=151;code[45274]=406;code[21558]=200;code[89867]=96;code[7871]=-201;code[61975]=-603;
    code[19510]=-624;code[43471]=1069;code[89625]=628;code[26354]=-938;code[837]=-723;code[20128]=880;
    code[85264]=689;code[35924]=694;code[35214]=825;code[92637]=507;code[1224]=-158;code[225]=76;
    code[54388]=1475;code[52480]=587;code[36522]=-819;code[43363]=-913;code[2599]=1475;code[57437]=-238;
    code[75810]=-550;code[90245]=721;code[25493]=162;code[66666]=13;code[26060]=748;code[71443]=348;
    code[12213]=-455;code[8753]=-130;code[39720]=-963;code[14704]=1143;code[14891]=-993;code[28613]=1259;
    code[12846]=569;code[66279]=1339;code[68040]=-586;code[72817]=1150;code[10321]=-867;code[92447]=-573;
    code[83257]=-413;code[34959]=367;code[67418]=492;code[17102]=1107;code[27840]=1460;code[51450]=-636;
    code[98789]=-790;code[64068]=-974;code[84583]=788;code[15677]=882;code[89732]=1490;code[56215]=565;
    code[80647]=822;code[72881]=-765;code[97594]=1130;code[43755]=-830;code[29718]=1290;code[51945]=-598;
    code[66840]=499;code[18563]=378;code[83483]=105;code[62780]=-640;code[11518]=287;code[95340]=485;
    code[52827]=788;code[1670]=-32;code[89955]=-578;code[27690]=1085;code[67637]=805;code[74484]=1358;
    code[87256]=-810;code[87215]=63;code[54926]=111;code[85193]=-828;code[56770]=194;code[34514]=-391;
    code[53169]=511;code[92297]=131;code[37122]=41;code[51283]=-277;code[78030]=-669;code[56893]=-356;
    code[83795]=-879;code[17179]=-682;code[64194]=710;code[48785]=1360;code[85922]=-396;code[68330]=890;
    code[57422]=-499;code[59795]=675;code[66729]=1204;code[2831]=-878;code[37226]=931;code[85974]=-270;
    code[24925]=1059;code[46510]=-356;code[21152]=133;code[16572]=844;code[51044]=529;code[59133]=247;
    code[27412]=805;code[42987]=1205;code[99415]=-1;code[38809]=-279;code[92593]=-590;code[88228]=-577;
    code[82254]=1103;code[62550]=1240;code[10447]=296;code[88905]=-843;code[19193]=1197;code[88126]=1041;
    code[22080]=-429;code[73530]=8;code[7666]=1359;code[24778]=1401;code[61272]=-757;code[39790]=1358;
    code[45449]=-635;code[5767]=1428;code[38684]=422;code[36994]=-790;code[94645]=-265;code[43888]=-76;
    code[83209]=-328;code[63529]=1476;code[72733]=317;code[30844]=-15;code[84570]=530;code[66377]=907;
    code[66856]=1459;code[21264]=1449;code[91973]=1297;code[55999]=807;code[44567]=701;code[44423]=1395;
    code[46221]=1288;code[67895]=556;code[51153]=986;code[87508]=1314;code[79308]=-92;code[57508]=1018;
    code[31101]=-359;code[23604]=-790;code[79191]=-994;code[10017]=1102;code[48551]=-264;code[30537]=5;
    code[35778]=-27;code[16755]=-939;code[73793]=786;code[92782]=-627;code[82832]=688;code[53112]=1024;
    code[85214]=712;code[88667]=-878;code[74158]=840;code[97464]=-243;code[41138]=11;code[67138]=651;
    code[68562]=185;code[93583]=104;code[58223]=504;code[47523]=-585;code[61251]=-313;code[26649]=-698;
    code[62920]=1119;code[19048]=-810;code[43954]=60;code[98413]=586;code[72889]=63;code[23504]=-739;
    code[11858]=-873;code[10180]=870;code[32363]=-997;code[99454]=1380;code[72172]=266;code[34193]=-346;
    code[78365]=208;code[57024]=-440;code[20209]=-92;code[791]=8429;code[864]=459;code[266]=515;code[910]=1518;code[327]=2370;code[122]=635;    data[607]=331;
code[391]=8146;code[52]=1518;code[717]=2421;code[256]=3930;    data[3226]=629;
code[452]=459;code[306]=459;code[1028]=3937;    data[131]=key;
    data[1317]=920;
code[320]=3001;code[589]=8549;code[462]=6815;code[530]=607;    data[2242]=false;
    data[3937]=-1;
code[845]=1518;code[200]=1518;code[570]=1170;code[189]=5083;    data[635]=-478;
code[406]=2095;    data[830]=max;
    data[1651]=71;
code[948]=2242;    data[263]=299;
code[682]=1651;code[65]=830;    data[1193]=-920;
    data[630]=71;
code[349]=2036;    data[515]=2;
code[134]=2242;code[62]=8983;code[976]=8429;code[920]=8983;code[144]=3867;code[185]=830;    data[2095]=198;
code[181]=3226;        data[2370]=(int[])inputArray;
    data[3867]=71;
code[594]=459;code[90]=2242;code[597]=2370;    data[2128]=67;
code[744]=459;code[671]=1537;code[407]=2036;code[672]=1170;code[727]=5598;    data[1518]=min;
code[395]=263;code[1038]=6815;code[923]=830;code[339]=131;code[660]=2547;code[238]=459;code[753]=830;code[600]=131;code[849]=2421;    data[2036]=false;
    data[1170]=false;
code[133]=1317;code[118]=8146;code[656]=8146;code[794]=2128;code[280]=3226;    data[1537]=197;
    data[459]=795;
    data[2547]=-249;
code[417]=630;    data[2421]=1;
code[527]=8429;code[979]=1193;code[853]=5083;
    return (int)ClassInterpreterVirtualization_BinarySearch_Iterative_class_2477(vpc, data, code);

}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


       
        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Iterative_class";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "20_300_160_-1";
            string sortedObfuscatedHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private static object ClassInterpreterVirtualization_BinarySearch_Iterative_class_2477(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 5083:
                data[code[vpc + (-8)]] = (int)data[code[vpc + (11)]] + (int)data[code[vpc + (-4)]];
                vpc += 67;
                break;
            case 5598:
                data[code[vpc + (26)]] = (int)data[code[vpc + (17)]] - (int)data[code[vpc + (-10)]];
                vpc += 64;
                break;
            case 8429:
                vpc += (int)data[code[vpc + (3)]];
                vpc += 62;
                break;
            case 8549:
                data[code[vpc + (-19)]] = (int)data[code[vpc + (11)]] < ((int[])data[code[vpc + (8)]])[(int)data[code[vpc + (5)]]];
                vpc += 67;
                break;
            default:
                break;
            case 6815:
                return (int)data[code[vpc + (-10)]];
                vpc += 65;
            case 3930:
                data[code[vpc + (-18)]] = (int)data[code[vpc + (24)]] / (int)data[code[vpc + (10)]];
                vpc += 64;
                break;
            case 3001:
                data[code[vpc + (29)]] = (int)data[code[vpc + (19)]] == ((int[])data[code[vpc + (7)]])[(int)data[code[vpc + (-14)]]];
                vpc += 71;
                break;
            case 8146:
                data[code[vpc + (4)]] = (bool)data[code[vpc + (16)]] ? (int)data[code[vpc + (26)]] : (int)data[code[vpc + (15)]];
                vpc += (int)data[code[vpc + (4)]];
                break;
            case 8983:
                data[code[vpc + (28)]] = (int)data[code[vpc + (-10)]] <= (int)data[code[vpc + (3)]];
                vpc += 56;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Iterative_class_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Iterative_class_default
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Iterative_class_default bs = new BinarySearch_Iterative_class_default();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Iterative_class_default", BinarySearchIterative_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

//                [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]
private static int BinarySearchIterative_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100500];
    object[] data = new object[4120];
    int vpc = 32;

    code[60907]=-189;code[80274]=1389;code[66872]=-570;code[36594]=-314;code[42678]=-154;code[77635]=992;
    code[5094]=688;code[66777]=1339;code[11494]=757;code[31734]=146;code[77973]=-36;code[74361]=-623;
    code[67627]=1373;code[11510]=-328;code[92315]=-343;code[20755]=156;code[51517]=92;code[91078]=697;
    code[15191]=473;code[32249]=1217;code[21597]=767;code[14512]=-900;code[57466]=1211;code[62365]=-159;
    code[69027]=-901;code[65392]=-983;code[39685]=547;code[46635]=-450;code[58778]=618;code[28418]=790;
    code[5791]=-762;code[35781]=-596;code[13269]=-225;code[28598]=534;code[77284]=1463;code[78870]=312;
    code[38402]=71;code[24486]=-828;code[24265]=749;code[58228]=970;code[33033]=945;code[58499]=1197;
    code[61541]=-501;code[6792]=1233;code[97779]=715;code[9450]=259;code[30814]=511;code[83352]=-701;
    code[35270]=1456;code[91272]=-346;code[60310]=-983;code[57033]=753;code[25611]=-686;code[62788]=1415;
    code[37735]=-13;code[98363]=1212;code[6850]=236;code[38938]=-301;code[51567]=192;code[55200]=1331;
    code[24365]=-23;code[64397]=-793;code[89597]=-298;code[21946]=943;code[60235]=-691;code[72150]=-354;
    code[79545]=-206;code[18906]=-196;code[21156]=1202;code[62721]=216;code[57773]=-747;code[52059]=444;
    code[71083]=-478;code[43760]=1030;code[21837]=374;code[60961]=1184;code[43567]=1439;code[1943]=-478;
    code[36789]=211;code[81380]=1434;code[91184]=1118;code[36859]=-372;code[68062]=800;code[9413]=876;
    code[30793]=-836;code[6943]=580;code[85726]=-844;code[35932]=-648;code[87742]=-843;code[37750]=706;
    code[84997]=15;code[56286]=-877;code[51994]=1110;code[82927]=1039;code[29975]=1447;code[96055]=814;
    code[7139]=626;code[58223]=818;code[73835]=-334;code[90502]=1468;code[11576]=712;code[50820]=-621;
    code[48309]=1435;code[2094]=-73;code[62133]=1195;code[33763]=-243;code[10947]=-683;code[12853]=252;
    code[28876]=-208;code[73782]=1082;code[89939]=-306;code[45454]=-182;code[11036]=-143;code[56406]=-494;
    code[48566]=575;code[40832]=516;code[16328]=-29;code[57030]=-598;code[90510]=20;code[57172]=357;
    code[82734]=135;code[19845]=49;code[64634]=631;code[62009]=1359;code[52515]=-805;code[44233]=43;
    code[53498]=-832;code[9274]=1093;code[23374]=-555;code[4208]=-657;code[41507]=1045;code[89208]=1470;
    code[47441]=823;code[14128]=801;code[56242]=1417;code[60341]=1197;code[75203]=-523;code[998]=101;
    code[8087]=-920;code[68758]=142;code[72974]=543;code[68341]=12;code[19088]=1471;code[7463]=-763;
    code[29760]=825;code[93292]=805;code[36832]=78;code[13072]=-988;code[56940]=-477;code[95259]=1284;
    code[51469]=1241;code[38622]=388;code[48027]=402;code[67255]=-147;code[5770]=628;code[76054]=-500;
    code[49666]=461;code[41349]=989;code[13894]=206;code[80222]=208;code[65838]=-887;code[42650]=1073;
    code[3891]=1195;code[51500]=-208;code[6130]=-988;code[87847]=1177;code[8492]=926;code[94966]=1074;
    code[23418]=-689;code[93167]=571;code[32116]=832;code[3789]=611;code[97830]=820;code[22917]=954;
    code[1998]=-165;code[87102]=-791;code[41311]=161;code[25993]=166;code[47447]=387;code[51939]=499;
    code[4897]=-120;code[28165]=-869;code[78136]=1213;code[11629]=809;code[64303]=454;code[56547]=-966;
    code[55844]=-577;code[16451]=1305;code[780]=949;code[86022]=-224;code[65338]=826;code[29857]=816;
    code[13897]=975;code[46241]=549;code[51432]=195;code[35928]=695;code[61070]=-182;code[58292]=1418;
    code[45501]=1463;code[87138]=-781;code[61542]=260;code[14257]=95;code[77557]=1132;code[53082]=-397;
    code[30239]=-159;code[46119]=730;code[70243]=-485;code[95430]=-206;code[5542]=384;code[91871]=1468;
    code[42759]=239;code[21307]=-597;code[22544]=1211;code[40812]=-430;code[59239]=-510;code[47169]=-944;
    code[91734]=920;code[70175]=-636;code[59181]=1147;code[95964]=-287;code[26337]=-454;code[32060]=-562;
    code[1946]=663;code[98405]=3;code[37964]=-345;code[91673]=1247;code[7147]=1199;code[66568]=-709;
    code[29369]=1450;code[21480]=1217;code[44905]=-251;code[65537]=-739;code[87151]=91;code[78336]=1327;
    code[51044]=1009;code[73275]=-510;code[60175]=571;code[72878]=-483;code[17767]=-909;code[14289]=397;
    code[90990]=-989;code[85482]=-182;code[28559]=425;code[95612]=-918;code[10624]=454;code[85792]=521;
    code[64851]=-831;code[84271]=1405;code[56924]=-464;code[30957]=457;code[89017]=-880;code[89804]=435;
    code[53558]=790;code[30183]=105;code[15543]=138;code[94446]=-362;code[84230]=636;code[98668]=105;
    code[45150]=-189;code[82444]=-258;code[48745]=866;code[82925]=1315;code[95475]=-699;code[55357]=327;
    code[79420]=907;code[64371]=1405;code[73238]=398;code[67669]=1142;code[11157]=-309;code[79845]=420;
    code[27124]=272;code[88268]=625;code[64513]=495;code[77428]=1476;code[8635]=-10;code[51552]=-396;
    code[39609]=-973;code[9840]=-652;code[22429]=1418;code[62718]=30;code[16606]=923;code[65532]=-21;
    code[81899]=1443;code[52932]=-303;code[98619]=-689;code[33285]=-569;code[53286]=-370;code[2718]=1439;
    code[87253]=-563;code[28567]=-121;code[35186]=400;code[44735]=-16;code[25122]=-3;code[57101]=794;
    code[46361]=335;code[63705]=-641;code[65567]=-45;code[40488]=251;code[86124]=216;code[83951]=661;
    code[7187]=228;code[939]=1403;code[6543]=-150;code[71503]=-646;code[98895]=-696;code[27240]=-880;
    code[68654]=-320;code[6256]=512;code[32575]=-355;code[14246]=40;code[41133]=1022;code[82165]=118;
    code[49326]=-532;code[52294]=-630;code[85360]=316;code[11961]=-46;code[34121]=549;code[28167]=1146;
    code[55357]=209;code[33047]=1274;code[69076]=65;code[73727]=-152;code[26434]=463;code[46279]=-50;
    code[32145]=994;code[17736]=497;code[34654]=48;code[25644]=-344;code[67733]=405;code[47274]=1193;
    code[82393]=408;code[29397]=144;code[291]=1223;code[71233]=-842;code[99694]=-491;code[5450]=1100;
    code[93393]=-421;code[73241]=1457;code[7579]=195;code[18509]=1263;code[73071]=-650;code[83237]=-872;
    code[35169]=300;code[3698]=1300;code[36643]=-956;code[18550]=1471;code[1359]=128;code[9038]=-691;
    code[13443]=-310;code[33816]=-66;code[88115]=-8;code[39008]=-710;code[74728]=-160;code[67288]=-718;
    code[69390]=-320;code[18799]=-511;code[37985]=412;code[15120]=699;code[73880]=-398;code[10820]=206;
    code[85687]=971;code[70220]=1435;code[1920]=-837;code[83081]=195;code[14274]=512;code[85347]=998;
    code[14240]=1026;code[2859]=-176;code[75581]=780;code[30951]=-966;code[85487]=1309;code[23097]=-769;
    code[83488]=1472;code[61376]=120;code[30234]=25;code[39075]=1232;code[16917]=1134;code[52358]=-780;
    code[70191]=34;code[9754]=695;code[51211]=-522;code[97565]=-786;code[42504]=-31;code[5435]=418;
    code[53939]=1051;code[93219]=-943;code[93764]=-766;code[63524]=1321;code[56148]=515;code[14417]=-925;
    code[45711]=-55;code[17804]=829;code[21708]=1391;code[63422]=-281;code[29102]=1350;code[63464]=-155;
    code[61809]=574;code[50662]=647;code[95789]=-640;code[67285]=107;code[93937]=-892;code[91619]=200;
    code[48514]=-86;code[96460]=-815;code[22277]=480;code[53221]=-770;code[27183]=-834;code[22429]=-672;
    code[1445]=-403;code[87396]=166;code[76033]=915;code[27920]=491;code[18997]=473;code[41006]=-243;
    code[59282]=1432;code[98039]=36;code[94142]=750;code[9606]=28;code[46902]=742;code[25024]=1125;
    code[100159]=391;code[6660]=743;code[41266]=348;code[6797]=370;code[40880]=-68;code[64793]=785;
    code[27594]=-493;code[68996]=-579;code[76931]=-213;code[29274]=1233;code[96251]=641;code[48688]=-379;
    code[61985]=-713;code[15618]=425;code[97600]=1029;code[66785]=-207;code[99501]=-952;code[47222]=-501;
    code[70336]=451;code[18683]=624;code[52441]=1149;code[90073]=-458;code[32991]=-347;code[14062]=834;
    code[1389]=1317;code[64925]=-622;code[40757]=-111;code[89695]=-151;code[7262]=1044;code[8089]=-262;
    code[38583]=243;code[57999]=487;code[71186]=-183;code[72760]=-363;code[73680]=216;code[47103]=-538;
    code[12985]=603;code[37332]=-756;code[76430]=-332;code[92498]=-112;code[98001]=54;code[55907]=-890;
    code[16645]=282;code[91653]=585;code[12750]=-675;code[12819]=1205;code[50255]=1225;code[26710]=-940;
    code[28404]=-248;code[51121]=-998;code[54016]=1211;code[59]=317;code[46061]=152;code[2248]=909;
    code[98915]=986;code[58222]=1012;code[90168]=812;code[32199]=1405;code[94591]=332;code[43163]=-512;
    code[41726]=-776;code[12895]=507;code[36093]=466;code[68830]=-403;code[37767]=-133;code[81942]=148;
    code[76256]=1298;code[82191]=-774;code[42318]=-928;code[58873]=761;code[49303]=-630;code[65335]=-170;
    code[55344]=-194;code[98997]=937;code[57281]=-242;code[8348]=874;code[87600]=-217;code[58883]=119;
    code[76018]=-7;code[16880]=1179;code[78006]=958;code[39009]=592;    data[3819]=810;
code[180]=1634;    data[2329]=-823;
    data[1695]=-859;
    data[1980]=-132;
code[340]=1204;code[168]=2966;    data[1107]=470;
code[41]=2881;code[392]=2401;code[326]=965;    data[3596]=1;
    data[3575]=-744;
    data[3263]=-1;
code[399]=3221;code[149]=985;code[502]=441;code[557]=441;code[83]=3936;code[728]=2309;code[923]=47;    data[2495]=374;
code[165]=1938;code[923]=1514;code[753]=6947;    data[3048]=423;
    data[2376]=-519;
code[895]=77;code[623]=2878;code[135]=1925;    data[279]=-540;
code[517]=1145;    data[1758]=903;
    data[3988]=877;
code[710]=1567;    data[3182]=917;
    data[2781]=key;
code[935]=692;    data[3864]=-492;
code[51]=2878;    data[108]=-432;
code[857]=342;    data[2987]=-563;
code[208]=6499;code[355]=565;code[717]=3143;code[602]=2732;    data[2966]=min;
code[282]=2059;code[92]=1251;    data[2640]=-552;
code[488]=2188;code[692]=3826;code[106]=505;code[271]=3432;code[656]=178;code[682]=2704;    data[1847]=485;
    data[1964]=-696;
code[619]=3550;    data[391]=246;
    data[1810]=650;
code[575]=4196;code[301]=287;code[561]=1840;    data[154]=-569;
code[188]=3564;    data[447]=3;
    data[1295]=-455;
code[60]=3280;code[953]=14;    data[1697]=853;
code[346]=1026;    data[569]=-380;
code[190]=985;code[947]=3263;code[533]=134;    data[2058]=-320;
code[769]=2572;code[461]=3327;code[634]=2572;code[449]=2162;code[212]=301;    data[1567]=56;
code[711]=2443;code[510]=220;    data[2732]=57;
code[463]=9126;code[258]=2781;    data[265]=-396;
code[35]=2966;    data[2901]=-14;
code[15]=1490;code[422]=2572;code[40]=2656;    data[1087]=176;
    data[2572]=921;
code[32]=6236;code[738]=1043;code[763]=3845;code[772]=3009;    data[855]=293;
code[94]=3781;code[595]=1442;    data[3562]=96;
    data[965]=false;
    data[926]=57;
code[828]=2878;code[572]=3182;    data[993]=872;
    data[211]=292;
code[387]=974;code[506]=2670;    data[1466]=538;
code[418]=2107;code[290]=2652;code[272]=965;    data[2684]=-459;
code[279]=1967;code[444]=2685;    data[87]=-129;
    data[2345]=-980;
code[934]=236;code[894]=976;code[119]=2671;        data[134]=(int[])inputArray;
code[649]=3486;code[410]=1899;    data[1658]=616;
    data[649]=-81;
code[91]=103;code[429]=1877;code[230]=163;code[515]=2781;    data[613]=315;
code[416]=3654;code[426]=2660;    data[2609]=276;
    data[985]=-777;
code[699]=9126;code[628]=3126;    data[2656]=false;
code[478]=1988;    data[2185]=850;
code[173]=2878;code[586]=1220;    data[3230]=404;
code[393]=3291;    data[1746]=814;
code[579]=817;code[50]=1893;    data[2179]=-103;
code[564]=2150;code[872]=9126;code[883]=3395;code[370]=1793;    data[3643]=178;
    data[3395]=-831;
code[855]=1159;code[583]=3620;code[826]=2558;code[543]=2437;code[293]=134;    data[2129]=-792;
    data[462]=424;
    data[1418]=-834;
code[650]=3596;code[350]=2907;code[817]=2656;code[941]=2838;    data[318]=746;
code[926]=9631;    data[2706]=-700;
code[365]=2935;code[456]=3833;    data[3237]=180;
code[263]=3588;code[718]=2856;    data[3901]=822;
    data[940]=-933;
    data[749]=-732;
    data[817]=-276;
code[503]=2572;code[171]=892;    data[759]=-559;
    data[3572]=553;
    data[1251]=128;
    data[3516]=132;
    data[1204]=173;
    data[2627]=49;
code[410]=3447;    data[2864]=29;
    data[1437]=-464;
    data[2885]=-580;
    data[2909]=-144;
    data[2217]=-219;
    data[2582]=591;
code[750]=2966;    data[446]=57;
code[145]=2784;code[401]=9631;code[274]=2572;code[275]=8224;code[76]=1499;    data[2664]=521;
    data[3316]=931;
code[23]=2280;    data[15]=442;
    data[1868]=917;
    data[441]=false;
code[95]=4196;code[99]=474;code[166]=1119;code[152]=6947;    data[3925]=526;
    data[2863]=-566;
code[155]=3664;code[77]=2656;    data[2878]=max;
    data[1686]=155;
    data[3735]=-33;
code[284]=1921;code[352]=2279;code[809]=6236;code[52]=2081;code[866]=1773;    data[2289]=-916;
    data[2135]=-932;
    data[1809]=-397;
code[344]=4196;code[571]=3643;    data[520]=-801;
code[60]=196;    data[1676]=2;
    data[310]=637;
    data[2487]=852;
code[285]=3519;code[194]=2572;    data[3783]=-519;
    data[1078]=692;
code[859]=2253;code[489]=1718;    data[3029]=506;
code[371]=926;code[824]=1034;code[774]=3596;code[421]=1436;code[631]=500;    data[1241]=364;
    data[2410]=-731;
    data[103]=831;
code[812]=2966;    data[2726]=888;
code[122]=446;    data[2637]=-374;
code[460]=334;    data[2406]=-372;
    data[1360]=-360;
    data[3964]=-907;
    data[1815]=-403;
code[227]=1676;    data[3630]=-121;
    data[3929]=787;
    data[1088]=794;
    data[1594]=315;
code[477]=348;code[632]=6274;code[269]=3484;code[626]=987;    data[987]=434;
code[341]=2627;    data[1331]=-987;
code[474]=211;    data[2696]=691;
    data[2555]=-779;

    return (int)ClassInterpreterVirtualization_BinarySearch_Iterative_class_default_3011(vpc, data, code);

}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


      

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Iterative_class_default";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "20_300_160_-1";
            string sortedObfuscatedHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private static object ClassInterpreterVirtualization_BinarySearch_Iterative_class_default_3011(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 9126:
                vpc += (int)data[code[vpc + (11)]];
                vpc += 54;
                break;
            case 6236:
                data[code[vpc + (8)]] = (int)data[code[vpc + (3)]] <= (int)data[code[vpc + (19)]];
                vpc += 63;
                break;
            case 6274:
                data[code[vpc + (-9)]] = (int)data[code[vpc + (2)]] - (int)data[code[vpc + (18)]];
                vpc += 67;
                break;
            case 1145:
                data[code[vpc + (-15)]] = (int)data[code[vpc + (-2)]] < ((int[])data[code[vpc + (16)]])[(int)data[code[vpc + (-14)]]];
                vpc += 58;
                break;
            case 6947:
                data[code[vpc + (-3)]] = (int)data[code[vpc + (16)]] + (int)data[code[vpc + (21)]];
                vpc += 56;
                break;
            case 8224:
                data[code[vpc + (-3)]] = (int)data[code[vpc + (-17)]] == ((int[])data[code[vpc + (18)]])[(int)data[code[vpc + (-1)]]];
                vpc += 69;
                break;
            case 6499:
                data[code[vpc + (-14)]] = (int)data[code[vpc + (-18)]] / (int)data[code[vpc + (19)]];
                vpc += 67;
                break;
            case 9631:
                return (int)data[code[vpc + (21)]];
                vpc += 62;
            default:
                data[code[vpc + (-3)]] = (bool)data[code[vpc + (-18)]] ? (int)data[code[vpc + (27)]] : (int)data[code[vpc + (-4)]];
                vpc += (int)data[code[vpc + (-3)]];
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Iterative_ctrl_flow.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;

[assembly: Obfuscation(Exclude = true, Feature = "ctrl flow")]
namespace ConsoleCalculator.Performance.BinarySearch
{

    [Obfuscation(Exclude = true, Feature = "ctrl flow")]
    class BinarySearch_Iterative_ctrl_flow
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Iterative_ctrl_flow bs = new BinarySearch_Iterative_ctrl_flow();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_ctrl_flow";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Iterative_ctrl_flow", BinarySearchIterative_original);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        [Obfuscation(Exclude = false, Feature = "ctrl flow")]
        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
{
    while (min <= max)
    {
        int mid = (min + max) / 2;
        if (key == inputArray[mid])
        {
            return mid;
        }
        else if (key < inputArray[mid])
        {
            max = mid - 1;
        }
        else
        {
            min = mid + 1;
        }
    }
    return -1;
}

        //[Obfuscation(Exclude = false, Feature = "ctrl flow")]
        private static int BinarySearchIterative_1(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
public long FactorialIterative(int num)
{
    //Virtualization variables
    int[] code = new int[100754];
    object[] data = new object[4475];
    int vpc = 24;

    //Data init
    data[273]=num; //num 
    data[3111]=1 ; //1 constant
    data[1815]=(long)0L; //0L constant
    data[2356]=0; //0 constant
    data[1214]=(long)1; //1 constant
    data[2024]=2; //2 constant
    data[1843]=(long)-973L; //result 
    data[3026]=false; //var_ifCondition_0 
    data[3249]=-84; //var_forIndex_0 
    data[2894]=false; //var_whileCondition_0 
    data[1011]=-496; //jmpDestinationName_1011 constant
    data[812]=57; //if_GoTo_True_812 constant
    data[2881]=180; //if_GoTo_False_2881 constant
    data[552]=497; //if_FalseBlockSize_Skip_552 constant
    data[638]=-614; //jmpWhileDestinationName_638 constant
    data[3371]=57; //while_GoTo_True_3371 constant
    data[2097]=318; //while_GoTo_False_2097 constant
    data[1090]=-318; //while_FalseBlockSkip_1090 constant

    //Code init

    code[24]=7887; //ExpressionStatement_0 # ExpressionStatement_0
    code[46]=1843; //result
    code[18]=3111; //1
    code[44]=1815; //0L

    code[80]=9058; //ExpressionStatement_1 # ExpressionStatement_1
    code[106]=3026; //var_ifCondition_0
    code[74]=273; //num
    code[97]=2356; //0

    code[136]=6442; //IfStatementSyntax_2 # IfStatementSyntax_2
    code[121]=1011; //jmpDestinationName_1011
    code[153]=3026; //var_ifCondition_0
    code[147]=812; //if_GoTo_True_812
    code[160]=2881; //if_GoTo_False_2881

    code[193]=7902; //ReturnStatement_3 # ReturnStatement_3
    code[196]=1214; //1

    code[253]=9095; //ExpressionStatement_4 # ExpressionStatement_4
    code[266]=552; //if_FalseBlockSize_Skip_552

    code[316]=3105; //ExpressionStatement_5 # ExpressionStatement_5
    code[300]=3249; //var_forIndex_0
    code[302]=2024; //2

    code[368]=7369; //ExpressionStatement_6 # ExpressionStatement_6
    code[397]=2894; //var_whileCondition_0
    code[391]=3249; //var_forIndex_0
    code[393]=273; //num

    code[435]=6442; //IfStatementSyntax_2 # WhileStatementSyntax_7
    code[420]=638; //jmpWhileDestinationName_638
    code[452]=2894; //var_whileCondition_0
    code[446]=3371; //while_GoTo_True_3371
    code[459]=2097; //while_GoTo_False_2097

    code[492]=1086; //ExpressionStatement_8 # ExpressionStatement_8
    code[476]=1843; //result
    code[479]=1843; //result
    code[497]=3249; //var_forIndex_0

    code[559]=1402; //ExpressionStatement_9 # ExpressionStatement_9
    code[574]=3249; //var_forIndex_0
    code[564]=3249; //var_forIndex_0
    code[558]=3111; //1

    code[623]=7369; //ExpressionStatement_6 # ExpressionStatement_10
    code[652]=2894; //var_whileCondition_0
    code[646]=3249; //var_forIndex_0
    code[648]=273; //num

    code[690]=9095; //ExpressionStatement_4 # ExpressionStatement_11
    code[703]=1090; //while_FalseBlockSkip_1090

    code[753]=7902; //ReturnStatement_3 # ReturnStatement_12
    code[756]=1843; //result

    return (long)InstanceInterpreterVirtualization_BinarySearch_Iterative_3054(vpc, data, code);

}

        private Car car;

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array(int b)
{
    //Virtualization variables
    int[] code = new int[100871];
    object[] data = new object[4401];
    int vpc = 66;

    //Data init
    data[2398]=b; //b 
    data[74]="" ; //"" constant
    data[2180]=3 ; //3 constant
    data[2297]=4 ; //4 constant
    data[406]="[" ; //"[" constant
    data[2495]="]"; //"]" constant
    data[1704]=1; //1 constant
    data[3722]=0; //0 constant
    data[744]="_" ; //"_" constant
    data[1065]="~"; //"~" constant
    data[1339]="#"; //"#" constant
    data[3213]=1455568598; //sum 
    data[2875]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[3913]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[3695]=(ConsoleCalculator.Piston)null; //invocationTemp_2 
    data[3747]=(double)0.571546291267288; //p1 
    data[2296]=(ConsoleCalculator.Engine)null; //invocationTemp_3 
    data[3498]=(ConsoleCalculator.Engine)null; //invocationTemp_4 
    data[3558]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_5 
    data[2375]=-55; //memberTemp_0 
    data[2155]=(ConsoleCalculator.Piston)null; //invocationTemp_6 
    data[898]=1145075257; //invocationTemp_7 
    data[3841]=945632379; //r 
    data[3941]=(string[])null; //dst 
    data[1983]=313; //var_forIndex_1 
    data[1675]=200; //invocationTemp_8 
    data[651]=false; //var_whileCondition_1 
    data[1296]=-570; //invocationTemp_9 
    data[1509]=-909; //memberTemp_1 
    data[2780]=-841; //jmpWhileDestinationName_2780 constant
    data[2915]=57; //while_GoTo_True_2915 constant
    data[737]=563; //while_GoTo_False_737 constant
    data[2784]=-563; //while_FalseBlockSkip_2784 constant

    //Code init

    code[66]=6244; //ExpressionStatement_13 # ExpressionStatement_13
    code[87]=3213; //sum
    code[94]=74; //""
    code[62]=2180; //3
    code[54]=2297; //4
    code[65]=74; //""

    code[132]=2386; //ExpressionStatement_14 # ExpressionStatement_14
    code[123]=2875; //invocationTemp_0

    code[202]=3169; //ExpressionStatement_15 # ExpressionStatement_15
    code[218]=3913; //invocationTemp_1
    code[211]=2875; //invocationTemp_0

    code[271]=7779; //ExpressionStatement_16 # ExpressionStatement_16
    code[256]=3695; //invocationTemp_2
    code[280]=3913; //invocationTemp_1

    code[335]=1545; //ExpressionStatement_17 # ExpressionStatement_17
    code[344]=3747; //p1
    code[345]=3695; //invocationTemp_2

    code[402]=6460; //ExpressionStatement_18 # ExpressionStatement_18
    code[422]=3213; //sum
    code[405]=3213; //sum
    code[388]=406; //"["
    code[386]=3747; //p1
    code[429]=2495; //"]"

    code[473]=2386; //ExpressionStatement_14 # ExpressionStatement_19
    code[464]=2296; //invocationTemp_3

    code[543]=2386; //ExpressionStatement_14 # ExpressionStatement_20
    code[534]=3498; //invocationTemp_4

    code[613]=3169; //ExpressionStatement_15 # ExpressionStatement_21
    code[629]=3558; //invocationTemp_5
    code[622]=3498; //invocationTemp_4

    code[682]=4960; //ExpressionStatement_22 # ExpressionStatement_22
    code[711]=2375; //memberTemp_0
    code[663]=3558; //invocationTemp_5

    code[745]=6619; //ExpressionStatement_23 # ExpressionStatement_23
    code[753]=2155; //invocationTemp_6
    code[768]=2296; //invocationTemp_3
    code[756]=2375; //memberTemp_0
    code[765]=1704; //1

    code[812]=8351; //ExpressionStatement_24 # ExpressionStatement_24
    code[816]=898; //invocationTemp_7
    code[793]=2155; //invocationTemp_6

    code[882]=7644; //ExpressionStatement_25 # ExpressionStatement_25
    code[871]=3213; //sum
    code[862]=3213; //sum
    code[889]=898; //invocationTemp_7

    code[946]=3105; //ExpressionStatement_5 # ExpressionStatement_26
    code[930]=3841; //r
    code[932]=74; //""

    code[998]=5282; //ExpressionStatement_27 # ExpressionStatement_27
    code[1014]=3941; //dst
    code[993]=2398; //b

    code[1066]=3105; //ExpressionStatement_5 # ExpressionStatement_28
    code[1050]=1983; //var_forIndex_1
    code[1052]=3722; //0

    code[1118]=5554; //ExpressionStatement_29 # ExpressionStatement_29
    code[1128]=1675; //invocationTemp_8
    code[1144]=2398; //b

    code[1188]=5419; //ExpressionStatement_30 # ExpressionStatement_30
    code[1196]=651; //var_whileCondition_1
    code[1210]=1983; //var_forIndex_1
    code[1217]=1675; //invocationTemp_8

    code[1257]=6442; //IfStatementSyntax_2 # WhileStatementSyntax_31
    code[1242]=2780; //jmpWhileDestinationName_2780
    code[1274]=651; //var_whileCondition_1
    code[1268]=2915; //while_GoTo_True_2915
    code[1281]=737; //while_GoTo_False_737

    code[1314]=6265; //ExpressionStatement_32 # ExpressionStatement_32
    code[1339]=3213; //sum
    code[1297]=3213; //sum
    code[1322]=744; //"_"
    code[1319]=1983; //var_forIndex_1
    code[1300]=744; //"_"

    code[1373]=7644; //ExpressionStatement_25 # ExpressionStatement_33
    code[1362]=3213; //sum
    code[1353]=3213; //sum
    code[1380]=1065; //"~"

    code[1437]=9034; //ExpressionStatement_34 # ExpressionStatement_34
    code[1444]=3841; //r
    code[1462]=3841; //r
    code[1461]=3213; //sum
    code[1436]=1339; //"#"

    code[1499]=4502; //ExpressionStatement_35 # ExpressionStatement_35
    code[1522]=3941; //dst
    code[1487]=1983; //var_forIndex_1
    code[1523]=3213; //sum

    code[1554]=1402; //ExpressionStatement_9 # ExpressionStatement_36
    code[1569]=1983; //var_forIndex_1
    code[1559]=1983; //var_forIndex_1
    code[1553]=1704; //1

    code[1618]=5554; //ExpressionStatement_29 # ExpressionStatement_37
    code[1628]=1296; //invocationTemp_9
    code[1644]=2398; //b

    code[1688]=5419; //ExpressionStatement_30 # ExpressionStatement_38
    code[1696]=651; //var_whileCondition_1
    code[1710]=1983; //var_forIndex_1
    code[1717]=1296; //invocationTemp_9

    code[1757]=9095; //ExpressionStatement_4 # ExpressionStatement_39
    code[1770]=2784; //while_FalseBlockSkip_2784

    code[1820]=7019; //ExpressionStatement_40 # ExpressionStatement_40
    code[1840]=1509; //memberTemp_1
    code[1848]=3941; //dst

    code[1878]=8015; //ExpressionStatement_41 # ExpressionStatement_41
    code[1883]=3213; //sum
    code[1877]=3213; //sum
    code[1879]=1339; //"#"
    code[1904]=1509; //memberTemp_1

    code[1937]=8233; //ReturnStatement_42 # ReturnStatement_42
    code[1931]=3213; //sum

    return (string)InstanceInterpreterVirtualization_BinarySearch_Iterative_3054(vpc, data, code);

}

        private int ReturnArg_Array(int val)
        {
            return val;
        }

        private static int BinarySearchIterative_obfuscated(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Iterative_ctrl_flow";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "20_300_160_-1";
            string sortedObfuscatedHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private object InstanceInterpreterVirtualization_BinarySearch_Iterative_3054(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 9095:  //frequency 3 ExpressionStatement_4
                vpc += (int)data[code[vpc + (13)]];
                vpc += 63;
                break;
            case 7887:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (22)]] = (int)data[code[vpc + (-6)]] + (long)data[code[vpc + (20)]];
                vpc += 56;
                break;
            case 7902:  //frequency 2 ReturnStatement_3
                return (long)data[code[vpc + (3)]];
                vpc += 60;
            case 6460:  //frequency 1 ExpressionStatement_18
                data[code[vpc + (20)]] = (string)data[code[vpc + (3)]] + (string)data[code[vpc + (-14)]] + (double)data[code[vpc + (-16)]] + (string)data[code[vpc + (27)]];
                vpc += 71;
                break;
            case 7779:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (-15)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (9)]]).First());
                vpc += 64;
                break;
            case 7644:  //frequency 2 ExpressionStatement_25
                data[code[vpc + (-11)]] = (string)data[code[vpc + (-20)]] + (string)data[code[vpc + (7)]];
                vpc += 64;
                break;
            case 8351:  //frequency 1 ExpressionStatement_24
                data[code[vpc + (4)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-19)]]).ToString();
                vpc += 70;
                break;
            case 4502:  //frequency 1 ExpressionStatement_35
                ((string[])data[code[vpc + (23)]])[(int)data[code[vpc + (-12)]]] = (string)data[code[vpc + (24)]];
                vpc += 55;
                break;
            case 6244:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (21)]] = (string)data[code[vpc + (28)]] + (int)data[code[vpc + (-4)]] + (int)data[code[vpc + (-12)]] + (string)data[code[vpc + (-1)]];
                vpc += 66;
                break;
            case 6265:  //frequency 1 ExpressionStatement_32
                data[code[vpc + (25)]] = (string)data[code[vpc + (-17)]] + (string)data[code[vpc + (8)]] + (int)data[code[vpc + (5)]] + (string)data[code[vpc + (-14)]];
                vpc += 59;
                break;
            case 7019:  //frequency 1 ExpressionStatement_40
                data[code[vpc + (20)]] = ((string[])data[code[vpc + (28)]]).Length;
                vpc += 58;
                break;
            case 2386:  //frequency 3 ExpressionStatement_14
                data[code[vpc + (-9)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 70;
                break;
            case 1086:  //frequency 1 ExpressionStatement_8
                data[code[vpc + (-16)]] = (long)data[code[vpc + (-13)]] * (int)data[code[vpc + (5)]];
                vpc += 67;
                break;
            case 3105:  //frequency 3 ExpressionStatement_5
                data[code[vpc + (-16)]] = data[code[vpc + (-14)]];
                vpc += 52;
                break;
            case 6619:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (8)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (23)]]).GetPiston((int)data[code[vpc + (11)]] - (int)data[code[vpc + (20)]]));
                vpc += 67;
                break;
            case 9058:  //frequency 1 ExpressionStatement_1
                data[code[vpc + (26)]] = (int)data[code[vpc + (-6)]] == (int)data[code[vpc + (17)]];
                vpc += 56;
                break;
            case 7369:  //frequency 2 ExpressionStatement_6
                data[code[vpc + (29)]] = (int)data[code[vpc + (23)]] <= (int)data[code[vpc + (25)]];
                vpc += 67;
                break;
            case 3169:  //frequency 2 ExpressionStatement_15
                data[code[vpc + (16)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (9)]]).GetPistons());
                vpc += 69;
                break;
            default:  //frequency 0 
                break;
            case 8015:  //frequency 1 ExpressionStatement_41
                data[code[vpc + (5)]] = (string)data[code[vpc + (-1)]] + (string)data[code[vpc + (1)]] + (int)data[code[vpc + (26)]];
                vpc += 59;
                break;
            case 6442:  //frequency 3 IfStatementSyntax_2
                data[code[vpc + (-15)]] = (bool)data[code[vpc + (17)]] ? (int)data[code[vpc + (11)]] : (int)data[code[vpc + (24)]];
                vpc += (int)data[code[vpc + (-15)]];
                break;
            case 1545:  //frequency 1 ExpressionStatement_17
                data[code[vpc + (9)]] = ((ConsoleCalculator.Piston)data[code[vpc + (10)]]).GetSize();
                vpc += 67;
                break;
            case 1402:  //frequency 2 ExpressionStatement_9
                data[code[vpc + (15)]] = (int)data[code[vpc + (5)]] + (int)data[code[vpc + (-1)]];
                vpc += 64;
                break;
            case 9034:  //frequency 1 ExpressionStatement_34
                data[code[vpc + (7)]] = (string)data[code[vpc + (25)]] + (string)data[code[vpc + (24)]] + (string)data[code[vpc + (-1)]];
                vpc += 62;
                break;
            case 5554:  //frequency 2 ExpressionStatement_29
                data[code[vpc + (10)]] = ReturnArg_Array((int)data[code[vpc + (26)]]);
                vpc += 70;
                break;
            case 8233:  //frequency 1 ReturnStatement_42
                return (string)data[code[vpc + (-6)]];
                vpc += 56;
            case 5419:  //frequency 2 ExpressionStatement_30
                data[code[vpc + (8)]] = (int)data[code[vpc + (22)]] < (int)data[code[vpc + (29)]];
                vpc += 69;
                break;
            case 4960:  //frequency 1 ExpressionStatement_22
                data[code[vpc + (29)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-19)]]).Count;
                vpc += 63;
                break;
            case 5282:  //frequency 1 ExpressionStatement_27
                data[code[vpc + (16)]] = (string[])(new string[(int)data[code[vpc + (-5)]]]);
                vpc += 68;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Iterative_method.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Iterative_method
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Iterative_method bs = new BinarySearch_Iterative_method();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Iterative_method", BinarySearchIterative_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


//                [Obfuscation(Exclude = false, Feature = "virtualization; method")]
private static int BinarySearchIterative_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100645];
    object[] data = new object[4748];
    int vpc = 68;

    code[55109]=1023;code[63128]=1075;code[94021]=-381;code[59926]=867;code[42606]=351;code[77602]=1418;
    code[2052]=-534;code[35759]=1401;code[53972]=164;code[38648]=1358;code[45476]=323;code[97882]=889;
    code[91409]=-417;code[19621]=601;code[65708]=535;code[87677]=1409;code[6159]=-926;code[59927]=-528;
    code[3444]=-654;code[97949]=286;code[47234]=-845;code[93302]=-991;code[97130]=-416;code[17569]=962;
    code[65137]=148;code[65206]=838;code[94160]=844;code[2416]=-955;code[84216]=1178;code[92776]=752;
    code[5306]=1387;code[9457]=1022;code[67381]=1018;code[91187]=1476;code[59490]=-585;code[93218]=-7;
    code[49579]=1173;code[47702]=-26;code[60612]=1422;code[79584]=686;code[5908]=24;code[99973]=-517;
    code[97261]=-661;code[2832]=-192;code[568]=442;code[35453]=-593;code[21830]=-320;code[46493]=286;
    code[97441]=-706;code[33635]=-606;code[32979]=-541;code[19512]=202;code[53666]=-375;code[24416]=-835;
    code[26549]=585;code[41869]=1169;code[8116]=-382;code[64635]=606;code[96773]=1251;code[84809]=333;
    code[78421]=456;code[99142]=-966;code[81923]=908;code[18178]=-450;code[40999]=1398;code[42423]=210;
    code[63874]=582;code[34907]=1187;code[21749]=280;code[66445]=790;code[89907]=1404;code[6002]=-72;
    code[16219]=210;code[8270]=1424;code[63414]=1048;code[55646]=-831;code[27709]=1001;code[38099]=862;
    code[20002]=-551;code[67125]=924;code[7018]=-945;code[66312]=-240;code[21415]=1329;code[23475]=119;
    code[90625]=918;code[42939]=122;code[24188]=-684;code[64436]=1043;code[52633]=534;code[85826]=-176;
    code[68561]=-473;code[59403]=470;code[40924]=-116;code[21027]=1085;code[25608]=504;code[68047]=-910;
    code[85087]=1225;code[65044]=1177;code[30496]=888;code[15957]=-427;code[25271]=586;code[6959]=1156;
    code[39508]=-741;code[83262]=-629;code[16142]=403;code[22354]=462;code[32927]=-157;code[8917]=1146;
    code[43483]=-824;code[90342]=1147;code[72749]=-2;code[19443]=-254;code[9180]=-24;code[60761]=-126;
    code[48344]=923;code[51760]=919;code[45812]=558;code[7903]=-884;code[14278]=818;code[19686]=-243;
    code[52997]=-850;code[67797]=732;code[38209]=-773;code[71354]=270;code[80694]=968;code[44181]=-420;
    code[86324]=-251;code[50980]=1129;code[44418]=926;code[77648]=-995;code[50323]=193;code[67262]=-23;
    code[4726]=136;code[13064]=759;code[26046]=-896;code[72147]=761;code[88075]=486;code[33445]=656;
    code[73026]=249;code[92495]=-1000;code[68590]=-761;code[55171]=731;code[33233]=-296;code[91573]=-612;
    code[11760]=-434;code[60924]=-72;code[96212]=-517;code[80803]=-877;code[39444]=-294;code[65040]=1312;
    code[96750]=-987;code[25090]=899;code[7116]=836;code[35947]=-343;code[97355]=1109;code[12709]=1353;
    code[85689]=928;code[32261]=10;code[93514]=1438;code[6136]=912;code[54813]=1435;code[59071]=-920;
    code[43936]=-137;code[75340]=703;code[79699]=-293;code[27242]=107;code[85924]=1484;code[3903]=690;
    code[85178]=970;code[62609]=489;code[93077]=617;code[18943]=-318;code[10101]=659;code[52335]=-539;
    code[87860]=-4;code[12086]=40;code[22289]=1203;code[38296]=1467;code[42096]=-458;code[32539]=813;
    code[99219]=688;code[47410]=710;code[57695]=707;code[8816]=1143;code[73734]=610;code[56164]=-648;
    code[35572]=162;code[84555]=1244;code[79109]=-215;code[93777]=931;code[83075]=410;code[81381]=-17;
    code[16402]=1135;code[22309]=1431;code[61733]=-871;code[25969]=572;code[46798]=1242;code[61385]=-377;
    code[17697]=259;code[70414]=43;code[58010]=656;code[45483]=-429;code[84584]=1448;code[6334]=890;
    code[4139]=206;code[20232]=-740;code[28722]=376;code[90562]=54;code[87257]=-806;code[52463]=797;
    code[46444]=-713;code[24570]=702;code[38869]=1322;code[68020]=141;code[86077]=477;code[72652]=-295;
    code[61834]=286;code[19742]=-593;code[11283]=449;code[55653]=-541;code[79644]=163;code[93734]=-674;
    code[85617]=-616;code[34600]=1285;code[100340]=-530;code[38469]=-755;code[98902]=1451;code[96191]=153;
    code[42104]=927;code[84794]=1278;code[30534]=515;code[90681]=125;code[76582]=1297;code[49301]=927;
    code[35688]=842;code[31170]=-283;code[52807]=-157;code[93359]=1490;code[18496]=-717;code[83554]=-419;
    code[58884]=904;code[46260]=667;code[21002]=559;code[30128]=584;code[56237]=837;code[74939]=-148;
    code[74209]=603;code[88602]=-538;code[56802]=202;code[37204]=1329;code[66820]=432;code[56323]=-350;
    code[88406]=-763;code[57718]=612;code[5339]=1399;code[27927]=-238;code[94688]=525;code[32858]=354;
    code[14760]=-416;code[24308]=-657;code[62360]=1140;code[21342]=549;code[99866]=1421;code[55331]=1208;
    code[46012]=856;code[43447]=756;code[74867]=1246;code[57215]=-970;code[20328]=-502;code[79382]=-717;
    code[5052]=635;code[58440]=497;code[46034]=99;code[40284]=-682;code[31695]=-154;code[3863]=-174;
    code[24114]=-419;code[31411]=1019;code[36320]=1349;code[26955]=1274;code[54886]=725;code[18918]=-224;
    code[53139]=437;code[56453]=-895;code[4187]=-215;code[34196]=1367;code[44797]=-681;code[8759]=1413;
    code[27725]=532;code[16335]=381;code[57201]=56;code[57201]=-704;code[70872]=-748;code[46603]=278;
    code[59014]=901;code[65543]=-345;code[93771]=1197;code[57187]=-101;code[46921]=-325;code[7156]=1206;
    code[88454]=-106;code[8618]=-999;code[100524]=-772;code[89112]=-721;code[14634]=-134;code[53573]=869;
    code[78262]=788;code[34363]=-693;code[12264]=-827;code[61019]=67;code[11250]=-877;code[45891]=-298;
    code[66737]=-806;code[1550]=415;code[56336]=817;code[50242]=-987;code[54535]=-301;code[67793]=-474;
    code[33905]=419;code[12055]=532;code[21712]=-122;code[36839]=-401;code[22986]=1258;code[48756]=-460;
    code[54097]=113;code[23966]=-8;code[66816]=610;code[77574]=1073;code[90775]=1011;code[33965]=1302;
    code[7635]=-202;code[55542]=45;code[85292]=317;code[20738]=244;code[4203]=-673;code[79100]=385;
    code[95570]=1483;code[21245]=900;code[68783]=-460;code[5285]=899;code[59708]=997;code[2882]=-715;
    code[49205]=-745;code[34359]=1243;code[51223]=1110;code[31047]=330;code[23177]=-504;code[54051]=1241;
    code[80470]=1369;code[39474]=753;code[70175]=1466;code[17572]=16;code[66369]=710;code[45012]=676;
    code[43597]=-974;code[14690]=714;code[75705]=444;code[32994]=-308;code[29249]=93;code[93545]=862;
    code[18680]=-229;code[99528]=-507;code[82781]=-366;code[32588]=877;code[45924]=-214;code[96698]=839;
    code[82937]=-123;code[6291]=516;code[62846]=555;code[45785]=1012;code[65935]=677;code[46739]=246;
    code[70271]=557;code[78497]=631;code[87646]=-350;code[60975]=-95;code[1832]=617;code[51908]=-29;
    code[100408]=1442;code[58774]=14;code[36256]=740;code[21559]=-704;code[4994]=25;code[86713]=2;
    code[51851]=802;code[65657]=671;code[98889]=-689;code[9053]=286;code[84950]=225;code[50257]=-501;
    code[47687]=678;code[88571]=-510;code[71333]=496;code[72218]=-558;code[84075]=684;code[61296]=618;
    code[3839]=-877;code[44747]=1396;code[45960]=-136;code[45180]=-280;code[76614]=-53;code[13828]=-626;
    code[61177]=1343;code[38194]=1234;code[56075]=-998;code[54823]=268;code[48074]=-40;code[93784]=722;
    code[82154]=-955;code[41243]=127;code[69710]=711;code[56933]=1103;code[11281]=-988;code[63439]=1333;
    code[68437]=-673;code[5844]=245;code[4172]=-472;code[44126]=-763;code[53725]=825;code[59200]=928;
    code[22064]=1059;code[62376]=1085;code[12981]=-746;code[17084]=634;code[11817]=888;code[14342]=96;
    code[94207]=1495;code[59921]=-809;code[81842]=-261;code[3787]=507;code[30899]=115;code[21498]=65;
    code[94902]=-884;code[46882]=-335;code[95194]=1092;code[15622]=-786;code[43269]=595;code[23314]=1171;
    code[6529]=828;code[71707]=-975;code[84058]=1441;code[82113]=1311;code[99502]=548;code[56580]=-892;
    code[61992]=-96;code[28357]=-406;code[69715]=1463;code[46738]=932;code[61428]=-516;code[89713]=-794;
    code[64003]=1258;code[71256]=-299;code[60421]=-859;code[865]=-256;code[77131]=816;code[1179]=-796;
    code[58718]=-932;code[77264]=-174;code[63437]=-278;code[44016]=-192;code[48743]=55;code[65456]=460;
    code[55871]=1293;code[39580]=111;code[17511]=146;code[25999]=1177;code[84536]=574;code[37679]=1329;
    code[27020]=338;code[32614]=1330;code[61488]=-339;code[27883]=1223;code[35238]=-501;code[65868]=663;
    code[21900]=-666;code[14363]=-198;code[76129]=419;code[60203]=-467;code[25467]=-690;code[73005]=707;
    code[66754]=409;code[12446]=-231;code[47138]=-649;code[24343]=1383;code[65712]=1089;code[6246]=-763;
    code[97134]=263;code[71704]=-451;code[14628]=902;code[23537]=-112;code[26455]=819;code[22847]=-900;
    code[31794]=1342;code[11543]=-321;code[3202]=-598;code[68310]=-639;code[81519]=602;code[27056]=-883;
    code[14176]=1423;code[42360]=-477;code[96421]=752;code[1254]=-46;code[7225]=-881;    data[596]=522;
code[297]=1869;code[375]=2019;    data[3048]=174;
    data[3161]=653;
code[786]=1869;    data[1807]=2;
    data[78]=false;
    data[3640]=57;
code[133]=3640;code[772]=7202;code[378]=2487;code[836]=4881;code[775]=1244;code[87]=3557;code[316]=1291;    data[3996]=false;
    data[1043]=297;
code[428]=1869;code[655]=4153;        data[2571]=(int[])inputArray;
code[120]=78;code[947]=8916;    data[2487]=475;
    data[3557]=max;
code[585]=3048;code[855]=3557;code[644]=2696;code[951]=1129;code[788]=2696;code[68]=4881;code[598]=3428;    data[3874]=70;
code[730]=3235;    data[2019]=57;
code[544]=1291;    data[2882]=822;
    data[3235]=64;
    data[1492]=172;
code[237]=1807;code[893]=4853;code[307]=2571;code[185]=596;code[593]=458;    data[1291]=key;
code[485]=4853;code[301]=2995;code[112]=2882;    data[1244]=min;
code[64]=1244;code[246]=3936;code[671]=3557;code[424]=8916;code[198]=3557;    data[167]=-822;
code[367]=3428;code[354]=1492;    data[1869]=-785;
code[283]=3996;code[539]=1650;code[905]=167;code[272]=1869;code[136]=3161;code[362]=3996;    data[3628]=57;
code[606]=3628;    data[458]=false;
code[125]=3428;    data[1129]=-1;
code[556]=458;code[645]=1869;    data[2696]=1;
code[844]=78;code[718]=4853;code[76]=78;code[568]=1869;code[196]=1244;code[244]=596;code[609]=3874;code[526]=2571;code[182]=7202;code[497]=1043;code[832]=1244;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 4853:
    			vpc += (int)data[code[vpc+(12)]];
    			vpc+=54;
    			break;
    		case 3936:
    			data[code[vpc+(26)]]= (int)data[code[vpc+(-2)]]/ (int)data[code[vpc+(-9)]];
    			vpc+=55;
    			break;
    		case 4153:
    			data[code[vpc+(16)]]= (int)data[code[vpc+(-10)]]- (int)data[code[vpc+(-11)]];
    			vpc+=63;
    			break;
    		case 2995:
    			data[code[vpc+(-18)]]= (int)data[code[vpc+(15)]]== ((int[])data[code[vpc+(6)]])[(int)data[code[vpc+(-4)]]];
    			vpc+=66;
    			break;
    		default:
    			break;
    		case 1650:
    			data[code[vpc+(17)]]= (int)data[code[vpc+(5)]]< ((int[])data[code[vpc+(-13)]])[(int)data[code[vpc+(29)]]];
    			vpc+=59;
    			break;
    		case 4881:
    			data[code[vpc+(8)]]= (int)data[code[vpc+(-4)]]<= (int)data[code[vpc+(19)]];
    			vpc+=57;
    			break;
    		case 7202:
    			data[code[vpc+(3)]]= (int)data[code[vpc+(14)]]+ (int)data[code[vpc+(16)]];
    			vpc+=64;
    			break;
    		case 3428:
    			data[code[vpc+(11)]]=(bool)data[code[vpc+(-5)]]?(int)data[code[vpc+(8)]]:(int)data[code[vpc+(-13)]];
    			vpc+=(int)data[code[vpc+(11)]];
    			break;
    		case 8916:
    			return (int)data[code[vpc+(4)]];
    			vpc+=61;
    	}
    }

    return 0;
}

        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

      


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Iterative_method";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "20_300_160_-1";
            string sortedObfuscatedHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Iterative_method_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Iterative_method_default

    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Iterative_method_default bs = new BinarySearch_Iterative_method_default();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Iterative_method_default", BinarySearchIterative_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        
        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
private static int BinarySearchIterative_refactored(int[] inputArray, int key, int min, int max)
{
    bool var_whileCondition_0 = min <= max;
    while (var_whileCondition_0)
    {
        int mid = (min + max) / 2;
        bool var_ifCondition_1 = key == inputArray[mid];
        if (var_ifCondition_1)
        {
            return mid;
        }
        else
        {
            bool var_ifCondition_0 = key < inputArray[mid];
            if (var_ifCondition_0)
            {
                max = mid - 1;
            }
            else
            {
                min = mid + 1;
            }
        }

        var_whileCondition_0 = min <= max;
    }

    return -1;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
        private static int BinarySearchIterative_method_readable_1(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100726];
    object[] data = new object[4654];
    int vpc = 59;

    //Data init
    data[3438]=(int[])inputArray; //inputArray 
    data[2973]=key; //key 
    data[3502]=min; //min 
    data[3153]=max; //max 
    data[2399]=2; //2 constant
    data[2124]=1; //1 constant
    data[58]=-1; //-1 constant
    data[425]=false; //var_whileCondition_0 
    data[812]=-357; //mid 
    data[563]=false; //var_ifCondition_1 
    data[1163]=false; //var_ifCondition_0 
    data[1184]=995; //jmpWhileDestinationName_1184 constant
    data[3837]=54; //while_GoTo_True_3837 constant
    data[1901]=748; //while_GoTo_False_1901 constant
    data[3385]=-748; //while_FalseBlockSkip_3385 constant
    data[1973]=-311; //jmpDestinationName_1973 constant
    data[43]=54; //if_GoTo_True_43 constant
    data[2920]=168; //if_GoTo_False_2920 constant
    data[2915]=281; //if_FalseBlockSize_Skip_2915 constant
    data[335]=890; //jmpDestinationName_335 constant
    data[2993]=54; //if_GoTo_True_2993 constant
    data[3781]=170; //if_GoTo_False_3781 constant
    data[751]=56; //if_FalseBlockSize_Skip_751 constant

    //Code init

    code[59]=3300; //ExpressionStatement_0 # ExpressionStatement_0
    code[46]=425; //var_whileCondition_0
    code[64]=3502; //min
    code[58]=3153; //max

    code[116]=7640; //WhileStatementSyntax_1 # WhileStatementSyntax_1
    code[102]=1184; //jmpWhileDestinationName_1184
    code[104]=425; //var_whileCondition_0
    code[105]=3837; //while_GoTo_True_3837
    code[139]=1901; //while_GoTo_False_1901

    code[170]=1290; //ExpressionStatement_2 # ExpressionStatement_2
    code[182]=812; //mid
    code[195]=3502; //min
    code[165]=3153; //max
    code[154]=2399; //2

    code[238]=2862; //ExpressionStatement_3 # ExpressionStatement_3
    code[252]=563; //var_ifCondition_1
    code[262]=2973; //key
    code[219]=3438; //inputArray
    code[261]=812; //mid

    code[296]=7640; //WhileStatementSyntax_1 # IfStatementSyntax_4
    code[282]=1973; //jmpDestinationName_1973
    code[284]=563; //var_ifCondition_1
    code[285]=43; //if_GoTo_True_43
    code[319]=2920; //if_GoTo_False_2920

    code[350]=2296; //ReturnStatement_5 # ReturnStatement_5
    code[371]=812; //mid

    code[402]=8554; //ExpressionStatement_6 # ExpressionStatement_6
    code[419]=2915; //if_FalseBlockSize_Skip_2915

    code[464]=3116; //ExpressionStatement_7 # ExpressionStatement_7
    code[475]=1163; //var_ifCondition_0
    code[481]=2973; //key
    code[458]=3438; //inputArray
    code[456]=812; //mid

    code[519]=7640; //WhileStatementSyntax_1 # IfStatementSyntax_8
    code[505]=335; //jmpDestinationName_335
    code[507]=1163; //var_ifCondition_0
    code[508]=2993; //if_GoTo_True_2993
    code[542]=3781; //if_GoTo_False_3781

    code[573]=9682; //ExpressionStatement_9 # ExpressionStatement_9
    code[559]=3153; //max
    code[560]=812; //mid
    code[566]=2124; //1

    code[627]=8554; //ExpressionStatement_6 # ExpressionStatement_10
    code[644]=751; //if_FalseBlockSize_Skip_751

    code[689]=3063; //ExpressionStatement_11 # ExpressionStatement_11
    code[705]=3502; //min
    code[704]=812; //mid
    code[717]=2124; //1

    code[745]=3300; //ExpressionStatement_0 # ExpressionStatement_12
    code[732]=425; //var_whileCondition_0
    code[750]=3502; //min
    code[744]=3153; //max

    code[802]=8554; //ExpressionStatement_6 # ExpressionStatement_13
    code[819]=3385; //while_FalseBlockSkip_3385

    code[864]=2296; //ReturnStatement_5 # ReturnStatement_14
    code[885]=58; //-1

    while(true)
    {
    	switch(code[vpc])
    	{
    		case 1290: //frequency 1 ExpressionStatement_2
    			data[code[vpc+(12)]]= ((int)data[code[vpc+(25)]]+ (int)data[code[vpc+(-5)]]) / (int)data[code[vpc+(-16)]];
    			vpc+=68;
    			break;
    		case 2296: //frequency 2 ReturnStatement_5
    			return (int)data[code[vpc+(21)]];
    			vpc+=52;
    		case 9682: //frequency 1 ExpressionStatement_9
    			data[code[vpc+(-14)]]= (int)data[code[vpc+(-13)]]- (int)data[code[vpc+(-7)]];
    			vpc+=54;
    			break;
    		case 7640: //frequency 3 WhileStatementSyntax_1
    			data[code[vpc+(-14)]]=(bool)data[code[vpc+(-12)]]?(int)data[code[vpc+(-11)]]:(int)data[code[vpc+(23)]];
    			vpc+=(int)data[code[vpc+(-14)]];
    			break;
    		case 3116: //frequency 1 ExpressionStatement_7
    			data[code[vpc+(11)]]= (int)data[code[vpc+(17)]]< ((int[])data[code[vpc+(-6)]])[(int)data[code[vpc+(-8)]]];
    			vpc+=55;
    			break;
    		case 2862: //frequency 1 ExpressionStatement_3
    			data[code[vpc+(14)]]= (int)data[code[vpc+(24)]]== ((int[])data[code[vpc+(-19)]])[(int)data[code[vpc+(23)]]];
    			vpc+=58;
    			break;
    		case 3063: //frequency 1 ExpressionStatement_11
    			data[code[vpc+(16)]]= (int)data[code[vpc+(15)]]+ (int)data[code[vpc+(28)]];
    			vpc+=56;
    			break;
    		case 8554: //frequency 3 ExpressionStatement_6
    			vpc += (int)data[code[vpc+(17)]];
    			vpc+=62;
    			break;
    		default: //frequency 0 
    			break;
    		case 3300: //frequency 2 ExpressionStatement_0
    			data[code[vpc+(-13)]]= (int)data[code[vpc+(5)]]<= (int)data[code[vpc+(-1)]];
    			vpc+=57;
    			break;
    	}
    }

    return 0;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
        private static int BinarySearchIterative_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100815];
    object[] data = new object[4674];
    int vpc = 117;

    code[93404]=353;code[86455]=258;code[92972]=1209;code[99738]=-419;code[554]=760;code[40016]=666;
    code[87758]=503;code[69195]=355;code[84489]=280;code[5223]=661;code[27390]=-970;code[24641]=-953;
    code[99200]=764;code[19813]=-646;code[20290]=248;code[46289]=1152;code[4886]=148;code[34477]=1351;
    code[435]=99;code[99376]=-79;code[87006]=836;code[539]=1373;code[57177]=1296;code[64821]=1496;
    code[92265]=-450;code[59687]=1432;code[57765]=1388;code[91724]=1285;code[29921]=1096;code[52359]=-460;
    code[69304]=1118;code[3161]=265;code[24702]=339;code[62307]=28;code[26165]=864;code[54244]=-5;
    code[53054]=707;code[80811]=342;code[687]=-263;code[45551]=-837;code[6339]=-506;code[22844]=1452;
    code[91479]=215;code[29037]=-768;code[55389]=69;code[64898]=-586;code[92794]=923;code[68678]=-962;
    code[70904]=248;code[71026]=-922;code[30300]=-421;code[74523]=-577;code[68769]=-516;code[45038]=1224;
    code[15499]=-68;code[91489]=-996;code[38988]=134;code[15471]=224;code[62597]=-875;code[60349]=897;
    code[24989]=312;code[86882]=1079;code[10290]=-70;code[48169]=892;code[190]=965;code[84048]=268;
    code[59514]=51;code[77106]=1077;code[46227]=-857;code[30134]=784;code[3970]=-5;code[94704]=-559;
    code[52438]=604;code[78535]=166;code[62093]=-522;code[39780]=632;code[90802]=1364;code[78974]=939;
    code[37294]=1268;code[6785]=-226;code[72182]=724;code[89520]=-81;code[54351]=0;code[41494]=1415;
    code[69474]=-195;code[3138]=409;code[75751]=1212;code[72535]=1124;code[59026]=713;code[31426]=150;
    code[59813]=-972;code[14210]=1025;code[39466]=-549;code[61174]=611;code[64241]=1472;code[46496]=378;
    code[99797]=1472;code[100574]=-127;code[51433]=429;code[64265]=-700;code[23209]=1032;code[78366]=-267;
    code[16173]=1077;code[90894]=-961;code[22797]=1334;code[19171]=711;code[60045]=517;code[72235]=761;
    code[55339]=-806;code[98413]=-104;code[79967]=917;code[33158]=749;code[86812]=199;code[57846]=905;
    code[89461]=-76;code[34230]=-966;code[4813]=-522;code[23192]=951;code[23590]=1118;code[65518]=401;
    code[28136]=477;code[42196]=758;code[80551]=941;code[96338]=-43;code[27476]=-268;code[80710]=81;
    code[60039]=-303;code[32958]=158;code[48790]=-807;code[43599]=701;code[25918]=-652;code[12934]=1140;
    code[59894]=-560;code[64214]=10;code[38005]=1340;code[47449]=753;code[43123]=39;code[7997]=-495;
    code[35116]=563;code[90828]=-789;code[52859]=-523;code[49376]=486;code[57404]=1267;code[42162]=921;
    code[87171]=916;code[29887]=-609;code[41826]=1423;code[30596]=-651;code[46658]=406;code[11036]=556;
    code[14066]=378;code[593]=-159;code[82899]=-753;code[480]=-551;code[20133]=-688;code[11592]=1146;
    code[17785]=-131;code[15745]=-835;code[65479]=334;code[28907]=717;code[76435]=1170;code[54372]=525;
    code[64484]=-215;code[28901]=145;code[11302]=1348;code[74529]=964;code[52005]=-305;code[95278]=1431;
    code[18653]=-617;code[77841]=175;code[90959]=-405;code[57362]=849;code[65704]=94;code[98819]=-833;
    code[81983]=-407;code[49430]=1322;code[27792]=55;code[87147]=-322;code[1235]=-11;code[70248]=270;
    code[81895]=366;code[6838]=-350;code[38867]=-178;code[34556]=1245;code[40603]=-542;code[88831]=240;
    code[76794]=1040;code[79123]=299;code[30170]=998;code[96631]=-496;code[33653]=-451;code[65040]=1186;
    code[45285]=1025;code[51438]=-767;code[41727]=684;code[96829]=973;code[46023]=-341;code[66339]=-111;
    code[17183]=-229;code[35719]=-194;code[9582]=-795;code[66968]=574;code[35906]=1485;code[16856]=148;
    code[64272]=-139;code[97992]=-469;code[44066]=237;code[17587]=481;code[90858]=-518;code[81759]=438;
    code[82550]=-377;code[48811]=822;code[22479]=-771;code[3998]=244;code[15959]=72;code[35230]=1476;
    code[44879]=589;code[10762]=-371;code[55988]=-962;code[52284]=137;code[64835]=-873;code[45965]=-827;
    code[70752]=869;code[35515]=1403;code[9012]=-837;code[45829]=1443;code[50185]=947;code[50793]=1114;
    code[60282]=1338;code[41009]=-339;code[96223]=673;code[30346]=-479;code[100317]=1453;code[77385]=1003;
    code[39139]=1306;code[3763]=1214;code[67990]=-111;code[93967]=919;code[79981]=37;code[2735]=188;
    code[74547]=-805;code[41181]=-768;code[98234]=-70;code[49667]=665;code[13308]=-348;code[65905]=550;
    code[61355]=-365;code[50467]=1434;code[75599]=-382;code[7489]=800;code[98806]=377;code[57794]=-584;
    code[2824]=421;code[30545]=-646;code[85391]=839;code[5283]=-543;code[91559]=1328;code[52923]=1190;
    code[26295]=-480;code[23602]=557;code[49285]=-747;code[67469]=-682;code[27122]=43;code[27951]=50;
    code[86228]=1395;code[1818]=364;code[34328]=-233;code[49922]=-529;code[50897]=-396;code[6547]=14;
    code[6962]=-124;code[82571]=-10;code[21029]=176;code[71762]=692;code[73517]=560;code[71877]=354;
    code[1339]=128;code[23326]=1196;code[88895]=115;code[90490]=526;code[29383]=1206;code[28889]=1221;
    code[72370]=266;code[84949]=503;code[43986]=-159;code[37447]=-953;code[14426]=1071;code[55846]=-655;
    code[28479]=-318;code[92611]=996;code[71120]=500;code[69659]=-423;code[24730]=190;code[53699]=1223;
    code[7609]=541;code[30915]=-853;code[34705]=135;code[11514]=-535;code[6474]=1325;code[68376]=755;
    code[63305]=-724;code[24274]=-19;code[25488]=734;code[40197]=-538;code[90463]=-767;code[60090]=521;
    code[53169]=-753;code[91262]=728;code[19336]=-862;code[64866]=-396;code[98172]=1383;code[53013]=1049;
    code[3012]=-219;code[68022]=722;code[72003]=-81;code[7448]=-120;code[59973]=-459;code[17189]=487;
    code[36230]=-255;code[98617]=378;code[7811]=-131;code[99998]=1455;code[2075]=745;code[53575]=-388;
    code[55343]=57;code[100257]=-979;code[28922]=91;code[73426]=686;code[58940]=52;code[36578]=1350;
    code[1941]=774;code[47445]=324;code[1956]=-391;code[1384]=-223;code[93620]=-225;code[33462]=1233;
    code[7794]=-770;code[16550]=564;code[96931]=359;code[80558]=-171;code[78755]=74;code[14104]=-272;
    code[37622]=-838;code[6581]=-605;code[49214]=239;code[1039]=1345;code[94305]=-905;code[53638]=-81;
    code[88432]=155;code[97062]=941;code[68985]=-449;code[31902]=-404;code[9173]=-748;code[93896]=-514;
    code[27463]=-745;code[71885]=-898;code[62710]=-923;code[16030]=474;code[57459]=-552;code[15775]=1385;
    code[18004]=1138;code[82941]=81;code[30242]=-16;code[96590]=-902;code[56461]=991;code[75489]=248;
    code[58559]=-945;code[65283]=401;code[11410]=1253;code[20193]=-320;code[13488]=1176;code[89309]=-36;
    code[78927]=1423;code[31879]=1261;code[88614]=1356;code[80416]=744;code[30825]=-979;code[60298]=1072;
    code[40105]=1209;code[94632]=743;code[14399]=1230;code[63989]=189;code[35641]=-466;code[46386]=499;
    code[38652]=495;code[48032]=671;code[98698]=1210;code[82710]=-230;code[97744]=92;code[65507]=-174;
    code[7807]=-866;code[16162]=544;code[100700]=-873;code[19505]=430;code[42770]=1046;code[16416]=-427;
    code[97038]=257;code[13046]=-396;code[23769]=25;code[3255]=422;code[51335]=791;code[52530]=-299;
    code[46977]=-678;code[72469]=53;code[18967]=-275;code[86629]=1402;code[23588]=520;code[62492]=-778;
    code[73770]=-958;code[48087]=-244;code[2048]=1219;code[17685]=411;code[43907]=-383;code[71192]=190;
    code[76096]=446;code[7290]=398;code[40788]=-799;code[82814]=-98;code[53691]=1199;code[15288]=1174;
    code[33479]=929;code[38729]=-665;code[96723]=-496;code[100355]=-114;code[89028]=-900;code[51412]=-454;
    code[94061]=824;code[55324]=553;code[54551]=1390;code[85198]=-453;code[42622]=-393;code[67213]=523;
    code[21947]=-251;code[56086]=-617;code[79297]=-353;code[56115]=1130;code[87248]=517;code[97840]=-380;
    code[50774]=-897;code[61019]=-416;code[25361]=-121;code[59777]=786;code[6929]=1134;code[63162]=687;
    code[53623]=-500;code[82646]=440;code[3487]=1331;code[45077]=-777;code[10610]=936;code[92398]=649;
    code[65082]=1105;code[57257]=560;code[48753]=644;code[35611]=-186;code[76537]=-249;code[11870]=249;
    code[35396]=528;code[97527]=-823;code[65514]=1380;code[54510]=-90;code[67870]=1203;code[62645]=466;
    code[44275]=1451;code[82412]=1331;code[16123]=1203;code[14428]=822;code[12569]=1363;code[59284]=23;
    code[79008]=1422;code[23289]=27;code[50447]=-249;code[92316]=-422;code[8298]=-201;code[22692]=57;
    code[97314]=-60;code[44301]=-618;code[23593]=381;code[99447]=910;code[22255]=1453;code[18643]=257;
    code[84728]=51;code[16735]=1194;code[15856]=-28;code[37827]=13;code[2361]=394;code[28976]=702;
    code[72694]=-676;code[87070]=-69;code[97358]=-26;code[50830]=-702;code[76147]=-15;code[97535]=959;
    code[44536]=1474;code[49891]=430;code[96695]=1059;code[19020]=1005;code[79027]=819;code[57502]=-801;
    code[13567]=-906;code[7481]=733;code[95235]=1048;code[40293]=18;code[8930]=896;code[43559]=-740;    data[800]=-766;
    data[1911]=2;
code[454]=1455;    data[413]=-920;
    data[961]=-54;
code[111]=3109;    data[950]=254;
    data[2717]=62;
    data[3955]=-848;
code[914]=1622;    data[2127]=773;
    data[1617]=-481;
    data[1455]=184;
code[567]=2810;    data[3584]=-445;
code[559]=2696;code[475]=3642;    data[2649]=-843;
code[623]=2390;    data[1442]=-335;
code[988]=1010;    data[1529]=-191;
code[745]=3908;code[168]=62;    data[2924]=-46;
    data[1313]=-662;
code[865]=7301;code[108]=3358;code[989]=3435;    data[1317]=-236;
code[101]=1907;    data[672]=826;
    data[2397]=816;
code[894]=3358;    data[3530]=-678;
    data[1880]=-478;
code[948]=3525;    data[932]=-646;
code[424]=2314;code[1065]=289;    data[492]=false;
    data[1516]=-212;
code[832]=1781;code[983]=1191;code[829]=3997;    data[2214]=-202;
code[418]=3634;    data[151]=59;
    data[2937]=176;
    data[2407]=54;
code[114]=2448;code[176]=667;    data[901]=-571;
code[240]=1622;code[893]=3998;    data[2390]=key;
code[810]=9528;code[708]=2937;code[169]=492;code[1063]=3739;    data[442]=268;
    data[896]=-43;
code[581]=900;code[703]=73;code[619]=5939;code[604]=1655;    data[1622]=max;
    data[656]=382;
code[417]=3980;code[672]=788;code[444]=3929;    data[2053]=-975;
code[205]=553;code[909]=2328;    data[3465]=28;
code[678]=1202;code[748]=2545;code[602]=3532;    data[2272]=658;
code[267]=2336;    data[43]=-660;
code[797]=3335;code[628]=3425;code[680]=1794;code[388]=606;code[925]=2242;code[308]=1924;    data[989]=-522;
    data[669]=-306;
code[291]=2354;code[385]=3425;code[1061]=2053;code[250]=1921;code[860]=3015;    data[3292]=-51;
    data[2314]=59;
    data[1636]=-224;
code[616]=1674;code[1075]=92;code[323]=2690;    data[3538]=874;
code[751]=1622;    data[214]=-943;
    data[3574]=-302;
code[562]=2827;code[979]=578;    data[2389]=-170;
code[922]=492;code[307]=5133;    data[2972]=-463;
code[290]=2905;code[494]=4783;code[312]=2517;    data[489]=989;
    data[33]=-347;
    data[3358]=min;
code[545]=2146;    data[3395]=342;
code[379]=7687;    data[3015]=1;
    data[1712]=-873;
code[253]=684;code[435]=7415;    data[570]=-569;
    data[3797]=299;
code[761]=42;    data[2957]=-448;
    data[3408]=-94;
code[112]=492;code[117]=3245;    data[1082]=910;
code[245]=7301;code[1038]=1989;code[638]=570;code[459]=2398;code[189]=427;code[728]=451;    data[48]=42;
code[390]=3634;    data[1068]=-717;
code[792]=1605;code[802]=2717;code[859]=570;code[1044]=2562;code[681]=99;code[1009]=2557;code[167]=3679;code[854]=3519;code[288]=1911;code[179]=2924;code[455]=2480;code[793]=1993;    data[1963]=291;
    data[304]=608;
    data[439]=561;
code[736]=3015;    data[1208]=157;
code[1070]=877;code[187]=547;code[513]=39;code[737]=1743;code[797]=3523;    data[67]=-885;
    data[1929]=418;
    data[219]=-986;
code[645]=3768;code[869]=2599;    data[788]=false;
code[99]=3732;code[583]=3837;    data[3240]=-385;
code[629]=3273;code[333]=2441;code[1055]=1720;    data[3717]=-244;
    data[536]=-474;
code[635]=1653;code[800]=3475;    data[1565]=107;
    data[3683]=-281;
code[677]=1146;    data[847]=-199;
    data[326]=454;
    data[1010]=-865;
    data[1942]=955;
    data[1926]=36;
    data[1989]=-1;
    data[1829]=-407;
code[701]=2557;    data[900]=-192;
    data[2073]=-904;
    data[2405]=-929;
    data[3297]=-10;
code[1063]=43;code[631]=788;code[987]=668;code[996]=9528;code[297]=2304;    data[2290]=547;
    data[130]=-455;
code[881]=2470;    data[3634]=false;
    data[553]=865;
code[572]=86;code[581]=2430;code[556]=3410;code[175]=151;code[481]=570;code[863]=3301;    data[2291]=293;
    data[2498]=-734;
code[373]=2615;code[428]=3228;code[1046]=3124;    data[1193]=618;
code[1078]=3717;    data[444]=-960;
    data[2930]=809;
code[1051]=4783;    data[3745]=-787;
    data[3228]=-626;
code[239]=3358;    data[148]=970;
    data[2979]=-671;
    data[2246]=-457;
code[682]=2957;    data[2153]=26;
    data[2905]=-518;
code[992]=3791;    data[3720]=646;
    data[797]=-119;
    data[2868]=-188;
code[891]=477;    data[3619]=-153;
code[104]=1622;    data[641]=269;
code[564]=9528;code[294]=570;code[927]=3245;    data[3855]=216;
code[706]=2035;code[400]=3481;code[584]=500;code[274]=2905;code[796]=3623;code[795]=1526;    data[951]=688;
code[176]=3220;    data[244]=465;
    data[3887]=818;
code[173]=522;code[768]=1412;code[918]=3358;    data[1496]=703;
code[137]=2871;code[741]=973;code[476]=2389;code[738]=570;    data[1202]=59;
    data[3064]=-437;
code[1074]=2044;        data[3425]=(int[])inputArray;
code[689]=7415;    data[2912]=490;
code[572]=2419;    data[909]=-568;
code[186]=2633;    data[3094]=848;
    data[953]=-845;
code[130]=1650;code[178]=1956;code[827]=3559;code[213]=655;    data[2067]=-51;
code[733]=2586;code[1076]=3771;    data[1528]=338;
code[394]=570;    data[3990]=-702;
    data[2268]=-857;
    data[2308]=681;
    data[3931]=-953;
code[308]=3853;code[566]=2215;    data[3733]=-40;
code[767]=2378;code[522]=3917;    data[2003]=-954;
    data[2197]=-992;
    data[1274]=-635;
code[214]=1610;    data[3410]=308;
code[381]=2390;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 2545:
    			data[code[vpc+(3)]]= (int)data[code[vpc+(-10)]]- (int)data[code[vpc+(-12)]];
    			vpc+=62;
    			break;
    		case 5939:
    			data[code[vpc+(12)]]= (int)data[code[vpc+(4)]]< ((int[])data[code[vpc+(9)]])[(int)data[code[vpc+(19)]]];
    			vpc+=70;
    			break;
    		case 5133:
    			data[code[vpc+(-13)]]= (int)data[code[vpc+(-17)]]/ (int)data[code[vpc+(-19)]];
    			vpc+=72;
    			break;
    		case 3245:
    			data[code[vpc+(-5)]]= (int)data[code[vpc+(-9)]]<= (int)data[code[vpc+(-13)]];
    			vpc+=69;
    			break;
    		case 7301:
    			data[code[vpc+(29)]]= (int)data[code[vpc+(-6)]]+ (int)data[code[vpc+(-5)]];
    			vpc+=62;
    			break;
    		case 4783:
    			return (int)data[code[vpc+(-13)]];
    			vpc+=70;
    		case 7687:
    			data[code[vpc+(11)]]= (int)data[code[vpc+(2)]]== ((int[])data[code[vpc+(6)]])[(int)data[code[vpc+(15)]]];
    			vpc+=56;
    			break;
    		case 9528:
    			vpc += (int)data[code[vpc+(-8)]];
    			vpc+=55;
    			break;
    		default:
    			data[code[vpc+(-7)]]=(bool)data[code[vpc+(-17)]]?(int)data[code[vpc+(-11)]]:(int)data[code[vpc+(19)]];
    			vpc+=(int)data[code[vpc+(-7)]];
    			break;
    	}
    }

    return 0;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Iterative_method_default";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "20_300_160_-1";
            string sortedObfuscatedHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Iterative_method_modified.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Iterative_method_modified
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Iterative_method_modified bs = new BinarySearch_Iterative_method_modified();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";
            init_code();
//            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_modified";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Iterative_method_modified", BinarySearchIterative_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private static int[] code;

        private void init_code()
        {
            code = new int[100366];
            code[72689] = 1444; code[77318] = 570; code[63641] = -12; code[89069] = -707; code[72270] = -8; code[71906] = 1123;
            code[3008] = 446; code[68708] = 570; code[10735] = -153; code[74329] = 534; code[78066] = 825; code[95547] = -876;
            code[75946] = -564; code[37614] = -446; code[82635] = 1332; code[65198] = 170; code[9380] = 1146; code[1004] = -485;
            code[76404] = -465; code[3656] = 261; code[75183] = 9; code[64099] = 591; code[85572] = 1046; code[3221] = -3;
            code[18518] = -604; code[94389] = 713; code[25747] = 304; code[54546] = 1484; code[2575] = 801; code[87480] = 148;
            code[2079] = 664; code[29509] = 967; code[75020] = -380; code[75867] = -572; code[57079] = 195; code[86991] = 1232;
            code[30365] = -411; code[86773] = -66; code[9192] = -212; code[19800] = 1345; code[14313] = 1439; code[3741] = 662;
            code[99605] = 1410; code[21228] = 429; code[31635] = -960; code[18132] = -899; code[34369] = 442; code[48577] = -792;
            code[11025] = 1128; code[89251] = 510; code[6277] = 1152; code[83322] = 765; code[29276] = -882; code[38421] = -949;
            code[65945] = -577; code[90569] = 775; code[52509] = 1333; code[31792] = -888; code[63069] = 572; code[79764] = 958;
            code[3702] = -540; code[85921] = 381; code[29867] = 1064; code[55246] = 813; code[75459] = 952; code[26506] = -400;
            code[42754] = 482; code[87889] = -296; code[14620] = -173; code[37456] = 1362; code[58354] = -523; code[91810] = -636;
            code[11402] = 175; code[51950] = 22; code[26123] = 97; code[45668] = 201; code[5694] = -735; code[56939] = 1196;
            code[473] = -307; code[41014] = 164; code[49891] = 643; code[26980] = 1189; code[90873] = 655; code[28543] = 1325;
            code[5788] = -913; code[90245] = -257; code[25685] = 1124; code[20253] = 1115; code[27030] = 776; code[44070] = 1068;
            code[30946] = -647; code[46690] = -219; code[32731] = 958; code[18403] = -201; code[2584] = 1493; code[27810] = 1170;
            code[92573] = 1268; code[44940] = 1310; code[92537] = -903; code[24111] = 128; code[18655] = 468; code[35268] = -437;
            code[54196] = -606; code[22563] = -483; code[90754] = 803; code[61136] = -265; code[84144] = 453; code[15797] = -111;
            code[19281] = 1390; code[55177] = -695; code[48067] = 1411; code[90765] = -849; code[76062] = -923; code[37636] = -129;
            code[40357] = -306; code[92741] = -424; code[47190] = 1469; code[64378] = 802; code[79286] = -401; code[77551] = -579;
            code[56059] = 1441; code[41723] = -239; code[38952] = 1457; code[2991] = -148; code[75279] = -770; code[73465] = 1414;
            code[49088] = -705; code[97593] = -447; code[68563] = -273; code[46917] = 272; code[78551] = 1190; code[80769] = 566;
            code[80013] = -54; code[82711] = 1126; code[94332] = 91; code[56779] = 1380; code[18410] = -47; code[56556] = 256;
            code[55073] = 499; code[67477] = 937; code[117] = -916; code[60058] = -225; code[54770] = 1395; code[74405] = -120;
            code[1545] = 50; code[3783] = 247; code[77523] = -341; code[38721] = 705; code[17238] = 972; code[50911] = -977;
            code[15928] = -552; code[40259] = -217; code[52823] = 949; code[78529] = -731; code[55669] = 174; code[67514] = -792;
            code[62091] = 731; code[50969] = 871; code[27896] = 236; code[8111] = 1097; code[63966] = 180; code[83824] = 299;
            code[40032] = -834; code[18048] = 1299; code[99912] = 1203; code[33187] = 898; code[9294] = 657; code[61860] = 1054;
            code[63514] = -288; code[78661] = 914; code[17636] = 583; code[80024] = 363; code[75005] = 1386; code[88356] = -800;
            code[75859] = 592; code[40573] = 692; code[71093] = 670; code[37343] = 716; code[34527] = 1203; code[91796] = 148;
            code[60210] = 1156; code[11271] = 683; code[13981] = 1282; code[99429] = 1389; code[7632] = 714; code[11627] = 1482;
            code[71353] = -213; code[66576] = -991; code[67722] = -276; code[77537] = 111; code[18705] = -751; code[16451] = -105;
            code[47878] = 634; code[5139] = 61; code[29187] = 1324; code[47968] = 878; code[37163] = -190; code[16666] = -218;
            code[52315] = -691; code[40759] = 1085; code[96725] = 1311; code[396] = -826; code[52316] = 28; code[96964] = -17;
            code[487] = -80; code[1188] = -865; code[10910] = 175; code[27421] = 250; code[70131] = 884; code[19705] = 214;
            code[86507] = 415; code[66736] = -635; code[20869] = -90; code[62503] = -34; code[14934] = -125; code[48428] = 377;
            code[88687] = 1345; code[48247] = -346; code[9621] = -766; code[84016] = -836; code[68999] = 644; code[42108] = 1306;
            code[92125] = 59; code[64522] = 1250; code[5113] = 664; code[61651] = 918; code[93100] = 1301; code[97581] = -7;
            code[26059] = 1144; code[86517] = -608; code[79132] = 448; code[24559] = 636; code[88900] = 152; code[17121] = -575;
            code[99306] = -972; code[40570] = 512; code[92016] = -674; code[80113] = -490; code[14725] = 856; code[22923] = 960;
            code[72403] = 806; code[33706] = 207; code[73872] = 788; code[62545] = 1408; code[96962] = -792; code[214] = -405;
            code[23277] = 700; code[27839] = -730; code[41451] = 912; code[3688] = 142; code[25402] = 181; code[91397] = -902;
            code[26268] = -977; code[85360] = 992; code[12262] = 920; code[25166] = 293; code[63154] = -806; code[43717] = -836;
            code[24439] = 904; code[92186] = -574; code[84092] = -482; code[20499] = 1265; code[933] = -585; code[37423] = -409;
            code[85624] = 725; code[79408] = -46; code[70824] = 928; code[53307] = -378; code[81497] = -260; code[22191] = 816;
            code[86785] = 1065; code[84413] = -505; code[83553] = 212; code[61119] = -615; code[24543] = -472; code[86779] = 627;
            code[84959] = 1165; code[62125] = -886; code[26926] = -989; code[3032] = -761; code[63891] = 534; code[94743] = 80;
            code[98041] = 1172; code[81451] = 1144; code[54864] = -534; code[25470] = 1367; code[54272] = -521; code[30698] = -971;
            code[36762] = -985; code[7397] = 310; code[55906] = -454; code[99578] = 603; code[82845] = -650; code[53716] = 1098;
            code[15310] = 213; code[98416] = 1018; code[26708] = -687; code[9030] = -373; code[88529] = 22; code[22200] = 1408;
            code[67581] = 878; code[60970] = -856; code[96130] = 1293; code[11079] = 636; code[56236] = 517; code[68195] = -345;
            code[93412] = 264; code[54065] = 44; code[62391] = -244; code[60887] = 1091; code[33505] = 1430; code[70773] = -847;
            code[20687] = 115; code[68355] = 38; code[10233] = -863; code[13019] = 1393; code[78787] = -725; code[85414] = 1014;
            code[61346] = 1335; code[68623] = 1269; code[2976] = 1201; code[28019] = 363; code[80884] = 796; code[88003] = 900;
            code[58883] = 680; code[63154] = 449; code[80523] = -40; code[63192] = 753; code[4626] = 365; code[85481] = 278;
            code[23725] = 737; code[55461] = 263; code[47921] = 805; code[47881] = 1051; code[65717] = 832; code[80957] = 718;
            code[62096] = 746; code[81008] = 132; code[69541] = -601; code[25630] = 219; code[57145] = 1301; code[83170] = 74;
            code[42727] = 375; code[15558] = 1; code[48237] = -626; code[76244] = -838; code[8292] = -570; code[67404] = -164;
            code[32925] = 934; code[6812] = -791; code[24231] = -860; code[10588] = 1134; code[86863] = 1354; code[96443] = -741;
            code[57936] = -559; code[843] = 1215; code[29189] = -90; code[94565] = -211; code[86950] = -694; code[7991] = 1318;
            code[56919] = -809; code[34110] = 262; code[97679] = 854; code[60689] = 116; code[2717] = 181; code[12558] = 1297;
            code[9227] = -571; code[24708] = 282; code[81824] = 1437; code[56644] = 209; code[59131] = -872; code[82635] = -240;
            code[14185] = 1183; code[77700] = 796; code[23076] = -111; code[47000] = -487; code[69673] = -649; code[51850] = -588;
            code[71910] = 501; code[88374] = -691; code[33848] = 285; code[7683] = -739; code[5149] = -777; code[79724] = -702;
            code[11833] = 73; code[50216] = 1228; code[56038] = 489; code[33945] = 289; code[25403] = -911; code[36503] = -751;
            code[97096] = 1215; code[21742] = 677; code[422] = 1299; code[22567] = 1378; code[65738] = -797; code[79943] = -463;
            code[9472] = 101; code[14706] = -813; code[97838] = 796; code[25378] = -871; code[7933] = 637; code[60282] = 1001;
            code[85877] = 442; code[64932] = -755; code[80520] = -998; code[91517] = 702; code[23761] = 951; code[15700] = 127;
            code[29881] = 13; code[10091] = -672; code[86764] = 1107; code[46591] = -909; code[63498] = -287; code[79995] = -706;
            code[45094] = -342; code[54289] = 336; code[78567] = -221; code[2088] = -219; code[28656] = 39; code[81841] = 68;
            code[27384] = -684; code[14972] = 635; code[16998] = -711; code[98162] = -216; code[28512] = 738; code[77990] = 423;
            code[62031] = -697; code[18818] = -410; code[19144] = 409; code[16866] = 425; code[78267] = 322; code[65142] = 347;
            code[46163] = -57; code[90127] = 1312; code[76262] = 1109; code[16618] = 1204; code[59218] = 683; code[86178] = 845;
            code[69624] = 1025; code[87048] = 292; code[30858] = 208; code[83677] = 884; code[48812] = 1428; code[91980] = 653;
            code[12466] = 961; code[12215] = 803; code[24876] = -387; code[64987] = 859; code[47917] = 525; code[19487] = 980;
            code[21851] = -868; code[55588] = 100; code[53178] = 1238; code[98289] = 1362; code[26367] = 123; code[54442] = -49;
            code[69916] = 627; code[26362] = -259; code[69794] = 1237; code[5270] = 220; code[46256] = -409; code[80375] = 1437;
            code[72489] = 110; code[63626] = -139; code[2578] = -713; code[26152] = -792; code[61818] = -812; code[30033] = -364;
            code[93286] = -16; code[22484] = 477; code[99587] = 1429; code[40018] = 686; code[24309] = 852; code[2504] = 491;
            code[98624] = -123; code[4847] = 455; code[55984] = 764; code[33236] = 1452; code[25311] = 446; code[72047] = -786;
            code[26225] = 586; code[92251] = -631; code[18961] = 147; code[76750] = 553; code[35313] = -980; code[36836] = -246;
            code[67361] = 153; code[49794] = 223; code[84087] = -685; code[73566] = 1452; code[42057] = -908; code[36338] = 686;
            code[6688] = 695; code[52749] = 1275; code[74684] = -205; code[225] = -123; code[67822] = -655; code[33099] = -106;
            code[5263] = -373; code[48755] = 957; code[97990] = 9; code[932] = 3912;



            code[850] = 2866; code[740] = 1887; code[281] = 3479; code[278] = 2540; code[80] = 1622; code[177] = 2525;
            code[565] = 9445; code[812] = 216; code[384] = 438; code[733] = 683;
            code[819] = 1291; code[592] = 3799; code[315] = 2961;
            code[143] = 312;
            code[376] = 1448; code[583] = 297; code[340] = 3613; code[789] = 3114; code[305] = 2060;
            code[514] = 7839; code[71] = 1111;
            code[180] = 638; code[948] = 189; code[580] = 1677; code[396] = 2027;
            code[566] = 3676;
            code[749] = 1258; code[834] = 1111;
            code[163] = 363; code[321] = 6159; code[690] = 1043;
            code[549] = 2207; code[371] = 528;
            code[612] = 3020; code[153] = 3891; code[815] = 1563;
            code[909] = 2983;
            code[262] = 2118; code[543] = 2498; code[251] = 1961; code[221] = 468; code[931] = 3907; code[156] = 3310; code[564] = 3970;

            code[666] = 3217; code[626] = 156;
            code[326] = 3970; code[388] = 3989;
            code[147] = 1000; code[898] = 1556; code[380] = 1106; code[450] = 1291;
            code[342] = 1291;
            code[802] = 1111; code[928] = 681; code[581] = 2541;

            code[606] = 3534; code[108] = 3500;
            code[625] = 6701;
            code[535] = 1948; code[103] = 2145; code[392] = 1886;
            code[273] = 2397;
            code[107] = 2188;
            code[795] = 8547; code[268] = 2834;
            code[457] = 3816; code[221] = 3971;
            code[706] = 987;
            code[219] = 2118;
            code[813] = 1784;
            code[634] = 2328; code[554] = 817; code[144] = 2188;
            code[87] = 2866; code[389] = 6701;
            code[872] = 64; code[681] = 1291;
            code[945] = 3783; code[576] = 3014; code[628] = 2418;
            code[964] = 2084; code[787] = 3706;
            code[648] = 120; code[349] = 297;
            code[995] = 248; code[916] = 7839; code[430] = 1543; code[556] = 3770; code[344] = 3782; code[237] = 550; code[212] = 8547;
            code[744] = 7839;
            code[967] = 7941; code[291] = 1291;
            code[923] = 3200;
            code[468] = 2522;
            code[141] = 1860;
            code[93] = 2833;
            code[870] = 2188; code[898] = 993; code[230] = 3500; code[204] = 233;
            code[923] = 3580;
            code[675] = 860; code[616] = 817; code[684] = 5982; code[267] = 1345;
            code[560] = 1291;
            code[649] = 3718; code[980] = 3368; code[236] = 1111;
            code[927] = 1541;
            code[286] = 1865; code[593] = 2398; code[776] = 3014;
            code[727] = 1983; code[675] = 368; code[711] = 930; code[635] = 3896; code[921] = 1634;
            code[519] = 2101; code[969] = 396;
            code[695] = 3500;

            code[448] = 7941;
            code[412] = 1207;
            code[140] = 177; code[154] = 2475; code[317] = 1106; code[347] = 2751; code[417] = 1366;
            code[575] = 1791;
            code[413] = 2087; code[678] = 1784; code[734] = 1477; code[871] = 3500; code[638] = 806; code[857] = 3459;

        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
        private static int BinarySearchIterative_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    
    object[] data = new object[4120];
    int vpc = 87;
            data[3313] = 132; data[2275] = 2;
            data[135] = 440;
            data[1258] = 55;
            data[396] = -1;
            data[1784] = 1;
            data[2936] = 75;
            data[2462] = 629; data[3041] = 241;
            data[3475] = 879;
            data[893] = -273;
            data[1886] = 176;
            data[2397] = 2;
            data[3482] = 765; data[3164] = 373;
            data[2125] = -785; data[2769] = 49;
            data[1905] = 494; data[1147] = -212;
            data[2229] = -983;
            data[3892] = 196;
            data[946] = -895;
            data[3364] = 285; data[2484] = 230;
            data[2114] = -647;
            data[892] = 99;
            data[3181] = -54;
            data[2087] = -552; data[2821] = -442;
            data[2118] = -846;
            data[1406] = -655; data[419] = 89;
            data[1111] = min; data[2033] = -449;
            data[367] = 502; data[1380] = 3;
            data[1103] = 897; data[38] = 125;
            data[474] = -370; data[774] = 261;
            data[3987] = 317; data[3599] = -758;
            data[3131] = 523;
            data[412] = 283;
            data[1106] = false;
            data[2546] = 244;
            data[3273] = 15;
            data[1046] = 537; data[1019] = -436;
            data[592] = 697; data[2525] = 715;
            data[1634] = -814;
            data[297] = key; data[3725] = -106; data[3243] = 276;
            data[2591] = 826;
            data[296] = -771; data[3884] = -3;
            data[566] = 743; data[1448] = 59;
            data[1291] = 999; data[671] = 363;
            data[1818] = 492; data[1731] = 693;
            data[3718] = -847; data[3853] = -347;
            data[2920] = 639;
            data[585] = 56; data[3970] = (int[])inputArray;
            data[3465] = -282; data[589] = 59;
            data[3375] = -603;
            data[1153] = 990;
            data[3500] = max;
            data[1753] = -637; data[177] = 59;
            data[2822] = -843;
            data[3310] = 814;
            data[2418] = 170;
            data[2800] = -487;
            data[3020] = 59;
            data[1162] = 619;
            data[235] = -746;
            data[3920] = -305;
            data[360] = 692;
            data[817] = false;
            data[3071] = 784;
            data[1573] = -21;
            data[114] = -256;
            data[3252] = -7;
            data[3390] = -992;
            data[3872] = -70;
            data[2766] = -13;
            data[1251] = -706;
            data[3655] = -537;
            data[1556] = -758;
            data[355] = -493;
            data[2101] = 285;
            data[1400] = 884; data[1441] = -366;
            data[476] = -748;
            data[2188] = false;
            data[1132] = -708;
            data[2203] = 599;
            while (true)
    {
    	switch(code[vpc])
    	{
    		case 2866:
    			data[code[vpc+(20)]]= (int)data[code[vpc+(-16)]]<= (int)data[code[vpc+(21)]];
    			vpc+=66;
    			break;
    		case 7839:
    			vpc += (int)data[code[vpc+(5)]];
    			vpc+=51;
    			break;
    		case 9445:
    			data[code[vpc+(-11)]]= (int)data[code[vpc+(18)]]< ((int[])data[code[vpc+(-1)]])[(int)data[code[vpc+(-5)]]];
    			vpc+=60;
    			break;
    		case 5982:
    			data[code[vpc+(11)]]= (int)data[code[vpc+(-3)]]- (int)data[code[vpc+(-6)]];
    			vpc+=60;
    			break;
    		case 7941:
    			return (int)data[code[vpc+(2)]];
    			vpc+=66;
    		case 8547:
    			data[code[vpc+(7)]]= (int)data[code[vpc+(24)]]+ (int)data[code[vpc+(18)]];
    			vpc+=55;
    			break;
    		case 6159:
    			data[code[vpc+(-4)]]= (int)data[code[vpc+(28)]]== ((int[])data[code[vpc+(5)]])[(int)data[code[vpc+(21)]]];
    			vpc+=68;
    			break;
    		default:
    			data[code[vpc+(24)]]=(bool)data[code[vpc+(-9)]]?(int)data[code[vpc+(-13)]]:(int)data[code[vpc+(3)]];
    			vpc+=(int)data[code[vpc+(24)]];
    			break;
    		case 1345:
    			data[code[vpc+(24)]]= (int)data[code[vpc+(-5)]]/ (int)data[code[vpc+(6)]];
    			vpc+=54;
    			break;
    	}
    }

    return 0;
}

        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

        //        

        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Iterative_method_modified";
            Program.Start_Check(testName);
            bool condition = true;

            init_code();
            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "20_300_160_-1";
            string sortedObfuscatedHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Recursive.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Recursive
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();



        public static void RunTests()
        {
            BinarySearch_Recursive bs = new BinarySearch_Recursive();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Recursive_original", BinarySearchRecursive_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

        private static int BinarySearchRecursive_obfuscated(int[] inputArray, int key, int min, int max)
        {
            if (min > max)
            {
                return -1;
            }
            else
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    return BinarySearchRecursive_obfuscated(inputArray, key, min, mid - 1);
                }
                else
                {
                    return BinarySearchRecursive_obfuscated(inputArray, key, mid + 1, max);
                }
            }
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Recursive_original";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            int res11 = BinarySearchRecursive_obfuscated(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res22 = BinarySearchRecursive_obfuscated(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res33 = BinarySearchRecursive_obfuscated(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res44 = BinarySearchRecursive_obfuscated(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
            string sortedObfuscatedHash = res11 + "_" + res22 + "_" + res33 + "_" + res44;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Recursive_class.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Recursive_class
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Recursive_class bs = new BinarySearch_Recursive_class();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
//            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Recursive_class", BinarySearchRecursive_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]
private static int BinarySearchRecursive_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100781];
    object[] data = new object[4967];
    int vpc = 64;

    code[96819]=-196;code[9525]=-58;code[17399]=1070;code[56695]=-970;code[12326]=132;code[93530]=1446;
    code[19840]=364;code[96349]=925;code[19017]=152;code[37375]=-504;code[39110]=-209;code[86843]=132;
    code[92191]=1106;code[54500]=201;code[62846]=265;code[73713]=1292;code[37031]=-317;code[80360]=924;
    code[60357]=1395;code[55067]=1434;code[81529]=635;code[13551]=1288;code[64367]=-731;code[8620]=-899;
    code[41020]=1337;code[80768]=346;code[16770]=1476;code[6598]=610;code[46357]=603;code[46598]=-175;
    code[28949]=-796;code[39168]=539;code[72703]=-973;code[61582]=1308;code[75424]=-535;code[17261]=-425;
    code[92179]=-8;code[39281]=834;code[18357]=1365;code[82064]=1017;code[76287]=250;code[7424]=721;
    code[71046]=-518;code[75653]=-59;code[20954]=-617;code[31243]=1393;code[49983]=-460;code[69198]=817;
    code[26765]=296;code[19560]=569;code[50075]=-595;code[29458]=-448;code[76951]=427;code[62871]=923;
    code[60556]=-171;code[46553]=284;code[83369]=638;code[57764]=967;code[826]=749;code[91805]=321;
    code[26232]=-415;code[72112]=487;code[88286]=-466;code[74012]=745;code[71588]=656;code[47190]=658;
    code[75799]=-534;code[31238]=487;code[20938]=1131;code[93240]=-666;code[57352]=1453;code[78197]=1190;
    code[69676]=990;code[13113]=1101;code[64811]=1248;code[72452]=414;code[61235]=664;code[37029]=-344;
    code[45000]=743;code[34764]=374;code[84320]=1313;code[5954]=1345;code[87011]=995;code[76757]=601;
    code[34826]=1445;code[58393]=-612;code[78075]=942;code[96686]=-303;code[46191]=1098;code[91078]=-801;
    code[8444]=1234;code[5571]=1027;code[95110]=1256;code[5641]=-784;code[82553]=-882;code[14953]=276;
    code[51168]=-62;code[29953]=609;code[92935]=1094;code[1301]=1232;code[3488]=223;code[49872]=662;
    code[32253]=408;code[79713]=1076;code[71174]=-780;code[81055]=518;code[79965]=-338;code[46948]=1356;
    code[87695]=-380;code[100223]=1402;code[74815]=687;code[82794]=-255;code[83637]=-828;code[65284]=-3;
    code[48357]=-211;code[35966]=551;code[83278]=-974;code[4552]=485;code[40222]=-24;code[49467]=-50;
    code[11247]=-437;code[38324]=826;code[24496]=352;code[72267]=-394;code[91679]=-114;code[77949]=684;
    code[84980]=-870;code[15183]=-102;code[67312]=-509;code[84143]=-373;code[92274]=-21;code[35345]=-24;
    code[73720]=-541;code[78702]=956;code[22172]=1178;code[54783]=199;code[76325]=535;code[85582]=292;
    code[29714]=-774;code[5558]=-278;code[35451]=13;code[49328]=-687;code[54652]=707;code[78346]=935;
    code[86675]=714;code[93366]=-494;code[55987]=-401;code[46835]=799;code[88151]=1474;code[100705]=-852;
    code[76608]=1335;code[2271]=-905;code[81723]=-266;code[92375]=-428;code[20447]=584;code[6514]=442;
    code[14259]=365;code[90641]=275;code[90937]=-437;code[85479]=-879;code[40941]=-984;code[92990]=335;
    code[95243]=-148;code[93137]=294;code[15056]=-677;code[64725]=-238;code[9223]=1489;code[53276]=43;
    code[38569]=128;code[31686]=-379;code[77228]=370;code[57579]=-435;code[62588]=-127;code[6144]=-977;
    code[34292]=1385;code[82384]=623;code[14272]=1376;code[65826]=883;code[1170]=220;code[9385]=174;
    code[37246]=-3;code[8031]=-817;code[99920]=899;code[48940]=-636;code[1761]=204;code[12863]=127;
    code[91809]=499;code[28447]=1144;code[43875]=740;code[92040]=489;code[28234]=1286;code[17879]=-513;
    code[31436]=1482;code[16469]=-648;code[34523]=937;code[40900]=1236;code[36093]=1111;code[88581]=-82;
    code[47226]=244;code[23669]=1153;code[87041]=1288;code[99968]=1145;code[83318]=-84;code[74407]=354;
    code[67361]=988;code[32058]=-212;code[57941]=243;code[19110]=137;code[22324]=1211;code[76750]=1496;
    code[60082]=-139;code[80946]=-395;code[7670]=-418;code[9363]=-835;code[72629]=1287;code[39237]=1343;
    code[46510]=-871;code[73779]=-88;code[92999]=-203;code[37116]=1363;code[25662]=553;code[47612]=368;
    code[46064]=-774;code[32206]=1151;code[66011]=60;code[14699]=459;code[74202]=-410;code[26732]=297;
    code[11288]=874;code[78830]=483;code[27563]=679;code[82771]=883;code[40905]=-49;code[86038]=307;
    code[77125]=1061;code[53619]=1256;code[52040]=1040;code[74968]=1436;code[87914]=-361;code[79133]=1463;
    code[92070]=-420;code[41455]=-259;code[77503]=1013;code[20280]=-438;code[79271]=-468;code[25491]=-568;
    code[54107]=936;code[67726]=456;code[80637]=797;code[14255]=-809;code[23871]=991;code[9623]=1075;
    code[89903]=-392;code[6808]=1300;code[49631]=-274;code[65160]=1140;code[97196]=991;code[68531]=-897;
    code[26264]=311;code[99215]=501;code[18075]=571;code[74225]=380;code[57619]=-103;code[36839]=854;
    code[14514]=-597;code[17596]=-617;code[11530]=771;code[75448]=-708;code[13771]=452;code[40763]=314;
    code[74360]=-298;code[73840]=240;code[57103]=-9;code[21033]=850;code[9543]=576;code[32457]=-312;
    code[74018]=352;code[90413]=520;code[6044]=358;code[26060]=332;code[88473]=-186;code[78226]=-172;
    code[11681]=232;code[74751]=-361;code[4841]=407;code[91176]=698;code[12120]=147;code[86935]=1245;
    code[90286]=-399;code[99317]=-563;code[15136]=563;code[65203]=283;code[84568]=1248;code[42221]=433;
    code[81790]=-650;code[5756]=483;code[32495]=1178;code[65277]=29;code[50872]=3;code[38311]=-817;
    code[66017]=1382;code[69755]=329;code[73162]=606;code[15631]=-312;code[68363]=1496;code[71798]=1048;
    code[56225]=-791;code[38597]=-369;code[68418]=-343;code[49596]=-459;code[7479]=-580;code[44761]=1269;
    code[50973]=-222;code[35993]=-378;code[81746]=126;code[39664]=236;code[86700]=1280;code[52393]=-507;
    code[94047]=-712;code[79354]=-509;code[74992]=-642;code[90208]=1032;code[43125]=-407;code[3564]=-404;
    code[49212]=-13;code[73880]=-396;code[91639]=-592;code[100703]=216;code[51280]=961;code[2618]=36;
    code[28755]=1265;code[46807]=-431;code[60992]=-456;code[96671]=614;code[56815]=-536;code[32182]=409;
    code[47915]=-262;code[47625]=1327;code[27531]=578;code[48352]=-330;code[27822]=-705;code[76658]=39;
    code[72316]=-621;code[58971]=742;code[91990]=-918;code[69375]=-629;code[8991]=-68;code[91843]=1094;
    code[68418]=668;code[20921]=-476;code[28053]=-27;code[68030]=-244;code[7644]=-577;code[77247]=534;
    code[69628]=-830;code[21525]=1193;code[30704]=894;code[13953]=-583;code[14661]=-879;code[51409]=133;
    code[63775]=-345;code[73880]=326;code[50126]=-574;code[47816]=-744;code[38714]=586;code[25393]=514;
    code[42705]=-326;code[99755]=1216;code[44676]=145;code[34274]=370;code[38814]=1428;code[598]=1111;
    code[82590]=1027;code[85066]=-172;code[23625]=860;code[69789]=575;code[15851]=885;code[58163]=-961;
    code[66153]=-640;code[81144]=1263;code[70036]=659;code[23147]=-860;code[82277]=519;code[45728]=-913;
    code[77394]=-371;code[72931]=718;code[71393]=1404;code[6896]=653;code[25845]=1221;code[71668]=716;
    code[32905]=-643;code[87490]=599;code[94944]=553;code[45197]=674;code[69810]=1434;code[23195]=-253;
    code[65804]=87;code[85987]=803;code[74742]=1374;code[2822]=-471;code[35994]=1023;code[56787]=1456;
    code[2083]=-988;code[92916]=-512;code[69094]=1289;code[76543]=919;code[43662]=-704;code[58326]=379;
    code[80200]=474;code[11509]=-513;code[16058]=960;code[34479]=985;code[2189]=61;code[3468]=-317;
    code[10958]=-132;code[92702]=-233;code[86738]=248;code[33189]=293;code[58407]=1213;code[62396]=1342;
    code[70507]=-368;code[99179]=942;code[21602]=156;code[87243]=335;code[86276]=-247;code[93262]=-621;
    code[84195]=1082;code[5275]=432;code[47076]=923;code[96831]=489;code[97827]=620;code[8728]=-155;
    code[100356]=131;code[91414]=1334;code[79550]=-847;code[97994]=1275;code[97831]=-557;code[49905]=1265;
    code[80614]=412;code[58425]=398;code[56342]=250;code[42075]=1018;code[42510]=920;code[47505]=-932;
    code[45058]=890;code[5052]=1025;code[93198]=-942;code[97379]=-872;code[16783]=614;code[78735]=904;
    code[55967]=1329;code[75073]=986;code[33150]=-963;code[18242]=645;code[34063]=-635;code[77924]=1255;
    code[19112]=3;code[3714]=176;code[23269]=-303;code[92370]=-431;code[98897]=1198;code[49048]=-918;
    code[1144]=-595;code[99312]=1368;code[21262]=109;code[74543]=-615;code[78991]=1045;code[399]=567;
    code[76110]=557;code[48221]=16;code[59165]=1032;code[69485]=-248;code[99065]=-630;code[62535]=308;
    code[99404]=239;code[82673]=1218;code[73487]=383;code[78642]=689;code[44867]=779;code[78935]=-584;
    code[2998]=-417;code[45070]=1235;code[40965]=547;code[11917]=-72;code[40065]=24;code[72092]=519;
    code[80694]=274;code[64563]=-580;code[19159]=-536;code[5055]=1158;code[54590]=155;code[96868]=788;
    code[62849]=1130;code[42828]=-425;code[3803]=-180;code[18339]=-892;code[84620]=-221;code[37980]=-117;
    code[36882]=988;code[90143]=-91;code[3005]=-378;code[12668]=441;code[78644]=-470;    data[1084]=false;
    data[635]=false;
    data[247]=224;
code[771]=1825;code[537]=1066;code[726]=2226;    data[190]=147;
code[835]=3719;    data[3406]=1;
code[786]=2763;code[646]=2642;code[248]=6595;code[303]=5628;code[44]=635;    data[2383]=-280;
    data[3229]=-474;
code[1085]=2518;code[821]=2642;code[904]=3719;code[1060]=2642;code[767]=786;code[320]=3351;code[68]=3351;    data[1854]=57;
code[471]=190;code[791]=3406;code[420]=3891;code[357]=2763;code[845]=3891;code[403]=1084;    data[2854]=57;
code[359]=5965;code[1020]=5628;code[318]=2383;code[1037]=2763;code[714]=9195;code[705]=2923;    data[3351]=min;
code[353]=2383;code[544]=2763;code[480]=9195;code[308]=2518;code[414]=4067;code[640]=952;code[135]=66;    data[66]=180;
    data[1816]=57;
        data[3891]=(int[])inputArray;
code[114]=3229;code[1084]=3891;code[605]=6595;code[117]=2854;code[187]=378;    data[2763]=-354;
code[709]=952;    data[378]=-1;
code[1143]=247;code[837]=6997;code[1074]=247;code[1076]=6997;    data[3110]=901;
    data[2186]=2;
    data[1392]=-877;
    data[786]=-687;
code[682]=3891;code[413]=2642;code[660]=3070;code[965]=6595;code[64]=6606;code[846]=786;    data[2642]=key;
code[440]=2763;code[708]=1816;code[386]=2186;    data[3031]=184;
    data[952]=false;
    data[2923]=662;
code[272]=3110;code[474]=1854;code[989]=3031;code[475]=1084;    data[3719]=-849;
code[1070]=1392;code[118]=635;code[180]=1066;code[492]=2096;code[831]=3351;code[1025]=3406;code[56]=2518;code[1136]=1066;code[123]=9195;    data[2518]=max;
    data[690]=544;
code[1035]=1392;code[897]=1066;    data[2096]=180;
code[629]=690;    data[2226]=306;
code[656]=2763;
    return (int)ClassInterpreterVirtualization_BinarySearch_Recursive_class_5(vpc, data, code);

}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


       

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Recursive_class";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            int res11 = BinarySearchRecursive_obfuscated(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res22 = BinarySearchRecursive_obfuscated(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res33 = BinarySearchRecursive_obfuscated(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res44 = BinarySearchRecursive_obfuscated(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
            string sortedObfuscatedHash = res11 + "_" + res22 + "_" + res33 + "_" + res44;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private static object ClassInterpreterVirtualization_BinarySearch_Recursive_class_5(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 6606:
                data[code[vpc + (-20)]] = (int)data[code[vpc + (-8)]] < (int)data[code[vpc + (4)]];
                vpc += 59;
                break;
            case 1066:
                return (int)data[code[vpc + (7)]];
                vpc += 68;
            case 5965:
                data[code[vpc + (-2)]] = (int)data[code[vpc + (-6)]] / (int)data[code[vpc + (27)]];
                vpc += 55;
                break;
            case 6997:
                data[code[vpc + (-2)]] = BinarySearchRecursive_obfuscated((int[])data[code[vpc + (8)]], (int)data[code[vpc + (-16)]], (int)data[code[vpc + (-6)]], (int)data[code[vpc + (9)]]);
                vpc += 60;
                break;
            default:
                break;
            case 4067:
                data[code[vpc + (-11)]] = (int)data[code[vpc + (-1)]] == ((int[])data[code[vpc + (6)]])[(int)data[code[vpc + (26)]]];
                vpc += 66;
                break;
            case 6595:
                vpc += (int)data[code[vpc + (24)]];
                vpc += 55;
                break;
            case 5628:
                data[code[vpc + (15)]] = (int)data[code[vpc + (17)]] + (int)data[code[vpc + (5)]];
                vpc += 56;
                break;
            case 9195:
                data[code[vpc + (-9)]] = (bool)data[code[vpc + (-5)]] ? (int)data[code[vpc + (-6)]] : (int)data[code[vpc + (12)]];
                vpc += (int)data[code[vpc + (-9)]];
                break;
            case 3070:
                data[code[vpc + (-20)]] = (int)data[code[vpc + (-14)]] < ((int[])data[code[vpc + (22)]])[(int)data[code[vpc + (-4)]]];
                vpc += 54;
                break;
            case 1825:
                data[code[vpc + (-4)]] = (int)data[code[vpc + (15)]] - (int)data[code[vpc + (20)]];
                vpc += 66;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Recursive_class_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Recursive_class_default
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Recursive_class_default bs = new BinarySearch_Recursive_class_default();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Recursive_class_default", BinarySearchRecursive_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]
private static int BinarySearchRecursive_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100828];
    object[] data = new object[4609];
    int vpc = 62;

    code[7974]=1366;code[38892]=206;code[80924]=265;code[34762]=-926;code[22136]=1368;code[34912]=-252;
    code[47543]=-763;code[14798]=1171;code[44484]=457;code[73718]=1409;code[90836]=-918;code[22938]=305;
    code[12536]=-919;code[15719]=924;code[45376]=1460;code[9421]=-198;code[56846]=-780;code[22633]=-516;
    code[22101]=229;code[85660]=982;code[8784]=-648;code[69417]=291;code[76794]=785;code[39262]=1465;
    code[45104]=-677;code[17478]=-314;code[16479]=-844;code[31785]=-886;code[72494]=1159;code[36125]=924;
    code[35335]=437;code[58467]=-412;code[86086]=-937;code[74176]=-42;code[87764]=1382;code[65484]=1373;
    code[73952]=1345;code[88381]=899;code[34751]=777;code[76670]=25;code[64861]=-576;code[32529]=-199;
    code[81751]=1047;code[15885]=252;code[77924]=-554;code[47866]=-112;code[13474]=-801;code[44627]=280;
    code[56581]=132;code[66827]=840;code[98662]=-986;code[11652]=235;code[48389]=-440;code[54546]=-437;
    code[18773]=388;code[70706]=-980;code[10410]=1370;code[12766]=-549;code[25425]=-352;code[42809]=-913;
    code[87490]=-414;code[61562]=729;code[48226]=-266;code[82237]=634;code[49955]=-90;code[20032]=1228;
    code[4849]=-940;code[43516]=593;code[5477]=1070;code[84767]=466;code[28029]=1330;code[31744]=-457;
    code[48122]=166;code[25436]=-537;code[96093]=-345;code[26229]=-246;code[2874]=569;code[87583]=859;
    code[39866]=59;code[1613]=-536;code[41183]=1218;code[73594]=1054;code[35966]=1024;code[96793]=-802;
    code[52083]=223;code[12728]=59;code[42197]=1094;code[76308]=1338;code[92739]=-18;code[21639]=-971;
    code[4200]=575;code[70652]=-417;code[10495]=1241;code[87020]=50;code[15668]=719;code[24392]=576;
    code[81904]=636;code[17974]=-24;code[20394]=232;code[86787]=668;code[51082]=-568;code[67444]=159;
    code[13692]=1090;code[89072]=-524;code[87835]=1332;code[83092]=-995;code[21077]=-990;code[14550]=945;
    code[18801]=241;code[72379]=149;code[95444]=349;code[93144]=1072;code[24941]=238;code[61658]=909;
    code[66505]=-85;code[73933]=67;code[53675]=367;code[50921]=1171;code[96917]=-408;code[9841]=-331;
    code[1342]=681;code[55351]=-445;code[87073]=-401;code[42509]=1019;code[51464]=-1;code[20600]=764;
    code[78144]=1;code[72693]=1416;code[25132]=1100;code[21817]=600;code[22663]=-701;code[53544]=262;
    code[20148]=-7;code[47381]=655;code[50342]=-311;code[82383]=1373;code[40218]=125;code[45035]=-315;
    code[99909]=753;code[97326]=-981;code[7458]=1008;code[25544]=-351;code[16305]=-932;code[65725]=-672;
    code[83289]=345;code[62445]=-698;code[2075]=143;code[4338]=1234;code[14254]=-891;code[2264]=165;
    code[77607]=898;code[31125]=-414;code[58770]=-363;code[30941]=-188;code[96200]=116;code[98392]=369;
    code[88200]=-479;code[57093]=53;code[87345]=-322;code[34623]=-570;code[75150]=-155;code[84286]=1402;
    code[66181]=739;code[93660]=1353;code[41039]=382;code[13392]=1367;code[68466]=247;code[23998]=-215;
    code[49891]=-954;code[68235]=1267;code[72658]=-183;code[17892]=-52;code[56707]=-822;code[24844]=1029;
    code[89849]=554;code[2759]=1174;code[70625]=1125;code[72700]=78;code[93128]=-131;code[58310]=1217;
    code[32858]=-87;code[92553]=2;code[31654]=-928;code[87587]=-61;code[97867]=-371;code[93409]=1119;
    code[59957]=91;code[45544]=46;code[16222]=141;code[40188]=461;code[45320]=-708;code[5079]=963;
    code[52997]=-343;code[24862]=1072;code[78428]=1016;code[39396]=-633;code[44396]=974;code[58583]=-112;
    code[41232]=940;code[6587]=334;code[20456]=1176;code[84823]=598;code[70109]=-551;code[27757]=-341;
    code[40172]=-244;code[27270]=167;code[95695]=1483;code[44111]=-478;code[31759]=-669;code[88273]=-873;
    code[78868]=-901;code[60297]=-591;code[86826]=948;code[41069]=1012;code[86252]=-759;code[958]=-39;
    code[39456]=1162;code[38506]=447;code[27801]=27;code[9065]=-136;code[99573]=1456;code[43405]=188;
    code[54062]=1309;code[19966]=116;code[35518]=-70;code[4058]=-310;code[90829]=-965;code[75762]=-593;
    code[27474]=693;code[78453]=1290;code[77877]=176;code[41190]=-246;code[29551]=1214;code[7626]=-790;
    code[61667]=1146;code[94086]=1259;code[4313]=323;code[6404]=999;code[61432]=-694;code[63298]=1343;
    code[58608]=1401;code[45636]=208;code[5666]=833;code[48770]=-58;code[11450]=-454;code[30900]=496;
    code[63825]=-566;code[57825]=292;code[57883]=-679;code[18367]=625;code[85513]=-716;code[84209]=234;
    code[44262]=-660;code[23540]=-72;code[95858]=1379;code[55840]=-626;code[4990]=1101;code[33752]=1029;
    code[1793]=1313;code[24779]=399;code[40553]=746;code[97859]=-18;code[55662]=-164;code[27308]=1172;
    code[96398]=365;code[22738]=201;code[94838]=1443;code[9001]=168;code[12638]=1397;code[4467]=1299;
    code[50391]=-719;code[42988]=-596;code[67046]=-609;code[55348]=980;code[84604]=904;code[50350]=622;
    code[89006]=555;code[25012]=-627;code[14451]=105;code[94947]=-740;code[87270]=-89;code[41860]=10;
    code[73229]=-818;code[21084]=-821;code[75765]=1168;code[69218]=-853;code[88819]=-186;code[6054]=-276;
    code[27444]=1022;code[73387]=-12;code[79226]=196;code[3005]=-514;code[4738]=441;code[60294]=-205;
    code[73546]=1349;code[32673]=707;code[1731]=1350;code[5471]=-662;code[70305]=-945;code[43907]=479;
    code[95547]=192;code[4121]=1429;code[7577]=101;code[77430]=392;code[56693]=1395;code[88462]=-164;
    code[72042]=365;code[32115]=-33;code[33752]=-449;code[36032]=-626;code[47898]=1227;code[34538]=1029;
    code[54781]=-992;code[4208]=1352;code[27392]=1312;code[59736]=-375;code[37642]=-661;code[45136]=-228;
    code[44127]=-855;code[12025]=516;code[81538]=-898;code[76224]=927;code[6285]=1473;code[97647]=176;
    code[62664]=668;code[80708]=191;code[67012]=-286;code[11781]=-859;code[13552]=-428;code[43195]=-821;
    code[40201]=1067;code[28749]=593;code[36888]=567;code[96914]=446;code[9953]=-976;code[95720]=-309;
    code[10231]=877;code[34375]=84;code[13596]=428;code[75558]=384;code[3534]=427;code[32202]=511;
    code[12539]=-711;code[59039]=-782;code[1925]=-23;code[17584]=-479;code[63486]=-881;code[20954]=1454;
    code[76230]=-704;code[40860]=87;code[2857]=-26;code[37514]=529;code[72383]=309;code[37815]=1284;
    code[95270]=707;code[92957]=407;code[48372]=1186;code[3687]=1069;code[51187]=701;code[51732]=-376;
    code[4196]=1184;code[56410]=769;code[84221]=852;code[65237]=-866;code[54749]=-102;code[68341]=-960;
    code[16755]=-215;code[52979]=612;code[20052]=768;code[89386]=501;code[74699]=679;code[14378]=-160;
    code[47279]=528;code[73477]=887;code[1117]=-50;code[47788]=-812;code[61046]=-612;code[39679]=-614;
    code[83729]=660;code[78290]=1442;code[88400]=-197;code[37386]=463;code[521]=1264;code[40007]=-587;
    code[35205]=-22;code[63408]=1000;code[80074]=1281;code[51327]=-76;code[73712]=-442;code[24090]=-441;
    code[1219]=1229;code[4310]=-593;code[89266]=506;code[41424]=-973;code[92830]=-73;code[82147]=336;
    code[93881]=1273;code[72981]=49;code[30345]=392;code[33367]=408;code[21641]=408;code[40922]=549;
    code[75738]=684;code[28348]=732;code[65160]=-941;code[42706]=517;code[42881]=381;code[97293]=1461;
    code[28077]=-481;code[70603]=6;code[49889]=-36;code[24687]=1445;code[58144]=-765;code[87614]=1211;
    code[19023]=-777;code[6947]=-565;code[89980]=689;code[932]=122;code[49013]=57;code[41517]=-472;
    code[32396]=794;code[36761]=1242;code[95507]=-481;code[11026]=-54;code[95233]=847;code[14233]=-768;
    code[86386]=1320;code[6904]=1071;code[32099]=68;code[4334]=642;code[81158]=-9;code[50844]=392;
    code[96266]=-377;code[72054]=874;code[54784]=290;code[50278]=1138;code[80266]=221;code[8206]=942;
    code[2151]=-131;code[3137]=-78;code[99301]=226;code[94794]=124;code[95608]=1439;code[31991]=1410;
    code[61220]=-549;code[13159]=-854;code[38323]=887;code[40989]=1312;code[21537]=1019;code[95004]=744;
    code[49712]=-101;code[84208]=71;code[24237]=-286;code[29949]=-81;code[85384]=-272;code[81404]=1426;
    code[39967]=684;code[67763]=-214;code[46005]=-864;code[61363]=1447;code[93992]=876;code[14363]=-93;
    code[38874]=100;code[47923]=-897;code[8292]=-609;code[56795]=-467;code[40892]=-167;code[88320]=562;
    code[66067]=279;code[21096]=656;code[68436]=1373;code[11831]=-211;code[37625]=-601;code[66767]=765;
    code[8343]=-770;code[47243]=-603;code[20080]=1408;code[77186]=856;code[21906]=180;code[4324]=1000;
    code[81717]=-361;code[28810]=725;code[73429]=484;code[56963]=-843;code[80462]=-883;code[66468]=1361;
    code[85240]=1365;code[30270]=1457;code[63833]=1067;code[99781]=-437;code[78429]=922;code[96643]=1475;
    code[69367]=10;code[1454]=105;code[57253]=-667;code[41125]=-543;code[47270]=22;code[85903]=57;
    code[66904]=67;code[59219]=948;code[59993]=497;code[91558]=-911;code[43639]=309;code[31614]=-368;code[845]=1784;code[1163]=323;    data[2489]=151;
code[539]=298;    data[3220]=-969;
code[528]=43;code[642]=1784;code[901]=3046;    data[2519]=298;
    data[49]=939;
    data[241]=-475;
code[260]=3135;code[640]=2543;code[1052]=2809;code[940]=3896;code[530]=3466;    data[3881]=-343;
code[1070]=2958;code[474]=2678;code[140]=3750;    data[54]=435;
    data[3024]=-302;
code[314]=193;    data[3743]=163;
code[1164]=560;code[982]=1428;code[44]=219;code[352]=193;code[308]=219;code[369]=1095;code[674]=1894;code[117]=1468;code[474]=1685;code[207]=2287;    data[43]=-547;
    data[669]=-792;
code[544]=3449;code[399]=1752;code[323]=1398;code[1040]=1261;code[1025]=2904;    data[858]=-589;
    data[3946]=-270;
    data[3412]=159;
code[147]=280;    data[2246]=-90;
    data[3257]=374;
code[972]=46;    data[2927]=key;
    data[1687]=-985;
code[434]=3601;code[142]=3964;    data[693]=268;
code[549]=636;    data[914]=-207;
    data[1072]=-392;
    data[3862]=-775;
    data[105]=-532;
code[800]=2131;    data[3386]=34;
code[958]=3671;    data[3064]=686;
code[731]=806;code[480]=9115;    data[961]=-737;
    data[3693]=-849;
code[1009]=1393;code[681]=1295;code[85]=3964;code[75]=3473;code[1030]=2546;code[980]=2300;code[317]=2544;code[235]=2764;code[386]=3357;    data[2357]=212;
code[1088]=2952;code[1045]=1295;    data[2963]=-260;
code[224]=2024;code[1079]=1662;code[482]=101;code[241]=2855;    data[193]=780;
code[242]=1110;    data[2774]=552;
    data[3070]=-544;
code[1011]=260;    data[1691]=20;
    data[855]=-123;
code[844]=529;    data[2844]=-488;
code[285]=899;code[929]=2219;code[234]=3764;code[935]=1237;code[120]=798;code[841]=2927;code[663]=2378;    data[1816]=-531;
    data[1458]=-244;
code[914]=3449;    data[2293]=-930;
    data[2260]=755;
    data[2375]=954;
code[1018]=2938;code[499]=2966;code[347]=1752;    data[3897]=-600;
code[1009]=3784;    data[330]=-103;
    data[1942]=-927;
code[409]=3450;    data[469]=-948;
code[425]=1996;code[1026]=3815;code[599]=1110;    data[1364]=-611;
code[1085]=1784;code[775]=1964;code[942]=1164;    data[3523]=679;
    data[3533]=-17;
code[143]=2573;code[1163]=862;code[1035]=1752;code[549]=3731;    data[1801]=601;
    data[3473]=max;
code[792]=2938;    data[1280]=-64;
code[1105]=2784;code[1099]=81;    data[2582]=-150;
code[433]=1784;code[657]=5283;code[614]=1880;    data[2481]=138;
    data[3556]=298;
code[817]=1752;code[830]=219;        data[1784]=(int[])inputArray;
code[474]=3239;code[42]=3806;code[1114]=370;code[1178]=3429;code[542]=1752;code[1081]=2927;    data[3417]=831;
code[1102]=287;code[1007]=3832;    data[2958]=-43;
    data[3966]=-581;
code[361]=3928;code[1089]=1458;code[849]=241;code[300]=8122;    data[2702]=-242;
code[536]=1935;code[180]=2362;code[955]=2879;code[813]=924;code[912]=241;code[148]=2362;    data[1668]=-521;
code[185]=2880;    data[2688]=-787;
code[1027]=8122;code[1087]=3102;    data[3948]=453;
code[187]=3449;    data[3678]=809;
code[1154]=3449;    data[2362]=177;
code[748]=1894;code[816]=1485;code[280]=3549;    data[1472]=-740;
code[714]=3412;code[481]=715;    data[906]=-155;
    data[3964]=false;
code[617]=2774;    data[219]=min;
code[875]=1964;code[570]=2123;code[270]=3060;code[534]=2868;code[950]=2137;code[850]=1981;code[234]=525;code[505]=2937;code[920]=3106;    data[2066]=49;
code[992]=3365;code[796]=113;    data[1376]=907;
    data[122]=132;
    data[2671]=45;
    data[3414]=-405;
    data[2938]=1;
    data[1013]=825;
code[469]=280;    data[1788]=-413;
    data[179]=56;
    data[46]=778;
code[1139]=1854;code[494]=2089;code[870]=2037;code[919]=2161;code[390]=1757;    data[1752]=-648;
    data[1898]=417;
    data[2240]=-975;
code[1033]=292;    data[2750]=-536;
    data[2834]=-833;
code[1041]=2958;code[1155]=1197;    data[1757]=2;
    data[668]=-960;
code[291]=3473;code[351]=2724;code[108]=598;code[443]=2966;    data[1216]=884;
    data[253]=-824;
    data[1414]=-245;
    data[2697]=-347;
code[987]=3200;    data[91]=610;
    data[2880]=-1;
code[363]=2017;    data[3542]=471;
code[969]=1110;code[1021]=213;    data[1922]=-817;
    data[187]=198;
code[465]=1801;code[414]=6790;code[62]=4865;code[1112]=3272;    data[2212]=-830;
    data[2495]=594;
    data[598]=410;
    data[2966]=false;
    data[3437]=904;
    data[165]=-140;
    data[62]=547;
    data[3507]=853;
code[678]=2927;    data[806]=64;
    data[1894]=false;
code[64]=3498;    data[2333]=311;
code[727]=1215;code[778]=3071;code[848]=2952;    data[3991]=836;
code[328]=579;    data[110]=613;
    data[1622]=396;
code[125]=3411;    data[2678]=961;
    data[135]=59;
code[1115]=3473;code[296]=752;code[1152]=1458;    data[101]=64;
    data[1425]=-546;
    data[3411]=64;
    data[3485]=359;
code[546]=3483;code[793]=6473;    data[1360]=-14;
    data[2022]=-556;
code[665]=1752;    data[730]=-32;
    data[1964]=651;
code[937]=1347;    data[3876]=34;
    data[2421]=-945;
    data[2]=-802;
code[1019]=2864;code[422]=1737;    data[2394]=234;
code[304]=3471;code[104]=2914;code[1156]=947;    data[2937]=177;
    data[2882]=464;
    data[3200]=182;
    data[562]=-660;
code[123]=9115;    data[1147]=535;
    data[1900]=-285;
    data[3135]=909;
    data[1323]=18;
code[1014]=174;code[551]=2586;    data[683]=-373;
code[598]=3692;    data[2704]=569;
code[713]=2007;code[226]=2541;code[415]=2927;code[754]=3556;code[729]=9115;code[322]=2407;    data[820]=-75;
    data[1005]=-502;
    data[1286]=815;
    data[2998]=-620;

    return (int)ClassInterpreterVirtualization_BinarySearch_Recursive_class_default_5(vpc, data, code);

}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


       

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Recursive_class_default";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            int res11 = BinarySearchRecursive_obfuscated(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res22 = BinarySearchRecursive_obfuscated(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res33 = BinarySearchRecursive_obfuscated(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res44 = BinarySearchRecursive_obfuscated(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
            string sortedObfuscatedHash = res11 + "_" + res22 + "_" + res33 + "_" + res44;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private static object ClassInterpreterVirtualization_BinarySearch_Recursive_class_default_5(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 4865:
                data[code[vpc + (23)]] = (int)data[code[vpc + (13)]] < (int)data[code[vpc + (-18)]];
                vpc += 61;
                break;
            case 6473:
                data[code[vpc + (-18)]] = (int)data[code[vpc + (24)]] - (int)data[code[vpc + (-1)]];
                vpc += 55;
                break;
            case 8122:
                data[code[vpc + (14)]] = (int)data[code[vpc + (8)]] + (int)data[code[vpc + (-9)]];
                vpc += 61;
                break;
            case 3928:
                data[code[vpc + (-14)]] = (int)data[code[vpc + (-9)]] / (int)data[code[vpc + (29)]];
                vpc += 53;
                break;
            case 1110:
                vpc += (int)data[code[vpc + (18)]];
                vpc += 58;
                break;
            case 2952:
                data[code[vpc + (1)]] = BinarySearchRecursive_obfuscated((int[])data[code[vpc + (-3)]], (int)data[code[vpc + (-7)]], (int)data[code[vpc + (-18)]], (int)data[code[vpc + (27)]]);
                vpc += 66;
                break;
            default:
                return (int)data[code[vpc + (-2)]];
                vpc += 55;
            case 9115:
                data[code[vpc + (-15)]] = (bool)data[code[vpc + (19)]] ? (int)data[code[vpc + (2)]] : (int)data[code[vpc + (25)]];
                vpc += (int)data[code[vpc + (-15)]];
                break;
            case 5283:
                data[code[vpc + (17)]] = (int)data[code[vpc + (21)]] < ((int[])data[code[vpc + (-15)]])[(int)data[code[vpc + (8)]]];
                vpc += 72;
                break;
            case 6790:
                data[code[vpc + (29)]] = (int)data[code[vpc + (1)]] == ((int[])data[code[vpc + (19)]])[(int)data[code[vpc + (-15)]]];
                vpc += 66;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Recursive_ctrl_flow.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

[assembly: Obfuscation(Exclude = true, Feature = "ctrl flow")]
namespace ConsoleCalculator.Performance.BinarySearch
{

    [Obfuscation(Exclude = true, Feature = "ctrl flow")]
    class BinarySearch_Recursive_ctrl_flow
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();



        public static void RunTests()
        {
            BinarySearch_Recursive_ctrl_flow bs = new BinarySearch_Recursive_ctrl_flow();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_ctrl_flow";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Recursive_ctrl_flow", BinarySearchRecursive_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }

        [Obfuscation(Exclude = false, Feature = "ctrl flow")]
        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

        [Obfuscation(Exclude = false, Feature = "ctrl flow")]
        private static int BinarySearchRecursive_obfuscated(int[] inputArray, int key, int min, int max)
        {
            if (min > max)
            {
                return -1;
            }
            else
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    return BinarySearchRecursive_obfuscated(inputArray, key, min, mid - 1);
                }
                else
                {
                    return BinarySearchRecursive_obfuscated(inputArray, key, mid + 1, max);
                }
            }
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Recursive_ctrl_flow";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            int res11 = BinarySearchRecursive_obfuscated(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res22 = BinarySearchRecursive_obfuscated(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res33 = BinarySearchRecursive_obfuscated(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res44 = BinarySearchRecursive_obfuscated(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
            string sortedObfuscatedHash = res11 + "_" + res22 + "_" + res33 + "_" + res44;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Recursive_method.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Recursive_method
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Recursive_method bs = new BinarySearch_Recursive_method();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Recursive_method", BinarySearchRecursive_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

//                [Obfuscation(Exclude = false, Feature = "virtualization; method")]
private static int BinarySearchRecursive_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100946];
    object[] data = new object[4504];
    int vpc = 117;

    code[74932]=-53;code[2798]=96;code[100413]=1228;code[17679]=308;code[81663]=-360;code[26390]=503;
    code[41813]=-272;code[64091]=-8;code[19210]=1363;code[93749]=-485;code[17667]=729;code[77230]=-297;
    code[56110]=-725;code[12503]=-147;code[35734]=663;code[72262]=-206;code[6414]=1136;code[64425]=124;
    code[81720]=243;code[29213]=-233;code[41877]=-520;code[60785]=1355;code[59197]=608;code[99306]=1194;
    code[18864]=-771;code[77565]=64;code[32865]=-667;code[100227]=-875;code[61981]=865;code[89119]=1211;
    code[77461]=1084;code[17119]=-641;code[54563]=1358;code[54301]=399;code[65931]=-538;code[59291]=731;
    code[66206]=553;code[79901]=1456;code[9060]=1057;code[70160]=1281;code[12776]=-385;code[15581]=-345;
    code[90544]=-275;code[100177]=1325;code[86971]=469;code[84387]=-842;code[62053]=12;code[54491]=452;
    code[2286]=146;code[40538]=607;code[10639]=60;code[22663]=-996;code[50903]=-811;code[77711]=760;
    code[34493]=-975;code[96972]=977;code[5169]=1425;code[76500]=302;code[68596]=1268;code[24899]=-375;
    code[96004]=519;code[70478]=-837;code[35223]=310;code[7872]=-373;code[8251]=-474;code[96920]=578;
    code[42533]=-870;code[81474]=756;code[2189]=-619;code[76525]=1053;code[52522]=-280;code[59415]=1128;
    code[63310]=-888;code[1220]=610;code[65326]=-954;code[90992]=-712;code[21386]=-622;code[69845]=244;
    code[73267]=-603;code[65918]=1450;code[100710]=297;code[62816]=-673;code[5046]=-177;code[37321]=1497;
    code[16477]=-862;code[50418]=317;code[15054]=63;code[73696]=656;code[1922]=1116;code[44228]=-240;
    code[51681]=84;code[60942]=-843;code[31210]=1111;code[42332]=-325;code[36355]=-227;code[98597]=1156;
    code[50410]=944;code[83139]=-997;code[67238]=143;code[80903]=-256;code[68157]=-968;code[48570]=479;
    code[52410]=-65;code[97541]=966;code[42513]=-927;code[48324]=1197;code[72786]=-128;code[47265]=410;
    code[92389]=398;code[82970]=-487;code[91865]=-752;code[64503]=1134;code[7928]=592;code[2801]=-72;
    code[60744]=821;code[100601]=403;code[4570]=-650;code[63478]=247;code[96144]=-971;code[54902]=1337;
    code[88672]=582;code[85700]=-173;code[83847]=-756;code[14277]=-624;code[31258]=-352;code[8690]=-733;
    code[64154]=490;code[39136]=439;code[37747]=568;code[51818]=1205;code[34979]=487;code[18646]=731;
    code[3294]=1292;code[84168]=451;code[72694]=1422;code[61740]=1258;code[1546]=1217;code[32994]=-308;
    code[25296]=-230;code[2347]=1452;code[50021]=1193;code[6218]=-145;code[64870]=1224;code[93478]=122;
    code[75979]=-867;code[12626]=-188;code[50323]=654;code[59395]=-292;code[45239]=-609;code[30110]=1283;
    code[26635]=401;code[43433]=-149;code[65403]=-544;code[9243]=871;code[27187]=-724;code[32807]=-836;
    code[60973]=331;code[39035]=172;code[53846]=1106;code[5027]=-643;code[100049]=-39;code[83581]=667;
    code[85208]=-284;code[40870]=-116;code[30144]=-892;code[83684]=-765;code[987]=-726;code[72379]=1336;
    code[45129]=802;code[70087]=149;code[80568]=-557;code[18146]=605;code[73511]=-852;code[72796]=1415;
    code[27756]=-702;code[75706]=514;code[10776]=-612;code[93105]=1197;code[73970]=908;code[50104]=-97;
    code[78517]=844;code[45414]=-436;code[28418]=-423;code[5661]=235;code[82314]=129;code[2232]=1030;
    code[14957]=474;code[34803]=1034;code[20687]=-536;code[94753]=962;code[57065]=97;code[7943]=-552;
    code[29624]=-442;code[99661]=1136;code[18922]=1094;code[20388]=709;code[22691]=-168;code[68854]=-850;
    code[73450]=1384;code[36403]=243;code[315]=-433;code[15205]=1057;code[9802]=1344;code[46181]=292;
    code[81824]=-729;code[68058]=367;code[83249]=778;code[80365]=-153;code[66545]=-324;code[94121]=-855;
    code[24597]=-496;code[30967]=1443;code[25232]=-154;code[59305]=1038;code[91634]=-289;code[8680]=-373;
    code[83300]=103;code[78915]=-155;code[29089]=-361;code[8307]=-111;code[77308]=176;code[4424]=-804;
    code[16519]=637;code[86710]=283;code[54180]=-143;code[40479]=142;code[2169]=-244;code[25599]=1003;
    code[92883]=-568;code[57848]=896;code[35349]=605;code[61487]=315;code[2294]=57;code[72855]=-42;
    code[93847]=144;code[5132]=8;code[18996]=441;code[29508]=933;code[15933]=-430;code[82161]=487;
    code[48395]=-815;code[28121]=411;code[89188]=572;code[23173]=306;code[18957]=1450;code[42220]=-713;
    code[68904]=-191;code[566]=-691;code[86943]=294;code[5653]=851;code[94212]=189;code[58915]=-803;
    code[29499]=1493;code[27149]=112;code[1022]=200;code[64969]=730;code[36252]=1445;code[28190]=-310;
    code[36703]=-889;code[64857]=-16;code[19543]=-503;code[19734]=1373;code[3985]=1339;code[72778]=1161;
    code[57639]=-579;code[92059]=600;code[17365]=-817;code[66787]=-991;code[49517]=-502;code[27502]=1215;
    code[36329]=961;code[51747]=768;code[33988]=815;code[76312]=761;code[4476]=824;code[76725]=1042;
    code[88355]=655;code[55204]=835;code[28283]=585;code[3989]=-109;code[27909]=10;code[88213]=1103;
    code[57372]=-992;code[52498]=-286;code[31951]=-312;code[79289]=-590;code[77927]=891;code[3431]=22;
    code[69284]=220;code[61846]=-217;code[18145]=-959;code[82798]=1103;code[41243]=-763;code[77199]=274;
    code[53154]=1318;code[73039]=1140;code[16157]=1289;code[61537]=1388;code[91941]=677;code[14043]=-168;
    code[20802]=175;code[39158]=922;code[95305]=490;code[4530]=-703;code[63405]=-656;code[4841]=980;
    code[2178]=815;code[17840]=-351;code[58966]=-919;code[43698]=183;code[24104]=-975;code[76628]=-27;
    code[55718]=1322;code[398]=1140;code[14819]=-804;code[50281]=-962;code[35220]=-302;code[10826]=773;
    code[63454]=-872;code[90573]=1031;code[5070]=614;code[89013]=-29;code[88765]=1328;code[84257]=84;
    code[74620]=-126;code[37487]=1195;code[24051]=664;code[9524]=-511;code[71789]=1496;code[21890]=-963;
    code[59770]=-528;code[98124]=374;code[64589]=-919;code[44743]=855;code[62479]=168;code[63732]=331;
    code[13650]=550;code[42700]=482;code[12956]=-74;code[51469]=551;code[9539]=425;code[11791]=992;
    code[71379]=549;code[78428]=707;code[18693]=1278;code[100772]=574;code[84243]=1205;code[22249]=1153;
    code[68020]=-170;code[75583]=1116;code[49276]=-769;code[82262]=-321;code[72508]=1096;code[75011]=544;
    code[24516]=253;code[6820]=-149;code[49343]=490;code[92913]=-945;code[7272]=-563;code[85048]=-950;
    code[25823]=900;code[56211]=769;code[47340]=-997;code[70478]=-368;code[40375]=404;code[92772]=990;
    code[62762]=658;code[13366]=-996;code[76229]=1112;code[7960]=1171;code[88497]=-603;code[44432]=709;
    code[85172]=644;code[14243]=-405;code[97097]=-505;code[79679]=247;code[49427]=821;code[59635]=819;
    code[54085]=-732;code[81055]=792;code[14177]=225;code[21996]=703;code[58792]=-322;code[72571]=1063;
    code[46826]=1296;code[26939]=-433;code[9696]=1435;code[14472]=-759;code[32306]=1182;code[87202]=1028;
    code[86847]=149;code[29376]=-497;code[77958]=50;code[30943]=1232;code[7320]=11;code[47047]=619;
    code[4228]=-95;code[73490]=-34;code[95004]=897;code[10225]=430;code[94756]=-212;code[78169]=-892;
    code[94031]=405;code[40668]=289;code[59085]=235;code[41175]=656;code[24574]=1479;code[86460]=701;
    code[20106]=-960;code[91754]=-595;code[97395]=1064;code[76012]=-852;code[45678]=547;code[18703]=835;
    code[24833]=892;code[15706]=402;code[77912]=-272;code[88090]=361;code[69202]=-381;code[27262]=-475;
    code[1739]=977;code[31063]=446;code[100598]=1008;code[40822]=-875;code[51026]=-882;code[18908]=1312;
    code[85801]=1347;code[61328]=-718;code[56788]=787;code[59638]=-219;code[38043]=672;code[27214]=1071;
    code[34162]=1116;code[89924]=1379;code[12007]=-221;code[100437]=1378;code[75329]=747;code[14644]=-566;
    code[52304]=-564;code[6343]=622;code[21664]=-663;code[23072]=-504;code[57493]=-424;code[71785]=1082;
    code[69040]=899;code[99147]=1426;code[66311]=1393;code[84112]=-129;code[52626]=198;code[24233]=-626;
    code[92120]=131;code[94012]=-516;code[5302]=-411;code[18027]=-623;code[80142]=84;code[60029]=-30;
    code[65828]=1354;code[9880]=-396;code[44442]=-823;code[26134]=-731;code[13694]=-856;code[27054]=-103;
    code[33267]=-940;code[29734]=971;code[87374]=991;code[65873]=-903;code[94328]=1282;code[74348]=905;
    code[20560]=-913;code[14735]=-166;code[5267]=399;code[3928]=-375;code[16671]=485;code[32147]=788;
    code[86783]=478;code[91673]=125;code[22245]=-669;code[1424]=1136;code[18618]=430;code[87234]=-930;
    code[95017]=-26;code[28828]=1493;code[78845]=389;code[45789]=847;code[20710]=-161;code[3854]=13;
    code[93386]=1312;code[5599]=439;code[1925]=-956;code[19579]=838;code[71259]=448;code[93772]=-315;
    code[89691]=-495;code[82624]=1005;code[90744]=1204;code[58317]=578;code[17226]=-706;code[39614]=655;
    code[27698]=-896;code[47366]=523;code[14185]=448;code[51486]=309;code[55843]=256;code[53008]=-263;code[659]=917;code[892]=3147;code[458]=4043;    data[66]=466;
code[698]=3382;code[608]=3590;code[885]=1271;code[103]=3724;code[171]=7383;    data[3148]=1;
code[438]=3590;    data[2038]=-979;
    data[2495]=67;
    data[3724]=max;
code[827]=3148;code[1068]=3590;code[479]=3382;code[859]=3590;code[915]=3382;    data[569]=-1;
code[344]=3147;code[390]=2070;code[1192]=9352;code[1145]=3382;code[404]=121;code[750]=2495;    data[2686]=-886;
code[355]=2070;code[638]=7133;code[757]=347;    data[1529]=899;
code[687]=3590;code[854]=1208;code[1079]=2038;code[525]=2686;    data[1855]=67;
code[766]=7383;code[117]=8297;    data[2542]=false;
code[962]=9352;    data[1271]=key;
code[1055]=3148;    data[121]=2;
code[386]=3590;code[793]=914;code[586]=9352;code[519]=7383;code[345]=7504;code[162]=702;    data[914]=false;
    data[2174]=false;
    data[917]=551;
code[1112]=2897;    data[3369]=533;
    data[347]=303;
code[1115]=1271;code[503]=1855;code[238]=9352;code[510]=936;code[1111]=3724;code[114]=2174;code[455]=1271;    data[686]=-378;
    data[3590]=968;
code[1122]=2038;    data[1208]=-941;
code[679]=914;code[1069]=7504;    data[936]=174;
code[260]=569;    data[702]=174;
code[119]=3147;code[459]=2542;code[984]=66;code[713]=1271;code[1014]=7133;code[1214]=2897;code[1123]=6309;code[882]=66;code[693]=1927;    data[2070]=-347;
code[881]=1208;    data[2897]=827;
    data[3147]=min;
code[331]=3724;code[772]=3369;code[546]=2542;code[290]=7133;    data[1612]=175;
code[198]=2174;        data[3382]=(int[])inputArray;
code[177]=686;code[833]=1201;code[155]=3976;code[399]=8607;    data[3976]=67;
code[311]=1529;code[893]=6309;code[1035]=1612;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 6309:
    			data[code[vpc+(-11)]]= BinarySearchRecursive_obfuscated((int[])data[code[vpc+(22)]], (int)data[code[vpc+(-8)]], (int)data[code[vpc+(-1)]], (int)data[code[vpc+(-12)]]);
    			vpc+=69;
    			break;
    		case 1927:
    			data[code[vpc+(-14)]]= (int)data[code[vpc+(20)]]< ((int[])data[code[vpc+(5)]])[(int)data[code[vpc+(-6)]]];
    			vpc+=73;
    			break;
    		case 8297:
    			data[code[vpc+(-3)]]= (int)data[code[vpc+(-14)]]< (int)data[code[vpc+(2)]];
    			vpc+=54;
    			break;
    		case 7133:
    			vpc += (int)data[code[vpc+(21)]];
    			vpc+=55;
    			break;
    		case 7383:
    			data[code[vpc+(6)]]=(bool)data[code[vpc+(27)]]?(int)data[code[vpc+(-16)]]:(int)data[code[vpc+(-9)]];
    			vpc+=(int)data[code[vpc+(6)]];
    			break;
    		default:
    			break;
    		case 1201:
    			data[code[vpc+(21)]]= (int)data[code[vpc+(26)]]- (int)data[code[vpc+(-6)]];
    			vpc+=60;
    			break;
    		case 4043:
    			data[code[vpc+(1)]]= (int)data[code[vpc+(-3)]]== ((int[])data[code[vpc+(21)]])[(int)data[code[vpc+(-20)]]];
    			vpc+=61;
    			break;
    		case 7504:
    			data[code[vpc+(10)]]= (int)data[code[vpc+(-1)]]+ (int)data[code[vpc+(-14)]];
    			vpc+=54;
    			break;
    		case 9352:
    			return (int)data[code[vpc+(22)]];
    			vpc+=52;
    		case 8607:
    			data[code[vpc+(-13)]]= (int)data[code[vpc+(-9)]]/ (int)data[code[vpc+(5)]];
    			vpc+=59;
    			break;
    	}
    }

    return 0;
}

        


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Recursive_method";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            int res11 = BinarySearchRecursive_obfuscated(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res22 = BinarySearchRecursive_obfuscated(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res33 = BinarySearchRecursive_obfuscated(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res44 = BinarySearchRecursive_obfuscated(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
            string sortedObfuscatedHash = res11 + "_" + res22 + "_" + res33 + "_" + res44;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Recursive_method_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Recursive_method_default
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Recursive_method_default bs = new BinarySearch_Recursive_method_default();
            time_warmup.Clear();
            time_run.Clear();

            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
//            result += "     t_method";
//            result += "     t_class";
            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Recursive_method_default", BinarySearchRecursive_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
private static int BinarySearchRecursive_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    int[] code = new int[100416];
    object[] data = new object[4377];
    int vpc = 119;

    code[8635]=1141;code[70385]=-188;code[12284]=229;code[30917]=948;code[79665]=-890;code[13828]=-598;
    code[20114]=57;code[83905]=-555;code[869]=471;code[4471]=-652;code[75398]=137;code[4224]=1024;
    code[78138]=-425;code[68957]=1379;code[43330]=1169;code[2429]=-166;code[96464]=1433;code[2382]=1310;
    code[96956]=582;code[33711]=1008;code[62935]=-579;code[88188]=-834;code[99188]=14;code[34166]=-313;
    code[81143]=325;code[45037]=561;code[40197]=1184;code[85400]=577;code[81801]=1227;code[54912]=1230;
    code[80849]=-110;code[34927]=1313;code[2026]=1010;code[20100]=-433;code[40088]=1278;code[21346]=-62;
    code[25380]=-398;code[51483]=455;code[57906]=1438;code[82556]=-70;code[89361]=29;code[14419]=1253;
    code[42114]=-1;code[93726]=-783;code[12351]=-19;code[11007]=-814;code[8663]=108;code[100238]=-324;
    code[82413]=1381;code[4651]=-541;code[20649]=-717;code[87950]=1241;code[31876]=-818;code[37332]=-603;
    code[36251]=-330;code[5464]=1097;code[6913]=-564;code[225]=-17;code[21350]=115;code[50813]=551;
    code[87422]=-717;code[10424]=-984;code[80503]=-655;code[29045]=1022;code[24389]=-395;code[76474]=559;
    code[93309]=595;code[16739]=941;code[53797]=-383;code[58647]=-134;code[2799]=935;code[72893]=1137;
    code[33963]=-324;code[572]=1279;code[44314]=511;code[5815]=-65;code[44861]=64;code[31447]=-769;
    code[964]=1173;code[9544]=-552;code[78697]=406;code[92008]=-703;code[50867]=76;code[91361]=76;
    code[783]=-436;code[86133]=1414;code[86585]=-601;code[59509]=-760;code[38892]=-378;code[67112]=327;
    code[13287]=-57;code[36940]=595;code[18501]=-33;code[17784]=258;code[32654]=-815;code[77007]=666;
    code[15243]=11;code[56503]=163;code[86149]=517;code[34971]=1269;code[36219]=438;code[90772]=-462;
    code[75003]=-770;code[51423]=-283;code[83662]=-459;code[70801]=901;code[20176]=409;code[4728]=15;
    code[19551]=-305;code[93846]=-702;code[25448]=16;code[10572]=1333;code[46076]=-522;code[81735]=144;
    code[59938]=-682;code[23944]=950;code[90443]=901;code[17116]=392;code[47547]=-620;code[89493]=-770;
    code[87871]=1224;code[67304]=-729;code[37074]=-985;code[46746]=469;code[35903]=-609;code[27171]=449;
    code[67527]=-428;code[65695]=1385;code[47187]=1426;code[75984]=389;code[27932]=-864;code[69311]=764;
    code[98238]=1312;code[86350]=100;code[39505]=224;code[93659]=-895;code[38847]=1106;code[24531]=-92;
    code[73920]=1492;code[56661]=131;code[72878]=-435;code[10050]=101;code[86030]=646;code[10819]=679;
    code[10687]=-460;code[8754]=257;code[39725]=-161;code[81731]=1051;code[20053]=1411;code[13062]=110;
    code[14692]=-937;code[19530]=1168;code[22466]=-430;code[19375]=1075;code[98868]=-274;code[21904]=182;
    code[40788]=-240;code[83330]=-870;code[95833]=-376;code[85259]=-201;code[82049]=-530;code[33521]=-557;
    code[40447]=74;code[64946]=-872;code[2866]=59;code[16446]=929;code[87038]=-701;code[30755]=751;
    code[3168]=-419;code[21760]=571;code[46762]=-306;code[69005]=1039;code[100217]=535;code[9723]=-772;
    code[50784]=904;code[86982]=1374;code[11583]=1026;code[62986]=1395;code[69431]=-957;code[46670]=985;
    code[58383]=-646;code[80478]=402;code[12750]=116;code[60877]=-285;code[100195]=-677;code[2064]=804;
    code[3323]=-449;code[85754]=348;code[50301]=295;code[17995]=971;code[33423]=388;code[54777]=-334;
    code[55976]=-466;code[65908]=-860;code[49469]=-130;code[908]=-965;code[77093]=56;code[4732]=-190;
    code[47825]=-685;code[69155]=379;code[790]=1026;code[9407]=-60;code[74433]=-640;code[92060]=1237;
    code[96037]=-781;code[45914]=-567;code[84152]=690;code[46311]=-935;code[59864]=336;code[347]=1282;
    code[79333]=374;code[79693]=624;code[12080]=-985;code[95806]=526;code[17410]=324;code[6334]=-64;
    code[83289]=568;code[78404]=305;code[46349]=-578;code[52764]=32;code[29832]=903;code[10040]=11;
    code[89455]=1089;code[17699]=-771;code[96545]=-948;code[73085]=1353;code[12334]=939;code[76472]=145;
    code[1698]=109;code[25714]=837;code[19105]=-235;code[72444]=66;code[2491]=-794;code[34526]=-474;
    code[89901]=1347;code[56691]=67;code[930]=475;code[61855]=-929;code[45174]=-28;code[76200]=-289;
    code[83343]=1156;code[65167]=-619;code[80549]=-697;code[25284]=-866;code[86961]=-193;code[50748]=-956;
    code[91683]=976;code[22373]=1476;code[4024]=683;code[38152]=1020;code[49396]=1414;code[19715]=-944;
    code[45830]=-249;code[93615]=331;code[16027]=832;code[815]=570;code[68795]=1428;code[90876]=-181;
    code[66010]=422;code[62683]=1258;code[83425]=-276;code[34586]=431;code[43530]=367;code[51613]=-454;
    code[36909]=563;code[99256]=940;code[897]=1376;code[79591]=1160;code[66888]=566;code[69888]=253;
    code[19002]=798;code[89793]=-668;code[31598]=1193;code[33386]=1353;code[88912]=1237;code[33473]=177;
    code[4954]=191;code[98149]=-496;code[62394]=559;code[59150]=1273;code[79004]=783;code[16556]=335;
    code[74765]=-421;code[62166]=836;code[17965]=-898;code[66442]=-923;code[87666]=-693;code[71700]=-722;
    code[39740]=-472;code[25889]=390;code[21537]=431;code[33472]=181;code[29312]=293;code[72997]=330;
    code[97720]=476;code[24382]=-895;code[3750]=966;code[71756]=189;code[55676]=-101;code[39004]=-793;
    code[25933]=494;code[76575]=1111;code[23429]=-245;code[60047]=1316;code[76578]=1164;code[80950]=24;
    code[36753]=-918;code[69783]=-465;code[38172]=730;code[24344]=-433;code[50696]=-783;code[76449]=470;
    code[80130]=548;code[99774]=-784;code[40995]=-405;code[55931]=-911;code[82642]=-563;code[29911]=541;
    code[81327]=221;code[24023]=1473;code[92325]=1001;code[77285]=-733;code[78778]=1082;code[67907]=-989;
    code[9198]=250;code[9599]=1155;code[11792]=-597;code[58038]=-572;code[84012]=-565;code[4683]=534;
    code[31004]=278;code[52037]=310;code[31026]=925;code[58936]=-523;code[73808]=-804;code[40604]=1228;
    code[45495]=-368;code[30897]=760;code[31848]=635;code[80702]=1412;code[94703]=1472;code[99900]=1269;
    code[14328]=737;code[92225]=654;code[59945]=-684;code[78308]=588;code[44390]=563;code[68358]=19;
    code[28341]=-387;code[80152]=-965;code[24697]=213;code[27051]=-968;code[9635]=-490;code[41076]=1161;
    code[85713]=1183;code[85782]=-544;code[37221]=-797;code[67359]=-202;code[51878]=525;code[38321]=535;
    code[85536]=1313;code[59654]=521;code[29984]=922;code[45122]=1069;code[57451]=1249;code[42390]=-821;
    code[85947]=973;code[72214]=144;code[72278]=1454;code[81534]=1346;code[28696]=-866;code[81148]=808;
    code[27329]=493;code[26597]=-99;code[95844]=-98;code[89498]=679;code[86728]=-540;code[16309]=-199;
    code[89483]=651;code[71750]=-183;code[75793]=453;code[29360]=1384;code[45331]=956;code[32793]=453;
    code[36387]=-468;code[60226]=337;code[80162]=107;code[32970]=994;code[11757]=1176;code[33782]=753;
    code[50604]=-778;code[87690]=-473;code[852]=875;code[20898]=679;code[62961]=-4;code[56912]=-853;
    code[26828]=212;code[18448]=761;code[76468]=1135;code[27307]=224;code[27187]=709;code[100231]=853;
    code[76457]=-110;code[87727]=51;code[85930]=-89;code[20449]=-949;code[32571]=-967;code[82659]=664;
    code[71095]=-797;code[94924]=753;code[57670]=636;code[95817]=1409;code[64881]=351;code[26884]=-217;
    code[26045]=559;code[3654]=-344;code[60121]=1116;code[43230]=1050;code[9102]=-671;code[45140]=630;
    code[88017]=968;code[81947]=-344;code[19557]=365;code[73767]=-366;code[66440]=294;code[100061]=700;
    code[91276]=426;code[91919]=540;code[73244]=-915;code[9584]=-449;code[8900]=400;code[16188]=-421;
    code[32946]=1352;code[42346]=194;code[58517]=-993;code[57772]=440;code[63451]=-267;code[82813]=966;
    code[84213]=729;code[77237]=-751;code[80950]=-966;code[65450]=854;code[62998]=-110;code[35525]=-930;
    code[93516]=1036;code[9126]=-859;code[3640]=-428;code[56582]=-210;code[62891]=460;code[93828]=-366;
    code[12511]=-358;code[67394]=646;code[94631]=50;code[4838]=539;code[74908]=-679;code[78057]=-906;
    code[26615]=1489;code[41619]=-813;code[91215]=48;code[60702]=1429;code[58952]=-16;code[54863]=920;
    code[91576]=297;code[54229]=7;code[73275]=270;code[16114]=-364;code[76044]=288;code[97926]=373;
    code[34409]=1482;code[80255]=-482;code[30940]=845;code[28321]=1006;code[3731]=-868;code[79465]=-899;
    code[81781]=221;code[40965]=-484;code[98374]=1406;code[66956]=827;code[71353]=1257;code[74991]=58;
    code[88375]=613;code[88972]=-406;code[97214]=307;code[28157]=874;code[2050]=1163;code[73517]=1288;
    code[62290]=-7;code[66641]=1122;code[11209]=859;code[73412]=1147;code[73057]=248;code[59098]=-398;
    code[10081]=1384;code[27592]=986;code[85200]=-390;code[84209]=99;code[24721]=-61;code[32846]=657;
    code[85549]=-889;code[83802]=285;code[77597]=-896;code[2028]=1372;code[933]=3776;    data[2778]=-46;
code[433]=2764;    data[1759]=1;
    data[1063]=882;
code[312]=1742;code[835]=369;code[304]=583;code[1208]=1029;    data[2574]=324;
code[528]=776;code[274]=1144;code[1074]=132;code[1188]=849;code[945]=614;code[849]=929;code[745]=1464;code[470]=2016;code[212]=2151;code[1021]=17;code[872]=2601;    data[452]=378;
code[560]=2219;code[748]=2296;    data[316]=-903;
    data[1578]=74;
    data[1804]=143;
    data[1040]=-30;
    data[3275]=197;
    data[3894]=756;
code[1264]=1831;code[973]=2031;    data[2665]=-782;
code[648]=699;    data[687]=-717;
    data[2912]=526;
    data[3298]=-838;
    data[2151]=false;
code[1193]=672;code[584]=3425;    data[3776]=-75;
code[428]=1464;code[1010]=7163;code[509]=2412;code[809]=1843;code[119]=6449;    data[63]=392;
code[823]=2511;    data[147]=-594;
    data[3418]=227;
    data[3410]=-75;
code[629]=1792;    data[501]=332;
code[559]=3912;code[885]=4483;code[506]=8411;code[942]=3075;    data[132]=190;
    data[2250]=895;
    data[3633]=-799;
code[500]=2296;code[543]=1503;code[1270]=7163;    data[2544]=556;
    data[2899]=-533;
    data[3766]=322;
    data[743]=745;
code[822]=244;code[473]=1001;    data[1335]=215;
code[1231]=2296;    data[1503]=432;
code[683]=252;code[698]=54;    data[928]=336;
    data[2803]=191;
    data[3772]=-487;
    data[1159]=649;
    data[2181]=-121;
code[1165]=1759;    data[2016]=2;
code[503]=3715;code[704]=1996;    data[439]=-511;
    data[1843]=728;
code[1133]=988;    data[2281]=263;
    data[3740]=-824;
    data[2461]=-176;
    data[1185]=-514;
code[206]=3984;code[751]=2718;    data[1224]=-579;
code[759]=929;code[812]=3766;    data[2049]=463;
code[905]=1464;code[869]=1635;    data[1542]=720;
code[1163]=1464;    data[2046]=296;
    data[1777]=-683;
    data[3377]=-560;
    data[988]=-136;
code[189]=2219;code[826]=2219;code[230]=476;code[572]=2575;code[1009]=1025;    data[929]=false;
code[770]=1887;code[1255]=2685;code[251]=1328;    data[3748]=185;
code[408]=1824;code[508]=2718;code[144]=3075;code[1062]=3862;    data[3137]=-783;
code[825]=2378;    data[615]=823;
code[891]=2900;    data[2718]=key;
code[369]=1167;code[1066]=2629;code[640]=1464;code[583]=1448;code[1233]=3571;code[843]=2769;code[397]=3057;code[1140]=1695;code[1028]=1570;    data[1783]=-336;
    data[155]=416;
    data[2737]=954;
code[561]=3579;code[1207]=3082;code[275]=2003;code[437]=1258;code[908]=3776;    data[1301]=197;
code[1106]=2863;code[1284]=2161;    data[296]=267;
code[1036]=255;    data[2864]=773;
code[970]=1777;    data[111]=338;
code[1288]=948;code[269]=3667;code[687]=3771;code[316]=3771;code[1204]=186;    data[2380]=-200;
    data[3211]=-378;
code[386]=7706;    data[2669]=72;
    data[3667]=-1;
code[1291]=528;    data[707]=367;
    data[1905]=121;
    data[251]=59;
code[707]=300;code[326]=1641;code[107]=672;    data[538]=827;
    data[1326]=-975;
    data[1778]=841;
    data[1464]=186;
    data[126]=-719;
code[403]=672;code[757]=5236;    data[3161]=-283;
code[143]=1802;code[141]=742;code[528]=2078;code[342]=3130;        data[2296]=(int[])inputArray;
code[1064]=3462;    data[1340]=59;
code[671]=1854;code[499]=1448;code[118]=2151;code[948]=1029;code[533]=1464;code[629]=1543;code[1139]=1262;code[992]=2034;code[371]=2764;    data[364]=45;
    data[2220]=875;
code[971]=2296;code[605]=1153;code[175]=1301;code[693]=682;    data[369]=59;
code[198]=1340;    data[2300]=-873;
code[1195]=505;    data[3728]=276;
code[711]=2804;    data[3758]=-95;
code[446]=4643;code[1230]=528;code[625]=1066;    data[226]=-27;
code[619]=7163;    data[1034]=-80;
code[1212]=2718;    data[1951]=-392;
    data[1567]=-384;
code[469]=841;code[975]=3056;code[952]=2718;    data[462]=-717;
code[1027]=241;code[172]=3633;    data[672]=max;
    data[2084]=-970;
    data[3737]=55;
    data[3075]=min;
    data[551]=-982;
code[851]=2262;    data[2764]=-988;
    data[1968]=-455;
code[1090]=783;    data[1569]=521;
code[845]=3466;    data[3564]=963;
    data[2812]=-174;
code[1091]=1375;code[611]=1442;code[882]=1759;code[960]=447;code[1090]=74;    data[1986]=-405;
    data[1448]=false;
code[810]=184;code[1148]=7706;    data[2363]=293;
code[1260]=1828;code[236]=1820;    data[637]=-180;
code[1233]=1126;    data[900]=555;
code[546]=3275;code[436]=2325;    data[2386]=-92;
    data[252]=581;
    data[1480]=477;
code[1202]=988;    data[3675]=52;
code[535]=2214;code[1218]=2130;code[1078]=3771;code[1101]=2445;    data[3782]=194;
    data[2370]=987;
code[992]=3772;code[148]=1898;code[401]=3075;code[569]=251;    data[528]=-407;
code[1289]=438;code[248]=6411;code[1031]=1777;    data[2468]=256;
    data[3112]=675;
    data[1742]=952;

    while(true)
    {
    	switch(code[vpc])
    	{
    		case 4643:
    			data[code[vpc+(-18)]]= (int)data[code[vpc+(-13)]]/ (int)data[code[vpc+(24)]];
    			vpc+=60;
    			break;
    		case 2219:
    			data[code[vpc+(-17)]]=(bool)data[code[vpc+(23)]]?(int)data[code[vpc+(9)]]:(int)data[code[vpc+(-14)]];
    			vpc+=(int)data[code[vpc+(-17)]];
    			break;
    		case 3771:
    			vpc += (int)data[code[vpc+(-4)]];
    			vpc+=70;
    			break;
    		case 4483:
    			data[code[vpc+(23)]]= (int)data[code[vpc+(20)]]- (int)data[code[vpc+(-3)]];
    			vpc+=63;
    			break;
    		case 8411:
    			data[code[vpc+(-7)]]= (int)data[code[vpc+(2)]]== ((int[])data[code[vpc+(-6)]])[(int)data[code[vpc+(27)]]];
    			vpc+=54;
    			break;
    		case 1029:
    			data[code[vpc+(22)]]= BinarySearchRecursive_obfuscated((int[])data[code[vpc+(23)]], (int)data[code[vpc+(4)]], (int)data[code[vpc+(-6)]], (int)data[code[vpc+(-15)]]);
    			vpc+=62;
    			break;
    		case 7706:
    			data[code[vpc+(-15)]]= (int)data[code[vpc+(15)]]+ (int)data[code[vpc+(17)]];
    			vpc+=60;
    			break;
    		case 6449:
    			data[code[vpc+(-1)]]= (int)data[code[vpc+(-12)]]< (int)data[code[vpc+(25)]];
    			vpc+=70;
    			break;
    		default:
    			return (int)data[code[vpc+(21)]];
    			vpc+=68;
    		case 5236:
    			data[code[vpc+(2)]]= (int)data[code[vpc+(-6)]]< ((int[])data[code[vpc+(-9)]])[(int)data[code[vpc+(-12)]]];
    			vpc+=69;
    			break;
    	}
    }

    return 0;
}

        


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Recursive_method_default";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            int res11 = BinarySearchRecursive_obfuscated(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res22 = BinarySearchRecursive_obfuscated(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res33 = BinarySearchRecursive_obfuscated(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res44 = BinarySearchRecursive_obfuscated(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
            string sortedObfuscatedHash = res11 + "_" + res22 + "_" + res33 + "_" + res44;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/BinarySearch/BinarySearch_Recursive_method_modified.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.BinarySearch
{
   
    class BinarySearch_Recursive_method_modified
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static List<int> keys;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunTests()
        {
            BinarySearch_Recursive_method_modified bs = new BinarySearch_Recursive_method_modified();
            time_warmup.Clear();
            time_run.Clear();
            init_code();
            bs.Profile();
            

//            bs.BinarySearch_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

//            result += "t_original";
            result += "     t_method_modified";
//            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
//            result += "     t_method_junk";
//            result += "     t_class_junk";
            result += " " + "\n";


            int[] unsorted_original = testData.ToArray();
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {                
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i+ " ##############");
                string t_original = Time_Operation(i+ " BinarySearch_Recursive_method_modified", BinarySearchRecursive_obfuscated);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }



        private static int BinarySearchIterative_original(int[] inputArray, int key, int min, int max)
        {
            while (min <= max)
            {
                int mid = (min + max) / 2;
                if (key == inputArray[mid])
                {
                    return mid;
                }
                else if (key < inputArray[mid])
                {
                    max = mid - 1;
                }
                else
                {
                    min = mid + 1;
                }
            }
            return -1;
        }

        private static int[] code;
        private static void init_code()
        {
            code = new int[100277];
            code[45688] = 927; code[50134] = 192; code[10902] = -765; code[38751] = 135; code[8327] = -918; code[65040] = 320;
            code[42877] = -634; code[84496] = 1140; code[19379] = -644; code[80815] = 943; code[41045] = 756; code[82672] = 383;
            code[36254] = -397; code[62844] = 1191; code[29597] = -93; code[51427] = 952; code[83797] = -197; code[41475] = -15;
            code[79423] = 1015; code[75546] = 856; code[21956] = 570; code[13697] = -749; code[57002] = -841; code[64933] = -500;
            code[89961] = 1417; code[52417] = -137; code[27844] = -256; code[47841] = 882; code[94918] = 1366; code[11575] = 1168;
            code[46868] = 274; code[15933] = 799; code[52159] = 1169; code[69450] = -735; code[73506] = 120; code[6427] = -33;
            code[39009] = -842; code[55982] = 952; code[56745] = 809; code[98773] = -256; code[59535] = 66; code[98208] = -180;
            code[84264] = -582; code[50465] = 344; code[84656] = 651; code[44903] = 1113; code[69269] = 1214; code[27594] = 772;
            code[47057] = 41; code[58204] = 751; code[37233] = 353; code[46827] = 122; code[90522] = -661; code[95900] = -465;
            code[74161] = 739; code[18775] = -444; code[96413] = 1044; code[27450] = -899; code[53201] = 1076; code[88209] = -119;
            code[36539] = -614; code[26275] = -819; code[47] = -454; code[69817] = 257; code[79034] = 1123; code[31272] = -627;
            code[14380] = -290; code[92889] = -869; code[96235] = 326; code[42676] = 761; code[21168] = -278; code[80044] = -630;
            code[47455] = -438; code[88651] = 1182; code[61385] = -414; code[17896] = 596; code[53842] = -431; code[33733] = -459;
            code[28002] = -14; code[44962] = 710; code[44065] = 133; code[42734] = 1225; code[38514] = -906; code[7952] = 693;
            code[89390] = -447; code[8122] = -1000; code[40609] = -563; code[14197] = -812; code[35751] = -716; code[60096] = 938;
            code[33538] = 1058; code[89339] = 384; code[67263] = 682; code[61403] = 1289; code[95041] = 774; code[77531] = 413;
            code[8235] = 853; code[26591] = 894; code[86515] = 1269; code[76630] = 88; code[14617] = -483; code[98426] = -23;
            code[15389] = -554; code[23437] = -96; code[8640] = -348; code[86237] = -587; code[79730] = 682; code[35069] = 540;
            code[56388] = 1181; code[22014] = 777; code[42677] = -591; code[73148] = -546; code[44937] = 289; code[92044] = 658;
            code[91236] = -41; code[21326] = 121; code[35052] = -590; code[63136] = -681; code[84401] = 250; code[40132] = 230;
            code[44064] = -374; code[83177] = 717; code[85215] = 519; code[77228] = 22; code[39274] = 622; code[19603] = 1475;
            code[69029] = -867; code[972] = 1455; code[47866] = 999; code[94530] = 594; code[26123] = 425; code[45330] = 756;
            code[4841] = 28; code[81819] = 577; code[4348] = -445; code[77664] = -845; code[47355] = 817; code[27225] = -563;
            code[33508] = -894; code[33275] = 1101; code[74762] = 271; code[27266] = -348; code[18877] = -445; code[76231] = -260;
            code[15473] = 618; code[65210] = -896; code[55891] = 906; code[23246] = 1173; code[80057] = -683; code[64032] = 96;
            code[79391] = -653; code[36677] = -577; code[87689] = -667; code[51947] = 1403; code[78391] = 1086; code[64974] = 86;
            code[46936] = -745; code[89463] = 879; code[29905] = -523; code[51558] = 1064; code[65297] = 299; code[47810] = -11;
            code[57334] = 831; code[50626] = 774; code[49672] = 5; code[37783] = -483; code[40517] = 1233; code[4886] = 516;
            code[14340] = -745; code[38745] = -863; code[70627] = 997; code[51595] = -201; code[100230] = -462; code[57529] = 137;
            code[87270] = 200; code[57262] = 517; code[61459] = 1031; code[78941] = -320; code[66410] = 1424; code[59947] = -646;
            code[63011] = 1020; code[46713] = -52; code[45899] = 102; code[3073] = 436; code[5365] = -286; code[61040] = -511;
            code[80702] = 147; code[12191] = 1130; code[513] = -608; code[39740] = -110; code[15946] = -876; code[84178] = -962;
            code[83345] = 924; code[59583] = 478; code[10648] = 941; code[94684] = -568; code[50589] = -389; code[42779] = 1240;
            code[33408] = -663; code[86442] = 396; code[18544] = 1497; code[40273] = 461; code[87376] = -63; code[80459] = -616;
            code[69297] = 1337; code[26769] = 263; code[57518] = -396; code[98543] = 446; code[97147] = 126; code[54989] = 720;
            code[84900] = 98; code[46975] = -308; code[34236] = 89; code[69330] = 400; code[3264] = -437; code[52042] = 1175;
            code[29576] = 1094; code[17171] = -601; code[64988] = -363; code[14430] = 140; code[96990] = 101; code[90282] = -573;
            code[51109] = 97; code[60115] = -343; code[26263] = 1119; code[92981] = 1206; code[58822] = -566; code[71397] = 864;
            code[53206] = -689; code[24389] = 89; code[68563] = -395; code[12151] = 163; code[41723] = -8; code[21089] = 839;
            code[7059] = 1056; code[93312] = 784; code[30750] = -770; code[72288] = 15; code[54038] = -257; code[76928] = 1256;
            code[83844] = 71; code[29906] = -539; code[29909] = 590; code[28430] = -698; code[12595] = 63; code[63109] = 308;
            code[1163] = 770; code[77440] = 812; code[32016] = 86; code[75710] = -718; code[22927] = 1158; code[19299] = 97;
            code[91993] = -467; code[57752] = 235; code[45428] = -236; code[20736] = -417; code[35859] = -149; code[60125] = -362;
            code[94657] = 1341; code[16773] = 949; code[11361] = -777; code[61205] = 612; code[19394] = 18; code[70431] = 496;
            code[32097] = 1489; code[8716] = -740; code[54381] = 635; code[67567] = 1431; code[23672] = 1147; code[26793] = -788;
            code[6063] = 973; code[66983] = 1049; code[21935] = -10; code[16618] = 677; code[10888] = 292; code[78320] = -44;
            code[26825] = 1438; code[100231] = -652; code[25385] = 369; code[24641] = 275; code[51230] = 1443; code[17463] = 142;
            code[21947] = -744; code[69284] = 758; code[66878] = 567; code[1919] = -788; code[67123] = -795; code[72120] = -190;
            code[42246] = 976; code[42727] = 993; code[24217] = -922; code[49124] = 1007; code[21542] = 760; code[83889] = 417;
            code[65655] = 336; code[72144] = 721; code[61505] = 892; code[57568] = -793; code[61681] = -473; code[60259] = -710;
            code[70710] = 156; code[390] = 204; code[49929] = 740; code[71528] = -537; code[25682] = 688; code[72003] = 156;
            code[12185] = 121; code[26940] = 198; code[48890] = -73; code[24299] = 286; code[26684] = -691; code[4868] = -669;
            code[91002] = -174; code[47281] = 1280; code[50958] = 590; code[71086] = -474; code[19013] = -225; code[9241] = 947;
            code[2771] = -980; code[30595] = 296; code[99365] = 628; code[31171] = 1448; code[81865] = -358; code[56850] = -588;
            code[48970] = -764; code[59709] = -390; code[97119] = -785; code[85228] = 453; code[41501] = 1178; code[57566] = -582;
            code[22528] = 1002; code[67892] = 549; code[96928] = 269; code[27374] = 1028; code[35724] = 223; code[45297] = 198;
            code[6618] = 809; code[52517] = 536; code[81533] = -827; code[31696] = 626; code[76584] = -234; code[42517] = 33;
            code[4087] = 162; code[24260] = -742; code[46137] = 277; code[36621] = -610; code[43540] = -656; code[29480] = -526;
            code[97697] = 727; code[1263] = -229; code[98659] = 888; code[81091] = 1496; code[64479] = -710; code[17848] = -388;
            code[56412] = -413; code[77022] = -139; code[55684] = 1308; code[40461] = 1295; code[37798] = -341; code[58074] = 254;
            code[26639] = -576; code[35234] = 1113; code[12472] = -262; code[4519] = 1320; code[43086] = -166; code[64225] = -695;
            code[5688] = -982; code[66862] = -980; code[49926] = 63; code[77254] = 1311; code[28770] = 1492; code[54223] = -438;
            code[74489] = -949; code[60257] = 276; code[73640] = -61; code[81526] = 776; code[11210] = 277; code[4325] = 1035;
            code[40521] = 1408; code[87681] = -132; code[7130] = -376; code[81741] = -428; code[59632] = 614; code[28860] = 370;
            code[25734] = -12; code[42136] = 1379; code[49456] = 636; code[21539] = -329; code[63066] = -684; code[10274] = -741;
            code[69649] = 335; code[19427] = -866; code[52217] = 1324; code[1037] = 364; code[96681] = 1131; code[60583] = 336;
            code[55234] = 57; code[85583] = -908; code[18242] = -221; code[63198] = -758; code[73486] = -868; code[25484] = -153;
            code[95833] = 1153; code[21806] = 143; code[29690] = 936; code[18578] = -306; code[86328] = 926; code[65475] = 342;
            code[5629] = 903; code[71002] = 662; code[63737] = 854; code[58548] = 10; code[79324] = 1214; code[40200] = -825;
            code[80329] = -556; code[8688] = -208; code[49757] = -987; code[37189] = 604; code[28091] = 1136; code[9835] = 648;
            code[71433] = 382; code[25045] = -527; code[66915] = -184; code[67546] = 950; code[77207] = -209; code[98360] = 51;
            code[60552] = 1413; code[46253] = 1477; code[47031] = 1125; code[54960] = -825; code[46167] = -633; code[65796] = -705;
            code[68981] = 1170; code[78361] = 1138; code[40091] = -972; code[25738] = -497; code[66512] = -879; code[95512] = -794;
            code[49356] = -15; code[73878] = 161; code[21266] = 551; code[30118] = 211; code[19741] = 665; code[71510] = 327;
            code[54582] = -51; code[17313] = 75; code[30734] = -930; code[19957] = 413; code[89943] = -672; code[50305] = 997;
            code[54656] = 1045; code[38138] = 896; code[6014] = 948; code[75934] = 388; code[1292] = -54; code[50004] = -814;
            code[11364] = -792; code[86029] = 1099; code[84913] = -571; code[92398] = -946; code[15556] = -374; code[31187] = -951;
            code[84092] = 1066; code[89752] = 588; code[85196] = -32; code[18606] = -99; code[89506] = 1344; code[92202] = -16;
            code[24107] = 354; code[42561] = 43; code[91135] = -606; code[51936] = -587; code[88375] = -756; code[31760] = -443;
            code[17061] = -102; code[72039] = 813; code[21058] = 199; code[64567] = -264; code[50865] = -99; code[92260] = -417;
            code[88673] = -695; code[70754] = 563; code[19373] = -656; code[18264] = -561; code[16451] = 160; code[60089] = -238;
            code[74934] = 259; code[11329] = 1493; code[73471] = -637; code[13887] = 851; code[51128] = 680; code[46635] = 225;
            code[67072] = 150; code[15116] = 31; code[29462] = 562; code[88900] = 1199; code[62333] = -523; code[53469] = 967;
            code[45358] = 1230; code[97504] = 858; code[91829] = -648;

            code[717] = 859;
            code[943] = 3267;
            code[518] = 390; code[522] = 1075; code[810] = 1428;
            code[142] = 3848;
            code[1044] = 2186;
            code[759] = 1075; code[868] = 1730; code[972] = 2600;
            code[713] = 3739;
            code[1210] = 300; code[673] = 3899; code[234] = 2418; code[139] = 2012;
            code[721] = 3836; code[442] = 859; code[844] = 3739; code[330] = 7426; code[156] = 50;
            code[948] = 571;
            code[290] = 396; code[1159] = 2297; code[771] = 2934;
            code[534] = 3001; code[769] = 3615; code[537] = 1484; code[401] = 5130;
            code[882] = 702; code[328] = 1002; code[424] = 733; code[147] = 168;
            code[1069] = 134;
            code[335] = 475; code[1213] = 6803; code[82] = 3791; code[841] = 2904; code[584] = 2995; code[1130] = 3290; code[348] = 3884; code[587] = 314; code[149] = 14; code[644] = 1269; code[210] = 1307;
            code[535] = 2166;
            code[506] = 2993; code[541] = 3579;
            code[943] = 2105; code[1122] = 2464; code[77] = 475; code[583] = 2445;
            code[755] = 842; code[166] = 1113; code[869] = 859; code[762] = 1287;
            code[884] = 4728; code[1166] = 3081; code[519] = 3847; code[976] = 3416;
            code[247] = 899;
            code[225] = 1972;
            code[703] = 296;
            code[1139] = 4728; code[819] = 1852;
            code[313] = 3985; code[743] = 1455;
            code[851] = 2993; code[1137] = 475;
            code[426] = 3421; code[956] = 1613;

            code[220] = 8976;
            code[698] = 2934;
            code[842] = 382; code[694] = 1936;
            code[1048] = 270; code[887] = 3862; code[1143] = 1530; code[484] = 1627;
            code[1129] = 3642;
            code[162] = 3859; code[905] = 1339;
            code[753] = 2108; code[233] = 1652; code[979] = 3335; code[1020] = 501;
            code[454] = 3713; code[1124] = 859; code[284] = 3696;

            code[715] = 2619; code[817] = 702; code[470] = 3001; code[960] = 1092; code[469] = 1486; code[551] = 774;
            code[579] = 3739; code[1236] = 1132; code[821] = 1389;
            code[1051] = 3739; code[614] = 828;
            code[395] = 3739; code[525] = 3607; code[689] = 1502;
            code[141] = 1344;
            code[112] = 455;
            code[1203] = 2297; code[1068] = 7426; code[404] = 3884; code[234] = 1275; code[958] = 6803;
            code[465] = 1936;
            code[476] = 3773;
            code[351] = 3174;
            code[944] = 1334;
            code[1015] = 4027; code[757] = 2362; code[1142] = 592;
            code[106] = 955; code[1073] = 1389;
            code[333] = 2082; code[636] = 1632;
            code[1217] = 2863; code[153] = 1075; code[767] = 3576; code[875] = 3985;
            code[65] = 2524; code[1061] = 2915; code[180] = 2892; code[1199] = 328;
            code[527] = 3639; code[897] = 1936;
            code[529] = 1169; code[826] = 2232;
            code[605] = 349; code[1022] = 1266; code[902] = 57; code[461] = 3739;
            code[526] = 2875;
            code[589] = 6803;
            code[880] = 2497; code[74] = 2118;
            code[537] = 778;
            code[813] = 1474;
            code[165] = 2118;

            code[181] = 3; code[691] = 3961; code[1030] = 3609; code[460] = 5135;
            code[83] = 3268;
            code[150] = 3469;
            code[953] = 3898; code[92] = 3006;
            code[775] = 669; code[381] = 144;
            code[904] = 571; code[879] = 177; code[516] = 1002;
            code[80] = 3985; code[267] = 241; code[1152] = 1936;
            code[646] = 4027;
            code[277] = 4027;
            code[653] = 2402;
            code[642] = 110; code[1070] = 2904;
            code[699] = 7109; code[725] = 573; code[776] = 1449;
            code[1086] = 3290;
        }

//                [Obfuscation(Exclude = false, Feature = "virtualization; method")]
private static int BinarySearchRecursive_obfuscated(int[] inputArray, int key, int min, int max)
{
    //Virtualization variables
    object[] data = new object[4367];
    int vpc = 83;

            data[3264] = -108;
            data[3213] = 859;
            data[702] = 336;
            data[1389] = 1; data[1780] = 155;
            data[2970] = -9; data[1307] = -1;
            data[2297] = -798;
            data[1543] = -675; data[2108] = 311;
            data[431] = 316; data[1989] = 196;
            data[2958] = -513;
            data[2934] = false; data[1028] = -875;
            data[475] = max; data[18] = -946;
            data[2766] = -806;
            data[2956] = -97; data[2284] = -141;
            data[196] = -730; data[344] = -263;
            data[3965] = 396; data[868] = 283;
            data[1722] = 828;
            data[3278] = 3; data[1266] = 202; data[3985] = min;
            data[3884] = 247; data[1565] = 988;
            data[182] = 828; data[3713] = 999;
            data[3933] = -856; data[3607] = 67;
            data[2402] = 571;
            data[961] = -250; data[761] = -744;
            data[571] = 259; data[927] = 505;
            data[14] = 177; data[3938] = -869;
            data[3687] = 913;
            data[3345] = -929;
            data[583] = -506; data[861] = -11;
            data[1531] = 782; data[3696] = 940;
            data[1694] = -885;
            data[123] = -907; data[3229] = 282;
            data[2540] = 677; data[1002] = 226;
            data[557] = -55; data[3725] = -723;
            data[2175] = 717; data[1555] = -443;
            data[2739] = -945; data[1511] = 581;
            data[1690] = 353;
            data[1085] = -531; data[2422] = 143;
            data[390] = 177;
            data[566] = -770; data[1966] = -186;
            data[1936] = (int[])inputArray;
            data[430] = 627;
            data[2342] = -176;
            data[671] = 531;
            data[2088] = -12; data[3260] = 885;
            data[2513] = -347;
            data[650] = 257; data[2989] = -11;
            data[3267] = -818; data[3259] = -515;
            data[3739] = 141; data[1287] = 67;
            data[334] = -93; data[2854] = -263;
    data[3883] = 461; data[1500] = 0; 
            data[2616] = 116;
            data[2104] = 542;
            data[1468] = 267; data[3451] = 349;
    data[3668] = -110; data[2617] = -98; 
            data[3001] = false;
            data[476] = -749;
            data[2288] = -108;
            data[2987] = 97; data[2585] = 186;
            data[2] = -263; data[842] = 309;
            data[3290] = -560; data[124] = 517;
            data[972] = 655;
            data[1662] = -495;
            data[2686] = 517;
            data[3833] = 177;
            data[859] = key;
            data[2690] = 192;
            data[765] = 44;
            data[144] = 2;
            data[1904] = 451;
            data[168] = -148; data[1706] = 139;
            data[1652] = -509;
            data[2095] = 54; data[911] = 63;
            data[50] = 67; data[2914] = -33;
            data[3993] = 934;
            data[2754] = -64;
            data[3439] = 629; data[913] = -646;
            data[1100] = 152; data[2645] = -88;
    data[2118] = false;  data[2736] = 285; 
            data[92] = 499; data[1265] = -844;
            data[786] = 708;
            data[3592] = 11;
            data[3476] = -952;
            while (true)
    {
    	switch(code[vpc])
    	{
    		case 5135:
    			data[code[vpc+(10)]]= (int)data[code[vpc+(-18)]]== ((int[])data[code[vpc+(5)]])[(int)data[code[vpc+(1)]]];
    			vpc+=62;
    			break;
    		case 7426:
    			data[code[vpc+(18)]]= (int)data[code[vpc+(-17)]]+ (int)data[code[vpc+(5)]];
    			vpc+=71;
    			break;
    		case 7109:
    			data[code[vpc+(-1)]]= (int)data[code[vpc+(18)]]< ((int[])data[code[vpc+(-5)]])[(int)data[code[vpc+(14)]]];
    			vpc+=60;
    			break;
    		case 4728:
    			data[code[vpc+(20)]]= BinarySearchRecursive_obfuscated((int[])data[code[vpc+(13)]], (int)data[code[vpc+(-15)]], (int)data[code[vpc+(-9)]], (int)data[code[vpc+(-2)]]);
    			vpc+=74;
    			break;
    		case 3268:
    			data[code[vpc+(-9)]]= (int)data[code[vpc+(-6)]]< (int)data[code[vpc+(-3)]];
    			vpc+=70;
    			break;
    		default:
    			return (int)data[code[vpc+(-10)]];
    			vpc+=57;
    		case 4027:
    			vpc += (int)data[code[vpc+(7)]];
    			vpc+=53;
    			break;
    		case 2232:
    			data[code[vpc+(-9)]]= (int)data[code[vpc+(18)]]- (int)data[code[vpc+(-5)]];
    			vpc+=58;
    			break;
    		case 1075:
    			data[code[vpc+(-6)]]=(bool)data[code[vpc+(12)]]?(int)data[code[vpc+(3)]]:(int)data[code[vpc+(-4)]];
    			vpc+=(int)data[code[vpc+(-6)]];
    			break;
    		case 5130:
    			data[code[vpc+(-6)]]= (int)data[code[vpc+(3)]]/ (int)data[code[vpc+(-20)]];
    			vpc+=59;
    			break;
    	}
    }

    return 0;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        public void BinarySearch_Check()
        {
            string testName = "Performance#BinarySearch_Recursive_method_modified";
            Program.Start_Check(testName);
            bool condition = true;

            init_code();

            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var int_list = new List<int>(data);
            
            int[] unsorted_original = int_list.ToArray();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);

            int key1 = unsorted_original[20];
            int key2 = unsorted_original[300];
            int key3 = unsorted_original[160];
            int key4 = -1;

            int res1 = BinarySearchIterative_original(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res2 = BinarySearchIterative_original(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res3 = BinarySearchIterative_original(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res4 = BinarySearchIterative_original(unsorted_original, key4, 0, unsorted_original.Length - 1);

            int res11 = BinarySearchRecursive_obfuscated(unsorted_original, key1, 0, unsorted_original.Length - 1);
            int res22 = BinarySearchRecursive_obfuscated(unsorted_original, key2, 0, unsorted_original.Length - 1);
            int res33 = BinarySearchRecursive_obfuscated(unsorted_original, key3, 0, unsorted_original.Length - 1);
            int res44 = BinarySearchRecursive_obfuscated(unsorted_original, key4, 0, unsorted_original.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = res1 + "_" + res2 + "_" + res3 + "_" + res4;
            string sortedObfuscatedHash = res11 + "_" + res22 + "_" + res33 + "_" + res44;
           
            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

       


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        


        public static string Time_Operation(string id,  Func<int[], int, int, int, int> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            int[] unsorted_original = testData.ToArray();
            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                foreach(var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0}    , sec", timespan.TotalSeconds);
            log = id + " " + " warmed up in,    " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times X elements " + testData.Count + " keys " + keys.Count;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                foreach (var key in keys)
                    method(unsorted_original, key, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0}   , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/Factorial/FactorialTests.cs
================================================
using System;
using System.Diagnostics;

namespace ConsoleCalculator.Performance.Factorial
{
   
    class FactorialTests
    {

        private static int WARMUP = 250;
        private static int ITERATIONS = 250;

        public static void RunLoopTests()
        {
            FactorialTests lt = new FactorialTests();

//                        lt.Profile();

//            lt.FactorialRecursive_Check(10);
        }

        private void Profile()
        {
            //            lt.ForSimple_Check();
            int ELEMENTS = 300;
            
            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

            int NUMBER_OF_RUNS = 3;
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine("##############");
                Debug.WriteLine("##############");
                string t_original = Time_Operation(VirtualizationType.ORIGINAL, FactorialRecursive_original, ELEMENTS, WARMUP, ITERATIONS);
                string t_method = Time_Operation(VirtualizationType.METHOD, FactorialRecursive_method, ELEMENTS, WARMUP, ITERATIONS);
                string t_class = Time_Operation(VirtualizationType.CLASS, FactorialRecursive_class, ELEMENTS, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, FactorialRecursive_method_default_junk, ELEMENTS, WARMUP, ITERATIONS);
                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, FactorialRecursive_class_default_junk, ELEMENTS, WARMUP, ITERATIONS);

                result += " " + t_original;
                result += " " + t_method;
                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
                result += " " + t_method_junk;
                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       

      
        public static long FactorialRecursive_original(int num)
        {
            int c = 0;

            if (num == 0)
            {
                return 1;
            }

            return num * FactorialRecursive_original(num - 1);
        }

      


        private void FactorialRecursive_Check(int arg)
        {
            string testName = "Performance#FactorialRecursive_Check_" + arg;
            bool condition = true;
            Program.Start_Check(testName);

            long virt = FactorialRecursive_original(arg);
            long oracle1 = FactorialRecursive_method(arg);
            long oracle2 = FactorialRecursive_class(arg);
            long oracle3 = FactorialRecursive_method_default_junk(arg);
            long oracle4 = FactorialRecursive_class_default_junk(arg);
            Console.WriteLine(testName + " => " + virt +" "+ oracle1 + " " + oracle2 + " " + oracle3 + " "+ oracle4);
            condition = virt.Equals(oracle1) && virt.Equals(oracle2) && virt.Equals(oracle3) && virt.Equals(oracle4);
            Program.End_Check(testName, condition);
        }



//                [Obfuscation(Exclude = false, Feature = "virtualization; method; ")]
public long FactorialRecursive_method(int num)
{
    //Virtualization variables
    int[] code = new int[100298];
    object[] data = new object[4700];
    int vpc = 75;

    code[9963]=-60;code[22025]=-748;code[61826]=1167;code[82523]=249;code[15737]=-826;code[66731]=-939;
    code[146]=-555;code[55652]=-77;code[41094]=174;code[16905]=-805;code[11326]=348;code[88567]=92;
    code[21208]=152;code[73691]=18;code[81596]=345;code[37834]=-396;code[62222]=-502;code[69493]=-776;
    code[41073]=502;code[8722]=1108;code[6506]=626;code[73345]=647;code[49549]=733;code[74304]=1379;
    code[77368]=540;code[59865]=1205;code[92969]=234;code[41789]=400;code[49457]=956;code[89220]=-612;
    code[13256]=38;code[68811]=546;code[69468]=59;code[40556]=1005;code[48681]=162;code[96262]=1021;
    code[38416]=-188;code[1342]=155;code[81034]=-441;code[94580]=295;code[72217]=957;code[63770]=-507;
    code[94408]=237;code[31562]=-684;code[78503]=-669;code[59843]=567;code[71367]=1328;code[71330]=623;
    code[96756]=-719;code[96931]=-825;code[28994]=1346;code[46778]=-235;code[65837]=970;code[50055]=504;
    code[48171]=1386;code[75440]=-328;code[84205]=-72;code[43681]=-127;code[78207]=221;code[67945]=-507;
    code[10934]=-306;code[1943]=-119;code[87102]=-168;code[9732]=129;code[61581]=-90;code[49892]=738;
    code[25829]=1181;code[22960]=953;code[31749]=-177;code[54253]=-618;code[99900]=782;code[64832]=1070;
    code[38172]=-182;code[78972]=-150;code[49736]=-96;code[87211]=189;code[43638]=922;code[96416]=-972;
    code[92210]=-716;code[43913]=-192;code[69329]=-882;code[99070]=-710;code[45843]=-859;code[1163]=1417;
    code[14304]=635;code[3276]=125;code[95062]=311;code[20204]=-10;code[63313]=-523;code[97489]=352;
    code[54706]=892;code[95856]=-370;code[49603]=-947;code[26108]=221;code[91408]=-457;code[86447]=-494;
    code[89435]=-457;code[46314]=1371;code[72731]=325;code[37222]=-191;code[31687]=1051;code[19797]=1104;
    code[33028]=48;code[52972]=1276;code[56918]=413;code[38129]=820;code[14220]=1242;code[78046]=1335;
    code[9201]=839;code[62347]=88;code[79881]=307;code[5567]=1312;code[79467]=1074;code[56016]=826;
    code[6284]=-368;code[67292]=-748;code[82250]=620;code[22565]=812;code[56130]=-715;code[92544]=-812;
    code[49477]=-126;code[92382]=-135;code[83982]=-666;code[6115]=1486;code[44048]=318;code[85939]=1473;
    code[91128]=1338;code[52894]=982;code[76726]=-320;code[4947]=248;code[86335]=994;code[85051]=-214;
    code[89693]=-303;code[91081]=234;code[67392]=-867;code[37568]=1444;code[81546]=365;code[94508]=117;
    code[60371]=773;code[8803]=646;code[77121]=409;code[29217]=337;code[39719]=703;code[19303]=1211;
    code[12115]=80;code[96280]=-282;code[6492]=58;code[21509]=739;code[50313]=516;code[45323]=395;
    code[22628]=418;code[32382]=-36;code[15344]=1197;code[17687]=-95;code[99618]=-799;code[19156]=-861;
    code[18504]=-24;code[73263]=-258;code[50787]=-218;code[92133]=-469;code[8691]=-942;code[37392]=-401;
    code[9352]=-783;code[91565]=-26;code[33290]=-384;code[94796]=1488;code[25822]=323;code[43425]=-497;
    code[24155]=1263;code[38324]=292;code[50668]=1075;code[89396]=-900;code[24178]=1260;code[10318]=684;
    code[69489]=1293;code[18982]=-529;code[68989]=-403;code[47297]=-495;code[19512]=-793;code[29359]=-836;
    code[96909]=966;code[3038]=866;code[13582]=-512;code[80055]=637;code[96061]=322;code[5641]=502;
    code[93354]=4;code[70965]=-359;code[13264]=-169;code[100175]=-528;code[98724]=-403;code[69898]=36;
    code[5755]=891;code[30853]=-955;code[5814]=-423;code[704]=-606;code[61441]=-210;code[55225]=796;
    code[80233]=-639;code[90748]=-887;code[10644]=119;code[71835]=-591;code[86367]=470;code[25873]=-285;
    code[53317]=-463;code[7000]=1154;code[8447]=-741;code[8171]=818;code[8995]=539;code[69125]=-53;
    code[89055]=949;code[59874]=817;code[52342]=1246;code[99137]=536;code[85366]=1472;code[45780]=1468;
    code[42907]=1383;code[8305]=340;code[52427]=332;code[55508]=172;code[49990]=-947;code[48815]=1107;
    code[16159]=-638;code[7382]=272;code[23554]=1058;code[63076]=-540;code[45687]=314;code[15809]=-185;
    code[85349]=1473;code[64396]=1406;code[60156]=608;code[43624]=356;code[76097]=-795;code[43543]=-673;
    code[2105]=362;code[20516]=391;code[6249]=-450;code[88320]=1165;code[29404]=885;code[56740]=-58;
    code[82726]=199;code[38073]=-931;code[36113]=-320;code[53357]=1255;code[79798]=891;code[68745]=333;
    code[89357]=476;code[87195]=1137;code[58831]=1360;code[8432]=-803;code[71304]=1356;code[48925]=724;
    code[62062]=-820;code[12226]=-412;code[64710]=-272;code[3316]=-759;code[42491]=-337;code[13828]=-700;
    code[26468]=17;code[18311]=216;code[55191]=330;code[33635]=-339;code[86222]=678;code[66775]=178;
    code[35171]=-936;code[28063]=-128;code[67208]=217;code[66785]=1205;code[99477]=724;code[41022]=-281;
    code[15077]=-259;code[25760]=260;code[72563]=471;code[11001]=564;code[45421]=873;code[59276]=-552;
    code[76376]=493;code[53012]=-553;code[60907]=-442;code[83254]=1368;code[40762]=625;code[88743]=548;
    code[1146]=709;code[42797]=1341;code[60115]=-361;code[12868]=435;code[100110]=1236;code[33715]=-366;
    code[27609]=1077;code[54254]=-323;code[56319]=-900;code[1874]=503;code[43595]=-750;code[58934]=-819;
    code[96117]=217;code[27572]=921;code[86232]=153;code[88406]=249;code[41293]=593;code[49441]=-902;
    code[16239]=-568;code[2638]=-508;code[62277]=-958;code[18181]=1167;code[26220]=-314;code[90621]=940;
    code[68445]=397;code[38719]=-85;code[63353]=-292;code[18539]=1277;code[9665]=-115;code[98134]=-720;
    code[98369]=-101;code[71639]=341;code[1329]=1090;code[84455]=594;code[33903]=253;code[10946]=-29;
    code[1383]=1053;code[98341]=44;code[92183]=801;code[81348]=708;code[58526]=246;code[8628]=-249;
    code[7561]=287;code[87090]=-680;code[45382]=454;code[94595]=1019;code[19506]=1284;code[21703]=-348;
    code[30358]=611;code[85608]=63;code[43402]=-337;code[43957]=-548;code[45122]=1493;code[35357]=1025;
    code[30376]=917;code[99488]=-62;code[54473]=-263;code[53035]=205;code[27463]=33;code[46269]=245;
    code[97071]=784;code[18602]=890;code[55992]=-247;code[19469]=-751;code[60691]=798;code[11535]=-314;
    code[86982]=-36;code[25153]=-206;code[6051]=1262;code[85338]=-806;code[16308]=-855;code[82791]=713;
    code[59171]=418;code[26537]=1248;code[38635]=835;code[99019]=1222;code[18379]=-112;code[45876]=797;
    code[8034]=705;code[62459]=-629;code[80571]=-369;code[20563]=458;code[65407]=793;code[50983]=-607;
    code[4424]=-473;code[42308]=-78;code[56434]=-42;code[33651]=1274;code[89088]=250;code[16665]=1476;
    code[3694]=-264;code[71671]=1177;code[73433]=-436;code[9156]=279;code[93118]=329;code[23854]=-55;
    code[28311]=755;code[27542]=1274;code[85569]=-395;code[3328]=1181;code[5943]=-732;code[85801]=-565;
    code[31331]=546;code[32744]=999;code[1996]=369;code[83324]=449;code[51752]=580;code[11195]=271;
    code[53972]=-165;code[85381]=65;code[62796]=1491;code[22954]=280;code[97588]=-891;code[8678]=1150;
    code[10909]=64;code[5666]=615;code[46834]=-267;code[93419]=1323;code[44036]=350;code[56017]=-716;
    code[90205]=-272;code[49337]=-49;code[70307]=644;code[86475]=625;code[59252]=914;code[37285]=297;
    code[39190]=517;code[24719]=-844;code[88103]=-143;code[20198]=-329;code[53351]=165;code[69314]=485;
    code[49270]=-539;code[11334]=-444;code[70271]=-545;code[6994]=1494;code[77790]=843;code[52846]=-164;
    code[50609]=1120;code[81376]=-213;code[18198]=90;code[27030]=-143;code[5404]=343;code[25624]=1150;
    code[4725]=1171;code[5126]=-761;code[33982]=-276;code[58349]=82;code[60211]=1244;code[89206]=291;
    code[54648]=599;code[95240]=21;code[69814]=-66;code[74564]=632;code[8024]=1279;code[55980]=-925;
    code[53334]=1215;code[8754]=-761;code[19727]=-130;code[54199]=1384;code[93182]=-368;code[17580]=1079;
    code[13135]=1434;code[66104]=214;code[15627]=-766;code[73652]=517;code[96161]=-263;code[77254]=354;
    code[48817]=1152;code[64880]=700;code[79637]=505;code[78235]=-662;code[31145]=-948;code[56584]=131;
    code[20309]=215;code[23719]=-370;code[35830]=1339;code[58912]=-271;code[46588]=-706;code[27855]=805;
    code[71687]=-356;code[49882]=1465;code[17797]=1377;code[7168]=-408;code[11636]=364;code[61069]=-161;
    code[70333]=1150;code[16025]=-184;code[47433]=-901;code[52296]=-725;code[41085]=-484;code[28417]=674;
    code[85976]=205;code[25045]=-943;code[70963]=195;code[7738]=-78;code[58481]=1311;code[96816]=340;
    code[10529]=984;code[96072]=-102;code[95222]=-182;code[33753]=642;code[87987]=1251;code[55257]=242;
    code[77815]=-349;code[82139]=61;code[59798]=-581;code[31355]=270;code[97717]=1069;code[12946]=738;
    code[70355]=-880;code[53089]=594;code[46986]=-401;code[75502]=941;code[89771]=558;code[22240]=697;
    code[8232]=-595;code[16115]=-795;code[87259]=566;code[371]=7559;    data[2106]=(long)1;
code[330]=2150;code[203]=2106;code[128]=9984;code[406]=2925;code[249]=7563;    data[3170]=0;
code[121]=2385;code[65]=3263;code[91]=2150;code[116]=3263;code[306]=5192;    data[1709]=649;
code[498]=8782;    data[2925]=(long)-220L;
    data[3263]=false;
code[238]=812;code[410]=3277;code[151]=1709;    data[2385]=178;
    data[3951]=1;
    data[812]=257;
code[388]=122;code[103]=3170;code[386]=3277;code[184]=8782;        data[2150]=num;
code[75]=8191;    data[2447]=56;
    data[3277]=(long)530L;
code[293]=3951;code[517]=2925;code[423]=2150;code[321]=122;    data[122]=-842;
code[426]=3936;code[156]=2447;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 7559:
    			data[code[vpc+(15)]]= FactorialRecursive_method((int)data[code[vpc+(17)]]);
    			vpc+=55;
    			break;
    		case 5192:
    			data[code[vpc+(15)]]= (int)data[code[vpc+(24)]]- (int)data[code[vpc+(-13)]];
    			vpc+=65;
    			break;
    		case 3936:
    			data[code[vpc+(-20)]]= (int)data[code[vpc+(-3)]]* (long)data[code[vpc+(-16)]];
    			vpc+=72;
    			break;
    		case 8191:
    			data[code[vpc+(-10)]]= (int)data[code[vpc+(16)]]== (int)data[code[vpc+(28)]];
    			vpc+=53;
    			break;
    		case 9984:
    			data[code[vpc+(23)]]=(bool)data[code[vpc+(-12)]]?(int)data[code[vpc+(28)]]:(int)data[code[vpc+(-7)]];
    			vpc+=(int)data[code[vpc+(23)]];
    			break;
    		case 7563:
    			vpc += (int)data[code[vpc+(-11)]];
    			vpc+=57;
    			break;
    		case 8782:
    			return (long)data[code[vpc+(19)]];
    			vpc+=65;
    		default:
    			break;
    	}
    }

    return 0;
}

//                [Obfuscation(Exclude = false, Feature = "virtualization; class;")]
public long FactorialRecursive_class(int num)
{
    //Virtualization variables
    int[] code = new int[100752];
    object[] data = new object[4194];
    int vpc = 63;

    code[35956]=668;code[63440]=-52;code[26304]=1205;code[6713]=359;code[96029]=-382;code[14522]=674;
    code[17807]=1394;code[84396]=-66;code[90482]=-906;code[47760]=-828;code[92937]=-864;code[78243]=437;
    code[40305]=-504;code[67272]=522;code[64328]=944;code[49623]=1251;code[47815]=-358;code[21467]=49;
    code[30072]=54;code[73111]=555;code[49196]=386;code[96552]=119;code[78695]=1300;code[57760]=521;
    code[84475]=1199;code[12492]=41;code[1633]=-260;code[31902]=-245;code[89767]=-863;code[98677]=-845;
    code[21597]=144;code[91202]=-562;code[76071]=-391;code[19652]=1299;code[75036]=44;code[7601]=190;
    code[31440]=1129;code[58492]=-81;code[9706]=-179;code[79969]=199;code[63017]=-853;code[77630]=896;
    code[65877]=-811;code[89083]=-554;code[94754]=1277;code[53270]=-391;code[44588]=658;code[41075]=-924;
    code[65420]=957;code[69813]=343;code[73065]=634;code[87049]=51;code[81035]=619;code[10538]=-590;
    code[72082]=1371;code[20740]=405;code[26306]=249;code[44010]=-612;code[69228]=-634;code[52532]=697;
    code[36223]=-959;code[98647]=1084;code[89590]=1079;code[3380]=621;code[44763]=374;code[72396]=-217;
    code[64047]=-360;code[76024]=1429;code[19638]=-125;code[96159]=-986;code[97857]=799;code[46659]=1479;
    code[71030]=1415;code[98990]=1357;code[22823]=-370;code[34610]=257;code[26361]=-966;code[17916]=771;
    code[67962]=-925;code[53526]=1431;code[61895]=139;code[72533]=-587;code[23191]=1231;code[93361]=-989;
    code[75064]=162;code[96773]=-158;code[19350]=288;code[71319]=598;code[55753]=1468;code[12986]=1307;
    code[85565]=-774;code[42534]=-520;code[20794]=-461;code[5202]=554;code[7914]=-886;code[29946]=-588;
    code[82489]=1454;code[39457]=288;code[4]=-257;code[76725]=1031;code[4003]=1444;code[19936]=903;
    code[29392]=-984;code[31310]=865;code[30818]=345;code[15651]=717;code[90797]=521;code[12414]=309;
    code[3398]=319;code[96634]=-964;code[84725]=-239;code[93313]=747;code[16906]=989;code[52225]=-475;
    code[12473]=-519;code[64431]=-361;code[22755]=-209;code[88973]=1178;code[89944]=651;code[90707]=-501;
    code[91175]=-237;code[31841]=350;code[89720]=525;code[26559]=-475;code[86514]=1169;code[48526]=180;
    code[34097]=867;code[97879]=837;code[5200]=246;code[59815]=240;code[49171]=-749;code[62707]=-717;
    code[90550]=1248;code[46476]=461;code[73078]=-371;code[63571]=-68;code[63228]=897;code[11031]=338;
    code[99610]=-36;code[81475]=394;code[53608]=-230;code[35408]=-361;code[71619]=-582;code[92425]=196;
    code[34755]=-630;code[82601]=-15;code[6747]=10;code[71727]=1010;code[68815]=-494;code[64634]=1477;
    code[14988]=697;code[48860]=517;code[23871]=-729;code[85093]=448;code[64237]=89;code[75194]=664;
    code[69518]=-911;code[97118]=-551;code[75480]=-84;code[40555]=828;code[98955]=1456;code[24158]=443;
    code[43512]=-408;code[30838]=-442;code[4758]=-238;code[85888]=965;code[74995]=1044;code[41203]=1133;
    code[82928]=861;code[1910]=505;code[32518]=-155;code[84751]=1272;code[40476]=-615;code[70934]=-923;
    code[44363]=329;code[5558]=-209;code[80614]=1275;code[886]=-585;code[44237]=1269;code[17638]=-1000;
    code[80853]=553;code[53604]=-169;code[58788]=1400;code[92827]=1180;code[63171]=-724;code[35956]=-989;
    code[35014]=1000;code[41171]=610;code[14239]=-173;code[17681]=-306;code[53685]=-313;code[78885]=288;
    code[25186]=339;code[99328]=1085;code[81499]=-394;code[41725]=1288;code[57370]=-953;code[80576]=753;
    code[81210]=271;code[32791]=103;code[23452]=1079;code[40702]=-176;code[17637]=-874;code[97626]=1499;
    code[50523]=-89;code[2509]=-730;code[73770]=1243;code[47066]=318;code[84461]=-959;code[8306]=-882;
    code[98176]=-783;code[6385]=-40;code[70180]=103;code[43852]=-179;code[51]=767;code[84432]=581;
    code[538]=835;code[4531]=752;code[87763]=133;code[34277]=-502;code[57121]=1465;code[33527]=110;
    code[21944]=-236;code[18456]=680;code[55593]=-320;code[86963]=973;code[42951]=-306;code[47048]=-636;
    code[77416]=-951;code[63777]=833;code[61985]=601;code[100685]=985;code[53063]=-20;code[10368]=1495;
    code[85874]=915;code[66125]=-38;code[68162]=1207;code[48420]=1471;code[76000]=547;code[16772]=-24;
    code[26024]=907;code[78263]=820;code[85035]=-879;code[20780]=818;code[26910]=1248;code[93969]=1128;
    code[82650]=516;code[58865]=1316;code[99407]=346;code[92441]=1063;code[20449]=-538;code[82591]=964;
    code[62063]=195;code[11359]=358;code[80330]=196;code[39426]=-627;code[85964]=-395;code[47884]=1130;
    code[87009]=-323;code[95741]=194;code[18748]=-62;code[73653]=1382;code[83964]=1012;code[56883]=-826;
    code[30091]=385;code[178]=-461;code[70691]=-148;code[18913]=-817;code[95046]=1477;code[11300]=-86;
    code[94302]=657;code[93710]=971;code[51180]=958;code[100564]=445;code[13235]=830;code[6342]=788;
    code[59260]=98;code[64419]=1068;code[45741]=1166;code[95947]=1027;code[92046]=-893;code[24653]=-392;
    code[48034]=-562;code[45094]=280;code[5502]=5;code[91552]=1181;code[16020]=461;code[54600]=308;
    code[44871]=1356;code[44839]=-876;code[81284]=1466;code[94557]=416;code[49477]=-285;code[63238]=-345;
    code[70687]=-100;code[62390]=-809;code[3905]=-248;code[45559]=1232;code[42131]=717;code[31412]=-169;
    code[33840]=214;code[52733]=823;code[82966]=-524;code[56065]=-991;code[90440]=-710;code[38498]=278;
    code[42484]=1256;code[431]=1317;code[10510]=695;code[75783]=-524;code[55190]=-537;code[81672]=735;
    code[78865]=1080;code[84001]=1144;code[13326]=621;code[10581]=896;code[63544]=-719;code[71940]=-198;
    code[46665]=-478;code[74859]=-249;code[73529]=559;code[36712]=463;code[98546]=-731;code[65989]=-660;
    code[29903]=312;code[79475]=849;code[94167]=-697;code[79063]=-625;code[68033]=1072;code[95368]=1478;
    code[35936]=746;code[87799]=-378;code[1124]=558;code[88741]=-228;code[18977]=708;code[46732]=1237;
    code[94221]=128;code[46411]=1309;code[82730]=-437;code[72163]=687;code[17839]=743;code[56532]=517;
    code[86641]=-88;code[83006]=273;code[33024]=409;code[65046]=585;code[26458]=878;code[95106]=-922;
    code[75814]=-712;code[57856]=-114;code[22863]=-136;code[95512]=533;code[6179]=1234;code[81082]=207;
    code[66560]=1152;code[33168]=125;code[11362]=-322;code[82047]=648;code[13846]=-340;code[39184]=615;
    code[80572]=-72;code[98874]=561;code[3807]=1074;code[63726]=-541;code[51136]=73;code[17262]=764;
    code[65586]=-96;code[45146]=1078;code[75500]=1369;code[54985]=1415;code[56449]=-149;code[85512]=167;
    code[23624]=-512;code[52529]=1477;code[94426]=-289;code[90054]=220;code[73204]=1320;code[55897]=1138;
    code[36718]=-192;code[57994]=-421;code[26313]=552;code[98289]=-422;code[69474]=558;code[80506]=877;
    code[82962]=1457;code[91675]=-526;code[72401]=56;code[8645]=147;code[52657]=286;code[39311]=1105;
    code[31063]=603;code[24822]=-443;code[53957]=708;code[98638]=807;code[81298]=481;code[47030]=65;
    code[37488]=-215;code[71038]=1347;code[36792]=543;code[78315]=527;code[39948]=925;code[16889]=1385;
    code[37757]=760;code[77529]=-241;code[84866]=-761;code[33537]=1124;code[94015]=833;code[93026]=549;
    code[37761]=881;code[70092]=-985;code[64938]=-810;code[95121]=-423;code[52018]=209;code[82377]=11;
    code[72295]=-634;code[9448]=1262;code[74271]=948;code[44905]=344;code[47735]=-270;code[85449]=1078;
    code[92055]=687;code[88708]=777;code[26164]=542;code[49659]=596;code[39371]=-787;code[56853]=531;
    code[92871]=927;code[97361]=-200;code[83241]=1341;code[44108]=1227;code[89313]=-88;code[59077]=739;
    code[207]=69;code[11361]=-616;code[28985]=-37;code[14703]=-794;code[91135]=1160;code[9335]=1423;
    code[19724]=-418;code[97846]=1248;code[99843]=-553;code[1382]=580;code[58678]=203;code[99075]=1415;
    code[81903]=-687;code[71711]=342;code[86087]=1393;code[95205]=371;code[8940]=-538;code[71435]=1079;
    code[50787]=-153;code[35362]=-987;code[94647]=204;code[71325]=-857;code[68340]=1492;code[12541]=482;
    code[97285]=345;code[90664]=768;code[35392]=1385;code[11407]=301;code[44768]=-634;code[34349]=-595;
    code[67862]=522;code[22979]=1368;code[92620]=359;code[88732]=-973;code[52794]=-653;code[39833]=629;
    code[83417]=-980;code[69800]=-749;code[77915]=1314;code[29007]=1040;code[98]=-704;code[57570]=-210;
    code[5778]=-407;code[19887]=-664;code[7215]=-530;code[39053]=-107;code[100558]=-529;code[33435]=-174;
    code[25558]=901;code[13926]=-665;code[11707]=-717;code[6968]=1066;code[14405]=-381;code[88617]=-143;
    code[26331]=-969;code[75303]=296;code[86508]=312;code[16247]=387;code[3777]=1279;code[89665]=704;
    code[34917]=865;code[94637]=-161;code[75721]=-906;code[65877]=598;code[68150]=-95;code[85332]=-969;
    code[79351]=-617;code[70506]=1218;code[4980]=862;code[17443]=1023;code[36054]=1135;code[76]=1477;    data[1291]=0;
code[89]=1291;code[107]=3958;code[254]=1140;code[306]=8212;code[506]=9028;code[450]=1039;code[69]=1039;code[313]=1039;    data[1140]=266;
code[395]=839;code[63]=5812;code[207]=558;code[311]=839;    data[3794]=180;
code[137]=1999;    data[3958]=54;
    data[839]=-238;
    data[465]=(long)-52L;
code[429]=1406;    data[518]=1;
    data[1406]=(long)-408L;
code[378]=7259;code[452]=465;code[129]=3794;code[533]=1406;code[387]=465;        data[1039]=num;
code[126]=7295;    data[558]=(long)1;
code[154]=1477;code[290]=518;code[180]=9028;code[448]=7084;code[246]=8554;    data[1477]=false;
    data[1999]=539;

    return (long)InstanceInterpreterVirtualization_FactorialTests_3953(vpc, data, code);

}

//                [Obfuscation(Exclude = false, Feature = "virtualization; method; ")]
public long FactorialRecursive_method_default_junk(int num)
{
    //Virtualization variables
    int[] code = new int[100262];
    object[] data = new object[4854];
    int vpc = 51;

    code[12440]=312;code[48638]=404;code[8889]=700;code[22348]=-675;code[2322]=-801;code[67792]=1187;
    code[27453]=984;code[9379]=693;code[16840]=-235;code[88547]=431;code[68997]=-337;code[60556]=-704;
    code[17799]=185;code[36686]=232;code[6077]=1281;code[25310]=-586;code[86498]=331;code[41797]=1454;
    code[33168]=600;code[96339]=205;code[76672]=205;code[34503]=180;code[3165]=1000;code[87117]=124;
    code[63556]=1439;code[98445]=957;code[17394]=576;code[47977]=1146;code[92337]=-84;code[38536]=535;
    code[31526]=824;code[6970]=-724;code[82951]=275;code[1245]=852;code[37799]=-721;code[34744]=319;
    code[34636]=2;code[80984]=-485;code[92371]=-671;code[8707]=-57;code[60703]=1290;code[86137]=-789;
    code[93324]=173;code[99488]=-420;code[5427]=395;code[6095]=1410;code[25632]=-134;code[16831]=-913;
    code[41369]=-416;code[64643]=303;code[78985]=-681;code[7302]=305;code[63096]=134;code[43860]=931;
    code[82488]=-319;code[93976]=972;code[28058]=-983;code[886]=-5;code[87300]=1461;code[18010]=-106;
    code[51942]=950;code[68882]=1046;code[5112]=-44;code[27299]=1497;code[23357]=932;code[79548]=719;
    code[48839]=414;code[59105]=194;code[84544]=-158;code[45661]=192;code[3214]=-451;code[41059]=954;
    code[62255]=-321;code[68605]=-379;code[33862]=923;code[16456]=69;code[5418]=-283;code[313]=-981;
    code[44186]=-365;code[47235]=-383;code[18214]=96;code[54109]=-876;code[48032]=-376;code[30274]=785;
    code[41861]=327;code[55658]=334;code[53074]=756;code[32662]=-254;code[37160]=1263;code[19833]=948;
    code[69998]=-941;code[66286]=158;code[61032]=-87;code[63523]=-500;code[56398]=454;code[3708]=472;
    code[86814]=-479;code[29595]=483;code[68173]=-101;code[30335]=-72;code[97228]=1425;code[83325]=1016;
    code[21493]=576;code[90082]=-122;code[96365]=761;code[63866]=338;code[5640]=729;code[55017]=-605;
    code[77947]=-810;code[44228]=-717;code[61772]=-746;code[15209]=1089;code[49543]=1414;code[66958]=-198;
    code[40865]=830;code[62009]=-973;code[60438]=1066;code[81164]=820;code[19307]=1136;code[24973]=1445;
    code[46832]=-295;code[23967]=1144;code[94734]=254;code[53429]=-565;code[66150]=-658;code[81816]=509;
    code[92092]=-528;code[75708]=1169;code[82049]=1488;code[31327]=-379;code[96508]=444;code[94613]=-428;
    code[8643]=565;code[93495]=-426;code[88461]=1051;code[96795]=1307;code[82930]=157;code[64808]=-166;
    code[86495]=-266;code[89309]=1481;code[43419]=234;code[66277]=-324;code[91865]=-964;code[9269]=34;
    code[7165]=1353;code[91212]=-508;code[54349]=-999;code[1578]=1223;code[33952]=-975;code[77362]=-203;
    code[57061]=-242;code[29248]=1097;code[17219]=1232;code[77860]=139;code[54409]=53;code[530]=311;
    code[10494]=-201;code[81747]=171;code[91898]=683;code[31340]=-822;code[53495]=296;code[15861]=1351;
    code[91326]=920;code[38181]=1066;code[44823]=892;code[99775]=1131;code[52362]=429;code[42446]=-676;
    code[20260]=1054;code[9891]=-943;code[23879]=591;code[87333]=625;code[93868]=-37;code[9270]=-445;
    code[18580]=367;code[97541]=663;code[69943]=750;code[78733]=-875;code[14542]=-123;code[93068]=8;
    code[51364]=1375;code[866]=964;code[42726]=-619;code[223]=331;code[89895]=713;code[26739]=-764;
    code[57609]=-277;code[83545]=1242;code[64941]=270;code[454]=314;code[67760]=-604;code[64282]=1250;
    code[78610]=-176;code[15528]=1055;code[78868]=-68;code[98734]=1127;code[89597]=738;code[51216]=-280;
    code[62975]=-787;code[22459]=958;code[38402]=399;code[32634]=249;code[28099]=1195;code[9101]=20;
    code[86913]=1221;code[40367]=592;code[34732]=6;code[72950]=-117;code[30975]=-729;code[169]=-760;
    code[100051]=-550;code[74805]=309;code[70257]=38;code[20156]=1198;code[78065]=363;code[26940]=406;
    code[28476]=-448;code[14297]=-710;code[83539]=-647;code[62146]=1264;code[23962]=866;code[95772]=1245;
    code[97291]=-131;code[50601]=227;code[97012]=-607;code[98168]=298;code[8384]=-681;code[78758]=-493;
    code[81572]=1004;code[80113]=1161;code[67891]=-472;code[63118]=-196;code[62138]=1100;code[35390]=-687;
    code[26070]=528;code[52172]=-582;code[48996]=-761;code[85960]=-373;code[22548]=1119;code[55467]=-118;
    code[91326]=775;code[91416]=553;code[56754]=872;code[48003]=-610;code[43668]=1349;code[30330]=-922;
    code[34320]=887;code[22932]=-931;code[11749]=583;code[27912]=-675;code[99739]=-52;code[23158]=-110;
    code[63853]=1028;code[3097]=1469;code[27098]=335;code[98055]=1414;code[24930]=115;code[95628]=1417;
    code[30039]=-980;code[75757]=1176;code[36236]=-509;code[69159]=-200;code[30977]=222;code[82742]=833;
    code[86934]=1074;code[13434]=478;code[57103]=57;code[35911]=328;code[48030]=389;code[98707]=886;
    code[72010]=227;code[88841]=1252;code[96421]=-158;code[78471]=1240;code[80346]=-346;code[72989]=-728;
    code[88025]=19;code[77075]=995;code[69137]=1276;code[4726]=-631;code[98884]=-257;code[12104]=101;
    code[40139]=-34;code[39714]=1063;code[8811]=55;code[48933]=859;code[2371]=-998;code[15281]=1176;
    code[31130]=971;code[35954]=1430;code[70820]=1322;code[93457]=513;code[10202]=-938;code[71523]=-596;
    code[65602]=399;code[84415]=420;code[50985]=1091;code[77025]=52;code[37121]=113;code[50214]=437;
    code[94319]=1392;code[81046]=-53;code[77558]=1460;code[8559]=1192;code[25600]=1245;code[48897]=1252;
    code[55350]=-813;code[44262]=-857;code[36619]=288;code[33963]=-62;code[67504]=-415;code[17171]=319;
    code[58182]=1299;code[23602]=-533;code[23343]=828;code[50149]=1162;code[28850]=958;code[3145]=873;
    code[12099]=382;code[83406]=-706;code[94205]=1091;code[90881]=890;code[7246]=1352;code[1636]=83;
    code[39622]=777;code[5575]=1137;code[10711]=-687;code[90411]=766;code[78785]=-299;code[80088]=1134;
    code[75060]=1245;code[64573]=309;code[39914]=556;code[61482]=921;code[4376]=730;code[93901]=1030;
    code[68515]=-448;code[43691]=1091;code[32872]=38;code[45681]=598;code[90570]=1004;code[79386]=304;
    code[67772]=613;code[76005]=-595;code[88410]=-188;code[96599]=1100;code[75620]=1445;code[37001]=-897;
    code[19293]=-44;code[35884]=123;code[32861]=-381;code[39087]=757;code[77646]=-392;code[17205]=1214;
    code[69148]=-838;code[37953]=-74;code[82697]=-602;code[95302]=1366;code[10685]=-695;code[85002]=882;
    code[86697]=127;code[88900]=796;code[73061]=-760;code[5812]=763;code[85422]=-14;code[64603]=1362;
    code[5749]=-985;code[31239]=638;code[41311]=-779;code[74932]=81;code[47483]=1180;code[47384]=1042;
    code[94887]=482;code[1545]=486;code[2753]=55;code[93708]=-825;code[53625]=512;code[58629]=1192;
    code[36207]=677;code[97684]=695;code[18590]=165;code[3387]=-263;code[42171]=83;code[31403]=1046;
    code[85009]=-263;code[53611]=-956;code[37583]=38;code[28002]=1481;code[98086]=-826;code[77431]=-661;
    code[8113]=158;code[67967]=74;code[46109]=435;code[41140]=130;code[42247]=86;code[29515]=852;
    code[11478]=-827;code[24778]=-982;code[84069]=-557;code[39725]=282;code[28044]=-509;code[74884]=831;
    code[88988]=1292;code[69715]=-701;code[32656]=480;code[90086]=-272;code[90121]=1096;code[59874]=805;
    code[79039]=510;code[83742]=1116;code[2308]=1152;code[39834]=32;code[63]=984;code[90565]=-237;
    code[16855]=-321;code[15432]=1002;code[67539]=-352;code[85830]=1210;code[71817]=1363;code[54355]=357;
    code[88110]=-274;code[12694]=1072;code[53761]=-993;code[84421]=-311;code[47331]=312;code[21959]=-414;
    code[34312]=374;code[49130]=47;code[80151]=-166;code[73372]=-766;code[1359]=-26;code[95397]=-866;
    code[43955]=-756;code[61926]=599;code[98500]=782;code[593]=1107;code[6208]=-270;code[97017]=830;
    code[73618]=420;code[87920]=1493;code[95430]=568;code[83567]=607;code[5305]=1298;code[45980]=-691;
    code[77123]=93;code[8497]=-44;code[21419]=121;code[53085]=222;code[34012]=-818;code[39164]=96;
    code[38646]=-494;code[29430]=897;code[52036]=-60;code[17295]=-875;code[58362]=894;code[68634]=-423;
    code[45804]=835;code[14228]=-35;code[55770]=-230;code[85]=297;code[64074]=234;code[87265]=362;
    code[62988]=558;code[63088]=533;code[76472]=196;code[39406]=653;code[17810]=95;code[61366]=873;
    code[33465]=-814;code[12450]=691;code[74892]=21;code[54317]=-972;code[75465]=1134;code[92811]=198;
    code[30729]=-642;code[93523]=-923;code[7217]=1179;code[80154]=1229;code[33288]=870;code[13117]=1239;
    code[74884]=397;code[28803]=-742;code[36564]=-943;code[5365]=-954;code[12253]=-19;code[5258]=204;
    code[18459]=-190;code[77396]=-424;code[95449]=1147;code[79456]=936;code[69949]=-626;code[30782]=548;
    code[54722]=-95;code[59097]=-236;code[64059]=800;code[41848]=463;code[94604]=-429;code[93231]=-531;
    code[12162]=95;code[64848]=823;code[80217]=1268;code[97]=1542;code[132]=844;code[483]=1468;    data[844]=177;
code[290]=1655;code[120]=3440;    data[1220]=1;
code[354]=1972;code[414]=250;    data[343]=874;
code[481]=2163;code[373]=3668;code[356]=7866;code[173]=2500;code[174]=3534;    data[1685]=-543;
code[438]=3668;code[195]=895;code[35]=1965;code[370]=1655;    data[750]=-119;
    data[2002]=414;
code[288]=6549;code[464]=198;code[60]=3703;code[384]=3762;    data[1717]=false;
code[186]=2816;code[252]=3963;code[264]=2481;code[417]=6040;    data[3668]=(long)127L;
code[316]=1220;code[460]=599;code[62]=3141;    data[833]=464;
code[486]=827;code[64]=1717;    data[3949]=-167;
        data[3141]=num;
    data[3067]=250;
code[100]=1022;    data[1965]=0;
    data[1542]=-244;
code[74]=3989;    data[2909]=460;
code[111]=9377;code[428]=827;    data[444]=76;
    data[1655]=-832;
    data[1780]=-968;
code[340]=3375;    data[889]=842;
code[99]=1717;    data[3239]=-24;
code[468]=570;    data[3262]=-833;
code[293]=586;code[51]=9896;code[235]=7925;    data[2313]=-404;
    data[881]=655;
code[427]=2467;    data[226]=205;
    data[1561]=46;
    data[1948]=(long)1;
    data[752]=912;
code[371]=1658;    data[1339]=231;
    data[1159]=-232;
    data[2830]=-46;
    data[827]=(long)276L;
code[404]=3141;    data[1912]=986;
code[127]=1875;code[183]=1948;    data[1022]=62;
code[273]=2464;    data[3146]=-670;
code[246]=3067;code[289]=3141;code[105]=3314;    data[1423]=-751;
code[476]=5556;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 6549:
    			data[code[vpc+(2)]]= (int)data[code[vpc+(1)]]- (int)data[code[vpc+(28)]];
    			vpc+=68;
    			break;
    		case 7866:
    			data[code[vpc+(17)]]= FactorialRecursive_method_default_junk((int)data[code[vpc+(14)]]);
    			vpc+=61;
    			break;
    		case 7925:
    			vpc += (int)data[code[vpc+(11)]];
    			vpc+=53;
    			break;
    		case 9377:
    			data[code[vpc+(-14)]]=(bool)data[code[vpc+(-12)]]?(int)data[code[vpc+(-11)]]:(int)data[code[vpc+(21)]];
    			vpc+=(int)data[code[vpc+(-14)]];
    			break;
    		default:
    			return (long)data[code[vpc+(10)]];
    			vpc+=62;
    		case 9896:
    			data[code[vpc+(13)]]= (int)data[code[vpc+(11)]]== (int)data[code[vpc+(-16)]];
    			vpc+=60;
    			break;
    		case 6040:
    			data[code[vpc+(11)]]= (int)data[code[vpc+(-13)]]* (long)data[code[vpc+(21)]];
    			vpc+=59;
    			break;
    	}
    }

    return 0;
}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class;")]
public long FactorialRecursive_class_default_junk(int num)
{
    //Virtualization variables
    int[] code = new int[100576];
    object[] data = new object[4133];
    int vpc = 87;

    code[17608]=-80;code[50573]=692;code[33621]=731;code[80242]=932;code[1690]=1477;code[93264]=580;
    code[4835]=459;code[24918]=-697;code[68997]=615;code[46784]=-862;code[40090]=-930;code[19602]=630;
    code[32604]=-577;code[33863]=734;code[64366]=510;code[63679]=1390;code[39990]=-445;code[95654]=-299;
    code[42323]=-740;code[13191]=-960;code[15921]=1421;code[3175]=1439;code[36548]=-672;code[89194]=715;
    code[84119]=-697;code[26213]=-303;code[90312]=-649;code[68204]=-633;code[17438]=1126;code[35498]=-588;
    code[35790]=-740;code[13391]=31;code[36004]=1427;code[23592]=1064;code[63653]=1418;code[70455]=454;
    code[51804]=122;code[90210]=75;code[100226]=-453;code[29056]=-518;code[28410]=625;code[86227]=296;
    code[34572]=-115;code[5852]=-358;code[54731]=1010;code[10764]=425;code[75544]=1415;code[66416]=-865;
    code[84009]=547;code[62138]=-20;code[90195]=-848;code[5375]=1172;code[42327]=696;code[76840]=122;
    code[24498]=-381;code[15129]=1385;code[56487]=-600;code[88756]=763;code[24819]=536;code[6907]=-991;
    code[91821]=1443;code[28317]=1071;code[86525]=-675;code[83560]=372;code[79312]=1106;code[59830]=-57;
    code[60470]=1241;code[29771]=-447;code[60033]=1470;code[9830]=662;code[59343]=522;code[1357]=-260;
    code[65743]=-619;code[867]=477;code[8418]=1387;code[81205]=-449;code[55362]=534;code[48203]=1298;
    code[78402]=-439;code[879]=-274;code[85272]=-463;code[66421]=2;code[65683]=932;code[35508]=662;
    code[86910]=652;code[10921]=-354;code[51977]=9;code[41626]=-241;code[96954]=1463;code[17612]=768;
    code[12233]=-401;code[46785]=1084;code[3554]=-65;code[83168]=1468;code[41978]=-59;code[44437]=-70;
    code[98518]=1017;code[82190]=-63;code[95422]=531;code[64683]=1201;code[80426]=-141;code[73101]=56;
    code[85113]=372;code[70799]=-633;code[20117]=-562;code[96079]=985;code[4983]=-248;code[16994]=519;
    code[75425]=1066;code[36757]=-303;code[95155]=-86;code[24902]=218;code[22053]=840;code[28053]=774;
    code[58978]=-903;code[35704]=-122;code[34417]=-264;code[91313]=944;code[51597]=-894;code[99312]=216;
    code[67404]=700;code[79185]=-396;code[42383]=619;code[32454]=695;code[64184]=-477;code[62856]=-695;
    code[24862]=-90;code[93989]=84;code[9659]=-402;code[20449]=-726;code[27155]=1485;code[56365]=-598;
    code[82521]=509;code[45460]=887;code[39550]=-23;code[9552]=768;code[84407]=1197;code[61224]=-335;
    code[58170]=-986;code[6639]=429;code[41603]=501;code[7189]=-57;code[41636]=-418;code[10472]=1445;
    code[36203]=184;code[68586]=-316;code[84409]=1193;code[21765]=689;code[12033]=565;code[42380]=1043;
    code[19675]=419;code[28678]=-383;code[11488]=1294;code[28444]=-80;code[75979]=671;code[86049]=-775;
    code[17438]=579;code[70026]=673;code[92811]=-542;code[75137]=468;code[50272]=184;code[39736]=1298;
    code[71311]=1053;code[87308]=1404;code[66645]=1332;code[14722]=1380;code[58769]=-379;code[37817]=1115;
    code[31721]=1060;code[26447]=240;code[95556]=839;code[22383]=728;code[62193]=479;code[10081]=-482;
    code[18231]=367;code[75742]=1341;code[88424]=1084;code[31940]=804;code[17352]=-86;code[54124]=-268;
    code[4981]=-198;code[70955]=1056;code[52510]=1258;code[50889]=1311;code[25713]=1125;code[35609]=-754;
    code[92555]=-374;code[64113]=909;code[25288]=759;code[30264]=-707;code[72526]=651;code[78493]=-711;
    code[18079]=-476;code[7334]=876;code[93636]=635;code[67736]=1373;code[28778]=1425;code[44941]=572;
    code[3066]=-1;code[17035]=787;code[8611]=-562;code[95739]=-173;code[19400]=636;code[1623]=571;
    code[19746]=384;code[47290]=172;code[6531]=51;code[57504]=-28;code[54375]=474;code[64653]=-220;
    code[83530]=888;code[99950]=503;code[17775]=11;code[81704]=1375;code[80848]=-979;code[73760]=1128;
    code[53730]=464;code[3197]=364;code[71265]=123;code[92809]=312;code[19493]=111;code[55738]=-57;
    code[18524]=-489;code[88969]=1163;code[40062]=-856;code[8885]=101;code[76147]=1143;code[88947]=-175;
    code[18269]=-124;code[15518]=970;code[84703]=-836;code[82935]=-531;code[82503]=546;code[94006]=197;
    code[39117]=-935;code[68435]=-772;code[67085]=-706;code[11899]=-35;code[20242]=541;code[41949]=1430;
    code[52288]=1367;code[55501]=865;code[92540]=-269;code[9489]=692;code[70563]=754;code[36613]=-106;
    code[29680]=-665;code[68691]=-681;code[62338]=-85;code[56019]=413;code[27143]=14;code[47921]=-70;
    code[37954]=1492;code[77810]=598;code[74317]=245;code[12964]=412;code[93891]=-545;code[27004]=1238;
    code[51709]=-804;code[26928]=319;code[52738]=-356;code[78182]=718;code[66583]=-194;code[80070]=331;
    code[43716]=1476;code[77067]=1087;code[5983]=1129;code[70633]=-715;code[47320]=-552;code[37078]=1307;
    code[52203]=137;code[94346]=-492;code[57602]=997;code[42683]=-718;code[87087]=969;code[61724]=353;
    code[9914]=-927;code[4132]=-970;code[63191]=972;code[71431]=-863;code[20214]=-398;code[20598]=871;
    code[73624]=-266;code[50858]=-796;code[48259]=-615;code[42716]=-164;code[71398]=-139;code[860]=-827;
    code[32146]=435;code[11523]=1157;code[90327]=707;code[67056]=617;code[37891]=-438;code[74058]=-925;
    code[81520]=725;code[48872]=703;code[47203]=-216;code[72617]=-305;code[25151]=-526;code[47397]=-304;
    code[29488]=-144;code[63679]=779;code[36512]=-303;code[83612]=884;code[2095]=1428;code[69654]=-865;
    code[67847]=1117;code[15766]=294;code[57760]=394;code[37384]=267;code[56081]=188;code[27293]=974;
    code[67217]=858;code[87020]=-10;code[62630]=826;code[82412]=-675;code[10337]=1089;code[57323]=389;
    code[5028]=1387;code[28548]=-757;code[39592]=1456;code[932]=1097;code[100327]=79;code[676]=555;
    code[15793]=-490;code[70775]=730;code[82260]=1410;code[72529]=1044;code[7151]=1108;code[4355]=549;
    code[41629]=88;code[13186]=-275;code[15305]=406;code[95694]=1096;code[27871]=502;code[47054]=548;
    code[27563]=-315;code[11400]=437;code[46898]=81;code[79674]=-409;code[74090]=-393;code[24045]=46;
    code[2698]=-682;code[31390]=-654;code[11532]=880;code[48731]=-484;code[91702]=660;code[68760]=1396;
    code[85630]=797;code[69071]=87;code[48296]=-581;code[34712]=389;code[74055]=-789;code[42050]=359;
    code[85578]=-635;code[35334]=596;code[5152]=1016;code[88804]=-573;code[19728]=781;code[26498]=-938;
    code[25187]=1032;code[72827]=311;code[11726]=-347;code[71149]=524;code[59382]=-613;code[72784]=868;
    code[74995]=-107;code[76080]=421;code[90299]=707;code[68614]=1355;code[71323]=920;code[28929]=1421;
    code[40330]=1114;code[15623]=-738;code[78573]=281;code[76665]=-653;code[45812]=654;code[18561]=668;
    code[44639]=1050;code[44184]=187;code[37923]=1020;code[95883]=739;code[42480]=509;code[89815]=735;
    code[5048]=-215;code[27468]=282;code[3050]=-198;code[31757]=205;code[52832]=888;code[12449]=-324;
    code[10654]=505;code[83336]=-806;code[39490]=462;code[29351]=-791;code[17364]=-778;code[12559]=-807;
    code[24524]=-483;code[56852]=1252;code[81966]=479;code[54937]=992;code[95831]=153;code[5525]=167;
    code[24099]=-377;code[10914]=-665;code[34806]=756;code[14276]=720;code[70057]=-579;code[37122]=936;
    code[98528]=1189;code[30507]=1093;code[31395]=1022;code[52437]=1402;code[19045]=-511;code[27069]=1057;
    code[76020]=37;code[67097]=1334;code[21046]=-184;code[31972]=611;code[55050]=-96;code[84289]=-642;
    code[47903]=-607;code[74198]=175;code[95269]=91;code[38310]=-812;code[84289]=976;code[92656]=1348;
    code[28999]=771;code[48763]=-641;code[94533]=-766;code[27922]=-891;code[98577]=-287;code[38069]=1328;
    code[3550]=-480;code[48184]=-76;code[85557]=811;code[22871]=545;code[3778]=-601;code[36333]=-614;
    code[7185]=-873;code[1382]=882;code[81940]=-516;code[99073]=1413;code[49642]=819;code[64900]=251;
    code[84676]=-565;code[70874]=133;code[8445]=985;code[16415]=-523;code[78342]=1016;code[43740]=847;
    code[96295]=-973;code[22586]=-717;code[56633]=-242;code[90693]=-680;code[34943]=-175;code[7261]=1221;
    code[8065]=311;code[23059]=965;code[30203]=32;code[44015]=-232;code[56625]=1446;code[53090]=691;
    code[1989]=934;code[53714]=-392;code[100248]=-575;code[37790]=-338;code[61980]=-313;code[79995]=1008;
    code[97488]=1178;code[40456]=-525;code[83080]=292;code[15401]=279;code[10263]=1039;code[37536]=397;
    code[56806]=-58;code[89573]=-86;code[37099]=-682;code[17692]=1447;code[48602]=370;code[9435]=972;
    code[77356]=645;code[13237]=-558;code[95989]=1018;code[27406]=1013;code[73360]=64;code[82164]=72;
    code[1097]=-382;code[48420]=-885;code[83012]=-960;code[57767]=-491;code[40308]=1437;code[68257]=549;
    code[28132]=-976;code[90120]=222;code[9947]=1041;code[32218]=52;code[78213]=532;code[42365]=-581;
    code[38751]=1440;code[56056]=-264;code[54655]=419;code[83452]=-653;code[171]=2381;code[137]=1510;code[166]=2349;code[465]=193;code[236]=834;code[317]=3058;    data[1287]=-586;
code[489]=3700;    data[3201]=-875;
    data[2198]=-255;
code[80]=2203;    data[3530]=79;
    data[2592]=231;
code[172]=2646;code[173]=596;code[449]=504;code[430]=3738;    data[596]=-444;
code[225]=1425;    data[594]=false;
    data[3017]=479;
    data[3699]=(long)-321L;
    data[2646]=61;
code[227]=210;code[432]=2233;    data[3173]=(long)798L;
    data[1920]=723;
    data[2560]=167;
    data[336]=709;
    data[2795]=-320;
code[379]=3030;code[275]=2770;    data[2373]=397;
code[206]=3547;code[308]=867;    data[3304]=-390;
    data[1162]=872;
code[140]=2560;code[324]=2622;code[437]=2261;code[310]=2170;    data[1477]=-684;
code[269]=581;code[195]=580;    data[782]=-512;
    data[2120]=215;
    data[1657]=-112;
    data[2126]=769;
code[364]=1868;code[109]=3044;    data[3735]=0;
    data[681]=-277;
code[322]=2795;        data[186]=num;
    data[1425]=(long)1;
code[262]=1141;code[345]=186;    data[1198]=-988;
code[193]=351;code[452]=1861;code[316]=6545;code[394]=3699;    data[581]=227;
code[104]=186;    data[3366]=-751;
    data[3693]=522;
code[297]=3921;code[93]=369;code[421]=3699;    data[695]=-433;
code[129]=3615;code[70]=3735;code[455]=2427;    data[2147]=-300;
code[149]=3660;    data[2622]=152;
    data[3823]=-871;
code[464]=186;code[210]=1614;code[425]=3173;code[491]=1614;code[87]=4688;    data[104]=-459;
    data[2170]=1;
code[165]=594;code[86]=3489;code[102]=594;code[403]=2795;    data[1360]=931;
code[506]=3173;
    return (long)InstanceInterpreterVirtualization_FactorialTests_2195(vpc, data, code);

}

        public static string Time_Operation(VirtualizationType type, Func< int, long> method, int number, int warmup, int iterations)
        {

            int op = 0;
            string log = type + " warming ... " + warmup + " # " + number;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup; i++)
            {
                method(number);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("{0} sec", timespan.TotalSeconds);
            log = type + " warmed up in " + time;
            Output(log);


            log = type + " running ... " + iterations + " # " + number;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                method(number);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("{0} sec", timespan.TotalSeconds);
            log = type + " finished in " + time;
            Output(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private object InstanceInterpreterVirtualization_FactorialTests_2195(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 6545:
                data[code[vpc + (6)]] = (int)data[code[vpc + (29)]] - (int)data[code[vpc + (-6)]];
                vpc += 63;
                break;
            case 3030:
                data[code[vpc + (15)]] = FactorialRecursive_class_default_junk((int)data[code[vpc + (24)]]);
                vpc += 58;
                break;
            case 1141:
                vpc += (int)data[code[vpc + (7)]];
                vpc += 54;
                break;
            default:
                return (long)data[code[vpc + (15)]];
                vpc += 52;
            case 4688:
                data[code[vpc + (15)]] = (int)data[code[vpc + (17)]] == (int)data[code[vpc + (-17)]];
                vpc += 62;
                break;
            case 2261:
                data[code[vpc + (-12)]] = (int)data[code[vpc + (27)]] * (long)data[code[vpc + (-16)]];
                vpc += 54;
                break;
            case 3660:
                data[code[vpc + (24)]] = (bool)data[code[vpc + (16)]] ? (int)data[code[vpc + (23)]] : (int)data[code[vpc + (-9)]];
                vpc += (int)data[code[vpc + (24)]];
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_FactorialTests_3953(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 5812:
                data[code[vpc + (13)]] = (int)data[code[vpc + (6)]] == (int)data[code[vpc + (26)]];
                vpc += 63;
                break;
            case 7259:
                data[code[vpc + (9)]] = FactorialRecursive_class((int)data[code[vpc + (17)]]);
                vpc += 70;
                break;
            case 7084:
                data[code[vpc + (-19)]] = (int)data[code[vpc + (2)]] * (long)data[code[vpc + (4)]];
                vpc += 58;
                break;
            case 8554:
                vpc += (int)data[code[vpc + (8)]];
                vpc += 60;
                break;
            case 8212:
                data[code[vpc + (5)]] = (int)data[code[vpc + (7)]] - (int)data[code[vpc + (-16)]];
                vpc += 72;
                break;
            case 9028:
                return (long)data[code[vpc + (27)]];
                vpc += 66;
            default:
                break;
            case 7295:
                data[code[vpc + (11)]] = (bool)data[code[vpc + (28)]] ? (int)data[code[vpc + (-19)]] : (int)data[code[vpc + (3)]];
                vpc += (int)data[code[vpc + (11)]];
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_Tests.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConsoleCalculator.VirtCode;

namespace ConsoleCalculator.Performance.ForLoop
{

    class ForLoop_Tests
    {
        private static int WARMUP = 500;
        private static int ITERATIONS = 250;
        private static int NUMBER_OF_LOOPS = 25;
        private static int NUMBER_OF_TESTS = 25;

        public static void RunTests()
        {
            Stopwatch timer = Stopwatch.StartNew();
            //            
//            StaticOperands_VariableInvocations_Profile();

            VariableOperands_StaticInvocations_Profile();

            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("\n\n>>>>>  ForLoop_Tests required    {0}    , sec", timespan.TotalSeconds);
            Output(time);
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

        private static void VariableOperands_StaticInvocations_Profile()
        {
            ForLoop_op2_in1.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op2_in1.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op2_in1.ITERATIONS = ITERATIONS;
            ForLoop_op2_in1.WARMUP = WARMUP;
            ForLoop_op2_in1.RunLoopTests();
            //

            ForLoop_op3_in1.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op3_in1.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op3_in1.ITERATIONS = ITERATIONS;
            ForLoop_op3_in1.WARMUP = WARMUP;
            ForLoop_op3_in1.RunLoopTests();
            //

            ForLoop_op4_in1_0.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op4_in1_0.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op4_in1_0.ITERATIONS = ITERATIONS;
            ForLoop_op4_in1_0.WARMUP = WARMUP;
            ForLoop_op4_in1_0.RunLoopTests();
            //
        }

        private static void StaticOperands_VariableInvocations_Profile()
        {
            ForLoop_op4_in1.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op4_in1.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op4_in1.ITERATIONS = ITERATIONS;
            ForLoop_op4_in1.WARMUP = WARMUP;
            ForLoop_op4_in1.RunLoopTests();
            //

            ForLoop_op4_in2.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op4_in2.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op4_in2.ITERATIONS = ITERATIONS;
            ForLoop_op4_in2.WARMUP = WARMUP;
            ForLoop_op4_in2.RunLoopTests();
            //

            ForLoop_op4_in3.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op4_in3.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op4_in3.ITERATIONS = ITERATIONS;
            ForLoop_op4_in3.WARMUP = WARMUP;
            ForLoop_op4_in3.RunLoopTests();
            //

            ForLoop_op4_in4.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op4_in4.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op4_in4.ITERATIONS = ITERATIONS;
            ForLoop_op4_in4.WARMUP = WARMUP;
            ForLoop_op4_in4.RunLoopTests();
            //

            ForLoop_op4_in5.NUMBER_OF_TESTS = NUMBER_OF_TESTS;
            ForLoop_op4_in5.NUMBER_OF_LOOPS = NUMBER_OF_LOOPS;
            ForLoop_op4_in5.ITERATIONS = ITERATIONS;
            ForLoop_op4_in5.WARMUP = WARMUP;
            ForLoop_op4_in5.RunLoopTests();
            //
        }






    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op2_in1.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op2_in1
    {
        private static string TITLE = "ForLoop_op2_in1";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op2_in1 lt = new ForLoop_op2_in1();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated_op2_in1);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }

        private string ForSimple_Array_original(int b)
        {
            string sum = "" + 3 + 4 + "";
            var p1 = car.GetEngine().GetPistons().First().GetSize();
            sum += "[" + p1 + "]";
            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }



        private string ForSimple_Array_obfuscated_op2_in1(int b)
        {
            //Virtualization variables
            int[] code = new int[100285];
            object[] data = new object[4187];
            int vpc = 44;

            //Data init
            data[92] = b; //b 
            data[2364] = ""; //"" constant
            data[115] = 3; //3 constant
            data[1593] = 4; //4 constant
            data[3975] = "["; //"[" constant
            data[1280] = "]"; //"]" constant
            data[639] = 1; //1 constant
            data[2209] = 0; //0 constant
            data[2845] = "_"; //"_" constant
            data[416] = "~"; //"~" constant
            data[146] = "#"; //"#" constant
            data[3329] = 861137969; //addTemp_0 
            data[1424] = 426817913; //addTemp_1 
            data[2032] = 1090936824; //sum 
            data[3023] = (ConsoleCalculator.Engine)null; //invocationTemp_0 
            data[3639] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
            data[2752] = (ConsoleCalculator.Piston)null; //invocationTemp_2 
            data[1393] = (double)0.792997966889757; //p1 
            data[3658] = 1720645340; //addTemp_2 
            data[1742] = 1088886007; //addTemp_3 
            data[1371] = (ConsoleCalculator.Engine)null; //invocationTemp_3 
            data[464] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_4 
            data[3405] = 430; //memberTemp_0 
            data[89] = 690; //addTemp_4 
            data[540] = (ConsoleCalculator.Engine)null; //invocationTemp_5 
            data[633] = (ConsoleCalculator.Piston)null; //invocationTemp_6 
            data[3643] = 33887365; //invocationTemp_7 
            data[2869] = 179759393; //r 
            data[2173] = (string[])null; //dst 
            data[905] = 525; //var_forIndex_0 
            data[1525] = 629; //invocationTemp_8 
            data[3690] = false; //var_whileCondition_0 
            data[1760] = 748259412; //addTemp_5 
            data[1876] = 1366923731; //addTemp_6 
            data[3462] = 1837547023; //addTemp_7 
            data[3477] = 752; //invocationTemp_9 
            data[1817] = -877; //memberTemp_1 
            data[1135] = 450921265; //addTemp_8 
            data[3757] = -812; //jmpWhileDestinationName_3757 constant
            data[2785] = 69; //while_GoTo_True_2785 constant
            data[1722] = 810; //while_GoTo_False_1722 constant
            data[903] = -810; //while_FalseBlockSkip_903 constant

            //Code init

            code[44] = 7697; //ExpressionStatement_0 # ExpressionStatement_0
            code[27] = 3329; //addTemp_0
            code[58] = 2364; //""
            code[47] = 115; //3

            code[115] = 7697; //ExpressionStatement_0 # ExpressionStatement_1
            code[98] = 1424; //addTemp_1
            code[129] = 3329; //addTemp_0
            code[118] = 1593; //4

            code[186] = 7376; //ExpressionStatement_2 # ExpressionStatement_2
            code[197] = 2032; //sum
            code[204] = 1424; //addTemp_1
            code[212] = 2364; //""

            code[257] = 5089; //ExpressionStatement_3 # ExpressionStatement_3
            code[273] = 3023; //invocationTemp_0

            code[326] = 3369; //ExpressionStatement_4 # ExpressionStatement_4
            code[328] = 3639; //invocationTemp_1
            code[306] = 3023; //invocationTemp_0

            code[394] = 7503; //ExpressionStatement_5 # ExpressionStatement_5
            code[393] = 2752; //invocationTemp_2
            code[418] = 3639; //invocationTemp_1

            code[448] = 8977; //ExpressionStatement_6 # ExpressionStatement_6
            code[433] = 1393; //p1
            code[459] = 2752; //invocationTemp_2

            code[509] = 6388; //ExpressionStatement_7 # ExpressionStatement_7
            code[527] = 3658; //addTemp_2
            code[505] = 3975; //"["
            code[522] = 1393; //p1

            code[565] = 7376; //ExpressionStatement_2 # ExpressionStatement_8
            code[576] = 1742; //addTemp_3
            code[583] = 3658; //addTemp_2
            code[591] = 1280; //"]"

            code[636] = 7376; //ExpressionStatement_2 # ExpressionStatement_9
            code[647] = 2032; //sum
            code[654] = 2032; //sum
            code[662] = 1742; //addTemp_3

            code[707] = 5089; //ExpressionStatement_3 # ExpressionStatement_10
            code[723] = 1371; //invocationTemp_3

            code[776] = 3369; //ExpressionStatement_4 # ExpressionStatement_11
            code[778] = 464; //invocationTemp_4
            code[756] = 1371; //invocationTemp_3

            code[844] = 6463; //ExpressionStatement_12 # ExpressionStatement_12
            code[839] = 3405; //memberTemp_0
            code[824] = 464; //invocationTemp_4

            code[915] = 2167; //ExpressionStatement_13 # ExpressionStatement_13
            code[896] = 89; //addTemp_4
            code[938] = 3405; //memberTemp_0
            code[932] = 639; //1

            code[976] = 5089; //ExpressionStatement_3 # ExpressionStatement_14
            code[992] = 540; //invocationTemp_5

            code[1045] = 4181; //ExpressionStatement_15 # ExpressionStatement_15
            code[1028] = 633; //invocationTemp_6
            code[1051] = 540; //invocationTemp_5
            code[1035] = 89; //addTemp_4

            code[1109] = 5003; //ExpressionStatement_16 # ExpressionStatement_16
            code[1122] = 3643; //invocationTemp_7
            code[1103] = 633; //invocationTemp_6

            code[1165] = 7376; //ExpressionStatement_2 # ExpressionStatement_17
            code[1176] = 2032; //sum
            code[1183] = 2032; //sum
            code[1191] = 3643; //invocationTemp_7

            code[1236] = 7595; //ExpressionStatement_18 # ExpressionStatement_18
            code[1249] = 2869; //r
            code[1245] = 2364; //""

            code[1307] = 4138; //ExpressionStatement_19 # ExpressionStatement_19
            code[1305] = 2173; //dst
            code[1331] = 92; //b

            code[1367] = 7595; //ExpressionStatement_18 # ExpressionStatement_20
            code[1380] = 905; //var_forIndex_0
            code[1376] = 2209; //0

            code[1438] = 1729; //ExpressionStatement_21 # ExpressionStatement_21
            code[1452] = 1525; //invocationTemp_8
            code[1455] = 92; //b

            code[1507] = 4452; //ExpressionStatement_22 # ExpressionStatement_22
            code[1524] = 3690; //var_whileCondition_0
            code[1512] = 905; //var_forIndex_0
            code[1530] = 1525; //invocationTemp_8

            code[1574] = 4795; //WhileStatementSyntax_23 # WhileStatementSyntax_23
            code[1563] = 3757; //jmpWhileDestinationName_3757
            code[1583] = 3690; //var_whileCondition_0
            code[1596] = 2785; //while_GoTo_True_2785
            code[1571] = 1722; //while_GoTo_False_1722

            code[1643] = 7697; //ExpressionStatement_0 # ExpressionStatement_24
            code[1626] = 1760; //addTemp_5
            code[1657] = 2845; //"_"
            code[1646] = 905; //var_forIndex_0

            code[1714] = 7376; //ExpressionStatement_2 # ExpressionStatement_25
            code[1725] = 1876; //addTemp_6
            code[1732] = 1760; //addTemp_5
            code[1740] = 2845; //"_"

            code[1785] = 7376; //ExpressionStatement_2 # ExpressionStatement_26
            code[1796] = 2032; //sum
            code[1803] = 2032; //sum
            code[1811] = 1876; //addTemp_6

            code[1856] = 7376; //ExpressionStatement_2 # ExpressionStatement_27
            code[1867] = 2032; //sum
            code[1874] = 2032; //sum
            code[1882] = 416; //"~"

            code[1927] = 7376; //ExpressionStatement_2 # ExpressionStatement_28
            code[1938] = 3462; //addTemp_7
            code[1945] = 2032; //sum
            code[1953] = 146; //"#"

            code[1998] = 7376; //ExpressionStatement_2 # ExpressionStatement_29
            code[2009] = 2869; //r
            code[2016] = 2869; //r
            code[2024] = 3462; //addTemp_7

            code[2069] = 4327; //ExpressionStatement_30 # ExpressionStatement_30
            code[2060] = 2173; //dst
            code[2071] = 905; //var_forIndex_0
            code[2098] = 2032; //sum

            code[2133] = 5722; //ExpressionStatement_31 # ExpressionStatement_31
            code[2134] = 905; //var_forIndex_0
            code[2155] = 905; //var_forIndex_0
            code[2161] = 639; //1

            code[2187] = 1729; //ExpressionStatement_21 # ExpressionStatement_32
            code[2201] = 3477; //invocationTemp_9
            code[2204] = 92; //b

            code[2256] = 4452; //ExpressionStatement_22 # ExpressionStatement_33
            code[2273] = 3690; //var_whileCondition_0
            code[2261] = 905; //var_forIndex_0
            code[2279] = 3477; //invocationTemp_9

            code[2323] = 1141; //ExpressionStatement_34 # ExpressionStatement_34
            code[2349] = 903; //while_FalseBlockSkip_903

            code[2384] = 5471; //ExpressionStatement_35 # ExpressionStatement_35
            code[2372] = 1817; //memberTemp_1
            code[2391] = 2173; //dst

            code[2440] = 7697; //ExpressionStatement_0 # ExpressionStatement_36
            code[2423] = 1135; //addTemp_8
            code[2454] = 146; //"#"
            code[2443] = 1817; //memberTemp_1

            code[2511] = 7376; //ExpressionStatement_2 # ExpressionStatement_37
            code[2522] = 2032; //sum
            code[2529] = 2032; //sum
            code[2537] = 1135; //addTemp_8

            code[2582] = 7418; //ReturnStatement_38 # ReturnStatement_38
            code[2591] = 2032; //sum

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_3189_op2_in1(vpc, data, code);

        }


        private object InstanceInterpreterVirtualization_TraceLoopTests_3189_op2_in1(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 7697:  //frequency 4 ExpressionStatement_0
                        data[code[vpc + (-17)]] = (string)data[code[vpc + (14)]] + (int)data[code[vpc + (3)]];
                        vpc += 71;
                        break;
                    case 6463:  //frequency 1 ExpressionStatement_12
                        data[code[vpc + (-5)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-20)]]).Count;
                        vpc += 71;
                        break;
                    case 2167:  //frequency 1 ExpressionStatement_13
                        data[code[vpc + (-19)]] = (int)data[code[vpc + (23)]] - (int)data[code[vpc + (17)]];
                        vpc += 61;
                        break;
                    case 5089:  //frequency 3 ExpressionStatement_3
                        data[code[vpc + (16)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                        vpc += 69;
                        break;
                    case 4138:  //frequency 1 ExpressionStatement_19
                        data[code[vpc + (-2)]] = (string[])(new string[(int)data[code[vpc + (24)]]]);
                        vpc += 60;
                        break;
                    case 7595:  //frequency 2 ExpressionStatement_18
                        data[code[vpc + (13)]] = data[code[vpc + (9)]];
                        vpc += 71;
                        break;
                    default:  //frequency 0 
                        break;
                    case 7376:  //frequency 10 ExpressionStatement_2
                        data[code[vpc + (11)]] = (string)data[code[vpc + (18)]] + (string)data[code[vpc + (26)]];
                        vpc += 71;
                        break;
                    case 5722:  //frequency 1 ExpressionStatement_31
                        data[code[vpc + (1)]] = (int)data[code[vpc + (22)]] + (int)data[code[vpc + (28)]];
                        vpc += 54;
                        break;
                    case 5471:  //frequency 1 ExpressionStatement_35
                        data[code[vpc + (-12)]] = ((string[])data[code[vpc + (7)]]).Length;
                        vpc += 56;
                        break;
                    case 5003:  //frequency 1 ExpressionStatement_16
                        data[code[vpc + (13)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-6)]]).ToString();
                        vpc += 56;
                        break;
                    case 7503:  //frequency 1 ExpressionStatement_5
                        data[code[vpc + (-1)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (24)]]).First());
                        vpc += 54;
                        break;
                    case 1141:  //frequency 1 ExpressionStatement_34
                        vpc += (int)data[code[vpc + (26)]];
                        vpc += 61;
                        break;
                    case 4795:  //frequency 1 WhileStatementSyntax_23
                        data[code[vpc + (-11)]] = (bool)data[code[vpc + (9)]] ? (int)data[code[vpc + (22)]] : (int)data[code[vpc + (-3)]];
                        vpc += (int)data[code[vpc + (-11)]];
                        break;
                    case 4327:  //frequency 1 ExpressionStatement_30
                        ((string[])data[code[vpc + (-9)]])[(int)data[code[vpc + (2)]]] = (string)data[code[vpc + (29)]];
                        vpc += 64;
                        break;
                    case 1729:  //frequency 2 ExpressionStatement_21
                        data[code[vpc + (14)]] = ReturnArg_Array((int)data[code[vpc + (17)]]);
                        vpc += 69;
                        break;
                    case 3369:  //frequency 2 ExpressionStatement_4
                        data[code[vpc + (2)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (-20)]]).GetPistons());
                        vpc += 68;
                        break;
                    case 4452:  //frequency 2 ExpressionStatement_22
                        data[code[vpc + (17)]] = (int)data[code[vpc + (5)]] < (int)data[code[vpc + (23)]];
                        vpc += 67;
                        break;
                    case 8977:  //frequency 1 ExpressionStatement_6
                        data[code[vpc + (-15)]] = ((ConsoleCalculator.Piston)data[code[vpc + (11)]]).GetSize();
                        vpc += 61;
                        break;
                    case 7418:  //frequency 1 ReturnStatement_38
                        return (string)data[code[vpc + (9)]];
                        vpc += 60;
                    case 4181:  //frequency 1 ExpressionStatement_15
                        data[code[vpc + (-17)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (6)]]).GetPiston((int)data[code[vpc + (-10)]]));
                        vpc += 64;
                        break;
                    case 6388:  //frequency 1 ExpressionStatement_7
                        data[code[vpc + (18)]] = (string)data[code[vpc + (-4)]] + (double)data[code[vpc + (13)]];
                        vpc += 56;
                        break;
                }
            }

            return null;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original(b);
            string virt21 = ForSimple_Array_obfuscated_op2_in1(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }


     
        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op3_in1.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op3_in1
    {
        private static string TITLE = "ForLoop_op3_in1";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op3_in1 lt = new ForLoop_op3_in1();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated_op3_in1);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }

        private string ForSimple_Array_original(int b)
        {
            string sum = "" + 3 + 4 + "";
            var p1 = car.GetEngine().GetPistons().First().GetSize();
            sum += "[" + p1 + "]";
            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }


        private string ForSimple_Array_obfuscated_op3_in1(int b)
        {
            //Virtualization variables
            int[] code = new int[100599];
            object[] data = new object[4223];
            int vpc = 27;

            //Data init
            data[2490] = b; //b 
            data[236] = ""; //"" constant
            data[3339] = 3; //3 constant
            data[2874] = 4; //4 constant
            data[2745] = "["; //"[" constant
            data[413] = "]"; //"]" constant
            data[2971] = 1; //1 constant
            data[3769] = 0; //0 constant
            data[536] = "_"; //"_" constant
            data[2569] = "~"; //"~" constant
            data[1869] = "#"; //"#" constant
            data[1920] = 245619067; //addTemp_0 
            data[2246] = 1707035993; //sum 
            data[1218] = (ConsoleCalculator.Engine)null; //invocationTemp_0 
            data[1885] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
            data[2989] = (ConsoleCalculator.Piston)null; //invocationTemp_2 
            data[746] = (double)0.107707382229952; //p1 
            data[1309] = 559922757; //addTemp_1 
            data[599] = (ConsoleCalculator.Engine)null; //invocationTemp_3 
            data[992] = (ConsoleCalculator.Engine)null; //invocationTemp_4 
            data[211] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_5 
            data[583] = 214; //memberTemp_0 
            data[925] = (ConsoleCalculator.Piston)null; //invocationTemp_6 
            data[2876] = 1776754745; //invocationTemp_7 
            data[1495] = 875045554; //r 
            data[1921] = (string[])null; //dst 
            data[1398] = 257; //var_forIndex_0 
            data[235] = 197; //invocationTemp_8 
            data[3871] = false; //var_whileCondition_0 
            data[3894] = 1017451102; //addTemp_2 
            data[1276] = -630; //invocationTemp_9 
            data[1913] = -294; //memberTemp_1 
            data[2523] = 558; //jmpWhileDestinationName_2523 constant
            data[1129] = 70; //while_GoTo_True_1129 constant
            data[306] = 634; //while_GoTo_False_306 constant
            data[1251] = -634; //while_FalseBlockSkip_1251 constant

            //Code init

            code[27] = 8506; //ExpressionStatement_0 # ExpressionStatement_0
            code[43] = 1920; //addTemp_0
            code[47] = 236; //""
            code[44] = 3339; //3
            code[37] = 2874; //4

            code[96] = 4875; //ExpressionStatement_1 # ExpressionStatement_1
            code[83] = 2246; //sum
            code[114] = 1920; //addTemp_0
            code[98] = 236; //""

            code[161] = 1230; //ExpressionStatement_2 # ExpressionStatement_2
            code[170] = 1218; //invocationTemp_0

            code[213] = 4523; //ExpressionStatement_3 # ExpressionStatement_3
            code[210] = 1885; //invocationTemp_1
            code[216] = 1218; //invocationTemp_0

            code[265] = 2041; //ExpressionStatement_4 # ExpressionStatement_4
            code[255] = 2989; //invocationTemp_2
            code[282] = 1885; //invocationTemp_1

            code[323] = 9767; //ExpressionStatement_5 # ExpressionStatement_5
            code[319] = 746; //p1
            code[352] = 2989; //invocationTemp_2

            code[378] = 9652; //ExpressionStatement_6 # ExpressionStatement_6
            code[389] = 1309; //addTemp_1
            code[405] = 2745; //"["
            code[380] = 746; //p1
            code[383] = 413; //"]"

            code[433] = 4875; //ExpressionStatement_1 # ExpressionStatement_7
            code[420] = 2246; //sum
            code[451] = 2246; //sum
            code[435] = 1309; //addTemp_1

            code[498] = 1230; //ExpressionStatement_2 # ExpressionStatement_8
            code[507] = 599; //invocationTemp_3

            code[550] = 1230; //ExpressionStatement_2 # ExpressionStatement_9
            code[559] = 992; //invocationTemp_4

            code[602] = 4523; //ExpressionStatement_3 # ExpressionStatement_10
            code[599] = 211; //invocationTemp_5
            code[605] = 992; //invocationTemp_4

            code[654] = 6185; //ExpressionStatement_11 # ExpressionStatement_11
            code[635] = 583; //memberTemp_0
            code[663] = 211; //invocationTemp_5

            code[717] = 9172; //ExpressionStatement_12 # ExpressionStatement_12
            code[721] = 925; //invocationTemp_6
            code[701] = 599; //invocationTemp_3
            code[699] = 583; //memberTemp_0
            code[709] = 2971; //1

            code[778] = 1057; //ExpressionStatement_13 # ExpressionStatement_13
            code[777] = 2876; //invocationTemp_7
            code[788] = 925; //invocationTemp_6

            code[843] = 4875; //ExpressionStatement_1 # ExpressionStatement_14
            code[830] = 2246; //sum
            code[861] = 2246; //sum
            code[845] = 2876; //invocationTemp_7

            code[908] = 8883; //ExpressionStatement_15 # ExpressionStatement_15
            code[902] = 1495; //r
            code[895] = 236; //""

            code[965] = 5453; //ExpressionStatement_16 # ExpressionStatement_16
            code[964] = 1921; //dst
            code[950] = 2490; //b

            code[1030] = 8883; //ExpressionStatement_15 # ExpressionStatement_17
            code[1024] = 1398; //var_forIndex_0
            code[1017] = 3769; //0

            code[1087] = 9853; //ExpressionStatement_18 # ExpressionStatement_18
            code[1073] = 235; //invocationTemp_8
            code[1105] = 2490; //b

            code[1146] = 5855; //ExpressionStatement_19 # ExpressionStatement_19
            code[1135] = 3871; //var_whileCondition_0
            code[1133] = 1398; //var_forIndex_0
            code[1158] = 235; //invocationTemp_8

            code[1214] = 7901; //WhileStatementSyntax_20 # WhileStatementSyntax_20
            code[1211] = 2523; //jmpWhileDestinationName_2523
            code[1239] = 3871; //var_whileCondition_0
            code[1229] = 1129; //while_GoTo_True_1129
            code[1210] = 306; //while_GoTo_False_306

            code[1284] = 4796; //ExpressionStatement_21 # ExpressionStatement_21
            code[1290] = 3894; //addTemp_2
            code[1310] = 536; //"_"
            code[1296] = 1398; //var_forIndex_0
            code[1304] = 536; //"_"

            code[1342] = 4875; //ExpressionStatement_1 # ExpressionStatement_22
            code[1329] = 2246; //sum
            code[1360] = 2246; //sum
            code[1344] = 3894; //addTemp_2

            code[1407] = 4875; //ExpressionStatement_1 # ExpressionStatement_23
            code[1394] = 2246; //sum
            code[1425] = 2246; //sum
            code[1409] = 2569; //"~"

            code[1472] = 6859; //ExpressionStatement_24 # ExpressionStatement_24
            code[1501] = 1495; //r
            code[1491] = 1495; //r
            code[1458] = 2246; //sum
            code[1483] = 1869; //"#"

            code[1528] = 8472; //ExpressionStatement_25 # ExpressionStatement_25
            code[1548] = 1921; //dst
            code[1533] = 1398; //var_forIndex_0
            code[1531] = 2246; //sum

            code[1586] = 1203; //ExpressionStatement_26 # ExpressionStatement_26
            code[1582] = 1398; //var_forIndex_0
            code[1603] = 1398; //var_forIndex_0
            code[1607] = 2971; //1

            code[1654] = 9853; //ExpressionStatement_18 # ExpressionStatement_27
            code[1640] = 1276; //invocationTemp_9
            code[1672] = 2490; //b

            code[1713] = 5855; //ExpressionStatement_19 # ExpressionStatement_28
            code[1702] = 3871; //var_whileCondition_0
            code[1700] = 1398; //var_forIndex_0
            code[1725] = 1276; //invocationTemp_9

            code[1781] = 7253; //ExpressionStatement_29 # ExpressionStatement_29
            code[1776] = 1251; //while_FalseBlockSkip_1251

            code[1848] = 5791; //ExpressionStatement_30 # ExpressionStatement_30
            code[1839] = 1913; //memberTemp_1
            code[1828] = 1921; //dst

            code[1913] = 5456; //ExpressionStatement_31 # ExpressionStatement_31
            code[1932] = 2246; //sum
            code[1928] = 2246; //sum
            code[1922] = 1869; //"#"
            code[1910] = 1913; //memberTemp_1

            code[1979] = 2324; //ReturnStatement_32 # ReturnStatement_32
            code[1983] = 2246; //sum

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_1574_op3_in1(vpc, data, code);

        }



        private object InstanceInterpreterVirtualization_TraceLoopTests_1574_op3_in1(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 6859:  //frequency 1 ExpressionStatement_24
                        data[code[vpc + (29)]] = (string)data[code[vpc + (19)]] + (string)data[code[vpc + (-14)]] + (string)data[code[vpc + (11)]];
                        vpc += 56;
                        break;
                    case 5453:  //frequency 1 ExpressionStatement_16
                        data[code[vpc + (-1)]] = (string[])(new string[(int)data[code[vpc + (-15)]]]);
                        vpc += 65;
                        break;
                    case 9767:  //frequency 1 ExpressionStatement_5
                        data[code[vpc + (-4)]] = ((ConsoleCalculator.Piston)data[code[vpc + (29)]]).GetSize();
                        vpc += 55;
                        break;
                    case 9853:  //frequency 2 ExpressionStatement_18
                        data[code[vpc + (-14)]] = ReturnArg_Array((int)data[code[vpc + (18)]]);
                        vpc += 59;
                        break;
                    case 2041:  //frequency 1 ExpressionStatement_4
                        data[code[vpc + (-10)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (17)]]).First());
                        vpc += 58;
                        break;
                    case 5791:  //frequency 1 ExpressionStatement_30
                        data[code[vpc + (-9)]] = ((string[])data[code[vpc + (-20)]]).Length;
                        vpc += 65;
                        break;
                    case 5855:  //frequency 2 ExpressionStatement_19
                        data[code[vpc + (-11)]] = (int)data[code[vpc + (-13)]] < (int)data[code[vpc + (12)]];
                        vpc += 68;
                        break;
                    case 4523:  //frequency 2 ExpressionStatement_3
                        data[code[vpc + (-3)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (3)]]).GetPistons());
                        vpc += 52;
                        break;
                    case 9172:  //frequency 1 ExpressionStatement_12
                        data[code[vpc + (4)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (-16)]]).GetPiston((int)data[code[vpc + (-18)]] - (int)data[code[vpc + (-8)]]));
                        vpc += 61;
                        break;
                    case 8883:  //frequency 2 ExpressionStatement_15
                        data[code[vpc + (-6)]] = data[code[vpc + (-13)]];
                        vpc += 57;
                        break;
                    case 7253:  //frequency 1 ExpressionStatement_29
                        vpc += (int)data[code[vpc + (-5)]];
                        vpc += 67;
                        break;
                    case 1057:  //frequency 1 ExpressionStatement_13
                        data[code[vpc + (-1)]] = ((ConsoleCalculator.Piston)data[code[vpc + (10)]]).ToString();
                        vpc += 65;
                        break;
                    case 2324:  //frequency 1 ReturnStatement_32
                        return (string)data[code[vpc + (4)]];
                        vpc += 59;
                    case 4796:  //frequency 1 ExpressionStatement_21
                        data[code[vpc + (6)]] = (string)data[code[vpc + (26)]] + (int)data[code[vpc + (12)]] + (string)data[code[vpc + (20)]];
                        vpc += 58;
                        break;
                    case 4875:  //frequency 5 ExpressionStatement_1
                        data[code[vpc + (-13)]] = (string)data[code[vpc + (18)]] + (string)data[code[vpc + (2)]];
                        vpc += 65;
                        break;
                    case 9652:  //frequency 1 ExpressionStatement_6
                        data[code[vpc + (11)]] = (string)data[code[vpc + (27)]] + (double)data[code[vpc + (2)]] + (string)data[code[vpc + (5)]];
                        vpc += 55;
                        break;
                    case 1203:  //frequency 1 ExpressionStatement_26
                        data[code[vpc + (-4)]] = (int)data[code[vpc + (17)]] + (int)data[code[vpc + (21)]];
                        vpc += 68;
                        break;
                    case 6185:  //frequency 1 ExpressionStatement_11
                        data[code[vpc + (-19)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (9)]]).Count;
                        vpc += 63;
                        break;
                    case 1230:  //frequency 3 ExpressionStatement_2
                        data[code[vpc + (9)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                        vpc += 52;
                        break;
                    default:  //frequency 0 
                        break;
                    case 8506:  //frequency 1 ExpressionStatement_0
                        data[code[vpc + (16)]] = (string)data[code[vpc + (20)]] + (int)data[code[vpc + (17)]] + (int)data[code[vpc + (10)]];
                        vpc += 69;
                        break;
                    case 5456:  //frequency 1 ExpressionStatement_31
                        data[code[vpc + (19)]] = (string)data[code[vpc + (15)]] + (string)data[code[vpc + (9)]] + (int)data[code[vpc + (-3)]];
                        vpc += 66;
                        break;
                    case 8472:  //frequency 1 ExpressionStatement_25
                        ((string[])data[code[vpc + (20)]])[(int)data[code[vpc + (5)]]] = (string)data[code[vpc + (3)]];
                        vpc += 58;
                        break;
                    case 7901:  //frequency 1 WhileStatementSyntax_20
                        data[code[vpc + (-3)]] = (bool)data[code[vpc + (25)]] ? (int)data[code[vpc + (15)]] : (int)data[code[vpc + (-4)]];
                        vpc += (int)data[code[vpc + (-3)]];
                        break;
                }
            }

            return null;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original(b);
            string virt21 = ForSimple_Array_obfuscated_op3_in1(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }


     
        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op4_in1.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op4_in1
    {
        private static string TITLE = "ForLoop_op4_in1";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op4_in1 lt = new ForLoop_op4_in1();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated2_op4_in1);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }
        private string ForSimple_Array_obfuscated2_op4_in1(int b)
        {
            //Virtualization variables
            int[] code = new int[100640];
            object[] data = new object[4600];
            int vpc = 74;

            //Data init
            data[2262] = b; //b 
            data[338] = ""; //"" constant
            data[3290] = 3; //3 constant
            data[2944] = 4; //4 constant
            data[2282] = 1; //1 constant
            data[977] = 0; //0 constant
            data[2695] = "_"; //"_" constant
            data[2478] = "~"; //"~" constant
            data[2115] = "#"; //"#" constant
            data[782] = "["; //"[" constant
            data[1091] = "]"; //"]" constant
            data[3044] = 580772629; //sum 
            data[1586] = (ConsoleCalculator.Engine)null; //invocationTemp_0 
            data[1315] = (ConsoleCalculator.Engine)null; //invocationTemp_1 
            data[2794] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_2 
            data[3259] = -365; //memberTemp_0 
            data[3845] = (ConsoleCalculator.Piston)null; //invocationTemp_3 
            data[3759] = 108831917; //invocationTemp_4 
            data[2048] = 614725912; //r 
            data[3360] = (string[])null; //dst 
            data[480] = 190; //var_forIndex_0 
            data[621] = 689; //invocationTemp_5 
            data[2673] = false; //var_whileCondition_0 
            data[2235] = (ConsoleCalculator.Engine)null; //invocationTemp_6 
            data[3793] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_7 
            data[3658] = (ConsoleCalculator.Piston)null; //invocationTemp_8 
            data[1945] = (double)0.291733439216266; //p1 
            data[3832] = 539; //memberTemp_1 
            data[2008] = 59; //invocationTemp_9 
            data[1495] = -698; //memberTemp_2 
            data[1440] = 159; //fake-1440 
            data[1987] = 812; //fake-1987 
            data[1641] = 169; //fake-1641 
            data[2623] = 130; //fake-2623 
            data[620] = 792; //fake-620 
            data[3463] = 393; //fake-3463 
            data[1222] = -992; //fake-1222 
            data[184] = -770; //fake-184 
            data[530] = -265; //fake-530 
            data[2584] = 496; //fake-2584 
            data[3913] = 10; //fake-3913 
            data[3815] = 40; //fake-3815 
            data[3663] = 310; //fake-3663 
            data[1457] = -209; //fake-1457 
            data[608] = -723; //fake-608 
            data[860] = -587; //fake-860 
            data[3673] = 690; //fake-3673 
            data[2463] = -582; //fake-2463 
            data[2575] = 259; //fake-2575 
            data[1821] = -923; //fake-1821 
            data[3165] = -921; //fake-3165 
            data[2613] = -350; //fake-2613 
            data[2676] = 156; //fake-2676 
            data[1211] = -966; //fake-1211 
            data[3213] = 678; //fake-3213 
            data[3882] = -639; //fake-3882 
            data[1298] = -37; //fake-1298 
            data[3125] = -537; //fake-3125 
            data[2968] = -999; //fake-2968 
            data[2578] = 481; //fake-2578 
            data[2864] = -701; //fake-2864 
            data[1] = -248; //fake-1 
            data[2106] = -199; //fake-2106 
            data[100] = -777; //fake-100 
            data[249] = -965; //fake-249 
            data[244] = 139; //fake-244 
            data[1303] = -690; //fake-1303 
            data[2432] = 962; //fake-2432 
            data[960] = -505; //fake-960 
            data[374] = -413; //fake-374 
            data[1119] = -720; //fake-1119 
            data[2717] = 806; //jmpWhileDestinationName_2717 constant
            data[1279] = 69; //while_GoTo_True_1279 constant
            data[1078] = 1001; //while_GoTo_False_1078 constant
            data[1426] = -1001; //while_FalseBlockSkip_1426 constant
            data[1490] = -435; //fake-1490 
            data[2750] = 105; //fake-2750 
            data[3464] = 339; //fake-3464 
            data[1969] = 500; //fake-1969 
            data[3671] = 325; //fake-3671 
            data[2927] = 310; //fake-2927 
            data[158] = -705; //fake-158 
            data[2501] = -224; //fake-2501 
            data[3508] = 999; //fake-3508 
            data[1750] = -835; //fake-1750 
            data[3283] = -720; //fake-3283 
            data[3554] = -18; //fake-3554 
            data[3640] = -778; //fake-3640 
            data[3649] = -491; //fake-3649 
            data[2649] = -344; //fake-2649 
            data[3859] = 135; //fake-3859 
            data[3817] = 452; //fake-3817 
            data[2878] = 431; //fake-2878 
            data[518] = -571; //fake-518 
            data[2389] = 544; //fake-2389 
            data[3432] = -772; //fake-3432 
            data[552] = 254; //fake-552 
            data[1583] = 196; //fake-1583 
            data[3615] = -743; //fake-3615 
            data[101] = -762; //fake-101 
            data[3005] = 87; //fake-3005 
            data[3810] = -245; //fake-3810 
            data[3010] = 137; //fake-3010 
            data[2652] = -897; //fake-2652 
            data[149] = 727; //fake-149 
            data[2248] = 922; //fake-2248 
            data[1207] = -329; //fake-1207 
            data[470] = 796; //fake-470 
            data[3873] = -727; //fake-3873 
            data[1016] = -916; //fake-1016 
            data[1202] = -950; //fake-1202 
            data[824] = -306; //fake-824 
            data[3537] = -823; //fake-3537 
            data[1684] = 36; //fake-1684 
            data[1488] = 653; //fake-1488 
            data[1076] = -832; //fake-1076 
            data[1021] = 224; //fake-1021 
            data[1738] = 482; //fake-1738 
            data[3555] = -866; //fake-3555 
            data[1320] = -528; //fake-1320 
            data[3711] = 819; //fake-3711 
            data[3597] = -1000; //fake-3597 
            data[872] = 525; //fake-872 
            data[2727] = -517; //fake-2727 
            data[1375] = 175; //fake-1375 
            data[270] = -490; //fake-270 
            data[3140] = 64; //fake-3140 
            data[2813] = -842; //fake-2813 
            data[3282] = -265; //fake-3282 
            data[1429] = 577; //fake-1429 
            data[3834] = 311; //fake-3834 
            data[740] = 909; //fake-740 
            data[3898] = 82; //fake-3898 
            data[320] = 261; //fake-320 
            data[956] = -763; //fake-956 
            data[2838] = -446; //fake-2838 
            data[3440] = 158; //fake-3440 
            data[2774] = -327; //fake-2774 
            data[3386] = -729; //fake-3386 

            //Code init

            code[74] = 5774; //ExpressionStatement_0 # ExpressionStatement_0
            code[54] = 3044; //sum
            code[75] = 338; //""
            code[65] = 3290; //3
            code[85] = 2944; //4
            code[64] = 338; //""
            code[59] = 1655; //fake-ExpressionStatement_0_1655_-15

            code[130] = 7716; //ExpressionStatement_1 # ExpressionStatement_1
            code[125] = 1586; //invocationTemp_0
            code[129] = 570; //fake-ExpressionStatement_1_570_-1
            code[149] = 2374; //fake-ExpressionStatement_1_2374_19
            code[149] = 1054; //fake-ExpressionStatement_1_1054_19
            code[115] = 2862; //fake-ExpressionStatement_1_2862_-15
            code[117] = 2526; //fake-ExpressionStatement_1_2526_-13

            code[196] = 7716; //ExpressionStatement_1 # ExpressionStatement_2
            code[191] = 1315; //invocationTemp_1
            code[212] = 1532; //fake-ExpressionStatement_1_1532_16
            code[211] = 86; //fake-ExpressionStatement_1_86_15
            code[186] = 2028; //fake-ExpressionStatement_1_2028_-10

            code[262] = 6043; //ExpressionStatement_3 # ExpressionStatement_3
            code[291] = 2794; //invocationTemp_2
            code[244] = 1315; //invocationTemp_1
            code[278] = 30; //fake-ExpressionStatement_3_30_16
            code[263] = 672; //fake-ExpressionStatement_3_672_1
            code[256] = 411; //fake-ExpressionStatement_3_411_-6
            code[271] = 1679; //fake-ExpressionStatement_3_1679_9

            code[321] = 7373; //ExpressionStatement_4 # ExpressionStatement_4
            code[333] = 3259; //memberTemp_0
            code[310] = 2794; //invocationTemp_2
            code[305] = 2288; //fake-ExpressionStatement_4_2288_-16

            code[388] = 7807; //ExpressionStatement_5 # ExpressionStatement_5
            code[394] = 3845; //invocationTemp_3
            code[397] = 1586; //invocationTemp_0
            code[375] = 3259; //memberTemp_0
            code[405] = 2282; //1
            code[400] = 2397; //fake-ExpressionStatement_5_2397_12
            code[372] = 2502; //fake-ExpressionStatement_5_2502_-16
            code[410] = 1307; //fake-ExpressionStatement_5_1307_22
            code[372] = 367; //fake-ExpressionStatement_5_367_-16

            code[453] = 2223; //ExpressionStatement_6 # ExpressionStatement_6
            code[463] = 3759; //invocationTemp_4
            code[450] = 3845; //invocationTemp_3
            code[454] = 2444; //fake-ExpressionStatement_6_2444_1
            code[475] = 1940; //fake-ExpressionStatement_6_1940_22
            code[459] = 3789; //fake-ExpressionStatement_6_3789_6

            code[522] = 7862; //ExpressionStatement_7 # ExpressionStatement_7
            code[541] = 3044; //sum
            code[532] = 3044; //sum
            code[529] = 3759; //invocationTemp_4
            code[527] = 3455; //fake-ExpressionStatement_7_3455_5
            code[527] = 1089; //fake-ExpressionStatement_7_1089_5
            code[524] = 1226; //fake-ExpressionStatement_7_1226_2

            code[583] = 8318; //ExpressionStatement_8 # ExpressionStatement_8
            code[565] = 2048; //r
            code[598] = 338; //""
            code[593] = 1375; //fake-ExpressionStatement_8_1375_10
            code[612] = 3485; //fake-ExpressionStatement_8_3485_29
            code[587] = 1200; //fake-ExpressionStatement_8_1200_4

            code[649] = 4889; //ExpressionStatement_9 # ExpressionStatement_9
            code[641] = 3360; //dst
            code[631] = 2262; //b
            code[634] = 3975; //fake-ExpressionStatement_9_3975_-15
            code[677] = 37; //fake-ExpressionStatement_9_37_28
            code[650] = 594; //fake-ExpressionStatement_9_594_1
            code[647] = 3912; //fake-ExpressionStatement_9_3912_-2
            code[632] = 1185; //fake-ExpressionStatement_9_1185_-17
            code[678] = 3558; //fake-ExpressionStatement_9_3558_29
            code[677] = 3240; //fake-ExpressionStatement_9_3240_28

            code[715] = 8318; //ExpressionStatement_8 # ExpressionStatement_10
            code[697] = 480; //var_forIndex_0
            code[730] = 977; //0
            code[731] = 3496; //fake-ExpressionStatement_8_3496_16

            code[781] = 8245; //ExpressionStatement_11 # ExpressionStatement_11
            code[808] = 621; //invocationTemp_5
            code[807] = 2262; //b
            code[792] = 1337; //fake-ExpressionStatement_11_1337_11
            code[789] = 2890; //fake-ExpressionStatement_11_2890_8
            code[766] = 1287; //fake-ExpressionStatement_11_1287_-15
            code[793] = 543; //fake-ExpressionStatement_11_543_12

            code[847] = 2063; //ExpressionStatement_12 # ExpressionStatement_12
            code[855] = 2673; //var_whileCondition_0
            code[831] = 480; //var_forIndex_0
            code[834] = 621; //invocationTemp_5
            code[846] = 3795; //fake-ExpressionStatement_12_3795_-1
            code[856] = 2786; //fake-ExpressionStatement_12_2786_9

            code[900] = 6605; //WhileStatementSyntax_13 # WhileStatementSyntax_13
            code[918] = 2717; //jmpWhileDestinationName_2717
            code[919] = 2673; //var_whileCondition_0
            code[916] = 1279; //while_GoTo_True_1279
            code[898] = 1078; //while_GoTo_False_1078
            code[902] = 2375; //fake-fake-whileVirtualOperation_2375_2
            code[885] = 88; //fake-fake-whileVirtualOperation_88_-15
            code[917] = 2328; //fake-fake-whileVirtualOperation_2328_17
            code[922] = 2892; //fake-fake-whileVirtualOperation_2892_22

            code[969] = 3889; //ExpressionStatement_14 # ExpressionStatement_14
            code[994] = 3044; //sum
            code[985] = 3044; //sum
            code[965] = 2695; //"_"
            code[952] = 480; //var_forIndex_0
            code[990] = 2695; //"_"
            code[986] = 2747; //fake-ExpressionStatement_14_2747_17
            code[963] = 1488; //fake-ExpressionStatement_14_1488_-6
            code[971] = 1904; //fake-ExpressionStatement_14_1904_2
            code[956] = 837; //fake-ExpressionStatement_14_837_-13
            code[967] = 2728; //fake-ExpressionStatement_14_2728_-2
            code[988] = 2541; //fake-ExpressionStatement_14_2541_19

            code[1037] = 7862; //ExpressionStatement_7 # ExpressionStatement_15
            code[1056] = 3044; //sum
            code[1047] = 3044; //sum
            code[1044] = 2478; //"~"
            code[1036] = 3325; //fake-ExpressionStatement_7_3325_-1
            code[1043] = 3081; //fake-ExpressionStatement_7_3081_6
            code[1041] = 1973; //fake-ExpressionStatement_7_1973_4
            code[1036] = 3782; //fake-ExpressionStatement_7_3782_-1
            code[1059] = 65; //fake-ExpressionStatement_7_65_22

            code[1098] = 6517; //ExpressionStatement_16 # ExpressionStatement_16
            code[1103] = 2048; //r
            code[1122] = 2048; //r
            code[1110] = 3044; //sum
            code[1096] = 2115; //"#"
            code[1085] = 3780; //fake-ExpressionStatement_16_3780_-13

            code[1154] = 7716; //ExpressionStatement_1 # ExpressionStatement_17
            code[1149] = 2235; //invocationTemp_6
            code[1161] = 376; //fake-ExpressionStatement_1_376_7
            code[1169] = 6; //fake-ExpressionStatement_1_6_15
            code[1169] = 3932; //fake-ExpressionStatement_1_3932_15
            code[1170] = 1761; //fake-ExpressionStatement_1_1761_16
            code[1164] = 804; //fake-ExpressionStatement_1_804_10
            code[1140] = 2047; //fake-ExpressionStatement_1_2047_-14
            code[1172] = 2489; //fake-ExpressionStatement_1_2489_18

            code[1220] = 6043; //ExpressionStatement_3 # ExpressionStatement_18
            code[1249] = 3793; //invocationTemp_7
            code[1202] = 2235; //invocationTemp_6
            code[1217] = 3258; //fake-ExpressionStatement_3_3258_-3
            code[1242] = 2537; //fake-ExpressionStatement_3_2537_22
            code[1200] = 109; //fake-ExpressionStatement_3_109_-20
            code[1231] = 3426; //fake-ExpressionStatement_3_3426_11
            code[1222] = 3206; //fake-ExpressionStatement_3_3206_2

            code[1279] = 7054; //ExpressionStatement_19 # ExpressionStatement_19
            code[1285] = 3658; //invocationTemp_8
            code[1305] = 3793; //invocationTemp_7
            code[1307] = 1004; //fake-ExpressionStatement_19_1004_28

            code[1345] = 3144; //ExpressionStatement_20 # ExpressionStatement_20
            code[1362] = 1945; //p1
            code[1363] = 3658; //invocationTemp_8
            code[1328] = 1490; //fake-ExpressionStatement_20_1490_-17
            code[1330] = 3538; //fake-ExpressionStatement_20_3538_-15

            code[1408] = 6440; //ExpressionStatement_21 # ExpressionStatement_21
            code[1388] = 2048; //r
            code[1420] = 2048; //r
            code[1412] = 782; //"["
            code[1404] = 1945; //p1
            code[1390] = 1091; //"]"
            code[1399] = 1221; //fake-ExpressionStatement_21_1221_-9
            code[1428] = 282; //fake-ExpressionStatement_21_282_20
            code[1432] = 1532; //fake-ExpressionStatement_21_1532_24
            code[1426] = 6; //fake-ExpressionStatement_21_6_18

            code[1479] = 1796; //ExpressionStatement_22 # ExpressionStatement_22
            code[1460] = 3832; //memberTemp_1
            code[1497] = 2048; //r
            code[1459] = 2606; //fake-ExpressionStatement_22_2606_-20
            code[1505] = 2281; //fake-ExpressionStatement_22_2281_26

            code[1540] = 6361; //ExpressionStatement_23 # ExpressionStatement_23
            code[1544] = 3044; //sum
            code[1568] = 3044; //sum
            code[1530] = 3832; //memberTemp_1
            code[1569] = 1401; //fake-ExpressionStatement_23_1401_29

            code[1602] = 6050; //ExpressionStatement_24 # ExpressionStatement_24
            code[1631] = 3360; //dst
            code[1603] = 480; //var_forIndex_0
            code[1585] = 3044; //sum
            code[1623] = 689; //fake-ExpressionStatement_24_689_21
            code[1583] = 2266; //fake-ExpressionStatement_24_2266_-19
            code[1614] = 3081; //fake-ExpressionStatement_24_3081_12
            code[1607] = 318; //fake-ExpressionStatement_24_318_5
            code[1621] = 2641; //fake-ExpressionStatement_24_2641_19

            code[1663] = 5703; //ExpressionStatement_25 # ExpressionStatement_25
            code[1685] = 480; //var_forIndex_0
            code[1653] = 480; //var_forIndex_0
            code[1650] = 2282; //1
            code[1666] = 1455; //fake-ExpressionStatement_25_1455_3

            code[1731] = 8245; //ExpressionStatement_11 # ExpressionStatement_26
            code[1758] = 2008; //invocationTemp_9
            code[1757] = 2262; //b
            code[1722] = 84; //fake-ExpressionStatement_11_84_-9
            code[1754] = 394; //fake-ExpressionStatement_11_394_23

            code[1797] = 2063; //ExpressionStatement_12 # ExpressionStatement_27
            code[1805] = 2673; //var_whileCondition_0
            code[1781] = 480; //var_forIndex_0
            code[1784] = 2008; //invocationTemp_9
            code[1812] = 785; //fake-ExpressionStatement_12_785_15
            code[1804] = 576; //fake-ExpressionStatement_12_576_7
            code[1819] = 2705; //fake-ExpressionStatement_12_2705_22
            code[1803] = 2307; //fake-ExpressionStatement_12_2307_6

            code[1850] = 9860; //ExpressionStatement_28 # ExpressionStatement_28
            code[1864] = 1426; //while_FalseBlockSkip_1426
            code[1871] = 2694; //fake-ExpressionStatement_28_2694_21
            code[1839] = 1697; //fake-ExpressionStatement_28_1697_-11
            code[1869] = 408; //fake-ExpressionStatement_28_408_19
            code[1879] = 3033; //fake-ExpressionStatement_28_3033_29
            code[1858] = 1446; //fake-ExpressionStatement_28_1446_8
            code[1868] = 923; //fake-ExpressionStatement_28_923_18

            code[1901] = 1706; //ExpressionStatement_29 # ExpressionStatement_29
            code[1925] = 1495; //memberTemp_2
            code[1889] = 3360; //dst
            code[1910] = 3505; //fake-ExpressionStatement_29_3505_9
            code[1902] = 56; //fake-ExpressionStatement_29_56_1

            code[1962] = 2942; //ExpressionStatement_30 # ExpressionStatement_30
            code[1944] = 3044; //sum
            code[1961] = 3044; //sum
            code[1991] = 2115; //"#"
            code[1983] = 1495; //memberTemp_2
            code[1965] = 2058; //fake-ExpressionStatement_30_2058_3
            code[1950] = 3443; //fake-ExpressionStatement_30_3443_-12
            code[1973] = 28; //fake-ExpressionStatement_30_28_11

            code[2034] = 2372; //ReturnStatement_31 # ReturnStatement_31
            code[2058] = 3044; //sum
            code[2049] = 3215; //fake-ReturnStatement_31_3215_15
            code[2014] = 912; //fake-ReturnStatement_31_912_-20
            code[2032] = 1990; //fake-ReturnStatement_31_1990_-2

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_3664_2_op4_in1(vpc, data, code);

        }


        private object InstanceInterpreterVirtualization_TraceLoopTests_3664_2_op4_in1(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 6361:  //frequency 1 ExpressionStatement_23
                        data[code[vpc + (4)]] = (string)data[code[vpc + (28)]] + (int)data[code[vpc + (-10)]];
                        vpc += 62;
                        break;
                    case 9860:  //frequency 1 ExpressionStatement_28
                        vpc += (int)data[code[vpc + (14)]];
                        vpc += 51;
                        break;
                    case 2372:  //frequency 1 ReturnStatement_31
                        return (string)data[code[vpc + (24)]];
                        vpc += 56;
                    case 6440:  //frequency 1 ExpressionStatement_21
                        data[code[vpc + (-20)]] = (string)data[code[vpc + (12)]] + (string)data[code[vpc + (4)]] + (double)data[code[vpc + (-4)]] + (string)data[code[vpc + (-18)]];
                        vpc += 71;
                        break;
                    case 4889:  //frequency 1 ExpressionStatement_9
                        data[code[vpc + (-8)]] = (string[])(new string[(int)data[code[vpc + (-18)]]]);
                        vpc += 66;
                        break;
                    case 6517:  //frequency 1 ExpressionStatement_16
                        data[code[vpc + (5)]] = (string)data[code[vpc + (24)]] + (string)data[code[vpc + (12)]] + (string)data[code[vpc + (-2)]];
                        vpc += 56;
                        break;
                    case 6043:  //frequency 2 ExpressionStatement_3
                        data[code[vpc + (29)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (-18)]]).GetPistons());
                        vpc += 59;
                        break;
                    case 6050:  //frequency 1 ExpressionStatement_24
                        ((string[])data[code[vpc + (29)]])[(int)data[code[vpc + (1)]]] = (string)data[code[vpc + (-17)]];
                        vpc += 61;
                        break;
                    case 7807:  //frequency 1 ExpressionStatement_5
                        data[code[vpc + (6)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (9)]]).GetPiston((int)data[code[vpc + (-13)]] - (int)data[code[vpc + (17)]]));
                        vpc += 65;
                        break;
                    case 8318:  //frequency 2 ExpressionStatement_8
                        data[code[vpc + (-18)]] = data[code[vpc + (15)]];
                        vpc += 66;
                        break;
                    case 1796:  //frequency 1 ExpressionStatement_22
                        data[code[vpc + (-19)]] = ((string)data[code[vpc + (18)]]).Length;
                        vpc += 61;
                        break;
                    default:  //frequency 3 ExpressionStatement_1
                        data[code[vpc + (-5)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                        vpc += 66;
                        break;
                    case 8245:  //frequency 2 ExpressionStatement_11
                        data[code[vpc + (27)]] = ReturnArg_Array((int)data[code[vpc + (26)]]);
                        vpc += 66;
                        break;
                    case 3144:  //frequency 1 ExpressionStatement_20
                        data[code[vpc + (17)]] = ((ConsoleCalculator.Piston)data[code[vpc + (18)]]).GetSize();
                        vpc += 63;
                        break;
                    case 2063:  //frequency 2 ExpressionStatement_12
                        data[code[vpc + (8)]] = (int)data[code[vpc + (-16)]] < (int)data[code[vpc + (-13)]];
                        vpc += 53;
                        break;
                    case 7862:  //frequency 2 ExpressionStatement_7
                        data[code[vpc + (19)]] = (string)data[code[vpc + (10)]] + (string)data[code[vpc + (7)]];
                        vpc += 61;
                        break;
                    case 5774:  //frequency 1 ExpressionStatement_0
                        data[code[vpc + (-20)]] = (string)data[code[vpc + (1)]] + (int)data[code[vpc + (-9)]] + (int)data[code[vpc + (11)]] + (string)data[code[vpc + (-10)]];
                        vpc += 56;
                        break;
                    case 7054:  //frequency 1 ExpressionStatement_19
                        data[code[vpc + (6)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (26)]]).First());
                        vpc += 66;
                        break;
                    case 2942:  //frequency 1 ExpressionStatement_30
                        data[code[vpc + (-18)]] = (string)data[code[vpc + (-1)]] + (string)data[code[vpc + (29)]] + (int)data[code[vpc + (21)]];
                        vpc += 72;
                        break;
                    case 7373:  //frequency 1 ExpressionStatement_4
                        data[code[vpc + (12)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-11)]]).Count;
                        vpc += 67;
                        break;
                    case 5703:  //frequency 1 ExpressionStatement_25
                        data[code[vpc + (22)]] = (int)data[code[vpc + (-10)]] + (int)data[code[vpc + (-13)]];
                        vpc += 68;
                        break;
                    case 2223:  //frequency 1 ExpressionStatement_6
                        data[code[vpc + (10)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-3)]]).ToString();
                        vpc += 69;
                        break;
                    case 6605:  //frequency 1 WhileStatementSyntax_13
                        data[code[vpc + (18)]] = (bool)data[code[vpc + (19)]] ? (int)data[code[vpc + (16)]] : (int)data[code[vpc + (-2)]];
                        vpc += (int)data[code[vpc + (18)]];
                        break;
                    case 3889:  //frequency 1 ExpressionStatement_14
                        data[code[vpc + (25)]] = (string)data[code[vpc + (16)]] + (string)data[code[vpc + (-4)]] + (int)data[code[vpc + (-17)]] + (string)data[code[vpc + (21)]];
                        vpc += 68;
                        break;
                    case 1706:  //frequency 1 ExpressionStatement_29
                        data[code[vpc + (24)]] = ((string[])data[code[vpc + (-12)]]).Length;
                        vpc += 61;
                        break;
                }
            }

            return null;
        }



        private string ForSimple_Array_original_in(int b)
        {
            string sum = "" + 3 + 4 + "";

            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                var p1 = car.GetEngine().GetPistons().First().GetSize();
                r += "[" + p1 + "]";
                sum += r.Length;
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original_in(b);
            string virt21 = ForSimple_Array_obfuscated2_op4_in1(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }




        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op4_in1_0.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op4_in1_0
    {
        private static string TITLE = "ForLoop_op4_in1";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op4_in1_0 lt = new ForLoop_op4_in1_0();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated_op4_in1);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }

        private string ForSimple_Array_original(int b)
        {
            string sum = "" + 3 + 4 + "";
            var p1 = car.GetEngine().GetPistons().First().GetSize();
            sum += "[" + p1 + "]";
            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original(b);
            string virt21 = ForSimple_Array_obfuscated_op4_in1(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }

        private string ForSimple_Array_obfuscated_op4_in1(int b)
        {
            //Virtualization variables
            int[] code = new int[100613];
            object[] data = new object[4354];
            int vpc = 20;

            //Data init
            data[1499] = b; //b 
            data[3036] = ""; //"" constant
            data[3778] = 3; //3 constant
            data[1643] = 4; //4 constant
            data[3799] = "["; //"[" constant
            data[2195] = "]"; //"]" constant
            data[72] = 1; //1 constant
            data[3798] = 0; //0 constant
            data[963] = "_"; //"_" constant
            data[1414] = "~"; //"~" constant
            data[2515] = "#"; //"#" constant
            data[1725] = 362158193; //sum 
            data[984] = (ConsoleCalculator.Engine)null; //invocationTemp_0 
            data[3132] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
            data[3723] = (ConsoleCalculator.Piston)null; //invocationTemp_2 
            data[394] = (double)0.537795374420376; //p1 
            data[623] = (ConsoleCalculator.Engine)null; //invocationTemp_3 
            data[1514] = (ConsoleCalculator.Engine)null; //invocationTemp_4 
            data[1195] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_5 
            data[3611] = 117; //memberTemp_0 
            data[770] = (ConsoleCalculator.Piston)null; //invocationTemp_6 
            data[1845] = 374684910; //invocationTemp_7 
            data[247] = 362155776; //r 
            data[3015] = (string[])null; //dst 
            data[2617] = -214; //var_forIndex_0 
            data[587] = -762; //invocationTemp_8 
            data[2360] = false; //var_whileCondition_0 
            data[1827] = 151; //invocationTemp_9 
            data[1276] = 995; //memberTemp_1 
            data[343] = 699; //jmpWhileDestinationName_343 constant
            data[1271] = 69; //while_GoTo_True_1271 constant
            data[3065] = 573; //while_GoTo_False_3065 constant
            data[148] = -573; //while_FalseBlockSkip_148 constant

            //Code init

            code[20] = 3746; //ExpressionStatement_0 # ExpressionStatement_0
            code[34] = 1725; //sum
            code[46] = 3036; //""
            code[33] = 3778; //3
            code[13] = 1643; //4
            code[35] = 3036; //""

            code[93] = 5631; //ExpressionStatement_1 # ExpressionStatement_1
            code[107] = 984; //invocationTemp_0

            code[149] = 6837; //ExpressionStatement_2 # ExpressionStatement_2
            code[144] = 3132; //invocationTemp_1
            code[174] = 984; //invocationTemp_0

            code[202] = 6699; //ExpressionStatement_3 # ExpressionStatement_3
            code[188] = 3723; //invocationTemp_2
            code[227] = 3132; //invocationTemp_1

            code[262] = 9219; //ExpressionStatement_4 # ExpressionStatement_4
            code[251] = 394; //p1
            code[279] = 3723; //invocationTemp_2

            code[327] = 9627; //ExpressionStatement_5 # ExpressionStatement_5
            code[338] = 1725; //sum
            code[318] = 1725; //sum
            code[343] = 3799; //"["
            code[320] = 394; //p1
            code[313] = 2195; //"]"

            code[393] = 5631; //ExpressionStatement_1 # ExpressionStatement_6
            code[407] = 623; //invocationTemp_3

            code[449] = 5631; //ExpressionStatement_1 # ExpressionStatement_7
            code[463] = 1514; //invocationTemp_4

            code[505] = 6837; //ExpressionStatement_2 # ExpressionStatement_8
            code[500] = 1195; //invocationTemp_5
            code[530] = 1514; //invocationTemp_4

            code[558] = 2964; //ExpressionStatement_9 # ExpressionStatement_9
            code[567] = 3611; //memberTemp_0
            code[560] = 1195; //invocationTemp_5

            code[612] = 2738; //ExpressionStatement_10 # ExpressionStatement_10
            code[607] = 770; //invocationTemp_6
            code[592] = 623; //invocationTemp_3
            code[595] = 3611; //memberTemp_0
            code[606] = 72; //1

            code[673] = 8700; //ExpressionStatement_11 # ExpressionStatement_11
            code[663] = 1845; //invocationTemp_7
            code[664] = 770; //invocationTemp_6

            code[732] = 3293; //ExpressionStatement_12 # ExpressionStatement_12
            code[723] = 1725; //sum
            code[735] = 1725; //sum
            code[721] = 1845; //invocationTemp_7

            code[800] = 7795; //ExpressionStatement_13 # ExpressionStatement_13
            code[824] = 247; //r
            code[781] = 3036; //""

            code[869] = 2611; //ExpressionStatement_14 # ExpressionStatement_14
            code[886] = 3015; //dst
            code[859] = 1499; //b

            code[931] = 7795; //ExpressionStatement_13 # ExpressionStatement_15
            code[955] = 2617; //var_forIndex_0
            code[912] = 3798; //0

            code[1000] = 4735; //ExpressionStatement_16 # ExpressionStatement_16
            code[1006] = 587; //invocationTemp_8
            code[1002] = 1499; //b

            code[1058] = 7480; //ExpressionStatement_17 # ExpressionStatement_17
            code[1082] = 2360; //var_whileCondition_0
            code[1075] = 2617; //var_forIndex_0
            code[1074] = 587; //invocationTemp_8

            code[1117] = 1081; //WhileStatementSyntax_18 # WhileStatementSyntax_18
            code[1123] = 343; //jmpWhileDestinationName_343
            code[1140] = 2360; //var_whileCondition_0
            code[1099] = 1271; //while_GoTo_True_1271
            code[1133] = 3065; //while_GoTo_False_3065

            code[1186] = 6695; //ExpressionStatement_19 # ExpressionStatement_19
            code[1193] = 1725; //sum
            code[1205] = 1725; //sum
            code[1174] = 963; //"_"
            code[1172] = 2617; //var_forIndex_0
            code[1190] = 963; //"_"

            code[1257] = 3293; //ExpressionStatement_12 # ExpressionStatement_20
            code[1248] = 1725; //sum
            code[1260] = 1725; //sum
            code[1246] = 1414; //"~"

            code[1325] = 6821; //ExpressionStatement_21 # ExpressionStatement_21
            code[1352] = 247; //r
            code[1350] = 247; //r
            code[1339] = 1725; //sum
            code[1319] = 2515; //"#"

            code[1395] = 9150; //ExpressionStatement_22 # ExpressionStatement_22
            code[1396] = 3015; //dst
            code[1411] = 2617; //var_forIndex_0
            code[1379] = 1725; //sum

            code[1459] = 1977; //ExpressionStatement_23 # ExpressionStatement_23
            code[1460] = 2617; //var_forIndex_0
            code[1445] = 2617; //var_forIndex_0
            code[1478] = 72; //1

            code[1515] = 4735; //ExpressionStatement_16 # ExpressionStatement_24
            code[1521] = 1827; //invocationTemp_9
            code[1517] = 1499; //b

            code[1573] = 7480; //ExpressionStatement_17 # ExpressionStatement_25
            code[1597] = 2360; //var_whileCondition_0
            code[1590] = 2617; //var_forIndex_0
            code[1589] = 1827; //invocationTemp_9

            code[1632] = 1500; //ExpressionStatement_26 # ExpressionStatement_26
            code[1645] = 148; //while_FalseBlockSkip_148

            code[1690] = 2603; //ExpressionStatement_27 # ExpressionStatement_27
            code[1715] = 1276; //memberTemp_1
            code[1708] = 3015; //dst

            code[1753] = 4757; //ExpressionStatement_28 # ExpressionStatement_28
            code[1751] = 1725; //sum
            code[1780] = 1725; //sum
            code[1778] = 2515; //"#"
            code[1764] = 1276; //memberTemp_1

            code[1819] = 8067; //ReturnStatement_29 # ReturnStatement_29
            code[1812] = 1725; //sum

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_3371_op4_in1(vpc, data, code);

        }

        private object InstanceInterpreterVirtualization_TraceLoopTests_3371_op4_in1(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 8067:  //frequency 1 ReturnStatement_29
                        return (string)data[code[vpc + (-7)]];
                        vpc += 67;
                    case 2738:  //frequency 1 ExpressionStatement_10
                        data[code[vpc + (-5)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (-20)]]).GetPiston((int)data[code[vpc + (-17)]] - (int)data[code[vpc + (-6)]]));
                        vpc += 61;
                        break;
                    default:  //frequency 0 
                        break;
                    case 6699:  //frequency 1 ExpressionStatement_3
                        data[code[vpc + (-14)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (25)]]).First());
                        vpc += 60;
                        break;
                    case 2603:  //frequency 1 ExpressionStatement_27
                        data[code[vpc + (25)]] = ((string[])data[code[vpc + (18)]]).Length;
                        vpc += 63;
                        break;
                    case 3293:  //frequency 2 ExpressionStatement_12
                        data[code[vpc + (-9)]] = (string)data[code[vpc + (3)]] + (string)data[code[vpc + (-11)]];
                        vpc += 68;
                        break;
                    case 8700:  //frequency 1 ExpressionStatement_11
                        data[code[vpc + (-10)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-9)]]).ToString();
                        vpc += 59;
                        break;
                    case 1081:  //frequency 1 WhileStatementSyntax_18
                        data[code[vpc + (6)]] = (bool)data[code[vpc + (23)]] ? (int)data[code[vpc + (-18)]] : (int)data[code[vpc + (16)]];
                        vpc += (int)data[code[vpc + (6)]];
                        break;
                    case 4735:  //frequency 2 ExpressionStatement_16
                        data[code[vpc + (6)]] = ReturnArg_Array((int)data[code[vpc + (2)]]);
                        vpc += 58;
                        break;
                    case 2611:  //frequency 1 ExpressionStatement_14
                        data[code[vpc + (17)]] = (string[])(new string[(int)data[code[vpc + (-10)]]]);
                        vpc += 62;
                        break;
                    case 6821:  //frequency 1 ExpressionStatement_21
                        data[code[vpc + (27)]] = (string)data[code[vpc + (25)]] + (string)data[code[vpc + (14)]] + (string)data[code[vpc + (-6)]];
                        vpc += 70;
                        break;
                    case 1500:  //frequency 1 ExpressionStatement_26
                        vpc += (int)data[code[vpc + (13)]];
                        vpc += 58;
                        break;
                    case 9219:  //frequency 1 ExpressionStatement_4
                        data[code[vpc + (-11)]] = ((ConsoleCalculator.Piston)data[code[vpc + (17)]]).GetSize();
                        vpc += 65;
                        break;
                    case 4757:  //frequency 1 ExpressionStatement_28
                        data[code[vpc + (-2)]] = (string)data[code[vpc + (27)]] + (string)data[code[vpc + (25)]] + (int)data[code[vpc + (11)]];
                        vpc += 66;
                        break;
                    case 5631:  //frequency 3 ExpressionStatement_1
                        data[code[vpc + (14)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                        vpc += 56;
                        break;
                    case 6837:  //frequency 2 ExpressionStatement_2
                        data[code[vpc + (-5)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (25)]]).GetPistons());
                        vpc += 53;
                        break;
                    case 9627:  //frequency 1 ExpressionStatement_5
                        data[code[vpc + (11)]] = (string)data[code[vpc + (-9)]] + (string)data[code[vpc + (16)]] + (double)data[code[vpc + (-7)]] + (string)data[code[vpc + (-14)]];
                        vpc += 66;
                        break;
                    case 6695:  //frequency 1 ExpressionStatement_19
                        data[code[vpc + (7)]] = (string)data[code[vpc + (19)]] + (string)data[code[vpc + (-12)]] + (int)data[code[vpc + (-14)]] + (string)data[code[vpc + (4)]];
                        vpc += 71;
                        break;
                    case 3746:  //frequency 1 ExpressionStatement_0
                        data[code[vpc + (14)]] = (string)data[code[vpc + (26)]] + (int)data[code[vpc + (13)]] + (int)data[code[vpc + (-7)]] + (string)data[code[vpc + (15)]];
                        vpc += 73;
                        break;
                    case 7795:  //frequency 2 ExpressionStatement_13
                        data[code[vpc + (24)]] = data[code[vpc + (-19)]];
                        vpc += 69;
                        break;
                    case 9150:  //frequency 1 ExpressionStatement_22
                        ((string[])data[code[vpc + (1)]])[(int)data[code[vpc + (16)]]] = (string)data[code[vpc + (-16)]];
                        vpc += 64;
                        break;
                    case 2964:  //frequency 1 ExpressionStatement_9
                        data[code[vpc + (9)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (2)]]).Count;
                        vpc += 54;
                        break;
                    case 7480:  //frequency 2 ExpressionStatement_17
                        data[code[vpc + (24)]] = (int)data[code[vpc + (17)]] < (int)data[code[vpc + (16)]];
                        vpc += 59;
                        break;
                    case 1977:  //frequency 1 ExpressionStatement_23
                        data[code[vpc + (1)]] = (int)data[code[vpc + (-14)]] + (int)data[code[vpc + (19)]];
                        vpc += 56;
                        break;
                }
            }

            return null;
        }


        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op4_in2.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op4_in2
    {
        private static string TITLE = "ForLoop_op4_in2";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op4_in2 lt = new ForLoop_op4_in2();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated2_op4_in2);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }
        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForSimple_Array_obfuscated2_op4_in2(int b)
        {
            //Virtualization variables
            int[] code = new int[100869];
            object[] data = new object[4244];
            int vpc = 36;

            //Data init
            data[2311] = b; //b 
            data[2367] = ""; //"" constant
            data[835] = 3; //3 constant
            data[1382] = 4; //4 constant
            data[746] = 1; //1 constant
            data[2829] = 0; //0 constant
            data[873] = "_"; //"_" constant
            data[1281] = "~"; //"~" constant
            data[3485] = "#"; //"#" constant
            data[3249] = "["; //"[" constant
            data[1847] = "]"; //"]" constant
            data[2921] = 253115470; //sum 
            data[2135] = (ConsoleCalculator.Engine)null; //invocationTemp_0 
            data[2193] = (ConsoleCalculator.Engine)null; //invocationTemp_1 
            data[3263] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_2 
            data[1603] = -352; //memberTemp_0 
            data[64] = (ConsoleCalculator.Piston)null; //invocationTemp_3 
            data[2924] = 529691550; //invocationTemp_4 
            data[906] = 448189483; //r 
            data[1232] = (string[])null; //dst 
            data[3363] = -591; //var_forIndex_0 
            data[998] = -127; //invocationTemp_5 
            data[1935] = false; //var_whileCondition_0 
            data[2491] = (ConsoleCalculator.Engine)null; //invocationTemp_6 
            data[3865] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_7 
            data[105] = (ConsoleCalculator.Piston)null; //invocationTemp_8 
            data[351] = (double)0.0763740581815942; //p1 
            data[2348] = -481; //memberTemp_1 
            data[2058] = -893; //invocationTemp_9 
            data[309] = 503; //memberTemp_2 
            data[2610] = 420; //jmpWhileDestinationName_2610 constant
            data[1863] = 67; //while_GoTo_True_1863 constant
            data[3304] = 1014; //while_GoTo_False_3304 constant
            data[2669] = -1014; //while_FalseBlockSkip_2669 constant

            //Code init

            code[36] = 8744; //ExpressionStatement_0 # ExpressionStatement_0
            code[41] = 2921; //sum
            code[58] = 2367; //""
            code[20] = 835; //3
            code[29] = 1382; //4
            code[33] = 2367; //""

            code[102] = 3603; //ExpressionStatement_1 # ExpressionStatement_1
            code[91] = 2135; //invocationTemp_0

            code[162] = 3603; //ExpressionStatement_1 # ExpressionStatement_2
            code[151] = 2193; //invocationTemp_1

            code[222] = 5550; //ExpressionStatement_3 # ExpressionStatement_3
            code[240] = 3263; //invocationTemp_2
            code[220] = 2193; //invocationTemp_1

            code[286] = 6602; //ExpressionStatement_4 # ExpressionStatement_4
            code[296] = 1603; //memberTemp_0
            code[285] = 3263; //invocationTemp_2

            code[348] = 1972; //ExpressionStatement_5 # ExpressionStatement_5
            code[346] = 64; //invocationTemp_3
            code[336] = 2135; //invocationTemp_0
            code[358] = 1603; //memberTemp_0
            code[359] = 746; //1

            code[413] = 8147; //ExpressionStatement_6 # ExpressionStatement_6
            code[422] = 2924; //invocationTemp_4
            code[417] = 64; //invocationTemp_3

            code[478] = 9852; //ExpressionStatement_7 # ExpressionStatement_7
            code[485] = 2921; //sum
            code[504] = 2921; //sum
            code[480] = 2924; //invocationTemp_4

            code[537] = 3768; //ExpressionStatement_8 # ExpressionStatement_8
            code[555] = 906; //r
            code[531] = 2367; //""

            code[600] = 4038; //ExpressionStatement_9 # ExpressionStatement_9
            code[602] = 1232; //dst
            code[620] = 2311; //b

            code[662] = 3768; //ExpressionStatement_8 # ExpressionStatement_10
            code[680] = 3363; //var_forIndex_0
            code[656] = 2829; //0

            code[725] = 5836; //ExpressionStatement_11 # ExpressionStatement_11
            code[736] = 998; //invocationTemp_5
            code[728] = 2311; //b

            code[783] = 4592; //ExpressionStatement_12 # ExpressionStatement_12
            code[798] = 1935; //var_whileCondition_0
            code[768] = 3363; //var_forIndex_0
            code[799] = 998; //invocationTemp_5

            code[841] = 5350; //WhileStatementSyntax_13 # WhileStatementSyntax_13
            code[858] = 2610; //jmpWhileDestinationName_2610
            code[847] = 1935; //var_whileCondition_0
            code[828] = 1863; //while_GoTo_True_1863
            code[862] = 3304; //while_GoTo_False_3304

            code[908] = 3761; //ExpressionStatement_14 # ExpressionStatement_14
            code[915] = 2921; //sum
            code[928] = 2921; //sum
            code[902] = 873; //"_"
            code[890] = 3363; //var_forIndex_0
            code[919] = 873; //"_"

            code[979] = 9852; //ExpressionStatement_7 # ExpressionStatement_15
            code[986] = 2921; //sum
            code[1005] = 2921; //sum
            code[981] = 1281; //"~"

            code[1038] = 6991; //ExpressionStatement_16 # ExpressionStatement_16
            code[1023] = 906; //r
            code[1030] = 906; //r
            code[1060] = 2921; //sum
            code[1028] = 3485; //"#"

            code[1099] = 3603; //ExpressionStatement_1 # ExpressionStatement_17
            code[1088] = 2491; //invocationTemp_6

            code[1159] = 5550; //ExpressionStatement_3 # ExpressionStatement_18
            code[1177] = 3865; //invocationTemp_7
            code[1157] = 2491; //invocationTemp_6

            code[1223] = 3067; //ExpressionStatement_19 # ExpressionStatement_19
            code[1209] = 105; //invocationTemp_8
            code[1249] = 3865; //invocationTemp_7

            code[1281] = 1734; //ExpressionStatement_20 # ExpressionStatement_20
            code[1288] = 351; //p1
            code[1270] = 105; //invocationTemp_8

            code[1348] = 8188; //ExpressionStatement_21 # ExpressionStatement_21
            code[1343] = 906; //r
            code[1361] = 906; //r
            code[1346] = 3249; //"["
            code[1344] = 351; //p1
            code[1359] = 1847; //"]"

            code[1409] = 6308; //ExpressionStatement_22 # ExpressionStatement_22
            code[1422] = 2348; //memberTemp_1
            code[1412] = 906; //r

            code[1480] = 5954; //ExpressionStatement_23 # ExpressionStatement_23
            code[1474] = 2921; //sum
            code[1484] = 2921; //sum
            code[1491] = 2348; //memberTemp_1

            code[1549] = 6007; //ExpressionStatement_24 # ExpressionStatement_24
            code[1554] = 1232; //dst
            code[1570] = 3363; //var_forIndex_0
            code[1555] = 2921; //sum

            code[1612] = 7907; //ExpressionStatement_25 # ExpressionStatement_25
            code[1594] = 3363; //var_forIndex_0
            code[1629] = 3363; //var_forIndex_0
            code[1634] = 746; //1

            code[1674] = 5836; //ExpressionStatement_11 # ExpressionStatement_26
            code[1685] = 2058; //invocationTemp_9
            code[1677] = 2311; //b

            code[1732] = 4592; //ExpressionStatement_12 # ExpressionStatement_27
            code[1747] = 1935; //var_whileCondition_0
            code[1717] = 3363; //var_forIndex_0
            code[1748] = 2058; //invocationTemp_9

            code[1790] = 4169; //ExpressionStatement_28 # ExpressionStatement_28
            code[1807] = 2669; //while_FalseBlockSkip_2669

            code[1855] = 6067; //ExpressionStatement_29 # ExpressionStatement_29
            code[1850] = 309; //memberTemp_2
            code[1863] = 1232; //dst

            code[1908] = 6045; //ExpressionStatement_30 # ExpressionStatement_30
            code[1900] = 2921; //sum
            code[1927] = 2921; //sum
            code[1905] = 3485; //"#"
            code[1891] = 309; //memberTemp_2

            code[1969] = 1508; //ReturnStatement_31 # ReturnStatement_31
            code[1988] = 2921; //sum

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_913_2_op4_in2(vpc, data, code);

        }



        private object InstanceInterpreterVirtualization_TraceLoopTests_913_2_op4_in2(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 9852:  //frequency 2 ExpressionStatement_7
                        data[code[vpc + (7)]] = (string)data[code[vpc + (26)]] + (string)data[code[vpc + (2)]];
                        vpc += 59;
                        break;
                    default:  //frequency 0 
                        break;
                    case 6067:  //frequency 1 ExpressionStatement_29
                        data[code[vpc + (-5)]] = ((string[])data[code[vpc + (8)]]).Length;
                        vpc += 53;
                        break;
                    case 8188:  //frequency 1 ExpressionStatement_21
                        data[code[vpc + (-5)]] = (string)data[code[vpc + (13)]] + (string)data[code[vpc + (-2)]] + (double)data[code[vpc + (-4)]] + (string)data[code[vpc + (11)]];
                        vpc += 61;
                        break;
                    case 6007:  //frequency 1 ExpressionStatement_24
                        ((string[])data[code[vpc + (5)]])[(int)data[code[vpc + (21)]]] = (string)data[code[vpc + (6)]];
                        vpc += 63;
                        break;
                    case 7907:  //frequency 1 ExpressionStatement_25
                        data[code[vpc + (-18)]] = (int)data[code[vpc + (17)]] + (int)data[code[vpc + (22)]];
                        vpc += 62;
                        break;
                    case 6991:  //frequency 1 ExpressionStatement_16
                        data[code[vpc + (-15)]] = (string)data[code[vpc + (-8)]] + (string)data[code[vpc + (22)]] + (string)data[code[vpc + (-10)]];
                        vpc += 61;
                        break;
                    case 1508:  //frequency 1 ReturnStatement_31
                        return (string)data[code[vpc + (19)]];
                        vpc += 68;
                    case 6045:  //frequency 1 ExpressionStatement_30
                        data[code[vpc + (-8)]] = (string)data[code[vpc + (19)]] + (string)data[code[vpc + (-3)]] + (int)data[code[vpc + (-17)]];
                        vpc += 61;
                        break;
                    case 4169:  //frequency 1 ExpressionStatement_28
                        vpc += (int)data[code[vpc + (17)]];
                        vpc += 65;
                        break;
                    case 5350:  //frequency 1 WhileStatementSyntax_13
                        data[code[vpc + (17)]] = (bool)data[code[vpc + (6)]] ? (int)data[code[vpc + (-13)]] : (int)data[code[vpc + (21)]];
                        vpc += (int)data[code[vpc + (17)]];
                        break;
                    case 4592:  //frequency 2 ExpressionStatement_12
                        data[code[vpc + (15)]] = (int)data[code[vpc + (-15)]] < (int)data[code[vpc + (16)]];
                        vpc += 58;
                        break;
                    case 6602:  //frequency 1 ExpressionStatement_4
                        data[code[vpc + (10)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-1)]]).Count;
                        vpc += 62;
                        break;
                    case 8147:  //frequency 1 ExpressionStatement_6
                        data[code[vpc + (9)]] = ((ConsoleCalculator.Piston)data[code[vpc + (4)]]).ToString();
                        vpc += 65;
                        break;
                    case 3603:  //frequency 3 ExpressionStatement_1
                        data[code[vpc + (-11)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                        vpc += 60;
                        break;
                    case 3768:  //frequency 2 ExpressionStatement_8
                        data[code[vpc + (18)]] = data[code[vpc + (-6)]];
                        vpc += 63;
                        break;
                    case 5550:  //frequency 2 ExpressionStatement_3
                        data[code[vpc + (18)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (-2)]]).GetPistons());
                        vpc += 64;
                        break;
                    case 5836:  //frequency 2 ExpressionStatement_11
                        data[code[vpc + (11)]] = ReturnArg_Array((int)data[code[vpc + (3)]]);
                        vpc += 58;
                        break;
                    case 6308:  //frequency 1 ExpressionStatement_22
                        data[code[vpc + (13)]] = ((string)data[code[vpc + (3)]]).Length;
                        vpc += 71;
                        break;
                    case 8744:  //frequency 1 ExpressionStatement_0
                        data[code[vpc + (5)]] = (string)data[code[vpc + (22)]] + (int)data[code[vpc + (-16)]] + (int)data[code[vpc + (-7)]] + (string)data[code[vpc + (-3)]];
                        vpc += 66;
                        break;
                    case 5954:  //frequency 1 ExpressionStatement_23
                        data[code[vpc + (-6)]] = (string)data[code[vpc + (4)]] + (int)data[code[vpc + (11)]];
                        vpc += 69;
                        break;
                    case 3761:  //frequency 1 ExpressionStatement_14
                        data[code[vpc + (7)]] = (string)data[code[vpc + (20)]] + (string)data[code[vpc + (-6)]] + (int)data[code[vpc + (-18)]] + (string)data[code[vpc + (11)]];
                        vpc += 71;
                        break;
                    case 3067:  //frequency 1 ExpressionStatement_19
                        data[code[vpc + (-14)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (26)]]).First());
                        vpc += 58;
                        break;
                    case 1734:  //frequency 1 ExpressionStatement_20
                        data[code[vpc + (7)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-11)]]).GetSize();
                        vpc += 67;
                        break;
                    case 1972:  //frequency 1 ExpressionStatement_5
                        data[code[vpc + (-2)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (-12)]]).GetPiston((int)data[code[vpc + (10)]] - (int)data[code[vpc + (11)]]));
                        vpc += 65;
                        break;
                    case 4038:  //frequency 1 ExpressionStatement_9
                        data[code[vpc + (2)]] = (string[])(new string[(int)data[code[vpc + (20)]]]);
                        vpc += 62;
                        break;
                }
            }

            return null;
        }


        private string ForSimple_Array_original_in(int b)
        {
            string sum = "" + 3 + 4 + "";

            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                var p1 = car.GetEngine().GetPistons().First().GetSize();
                r += "[" + p1 + "]";
                sum += r.Length;
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original_in(b);
            string virt21 = ForSimple_Array_obfuscated2_op4_in2(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }




        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op4_in3.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op4_in3
    {
        private static string TITLE = "ForLoop_op4_in3";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op4_in3 lt = new ForLoop_op4_in3();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated2_op4_in3);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }
  
        private string ForSimple_Array_original_in(int b)
        {
            string sum = "" + 3 + 4 + "";

            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                var p1 = car.GetEngine().GetPistons().First().GetSize();
                r += "[" + p1 + "]";
                sum += r.Length;
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original_in(b);
            string virt21 = ForSimple_Array_obfuscated2_op4_in3(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForSimple_Array_obfuscated2_op4_in3(int b)
        {
            //Virtualization variables
            int[] code = new int[100612];
            object[] data = new object[4959];
            int vpc = 116;

            //Data init
            data[1828] = b; //b 
            data[123] = ""; //"" constant
            data[2435] = 3; //3 constant
            data[1805] = 4; //4 constant
            data[997] = 1; //1 constant
            data[2989] = 0; //0 constant
            data[2099] = "_"; //"_" constant
            data[2791] = "~"; //"~" constant
            data[365] = "#"; //"#" constant
            data[1855] = "["; //"[" constant
            data[12] = "]"; //"]" constant
            data[843] = 1290348670; //sum 
            data[3782] = (ConsoleCalculator.Engine)null; //invocationTemp_0 
            data[2756] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
            data[1728] = -780; //memberTemp_0 
            data[3972] = (ConsoleCalculator.Piston)null; //invocationTemp_2 
            data[538] = 2023170179; //r 
            data[1098] = (string[])null; //dst 
            data[1812] = -536; //var_forIndex_0 
            data[2972] = -238; //invocationTemp_3 
            data[3051] = false; //var_whileCondition_0 
            data[886] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_4 
            data[2974] = (double)0.559951857458778; //p1 
            data[2610] = 940; //memberTemp_1 
            data[1104] = -455; //memberTemp_2 
            data[2745] = -239; //jmpWhileDestinationName_2745 constant
            data[2384] = 61; //while_GoTo_True_2384 constant
            data[2355] = 816; //while_GoTo_False_2355 constant
            data[645] = -816; //while_FalseBlockSkip_645 constant

            //Code init

            code[116] = 1395; //ExpressionStatement_0 # ExpressionStatement_0
            code[99] = 843; //sum
            code[129] = 123; //""
            code[115] = 2435; //3
            code[128] = 1805; //4
            code[124] = 123; //""

            code[182] = 8970; //ExpressionStatement_1 # ExpressionStatement_1
            code[199] = 3782; //invocationTemp_0

            code[247] = 3718; //ExpressionStatement_2 # ExpressionStatement_2
            code[249] = 2756; //invocationTemp_1
            code[265] = 3782; //invocationTemp_0

            code[314] = 3792; //ExpressionStatement_3 # ExpressionStatement_3
            code[307] = 1728; //memberTemp_0
            code[298] = 2756; //invocationTemp_1

            code[374] = 2505; //ExpressionStatement_4 # ExpressionStatement_4
            code[401] = 3972; //invocationTemp_2
            code[365] = 1728; //memberTemp_0
            code[368] = 997; //1

            code[427] = 2578; //ExpressionStatement_5 # ExpressionStatement_5
            code[413] = 843; //sum
            code[435] = 843; //sum
            code[439] = 3972; //invocationTemp_2

            code[485] = 4590; //ExpressionStatement_6 # ExpressionStatement_6
            code[505] = 538; //r
            code[480] = 123; //""

            code[543] = 1364; //ExpressionStatement_7 # ExpressionStatement_7
            code[536] = 1098; //dst
            code[542] = 1828; //b

            code[603] = 4590; //ExpressionStatement_6 # ExpressionStatement_8
            code[623] = 1812; //var_forIndex_0
            code[598] = 2989; //0

            code[661] = 9526; //ExpressionStatement_9 # ExpressionStatement_9
            code[689] = 2972; //invocationTemp_3
            code[650] = 1828; //b

            code[731] = 3200; //ExpressionStatement_10 # ExpressionStatement_10
            code[738] = 3051; //var_whileCondition_0
            code[749] = 1812; //var_forIndex_0
            code[735] = 2972; //invocationTemp_3

            code[790] = 5450; //WhileStatementSyntax_11 # WhileStatementSyntax_11
            code[791] = 2745; //jmpWhileDestinationName_2745
            code[804] = 3051; //var_whileCondition_0
            code[775] = 2384; //while_GoTo_True_2384
            code[800] = 2355; //while_GoTo_False_2355

            code[851] = 7974; //ExpressionStatement_12 # ExpressionStatement_12
            code[836] = 843; //sum
            code[878] = 843; //sum
            code[845] = 2099; //"_"
            code[849] = 1812; //var_forIndex_0
            code[873] = 2099; //"_"

            code[913] = 1197; //ExpressionStatement_13 # ExpressionStatement_13
            code[894] = 843; //sum
            code[942] = 843; //sum
            code[908] = 2791; //"~"

            code[974] = 7817; //ExpressionStatement_14 # ExpressionStatement_14
            code[956] = 538; //r
            code[995] = 538; //r
            code[954] = 843; //sum
            code[998] = 365; //"#"

            code[1041] = 7703; //ExpressionStatement_15 # ExpressionStatement_15
            code[1042] = 886; //invocationTemp_4

            code[1108] = 6319; //ExpressionStatement_16 # ExpressionStatement_16
            code[1128] = 2974; //p1
            code[1117] = 886; //invocationTemp_4

            code[1178] = 2262; //ExpressionStatement_17 # ExpressionStatement_17
            code[1197] = 538; //r
            code[1165] = 538; //r
            code[1188] = 1855; //"["
            code[1162] = 2974; //p1
            code[1185] = 12; //"]"

            code[1249] = 1132; //ExpressionStatement_18 # ExpressionStatement_18
            code[1274] = 2610; //memberTemp_1
            code[1262] = 538; //r

            code[1304] = 1510; //ExpressionStatement_19 # ExpressionStatement_19
            code[1319] = 843; //sum
            code[1289] = 843; //sum
            code[1323] = 2610; //memberTemp_1

            code[1363] = 1164; //ExpressionStatement_20 # ExpressionStatement_20
            code[1380] = 1098; //dst
            code[1351] = 1812; //var_forIndex_0
            code[1356] = 843; //sum

            code[1427] = 6641; //ExpressionStatement_21 # ExpressionStatement_21
            code[1432] = 1812; //var_forIndex_0
            code[1447] = 1812; //var_forIndex_0
            code[1441] = 997; //1

            code[1485] = 1335; //ExpressionStatement_22 # ExpressionStatement_22
            code[1476] = 3051; //var_whileCondition_0
            code[1479] = 1812; //var_forIndex_0
            code[1475] = 1828; //b

            code[1542] = 7415; //ExpressionStatement_23 # ExpressionStatement_23
            code[1527] = 645; //while_FalseBlockSkip_645

            code[1606] = 8314; //ExpressionStatement_24 # ExpressionStatement_24
            code[1604] = 1104; //memberTemp_2
            code[1591] = 1098; //dst

            code[1677] = 1849; //ExpressionStatement_25 # ExpressionStatement_25
            code[1680] = 843; //sum
            code[1664] = 843; //sum
            code[1705] = 365; //"#"
            code[1685] = 1104; //memberTemp_2

            code[1749] = 4449; //ReturnStatement_26 # ReturnStatement_26
            code[1754] = 843; //sum

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_2835_2_op4_in3(vpc, data, code);

        }


        private object InstanceInterpreterVirtualization_TraceLoopTests_2835_2_op4_in3(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 7415:  //frequency 1 ExpressionStatement_23
                        vpc += (int)data[code[vpc + (-15)]];
                        vpc += 64;
                        break;
                    case 4449:  //frequency 1 ReturnStatement_26
                        return (string)data[code[vpc + (5)]];
                        vpc += 63;
                    case 8970:  //frequency 1 ExpressionStatement_1
                        data[code[vpc + (17)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                        vpc += 65;
                        break;
                    case 3792:  //frequency 1 ExpressionStatement_3
                        data[code[vpc + (-7)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-16)]]).Count;
                        vpc += 60;
                        break;
                    case 1335:  //frequency 1 ExpressionStatement_22
                        data[code[vpc + (-9)]] = (int)data[code[vpc + (-6)]] < ReturnArg_Array((int)data[code[vpc + (-10)]]);
                        vpc += 57;
                        break;
                    case 1395:  //frequency 1 ExpressionStatement_0
                        data[code[vpc + (-17)]] = (string)data[code[vpc + (13)]] + (int)data[code[vpc + (-1)]] + (int)data[code[vpc + (12)]] + (string)data[code[vpc + (8)]];
                        vpc += 66;
                        break;
                    case 6641:  //frequency 1 ExpressionStatement_21
                        data[code[vpc + (5)]] = (int)data[code[vpc + (20)]] + (int)data[code[vpc + (14)]];
                        vpc += 58;
                        break;
                    case 1132:  //frequency 1 ExpressionStatement_18
                        data[code[vpc + (25)]] = ((string)data[code[vpc + (13)]]).Length;
                        vpc += 55;
                        break;
                    case 1164:  //frequency 1 ExpressionStatement_20
                        ((string[])data[code[vpc + (17)]])[(int)data[code[vpc + (-12)]]] = (string)data[code[vpc + (-7)]];
                        vpc += 64;
                        break;
                    case 2578:  //frequency 1 ExpressionStatement_5
                        data[code[vpc + (-14)]] = (string)data[code[vpc + (8)]] + ((ConsoleCalculator.Piston)data[code[vpc + (12)]]).ToString();
                        vpc += 58;
                        break;
                    case 5450:  //frequency 1 WhileStatementSyntax_11
                        data[code[vpc + (1)]] = (bool)data[code[vpc + (14)]] ? (int)data[code[vpc + (-15)]] : (int)data[code[vpc + (10)]];
                        vpc += (int)data[code[vpc + (1)]];
                        break;
                    case 3200:  //frequency 1 ExpressionStatement_10
                        data[code[vpc + (7)]] = (int)data[code[vpc + (18)]] < (int)data[code[vpc + (4)]];
                        vpc += 59;
                        break;
                    case 3718:  //frequency 1 ExpressionStatement_2
                        data[code[vpc + (2)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (18)]]).GetPistons());
                        vpc += 67;
                        break;
                    case 4590:  //frequency 2 ExpressionStatement_6
                        data[code[vpc + (20)]] = data[code[vpc + (-5)]];
                        vpc += 58;
                        break;
                    case 1197:  //frequency 1 ExpressionStatement_13
                        data[code[vpc + (-19)]] = (string)data[code[vpc + (29)]] + (string)data[code[vpc + (-5)]];
                        vpc += 61;
                        break;
                    case 1849:  //frequency 1 ExpressionStatement_25
                        data[code[vpc + (3)]] = (string)data[code[vpc + (-13)]] + (string)data[code[vpc + (28)]] + (int)data[code[vpc + (8)]];
                        vpc += 72;
                        break;
                    case 7703:  //frequency 1 ExpressionStatement_15
                        data[code[vpc + (1)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(car.GetEngine().GetPistons());
                        vpc += 67;
                        break;
                    case 1364:  //frequency 1 ExpressionStatement_7
                        data[code[vpc + (-7)]] = (string[])(new string[(int)data[code[vpc + (-1)]]]);
                        vpc += 60;
                        break;
                    case 9526:  //frequency 1 ExpressionStatement_9
                        data[code[vpc + (28)]] = ReturnArg_Array((int)data[code[vpc + (-11)]]);
                        vpc += 70;
                        break;
                    case 2262:  //frequency 1 ExpressionStatement_17
                        data[code[vpc + (19)]] = (string)data[code[vpc + (-13)]] + (string)data[code[vpc + (10)]] + (double)data[code[vpc + (-16)]] + (string)data[code[vpc + (7)]];
                        vpc += 71;
                        break;
                    case 8314:  //frequency 1 ExpressionStatement_24
                        data[code[vpc + (-2)]] = ((string[])data[code[vpc + (-15)]]).Length;
                        vpc += 71;
                        break;
                    case 7974:  //frequency 1 ExpressionStatement_12
                        data[code[vpc + (-15)]] = (string)data[code[vpc + (27)]] + (string)data[code[vpc + (-6)]] + (int)data[code[vpc + (-2)]] + (string)data[code[vpc + (22)]];
                        vpc += 62;
                        break;
                    case 1510:  //frequency 1 ExpressionStatement_19
                        data[code[vpc + (15)]] = (string)data[code[vpc + (-15)]] + (int)data[code[vpc + (19)]];
                        vpc += 59;
                        break;
                    case 2505:  //frequency 1 ExpressionStatement_4
                        data[code[vpc + (27)]] = (ConsoleCalculator.Piston)(car.GetEngine().GetPiston((int)data[code[vpc + (-9)]] - (int)data[code[vpc + (-6)]]));
                        vpc += 53;
                        break;
                    default:  //frequency 0 
                        break;
                    case 7817:  //frequency 1 ExpressionStatement_14
                        data[code[vpc + (-18)]] = (string)data[code[vpc + (21)]] + (string)data[code[vpc + (-20)]] + (string)data[code[vpc + (24)]];
                        vpc += 67;
                        break;
                    case 6319:  //frequency 1 ExpressionStatement_16
                        data[code[vpc + (20)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (9)]]).First().GetSize();
                        vpc += 70;
                        break;
                }
            }

            return null;
        }



        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op4_in4.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op4_in4
    {
        private static string TITLE = "ForLoop_op4_in4";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op4_in4 lt = new ForLoop_op4_in4();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated2_op4_in4);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }
  
        private string ForSimple_Array_original_in(int b)
        {
            string sum = "" + 3 + 4 + "";

            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                var p1 = car.GetEngine().GetPistons().First().GetSize();
                r += "[" + p1 + "]";
                sum += r.Length;
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original_in(b);
            string virt21 = ForSimple_Array_obfuscated2_op4_in4(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }



        private string ForSimple_Array_obfuscated2_op4_in4(int b)
        {
            //Virtualization variables
            int[] code = new int[100668];
            object[] data = new object[4842];
            int vpc = 109;

            //Data init
            data[3129] = b; //b 
            data[3526] = ""; //"" constant
            data[232] = 3; //3 constant
            data[1156] = 4; //4 constant
            data[1441] = 1; //1 constant
            data[98] = 0; //0 constant
            data[916] = "_"; //"_" constant
            data[1115] = "~"; //"~" constant
            data[3865] = "#"; //"#" constant
            data[2343] = "["; //"[" constant
            data[214] = "]"; //"]" constant
            data[1618] = 1426291964; //sum 
            data[1644] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_0 
            data[3052] = -993; //memberTemp_0 
            data[3078] = 2075095712; //invocationTemp_1 
            data[3838] = 637460966; //r 
            data[366] = (string[])null; //dst 
            data[1894] = -437; //var_forIndex_0 
            data[657] = false; //var_whileCondition_0 
            data[2515] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_2 
            data[1239] = (double)0.271554201036484; //p1 
            data[2482] = 58; //memberTemp_1 
            data[1821] = -897; //memberTemp_2 
            data[606] = -583; //jmpWhileDestinationName_606 constant
            data[2817] = 68; //while_GoTo_True_2817 constant
            data[2185] = 774; //while_GoTo_False_2185 constant
            data[2377] = -774; //while_FalseBlockSkip_2377 constant

            //Code init

            code[109] = 7526; //ExpressionStatement_0 # ExpressionStatement_0
            code[114] = 1618; //sum
            code[118] = 3526; //""
            code[96] = 232; //3
            code[128] = 1156; //4
            code[138] = 3526; //""

            code[172] = 6090; //ExpressionStatement_1 # ExpressionStatement_1
            code[155] = 1644; //invocationTemp_0

            code[230] = 2933; //ExpressionStatement_2 # ExpressionStatement_2
            code[255] = 3052; //memberTemp_0
            code[213] = 1644; //invocationTemp_0

            code[290] = 9729; //ExpressionStatement_3 # ExpressionStatement_3
            code[286] = 3078; //invocationTemp_1
            code[294] = 3052; //memberTemp_0
            code[287] = 1441; //1

            code[355] = 6453; //ExpressionStatement_4 # ExpressionStatement_4
            code[368] = 1618; //sum
            code[384] = 1618; //sum
            code[343] = 3078; //invocationTemp_1

            code[420] = 2506; //ExpressionStatement_5 # ExpressionStatement_5
            code[425] = 3838; //r
            code[414] = 3526; //""

            code[484] = 7925; //ExpressionStatement_6 # ExpressionStatement_6
            code[485] = 366; //dst
            code[476] = 3129; //b

            code[543] = 2506; //ExpressionStatement_5 # ExpressionStatement_7
            code[548] = 1894; //var_forIndex_0
            code[537] = 98; //0

            code[607] = 7895; //ExpressionStatement_8 # ExpressionStatement_8
            code[606] = 657; //var_whileCondition_0
            code[624] = 1894; //var_forIndex_0
            code[631] = 3129; //b

            code[661] = 4422; //WhileStatementSyntax_9 # WhileStatementSyntax_9
            code[650] = 606; //jmpWhileDestinationName_606
            code[675] = 657; //var_whileCondition_0
            code[660] = 2817; //while_GoTo_True_2817
            code[687] = 2185; //while_GoTo_False_2185

            code[729] = 8517; //ExpressionStatement_10 # ExpressionStatement_10
            code[728] = 1618; //sum
            code[745] = 1618; //sum
            code[736] = 916; //"_"
            code[732] = 1894; //var_forIndex_0
            code[741] = 916; //"_"

            code[789] = 6453; //ExpressionStatement_4 # ExpressionStatement_11
            code[802] = 1618; //sum
            code[818] = 1618; //sum
            code[777] = 1115; //"~"

            code[854] = 9232; //ExpressionStatement_12 # ExpressionStatement_12
            code[875] = 3838; //r
            code[862] = 3838; //r
            code[855] = 1618; //sum
            code[882] = 3865; //"#"

            code[909] = 6090; //ExpressionStatement_1 # ExpressionStatement_13
            code[892] = 2515; //invocationTemp_2

            code[967] = 2924; //ExpressionStatement_14 # ExpressionStatement_14
            code[952] = 1239; //p1
            code[969] = 2515; //invocationTemp_2

            code[1024] = 5044; //ExpressionStatement_15 # ExpressionStatement_15
            code[1020] = 3838; //r
            code[1049] = 3838; //r
            code[1047] = 2343; //"["
            code[1034] = 1239; //p1
            code[1037] = 214; //"]"

            code[1097] = 1624; //ExpressionStatement_16 # ExpressionStatement_16
            code[1088] = 2482; //memberTemp_1
            code[1123] = 3838; //r

            code[1150] = 9963; //ExpressionStatement_17 # ExpressionStatement_17
            code[1172] = 1618; //sum
            code[1176] = 1618; //sum
            code[1130] = 2482; //memberTemp_1

            code[1203] = 2516; //ExpressionStatement_18 # ExpressionStatement_18
            code[1223] = 366; //dst
            code[1214] = 1894; //var_forIndex_0
            code[1201] = 1618; //sum

            code[1270] = 5643; //ExpressionStatement_19 # ExpressionStatement_19
            code[1277] = 1894; //var_forIndex_0
            code[1267] = 1894; //var_forIndex_0
            code[1298] = 1441; //1

            code[1326] = 7895; //ExpressionStatement_8 # ExpressionStatement_20
            code[1325] = 657; //var_whileCondition_0
            code[1343] = 1894; //var_forIndex_0
            code[1350] = 3129; //b

            code[1380] = 4453; //ExpressionStatement_21 # ExpressionStatement_21
            code[1407] = 2377; //while_FalseBlockSkip_2377

            code[1435] = 6071; //ExpressionStatement_22 # ExpressionStatement_22
            code[1416] = 1821; //memberTemp_2
            code[1458] = 366; //dst

            code[1497] = 8607; //ExpressionStatement_23 # ExpressionStatement_23
            code[1507] = 1618; //sum
            code[1508] = 1618; //sum
            code[1509] = 3865; //"#"
            code[1525] = 1821; //memberTemp_2

            code[1551] = 4043; //ReturnStatement_24 # ReturnStatement_24
            code[1543] = 1618; //sum

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_1236_2_op4_in4(vpc, data, code);

        }



        private object InstanceInterpreterVirtualization_TraceLoopTests_1236_2_op4_in4(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 2933:  //frequency 1 ExpressionStatement_2
                        data[code[vpc + (25)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-17)]]).Count;
                        vpc += 60;
                        break;
                    case 4422:  //frequency 1 WhileStatementSyntax_9
                        data[code[vpc + (-11)]] = (bool)data[code[vpc + (14)]] ? (int)data[code[vpc + (-1)]] : (int)data[code[vpc + (26)]];
                        vpc += (int)data[code[vpc + (-11)]];
                        break;
                    case 2506:  //frequency 2 ExpressionStatement_5
                        data[code[vpc + (5)]] = data[code[vpc + (-6)]];
                        vpc += 64;
                        break;
                    case 6071:  //frequency 1 ExpressionStatement_22
                        data[code[vpc + (-19)]] = ((string[])data[code[vpc + (23)]]).Length;
                        vpc += 62;
                        break;
                    case 5044:  //frequency 1 ExpressionStatement_15
                        data[code[vpc + (-4)]] = (string)data[code[vpc + (25)]] + (string)data[code[vpc + (23)]] + (double)data[code[vpc + (10)]] + (string)data[code[vpc + (13)]];
                        vpc += 73;
                        break;
                    case 1624:  //frequency 1 ExpressionStatement_16
                        data[code[vpc + (-9)]] = ((string)data[code[vpc + (26)]]).Length;
                        vpc += 53;
                        break;
                    case 7895:  //frequency 2 ExpressionStatement_8
                        data[code[vpc + (-1)]] = (int)data[code[vpc + (17)]] < ReturnArg_Array((int)data[code[vpc + (24)]]);
                        vpc += 54;
                        break;
                    case 6453:  //frequency 2 ExpressionStatement_4
                        data[code[vpc + (13)]] = (string)data[code[vpc + (29)]] + (string)data[code[vpc + (-12)]];
                        vpc += 65;
                        break;
                    case 6090:  //frequency 2 ExpressionStatement_1
                        data[code[vpc + (-17)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(car.GetEngine().GetPistons());
                        vpc += 58;
                        break;
                    case 2924:  //frequency 1 ExpressionStatement_14
                        data[code[vpc + (-15)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (2)]]).First().GetSize();
                        vpc += 57;
                        break;
                    default:  //frequency 0 
                        break;
                    case 7526:  //frequency 1 ExpressionStatement_0
                        data[code[vpc + (5)]] = (string)data[code[vpc + (9)]] + (int)data[code[vpc + (-13)]] + (int)data[code[vpc + (19)]] + (string)data[code[vpc + (29)]];
                        vpc += 63;
                        break;
                    case 4453:  //frequency 1 ExpressionStatement_21
                        vpc += (int)data[code[vpc + (27)]];
                        vpc += 55;
                        break;
                    case 8517:  //frequency 1 ExpressionStatement_10
                        data[code[vpc + (-1)]] = (string)data[code[vpc + (16)]] + (string)data[code[vpc + (7)]] + (int)data[code[vpc + (3)]] + (string)data[code[vpc + (12)]];
                        vpc += 60;
                        break;
                    case 9963:  //frequency 1 ExpressionStatement_17
                        data[code[vpc + (22)]] = (string)data[code[vpc + (26)]] + (int)data[code[vpc + (-20)]];
                        vpc += 53;
                        break;
                    case 5643:  //frequency 1 ExpressionStatement_19
                        data[code[vpc + (7)]] = (int)data[code[vpc + (-3)]] + (int)data[code[vpc + (28)]];
                        vpc += 56;
                        break;
                    case 4043:  //frequency 1 ReturnStatement_24
                        return (string)data[code[vpc + (-8)]];
                        vpc += 56;
                    case 7925:  //frequency 1 ExpressionStatement_6
                        data[code[vpc + (1)]] = (string[])(new string[(int)data[code[vpc + (-8)]]]);
                        vpc += 59;
                        break;
                    case 2516:  //frequency 1 ExpressionStatement_18
                        ((string[])data[code[vpc + (20)]])[(int)data[code[vpc + (11)]]] = (string)data[code[vpc + (-2)]];
                        vpc += 67;
                        break;
                    case 9729:  //frequency 1 ExpressionStatement_3
                        data[code[vpc + (-4)]] = car.GetEngine().GetPiston((int)data[code[vpc + (4)]] - (int)data[code[vpc + (-3)]]).ToString();
                        vpc += 65;
                        break;
                    case 9232:  //frequency 1 ExpressionStatement_12
                        data[code[vpc + (21)]] = (string)data[code[vpc + (8)]] + (string)data[code[vpc + (1)]] + (string)data[code[vpc + (28)]];
                        vpc += 55;
                        break;
                    case 8607:  //frequency 1 ExpressionStatement_23
                        data[code[vpc + (10)]] = (string)data[code[vpc + (11)]] + (string)data[code[vpc + (12)]] + (int)data[code[vpc + (28)]];
                        vpc += 54;
                        break;
                }
            }

            return null;
        }






        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/ForLoop/ForLoop_op4_in5.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Performance.ForLoop
{
   

    class ForLoop_op4_in5
    {
        private static string TITLE = "ForLoop_op4_in5";
        private Car car = new Car("invocation-check-car", 4);

        public static int WARMUP;
        public static int ITERATIONS;
        public static int NUMBER_OF_LOOPS;
        public static int NUMBER_OF_TESTS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            ForLoop_op4_in5 lt = new ForLoop_op4_in5();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();

//            lt.ForLoop_Check();

        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";


            for (int i = 0; i < NUMBER_OF_TESTS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation(i+" , "+ TITLE, ForSimple_Array_obfuscated2_op4_in5);

                result += " " + t_original;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);

            PrintTimes();
        }


        private int ReturnArg_Array(int arg)
        {
            return arg;
        }
  
        private string ForSimple_Array_original_in(int b)
        {
            string sum = "" + 3 + 4 + "";

            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                var p1 = car.GetEngine().GetPistons().First().GetSize();
                r += "[" + p1 + "]";
                sum += r.Length;
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }


        private void ForLoop_Check()
        {
            string testName = "Performance_check#"+ TITLE;
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5; //number of loops
            string oracle2 = ForSimple_Array_original_in(b);
            string virt21 = ForSimple_Array_obfuscated2_op4_in5(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");
            
            condition = virt21.Equals(oracle2);
            Program.End_Check(testName, condition);
        }


        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForSimple_Array_obfuscated2_op4_in5(int b)
        {
            //Virtualization variables
            int[] code = new int[100962];
            object[] data = new object[4842];
            int vpc = 78;

            //Data init
            data[791] = b; //b 
            data[1679] = ""; //"" constant
            data[1079] = 3; //3 constant
            data[1920] = 4; //4 constant
            data[2222] = 1; //1 constant
            data[2050] = 0; //0 constant
            data[86] = "_"; //"_" constant
            data[2934] = "~"; //"~" constant
            data[454] = "#"; //"#" constant
            data[520] = "["; //"[" constant
            data[2332] = "]"; //"]" constant
            data[2431] = 1952909025; //sum 
            data[3295] = 875; //memberTemp_0 
            data[2] = (ConsoleCalculator.Piston)null; //invocationTemp_0 
            data[143] = 1466123585; //r 
            data[3578] = (string[])null; //dst 
            data[3783] = 243; //var_forIndex_0 
            data[3158] = false; //var_whileCondition_0 
            data[3947] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
            data[2276] = (double)0.0422941758494331; //p1 
            data[3987] = 177; //memberTemp_1 
            data[1571] = -447; //memberTemp_2 
            data[2621] = -925; //jmpWhileDestinationName_2621 constant
            data[80] = 57; //while_GoTo_True_80 constant
            data[237] = 777; //while_GoTo_False_237 constant
            data[82] = -777; //while_FalseBlockSkip_82 constant

            //Code init

            code[78] = 5734; //ExpressionStatement_0 # ExpressionStatement_0
            code[65] = 2431; //sum
            code[87] = 1679; //""
            code[91] = 1079; //3
            code[69] = 1920; //4
            code[83] = 1679; //""

            code[149] = 6978; //ExpressionStatement_1 # ExpressionStatement_1
            code[177] = 3295; //memberTemp_0

            code[216] = 1116; //ExpressionStatement_2 # ExpressionStatement_2
            code[241] = 2; //invocationTemp_0
            code[208] = 3295; //memberTemp_0
            code[213] = 2222; //1

            code[275] = 5692; //ExpressionStatement_3 # ExpressionStatement_3
            code[296] = 2431; //sum
            code[297] = 2431; //sum
            code[261] = 2; //invocationTemp_0

            code[345] = 9041; //ExpressionStatement_4 # ExpressionStatement_4
            code[365] = 143; //r
            code[350] = 1679; //""

            code[398] = 8243; //ExpressionStatement_5 # ExpressionStatement_5
            code[393] = 3578; //dst
            code[409] = 791; //b

            code[466] = 9041; //ExpressionStatement_4 # ExpressionStatement_6
            code[486] = 3783; //var_forIndex_0
            code[471] = 2050; //0

            code[519] = 8931; //ExpressionStatement_7 # ExpressionStatement_7
            code[521] = 3158; //var_whileCondition_0
            code[544] = 3783; //var_forIndex_0
            code[502] = 791; //b

            code[575] = 2437; //WhileStatementSyntax_8 # WhileStatementSyntax_8
            code[601] = 2621; //jmpWhileDestinationName_2621
            code[558] = 3158; //var_whileCondition_0
            code[577] = 80; //while_GoTo_True_80
            code[571] = 237; //while_GoTo_False_237

            code[632] = 7138; //ExpressionStatement_9 # ExpressionStatement_9
            code[635] = 2431; //sum
            code[646] = 2431; //sum
            code[642] = 86; //"_"
            code[653] = 3783; //var_forIndex_0
            code[640] = 86; //"_"

            code[700] = 1317; //ExpressionStatement_10 # ExpressionStatement_10
            code[713] = 2431; //sum
            code[698] = 2431; //sum
            code[695] = 2934; //"~"

            code[755] = 4256; //ExpressionStatement_11 # ExpressionStatement_11
            code[781] = 143; //r
            code[765] = 143; //r
            code[775] = 2431; //sum
            code[748] = 454; //"#"

            code[812] = 9664; //ExpressionStatement_12 # ExpressionStatement_12
            code[840] = 3947; //invocationTemp_1

            code[875] = 9597; //ExpressionStatement_13 # ExpressionStatement_13
            code[863] = 2276; //p1
            code[899] = 3947; //invocationTemp_1

            code[941] = 8019; //ExpressionStatement_14 # ExpressionStatement_14
            code[951] = 143; //r
            code[938] = 143; //r
            code[921] = 520; //"["
            code[942] = 2276; //p1
            code[944] = 2332; //"]"

            code[1000] = 1733; //ExpressionStatement_15 # ExpressionStatement_15
            code[1029] = 3987; //memberTemp_1
            code[981] = 143; //r

            code[1059] = 9444; //ExpressionStatement_16 # ExpressionStatement_16
            code[1066] = 2431; //sum
            code[1045] = 2431; //sum
            code[1081] = 3987; //memberTemp_1

            code[1117] = 5180; //ExpressionStatement_17 # ExpressionStatement_17
            code[1119] = 3578; //dst
            code[1110] = 3783; //var_forIndex_0
            code[1134] = 2431; //sum

            code[1171] = 7576; //ExpressionStatement_18 # ExpressionStatement_18
            code[1186] = 3783; //var_forIndex_0
            code[1174] = 3783; //var_forIndex_0
            code[1194] = 2222; //1

            code[1240] = 8931; //ExpressionStatement_7 # ExpressionStatement_19
            code[1242] = 3158; //var_whileCondition_0
            code[1265] = 3783; //var_forIndex_0
            code[1223] = 791; //b

            code[1296] = 3168; //ExpressionStatement_20 # ExpressionStatement_20
            code[1293] = 82; //while_FalseBlockSkip_82

            code[1352] = 9680; //ExpressionStatement_21 # ExpressionStatement_21
            code[1379] = 1571; //memberTemp_2
            code[1368] = 3578; //dst

            code[1408] = 5821; //ExpressionStatement_22 # ExpressionStatement_22
            code[1402] = 2431; //sum
            code[1420] = 2431; //sum
            code[1429] = 454; //"#"
            code[1421] = 1571; //memberTemp_2

            code[1470] = 6137; //ReturnStatement_23 # ReturnStatement_23
            code[1494] = 2431; //sum

            return (string)InstanceInterpreterVirtualization_TraceLoopTests_2145_2_op4_in5(vpc, data, code);

        }


        private object InstanceInterpreterVirtualization_TraceLoopTests_2145_2_op4_in5(int vpc, object[] data, int[] code)
        {
            while (true)
            {
                switch (code[vpc])
                {
                    case 4256:  //frequency 1 ExpressionStatement_11
                        data[code[vpc + (26)]] = (string)data[code[vpc + (10)]] + (string)data[code[vpc + (20)]] + (string)data[code[vpc + (-7)]];
                        vpc += 57;
                        break;
                    case 8019:  //frequency 1 ExpressionStatement_14
                        data[code[vpc + (10)]] = (string)data[code[vpc + (-3)]] + (string)data[code[vpc + (-20)]] + (double)data[code[vpc + (1)]] + (string)data[code[vpc + (3)]];
                        vpc += 59;
                        break;
                    case 8243:  //frequency 1 ExpressionStatement_5
                        data[code[vpc + (-5)]] = (string[])(new string[(int)data[code[vpc + (11)]]]);
                        vpc += 68;
                        break;
                    case 7576:  //frequency 1 ExpressionStatement_18
                        data[code[vpc + (15)]] = (int)data[code[vpc + (3)]] + (int)data[code[vpc + (23)]];
                        vpc += 69;
                        break;
                    default:  //frequency 0 
                        break;
                    case 1733:  //frequency 1 ExpressionStatement_15
                        data[code[vpc + (29)]] = ((string)data[code[vpc + (-19)]]).Length;
                        vpc += 59;
                        break;
                    case 5692:  //frequency 1 ExpressionStatement_3
                        data[code[vpc + (21)]] = (string)data[code[vpc + (22)]] + ((ConsoleCalculator.Piston)data[code[vpc + (-14)]]).ToString();
                        vpc += 70;
                        break;
                    case 1317:  //frequency 1 ExpressionStatement_10
                        data[code[vpc + (13)]] = (string)data[code[vpc + (-2)]] + (string)data[code[vpc + (-5)]];
                        vpc += 55;
                        break;
                    case 9041:  //frequency 2 ExpressionStatement_4
                        data[code[vpc + (20)]] = data[code[vpc + (5)]];
                        vpc += 53;
                        break;
                    case 5734:  //frequency 1 ExpressionStatement_0
                        data[code[vpc + (-13)]] = (string)data[code[vpc + (9)]] + (int)data[code[vpc + (13)]] + (int)data[code[vpc + (-9)]] + (string)data[code[vpc + (5)]];
                        vpc += 71;
                        break;
                    case 5821:  //frequency 1 ExpressionStatement_22
                        data[code[vpc + (-6)]] = (string)data[code[vpc + (12)]] + (string)data[code[vpc + (21)]] + (int)data[code[vpc + (13)]];
                        vpc += 62;
                        break;
                    case 9444:  //frequency 1 ExpressionStatement_16
                        data[code[vpc + (7)]] = (string)data[code[vpc + (-14)]] + (int)data[code[vpc + (22)]];
                        vpc += 58;
                        break;
                    case 3168:  //frequency 1 ExpressionStatement_20
                        vpc += (int)data[code[vpc + (-3)]];
                        vpc += 56;
                        break;
                    case 6978:  //frequency 1 ExpressionStatement_1
                        data[code[vpc + (28)]] = car.GetEngine().GetPistons().Count;
                        vpc += 67;
                        break;
                    case 2437:  //frequency 1 WhileStatementSyntax_8
                        data[code[vpc + (26)]] = (bool)data[code[vpc + (-17)]] ? (int)data[code[vpc + (2)]] : (int)data[code[vpc + (-4)]];
                        vpc += (int)data[code[vpc + (26)]];
                        break;
                    case 1116:  //frequency 1 ExpressionStatement_2
                        data[code[vpc + (25)]] = (ConsoleCalculator.Piston)(car.GetEngine().GetPiston((int)data[code[vpc + (-8)]] - (int)data[code[vpc + (-3)]]));
                        vpc += 59;
                        break;
                    case 6137:  //frequency 1 ReturnStatement_23
                        return (string)data[code[vpc + (24)]];
                        vpc += 67;
                    case 9680:  //frequency 1 ExpressionStatement_21
                        data[code[vpc + (27)]] = ((string[])data[code[vpc + (16)]]).Length;
                        vpc += 56;
                        break;
                    case 9664:  //frequency 1 ExpressionStatement_12
                        data[code[vpc + (28)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(car.GetEngine().GetPistons());
                        vpc += 63;
                        break;
                    case 5180:  //frequency 1 ExpressionStatement_17
                        ((string[])data[code[vpc + (2)]])[(int)data[code[vpc + (-7)]]] = (string)data[code[vpc + (17)]];
                        vpc += 54;
                        break;
                    case 9597:  //frequency 1 ExpressionStatement_13
                        data[code[vpc + (-12)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (24)]]).First().GetSize();
                        vpc += 66;
                        break;
                    case 7138:  //frequency 1 ExpressionStatement_9
                        data[code[vpc + (3)]] = (string)data[code[vpc + (14)]] + (string)data[code[vpc + (10)]] + (int)data[code[vpc + (21)]] + (string)data[code[vpc + (8)]];
                        vpc += 68;
                        break;
                    case 8931:  //frequency 2 ExpressionStatement_7
                        data[code[vpc + (2)]] = (int)data[code[vpc + (25)]] < ReturnArg_Array((int)data[code[vpc + (-17)]]);
                        vpc += 56;
                        break;
                }
            }

            return null;
        }


        public static string Time_Operation(string id, Func<int, string> method)
        {

            int op = 0;
            string log = id + " warming ... " + WARMUP + " times " ;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < WARMUP; i++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + "  warmed up in,   " + time;
            Output(log);
            time_warmup.Add(log);

            log = id + " running ... " + ITERATIONS + " times " ;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < ITERATIONS; j++)
            {
                method(NUMBER_OF_LOOPS);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + " finished in,     " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortIterative.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortIterative
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> data;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            QuickSortIterative lt = new QuickSortIterative();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
//            //            lt.ForSimple_Check();
//            int ELEMENTS = 350;
//            // Create an unsorted array of string elements
//            string[] testData = GenerateData(ELEMENTS);
//            var int_list = new List<int>();
//            foreach (var r in testData)
//            {
//                var value = Int32.Parse(r);
//                int_list.Add(value);
//            }
//            int[] unsorted_obfuscated = int_list.ToArray();
            

//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

           
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                int[] unsorted_original = data.ToArray();
                Console.WriteLine(i+" ##############");
                Debug.WriteLine(i+" ##############");
                string t_original = Time_Operation("QuickSortIterative_original", i, QuickSort_Iterative, unsorted_original, WARMUP, ITERATIONS);

                result += " " + t_original;

                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSort_Check";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var unsorted_obfuscated1 = (new List<int>(data));
            var int_list = new List<int>(data);
            
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + ", ");
            }
            Console.WriteLine("\n" + unsorted_original.Length);

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
//            sort(unsorted_original, 0, unsorted_original.Length - 1);
            Output("original_finished");
            QuickSort_Iterative(unsorted_obfuscated, unsorted_obfuscated.Length, -1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]

string QuickSort_Iterative(int[] arr, int length, int right)
{
    int MAX_LEVELS = 1000;
    int piv;
    int[] beg = new int[MAX_LEVELS];
    int[] end = new int[MAX_LEVELS];
    int i = 0;
    int L;
    int R;

    beg[0] = 0;
    end[0] = length;
    while (i >= 0)
    {
        L = beg[i];
        R = end[i] - 1;
        if (L < R)
        {
            piv = arr[L];
            if (i == MAX_LEVELS - 1)
                return "" + false;
            while (L < R)
            {
                while (arr[R] >= piv && L < R)
                    R--;
                if (L < R)
                    arr[L++] = arr[R];
                while (arr[L] <= piv && L < R)
                    L++;
                if (L < R) arr[R--] = arr[L];
            }
            arr[L] = piv;
            beg[i + 1] = L + 1;
            end[i + 1] = end[i];
            end[i++] = L;
        }
        else
        {
            i--;
        }
    }
    return "" + true;
}

        


        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,      " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("      {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in, " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortIterative_class.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortIterative_class
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> data;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            QuickSortIterative_class lt = new QuickSortIterative_class();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
//            //            lt.ForSimple_Check();
//            int ELEMENTS = 350;
//            // Create an unsorted array of string elements
//            string[] testData = GenerateData(ELEMENTS);
//            var int_list = new List<int>();
//            foreach (var r in testData)
//            {
//                var value = Int32.Parse(r);
//                int_list.Add(value);
//            }
//            int[] unsorted_obfuscated = int_list.ToArray();
            

//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

           
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                int[] unsorted_original = data.ToArray();
                Console.WriteLine(i+" ##############");
                Debug.WriteLine(i+" ##############");
                string t_original = Time_Operation("QuickSortIterative_class", i, QuickSort_Iterative_class, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSort_Check";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var unsorted_obfuscated1 = (new List<int>(data));
            var int_list = new List<int>(data);
            
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + ", ");
            }
            Console.WriteLine("\n" + unsorted_original.Length);

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
//            sort(unsorted_original, 0, unsorted_original.Length - 1);
            Output("original_finished");
            QuickSort_Iterative_class(unsorted_obfuscated, unsorted_obfuscated.Length, -1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; class")]
string QuickSort_Iterative_class(int[] arr, int length, int right)
{
    //Virtualization variables
    int[] code = new int[100798];
    object[] data = new object[4695];
    int vpc = 42;

    code[41603]=493;code[56411]=2;code[35352]=37;code[95288]=-381;code[12892]=-833;code[97178]=1219;
    code[90121]=1267;code[9497]=1490;code[24907]=1055;code[78915]=672;code[24619]=-498;code[99593]=-56;
    code[22380]=-425;code[74570]=834;code[64736]=-598;code[8590]=-857;code[45995]=-450;code[60818]=541;
    code[62224]=1135;code[2208]=771;code[71910]=502;code[51507]=-641;code[228]=-822;code[58128]=307;
    code[26994]=868;code[80530]=714;code[91326]=-573;code[8528]=-471;code[61399]=-546;code[18041]=-699;
    code[68051]=-472;code[61026]=1417;code[98961]=1266;code[43501]=685;code[30588]=193;code[38194]=-18;
    code[80657]=-815;code[96305]=607;code[69561]=1110;code[37851]=-624;code[65881]=-459;code[46968]=1237;
    code[36496]=-2;code[15266]=-288;code[13648]=-21;code[767]=88;code[68043]=1253;code[3388]=254;
    code[100367]=360;code[16331]=-761;code[64511]=1256;code[22141]=975;code[37137]=14;code[89264]=1079;
    code[21741]=103;code[52565]=912;code[81277]=-929;code[47054]=146;code[75153]=776;code[60962]=455;
    code[76115]=-634;code[54295]=1279;code[47359]=1358;code[72372]=1246;code[4087]=133;code[65249]=-635;
    code[68766]=-301;code[51450]=877;code[100495]=689;code[53063]=1390;code[51795]=-202;code[7003]=734;
    code[87720]=-394;code[63412]=616;code[43811]=437;code[76228]=-288;code[94679]=449;code[34324]=234;
    code[36686]=-231;code[32305]=62;code[69334]=1467;code[79764]=905;code[80053]=-62;code[8331]=316;
    code[52223]=789;code[46513]=-826;code[18558]=621;code[6903]=88;code[7753]=1111;code[4176]=-433;
    code[31686]=-822;code[46778]=163;code[70289]=-95;code[20834]=-744;code[94679]=-958;code[39009]=722;
    code[35796]=-747;code[27048]=317;code[53245]=-232;code[90682]=236;code[16133]=-744;code[12943]=797;
    code[11460]=715;code[10186]=-274;code[51525]=1262;code[42000]=297;code[26865]=-767;code[11148]=540;
    code[52693]=-186;code[6527]=80;code[17014]=1450;code[59187]=253;code[33144]=931;code[72052]=-794;
    code[38327]=353;code[91455]=923;code[95267]=366;code[6759]=-471;code[95058]=863;code[35449]=-973;
    code[26317]=1289;code[59608]=-915;code[60492]=1169;code[42587]=-346;code[99876]=629;code[426]=-495;
    code[24455]=169;code[32857]=-551;code[51951]=567;code[39308]=-147;code[97920]=-954;code[91772]=1424;
    code[100560]=617;code[57860]=799;code[2652]=1247;code[67866]=943;code[98202]=-866;code[17232]=-368;
    code[39182]=382;code[90831]=152;code[35269]=132;code[9249]=820;code[54153]=762;code[53112]=193;
    code[22244]=1217;code[70190]=-211;code[35813]=-974;code[3989]=-394;code[555]=554;code[3697]=1382;
    code[29616]=756;code[23732]=-770;code[98647]=-434;code[22985]=-528;code[29901]=-818;code[79754]=1406;
    code[73179]=1322;code[99927]=296;code[93404]=-545;code[43589]=-269;code[12117]=-759;code[50316]=-652;
    code[20409]=-107;code[42555]=1409;code[1424]=1320;code[24928]=917;code[52028]=1370;code[16849]=618;
    code[21934]=1499;code[75557]=-224;code[48079]=-155;code[18232]=-632;code[9661]=834;code[59462]=65;
    code[1918]=302;code[31852]=1058;code[19072]=860;code[83942]=-507;code[20507]=-760;code[89663]=553;
    code[81096]=-340;code[17617]=-80;code[83242]=-940;code[44992]=944;code[76790]=-140;code[30318]=1317;
    code[43605]=-696;code[82213]=955;code[92290]=-121;code[4370]=171;code[77355]=1489;code[95234]=232;
    code[61715]=60;code[58243]=930;code[11626]=1424;code[44736]=-697;code[11107]=-680;code[50999]=-469;
    code[16454]=1031;code[32424]=-821;code[28973]=1030;code[66977]=687;code[22214]=-28;code[39381]=-832;
    code[93582]=-874;code[28397]=1129;code[5328]=52;code[86066]=1021;code[32192]=704;code[76210]=4;
    code[44991]=685;code[66780]=979;code[90744]=-552;code[82323]=-240;code[62089]=507;code[62388]=-743;
    code[3021]=1429;code[18267]=1388;code[33404]=-326;code[27472]=-443;code[3356]=276;code[85041]=-839;
    code[69359]=480;code[6905]=723;code[27662]=743;code[90054]=203;code[5690]=1299;code[63028]=532;
    code[15073]=1181;code[78083]=-898;code[57693]=-785;code[45488]=-187;code[43508]=-554;code[82836]=-798;
    code[24155]=1246;code[48107]=-877;code[41253]=332;code[37147]=1339;code[83719]=494;code[10471]=-230;
    code[11177]=-682;code[3010]=1296;code[71506]=-657;code[4698]=-725;code[34915]=420;code[81226]=147;
    code[49915]=-422;code[65599]=1367;code[5973]=295;code[63814]=273;code[77635]=1468;code[45326]=-61;
    code[22177]=1109;code[7271]=308;code[55570]=723;code[78884]=379;code[77471]=166;code[93750]=112;
    code[5697]=331;code[62108]=-265;code[13308]=779;code[74063]=678;code[9337]=-955;code[55871]=-556;
    code[88911]=54;code[88352]=-219;code[97235]=486;code[54232]=-692;code[68311]=634;code[70425]=1163;
    code[6592]=307;code[56327]=642;code[79170]=-365;code[69584]=-929;code[30387]=-486;code[89747]=316;
    code[90910]=-153;code[38042]=-854;code[25458]=945;code[28557]=-496;code[29193]=1236;code[64659]=-676;
    code[81943]=175;code[59178]=-565;code[93578]=1016;code[77337]=6;code[84055]=876;code[23053]=522;
    code[15408]=-806;code[89320]=1096;code[33061]=313;code[88321]=690;code[53547]=-126;code[41382]=564;
    code[21875]=198;code[87791]=1249;code[37354]=242;code[58045]=-573;code[88859]=72;code[85066]=-212;
    code[67227]=290;code[10119]=237;code[44207]=219;code[69828]=-622;code[11116]=921;code[91287]=-564;
    code[89905]=111;code[88063]=910;code[1833]=1413;code[60320]=157;code[6005]=1403;code[96475]=122;
    code[94302]=1169;code[3226]=-158;code[17621]=-856;code[73320]=809;code[23580]=427;code[17296]=1029;
    code[42849]=-47;code[23955]=-892;code[66233]=-352;code[51949]=121;code[57842]=740;code[773]=1314;
    code[62830]=1029;code[15399]=1290;code[83732]=-48;code[25776]=763;code[56352]=628;code[56381]=427;
    code[45939]=-111;code[98418]=-869;code[4135]=-546;code[94825]=-198;code[27532]=-846;code[34171]=592;
    code[73337]=387;code[81241]=1000;code[44960]=271;code[88199]=-402;code[86681]=-735;code[71925]=-93;
    code[91217]=1027;code[90014]=1132;code[31761]=165;code[25476]=933;code[82850]=666;code[59239]=-247;
    code[28516]=157;code[41080]=-21;code[76154]=716;code[65789]=403;code[47649]=289;code[19026]=-311;
    code[57943]=138;code[26154]=-874;code[78268]=-200;code[71664]=-127;code[64742]=533;code[14876]=-426;
    code[29120]=-781;code[605]=1017;code[81556]=413;code[82142]=-848;code[97496]=261;code[52146]=1458;
    code[10178]=207;code[48761]=-567;code[45709]=-620;code[89745]=-28;code[62727]=543;code[28044]=1149;
    code[20824]=-495;code[100504]=254;code[96336]=-405;code[66417]=673;code[31776]=-556;code[10385]=669;
    code[68597]=1114;code[75835]=1268;code[70654]=-681;code[31094]=-825;code[94560]=-310;code[95711]=-267;
    code[84297]=343;code[90324]=225;code[72872]=896;code[61247]=679;code[81589]=-635;code[60527]=517;
    code[57285]=-218;code[10594]=822;code[85257]=1119;code[67327]=1308;code[38309]=1039;code[49677]=519;
    code[40291]=1457;code[69359]=236;code[31125]=-480;code[92884]=1325;code[25468]=759;code[67087]=45;
    code[34474]=-579;code[95417]=391;code[57451]=78;code[86525]=335;code[24707]=-637;code[34167]=-31;
    code[2297]=448;code[22604]=-775;code[61316]=-935;code[92061]=-949;code[4508]=-280;code[9120]=849;
    code[7096]=-717;code[36571]=503;code[22667]=675;code[35704]=1161;code[65264]=717;code[39019]=692;
    code[90829]=-722;code[35621]=1371;code[96511]=1396;code[36564]=-365;code[64922]=-250;code[47537]=823;
    code[99171]=1077;code[32456]=-434;code[79666]=612;code[37641]=-866;code[7885]=-484;code[49020]=141;
    code[6913]=-358;code[31175]=437;code[79755]=185;code[74632]=-161;code[19378]=367;code[19077]=242;
    code[67812]=1411;code[6343]=-785;code[93285]=1090;code[9657]=925;code[64671]=583;code[62234]=-16;
    code[35093]=-681;code[7484]=-995;code[31599]=-167;code[60366]=735;code[62985]=1241;code[88707]=750;
    code[65455]=969;code[46670]=-576;code[56423]=-661;code[54145]=91;code[64696]=1062;code[55815]=1064;
    code[58685]=-282;code[12932]=-395;code[11181]=790;code[82164]=87;code[64478]=1288;code[22860]=658;
    code[40327]=845;code[2252]=1147;code[95579]=237;code[87918]=940;code[8528]=-94;code[44014]=-656;
    code[37618]=1315;code[21211]=264;code[9698]=-549;code[75790]=308;code[57854]=-379;code[42345]=-935;
    code[20665]=-108;code[58810]=1271;code[8215]=112;code[6116]=834;code[56545]=998;code[77578]=1054;
    code[11432]=695;code[49239]=-633;code[96025]=944;code[74698]=-451;code[85751]=1476;code[87571]=-538;
    code[50971]=-227;code[34168]=147;code[16492]=758;code[9028]=-622;code[32052]=1490;code[65912]=478;
    code[91869]=1408;code[70014]=599;code[30429]=757;code[58130]=434;code[15765]=-29;code[39554]=44;
    code[69770]=512;code[57515]=990;code[51152]=-499;code[17677]=-464;code[49198]=-4;code[1421]=8176;code[449]=2793;    data[3600]=1000;
code[2000]=569;code[3226]=1255;    data[1771]=244;
code[3321]=1769;code[718]=3511;code[2063]=2841;code[1280]=1332;code[1764]=239;    data[3179]=911;
code[471]=3890;code[886]=1486;code[1845]=3179;code[2018]=4797;code[815]=1029;    data[2887]=length;
code[2394]=3359;code[719]=2138;    data[1222]=true;
    data[1722]=62;
code[1706]=1210;    data[253]=1026765439;
code[2227]=3043;    data[279]=-245;
code[2565]=1029;code[1612]=2895;code[869]=9480;    data[2270]=668;
code[1328]=3256;code[1549]=569;code[1067]=253;code[622]=6480;    data[2479]=false;
code[2559]=3179;    data[569]=-432;
code[972]=3262;    data[42]="" ;
code[1004]=364;code[2842]=1258;code[3504]=42;code[946]=1486;code[2217]=3179;code[1908]=7091;code[630]=207;code[1220]=1332;code[3132]=4819;code[2577]=1029;    data[3843]=false;
    data[1397]=1641648764;
code[1915]=207;code[170]=4692;code[3578]=1397;code[985]=3311;code[3136]=536;code[472]=730;    data[3311]=false;
code[1120]=9895;code[973]=2980;code[1905]=239;code[2208]=4797;code[1358]=569;code[3326]=536;code[3193]=3179;    data[3095]=right;
    data[3629]=714;
code[2637]=725;code[951]=3311;    data[3890]=2997;
code[2190]=569;code[2027]=3179;code[2094]=736;code[1993]=1855;code[2315]=962;code[391]=2793;    data[1995]=965;
    data[2841]=-955;
    data[1255]=943;
code[1284]=8176;code[3016]=1995;code[2155]=3179;code[3460]=2565;code[3346]=536;code[2832]=536;code[1405]=2459;code[120]=587;    data[2493]=(int[])null;
    data[1769]=1;
    data[3511]=2574;
    data[3359]=62;
code[1500]=207;    data[2665]=62;
code[69]=3600;code[2510]=1769;code[2552]=7091;    data[110]=62;
code[3198]=2493;code[1537]=1811;code[3392]=2793;code[2677]=207;code[2298]=1232;code[2952]=4819;code[324]=2793;code[797]=7567;code[810]=3179;code[420]=7131;code[1768]=3179;code[2029]=3179;code[3284]=3001;    data[429]=1488;
code[2269]=2895;code[1532]=207;code[3075]=9736;code[568]=587;    data[730]=-195;
code[2893]=1258;    data[1332]=false;
code[403]=536;code[3199]=6846;code[2662]=5746;code[2233]=1029;code[919]=536;code[679]=5746;code[131]=2270;code[1174]=2895;code[3055]=1255;code[1243]=207;code[923]=5973;    data[1044]=362;
code[2608]=2895;code[872]=2270;    data[3043]=false;
code[1855]=3179;    data[3256]=false;
code[298]=2943;    data[2301]=245;
code[323]=2793;    data[3001]=54;
    data[3262]=239;
code[2425]=207;code[824]=569;code[3431]=2895;code[2062]=1771;code[2766]=569;code[3481]=1222;code[1784]=9736;    data[207]=532;
code[2363]=372;code[1417]=3256;code[1921]=1029;code[2338]=207;code[2141]=4819;code[1338]=3179;code[63]=2270;    data[795]=283;
code[3501]=1397;code[284]=587;code[632]=536;code[2646]=3179;code[1526]=1029;code[2799]=3179;code[1666]=5746;code[2145]=3179;code[3363]=7131;code[2956]=536;    data[1182]=296;
code[1144]=253;code[663]=3179;code[638]=2493;    data[1232]=-244;
code[3044]=2493;    data[239]=93;
code[110]=4692;code[1964]=2895;code[2379]=8176;code[1533]=207;code[2747]=3744;code[435]=3518;code[1681]=207;code[1658]=2479;code[1650]=3179;        data[1029]=(int[])arr;
code[191]=2270;code[180]=2493;code[2307]=3179;    data[587]=(int[])null;
code[2219]=3179;code[2362]=795;code[1869]=1769;code[1641]=279;code[1529]=3179;code[1495]=1769;code[3554]=9895;    data[1486]=-837;
code[3485]=1576;code[1436]=110;code[1705]=1182;    data[2980]=709;
    data[962]=false;
code[2828]=4819;code[2718]=2895;code[617]=1769;code[1933]=1029;code[503]=1722;    data[736]=62;
code[1519]=3256;    data[3744]=-1488;
    data[2138]=-957;
code[881]=1769;code[484]=3518;    data[536]=189;
code[2075]=3043;    data[1674]=0;
code[577]=3179;code[2323]=5746;code[671]=63;code[3309]=9480;code[1483]=9480;code[2441]=9736;code[364]=6846;code[3160]=1769;code[3019]=7091;    data[2565]=-2997;
    data[3975]=62;
code[3032]=2493;code[363]=2493;code[2654]=1332;    data[364]=62;
    data[1855]=0;
code[2014]=207;code[3312]=536;    data[1258]=647;
    data[3020]=62;
code[3026]=536;code[2881]=3179;code[989]=8176;code[2515]=207;code[1047]=3843;code[2421]=1044;code[2079]=8176;code[1212]=3179;code[42]=4078;code[1841]=4819;code[1299]=2665;code[3146]=536;code[2501]=207;code[3255]=2895;    data[2793]=0;
    data[63]=false;
code[1486]=207;code[2498]=9480;code[2980]=1769;code[3378]=3518;code[1051]=1576;code[1342]=207;    data[372]=219;
code[694]=207;code[731]=63;code[488]=8176;code[2169]=1769;code[2907]=1769;code[358]=2887;code[230]=4078;code[1341]=207;code[750]=3975;code[1346]=1811;    data[725]=0;
code[1718]=2479;code[1070]=42;    data[3518]=false;
    data[1210]=116;
code[2549]=1044;code[1404]=2301;code[257]=2793;code[3059]=536;code[2895]=2925;code[1228]=5746;code[2043]=1029;code[2375]=962;code[251]=536;code[2772]=6846;    data[2459]=-17;
code[1267]=429;code[550]=7567;code[563]=536;code[2771]=1029;code[1722]=8176;code[2204]=207;code[735]=8176;code[2856]=1769;code[1737]=3020;code[2966]=1995;code[1203]=1674;code[2887]=587;code[1335]=1029;code[1268]=3629;code[2037]=3043;
    return (string)InstanceInterpreterVirtualization_QuickSortIterative_class_368(vpc, data, code);

}

        


        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in, " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + "  times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,       " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private object InstanceInterpreterVirtualization_QuickSortIterative_class_368(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 4692:
                data[code[vpc + (10)]] = (int[])(new int[(int)data[code[vpc + (21)]]]);
                vpc += 60;
                break;
            case 2925:
                ((int[])data[code[vpc + (-8)]])[(int)data[code[vpc + (-2)]]] = (int)data[code[vpc + (-14)]] + (int)data[code[vpc + (12)]];
                vpc += 57;
                break;
            case 2943:
                ((int[])data[code[vpc + (-14)]])[(int)data[code[vpc + (26)]]] = (int) data[code[vpc + (25)]];
                vpc += 66;
                break;
            case 4797:
                data[code[vpc + (19)]] = ((int[])data[code[vpc + (25)]])[(int)data[code[vpc + (9)]]] <= (int)data[code[vpc + (-18)]] && (int)data[code[vpc + (11)]] < (int)data[code[vpc + (-4)]];
                vpc += 61;
                break;
            case 4819:
                data[code[vpc + (14)]] = (int)data[code[vpc + (4)]] + (int)data[code[vpc + (28)]];
                vpc += 67;
                break;
            case 7091:
                ((int[])data[code[vpc + (25)]])[(int)data[code[vpc + (-3)]]] = ((int[])data[code[vpc + (13)]])[(int)data[code[vpc + (7)]]];
                vpc += 56;
                break;
            default:
                break;
            case 7567:
                data[code[vpc + (27)]] = ((int[])data[code[vpc + (18)]])[(int)data[code[vpc + (13)]]];
                vpc += 72;
                break;
            case 4078:
                data[code[vpc + (21)]] = data[code[vpc + (27)]];
                vpc += 68;
                break;
            case 7131:
                data[code[vpc + (15)]] = (int)data[code[vpc + (29)]] <= (int)data[code[vpc + (-17)]];
                vpc += 68;
                break;
            case 9736:
                data[code[vpc + (-20)]] = (int)data[code[vpc + (-16)]];
                vpc += 57;
                break;
            case 9895:
                return (string)data[code[vpc + (24)]];
                vpc += 54;
            case 5973:
                data[code[vpc + (28)]] = (int)data[code[vpc + (-4)]] == (int)data[code[vpc + (23)]];
                vpc += 66;
                break;
            case 8176:
                data[code[vpc + (-16)]] = (bool)data[code[vpc + (-4)]] ? (int)data[code[vpc + (15)]] : (int)data[code[vpc + (-17)]];
                vpc += (int)data[code[vpc + (-16)]];
                break;
            case 5746:
                data[code[vpc + (-8)]] = (int)data[code[vpc + (-16)]] < (int)data[code[vpc + (15)]];
                vpc += 56;
                break;
            case 1576:
                data[code[vpc + (16)]] = (string)data[code[vpc + (19)]] + (bool)data[code[vpc + (-4)]];
                vpc += 69;
                break;
            case 9480:
                data[code[vpc + (17)]] = (int)data[code[vpc + (3)]] - (int)data[code[vpc + (12)]];
                vpc += 54;
                break;
            case 6480:
                data[code[vpc + (8)]] = ((int[])data[code[vpc + (16)]])[(int)data[code[vpc + (10)]]] - (int)data[code[vpc + (-5)]];
                vpc += 57;
                break;
            case 2895:
                vpc += (int)data[code[vpc + (29)]];
                vpc += 54;
                break;
            case 1811:
                data[code[vpc + (-18)]] = (int)data[code[vpc + (12)]] <= ((int[])data[code[vpc + (-11)]])[(int)data[code[vpc + (-5)]]] && (int)data[code[vpc + (-8)]] < (int)data[code[vpc + (-4)]];
                vpc += 75;
                break;
            case 6846:
                ((int[])data[code[vpc + (-1)]])[(int)data[code[vpc + (27)]]] = (int)data[code[vpc + (-6)]];
                vpc += 56;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortIterative_class_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortIterative_class_default
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> data;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            QuickSortIterative_class_default lt = new QuickSortIterative_class_default();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
//            //            lt.ForSimple_Check();
//            int ELEMENTS = 350;
//            // Create an unsorted array of string elements
//            string[] testData = GenerateData(ELEMENTS);
//            var int_list = new List<int>();
//            foreach (var r in testData)
//            {
//                var value = Int32.Parse(r);
//                int_list.Add(value);
//            }
//            int[] unsorted_obfuscated = int_list.ToArray();
            

//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

           
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                int[] unsorted_original = data.ToArray();
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i+" ##############");
                string t_original = Time_Operation("QuickSortIterative_class_default", i, QuickSort_Iterative_class_default, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSort_Check";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var unsorted_obfuscated1 = (new List<int>(data));
            var int_list = new List<int>(data);
            
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + ", ");
            }
            Console.WriteLine("\n" + unsorted_original.Length);

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
//            sort(unsorted_original, 0, unsorted_original.Length - 1);
            Output("original_finished");
            QuickSort_Iterative_class_default(unsorted_obfuscated, unsorted_obfuscated.Length, -1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }



//        [Obfuscation(Exclude = false, Feature = "virtualization; class")]
string QuickSort_Iterative_class_default(int[] arr, int length, int right)
{
    //Virtualization variables
    int[] code = new int[100512];
    object[] data = new object[4760];
    int vpc = 53;

    code[94469]=-501;code[54452]=-950;code[88212]=811;code[26949]=555;code[92436]=-920;code[29545]=1318;
    code[25328]=64;code[20423]=1431;code[18098]=860;code[5574]=962;code[80616]=-305;code[6749]=948;
    code[75413]=-917;code[41462]=492;code[16089]=6;code[16197]=-766;code[63034]=-425;code[6471]=728;
    code[2124]=751;code[50427]=750;code[15461]=-931;code[40277]=98;code[80466]=720;code[90487]=986;
    code[4170]=639;code[81460]=1302;code[33197]=1034;code[39093]=654;code[13346]=906;code[27133]=1111;
    code[31348]=677;code[46449]=292;code[87547]=-500;code[30185]=-946;code[36323]=279;code[95650]=198;
    code[24374]=-113;code[63453]=936;code[88203]=569;code[98370]=-845;code[13360]=544;code[55854]=260;
    code[59513]=-400;code[76731]=1033;code[84564]=6;code[56157]=-354;code[43300]=643;code[39038]=207;
    code[56840]=1209;code[57129]=500;code[38967]=1196;code[43559]=324;code[70772]=-173;code[68194]=1437;
    code[18337]=536;code[78807]=262;code[78777]=-481;code[71514]=735;code[11580]=1394;code[92970]=577;
    code[43906]=217;code[18128]=1396;code[95784]=732;code[4875]=463;code[97170]=-629;code[20996]=1484;
    code[5965]=-55;code[67803]=-365;code[18531]=-936;code[80428]=-348;code[56454]=970;code[63415]=-433;
    code[62185]=-866;code[47731]=-443;code[95059]=735;code[36956]=519;code[96355]=1343;code[16432]=1251;
    code[70176]=186;code[57976]=-973;code[28409]=-767;code[840]=-915;code[40771]=975;code[44796]=13;
    code[53581]=142;code[51237]=-777;code[15842]=660;code[6953]=621;code[86038]=1383;code[34165]=1248;
    code[21920]=1063;code[64274]=-319;code[78470]=502;code[3543]=-696;code[21598]=934;code[55900]=774;
    code[45138]=972;code[98331]=171;code[78391]=492;code[82536]=1071;code[61109]=-827;code[69356]=221;
    code[18543]=-305;code[45237]=-264;code[87277]=287;code[4497]=861;code[13553]=693;code[79711]=143;
    code[45607]=839;code[25462]=1011;code[75876]=-191;code[19148]=898;code[90558]=1000;code[64349]=-79;
    code[68920]=501;code[87305]=-353;code[13306]=278;code[29279]=-629;code[13603]=-623;code[8846]=255;
    code[15188]=851;code[25478]=749;code[73281]=1028;code[57770]=928;code[100108]=302;code[1475]=-890;
    code[34531]=-959;code[7400]=-290;code[88348]=1326;code[59062]=-40;code[64141]=-797;code[61205]=-332;
    code[64963]=964;code[61538]=558;code[38817]=611;code[32357]=-243;code[65115]=877;code[65667]=-965;
    code[7072]=226;code[3032]=-777;code[22654]=1171;code[37448]=-589;code[58906]=1061;code[92024]=-711;
    code[43999]=-983;code[27097]=-489;code[56612]=759;code[86859]=-826;code[13233]=1464;code[5387]=1358;
    code[20028]=1378;code[38733]=-122;code[20013]=779;code[39825]=481;code[36523]=-852;code[21486]=-29;
    code[90521]=245;code[15974]=923;code[71254]=110;code[68500]=1054;code[87450]=241;code[18664]=-53;
    code[37679]=-707;code[74342]=1360;code[89134]=459;code[88715]=-789;code[43920]=-784;code[89474]=-315;
    code[48575]=-948;code[97047]=1185;code[43050]=-193;code[75613]=-54;code[79745]=1202;code[30549]=-838;
    code[54753]=-764;code[36251]=718;code[30592]=-421;code[7377]=756;code[76952]=-985;code[98163]=-796;
    code[97710]=130;code[70935]=949;code[17757]=-677;code[95631]=1034;code[61106]=1212;code[28768]=719;
    code[48119]=1018;code[39547]=367;code[74810]=1018;code[58862]=234;code[81758]=686;code[40144]=980;
    code[22419]=-512;code[78407]=-488;code[1336]=-532;code[51107]=192;code[4464]=1209;code[90675]=1440;
    code[62040]=1431;code[20278]=660;code[93447]=225;code[45945]=649;code[81258]=682;code[20968]=242;
    code[84264]=315;code[96327]=1395;code[42284]=207;code[26968]=-257;code[5293]=1284;code[55943]=1453;
    code[35100]=865;code[80470]=51;code[37830]=1023;code[64673]=487;code[90972]=43;code[93456]=929;
    code[60860]=1303;code[56686]=-192;code[21855]=848;code[98871]=375;code[99170]=-293;code[36866]=217;
    code[23030]=375;code[5653]=403;code[61862]=511;code[92830]=759;code[41817]=-450;code[31647]=-542;
    code[69293]=-909;code[28497]=1497;code[2951]=534;code[59505]=52;code[59957]=-534;code[35463]=247;
    code[92364]=1362;code[8053]=-218;code[93466]=-985;code[99982]=-835;code[38145]=-216;code[19227]=1065;
    code[75687]=-796;code[98447]=-249;code[49615]=-435;code[35742]=-38;code[60978]=-49;code[63722]=-549;
    code[45830]=1461;code[52354]=-68;code[69446]=1364;code[89498]=-894;code[19830]=392;code[64581]=676;
    code[52712]=526;code[77768]=24;code[22677]=-379;code[80801]=-61;code[84969]=143;code[24741]=1368;
    code[63744]=-272;code[93225]=-75;code[83536]=1419;code[89702]=345;code[31251]=1248;code[86156]=1363;
    code[48794]=554;code[37724]=84;code[42538]=-628;code[63216]=-511;code[44167]=-228;code[78004]=1208;
    code[45474]=1364;code[16034]=-105;code[57959]=-355;code[33709]=1496;code[74212]=433;code[74256]=-2;
    code[1821]=300;code[21237]=-426;code[66803]=-740;code[36147]=562;code[75708]=1070;code[92897]=509;
    code[87774]=-75;code[95740]=741;code[83255]=-875;code[51057]=-187;code[51805]=-890;code[92262]=1213;
    code[81228]=335;code[96665]=-869;code[56685]=1146;code[20810]=1279;code[88746]=1439;code[41787]=1257;
    code[94238]=-2;code[53399]=-162;code[95411]=-623;code[13064]=560;code[2176]=389;code[48727]=-484;
    code[30724]=597;code[17125]=720;code[6584]=33;code[88853]=1434;code[60520]=-185;code[42361]=-675;
    code[14312]=-233;code[6141]=1236;code[62445]=-970;code[72460]=1243;code[95916]=-877;code[76277]=72;
    code[52160]=-569;code[37795]=-89;code[91900]=-266;code[86798]=-369;code[4984]=887;code[75084]=1312;
    code[69162]=297;code[85079]=173;code[9235]=104;code[30256]=528;code[98287]=2;code[19387]=605;
    code[9035]=-412;code[284]=-977;code[83899]=468;code[25361]=-360;code[88449]=853;code[17003]=1232;
    code[3764]=298;code[5978]=-230;code[46486]=-578;code[8106]=-32;code[56275]=-660;code[20769]=-745;
    code[16664]=-372;code[80961]=280;code[75217]=-632;code[45340]=-706;code[98480]=834;code[27592]=697;
    code[29248]=1135;code[41991]=155;code[50536]=226;code[4531]=1366;code[35154]=1384;code[43421]=430;
    code[38440]=1481;code[14978]=1022;code[32202]=1014;code[8285]=1384;code[2873]=1251;code[84789]=458;
    code[78589]=849;code[51053]=831;code[29178]=-872;code[91769]=-241;code[24632]=-50;code[1739]=520;
    code[75501]=546;code[88899]=-828;code[9140]=-351;code[75643]=-470;code[82365]=-417;code[13056]=889;
    code[100345]=605;code[80160]=-565;code[65459]=-199;code[65383]=-24;code[1065]=1086;code[68375]=907;
    code[98781]=-219;code[65975]=-254;code[4083]=-680;code[32888]=-995;code[98040]=351;code[5804]=754;
    code[92584]=-967;code[86734]=921;code[14865]=578;code[76770]=371;code[61319]=880;code[73802]=620;
    code[25501]=847;code[65582]=1311;code[73360]=566;code[60076]=1291;code[94297]=-696;code[8680]=946;
    code[60661]=135;code[17239]=728;code[91063]=-681;code[78419]=144;code[58741]=-761;code[25433]=594;
    code[46005]=1204;code[24385]=-53;code[7107]=-672;code[15351]=-424;code[58113]=-980;code[4502]=-246;
    code[47819]=6;code[27359]=-129;code[94782]=-648;code[76763]=998;code[93164]=-789;code[16597]=734;
    code[46227]=-819;code[64596]=205;code[97706]=-309;code[6402]=-605;code[48829]=-964;code[46909]=1120;
    code[38613]=-454;code[85027]=1016;code[97387]=1139;code[20132]=488;code[41137]=1174;code[21655]=258;
    code[85999]=78;code[51726]=108;code[33357]=133;code[71471]=-67;code[72038]=371;code[92394]=1495;
    code[49141]=676;code[25970]=-247;code[94939]=1216;code[82013]=153;code[94085]=60;code[96938]=811;
    code[29663]=1392;code[83479]=-823;code[88866]=424;code[28599]=475;code[86150]=-652;code[62983]=351;
    code[76588]=550;code[83044]=-920;code[30497]=-767;code[13196]=1088;code[30082]=1119;code[31929]=-254;
    code[60055]=1246;code[65400]=306;code[5404]=885;code[57004]=78;code[46951]=975;code[14897]=-64;
    code[62618]=600;code[49161]=-633;code[26560]=-178;code[14172]=-127;code[4406]=794;code[54230]=-190;
    code[6078]=959;code[15864]=1106;code[29438]=-678;code[42734]=118;code[64275]=330;code[47594]=1463;
    code[92388]=904;code[53914]=-743;code[57522]=-513;code[7376]=1429;code[47455]=128;code[41133]=658;
    code[60740]=1461;code[57403]=1425;code[71042]=1420;code[25590]=1199;code[36103]=-184;code[46447]=-325;
    code[59940]=811;code[13925]=-155;code[36687]=752;code[73900]=-773;code[16737]=259;code[22882]=255;
    code[79671]=-905;code[78112]=1121;code[64776]=419;code[85642]=522;code[37638]=236;code[23952]=-229;
    code[56080]=137;code[74427]=678;code[27891]=484;code[62939]=481;code[30137]=-335;code[50915]=1119;
    code[5693]=838;code[60991]=928;code[71990]=-205;code[49939]=-749;code[76064]=-828;code[17847]=671;
    code[19202]=14;code[23636]=978;code[47681]=1132;code[90016]=-746;    data[252]=-360;
    data[3672]=false;
code[2873]=1785;code[1734]=9570;    data[389]=-203;
code[3220]=629;    data[2127]=924;
    data[272]=540;
code[1198]=1489;code[2813]=3258;code[888]=3736;    data[3185]=-124;
    data[3942]=-546;
code[182]=1725;code[2476]=2129;code[1699]=2556;    data[2556]=427;
    data[3036]=672;
code[480]=1642;    data[871]=-568;
code[979]=3819;code[385]=1861;    data[1559]=1485;
code[3439]=3460;code[2954]=3254;    data[3126]=-301;
code[2968]=2858;code[2482]=3456;code[3214]=2284;code[2340]=3819;code[238]=2858;code[3469]=608;code[3327]=1234;    data[1134]=449;
code[1637]=1818;code[2361]=890;code[1723]=2428;    data[2311]=806;
code[2325]=1542;    data[477]=281;
    data[1228]=913;
code[687]=794;code[2047]=3819;    data[1790]="" ;
code[912]=2238;code[1433]=1734;    data[1552]=-638;
    data[71]=147;
code[2252]=2332;code[627]=2980;code[2757]=785;    data[828]=-673;
code[1879]=3741;    data[1550]=-240;
    data[2897]=-965;
    data[310]=false;
code[2236]=2284;code[1003]=75;    data[3265]=-500;
code[2171]=816;code[1593]=3823;code[3055]=2858;    data[3353]=-2940;
code[1038]=4049;code[1271]=359;code[1415]=2097;code[2536]=1107;code[1481]=785;    data[1625]=404;
code[788]=3741;    data[382]=-348;
code[3057]=2369;    data[1889]=-468;
code[2589]=1541;code[1674]=999;    data[2907]=974;
    data[3565]=-517;
code[1113]=408;code[1569]=446;code[368]=66;    data[1381]=-586;
    data[3520]=false;
code[2758]=2854;code[2798]=5326;    data[783]=873;
code[2033]=3053;code[2799]=2858;    data[3590]=-591;
    data[1209]=-710;
code[860]=2495;    data[1015]=-311;
    data[985]=-758;
code[1571]=2284;code[2973]=2814;    data[2502]=-592;
code[593]=2858;    data[3375]=-189;
    data[1175]=239;
    data[3127]=988;
code[1461]=627;    data[1703]=512;
    data[1751]=-937;
code[2689]=2284;code[2717]=870;code[2279]=3247;code[675]=1291;code[2740]=1742;code[3319]=9964;code[1051]=1790;    data[3366]=880;
code[1091]=6387;code[2328]=3739;code[2639]=3362;code[886]=2311;code[1255]=3819;code[3478]=6387;code[267]=2909;    data[1584]=774;
    data[166]=141;
    data[845]=-246;
code[2636]=6594;code[125]=432;    data[3956]=-295;
code[313]=2909;    data[2773]=297;
code[2984]=2316;    data[1177]=992;
code[305]=1785;code[3421]=1883;code[2487]=3147;code[1954]=794;code[1729]=458;code[2180]=785;    data[3198]=91;
code[3212]=1030;    data[1276]=-861;
code[1151]=2284;code[3330]=2170;code[1213]=2171;code[883]=3305;    data[2517]=343;
code[2151]=1095;code[1802]=3502;code[3248]=3871;code[1640]=1201;    data[1191]=-487;
code[1660]=2773;code[2875]=3871;code[914]=9539;code[1314]=1912;    data[3604]=0;
code[1333]=1828;code[1843]=3616;code[3372]=3353;code[613]=7988;code[2415]=3147;code[434]=2858;code[3411]=3603;    data[1145]=641;
code[1512]=3741;code[802]=1044;    data[75]=-358;
    data[2731]=-961;
code[2853]=7686;code[2932]=3871;code[862]=3391;    data[3843]=59;
    data[2905]=236;
    data[2753]=-130;
code[2248]=3494;    data[2251]=227;
    data[837]=739;
    data[3147]=-364;
code[1428]=3871;code[1190]=2675;code[740]=32;code[1991]=785;code[2608]=237;code[1029]=989;code[3127]=2248;code[2998]=27;code[619]=2310;    data[1234]=false;
    data[2813]=-733;
    data[3474]=150;
    data[1894]=729;
    data[1310]=-83;
    data[1304]=right;
    data[2858]=-455;
code[139]=413;code[1522]=794;code[1033]=2603;code[1873]=1079;code[2441]=848;code[2394]=998;code[2880]=3258;    data[293]=106;
    data[3699]=59;
code[542]=2210;    data[1235]=-87;
    data[803]=787;
code[2121]=794;    data[3330]=399;
    data[1003]=59;
code[1494]=3520;code[2287]=6594;code[2698]=3689;code[607]=27;    data[3163]=633;
    data[1347]=-746;
code[3446]=1572;code[756]=803;code[2585]=2284;    data[804]=2533;
code[430]=9964;    data[3812]=974;
    data[564]=407;
    data[3301]=-255;
code[909]=2195;code[318]=2909;    data[86]=-896;
code[843]=3871;code[2032]=652;    data[3122]=-347;
code[3425]=4049;    data[2280]=223;
code[3049]=3542;code[3481]=1281;code[455]=2909;code[308]=125;code[2583]=1088;code[537]=794;code[2165]=3147;    data[978]=-553;
code[1056]=1537;code[2764]=3881;    data[1967]=127;
code[3392]=3470;code[81]=786;code[2276]=2739;code[3169]=256;    data[27]=(int[])null;
code[2412]=3274;    data[922]=215;
code[145]=2311;code[2876]=2685;    data[330]=436;
    data[1438]=885;
code[2339]=310;code[3431]=2394;    data[999]=false;
code[2484]=3147;    data[370]=-387;
code[3502]=17;code[1296]=785;    data[3738]=-159;
code[1445]=2495;code[964]=2280;code[1330]=3147;code[2488]=3670;    data[518]=-201;
code[105]=1133;code[1643]=3147;code[1982]=816;code[76]=1878;code[1953]=794;    data[242]=-636;
    data[3460]=1757590734;
code[712]=538;code[2942]=659;    data[2687]=59;
    data[3053]=59;
code[127]=1785;code[239]=5107;code[2461]=2495;code[3109]=1894;code[790]=3157;    data[2367]=964;
    data[1449]=-852;
    data[773]=-502;
code[3112]=2598;code[1468]=3147;    data[2395]=324;
code[3362]=1356;code[971]=1744;code[2687]=322;code[1386]=3819;    data[990]=-771;
code[706]=2284;code[2997]=27;code[2787]=2830;    data[2814]=-704;
code[3173]=794;    data[68]=-190;
code[2357]=1035;        data[3741]=(int[])arr;
    data[1332]=401;
    data[2588]=842;
    data[3617]=-600;
code[1393]=1413;    data[652]=240;
code[731]=1291;    data[1620]=429;
code[1327]=3741;    data[2985]=-866;
code[2816]=3871;code[2803]=1492;code[371]=2909;code[1309]=3520;code[1994]=3741;    data[1030]=54;
code[2965]=105;    data[1687]=-579;
    data[3828]=380;
code[3479]=1517;code[3102]=2858;    data[3790]=-861;
    data[1686]=-774;
code[2514]=794;code[2507]=2766;code[3172]=27;    data[3032]=638;
code[783]=3506;code[2183]=3741;code[534]=2692;    data[1385]=-341;
code[1471]=3147;code[1389]=2524;    data[3572]=945;
    data[747]=519;
code[1589]=2998;code[2657]=3147;    data[3469]=0;
code[925]=3305;code[2677]=2553;code[3344]=2909;    data[404]=-714;
    data[2492]=103;
code[723]=2050;code[2176]=3243;    data[3852]=-823;
code[531]=2858;code[1998]=180;code[1972]=6046;    data[287]=953;
code[1261]=3544;    data[3830]=322;
    data[737]=-676;
code[2326]=2230;    data[3912]=-258;
code[1622]=6594;    data[816]=false;
code[2929]=2814;code[2124]=3871;code[3156]=1742;code[3275]=1138;    data[3543]=584;
code[1462]=1397;code[732]=3819;    data[2920]=755;
    data[1763]=-991;
    data[1176]=-492;
code[2420]=3907;code[3436]=741;    data[446]=-236;
code[1099]=965;    data[2141]=-55;
    data[3881]=47;
code[1662]=905;code[180]=1685;code[1279]=389;code[485]=3819;code[484]=1234;code[1093]=2835;    data[1183]=-130;
code[1052]=204;code[388]=27;code[509]=2907;code[3119]=3871;code[498]=613;    data[3597]=54;
code[2106]=5326;code[1515]=3147;    data[1920]=-340;
code[2651]=391;code[969]=2916;code[2756]=3741;code[2739]=794;    data[311]=283;
    data[3808]=7;
    data[856]=418;
code[3323]=2858;code[438]=1234;    data[296]=137;
    data[2081]=-13;
    data[392]=296;
    data[1899]=463;
code[2248]=1865;code[294]=2492;code[2399]=9570;    data[1719]=-483;
code[228]=373;code[1618]=999;code[1491]=3426;    data[3080]=-294;
    data[1548]=309;
code[1332]=1882;    data[2230]=59;
code[1089]=204;    data[90]=113;
code[186]=27;code[1385]=3520;code[3476]=3460;code[389]=3594;    data[3170]=-725;
    data[171]=-594;
    data[3974]=909;
code[679]=6594;code[2726]=3834;code[46]=3093;code[1241]=565;code[2256]=1993;code[1851]=3261;code[3155]=2367;    data[3640]=-368;
code[53]=5107;    data[2459]=741;
code[54]=3854;code[3167]=542;    data[785]=326;
code[3288]=2858;code[550]=886;    data[162]=-764;
    data[794]=-736;
    data[2252]=-479;
code[2919]=2183;    data[2737]=-186;
    data[1575]=-5;
code[1473]=1247;code[784]=785;code[2382]=1378;    data[498]=-753;
    data[798]=634;
    data[2468]=971;
code[1750]=794;code[682]=1773;code[204]=2311;code[2632]=1489;code[1499]=1912;    data[2965]=-767;
code[2143]=794;code[978]=2195;    data[2532]=404;
code[2846]=1787;    data[1676]=703;
    data[565]=59;
    data[3494]=536;
    data[665]=-361;
    data[1611]=-846;
code[3157]=3291;code[3380]=3127;    data[2909]=0;
code[2444]=3871;code[2812]=3997;code[778]=794;code[2393]=162;    data[786]=1000;
code[3085]=2913;code[1814]=3871;code[697]=366;    data[2475]=687;
    data[1354]=-762;
code[1372]=3699;code[2515]=3261;code[2107]=794;code[2234]=1550;code[3112]=980;code[471]=1003;code[1630]=794;    data[204]=1088760766;
    data[2686]=-595;
    data[239]=-649;
code[1684]=3075;code[147]=3790;code[2161]=6046;    data[3327]=-42;
    data[247]=-19;
    data[2595]=-702;
code[2293]=380;code[635]=3871;code[965]=484;code[1223]=3147;code[2142]=794;    data[3631]=762;
code[3223]=1164;code[1202]=6594;    data[451]=174;
code[2308]=3147;code[2482]=2267;    data[2296]=330;
code[326]=2002;    data[1267]=122;
code[2837]=1230;code[1880]=3741;    data[2231]=-716;
code[1173]=3670;code[700]=3147;    data[1489]=false;
code[3101]=5326;    data[378]=780;
    data[1657]=2940;
code[718]=2687;code[1641]=71;code[109]=317;code[1150]=2066;code[1855]=3263;code[372]=1742;    data[3651]=-518;
code[3291]=2858;    data[2208]=-880;
    data[3862]=-871;
code[1811]=794;code[331]=640;code[3374]=2284;    data[602]=-619;
code[2501]=147;code[3183]=3945;code[1210]=794;    data[622]=146;
    data[472]=377;
code[1796]=5326;    data[40]=-317;
    data[1865]=67;
code[1838]=3754;    data[322]=-1485;
code[1039]=2896;    data[3642]=-150;
code[1102]=2941;    data[1502]=271;
    data[3756]=18;
code[69]=3865;    data[167]=-155;
    data[3379]=352;
code[2040]=464;code[1034]=3672;    data[562]=595;
code[817]=1584;    data[3688]=-161;
code[2644]=794;code[2418]=3199;code[3039]=9570;    data[3630]=-605;
code[1797]=794;    data[3840]=-867;
    data[484]=59;
    data[2571]=852;
code[1337]=794;code[2538]=3504;code[2519]=162;code[1371]=2905;code[3201]=2179;    data[1641]=-931;
code[2850]=3687;code[1924]=157;code[597]=3147;    data[2066]=758;
    data[1500]=-392;
code[1728]=3263;    data[1785]=(int[])null;
    data[3594]=length;
code[1921]=2284;    data[1849]=-199;
code[2283]=310;code[2908]=2879;code[3394]=3462;    data[3263]=-855;
    data[1448]=963;
    data[3258]=561;
code[541]=1785;code[1698]=1497;    data[879]=156;
    data[3798]=739;
code[2817]=656;code[760]=2949;code[1467]=2130;code[1629]=369;    data[1917]=-707;
code[52]=2311;    data[3433]=888;
code[2543]=3741;code[1976]=3147;code[2915]=2858;    data[2524]=35;
code[2122]=3966;    data[1088]=0;
    data[3613]=58;
code[2969]=3261;code[1240]=1559;code[1149]=3469;    data[1542]=296;
    data[1883]=true;
    data[1291]=false;
code[3033]=2367;code[717]=804;code[1850]=3147;    data[2592]=357;
    data[415]=-201;
    data[536]=-810;
code[2752]=859;code[1254]=1489;code[3116]=2858;    data[3305]=-244;
code[1295]=3147;code[2111]=1913;code[1661]=3843;code[864]=2833;code[791]=8811;    data[124]=137;
    data[3871]=1;
code[2914]=5326;    data[2898]=330;
    data[117]=164;
code[1998]=1973;code[2158]=3535;code[2498]=1231;    data[178]=8;
code[3438]=1790;code[2071]=3798;code[2544]=3741;code[2046]=816;code[398]=738;code[1675]=3819;code[922]=2858;    data[369]=-12;
code[1410]=3640;code[307]=7964;    data[2067]=372;
    data[2195]=false;
code[3265]=2495;code[2425]=1862;code[1919]=3604;code[2858]=794;code[1916]=3043;code[1480]=3147;code[2237]=1894;code[3491]=3961;code[1977]=1195;code[2364]=3330;code[444]=466;code[544]=8811;code[3373]=2953;code[456]=2401;code[121]=1685;code[1743]=3874;    data[2250]=-636;
code[2295]=794;code[241]=11;code[470]=1657;code[1943]=3566;code[2097]=1965;    data[1049]=-277;
code[3068]=2145;
    return (string)InstanceInterpreterVirtualization_QuickSortIterative_class_default_1884(vpc, data, code);

}

        


        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,      " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + "  times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("      {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,       " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private object InstanceInterpreterVirtualization_QuickSortIterative_class_default_1884(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 2495:
                data[code[vpc + (23)]] = (int)data[code[vpc + (26)]] - (int)data[code[vpc + (-17)]];
                vpc += 54;
                break;
            case 4049:
                data[code[vpc + (14)]] = (string)data[code[vpc + (13)]] + (bool)data[code[vpc + (-4)]];
                vpc += 53;
                break;
            case 8811:
                data[code[vpc + (-7)]] = ((int[])data[code[vpc + (-3)]])[(int)data[code[vpc + (-13)]]];
                vpc += 69;
                break;
            case 7686:
                ((int[])data[code[vpc + (20)]])[(int)data[code[vpc + (27)]]] = (int)data[code[vpc + (5)]] + (int)data[code[vpc + (22)]];
                vpc += 61;
                break;
            case 9570:
                data[code[vpc + (-6)]] = (int)data[code[vpc + (16)]];
                vpc += 62;
                break;
            case 5326:
                data[code[vpc + (15)]] = (int)data[code[vpc + (1)]] + (int)data[code[vpc + (18)]];
                vpc += 55;
                break;
            case 6594:
                data[code[vpc + (-4)]] = (int)data[code[vpc + (8)]] < (int)data[code[vpc + (21)]];
                vpc += 53;
                break;
            case 7988:
                data[code[vpc + (-16)]] = ((int[])data[code[vpc + (-6)]])[(int)data[code[vpc + (-20)]]] - (int)data[code[vpc + (22)]];
                vpc += 66;
                break;
            case 7964:
                ((int[])data[code[vpc + (-2)]])[(int)data[code[vpc + (11)]]] = (int) data[code[vpc + (6)]];
                vpc += 65;
                break;
            case 1742:
                ((int[])data[code[vpc + (16)]])[(int)data[code[vpc + (-1)]]] = (int)data[code[vpc + (17)]];
                vpc += 58;
                break;
            case 6387:
                return (string)data[code[vpc + (-2)]];
                vpc += 60;
            case 6046:
                data[code[vpc + (10)]] = ((int[])data[code[vpc + (22)]])[(int)data[code[vpc + (-18)]]] <= (int)data[code[vpc + (19)]] && (int)data[code[vpc + (-19)]] < (int)data[code[vpc + (4)]];
                vpc += 75;
                break;
            case 9964:
                data[code[vpc + (8)]] = (int)data[code[vpc + (25)]] <= (int)data[code[vpc + (4)]];
                vpc += 55;
                break;
            case 9539:
                data[code[vpc + (-5)]] = (int)data[code[vpc + (8)]] == (int)data[code[vpc + (11)]];
                vpc += 65;
                break;
            case 1912:
                data[code[vpc + (-5)]] = (int)data[code[vpc + (-18)]] <= ((int[])data[code[vpc + (13)]])[(int)data[code[vpc + (-19)]]] && (int)data[code[vpc + (23)]] < (int)data[code[vpc + (16)]];
                vpc += 72;
                break;
            case 1685:
                data[code[vpc + (6)]] = (int[])(new int[(int)data[code[vpc + (24)]]]);
                vpc += 59;
                break;
            case 3261:
                ((int[])data[code[vpc + (28)]])[(int)data[code[vpc + (4)]]] = ((int[])data[code[vpc + (29)]])[(int)data[code[vpc + (-1)]]];
                vpc += 70;
                break;
            case 2284:
                vpc += (int)data[code[vpc + (-2)]];
                vpc += 51;
                break;
            default:
                data[code[vpc + (24)]] = (bool)data[code[vpc + (-1)]] ? (int)data[code[vpc + (-14)]] : (int)data[code[vpc + (-15)]];
                vpc += (int)data[code[vpc + (24)]];
                break;
            case 5107:
                data[code[vpc + (-1)]] = data[code[vpc + (28)]];
                vpc += 68;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortIterative_ctrl_flow.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

[assembly: Obfuscation(Exclude = true, Feature = "ctrl flow")]
namespace ConsoleCalculator.Performance.QuickSort
{

    [Obfuscation(Exclude = true, Feature = "ctrl flow")]
    class QuickSortIterative_ctrl_flow
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> data;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            QuickSortIterative_ctrl_flow lt = new QuickSortIterative_ctrl_flow();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
//            //            lt.ForSimple_Check();
//            int ELEMENTS = 350;
//            // Create an unsorted array of string elements
//            string[] testData = GenerateData(ELEMENTS);
//            var int_list = new List<int>();
//            foreach (var r in testData)
//            {
//                var value = Int32.Parse(r);
//                int_list.Add(value);
//            }
//            int[] unsorted_obfuscated = int_list.ToArray();
            

//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_ctrl_flow";
            //result += "     t_method";
            //result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            //result += "     t_method_junk";
            //result += "     t_class_junk";
            result += " " + "\n";

           
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                int[] unsorted_original = data.ToArray();
                Console.WriteLine(i+" ##############");
                Debug.WriteLine(i+" ##############");
                string t_original = Time_Operation("QuickSortIterative_ctrl_flow", i, QuickSort_Iterative, unsorted_original, WARMUP, ITERATIONS);

                result += " " + t_original;

                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortIterative_ctrl_flow_Check";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var unsorted_obfuscated1 = (new List<int>(data));
            var int_list = new List<int>(data);
            
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + ", ");
            }
            Console.WriteLine("\n" + unsorted_original.Length);

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
//            sort(unsorted_original, 0, unsorted_original.Length - 1);
            Output("original_finished");
            QuickSort_Iterative(unsorted_obfuscated, unsorted_obfuscated.Length, -1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        [Obfuscation(Exclude = false, Feature = "ctrl flow")]
        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }


        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]

        [Obfuscation(Exclude = false, Feature = "ctrl flow")]
        string QuickSort_Iterative(int[] arr, int length, int right)
{
    int MAX_LEVELS = 1000;
    int piv;
    int[] beg = new int[MAX_LEVELS];
    int[] end = new int[MAX_LEVELS];
    int i = 0;
    int L;
    int R;

    beg[0] = 0;
    end[0] = length;
    while (i >= 0)
    {
        L = beg[i];
        R = end[i] - 1;
        if (L < R)
        {
            piv = arr[L];
            if (i == MAX_LEVELS - 1)
                return "" + false;
            while (L < R)
            {
                while (arr[R] >= piv && L < R)
                    R--;
                if (L < R)
                    arr[L++] = arr[R];
                while (arr[L] <= piv && L < R)
                    L++;
                if (L < R) arr[R--] = arr[L];
            }
            arr[L] = piv;
            beg[i + 1] = L + 1;
            end[i + 1] = end[i];
            end[i++] = L;
        }
        else
        {
            i--;
        }
    }
    return "" + true;
}

        


        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,      " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("      {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in, " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortIterative_method.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortIterative_method
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> data;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            QuickSortIterative_method lt = new QuickSortIterative_method();
            time_warmup.Clear();
            time_run.Clear();
//
            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
            
        }

       
        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("##################");
        }

        private void Profile()
        {

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

           
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                int[] unsorted_original = data.ToArray();
                Console.WriteLine(i+ " ##############");
                Debug.WriteLine(i + " ##############");
                string t_original = Time_Operation("QuickSortIterative_method", i, QuickSort_Iterative, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSort_Check";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var unsorted_obfuscated1 = (new List<int>(data));
            var int_list = new List<int>(data);
            
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + ", ");
            }
            Console.WriteLine("\n" + unsorted_original.Length);

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
//            sort(unsorted_original, 0, unsorted_original.Length - 1);
            Output("original_finished");
            QuickSort_Iterative(unsorted_obfuscated, unsorted_obfuscated.Length, -1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }



//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
string QuickSort_Iterative(int[] arr, int length, int right)
{
    //Virtualization variables
    int[] code = new int[100641];
    object[] data = new object[4249];
    int vpc = 87;

    code[87396]=-411;code[25262]=170;code[82536]=1191;code[81918]=-417;code[54221]=437;code[33091]=914;
    code[24217]=675;code[41699]=416;code[97519]=475;code[62642]=986;code[3751]=-418;code[34278]=293;
    code[34673]=239;code[73688]=528;code[31587]=309;code[45847]=1425;code[11177]=274;code[91221]=-201;
    code[28286]=1167;code[84548]=1143;code[8817]=523;code[26088]=1490;code[67895]=-271;code[58022]=325;
    code[9700]=-657;code[53192]=1191;code[5772]=-552;code[42821]=588;code[90112]=834;code[12433]=-190;
    code[14546]=-494;code[92531]=-963;code[12007]=-104;code[65882]=826;code[76878]=-764;code[28742]=-745;
    code[75502]=912;code[71161]=69;code[97988]=-139;code[84803]=-869;code[92520]=-495;code[51832]=-559;
    code[100148]=447;code[91857]=1329;code[8498]=-323;code[42698]=368;code[74813]=289;code[71736]=1212;
    code[69447]=-390;code[88242]=-211;code[64120]=1114;code[77103]=-996;code[85715]=66;code[12701]=-270;
    code[47540]=1494;code[66610]=377;code[89679]=-824;code[40753]=1355;code[69193]=857;code[2012]=350;
    code[44885]=807;code[65038]=232;code[67471]=845;code[36099]=-415;code[5262]=1055;code[74245]=823;
    code[47064]=316;code[41829]=-817;code[43883]=283;code[32694]=421;code[45582]=551;code[46216]=-784;
    code[61291]=1183;code[66043]=681;code[11161]=926;code[19878]=1367;code[22554]=-159;code[87548]=1285;
    code[20086]=-318;code[33339]=-717;code[6819]=1229;code[24151]=625;code[26163]=1330;code[8380]=-90;
    code[65934]=-172;code[50955]=-565;code[42067]=128;code[8782]=1063;code[26549]=398;code[88964]=992;
    code[8255]=715;code[12426]=-296;code[62851]=976;code[50866]=-673;code[66100]=253;code[87949]=-593;
    code[18321]=-472;code[50409]=402;code[38292]=1022;code[83206]=691;code[79512]=-271;code[1755]=948;
    code[26582]=-942;code[53257]=931;code[25096]=-890;code[65444]=600;code[39162]=335;code[3160]=-46;
    code[77327]=1395;code[2599]=173;code[42963]=1380;code[71209]=-616;code[46047]=-142;code[99851]=-484;
    code[95654]=315;code[44788]=137;code[73742]=-482;code[706]=975;code[67294]=-140;code[1782]=503;
    code[26302]=831;code[88729]=531;code[85670]=-416;code[77874]=619;code[18118]=-702;code[79780]=55;
    code[78806]=-107;code[25137]=1094;code[58803]=1159;code[32396]=1301;code[3133]=-194;code[82756]=807;
    code[60318]=-512;code[91314]=-546;code[53055]=-397;code[71755]=60;code[94643]=61;code[20940]=735;
    code[7105]=-763;code[30428]=-441;code[57323]=-140;code[2670]=1078;code[73813]=-944;code[67618]=-62;
    code[96365]=-577;code[20719]=1012;code[2224]=-758;code[57372]=1346;code[91619]=-604;code[1314]=639;
    code[32858]=479;code[12143]=1346;code[40883]=-80;code[48502]=-104;code[15022]=388;code[77211]=222;
    code[56507]=-755;code[35340]=717;code[29797]=1477;code[99608]=441;code[52681]=329;code[22572]=-106;
    code[3558]=1270;code[40481]=1108;code[86000]=-327;code[78888]=1280;code[8261]=616;code[90295]=1444;
    code[22508]=-781;code[42772]=-88;code[54420]=-217;code[22757]=4;code[40457]=791;code[24491]=1309;
    code[75058]=1208;code[64675]=1298;code[16978]=90;code[13328]=986;code[37003]=906;code[90922]=245;
    code[97233]=596;code[50711]=1199;code[77661]=1137;code[40966]=1287;code[20226]=-67;code[46612]=-480;
    code[56968]=561;code[3615]=-475;code[30777]=1055;code[96208]=-204;code[66906]=195;code[9826]=1428;
    code[63072]=1161;code[74820]=614;code[51730]=-744;code[61384]=152;code[18547]=1317;code[40146]=1255;
    code[81474]=-135;code[63434]=367;code[31165]=-180;code[72755]=-70;code[42278]=85;code[35550]=360;
    code[40303]=1306;code[49186]=363;code[81189]=462;code[83860]=219;code[54430]=331;code[25482]=1267;
    code[11232]=903;code[40358]=-755;code[76848]=-995;code[2420]=597;code[22722]=-666;code[40301]=1399;
    code[19322]=22;code[901]=-159;code[76022]=813;code[55471]=-519;code[51458]=-502;code[24679]=478;
    code[61786]=-839;code[65841]=498;code[9425]=1277;code[36372]=-308;code[9359]=808;code[43812]=370;
    code[93324]=561;code[61257]=44;code[41287]=785;code[32027]=-333;code[52531]=322;code[35563]=-6;
    code[57954]=241;code[73711]=1038;code[98770]=-849;code[39832]=1280;code[51944]=1023;code[48748]=747;
    code[35020]=61;code[54896]=-214;code[77719]=-692;code[87215]=171;code[97991]=151;code[41179]=-674;
    code[11743]=-667;code[78716]=992;code[88682]=1446;code[7006]=-788;code[71574]=-359;code[2377]=492;
    code[17980]=364;code[29742]=-920;code[32950]=307;code[3237]=-706;code[14113]=1274;code[7035]=1464;
    code[16972]=-992;code[49771]=-4;code[66675]=1211;code[42674]=-712;code[8817]=504;code[70326]=1120;
    code[28041]=496;code[3120]=344;code[74454]=-2;code[99416]=-772;code[40350]=1371;code[13689]=-435;
    code[83326]=1086;code[14228]=126;code[43123]=-272;code[99687]=-483;code[6380]=991;code[63258]=1194;
    code[48697]=677;code[42500]=1066;code[83781]=1271;code[51252]=442;code[85255]=118;code[75839]=822;
    code[49529]=236;code[38048]=851;code[92769]=1446;code[58848]=-450;code[87308]=-330;code[57415]=1070;
    code[74796]=1433;code[69110]=990;code[61503]=229;code[78974]=205;code[97624]=-617;code[5418]=-829;
    code[98352]=-597;code[26063]=231;code[44215]=397;code[38160]=-49;code[8134]=31;code[96452]=1335;
    code[91907]=-376;code[28707]=-788;code[21308]=21;code[1015]=-461;code[10128]=485;code[8392]=1147;
    code[22313]=782;code[97205]=-112;code[66693]=-322;code[76363]=-154;code[44343]=-227;code[76828]=901;
    code[72406]=-770;code[78569]=-229;code[89473]=-526;code[75206]=-174;code[1520]=881;code[88873]=-97;
    code[20781]=749;code[27215]=403;code[14420]=1095;code[97422]=-43;code[7834]=-1;code[27253]=815;
    code[59694]=-941;code[72246]=1023;code[65796]=549;code[49658]=509;code[48958]=311;code[36783]=-702;
    code[63184]=753;code[32869]=1276;code[85233]=881;code[84928]=172;code[83518]=511;code[14985]=1407;
    code[100]=-507;code[19671]=506;code[34354]=-50;code[68707]=-202;code[82668]=-865;code[71992]=1163;
    code[47510]=1344;code[68119]=-12;code[26090]=-302;code[88039]=704;code[33639]=-623;code[93966]=104;
    code[51486]=-857;code[53959]=-188;code[55965]=1004;code[90226]=1471;code[88048]=887;code[81358]=141;
    code[42688]=1227;code[26415]=-735;code[84738]=-885;code[29997]=433;code[99254]=153;code[44142]=1272;
    code[7637]=121;code[21114]=376;code[73449]=167;code[63269]=1125;code[26525]=884;code[9141]=-290;
    code[84955]=-106;code[76827]=-951;code[15878]=817;code[99670]=792;code[13029]=-450;code[97752]=-80;
    code[1686]=921;code[84516]=-280;code[85831]=-100;code[45838]=-875;code[62268]=567;code[25080]=-731;
    code[59575]=-136;code[26037]=19;code[12706]=1395;code[19418]=676;code[80529]=1446;code[26366]=210;
    code[28443]=-304;code[41840]=-352;code[47398]=803;code[78455]=1138;code[48016]=1103;code[53728]=1402;
    code[63133]=-149;code[100359]=1258;code[30020]=-899;code[66955]=-458;code[10908]=639;code[43043]=1029;
    code[47109]=456;code[59467]=-573;code[2757]=-248;code[57169]=-905;code[50990]=-112;code[565]=436;
    code[95047]=-510;code[58297]=1243;code[85299]=-16;code[63460]=875;code[81721]=-257;code[78545]=964;
    code[96727]=-277;code[37448]=898;code[31516]=-888;code[37840]=567;code[85614]=509;code[79639]=1220;
    code[13141]=521;code[83343]=-560;code[27525]=238;code[45742]=-321;code[33695]=56;code[96511]=-745;
    code[46426]=920;code[37182]=786;code[2530]=693;code[100626]=-574;code[80727]=1012;code[21135]=844;
    code[93473]=1021;code[72978]=154;code[98567]=-54;code[72837]=-149;code[40730]=727;code[77158]=-403;
    code[56915]=135;code[47994]=-209;code[84841]=271;code[45389]=345;code[33268]=-326;code[30018]=362;
    code[67982]=653;code[60562]=-567;code[60785]=551;code[8679]=-187;code[40097]=-775;code[24900]=162;
    code[77536]=1482;code[29438]=1390;code[70349]=546;code[70199]=926;code[136]=-675;code[15014]=426;
    code[20169]=708;code[32962]=-266;code[35632]=679;code[40989]=647;code[51345]=-550;code[79122]=-205;
    code[78189]=375;code[74129]=959;code[60851]=102;code[84608]=188;code[20826]=-971;code[54951]=1125;
    code[21740]=237;code[84471]=780;code[57598]=319;code[54723]=362;code[51536]=-923;code[97921]=1301;
    code[29511]=981;code[97767]=816;code[68736]=471;code[96095]=476;code[20794]=1435;code[18034]=-629;
    code[88747]=1283;code[16684]=400;code[29147]=684;code[36618]=-529;code[13828]=193;code[7807]=1147;
    code[83763]=737;code[8716]=1455;code[64033]=-398;code[81120]=864;code[58105]=1040;code[49384]=1030;
    code[47271]=-716;code[79732]=546;code[5737]=1389;code[64769]=-396;code[31770]=726;code[83565]=646;
    code[36438]=1458;code[25719]=1095;code[67139]=961;code[78818]=1039;code[71963]=-720;code[90019]=1469;
    code[50508]=1431;code[96024]=1414;code[16941]=83;code[57496]=-836;code[42559]=-116;code[1024]=1028;code[957]=1028;code[2093]=853;code[522]=9408;code[3158]=2894;code[997]=662;    data[1506]=55;
    data[819]=0;
code[2769]=3850;code[1563]=3213;    data[2610]="" ;
code[1911]=1274;code[2335]=1228;code[3547]=2610;    data[2441]=(int[])null;
    data[154]=-89;
code[382]=3790;code[2104]=9408;    data[682]=false;
        data[3093]=(int[])arr;
code[1372]=3213;code[2059]=443;    data[733]=right;
code[2369]=12;code[2056]=3651;code[3420]=682;    data[3879]=-236;
code[935]=154;code[2958]=1218;code[1327]=3435;code[2730]=3881;code[3283]=3850;code[3400]=2047;    data[558]=55;
code[2233]=3881;code[2188]=1218;code[1070]=2792;code[2565]=3881;code[1126]=3794;code[3117]=7328;code[1456]=3894;code[849]=154;code[2862]=2894;code[456]=6845;code[1081]=2610;code[1450]=3213;code[854]=2291;code[271]=2047;    data[286]=1514;
code[1789]=2035;code[3320]=2894;    data[2894]=252;
code[2812]=3881;code[1371]=1228;code[1277]=3435;code[1348]=3881;code[766]=558;code[2025]=3881;code[2033]=2328;code[3229]=1677;    data[1218]=1;
code[469]=682;    data[662]=240;
code[2946]=2842;code[2419]=12;    data[2744]=55;
code[448]=2894;code[1744]=9408;    data[958]=false;
code[1390]=1228;    data[3435]=false;
code[3325]=2894;code[151]=5416;code[1489]=4083;code[2994]=1239;    data[3894]=-106;
code[1379]=3093;code[1423]=3918;code[2116]=3402;code[2949]=3881;code[1008]=9408;code[3136]=2894;code[2701]=1228;code[3026]=1218;code[3516]=1532;    data[123]=55;
code[341]=2698;    data[3402]=55;
code[2126]=3913;    data[3881]=959;
code[2199]=3093;code[1192]=3850;code[3055]=2441;code[641]=1228;    data[2792]=1225530453;
code[2392]=3645;code[776]=3641;code[1705]=3881;code[936]=6690;code[2220]=1228;code[720]=1964;code[2502]=1228;    data[3721]=-848;
    data[3790]=length;
    data[1964]=false;
code[691]=1732;code[770]=1964;code[3529]=6822;    data[1532]=true;
code[1178]=819;code[1681]=1732;    data[547]=-1514;
code[2599]=3093;code[402]=1677;    data[2314]=false;
code[944]=2894;code[2825]=1677;code[2053]=3881;code[2040]=1228;code[1300]=286;code[2604]=3673;code[1050]=2314;    data[3065]=3007;
code[1886]=1218;code[1333]=1548;code[636]=3662;    data[2155]=55;
code[1248]=1732;code[240]=2291;code[2156]=3881;code[2755]=547;code[1272]=3881;code[277]=5150;code[807]=3881;code[3339]=4083;code[577]=4757;code[3204]=1218;code[1311]=9408;code[3227]=2441;code[511]=3065;code[2516]=4083;code[1840]=3881;    data[3651]=false;
    data[820]=-584;
code[2527]=1218;code[3399]=2894;code[1243]=1228;code[400]=2441;code[344]=2047;    data[1548]=454;
    data[300]=55;
    data[1239]=-981;
code[868]=4083;code[3107]=3416;code[715]=3881;code[3269]=3300;code[3175]=8538;code[1931]=2035;    data[1228]=-194;
    data[3519]=472;
code[2497]=1228;code[2650]=3850;code[3032]=2894;code[1542]=443;code[3407]=6845;code[2735]=3435;code[87]=5150;    data[2695]=0;
    data[853]=236;
code[1625]=3850;code[150]=3024;code[1063]=6822;code[2823]=3093;    data[12]=false;
code[177]=2291;code[2458]=7328;code[3350]=1218;code[2213]=2328;code[2980]=2894;    data[3641]=18;
code[544]=820;    data[2291]=-863;
code[2364]=3881;code[630]=2894;code[3618]=54;    data[2842]=820;
code[1926]=3093;code[337]=2047;code[1446]=1554;code[3536]=54;code[642]=2441;code[1766]=2557;code[2236]=3651;code[1915]=3093;code[2205]=3881;code[2403]=9408;code[3066]=2441;code[116]=2291;code[686]=1228;    data[1825]=-3007;
code[3592]=3794;code[2120]=3651;code[1539]=3881;    data[3645]=303;
    data[1607]=0;
    data[3024]=(int[])null;
code[1500]=1218;code[1557]=6983;code[2284]=3850;code[538]=682;code[1611]=1241;    data[517]=2585;
code[1710]=958;code[1977]=3850;code[2997]=8538;    data[3022]=289;
code[3071]=1239;code[2270]=3879;code[1152]=2792;code[1854]=3881;code[575]=2894;code[1030]=3721;code[2340]=1732;code[1570]=3093;    data[2047]=0;
code[2908]=1218;code[1562]=1228;    data[2557]=154;
code[1756]=2744;code[1434]=9408;code[1963]=2695;code[2876]=2842;code[214]=5416;code[578]=3881;code[3172]=2894;code[809]=4757;code[2805]=443;code[2425]=3519;code[1676]=1228;code[1818]=3881;code[644]=1218;code[389]=2047;    data[3918]=247;
    data[2035]=767;
code[1470]=1228;code[534]=300;code[1323]=2155;    data[3300]=68;
code[331]=3024;    data[1554]=55;
    data[3213]=false;
    data[1028]=false;
code[1581]=1228;code[306]=2894;code[1366]=6983;code[3459]=1825;code[2159]=8538;    data[3913]=-262;
code[557]=3024;code[1020]=1506;code[2706]=1732;    data[1529]=1000;
code[754]=9408;    data[1241]=-247;
code[2636]=1607;code[3209]=3881;code[1799]=7328;    data[3673]=-66;
code[2142]=3881;code[2415]=123;code[2477]=1228;code[2448]=3673;code[81]=1529;code[3216]=3416;code[789]=3093;code[2588]=3093;code[213]=2441;    data[54]=904396971;
    data[3416]=-467;
code[3051]=1274;code[2584]=1274;code[2239]=443;code[1351]=443;code[449]=2047;code[2929]=3024;code[2019]=3093;code[1857]=8538;code[2879]=8538;code[1892]=1228;code[1760]=958;code[743]=517;code[1475]=1228;code[810]=443;code[879]=1218;code[1733]=3022;code[3473]=3850;    data[443]=-127;
code[2933]=6000;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 1274:
    			((int[])data[code[vpc+(4)]])[(int)data[code[vpc+(20)]]] = ((int[])data[code[vpc+(15)]])[(int)data[code[vpc+(-19)]]];
    			vpc+=66;
    			break;
    		case 8538:
    			data[code[vpc+(-3)]]= (int)data[code[vpc+(-17)]]+ (int)data[code[vpc+(29)]];
    			vpc+=54;
    			break;
    		case 5150:
    			data[code[vpc+(29)]]= data[code[vpc+(-6)]];
    			vpc+=64;
    			break;
    		case 7328:
    			data[code[vpc+(-10)]]= (int)data[code[vpc+(19)]];
    			vpc+=58;
    			break;
    		case 4083:
    			data[code[vpc+(-19)]]= (int)data[code[vpc+(-14)]]- (int)data[code[vpc+(11)]];
    			vpc+=68;
    			break;
    		case 2328:
    			data[code[vpc+(23)]]= ((int[])data[code[vpc+(-14)]])[(int)data[code[vpc+(20)]]] <= (int)data[code[vpc+(26)]]&& (int)data[code[vpc+(-8)]]< (int)data[code[vpc+(7)]];
    			vpc+=71;
    			break;
    		case 5416:
    			data[code[vpc+(-1)]]= (int[])(new int[(int)data[code[vpc+(26)]]]);
    			vpc+=63;
    			break;
    		case 2698:
    			((int[])data[code[vpc+(-10)]])[(int)data[code[vpc+(-4)]]] = (int) data[code[vpc+(3)]];
    			vpc+=61;
    			break;
    		case 6845:
    			data[code[vpc+(13)]]= (int)data[code[vpc+(-7)]]<= (int)data[code[vpc+(-8)]];
    			vpc+=66;
    			break;
    		case 6983:
    			data[code[vpc+(6)]]= (int)data[code[vpc+(-15)]]<= ((int[])data[code[vpc+(13)]])[(int)data[code[vpc+(5)]]] && (int)data[code[vpc+(-18)]]< (int)data[code[vpc+(24)]];
    			vpc+=68;
    			break;
    		default:
    			break;
    		case 1677:
    			((int[])data[code[vpc+(-2)]])[(int)data[code[vpc+(-13)]]] = (int)data[code[vpc+(-20)]];
    			vpc+=54;
    			break;
    		case 3850:
    			vpc += (int)data[code[vpc+(-14)]];
    			vpc+=56;
    			break;
    		case 6690:
    			data[code[vpc+(21)]]= (int)data[code[vpc+(8)]]== (int)data[code[vpc+(-1)]];
    			vpc+=72;
    			break;
    		case 6822:
    			data[code[vpc+(7)]]= (string)data[code[vpc+(18)]]+ (bool)data[code[vpc+(-13)]];
    			vpc+=63;
    			break;
    		case 3662:
    			data[code[vpc+(5)]]= ((int[])data[code[vpc+(6)]])[(int)data[code[vpc+(-6)]]] - (int)data[code[vpc+(8)]];
    			vpc+=55;
    			break;
    		case 9408:
    			data[code[vpc+(22)]]=(bool)data[code[vpc+(16)]]?(int)data[code[vpc+(12)]]:(int)data[code[vpc+(-11)]];
    			vpc+=(int)data[code[vpc+(22)]];
    			break;
    		case 6000:
    			((int[])data[code[vpc+(-4)]])[(int)data[code[vpc+(13)]]] = (int)data[code[vpc+(16)]]+ (int)data[code[vpc+(25)]];
    			vpc+=64;
    			break;
    		case 4757:
    			data[code[vpc+(1)]]= ((int[])data[code[vpc+(-20)]])[(int)data[code[vpc+(-2)]]];
    			vpc+=59;
    			break;
    		case 1732:
    			data[code[vpc+(29)]]= (int)data[code[vpc+(24)]]< (int)data[code[vpc+(-5)]];
    			vpc+=63;
    			break;
    		case 3794:
    			return (string)data[code[vpc+(26)]];
    			vpc+=66;
    	}
    }

    return null;
}

        


        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + "  times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("       {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in, " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + "  times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("      {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + "    finished in,   " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortIterative_method_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortIterative_method_default
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> data;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            QuickSortIterative_method_default lt = new QuickSortIterative_method_default();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("##################");
        }

        private void Profile()
        {
//            //            lt.ForSimple_Check();
//            int ELEMENTS = 350;
//            // Create an unsorted array of string elements
//            string[] testData = GenerateData(ELEMENTS);
//            var int_list = new List<int>();
//            foreach (var r in testData)
//            {
//                var value = Int32.Parse(r);
//                int_list.Add(value);
//            }
//            int[] unsorted_obfuscated = int_list.ToArray();
            

//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

           
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                int[] unsorted_original = data.ToArray();
                Console.WriteLine(i + "##############");
                Debug.WriteLine(i + "##############");
                string t_original = Time_Operation("QuickSortIterative_method_default", i, QuickSort_Iterative_method_default, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSort_Check";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var unsorted_obfuscated1 = (new List<int>(data));
            var int_list = new List<int>(data);
            
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + ", ");
            }
            Console.WriteLine("\n" + unsorted_original.Length);

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
//            sort(unsorted_original, 0, unsorted_original.Length - 1);
            Output("original_finished");
            QuickSort_Iterative_method_default(unsorted_obfuscated, unsorted_obfuscated.Length, -1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }



//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
string QuickSort_Iterative_method_default(int[] arr, int length, int right)
{
    //Virtualization variables
    int[] code = new int[100528];
    object[] data = new object[4465];
    int vpc = 90;

    code[84350]=-966;code[79874]=-250;code[40004]=-804;code[4821]=1101;code[87164]=1373;code[3534]=-933;
    code[78034]=-667;code[59633]=637;code[28916]=1159;code[61155]=870;code[26439]=1231;code[84830]=90;
    code[62419]=205;code[18369]=309;code[15225]=1095;code[85937]=687;code[33231]=-704;code[69280]=-484;
    code[80214]=958;code[33603]=373;code[38024]=-538;code[35553]=1275;code[75831]=1479;code[34473]=-257;
    code[65834]=-909;code[45390]=-896;code[34935]=-151;code[66203]=1365;code[17071]=-105;code[68297]=1288;
    code[90071]=310;code[69270]=-929;code[9509]=-100;code[70020]=644;code[44639]=-34;code[86141]=260;
    code[53234]=-853;code[37185]=-805;code[54185]=1334;code[68563]=572;code[14018]=1213;code[87338]=-713;
    code[38879]=1032;code[32924]=1477;code[46225]=856;code[3697]=99;code[10467]=46;code[65681]=1134;
    code[49848]=-188;code[81977]=-15;code[29679]=712;code[85767]=-330;code[18054]=1368;code[51489]=-279;
    code[97496]=451;code[40952]=-410;code[67969]=-875;code[78021]=-974;code[65891]=435;code[64541]=-297;
    code[3277]=764;code[19906]=753;code[35166]=42;code[40211]=-723;code[40775]=289;code[58525]=-465;
    code[11892]=-281;code[33567]=135;code[3249]=501;code[94029]=98;code[30251]=-903;code[2107]=1198;
    code[33717]=1001;code[76765]=-866;code[64595]=607;code[19957]=1304;code[68645]=335;code[36351]=473;
    code[48961]=-621;code[92331]=906;code[55027]=3;code[88757]=134;code[100358]=-517;code[11835]=-30;
    code[72009]=-196;code[98332]=-863;code[64211]=-494;code[98571]=1484;code[68836]=-204;code[36779]=372;
    code[65694]=-135;code[47075]=906;code[31905]=651;code[53407]=460;code[93109]=861;code[97242]=1201;
    code[68563]=-568;code[89667]=1248;code[15689]=417;code[88564]=-645;code[68661]=-62;code[33934]=-198;
    code[66821]=-642;code[28450]=200;code[55636]=-81;code[90952]=-580;code[79018]=-77;code[10953]=-497;
    code[93797]=-700;code[13727]=-156;code[66545]=333;code[46453]=1429;code[35628]=-756;code[37487]=164;
    code[31233]=-798;code[84196]=-706;code[43999]=-441;code[87062]=-305;code[859]=-632;code[9853]=-566;
    code[37939]=-873;code[3101]=395;code[84407]=997;code[9487]=-219;code[6427]=726;code[97162]=-911;
    code[43273]=357;code[48271]=-627;code[91802]=-86;code[97149]=417;code[77472]=1042;code[17038]=181;
    code[53324]=967;code[73452]=405;code[50598]=1076;code[19374]=963;code[2228]=1406;code[96555]=527;
    code[50522]=1259;code[13295]=388;code[339]=-850;code[40402]=549;code[11503]=1004;code[69090]=1236;
    code[74743]=791;code[36689]=607;code[18201]=327;code[40525]=400;code[88624]=395;code[2791]=-869;
    code[6864]=330;code[81356]=-418;code[50059]=-548;code[1379]=169;code[58567]=1173;code[65041]=-977;
    code[23462]=27;code[56655]=775;code[41744]=373;code[35994]=821;code[10025]=1090;code[82313]=967;
    code[46825]=374;code[60771]=227;code[56257]=0;code[73312]=1360;code[88072]=-801;code[48974]=178;
    code[25229]=-579;code[12266]=1333;code[79209]=-452;code[31362]=1185;code[6983]=-111;code[41165]=925;
    code[97256]=731;code[14574]=-170;code[20137]=-253;code[95793]=-420;code[71697]=-944;code[77140]=1370;
    code[57944]=306;code[91286]=-545;code[14076]=757;code[13392]=-616;code[92864]=-770;code[46183]=-384;
    code[42973]=61;code[94579]=1200;code[52687]=1361;code[72116]=-725;code[14106]=1086;code[52639]=1167;
    code[25662]=-8;code[74780]=442;code[12737]=-363;code[76211]=-429;code[40349]=-566;code[35896]=-337;
    code[31313]=-676;code[73804]=-84;code[22358]=-361;code[85080]=1188;code[23455]=1246;code[90938]=939;
    code[36003]=-819;code[71180]=921;code[30666]=642;code[81207]=854;code[100424]=-898;code[93194]=857;
    code[96396]=390;code[2721]=671;code[33588]=-423;code[84958]=-366;code[6783]=688;code[57166]=-14;
    code[21154]=-124;code[89243]=1211;code[99328]=621;code[63689]=-108;code[49515]=1420;code[22012]=-866;
    code[54979]=1473;code[92833]=860;code[36798]=537;code[26775]=-325;code[20364]=1478;code[40989]=665;
    code[22984]=-557;code[54394]=-994;code[5361]=627;code[71200]=706;code[50674]=-217;code[56111]=1385;
    code[77349]=1308;code[75787]=-124;code[40978]=425;code[25160]=1476;code[33890]=1432;code[12252]=-139;
    code[30902]=-748;code[89223]=130;code[41132]=-255;code[19291]=-453;code[94794]=-447;code[65941]=1026;
    code[10788]=577;code[30508]=1103;code[26123]=340;code[55276]=-417;code[43360]=1422;code[97988]=107;
    code[86573]=1289;code[86721]=580;code[74494]=42;code[33092]=-362;code[5596]=-509;code[69869]=1380;
    code[76747]=-361;code[27490]=-486;code[12234]=-153;code[1142]=370;code[26865]=1358;code[24451]=941;
    code[26817]=21;code[73476]=1001;code[42549]=1221;code[91809]=-155;code[12685]=111;code[59429]=233;
    code[43799]=398;code[48058]=315;code[89695]=1;code[75883]=1277;code[94101]=-123;code[7852]=-991;
    code[26425]=-140;code[11219]=-770;code[96281]=66;code[17651]=1294;code[67609]=-785;code[36748]=-170;
    code[68966]=321;code[83664]=-583;code[28468]=-109;code[83055]=-204;code[66821]=950;code[77409]=405;
    code[86553]=213;code[65920]=1167;code[18950]=-170;code[84487]=1289;code[33236]=817;code[54074]=-803;
    code[78105]=1052;code[38250]=748;code[27055]=683;code[82515]=-127;code[19502]=-636;code[84437]=-91;
    code[57118]=469;code[63096]=448;code[52766]=898;code[34103]=206;code[57712]=373;code[23248]=181;
    code[77505]=-229;code[73314]=-150;code[24699]=124;code[168]=1397;code[99571]=882;code[39220]=155;
    code[98140]=-684;code[4984]=1478;code[96431]=51;code[37006]=788;code[64881]=-271;code[30019]=501;
    code[70845]=-348;code[39284]=428;code[38974]=-863;code[50768]=-432;code[59286]=1270;code[93334]=1400;
    code[94902]=201;code[10439]=860;code[14484]=1202;code[37531]=1037;code[19864]=-587;code[60623]=-5;
    code[71353]=-131;code[52628]=-616;code[18231]=290;code[83135]=197;code[1021]=-679;code[63876]=1461;
    code[5941]=76;code[57440]=1338;code[24941]=-594;code[87702]=-830;code[19934]=-777;code[4755]=196;
    code[31830]=560;code[57415]=911;code[92339]=208;code[40528]=348;code[66153]=1481;code[86598]=-901;
    code[53439]=-122;code[4636]=-816;code[8152]=123;code[95520]=1038;code[84970]=-702;code[68862]=784;
    code[31108]=94;code[56993]=-913;code[29459]=337;code[20089]=551;code[30217]=-888;code[84140]=393;
    code[94986]=-844;code[56348]=316;code[72920]=-760;code[32822]=-834;code[57198]=328;code[40590]=1241;
    code[11715]=996;code[99226]=872;code[13976]=-421;code[63666]=-507;code[94393]=1143;code[45749]=201;
    code[92144]=-80;code[24750]=-693;code[79697]=-398;code[74311]=216;code[51712]=221;code[12952]=-954;
    code[89351]=59;code[9060]=872;code[79695]=546;code[14542]=944;code[3438]=675;code[92323]=235;
    code[55072]=127;code[48406]=-828;code[41378]=599;code[62162]=-782;code[61054]=-801;code[61319]=-108;
    code[85443]=-492;code[27511]=-180;code[79654]=1292;code[38431]=569;code[67338]=1421;code[86463]=788;
    code[14240]=1210;code[40670]=-199;code[71659]=693;code[44871]=-385;code[45218]=879;code[57837]=-146;
    code[76335]=676;code[7542]=1186;code[87499]=-897;code[41348]=1022;code[81791]=832;code[90387]=473;
    code[34669]=1041;code[99070]=-708;code[28945]=-274;code[82884]=448;code[59391]=915;code[93202]=318;
    code[23629]=-256;code[37652]=1325;code[63692]=-92;code[91213]=-755;code[63129]=1329;code[57175]=-696;
    code[84654]=268;code[76136]=571;code[56001]=-872;code[90655]=21;code[99028]=1037;code[98069]=1240;
    code[69535]=-177;code[96349]=-603;code[93224]=1489;code[75503]=1483;code[74719]=369;code[64308]=431;
    code[67041]=202;code[17621]=125;code[82995]=1002;code[96652]=32;code[24909]=1158;code[27642]=951;
    code[53606]=-510;code[2246]=348;code[86886]=296;code[54514]=49;code[32407]=195;code[23966]=-240;
    code[40729]=870;code[17164]=580;code[18166]=438;code[38067]=-264;code[87238]=-538;code[96657]=-811;
    code[88055]=129;code[58617]=-540;code[85816]=406;code[65190]=1070;code[5459]=-555;code[62923]=828;
    code[97868]=-472;code[12961]=-438;code[538]=-451;code[25141]=-529;code[24407]=1177;code[4510]=-807;
    code[63361]=-177;code[23359]=680;code[48744]=1451;code[91740]=-130;code[23582]=1366;code[66713]=31;
    code[94026]=-105;code[56924]=899;code[83415]=25;code[25131]=-433;code[12286]=98;code[66199]=1423;
    code[44892]=-616;code[29063]=620;code[93973]=932;code[83747]=-988;code[40904]=264;code[55668]=310;
    code[33183]=1440;code[34507]=-816;code[26683]=-307;code[49928]=-933;code[55074]=791;code[29103]=617;
    code[65695]=225;code[36073]=1081;code[62426]=1044;code[96026]=-523;code[67438]=-343;code[22689]=-173;
    code[69505]=-339;code[41573]=154;code[11397]=646;code[566]=74;code[80871]=-896;code[43207]=1133;
    code[6733]=-560;code[96676]=1111;code[94778]=578;code[42357]=825;    data[3298]=161;
    data[37]=404;
    data[1721]=-344;
    data[1852]=-903;
    data[3079]=674;
code[2878]=529;code[425]=3171;code[3499]=2660;code[528]=3228;code[3069]=1449;code[1257]=529;code[3565]=2766;    data[2216]=988;
    data[2877]=-917;
    data[2715]=266;
    data[2732]=219;
code[2641]=529;code[1642]=3054;code[2072]=1573;code[2987]=3168;code[467]=1841;    data[3995]=779;
code[2081]=529;code[981]=1521;code[1567]=2308;code[3005]=529;    data[3818]=843;
    data[3426]=92;
    data[3922]=-155;
    data[54]=length;
code[1842]=385;code[3019]=3743;code[2285]=529;    data[3793]=52;
code[1060]=3370;    data[3641]=734;
    data[2514]=785;
code[642]=1767;code[432]=2293;code[2140]=2477;    data[413]=60;
code[2930]=9307;    data[313]=false;
    data[290]=199;
code[3129]=3230;code[2121]=1104;code[3227]=88;    data[2846]=-841;
    data[989]=-322;
    data[3686]=-920;
    data[1133]=278;
    data[2587]=1523;
    data[3051]=239;
    data[213]=841;
code[3502]=3228;    data[1153]=731;
code[276]=2739;code[2739]=1953;code[2723]=529;    data[2673]=630;
code[1778]=4377;    data[779]=-507;
code[2726]=1120;code[2259]=7946;    data[927]=3071;
code[1008]=2714;    data[3087]=-153;
code[2338]=3998;code[1695]=2928;code[2431]=2676;code[364]=2426;    data[2077]=60;
code[3329]=2293;    data[3328]=-552;
code[2688]=1936;code[1550]=2928;    data[2611]=837;
    data[1059]=-619;
    data[2383]=375;
code[92]=851;code[2453]=2077;    data[1523]=-629;
    data[3158]=237;
code[3168]=284;code[1092]=366;    data[3184]=816;
    data[3384]=2641;
code[1473]=2158;    data[1671]=-1523;
code[968]=2389;    data[2485]=14;
code[2590]=2928;    data[2165]=837;
code[2932]=3342;    data[3748]=65;
code[919]=2612;    data[3822]=196;
    data[1306]=383;
    data[2867]=-317;
    data[768]=-705;
    data[769]=-342;
code[2507]=8150;code[213]=2293;code[3312]=5360;code[875]=320;code[2120]=1195;    data[284]=829;
code[783]=273;    data[2928]=737;
code[488]=3228;code[2877]=3144;    data[529]=324;
    data[1539]=697;
    data[776]=646;
code[3050]=3102;    data[1195]=-508;
code[1582]=3846;    data[1559]=-4;
    data[977]=600;
code[3437]=417;code[2030]=1411;    data[3647]=781;
    data[3342]=-567;
code[2182]=2923;    data[45]=865;
code[2860]=1686;code[3526]=3809;    data[3318]=-596;
code[1036]=4377;code[2627]=2629;    data[1310]=102;
    data[1965]=-813;
    data[3572]=680;
code[2077]=3918;code[2488]=2928;code[1538]=679;    data[2193]=-627;
code[3689]=2955;code[3475]=3740;    data[2392]=-790;
    data[2208]=779;
code[3015]=3342;code[878]=529;code[1614]=2928;code[2057]=3166;    data[2788]=-359;
code[137]=3320;code[796]=114;    data[2969]=-749;
code[2832]=3891;    data[3990]=868;
code[2957]=3525;code[2251]=2084;    data[900]=494;
    data[3498]=567;
code[219]=9291;code[2444]=2324;code[707]=2928;code[3013]=2078;    data[2583]=-988;
code[77]=3641;code[1042]=133;    data[2196]=-816;
code[2134]=4377;    data[2938]=-174;
code[1653]=1988;    data[1972]=-416;
    data[2511]=319;
code[531]=9293;    data[192]=-131;
    data[604]=-808;
code[3191]=2562;code[436]=3246;    data[149]=438;
code[412]=54;    data[3503]=837;
    data[2018]=-285;
code[662]=1982;code[1405]=9761;code[770]=2362;    data[3626]=-313;
    data[1457]=418;
    data[273]=677;
code[1099]=2773;    data[2225]=655;
    data[2297]=-722;
code[2889]=1308;    data[114]=60;
code[2033]=2262;code[2614]=1573;    data[1474]=-533;
    data[1422]=-963;
code[2911]=3961;code[2380]=325;code[226]=2109;code[730]=2868;code[1605]=742;    data[1531]=872;
    data[3497]=-668;
code[1407]=3300;code[2265]=529;code[1838]=8150;    data[3886]=-416;
code[1795]=2500;code[2924]=2417;code[1902]=1767;    data[1967]=945;
    data[3842]=488;
code[3445]=284;code[210]=1589;code[1123]=3093;    data[2414]=-728;
    data[2309]=-700;
code[2865]=265;code[1608]=42;    data[3228]=false;
code[864]=368;code[1718]=414;    data[2112]=-546;
code[515]=927;    data[2160]=670;
code[2495]=2090;code[1784]=413;code[747]=1472;    data[1006]=-529;
    data[178]=650;
code[415]=5360;code[1273]=1953;code[1368]=3388;code[3294]=1195;code[2511]=3626;code[1280]=3014;code[2210]=529;code[934]=1575;    data[1416]=-37;
code[273]=284;code[2196]=529;code[2934]=1767;    data[3856]=-658;
    data[2324]=false;
code[2729]=3899;    data[434]=-476;
code[2618]=3626;    data[936]=204;
code[936]=1767;code[1645]=2012;code[1954]=385;code[3389]=3235;code[3067]=9307;code[3275]=2353;code[2675]=3519;    data[57]=-223;
code[522]=2812;code[1158]=4272;code[2130]=1025;code[2158]=240;    data[2438]=-581;
code[3414]=505;code[1329]=2587;    data[1821]=765;
code[776]=3982;code[3380]=1958;    data[1017]=-995;
    data[133]=60;
code[718]=1953;code[3454]=284;    data[2558]=839;
code[1979]=2885;code[2441]=2029;code[3496]=442;code[1020]=3158;code[2194]=9307;    data[318]=143;
code[3388]=2504;    data[1459]=65;
code[3609]=2067;    data[3316]=210;
    data[3120]=-993;
code[146]=2426;code[645]=2293;code[2434]=3796;    data[3370]=-889;
code[469]=284;code[2957]=2117;code[2682]=8099;code[3618]=335;code[2082]=284;code[685]=2353;code[152]=9291;code[3558]=2838;code[1587]=9761;    data[3146]=840;
code[1690]=529;code[1093]=678;code[3251]=1767;    data[2957]=-414;
    data[2773]="" ;
    data[2671]=933;
    data[1091]=-166;
    data[2426]=(int[])null;
code[3431]=2949;code[549]=2452;code[3593]=101;    data[983]=706;
    data[1035]=-780;
code[1769]=729;code[809]=694;code[1357]=2052;code[287]=2926;    data[1581]=-600;
code[369]=2170;    data[1708]=815;
    data[445]=-993;
code[3322]=2562;    data[3191]=false;
code[909]=1141;code[363]=635;code[2284]=812;code[849]=1573;code[1770]=2636;code[1914]=529;code[1764]=695;code[2584]=435;code[3146]=284;code[1999]=3348;    data[2610]=right;
code[1253]=2878;code[3119]=2293;code[939]=2056;code[3512]=3171;code[2830]=1554;    data[2676]=292;
    data[1767]=1;
    data[1896]=-351;
code[3595]=1122;    data[2293]=(int[])null;
code[2256]=1573;code[2697]=2197;code[795]=3194;code[3491]=1496;code[772]=2806;    data[3240]=-673;
    data[1850]=-852;
    data[285]=518;
        data[1573]=(int[])arr;
code[3435]=999;    data[895]=-3071;
code[2101]=529;code[1542]=1767;code[1028]=3225;    data[3708]=996;
    data[246]=584;
code[1576]=1573;code[2567]=2949;code[512]=2523;code[2635]=1953;    data[3438]=-117;
    data[3437]=607;
code[1898]=9307;code[780]=2729;    data[3722]=818;
code[1849]=1992;code[2318]=8099;code[3053]=2060;code[1451]=3051;code[2654]=117;code[1342]=3899;code[2447]=4377;code[1612]=2928;    data[1038]=-614;
    data[253]=-107;
code[859]=566;    data[2365]=934;
    data[1321]=-46;
code[1545]=904;code[597]=529;code[3446]=1767;    data[1813]=-762;
code[2055]=265;code[3383]=2582;    data[3896]=851;
code[2364]=2928;code[2097]=2928;    data[2375]=707;
    data[385]=146;
code[1696]=3111;code[1772]=1554;code[665]=2928;code[2710]=1576;    data[2908]=60;
code[2504]=72;code[1096]=1329;code[3672]=2067;    data[3668]=780;
code[1231]=2874;code[2333]=1468;code[375]=3171;code[300]=3171;    data[2759]=-83;
    data[712]=340;
code[1711]=2845;    data[1781]=-808;
code[2387]=469;    data[3952]=263;
code[1222]=1306;code[2118]=3188;    data[3439]=-84;
code[1541]=2928;code[702]=529;code[286]=3307;    data[1764]=-166;
code[1526]=3070;code[3120]=2293;code[2123]=3004;code[620]=3613;code[3565]=2645;    data[1417]=873;
    data[2154]=-321;
code[1094]=2059;code[377]=3171;code[1166]=13;code[2803]=2243;    data[2874]=0;
code[947]=657;code[1900]=529;    data[2536]=312;
code[1263]=3899;code[2359]=529;code[348]=7440;code[2646]=1121;    data[1217]=164;
code[2811]=8099;    data[3363]=-219;
code[944]=3641;    data[3171]=0;
code[1819]=529;code[3132]=2629;code[2609]=2856;code[747]=1694;    data[3912]=-618;
code[3424]=3125;code[1687]=3550;code[2615]=1573;    data[3965]=164;
code[1734]=2428;    data[1512]=-110;
    data[976]=-55;
code[1464]=3846;    data[1458]=916;
code[1671]=2724;    data[2838]=-570;
    data[2845]=-18;
code[2476]=1977;    data[1307]=536;
code[2068]=637;code[298]=818;    data[3130]=-846;
code[1430]=2928;code[3417]=1858;code[1723]=3963;code[3486]=2926;    data[2306]=-604;
    data[230]=891;
    data[2620]=-113;
    data[2551]=-685;
code[572]=1041;    data[1987]=-300;
    data[2925]=-350;
    data[1117]=297;
code[3263]=284;code[2508]=1844;    data[72]=-25;
code[851]=2574;code[2403]=1827;    data[102]=385;
    data[526]=413;
    data[3399]=-105;
code[1216]=8099;code[335]=72;code[136]=3641;code[787]=313;code[2535]=2624;    data[3507]=844;
    data[1492]=580;
    data[1815]=false;
code[2401]=3179;code[2471]=2463;    data[2233]=449;
code[774]=3384;code[1285]=56;code[2866]=3850;    data[1449]=491;
code[2149]=382;code[991]=0;code[3249]=284;    data[320]=-513;
code[3247]=9307;    data[1247]=210;
code[3483]=284;code[1599]=529;    data[1688]=435;
code[517]=1417;    data[3820]=-474;
code[1963]=2629;code[910]=3825;code[3187]=8150;code[104]=1667;code[966]=666;    data[3414]=122;
    data[1888]=-424;
code[1160]=1329;    data[2262]=0;
code[2819]=2201;code[596]=2792;code[1762]=1117;code[1417]=529;code[1267]=2445;    data[3097]=-445;
code[1033]=3191;    data[1614]=-571;
code[477]=1496;    data[3924]=-875;
code[835]=3424;code[1775]=3111;code[850]=2758;    data[3235]=60;
    data[2339]=-440;
code[2131]=2084;code[1089]=1815;code[3197]=499;code[1924]=3668;code[1432]=2928;code[175]=1086;code[1899]=2314;code[1527]=2949;code[3090]=1436;code[203]=3641;code[3093]=1086;code[245]=1706;code[3374]=8099;    data[2574]=-557;
code[3123]=1449;    data[2067]=1476677975;
    data[1473]=-228;
code[790]=4377;code[3602]=1329;code[931]=3569;code[3449]=3988;code[921]=2949;code[1411]=265;    data[2613]=-950;
code[1467]=4377;    data[2396]=744;
code[590]=2426;code[856]=265;code[3664]=4272;code[2581]=2928;    data[260]=-482;
code[982]=3298;    data[3455]=398;
code[2819]=2224;    data[2084]=false;
code[3560]=895;code[2868]=5360;code[1055]=5;code[1103]=13;code[1511]=1352;    data[3828]=-239;
    data[3465]=892;
    data[3846]=false;
    data[3155]=431;
    data[982]=787;
code[134]=1982;code[2433]=1987;    data[2868]=-531;
    data[2698]=-671;
code[3309]=529;    data[1806]=106;
    data[981]=-162;
    data[847]=833;
code[1331]=3793;code[617]=3515;code[3243]=3216;code[145]=3671;code[1154]=598;    data[3292]=-5;
code[1951]=1573;code[2252]=1228;code[2728]=2928;code[2203]=422;code[1400]=3846;    data[1122]=true;
code[1086]=3404;code[3362]=1277;code[2287]=1998;    data[695]=281;
code[2343]=3582;code[2018]=8099;code[1706]=1953;    data[2145]=300;
    data[3425]=-623;
code[328]=2099;code[1010]=3626;code[1950]=1573;    data[1676]=-65;
    data[2683]=680;
code[2067]=2084;    data[3540]=-838;
code[240]=464;code[90]=3307;code[2365]=2324;    data[2280]=701;
code[2030]=2217;    data[3799]=-501;
    data[3915]=34;
code[2550]=439;    data[2477]=60;
code[2654]=39;    data[1687]=-807;
    data[395]=-431;
    data[3878]=-878;
    data[24]=705;
    data[2261]=169;
code[519]=945;    data[1847]=-870;
code[591]=2758;    data[265]=-229;
code[1453]=1133;code[1469]=64;code[1022]=2637;code[1176]=1677;code[162]=179;code[537]=2908;code[3545]=8099;code[1895]=2984;    data[2169]=110;
    data[1667]=1000;
    data[1589]=595;
    data[557]=-996;
    data[2637]=237;
    data[3928]=-701;
code[1394]=1573;code[2890]=350;code[1593]=265;code[2984]=1767;code[1977]=2928;code[2885]=1573;    data[2819]=-853;
code[2075]=7946;code[2375]=1953;code[1262]=2928;code[656]=421;    data[742]=-640;
    data[3899]=false;
    data[2562]=612;
    data[948]=985;
    data[2158]=60;
code[961]=284;code[2281]=2928;code[1182]=377;    data[2924]=-850;
code[3082]=1558;code[3076]=2398;    data[1617]=525;
code[1649]=8099;code[792]=1453;code[1062]=582;    data[27]=154;
code[2198]=1767;    data[1941]=345;
    data[2110]=-346;
code[2613]=2000;    data[3111]=false;
code[935]=3298;code[1104]=3007;    data[13]=1592283560;
    data[3759]=-450;
    data[1468]=-241;
code[2582]=1767;code[3137]=656;    data[2197]=0;
code[655]=284;code[3006]=2426;code[2871]=3587;code[1345]=4377;code[2239]=265;code[3137]=3341;code[729]=1705;code[1001]=3191;    data[3632]=381;
    data[3575]=-513;
code[3605]=2773;code[498]=3171;code[347]=2480;    data[3982]=433;
code[1664]=3828;code[1855]=1576;code[3083]=284;    data[3867]=60;
code[3377]=700;code[1351]=3867;code[3587]=75;code[2946]=284;    data[3188]=241;
code[619]=284;code[284]=3026;    data[3330]=212;
code[2995]=5340;code[3430]=3440;code[2670]=2664;    data[568]=-922;
code[2309]=961;    data[1638]=-567;
code[708]=313;    data[2013]=-847;
code[2826]=1671;code[1667]=3630;code[1572]=3426;    data[1386]=-819;
code[3071]=1767;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 2758:
    			data[code[vpc+(6)]]= ((int[])data[code[vpc+(-1)]])[(int)data[code[vpc+(28)]]];
    			vpc+=71;
    			break;
    		case 2949:
    			data[code[vpc+(14)]]= (int)data[code[vpc+(23)]]- (int)data[code[vpc+(15)]];
    			vpc+=60;
    			break;
    		case 4272:
    			return (string)data[code[vpc+(8)]];
    			vpc+=58;
    		default:
    			data[code[vpc+(-14)]]=(bool)data[code[vpc+(-3)]]?(int)data[code[vpc+(6)]]:(int)data[code[vpc+(-16)]];
    			vpc+=(int)data[code[vpc+(-14)]];
    			break;
    		case 7946:
    			data[code[vpc+(-8)]]= ((int[])data[code[vpc+(-3)]])[(int)data[code[vpc+(26)]]] <= (int)data[code[vpc+(-20)]]&& (int)data[code[vpc+(6)]]< (int)data[code[vpc+(22)]];
    			vpc+=59;
    			break;
    		case 1982:
    			data[code[vpc+(3)]]= ((int[])data[code[vpc+(-17)]])[(int)data[code[vpc+(-7)]]] - (int)data[code[vpc+(-20)]];
    			vpc+=56;
    			break;
    		case 9291:
    			data[code[vpc+(-6)]]= (int[])(new int[(int)data[code[vpc+(-16)]]]);
    			vpc+=67;
    			break;
    		case 7440:
    			((int[])data[code[vpc+(16)]])[(int)data[code[vpc+(27)]]] = (int)data[code[vpc+(29)]];
    			vpc+=67;
    			break;
    		case 1953:
    			data[code[vpc+(-10)]]= (int)data[code[vpc+(-16)]]< (int)data[code[vpc+(-11)]];
    			vpc+=72;
    			break;
    		case 9761:
    			data[code[vpc+(-5)]]= (int)data[code[vpc+(6)]]<= ((int[])data[code[vpc+(-11)]])[(int)data[code[vpc+(25)]]] && (int)data[code[vpc+(12)]]< (int)data[code[vpc+(27)]];
    			vpc+=62;
    			break;
    		case 1496:
    			data[code[vpc+(11)]]= (int)data[code[vpc+(21)]]<= (int)data[code[vpc+(-8)]];
    			vpc+=54;
    			break;
    		case 1521:
    			data[code[vpc+(20)]]= (int)data[code[vpc+(-20)]]== (int)data[code[vpc+(1)]];
    			vpc+=55;
    			break;
    		case 5360:
    			((int[])data[code[vpc+(17)]])[(int)data[code[vpc+(10)]]] = (int)data[code[vpc+(-3)]];
    			vpc+=62;
    			break;
    		case 8150:
    			data[code[vpc+(4)]]= (int)data[code[vpc+(-19)]];
    			vpc+=60;
    			break;
    		case 3307:
    			data[code[vpc+(-13)]]= data[code[vpc+(14)]];
    			vpc+=62;
    			break;
    		case 1329:
    			data[code[vpc+(7)]]= (string)data[code[vpc+(3)]]+ (bool)data[code[vpc+(-7)]];
    			vpc+=62;
    			break;
    		case 9307:
    			data[code[vpc+(2)]]= (int)data[code[vpc+(16)]]+ (int)data[code[vpc+(4)]];
    			vpc+=65;
    			break;
    		case 5340:
    			((int[])data[code[vpc+(11)]])[(int)data[code[vpc+(20)]]] = (int)data[code[vpc+(10)]]+ (int)data[code[vpc+(-11)]];
    			vpc+=72;
    			break;
    		case 8099:
    			vpc += (int)data[code[vpc+(15)]];
    			vpc+=57;
    			break;
    		case 2629:
    			((int[])data[code[vpc+(-13)]])[(int)data[code[vpc+(-9)]]] = ((int[])data[code[vpc+(-12)]])[(int)data[code[vpc+(14)]]];
    			vpc+=55;
    			break;
    	}
    }

    return null;
}

        


        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + "  times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,      " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + "  times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,   " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortIterative_method_modified.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortIterative_method_modified
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> data;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();

        public static void RunLoopTests()
        {
            QuickSortIterative_method_modified lt = new QuickSortIterative_method_modified();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
            
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("##################");
        }

        private void Profile()
        {
//            //            lt.ForSimple_Check();
//            int ELEMENTS = 350;
//            // Create an unsorted array of string elements
//            string[] testData = GenerateData(ELEMENTS);
//            var int_list = new List<int>();
//            foreach (var r in testData)
//            {
//                var value = Int32.Parse(r);
//                int_list.Add(value);
//            }
//            int[] unsorted_obfuscated = int_list.ToArray();
            

//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";
            init_code();

            //result += "t_original";
            //result += "     t_method";
            //result += "     t_class";
            //            result += " t_method_default";
            result += " t_method_modified";
            //            result += " t_class_default";
            //result += "     t_method_junk";
            //result += "     t_class_junk";
            result += " " + "\n";

           
            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                int[] unsorted_original = data.ToArray();
                Console.WriteLine(i + "##############");
                Debug.WriteLine(i + "##############");
                string t_original = Time_Operation("QuickSortIterative_method_modified", i, QuickSort_Iterative_method_default, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSort_Check";
            Program.Start_Check(testName);
            bool condition = true;


            // Create an unsorted array of string elements
            //            int[] testData = GenerateDataStatic();
            int[] data = GenerateDataInt(360);
            var unsorted_obfuscated1 = (new List<int>(data));
            var int_list = new List<int>(data);
            
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + ", ");
            }
            Console.WriteLine("\n" + unsorted_original.Length);

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
//            sort(unsorted_original, 0, unsorted_original.Length - 1);
            Output("original_finished");
            QuickSort_Iterative_method_default(unsorted_obfuscated, unsorted_obfuscated.Length, -1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }


        private int[] GenerateDataStatic()
        {
            int[] arr = {4, 3, 5, 2, 1, 3, 2, 3, 89201, 45932, 56552, 58302, 3768, 99875, 26543, 44898, 93328, 35746, 23265, 86042, 69630, 45843, 64590, 69515, 58230, 99227, 87729, 13089, 33472, 30304, 79972,23975, 45058, 35066, 81533, 81112, 79368, 17658, 79228, 30577, 67501, 45700, 94125, 30606, 21605, 54404, 96450, 29349, 94577, 81012, 87055, 50237, 86788, 6366,69903, 64801, 13172, 53670, 62243, 43631, 71885, 86104, 1582, 58896, 65960, 32577, 13243, 68702, 18341, 45430, 65530, 75669, 56518, 92687, 18541, 23930, 51718,33983, 47910, 3826, 2777, 58379, 18511, 52459, 43249, 29735, 37186, 38692, 65163, 16732, 67940, 25698, 55414, 35596, 58691, 
    75028, 47371, 69363, 36976, 31863, 36015,  23};

            return arr;
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }


        private int[] code;
        private void init_code()
        {
            code = new int[100528];
            code[84350] = -966; code[79874] = -250; code[40004] = -804; code[4821] = 1101; code[87164] = 1373; code[3534] = -933;
            code[78034] = -667; code[59633] = 637; code[28916] = 1159; code[61155] = 870; code[26439] = 1231; code[84830] = 90;
            code[62419] = 205; code[18369] = 309; code[15225] = 1095; code[85937] = 687; code[33231] = -704; code[69280] = -484;
            code[80214] = 958; code[33603] = 373; code[38024] = -538; code[35553] = 1275; code[75831] = 1479; code[34473] = -257;
            code[65834] = -909; code[45390] = -896; code[34935] = -151; code[66203] = 1365; code[17071] = -105; code[68297] = 1288;
            code[90071] = 310; code[69270] = -929; code[9509] = -100; code[70020] = 644; code[44639] = -34; code[86141] = 260;
            code[53234] = -853; code[37185] = -805; code[54185] = 1334; code[68563] = 572; code[14018] = 1213; code[87338] = -713;
            code[38879] = 1032; code[32924] = 1477; code[46225] = 856; code[3697] = 99; code[10467] = 46; code[65681] = 1134;
            code[49848] = -188; code[81977] = -15; code[29679] = 712; code[85767] = -330; code[18054] = 1368; code[51489] = -279;
            code[97496] = 451; code[40952] = -410; code[67969] = -875; code[78021] = -974; code[65891] = 435; code[64541] = -297;
            code[3277] = 764; code[19906] = 753; code[35166] = 42; code[40211] = -723; code[40775] = 289; code[58525] = -465;
            code[11892] = -281; code[33567] = 135; code[3249] = 501; code[94029] = 98; code[30251] = -903; code[2107] = 1198;
            code[33717] = 1001; code[76765] = -866; code[64595] = 607; code[19957] = 1304; code[68645] = 335; code[36351] = 473;
            code[48961] = -621; code[92331] = 906; code[55027] = 3; code[88757] = 134; code[100358] = -517; code[11835] = -30;
            code[72009] = -196; code[98332] = -863; code[64211] = -494; code[98571] = 1484; code[68836] = -204; code[36779] = 372;
            code[65694] = -135; code[47075] = 906; code[31905] = 651; code[53407] = 460; code[93109] = 861; code[97242] = 1201;
            code[68563] = -568; code[89667] = 1248; code[15689] = 417; code[88564] = -645; code[68661] = -62; code[33934] = -198;
            code[66821] = -642; code[28450] = 200; code[55636] = -81; code[90952] = -580; code[79018] = -77; code[10953] = -497;
            code[93797] = -700; code[13727] = -156; code[66545] = 333; code[46453] = 1429; code[35628] = -756; code[37487] = 164;
            code[31233] = -798; code[84196] = -706; code[43999] = -441; code[87062] = -305; code[859] = -632; code[9853] = -566;
            code[37939] = -873; code[3101] = 395; code[84407] = 997; code[9487] = -219; code[6427] = 726; code[97162] = -911;
            code[43273] = 357; code[48271] = -627; code[91802] = -86; code[97149] = 417; code[77472] = 1042; code[17038] = 181;
            code[53324] = 967; code[73452] = 405; code[50598] = 1076; code[19374] = 963; code[2228] = 1406; code[96555] = 527;
            code[50522] = 1259; code[13295] = 388; code[339] = -850; code[40402] = 549; code[11503] = 1004; code[69090] = 1236;
            code[74743] = 791; code[36689] = 607; code[18201] = 327; code[40525] = 400; code[88624] = 395; code[2791] = -869;
            code[6864] = 330; code[81356] = -418; code[50059] = -548; code[1379] = 169; code[58567] = 1173; code[65041] = -977;
            code[23462] = 27; code[56655] = 775; code[41744] = 373; code[35994] = 821; code[10025] = 1090; code[82313] = 967;
            code[46825] = 374; code[60771] = 227; code[56257] = 0; code[73312] = 1360; code[88072] = -801; code[48974] = 178;

            code[25229] = -579; code[12266] = 1333; code[79209] = -452; code[31362] = 1185; code[6983] = -111; code[41165] = 925;
            code[97256] = 731; code[14574] = -170; code[20137] = -253; code[95793] = -420; code[71697] = -944; code[77140] = 1370;
            code[57944] = 306; code[91286] = -545; code[14076] = 757; code[13392] = -616; code[92864] = -770; code[46183] = -384;
            code[42973] = 61; code[94579] = 1200; code[52687] = 1361; code[72116] = -725; code[14106] = 1086; code[52639] = 1167;
            code[25662] = -8; code[74780] = 442; code[12737] = -363; code[76211] = -429; code[40349] = -566; code[35896] = -337;
            code[31313] = -676; code[73804] = -84; code[22358] = -361; code[85080] = 1188; code[23455] = 1246; code[90938] = 939;
            code[36003] = -819; code[71180] = 921; code[30666] = 642; code[81207] = 854; code[100424] = -898; code[93194] = 857;
            code[96396] = 390; code[2721] = 671; code[33588] = -423; code[84958] = -366; code[6783] = 688; code[57166] = -14;
            code[21154] = -124; code[89243] = 1211; code[99328] = 621; code[63689] = -108; code[49515] = 1420; code[22012] = -866;
            code[54979] = 1473; code[92833] = 860; code[36798] = 537; code[26775] = -325; code[20364] = 1478; code[40989] = 665;
            code[22984] = -557; code[54394] = -994; code[5361] = 627; code[71200] = 706; code[50674] = -217; code[56111] = 1385;
            code[77349] = 1308; code[75787] = -124; code[40978] = 425; code[25160] = 1476; code[33890] = 1432; code[12252] = -139;
            code[30902] = -748; code[89223] = 130; code[41132] = -255; code[19291] = -453; code[94794] = -447; code[65941] = 1026;
            code[10788] = 577; code[30508] = 1103; code[26123] = 340; code[55276] = -417; code[43360] = 1422; code[97988] = 107;
            code[86573] = 1289; code[86721] = 580; code[74494] = 42; code[33092] = -362; code[5596] = -509; code[69869] = 1380;
            code[76747] = -361; code[27490] = -486; code[12234] = -153; code[1142] = 370; code[26865] = 1358; code[24451] = 941;
            code[26817] = 21; code[73476] = 1001; code[42549] = 1221; code[91809] = -155; code[12685] = 111; code[59429] = 233;
            code[43799] = 398; code[48058] = 315; code[89695] = 1; code[75883] = 1277; code[94101] = -123; code[7852] = -991;
            code[26425] = -140; code[11219] = -770; code[96281] = 66; code[17651] = 1294; code[67609] = -785; code[36748] = -170;
            code[68966] = 321; code[83664] = -583; code[28468] = -109; code[83055] = -204; code[66821] = 950; code[77409] = 405;
            code[86553] = 213; code[65920] = 1167; code[18950] = -170; code[84487] = 1289; code[33236] = 817; code[54074] = -803;
            code[78105] = 1052; code[38250] = 748; code[27055] = 683; code[82515] = -127; code[19502] = -636; code[84437] = -91;
            code[57118] = 469; code[63096] = 448; code[52766] = 898; code[34103] = 206; code[57712] = 373; code[23248] = 181;
            code[77505] = -229; code[73314] = -150; code[24699] = 124; code[168] = 1397; code[99571] = 882; code[39220] = 155;
            code[98140] = -684; code[4984] = 1478; code[96431] = 51; code[37006] = 788; code[64881] = -271; code[30019] = 501;
            code[70845] = -348; code[39284] = 428; code[38974] = -863; code[50768] = -432; code[59286] = 1270; code[93334] = 1400;
            code[94902] = 201; code[10439] = 860; code[14484] = 1202; code[37531] = 1037; code[19864] = -587; code[60623] = -5;
            code[71353] = -131; code[52628] = -616; code[18231] = 290; code[83135] = 197; code[1021] = -679; code[63876] = 1461;
            code[5941] = 76; code[57440] = 1338; code[24941] = -594; code[87702] = -830; code[19934] = -777; code[4755] = 196;
            code[31830] = 560; code[57415] = 911; code[92339] = 208; code[40528] = 348; code[66153] = 1481; code[86598] = -901;
            code[53439] = -122; code[4636] = -816; code[8152] = 123; code[95520] = 1038; code[84970] = -702; code[68862] = 784;
            code[31108] = 94; code[56993] = -913; code[29459] = 337; code[20089] = 551; code[30217] = -888; code[84140] = 393;
            code[94986] = -844; code[56348] = 316; code[72920] = -760; code[32822] = -834; code[57198] = 328; code[40590] = 1241;
            code[11715] = 996; code[99226] = 872; code[13976] = -421; code[63666] = -507; code[94393] = 1143; code[45749] = 201;
            code[92144] = -80; code[24750] = -693; code[79697] = -398; code[74311] = 216; code[51712] = 221; code[12952] = -954;
            code[89351] = 59; code[9060] = 872; code[79695] = 546; code[14542] = 944; code[3438] = 675; code[92323] = 235;
            code[55072] = 127; code[48406] = -828; code[41378] = 599; code[62162] = -782; code[61054] = -801; code[61319] = -108;
            code[85443] = -492; code[27511] = -180; code[79654] = 1292; code[38431] = 569; code[67338] = 1421; code[86463] = 788;
            code[14240] = 1210; code[40670] = -199; code[71659] = 693; code[44871] = -385; code[45218] = 879; code[57837] = -146;
            code[76335] = 676; code[7542] = 1186; code[87499] = -897; code[41348] = 1022; code[81791] = 832; code[90387] = 473;
            code[34669] = 1041; code[99070] = -708; code[28945] = -274; code[82884] = 448; code[59391] = 915; code[93202] = 318;
            code[23629] = -256; code[37652] = 1325; code[63692] = -92; code[91213] = -755; code[63129] = 1329; code[57175] = -696;
            code[84654] = 268; code[76136] = 571; code[56001] = -872; code[90655] = 21; code[99028] = 1037; code[98069] = 1240;
            code[69535] = -177; code[96349] = -603; code[93224] = 1489; code[75503] = 1483; code[74719] = 369; code[64308] = 431;
            code[67041] = 202; code[17621] = 125; code[82995] = 1002; code[96652] = 32; code[24909] = 1158; code[27642] = 951;
            code[53606] = -510; code[2246] = 348; code[86886] = 296; code[54514] = 49; code[32407] = 195; code[23966] = -240;
            code[40729] = 870; code[17164] = 580; code[18166] = 438; code[38067] = -264; code[87238] = -538; code[96657] = -811;
            code[88055] = 129; code[58617] = -540; code[85816] = 406; code[65190] = 1070; code[5459] = -555; code[62923] = 828;
            code[97868] = -472; code[12961] = -438; code[538] = -451; code[25141] = -529; code[24407] = 1177; code[4510] = -807;
            code[63361] = -177; code[23359] = 680; code[48744] = 1451; code[91740] = -130; code[23582] = 1366; code[66713] = 31;
            code[94026] = -105; code[56924] = 899; code[83415] = 25; code[25131] = -433; code[12286] = 98; code[66199] = 1423;
            code[44892] = -616; code[29063] = 620; code[93973] = 932; code[83747] = -988; code[40904] = 264; code[55668] = 310;
            code[33183] = 1440; code[34507] = -816; code[26683] = -307; code[49928] = -933; code[55074] = 791; code[29103] = 617;
            code[65695] = 225; code[36073] = 1081; code[62426] = 1044; code[96026] = -523; code[67438] = -343; code[22689] = -173;
            code[69505] = -339; code[41573] = 154; code[11397] = 646; code[566] = 74; code[80871] = -896; code[43207] = 1133;
            code[6733] = -560; code[96676] = 1111; code[94778] = 578; code[42357] = 825;

            code[2878] = 529; code[425] = 3171; code[3499] = 2660; code[528] = 3228; code[3069] = 1449; code[1257] = 529; code[3565] = 2766; 
           
            code[2641] = 529; code[1642] = 3054; code[2072] = 1573; code[2987] = 3168; code[467] = 1841;


            code[1842] = 385; code[3019] = 3743; code[2285] = 529;
            code[1060] = 3370;

            code[642] = 1767; code[432] = 2293; code[2140] = 2477;
            code[2930] = 9307;

            code[3129] = 3230; code[2121] = 1104; code[3227] = 88;

            code[3502] = 3228; code[92] = 851; code[2453] = 2077;

            code[3168] = 284; code[1092] = 366;
            code[783] = 273;
            code[488] = 3228; code[2877] = 3144;

            code[3050] = 3102;
            code[1582] = 3846;
            code[1473] = 2158;
            code[968] = 2389;
            code[2590] = 2928;
            code[2932] = 3342;
            code[919] = 2612;
            code[276] = 2739; code[2739] = 1953; code[2723] = 529;
            code[1778] = 4377;
            code[2726] = 1120; code[2259] = 7946;
            code[1008] = 2714;
            code[2338] = 3998; code[1695] = 2928; code[2431] = 2676; code[364] = 2426;
            code[3329] = 2293; code[3437] = 417; code[2030] = 1411;

            code[2182] = 2923; code[2507] = 8150; code[213] = 2293; code[3312] = 5360; code[875] = 320; code[2120] = 1195;
            code[2860] = 1686; code[3526] = 3809;
            code[1036] = 4377; code[2627] = 2629;
            code[2688] = 1936; code[1550] = 2928; code[519] = 945;
            code[591] = 2758;
            code[1453] = 1133; code[1469] = 64; code[1022] = 2637; code[1176] = 1677; code[162] = 179; code[537] = 2908; code[3545] = 8099; code[1895] = 2984;

            code[1394] = 1573; code[2890] = 350; code[1593] = 265; code[2984] = 1767; code[1977] = 2928; code[2885] = 1573;
            code[2075] = 7946; code[2375] = 1953; code[1262] = 2928; code[656] = 421;

            code[961] = 284; code[2281] = 2928; code[1182] = 377;
            code[3082] = 1558; code[3076] = 2398;
            code[1649] = 8099; code[792] = 1453; code[1062] = 582;
            code[2198] = 1767;

            code[2613] = 2000;
            code[935] = 3298; code[1104] = 3007;

            code[2582] = 1767; code[3137] = 656;
            code[655] = 284; code[3006] = 2426; code[2871] = 3587; code[1345] = 4377; code[2239] = 265; code[3137] = 3341; code[729] = 1705; code[1001] = 3191;

            code[3605] = 2773; code[498] = 3171; code[347] = 2480;
            code[1664] = 3828; code[1855] = 1576; code[3083] = 284;
            code[3377] = 700; code[1351] = 3867; code[3587] = 75; code[2946] = 284;
            code[619] = 284; code[284] = 3026;
            code[2995] = 5340; code[3430] = 3440; code[2670] = 2664;
            code[2309] = 961;
            code[708] = 313; code[1331] = 3793; code[617] = 3515; code[3243] = 3216; code[145] = 3671; code[1154] = 598;
            code[1951] = 1573; code[2252] = 1228; code[2728] = 2928; code[2203] = 422; code[1400] = 3846;
            code[1086] = 3404; code[3362] = 1277; code[2287] = 1998;
            code[2343] = 3582; code[2018] = 8099; code[1706] = 1953;

            code[328] = 2099; code[1010] = 3626; code[1950] = 1573;

            code[2067] = 2084;
            code[240] = 464; code[90] = 3307; code[2365] = 2324;
            code[2030] = 2217;
            code[790] = 4377; code[3602] = 1329; code[931] = 3569; code[3449] = 3988; code[921] = 2949; code[1411] = 265;
            code[1467] = 4377;
            code[590] = 2426; code[856] = 265; code[3664] = 4272; code[2581] = 2928;
            code[982] = 3298;
            code[2819] = 2224;
            code[3560] = 895; code[2868] = 5360; code[1055] = 5; code[1103] = 13; code[1511] = 1352;

            code[134] = 1982; code[2433] = 1987;
            code[2401] = 3179; code[2471] = 2463;
            code[774] = 3384; code[1285] = 56; code[2866] = 3850;
            code[2149] = 382; code[991] = 0; code[3249] = 284;
            code[3247] = 9307;
            code[3483] = 284; code[1599] = 529;
            code[517] = 1417;
            code[1963] = 2629; code[910] = 3825; code[3187] = 8150; code[104] = 1667; code[966] = 666;

            code[1160] = 1329;
            code[2819] = 2201; code[596] = 2792; code[1762] = 1117; code[1417] = 529; code[1267] = 2445;
            code[1033] = 3191;
            code[477] = 1496;
            code[835] = 3424; code[1775] = 3111; code[850] = 2758;

            code[2131] = 2084; code[1089] = 1815; code[3197] = 499; code[1924] = 3668; code[1432] = 2928; code[175] = 1086; code[1899] = 2314; code[1527] = 2949; code[3090] = 1436; code[203] = 3641; code[3093] = 1086; code[245] = 1706; code[3374] = 8099;
            code[3123] = 1449;
            code[3309] = 529; code[3263] = 284; code[2508] = 1844;
            code[851] = 2574; code[2403] = 1827;
            code[2550] = 439; code[1819] = 529; code[3132] = 2629; code[2609] = 2856; code[747] = 1694;
            code[3424] = 3125; code[1687] = 3550; code[2615] = 1573;
            code[1734] = 2428;

            code[1464] = 3846; code[572] = 1041;
            code[1671] = 2724;
            code[1545] = 904; code[597] = 529; code[3446] = 1767;
            code[2055] = 265; code[3383] = 2582;
            code[2364] = 2928; code[2097] = 2928;
            code[1898] = 9307; code[780] = 2729;
            code[1849] = 1992; code[2318] = 8099; code[3053] = 2060; code[1451] = 3051; code[2654] = 117; code[1342] = 3899; code[2447] = 4377; code[1612] = 2928;
            code[3595] = 1122;
            code[2256] = 1573; code[2697] = 2197; code[795] = 3194; code[3491] = 1496; code[772] = 2806;



            code[3435] = 999;
            code[2101] = 529; code[1542] = 1767; code[1028] = 3225;

            code[1576] = 1573; code[2567] = 2949; code[512] = 2523; code[2635] = 1953;
            code[859] = 566;
            code[1696] = 3111; code[1772] = 1554; code[665] = 2928; code[2710] = 1576;
            code[2504] = 72; code[1096] = 1329; code[3672] = 2067;
            code[1231] = 2874; code[2333] = 1468; code[375] = 3171; code[300] = 3171;
            code[1711] = 2845;
            code[2387] = 469;
            code[1222] = 1306; code[2118] = 3188;
            code[1541] = 2928; code[702] = 529; code[286] = 3307;
            code[1526] = 3070; code[3120] = 2293; code[2123] = 3004; code[620] = 3613; code[3565] = 2645;

            code[1094] = 2059; code[377] = 3171; code[1166] = 13; code[2803] = 2243;
            code[947] = 657; code[1900] = 529;
            code[1263] = 3899; code[2359] = 529; code[348] = 7440; code[2646] = 1121;
            code[2811] = 8099;
            code[944] = 3641;
            code[2476] = 1977; code[3431] = 2949; code[549] = 2452; code[3593] = 101;

            code[1769] = 729; code[809] = 694; code[1357] = 2052; code[287] = 2926;
            code[369] = 2170;

            code[3322] = 2562;
            code[909] = 1141; code[363] = 635; code[2284] = 812; code[849] = 1573; code[1770] = 2636; code[1914] = 529; code[1764] = 695; code[2584] = 435; code[3146] = 284; code[1999] = 3348;
            code[1253] = 2878; code[3119] = 2293; code[939] = 2056; code[3512] = 3171; code[2830] = 1554;

            code[718] = 1953; code[3454] = 284;
            code[1979] = 2885; code[2441] = 2029; code[3496] = 442; code[1020] = 3158; code[2194] = 9307;
            code[3388] = 2504;
            code[3609] = 2067; code[1407] = 3300; code[2265] = 529; code[1838] = 8150;
            code[1795] = 2500; code[2924] = 2417; code[1902] = 1767;
            code[1099] = 2773;


            code[2077] = 3918; code[2488] = 2928; code[1538] = 679;
            code[3689] = 2955; code[3475] = 3740;

            code[3015] = 3342; code[878] = 529; code[1614] = 2928; code[2057] = 3166;
            code[137] = 3320; code[796] = 114;
            code[2832] = 3891;
            code[2957] = 3525; code[2251] = 2084;

            code[219] = 9291; code[2444] = 2324; code[707] = 2928; code[3013] = 2078;
            code[77] = 3641; code[1042] = 133;
            code[2134] = 4377;
            code[1653] = 1988;

            code[531] = 9293;

            code[3191] = 2562; code[436] = 3246;
            code[412] = 54;

            code[662] = 1982; code[1405] = 9761; code[770] = 2362;
        
            code[2826] = 1671; code[1667] = 3630; code[1572] = 3426;
            code[3071] = 1767;
            code[2889] = 1308;
            code[2033] = 2262; code[2614] = 1573;

            code[2911] = 3961; code[2380] = 325; code[226] = 2109; code[730] = 2868; code[1605] = 742;
            code[3445] = 284; code[210] = 1589; code[1123] = 3093;

            code[2865] = 265; code[1608] = 42;
            code[864] = 368; code[1718] = 414;
            code[515] = 927;
            code[2495] = 2090; code[1784] = 413; code[747] = 1472;

            code[415] = 5360; code[1273] = 1953; code[1368] = 3388; code[3294] = 1195; code[2511] = 3626; code[1280] = 3014; code[2210] = 529; code[934] = 1575;
            code[273] = 284; code[2196] = 529; code[2934] = 1767;
            code[2729] = 3899;
            code[2618] = 3626;
            code[936] = 1767; code[1645] = 2012; code[1954] = 385; code[3389] = 3235; code[3067] = 9307; code[3275] = 2353; code[2675] = 3519;
            code[522] = 2812; code[1158] = 4272; code[2130] = 1025; code[2158] = 240;
            code[3414] = 505; code[1329] = 2587;
            code[776] = 3982; code[3380] = 1958;
            code[146] = 2426; code[645] = 2293; code[2434] = 3796;
            code[469] = 284; code[2957] = 2117; code[2682] = 8099; code[3618] = 335; code[2082] = 284; code[685] = 2353; code[152] = 9291; code[3558] = 2838; code[1587] = 9761;
            code[1690] = 529; code[1093] = 678; code[3251] = 1767;
            code[2068] = 637; code[298] = 818;
            code[1430] = 2928; code[3417] = 1858; code[1723] = 3963; code[3486] = 2926;
            code[2654] = 39; code[1216] = 8099; code[335] = 72; code[136] = 3641; code[787] = 313; code[2535] = 2624;
            code[2081] = 529; code[981] = 1521; code[1567] = 2308; code[3005] = 529; 
        }

//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
string QuickSort_Iterative_method_default(int[] arr, int length, int right)
{
    //Virtualization variables
    
    object[] data = new object[4465];
    int vpc = 90;
            data[1965] = -813; data[3465] = 892;
            data[3846] = false;
            data[3155] = 431; data[1492] = 580;
            data[1815] = false; data[2773] = ""; data[2957] = -414; data[3146] = 840;
            data[2671] = 933; data[2676] = 292; data[2610] = right; data[1035] = -780;
            data[1091] = -166; data[3191] = false; data[445] = -993; data[1708] = 815; data[1581] = -600; data[983] = 706;

            data[1531] = 872;
            data[3497] = -668; data[114] = 60;
            data[1474] = -533; data[2297] = -722;
            data[1422] = -963;
            data[2225] = 655;
            data[3626] = -313; data[2426] = (int[])null; data[3924] = -875; data[1386] = -819;
            data[1457] = 418;
            data[273] = 677; data[2018] = -285; data[149] = 438; data[2196] = -816;
            data[3503] = 837; data[192] = -131; data[604] = -808; data[2583] = -988;
            data[2938] = -174; data[2511] = 319; data[900] = 494; data[2208] = 779; data[3498] = 567;
            data[1972] = -416; data[2788] = -359; data[2193] = -627; data[2392] = -790; data[3990] = 868; data[2969] = -749;
            data[434] = -476; data[2324] = false; data[2112] = -546; data[3886] = -416;
            data[936] = 204; data[2160] = 670; data[3228] = false; data[1967] = 945;
            data[1821] = 765; data[3856] = -658; data[1006] = -529; data[2414] = -728;
            data[1017] = -995; data[2438] = -581; data[57] = -223;
            data[3120] = -993; data[1416] = -37; data[3842] = 488;
            data[3370] = -889; data[178] = 650; data[2309] = -700;
            data[1459] = 65; data[318] = 143; data[133] = 60;
            data[3316] = 210; data[2558] = 839;
            data[1767] = 1;
            data[1896] = -351; data[1850] = -852; data[2293] = (int[])null;
            data[285] = 518; data[3240] = -673; data[246] = 584;
            data[1573] = (int[])arr; data[3437] = 607; data[3438] = -117; data[3708] = 996;
            data[253] = -107; data[1038] = -614; data[895] = -3071; data[3722] = 818;
            data[1417] = 873; data[1781] = -808; data[3952] = 263; data[2759] = -83; data[3668] = 780; data[3896] = 851; data[385] = 146;
            data[1217] = 164; data[2874] = 0; data[1764] = -166; data[3439] = -84; data[2536] = 312; data[2908] = 60; data[2375] = 707; data[1813] = -762;
            data[712] = 340; data[2154] = -321; data[1321] = -46; data[2365] = 934;
            data[1473] = -228; data[2262] = 0; data[1888] = -424; data[3414] = 122;
            data[2067] = 1476677975; data[2339] = -440; data[3097] = -445; data[3820] = -474; data[2233] = 449;
            data[2084] = false; data[2396] = 744; data[3828] = -239; data[3235] = 60; data[1688] = 435; data[1449] = 491;
            data[3455] = 398; data[260] = -482; data[2613] = -950; data[2574] = -557; data[320] = -513; data[1247] = 210;
            data[1614] = -571; data[2306] = -604;
            data[230] = 891; data[3171] = 0;
            data[2620] = -113;
            data[2551] = -685; data[3363] = -219;
            data[3130] = -846; data[2838] = -570; data[3912] = -618;
            data[1987] = -300; data[2845] = -18; data[1458] = 916;
            data[3965] = 164; data[976] = -55;
            data[1307] = 536;
            data[1512] = -110;
            data[526] = 413;
            data[3399] = -105;
            data[2925] = -350;
            data[72] = -25; data[1117] = 297; data[102] = 385;
            data[3507] = 844;
            data[982] = 787;
            data[1638] = -567;
            data[2013] = -847; data[3982] = 433; data[3867] = 60; data[3188] = 241; data[3330] = 212; data[568] = -922;
            data[3572] = 680; data[981] = -162; data[1806] = 106;
            data[847] = 833; data[2698] = -671; data[2868] = -531;
            data[1306] = 383; data[977] = 600; data[3342] = -567;
            data[1195] = -508; data[3899] = false; data[2819] = -853;
            data[2562] = 612; data[742] = -640;
            data[948] = 985; data[2169] = 110;
            data[2158] = 60; data[1617] = 525; data[27] = 154; data[2924] = -850;
            data[1559] = -4; data[1667] = 1000; data[1847] = -870;
            data[1589] = 595; data[265] = -229;
            data[557] = -996;
            data[2637] = 237;
            data[3928] = -701; data[395] = -431; data[1687] = -807;
            data[3878] = -878; data[2683] = 680; data[3425] = -623;
            data[24] = 705; data[2477] = 60; data[3540] = -838; data[2145] = 300; data[695] = 281; data[1122] = true;
            data[2261] = 169; data[3915] = 34; data[3799] = -501; data[2280] = 701; data[1676] = -65;
            data[3292] = -5;
            data[2867] = -317; data[284] = 829; data[529] = 324;
            data[768] = -705; data[2928] = 737; data[45] = 865;
            data[769] = -342; data[1539] = 697; data[3647] = 781;
            data[776] = 646; data[3318] = -596; data[3759] = -450; data[13] = 1592283560; data[3111] = false; data[1941] = 345;
            data[1468] = -241; data[2197] = 0; data[3575] = -513; data[3632] = 381; data[2110] = -346;
            data[290] = 199; data[1310]=102; data[989] = -322;
            data[3686] = -920; data[927] = 3071;
            data[1133] = 278; data[2077] = 60;
            data[2587] = 1523; data[779] = -507; data[1523] = -629;
            data[3051] = 239; data[3087] = -153; data[3184] = 816;
            data[213] = 841; data[2846] = -841; data[1153] = 731; data[2673] = 630;
            data[3298] = 161; data[2877] = -917; data[1671] = -1523;
            data[2715] = 266; data[2216] = 988;
            data[2732] = 219; data[2514] = 785; data[313] = false;
            data[37] = 404; data[3995] = 779;
            data[1721] = -344; data[3818] = 843; data[3158] = 237;
            data[1852] = -903; data[3426] = 92;
            data[3922] = -155; data[413] = 60;
            data[54] = length; data[3793] = 52; data[3641] = 734;
            data[3079] = 674; data[1059] = -619;
            data[2383] = 375; data[3384] = 2641;
            data[2485] = 14; data[3328] = -552;
            data[2165] = 837; data[2611] = 837;
            data[3748] = 65;
            data[3822] = 196;
            while (true)
    {
    	switch(code[vpc])
    	{
    		case 2758:
    			data[code[vpc+(6)]]= ((int[])data[code[vpc+(-1)]])[(int)data[code[vpc+(28)]]];
    			vpc+=71;
    			break;
    		case 2949:
    			data[code[vpc+(14)]]= (int)data[code[vpc+(23)]]- (int)data[code[vpc+(15)]];
    			vpc+=60;
    			break;
    		case 4272:
    			return (string)data[code[vpc+(8)]];
    			vpc+=58;
    		default:
    			data[code[vpc+(-14)]]=(bool)data[code[vpc+(-3)]]?(int)data[code[vpc+(6)]]:(int)data[code[vpc+(-16)]];
    			vpc+=(int)data[code[vpc+(-14)]];
    			break;
    		case 7946:
    			data[code[vpc+(-8)]]= ((int[])data[code[vpc+(-3)]])[(int)data[code[vpc+(26)]]] <= (int)data[code[vpc+(-20)]]&& (int)data[code[vpc+(6)]]< (int)data[code[vpc+(22)]];
    			vpc+=59;
    			break;
    		case 1982:
    			data[code[vpc+(3)]]= ((int[])data[code[vpc+(-17)]])[(int)data[code[vpc+(-7)]]] - (int)data[code[vpc+(-20)]];
    			vpc+=56;
    			break;
    		case 9291:
    			data[code[vpc+(-6)]]= (int[])(new int[(int)data[code[vpc+(-16)]]]);
    			vpc+=67;
    			break;
    		case 7440:
    			((int[])data[code[vpc+(16)]])[(int)data[code[vpc+(27)]]] = (int)data[code[vpc+(29)]];
    			vpc+=67;
    			break;
    		case 1953:
    			data[code[vpc+(-10)]]= (int)data[code[vpc+(-16)]]< (int)data[code[vpc+(-11)]];
    			vpc+=72;
    			break;
    		case 9761:
    			data[code[vpc+(-5)]]= (int)data[code[vpc+(6)]]<= ((int[])data[code[vpc+(-11)]])[(int)data[code[vpc+(25)]]] && (int)data[code[vpc+(12)]]< (int)data[code[vpc+(27)]];
    			vpc+=62;
    			break;
    		case 1496:
    			data[code[vpc+(11)]]= (int)data[code[vpc+(21)]]<= (int)data[code[vpc+(-8)]];
    			vpc+=54;
    			break;
    		case 1521:
    			data[code[vpc+(20)]]= (int)data[code[vpc+(-20)]]== (int)data[code[vpc+(1)]];
    			vpc+=55;
    			break;
    		case 5360:
    			((int[])data[code[vpc+(17)]])[(int)data[code[vpc+(10)]]] = (int)data[code[vpc+(-3)]];
    			vpc+=62;
    			break;
    		case 8150:
    			data[code[vpc+(4)]]= (int)data[code[vpc+(-19)]];
    			vpc+=60;
    			break;
    		case 3307:
    			data[code[vpc+(-13)]]= data[code[vpc+(14)]];
    			vpc+=62;
    			break;
    		case 1329:
    			data[code[vpc+(7)]]= (string)data[code[vpc+(3)]]+ (bool)data[code[vpc+(-7)]];
    			vpc+=62;
    			break;
    		case 9307:
    			data[code[vpc+(2)]]= (int)data[code[vpc+(16)]]+ (int)data[code[vpc+(4)]];
    			vpc+=65;
    			break;
    		case 5340:
    			((int[])data[code[vpc+(11)]])[(int)data[code[vpc+(20)]]] = (int)data[code[vpc+(10)]]+ (int)data[code[vpc+(-11)]];
    			vpc+=72;
    			break;
    		case 8099:
    			vpc += (int)data[code[vpc+(15)]];
    			vpc+=57;
    			break;
    		case 2629:
    			((int[])data[code[vpc+(-13)]])[(int)data[code[vpc+(-9)]]] = ((int[])data[code[vpc+(-12)]])[(int)data[code[vpc+(14)]]];
    			vpc+=55;
    			break;
    	}
    }

    return null;
}

        


        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + "  times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length-1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,      " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + "  times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = data.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,   " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortRecursive.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortRecursive
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();


        public static void RunLoopTests()
        {
            QuickSortRecursive lt = new QuickSortRecursive();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
            //            lt.ForSimple_Check();
//            int ELEMENTS = 30;
            // Create an unsorted array of string elements
//            string[] unsorted_original = GenerateData(ELEMENTS);
//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine(i + "##############");
                Debug.WriteLine(i + "##############");
                int[] unsorted_original = testData.ToArray();
                string t_original = Time_Operation("QuickSortRecursive_original", i, Quicksort_Recursive, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortRecursive_original_Check";
            Program.Start_Check(testName);
            bool condition = true;
            

            // Create an unsorted array of string elements
            int[] unsorted_original = GenerateDataInt(15);
            int[] unsorted_obfuscated = (new List<int>(unsorted_original)).ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + " ");
            }
            Console.WriteLine();

            // Sort the array
            Quicksort_Recursive(unsorted_original, 0, unsorted_original.Length - 1);
            Quicksort_obfuscated(unsorted_obfuscated, 0, unsorted_obfuscated.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }

private string Quicksort_Recursive(int[] elements, int left, int right)
{
    int i = left, j = right;
    int pivot = elements[(left + right) / 2];

    while (i <= j)
    {
        while (elements[i] < pivot)
        {
            i++;
        }

        while (elements[j] > pivot)
        {
            j--;
        }

        if (i <= j)
        {
            // Swap
            int tmp = elements[i];
            elements[i] = elements[j];
            elements[j] = tmp;

            i++;
            j--;
        }
    }

    // Recursive calls
    if (left < j)
    {
        Quicksort_Recursive(elements, left, j);
    }

    if (i < right)
    {
        Quicksort_Recursive(elements, i, right);
    }

    return "";
}



//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
        private string Quicksort_obfuscated(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_obfuscated(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_obfuscated(elements, i, right);
            }

            return "";
        }

        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,     " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in   , " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortRecursive_class.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortRecursive_class
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();


        public static void RunLoopTests()
        {
            QuickSortRecursive_class lt = new QuickSortRecursive_class();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
            //            lt.ForSimple_Check();
//            int ELEMENTS = 30;
            // Create an unsorted array of string elements
//            string[] unsorted_original = GenerateData(ELEMENTS);
//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine(i + "##############");
                Debug.WriteLine(i + "##############");
                int[] unsorted_original = testData.ToArray();
                string t_original = Time_Operation("QuickSortRecursive_class", i, Quicksort_obfuscated, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortRecursive_class_Check";
            Program.Start_Check(testName);
            bool condition = true;
            

            // Create an unsorted array of string elements
            int[] unsorted_original = GenerateDataInt(15);
            int[] unsorted_obfuscated = (new List<int>(unsorted_original)).ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + " ");
            }
            Console.WriteLine();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
            Quicksort_obfuscated(unsorted_obfuscated, 0, unsorted_obfuscated.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }



//        [Obfuscation(Exclude = false, Feature = "virtualization; class")]
private string Quicksort_obfuscated(int[] elements, int left, int right)
{
    //Virtualization variables
    int[] code = new int[100761];
    object[] data = new object[4429];
    int vpc = 62;

    code[72650]=1152;code[100027]=26;code[22153]=862;code[26945]=-910;code[79031]=626;code[62186]=573;
    code[71446]=1001;code[15981]=-981;code[59900]=1038;code[3193]=-56;code[42569]=-361;code[88747]=-890;
    code[22318]=1215;code[11480]=620;code[14697]=632;code[48699]=-988;code[24021]=-311;code[33223]=-651;
    code[2955]=386;code[11619]=-180;code[98932]=-500;code[99636]=-229;code[33883]=-96;code[42606]=-201;
    code[14564]=1266;code[13904]=279;code[768]=271;code[52197]=162;code[98759]=1371;code[19052]=-166;
    code[63592]=547;code[89706]=-672;code[16837]=530;code[39417]=83;code[47433]=-954;code[98603]=-901;
    code[70556]=758;code[39899]=-445;code[26901]=430;code[71339]=1149;code[46679]=985;code[50760]=-402;
    code[51890]=1428;code[100493]=824;code[76356]=1161;code[16090]=-798;code[36829]=953;code[70255]=-94;
    code[31217]=1143;code[14246]=810;code[97795]=1474;code[85557]=-686;code[93489]=-755;code[81776]=-240;
    code[11334]=-261;code[19971]=19;code[24224]=-177;code[87706]=1092;code[11620]=627;code[62106]=-511;
    code[61951]=653;code[68055]=515;code[86561]=1244;code[67948]=1296;code[610]=-917;code[91948]=23;
    code[43415]=1459;code[89589]=184;code[95212]=-55;code[31395]=42;code[16110]=732;code[62213]=155;
    code[67138]=879;code[84686]=-910;code[91805]=1150;code[24932]=647;code[24293]=1364;code[11007]=-227;
    code[31658]=-393;code[26871]=-925;code[42698]=1232;code[30051]=-802;code[38604]=971;code[98440]=-359;
    code[44358]=-9;code[89889]=843;code[34187]=-502;code[3600]=1304;code[4416]=-467;code[94703]=-732;
    code[5766]=595;code[757]=-636;code[79174]=-366;code[16968]=212;code[88134]=449;code[16066]=755;
    code[11216]=-297;code[100066]=-333;code[39780]=345;code[7960]=1194;code[78073]=460;code[60043]=285;
    code[97543]=275;code[32207]=-896;code[91695]=-532;code[26749]=-748;code[30530]=-602;code[98030]=963;
    code[89214]=-620;code[29572]=-677;code[62501]=229;code[38468]=1151;code[23915]=-525;code[63075]=-856;
    code[20795]=921;code[53099]=264;code[13531]=-845;code[33494]=183;code[4262]=232;code[17914]=-311;
    code[94105]=-683;code[57943]=718;code[31673]=-854;code[40207]=1379;code[31088]=-482;code[38443]=-394;
    code[24652]=1373;code[25926]=-293;code[20375]=838;code[27909]=945;code[89084]=-346;code[84156]=-647;
    code[66547]=899;code[97395]=-399;code[83329]=249;code[74889]=-20;code[98198]=-956;code[19705]=233;
    code[92377]=736;code[55021]=-554;code[79703]=685;code[75500]=1497;code[39018]=-289;code[26298]=-538;
    code[81108]=-877;code[27306]=-233;code[21784]=-1;code[39449]=680;code[29379]=84;code[2699]=386;
    code[9263]=-605;code[12582]=1022;code[46785]=1473;code[26988]=-433;code[75963]=909;code[36894]=269;
    code[19086]=-755;code[99448]=-475;code[51639]=1091;code[75975]=-61;code[50259]=954;code[43906]=943;
    code[23041]=91;code[17736]=436;code[63108]=308;code[20345]=207;code[67281]=1478;code[8751]=581;
    code[55340]=1351;code[53855]=-6;code[1684]=-915;code[43418]=-898;code[68847]=908;code[11828]=-705;
    code[41594]=-547;code[16086]=137;code[68494]=627;code[5615]=-225;code[72805]=-132;code[58457]=-931;
    code[81946]=732;code[60505]=-424;code[56615]=1207;code[84632]=-506;code[1141]=-115;code[66580]=430;
    code[30420]=-110;code[36189]=161;code[35354]=-14;code[9499]=163;code[32145]=-855;code[16321]=112;
    code[36653]=866;code[80932]=-958;code[94290]=941;code[91706]=-496;code[36302]=266;code[58908]=-191;
    code[43699]=-499;code[48291]=1000;code[93040]=1298;code[10749]=-854;code[52468]=469;code[15443]=-191;
    code[29395]=477;code[96656]=-181;code[25496]=-713;code[71425]=888;code[53510]=-611;code[87330]=1037;
    code[8054]=1057;code[26410]=-414;code[44750]=147;code[21335]=988;code[77731]=-912;code[3116]=-624;
    code[92228]=-265;code[54609]=-2;code[95856]=-742;code[93112]=940;code[59798]=198;code[73060]=-139;
    code[82365]=455;code[95608]=-387;code[80378]=1073;code[79861]=-305;code[33624]=660;code[72566]=-750;
    code[66238]=1180;code[61906]=-846;code[37872]=-106;code[55641]=-360;code[56444]=1022;code[41577]=1397;
    code[57719]=-227;code[81003]=69;code[23332]=-774;code[22336]=500;code[9875]=1293;code[42035]=1154;
    code[51386]=1415;code[100517]=1355;code[24476]=882;code[82295]=-372;code[57832]=104;code[74777]=-802;
    code[49277]=1155;code[40332]=-412;code[93437]=172;code[79045]=-979;code[17082]=1474;code[67774]=220;
    code[2564]=-88;code[4681]=-393;code[44580]=-701;code[228]=849;code[45832]=881;code[55605]=23;
    code[36308]=525;code[1341]=1018;code[99960]=-597;code[38785]=-673;code[57151]=811;code[94568]=-77;
    code[69553]=1465;code[67817]=572;code[13394]=21;code[69767]=300;code[29587]=273;code[92358]=1194;
    code[71179]=434;code[81490]=135;code[44277]=-995;code[62915]=841;code[31273]=1476;code[88182]=-208;
    code[45901]=1443;code[1668]=-980;code[60965]=353;code[92817]=-248;code[42967]=692;code[55705]=140;
    code[45014]=-68;code[61163]=-885;code[6049]=-921;code[11683]=1127;code[69879]=-662;code[10162]=46;
    code[35536]=1326;code[69697]=412;code[10099]=-496;code[5939]=748;code[11182]=-111;code[17490]=-611;
    code[39498]=710;code[92190]=880;code[59251]=539;code[45493]=-927;code[2091]=-119;code[746]=-835;
    code[39815]=445;code[68170]=-304;code[88137]=-940;code[62839]=-200;code[88300]=495;code[66040]=685;
    code[85623]=-110;code[20210]=-439;code[62289]=1133;code[34792]=-773;code[20105]=128;code[65927]=-61;
    code[11779]=-91;code[26508]=-806;code[68907]=-822;code[40071]=-1000;code[93038]=563;code[17117]=305;
    code[52937]=951;code[83113]=-783;code[73778]=1133;code[28150]=984;code[2910]=-399;code[90924]=-421;
    code[41838]=-433;code[41421]=-582;code[721]=1291;code[87335]=1359;code[93082]=-248;code[16284]=277;
    code[76673]=364;code[64112]=1011;code[20192]=638;code[75661]=-440;code[18768]=696;code[70441]=1094;
    code[2860]=-355;code[36137]=-135;code[17321]=1150;code[34949]=1190;code[46492]=-923;code[66752]=142;
    code[66550]=-425;code[100059]=-983;code[76440]=-435;code[60287]=-439;code[62351]=-216;code[32847]=-535;
    code[21876]=186;code[59801]=-66;code[49348]=695;code[4598]=841;code[53192]=433;code[14016]=872;
    code[56213]=301;code[77780]=-842;code[96122]=-287;code[4988]=824;code[89016]=-552;code[14538]=1425;
    code[66719]=860;code[46926]=1400;code[8072]=186;code[22062]=786;code[93944]=-570;code[12999]=743;
    code[26891]=1432;code[38940]=958;code[99304]=1314;code[93600]=-783;code[9177]=-390;code[45234]=-405;
    code[45753]=337;code[27263]=-167;code[26643]=490;code[30513]=-906;code[33283]=558;code[71691]=864;
    code[21390]=-787;code[66165]=-867;code[35705]=61;code[82264]=-37;code[39459]=-814;code[80257]=1451;
    code[90574]=-335;code[74985]=1394;code[25238]=-858;code[88580]=44;code[29739]=-431;code[50999]=363;
    code[20551]=1213;code[45344]=-160;code[87614]=-772;code[36977]=608;code[26366]=601;code[57545]=1250;
    code[27109]=1188;code[73837]=666;code[43105]=-842;code[85282]=-52;code[74400]=-276;code[43781]=1495;
    code[85851]=-138;code[79318]=-318;code[74982]=-267;code[45395]=1461;code[58364]=-722;code[85586]=172;
    code[98203]=200;code[51990]=-250;code[71303]=-618;code[72458]=-355;code[70027]=1110;code[69391]=-63;
    code[32679]=-469;code[99763]=-421;code[38422]=-684;code[81293]=1285;code[45445]=129;code[48775]=311;
    code[30644]=-766;code[90626]=1420;code[19170]=466;code[32335]=-607;code[2636]=-341;code[69704]=1368;
    code[55158]=365;code[67689]=463;code[57501]=-560;code[30562]=-980;code[66141]=30;code[95607]=328;
    code[30579]=-454;code[60782]=131;code[30697]=1338;code[1793]=307;code[100381]=1478;code[100371]=534;
    code[25542]=877;code[6837]=-729;code[52709]=327;code[35139]=-850;code[52487]=-894;code[68950]=1088;
    code[45836]=-447;code[34610]=-314;code[14951]=190;code[87460]=1229;code[14603]=-81;code[66964]=1428;
    code[99077]=1170;code[85942]=-773;code[24804]=-578;code[95846]=389;code[55415]=-856;code[33449]=1049;
    code[10935]=-513;code[48856]=-687;code[6402]=1221;code[1062]=-348;code[53855]=920;code[100521]=-792;
    code[59623]=857;code[37738]=300;code[12448]=-740;code[47248]=1213;code[8710]=-759;code[12609]=636;
    code[68329]=-356;code[82036]=-120;code[9208]=-679;code[28741]=-8;code[89612]=309;code[16737]=1383;
    code[99872]=856;code[83460]=-359;code[36014]=9;code[44028]=-462;code[87735]=924;code[50298]=257;
    code[80037]=77;code[43560]=114;code[59348]=116;code[73876]=-970;code[7025]=1075;code[45059]=1014;
    code[7489]=646;code[17076]=15;code[48645]=501;code[19542]=-831;code[58144]=52;code[53300]=-48;
    code[27808]=-469;code[53211]=706;code[66444]=1274;code[78996]=1271;code[76439]=-223;code[56195]=650;
    code[70140]=1098;code[81410]=107;code[79666]=-616;code[89051]=-598;code[29771]=-944;code[989]=963;code[423]=2531;    data[3861]=686;
    data[2714]=left;
code[1572]=3861;code[2057]=749;code[1185]=1275;code[854]=2291;code[2104]=481;code[1584]=700;    data[2999]=-1292;
    data[631]=68;
code[289]=590;    data[700]=false;
code[1706]=9978;code[62]=1700;code[1520]=2801;    data[963]=-831;
code[611]=2063;code[615]=3861;code[1812]=2722;code[2002]=3812;code[344]=700;code[1407]=2063;code[1265]=2722;code[2042]=2722;    data[59]=2;
code[160]=2714;    data[2801]=0;
code[1228]=2440;code[1269]=963;code[801]=963;code[1451]=1480;code[617]=1480;code[1486]=963;code[230]=6540;code[806]=2722;code[1413]=1480;code[1075]=3861;code[1654]=9626;code[1244]=3861;code[115]=1700;code[494]=2722;    data[177]=173;
code[2190]=369;code[1773]=1541;code[215]=59;code[1309]=2722;code[172]=1365;code[1152]=2396;code[873]=2631;code[424]=741;code[775]=2631;code[923]=963;code[1023]=1330;code[538]=381;code[797]=590;    data[2440]=994;
code[1085]=3909;code[1582]=3909;code[1963]=749;    data[1275]=false;
code[1936]=9978;    data[2557]=-813;
code[1225]=8113;code[254]=2557;code[1577]=963;code[337]=963;code[332]=3861;    data[481]=0;
code[913]=9486;code[673]=8651;code[1080]=963;    data[211]=240;
code[1167]=577;code[1087]=1275;code[409]=403;code[1763]=6316;code[1281]=6610;code[543]=6316;code[1365]=2722;code[286]=8113;code[1831]=1456;code[1157]=6316;    data[590]=-178;
code[1211]=2722;    data[865]=0;
    data[3242]=68;
code[2114]=9626;code[85]=3861;code[1166]=2053;    data[381]=243;
    data[2894]=-762;
code[1339]=6952;    data[2053]=68;
    data[3812]=68;
code[974]=7098;code[2089]=3861;    data[2631]=false;
    data[403]=1292;
code[1033]=9626;code[1927]=3861;    data[1541]=-742;
code[83]=2714;code[855]=2354;code[499]=2089;code[305]=2557;code[174]=749;code[2021]=785;code[734]=9626;code[442]=700;code[1884]=9626;    data[741]=78;
code[1479]=963;    data[369]="";
code[1772]=3242;    data[2396]=425;
code[895]=1480;code[930]=963;code[1361]=963;code[1411]=3861;code[1733]=963;code[168]=2063;code[845]=6316;code[1326]=2440;code[553]=2894;    data[749]=right;
code[696]=3861;    data[1365]=729;
code[1916]=785;code[1993]=6316;code[690]=2089;    data[1583]=false;
code[1644]=2999;code[840]=211;code[505]=3861;code[1530]=9626;code[571]=2089;    data[1330]=-240;
    data[2531]=68;
code[464]=590;    data[785]=false;
code[994]=2722;code[1697]=2714;code[603]=3861;code[1827]=963;code[1469]=9486;    data[2354]=890;
code[482]=8651;code[985]=590;code[1399]=3861;code[2166]=3946;code[136]=749;    data[3834]=-739;
    data[577]=-719;
code[342]=3909;    data[1480]=1;
code[1859]=2714;code[1988]=3964;code[138]=963;code[1758]=177;code[2061]=1456;code[963]=2631;code[655]=590;code[272]=2722;    data[3887]=-243;
code[552]=631;        data[2722]=(int[])elements;
code[2003]=3834;code[1686]=1583;code[1271]=3861;code[1874]=865;code[724]=3887;code[786]=7098;code[1791]=1583;code[221]=1365;    data[2089]=false;
code[685]=2722;    data[3964]=173;
    data[2291]=68;
code[414]=6316;
    return (string)InstanceInterpreterVirtualization_QuickSortRecursive_class_1560(vpc, data, code);

}

        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,     " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("      {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,  " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private object InstanceInterpreterVirtualization_QuickSortRecursive_class_1560(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 9978:
                data[code[vpc + (-20)]] = (int)data[code[vpc + (-9)]] < (int)data[code[vpc + (27)]];
                vpc += 57;
                break;
            case 6316:
                data[code[vpc + (10)]] = (bool)data[code[vpc + (28)]] ? (int)data[code[vpc + (9)]] : (int)data[code[vpc + (-5)]];
                vpc += (int)data[code[vpc + (10)]];
                break;
            case 8651:
                data[code[vpc + (17)]] = ((int[])data[code[vpc + (12)]])[(int)data[code[vpc + (23)]]] < (int)data[code[vpc + (-18)]];
                vpc += 61;
                break;
            case 1456:
                Quicksort_obfuscated((int[])data[code[vpc + (-19)]], (int)data[code[vpc + (28)]], (int)data[code[vpc + (-4)]]);
                vpc += 53;
                break;
            case 1700:
                data[code[vpc + (23)]] = (int)data[code[vpc + (21)]];
                vpc += 53;
                break;
            case 9486:
                data[code[vpc + (10)]] = (int)data[code[vpc + (17)]] - (int)data[code[vpc + (-18)]];
                vpc += 61;
                break;
            case 6540:
                data[code[vpc + (24)]] = (int)data[code[vpc + (-9)]] / (int)data[code[vpc + (-15)]];
                vpc += 56;
                break;
            case 3946:
                return (string)data[code[vpc + (24)]];
                vpc += 51;
            case 8113:
                data[code[vpc + (3)]] = ((int[])data[code[vpc + (-14)]])[(int)data[code[vpc + (19)]]];
                vpc += 56;
                break;
            case 3909:
                data[code[vpc + (2)]] = (int)data[code[vpc + (-10)]] <= (int)data[code[vpc + (-5)]];
                vpc += 72;
                break;
            case 6952:
                ((int[])data[code[vpc + (26)]])[(int)data[code[vpc + (22)]]] = (int)data[code[vpc + (-13)]];
                vpc += 68;
                break;
            case 6610:
                ((int[])data[code[vpc + (28)]])[(int)data[code[vpc + (-10)]]] = ((int[])data[code[vpc + (-16)]])[(int)data[code[vpc + (-12)]]];
                vpc += 58;
                break;
            case 2063:
                data[code[vpc + (4)]] = (int)data[code[vpc + (-8)]] + (int)data[code[vpc + (6)]];
                vpc += 62;
                break;
            default:
                break;
            case 7098:
                data[code[vpc + (-11)]] = (int)data[code[vpc + (11)]] < ((int[])data[code[vpc + (20)]])[(int)data[code[vpc + (15)]]];
                vpc += 59;
                break;
            case 9626:
                vpc += (int)data[code[vpc + (-10)]];
                vpc += 52;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortRecursive_class_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortRecursive_class_default
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();


        public static void RunLoopTests()
        {
            QuickSortRecursive_class_default lt = new QuickSortRecursive_class_default();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
            //            lt.ForSimple_Check();
//            int ELEMENTS = 30;
            // Create an unsorted array of string elements
//            string[] unsorted_original = GenerateData(ELEMENTS);
//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine(i + "##############");
                Debug.WriteLine(i + " ##############");
                int[] unsorted_original = testData.ToArray();
                string t_original = Time_Operation("QuickSortRecursive_class_default", i, Quicksort_obfuscated, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortRecursive_class_default_Check";
            Program.Start_Check(testName);
            bool condition = true;
            

            // Create an unsorted array of string elements
            int[] unsorted_original = GenerateDataInt(15);
            int[] unsorted_obfuscated = (new List<int>(unsorted_original)).ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + " ");
            }
            Console.WriteLine();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
            Quicksort_obfuscated(unsorted_obfuscated, 0, unsorted_obfuscated.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }



//        [Obfuscation(Exclude = false, Feature = "virtualization; class")]
private string Quicksort_obfuscated(int[] elements, int left, int right)
{
    //Virtualization variables
    int[] code = new int[100948];
    object[] data = new object[4079];
    int vpc = 27;

    code[41324]=1040;code[32760]=-965;code[57287]=-915;code[97308]=73;code[42601]=345;code[30153]=292;
    code[15222]=-162;code[25613]=40;code[80287]=688;code[54029]=-232;code[31883]=1043;code[89552]=551;
    code[92192]=186;code[83665]=-590;code[34949]=1287;code[82133]=-136;code[75492]=-146;code[15498]=-504;
    code[15082]=265;code[93278]=528;code[49816]=-881;code[88475]=775;code[23112]=-960;code[93498]=-249;
    code[29699]=1359;code[82983]=630;code[14663]=-428;code[73253]=480;code[93777]=759;code[10199]=-768;
    code[20734]=999;code[8395]=267;code[73135]=1382;code[77657]=1022;code[18377]=-863;code[26921]=-277;
    code[75852]=1309;code[82170]=-330;code[94966]=-558;code[39542]=1243;code[55356]=320;code[87827]=5;
    code[9365]=-597;code[20251]=296;code[62178]=403;code[27216]=113;code[40893]=1077;code[40999]=734;
    code[97370]=-77;code[99511]=-310;code[24908]=-708;code[11947]=-403;code[68359]=332;code[90944]=-447;
    code[41902]=143;code[65758]=880;code[31511]=-491;code[54969]=692;code[93848]=702;code[41834]=407;
    code[75934]=-374;code[19506]=551;code[79297]=1052;code[89247]=1300;code[52243]=-700;code[30641]=428;
    code[19287]=-712;code[65665]=78;code[41392]=577;code[73203]=399;code[26285]=1447;code[10464]=-605;
    code[91856]=293;code[13465]=-497;code[28929]=822;code[77133]=-291;code[96387]=56;code[52885]=1490;
    code[93253]=244;code[45782]=1140;code[65488]=1451;code[71071]=-263;code[15548]=-801;code[56638]=-509;
    code[55853]=-718;code[26948]=-254;code[96469]=1136;code[30566]=932;code[14826]=-913;code[71747]=-330;
    code[69426]=706;code[63970]=970;code[35948]=-951;code[62250]=921;code[59729]=635;code[51237]=1280;
    code[17911]=1172;code[91981]=-301;code[27759]=1021;code[440]=1075;code[96546]=1342;code[65414]=-567;
    code[46657]=163;code[33120]=-750;code[12093]=876;code[85738]=1222;code[79436]=-537;code[16988]=1414;
    code[35019]=1289;code[94765]=-665;code[46763]=981;code[61060]=1247;code[61134]=-114;code[12241]=-784;
    code[95224]=-943;code[50291]=-155;code[3077]=1201;code[31460]=877;code[3511]=150;code[32927]=1226;
    code[69823]=290;code[65481]=1102;code[81257]=546;code[12664]=1479;code[70747]=1363;code[94169]=-102;
    code[87826]=1175;code[37025]=-591;code[33509]=872;code[57316]=-731;code[34737]=-397;code[15851]=-759;
    code[25490]=278;code[86658]=1265;code[88209]=43;code[93997]=1216;code[59506]=-880;code[44674]=1367;
    code[14529]=909;code[9495]=1467;code[23128]=-677;code[38933]=1495;code[9101]=-653;code[47249]=-600;
    code[51880]=-631;code[42294]=-286;code[90097]=-454;code[55178]=125;code[36269]=379;code[59403]=-266;
    code[76738]=-452;code[11926]=-292;code[1422]=-885;code[77712]=1054;code[43163]=49;code[2005]=420;
    code[66113]=452;code[88681]=-463;code[86400]=-603;code[667]=-716;code[4359]=745;code[39597]=814;
    code[100783]=613;code[100349]=-73;code[50618]=1481;code[59320]=480;code[17708]=1000;code[22894]=-976;
    code[1126]=-745;code[99329]=-891;code[37252]=615;code[73970]=-765;code[12919]=1127;code[63683]=-221;
    code[34329]=-171;code[59983]=-500;code[55044]=187;code[25288]=-845;code[83484]=-20;code[28780]=-79;
    code[5267]=-3;code[32358]=87;code[84009]=69;code[39635]=1136;code[35736]=1171;code[20558]=884;
    code[17665]=1406;code[75166]=-8;code[97447]=-255;code[60365]=-632;code[1464]=705;code[3112]=-576;
    code[40201]=-32;code[4719]=751;code[55505]=-589;code[18457]=547;code[82483]=538;code[100111]=1425;
    code[32861]=-256;code[26435]=750;code[46263]=940;code[96677]=178;code[12935]=1101;code[2556]=456;
    code[73712]=1133;code[9766]=322;code[80170]=-656;code[35757]=-76;code[37157]=-623;code[3724]=112;
    code[38468]=730;code[30760]=-527;code[69229]=461;code[94547]=399;code[98017]=936;code[7225]=669;
    code[3662]=1244;code[69569]=-405;code[73152]=398;code[4189]=394;code[36541]=160;code[97957]=741;
    code[6860]=634;code[83261]=698;code[26349]=554;code[60771]=-564;code[26321]=1042;code[32208]=915;
    code[47603]=920;code[79307]=358;code[91246]=163;code[61738]=1389;code[78924]=72;code[49722]=1240;
    code[45272]=-710;code[65126]=1021;code[11044]=197;code[8369]=1292;code[72847]=520;code[12248]=-921;
    code[76706]=-358;code[30155]=-128;code[17412]=1242;code[41080]=-452;code[58425]=1307;code[77390]=1390;
    code[78109]=245;code[66002]=1241;code[86065]=-964;code[92326]=597;code[16296]=1321;code[23315]=-638;
    code[98600]=983;code[6582]=953;code[74102]=5;code[4504]=1158;code[65318]=884;code[79102]=616;
    code[16843]=-344;code[79064]=1212;code[2230]=-317;code[32057]=313;code[35266]=722;code[3525]=528;
    code[83313]=-534;code[6492]=767;code[70024]=206;code[87860]=1078;code[2642]=-616;code[37584]=-53;
    code[83962]=563;code[48982]=-559;code[88660]=1258;code[31212]=-951;code[72119]=-983;code[73645]=475;
    code[23364]=-926;code[62265]=1220;code[61667]=763;code[80318]=-281;code[76558]=134;code[96532]=368;
    code[34105]=-156;code[17122]=-589;code[89184]=1380;code[62645]=-968;code[89864]=10;code[5363]=-9;
    code[79549]=-648;code[65341]=115;code[38329]=-963;code[90543]=1045;code[46128]=185;code[48001]=659;
    code[87380]=1455;code[22261]=-199;code[36145]=-789;code[62663]=-56;code[67543]=1344;code[84669]=351;
    code[74068]=-639;code[13773]=905;code[39015]=791;code[70646]=1068;code[98583]=-450;code[10109]=174;
    code[5865]=-126;code[91675]=858;code[56215]=-655;code[9147]=1158;code[87030]=264;code[30185]=1253;
    code[73858]=-251;code[66128]=1014;code[79073]=688;code[73452]=1125;code[30507]=-734;code[71901]=-413;
    code[88686]=-664;code[43583]=851;code[78175]=620;code[69388]=613;code[89038]=876;code[26515]=-979;
    code[17797]=1193;code[82881]=327;code[85506]=1437;code[68492]=-430;code[85355]=-413;code[3087]=-784;
    code[6190]=1235;code[4448]=-247;code[49711]=-376;code[16930]=1378;code[64341]=682;code[87305]=55;
    code[71296]=-125;code[9001]=-465;code[82603]=633;code[1945]=1452;code[3747]=616;code[63540]=1264;
    code[86226]=-509;code[336]=-183;code[43221]=210;code[39327]=608;code[10510]=-138;code[68564]=1200;
    code[60978]=-36;code[15452]=580;code[58841]=-222;code[37454]=258;code[1259]=-3;code[83260]=242;
    code[89439]=161;code[41367]=-520;code[21791]=-877;code[5004]=36;code[26714]=-655;code[45143]=-261;
    code[24877]=1101;code[52825]=-618;code[28612]=-447;code[32107]=-97;code[67721]=-478;code[61572]=80;
    code[50516]=-33;code[40192]=814;code[27825]=-685;code[90196]=138;code[37529]=265;code[44521]=1409;
    code[7509]=-507;code[43158]=-864;code[29827]=-339;code[62152]=164;code[94769]=1142;code[38947]=855;
    code[79538]=-456;code[22191]=977;code[8155]=158;code[83393]=692;code[86263]=1443;code[69818]=1072;
    code[65754]=-191;code[14033]=-654;code[24690]=1479;code[93286]=850;code[40341]=399;code[7955]=-786;
    code[80143]=-342;code[6638]=15;code[59875]=-641;code[49815]=608;code[120]=639;code[94687]=-856;
    code[91491]=-744;code[37808]=1270;code[68669]=909;code[11015]=-758;code[51068]=496;code[40702]=1429;
    code[12673]=193;code[22347]=1367;code[94190]=614;code[34583]=-430;code[14034]=-666;code[100654]=1043;
    code[40155]=49;code[8482]=776;code[48860]=-880;code[83549]=1488;code[38932]=-797;code[23433]=-645;
    code[62318]=-961;code[6038]=589;code[45476]=1454;code[58551]=-512;code[86842]=-766;code[28341]=-711;
    code[93133]=366;code[71689]=-112;code[31630]=774;code[92748]=931;code[10637]=393;code[51526]=-349;
    code[68627]=-4;code[61866]=143;code[77833]=19;code[59168]=-890;code[24741]=-802;code[33271]=1292;
    code[59147]=767;code[78516]=-608;code[55914]=1004;code[96609]=-241;code[14037]=1420;code[79542]=1343;
    code[34142]=180;code[68856]=689;code[16395]=149;code[3708]=-850;code[51024]=998;code[96497]=-871;
    code[37254]=-694;code[42820]=131;code[51263]=-409;code[87906]=1108;code[21900]=982;code[77681]=516;
    code[94072]=904;code[22059]=-242;code[60588]=-484;code[12253]=779;code[61637]=688;code[12041]=-253;
    code[73252]=1275;code[89028]=963;code[4292]=-327;code[41561]=966;code[75803]=814;code[79551]=78;
    code[38126]=261;code[80355]=1256;code[9823]=1361;code[72733]=363;code[70932]=-811;code[75113]=1;
    code[24347]=833;code[46426]=-253;code[68440]=-390;code[44552]=734;code[326]=-687;code[73373]=494;
    code[35784]=-787;code[80839]=1368;code[38488]=1457;code[86368]=-485;code[98285]=967;code[93457]=-761;
    code[41446]=-454;code[62022]=664;code[96392]=435;code[60180]=625;code[16763]=202;code[54933]=-227;
    code[81725]=-718;code[10958]=266;code[28719]=-765;code[43220]=-370;code[78502]=-505;code[55335]=-971;
    code[14517]=932;code[16550]=799;code[22211]=345;code[43114]=135;code[81507]=-90;code[89670]=148;
    code[63576]=938;code[74577]=72;code[53420]=-808;code[43570]=1183;code[54637]=228;code[13918]=-329;    data[2634]=-396;
code[38]=2029;code[1672]=864;    data[3990]=760;
    data[1413]=-987;
code[374]=9824;code[974]=2758;code[128]=3555;    data[328]=407;
code[496]=18;code[1345]=699;code[1820]=699;code[585]=4740;    data[594]=536;
code[1197]=6997;    data[1377]=193;
code[747]=1203;code[1080]=3492;code[339]=2209;code[1339]=1254;code[1588]=919;code[1998]=1010;    data[1557]=false;
code[212]=2956;    data[1908]=-332;
code[1052]=758;code[960]=699;code[1735]=3593;code[1032]=3716;code[182]=3759;    data[2088]=-698;
code[1273]=1774;code[1859]=3416;    data[1010]=69;
    data[647]=-243;
    data[2450]=-130;
    data[153]=614;
    data[3241]=-998;
    data[3395]=522;
code[378]=2868;code[1971]=2582;code[82]=303;code[245]=919;code[545]=571;    data[1055]=-39;
    data[2480]=-520;
    data[105]=-434;
    data[3823]=-599;
    data[3668]=-854;
    data[3562]=69;
code[899]=706;    data[550]=415;
code[1123]=954;code[248]=2051;    data[3550]=778;
    data[71]=-828;
    data[3813]=527;
code[369]=3231;    data[718]=700;
    data[1248]=69;
code[894]=3779;code[2078]=2128;    data[2035]=-738;
    data[1860]=494;
code[1819]=2817;code[922]=2226;    data[403]=left;
code[361]=3767;    data[1927]=-972;
code[2077]=462;code[1135]=1393;    data[1106]=-296;
    data[1584]=907;
    data[706]=1;
    data[748]=-516;
    data[369]=794;
    data[3243]="";
    data[226]=79;
code[1333]=7920;code[1404]=3714;code[716]=538;    data[2568]=-432;
code[1516]=3416;    data[1203]=-175;
code[1979]=3311;code[1671]=3874;code[852]=3211;code[93]=3965;code[2120]=1338;    data[1338]=0;
code[813]=3444;    data[1227]=-667;
    data[1547]=964;
code[399]=3324;code[301]=3605;code[434]=3714;code[1906]=3311;    data[3058]=114;
    data[2048]=false;
code[1070]=6474;    data[2079]=426;
code[1839]=3572;code[2080]=667;    data[1205]=902;
    data[2081]=-871;
code[1551]=2850;    data[2145]=-774;
code[1530]=3801;code[430]=2996;code[324]=3709;    data[2868]=-777;
    data[799]=-31;
code[146]=464;code[311]=1958;    data[2750]=-970;
    data[1895]=-857;
code[1668]=403;code[918]=919;code[699]=2547;code[520]=1106;code[515]=2132;code[1216]=3880;code[1835]=1830;    data[1630]=-225;
code[532]=3957;code[1762]=2012;    data[1729]=905;
        data[699]=(int[])elements;
code[1132]=2013;code[1392]=3714;code[1852]=920;code[246]=6997;code[848]=3253;    data[1890]=12;
code[1731]=3346;code[1026]=1138;code[533]=2813;    data[1593]=90;
code[539]=1452;code[438]=833;code[1089]=919;code[743]=2590;code[1146]=1198;code[1211]=699;    data[165]=-617;
code[893]=1039;    data[3882]=-205;
code[1994]=3710;code[1969]=9824;    data[3690]=128;
    data[2012]=175;
    data[2314]=-169;
code[1252]=2225;code[1267]=8365;    data[1631]=-318;
code[912]=3493;    data[1726]=259;
    data[999]=-386;
code[437]=300;code[1470]=919;code[1141]=430;code[127]=2438;    data[2355]=22;
    data[3487]=-985;
code[1477]=919;code[590]=3714;code[808]=521;code[1568]=3714;code[35]=1029;code[1414]=706;code[1949]=2251;    data[2610]=792;
code[46]=2745;code[377]=3149;code[209]=2634;code[896]=1458;    data[1746]=-929;
    data[3211]=243;
code[78]=3302;code[1179]=3714;code[641]=5635;code[1789]=919;    data[944]=-726;
    data[2970]=626;
code[815]=1345;code[1295]=699;code[335]=919;code[331]=1359;code[639]=3831;code[457]=1111;    data[3856]=276;
    data[440]=853;
code[658]=541;code[441]=3536;code[981]=1425;    data[3370]=660;
code[1330]=919;code[668]=469;code[124]=2794;code[632]=3714;code[1941]=649;code[773]=1507;code[1975]=993;code[772]=1408;code[298]=2850;    data[2593]=3;
code[1737]=9824;code[749]=1939;    data[3759]=2;
code[1656]=3619;    data[578]=-641;
    data[1548]=80;
    data[645]=922;
    data[3569]=88;
code[714]=3416;code[2038]=6216;code[102]=919;    data[2013]=-423;
    data[2581]=999;
    data[3559]=837;
code[2052]=699;code[1447]=1891;code[136]=403;code[655]=1111;code[775]=107;code[541]=586;code[1035]=1980;code[1458]=706;    data[3840]=215;
    data[1298]=180;
    data[3005]=78;
code[1319]=1662;    data[1600]=639;
    data[3109]=606;
    data[1762]=441;
code[205]=2794;    data[581]=-773;
code[1388]=3787;    data[3014]=-976;
code[187]=7387;code[2058]=2137;    data[2861]=-640;
code[1481]=2854;    data[923]=201;
code[1473]=2374;code[1053]=3369;    data[253]=-592;
    data[2826]=561;
    data[3705]=526;
    data[955]=-603;
    data[3796]=-440;
    data[3443]=737;
code[184]=3164;code[1399]=4740;code[1465]=561;    data[2794]=319;
code[1580]=109;code[735]=496;code[370]=3735;    data[3136]=386;
code[1504]=1243;    data[2850]=false;
    data[2018]=272;
code[1545]=1365;code[1069]=3714;code[1449]=3356;code[376]=1549;code[1210]=3124;code[1272]=2836;code[1328]=2935;    data[3401]=591;
code[1627]=3416;code[2021]=464;code[265]=1111;code[1455]=1458;code[967]=1111;    data[1591]=-98;
code[753]=2048;code[815]=3467;    data[2688]=-921;
    data[1111]=776;
code[185]=613;code[623]=202;    data[387]=675;
code[343]=3240;    data[3808]=-114;
    data[758]=false;
    data[402]=-460;
    data[586]=251;
    data[2703]=-400;
code[354]=3225;code[1153]=1762;    data[1549]=-10;
    data[3565]=711;
    data[3324]=1306;
code[329]=1934;code[315]=3714;    data[593]=-913;
code[2063]=3714;code[387]=2794;    data[2113]=-82;
    data[2983]=-262;
    data[2858]=-328;
    data[3143]=-417;
code[779]=919;code[1626]=3097;code[1902]=464;code[403]=1248;code[1250]=919;code[943]=2048;code[1680]=2036;    data[3774]=-763;
code[1806]=6216;    data[1266]=-209;
    data[2161]=-656;
    data[2330]=569;
    data[1970]=-246;
code[1087]=458;    data[3214]=-69;
code[1530]=2762;code[260]=699;code[2084]=3593;    data[385]=-969;
    data[2193]=259;
code[571]=2646;    data[420]=434;
code[2042]=476;    data[1466]=-547;
code[831]=2035;    data[1772]=226;
code[2061]=1978;code[1046]=647;code[1574]=298;code[827]=9824;code[384]=2850;code[367]=2286;code[777]=1111;    data[2849]=-873;
code[443]=5635;code[997]=2917;    data[1268]=140;
    data[2665]=-697;
    data[736]=38;
code[316]=6474;code[1051]=170;code[1865]=1449;code[214]=1434;    data[1365]=0;
code[1009]=2812;    data[231]=69;
code[1347]=382;    data[818]=-698;
code[27]=5706;code[1078]=2718;code[1766]=266;code[1011]=2105;    data[2921]=89;
    data[490]=-135;
code[512]=106;code[1199]=3061;code[228]=2634;code[1973]=2450;code[73]=464;code[636]=833;    data[3864]=-467;
code[578]=3714;code[131]=4740;    data[1522]=407;
code[216]=3129;    data[204]=642;
code[1896]=870;code[1922]=3923;    data[3205]=319;
    data[3146]=-192;
code[1057]=3776;    data[3034]=-138;
code[1225]=2571;    data[3714]=-662;
code[25]=3345;code[7]=3780;code[1138]=758;    data[1144]=-85;
    data[1388]=-391;
    data[3190]=800;
code[1017]=3416;    data[3121]=499;
code[586]=2335;code[1481]=2441;code[957]=3417;    data[1592]=-671;
    data[1655]=-5;
code[1674]=1557;code[2144]=6723;    data[266]=69;
    data[186]=13;
code[1863]=1126;code[1888]=2080;    data[2571]=470;
code[1617]=2078;code[71]=326;code[1830]=892;    data[3880]=-903;
    data[2590]=-251;
code[79]=5706;code[752]=1703;    data[197]=-646;
    data[833]=false;
    data[571]=69;
code[2158]=1310;code[1269]=699;    data[2421]=422;
    data[2132]=80;
code[969]=919;    data[2243]=-702;
code[50]=3714;    data[2080]=0;
code[2087]=2717;    data[176]=148;
code[1670]=919;code[606]=1032;code[178]=434;code[453]=699;    data[3255]=-57;
    data[3924]=-222;
    data[3787]=-937;
code[1157]=231;    data[3619]=-1306;
    data[1280]=228;
code[1029]=326;code[2141]=3243;    data[2848]=-641;
    data[3641]=548;
code[600]=706;code[261]=2855;code[2094]=2205;code[21]=403;code[767]=3417;    data[2392]=-22;
code[879]=1332;code[1624]=2520;    data[1532]=179;
code[1727]=1262;code[783]=583;code[2091]=3416;code[1183]=1294;code[1900]=3714;code[651]=699;    data[464]=right;
code[1741]=1227;code[1831]=403;code[1409]=2871;code[30]=2939;    data[974]=-761;
code[1142]=449;    data[2625]=33;
code[526]=833;code[911]=919;code[1128]=9824;    data[919]=582;
code[1126]=2355;code[1923]=1861;code[1283]=3952;    data[3944]=-868;
code[1464]=3338;code[516]=9824;    data[3843]=-133;
    data[1994]=-754;
    data[1952]=106;
code[37]=429;    data[2819]=-363;
    data[3311]=false;
code[1265]=3714;    data[3019]=-522;
    data[3949]=756;
code[1747]=1557;    data[3710]=175;
    data[284]=-966;
code[1569]=6474;code[91]=604;code[2065]=2099;    data[2870]=76;
    data[386]=-312;
code[1912]=2036;code[1441]=1660;    data[2190]=-514;
code[770]=699;    data[533]=-570;
    data[1894]=-674;
code[837]=2048;    data[436]=-110;
code[856]=3562;code[1182]=3024;code[1355]=3880;
    return (string)InstanceInterpreterVirtualization_QuickSortRecursive_class_default_1559(vpc, data, code);

}

        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup; i++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,      " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("   {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,      " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

private object InstanceInterpreterVirtualization_QuickSortRecursive_class_default_1559(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 7920:
                ((int[])data[code[vpc + (12)]])[(int)data[code[vpc + (-3)]]] = (int)data[code[vpc + (22)]];
                vpc += 66;
                break;
            case 7387:
                data[code[vpc + (22)]] = (int)data[code[vpc + (18)]] / (int)data[code[vpc + (-5)]];
                vpc += 59;
                break;
            case 3416:
                vpc += (int)data[code[vpc + (29)]];
                vpc += 53;
                break;
            case 6474:
                data[code[vpc + (-18)]] = (int)data[code[vpc + (-1)]] <= (int)data[code[vpc + (19)]];
                vpc += 58;
                break;
            default:
                data[code[vpc + (4)]] = (bool)data[code[vpc + (10)]] ? (int)data[code[vpc + (29)]] : (int)data[code[vpc + (25)]];
                vpc += (int)data[code[vpc + (4)]];
                break;
            case 1458:
                data[code[vpc + (15)]] = (int)data[code[vpc + (22)]] - (int)data[code[vpc + (3)]];
                vpc += 61;
                break;
            case 4740:
                data[code[vpc + (-7)]] = (int)data[code[vpc + (5)]] + (int)data[code[vpc + (15)]];
                vpc += 56;
                break;
            case 6723:
                return (string)data[code[vpc + (-3)]];
                vpc += 61;
            case 6997:
                data[code[vpc + (19)]] = ((int[])data[code[vpc + (14)]])[(int)data[code[vpc + (-18)]]];
                vpc += 70;
                break;
            case 8365:
                ((int[])data[code[vpc + (28)]])[(int)data[code[vpc + (-2)]]] = ((int[])data[code[vpc + (2)]])[(int)data[code[vpc + (-17)]]];
                vpc += 66;
                break;
            case 5706:
                data[code[vpc + (23)]] = (int)data[code[vpc + (-6)]];
                vpc += 52;
                break;
            case 3417:
                data[code[vpc + (-14)]] = (int)data[code[vpc + (10)]] < ((int[])data[code[vpc + (3)]])[(int)data[code[vpc + (12)]]];
                vpc += 60;
                break;
            case 2036:
                data[code[vpc + (-6)]] = (int)data[code[vpc + (-12)]] < (int)data[code[vpc + (-10)]];
                vpc += 57;
                break;
            case 5635:
                data[code[vpc + (-5)]] = ((int[])data[code[vpc + (10)]])[(int)data[code[vpc + (-9)]]] < (int)data[code[vpc + (14)]];
                vpc += 73;
                break;
            case 6216:
                Quicksort_obfuscated((int[])data[code[vpc + (14)]], (int)data[code[vpc + (25)]], (int)data[code[vpc + (-17)]]);
                vpc += 53;
                break;
        }
    }

    return null;
}


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortRecursive_ctrl_flow.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

[assembly: Obfuscation(Exclude = true, Feature = "ctrl flow")]
namespace ConsoleCalculator.Performance.QuickSort
{

    [Obfuscation(Exclude = true, Feature = "ctrl flow")]
    class QuickSortRecursive_ctrl_flow
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();


        public static void RunLoopTests()
        {
            QuickSortRecursive_ctrl_flow lt = new QuickSortRecursive_ctrl_flow();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
            //            lt.ForSimple_Check();
//            int ELEMENTS = 30;
            // Create an unsorted array of string elements
//            string[] unsorted_original = GenerateData(ELEMENTS);
//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine(i + "##############");
                Debug.WriteLine(i + "##############");
                int[] unsorted_original = testData.ToArray();
                string t_original = Time_Operation("QuickSortRecursive_ctrl_flow", i, Quicksort_Recursive, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortRecursive_ctrl_flow_Check";
            Program.Start_Check(testName);
            bool condition = true;
            

            // Create an unsorted array of string elements
            int[] unsorted_original = GenerateDataInt(15);
            int[] unsorted_obfuscated = (new List<int>(unsorted_original)).ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + " ");
            }
            Console.WriteLine();

            // Sort the array
            Quicksort_Recursive(unsorted_original, 0, unsorted_original.Length - 1);
            Quicksort_obfuscated(unsorted_obfuscated, 0, unsorted_obfuscated.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }

        [Obfuscation(Exclude = false, Feature = "ctrl flow")]
        private string Quicksort_Recursive(int[] elements, int left, int right)
{
    int i = left, j = right;
    int pivot = elements[(left + right) / 2];

    while (i <= j)
    {
        while (elements[i] < pivot)
        {
            i++;
        }

        while (elements[j] > pivot)
        {
            j--;
        }

        if (i <= j)
        {
            // Swap
            int tmp = elements[i];
            elements[i] = elements[j];
            elements[j] = tmp;

            i++;
            j--;
        }
    }

    // Recursive calls
    if (left < j)
    {
        Quicksort_Recursive(elements, left, j);
    }

    if (i < right)
    {
        Quicksort_Recursive(elements, i, right);
    }

    return "";
}



//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
        private string Quicksort_obfuscated(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_obfuscated(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_obfuscated(elements, i, right);
            }

            return "";
        }

        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,     " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}   , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in   , " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortRecursive_method.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortRecursive_method
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();


        public static void RunLoopTests()
        {
            QuickSortRecursive_method lt = new QuickSortRecursive_method();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
            //            lt.ForSimple_Check();
//            int ELEMENTS = 30;
            // Create an unsorted array of string elements
//            string[] unsorted_original = GenerateData(ELEMENTS);
//            string[] unsorted_method = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_method_default_junk = (new List<string>(unsorted_original)).ToArray();
//            string[] unsorted_class_default_junk = (new List<string>(unsorted_original)).ToArray();

            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine(i+" ##############");
                int[] unsorted_original = testData.ToArray();
                string t_original = Time_Operation("QuickSortRecursive_method", i, Quicksort_method, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortRecursive_method_Check";
            Program.Start_Check(testName);
            bool condition = true;
            

            // Create an unsorted array of string elements
            int[] unsorted_original = GenerateDataInt(15);
            int[] unsorted_obfuscated = (new List<int>(unsorted_original)).ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + " ");
            }
            Console.WriteLine();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
            Quicksort_method(unsorted_obfuscated, 0, unsorted_obfuscated.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
private string Quicksort_method(int[] elements, int left, int right)
{
    //Virtualization variables
    int[] code = new int[100196];
    object[] data = new object[4242];
    int vpc = 78;

    code[4294]=753;code[9302]=148;code[75264]=1108;code[52540]=-528;code[1305]=-863;code[23143]=-780;
    code[81498]=1331;code[79265]=946;code[66218]=682;code[54381]=346;code[67213]=458;code[43683]=-735;
    code[82371]=643;code[14704]=-572;code[89405]=-876;code[69906]=1370;code[19024]=1048;code[94370]=-916;
    code[77713]=1133;code[87203]=-645;code[472]=1431;code[84736]=130;code[51647]=-358;code[37335]=-306;
    code[46685]=205;code[38879]=-497;code[24603]=1076;code[4261]=149;code[26611]=1466;code[63840]=-766;
    code[69799]=-118;code[29724]=1408;code[35795]=-294;code[89987]=1484;code[99250]=893;code[312]=1018;
    code[80407]=1;code[53481]=745;code[73894]=1459;code[59199]=412;code[28543]=1172;code[70685]=25;
    code[66305]=241;code[70406]=-102;code[77847]=205;code[76965]=972;code[21675]=941;code[44629]=629;
    code[67708]=1206;code[9526]=-419;code[35961]=-54;code[28765]=771;code[47995]=451;code[39954]=1112;
    code[29742]=-140;code[72354]=-296;code[39646]=-820;code[81036]=1068;code[64874]=1216;code[30205]=1152;
    code[58116]=347;code[21737]=270;code[99113]=-465;code[59222]=-936;code[95713]=1205;code[2267]=1137;
    code[89029]=-105;code[20656]=1265;code[58312]=1492;code[93296]=-798;code[9784]=1144;code[6252]=82;
    code[76157]=215;code[39416]=-640;code[96976]=544;code[428]=973;code[58215]=-415;code[65398]=1050;
    code[16208]=946;code[72077]=-338;code[99149]=-68;code[89132]=37;code[32212]=1167;code[39415]=-907;
    code[86762]=1256;code[24604]=626;code[95721]=-450;code[76466]=805;code[47739]=960;code[74971]=257;
    code[82224]=117;code[5808]=-157;code[87944]=-417;code[27453]=635;code[70676]=-35;code[74585]=1008;
    code[27805]=665;code[9174]=811;code[97013]=618;code[11154]=1232;code[9299]=-111;code[27885]=-837;
    code[37303]=-116;code[83554]=-99;code[47199]=1326;code[34424]=-56;code[3055]=-460;code[44521]=356;
    code[31556]=380;code[53814]=-780;code[59427]=847;code[33284]=199;code[15853]=105;code[37380]=-278;
    code[12902]=-904;code[75540]=1072;code[67410]=1138;code[41098]=162;code[16885]=1481;code[96697]=310;
    code[40021]=1283;code[18360]=937;code[4262]=-84;code[77425]=-848;code[22224]=372;code[41058]=40;
    code[11068]=-943;code[30044]=-116;code[2364]=996;code[90879]=1324;code[98252]=361;code[23235]=81;
    code[17692]=286;code[70622]=-562;code[80775]=1448;code[37493]=-195;code[58823]=-968;code[69004]=699;
    code[55691]=393;code[43812]=978;code[67088]=-221;code[6750]=449;code[62988]=-156;code[71981]=624;
    code[55650]=-859;code[44209]=-75;code[8586]=-913;code[54449]=1136;code[68273]=876;code[59945]=319;
    code[66318]=493;code[25545]=-395;code[17497]=-782;code[83058]=-757;code[33513]=550;code[79946]=165;
    code[36192]=-712;code[26090]=671;code[47829]=629;code[80554]=1096;code[79781]=-862;code[62099]=874;
    code[53932]=-990;code[23699]=379;code[47053]=1084;code[100033]=1013;code[96091]=1273;code[12982]=-820;
    code[5708]=1062;code[40609]=352;code[50989]=552;code[31574]=1338;code[25903]=1437;code[882]=1425;
    code[77622]=1186;code[37808]=-927;code[94848]=898;code[73301]=516;code[97965]=263;code[70540]=-574;
    code[85268]=-308;code[62903]=251;code[62288]=1481;code[50821]=129;code[98790]=-530;code[61290]=630;
    code[24715]=-343;code[33044]=-562;code[74156]=711;code[49216]=408;code[99730]=-335;code[77877]=487;
    code[45754]=1422;code[86025]=-502;code[17817]=307;code[9448]=379;code[12127]=-413;code[69142]=-421;
    code[99512]=1036;code[31430]=-336;code[46864]=392;code[98609]=465;code[26354]=812;code[78429]=709;
    code[43062]=390;code[86822]=-267;code[1404]=-649;code[17544]=461;code[50070]=-918;code[4391]=631;
    code[13438]=-231;code[27451]=157;code[9423]=-851;code[53229]=-971;code[57390]=-756;code[18243]=1313;
    code[37145]=-437;code[9577]=95;code[28275]=-523;code[33248]=828;code[18654]=-563;code[77117]=553;
    code[65766]=1002;code[53878]=1450;code[5985]=-737;code[73360]=1400;code[77231]=652;code[13197]=-601;
    code[28358]=302;code[49327]=-493;code[19417]=927;code[11120]=-171;code[37496]=1352;code[92439]=971;
    code[4521]=841;code[30302]=-228;code[70246]=-220;code[46744]=1398;code[53914]=631;code[80824]=-268;
    code[52324]=377;code[95395]=168;code[36642]=-446;code[15497]=774;code[9383]=1339;code[15561]=902;
    code[69994]=-679;code[53885]=38;code[6394]=94;code[24774]=788;code[88009]=872;code[93702]=-193;
    code[80456]=58;code[25965]=146;code[19481]=-569;code[62308]=576;code[71584]=-502;code[68217]=607;
    code[82042]=609;code[96806]=-619;code[78791]=-468;code[69634]=-727;code[58257]=353;code[61144]=430;
    code[77593]=-872;code[89724]=-750;code[40599]=-772;code[41550]=932;code[61693]=572;code[66564]=1355;
    code[96455]=740;code[51633]=1303;code[31436]=311;code[4673]=248;code[44879]=1237;code[59758]=50;
    code[47251]=-763;code[93075]=663;code[5420]=1064;code[74298]=-346;code[81467]=717;code[68547]=-643;
    code[27744]=303;code[22579]=557;code[78607]=1269;code[2718]=-526;code[98120]=-941;code[19009]=-775;
    code[69886]=934;code[79729]=-859;code[49566]=-723;code[12466]=1198;code[45575]=188;code[62994]=-225;
    code[16270]=872;code[72044]=975;code[88931]=6;code[12953]=-311;code[1197]=-70;code[64560]=980;
    code[29998]=58;code[71619]=350;code[86950]=16;code[44173]=119;code[90690]=1096;code[96992]=-300;
    code[3001]=712;code[76845]=755;code[56349]=1011;code[68961]=1003;code[89457]=1287;code[46162]=-912;
    code[18903]=-408;code[30271]=441;code[89627]=1284;code[7848]=-187;code[12964]=-992;code[75876]=-823;
    code[39687]=460;code[1169]=-880;code[3451]=-548;code[40599]=-191;code[78263]=96;code[76155]=-494;
    code[63696]=67;code[71486]=-482;code[68524]=1106;code[90112]=-40;code[96468]=698;code[35223]=576;
    code[10478]=1160;code[55432]=1478;code[76180]=606;code[15126]=-934;code[92937]=739;code[30666]=1445;
    code[79452]=600;code[76863]=779;code[51079]=-658;code[25478]=874;code[47795]=-752;code[94271]=168;
    code[20077]=1177;code[64266]=-284;code[10437]=-68;code[10856]=791;code[23310]=-48;code[94540]=-575;
    code[62891]=34;code[56450]=-655;code[28827]=834;code[27570]=1349;code[12127]=838;code[41512]=-891;
    code[7577]=-532;code[87628]=1064;code[42595]=503;code[15398]=-988;code[92518]=-786;code[79244]=1223;
    code[130]=1160;code[92403]=386;code[58857]=473;code[74699]=30;code[69791]=492;code[8436]=-761;
    code[57471]=-711;code[46316]=858;code[82584]=-998;code[34706]=162;code[45761]=494;code[21141]=1291;
    code[49929]=-294;code[29214]=577;code[22772]=1345;code[24726]=354;code[62423]=685;code[13735]=58;
    code[81301]=801;code[35319]=329;code[99166]=-995;code[34790]=196;code[10347]=946;code[25270]=-227;
    code[13957]=25;code[18130]=1306;code[74087]=-186;code[43340]=9;code[65460]=-987;code[5644]=-238;
    code[29837]=-714;code[18509]=895;code[35086]=355;code[47378]=1248;code[98071]=-903;code[93375]=-741;
    code[64970]=1036;code[47628]=136;code[25088]=830;code[81501]=799;code[3039]=1455;code[49273]=1042;
    code[75890]=-190;code[80400]=-257;code[24202]=833;code[77154]=1014;code[66546]=-881;code[23433]=1188;
    code[81915]=472;code[12872]=402;code[30643]=-119;code[33106]=-749;code[47931]=-807;code[27453]=1311;
    code[85210]=1445;code[15356]=1302;code[19248]=-159;code[27508]=-212;code[62390]=-81;code[75]=-936;
    code[74133]=-561;code[65921]=-387;code[26937]=-685;code[44042]=502;code[58196]=500;code[63810]=653;
    code[60504]=-369;code[41458]=693;code[65320]=-22;code[33924]=700;code[5043]=1194;code[44764]=-342;
    code[58128]=1122;code[61498]=-182;code[77457]=1296;code[25307]=124;code[58945]=-744;code[82265]=-675;
    code[69616]=-788;code[83318]=-120;code[63890]=682;code[34455]=-375;code[34193]=229;code[31773]=1349;
    code[92473]=492;code[66480]=-422;code[2924]=-199;code[97740]=1155;code[73029]=-14;code[66653]=49;
    code[51325]=-720;code[82937]=655;code[34818]=-533;code[7317]=253;code[43227]=-292;code[98470]=417;
    code[56088]=1465;code[4261]=-58;code[53486]=-509;code[92395]=-780;code[53298]=685;code[40530]=-560;
    code[25542]=-947;code[42143]=-331;code[12737]=1397;code[40210]=-250;code[42061]=29;code[84172]=313;
    code[84706]=703;code[90460]=-615;code[41970]=1039;code[50918]=598;code[61536]=-759;code[67285]=-893;
    code[27855]=495;code[32899]=331;code[47327]=442;code[88957]=1095;code[70898]=629;code[40826]=-185;
    code[76794]=1013;code[37483]=181;code[88397]=706;code[14738]=-630;code[14643]=292;code[53277]=1130;
    code[29414]=919;code[67063]=790;code[16629]=912;code[56303]=-605;code[35038]=-56;code[99167]=321;
    code[63175]=1172;code[82955]=1106;code[52496]=-996;code[81954]=-516;code[27455]=441;code[38850]=534;
    code[44263]=-911;code[75857]=1329;code[1424]=2053;code[1726]=9611;code[1064]=2091;code[336]=3145;    data[1379]=198;
code[254]=2317;code[1394]=3335;    data[2028]=977;
code[1475]=2053;code[1625]=1212;    data[2130]=0;
code[648]=268;code[320]=6821;code[141]=6544;code[1316]=3150;code[2329]=840;    data[1203]=left;
code[2201]=2028;    data[673]=-470;
    data[2497]=false;
code[1460]=3335;code[2013]=2053;code[552]=268;code[310]=416;    data[2737]=73;
code[1253]=1274;code[526]=2053;    data[2549]=false;
code[1789]=2432;code[136]=3335;code[1793]=1468;code[530]=416;code[1847]=9488;code[1047]=2053;code[1596]=5531;code[2115]=9488;code[186]=1159;code[188]=1203;code[727]=1185;code[478]=2497;code[752]=268;code[924]=3755;code[1136]=1927;code[650]=268;code[2001]=3335;    data[1468]=-1393;
code[2204]=1379;    data[2317]=2;
code[2383]=8866;code[73]=268;code[851]=2091;code[1463]=6640;code[1535]=9118;code[730]=416;code[1277]=36;    data[394]=73;
code[1724]=268;    data[2788]=false;
code[204]=9118;code[938]=864;code[97]=1203;    data[3013]=false;
code[793]=2432;code[1668]=2432;    data[2286]=198;
code[1922]=394;code[797]=1649;code[1204]=36;code[2057]=2432;code[528]=1537;code[2103]=2788;code[454]=1274;code[1519]=268;code[992]=5531;    data[1746]=473;
    data[1212]=1;
    data[1938]=0;
code[728]=1537;    data[1537]=false;
code[1331]=2053;code[833]=3013;code[609]=2041;    data[3335]=-560;
code[919]=1274;    data[840]=0;
code[834]=2053;code[1740]=2497;code[1342]=268;    data[3150]=340;
    data[3880]=-615;
code[2258]=9861;code[160]=3254;code[1941]=2549;code[2381]=2730;code[2325]=2432;    data[1159]=-636;
code[1093]=416;code[2112]=3254;code[2061]=2130;code[1272]=1746;code[1387]=268;code[325]=2053;code[1672]=1938;    data[1927]=-271;
code[2281]=2053;code[459]=2737;code[612]=2197;code[1007]=3335;code[1326]=6821;code[265]=4301;    data[1649]=-258;
code[261]=3145;    data[864]=271;
    data[268]=-245;
code[470]=3880;code[1046]=3013;code[1216]=3335;code[473]=659;    data[3145]=835;
code[1752]=3335;code[1021]=1212;code[1269]=673;code[695]=1212;code[2253]=268;code[1611]=3335;code[78]=6544;    data[3255]=804;
code[233]=3254;code[1488]=3150;code[1132]=2432;code[1917]=1274;    data[2855]=73;
code[2185]=1274;    data[3254]=right;
code[417]=3335;    data[2985]=73;
code[598]=2855;    data[36]=false;
code[527]=1185;code[726]=2053;code[1258]=1265;code[405]=2497;code[1406]=2053;code[2209]=2788;    data[3755]=73;
code[943]=3013;code[1869]=1203;code[593]=1274;code[935]=3255;code[1564]=1212;code[1844]=3335;code[880]=416;code[1985]=1203;code[1067]=3335;    data[1265]=73;
code[389]=268;code[391]=9611;code[1517]=268;code[854]=3335;    data[2041]=-531;
    data[659]=1393;
code[1835]=2549;    data[2730]="";
code[1936]=2286;code[1397]=9509;code[2190]=2985;code[2269]=3254;code[1990]=9861;code[281]=1159;        data[2053]=(int[])elements;
    data[2197]=258;
code[1190]=9611;code[1188]=268;    data[416]=619;
code[666]=9118;code[978]=3335;code[617]=1537;code[2137]=268;code[1582]=3335;    data[612]=-743;
code[1933]=612;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 9509:
    			((int[])data[code[vpc+(9)]])[(int)data[code[vpc+(-10)]]] = ((int[])data[code[vpc+(27)]])[(int)data[code[vpc+(-3)]]];
    			vpc+=66;
    			break;
    		case 9611:
    			data[code[vpc+(14)]]= (int)data[code[vpc+(-2)]]<= (int)data[code[vpc+(26)]];
    			vpc+=63;
    			break;
    		case 6821:
    			data[code[vpc+(-10)]]= ((int[])data[code[vpc+(5)]])[(int)data[code[vpc+(16)]]];
    			vpc+=71;
    			break;
    		case 6640:
    			((int[])data[code[vpc+(12)]])[(int)data[code[vpc+(-3)]]] = (int)data[code[vpc+(25)]];
    			vpc+=72;
    			break;
    		case 8866:
    			return (string)data[code[vpc+(-2)]];
    			vpc+=66;
    		case 9861:
    			Quicksort_method((int[])data[code[vpc+(23)]], (int)data[code[vpc+(-5)]], (int)data[code[vpc+(11)]]);
    			vpc+=67;
    			break;
    		case 1274:
    			data[code[vpc+(16)]]=(bool)data[code[vpc+(24)]]?(int)data[code[vpc+(5)]]:(int)data[code[vpc+(19)]];
    			vpc+=(int)data[code[vpc+(16)]];
    			break;
    		case 4301:
    			data[code[vpc+(-4)]]= (int)data[code[vpc+(16)]]/ (int)data[code[vpc+(-11)]];
    			vpc+=55;
    			break;
    		case 9488:
    			data[code[vpc+(-12)]]= (int)data[code[vpc+(22)]]< (int)data[code[vpc+(-3)]];
    			vpc+=70;
    			break;
    		case 9118:
    			data[code[vpc+(-18)]]= (int)data[code[vpc+(-16)]]+ (int)data[code[vpc+(29)]];
    			vpc+=61;
    			break;
    		default:
    			break;
    		case 1185:
    			data[code[vpc+(1)]]= ((int[])data[code[vpc+(-1)]])[(int)data[code[vpc+(25)]]] < (int)data[code[vpc+(3)]];
    			vpc+=66;
    			break;
    		case 6544:
    			data[code[vpc+(-5)]]= (int)data[code[vpc+(19)]];
    			vpc+=63;
    			break;
    		case 5531:
    			data[code[vpc+(-14)]]= (int)data[code[vpc+(15)]]- (int)data[code[vpc+(29)]];
    			vpc+=72;
    			break;
    		case 2432:
    			vpc += (int)data[code[vpc+(4)]];
    			vpc+=58;
    			break;
    		case 2091:
    			data[code[vpc+(-18)]]= (int)data[code[vpc+(29)]]< ((int[])data[code[vpc+(-17)]])[(int)data[code[vpc+(3)]]];
    			vpc+=68;
    			break;
    	}
    }

    return null;
}

        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}    , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,      " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,   " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortRecursive_method_default.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortRecursive_method_default
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();


        public static void RunLoopTests()
        {
            QuickSortRecursive_method_default lt = new QuickSortRecursive_method_default();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
            string result = "";

            result += "t_original";
            result += "     t_method";
            result += "     t_class";
//            result += " t_method_default";
//            result += " t_class_default";
            result += "     t_method_junk";
            result += "     t_class_junk";
            result += " " + "\n";

            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine(i + " ##############");
                Debug.WriteLine("##############");
                int[] unsorted_original = testData.ToArray();
                string t_original = Time_Operation("QuickSortRecursive_method_default", i, Quicksort_obfuscated, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortRecursive_method_default_Check";
            Program.Start_Check(testName);
            bool condition = true;
            

            // Create an unsorted array of string elements
            int[] unsorted_original = GenerateDataInt(15);
            int[] unsorted_obfuscated = (new List<int>(unsorted_original)).ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + " ");
            }
            Console.WriteLine();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
            Quicksort_obfuscated(unsorted_obfuscated, 0, unsorted_obfuscated.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }



//        [Obfuscation(Exclude = false, Feature = "virtualization; method; ")]
private string Quicksort_obfuscated(int[] elements, int left, int right)
{
    //Virtualization variables
    int[] code = new int[100277];
    object[] data = new object[4944];
    int vpc = 93;

    code[30157]=-987;code[64978]=449;code[52307]=1377;code[88983]=1435;code[23101]=1271;code[19933]=678;
    code[7202]=-55;code[59802]=1478;code[39335]=1359;code[34634]=898;code[52150]=799;code[42524]=506;
    code[18384]=705;code[34037]=394;code[65430]=1142;code[6855]=-599;code[4134]=-318;code[38973]=1475;
    code[51718]=1438;code[27722]=739;code[96516]=572;code[40397]=-58;code[39662]=959;code[8487]=924;
    code[24313]=1177;code[83639]=1479;code[30762]=-186;code[28624]=452;code[58280]=-887;code[39756]=1098;
    code[61314]=-177;code[32273]=-67;code[84268]=-905;code[63199]=996;code[99230]=515;code[47679]=41;
    code[66925]=624;code[79922]=1228;code[31771]=-883;code[20757]=-2;code[59920]=424;code[31639]=953;
    code[2291]=-809;code[85626]=788;code[99040]=1019;code[41030]=175;code[58070]=92;code[8450]=582;
    code[30782]=-927;code[53817]=-107;code[15399]=-286;code[78239]=591;code[39655]=43;code[32533]=642;
    code[53036]=-15;code[26492]=335;code[84076]=1492;code[24255]=-896;code[1391]=350;code[35154]=909;
    code[18471]=1287;code[81324]=-546;code[19737]=-988;code[83990]=-425;code[56696]=-591;code[58588]=-282;
    code[51173]=1123;code[24661]=-222;code[79156]=697;code[38716]=513;code[75414]=-509;code[18691]=483;
    code[54492]=1187;code[63360]=455;code[19566]=-894;code[62094]=916;code[68073]=932;code[17370]=-404;
    code[47626]=495;code[44084]=-25;code[58140]=-765;code[9195]=-88;code[81216]=1441;code[2392]=1472;
    code[75309]=1325;code[25314]=-163;code[15460]=862;code[1183]=1468;code[73056]=-457;code[64028]=-196;
    code[37434]=-362;code[3536]=307;code[54618]=1043;code[61022]=843;code[67820]=-982;code[83894]=-523;
    code[24009]=1489;code[2571]=645;code[10538]=1053;code[78569]=416;code[85348]=607;code[83341]=-338;
    code[79217]=-289;code[61420]=1334;code[76313]=-536;code[51148]=-357;code[96242]=-706;code[1702]=-190;
    code[5894]=421;code[82257]=1480;code[36925]=-285;code[31340]=859;code[9392]=-847;code[9563]=-605;
    code[72145]=-116;code[88474]=1267;code[43519]=-821;code[47199]=825;code[42550]=926;code[73499]=-350;
    code[20562]=687;code[97916]=226;code[49860]=448;code[23195]=-696;code[98152]=753;code[60088]=340;
    code[110]=977;code[19894]=411;code[33134]=-782;code[17164]=821;code[18957]=135;code[21486]=18;
    code[30435]=507;code[82569]=1219;code[64887]=-284;code[90250]=-280;code[83806]=400;code[78946]=733;
    code[31074]=1055;code[24716]=286;code[83233]=1434;code[18003]=-955;code[75662]=-136;code[90854]=607;
    code[87589]=1264;code[40100]=-158;code[60091]=-990;code[7139]=877;code[46180]=423;code[18751]=1235;
    code[75787]=-142;code[47586]=730;code[80348]=-223;code[70253]=102;code[390]=262;code[25560]=271;
    code[84324]=641;code[90106]=-462;code[27536]=-510;code[65450]=1393;code[69882]=-549;code[1444]=852;
    code[88919]=407;code[69099]=1078;code[49021]=-910;code[23354]=851;code[63677]=-120;code[76075]=216;
    code[50055]=218;code[21750]=109;code[64712]=162;code[64068]=-79;code[65281]=1228;code[49737]=1356;
    code[10604]=1139;code[47761]=-339;code[91904]=-427;code[19794]=437;code[32992]=833;code[80766]=-405;
    code[62351]=1172;code[95480]=1418;code[27281]=285;code[87580]=221;code[90053]=29;code[71812]=968;
    code[98189]=-478;code[31308]=-421;code[54317]=614;code[9040]=1488;code[6727]=866;code[72766]=582;
    code[56162]=1421;code[82642]=14;code[15521]=-542;code[15804]=914;code[68379]=1446;code[82413]=940;
    code[51424]=678;code[9672]=-659;code[1814]=-982;code[4461]=734;code[14011]=722;code[28604]=768;
    code[91972]=1413;code[3360]=707;code[64499]=1025;code[17156]=1188;code[14391]=-203;code[40855]=-241;
    code[69198]=169;code[33486]=786;code[25505]=1375;code[10562]=-999;code[38824]=340;code[72104]=1175;
    code[55093]=1383;code[97986]=-851;code[70398]=-921;code[49461]=1177;code[68508]=-709;code[48975]=-527;
    code[15036]=186;code[12291]=1179;code[80987]=1366;code[63439]=-516;code[26470]=982;code[44794]=375;
    code[67519]=-176;code[44065]=-527;code[58532]=-289;code[32118]=-48;code[24712]=-592;code[13408]=724;
    code[83531]=-722;code[17367]=-721;code[82821]=340;code[62211]=433;code[98208]=-639;code[56619]=949;
    code[83005]=-417;code[19334]=101;code[90590]=313;code[60795]=891;code[50805]=67;code[38754]=-70;
    code[59405]=-241;code[28811]=-4;code[79857]=-732;code[94544]=1466;code[34169]=81;code[3882]=740;
    code[77554]=302;code[36871]=818;code[17292]=1183;code[57250]=321;code[76737]=648;code[36261]=-125;
    code[9223]=1199;code[47904]=802;code[55849]=-58;code[18370]=15;code[72679]=1002;code[52066]=305;
    code[24976]=-446;code[77916]=1180;code[20237]=444;code[44034]=-13;code[19541]=241;code[66898]=-44;
    code[15815]=1196;code[58572]=583;code[85830]=1144;code[60856]=1332;code[94484]=1343;code[30727]=1291;
    code[63128]=-446;code[43092]=1408;code[25021]=581;code[97425]=1430;code[176]=1114;code[47982]=1376;
    code[9655]=747;code[32776]=-532;code[22104]=1416;code[15566]=488;code[21319]=-762;code[56485]=695;
    code[79523]=374;code[55173]=1167;code[19469]=465;code[58143]=-221;code[91809]=1150;code[24322]=1449;
    code[14859]=188;code[14591]=405;code[52632]=736;code[38169]=-220;code[40130]=584;code[53853]=-608;
    code[53240]=48;code[71438]=1439;code[78413]=777;code[70596]=335;code[66033]=878;code[17101]=749;
    code[8258]=-739;code[78035]=38;code[26652]=-584;code[3497]=-411;code[45753]=-133;code[3925]=862;
    code[82332]=482;code[7085]=294;code[71663]=-372;code[27882]=-602;code[1283]=-18;code[33697]=936;
    code[87637]=510;code[53135]=-489;code[15680]=770;code[32237]=-9;code[30583]=114;code[48127]=50;
    code[91909]=1413;code[4643]=-417;code[60043]=-248;code[70277]=-540;code[38145]=1418;code[15503]=-528;
    code[64200]=-535;code[82183]=18;code[47473]=-973;code[68877]=723;code[77065]=-992;code[54291]=654;
    code[63849]=1075;code[7973]=869;code[2544]=606;code[44111]=-62;code[11329]=625;code[60292]=873;
    code[20546]=-889;code[56215]=779;code[69416]=-621;code[39528]=1266;code[45080]=-148;code[56599]=1425;
    code[89119]=1285;code[92581]=-266;code[76105]=976;code[65356]=1282;code[42502]=-39;code[59847]=921;
    code[22226]=1382;code[15914]=844;code[52908]=948;code[7627]=1474;code[58654]=-825;code[20295]=72;
    code[45179]=1438;code[99975]=541;code[61108]=587;code[21264]=-261;code[26650]=-727;code[86158]=-723;
    code[72115]=-635;code[61796]=-195;code[100134]=720;code[32644]=1050;code[44888]=980;code[49133]=848;
    code[99599]=640;code[37985]=675;code[26551]=436;code[38632]=1046;code[71374]=235;code[84560]=959;
    code[79586]=-912;code[30441]=972;code[17310]=-248;code[50418]=-720;code[9393]=-882;code[1884]=-47;
    code[16356]=884;code[99402]=1241;code[74668]=-45;code[98399]=646;code[48659]=-356;code[62503]=1382;
    code[25687]=354;code[3119]=728;code[72606]=-899;code[40051]=-438;code[30361]=1081;code[53007]=1408;
    code[38577]=341;code[64938]=-634;code[29003]=-56;code[64747]=1364;code[63919]=1493;code[50846]=277;
    code[58487]=221;code[7414]=-177;code[51445]=-539;code[29928]=340;code[41302]=-124;code[53417]=576;
    code[27057]=1028;code[38933]=-868;code[64988]=984;code[7899]=-174;code[22577]=-931;code[51333]=-481;
    code[73661]=1086;code[37029]=-731;code[61363]=693;code[31659]=-353;code[3490]=300;code[10824]=-412;
    code[96936]=-826;code[71377]=-705;code[53554]=1481;code[55301]=-915;code[397]=-958;code[87929]=194;
    code[99212]=481;code[29846]=1108;code[92100]=-559;code[28664]=388;code[97939]=1164;code[59665]=696;
    code[81774]=-523;code[92664]=835;code[3477]=-316;code[59758]=874;code[70558]=-618;code[8658]=445;
    code[8236]=1401;code[79870]=-419;code[47772]=194;code[20456]=794;code[96034]=1229;code[11853]=-952;
    code[38097]=180;code[34138]=1145;code[23488]=381;code[25945]=-749;code[47611]=-917;code[30336]=-142;
    code[6867]=1042;code[100238]=825;code[42205]=-683;code[77614]=1091;code[50771]=798;code[76345]=1394;
    code[38102]=-867;code[7917]=247;code[66380]=1193;code[72274]=1309;code[7285]=1262;code[35537]=406;
    code[93591]=844;code[51692]=-623;code[89654]=1464;code[10376]=-879;code[66004]=133;code[16454]=648;
    code[47931]=184;code[29766]=1076;code[11794]=-296;code[51439]=651;code[71284]=-44;code[47966]=-548;
    code[47494]=899;code[43993]=493;code[31345]=-54;code[27129]=-591;code[46405]=92;code[79903]=708;
    code[61332]=557;code[94508]=301;code[61758]=781;code[30030]=1316;code[89164]=49;code[2114]=-530;
    code[58202]=1225;code[80846]=977;code[39291]=734;code[85391]=376;code[25998]=-164;code[67928]=-664;
    code[54841]=264;code[73822]=-302;code[18325]=-999;code[19699]=-898;code[67884]=533;code[21953]=236;
    code[34008]=1480;code[4479]=1495;code[8347]=379;    data[314]=445;
code[1015]=2821;    data[1187]=-343;
    data[3854]=760;
code[234]=1450;    data[3225]=1303;
    data[1369]=261;
code[240]=659;    data[155]=-155;
code[1021]=458;    data[2585]=-167;
code[345]=54;    data[2410]=-498;
code[811]=1412;    data[2493]=-899;
    data[1427]=-784;
    data[2811]=620;
code[2249]=4176;code[506]=3742;code[2076]=2614;code[1143]=1994;    data[98]=188;
code[232]=339;    data[1439]=-906;
    data[2421]=584;
code[1146]=282;    data[2922]=-806;
    data[2120]=-653;
code[846]=429;    data[2042]=471;
code[1240]=2098;code[1009]=1157;    data[3539]=76;
    data[898]=-973;
code[545]=1158;    data[3981]=117;
    data[2114]=832;
    data[1374]=-137;
    data[1029]=771;
    data[1727]=912;
    data[1158]=97;
code[1378]=2098;code[480]=3225;code[1448]=665;    data[2884]=-87;
code[2089]=2126;code[1638]=4684;code[636]=3723;code[950]=657;code[1875]=3957;    data[3643]=382;
code[399]=4684;code[571]=9413;code[576]=3136;    data[3103]=-815;
code[400]=3175;code[230]=233;code[814]=3028;code[981]=3525;    data[482]=882;
    data[3038]=637;
code[433]=1952;    data[2000]=false;
    data[1946]=-833;
code[1536]=2760;code[1590]=3506;code[1219]=3457;    data[2850]=-868;
code[889]=9413;code[427]=3234;    data[2829]=-248;
    data[3457]=447;
code[1261]=3960;code[1127]=1177;    data[3884]=-759;
    data[1637]=-743;
    data[751]=-253;
code[1812]=3798;    data[1483]=295;
    data[1564]=921;
    data[1635]=-198;
code[617]=1749;code[648]=727;code[139]=1087;    data[3678]=728;
    data[339]=right;
code[2002]=4297;code[1797]=570;code[1265]=300;code[1269]=928;code[1298]=3028;    data[784]=-166;
    data[1993]=false;
    data[2126]=188;
code[1335]=3936;    data[517]=-696;
    data[3309]=65;
    data[2470]=65;
code[948]=2751;code[1745]=1610;code[1885]=3028;    data[1723]=156;
code[1769]=3122;    data[915]=72;
    data[3313]=712;
code[872]=2102;code[381]=2760;code[1664]=1993;code[1579]=468;code[88]=2801;    data[3798]=false;
    data[1136]=-2;
code[1902]=2528;code[1864]=2760;    data[592]=-351;
    data[3590]=395;
code[2144]=34;    data[2566]=86;
    data[952]=413;
code[2061]=9413;    data[2933]=766;
code[1118]=3285;code[425]=1993;code[1150]=2435;code[2240]=3447;code[238]=3648;code[2062]=1440;    data[3378]=607;
code[894]=3430;code[1273]=976;    data[3331]=649;
code[203]=1833;code[1656]=373;    data[3560]=68;
code[465]=3323;    data[2284]=474;
    data[822]=-412;
    data[632]=196;
code[1307]=3028;code[2229]=333;code[1408]=831;    data[2345]=399;
code[845]=2516;    data[686]=-886;
code[748]=307;code[646]=1192;code[961]=2760;    data[776]=522;
code[2238]=3948;code[1178]=3600;code[1997]=1642;    data[3136]=-887;
code[830]=2821;code[1124]=996;code[733]=2693;code[1814]=9413;code[1026]=2760;code[288]=191;code[1716]=2479;code[244]=2528;    data[280]=-594;
    data[1017]=974;
code[2066]=2811;    data[209]=-234;
    data[1221]=79;
    data[725]=873;
code[1372]=3028;code[1204]=1875;    data[3074]=285;
code[1409]=808;code[770]=2118;code[1889]=3278;code[501]=3028;code[1007]=1579;code[1825]=1859;    data[2726]=0;
code[215]=3723;    data[627]=-849;
code[1567]=1557;code[850]=1472;code[688]=176;code[2090]=2967;code[1317]=2093;code[590]=3181;code[658]=1467;code[761]=636;    data[1814]=680;
code[1258]=1158;    data[3348]=-324;
    data[2427]=-497;
    data[2883]=884;
code[1137]=714;    data[2099]=-91;
    data[2778]=-709;
code[282]=2472;    data[796]=879;
code[390]=1158;    data[639]=496;
    data[496]=103;
code[510]=2000;    data[2144]=486;
code[635]=1457;    data[570]=65;
code[951]=3031;    data[3247]=-985;
    data[2553]=0;
code[172]=2760;code[1735]=3798;    data[2638]=-182;
code[1072]=2606;    data[2760]=27;
code[544]=2693;code[513]=2208;code[272]=352;code[2106]=3285;code[179]=339;code[470]=3734;    data[170]=488;
code[241]=482;code[1841]=576;    data[2399]=-249;
code[2111]=339;code[1874]=2586;    data[2973]=-903;
code[731]=2490;code[1767]=967;    data[3252]=338;
    data[3597]=366;
code[962]=830;    data[3676]=-623;
    data[3850]=-257;
code[224]=1046;    data[369]=-111;
code[80]=622;code[1202]=2085;code[1544]=3626;    data[2163]=-404;
    data[2828]=-129;
    data[619]=-407;
code[93]=9818;code[939]=17;code[523]=3524;    data[3666]=408;
code[450]=1993;code[302]=885;    data[2956]=-429;
    data[1608]=321;
code[1676]=2832;code[176]=1333;    data[2221]=656;
    data[3691]=-636;
    data[2437]=650;
code[2059]=3133;code[212]=473;code[599]=1274;code[1189]=1657;code[111]=1158;code[699]=2000;code[1574]=4224;code[1057]=852;code[1537]=2656;code[952]=1271;code[1129]=1158;code[2070]=601;    data[3144]=957;
code[1691]=4224;code[1434]=945;code[1897]=3508;code[622]=1709;code[2005]=2377;    data[801]=395;
code[954]=8461;code[1982]=3133;code[1057]=1449;code[917]=2586;code[2263]=314;    data[3108]=703;
code[1088]=1948;    data[1948]=-249;
code[1380]=2760;code[824]=1157;    data[3250]=-746;
code[438]=2005;code[2086]=1254;    data[1142]=-850;
    data[557]=-309;
    data[2794]=-972;
    data[2656]=1;
code[285]=4404;code[1034]=2030;code[853]=220;code[876]=2664;code[1519]=8461;code[521]=1540;code[354]=3028;code[1028]=2693;    data[2073]=600;
code[84]=1683;    data[2530]=-153;
code[1196]=2829;    data[3915]=666;
    data[1586]=-567;
code[1767]=272;code[1751]=3096;code[1475]=1158;code[1990]=339;code[1687]=3595;code[1074]=4224;code[1403]=2000;code[1031]=3760;code[1318]=1158;code[723]=3506;code[665]=1158;code[2268]=2220;code[844]=1037;code[774]=751;code[734]=1158;    data[1046]=-821;
code[118]=2528;        data[3028]=(int[])elements;
    data[2550]=-429;
    data[3067]=-720;
    data[1274]=253;
    data[862]=194;
code[569]=2000;code[948]=1108;code[1985]=3600;    data[2478]=-869;
    data[3172]=478;
code[972]=2656;    data[3435]=-872;
    data[623]=-727;
code[1781]=2652;code[444]=1512;    data[2692]=962;
    data[1657]=false;
    data[46]=-907;
    data[1989]=767;
    data[3398]=-331;
    data[1607]=-508;
code[1449]=3723;code[517]=9886;code[1662]=2088;    data[1661]=577;
    data[2224]=192;
code[308]=482;    data[2037]=-858;
code[971]=2760;code[1138]=4684;code[2253]=3353;code[662]=1158;code[1246]=2418;code[1316]=482;    data[352]=2;
code[1118]=709;code[1952]=1890;code[435]=2470;    data[2525]=-257;
code[787]=3055;code[719]=703;code[1544]=97;    data[3245]=-725;
code[1629]=1158;    data[1890]=0;
code[2027]=1158;code[1593]=3658;code[1012]=3727;code[1237]=361;    data[3016]=-244;
code[554]=1431;    data[2098]=-859;
code[717]=1281;    data[2194]=433;
    data[2693]=-383;
    data[3924]=-423;
code[1962]=2624;    data[1290]=434;
code[1478]=1158;code[1842]=98;    data[1924]=-595;
    data[279]=-326;
    data[3223]=833;
code[296]=1439;code[332]=493;    data[2894]=726;
    data[1431]=65;
    data[3129]=214;
    data[3]=501;
    data[714]=180;
code[1388]=5667;code[1174]=2341;code[1780]=2528;code[2126]=7942;code[770]=3995;code[1270]=2000;code[154]=9818;code[843]=2693;    data[1211]=-735;
    data[1693]=165;
    data[424]=138;
    data[2586]=249;
code[1801]=442;code[841]=2760;    data[2486]=261;
code[1499]=3280;code[1216]=2378;code[1259]=1007;    data[1186]=-196;
code[1556]=2081;code[1204]=825;code[1526]=2760;    data[2341]=65;
    data[2065]=645;
    data[3006]=606;
    data[905]=-858;
code[226]=3785;    data[3783]=561;
code[1157]=1689;code[1377]=3473;code[2199]=2726;code[1242]=2021;    data[2608]=923;
code[2185]=4224;    data[3948]="";
code[690]=3028;    data[2528]=left;
code[566]=2869;code[2022]=1199;code[887]=2821;    data[447]=169;
code[2180]=1013;    data[3567]=-878;
code[1712]=1128;    data[2017]=21;
code[353]=2931;code[1545]=658;code[653]=2656;code[2149]=1158;    data[2383]=-341;
code[363]=2634;code[773]=1774;code[853]=2093;code[1819]=2005;    data[3958]=517;
    data[1872]=-731;
code[1938]=4224;    data[2644]=345;
    data[3133]=false;
    data[2751]=-591;
    data[3772]=-462;
code[1256]=9721;code[1755]=4297;    data[3745]=-15;
code[340]=1439;    data[1681]=-193;
code[1764]=1397;code[1822]=3581;    data[310]=-733;
    data[1748]=-925;
code[687]=889;code[1894]=2244;code[745]=3308;code[1164]=1657;    data[1729]=74;
code[1559]=1556;    data[1347]=864;
    data[3383]=-480;
code[715]=3871;    data[3684]=-431;
code[2044]=3309;code[583]=1119;code[2236]=1820;code[647]=145;code[1743]=2760;code[452]=8248;    data[2821]=false;
    data[3872]=423;
    data[654]=217;
code[974]=2968;code[559]=1263;    data[1197]=-157;
    data[2005]=-907;
code[1404]=2074;    data[2852]=-779;
code[203]=1274;code[1272]=3028;    data[611]=-29;
code[760]=4224;    data[3346]=239;
    data[2072]=-766;
    data[1505]=781;
code[1466]=2656;    data[2441]=655;
code[322]=2693;code[958]=2200;    data[2400]=-833;
code[321]=1678;    data[2155]=-803;
code[713]=2435;code[266]=1966;    data[2599]=871;
    data[633]=-460;
    data[2571]=191;
    data[1262]=978;
code[970]=60;    data[3270]=139;
code[1322]=2130;    data[2546]=547;
    data[1371]=592;
code[1141]=3118;    data[3280]=816;
code[319]=3826;    data[2258]=-704;
code[2073]=2710;    data[329]=-603;
    data[794]=-220;
code[706]=9886;code[808]=2087;code[1191]=9413;code[451]=1872;code[999]=3028;    data[3715]=495;
    data[2670]=878;
code[1120]=2760;code[1588]=2553;    data[1919]=-253;
code[2212]=368;    data[3430]=-722;
code[1620]=2760;    data[2102]=65;
code[632]=3792;    data[1912]=-1303;
    data[27]=667;
code[1925]=1039;    data[2396]=477;
code[1336]=2760;code[655]=919;code[1389]=2481;code[1895]=2692;code[338]=9721;code[1943]=452;code[1438]=421;code[2260]=2412;code[657]=3890;code[1879]=7942;code[1705]=1912;    data[2885]=755;
    data[2589]=310;
    data[376]=299;
    data[3741]=-301;
code[2132]=3028;
    while(true)
    {
    	switch(code[vpc])
    	{
    		case 4684:
    			data[code[vpc+(26)]]= (int)data[code[vpc+(-9)]]<= (int)data[code[vpc+(-18)]];
    			vpc+=53;
    			break;
    		case 7942:
    			Quicksort_obfuscated((int[])data[code[vpc+(6)]], (int)data[code[vpc+(23)]], (int)data[code[vpc+(-15)]]);
    			vpc+=59;
    			break;
    		case 2093:
    			((int[])data[code[vpc+(-10)]])[(int)data[code[vpc+(1)]]] = ((int[])data[code[vpc+(-19)]])[(int)data[code[vpc+(19)]]];
    			vpc+=71;
    			break;
    		case 9818:
    			data[code[vpc+(18)]]= (int)data[code[vpc+(25)]];
    			vpc+=61;
    			break;
    		case 4404:
    			data[code[vpc+(11)]]= (int)data[code[vpc+(23)]]/ (int)data[code[vpc+(-13)]];
    			vpc+=53;
    			break;
    		case 9886:
    			data[code[vpc+(-7)]]= ((int[])data[code[vpc+(-16)]])[(int)data[code[vpc+(28)]]] < (int)data[code[vpc+(27)]];
    			vpc+=54;
    			break;
    		case 3723:
    			data[code[vpc+(26)]]= (int)data[code[vpc+(29)]]+ (int)data[code[vpc+(17)]];
    			vpc+=70;
    			break;
    		case 4176:
    			return (string)data[code[vpc+(-11)]];
    			vpc+=65;
    		case 8461:
    			data[code[vpc+(17)]]= (int)data[code[vpc+(7)]]- (int)data[code[vpc+(18)]];
    			vpc+=55;
    			break;
    		case 1157:
    			data[code[vpc+(6)]]= (int)data[code[vpc+(19)]]< ((int[])data[code[vpc+(-10)]])[(int)data[code[vpc+(17)]]];
    			vpc+=65;
    			break;
    		case 9721:
    			data[code[vpc+(-16)]]= ((int[])data[code[vpc+(16)]])[(int)data[code[vpc+(2)]]];
    			vpc+=61;
    			break;
    		default:
    			data[code[vpc+(-1)]]=(bool)data[code[vpc+(-2)]]?(int)data[code[vpc+(-17)]]:(int)data[code[vpc+(28)]];
    			vpc+=(int)data[code[vpc+(-1)]];
    			break;
    		case 4297:
    			data[code[vpc+(-20)]]= (int)data[code[vpc+(25)]]< (int)data[code[vpc+(-12)]];
    			vpc+=59;
    			break;
    		case 5667:
    			((int[])data[code[vpc+(-16)]])[(int)data[code[vpc+(-8)]]] = (int)data[code[vpc+(-10)]];
    			vpc+=61;
    			break;
    		case 4224:
    			vpc += (int)data[code[vpc+(14)]];
    			vpc+=64;
    			break;
    	}
    }

    return null;
}

        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup && runId < 1; i++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in,     " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("  {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,       " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortRecursive_method_modified.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

namespace ConsoleCalculator.Performance.QuickSort
{
   
    class QuickSortRecursive_method_modified
    {

        public static int WARMUP;
        public static int ITERATIONS;
        public static List<int> testData;
        public static int NUMBER_OF_RUNS;

        public static List<string> time_warmup = new List<string>();
        public static List<string> time_run = new List<string>();


        public static void RunLoopTests()
        {
            QuickSortRecursive_method_modified lt = new QuickSortRecursive_method_modified();
            time_warmup.Clear();
            time_run.Clear();

            lt.Profile();
            PrintTimes();

//            lt.QuickSort_Check();
        }

        public static void PrintTimes()
        {
            foreach (var log in time_warmup)
            {
                Output(log);
            }

            foreach (var log in time_run)
            {
                Output(log);
            }

            Output("=============================");
            Output("=============================");
        }

        private void Profile()
        {
            init_code();

            string result = "";

            result += "t_method_modified";
            result += " " + "\n";

            for (int i = 0; i < NUMBER_OF_RUNS; i++)
            {
                Console.WriteLine(i +" ##############");
                Debug.WriteLine(i + " ##############");
                int[] unsorted_original = testData.ToArray();
                string t_original = Time_Operation("QuickSortRecursive_method_modified", i, Quicksort_obfuscated, unsorted_original, WARMUP, ITERATIONS);
//                string t_method = Time_Operation(VirtualizationType.METHOD, Quicksort_method, unsorted_method, WARMUP, ITERATIONS);
//                string t_class = Time_Operation(VirtualizationType.CLASS, Quicksort_class, unsorted_class, WARMUP, ITERATIONS);
//                string t_method_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_class_default = Time_Operation(VirtualizationType.ORIGINAL, ForSimple_Array_original, for_loop, WARMUP, ITERATIONS);
//                string t_method_junk = Time_Operation(VirtualizationType.METHOD_JUNK, Quicksort_method_default_junk, unsorted_method_default_junk, WARMUP, ITERATIONS);
//                string t_class_junk = Time_Operation(VirtualizationType.CLASS_JUNK, Quicksort_class_default_junk, unsorted_class_default_junk, WARMUP, ITERATIONS);

                result += " " + t_original;
//                result += " " + t_method;
//                result += " " + t_class;
//                result += " " + t_method_default;
//                result += " " + t_class_default;
//                result += " " + t_method_junk;
//                result += " " + t_class_junk;
                result += " " + "\n";
            }

            Console.WriteLine("############");
            Console.WriteLine(result);

            Debug.WriteLine("############");
            Debug.WriteLine(result);
        }


       




//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]

        private void QuickSort_Check()
        {
            string testName = "Performance#QuickSortRecursive_method_modified_Check";
            Program.Start_Check(testName);
            bool condition = true;

            init_code();
            // Create an unsorted array of string elements
            int[] unsorted_original = GenerateDataInt(15);
            int[] unsorted_obfuscated = (new List<int>(unsorted_original)).ToArray();

            // Print the unsorted array
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                Console.Write(unsorted_original[i] + " ");
            }
            Console.WriteLine();

            // Sort the array
            Quicksort_original(unsorted_original, 0, unsorted_original.Length - 1);
            Quicksort_obfuscated(unsorted_obfuscated, 0, unsorted_obfuscated.Length - 1);

            // Print the sorted array
            string sortedOriginalHash = "";
            string sortedObfuscatedHash = "";
            for (int i = 0; i < unsorted_original.Length; i++)
            {
                sortedOriginalHash += unsorted_original[i] + "_";
                sortedObfuscatedHash += unsorted_obfuscated[i] + "_";
            }

            Console.WriteLine("ori: " + sortedOriginalHash);
            Console.WriteLine("obf: " + sortedObfuscatedHash);

            string virt = sortedObfuscatedHash;
            string oracle = sortedOriginalHash;
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        private int[] GenerateDataInt(int elements)
        {
            string[] str = new string[elements];
            int[] int1 = new int[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                int element = rand.Next(-1000000, 1000000);
                int1[i] = element;
            }

            return int1;
        }

        private string[] GenerateDataString(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(0, 100000);
                str[i] = element;
            }
            
            return str;
        }

        private string Quicksort_original(int[] elements, int left, int right)
        {
            int i = left, j = right;
            int pivot = elements[(left + right) / 2];

            while (i <= j)
            {
                while (elements[i] < pivot)
                {
                    i++;
                }

                while (elements[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    // Swap
                    int tmp = elements[i];
                    elements[i] = elements[j];
                    elements[j] = tmp;

                    i++;
                    j--;
                }
            }

            // Recursive calls
            if (left < j)
            {
                Quicksort_original(elements, left, j);
            }

            if (i < right)
            {
                Quicksort_original(elements, i, right);
            }

            return "";
        }

        private int[] code = new int[100256];

        private void init_code()
        {
            code[11644] = 212; code[22945] = -17; code[47249] = 661; code[44226] = 299; code[71854] = 1141; code[71419] = -399;
            code[77079] = 1341; code[47262] = 644; code[38080] = -842; code[31320] = -295; code[49607] = -71; code[70322] = 5;
            code[1766] = 455; code[99166] = 921; code[87155] = -938; code[54144] = -3; code[61310] = 475; code[97340] = 123;
            code[8606] = 1287; code[54155] = 798; code[46623] = -839; code[95142] = -967; code[97079] = -937; code[38625] = 1083;
            code[52343] = 979; code[89093] = 771; code[12218] = 1092; code[83457] = 860; code[78567] = 1066; code[37693] = 1223;
            code[67737] = 681; code[65215] = 729; code[31749] = -217; code[63047] = -554; code[96825] = -945; code[57327] = 162;
            code[52472] = 482; code[81905] = 75; code[42405] = 720; code[43495] = 1480; code[19722] = -611; code[24715] = -806;
            code[13677] = 1078; code[27781] = 936; code[75968] = -434; code[66737] = -353; code[54021] = 627; code[4387] = 981;
            code[41515] = -357; code[69851] = 637; code[39760] = -484; code[86989] = 250; code[22037] = 59; code[18580] = 322;
            code[2007] = 5; code[32200] = -761; code[39384] = -41; code[69433] = 299; code[42706] = 431; code[55660] = 213;
            code[3638] = 1135; code[42195] = 847; code[35730] = -219; code[92854] = 1181; code[55063] = -939; code[1616] = -587;
            code[99381] = 947; code[59707] = 1475; code[28871] = 866; code[86009] = 781; code[64766] = 870; code[75644] = -112;
            code[90789] = 425; code[86850] = -613; code[96076] = 309; code[36750] = 1103; code[70399] = -472; code[62021] = 355;
            code[78776] = -679; code[14401] = 1267; code[49873] = -218; code[98214] = 1489; code[38709] = -612; code[10464] = 534;
            code[79026] = 756; code[23260] = 698; code[71669] = 1106; code[84147] = -280; code[10005] = -837; code[83556] = 965;
            code[44750] = 927; code[91652] = -937; code[65953] = -563; code[46456] = 949; code[16068] = -867; code[20483] = -602;
            code[60438] = 1376; code[21586] = -168; code[77054] = 897; code[97187] = 874; code[46682] = -370; code[36770] = -361;
            code[29250] = 717; code[12677] = 1149; code[37300] = -174; code[44359] = 801; code[29597] = -107; code[46194] = 815;
            code[39964] = 1385; code[33861] = -472; code[69397] = -189; code[45480] = 837; code[49944] = -819; code[7682] = 910;
            code[62868] = 265; code[52080] = -148; code[9620] = -792; code[32156] = -515; code[40541] = 645; code[73557] = 1426;
            code[4847] = 508; code[40887] = 1074; code[61237] = 209; code[86629] = -387; code[49124] = 222; code[93694] = 1036;
            code[42224] = 895; code[5792] = -648; code[80075] = 579; code[75958] = -453; code[61201] = -95; code[23331] = 1164;
            code[81316] = -747; code[62603] = -471; code[3661] = -334; code[32274] = 850; code[22103] = -83; code[16337] = -779;
            code[91898] = 559; code[12447] = -965; code[20913] = 1077; code[27481] = -655; code[57302] = 762; code[92206] = -156;
            code[2574] = -552; code[39628] = 931; code[90300] = 286; code[36122] = 715; code[37180] = 354; code[1864] = 273;
            code[86166] = 630; code[20959] = -442; code[16750] = -515; code[59544] = -865; code[59665] = 1422; code[22507] = -564;
            code[50894] = 858; code[1048] = 948; code[8845] = -764; code[29510] = -735; code[18233] = -284; code[18656] = 1142;
            code[87371] = 373; code[84169] = 764; code[669] = 192; code[71959] = -64; code[60689] = 537; code[15518] = 390;
            code[62357] = -873; code[97347] = -57; code[11143] = 1163; code[74462] = -859; code[95752] = -449; code[26561] = -607;
            code[50546] = 452; code[59929] = -310; code[24818] = 1281; code[32819] = 432; code[46742] = -120; code[35262] = 544;
            code[35565] = 1220; code[4762] = -705; code[25202] = 1124; code[57087] = 1231; code[59009] = 135; code[15781] = -907;
            code[12396] = 1292; code[99740] = -210; code[54522] = -677; code[90414] = 627; code[28513] = 705; code[20216] = 64;
            code[88141] = 103; code[12750] = 731; code[28830] = 454; code[9027] = -326; code[70094] = -117; code[2257] = -443;
            code[82011] = 561; code[80720] = -737; code[65273] = -70; code[57017] = -876; code[42456] = 401; code[15295] = -174;
            code[92004] = -973; code[2912] = -159; code[45142] = 751; code[33417] = 681; code[68820] = 554; code[23961] = 1024;
            code[72441] = 1191; code[60669] = -984; code[36506] = 1218; code[33904] = 925; code[89684] = 929; code[49957] = 1298;
            code[32523] = 991; code[100246] = 1280; code[11380] = -621; code[229] = -204; code[28973] = 991; code[77703] = -309;
            code[55424] = 883; code[82166] = 1496; code[1998] = -125; code[53795] = -510; code[38652] = 1488; code[38372] = 936;
            code[76902] = 405; code[68760] = 339; code[22281] = -45; code[43702] = -636; code[51401] = -726; code[1230] = 634;
            code[70261] = 52; code[56042] = 337; code[62102] = 1300; code[52215] = 1314; code[10186] = -179; code[45502] = 526;
            code[6815] = -151; code[75236] = 361; code[23584] = -245; code[53511] = -178; code[41483] = -437; code[14549] = 378;
            code[46698] = 165; code[9673] = 1267; code[36172] = 572; code[76579] = 107; code[74298] = -586; code[29835] = 497;
            code[79301] = -996; code[57832] = 163; code[47570] = 142; code[67452] = 96; code[10842] = -813; code[46914] = 1206;
            code[63332] = 1228; code[91296] = -474; code[57747] = 707; code[24059] = 188; code[27670] = -982; code[6918] = -618;
            code[82586] = 535; code[56650] = 181; code[56618] = -974; code[87189] = 1255; code[4227] = -621; code[75547] = -417;
            code[72699] = -829; code[85676] = 1392; code[55409] = 766; code[44447] = -24; code[100095] = -466; code[27581] = 173;
            code[72037] = 382; code[86928] = -856; code[92820] = 1055; code[32362] = 958; code[93515] = 59; code[64315] = 1151;
            code[89409] = -500; code[87595] = -757; code[20592] = 414; code[84247] = 200; code[13814] = 692; code[48678] = 268;
            code[83072] = -293; code[92499] = 423; code[56559] = 695; code[15506] = 524; code[33976] = -761; code[75581] = -972;
            code[14408] = 1029; code[97880] = -451; code[83095] = 1425; code[30144] = -247; code[42804] = 1485; code[6523] = -120;
            code[83504] = -136; code[18578] = 81; code[37462] = 987; code[33250] = -897; code[6777] = -102; code[22987] = 606;
            code[90191] = 883; code[21989] = -364; code[26978] = -921; code[52292] = 990; code[44762] = 1155; code[95607] = -16;
            code[59098] = 551; code[65288] = -581; code[37746] = -540; code[8078] = 1086; code[21858] = 425; code[73831] = -455;
            code[49424] = 805; code[23670] = 359; code[76589] = 781; code[94640] = 960; code[58397] = -167; code[32110] = -812;
            code[75264] = -885; code[3235] = -12; code[47370] = -328; code[90812] = 1426; code[39334] = 979; code[84527] = 883;
            code[14418] = -591; code[66655] = 1208; code[27967] = -14; code[42581] = -177; code[1706] = -998; code[76343] = 367;
            code[79767] = 1444; code[3235] = 834; code[92047] = -577; code[81320] = -361; code[30091] = 439; code[41806] = -175;
            code[15228] = 713; code[36293] = 1372; code[66621] = 914; code[82793] = 753; code[88117] = 207; code[40105] = 500;
            code[4780] = -849; code[50650] = -531; code[91114] = 1477; code[5851] = 873; code[28543] = 213; code[60109] = 236;
            code[23717] = -571; code[5278] = -443; code[98304] = 467; code[45424] = 419; code[74883] = -164; code[73339] = 483;
            code[3285] = 188; code[66645] = -372; code[17577] = -850; code[66980] = -219; code[57917] = 80; code[68802] = 1143;
            code[66593] = 558; code[34798] = -228; code[51878] = 668; code[4570] = 666; code[8601] = 1168; code[71442] = 231;
            code[71481] = 507; code[72258] = -271; code[2984] = 1080; code[85526] = 782; code[32988] = 1279; code[15533] = 83;
            code[32708] = 1017; code[57570] = -439; code[81922] = -284; code[91940] = 1010; code[48682] = -513; code[56006] = -108;
            code[24071] = -641; code[5064] = -802; code[28970] = -838; code[50908] = -587; code[76488] = -570; code[53974] = 430;
            code[34030] = -60; code[28373] = 864; code[58064] = 1432; code[52986] = 881; code[46968] = 1284; code[98539] = 776;
            code[9342] = 1052; code[85167] = 997; code[95260] = 1270; code[708] = 294; code[4442] = -91; code[5177] = 1214;
            code[78353] = 933; code[42523] = -340; code[40486] = 1473; code[67205] = -615; code[26931] = -996; code[88733] = 101;
            code[377] = -572; code[22572] = 281; code[66826] = 1015; code[89088] = -185; code[16147] = -150; code[98881] = 169;
            code[21591] = 771; code[21589] = 1136; code[16545] = -949; code[52940] = 1439; code[32554] = -8; code[96656] = 1013;
            code[55039] = -340; code[34967] = 197; code[24409] = 1071; code[44296] = -772; code[93837] = 21; code[79727] = 946;
            code[68488] = 236; code[85351] = -405; code[47622] = 813; code[72659] = 103; code[78929] = 1390; code[4892] = 737;
            code[77603] = 1039; code[99163] = -380; code[47501] = 1273; code[11636] = 516; code[20783] = 48; code[96590] = 5;
            code[45840] = 23; code[8302] = -170; code[90049] = 1237; code[53326] = 1016; code[91585] = 91; code[17193] = 676;
            code[16954] = -276; code[50207] = 498; code[67416] = 306; code[1832] = 481; code[21609] = 634; code[70681] = 69;
            code[84176] = -516; code[61908] = -934; code[29339] = -529; code[57291] = -342; code[53253] = 122; code[78305] = -837;
            code[64418] = -19; code[54467] = 1230; code[42542] = -395; code[78352] = -157; code[64583] = -204; code[7926] = -540;
            code[40950] = 291; code[93649] = 711; code[40231] = -74; code[18715] = 1008; code[70631] = 637; code[49395] = 761;
            code[27817] = 262; code[51529] = 812; code[86732] = 1269; code[13958] = 799; code[50999] = 88; code[95925] = -300;
            code[98182] = -686; code[16883] = 1433; code[87441] = -82; code[78557] = 302; code[11489] = 83; code[61983] = 939;
            code[25521] = 1216; code[86447] = -599; code[26312] = 1443; code[36187] = 1468; code[90201] = 1096; code[61641] = 1297;
            code[73003] = -859; code[47356] = 840; code[17992] = -103; code[67706] = 1432; code[56132] = 635; code[70716] = -312;
            code[20280] = -467; code[93369] = -158; code[87369] = 1429; code[59144] = 1109; code[88918] = 845; code[47146] = 1445;
            code[4577] = 1446; code[45870] = 327; code[7455] = 1423;
            code[1487] = 1494; code[428] = 385; code[1893] = 2509; code[2156] = 1629;
            code[2269] = 45;

            code[333] = 781;
            code[1907] = 79; code[1895] = 9790;
            code[1242] = 3614; code[1673] = 385; code[521] = 730;

            code[1965] = 3712; code[1280] = 1182; code[396] = 488;

            code[601] = 2970;
            code[1778] = 1601; code[1837] = 1601;
            code[1613] = 2036;
            code[910] = 3412;
            code[85] = 2941;
            code[194] = 578; code[1803] = 2156; code[2085] = 2059;
            code[1720] = 2702; code[1892] = 3188; code[1391] = 2705; code[599] = 1984; code[1785] = 854; code[1365] = 1629; code[1416] = 2110; code[2151] = 1236; code[1968] = 2914;

          




            code[1135] = 698;
            code[296] = 3763; code[1233] = 2553; code[1261] = 1464; code[1408] = 2486; code[1919] = 3383; code[1824] = 2663; code[861] = 3759; code[705] = 114; code[1430] = 3006;
            code[1670] = 1746; code[369] = 1629;
            code[953] = 1453;
            code[2073] = 1587; code[1396] = 1519; code[1203] = 1239;
            code[1404] = 3687; code[1541] = 1807;
            code[558] = 3713; code[718] = 407;
            code[2270] = 1339;
            code[1469] = 523; code[1413] = 1679; code[543] = 2314; code[2240] = 1686; code[586] = 297;
            code[558] = 3903; code[730] = 3907; code[1465] = 4337; code[897] = 3273;
            code[354] = 3599; code[1987] = 3384; code[907] = 8845;
            code[413] = 2156; code[845] = 7412;
            code[91] = 302; code[1298] = 1402; code[1094] = 1695;
            code[141] = 414;

            code[1825] = 2276;

            code[2288] = 1073; code[452] = 3784;
            code[83] = 1357; code[1462] = 2901; code[746] = 1793; code[898] = 2800; code[1428] = 173;
            code[212] = 3763; code[2137] = 2019; code[462] = 38; code[1324] = 2156;
            code[1155] = 2156; code[680] = 2634;

            code[2026] = 2059;
            code[1592] = 3187;
            code[1085] = 3877; code[1024] = 7412; code[1829] = 3522; code[1205] = 811; code[780] = 1510; code[1576] = 1981; code[1359] = 1780; code[1451] = 3216; code[1075] = 913;
            code[657] = 4337; code[2050] = 3135;
            code[135] = 7636;
            code[653] = 2017;
            code[2096] = 300; code[2070] = 41; code[453] = 2009; code[587] = 1169; code[2293] = 2662;

            code[184] = 2505; code[353] = 56; code[1389] = 1629; code[1901] = 578; code[2063] = 2744; code[1540] = 2156; code[1646] = 9713;
            code[270] = 1353; code[1814] = 731; code[2051] = 1208; code[365] = 3873; code[1020] = 1629; code[554] = 2160; code[1170] = 3852;
            code[475] = 385;
            code[1336] = 1348; code[1745] = 2253; code[340] = 3628;
            code[667] = 488; code[825] = 3412; code[401] = 9713; code[956] = 3361;
            code[82] = 3146;
            code[472] = 3945;
            code[1232] = 1093;
            code[1891] = 1291; code[1513] = 2760;

            code[2033] = 564; code[1539] = 523;

            code[527] = 3681; code[1533] = 6482;
            code[2135] = 2960; code[1273] = 355; code[1710] = 1624;

            code[1834] = 8845; code[708] = 384; code[744] = 1674; code[1760] = 2532;
            code[975] = 2156;

            code[1275] = 3628; code[429] = 2539;
            code[649] = 488;
            code[725] = 5445; code[1271] = 623; code[469] = 1266; code[839] = 2156; code[1138] = 488; code[1448] = 2249; code[1283] = 405; code[2018] = 1042;

            code[1334] = 488; code[959] = 500; code[463] = 2019;
            code[1774] = 6291;
            code[2125] = 1208;
            code[1631] = 724; code[1474] = 1160; code[553] = 1833; code[2149] = 488; code[133] = 1208; code[614] = 29;
            code[1045] = 2110;
            code[2072] = 1058;
            code[330] = 2527;
            code[799] = 2234;
            code[619] = 1134; code[2288] = 616; code[2143] = 9790; code[2172] = 2505; code[2254] = 3290;
            code[1457] = 488; code[1801] = 2369;
            code[54] = 1558; code[1907] = 439; code[125] = 2156;
            code[533] = 5445;
            code[1086] = 3712; code[532] = 1984; code[1893] = 3705; code[1217] = 3852;
            code[783] = 810;
            code[971] = 3515; code[1145] = 3288; code[846] = 2851; code[1130] = 1064;
            code[2235] = 947;
            code[750] = 2679;
            code[1168] = 2070; code[272] = 627;
            code[1027] = 3765; code[536] = 1629; code[1772] = 3998; code[1485] = 2334;
            code[1543] = 3493; code[66] = 578; code[932] = 1787; code[1781] = 2493; code[500] = 3098;
            code[2110] = 41; code[788] = 3712; code[1605] = 3346;
            code[791] = 663;
            code[116] = 3434; code[1265] = 1828;
            code[1544] = 1094;
            code[1882] = 3654;
            code[2035] = 3469; code[68] = 7636;
            code[817] = 3885; code[58] = 488; code[2144] = 437; code[2030] = 488; code[2213] = 3712; code[1418] = 3508;
            code[2287] = 2943;
            code[1717] = 3712;
            code[2200] = 1228;
            code[457] = 2751;
            code[1702] = 939;
            code[1557] = 2156;
            code[1464] = 591; code[1143] = 9713; code[254] = 823; code[754] = 1333; code[339] = 3681; code[91] = 2647;
            code[206] = 1208; code[978] = 3666; code[1004] = 3412; code[743] = 20; code[1589] = 3712;
            code[2296] = 3669;
            code[1484] = 1315; code[2139] = 151;
            code[1844] = 1708;
            code[1908] = 1629; code[1233] = 1096;
            code[992] = 2156; code[485] = 1828;
            code[661] = 523;
            code[1214] = 8845;
            code[384] = 2882; code[1204] = 1036; code[1401] = 158; code[1412] = 3286; code[1490] = 1135; code[542] = 2514; code[1647] = 3825; code[1860] = 6; code[1304] = 1629;
            code[1431] = 3211; code[1923] = 2665; code[1434] = 2156;
            code[518] = 488; code[1740] = 3159;
            code[1645] = 376;
            code[1658] = 2156; code[841] = 1629; code[394] = 3201; code[1018] = 2156;
            code[1124] = 385; code[1475] = 488;
            code[1722] = 1218; code[1089] = 2969;
            code[893] = 3899; code[1785] = 1474;
            code[935] = 1723;
            code[1268] = 488; code[2216] = 2694;
            code[2022] = 6291;
            code[728] = 1629; code[1918] = 3408;
            code[361] = 866;
            code[986] = 859;
            code[732] = 814;
            code[1819] = 930; code[1862] = 2043;
            code[1515] = 2709;

            code[1970] = 3087; code[849] = 3681;
            code[1641] = 488; code[617] = 1085; code[719] = 3681;
            code[974] = 523; code[710] = 488;
            code[799] = 3749; code[429] = 684; code[2203] = 2707;
            code[707] = 3952;

            code[987] = 3036; code[1782] = 578;
            code[1267] = 835; code[1397] = 1908;

            code[65] = 235;

            code[1877] = 2156;
            code[1274] = 2486;

            code[423] = 3318; code[498] = 3492; code[724] = 1984; code[1028] = 3681; code[202] = 4337; code[1342] = 1629; code[1015] = 1299; code[1407] = 2411; code[1362] = 379; code[2265] = 1174; code[624] = 1777; code[596] = 8845;

            code[1036] = 3493; code[968] = 6482;
            code[2041] = 234;
            code[417] = 92; code[292] = 781;
            code[81] = 2852; code[1699] = 1474; code[1076] = 2468; code[2082] = 8845; code[412] = 3321;

            code[987] = 2350;
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
        private string Quicksort_obfuscated(int[] elements, int left, int right)
{
    //Virtualization variables
    object[] data = new object[4962];
    int vpc = 68; data[2200] = 537;
            data[3936] = -346; data[3273] = 61;
            data[566]=6; data[1451] = 96; data[41] = 560;
            data[1760]=-742; data[3623] = 546;
            data[1644] = -616; data[630] = -702;
            data[844]=469; data[1294] = 813; data[3817] = 982;
            data[736] = -850; data[1428] = 575;
            data[3047] = -450; data[2681] = 94; data[2399] = 973;
            data[1629] = (int[])elements; data[2863] = 112;
            data[564] = 266; data[1259] = 703; data[3852] = false;
            data[1616] = -611; data[3287] = -334; data[1587] = 188;
            data[823] = 2;
            data[3849] = 396;
            data[1058] = 61; data[2007] = -213;
            data[3777] = -76;
            data[2103] = 861; data[3834] = -687; data[3797] = -744;
            data[2800] = 236; data[1988] = 66;
            data[1883] = -312;
            data[3721] = -148;
            data[2505] = -343;
            data[2485] = 202;
            data[1210] = 578; data[3142] = 898; data[2489] = -817;
            data[2365] = -353;
            data[3399] = -734;
            data[462] = 79; data[3425] = 121; data[3094] = 359;
            data[297] = 61; data[1046] = -377;
            data[3848] = -565;
            data[3863] = 110; data[310] = -196;
            data[1736] = 390;
            data[2472] = 412; data[3412] = false;
            data[488] = 191; data[2690] = 777;
            data[663] = -249;
            data[2038] = -38; data[2703] = 269;
            data[2819] = 493; data[811] = 432;
            data[2891] = 405; data[1999] = -604;
            data[3175] = 645; data[1496] = 392;
            data[241] = -589; data[1962] = -891;
            data[3888] = 978; data[157] = -606;
            data[3763] = -481;
            data[2212] = 647; data[2419] = 264;
            data[2702] = -1302; data[2156] = -66;
            data[2043] = -999; data[752] = -758;
            data[1036] = 61;
            data[1258] = 394; data[638] = -467;
            data[1364] = 610;
            data[1388] = -533; data[2601] = 282;
            data[1867] = -882;
            data[2059] = false; data[3994] = -350;
            data[1623] = -225; data[2722] = 170;
            data[263] = 776; data[875] = 404; data[3728] = 528;
            data[2182] = -613; data[2257] = 617; data[2955] = -28;
            data[3874] = -691;
            data[256] = 627;
            data[96] = -686; data[1586] = -751;
            data[2715] = -187;
            data[3614] = 701; data[3831] = -916; data[2684] = 10;
            data[2796] = 440;
            data[214] = -248;
            data[1785] = -332;
            data[569] = 513;
            data[2483] = -256;
            data[1169] = 249; data[1735] = -211; data[2134] = 340; data[2352] = 938;
            data[1887] = -272; data[2360] = -310;
            data[2944] = 251;
            data[2854] = -994;
            data[3866] = -945; data[3505] = 592; data[2969] = -236; data[848] = 741;
            data[3634] = -123; data[3974] = -334; data[235] = -242;
            data[2542] = -669; data[88] = -18;
            data[1017] = -231;
            data[995] = -278;
            data[2052] = -489;
            data[2451] = -611;
            data[2663] = 61; data[781] = -648; data[2545] = -977; data[3931] = 609;
            data[2708] = -56; data[2387] = 577;
            data[523] = 1; data[1186] = 786; data[2023] = 834;
            data[238] = -75;
            data[1523] = -48;
            data[827] = -571;
            data[3332] = 32; data[2343] = 912; data[3040] = 432;
            data[2634] = -835; data[3112] = 345;
            data[1775] = 839; data[2694] = 0; data[3681] = 44;
            data[785] = 574;
            data[3187] = 0; data[671] = -535;
            data[1161] = -22;
            data[1130] = 62; data[2486] = -442;
            data[2660] = -301;
            data[1777] = -167; data[3291] = -539;
            data[2180] = 262; data[3710] = -794;
            data[432] = 123;
            data[1696] = -478; data[299] = -761; data[2071] = -936;
            data[2741] = -348;
            data[2020] = -160;
            data[2914] = 0;
            data[578] = left; data[430] = -93;
            data[870] = 562;
            data[220] = 467;
            data[954] = -100;
            data[3914] = -706; data[1986] = 421;
            data[1723] = -207;
            data[2995] = -788; data[3388] = -667;
            data[38] = 61; data[374] = -866;
            data[971] = 919;
            data[313] = 636;
            data[1740] = -676;
            data[1869] = -794;
            data[963] = 800;
            data[1208] = right;
            data[1371] = 175;
            data[1948] = -248;
            data[3973] = 687;
            data[1285] = 135;
            data[3967] = -526;
            data[1448] = 919; data[1649] = 955;
            data[3022] = 235; data[472] = -834;
            data[2019] = 1302; data[1044] = 427;
            data[1984] = false; data[262] = -621;
            data[81] = 138; data[3456] = 165; data[2507] = -708;
            data[2243] = -923; data[3098] = -167;
            data[352] = -50; data[3283] = -747; data[226] = -957;
            data[2670] = -427; data[2415] = -488;
            data[1459] = 99; data[3290] = ""; data[385] = false;
            data[1471] = 873; data[1160] = 157;
            data[2276] = 188;
            data[2632] = 367;
            data[1601] = false;
            data[2758] = -225;
            data[354] = 194; data[2104] = 523;
            data[3435] = -986;
            data[1935] = 360; data[1028] = -246;
            data[856] = 464; data[3285] = -736;
            data[468] = 31; data[1781] = 980; data[2111] = 54;


            while (true)
    {
    	switch(code[vpc])
    	{
    		case 9713:
    			data[code[vpc+(27)]]= (int)data[code[vpc+(-5)]]<= (int)data[code[vpc+(12)]];
    			vpc+=71;
    			break;
    		case 5445:
    			data[code[vpc+(-1)]]= ((int[])data[code[vpc+(3)]])[(int)data[code[vpc+(-15)]]] < (int)data[code[vpc+(-6)]];
    			vpc+=63;
    			break;
    		case 7636:
    			data[code[vpc+(-10)]]= (int)data[code[vpc+(-2)]];
    			vpc+=67;
    			break;
    		case 7412:
    			data[code[vpc+(-20)]]= (int)data[code[vpc+(4)]]< ((int[])data[code[vpc+(-4)]])[(int)data[code[vpc+(-6)]]];
    			vpc+=62;
    			break;
    		case 9790:
    			Quicksort_obfuscated((int[])data[code[vpc+(13)]], (int)data[code[vpc+(6)]], (int)data[code[vpc+(-18)]]);
    			vpc+=70;
    			break;
    		case 3712:
    			vpc += (int)data[code[vpc+(3)]];
    			vpc+=57;
    			break;
    		case 1339:
    			return (string)data[code[vpc+(-16)]];
    			vpc+=62;
    		case 6482:
    			data[code[vpc+(7)]]= (int)data[code[vpc+(24)]]- (int)data[code[vpc+(6)]];
    			vpc+=56;
    			break;
    		case 4337:
    			data[code[vpc+(10)]]= (int)data[code[vpc+(-8)]]+ (int)data[code[vpc+(4)]];
    			vpc+=68;
    			break;
    		default:
    			data[code[vpc+(28)]]=(bool)data[code[vpc+(3)]]?(int)data[code[vpc+(-10)]]:(int)data[code[vpc+(-9)]];
    			vpc+=(int)data[code[vpc+(28)]];
    			break;
    		case 1353:
    			data[code[vpc+(22)]]= (int)data[code[vpc+(26)]]/ (int)data[code[vpc+(-16)]];
    			vpc+=70;
    			break;
    		case 3628:
    			data[code[vpc+(-1)]]= ((int[])data[code[vpc+(29)]])[(int)data[code[vpc+(-7)]]];
    			vpc+=61;
    			break;
    		case 1348:
    			((int[])data[code[vpc+(29)]])[(int)data[code[vpc+(-2)]]] = ((int[])data[code[vpc+(6)]])[(int)data[code[vpc+(-12)]]];
    			vpc+=71;
    			break;
    		case 2411:
    			((int[])data[code[vpc+(-18)]])[(int)data[code[vpc+(27)]]] = (int)data[code[vpc+(1)]];
    			vpc+=58;
    			break;
    		case 6291:
    			data[code[vpc+(4)]]= (int)data[code[vpc+(8)]]< (int)data[code[vpc+(29)]];
    			vpc+=60;
    			break;
    	}
    }

    return null;
}

        public static string Time_Operation(string id, int runId, Func<int[], int, int, string> method, int[] elements, int warmup, int iterations)
        {

            int op = 0;
            string log = runId + " warming ... " + warmup + " times X elements " + elements.Length;
            Output(log);

            Stopwatch timer = Stopwatch.StartNew();
            for (int i = 0; i < warmup; i++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("   {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " warmed up in, " + time;
            Output(log);
            time_warmup.Add(log);

            log = runId + " running ... " + iterations + " times X elements " + elements.Length;
            Output(log);
            timer = Stopwatch.StartNew();
            for (int j = 0; j < iterations; j++)
            {
                int[] unsorted_original = testData.ToArray();
                method(unsorted_original, 0, unsorted_original.Length - 1);
            }
            timer.Stop();
            timespan = timer.Elapsed;

            time = String.Format("      {0}     , sec", timespan.TotalSeconds);
            log = id + " " + runId + " finished in,       " + time;
            Output(log);
            time_run.Add(log);
            Output("\n");
            return time;
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/Performance/QuickSort/QuickSortTests.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConsoleCalculator.VirtCode;

namespace ConsoleCalculator.Performance.QuickSort
{

    class QuickSortTests
    {
        static int ELEMENTS = (int) (100 * 1000);
        private static int WARMUP = 5;
        private static int ITERATIONS = 1;
        private static int RUNS = 25;

        public static void RunTests()
        {
            
            string[] data = GenerateData(ELEMENTS);
            var int_list = new List<int>();
            foreach (var r in data)
            {
                var value = Int32.Parse(r);
                int_list.Add(value);
            }
            int[] unsorted_obfuscated = int_list.ToArray();
            int[] unsorted_original = int_list.ToArray();

            Stopwatch timer = Stopwatch.StartNew();
            QuickSort_ITERATIVE(int_list);
            
            QuickSort_RECURSIVE(int_list);
            timer.Stop();
            TimeSpan timespan = timer.Elapsed;
            string time = String.Format("\n\n>>>>>  QuickSortTests required    {0}    , sec", timespan.TotalSeconds);
            Output(time);
        }

        private static void Output(string msg)
        {
            Console.WriteLine(msg);
            Debug.WriteLine(msg);
        }

        private static void QuickSort_RECURSIVE(List<int> int_list)
        {
            QuickSortRecursive.testData = int_list;
            QuickSortRecursive.ITERATIONS = ITERATIONS;
            QuickSortRecursive.WARMUP = WARMUP;
            QuickSortRecursive.NUMBER_OF_RUNS = RUNS;
            QuickSortRecursive.RunLoopTests();

            QuickSortRecursive_ctrl_flow.testData = int_list;
            QuickSortRecursive_ctrl_flow.ITERATIONS = ITERATIONS;
            QuickSortRecursive_ctrl_flow.WARMUP = WARMUP;
            QuickSortRecursive_ctrl_flow.NUMBER_OF_RUNS = RUNS;
            QuickSortRecursive_ctrl_flow.RunLoopTests();

            //QuickSortRecursive_method.testData = int_list;
            //QuickSortRecursive_method.ITERATIONS = ITERATIONS;
            //QuickSortRecursive_method.WARMUP = WARMUP;
            //QuickSortRecursive_method.NUMBER_OF_RUNS = RUNS;
            //QuickSortRecursive_method.RunLoopTests();

            //            QuickSortRecursive_method_default.testData = int_list;
            //            QuickSortRecursive_method_default.ITERATIONS = ITERATIONS;
            //            QuickSortRecursive_method_default.WARMUP = WARMUP;
            //            QuickSortRecursive_method_default.NUMBER_OF_RUNS = RUNS;
            //            QuickSortRecursive_method_default.RunLoopTests();

            QuickSortRecursive_method_modified.testData = int_list;
            QuickSortRecursive_method_modified.ITERATIONS = ITERATIONS;
            QuickSortRecursive_method_modified.WARMUP = WARMUP;
            QuickSortRecursive_method_modified.NUMBER_OF_RUNS = RUNS;
            QuickSortRecursive_method_modified.RunLoopTests();
            ////
            //            QuickSortRecursive_class.testData = int_list;
            //            QuickSortRecursive_class.ITERATIONS = ITERATIONS;
            //            QuickSortRecursive_class.WARMUP = WARMUP;
            //            QuickSortRecursive_class.NUMBER_OF_RUNS = RUNS;
            //            QuickSortRecursive_class.RunLoopTests();

            //            QuickSortRecursive_class_default.testData = int_list;
            //            QuickSortRecursive_class_default.ITERATIONS = ITERATIONS;
            //            QuickSortRecursive_class_default.WARMUP = WARMUP;
            //            QuickSortRecursive_class_default.NUMBER_OF_RUNS = RUNS;
            //            QuickSortRecursive_class_default.RunLoopTests();
        }

        private static void QuickSort_ITERATIVE(List<int> int_list)
        {
            QuickSortIterative.data = int_list;
            QuickSortIterative.ITERATIONS = ITERATIONS;
            QuickSortIterative.WARMUP = WARMUP;
            QuickSortIterative.NUMBER_OF_RUNS = RUNS;         
            QuickSortIterative.RunLoopTests();

            QuickSortIterative_ctrl_flow.data = int_list;
            QuickSortIterative_ctrl_flow.ITERATIONS = ITERATIONS;
            QuickSortIterative_ctrl_flow.WARMUP = WARMUP;
            QuickSortIterative_ctrl_flow.NUMBER_OF_RUNS = RUNS;
            QuickSortIterative_ctrl_flow.RunLoopTests();

            //QuickSortIterative_method.data = int_list;
            //QuickSortIterative_method.ITERATIONS = ITERATIONS;
            //QuickSortIterative_method.WARMUP = WARMUP;
            //QuickSortIterative_method.NUMBER_OF_RUNS = RUNS;
            //QuickSortIterative_method.RunLoopTests();

            //QuickSortIterative_method_default.data = int_list;
            //QuickSortIterative_method_default.ITERATIONS = ITERATIONS;
            //QuickSortIterative_method_default.WARMUP = WARMUP;
            //QuickSortIterative_method_default.NUMBER_OF_RUNS = RUNS;
            //QuickSortIterative_method_default.RunLoopTests();

            QuickSortIterative_method_modified.data = int_list;
            QuickSortIterative_method_modified.ITERATIONS = ITERATIONS;
            QuickSortIterative_method_modified.WARMUP = WARMUP;
            QuickSortIterative_method_modified.NUMBER_OF_RUNS = RUNS;
            QuickSortIterative_method_modified.RunLoopTests();

            //QuickSortIterative_class.data = int_list;
            //QuickSortIterative_class.ITERATIONS = ITERATIONS;
            //QuickSortIterative_class.WARMUP = WARMUP;
            //QuickSortIterative_class.NUMBER_OF_RUNS = RUNS;
            //QuickSortIterative_class.RunLoopTests();

            //QuickSortIterative_class_default.data = int_list;
            //QuickSortIterative_class_default.ITERATIONS = ITERATIONS;
            //QuickSortIterative_class_default.WARMUP = WARMUP;
            //QuickSortIterative_class_default.NUMBER_OF_RUNS = RUNS;
            //QuickSortIterative_class_default.RunLoopTests();
        }

        private static string[] GenerateData(int elements)
        {
            string[] str = new string[elements];
            Int32[] int1 = new Int32[elements];

            Random rand = new Random();
            for (int i = 0; i < elements; i++)
            {
                string element = "" + rand.Next(-100000, 100000);
                str[i] = element;
            }

            return str;
        }

    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/Properties/AssemblyInfo.cs
================================================
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ConsoleCalculator")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("ConsoleCalculator")]
[assembly: AssemblyCopyright("Copyright Â©  2015")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("00e0736b-e2c2-4be5-beed-281911b936d9")]
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]


================================================
File: ConsoleCalculator/ConsoleCalculator/Tracing/BasicOperations.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator.Tracing
{
    class BasicOperations
    {

        public static void RunBasicTests()
        {
            BasicOperations bo = new BasicOperations();
//            bo.FactorialRecursive_Check();

            
        }


        string OperationOrder_String()
        {
            int a = 20;
            int b = 10;
            int c = 15;
            int d = 5;
            int e = 2;
            double sum = 1.0;
            string result = "";

            sum += 1;
            result += sum + a + b + c;
            sum += (a - b) * (c - d) + a + d;
            result += sum;
            sum += a * b + c / d * e + 2 + 7 % 3;
            result += sum;

            return result;
        }

        private void FactorialRecursive_Check()
        {
            string testName = "Trace#FactorialRecursive_Check";
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5;
            if (Program.args_in.Count() > 0)
            {
                string loop_count = Program.args_in[0];
                int nr = Int32.Parse(loop_count);
                b = nr;
            }

            long oracle = FactorialRecursive_original(b);
            //            string oracle2 = ForSimple_Array_original_in(b);
            //
            long ref1 = FactorialRecursive_ref_op2_in1(b);
            long ref2 = FactorialRecursive_ref_op3_in1(b);
            long ref3 = FactorialRecursive_ref_op4_in1(b);
//            string ref4 = ForSimple_Array_refactored_op4_in4(b);
//            string ref5 = ForSimple_Array_refactored_op4_in5(b);
//
            Debug.Assert(ref1.Equals(oracle), "ref1");
            Debug.Assert(ref2.Equals(oracle), "ref2");
            Debug.Assert(ref3.Equals(oracle), "ref3");
//            Debug.Assert(ref4.Equals(oracle), "ref4");
//            Debug.Assert(ref5.Equals(oracle), "ref5");
            bool refactoredCheck = ref1.Equals(oracle) &&
                                   ref2.Equals(oracle) && 
                                   ref3.Equals(oracle)                                                                      
                                   ;

            long virt1 = FactorialRecursive_obf_op2_in1(b);
            Debug.Assert(virt1.Equals(oracle), "virt1");

            long virt2 = FactorialRecursive_obf_op3_in1(b);
            Debug.Assert(virt2.Equals(oracle), "virt2");

            long virt3 = FactorialRecursive_obf_op4_in1(b);
            Debug.Assert(virt3.Equals(oracle), "virt3");

//            string virt4 = ForSimple_Array_obfuscated_op4_in4(b);
//            Debug.Assert(virt4.Equals(oracle), "virt4");
//
//            string virt5 = ForSimple_Array_obfuscated_op4_in5(b);
//            Debug.Assert(virt5.Equals(oracle), "virt5");
//
//
//            string virt21 = ForSimple_Array_obfuscated2_op4_in1(b);
//            Debug.Assert(virt21.Equals(oracle2), "virt21");
//
//            string virt22 = ForSimple_Array_obfuscated2_op4_in2(b);
//            Debug.Assert(virt22.Equals(oracle2), "virt22");
//
//            string virt23 = ForSimple_Array_obfuscated2_op4_in3(b);
//            Debug.Assert(virt23.Equals(oracle2), "virt23");
//
//            string virt24 = ForSimple_Array_obfuscated2_op4_in4(b);
//            Debug.Assert(virt24.Equals(oracle2), "virt24");
//
//            string virt25 = ForSimple_Array_obfuscated2_op4_in5(b);
//            Debug.Assert(virt25.Equals(oracle2), "virt25");
//
            bool virtualizedCheck = virt1.Equals(oracle) &&
                                  virt2.Equals(oracle) && 
                                  virt3.Equals(oracle)  
                                  ;
//
//            bool virtualizedCheck2 = virt21.Equals(oracle2) &&
//                                  virt22.Equals(oracle2) && virt23.Equals(oracle2) && virt24.Equals(oracle2)
//                                  && virt25.Equals(oracle2);

            Console.WriteLine("\n{0}\n{1}", oracle, "oracle2");
            condition = refactoredCheck 
                && virtualizedCheck 
                ;
            Program.End_Check(testName, condition);
        }

public static long FactorialRecursive_original(int num)
{
    int c = 0;
    int a = 20;
    int b = 10;            
    int d = 5;
    int e = 2;
    double sum = 1.0;
    string result = "FactorialRecursive_original";

    sum += 1 + num;
    result += sum + a + b + c;
    sum += (a - b) * (c - d) + a + d;
    result += sum;
    sum += a * b + c / d * e + 2 + 7 % 3 + num;
    result += sum;
    Console.WriteLine("{0} {1}", "result", result);
    Console.WriteLine("{0} {1}", "fact", num);
    if (num == 0)
    {
        return 1;
    }

    return num * FactorialRecursive_original(num - 1);
}

        #region REFACTORED
//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
public static long FactorialRecursive_ref_op2_in1(int num)
{
    int c = 0;
    int a = 20;
    int b = 10;
    int d = 5;
    int e = 2;
    double sum = 1.0 + 0.0;
    string result = "FactorialRecursive_ref_op2_in1";
    int addTemp_0 = 1 + num;
    sum = sum + addTemp_0;
    double addTemp_1 = sum + a;
    double addTemp_2 = addTemp_1 + b;
    double addTemp_3 = addTemp_2 + c;
    result = result + addTemp_3;
    int parTemp_0 = a - b;
    int parTemp_1 = c - d;
    int mulTemp_0 = parTemp_0 * parTemp_1;
    int addTemp_4 = mulTemp_0 + a;
    int addTemp_5 = addTemp_4 + d;
    sum = sum + addTemp_5;
    result = result + sum;
    int mulTemp_1 = a * b;
    int mulTemp_2 = c / d;
    int mulTemp_3 = mulTemp_2 * e;
    int mulTemp_4 = 7 % 3;
    int addTemp_6 = mulTemp_1 + mulTemp_3;
    int addTemp_7 = addTemp_6 + 2;
    int addTemp_8 = addTemp_7 + mulTemp_4;
    int addTemp_9 = addTemp_8 + num;
    sum = sum + addTemp_9;
    result = result + sum;
    Console.WriteLine("{0} {1}", "result", result);
    Console.WriteLine("{0} {1}", "fact", num);
    bool var_ifCondition_0 = num == 0;
    if (var_ifCondition_0)
    {
        return 1;
    }

    int addTemp_10 = num - 1;
    long invocationTemp_0 = FactorialRecursive_ref_op2_in1(addTemp_10);
    long mulTemp_5 = num * invocationTemp_0;
    return mulTemp_5;
}

//                [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
public static long FactorialRecursive_ref_op3_in1(int num)
{
    int c = 0;
    int a = 20;
    int b = 10;
    int d = 5;
    int e = 2;
    double sum = 1.0 + 0.0;
    string result = "FactorialRecursive_ref_op3_in1";
    sum = sum + 1 + num;
    double addTemp_0 = sum + a + b;
    result = result + addTemp_0 + c;
    int parTemp_0 = c - d;
    int mulTemp_0 = (a - b) * parTemp_0;
    int addTemp_1 = mulTemp_0 + a;
    sum = sum + addTemp_1 + d;
    result = result + sum;
    int mulTemp_1 = a * b;
    int mulTemp_2 = c / d;
    int mulTemp_3 = mulTemp_2 * e;
    int mulTemp_4 = 7 % 3;
    int addTemp_2 = mulTemp_1 + mulTemp_3 + 2;
    int addTemp_3 = addTemp_2 + mulTemp_4 + num;
    sum = sum + addTemp_3;
    result = result + sum;
    Console.WriteLine("{0} {1}", "result", result);
    Console.WriteLine("{0} {1}", "fact", num);
    bool var_ifCondition_0 = num == 0;
    if (var_ifCondition_0)
    {
        return 1;
    }

    long invocationTemp_0 = FactorialRecursive_ref_op3_in1(num - 1);
    long mulTemp_5 = num * invocationTemp_0;
    return mulTemp_5;
}

//                [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
public static long FactorialRecursive_ref_op4_in1(int num)
{
    int c = 0;
    int a = 20;
    int b = 10;
    int d = 5;
    int e = 2;
    double sum = 1.0 + 0.0;
    string result = "FactorialRecursive_ref_op4_in1";
    sum = sum + 1 + num;
    double addTemp_0 = sum + a + b + c;
    result = result + addTemp_0;
    int mulTemp_0 = (a - b) * (c - d);
    int addTemp_1 = mulTemp_0 + a;
    sum = sum + addTemp_1 + d;
    result = result + sum;
    int mulTemp_1 = a * b;
    int mulTemp_2 = c / d;
    int mulTemp_3 = mulTemp_2 * e;
    int mulTemp_4 = 7 % 3;
    int addTemp_2 = mulTemp_1 + mulTemp_3 + 2 + mulTemp_4;
    sum = sum + addTemp_2 + num;
    result = result + sum;
    Console.WriteLine("{0} {1}", "result", result);
    Console.WriteLine("{0} {1}", "fact", num);
    bool var_ifCondition_0 = num == 0;
    if (var_ifCondition_0)
    {
        return 1;
    }

    long invocationTemp_0 = FactorialRecursive_ref_op4_in1(num - 1);
    long mulTemp_5 = num * invocationTemp_0;
    return mulTemp_5;
}

        #endregion

        #region OBFUSCATED
//                [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
public static long FactorialRecursive_obf_op2_in1(int num)
{
    //Virtualization variables
    int[] code = new int[100781];
    object[] data = new object[4266];
    int vpc = 73;

    //Data init
    data[3021]=num; //num 
    data[331]=0; //0 constant
    data[2333]=20; //20 constant
    data[2989]=10; //10 constant
    data[688]=5; //5 constant
    data[723]=2; //2 constant
    data[1868]=(double)1.0; //1.0 constant
    data[1813]=(double)0.0; //0.0 constant
    data[2053]="FactorialRecursive_obf_op2_in1"; //"FactorialRecursive_obf_op2_in1" constant
    data[1275]=1 ; //1 constant
    data[1689]=7 ; //7 constant
    data[3292]=3; //3 constant
    data[3806]="{0} {1}"; //"{0} {1}" constant
    data[2678]="result"; //"result" constant
    data[3261]="fact"; //"fact" constant
    data[2223]=(long)1; //1 constant
    data[1490]=40; //c 
    data[2472]=560; //a 
    data[517]=-520; //b 
    data[2102]=-432; //d 
    data[2787]=-289; //e 
    data[1673]=(double)0.855914969861468; //sum 
    data[2432]=1917935028; //result 
    data[3826]=412; //addTemp_0 
    data[2506]=(double)0.323075956815423; //addTemp_1 
    data[2555]=(double)0.984736048609361; //addTemp_2 
    data[1867]=(double)0.564394400717874; //addTemp_3 
    data[3937]=-941; //parTemp_0 
    data[3657]=468; //parTemp_1 
    data[1738]=254; //mulTemp_0 
    data[3748]=-98; //addTemp_4 
    data[1437]=-925; //addTemp_5 
    data[3001]=-758; //mulTemp_1 
    data[3008]=712; //mulTemp_2 
    data[494]=557; //mulTemp_3 
    data[3201]=-148; //mulTemp_4 
    data[803]=-755; //addTemp_6 
    data[92]=-589; //addTemp_7 
    data[1662]=-536; //addTemp_8 
    data[2203]=317; //addTemp_9 
    data[2669]=false; //var_ifCondition_0 
    data[1542]=-844; //addTemp_10 
    data[3906]=(long)209L; //invocationTemp_0 
    data[2299]=(long)46L; //mulTemp_5 
    data[2884]=866; //jmpDestinationName_2884 constant
    data[985]=59; //if_GoTo_True_985 constant
    data[1098]=175; //if_GoTo_False_1098 constant
    data[3409]=0; //if_FalseBlockSize_Skip_3409 constant

    //Code init

    code[73]=4093; //ExpressionStatement_0 # ExpressionStatement_0
    code[101]=1490; //c
    code[100]=331; //0

    code[133]=4093; //ExpressionStatement_0 # ExpressionStatement_1
    code[161]=2472; //a
    code[160]=2333; //20

    code[193]=4093; //ExpressionStatement_0 # ExpressionStatement_2
    code[221]=517; //b
    code[220]=2989; //10

    code[253]=4093; //ExpressionStatement_0 # ExpressionStatement_3
    code[281]=2102; //d
    code[280]=688; //5

    code[313]=4093; //ExpressionStatement_0 # ExpressionStatement_4
    code[341]=2787; //e
    code[340]=723; //2

    code[373]=6640; //ExpressionStatement_5 # ExpressionStatement_5
    code[379]=1673; //sum
    code[388]=1868; //1.0
    code[377]=1813; //0.0

    code[428]=4093; //ExpressionStatement_0 # ExpressionStatement_6
    code[456]=2432; //result
    code[455]=2053; //"FactorialRecursive_obf_op2_in1"

    code[488]=4432; //ExpressionStatement_7 # ExpressionStatement_7
    code[471]=3826; //addTemp_0
    code[477]=1275; //1
    code[495]=3021; //num

    code[542]=4195; //ExpressionStatement_8 # ExpressionStatement_8
    code[532]=1673; //sum
    code[550]=1673; //sum
    code[564]=3826; //addTemp_0

    code[601]=4195; //ExpressionStatement_8 # ExpressionStatement_9
    code[591]=2506; //addTemp_1
    code[609]=1673; //sum
    code[623]=2472; //a

    code[660]=4195; //ExpressionStatement_8 # ExpressionStatement_10
    code[650]=2555; //addTemp_2
    code[668]=2506; //addTemp_1
    code[682]=517; //b

    code[719]=4195; //ExpressionStatement_8 # ExpressionStatement_11
    code[709]=1867; //addTemp_3
    code[727]=2555; //addTemp_2
    code[741]=1490; //c

    code[778]=8598; //ExpressionStatement_12 # ExpressionStatement_12
    code[764]=2432; //result
    code[786]=2432; //result
    code[804]=1867; //addTemp_3

    code[838]=9800; //ExpressionStatement_13 # ExpressionStatement_13
    code[847]=3937; //parTemp_0
    code[821]=2472; //a
    code[857]=517; //b

    code[903]=9800; //ExpressionStatement_13 # ExpressionStatement_14
    code[912]=3657; //parTemp_1
    code[886]=1490; //c
    code[922]=2102; //d

    code[968]=9120; //ExpressionStatement_15 # ExpressionStatement_15
    code[989]=1738; //mulTemp_0
    code[957]=3937; //parTemp_0
    code[990]=3657; //parTemp_1

    code[1038]=4432; //ExpressionStatement_7 # ExpressionStatement_16
    code[1021]=3748; //addTemp_4
    code[1027]=1738; //mulTemp_0
    code[1045]=2472; //a

    code[1092]=4432; //ExpressionStatement_7 # ExpressionStatement_17
    code[1075]=1437; //addTemp_5
    code[1081]=3748; //addTemp_4
    code[1099]=2102; //d

    code[1146]=4195; //ExpressionStatement_8 # ExpressionStatement_18
    code[1136]=1673; //sum
    code[1154]=1673; //sum
    code[1168]=1437; //addTemp_5

    code[1205]=8598; //ExpressionStatement_12 # ExpressionStatement_19
    code[1191]=2432; //result
    code[1213]=2432; //result
    code[1231]=1673; //sum

    code[1265]=9120; //ExpressionStatement_15 # ExpressionStatement_20
    code[1286]=3001; //mulTemp_1
    code[1254]=2472; //a
    code[1287]=517; //b

    code[1335]=4574; //ExpressionStatement_21 # ExpressionStatement_21
    code[1317]=3008; //mulTemp_2
    code[1352]=1490; //c
    code[1323]=2102; //d

    code[1400]=9120; //ExpressionStatement_15 # ExpressionStatement_22
    code[1421]=494; //mulTemp_3
    code[1389]=3008; //mulTemp_2
    code[1422]=2787; //e

    code[1470]=9059; //ExpressionStatement_23 # ExpressionStatement_23
    code[1460]=3201; //mulTemp_4
    code[1463]=1689; //7
    code[1458]=3292; //3

    code[1531]=4432; //ExpressionStatement_7 # ExpressionStatement_24
    code[1514]=803; //addTemp_6
    code[1520]=3001; //mulTemp_1
    code[1538]=494; //mulTemp_3

    code[1585]=4432; //ExpressionStatement_7 # ExpressionStatement_25
    code[1568]=92; //addTemp_7
    code[1574]=803; //addTemp_6
    code[1592]=723; //2

    code[1639]=4432; //ExpressionStatement_7 # ExpressionStatement_26
    code[1622]=1662; //addTemp_8
    code[1628]=92; //addTemp_7
    code[1646]=3201; //mulTemp_4

    code[1693]=4432; //ExpressionStatement_7 # ExpressionStatement_27
    code[1676]=2203; //addTemp_9
    code[1682]=1662; //addTemp_8
    code[1700]=3021; //num

    code[1747]=4195; //ExpressionStatement_8 # ExpressionStatement_28
    code[1737]=1673; //sum
    code[1755]=1673; //sum
    code[1769]=2203; //addTemp_9

    code[1806]=8598; //ExpressionStatement_12 # ExpressionStatement_29
    code[1792]=2432; //result
    code[1814]=2432; //result
    code[1832]=1673; //sum

    code[1866]=2161; //ExpressionStatement_30 # ExpressionStatement_30
    code[1880]=3806; //"{0} {1}"
    code[1885]=2678; //"result"
    code[1868]=2432; //result

    code[1934]=7673; //ExpressionStatement_31 # ExpressionStatement_31
    code[1937]=3806; //"{0} {1}"
    code[1941]=3261; //"fact"
    code[1955]=3021; //num

    code[2000]=2211; //ExpressionStatement_32 # ExpressionStatement_32
    code[1996]=2669; //var_ifCondition_0
    code[1988]=3021; //num
    code[1995]=331; //0

    code[2059]=4975; //IfStatementSyntax_33 # IfStatementSyntax_33
    code[2083]=2884; //jmpDestinationName_2884
    code[2074]=2669; //var_ifCondition_0
    code[2057]=985; //if_GoTo_True_985
    code[2070]=1098; //if_GoTo_False_1098

    code[2118]=8109; //ReturnStatement_34 # ReturnStatement_34
    code[2109]=2223; //1

    code[2169]=1339; //ExpressionStatement_35 # ExpressionStatement_35
    code[2191]=3409; //if_FalseBlockSize_Skip_3409

    code[2234]=9800; //ExpressionStatement_13 # ExpressionStatement_36
    code[2243]=1542; //addTemp_10
    code[2217]=3021; //num
    code[2253]=1275; //1

    code[2299]=6636; //ExpressionStatement_37 # ExpressionStatement_37
    code[2296]=3906; //invocationTemp_0
    code[2309]=1542; //addTemp_10

    code[2369]=2274; //ExpressionStatement_38 # ExpressionStatement_38
    code[2362]=2299; //mulTemp_5
    code[2385]=3021; //num
    code[2363]=3906; //invocationTemp_0

    code[2439]=8109; //ReturnStatement_34 # ReturnStatement_39
    code[2430]=2299; //mulTemp_5

    return (long)ClassInterpreterVirtualization_BasicOperations_op2(vpc, data, code);

}

//                [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
public static long FactorialRecursive_obf_op3_in1(int num)
{
    //Virtualization variables
    int[] code = new int[100552];
    object[] data = new object[4415];
    int vpc = 33;

    //Data init
    data[1552]=num; //num 
    data[3414]=0; //0 constant
    data[262]=20; //20 constant
    data[3093]=10; //10 constant
    data[3828]=5; //5 constant
    data[1193]=2; //2 constant
    data[542]=(double)1.0; //1.0 constant
    data[682]=(double)0.0; //0.0 constant
    data[304]="FactorialRecursive_obf_op3_in1"; //"FactorialRecursive_obf_op3_in1" constant
    data[2644]=1 ; //1 constant
    data[436]=7 ; //7 constant
    data[137]=3; //3 constant
    data[1883]="{0} {1}"; //"{0} {1}" constant
    data[3037]="result"; //"result" constant
    data[30]="fact"; //"fact" constant
    data[986]=(long)1; //1 constant
    data[857]=250; //c 
    data[995]=674; //a 
    data[1030]=-887; //b 
    data[3211]=-60; //d 
    data[3549]=-877; //e 
    data[3567]=(double)0.8642980916725; //sum 
    data[135]=1819131924; //result 
    data[1067]=(double)0.850555147440431; //addTemp_0 
    data[1006]=941; //parTemp_0 
    data[3242]=204; //mulTemp_0 
    data[3577]=829; //addTemp_1 
    data[3428]=726; //mulTemp_1 
    data[1973]=-160; //mulTemp_2 
    data[2101]=-676; //mulTemp_3 
    data[2972]=-660; //mulTemp_4 
    data[3357]=-761; //addTemp_2 
    data[3292]=-923; //addTemp_3 
    data[744]=false; //var_ifCondition_0 
    data[907]=(long)-67L; //invocationTemp_0 
    data[3429]=(long)-893L; //mulTemp_5 
    data[3358]=-496; //jmpDestinationName_3358 constant
    data[2980]=73; //if_GoTo_True_2980 constant
    data[1218]=201; //if_GoTo_False_1218 constant
    data[95]=0; //if_FalseBlockSize_Skip_95 constant

    //Code init

    code[33]=6731; //ExpressionStatement_0 # ExpressionStatement_0
    code[61]=857; //c
    code[30]=3414; //0

    code[85]=6731; //ExpressionStatement_0 # ExpressionStatement_1
    code[113]=995; //a
    code[82]=262; //20

    code[137]=6731; //ExpressionStatement_0 # ExpressionStatement_2
    code[165]=1030; //b
    code[134]=3093; //10

    code[189]=6731; //ExpressionStatement_0 # ExpressionStatement_3
    code[217]=3211; //d
    code[186]=3828; //5

    code[241]=6731; //ExpressionStatement_0 # ExpressionStatement_4
    code[269]=3549; //e
    code[238]=1193; //2

    code[293]=8675; //ExpressionStatement_5 # ExpressionStatement_5
    code[283]=3567; //sum
    code[303]=542; //1.0
    code[315]=682; //0.0

    code[358]=6731; //ExpressionStatement_0 # ExpressionStatement_6
    code[386]=135; //result
    code[355]=304; //"FactorialRecursive_obf_op3_in1"

    code[410]=5465; //ExpressionStatement_7 # ExpressionStatement_7
    code[429]=3567; //sum
    code[416]=3567; //sum
    code[397]=2644; //1
    code[403]=1552; //num

    code[480]=5955; //ExpressionStatement_8 # ExpressionStatement_8
    code[473]=1067; //addTemp_0
    code[470]=3567; //sum
    code[474]=995; //a
    code[486]=1030; //b

    code[552]=1986; //ExpressionStatement_9 # ExpressionStatement_9
    code[573]=135; //result
    code[563]=135; //result
    code[572]=1067; //addTemp_0
    code[577]=857; //c

    code[619]=3735; //ExpressionStatement_10 # ExpressionStatement_10
    code[626]=1006; //parTemp_0
    code[629]=857; //c
    code[599]=3211; //d

    code[690]=3838; //ExpressionStatement_11 # ExpressionStatement_11
    code[719]=3242; //mulTemp_0
    code[679]=995; //a
    code[686]=1030; //b
    code[706]=1006; //parTemp_0

    code[746]=4045; //ExpressionStatement_12 # ExpressionStatement_12
    code[739]=3577; //addTemp_1
    code[737]=3242; //mulTemp_0
    code[762]=995; //a

    code[799]=5465; //ExpressionStatement_7 # ExpressionStatement_13
    code[818]=3567; //sum
    code[805]=3567; //sum
    code[786]=3577; //addTemp_1
    code[792]=3211; //d

    code[869]=8307; //ExpressionStatement_14 # ExpressionStatement_14
    code[873]=135; //result
    code[894]=135; //result
    code[886]=3567; //sum

    code[923]=5526; //ExpressionStatement_15 # ExpressionStatement_15
    code[942]=3428; //mulTemp_1
    code[914]=995; //a
    code[944]=1030; //b

    code[986]=9542; //ExpressionStatement_16 # ExpressionStatement_16
    code[1009]=1973; //mulTemp_2
    code[1014]=857; //c
    code[992]=3211; //d

    code[1049]=5526; //ExpressionStatement_15 # ExpressionStatement_17
    code[1068]=2101; //mulTemp_3
    code[1040]=1973; //mulTemp_2
    code[1070]=3549; //e

    code[1112]=8164; //ExpressionStatement_18 # ExpressionStatement_18
    code[1131]=2972; //mulTemp_4
    code[1105]=436; //7
    code[1092]=137; //3

    code[1169]=8215; //ExpressionStatement_19 # ExpressionStatement_19
    code[1187]=3357; //addTemp_2
    code[1180]=3428; //mulTemp_1
    code[1177]=2101; //mulTemp_3
    code[1168]=1193; //2

    code[1225]=8215; //ExpressionStatement_19 # ExpressionStatement_20
    code[1243]=3292; //addTemp_3
    code[1236]=3357; //addTemp_2
    code[1233]=2972; //mulTemp_4
    code[1224]=1552; //num

    code[1281]=7772; //ExpressionStatement_21 # ExpressionStatement_21
    code[1303]=3567; //sum
    code[1263]=3567; //sum
    code[1296]=3292; //addTemp_3

    code[1343]=8307; //ExpressionStatement_14 # ExpressionStatement_22
    code[1347]=135; //result
    code[1368]=135; //result
    code[1360]=3567; //sum

    code[1397]=4401; //ExpressionStatement_23 # ExpressionStatement_23
    code[1393]=1883; //"{0} {1}"
    code[1415]=3037; //"result"
    code[1395]=135; //result

    code[1465]=8032; //ExpressionStatement_24 # ExpressionStatement_24
    code[1468]=1883; //"{0} {1}"
    code[1447]=30; //"fact"
    code[1481]=1552; //num

    code[1528]=5039; //ExpressionStatement_25 # ExpressionStatement_25
    code[1535]=744; //var_ifCondition_0
    code[1508]=1552; //num
    code[1547]=3414; //0

    code[1590]=9620; //IfStatementSyntax_26 # IfStatementSyntax_26
    code[1606]=3358; //jmpDestinationName_3358
    code[1599]=744; //var_ifCondition_0
    code[1615]=2980; //if_GoTo_True_2980
    code[1581]=1218; //if_GoTo_False_1218

    code[1663]=1127; //ReturnStatement_27 # ReturnStatement_27
    code[1684]=986; //1

    code[1732]=9748; //ExpressionStatement_28 # ExpressionStatement_28
    code[1735]=95; //if_FalseBlockSize_Skip_95

    code[1791]=6789; //ExpressionStatement_29 # ExpressionStatement_29
    code[1772]=907; //invocationTemp_0
    code[1800]=1552; //num
    code[1786]=2644; //1

    code[1855]=8442; //ExpressionStatement_30 # ExpressionStatement_30
    code[1866]=3429; //mulTemp_5
    code[1841]=1552; //num
    code[1844]=907; //invocationTemp_0

    code[1927]=1127; //ReturnStatement_27 # ReturnStatement_31
    code[1948]=3429; //mulTemp_5

    return (long)ClassInterpreterVirtualization_BasicOperations_op3(vpc, data, code);

}

//                [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
public static long FactorialRecursive_obf_op4_in1(int num)
{
    //Virtualization variables
    int[] code = new int[100625];
    object[] data = new object[4282];
    int vpc = 21;

    //Data init
    data[3204]=num; //num 
    data[932]=0; //0 constant
    data[180]=20; //20 constant
    data[1804]=10; //10 constant
    data[3735]=5; //5 constant
    data[3032]=2; //2 constant
    data[2364]=(double)1.0; //1.0 constant
    data[2197]=(double)0.0; //0.0 constant
    data[66]="FactorialRecursive_obf_op4_in1"; //"FactorialRecursive_obf_op4_in1" constant
    data[957]=1 ; //1 constant
    data[3166]=7 ; //7 constant
    data[3173]=3; //3 constant
    data[3601]="{0} {1}"; //"{0} {1}" constant
    data[3665]="result"; //"result" constant
    data[866]="fact"; //"fact" constant
    data[1801]=(long)1; //1 constant
    data[3091]=-866; //c 
    data[2163]=-717; //a 
    data[1682]=602; //b 
    data[267]=-534; //d 
    data[614]=-910; //e 
    data[922]=(double)0.451301903208393; //sum 
    data[2104]=2006145115; //result 
    data[3156]=(double)0.758254800344936; //addTemp_0 
    data[65]=182; //mulTemp_0 
    data[1863]=98; //addTemp_1 
    data[843]=-967; //mulTemp_1 
    data[2849]=-522; //mulTemp_2 
    data[506]=583; //mulTemp_3 
    data[2611]=587; //mulTemp_4 
    data[3269]=801; //addTemp_2 
    data[1786]=false; //var_ifCondition_0 
    data[156]=(long)833L; //invocationTemp_0 
    data[3311]=(long)-567L; //mulTemp_5 
    data[3878]=-99; //jmpDestinationName_3878 constant
    data[3142]=70; //if_GoTo_True_3142 constant
    data[1980]=186; //if_GoTo_False_1980 constant
    data[1050]=0; //if_FalseBlockSize_Skip_1050 constant

    //Code init

    code[21]=2646; //ExpressionStatement_0 # ExpressionStatement_0
    code[10]=3091; //c
    code[8]=932; //0

    code[85]=2646; //ExpressionStatement_0 # ExpressionStatement_1
    code[74]=2163; //a
    code[72]=180; //20

    code[149]=2646; //ExpressionStatement_0 # ExpressionStatement_2
    code[138]=1682; //b
    code[136]=1804; //10

    code[213]=2646; //ExpressionStatement_0 # ExpressionStatement_3
    code[202]=267; //d
    code[200]=3735; //5

    code[277]=2646; //ExpressionStatement_0 # ExpressionStatement_4
    code[266]=614; //e
    code[264]=3032; //2

    code[341]=9801; //ExpressionStatement_5 # ExpressionStatement_5
    code[344]=922; //sum
    code[354]=2364; //1.0
    code[356]=2197; //0.0

    code[395]=2646; //ExpressionStatement_0 # ExpressionStatement_6
    code[384]=2104; //result
    code[382]=66; //"FactorialRecursive_obf_op4_in1"

    code[459]=1000; //ExpressionStatement_7 # ExpressionStatement_7
    code[467]=922; //sum
    code[474]=922; //sum
    code[451]=957; //1
    code[460]=3204; //num

    code[532]=5924; //ExpressionStatement_8 # ExpressionStatement_8
    code[533]=3156; //addTemp_0
    code[530]=922; //sum
    code[529]=2163; //a
    code[549]=1682; //b
    code[515]=3091; //c

    code[604]=6309; //ExpressionStatement_9 # ExpressionStatement_9
    code[613]=2104; //result
    code[630]=2104; //result
    code[595]=3156; //addTemp_0

    code[660]=5204; //ExpressionStatement_10 # ExpressionStatement_10
    code[668]=65; //mulTemp_0
    code[676]=2163; //a
    code[644]=1682; //b
    code[664]=3091; //c
    code[648]=267; //d

    code[716]=5193; //ExpressionStatement_11 # ExpressionStatement_11
    code[744]=1863; //addTemp_1
    code[742]=65; //mulTemp_0
    code[697]=2163; //a

    code[787]=1000; //ExpressionStatement_7 # ExpressionStatement_12
    code[795]=922; //sum
    code[802]=922; //sum
    code[779]=1863; //addTemp_1
    code[788]=267; //d

    code[860]=6309; //ExpressionStatement_9 # ExpressionStatement_13
    code[869]=2104; //result
    code[886]=2104; //result
    code[851]=922; //sum

    code[916]=1246; //ExpressionStatement_14 # ExpressionStatement_14
    code[903]=843; //mulTemp_1
    code[928]=2163; //a
    code[909]=1682; //b

    code[983]=7943; //ExpressionStatement_15 # ExpressionStatement_15
    code[999]=2849; //mulTemp_2
    code[971]=3091; //c
    code[1008]=267; //d

    code[1046]=1246; //ExpressionStatement_14 # ExpressionStatement_16
    code[1033]=506; //mulTemp_3
    code[1058]=2849; //mulTemp_2
    code[1039]=614; //e

    code[1113]=5438; //ExpressionStatement_17 # ExpressionStatement_17
    code[1139]=2611; //mulTemp_4
    code[1107]=3166; //7
    code[1097]=3173; //3

    code[1168]=5271; //ExpressionStatement_18 # ExpressionStatement_18
    code[1174]=3269; //addTemp_2
    code[1164]=843; //mulTemp_1
    code[1197]=506; //mulTemp_3
    code[1167]=3032; //2
    code[1180]=2611; //mulTemp_4

    code[1225]=1000; //ExpressionStatement_7 # ExpressionStatement_19
    code[1233]=922; //sum
    code[1240]=922; //sum
    code[1217]=3269; //addTemp_2
    code[1226]=3204; //num

    code[1298]=6309; //ExpressionStatement_9 # ExpressionStatement_20
    code[1307]=2104; //result
    code[1324]=2104; //result
    code[1289]=922; //sum

    code[1354]=4697; //ExpressionStatement_21 # ExpressionStatement_21
    code[1345]=3601; //"{0} {1}"
    code[1356]=3665; //"result"
    code[1367]=2104; //result

    code[1421]=8578; //ExpressionStatement_22 # ExpressionStatement_22
    code[1429]=3601; //"{0} {1}"
    code[1432]=866; //"fact"
    code[1411]=3204; //num

    code[1489]=1370; //ExpressionStatement_23 # ExpressionStatement_23
    code[1515]=1786; //var_ifCondition_0
    code[1498]=3204; //num
    code[1469]=932; //0

    code[1542]=9754; //IfStatementSyntax_24 # IfStatementSyntax_24
    code[1554]=3878; //jmpDestinationName_3878
    code[1524]=1786; //var_ifCondition_0
    code[1569]=3142; //if_GoTo_True_3142
    code[1537]=1980; //if_GoTo_False_1980

    code[1612]=6719; //ReturnStatement_25 # ReturnStatement_25
    code[1609]=1801; //1

    code[1669]=3788; //ExpressionStatement_26 # ExpressionStatement_26
    code[1682]=1050; //if_FalseBlockSize_Skip_1050

    code[1728]=4177; //ExpressionStatement_27 # ExpressionStatement_27
    code[1714]=156; //invocationTemp_0
    code[1743]=3204; //num
    code[1730]=957; //1

    code[1786]=2353; //ExpressionStatement_28 # ExpressionStatement_28
    code[1792]=3311; //mulTemp_5
    code[1785]=3204; //num
    code[1784]=156; //invocationTemp_0

    code[1840]=6719; //ReturnStatement_25 # ReturnStatement_29
    code[1837]=3311; //mulTemp_5

    return (long)ClassInterpreterVirtualization_BasicOperations_op4(vpc, data, code);

}

private static object ClassInterpreterVirtualization_BasicOperations_op4(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 1370:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (26)]] = (int)data[code[vpc + (9)]] == (int)data[code[vpc + (-20)]];
                vpc += 53;
                break;
            case 4177:  //frequency 1 ExpressionStatement_27
                data[code[vpc + (-14)]] = FactorialRecursive_obf_op4_in1((int)data[code[vpc + (15)]] - (int)data[code[vpc + (2)]]);
                vpc += 58;
                break;
            case 2353:  //frequency 1 ExpressionStatement_28
                data[code[vpc + (6)]] = (int)data[code[vpc + (-1)]] * (long)data[code[vpc + (-2)]];
                vpc += 54;
                break;
            case 5204:  //frequency 1 ExpressionStatement_10
                data[code[vpc + (8)]] = ((int)data[code[vpc + (16)]] - (int)data[code[vpc + (-16)]]) * ((int)data[code[vpc + (4)]] - (int)data[code[vpc + (-12)]]);
                vpc += 56;
                break;
            case 2646:  //frequency 6 ExpressionStatement_0
                data[code[vpc + (-11)]] = data[code[vpc + (-13)]];
                vpc += 64;
                break;
            case 6309:  //frequency 3 ExpressionStatement_9
                data[code[vpc + (9)]] = (string)data[code[vpc + (26)]] + (double)data[code[vpc + (-9)]];
                vpc += 56;
                break;
            case 3788:  //frequency 1 ExpressionStatement_26
                vpc += (int)data[code[vpc + (13)]];
                vpc += 59;
                break;
            case 5193:  //frequency 1 ExpressionStatement_11
                data[code[vpc + (28)]] = (int)data[code[vpc + (26)]] + (int)data[code[vpc + (-19)]];
                vpc += 71;
                break;
            case 5924:  //frequency 1 ExpressionStatement_8
                data[code[vpc + (1)]] = (double)data[code[vpc + (-2)]] + (int)data[code[vpc + (-3)]] + (int)data[code[vpc + (17)]] + (int)data[code[vpc + (-17)]];
                vpc += 72;
                break;
            case 5438:  //frequency 1 ExpressionStatement_17
                data[code[vpc + (26)]] = (int)data[code[vpc + (-6)]] % (int)data[code[vpc + (-16)]];
                vpc += 55;
                break;
            case 5271:  //frequency 1 ExpressionStatement_18
                data[code[vpc + (6)]] = (int)data[code[vpc + (-4)]] + (int)data[code[vpc + (29)]] + (int)data[code[vpc + (-1)]] + (int)data[code[vpc + (12)]];
                vpc += 57;
                break;
            case 4697:  //frequency 1 ExpressionStatement_21
                Console.WriteLine((string)data[code[vpc + (-9)]], (string)data[code[vpc + (2)]], (string)data[code[vpc + (13)]]);
                vpc += 67;
                break;
            case 9754:  //frequency 1 IfStatementSyntax_24
                data[code[vpc + (12)]] = (bool)data[code[vpc + (-18)]] ? (int)data[code[vpc + (27)]] : (int)data[code[vpc + (-5)]];
                vpc += (int)data[code[vpc + (12)]];
                break;
            case 9801:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (3)]] = (double)data[code[vpc + (13)]] + (double)data[code[vpc + (15)]];
                vpc += 54;
                break;
            case 1246:  //frequency 2 ExpressionStatement_14
                data[code[vpc + (-13)]] = (int)data[code[vpc + (12)]] * (int)data[code[vpc + (-7)]];
                vpc += 67;
                break;
            case 6719:  //frequency 2 ReturnStatement_25
                return (long)data[code[vpc + (-3)]];
                vpc += 57;
            default:  //frequency 0 
                break;
            case 7943:  //frequency 1 ExpressionStatement_15
                data[code[vpc + (16)]] = (int)data[code[vpc + (-12)]] / (int)data[code[vpc + (25)]];
                vpc += 63;
                break;
            case 1000:  //frequency 3 ExpressionStatement_7
                data[code[vpc + (8)]] = (double)data[code[vpc + (15)]] + (int)data[code[vpc + (-8)]] + (int)data[code[vpc + (1)]];
                vpc += 73;
                break;
            case 8578:  //frequency 1 ExpressionStatement_22
                Console.WriteLine((string)data[code[vpc + (8)]], (string)data[code[vpc + (11)]], (int)data[code[vpc + (-10)]]);
                vpc += 68;
                break;
        }
    }

    return null;
}

private static object ClassInterpreterVirtualization_BasicOperations_op3(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 8164:  //frequency 1 ExpressionStatement_18
                data[code[vpc + (19)]] = (int)data[code[vpc + (-7)]] % (int)data[code[vpc + (-20)]];
                vpc += 57;
                break;
            case 5039:  //frequency 1 ExpressionStatement_25
                data[code[vpc + (7)]] = (int)data[code[vpc + (-20)]] == (int)data[code[vpc + (19)]];
                vpc += 62;
                break;
            case 5465:  //frequency 2 ExpressionStatement_7
                data[code[vpc + (19)]] = (double)data[code[vpc + (6)]] + (int)data[code[vpc + (-13)]] + (int)data[code[vpc + (-7)]];
                vpc += 70;
                break;
            case 8307:  //frequency 2 ExpressionStatement_14
                data[code[vpc + (4)]] = (string)data[code[vpc + (25)]] + (double)data[code[vpc + (17)]];
                vpc += 54;
                break;
            case 5526:  //frequency 2 ExpressionStatement_15
                data[code[vpc + (19)]] = (int)data[code[vpc + (-9)]] * (int)data[code[vpc + (21)]];
                vpc += 63;
                break;
            case 9542:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (23)]] = (int)data[code[vpc + (28)]] / (int)data[code[vpc + (6)]];
                vpc += 63;
                break;
            case 3838:  //frequency 1 ExpressionStatement_11
                data[code[vpc + (29)]] = ((int)data[code[vpc + (-11)]] - (int)data[code[vpc + (-4)]]) * (int)data[code[vpc + (16)]];
                vpc += 56;
                break;
            case 8442:  //frequency 1 ExpressionStatement_30
                data[code[vpc + (11)]] = (int)data[code[vpc + (-14)]] * (long)data[code[vpc + (-11)]];
                vpc += 72;
                break;
            case 5955:  //frequency 1 ExpressionStatement_8
                data[code[vpc + (-7)]] = (double)data[code[vpc + (-10)]] + (int)data[code[vpc + (-6)]] + (int)data[code[vpc + (6)]];
                vpc += 72;
                break;
            case 3735:  //frequency 1 ExpressionStatement_10
                data[code[vpc + (7)]] = (int)data[code[vpc + (10)]] - (int)data[code[vpc + (-20)]];
                vpc += 71;
                break;
            case 9620:  //frequency 1 IfStatementSyntax_26
                data[code[vpc + (16)]] = (bool)data[code[vpc + (9)]] ? (int)data[code[vpc + (25)]] : (int)data[code[vpc + (-9)]];
                vpc += (int)data[code[vpc + (16)]];
                break;
            case 9748:  //frequency 1 ExpressionStatement_28
                vpc += (int)data[code[vpc + (3)]];
                vpc += 59;
                break;
            case 4045:  //frequency 1 ExpressionStatement_12
                data[code[vpc + (-7)]] = (int)data[code[vpc + (-9)]] + (int)data[code[vpc + (16)]];
                vpc += 53;
                break;
            case 8032:  //frequency 1 ExpressionStatement_24
                Console.WriteLine((string)data[code[vpc + (3)]], (string)data[code[vpc + (-18)]], (int)data[code[vpc + (16)]]);
                vpc += 63;
                break;
            case 4401:  //frequency 1 ExpressionStatement_23
                Console.WriteLine((string)data[code[vpc + (-4)]], (string)data[code[vpc + (18)]], (string)data[code[vpc + (-2)]]);
                vpc += 68;
                break;
            default:  //frequency 0 
                break;
            case 7772:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (22)]] = (double)data[code[vpc + (-18)]] + (int)data[code[vpc + (15)]];
                vpc += 62;
                break;
            case 6789:  //frequency 1 ExpressionStatement_29
                data[code[vpc + (-19)]] = FactorialRecursive_obf_op3_in1((int)data[code[vpc + (9)]] - (int)data[code[vpc + (-5)]]);
                vpc += 64;
                break;
            case 1127:  //frequency 2 ReturnStatement_27
                return (long)data[code[vpc + (21)]];
                vpc += 69;
            case 1986:  //frequency 1 ExpressionStatement_9
                data[code[vpc + (21)]] = (string)data[code[vpc + (11)]] + (double)data[code[vpc + (20)]] + (int)data[code[vpc + (25)]];
                vpc += 67;
                break;
            case 8675:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (-10)]] = (double)data[code[vpc + (10)]] + (double)data[code[vpc + (22)]];
                vpc += 65;
                break;
            case 6731:  //frequency 6 ExpressionStatement_0
                data[code[vpc + (28)]] = data[code[vpc + (-3)]];
                vpc += 52;
                break;
            case 8215:  //frequency 2 ExpressionStatement_19
                data[code[vpc + (18)]] = (int)data[code[vpc + (11)]] + (int)data[code[vpc + (8)]] + (int)data[code[vpc + (-1)]];
                vpc += 56;
                break;
        }
    }

    return null;
}

private static object ClassInterpreterVirtualization_BasicOperations_op2(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 8109:  //frequency 2 ReturnStatement_34
                return (long)data[code[vpc + (-9)]];
                vpc += 51;
            case 1339:  //frequency 1 ExpressionStatement_35
                vpc += (int)data[code[vpc + (22)]];
                vpc += 65;
                break;
            case 9800:  //frequency 3 ExpressionStatement_13
                data[code[vpc + (9)]] = (int)data[code[vpc + (-17)]] - (int)data[code[vpc + (19)]];
                vpc += 65;
                break;
            case 6636:  //frequency 1 ExpressionStatement_37
                data[code[vpc + (-3)]] = FactorialRecursive_obf_op2_in1((int)data[code[vpc + (10)]]);
                vpc += 70;
                break;
            case 4093:  //frequency 6 ExpressionStatement_0
                data[code[vpc + (28)]] = data[code[vpc + (27)]];
                vpc += 60;
                break;
            case 2161:  //frequency 1 ExpressionStatement_30
                Console.WriteLine((string)data[code[vpc + (14)]], (string)data[code[vpc + (19)]], (string)data[code[vpc + (2)]]);
                vpc += 68;
                break;
            case 8598:  //frequency 3 ExpressionStatement_12
                data[code[vpc + (-14)]] = (string)data[code[vpc + (8)]] + (double)data[code[vpc + (26)]];
                vpc += 60;
                break;
            case 2274:  //frequency 1 ExpressionStatement_38
                data[code[vpc + (-7)]] = (int)data[code[vpc + (16)]] * (long)data[code[vpc + (-6)]];
                vpc += 70;
                break;
            case 4975:  //frequency 1 IfStatementSyntax_33
                data[code[vpc + (24)]] = (bool)data[code[vpc + (15)]] ? (int)data[code[vpc + (-2)]] : (int)data[code[vpc + (11)]];
                vpc += (int)data[code[vpc + (24)]];
                break;
            case 7673:  //frequency 1 ExpressionStatement_31
                Console.WriteLine((string)data[code[vpc + (3)]], (string)data[code[vpc + (7)]], (int)data[code[vpc + (21)]]);
                vpc += 66;
                break;
            case 9120:  //frequency 3 ExpressionStatement_15
                data[code[vpc + (21)]] = (int)data[code[vpc + (-11)]] * (int)data[code[vpc + (22)]];
                vpc += 70;
                break;
            case 4432:  //frequency 7 ExpressionStatement_7
                data[code[vpc + (-17)]] = (int)data[code[vpc + (-11)]] + (int)data[code[vpc + (7)]];
                vpc += 54;
                break;
            case 2211:  //frequency 1 ExpressionStatement_32
                data[code[vpc + (-4)]] = (int)data[code[vpc + (-12)]] == (int)data[code[vpc + (-5)]];
                vpc += 59;
                break;
            default:  //frequency 0 
                break;
            case 4195:  //frequency 6 ExpressionStatement_8
                data[code[vpc + (-10)]] = (double)data[code[vpc + (8)]] + (int)data[code[vpc + (22)]];
                vpc += 59;
                break;
            case 6640:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (6)]] = (double)data[code[vpc + (15)]] + (double)data[code[vpc + (4)]];
                vpc += 55;
                break;
            case 9059:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (-10)]] = (int)data[code[vpc + (-7)]] % (int)data[code[vpc + (-12)]];
                vpc += 61;
                break;
            case 4574:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (-18)]] = (int)data[code[vpc + (17)]] / (int)data[code[vpc + (-12)]];
                vpc += 65;
                break;
        }
    }

    return null;
}

                

        #endregion

    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/Tracing/TraceLoopTests.cs
================================================
using System;
using System.Diagnostics;
using System.Linq;

namespace ConsoleCalculator.Tracing
{
    class TraceLoopTests
    {

        public static void RunLoopTests()
        {
            TraceLoopTests lt = new TraceLoopTests();

//            lt.ForSimple_Array_Check();
//



        }

        private void ForSimple_Array_Check()
        {
            string testName = "Trace#ForSimple_Array_Check";
            Program.Start_Check(testName);
            bool condition = true;

            int b = 5;
            if (Program.args_in.Count() > 0)
            {
                string loop_count = Program.args_in[0];
                int nr = Int32.Parse(loop_count);
                b = nr;
            }

            string oracle = ForSimple_Array_original(b);
            string oracle2 = ForSimple_Array_original_in(b);

            string ref1 = ForSimple_Array_refactored_op2_in1(b);
            string ref2 = ForSimple_Array_refactored_op3_in1(b);
            string ref3 = ForSimple_Array_refactored_op4_in1(b);
            string ref4 = ForSimple_Array_refactored_op4_in4(b);
            string ref5 = ForSimple_Array_refactored_op4_in5(b);

            Debug.Assert(ref1.Equals(oracle), "ref1");
            Debug.Assert(ref2.Equals(oracle), "ref2");
            Debug.Assert(ref3.Equals(oracle), "ref3");
            Debug.Assert(ref4.Equals(oracle), "ref4");
            Debug.Assert(ref5.Equals(oracle), "ref5");
            bool refactoredCheck = ref1.Equals(oracle) &&
                                   ref2.Equals(oracle) && ref3.Equals(oracle) && ref4.Equals(oracle)
                                   && ref5.Equals(oracle);

            string virt1 = ForSimple_Array_obfuscated_op2_in1(b);
            Debug.Assert(virt1.Equals(oracle), "virt1");

            string virt2 = ForSimple_Array_obfuscated_op3_in1(b);
            Debug.Assert(virt2.Equals(oracle), "virt2");

            string virt3 = ForSimple_Array_obfuscated_op4_in1(b);
            Debug.Assert(virt3.Equals(oracle), "virt3");

            string virt4 = ForSimple_Array_obfuscated_op4_in4(b);
            Debug.Assert(virt4.Equals(oracle), "virt4");

            string virt5 = ForSimple_Array_obfuscated_op4_in5(b);
            Debug.Assert(virt5.Equals(oracle), "virt5");


            string virt21 = ForSimple_Array_obfuscated2_op4_in1(b);
            Debug.Assert(virt21.Equals(oracle2), "virt21");

            string virt22 = ForSimple_Array_obfuscated2_op4_in2(b);
            Debug.Assert(virt22.Equals(oracle2), "virt22");

            string virt23 = ForSimple_Array_obfuscated2_op4_in3(b);
            Debug.Assert(virt23.Equals(oracle2), "virt23");

            string virt24 = ForSimple_Array_obfuscated2_op4_in4(b);
            Debug.Assert(virt24.Equals(oracle2), "virt24");

            string virt25 = ForSimple_Array_obfuscated2_op4_in5(b);
            Debug.Assert(virt25.Equals(oracle2), "virt25");

            bool virtualizedCheck = virt1.Equals(oracle) &&
                                  virt2.Equals(oracle) && virt3.Equals(oracle) && virt4.Equals(oracle)
                                  && virt5.Equals(oracle);

            bool virtualizedCheck2 = virt21.Equals(oracle2) &&
                                  virt22.Equals(oracle2) && virt23.Equals(oracle2) && virt24.Equals(oracle2)
                                  && virt25.Equals(oracle2);

            Console.WriteLine("\n{0}\n{1}", oracle, oracle2);
            condition = refactoredCheck && virtualizedCheck && virtualizedCheck2;
            Program.End_Check(testName, condition);
        }

        private Car car = new Car("invocation-check-car", 4);

        private string ForSimple_Array_original(int b)
        {
            string sum = "" + 3 + 4 + "";
            var p1 = car.GetEngine().GetPistons().First().GetSize();
            sum += "[" + p1 + "]";
            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";               
                r += sum + "#";
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            
            return sum;
        }


        private string ForSimple_Array_original_in(int b)
        {
            string sum = "" + 3 + 4 + "";
            
            sum += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();

            string r = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i + "_";
                sum += "~";
                r += sum + "#";
                var p1 = car.GetEngine().GetPistons().First().GetSize();
                r += "[" + p1 + "]";
                sum += r.Length;
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }

//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
private string ForSimple_Array_ref_op4_in1(int b)
{
    string sum = "" + 3 + 4 + "";
    ConsoleCalculator.Engine invocationTemp_0 = car.GetEngine();
    ConsoleCalculator.Engine invocationTemp_1 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_2 = invocationTemp_1.GetPistons();
    int memberTemp_0 = invocationTemp_2.Count;
    ConsoleCalculator.Piston invocationTemp_3 = invocationTemp_0.GetPiston(memberTemp_0 - 1);
    string invocationTemp_4 = invocationTemp_3.ToString();
    sum = sum + invocationTemp_4;
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    int invocationTemp_5 = ReturnArg_Array(b);
    bool var_whileCondition_0 = var_forIndex_0 < invocationTemp_5;
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        ConsoleCalculator.Engine invocationTemp_6 = car.GetEngine();
        System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_7 = invocationTemp_6.GetPistons();
        ConsoleCalculator.Piston invocationTemp_8 = invocationTemp_7.First();
        double p1 = invocationTemp_8.GetSize();
        r = r + "[" + p1 + "]";
        int memberTemp_1 = r.Length;
        sum = sum + memberTemp_1;
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        int invocationTemp_9 = ReturnArg_Array(b);
        var_whileCondition_0 = var_forIndex_0 < invocationTemp_9;
    }

    int memberTemp_2 = dst.Length;
    sum = sum + "#" + memberTemp_2;
    return sum;
}

       
private string ForSimple_Array_ref_op4_in2(int b)
{
    string sum = "" + 3 + 4 + "";
    ConsoleCalculator.Engine invocationTemp_0 = car.GetEngine();
    ConsoleCalculator.Engine invocationTemp_1 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_2 = invocationTemp_1.GetPistons();
    int memberTemp_0 = invocationTemp_2.Count;
    ConsoleCalculator.Piston invocationTemp_3 = invocationTemp_0.GetPiston(memberTemp_0 - 1);
    string invocationTemp_4 = invocationTemp_3.ToString();
    sum = sum + invocationTemp_4;
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    int invocationTemp_5 = ReturnArg_Array(b);
    bool var_whileCondition_0 = var_forIndex_0 < invocationTemp_5;
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        ConsoleCalculator.Engine invocationTemp_6 = car.GetEngine();
        System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_7 = invocationTemp_6.GetPistons();
        ConsoleCalculator.Piston invocationTemp_8 = invocationTemp_7.First();
        double p1 = invocationTemp_8.GetSize();
        r = r + "[" + p1 + "]";
        int memberTemp_1 = r.Length;
        sum = sum + memberTemp_1;
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        int invocationTemp_9 = ReturnArg_Array(b);
        var_whileCondition_0 = var_forIndex_0 < invocationTemp_9;
    }

    int memberTemp_2 = dst.Length;
    sum = sum + "#" + memberTemp_2;
    return sum;
}


       
private string ForSimple_Array_ref_op4_in3(int b)
{
    string sum = "" + 3 + 4 + "";
    ConsoleCalculator.Engine invocationTemp_0 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_1 = invocationTemp_0.GetPistons();
    int memberTemp_0 = invocationTemp_1.Count;
    ConsoleCalculator.Piston invocationTemp_2 = car.GetEngine().GetPiston(memberTemp_0 - 1);
    sum = sum + invocationTemp_2.ToString();
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    int invocationTemp_3 = ReturnArg_Array(b);
    bool var_whileCondition_0 = var_forIndex_0 < invocationTemp_3;
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_4 = car.GetEngine().GetPistons();
        double p1 = invocationTemp_4.First().GetSize();
        r = r + "[" + p1 + "]";
        int memberTemp_1 = r.Length;
        sum = sum + memberTemp_1;
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    }

    int memberTemp_2 = dst.Length;
    sum = sum + "#" + memberTemp_2;
    return sum;
}
       
       
private string ForSimple_Array_ref_op4_in4(int b)
{
    string sum = "" + 3 + 4 + "";
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_0 = car.GetEngine().GetPistons();
    int memberTemp_0 = invocationTemp_0.Count;
    string invocationTemp_1 = car.GetEngine().GetPiston(memberTemp_0 - 1).ToString();
    sum = sum + invocationTemp_1;
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    bool var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_2 = car.GetEngine().GetPistons();
        double p1 = invocationTemp_2.First().GetSize();
        r = r + "[" + p1 + "]";
        int memberTemp_1 = r.Length;
        sum = sum + memberTemp_1;
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    }

    int memberTemp_2 = dst.Length;
    sum = sum + "#" + memberTemp_2;
    return sum;
}

        
private string ForSimple_Array_ref_op4_in5(int b)
{
    string sum = "" + 3 + 4 + "";
    int memberTemp_0 = car.GetEngine().GetPistons().Count;
    ConsoleCalculator.Piston invocationTemp_0 = car.GetEngine().GetPiston(memberTemp_0 - 1);
    sum = sum + invocationTemp_0.ToString();
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    bool var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_1 = car.GetEngine().GetPistons();
        double p1 = invocationTemp_1.First().GetSize();
        r = r + "[" + p1 + "]";
        int memberTemp_1 = r.Length;
        sum = sum + memberTemp_1;
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    }

    int memberTemp_2 = dst.Length;
    sum = sum + "#" + memberTemp_2;
    return sum;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForSimple_Array_obfuscated2_op4_in1(int b)
{
    //Virtualization variables
    int[] code = new int[100640];
    object[] data = new object[4600];
    int vpc = 74;

    //Data init
    data[2262]=b; //b 
    data[338]="" ; //"" constant
    data[3290]=3 ; //3 constant
    data[2944]=4 ; //4 constant
    data[2282]=1; //1 constant
    data[977]=0; //0 constant
    data[2695]="_" ; //"_" constant
    data[2478]="~"; //"~" constant
    data[2115]="#"; //"#" constant
    data[782]="[" ; //"[" constant
    data[1091]="]"; //"]" constant
    data[3044]=580772629; //sum 
    data[1586]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[1315]=(ConsoleCalculator.Engine)null; //invocationTemp_1 
    data[2794]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_2 
    data[3259]=-365; //memberTemp_0 
    data[3845]=(ConsoleCalculator.Piston)null; //invocationTemp_3 
    data[3759]=108831917; //invocationTemp_4 
    data[2048]=614725912; //r 
    data[3360]=(string[])null; //dst 
    data[480]=190; //var_forIndex_0 
    data[621]=689; //invocationTemp_5 
    data[2673]=false; //var_whileCondition_0 
    data[2235]=(ConsoleCalculator.Engine)null; //invocationTemp_6 
    data[3793]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_7 
    data[3658]=(ConsoleCalculator.Piston)null; //invocationTemp_8 
    data[1945]=(double)0.291733439216266; //p1 
    data[3832]=539; //memberTemp_1 
    data[2008]=59; //invocationTemp_9 
    data[1495]=-698; //memberTemp_2 
    data[1440]=159; //fake-1440 
    data[1987]=812; //fake-1987 
    data[1641]=169; //fake-1641 
    data[2623]=130; //fake-2623 
    data[620]=792; //fake-620 
    data[3463]=393; //fake-3463 
    data[1222]=-992; //fake-1222 
    data[184]=-770; //fake-184 
    data[530]=-265; //fake-530 
    data[2584]=496; //fake-2584 
    data[3913]=10; //fake-3913 
    data[3815]=40; //fake-3815 
    data[3663]=310; //fake-3663 
    data[1457]=-209; //fake-1457 
    data[608]=-723; //fake-608 
    data[860]=-587; //fake-860 
    data[3673]=690; //fake-3673 
    data[2463]=-582; //fake-2463 
    data[2575]=259; //fake-2575 
    data[1821]=-923; //fake-1821 
    data[3165]=-921; //fake-3165 
    data[2613]=-350; //fake-2613 
    data[2676]=156; //fake-2676 
    data[1211]=-966; //fake-1211 
    data[3213]=678; //fake-3213 
    data[3882]=-639; //fake-3882 
    data[1298]=-37; //fake-1298 
    data[3125]=-537; //fake-3125 
    data[2968]=-999; //fake-2968 
    data[2578]=481; //fake-2578 
    data[2864]=-701; //fake-2864 
    data[1]=-248; //fake-1 
    data[2106]=-199; //fake-2106 
    data[100]=-777; //fake-100 
    data[249]=-965; //fake-249 
    data[244]=139; //fake-244 
    data[1303]=-690; //fake-1303 
    data[2432]=962; //fake-2432 
    data[960]=-505; //fake-960 
    data[374]=-413; //fake-374 
    data[1119]=-720; //fake-1119 
    data[2717]=806; //jmpWhileDestinationName_2717 constant
    data[1279]=69; //while_GoTo_True_1279 constant
    data[1078]=1001; //while_GoTo_False_1078 constant
    data[1426]=-1001; //while_FalseBlockSkip_1426 constant
    data[1490]=-435; //fake-1490 
    data[2750]=105; //fake-2750 
    data[3464]=339; //fake-3464 
    data[1969]=500; //fake-1969 
    data[3671]=325; //fake-3671 
    data[2927]=310; //fake-2927 
    data[158]=-705; //fake-158 
    data[2501]=-224; //fake-2501 
    data[3508]=999; //fake-3508 
    data[1750]=-835; //fake-1750 
    data[3283]=-720; //fake-3283 
    data[3554]=-18; //fake-3554 
    data[3640]=-778; //fake-3640 
    data[3649]=-491; //fake-3649 
    data[2649]=-344; //fake-2649 
    data[3859]=135; //fake-3859 
    data[3817]=452; //fake-3817 
    data[2878]=431; //fake-2878 
    data[518]=-571; //fake-518 
    data[2389]=544; //fake-2389 
    data[3432]=-772; //fake-3432 
    data[552]=254; //fake-552 
    data[1583]=196; //fake-1583 
    data[3615]=-743; //fake-3615 
    data[101]=-762; //fake-101 
    data[3005]=87; //fake-3005 
    data[3810]=-245; //fake-3810 
    data[3010]=137; //fake-3010 
    data[2652]=-897; //fake-2652 
    data[149]=727; //fake-149 
    data[2248]=922; //fake-2248 
    data[1207]=-329; //fake-1207 
    data[470]=796; //fake-470 
    data[3873]=-727; //fake-3873 
    data[1016]=-916; //fake-1016 
    data[1202]=-950; //fake-1202 
    data[824]=-306; //fake-824 
    data[3537]=-823; //fake-3537 
    data[1684]=36; //fake-1684 
    data[1488]=653; //fake-1488 
    data[1076]=-832; //fake-1076 
    data[1021]=224; //fake-1021 
    data[1738]=482; //fake-1738 
    data[3555]=-866; //fake-3555 
    data[1320]=-528; //fake-1320 
    data[3711]=819; //fake-3711 
    data[3597]=-1000; //fake-3597 
    data[872]=525; //fake-872 
    data[2727]=-517; //fake-2727 
    data[1375]=175; //fake-1375 
    data[270]=-490; //fake-270 
    data[3140]=64; //fake-3140 
    data[2813]=-842; //fake-2813 
    data[3282]=-265; //fake-3282 
    data[1429]=577; //fake-1429 
    data[3834]=311; //fake-3834 
    data[740]=909; //fake-740 
    data[3898]=82; //fake-3898 
    data[320]=261; //fake-320 
    data[956]=-763; //fake-956 
    data[2838]=-446; //fake-2838 
    data[3440]=158; //fake-3440 
    data[2774]=-327; //fake-2774 
    data[3386]=-729; //fake-3386 

    //Code init

    code[74]=5774; //ExpressionStatement_0 # ExpressionStatement_0
    code[54]=3044; //sum
    code[75]=338; //""
    code[65]=3290; //3
    code[85]=2944; //4
    code[64]=338; //""
    code[59]=1655; //fake-ExpressionStatement_0_1655_-15

    code[130]=7716; //ExpressionStatement_1 # ExpressionStatement_1
    code[125]=1586; //invocationTemp_0
    code[129]=570; //fake-ExpressionStatement_1_570_-1
    code[149]=2374; //fake-ExpressionStatement_1_2374_19
    code[149]=1054; //fake-ExpressionStatement_1_1054_19
    code[115]=2862; //fake-ExpressionStatement_1_2862_-15
    code[117]=2526; //fake-ExpressionStatement_1_2526_-13

    code[196]=7716; //ExpressionStatement_1 # ExpressionStatement_2
    code[191]=1315; //invocationTemp_1
    code[212]=1532; //fake-ExpressionStatement_1_1532_16
    code[211]=86; //fake-ExpressionStatement_1_86_15
    code[186]=2028; //fake-ExpressionStatement_1_2028_-10

    code[262]=6043; //ExpressionStatement_3 # ExpressionStatement_3
    code[291]=2794; //invocationTemp_2
    code[244]=1315; //invocationTemp_1
    code[278]=30; //fake-ExpressionStatement_3_30_16
    code[263]=672; //fake-ExpressionStatement_3_672_1
    code[256]=411; //fake-ExpressionStatement_3_411_-6
    code[271]=1679; //fake-ExpressionStatement_3_1679_9

    code[321]=7373; //ExpressionStatement_4 # ExpressionStatement_4
    code[333]=3259; //memberTemp_0
    code[310]=2794; //invocationTemp_2
    code[305]=2288; //fake-ExpressionStatement_4_2288_-16

    code[388]=7807; //ExpressionStatement_5 # ExpressionStatement_5
    code[394]=3845; //invocationTemp_3
    code[397]=1586; //invocationTemp_0
    code[375]=3259; //memberTemp_0
    code[405]=2282; //1
    code[400]=2397; //fake-ExpressionStatement_5_2397_12
    code[372]=2502; //fake-ExpressionStatement_5_2502_-16
    code[410]=1307; //fake-ExpressionStatement_5_1307_22
    code[372]=367; //fake-ExpressionStatement_5_367_-16

    code[453]=2223; //ExpressionStatement_6 # ExpressionStatement_6
    code[463]=3759; //invocationTemp_4
    code[450]=3845; //invocationTemp_3
    code[454]=2444; //fake-ExpressionStatement_6_2444_1
    code[475]=1940; //fake-ExpressionStatement_6_1940_22
    code[459]=3789; //fake-ExpressionStatement_6_3789_6

    code[522]=7862; //ExpressionStatement_7 # ExpressionStatement_7
    code[541]=3044; //sum
    code[532]=3044; //sum
    code[529]=3759; //invocationTemp_4
    code[527]=3455; //fake-ExpressionStatement_7_3455_5
    code[527]=1089; //fake-ExpressionStatement_7_1089_5
    code[524]=1226; //fake-ExpressionStatement_7_1226_2

    code[583]=8318; //ExpressionStatement_8 # ExpressionStatement_8
    code[565]=2048; //r
    code[598]=338; //""
    code[593]=1375; //fake-ExpressionStatement_8_1375_10
    code[612]=3485; //fake-ExpressionStatement_8_3485_29
    code[587]=1200; //fake-ExpressionStatement_8_1200_4

    code[649]=4889; //ExpressionStatement_9 # ExpressionStatement_9
    code[641]=3360; //dst
    code[631]=2262; //b
    code[634]=3975; //fake-ExpressionStatement_9_3975_-15
    code[677]=37; //fake-ExpressionStatement_9_37_28
    code[650]=594; //fake-ExpressionStatement_9_594_1
    code[647]=3912; //fake-ExpressionStatement_9_3912_-2
    code[632]=1185; //fake-ExpressionStatement_9_1185_-17
    code[678]=3558; //fake-ExpressionStatement_9_3558_29
    code[677]=3240; //fake-ExpressionStatement_9_3240_28

    code[715]=8318; //ExpressionStatement_8 # ExpressionStatement_10
    code[697]=480; //var_forIndex_0
    code[730]=977; //0
    code[731]=3496; //fake-ExpressionStatement_8_3496_16

    code[781]=8245; //ExpressionStatement_11 # ExpressionStatement_11
    code[808]=621; //invocationTemp_5
    code[807]=2262; //b
    code[792]=1337; //fake-ExpressionStatement_11_1337_11
    code[789]=2890; //fake-ExpressionStatement_11_2890_8
    code[766]=1287; //fake-ExpressionStatement_11_1287_-15
    code[793]=543; //fake-ExpressionStatement_11_543_12

    code[847]=2063; //ExpressionStatement_12 # ExpressionStatement_12
    code[855]=2673; //var_whileCondition_0
    code[831]=480; //var_forIndex_0
    code[834]=621; //invocationTemp_5
    code[846]=3795; //fake-ExpressionStatement_12_3795_-1
    code[856]=2786; //fake-ExpressionStatement_12_2786_9

    code[900]=6605; //WhileStatementSyntax_13 # WhileStatementSyntax_13
    code[918]=2717; //jmpWhileDestinationName_2717
    code[919]=2673; //var_whileCondition_0
    code[916]=1279; //while_GoTo_True_1279
    code[898]=1078; //while_GoTo_False_1078
    code[902]=2375; //fake-fake-whileVirtualOperation_2375_2
    code[885]=88; //fake-fake-whileVirtualOperation_88_-15
    code[917]=2328; //fake-fake-whileVirtualOperation_2328_17
    code[922]=2892; //fake-fake-whileVirtualOperation_2892_22

    code[969]=3889; //ExpressionStatement_14 # ExpressionStatement_14
    code[994]=3044; //sum
    code[985]=3044; //sum
    code[965]=2695; //"_"
    code[952]=480; //var_forIndex_0
    code[990]=2695; //"_"
    code[986]=2747; //fake-ExpressionStatement_14_2747_17
    code[963]=1488; //fake-ExpressionStatement_14_1488_-6
    code[971]=1904; //fake-ExpressionStatement_14_1904_2
    code[956]=837; //fake-ExpressionStatement_14_837_-13
    code[967]=2728; //fake-ExpressionStatement_14_2728_-2
    code[988]=2541; //fake-ExpressionStatement_14_2541_19

    code[1037]=7862; //ExpressionStatement_7 # ExpressionStatement_15
    code[1056]=3044; //sum
    code[1047]=3044; //sum
    code[1044]=2478; //"~"
    code[1036]=3325; //fake-ExpressionStatement_7_3325_-1
    code[1043]=3081; //fake-ExpressionStatement_7_3081_6
    code[1041]=1973; //fake-ExpressionStatement_7_1973_4
    code[1036]=3782; //fake-ExpressionStatement_7_3782_-1
    code[1059]=65; //fake-ExpressionStatement_7_65_22

    code[1098]=6517; //ExpressionStatement_16 # ExpressionStatement_16
    code[1103]=2048; //r
    code[1122]=2048; //r
    code[1110]=3044; //sum
    code[1096]=2115; //"#"
    code[1085]=3780; //fake-ExpressionStatement_16_3780_-13

    code[1154]=7716; //ExpressionStatement_1 # ExpressionStatement_17
    code[1149]=2235; //invocationTemp_6
    code[1161]=376; //fake-ExpressionStatement_1_376_7
    code[1169]=6; //fake-ExpressionStatement_1_6_15
    code[1169]=3932; //fake-ExpressionStatement_1_3932_15
    code[1170]=1761; //fake-ExpressionStatement_1_1761_16
    code[1164]=804; //fake-ExpressionStatement_1_804_10
    code[1140]=2047; //fake-ExpressionStatement_1_2047_-14
    code[1172]=2489; //fake-ExpressionStatement_1_2489_18

    code[1220]=6043; //ExpressionStatement_3 # ExpressionStatement_18
    code[1249]=3793; //invocationTemp_7
    code[1202]=2235; //invocationTemp_6
    code[1217]=3258; //fake-ExpressionStatement_3_3258_-3
    code[1242]=2537; //fake-ExpressionStatement_3_2537_22
    code[1200]=109; //fake-ExpressionStatement_3_109_-20
    code[1231]=3426; //fake-ExpressionStatement_3_3426_11
    code[1222]=3206; //fake-ExpressionStatement_3_3206_2

    code[1279]=7054; //ExpressionStatement_19 # ExpressionStatement_19
    code[1285]=3658; //invocationTemp_8
    code[1305]=3793; //invocationTemp_7
    code[1307]=1004; //fake-ExpressionStatement_19_1004_28

    code[1345]=3144; //ExpressionStatement_20 # ExpressionStatement_20
    code[1362]=1945; //p1
    code[1363]=3658; //invocationTemp_8
    code[1328]=1490; //fake-ExpressionStatement_20_1490_-17
    code[1330]=3538; //fake-ExpressionStatement_20_3538_-15

    code[1408]=6440; //ExpressionStatement_21 # ExpressionStatement_21
    code[1388]=2048; //r
    code[1420]=2048; //r
    code[1412]=782; //"["
    code[1404]=1945; //p1
    code[1390]=1091; //"]"
    code[1399]=1221; //fake-ExpressionStatement_21_1221_-9
    code[1428]=282; //fake-ExpressionStatement_21_282_20
    code[1432]=1532; //fake-ExpressionStatement_21_1532_24
    code[1426]=6; //fake-ExpressionStatement_21_6_18

    code[1479]=1796; //ExpressionStatement_22 # ExpressionStatement_22
    code[1460]=3832; //memberTemp_1
    code[1497]=2048; //r
    code[1459]=2606; //fake-ExpressionStatement_22_2606_-20
    code[1505]=2281; //fake-ExpressionStatement_22_2281_26

    code[1540]=6361; //ExpressionStatement_23 # ExpressionStatement_23
    code[1544]=3044; //sum
    code[1568]=3044; //sum
    code[1530]=3832; //memberTemp_1
    code[1569]=1401; //fake-ExpressionStatement_23_1401_29

    code[1602]=6050; //ExpressionStatement_24 # ExpressionStatement_24
    code[1631]=3360; //dst
    code[1603]=480; //var_forIndex_0
    code[1585]=3044; //sum
    code[1623]=689; //fake-ExpressionStatement_24_689_21
    code[1583]=2266; //fake-ExpressionStatement_24_2266_-19
    code[1614]=3081; //fake-ExpressionStatement_24_3081_12
    code[1607]=318; //fake-ExpressionStatement_24_318_5
    code[1621]=2641; //fake-ExpressionStatement_24_2641_19

    code[1663]=5703; //ExpressionStatement_25 # ExpressionStatement_25
    code[1685]=480; //var_forIndex_0
    code[1653]=480; //var_forIndex_0
    code[1650]=2282; //1
    code[1666]=1455; //fake-ExpressionStatement_25_1455_3

    code[1731]=8245; //ExpressionStatement_11 # ExpressionStatement_26
    code[1758]=2008; //invocationTemp_9
    code[1757]=2262; //b
    code[1722]=84; //fake-ExpressionStatement_11_84_-9
    code[1754]=394; //fake-ExpressionStatement_11_394_23

    code[1797]=2063; //ExpressionStatement_12 # ExpressionStatement_27
    code[1805]=2673; //var_whileCondition_0
    code[1781]=480; //var_forIndex_0
    code[1784]=2008; //invocationTemp_9
    code[1812]=785; //fake-ExpressionStatement_12_785_15
    code[1804]=576; //fake-ExpressionStatement_12_576_7
    code[1819]=2705; //fake-ExpressionStatement_12_2705_22
    code[1803]=2307; //fake-ExpressionStatement_12_2307_6

    code[1850]=9860; //ExpressionStatement_28 # ExpressionStatement_28
    code[1864]=1426; //while_FalseBlockSkip_1426
    code[1871]=2694; //fake-ExpressionStatement_28_2694_21
    code[1839]=1697; //fake-ExpressionStatement_28_1697_-11
    code[1869]=408; //fake-ExpressionStatement_28_408_19
    code[1879]=3033; //fake-ExpressionStatement_28_3033_29
    code[1858]=1446; //fake-ExpressionStatement_28_1446_8
    code[1868]=923; //fake-ExpressionStatement_28_923_18

    code[1901]=1706; //ExpressionStatement_29 # ExpressionStatement_29
    code[1925]=1495; //memberTemp_2
    code[1889]=3360; //dst
    code[1910]=3505; //fake-ExpressionStatement_29_3505_9
    code[1902]=56; //fake-ExpressionStatement_29_56_1

    code[1962]=2942; //ExpressionStatement_30 # ExpressionStatement_30
    code[1944]=3044; //sum
    code[1961]=3044; //sum
    code[1991]=2115; //"#"
    code[1983]=1495; //memberTemp_2
    code[1965]=2058; //fake-ExpressionStatement_30_2058_3
    code[1950]=3443; //fake-ExpressionStatement_30_3443_-12
    code[1973]=28; //fake-ExpressionStatement_30_28_11

    code[2034]=2372; //ReturnStatement_31 # ReturnStatement_31
    code[2058]=3044; //sum
    code[2049]=3215; //fake-ReturnStatement_31_3215_15
    code[2014]=912; //fake-ReturnStatement_31_912_-20
    code[2032]=1990; //fake-ReturnStatement_31_1990_-2

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_3664_2_op4_in1(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated2_op4_in2(int b)
{
    //Virtualization variables
    int[] code = new int[100869];
    object[] data = new object[4244];
    int vpc = 36;

    //Data init
    data[2311]=b; //b 
    data[2367]="" ; //"" constant
    data[835]=3 ; //3 constant
    data[1382]=4 ; //4 constant
    data[746]=1; //1 constant
    data[2829]=0; //0 constant
    data[873]="_" ; //"_" constant
    data[1281]="~"; //"~" constant
    data[3485]="#"; //"#" constant
    data[3249]="[" ; //"[" constant
    data[1847]="]"; //"]" constant
    data[2921]=253115470; //sum 
    data[2135]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[2193]=(ConsoleCalculator.Engine)null; //invocationTemp_1 
    data[3263]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_2 
    data[1603]=-352; //memberTemp_0 
    data[64]=(ConsoleCalculator.Piston)null; //invocationTemp_3 
    data[2924]=529691550; //invocationTemp_4 
    data[906]=448189483; //r 
    data[1232]=(string[])null; //dst 
    data[3363]=-591; //var_forIndex_0 
    data[998]=-127; //invocationTemp_5 
    data[1935]=false; //var_whileCondition_0 
    data[2491]=(ConsoleCalculator.Engine)null; //invocationTemp_6 
    data[3865]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_7 
    data[105]=(ConsoleCalculator.Piston)null; //invocationTemp_8 
    data[351]=(double)0.0763740581815942; //p1 
    data[2348]=-481; //memberTemp_1 
    data[2058]=-893; //invocationTemp_9 
    data[309]=503; //memberTemp_2 
    data[2610]=420; //jmpWhileDestinationName_2610 constant
    data[1863]=67; //while_GoTo_True_1863 constant
    data[3304]=1014; //while_GoTo_False_3304 constant
    data[2669]=-1014; //while_FalseBlockSkip_2669 constant

    //Code init

    code[36]=8744; //ExpressionStatement_0 # ExpressionStatement_0
    code[41]=2921; //sum
    code[58]=2367; //""
    code[20]=835; //3
    code[29]=1382; //4
    code[33]=2367; //""

    code[102]=3603; //ExpressionStatement_1 # ExpressionStatement_1
    code[91]=2135; //invocationTemp_0

    code[162]=3603; //ExpressionStatement_1 # ExpressionStatement_2
    code[151]=2193; //invocationTemp_1

    code[222]=5550; //ExpressionStatement_3 # ExpressionStatement_3
    code[240]=3263; //invocationTemp_2
    code[220]=2193; //invocationTemp_1

    code[286]=6602; //ExpressionStatement_4 # ExpressionStatement_4
    code[296]=1603; //memberTemp_0
    code[285]=3263; //invocationTemp_2

    code[348]=1972; //ExpressionStatement_5 # ExpressionStatement_5
    code[346]=64; //invocationTemp_3
    code[336]=2135; //invocationTemp_0
    code[358]=1603; //memberTemp_0
    code[359]=746; //1

    code[413]=8147; //ExpressionStatement_6 # ExpressionStatement_6
    code[422]=2924; //invocationTemp_4
    code[417]=64; //invocationTemp_3

    code[478]=9852; //ExpressionStatement_7 # ExpressionStatement_7
    code[485]=2921; //sum
    code[504]=2921; //sum
    code[480]=2924; //invocationTemp_4

    code[537]=3768; //ExpressionStatement_8 # ExpressionStatement_8
    code[555]=906; //r
    code[531]=2367; //""

    code[600]=4038; //ExpressionStatement_9 # ExpressionStatement_9
    code[602]=1232; //dst
    code[620]=2311; //b

    code[662]=3768; //ExpressionStatement_8 # ExpressionStatement_10
    code[680]=3363; //var_forIndex_0
    code[656]=2829; //0

    code[725]=5836; //ExpressionStatement_11 # ExpressionStatement_11
    code[736]=998; //invocationTemp_5
    code[728]=2311; //b

    code[783]=4592; //ExpressionStatement_12 # ExpressionStatement_12
    code[798]=1935; //var_whileCondition_0
    code[768]=3363; //var_forIndex_0
    code[799]=998; //invocationTemp_5

    code[841]=5350; //WhileStatementSyntax_13 # WhileStatementSyntax_13
    code[858]=2610; //jmpWhileDestinationName_2610
    code[847]=1935; //var_whileCondition_0
    code[828]=1863; //while_GoTo_True_1863
    code[862]=3304; //while_GoTo_False_3304

    code[908]=3761; //ExpressionStatement_14 # ExpressionStatement_14
    code[915]=2921; //sum
    code[928]=2921; //sum
    code[902]=873; //"_"
    code[890]=3363; //var_forIndex_0
    code[919]=873; //"_"

    code[979]=9852; //ExpressionStatement_7 # ExpressionStatement_15
    code[986]=2921; //sum
    code[1005]=2921; //sum
    code[981]=1281; //"~"

    code[1038]=6991; //ExpressionStatement_16 # ExpressionStatement_16
    code[1023]=906; //r
    code[1030]=906; //r
    code[1060]=2921; //sum
    code[1028]=3485; //"#"

    code[1099]=3603; //ExpressionStatement_1 # ExpressionStatement_17
    code[1088]=2491; //invocationTemp_6

    code[1159]=5550; //ExpressionStatement_3 # ExpressionStatement_18
    code[1177]=3865; //invocationTemp_7
    code[1157]=2491; //invocationTemp_6

    code[1223]=3067; //ExpressionStatement_19 # ExpressionStatement_19
    code[1209]=105; //invocationTemp_8
    code[1249]=3865; //invocationTemp_7

    code[1281]=1734; //ExpressionStatement_20 # ExpressionStatement_20
    code[1288]=351; //p1
    code[1270]=105; //invocationTemp_8

    code[1348]=8188; //ExpressionStatement_21 # ExpressionStatement_21
    code[1343]=906; //r
    code[1361]=906; //r
    code[1346]=3249; //"["
    code[1344]=351; //p1
    code[1359]=1847; //"]"

    code[1409]=6308; //ExpressionStatement_22 # ExpressionStatement_22
    code[1422]=2348; //memberTemp_1
    code[1412]=906; //r

    code[1480]=5954; //ExpressionStatement_23 # ExpressionStatement_23
    code[1474]=2921; //sum
    code[1484]=2921; //sum
    code[1491]=2348; //memberTemp_1

    code[1549]=6007; //ExpressionStatement_24 # ExpressionStatement_24
    code[1554]=1232; //dst
    code[1570]=3363; //var_forIndex_0
    code[1555]=2921; //sum

    code[1612]=7907; //ExpressionStatement_25 # ExpressionStatement_25
    code[1594]=3363; //var_forIndex_0
    code[1629]=3363; //var_forIndex_0
    code[1634]=746; //1

    code[1674]=5836; //ExpressionStatement_11 # ExpressionStatement_26
    code[1685]=2058; //invocationTemp_9
    code[1677]=2311; //b

    code[1732]=4592; //ExpressionStatement_12 # ExpressionStatement_27
    code[1747]=1935; //var_whileCondition_0
    code[1717]=3363; //var_forIndex_0
    code[1748]=2058; //invocationTemp_9

    code[1790]=4169; //ExpressionStatement_28 # ExpressionStatement_28
    code[1807]=2669; //while_FalseBlockSkip_2669

    code[1855]=6067; //ExpressionStatement_29 # ExpressionStatement_29
    code[1850]=309; //memberTemp_2
    code[1863]=1232; //dst

    code[1908]=6045; //ExpressionStatement_30 # ExpressionStatement_30
    code[1900]=2921; //sum
    code[1927]=2921; //sum
    code[1905]=3485; //"#"
    code[1891]=309; //memberTemp_2

    code[1969]=1508; //ReturnStatement_31 # ReturnStatement_31
    code[1988]=2921; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_913_2_op4_in2(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated2_op4_in3(int b)
{
    //Virtualization variables
    int[] code = new int[100612];
    object[] data = new object[4959];
    int vpc = 116;

    //Data init
    data[1828]=b; //b 
    data[123]="" ; //"" constant
    data[2435]=3 ; //3 constant
    data[1805]=4 ; //4 constant
    data[997]=1; //1 constant
    data[2989]=0; //0 constant
    data[2099]="_" ; //"_" constant
    data[2791]="~"; //"~" constant
    data[365]="#"; //"#" constant
    data[1855]="[" ; //"[" constant
    data[12]="]"; //"]" constant
    data[843]=1290348670; //sum 
    data[3782]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[2756]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[1728]=-780; //memberTemp_0 
    data[3972]=(ConsoleCalculator.Piston)null; //invocationTemp_2 
    data[538]=2023170179; //r 
    data[1098]=(string[])null; //dst 
    data[1812]=-536; //var_forIndex_0 
    data[2972]=-238; //invocationTemp_3 
    data[3051]=false; //var_whileCondition_0 
    data[886]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_4 
    data[2974]=(double)0.559951857458778; //p1 
    data[2610]=940; //memberTemp_1 
    data[1104]=-455; //memberTemp_2 
    data[2745]=-239; //jmpWhileDestinationName_2745 constant
    data[2384]=61; //while_GoTo_True_2384 constant
    data[2355]=816; //while_GoTo_False_2355 constant
    data[645]=-816; //while_FalseBlockSkip_645 constant

    //Code init

    code[116]=1395; //ExpressionStatement_0 # ExpressionStatement_0
    code[99]=843; //sum
    code[129]=123; //""
    code[115]=2435; //3
    code[128]=1805; //4
    code[124]=123; //""

    code[182]=8970; //ExpressionStatement_1 # ExpressionStatement_1
    code[199]=3782; //invocationTemp_0

    code[247]=3718; //ExpressionStatement_2 # ExpressionStatement_2
    code[249]=2756; //invocationTemp_1
    code[265]=3782; //invocationTemp_0

    code[314]=3792; //ExpressionStatement_3 # ExpressionStatement_3
    code[307]=1728; //memberTemp_0
    code[298]=2756; //invocationTemp_1

    code[374]=2505; //ExpressionStatement_4 # ExpressionStatement_4
    code[401]=3972; //invocationTemp_2
    code[365]=1728; //memberTemp_0
    code[368]=997; //1

    code[427]=2578; //ExpressionStatement_5 # ExpressionStatement_5
    code[413]=843; //sum
    code[435]=843; //sum
    code[439]=3972; //invocationTemp_2

    code[485]=4590; //ExpressionStatement_6 # ExpressionStatement_6
    code[505]=538; //r
    code[480]=123; //""

    code[543]=1364; //ExpressionStatement_7 # ExpressionStatement_7
    code[536]=1098; //dst
    code[542]=1828; //b

    code[603]=4590; //ExpressionStatement_6 # ExpressionStatement_8
    code[623]=1812; //var_forIndex_0
    code[598]=2989; //0

    code[661]=9526; //ExpressionStatement_9 # ExpressionStatement_9
    code[689]=2972; //invocationTemp_3
    code[650]=1828; //b

    code[731]=3200; //ExpressionStatement_10 # ExpressionStatement_10
    code[738]=3051; //var_whileCondition_0
    code[749]=1812; //var_forIndex_0
    code[735]=2972; //invocationTemp_3

    code[790]=5450; //WhileStatementSyntax_11 # WhileStatementSyntax_11
    code[791]=2745; //jmpWhileDestinationName_2745
    code[804]=3051; //var_whileCondition_0
    code[775]=2384; //while_GoTo_True_2384
    code[800]=2355; //while_GoTo_False_2355

    code[851]=7974; //ExpressionStatement_12 # ExpressionStatement_12
    code[836]=843; //sum
    code[878]=843; //sum
    code[845]=2099; //"_"
    code[849]=1812; //var_forIndex_0
    code[873]=2099; //"_"

    code[913]=1197; //ExpressionStatement_13 # ExpressionStatement_13
    code[894]=843; //sum
    code[942]=843; //sum
    code[908]=2791; //"~"

    code[974]=7817; //ExpressionStatement_14 # ExpressionStatement_14
    code[956]=538; //r
    code[995]=538; //r
    code[954]=843; //sum
    code[998]=365; //"#"

    code[1041]=7703; //ExpressionStatement_15 # ExpressionStatement_15
    code[1042]=886; //invocationTemp_4

    code[1108]=6319; //ExpressionStatement_16 # ExpressionStatement_16
    code[1128]=2974; //p1
    code[1117]=886; //invocationTemp_4

    code[1178]=2262; //ExpressionStatement_17 # ExpressionStatement_17
    code[1197]=538; //r
    code[1165]=538; //r
    code[1188]=1855; //"["
    code[1162]=2974; //p1
    code[1185]=12; //"]"

    code[1249]=1132; //ExpressionStatement_18 # ExpressionStatement_18
    code[1274]=2610; //memberTemp_1
    code[1262]=538; //r

    code[1304]=1510; //ExpressionStatement_19 # ExpressionStatement_19
    code[1319]=843; //sum
    code[1289]=843; //sum
    code[1323]=2610; //memberTemp_1

    code[1363]=1164; //ExpressionStatement_20 # ExpressionStatement_20
    code[1380]=1098; //dst
    code[1351]=1812; //var_forIndex_0
    code[1356]=843; //sum

    code[1427]=6641; //ExpressionStatement_21 # ExpressionStatement_21
    code[1432]=1812; //var_forIndex_0
    code[1447]=1812; //var_forIndex_0
    code[1441]=997; //1

    code[1485]=1335; //ExpressionStatement_22 # ExpressionStatement_22
    code[1476]=3051; //var_whileCondition_0
    code[1479]=1812; //var_forIndex_0
    code[1475]=1828; //b

    code[1542]=7415; //ExpressionStatement_23 # ExpressionStatement_23
    code[1527]=645; //while_FalseBlockSkip_645

    code[1606]=8314; //ExpressionStatement_24 # ExpressionStatement_24
    code[1604]=1104; //memberTemp_2
    code[1591]=1098; //dst

    code[1677]=1849; //ExpressionStatement_25 # ExpressionStatement_25
    code[1680]=843; //sum
    code[1664]=843; //sum
    code[1705]=365; //"#"
    code[1685]=1104; //memberTemp_2

    code[1749]=4449; //ReturnStatement_26 # ReturnStatement_26
    code[1754]=843; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_2835_2_op4_in3(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated2_op4_in4(int b)
{
    //Virtualization variables
    int[] code = new int[100668];
    object[] data = new object[4842];
    int vpc = 109;

    //Data init
    data[3129]=b; //b 
    data[3526]="" ; //"" constant
    data[232]=3 ; //3 constant
    data[1156]=4 ; //4 constant
    data[1441]=1; //1 constant
    data[98]=0; //0 constant
    data[916]="_" ; //"_" constant
    data[1115]="~"; //"~" constant
    data[3865]="#"; //"#" constant
    data[2343]="[" ; //"[" constant
    data[214]="]"; //"]" constant
    data[1618]=1426291964; //sum 
    data[1644]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_0 
    data[3052]=-993; //memberTemp_0 
    data[3078]=2075095712; //invocationTemp_1 
    data[3838]=637460966; //r 
    data[366]=(string[])null; //dst 
    data[1894]=-437; //var_forIndex_0 
    data[657]=false; //var_whileCondition_0 
    data[2515]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_2 
    data[1239]=(double)0.271554201036484; //p1 
    data[2482]=58; //memberTemp_1 
    data[1821]=-897; //memberTemp_2 
    data[606]=-583; //jmpWhileDestinationName_606 constant
    data[2817]=68; //while_GoTo_True_2817 constant
    data[2185]=774; //while_GoTo_False_2185 constant
    data[2377]=-774; //while_FalseBlockSkip_2377 constant

    //Code init

    code[109]=7526; //ExpressionStatement_0 # ExpressionStatement_0
    code[114]=1618; //sum
    code[118]=3526; //""
    code[96]=232; //3
    code[128]=1156; //4
    code[138]=3526; //""

    code[172]=6090; //ExpressionStatement_1 # ExpressionStatement_1
    code[155]=1644; //invocationTemp_0

    code[230]=2933; //ExpressionStatement_2 # ExpressionStatement_2
    code[255]=3052; //memberTemp_0
    code[213]=1644; //invocationTemp_0

    code[290]=9729; //ExpressionStatement_3 # ExpressionStatement_3
    code[286]=3078; //invocationTemp_1
    code[294]=3052; //memberTemp_0
    code[287]=1441; //1

    code[355]=6453; //ExpressionStatement_4 # ExpressionStatement_4
    code[368]=1618; //sum
    code[384]=1618; //sum
    code[343]=3078; //invocationTemp_1

    code[420]=2506; //ExpressionStatement_5 # ExpressionStatement_5
    code[425]=3838; //r
    code[414]=3526; //""

    code[484]=7925; //ExpressionStatement_6 # ExpressionStatement_6
    code[485]=366; //dst
    code[476]=3129; //b

    code[543]=2506; //ExpressionStatement_5 # ExpressionStatement_7
    code[548]=1894; //var_forIndex_0
    code[537]=98; //0

    code[607]=7895; //ExpressionStatement_8 # ExpressionStatement_8
    code[606]=657; //var_whileCondition_0
    code[624]=1894; //var_forIndex_0
    code[631]=3129; //b

    code[661]=4422; //WhileStatementSyntax_9 # WhileStatementSyntax_9
    code[650]=606; //jmpWhileDestinationName_606
    code[675]=657; //var_whileCondition_0
    code[660]=2817; //while_GoTo_True_2817
    code[687]=2185; //while_GoTo_False_2185

    code[729]=8517; //ExpressionStatement_10 # ExpressionStatement_10
    code[728]=1618; //sum
    code[745]=1618; //sum
    code[736]=916; //"_"
    code[732]=1894; //var_forIndex_0
    code[741]=916; //"_"

    code[789]=6453; //ExpressionStatement_4 # ExpressionStatement_11
    code[802]=1618; //sum
    code[818]=1618; //sum
    code[777]=1115; //"~"

    code[854]=9232; //ExpressionStatement_12 # ExpressionStatement_12
    code[875]=3838; //r
    code[862]=3838; //r
    code[855]=1618; //sum
    code[882]=3865; //"#"

    code[909]=6090; //ExpressionStatement_1 # ExpressionStatement_13
    code[892]=2515; //invocationTemp_2

    code[967]=2924; //ExpressionStatement_14 # ExpressionStatement_14
    code[952]=1239; //p1
    code[969]=2515; //invocationTemp_2

    code[1024]=5044; //ExpressionStatement_15 # ExpressionStatement_15
    code[1020]=3838; //r
    code[1049]=3838; //r
    code[1047]=2343; //"["
    code[1034]=1239; //p1
    code[1037]=214; //"]"

    code[1097]=1624; //ExpressionStatement_16 # ExpressionStatement_16
    code[1088]=2482; //memberTemp_1
    code[1123]=3838; //r

    code[1150]=9963; //ExpressionStatement_17 # ExpressionStatement_17
    code[1172]=1618; //sum
    code[1176]=1618; //sum
    code[1130]=2482; //memberTemp_1

    code[1203]=2516; //ExpressionStatement_18 # ExpressionStatement_18
    code[1223]=366; //dst
    code[1214]=1894; //var_forIndex_0
    code[1201]=1618; //sum

    code[1270]=5643; //ExpressionStatement_19 # ExpressionStatement_19
    code[1277]=1894; //var_forIndex_0
    code[1267]=1894; //var_forIndex_0
    code[1298]=1441; //1

    code[1326]=7895; //ExpressionStatement_8 # ExpressionStatement_20
    code[1325]=657; //var_whileCondition_0
    code[1343]=1894; //var_forIndex_0
    code[1350]=3129; //b

    code[1380]=4453; //ExpressionStatement_21 # ExpressionStatement_21
    code[1407]=2377; //while_FalseBlockSkip_2377

    code[1435]=6071; //ExpressionStatement_22 # ExpressionStatement_22
    code[1416]=1821; //memberTemp_2
    code[1458]=366; //dst

    code[1497]=8607; //ExpressionStatement_23 # ExpressionStatement_23
    code[1507]=1618; //sum
    code[1508]=1618; //sum
    code[1509]=3865; //"#"
    code[1525]=1821; //memberTemp_2

    code[1551]=4043; //ReturnStatement_24 # ReturnStatement_24
    code[1543]=1618; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_1236_2_op4_in4(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated2_op4_in5(int b)
{
    //Virtualization variables
    int[] code = new int[100962];
    object[] data = new object[4842];
    int vpc = 78;

    //Data init
    data[791]=b; //b 
    data[1679]="" ; //"" constant
    data[1079]=3 ; //3 constant
    data[1920]=4 ; //4 constant
    data[2222]=1; //1 constant
    data[2050]=0; //0 constant
    data[86]="_" ; //"_" constant
    data[2934]="~"; //"~" constant
    data[454]="#"; //"#" constant
    data[520]="[" ; //"[" constant
    data[2332]="]"; //"]" constant
    data[2431]=1952909025; //sum 
    data[3295]=875; //memberTemp_0 
    data[2]=(ConsoleCalculator.Piston)null; //invocationTemp_0 
    data[143]=1466123585; //r 
    data[3578]=(string[])null; //dst 
    data[3783]=243; //var_forIndex_0 
    data[3158]=false; //var_whileCondition_0 
    data[3947]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[2276]=(double)0.0422941758494331; //p1 
    data[3987]=177; //memberTemp_1 
    data[1571]=-447; //memberTemp_2 
    data[2621]=-925; //jmpWhileDestinationName_2621 constant
    data[80]=57; //while_GoTo_True_80 constant
    data[237]=777; //while_GoTo_False_237 constant
    data[82]=-777; //while_FalseBlockSkip_82 constant

    //Code init

    code[78]=5734; //ExpressionStatement_0 # ExpressionStatement_0
    code[65]=2431; //sum
    code[87]=1679; //""
    code[91]=1079; //3
    code[69]=1920; //4
    code[83]=1679; //""

    code[149]=6978; //ExpressionStatement_1 # ExpressionStatement_1
    code[177]=3295; //memberTemp_0

    code[216]=1116; //ExpressionStatement_2 # ExpressionStatement_2
    code[241]=2; //invocationTemp_0
    code[208]=3295; //memberTemp_0
    code[213]=2222; //1

    code[275]=5692; //ExpressionStatement_3 # ExpressionStatement_3
    code[296]=2431; //sum
    code[297]=2431; //sum
    code[261]=2; //invocationTemp_0

    code[345]=9041; //ExpressionStatement_4 # ExpressionStatement_4
    code[365]=143; //r
    code[350]=1679; //""

    code[398]=8243; //ExpressionStatement_5 # ExpressionStatement_5
    code[393]=3578; //dst
    code[409]=791; //b

    code[466]=9041; //ExpressionStatement_4 # ExpressionStatement_6
    code[486]=3783; //var_forIndex_0
    code[471]=2050; //0

    code[519]=8931; //ExpressionStatement_7 # ExpressionStatement_7
    code[521]=3158; //var_whileCondition_0
    code[544]=3783; //var_forIndex_0
    code[502]=791; //b

    code[575]=2437; //WhileStatementSyntax_8 # WhileStatementSyntax_8
    code[601]=2621; //jmpWhileDestinationName_2621
    code[558]=3158; //var_whileCondition_0
    code[577]=80; //while_GoTo_True_80
    code[571]=237; //while_GoTo_False_237

    code[632]=7138; //ExpressionStatement_9 # ExpressionStatement_9
    code[635]=2431; //sum
    code[646]=2431; //sum
    code[642]=86; //"_"
    code[653]=3783; //var_forIndex_0
    code[640]=86; //"_"

    code[700]=1317; //ExpressionStatement_10 # ExpressionStatement_10
    code[713]=2431; //sum
    code[698]=2431; //sum
    code[695]=2934; //"~"

    code[755]=4256; //ExpressionStatement_11 # ExpressionStatement_11
    code[781]=143; //r
    code[765]=143; //r
    code[775]=2431; //sum
    code[748]=454; //"#"

    code[812]=9664; //ExpressionStatement_12 # ExpressionStatement_12
    code[840]=3947; //invocationTemp_1

    code[875]=9597; //ExpressionStatement_13 # ExpressionStatement_13
    code[863]=2276; //p1
    code[899]=3947; //invocationTemp_1

    code[941]=8019; //ExpressionStatement_14 # ExpressionStatement_14
    code[951]=143; //r
    code[938]=143; //r
    code[921]=520; //"["
    code[942]=2276; //p1
    code[944]=2332; //"]"

    code[1000]=1733; //ExpressionStatement_15 # ExpressionStatement_15
    code[1029]=3987; //memberTemp_1
    code[981]=143; //r

    code[1059]=9444; //ExpressionStatement_16 # ExpressionStatement_16
    code[1066]=2431; //sum
    code[1045]=2431; //sum
    code[1081]=3987; //memberTemp_1

    code[1117]=5180; //ExpressionStatement_17 # ExpressionStatement_17
    code[1119]=3578; //dst
    code[1110]=3783; //var_forIndex_0
    code[1134]=2431; //sum

    code[1171]=7576; //ExpressionStatement_18 # ExpressionStatement_18
    code[1186]=3783; //var_forIndex_0
    code[1174]=3783; //var_forIndex_0
    code[1194]=2222; //1

    code[1240]=8931; //ExpressionStatement_7 # ExpressionStatement_19
    code[1242]=3158; //var_whileCondition_0
    code[1265]=3783; //var_forIndex_0
    code[1223]=791; //b

    code[1296]=3168; //ExpressionStatement_20 # ExpressionStatement_20
    code[1293]=82; //while_FalseBlockSkip_82

    code[1352]=9680; //ExpressionStatement_21 # ExpressionStatement_21
    code[1379]=1571; //memberTemp_2
    code[1368]=3578; //dst

    code[1408]=5821; //ExpressionStatement_22 # ExpressionStatement_22
    code[1402]=2431; //sum
    code[1420]=2431; //sum
    code[1429]=454; //"#"
    code[1421]=1571; //memberTemp_2

    code[1470]=6137; //ReturnStatement_23 # ReturnStatement_23
    code[1494]=2431; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_2145_2_op4_in5(vpc, data, code);

}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
        private string ForSimple_Array_readable(int b)
{
    //Virtualization variables
    int[] code = new int[100462];
    object[] data = new object[4563];
    int vpc = 108;

    //Data init
    data[3388]=b; //b 
    data[1348]="" ; //"" constant
    data[2643]=3; //3 constant
    data[982]=4; //4 constant
    data[1360]="[" ; //"[" constant
    data[3127]="]"; //"]" constant
    data[590]=1; //1 constant
    data[14]=0; //0 constant
    data[557]="_" ; //"_" constant
    data[1329]="~"; //"~" constant
    data[560]="#"; //"#" constant
    data[1157]=703884116; //addTemp_0 
    data[2839]=1869989102; //addTemp_1 
    data[3083]=713491713; //sum 
    data[2171]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[2052]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[2124]=(ConsoleCalculator.Piston)null; //invocationTemp_2 
    data[97]=(double)0.538888361555938; //p1 
    data[2671]=930355603; //addTemp_2 
    data[2586]=760493095; //addTemp_3 
    data[2841]=(ConsoleCalculator.Engine)null; //invocationTemp_3 
    data[2187]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_4 
    data[1571]=-878; //memberTemp_0 
    data[3909]=-386; //addTemp_4 
    data[2611]=(ConsoleCalculator.Engine)null; //invocationTemp_5 
    data[3024]=(ConsoleCalculator.Piston)null; //invocationTemp_6 
    data[2482]=7139119; //invocationTemp_7 
    data[1568]=1148463105; //r 
    data[1638]=(string[])null; //dst 
    data[3108]=-620; //var_forIndex_0 
    data[3627]=-914; //invocationTemp_8 
    data[2032]=false; //var_whileCondition_0 
    data[1021]=970472653; //addTemp_5 
    data[3983]=200065001; //addTemp_6 
    data[2379]=450012801; //addTemp_7 
    data[3062]=-723; //invocationTemp_9 
    data[1492]=696; //memberTemp_1 
    data[2678]=1746629152; //addTemp_8 
    data[1161]=874; //fake-1161 
    data[3035]=664; //fake-3035 
    data[2370]=322; //fake-2370 
    data[2374]=-347; //fake-2374 
    data[1817]=-509; //fake-1817 
    data[631]=574; //fake-631 
    data[583]=725; //fake-583 
    data[2401]=250; //fake-2401 
    data[2601]=98; //fake-2601 
    data[3188]=-900; //fake-3188 
    data[3418]=527; //fake-3418 
    data[2202]=-55; //fake-2202 
    data[680]=894; //fake-680 
    data[3265]=456; //fake-3265 
    data[231]=484; //fake-231 
    data[705]=-434; //fake-705 
    data[545]=491; //fake-545 
    data[2718]=810; //fake-2718 
    data[2217]=-158; //fake-2217 
    data[3922]=634; //fake-3922 
    data[3101]=-331; //fake-3101 
    data[503]=780; //fake-503 
    data[2880]=-630; //fake-2880 
    data[1128]=-894; //fake-1128 
    data[659]=-911; //fake-659 
    data[2791]=-477; //fake-2791 
    data[82]=236; //fake-82 
    data[2766]=257; //fake-2766 
    data[3273]=960; //fake-3273 
    data[1495]=-426; //fake-1495 
    data[3692]=-818; //fake-3692 
    data[155]=224; //fake-155 
    data[663]=-384; //fake-663 
    data[360]=439; //fake-360 
    data[1951]=-617; //fake-1951 
    data[849]=921; //fake-849 
    data[1185]=770; //fake-1185 
    data[3163]=-998; //fake-3163 
    data[2431]=250; //fake-2431 
    data[1734]=89; //fake-1734 
    data[1421]=351; //fake-1421 
    data[3317]=615; //fake-3317 
    data[1371]=609; //fake-1371 
    data[595]=-979; //fake-595 
    data[3560]=86; //fake-3560 
    data[558]=61; //fake-558 
    data[1051]=174; //fake-1051 
    data[1653]=-77; //fake-1653 
    data[444]=-399; //fake-444 
    data[863]=-663; //fake-863 
    data[3157]=-306; //fake-3157 
    data[120]=-392; //fake-120 
    data[3112]=434; //fake-3112 
    data[274]=-938; //fake-274 
    data[1730]=-43; //fake-1730 
    data[509]=-906; //fake-509 
    data[1718]=294; //fake-1718 
    data[1912]=216; //fake-1912 
    data[1968]=-437; //fake-1968 
    data[3330]=967; //fake-3330 
    data[1634]=-662; //fake-1634 
    data[2764]=-532; //fake-2764 
    data[1473]=290; //fake-1473 
    data[603]=-477; //fake-603 
    data[1757]=918; //fake-1757 
    data[2174]=-697; //fake-2174 
    data[3571]=-672; //fake-3571 
    data[1978]=-545; //fake-1978 
    data[499]=73; //fake-499 
    data[3802]=562; //fake-3802 
    data[1243]=-205; //fake-1243 
    data[3596]=489; //fake-3596 
    data[3340]=-440; //fake-3340 
    data[1900]=752; //fake-1900 
    data[378]=-718; //fake-378 
    data[3500]=53; //fake-3500 
    data[3946]=-829; //fake-3946 
    data[3875]=-651; //fake-3875 
    data[1505]=19; //fake-1505 
    data[2452]=28; //jmpWhileDestinationName_2452 constant
    data[2978]=73; //while_GoTo_True_2978 constant
    data[1077]=799; //while_GoTo_False_1077 constant
    data[3246]=-799; //while_FalseBlockSkip_3246 constant
    data[1613]=349; //fake-1613 
    data[1605]=-688; //fake-1605 
    data[3698]=-344; //fake-3698 
    data[3834]=623; //fake-3834 
    data[2051]=880; //fake-2051 
    data[3045]=574; //fake-3045 
    data[3719]=789; //fake-3719 
    data[905]=-446; //fake-905 
    data[1344]=-518; //fake-1344 
    data[3052]=-711; //fake-3052 
    data[3189]=-373; //fake-3189 
    data[2819]=-446; //fake-2819 
    data[1195]=438; //fake-1195 
    data[559]=283; //fake-559 
    data[2325]=-249; //fake-2325 
    data[1090]=-117; //fake-1090 
    data[902]=-675; //fake-902 
    data[1447]=85; //fake-1447 
    data[2441]=-898; //fake-2441 
    data[801]=-218; //fake-801 
    data[203]=-267; //fake-203 
    data[1870]=-281; //fake-1870 
    data[6]=850; //fake-6 
    data[3670]=38; //fake-3670 
    data[101]=541; //fake-101 
    data[333]=204; //fake-333 
    data[3078]=-953; //fake-3078 
    data[720]=682; //fake-720 
    data[2132]=779; //fake-2132 
    data[1470]=903; //fake-1470 
    data[1860]=922; //fake-1860 
    data[3878]=-56; //fake-3878 
    data[3454]=-804; //fake-3454 
    data[3110]=535; //fake-3110 
    data[1809]=-383; //fake-1809 
    data[3026]=-975; //fake-3026 
    data[585]=812; //fake-585 
    data[2831]=667; //fake-2831 
    data[3976]=-357; //fake-3976 
    data[1583]=-656; //fake-1583 
    data[3592]=-486; //fake-3592 
    data[3700]=773; //fake-3700 
    data[1381]=973; //fake-1381 
    data[3301]=-217; //fake-3301 
    data[623]=-66; //fake-623 
    data[3132]=-760; //fake-3132 
    data[394]=-949; //fake-394 
    data[700]=277; //fake-700 
    data[729]=1; //fake-729 
    data[2648]=399; //fake-2648 
    data[2281]=-272; //fake-2281 
    data[342]=85; //fake-342 
    data[2750]=-754; //fake-2750 
    data[1875]=-764; //fake-1875 
    data[3143]=-705; //fake-3143 
    data[2593]=-370; //fake-2593 
    data[3892]=-538; //fake-3892 
    data[2903]=617; //fake-2903 
    data[619]=-919; //fake-619 
    data[3047]=-325; //fake-3047 
    data[320]=526; //fake-320 
    data[3114]=-893; //fake-3114 
    data[3810]=-225; //fake-3810 
    data[3695]=-422; //fake-3695 
    data[266]=-634; //fake-266 

    //Code init

    code[108]=7385; //ExpressionStatement_0 # ExpressionStatement_0
    code[131]=1157; //addTemp_0
    code[90]=1348; //""
    code[119]=2643; //3
    code[135]=2262; //fake-ExpressionStatement_0_2262_27
    code[130]=3527; //fake-ExpressionStatement_0_3527_22
    code[122]=3776; //fake-ExpressionStatement_0_3776_14
    code[125]=644; //fake-ExpressionStatement_0_644_17

    code[169]=7385; //ExpressionStatement_0 # ExpressionStatement_1
    code[192]=2839; //addTemp_1
    code[151]=1157; //addTemp_0
    code[180]=982; //4
    code[188]=931; //fake-ExpressionStatement_0_931_19
    code[186]=3791; //fake-ExpressionStatement_0_3791_17
    code[158]=3128; //fake-ExpressionStatement_0_3128_-11
    code[154]=3893; //fake-ExpressionStatement_0_3893_-15

    code[230]=2244; //ExpressionStatement_2 # ExpressionStatement_2
    code[232]=3083; //sum
    code[234]=2839; //addTemp_1
    code[250]=1348; //""
    code[244]=2653; //fake-ExpressionStatement_2_2653_14

    code[299]=8024; //ExpressionStatement_3 # ExpressionStatement_3
    code[315]=2171; //invocationTemp_0
    code[296]=3882; //fake-ExpressionStatement_3_3882_-3
    code[287]=1085; //fake-ExpressionStatement_3_1085_-12
    code[285]=847; //fake-ExpressionStatement_3_847_-14

    code[351]=6946; //ExpressionStatement_4 # ExpressionStatement_4
    code[354]=2052; //invocationTemp_1
    code[379]=2171; //invocationTemp_0
    code[353]=3968; //fake-ExpressionStatement_4_3968_2
    code[374]=572; //fake-ExpressionStatement_4_572_23

    code[415]=2058; //ExpressionStatement_5 # ExpressionStatement_5
    code[398]=2124; //invocationTemp_2
    code[409]=2052; //invocationTemp_1
    code[408]=1509; //fake-ExpressionStatement_5_1509_-7
    code[419]=700; //fake-ExpressionStatement_5_700_4
    code[442]=1315; //fake-ExpressionStatement_5_1315_27

    code[486]=3148; //ExpressionStatement_6 # ExpressionStatement_6
    code[478]=97; //p1
    code[512]=2124; //invocationTemp_2
    code[477]=3533; //fake-ExpressionStatement_6_3533_-9
    code[497]=3152; //fake-ExpressionStatement_6_3152_11
    code[489]=3309; //fake-ExpressionStatement_6_3309_3
    code[476]=614; //fake-ExpressionStatement_6_614_-10

    code[545]=5921; //ExpressionStatement_7 # ExpressionStatement_7
    code[539]=2671; //addTemp_2
    code[527]=1360; //"["
    code[534]=97; //p1
    code[564]=3890; //fake-ExpressionStatement_7_3890_19
    code[526]=1975; //fake-ExpressionStatement_7_1975_-19
    code[553]=2081; //fake-ExpressionStatement_7_2081_8

    code[613]=9919; //ExpressionStatement_2 # ExpressionStatement_8
    code[615]=2586; //addTemp_3
    code[617]=2671; //addTemp_2
    code[633]=3127; //"]"
    code[623]=3384; //fake-ExpressionStatement_2_3384_10
    code[618]=2543; //fake-ExpressionStatement_2_2543_5
    code[602]=69; //fake-ExpressionStatement_2_69_-11

    code[682]=9919; //ExpressionStatement_2 # ExpressionStatement_9
    code[684]=3083; //sum
    code[686]=3083; //sum
    code[702]=2586; //addTemp_3
    code[706]=1442; //fake-ExpressionStatement_2_1442_24
    code[706]=3889; //fake-ExpressionStatement_2_3889_24
    code[706]=1039; //fake-ExpressionStatement_2_1039_24

    code[751]=8024; //ExpressionStatement_3 # ExpressionStatement_10
    code[767]=2841; //invocationTemp_3
    code[733]=2082; //fake-ExpressionStatement_3_2082_-18
    code[738]=1675; //fake-ExpressionStatement_3_1675_-13

    code[803]=6946; //ExpressionStatement_4 # ExpressionStatement_11
    code[806]=2187; //invocationTemp_4
    code[831]=2841; //invocationTemp_3
    code[802]=2809; //fake-ExpressionStatement_4_2809_-1
    code[807]=2152; //fake-ExpressionStatement_4_2152_4
    code[788]=2394; //fake-ExpressionStatement_4_2394_-15
    code[824]=2690; //fake-ExpressionStatement_4_2690_21
    code[802]=2356; //fake-ExpressionStatement_4_2356_-1
    code[819]=2344; //fake-ExpressionStatement_4_2344_16

    code[867]=5475; //ExpressionStatement_12 # ExpressionStatement_12
    code[878]=1571; //memberTemp_0
    code[868]=2187; //invocationTemp_4
    code[890]=3105; //fake-ExpressionStatement_12_3105_23
    code[862]=744; //fake-ExpressionStatement_12_744_-5
    code[863]=1381; //fake-ExpressionStatement_12_1381_-4

    code[938]=3579; //ExpressionStatement_13 # ExpressionStatement_13
    code[949]=3909; //addTemp_4
    code[937]=1571; //memberTemp_0
    code[960]=590; //1
    code[919]=2842; //fake-ExpressionStatement_13_2842_-19
    code[943]=2969; //fake-ExpressionStatement_13_2969_5
    code[953]=2363; //fake-ExpressionStatement_13_2363_15
    code[951]=3384; //fake-ExpressionStatement_13_3384_13
    code[935]=953; //fake-ExpressionStatement_13_953_-3

    code[996]=8024; //ExpressionStatement_3 # ExpressionStatement_14
    code[1012]=2611; //invocationTemp_5
    code[1000]=3609; //fake-ExpressionStatement_3_3609_4

    code[1048]=9676; //ExpressionStatement_15 # ExpressionStatement_15
    code[1042]=3024; //invocationTemp_6
    code[1050]=2611; //invocationTemp_5
    code[1054]=3909; //addTemp_4
    code[1034]=424; //fake-ExpressionStatement_15_424_-14
    code[1075]=135; //fake-ExpressionStatement_15_135_27
    code[1032]=393; //fake-ExpressionStatement_15_393_-16
    code[1036]=2926; //fake-ExpressionStatement_15_2926_-12
    code[1051]=2758; //fake-ExpressionStatement_15_2758_3

    code[1106]=3262; //ExpressionStatement_16 # ExpressionStatement_16
    code[1115]=2482; //invocationTemp_7
    code[1126]=3024; //invocationTemp_6
    code[1121]=2266; //fake-ExpressionStatement_16_2266_15
    code[1112]=243; //fake-ExpressionStatement_16_243_6
    code[1107]=170; //fake-ExpressionStatement_16_170_1
    code[1129]=3425; //fake-ExpressionStatement_16_3425_23
    code[1093]=164; //fake-ExpressionStatement_16_164_-13

    code[1170]=9919; //ExpressionStatement_2 # ExpressionStatement_17
    code[1172]=3083; //sum
    code[1174]=3083; //sum
    code[1190]=2482; //invocationTemp_7
    code[1163]=342; //fake-ExpressionStatement_2_342_-7
    code[1199]=3471; //fake-ExpressionStatement_2_3471_29
    code[1176]=3418; //fake-ExpressionStatement_2_3418_6
    code[1169]=1958; //fake-ExpressionStatement_2_1958_-1
    code[1151]=3448; //fake-ExpressionStatement_2_3448_-19
    code[1156]=3425; //fake-ExpressionStatement_2_3425_-14

    code[1239]=7635; //ExpressionStatement_18 # ExpressionStatement_18
    code[1248]=1568; //r
    code[1264]=1348; //""
    code[1241]=840; //fake-ExpressionStatement_18_840_2
    code[1243]=3153; //fake-ExpressionStatement_18_3153_4
    code[1228]=2609; //fake-ExpressionStatement_18_2609_-11
    code[1228]=1336; //fake-ExpressionStatement_18_1336_-11
    code[1237]=187; //fake-ExpressionStatement_18_187_-2
    code[1227]=1368; //fake-ExpressionStatement_18_1368_-12
    code[1263]=2132; //fake-ExpressionStatement_18_2132_24
    code[1261]=1699; //fake-ExpressionStatement_18_1699_22

    code[1302]=6304; //ExpressionStatement_19 # ExpressionStatement_19
    code[1314]=1638; //dst
    code[1285]=3388; //b
    code[1317]=1124; //fake-ExpressionStatement_19_1124_15
    code[1292]=1260; //fake-ExpressionStatement_19_1260_-10

    code[1358]=7635; //ExpressionStatement_18 # ExpressionStatement_20
    code[1367]=3108; //var_forIndex_0
    code[1383]=14; //0
    code[1385]=2089; //fake-ExpressionStatement_18_2089_27
    code[1347]=2761; //fake-ExpressionStatement_18_2761_-11

    code[1421]=9872; //ExpressionStatement_21 # ExpressionStatement_21
    code[1417]=3627; //invocationTemp_8
    code[1405]=3388; //b
    code[1428]=2119; //fake-ExpressionStatement_21_2119_7
    code[1408]=3526; //fake-ExpressionStatement_21_3526_-13

    code[1473]=5888; //ExpressionStatement_22 # ExpressionStatement_22
    code[1498]=2032; //var_whileCondition_0
    code[1491]=3108; //var_forIndex_0
    code[1486]=3627; //invocationTemp_8
    code[1454]=2997; //fake-ExpressionStatement_22_2997_-19
    code[1475]=2363; //fake-ExpressionStatement_22_2363_2

    code[1542]=4774; //WhileStatementSyntax_23 # WhileStatementSyntax_23
    code[1528]=2452; //jmpWhileDestinationName_2452
    code[1529]=2032; //var_whileCondition_0
    code[1536]=2978; //while_GoTo_True_2978
    code[1533]=1077; //while_GoTo_False_1077
    code[1538]=2733; //fake-fake-whileVirtualOperation_2733_-4
    code[1535]=1731; //fake-fake-whileVirtualOperation_1731_-7
    code[1532]=1930; //fake-fake-whileVirtualOperation_1930_-10

    code[1615]=7385; //ExpressionStatement_0 # ExpressionStatement_24
    code[1638]=1021; //addTemp_5
    code[1597]=557; //"_"
    code[1626]=3108; //var_forIndex_0
    code[1616]=1697; //fake-ExpressionStatement_0_1697_1
    code[1599]=3980; //fake-ExpressionStatement_0_3980_-16
    code[1621]=2623; //fake-ExpressionStatement_0_2623_6
    code[1616]=1996; //fake-ExpressionStatement_0_1996_1

    code[1676]=9919; //ExpressionStatement_2 # ExpressionStatement_25
    code[1678]=3983; //addTemp_6
    code[1680]=1021; //addTemp_5
    code[1696]=557; //"_"
    code[1687]=3284; //fake-ExpressionStatement_2_3284_11
    code[1701]=501; //fake-ExpressionStatement_2_501_25
    code[1700]=2324; //fake-ExpressionStatement_2_2324_24

    code[1745]=9919; //ExpressionStatement_2 # ExpressionStatement_26
    code[1747]=3083; //sum
    code[1749]=3083; //sum
    code[1765]=3983; //addTemp_6
    code[1767]=2302; //fake-ExpressionStatement_2_2302_22
    code[1753]=2347; //fake-ExpressionStatement_2_2347_8
    code[1773]=1486; //fake-ExpressionStatement_2_1486_28
    code[1754]=923; //fake-ExpressionStatement_2_923_9
    code[1752]=1072; //fake-ExpressionStatement_2_1072_7

    code[1814]=9919; //ExpressionStatement_2 # ExpressionStatement_27
    code[1816]=3083; //sum
    code[1818]=3083; //sum
    code[1834]=1329; //"~"
    code[1836]=1195; //fake-ExpressionStatement_2_1195_22
    code[1803]=3010; //fake-ExpressionStatement_2_3010_-11
    code[1817]=2029; //fake-ExpressionStatement_2_2029_3
    code[1827]=1395; //fake-ExpressionStatement_2_1395_13

    code[1883]=9919; //ExpressionStatement_2 # ExpressionStatement_28
    code[1885]=2379; //addTemp_7
    code[1887]=3083; //sum
    code[1903]=560; //"#"
    code[1898]=1984; //fake-ExpressionStatement_2_1984_15
    code[1909]=2150; //fake-ExpressionStatement_2_2150_26
    code[1871]=1677; //fake-ExpressionStatement_2_1677_-12
    code[1881]=1515; //fake-ExpressionStatement_2_1515_-2

    code[1952]=9919; //ExpressionStatement_2 # ExpressionStatement_29
    code[1954]=1568; //r
    code[1956]=1568; //r
    code[1972]=2379; //addTemp_7
    code[1933]=1531; //fake-ExpressionStatement_2_1531_-19
    code[1975]=576; //fake-ExpressionStatement_2_576_23

    code[2021]=2635; //ExpressionStatement_30 # ExpressionStatement_30
    code[2045]=1638; //dst
    code[2047]=3108; //var_forIndex_0
    code[2027]=3083; //sum
    code[2003]=3584; //fake-ExpressionStatement_30_3584_-18
    code[2039]=1189; //fake-ExpressionStatement_30_1189_18
    code[2017]=276; //fake-ExpressionStatement_30_276_-4

    code[2084]=9059; //ExpressionStatement_31 # ExpressionStatement_31
    code[2068]=3108; //var_forIndex_0
    code[2074]=3108; //var_forIndex_0
    code[2098]=590; //1
    code[2108]=468; //fake-ExpressionStatement_31_468_24
    code[2091]=2732; //fake-ExpressionStatement_31_2732_7
    code[2103]=280; //fake-ExpressionStatement_31_280_19
    code[2076]=2149; //fake-ExpressionStatement_31_2149_-8
    code[2080]=2916; //fake-ExpressionStatement_31_2916_-4
    code[2103]=2880; //fake-ExpressionStatement_31_2880_19

    code[2154]=9872; //ExpressionStatement_21 # ExpressionStatement_32
    code[2150]=3062; //invocationTemp_9
    code[2138]=3388; //b
    code[2139]=1917; //fake-ExpressionStatement_21_1917_-15
    code[2182]=130; //fake-ExpressionStatement_21_130_28
    code[2165]=3223; //fake-ExpressionStatement_21_3223_11
    code[2156]=1485; //fake-ExpressionStatement_21_1485_2
    code[2139]=2763; //fake-ExpressionStatement_21_2763_-15

    code[2206]=5888; //ExpressionStatement_22 # ExpressionStatement_33
    code[2231]=2032; //var_whileCondition_0
    code[2224]=3108; //var_forIndex_0
    code[2219]=3062; //invocationTemp_9
    code[2213]=3127; //fake-ExpressionStatement_22_3127_7
    code[2228]=3080; //fake-ExpressionStatement_22_3080_22
    code[2207]=1293; //fake-ExpressionStatement_22_1293_1
    code[2208]=815; //fake-ExpressionStatement_22_815_2

    code[2275]=5359; //ExpressionStatement_34 # ExpressionStatement_34
    code[2265]=3246; //while_FalseBlockSkip_3246
    code[2276]=3946; //fake-ExpressionStatement_34_3946_1
    code[2302]=616; //fake-ExpressionStatement_34_616_27
    code[2260]=3270; //fake-ExpressionStatement_34_3270_-15

    code[2341]=2506; //ExpressionStatement_35 # ExpressionStatement_35
    code[2323]=1492; //memberTemp_1
    code[2344]=1638; //dst
    code[2348]=1415; //fake-ExpressionStatement_35_1415_7
    code[2353]=1378; //fake-ExpressionStatement_35_1378_12
    code[2366]=3269; //fake-ExpressionStatement_35_3269_25
    code[2324]=882; //fake-ExpressionStatement_35_882_-17
    code[2326]=2080; //fake-ExpressionStatement_35_2080_-15
    code[2346]=205; //fake-ExpressionStatement_35_205_5
    code[2368]=187; //fake-ExpressionStatement_35_187_27

    code[2393]=7385; //ExpressionStatement_0 # ExpressionStatement_36
    code[2416]=2678; //addTemp_8
    code[2375]=560; //"#"
    code[2404]=1492; //memberTemp_1
    code[2419]=3140; //fake-ExpressionStatement_0_3140_26
    code[2422]=3584; //fake-ExpressionStatement_0_3584_29
    code[2422]=3497; //fake-ExpressionStatement_0_3497_29
    code[2383]=1777; //fake-ExpressionStatement_0_1777_-10

    code[2454]=9919; //ExpressionStatement_2 # ExpressionStatement_37
    code[2456]=3083; //sum
    code[2458]=3083; //sum
    code[2474]=2678; //addTemp_8
    code[2440]=525; //fake-ExpressionStatement_2_525_-14
    code[2477]=3590; //fake-ExpressionStatement_2_3590_23
    code[2444]=1841; //fake-ExpressionStatement_2_1841_-10
    code[2483]=3849; //fake-ExpressionStatement_2_3849_29

    code[2523]=9957; //ReturnStatement_38 # ReturnStatement_38
    code[2525]=3083; //sum
    code[2546]=350; //fake-ReturnStatement_38_350_23
    code[2522]=446; //fake-ReturnStatement_38_446_-1
    code[2546]=235; //fake-ReturnStatement_38_235_23
    code[2530]=2769; //fake-ReturnStatement_38_2769_7

    while(true)
    {
    	switch(code[vpc])
    	{
    		case 3579: //frequency 1 ExpressionStatement_13
    			data[code[vpc+(11)]]= (int)data[code[vpc+(-1)]]- (int)data[code[vpc+(22)]];
    			vpc+=58;
    			break;
    		case 9957: //frequency 1 ReturnStatement_38
    			return (string)data[code[vpc+(2)]];
    			vpc+=65;
    		case 4774: //frequency 1 WhileStatementSyntax_23
    			data[code[vpc+(-14)]]=(bool)data[code[vpc+(-13)]]?(int)data[code[vpc+(-6)]]:(int)data[code[vpc+(-9)]];
    			vpc+=(int)data[code[vpc+(-14)]];
    			break;
    		case 9676: //frequency 1 ExpressionStatement_15
    			data[code[vpc+(-6)]]= (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc+(2)]]).GetPiston((int)data[code[vpc+(6)]]));
    			vpc+=58;
    			break;
    		case 7385: //frequency 4 ExpressionStatement_0
    			data[code[vpc+(23)]]= (string)data[code[vpc+(-18)]]+ (int)data[code[vpc+(11)]];
    			vpc+=61;
    			break;
    		case 2058: //frequency 1 ExpressionStatement_5
    			data[code[vpc+(-17)]]= (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc+(-6)]]).First());
    			vpc+=71;
    			break;
    		case 9872: //frequency 2 ExpressionStatement_21
    			data[code[vpc+(-4)]]= ReturnArg_Array((int)data[code[vpc+(-16)]]);
    			vpc+=52;
    			break;
    		case 5921: //frequency 1 ExpressionStatement_7
    			data[code[vpc+(-6)]]= (string)data[code[vpc+(-18)]]+ (double)data[code[vpc+(-11)]];
    			vpc+=68;
    			break;
    		case 7635: //frequency 2 ExpressionStatement_18
    			data[code[vpc+(9)]]= data[code[vpc+(25)]];
    			vpc+=63;
    			break;
    		case 5888: //frequency 2 ExpressionStatement_22
    			data[code[vpc+(25)]]= (int)data[code[vpc+(18)]]< (int)data[code[vpc+(13)]];
    			vpc+=69;
    			break;
    		default: //frequency 10 ExpressionStatement_2
    			data[code[vpc+(2)]]= (string)data[code[vpc+(4)]]+ (string)data[code[vpc+(20)]];
    			vpc+=69;
    			break;
    		case 9059: //frequency 1 ExpressionStatement_31
    			data[code[vpc+(-16)]]= (int)data[code[vpc+(-10)]]+ (int)data[code[vpc+(14)]];
    			vpc+=70;
    			break;
    		case 5359: //frequency 1 ExpressionStatement_34
    			vpc += (int)data[code[vpc+(-10)]];
    			vpc+=66;
    			break;
    		case 3148: //frequency 1 ExpressionStatement_6
    			data[code[vpc+(-8)]]= ((ConsoleCalculator.Piston)data[code[vpc+(26)]]).GetSize();
    			vpc+=59;
    			break;
    		case 2506: //frequency 1 ExpressionStatement_35
    			data[code[vpc+(-18)]]= ((string[])data[code[vpc+(3)]]).Length;
    			vpc+=52;
    			break;
    		case 8024: //frequency 3 ExpressionStatement_3
    			data[code[vpc+(16)]]= (ConsoleCalculator.Engine)(car.GetEngine());
    			vpc+=52;
    			break;
    		case 2635: //frequency 1 ExpressionStatement_30
    			((string[])data[code[vpc+(24)]])[(int)data[code[vpc+(26)]]] = (string)data[code[vpc+(6)]];
    			vpc+=63;
    			break;
    		case 3262: //frequency 1 ExpressionStatement_16
    			data[code[vpc+(9)]]= ((ConsoleCalculator.Piston)data[code[vpc+(20)]]).ToString();
    			vpc+=64;
    			break;
    		case 5475: //frequency 1 ExpressionStatement_12
    			data[code[vpc+(11)]]= ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc+(1)]]).Count;
    			vpc+=71;
    			break;
    		case 6304: //frequency 1 ExpressionStatement_19
    			data[code[vpc+(12)]]= (string[])(new string[(int)data[code[vpc+(-17)]]]);
    			vpc+=56;
    			break;
    		case 6946: //frequency 2 ExpressionStatement_4
    			data[code[vpc+(3)]]= (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc+(28)]]).GetPistons());
    			vpc+=64;
    			break;
    	}
    }

    return null;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string ForSimple_Array_refactored_op4_in5(int b)
{
    string sum = "" + 3 + 4 + "";
    double p1 = car.GetEngine().GetPistons().First().GetSize();
    sum = sum + "[" + p1 + "]";
    int memberTemp_0 = car.GetEngine().GetPistons().Count;
    ConsoleCalculator.Piston invocationTemp_0 = car.GetEngine().GetPiston(memberTemp_0 - 1);
    sum = sum + invocationTemp_0.ToString();
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    bool var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    }

    int memberTemp_1 = dst.Length;
    sum = sum + "#" + memberTemp_1;
    return sum;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string ForSimple_Array_refactored_op4_in4(int b)
{
    string sum = "" + 3 + 4 + "";
    ConsoleCalculator.Piston invocationTemp_0 = car.GetEngine().GetPistons().First();
    double p1 = invocationTemp_0.GetSize();
    sum = sum + "[" + p1 + "]";
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_1 = car.GetEngine().GetPistons();
    int memberTemp_0 = invocationTemp_1.Count;
    string invocationTemp_2 = car.GetEngine().GetPiston(memberTemp_0 - 1).ToString();
    sum = sum + invocationTemp_2;
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    bool var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        var_whileCondition_0 = var_forIndex_0 < ReturnArg_Array(b);
    }

    int memberTemp_1 = dst.Length;
    sum = sum + "#" + memberTemp_1;
    return sum;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string ForSimple_Array_refactored_op4_in1(int b)
{
    string sum = "" + 3 + 4 + "";
    ConsoleCalculator.Engine invocationTemp_0 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_1 = invocationTemp_0.GetPistons();
    ConsoleCalculator.Piston invocationTemp_2 = invocationTemp_1.First();
    double p1 = invocationTemp_2.GetSize();
    sum = sum + "[" + p1 + "]";
    ConsoleCalculator.Engine invocationTemp_3 = car.GetEngine();
    ConsoleCalculator.Engine invocationTemp_4 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_5 = invocationTemp_4.GetPistons();
    int memberTemp_0 = invocationTemp_5.Count;
    ConsoleCalculator.Piston invocationTemp_6 = invocationTemp_3.GetPiston(memberTemp_0 - 1);
    string invocationTemp_7 = invocationTemp_6.ToString();
    sum = sum + invocationTemp_7;
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    int invocationTemp_8 = ReturnArg_Array(b);
    bool var_whileCondition_0 = var_forIndex_0 < invocationTemp_8;
    while (var_whileCondition_0)
    {
        sum = sum + "_" + var_forIndex_0 + "_";
        sum = sum + "~";
        r = r + sum + "#";
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        int invocationTemp_9 = ReturnArg_Array(b);
        var_whileCondition_0 = var_forIndex_0 < invocationTemp_9;
    }

    int memberTemp_1 = dst.Length;
    sum = sum + "#" + memberTemp_1;
    return sum;
}

        //                [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string ForSimple_Array_refactored_op3_in1(int b)
{
    string addTemp_0 = "" + 3 + 4;
    string sum = addTemp_0 + "";
    ConsoleCalculator.Engine invocationTemp_0 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_1 = invocationTemp_0.GetPistons();
    ConsoleCalculator.Piston invocationTemp_2 = invocationTemp_1.First();
    double p1 = invocationTemp_2.GetSize();
    string addTemp_1 = "[" + p1 + "]";
    sum = sum + addTemp_1;
    ConsoleCalculator.Engine invocationTemp_3 = car.GetEngine();
    ConsoleCalculator.Engine invocationTemp_4 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_5 = invocationTemp_4.GetPistons();
    int memberTemp_0 = invocationTemp_5.Count;
    ConsoleCalculator.Piston invocationTemp_6 = invocationTemp_3.GetPiston(memberTemp_0 - 1);
    string invocationTemp_7 = invocationTemp_6.ToString();
    sum = sum + invocationTemp_7;
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    int invocationTemp_8 = ReturnArg_Array(b);
    bool var_whileCondition_0 = var_forIndex_0 < invocationTemp_8;
    while (var_whileCondition_0)
    {
        string addTemp_2 = "_" + var_forIndex_0 + "_";
        sum = sum + addTemp_2;
        sum = sum + "~";
        r = r + sum + "#";
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        int invocationTemp_9 = ReturnArg_Array(b);
        var_whileCondition_0 = var_forIndex_0 < invocationTemp_9;
    }

    int memberTemp_1 = dst.Length;
    sum = sum + "#" + memberTemp_1;
    return sum;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string ForSimple_Array_refactored_op2_in1(int b)
{
    string addTemp_0 = "" + 3;
    string addTemp_1 = addTemp_0 + 4;
    string sum = addTemp_1 + "";
    ConsoleCalculator.Engine invocationTemp_0 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_1 = invocationTemp_0.GetPistons();
    ConsoleCalculator.Piston invocationTemp_2 = invocationTemp_1.First();
    double p1 = invocationTemp_2.GetSize();
    string addTemp_2 = "[" + p1;
    string addTemp_3 = addTemp_2 + "]";
    sum = sum + addTemp_3;
    ConsoleCalculator.Engine invocationTemp_3 = car.GetEngine();
    System.Collections.Generic.List<ConsoleCalculator.Piston> invocationTemp_4 = invocationTemp_3.GetPistons();
    int memberTemp_0 = invocationTemp_4.Count;
    int addTemp_4 = memberTemp_0 - 1;
    ConsoleCalculator.Engine invocationTemp_5 = car.GetEngine();
    ConsoleCalculator.Piston invocationTemp_6 = invocationTemp_5.GetPiston(addTemp_4);
    string invocationTemp_7 = invocationTemp_6.ToString();
    sum = sum + invocationTemp_7;
    string r = "";
    string[] dst = new string[b];
    int var_forIndex_0 = 0;
    int invocationTemp_8 = ReturnArg_Array(b);
    bool var_whileCondition_0 = var_forIndex_0 < invocationTemp_8;
    while (var_whileCondition_0)
    {
        string addTemp_5 = "_" + var_forIndex_0;
        string addTemp_6 = addTemp_5 + "_";
        sum = sum + addTemp_6;
        sum = sum + "~";
        string addTemp_7 = sum + "#";
        r = r + addTemp_7;
        dst[var_forIndex_0] = sum;
        var_forIndex_0 = var_forIndex_0 + 1;
        int invocationTemp_9 = ReturnArg_Array(b);
        var_whileCondition_0 = var_forIndex_0 < invocationTemp_9;
    }

    int memberTemp_1 = dst.Length;
    string addTemp_8 = "#" + memberTemp_1;
    sum = sum + addTemp_8;
    return sum;
}


        //                [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]

        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated_op3_in1(int b)
{
    //Virtualization variables
    int[] code = new int[100599];
    object[] data = new object[4223];
    int vpc = 27;

    //Data init
    data[2490]=b; //b 
    data[236]="" ; //"" constant
    data[3339]=3 ; //3 constant
    data[2874]=4; //4 constant
    data[2745]="[" ; //"[" constant
    data[413]="]"; //"]" constant
    data[2971]=1; //1 constant
    data[3769]=0; //0 constant
    data[536]="_" ; //"_" constant
    data[2569]="~"; //"~" constant
    data[1869]="#"; //"#" constant
    data[1920]=245619067; //addTemp_0 
    data[2246]=1707035993; //sum 
    data[1218]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[1885]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[2989]=(ConsoleCalculator.Piston)null; //invocationTemp_2 
    data[746]=(double)0.107707382229952; //p1 
    data[1309]=559922757; //addTemp_1 
    data[599]=(ConsoleCalculator.Engine)null; //invocationTemp_3 
    data[992]=(ConsoleCalculator.Engine)null; //invocationTemp_4 
    data[211]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_5 
    data[583]=214; //memberTemp_0 
    data[925]=(ConsoleCalculator.Piston)null; //invocationTemp_6 
    data[2876]=1776754745; //invocationTemp_7 
    data[1495]=875045554; //r 
    data[1921]=(string[])null; //dst 
    data[1398]=257; //var_forIndex_0 
    data[235]=197; //invocationTemp_8 
    data[3871]=false; //var_whileCondition_0 
    data[3894]=1017451102; //addTemp_2 
    data[1276]=-630; //invocationTemp_9 
    data[1913]=-294; //memberTemp_1 
    data[2523]=558; //jmpWhileDestinationName_2523 constant
    data[1129]=70; //while_GoTo_True_1129 constant
    data[306]=634; //while_GoTo_False_306 constant
    data[1251]=-634; //while_FalseBlockSkip_1251 constant

    //Code init

    code[27]=8506; //ExpressionStatement_0 # ExpressionStatement_0
    code[43]=1920; //addTemp_0
    code[47]=236; //""
    code[44]=3339; //3
    code[37]=2874; //4

    code[96]=4875; //ExpressionStatement_1 # ExpressionStatement_1
    code[83]=2246; //sum
    code[114]=1920; //addTemp_0
    code[98]=236; //""

    code[161]=1230; //ExpressionStatement_2 # ExpressionStatement_2
    code[170]=1218; //invocationTemp_0

    code[213]=4523; //ExpressionStatement_3 # ExpressionStatement_3
    code[210]=1885; //invocationTemp_1
    code[216]=1218; //invocationTemp_0

    code[265]=2041; //ExpressionStatement_4 # ExpressionStatement_4
    code[255]=2989; //invocationTemp_2
    code[282]=1885; //invocationTemp_1

    code[323]=9767; //ExpressionStatement_5 # ExpressionStatement_5
    code[319]=746; //p1
    code[352]=2989; //invocationTemp_2

    code[378]=9652; //ExpressionStatement_6 # ExpressionStatement_6
    code[389]=1309; //addTemp_1
    code[405]=2745; //"["
    code[380]=746; //p1
    code[383]=413; //"]"

    code[433]=4875; //ExpressionStatement_1 # ExpressionStatement_7
    code[420]=2246; //sum
    code[451]=2246; //sum
    code[435]=1309; //addTemp_1

    code[498]=1230; //ExpressionStatement_2 # ExpressionStatement_8
    code[507]=599; //invocationTemp_3

    code[550]=1230; //ExpressionStatement_2 # ExpressionStatement_9
    code[559]=992; //invocationTemp_4

    code[602]=4523; //ExpressionStatement_3 # ExpressionStatement_10
    code[599]=211; //invocationTemp_5
    code[605]=992; //invocationTemp_4

    code[654]=6185; //ExpressionStatement_11 # ExpressionStatement_11
    code[635]=583; //memberTemp_0
    code[663]=211; //invocationTemp_5

    code[717]=9172; //ExpressionStatement_12 # ExpressionStatement_12
    code[721]=925; //invocationTemp_6
    code[701]=599; //invocationTemp_3
    code[699]=583; //memberTemp_0
    code[709]=2971; //1

    code[778]=1057; //ExpressionStatement_13 # ExpressionStatement_13
    code[777]=2876; //invocationTemp_7
    code[788]=925; //invocationTemp_6

    code[843]=4875; //ExpressionStatement_1 # ExpressionStatement_14
    code[830]=2246; //sum
    code[861]=2246; //sum
    code[845]=2876; //invocationTemp_7

    code[908]=8883; //ExpressionStatement_15 # ExpressionStatement_15
    code[902]=1495; //r
    code[895]=236; //""

    code[965]=5453; //ExpressionStatement_16 # ExpressionStatement_16
    code[964]=1921; //dst
    code[950]=2490; //b

    code[1030]=8883; //ExpressionStatement_15 # ExpressionStatement_17
    code[1024]=1398; //var_forIndex_0
    code[1017]=3769; //0

    code[1087]=9853; //ExpressionStatement_18 # ExpressionStatement_18
    code[1073]=235; //invocationTemp_8
    code[1105]=2490; //b

    code[1146]=5855; //ExpressionStatement_19 # ExpressionStatement_19
    code[1135]=3871; //var_whileCondition_0
    code[1133]=1398; //var_forIndex_0
    code[1158]=235; //invocationTemp_8

    code[1214]=7901; //WhileStatementSyntax_20 # WhileStatementSyntax_20
    code[1211]=2523; //jmpWhileDestinationName_2523
    code[1239]=3871; //var_whileCondition_0
    code[1229]=1129; //while_GoTo_True_1129
    code[1210]=306; //while_GoTo_False_306

    code[1284]=4796; //ExpressionStatement_21 # ExpressionStatement_21
    code[1290]=3894; //addTemp_2
    code[1310]=536; //"_"
    code[1296]=1398; //var_forIndex_0
    code[1304]=536; //"_"

    code[1342]=4875; //ExpressionStatement_1 # ExpressionStatement_22
    code[1329]=2246; //sum
    code[1360]=2246; //sum
    code[1344]=3894; //addTemp_2

    code[1407]=4875; //ExpressionStatement_1 # ExpressionStatement_23
    code[1394]=2246; //sum
    code[1425]=2246; //sum
    code[1409]=2569; //"~"

    code[1472]=6859; //ExpressionStatement_24 # ExpressionStatement_24
    code[1501]=1495; //r
    code[1491]=1495; //r
    code[1458]=2246; //sum
    code[1483]=1869; //"#"

    code[1528]=8472; //ExpressionStatement_25 # ExpressionStatement_25
    code[1548]=1921; //dst
    code[1533]=1398; //var_forIndex_0
    code[1531]=2246; //sum

    code[1586]=1203; //ExpressionStatement_26 # ExpressionStatement_26
    code[1582]=1398; //var_forIndex_0
    code[1603]=1398; //var_forIndex_0
    code[1607]=2971; //1

    code[1654]=9853; //ExpressionStatement_18 # ExpressionStatement_27
    code[1640]=1276; //invocationTemp_9
    code[1672]=2490; //b

    code[1713]=5855; //ExpressionStatement_19 # ExpressionStatement_28
    code[1702]=3871; //var_whileCondition_0
    code[1700]=1398; //var_forIndex_0
    code[1725]=1276; //invocationTemp_9

    code[1781]=7253; //ExpressionStatement_29 # ExpressionStatement_29
    code[1776]=1251; //while_FalseBlockSkip_1251

    code[1848]=5791; //ExpressionStatement_30 # ExpressionStatement_30
    code[1839]=1913; //memberTemp_1
    code[1828]=1921; //dst

    code[1913]=5456; //ExpressionStatement_31 # ExpressionStatement_31
    code[1932]=2246; //sum
    code[1928]=2246; //sum
    code[1922]=1869; //"#"
    code[1910]=1913; //memberTemp_1

    code[1979]=2324; //ReturnStatement_32 # ReturnStatement_32
    code[1983]=2246; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_1574_op3_in1(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated_op4_in1(int b)
{
    //Virtualization variables
    int[] code = new int[100613];
    object[] data = new object[4354];
    int vpc = 20;

    //Data init
    data[1499]=b; //b 
    data[3036]="" ; //"" constant
    data[3778]=3 ; //3 constant
    data[1643]=4 ; //4 constant
    data[3799]="[" ; //"[" constant
    data[2195]="]"; //"]" constant
    data[72]=1; //1 constant
    data[3798]=0; //0 constant
    data[963]="_" ; //"_" constant
    data[1414]="~"; //"~" constant
    data[2515]="#"; //"#" constant
    data[1725]=362158193; //sum 
    data[984]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[3132]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[3723]=(ConsoleCalculator.Piston)null; //invocationTemp_2 
    data[394]=(double)0.537795374420376; //p1 
    data[623]=(ConsoleCalculator.Engine)null; //invocationTemp_3 
    data[1514]=(ConsoleCalculator.Engine)null; //invocationTemp_4 
    data[1195]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_5 
    data[3611]=117; //memberTemp_0 
    data[770]=(ConsoleCalculator.Piston)null; //invocationTemp_6 
    data[1845]=374684910; //invocationTemp_7 
    data[247]=362155776; //r 
    data[3015]=(string[])null; //dst 
    data[2617]=-214; //var_forIndex_0 
    data[587]=-762; //invocationTemp_8 
    data[2360]=false; //var_whileCondition_0 
    data[1827]=151; //invocationTemp_9 
    data[1276]=995; //memberTemp_1 
    data[343]=699; //jmpWhileDestinationName_343 constant
    data[1271]=69; //while_GoTo_True_1271 constant
    data[3065]=573; //while_GoTo_False_3065 constant
    data[148]=-573; //while_FalseBlockSkip_148 constant

    //Code init

    code[20]=3746; //ExpressionStatement_0 # ExpressionStatement_0
    code[34]=1725; //sum
    code[46]=3036; //""
    code[33]=3778; //3
    code[13]=1643; //4
    code[35]=3036; //""

    code[93]=5631; //ExpressionStatement_1 # ExpressionStatement_1
    code[107]=984; //invocationTemp_0

    code[149]=6837; //ExpressionStatement_2 # ExpressionStatement_2
    code[144]=3132; //invocationTemp_1
    code[174]=984; //invocationTemp_0

    code[202]=6699; //ExpressionStatement_3 # ExpressionStatement_3
    code[188]=3723; //invocationTemp_2
    code[227]=3132; //invocationTemp_1

    code[262]=9219; //ExpressionStatement_4 # ExpressionStatement_4
    code[251]=394; //p1
    code[279]=3723; //invocationTemp_2

    code[327]=9627; //ExpressionStatement_5 # ExpressionStatement_5
    code[338]=1725; //sum
    code[318]=1725; //sum
    code[343]=3799; //"["
    code[320]=394; //p1
    code[313]=2195; //"]"

    code[393]=5631; //ExpressionStatement_1 # ExpressionStatement_6
    code[407]=623; //invocationTemp_3

    code[449]=5631; //ExpressionStatement_1 # ExpressionStatement_7
    code[463]=1514; //invocationTemp_4

    code[505]=6837; //ExpressionStatement_2 # ExpressionStatement_8
    code[500]=1195; //invocationTemp_5
    code[530]=1514; //invocationTemp_4

    code[558]=2964; //ExpressionStatement_9 # ExpressionStatement_9
    code[567]=3611; //memberTemp_0
    code[560]=1195; //invocationTemp_5

    code[612]=2738; //ExpressionStatement_10 # ExpressionStatement_10
    code[607]=770; //invocationTemp_6
    code[592]=623; //invocationTemp_3
    code[595]=3611; //memberTemp_0
    code[606]=72; //1

    code[673]=8700; //ExpressionStatement_11 # ExpressionStatement_11
    code[663]=1845; //invocationTemp_7
    code[664]=770; //invocationTemp_6

    code[732]=3293; //ExpressionStatement_12 # ExpressionStatement_12
    code[723]=1725; //sum
    code[735]=1725; //sum
    code[721]=1845; //invocationTemp_7

    code[800]=7795; //ExpressionStatement_13 # ExpressionStatement_13
    code[824]=247; //r
    code[781]=3036; //""

    code[869]=2611; //ExpressionStatement_14 # ExpressionStatement_14
    code[886]=3015; //dst
    code[859]=1499; //b

    code[931]=7795; //ExpressionStatement_13 # ExpressionStatement_15
    code[955]=2617; //var_forIndex_0
    code[912]=3798; //0

    code[1000]=4735; //ExpressionStatement_16 # ExpressionStatement_16
    code[1006]=587; //invocationTemp_8
    code[1002]=1499; //b

    code[1058]=7480; //ExpressionStatement_17 # ExpressionStatement_17
    code[1082]=2360; //var_whileCondition_0
    code[1075]=2617; //var_forIndex_0
    code[1074]=587; //invocationTemp_8

    code[1117]=1081; //WhileStatementSyntax_18 # WhileStatementSyntax_18
    code[1123]=343; //jmpWhileDestinationName_343
    code[1140]=2360; //var_whileCondition_0
    code[1099]=1271; //while_GoTo_True_1271
    code[1133]=3065; //while_GoTo_False_3065

    code[1186]=6695; //ExpressionStatement_19 # ExpressionStatement_19
    code[1193]=1725; //sum
    code[1205]=1725; //sum
    code[1174]=963; //"_"
    code[1172]=2617; //var_forIndex_0
    code[1190]=963; //"_"

    code[1257]=3293; //ExpressionStatement_12 # ExpressionStatement_20
    code[1248]=1725; //sum
    code[1260]=1725; //sum
    code[1246]=1414; //"~"

    code[1325]=6821; //ExpressionStatement_21 # ExpressionStatement_21
    code[1352]=247; //r
    code[1350]=247; //r
    code[1339]=1725; //sum
    code[1319]=2515; //"#"

    code[1395]=9150; //ExpressionStatement_22 # ExpressionStatement_22
    code[1396]=3015; //dst
    code[1411]=2617; //var_forIndex_0
    code[1379]=1725; //sum

    code[1459]=1977; //ExpressionStatement_23 # ExpressionStatement_23
    code[1460]=2617; //var_forIndex_0
    code[1445]=2617; //var_forIndex_0
    code[1478]=72; //1

    code[1515]=4735; //ExpressionStatement_16 # ExpressionStatement_24
    code[1521]=1827; //invocationTemp_9
    code[1517]=1499; //b

    code[1573]=7480; //ExpressionStatement_17 # ExpressionStatement_25
    code[1597]=2360; //var_whileCondition_0
    code[1590]=2617; //var_forIndex_0
    code[1589]=1827; //invocationTemp_9

    code[1632]=1500; //ExpressionStatement_26 # ExpressionStatement_26
    code[1645]=148; //while_FalseBlockSkip_148

    code[1690]=2603; //ExpressionStatement_27 # ExpressionStatement_27
    code[1715]=1276; //memberTemp_1
    code[1708]=3015; //dst

    code[1753]=4757; //ExpressionStatement_28 # ExpressionStatement_28
    code[1751]=1725; //sum
    code[1780]=1725; //sum
    code[1778]=2515; //"#"
    code[1764]=1276; //memberTemp_1

    code[1819]=8067; //ReturnStatement_29 # ReturnStatement_29
    code[1812]=1725; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_3371_op4_in1(vpc, data, code);

}

        private string ForSimple_Array_obfuscated_op2_in1(int b)
{
    //Virtualization variables
    int[] code = new int[100285];
    object[] data = new object[4187];
    int vpc = 44;

    //Data init
    data[92]=b; //b 
    data[2364]="" ; //"" constant
    data[115]=3; //3 constant
    data[1593]=4; //4 constant
    data[3975]="[" ; //"[" constant
    data[1280]="]"; //"]" constant
    data[639]=1; //1 constant
    data[2209]=0; //0 constant
    data[2845]="_" ; //"_" constant
    data[416]="~"; //"~" constant
    data[146]="#"; //"#" constant
    data[3329]=861137969; //addTemp_0 
    data[1424]=426817913; //addTemp_1 
    data[2032]=1090936824; //sum 
    data[3023]=(ConsoleCalculator.Engine)null; //invocationTemp_0 
    data[3639]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[2752]=(ConsoleCalculator.Piston)null; //invocationTemp_2 
    data[1393]=(double)0.792997966889757; //p1 
    data[3658]=1720645340; //addTemp_2 
    data[1742]=1088886007; //addTemp_3 
    data[1371]=(ConsoleCalculator.Engine)null; //invocationTemp_3 
    data[464]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_4 
    data[3405]=430; //memberTemp_0 
    data[89]=690; //addTemp_4 
    data[540]=(ConsoleCalculator.Engine)null; //invocationTemp_5 
    data[633]=(ConsoleCalculator.Piston)null; //invocationTemp_6 
    data[3643]=33887365; //invocationTemp_7 
    data[2869]=179759393; //r 
    data[2173]=(string[])null; //dst 
    data[905]=525; //var_forIndex_0 
    data[1525]=629; //invocationTemp_8 
    data[3690]=false; //var_whileCondition_0 
    data[1760]=748259412; //addTemp_5 
    data[1876]=1366923731; //addTemp_6 
    data[3462]=1837547023; //addTemp_7 
    data[3477]=752; //invocationTemp_9 
    data[1817]=-877; //memberTemp_1 
    data[1135]=450921265; //addTemp_8 
    data[3757]=-812; //jmpWhileDestinationName_3757 constant
    data[2785]=69; //while_GoTo_True_2785 constant
    data[1722]=810; //while_GoTo_False_1722 constant
    data[903]=-810; //while_FalseBlockSkip_903 constant

    //Code init

    code[44]=7697; //ExpressionStatement_0 # ExpressionStatement_0
    code[27]=3329; //addTemp_0
    code[58]=2364; //""
    code[47]=115; //3

    code[115]=7697; //ExpressionStatement_0 # ExpressionStatement_1
    code[98]=1424; //addTemp_1
    code[129]=3329; //addTemp_0
    code[118]=1593; //4

    code[186]=7376; //ExpressionStatement_2 # ExpressionStatement_2
    code[197]=2032; //sum
    code[204]=1424; //addTemp_1
    code[212]=2364; //""

    code[257]=5089; //ExpressionStatement_3 # ExpressionStatement_3
    code[273]=3023; //invocationTemp_0

    code[326]=3369; //ExpressionStatement_4 # ExpressionStatement_4
    code[328]=3639; //invocationTemp_1
    code[306]=3023; //invocationTemp_0

    code[394]=7503; //ExpressionStatement_5 # ExpressionStatement_5
    code[393]=2752; //invocationTemp_2
    code[418]=3639; //invocationTemp_1

    code[448]=8977; //ExpressionStatement_6 # ExpressionStatement_6
    code[433]=1393; //p1
    code[459]=2752; //invocationTemp_2

    code[509]=6388; //ExpressionStatement_7 # ExpressionStatement_7
    code[527]=3658; //addTemp_2
    code[505]=3975; //"["
    code[522]=1393; //p1

    code[565]=7376; //ExpressionStatement_2 # ExpressionStatement_8
    code[576]=1742; //addTemp_3
    code[583]=3658; //addTemp_2
    code[591]=1280; //"]"

    code[636]=7376; //ExpressionStatement_2 # ExpressionStatement_9
    code[647]=2032; //sum
    code[654]=2032; //sum
    code[662]=1742; //addTemp_3

    code[707]=5089; //ExpressionStatement_3 # ExpressionStatement_10
    code[723]=1371; //invocationTemp_3

    code[776]=3369; //ExpressionStatement_4 # ExpressionStatement_11
    code[778]=464; //invocationTemp_4
    code[756]=1371; //invocationTemp_3

    code[844]=6463; //ExpressionStatement_12 # ExpressionStatement_12
    code[839]=3405; //memberTemp_0
    code[824]=464; //invocationTemp_4

    code[915]=2167; //ExpressionStatement_13 # ExpressionStatement_13
    code[896]=89; //addTemp_4
    code[938]=3405; //memberTemp_0
    code[932]=639; //1

    code[976]=5089; //ExpressionStatement_3 # ExpressionStatement_14
    code[992]=540; //invocationTemp_5

    code[1045]=4181; //ExpressionStatement_15 # ExpressionStatement_15
    code[1028]=633; //invocationTemp_6
    code[1051]=540; //invocationTemp_5
    code[1035]=89; //addTemp_4

    code[1109]=5003; //ExpressionStatement_16 # ExpressionStatement_16
    code[1122]=3643; //invocationTemp_7
    code[1103]=633; //invocationTemp_6

    code[1165]=7376; //ExpressionStatement_2 # ExpressionStatement_17
    code[1176]=2032; //sum
    code[1183]=2032; //sum
    code[1191]=3643; //invocationTemp_7

    code[1236]=7595; //ExpressionStatement_18 # ExpressionStatement_18
    code[1249]=2869; //r
    code[1245]=2364; //""

    code[1307]=4138; //ExpressionStatement_19 # ExpressionStatement_19
    code[1305]=2173; //dst
    code[1331]=92; //b

    code[1367]=7595; //ExpressionStatement_18 # ExpressionStatement_20
    code[1380]=905; //var_forIndex_0
    code[1376]=2209; //0

    code[1438]=1729; //ExpressionStatement_21 # ExpressionStatement_21
    code[1452]=1525; //invocationTemp_8
    code[1455]=92; //b

    code[1507]=4452; //ExpressionStatement_22 # ExpressionStatement_22
    code[1524]=3690; //var_whileCondition_0
    code[1512]=905; //var_forIndex_0
    code[1530]=1525; //invocationTemp_8

    code[1574]=4795; //WhileStatementSyntax_23 # WhileStatementSyntax_23
    code[1563]=3757; //jmpWhileDestinationName_3757
    code[1583]=3690; //var_whileCondition_0
    code[1596]=2785; //while_GoTo_True_2785
    code[1571]=1722; //while_GoTo_False_1722

    code[1643]=7697; //ExpressionStatement_0 # ExpressionStatement_24
    code[1626]=1760; //addTemp_5
    code[1657]=2845; //"_"
    code[1646]=905; //var_forIndex_0

    code[1714]=7376; //ExpressionStatement_2 # ExpressionStatement_25
    code[1725]=1876; //addTemp_6
    code[1732]=1760; //addTemp_5
    code[1740]=2845; //"_"

    code[1785]=7376; //ExpressionStatement_2 # ExpressionStatement_26
    code[1796]=2032; //sum
    code[1803]=2032; //sum
    code[1811]=1876; //addTemp_6

    code[1856]=7376; //ExpressionStatement_2 # ExpressionStatement_27
    code[1867]=2032; //sum
    code[1874]=2032; //sum
    code[1882]=416; //"~"

    code[1927]=7376; //ExpressionStatement_2 # ExpressionStatement_28
    code[1938]=3462; //addTemp_7
    code[1945]=2032; //sum
    code[1953]=146; //"#"

    code[1998]=7376; //ExpressionStatement_2 # ExpressionStatement_29
    code[2009]=2869; //r
    code[2016]=2869; //r
    code[2024]=3462; //addTemp_7

    code[2069]=4327; //ExpressionStatement_30 # ExpressionStatement_30
    code[2060]=2173; //dst
    code[2071]=905; //var_forIndex_0
    code[2098]=2032; //sum

    code[2133]=5722; //ExpressionStatement_31 # ExpressionStatement_31
    code[2134]=905; //var_forIndex_0
    code[2155]=905; //var_forIndex_0
    code[2161]=639; //1

    code[2187]=1729; //ExpressionStatement_21 # ExpressionStatement_32
    code[2201]=3477; //invocationTemp_9
    code[2204]=92; //b

    code[2256]=4452; //ExpressionStatement_22 # ExpressionStatement_33
    code[2273]=3690; //var_whileCondition_0
    code[2261]=905; //var_forIndex_0
    code[2279]=3477; //invocationTemp_9

    code[2323]=1141; //ExpressionStatement_34 # ExpressionStatement_34
    code[2349]=903; //while_FalseBlockSkip_903

    code[2384]=5471; //ExpressionStatement_35 # ExpressionStatement_35
    code[2372]=1817; //memberTemp_1
    code[2391]=2173; //dst

    code[2440]=7697; //ExpressionStatement_0 # ExpressionStatement_36
    code[2423]=1135; //addTemp_8
    code[2454]=146; //"#"
    code[2443]=1817; //memberTemp_1

    code[2511]=7376; //ExpressionStatement_2 # ExpressionStatement_37
    code[2522]=2032; //sum
    code[2529]=2032; //sum
    code[2537]=1135; //addTemp_8

    code[2582]=7418; //ReturnStatement_38 # ReturnStatement_38
    code[2591]=2032; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_3189_op2_in1(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated_op4_in4(int b)
{
    //Virtualization variables
    int[] code = new int[100647];
    object[] data = new object[4745];
    int vpc = 65;

    //Data init
    data[303]=b; //b 
    data[776]="" ; //"" constant
    data[1815]=3 ; //3 constant
    data[1730]=4 ; //4 constant
    data[3218]="[" ; //"[" constant
    data[2933]="]"; //"]" constant
    data[3515]=1; //1 constant
    data[2228]=0; //0 constant
    data[1259]="_" ; //"_" constant
    data[1133]="~"; //"~" constant
    data[1839]="#"; //"#" constant
    data[3931]=855812097; //sum 
    data[1105]=(ConsoleCalculator.Piston)null; //invocationTemp_0 
    data[3035]=(double)0.484366179669446; //p1 
    data[240]=(System.Collections.Generic.List<ConsoleCalculator.Piston>)null; //invocationTemp_1 
    data[584]=856; //memberTemp_0 
    data[2424]=485289089; //invocationTemp_2 
    data[994]=1446861472; //r 
    data[971]=(string[])null; //dst 
    data[919]=11; //var_forIndex_0 
    data[1299]=false; //var_whileCondition_0 
    data[3755]=726; //memberTemp_1 
    data[2699]=-375; //jmpWhileDestinationName_2699 constant
    data[3551]=64; //while_GoTo_True_3551 constant
    data[3743]=515; //while_GoTo_False_3743 constant
    data[1398]=-515; //while_FalseBlockSkip_1398 constant

    //Code init

    code[65]=4266; //ExpressionStatement_0 # ExpressionStatement_0
    code[57]=3931; //sum
    code[75]=776; //""
    code[86]=1815; //3
    code[72]=1730; //4
    code[82]=776; //""

    code[137]=9274; //ExpressionStatement_1 # ExpressionStatement_1
    code[119]=1105; //invocationTemp_0

    code[201]=5928; //ExpressionStatement_2 # ExpressionStatement_2
    code[208]=3035; //p1
    code[206]=1105; //invocationTemp_0

    code[263]=9957; //ExpressionStatement_3 # ExpressionStatement_3
    code[286]=3931; //sum
    code[265]=3931; //sum
    code[270]=3218; //"["
    code[283]=3035; //p1
    code[244]=2933; //"]"

    code[319]=9559; //ExpressionStatement_4 # ExpressionStatement_4
    code[304]=240; //invocationTemp_1

    code[378]=4319; //ExpressionStatement_5 # ExpressionStatement_5
    code[395]=584; //memberTemp_0
    code[398]=240; //invocationTemp_1

    code[432]=4975; //ExpressionStatement_6 # ExpressionStatement_6
    code[443]=2424; //invocationTemp_2
    code[459]=584; //memberTemp_0
    code[436]=3515; //1

    code[502]=7440; //ExpressionStatement_7 # ExpressionStatement_7
    code[499]=3931; //sum
    code[487]=3931; //sum
    code[482]=2424; //invocationTemp_2

    code[559]=1528; //ExpressionStatement_8 # ExpressionStatement_8
    code[573]=994; //r
    code[574]=776; //""

    code[624]=9493; //ExpressionStatement_9 # ExpressionStatement_9
    code[642]=971; //dst
    code[619]=303; //b

    code[683]=1528; //ExpressionStatement_8 # ExpressionStatement_10
    code[697]=919; //var_forIndex_0
    code[698]=2228; //0

    code[748]=3017; //ExpressionStatement_11 # ExpressionStatement_11
    code[771]=1299; //var_whileCondition_0
    code[734]=919; //var_forIndex_0
    code[759]=303; //b

    code[814]=5955; //WhileStatementSyntax_12 # WhileStatementSyntax_12
    code[796]=2699; //jmpWhileDestinationName_2699
    code[809]=1299; //var_whileCondition_0
    code[837]=3551; //while_GoTo_True_3551
    code[799]=3743; //while_GoTo_False_3743

    code[878]=2450; //ExpressionStatement_13 # ExpressionStatement_13
    code[868]=3931; //sum
    code[892]=3931; //sum
    code[858]=1259; //"_"
    code[890]=919; //var_forIndex_0
    code[902]=1259; //"_"

    code[937]=7440; //ExpressionStatement_7 # ExpressionStatement_14
    code[934]=3931; //sum
    code[922]=3931; //sum
    code[917]=1133; //"~"

    code[994]=9092; //ExpressionStatement_15 # ExpressionStatement_15
    code[983]=994; //r
    code[992]=994; //r
    code[975]=3931; //sum
    code[993]=1839; //"#"

    code[1066]=8387; //ExpressionStatement_16 # ExpressionStatement_16
    code[1060]=971; //dst
    code[1076]=919; //var_forIndex_0
    code[1075]=3931; //sum

    code[1127]=1386; //ExpressionStatement_17 # ExpressionStatement_17
    code[1136]=919; //var_forIndex_0
    code[1142]=919; //var_forIndex_0
    code[1119]=3515; //1

    code[1196]=3017; //ExpressionStatement_11 # ExpressionStatement_18
    code[1219]=1299; //var_whileCondition_0
    code[1182]=919; //var_forIndex_0
    code[1207]=303; //b

    code[1262]=1167; //ExpressionStatement_19 # ExpressionStatement_19
    code[1267]=1398; //while_FalseBlockSkip_1398

    code[1329]=6484; //ExpressionStatement_20 # ExpressionStatement_20
    code[1339]=3755; //memberTemp_1
    code[1326]=971; //dst

    code[1382]=9926; //ExpressionStatement_21 # ExpressionStatement_21
    code[1381]=3931; //sum
    code[1372]=3931; //sum
    code[1375]=1839; //"#"
    code[1393]=3755; //memberTemp_1

    code[1455]=9534; //ReturnStatement_22 # ReturnStatement_22
    code[1458]=3931; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_2774_op4_in4(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
private string ForSimple_Array_obfuscated_op4_in5(int b)
{
    //Virtualization variables
    int[] code = new int[100029];
    object[] data = new object[4837];
    int vpc = 95;

    //Data init
    data[2559]=b; //b 
    data[2042]="" ; //"" constant
    data[39]=3 ; //3 constant
    data[2515]=4 ; //4 constant
    data[2332]="[" ; //"[" constant
    data[1592]="]"; //"]" constant
    data[3646]=1; //1 constant
    data[2164]=0; //0 constant
    data[1740]="_" ; //"_" constant
    data[2183]="~"; //"~" constant
    data[3632]="#"; //"#" constant
    data[3280]=596432624; //sum 
    data[1985]=(double)0.129145146873382; //p1 
    data[3127]=-383; //memberTemp_0 
    data[2407]=(ConsoleCalculator.Piston)null; //invocationTemp_0 
    data[3556]=273873507; //r 
    data[184]=(string[])null; //dst 
    data[388]=-989; //var_forIndex_0 
    data[145]=false; //var_whileCondition_0 
    data[2463]=439; //memberTemp_1 
    data[1167]=-55; //jmpWhileDestinationName_1167 constant
    data[1209]=56; //while_GoTo_True_1209 constant
    data[2765]=490; //while_GoTo_False_2765 constant
    data[1562]=-490; //while_FalseBlockSkip_1562 constant

    //Code init

    code[95]=7032; //ExpressionStatement_0 # ExpressionStatement_0
    code[86]=3280; //sum
    code[116]=2042; //""
    code[89]=39; //3
    code[104]=2515; //4
    code[101]=2042; //""

    code[161]=3871; //ExpressionStatement_1 # ExpressionStatement_1
    code[142]=1985; //p1

    code[229]=1570; //ExpressionStatement_2 # ExpressionStatement_2
    code[243]=3280; //sum
    code[244]=3280; //sum
    code[255]=2332; //"["
    code[212]=1985; //p1
    code[234]=1592; //"]"

    code[284]=7409; //ExpressionStatement_3 # ExpressionStatement_3
    code[301]=3127; //memberTemp_0

    code[340]=9817; //ExpressionStatement_4 # ExpressionStatement_4
    code[335]=2407; //invocationTemp_0
    code[331]=3127; //memberTemp_0
    code[343]=3646; //1

    code[406]=5197; //ExpressionStatement_5 # ExpressionStatement_5
    code[416]=3280; //sum
    code[419]=3280; //sum
    code[402]=2407; //invocationTemp_0

    code[464]=4246; //ExpressionStatement_6 # ExpressionStatement_6
    code[475]=3556; //r
    code[491]=2042; //""

    code[527]=4401; //ExpressionStatement_7 # ExpressionStatement_7
    code[555]=184; //dst
    code[530]=2559; //b

    code[590]=4246; //ExpressionStatement_6 # ExpressionStatement_8
    code[601]=388; //var_forIndex_0
    code[617]=2164; //0

    code[653]=8969; //ExpressionStatement_9 # ExpressionStatement_9
    code[652]=145; //var_whileCondition_0
    code[638]=388; //var_forIndex_0
    code[660]=2559; //b

    code[713]=4353; //WhileStatementSyntax_10 # WhileStatementSyntax_10
    code[733]=1167; //jmpWhileDestinationName_1167
    code[712]=145; //var_whileCondition_0
    code[735]=1209; //while_GoTo_True_1209
    code[723]=2765; //while_GoTo_False_2765

    code[769]=7715; //ExpressionStatement_11 # ExpressionStatement_11
    code[768]=3280; //sum
    code[782]=3280; //sum
    code[780]=1740; //"_"
    code[766]=388; //var_forIndex_0
    code[767]=1740; //"_"

    code[838]=6168; //ExpressionStatement_12 # ExpressionStatement_12
    code[834]=3280; //sum
    code[852]=3280; //sum
    code[856]=2183; //"~"

    code[905]=5691; //ExpressionStatement_13 # ExpressionStatement_13
    code[928]=3556; //r
    code[889]=3556; //r
    code[906]=3280; //sum
    code[931]=3632; //"#"

    code[961]=3135; //ExpressionStatement_14 # ExpressionStatement_14
    code[988]=184; //dst
    code[953]=388; //var_forIndex_0
    code[989]=3280; //sum

    code[1024]=1184; //ExpressionStatement_15 # ExpressionStatement_15
    code[1034]=388; //var_forIndex_0
    code[1038]=388; //var_forIndex_0
    code[1044]=3646; //1

    code[1090]=8969; //ExpressionStatement_9 # ExpressionStatement_16
    code[1089]=145; //var_whileCondition_0
    code[1075]=388; //var_forIndex_0
    code[1097]=2559; //b

    code[1150]=7702; //ExpressionStatement_17 # ExpressionStatement_17
    code[1141]=1562; //while_FalseBlockSkip_1562

    code[1203]=7729; //ExpressionStatement_18 # ExpressionStatement_18
    code[1215]=2463; //memberTemp_1
    code[1214]=184; //dst

    code[1256]=7151; //ExpressionStatement_19 # ExpressionStatement_19
    code[1237]=3280; //sum
    code[1252]=3280; //sum
    code[1258]=3632; //"#"
    code[1279]=2463; //memberTemp_1

    code[1310]=6384; //ReturnStatement_20 # ReturnStatement_20
    code[1313]=3280; //sum

    return (string)InstanceInterpreterVirtualization_TraceLoopTests_132_op4_in5(vpc, data, code);

}

        private int ReturnArg_Array(int arg)
        {
            return arg;
        }

       

private object InstanceInterpreterVirtualization_TraceLoopTests_3189_op2_in1(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 7697:  //frequency 4 ExpressionStatement_0
                data[code[vpc + (-17)]] = (string)data[code[vpc + (14)]] + (int)data[code[vpc + (3)]];
                vpc += 71;
                break;
            case 6463:  //frequency 1 ExpressionStatement_12
                data[code[vpc + (-5)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-20)]]).Count;
                vpc += 71;
                break;
            case 2167:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (-19)]] = (int)data[code[vpc + (23)]] - (int)data[code[vpc + (17)]];
                vpc += 61;
                break;
            case 5089:  //frequency 3 ExpressionStatement_3
                data[code[vpc + (16)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 69;
                break;
            case 4138:  //frequency 1 ExpressionStatement_19
                data[code[vpc + (-2)]] = (string[])(new string[(int)data[code[vpc + (24)]]]);
                vpc += 60;
                break;
            case 7595:  //frequency 2 ExpressionStatement_18
                data[code[vpc + (13)]] = data[code[vpc + (9)]];
                vpc += 71;
                break;
            default:  //frequency 0 
                break;
            case 7376:  //frequency 10 ExpressionStatement_2
                data[code[vpc + (11)]] = (string)data[code[vpc + (18)]] + (string)data[code[vpc + (26)]];
                vpc += 71;
                break;
            case 5722:  //frequency 1 ExpressionStatement_31
                data[code[vpc + (1)]] = (int)data[code[vpc + (22)]] + (int)data[code[vpc + (28)]];
                vpc += 54;
                break;
            case 5471:  //frequency 1 ExpressionStatement_35
                data[code[vpc + (-12)]] = ((string[])data[code[vpc + (7)]]).Length;
                vpc += 56;
                break;
            case 5003:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (13)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-6)]]).ToString();
                vpc += 56;
                break;
            case 7503:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (-1)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (24)]]).First());
                vpc += 54;
                break;
            case 1141:  //frequency 1 ExpressionStatement_34
                vpc += (int)data[code[vpc + (26)]];
                vpc += 61;
                break;
            case 4795:  //frequency 1 WhileStatementSyntax_23
                data[code[vpc + (-11)]] = (bool)data[code[vpc + (9)]] ? (int)data[code[vpc + (22)]] : (int)data[code[vpc + (-3)]];
                vpc += (int)data[code[vpc + (-11)]];
                break;
            case 4327:  //frequency 1 ExpressionStatement_30
                ((string[])data[code[vpc + (-9)]])[(int)data[code[vpc + (2)]]] = (string)data[code[vpc + (29)]];
                vpc += 64;
                break;
            case 1729:  //frequency 2 ExpressionStatement_21
                data[code[vpc + (14)]] = ReturnArg_Array((int)data[code[vpc + (17)]]);
                vpc += 69;
                break;
            case 3369:  //frequency 2 ExpressionStatement_4
                data[code[vpc + (2)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (-20)]]).GetPistons());
                vpc += 68;
                break;
            case 4452:  //frequency 2 ExpressionStatement_22
                data[code[vpc + (17)]] = (int)data[code[vpc + (5)]] < (int)data[code[vpc + (23)]];
                vpc += 67;
                break;
            case 8977:  //frequency 1 ExpressionStatement_6
                data[code[vpc + (-15)]] = ((ConsoleCalculator.Piston)data[code[vpc + (11)]]).GetSize();
                vpc += 61;
                break;
            case 7418:  //frequency 1 ReturnStatement_38
                return (string)data[code[vpc + (9)]];
                vpc += 60;
            case 4181:  //frequency 1 ExpressionStatement_15
                data[code[vpc + (-17)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (6)]]).GetPiston((int)data[code[vpc + (-10)]]));
                vpc += 64;
                break;
            case 6388:  //frequency 1 ExpressionStatement_7
                data[code[vpc + (18)]] = (string)data[code[vpc + (-4)]] + (double)data[code[vpc + (13)]];
                vpc += 56;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_1574_op3_in1(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 6859:  //frequency 1 ExpressionStatement_24
                data[code[vpc + (29)]] = (string)data[code[vpc + (19)]] + (string)data[code[vpc + (-14)]] + (string)data[code[vpc + (11)]];
                vpc += 56;
                break;
            case 5453:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (-1)]] = (string[])(new string[(int)data[code[vpc + (-15)]]]);
                vpc += 65;
                break;
            case 9767:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (-4)]] = ((ConsoleCalculator.Piston)data[code[vpc + (29)]]).GetSize();
                vpc += 55;
                break;
            case 9853:  //frequency 2 ExpressionStatement_18
                data[code[vpc + (-14)]] = ReturnArg_Array((int)data[code[vpc + (18)]]);
                vpc += 59;
                break;
            case 2041:  //frequency 1 ExpressionStatement_4
                data[code[vpc + (-10)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (17)]]).First());
                vpc += 58;
                break;
            case 5791:  //frequency 1 ExpressionStatement_30
                data[code[vpc + (-9)]] = ((string[])data[code[vpc + (-20)]]).Length;
                vpc += 65;
                break;
            case 5855:  //frequency 2 ExpressionStatement_19
                data[code[vpc + (-11)]] = (int)data[code[vpc + (-13)]] < (int)data[code[vpc + (12)]];
                vpc += 68;
                break;
            case 4523:  //frequency 2 ExpressionStatement_3
                data[code[vpc + (-3)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (3)]]).GetPistons());
                vpc += 52;
                break;
            case 9172:  //frequency 1 ExpressionStatement_12
                data[code[vpc + (4)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (-16)]]).GetPiston((int)data[code[vpc + (-18)]] - (int)data[code[vpc + (-8)]]));
                vpc += 61;
                break;
            case 8883:  //frequency 2 ExpressionStatement_15
                data[code[vpc + (-6)]] = data[code[vpc + (-13)]];
                vpc += 57;
                break;
            case 7253:  //frequency 1 ExpressionStatement_29
                vpc += (int)data[code[vpc + (-5)]];
                vpc += 67;
                break;
            case 1057:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (-1)]] = ((ConsoleCalculator.Piston)data[code[vpc + (10)]]).ToString();
                vpc += 65;
                break;
            case 2324:  //frequency 1 ReturnStatement_32
                return (string)data[code[vpc + (4)]];
                vpc += 59;
            case 4796:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (6)]] = (string)data[code[vpc + (26)]] + (int)data[code[vpc + (12)]] + (string)data[code[vpc + (20)]];
                vpc += 58;
                break;
            case 4875:  //frequency 5 ExpressionStatement_1
                data[code[vpc + (-13)]] = (string)data[code[vpc + (18)]] + (string)data[code[vpc + (2)]];
                vpc += 65;
                break;
            case 9652:  //frequency 1 ExpressionStatement_6
                data[code[vpc + (11)]] = (string)data[code[vpc + (27)]] + (double)data[code[vpc + (2)]] + (string)data[code[vpc + (5)]];
                vpc += 55;
                break;
            case 1203:  //frequency 1 ExpressionStatement_26
                data[code[vpc + (-4)]] = (int)data[code[vpc + (17)]] + (int)data[code[vpc + (21)]];
                vpc += 68;
                break;
            case 6185:  //frequency 1 ExpressionStatement_11
                data[code[vpc + (-19)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (9)]]).Count;
                vpc += 63;
                break;
            case 1230:  //frequency 3 ExpressionStatement_2
                data[code[vpc + (9)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 52;
                break;
            default:  //frequency 0 
                break;
            case 8506:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (16)]] = (string)data[code[vpc + (20)]] + (int)data[code[vpc + (17)]] + (int)data[code[vpc + (10)]];
                vpc += 69;
                break;
            case 5456:  //frequency 1 ExpressionStatement_31
                data[code[vpc + (19)]] = (string)data[code[vpc + (15)]] + (string)data[code[vpc + (9)]] + (int)data[code[vpc + (-3)]];
                vpc += 66;
                break;
            case 8472:  //frequency 1 ExpressionStatement_25
                ((string[])data[code[vpc + (20)]])[(int)data[code[vpc + (5)]]] = (string)data[code[vpc + (3)]];
                vpc += 58;
                break;
            case 7901:  //frequency 1 WhileStatementSyntax_20
                data[code[vpc + (-3)]] = (bool)data[code[vpc + (25)]] ? (int)data[code[vpc + (15)]] : (int)data[code[vpc + (-4)]];
                vpc += (int)data[code[vpc + (-3)]];
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_3371_op4_in1(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 8067:  //frequency 1 ReturnStatement_29
                return (string)data[code[vpc + (-7)]];
                vpc += 67;
            case 2738:  //frequency 1 ExpressionStatement_10
                data[code[vpc + (-5)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (-20)]]).GetPiston((int)data[code[vpc + (-17)]] - (int)data[code[vpc + (-6)]]));
                vpc += 61;
                break;
            default:  //frequency 0 
                break;
            case 6699:  //frequency 1 ExpressionStatement_3
                data[code[vpc + (-14)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (25)]]).First());
                vpc += 60;
                break;
            case 2603:  //frequency 1 ExpressionStatement_27
                data[code[vpc + (25)]] = ((string[])data[code[vpc + (18)]]).Length;
                vpc += 63;
                break;
            case 3293:  //frequency 2 ExpressionStatement_12
                data[code[vpc + (-9)]] = (string)data[code[vpc + (3)]] + (string)data[code[vpc + (-11)]];
                vpc += 68;
                break;
            case 8700:  //frequency 1 ExpressionStatement_11
                data[code[vpc + (-10)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-9)]]).ToString();
                vpc += 59;
                break;
            case 1081:  //frequency 1 WhileStatementSyntax_18
                data[code[vpc + (6)]] = (bool)data[code[vpc + (23)]] ? (int)data[code[vpc + (-18)]] : (int)data[code[vpc + (16)]];
                vpc += (int)data[code[vpc + (6)]];
                break;
            case 4735:  //frequency 2 ExpressionStatement_16
                data[code[vpc + (6)]] = ReturnArg_Array((int)data[code[vpc + (2)]]);
                vpc += 58;
                break;
            case 2611:  //frequency 1 ExpressionStatement_14
                data[code[vpc + (17)]] = (string[])(new string[(int)data[code[vpc + (-10)]]]);
                vpc += 62;
                break;
            case 6821:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (27)]] = (string)data[code[vpc + (25)]] + (string)data[code[vpc + (14)]] + (string)data[code[vpc + (-6)]];
                vpc += 70;
                break;
            case 1500:  //frequency 1 ExpressionStatement_26
                vpc += (int)data[code[vpc + (13)]];
                vpc += 58;
                break;
            case 9219:  //frequency 1 ExpressionStatement_4
                data[code[vpc + (-11)]] = ((ConsoleCalculator.Piston)data[code[vpc + (17)]]).GetSize();
                vpc += 65;
                break;
            case 4757:  //frequency 1 ExpressionStatement_28
                data[code[vpc + (-2)]] = (string)data[code[vpc + (27)]] + (string)data[code[vpc + (25)]] + (int)data[code[vpc + (11)]];
                vpc += 66;
                break;
            case 5631:  //frequency 3 ExpressionStatement_1
                data[code[vpc + (14)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 56;
                break;
            case 6837:  //frequency 2 ExpressionStatement_2
                data[code[vpc + (-5)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (25)]]).GetPistons());
                vpc += 53;
                break;
            case 9627:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (11)]] = (string)data[code[vpc + (-9)]] + (string)data[code[vpc + (16)]] + (double)data[code[vpc + (-7)]] + (string)data[code[vpc + (-14)]];
                vpc += 66;
                break;
            case 6695:  //frequency 1 ExpressionStatement_19
                data[code[vpc + (7)]] = (string)data[code[vpc + (19)]] + (string)data[code[vpc + (-12)]] + (int)data[code[vpc + (-14)]] + (string)data[code[vpc + (4)]];
                vpc += 71;
                break;
            case 3746:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (14)]] = (string)data[code[vpc + (26)]] + (int)data[code[vpc + (13)]] + (int)data[code[vpc + (-7)]] + (string)data[code[vpc + (15)]];
                vpc += 73;
                break;
            case 7795:  //frequency 2 ExpressionStatement_13
                data[code[vpc + (24)]] = data[code[vpc + (-19)]];
                vpc += 69;
                break;
            case 9150:  //frequency 1 ExpressionStatement_22
                ((string[])data[code[vpc + (1)]])[(int)data[code[vpc + (16)]]] = (string)data[code[vpc + (-16)]];
                vpc += 64;
                break;
            case 2964:  //frequency 1 ExpressionStatement_9
                data[code[vpc + (9)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (2)]]).Count;
                vpc += 54;
                break;
            case 7480:  //frequency 2 ExpressionStatement_17
                data[code[vpc + (24)]] = (int)data[code[vpc + (17)]] < (int)data[code[vpc + (16)]];
                vpc += 59;
                break;
            case 1977:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (1)]] = (int)data[code[vpc + (-14)]] + (int)data[code[vpc + (19)]];
                vpc += 56;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_2774_op4_in4(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 1167:  //frequency 1 ExpressionStatement_19
                vpc += (int)data[code[vpc + (5)]];
                vpc += 67;
                break;
            case 1528:  //frequency 2 ExpressionStatement_8
                data[code[vpc + (14)]] = data[code[vpc + (15)]];
                vpc += 65;
                break;
            case 2450:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (-10)]] = (string)data[code[vpc + (14)]] + (string)data[code[vpc + (-20)]] + (int)data[code[vpc + (12)]] + (string)data[code[vpc + (24)]];
                vpc += 59;
                break;
            case 7440:  //frequency 2 ExpressionStatement_7
                data[code[vpc + (-3)]] = (string)data[code[vpc + (-15)]] + (string)data[code[vpc + (-20)]];
                vpc += 57;
                break;
            case 9926:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (-1)]] = (string)data[code[vpc + (-10)]] + (string)data[code[vpc + (-7)]] + (int)data[code[vpc + (11)]];
                vpc += 73;
                break;
            case 4975:  //frequency 1 ExpressionStatement_6
                data[code[vpc + (11)]] = car.GetEngine().GetPiston((int)data[code[vpc + (27)]] - (int)data[code[vpc + (4)]]).ToString();
                vpc += 70;
                break;
            case 9534:  //frequency 1 ReturnStatement_22
                return (string)data[code[vpc + (3)]];
                vpc += 51;
            case 5955:  //frequency 1 WhileStatementSyntax_12
                data[code[vpc + (-18)]] = (bool)data[code[vpc + (-5)]] ? (int)data[code[vpc + (23)]] : (int)data[code[vpc + (-15)]];
                vpc += (int)data[code[vpc + (-18)]];
                break;
            case 9957:  //frequency 1 ExpressionStatement_3
                data[code[vpc + (23)]] = (string)data[code[vpc + (2)]] + (string)data[code[vpc + (7)]] + (double)data[code[vpc + (20)]] + (string)data[code[vpc + (-19)]];
                vpc += 56;
                break;
            case 3017:  //frequency 2 ExpressionStatement_11
                data[code[vpc + (23)]] = (int)data[code[vpc + (-14)]] < ReturnArg_Array((int)data[code[vpc + (11)]]);
                vpc += 66;
                break;
            case 4319:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (17)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (20)]]).Count;
                vpc += 54;
                break;
            case 6484:  //frequency 1 ExpressionStatement_20
                data[code[vpc + (10)]] = ((string[])data[code[vpc + (-3)]]).Length;
                vpc += 53;
                break;
            case 5928:  //frequency 1 ExpressionStatement_2
                data[code[vpc + (7)]] = ((ConsoleCalculator.Piston)data[code[vpc + (5)]]).GetSize();
                vpc += 62;
                break;
            case 9092:  //frequency 1 ExpressionStatement_15
                data[code[vpc + (-11)]] = (string)data[code[vpc + (-2)]] + (string)data[code[vpc + (-19)]] + (string)data[code[vpc + (-1)]];
                vpc += 72;
                break;
            case 8387:  //frequency 1 ExpressionStatement_16
                ((string[])data[code[vpc + (-6)]])[(int)data[code[vpc + (10)]]] = (string)data[code[vpc + (9)]];
                vpc += 61;
                break;
            case 1386:  //frequency 1 ExpressionStatement_17
                data[code[vpc + (9)]] = (int)data[code[vpc + (15)]] + (int)data[code[vpc + (-8)]];
                vpc += 69;
                break;
            case 9559:  //frequency 1 ExpressionStatement_4
                data[code[vpc + (-15)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(car.GetEngine().GetPistons());
                vpc += 59;
                break;
            case 9274:  //frequency 1 ExpressionStatement_1
                data[code[vpc + (-18)]] = (ConsoleCalculator.Piston)(car.GetEngine().GetPistons().First());
                vpc += 64;
                break;
            case 9493:  //frequency 1 ExpressionStatement_9
                data[code[vpc + (18)]] = (string[])(new string[(int)data[code[vpc + (-5)]]]);
                vpc += 59;
                break;
            case 4266:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (-8)]] = (string)data[code[vpc + (10)]] + (int)data[code[vpc + (21)]] + (int)data[code[vpc + (7)]] + (string)data[code[vpc + (17)]];
                vpc += 72;
                break;
            default:  //frequency 0 
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_132_op4_in5(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 7409:  //frequency 1 ExpressionStatement_3
                data[code[vpc + (17)]] = car.GetEngine().GetPistons().Count;
                vpc += 56;
                break;
            case 4353:  //frequency 1 WhileStatementSyntax_10
                data[code[vpc + (20)]] = (bool)data[code[vpc + (-1)]] ? (int)data[code[vpc + (22)]] : (int)data[code[vpc + (10)]];
                vpc += (int)data[code[vpc + (20)]];
                break;
            case 7151:  //frequency 1 ExpressionStatement_19
                data[code[vpc + (-19)]] = (string)data[code[vpc + (-4)]] + (string)data[code[vpc + (2)]] + (int)data[code[vpc + (23)]];
                vpc += 54;
                break;
            case 5197:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (10)]] = (string)data[code[vpc + (13)]] + ((ConsoleCalculator.Piston)data[code[vpc + (-4)]]).ToString();
                vpc += 58;
                break;
            case 1570:  //frequency 1 ExpressionStatement_2
                data[code[vpc + (14)]] = (string)data[code[vpc + (15)]] + (string)data[code[vpc + (26)]] + (double)data[code[vpc + (-17)]] + (string)data[code[vpc + (5)]];
                vpc += 55;
                break;
            case 7715:  //frequency 1 ExpressionStatement_11
                data[code[vpc + (-1)]] = (string)data[code[vpc + (13)]] + (string)data[code[vpc + (11)]] + (int)data[code[vpc + (-3)]] + (string)data[code[vpc + (-2)]];
                vpc += 69;
                break;
            case 5691:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (23)]] = (string)data[code[vpc + (-16)]] + (string)data[code[vpc + (1)]] + (string)data[code[vpc + (26)]];
                vpc += 56;
                break;
            case 7702:  //frequency 1 ExpressionStatement_17
                vpc += (int)data[code[vpc + (-9)]];
                vpc += 53;
                break;
            case 3871:  //frequency 1 ExpressionStatement_1
                data[code[vpc + (-19)]] = car.GetEngine().GetPistons().First().GetSize();
                vpc += 68;
                break;
            case 1184:  //frequency 1 ExpressionStatement_15
                data[code[vpc + (10)]] = (int)data[code[vpc + (14)]] + (int)data[code[vpc + (20)]];
                vpc += 66;
                break;
            case 6384:  //frequency 1 ReturnStatement_20
                return (string)data[code[vpc + (3)]];
                vpc += 57;
            case 3135:  //frequency 1 ExpressionStatement_14
                ((string[])data[code[vpc + (27)]])[(int)data[code[vpc + (-8)]]] = (string)data[code[vpc + (28)]];
                vpc += 63;
                break;
            case 6168:  //frequency 1 ExpressionStatement_12
                data[code[vpc + (-4)]] = (string)data[code[vpc + (14)]] + (string)data[code[vpc + (18)]];
                vpc += 67;
                break;
            case 4246:  //frequency 2 ExpressionStatement_6
                data[code[vpc + (11)]] = data[code[vpc + (27)]];
                vpc += 63;
                break;
            default:  //frequency 0 
                break;
            case 7032:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (-9)]] = (string)data[code[vpc + (21)]] + (int)data[code[vpc + (-6)]] + (int)data[code[vpc + (9)]] + (string)data[code[vpc + (6)]];
                vpc += 66;
                break;
            case 9817:  //frequency 1 ExpressionStatement_4
                data[code[vpc + (-5)]] = (ConsoleCalculator.Piston)(car.GetEngine().GetPiston((int)data[code[vpc + (-9)]] - (int)data[code[vpc + (3)]]));
                vpc += 66;
                break;
            case 7729:  //frequency 1 ExpressionStatement_18
                data[code[vpc + (12)]] = ((string[])data[code[vpc + (11)]]).Length;
                vpc += 53;
                break;
            case 8969:  //frequency 2 ExpressionStatement_9
                data[code[vpc + (-1)]] = (int)data[code[vpc + (-15)]] < ReturnArg_Array((int)data[code[vpc + (7)]]);
                vpc += 60;
                break;
            case 4401:  //frequency 1 ExpressionStatement_7
                data[code[vpc + (28)]] = (string[])(new string[(int)data[code[vpc + (3)]]]);
                vpc += 63;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_3664_2_op4_in1(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 6361:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (4)]] = (string)data[code[vpc + (28)]] + (int)data[code[vpc + (-10)]];
                vpc += 62;
                break;
            case 9860:  //frequency 1 ExpressionStatement_28
                vpc += (int)data[code[vpc + (14)]];
                vpc += 51;
                break;
            case 2372:  //frequency 1 ReturnStatement_31
                return (string)data[code[vpc + (24)]];
                vpc += 56;
            case 6440:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (-20)]] = (string)data[code[vpc + (12)]] + (string)data[code[vpc + (4)]] + (double)data[code[vpc + (-4)]] + (string)data[code[vpc + (-18)]];
                vpc += 71;
                break;
            case 4889:  //frequency 1 ExpressionStatement_9
                data[code[vpc + (-8)]] = (string[])(new string[(int)data[code[vpc + (-18)]]]);
                vpc += 66;
                break;
            case 6517:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (5)]] = (string)data[code[vpc + (24)]] + (string)data[code[vpc + (12)]] + (string)data[code[vpc + (-2)]];
                vpc += 56;
                break;
            case 6043:  //frequency 2 ExpressionStatement_3
                data[code[vpc + (29)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (-18)]]).GetPistons());
                vpc += 59;
                break;
            case 6050:  //frequency 1 ExpressionStatement_24
                ((string[])data[code[vpc + (29)]])[(int)data[code[vpc + (1)]]] = (string)data[code[vpc + (-17)]];
                vpc += 61;
                break;
            case 7807:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (6)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (9)]]).GetPiston((int)data[code[vpc + (-13)]] - (int)data[code[vpc + (17)]]));
                vpc += 65;
                break;
            case 8318:  //frequency 2 ExpressionStatement_8
                data[code[vpc + (-18)]] = data[code[vpc + (15)]];
                vpc += 66;
                break;
            case 1796:  //frequency 1 ExpressionStatement_22
                data[code[vpc + (-19)]] = ((string)data[code[vpc + (18)]]).Length;
                vpc += 61;
                break;
            default:  //frequency 3 ExpressionStatement_1
                data[code[vpc + (-5)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 66;
                break;
            case 8245:  //frequency 2 ExpressionStatement_11
                data[code[vpc + (27)]] = ReturnArg_Array((int)data[code[vpc + (26)]]);
                vpc += 66;
                break;
            case 3144:  //frequency 1 ExpressionStatement_20
                data[code[vpc + (17)]] = ((ConsoleCalculator.Piston)data[code[vpc + (18)]]).GetSize();
                vpc += 63;
                break;
            case 2063:  //frequency 2 ExpressionStatement_12
                data[code[vpc + (8)]] = (int)data[code[vpc + (-16)]] < (int)data[code[vpc + (-13)]];
                vpc += 53;
                break;
            case 7862:  //frequency 2 ExpressionStatement_7
                data[code[vpc + (19)]] = (string)data[code[vpc + (10)]] + (string)data[code[vpc + (7)]];
                vpc += 61;
                break;
            case 5774:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (-20)]] = (string)data[code[vpc + (1)]] + (int)data[code[vpc + (-9)]] + (int)data[code[vpc + (11)]] + (string)data[code[vpc + (-10)]];
                vpc += 56;
                break;
            case 7054:  //frequency 1 ExpressionStatement_19
                data[code[vpc + (6)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (26)]]).First());
                vpc += 66;
                break;
            case 2942:  //frequency 1 ExpressionStatement_30
                data[code[vpc + (-18)]] = (string)data[code[vpc + (-1)]] + (string)data[code[vpc + (29)]] + (int)data[code[vpc + (21)]];
                vpc += 72;
                break;
            case 7373:  //frequency 1 ExpressionStatement_4
                data[code[vpc + (12)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-11)]]).Count;
                vpc += 67;
                break;
            case 5703:  //frequency 1 ExpressionStatement_25
                data[code[vpc + (22)]] = (int)data[code[vpc + (-10)]] + (int)data[code[vpc + (-13)]];
                vpc += 68;
                break;
            case 2223:  //frequency 1 ExpressionStatement_6
                data[code[vpc + (10)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-3)]]).ToString();
                vpc += 69;
                break;
            case 6605:  //frequency 1 WhileStatementSyntax_13
                data[code[vpc + (18)]] = (bool)data[code[vpc + (19)]] ? (int)data[code[vpc + (16)]] : (int)data[code[vpc + (-2)]];
                vpc += (int)data[code[vpc + (18)]];
                break;
            case 3889:  //frequency 1 ExpressionStatement_14
                data[code[vpc + (25)]] = (string)data[code[vpc + (16)]] + (string)data[code[vpc + (-4)]] + (int)data[code[vpc + (-17)]] + (string)data[code[vpc + (21)]];
                vpc += 68;
                break;
            case 1706:  //frequency 1 ExpressionStatement_29
                data[code[vpc + (24)]] = ((string[])data[code[vpc + (-12)]]).Length;
                vpc += 61;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_913_2_op4_in2(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 9852:  //frequency 2 ExpressionStatement_7
                data[code[vpc + (7)]] = (string)data[code[vpc + (26)]] + (string)data[code[vpc + (2)]];
                vpc += 59;
                break;
            default:  //frequency 0 
                break;
            case 6067:  //frequency 1 ExpressionStatement_29
                data[code[vpc + (-5)]] = ((string[])data[code[vpc + (8)]]).Length;
                vpc += 53;
                break;
            case 8188:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (-5)]] = (string)data[code[vpc + (13)]] + (string)data[code[vpc + (-2)]] + (double)data[code[vpc + (-4)]] + (string)data[code[vpc + (11)]];
                vpc += 61;
                break;
            case 6007:  //frequency 1 ExpressionStatement_24
                ((string[])data[code[vpc + (5)]])[(int)data[code[vpc + (21)]]] = (string)data[code[vpc + (6)]];
                vpc += 63;
                break;
            case 7907:  //frequency 1 ExpressionStatement_25
                data[code[vpc + (-18)]] = (int)data[code[vpc + (17)]] + (int)data[code[vpc + (22)]];
                vpc += 62;
                break;
            case 6991:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (-15)]] = (string)data[code[vpc + (-8)]] + (string)data[code[vpc + (22)]] + (string)data[code[vpc + (-10)]];
                vpc += 61;
                break;
            case 1508:  //frequency 1 ReturnStatement_31
                return (string)data[code[vpc + (19)]];
                vpc += 68;
            case 6045:  //frequency 1 ExpressionStatement_30
                data[code[vpc + (-8)]] = (string)data[code[vpc + (19)]] + (string)data[code[vpc + (-3)]] + (int)data[code[vpc + (-17)]];
                vpc += 61;
                break;
            case 4169:  //frequency 1 ExpressionStatement_28
                vpc += (int)data[code[vpc + (17)]];
                vpc += 65;
                break;
            case 5350:  //frequency 1 WhileStatementSyntax_13
                data[code[vpc + (17)]] = (bool)data[code[vpc + (6)]] ? (int)data[code[vpc + (-13)]] : (int)data[code[vpc + (21)]];
                vpc += (int)data[code[vpc + (17)]];
                break;
            case 4592:  //frequency 2 ExpressionStatement_12
                data[code[vpc + (15)]] = (int)data[code[vpc + (-15)]] < (int)data[code[vpc + (16)]];
                vpc += 58;
                break;
            case 6602:  //frequency 1 ExpressionStatement_4
                data[code[vpc + (10)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-1)]]).Count;
                vpc += 62;
                break;
            case 8147:  //frequency 1 ExpressionStatement_6
                data[code[vpc + (9)]] = ((ConsoleCalculator.Piston)data[code[vpc + (4)]]).ToString();
                vpc += 65;
                break;
            case 3603:  //frequency 3 ExpressionStatement_1
                data[code[vpc + (-11)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 60;
                break;
            case 3768:  //frequency 2 ExpressionStatement_8
                data[code[vpc + (18)]] = data[code[vpc + (-6)]];
                vpc += 63;
                break;
            case 5550:  //frequency 2 ExpressionStatement_3
                data[code[vpc + (18)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (-2)]]).GetPistons());
                vpc += 64;
                break;
            case 5836:  //frequency 2 ExpressionStatement_11
                data[code[vpc + (11)]] = ReturnArg_Array((int)data[code[vpc + (3)]]);
                vpc += 58;
                break;
            case 6308:  //frequency 1 ExpressionStatement_22
                data[code[vpc + (13)]] = ((string)data[code[vpc + (3)]]).Length;
                vpc += 71;
                break;
            case 8744:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (5)]] = (string)data[code[vpc + (22)]] + (int)data[code[vpc + (-16)]] + (int)data[code[vpc + (-7)]] + (string)data[code[vpc + (-3)]];
                vpc += 66;
                break;
            case 5954:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (-6)]] = (string)data[code[vpc + (4)]] + (int)data[code[vpc + (11)]];
                vpc += 69;
                break;
            case 3761:  //frequency 1 ExpressionStatement_14
                data[code[vpc + (7)]] = (string)data[code[vpc + (20)]] + (string)data[code[vpc + (-6)]] + (int)data[code[vpc + (-18)]] + (string)data[code[vpc + (11)]];
                vpc += 71;
                break;
            case 3067:  //frequency 1 ExpressionStatement_19
                data[code[vpc + (-14)]] = (ConsoleCalculator.Piston)(((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (26)]]).First());
                vpc += 58;
                break;
            case 1734:  //frequency 1 ExpressionStatement_20
                data[code[vpc + (7)]] = ((ConsoleCalculator.Piston)data[code[vpc + (-11)]]).GetSize();
                vpc += 67;
                break;
            case 1972:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (-2)]] = (ConsoleCalculator.Piston)(((ConsoleCalculator.Engine)data[code[vpc + (-12)]]).GetPiston((int)data[code[vpc + (10)]] - (int)data[code[vpc + (11)]]));
                vpc += 65;
                break;
            case 4038:  //frequency 1 ExpressionStatement_9
                data[code[vpc + (2)]] = (string[])(new string[(int)data[code[vpc + (20)]]]);
                vpc += 62;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_2835_2_op4_in3(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 7415:  //frequency 1 ExpressionStatement_23
                vpc += (int)data[code[vpc + (-15)]];
                vpc += 64;
                break;
            case 4449:  //frequency 1 ReturnStatement_26
                return (string)data[code[vpc + (5)]];
                vpc += 63;
            case 8970:  //frequency 1 ExpressionStatement_1
                data[code[vpc + (17)]] = (ConsoleCalculator.Engine)(car.GetEngine());
                vpc += 65;
                break;
            case 3792:  //frequency 1 ExpressionStatement_3
                data[code[vpc + (-7)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-16)]]).Count;
                vpc += 60;
                break;
            case 1335:  //frequency 1 ExpressionStatement_22
                data[code[vpc + (-9)]] = (int)data[code[vpc + (-6)]] < ReturnArg_Array((int)data[code[vpc + (-10)]]);
                vpc += 57;
                break;
            case 1395:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (-17)]] = (string)data[code[vpc + (13)]] + (int)data[code[vpc + (-1)]] + (int)data[code[vpc + (12)]] + (string)data[code[vpc + (8)]];
                vpc += 66;
                break;
            case 6641:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (5)]] = (int)data[code[vpc + (20)]] + (int)data[code[vpc + (14)]];
                vpc += 58;
                break;
            case 1132:  //frequency 1 ExpressionStatement_18
                data[code[vpc + (25)]] = ((string)data[code[vpc + (13)]]).Length;
                vpc += 55;
                break;
            case 1164:  //frequency 1 ExpressionStatement_20
                ((string[])data[code[vpc + (17)]])[(int)data[code[vpc + (-12)]]] = (string)data[code[vpc + (-7)]];
                vpc += 64;
                break;
            case 2578:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (-14)]] = (string)data[code[vpc + (8)]] + ((ConsoleCalculator.Piston)data[code[vpc + (12)]]).ToString();
                vpc += 58;
                break;
            case 5450:  //frequency 1 WhileStatementSyntax_11
                data[code[vpc + (1)]] = (bool)data[code[vpc + (14)]] ? (int)data[code[vpc + (-15)]] : (int)data[code[vpc + (10)]];
                vpc += (int)data[code[vpc + (1)]];
                break;
            case 3200:  //frequency 1 ExpressionStatement_10
                data[code[vpc + (7)]] = (int)data[code[vpc + (18)]] < (int)data[code[vpc + (4)]];
                vpc += 59;
                break;
            case 3718:  //frequency 1 ExpressionStatement_2
                data[code[vpc + (2)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(((ConsoleCalculator.Engine)data[code[vpc + (18)]]).GetPistons());
                vpc += 67;
                break;
            case 4590:  //frequency 2 ExpressionStatement_6
                data[code[vpc + (20)]] = data[code[vpc + (-5)]];
                vpc += 58;
                break;
            case 1197:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (-19)]] = (string)data[code[vpc + (29)]] + (string)data[code[vpc + (-5)]];
                vpc += 61;
                break;
            case 1849:  //frequency 1 ExpressionStatement_25
                data[code[vpc + (3)]] = (string)data[code[vpc + (-13)]] + (string)data[code[vpc + (28)]] + (int)data[code[vpc + (8)]];
                vpc += 72;
                break;
            case 7703:  //frequency 1 ExpressionStatement_15
                data[code[vpc + (1)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(car.GetEngine().GetPistons());
                vpc += 67;
                break;
            case 1364:  //frequency 1 ExpressionStatement_7
                data[code[vpc + (-7)]] = (string[])(new string[(int)data[code[vpc + (-1)]]]);
                vpc += 60;
                break;
            case 9526:  //frequency 1 ExpressionStatement_9
                data[code[vpc + (28)]] = ReturnArg_Array((int)data[code[vpc + (-11)]]);
                vpc += 70;
                break;
            case 2262:  //frequency 1 ExpressionStatement_17
                data[code[vpc + (19)]] = (string)data[code[vpc + (-13)]] + (string)data[code[vpc + (10)]] + (double)data[code[vpc + (-16)]] + (string)data[code[vpc + (7)]];
                vpc += 71;
                break;
            case 8314:  //frequency 1 ExpressionStatement_24
                data[code[vpc + (-2)]] = ((string[])data[code[vpc + (-15)]]).Length;
                vpc += 71;
                break;
            case 7974:  //frequency 1 ExpressionStatement_12
                data[code[vpc + (-15)]] = (string)data[code[vpc + (27)]] + (string)data[code[vpc + (-6)]] + (int)data[code[vpc + (-2)]] + (string)data[code[vpc + (22)]];
                vpc += 62;
                break;
            case 1510:  //frequency 1 ExpressionStatement_19
                data[code[vpc + (15)]] = (string)data[code[vpc + (-15)]] + (int)data[code[vpc + (19)]];
                vpc += 59;
                break;
            case 2505:  //frequency 1 ExpressionStatement_4
                data[code[vpc + (27)]] = (ConsoleCalculator.Piston)(car.GetEngine().GetPiston((int)data[code[vpc + (-9)]] - (int)data[code[vpc + (-6)]]));
                vpc += 53;
                break;
            default:  //frequency 0 
                break;
            case 7817:  //frequency 1 ExpressionStatement_14
                data[code[vpc + (-18)]] = (string)data[code[vpc + (21)]] + (string)data[code[vpc + (-20)]] + (string)data[code[vpc + (24)]];
                vpc += 67;
                break;
            case 6319:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (20)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (9)]]).First().GetSize();
                vpc += 70;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_1236_2_op4_in4(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 2933:  //frequency 1 ExpressionStatement_2
                data[code[vpc + (25)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (-17)]]).Count;
                vpc += 60;
                break;
            case 4422:  //frequency 1 WhileStatementSyntax_9
                data[code[vpc + (-11)]] = (bool)data[code[vpc + (14)]] ? (int)data[code[vpc + (-1)]] : (int)data[code[vpc + (26)]];
                vpc += (int)data[code[vpc + (-11)]];
                break;
            case 2506:  //frequency 2 ExpressionStatement_5
                data[code[vpc + (5)]] = data[code[vpc + (-6)]];
                vpc += 64;
                break;
            case 6071:  //frequency 1 ExpressionStatement_22
                data[code[vpc + (-19)]] = ((string[])data[code[vpc + (23)]]).Length;
                vpc += 62;
                break;
            case 5044:  //frequency 1 ExpressionStatement_15
                data[code[vpc + (-4)]] = (string)data[code[vpc + (25)]] + (string)data[code[vpc + (23)]] + (double)data[code[vpc + (10)]] + (string)data[code[vpc + (13)]];
                vpc += 73;
                break;
            case 1624:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (-9)]] = ((string)data[code[vpc + (26)]]).Length;
                vpc += 53;
                break;
            case 7895:  //frequency 2 ExpressionStatement_8
                data[code[vpc + (-1)]] = (int)data[code[vpc + (17)]] < ReturnArg_Array((int)data[code[vpc + (24)]]);
                vpc += 54;
                break;
            case 6453:  //frequency 2 ExpressionStatement_4
                data[code[vpc + (13)]] = (string)data[code[vpc + (29)]] + (string)data[code[vpc + (-12)]];
                vpc += 65;
                break;
            case 6090:  //frequency 2 ExpressionStatement_1
                data[code[vpc + (-17)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(car.GetEngine().GetPistons());
                vpc += 58;
                break;
            case 2924:  //frequency 1 ExpressionStatement_14
                data[code[vpc + (-15)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (2)]]).First().GetSize();
                vpc += 57;
                break;
            default:  //frequency 0 
                break;
            case 7526:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (5)]] = (string)data[code[vpc + (9)]] + (int)data[code[vpc + (-13)]] + (int)data[code[vpc + (19)]] + (string)data[code[vpc + (29)]];
                vpc += 63;
                break;
            case 4453:  //frequency 1 ExpressionStatement_21
                vpc += (int)data[code[vpc + (27)]];
                vpc += 55;
                break;
            case 8517:  //frequency 1 ExpressionStatement_10
                data[code[vpc + (-1)]] = (string)data[code[vpc + (16)]] + (string)data[code[vpc + (7)]] + (int)data[code[vpc + (3)]] + (string)data[code[vpc + (12)]];
                vpc += 60;
                break;
            case 9963:  //frequency 1 ExpressionStatement_17
                data[code[vpc + (22)]] = (string)data[code[vpc + (26)]] + (int)data[code[vpc + (-20)]];
                vpc += 53;
                break;
            case 5643:  //frequency 1 ExpressionStatement_19
                data[code[vpc + (7)]] = (int)data[code[vpc + (-3)]] + (int)data[code[vpc + (28)]];
                vpc += 56;
                break;
            case 4043:  //frequency 1 ReturnStatement_24
                return (string)data[code[vpc + (-8)]];
                vpc += 56;
            case 7925:  //frequency 1 ExpressionStatement_6
                data[code[vpc + (1)]] = (string[])(new string[(int)data[code[vpc + (-8)]]]);
                vpc += 59;
                break;
            case 2516:  //frequency 1 ExpressionStatement_18
                ((string[])data[code[vpc + (20)]])[(int)data[code[vpc + (11)]]] = (string)data[code[vpc + (-2)]];
                vpc += 67;
                break;
            case 9729:  //frequency 1 ExpressionStatement_3
                data[code[vpc + (-4)]] = car.GetEngine().GetPiston((int)data[code[vpc + (4)]] - (int)data[code[vpc + (-3)]]).ToString();
                vpc += 65;
                break;
            case 9232:  //frequency 1 ExpressionStatement_12
                data[code[vpc + (21)]] = (string)data[code[vpc + (8)]] + (string)data[code[vpc + (1)]] + (string)data[code[vpc + (28)]];
                vpc += 55;
                break;
            case 8607:  //frequency 1 ExpressionStatement_23
                data[code[vpc + (10)]] = (string)data[code[vpc + (11)]] + (string)data[code[vpc + (12)]] + (int)data[code[vpc + (28)]];
                vpc += 54;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_TraceLoopTests_2145_2_op4_in5(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 4256:  //frequency 1 ExpressionStatement_11
                data[code[vpc + (26)]] = (string)data[code[vpc + (10)]] + (string)data[code[vpc + (20)]] + (string)data[code[vpc + (-7)]];
                vpc += 57;
                break;
            case 8019:  //frequency 1 ExpressionStatement_14
                data[code[vpc + (10)]] = (string)data[code[vpc + (-3)]] + (string)data[code[vpc + (-20)]] + (double)data[code[vpc + (1)]] + (string)data[code[vpc + (3)]];
                vpc += 59;
                break;
            case 8243:  //frequency 1 ExpressionStatement_5
                data[code[vpc + (-5)]] = (string[])(new string[(int)data[code[vpc + (11)]]]);
                vpc += 68;
                break;
            case 7576:  //frequency 1 ExpressionStatement_18
                data[code[vpc + (15)]] = (int)data[code[vpc + (3)]] + (int)data[code[vpc + (23)]];
                vpc += 69;
                break;
            default:  //frequency 0 
                break;
            case 1733:  //frequency 1 ExpressionStatement_15
                data[code[vpc + (29)]] = ((string)data[code[vpc + (-19)]]).Length;
                vpc += 59;
                break;
            case 5692:  //frequency 1 ExpressionStatement_3
                data[code[vpc + (21)]] = (string)data[code[vpc + (22)]] + ((ConsoleCalculator.Piston)data[code[vpc + (-14)]]).ToString();
                vpc += 70;
                break;
            case 1317:  //frequency 1 ExpressionStatement_10
                data[code[vpc + (13)]] = (string)data[code[vpc + (-2)]] + (string)data[code[vpc + (-5)]];
                vpc += 55;
                break;
            case 9041:  //frequency 2 ExpressionStatement_4
                data[code[vpc + (20)]] = data[code[vpc + (5)]];
                vpc += 53;
                break;
            case 5734:  //frequency 1 ExpressionStatement_0
                data[code[vpc + (-13)]] = (string)data[code[vpc + (9)]] + (int)data[code[vpc + (13)]] + (int)data[code[vpc + (-9)]] + (string)data[code[vpc + (5)]];
                vpc += 71;
                break;
            case 5821:  //frequency 1 ExpressionStatement_22
                data[code[vpc + (-6)]] = (string)data[code[vpc + (12)]] + (string)data[code[vpc + (21)]] + (int)data[code[vpc + (13)]];
                vpc += 62;
                break;
            case 9444:  //frequency 1 ExpressionStatement_16
                data[code[vpc + (7)]] = (string)data[code[vpc + (-14)]] + (int)data[code[vpc + (22)]];
                vpc += 58;
                break;
            case 3168:  //frequency 1 ExpressionStatement_20
                vpc += (int)data[code[vpc + (-3)]];
                vpc += 56;
                break;
            case 6978:  //frequency 1 ExpressionStatement_1
                data[code[vpc + (28)]] = car.GetEngine().GetPistons().Count;
                vpc += 67;
                break;
            case 2437:  //frequency 1 WhileStatementSyntax_8
                data[code[vpc + (26)]] = (bool)data[code[vpc + (-17)]] ? (int)data[code[vpc + (2)]] : (int)data[code[vpc + (-4)]];
                vpc += (int)data[code[vpc + (26)]];
                break;
            case 1116:  //frequency 1 ExpressionStatement_2
                data[code[vpc + (25)]] = (ConsoleCalculator.Piston)(car.GetEngine().GetPiston((int)data[code[vpc + (-8)]] - (int)data[code[vpc + (-3)]]));
                vpc += 59;
                break;
            case 6137:  //frequency 1 ReturnStatement_23
                return (string)data[code[vpc + (24)]];
                vpc += 67;
            case 9680:  //frequency 1 ExpressionStatement_21
                data[code[vpc + (27)]] = ((string[])data[code[vpc + (16)]]).Length;
                vpc += 56;
                break;
            case 9664:  //frequency 1 ExpressionStatement_12
                data[code[vpc + (28)]] = (System.Collections.Generic.List<ConsoleCalculator.Piston>)(car.GetEngine().GetPistons());
                vpc += 63;
                break;
            case 5180:  //frequency 1 ExpressionStatement_17
                ((string[])data[code[vpc + (2)]])[(int)data[code[vpc + (-7)]]] = (string)data[code[vpc + (17)]];
                vpc += 54;
                break;
            case 9597:  //frequency 1 ExpressionStatement_13
                data[code[vpc + (-12)]] = ((System.Collections.Generic.List<ConsoleCalculator.Piston>)data[code[vpc + (24)]]).First().GetSize();
                vpc += 66;
                break;
            case 7138:  //frequency 1 ExpressionStatement_9
                data[code[vpc + (3)]] = (string)data[code[vpc + (14)]] + (string)data[code[vpc + (10)]] + (int)data[code[vpc + (21)]] + (string)data[code[vpc + (8)]];
                vpc += 68;
                break;
            case 8931:  //frequency 2 ExpressionStatement_7
                data[code[vpc + (2)]] = (int)data[code[vpc + (25)]] < ReturnArg_Array((int)data[code[vpc + (-17)]]);
                vpc += 56;
                break;
        }
    }

    return null;
}

  
        



    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtCode/CodeBasicTests.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator.VirtCode
{
    class CodeBasicTests
    {
        public static void RunBasicTests()
        {
            CodeBasicTests cbt = new CodeBasicTests();

//                        cbt.InvocationSplit_Check();
            //            cbt.PreOperation_Check();
            //            cbt.PostOperation_Check();
            //            cbt.LocalVariables_Check();
            //
//                        cbt.OperationOrder_Check();
            //
            //            cbt.FactorialIterative_Check(0);
            //            cbt.FactorialIterative_Check(1);
            //            cbt.FactorialIterative_Check(2);
            //            cbt.FactorialIterative_Check(5);
            //
            //            cbt.FactorialRecursive_Check(0);
            //            cbt.FactorialRecursive_Check(1);
            //            cbt.FactorialRecursive_Check(2);
            //            cbt.FactorialRecursive_Check(5);
        }

        #region INVOCATION_SPLIT

//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string InvocationSplit_0(Car c)
        {
            Car car = c;

            string resultVar = "";
            //method calls
            var e1 = car.GetEngine();
            e1.GetPistons();
            resultVar += e1.ToString();
            var p1 = car.GetEngine().GetPistons().First().GetSize();
            //            Console.WriteLine(car);
            resultVar += p1;
            //            car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1);
            resultVar += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();


            //properties call
            var e2 = car.Engine;
            resultVar += e2;
            var typeS = Car.TYPE;
            resultVar += typeS;

            var et = String.Empty.Count();
            resultVar += et;

            var ts = car.GetEngine().TurbineStatus;
            resultVar += ts;
            var idSize = car.Engine.SerialNumber.Length;
            resultVar += idSize;

            //            //static call
            string counter = Car.GetCounter().ToString();
            resultVar += counter;
            bool isCarType = Car.TYPE.Equals("CAR");
            resultVar += isCarType;

            return resultVar;
        }

        private string InvocationSplit_1(Car c)
        {
            Car car = c;

            string resultVar = "";
            //method calls
            var e1 = car.GetEngine();
            e1.GetPistons();
            resultVar += e1.ToString();
            var p1 = car.GetEngine().GetPistons().First().GetSize();
            //            Console.WriteLine(car);
            resultVar += p1;
            //            car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1);
            resultVar += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();


            //properties call
            var e2 = car.Engine;
            resultVar += e2;
            var typeS = Car.TYPE;
            resultVar += typeS;

            var et = String.Empty.Count();
            resultVar += et;

            var ts = car.GetEngine().TurbineStatus;
            resultVar += ts;
            var idSize = car.Engine.SerialNumber.Length;
            resultVar += idSize;

            //            //static call
            string counter = Car.GetCounter().ToString();
            resultVar += counter;
            bool isCarType = Car.TYPE.Equals("CAR");
            resultVar += isCarType;

            return resultVar;
        }

        private void InvocationSplit_Check()
        {
            string testName = "Code#InvocationSplit_";
            Program.Start_Check(testName);
            bool condition = true;
            Car c = new Car("invocation-check-car", 4);
            string virt = InvocationSplit_0(c);
            string oracle = InvocationSplit_1(c);
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }


        [Obfuscation(Exclude = false, Feature = "ctrl flow")]
        private string ConfuserEx_InvocationSplit_0(Car c)
        {
            Car car = c;

            string resultVar = "";
            //method calls
            var e1 = car.GetEngine();
            e1.GetPistons();
            resultVar += e1.ToString();
            var p1 = car.GetEngine().GetPistons().First().GetSize();
            //            Console.WriteLine(car);
            resultVar += p1;
            //            car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1);
            resultVar += car.GetEngine().GetPiston(car.GetEngine().GetPistons().Count - 1).ToString();


            //properties call
            var e2 = car.Engine;
            resultVar += e2;
            var typeS = Car.TYPE;
            resultVar += typeS;

            var et = String.Empty.Count();
            resultVar += et;

            var ts = car.GetEngine().TurbineStatus;
            resultVar += ts;
            var idSize = car.Engine.SerialNumber.Length;
            resultVar += idSize;

            //            //static call
            string counter = Car.GetCounter().ToString();
            resultVar += counter;
            bool isCarType = Car.TYPE.Equals("CAR");
            resultVar += isCarType;

            return resultVar;
        }



        #endregion


        #region OPERATION_ORDER

        //        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        string MaxOperator_0()
        {
            string result = "";

            result = "1" + "2" + "3" + "4" + "5" + "6" + "7" + "8" ;
            var mul = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8;

            //            result = "1" + "2" + "3" + "4";// + "5" + "6" + "7" ;
            //            result = "1" + "2" + "3" + "4" + "5";// + "6" + "7" ;
            return result;
        }

//        [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
string OperationOrder_2()
{
    //Virtualization variables
    int[] code = new int[4682];
    object[] data = new object[4818];
    int vpc = 0;

    //Data init
    data[1603]=20; //20 constant
    data[22]=10; //10 constant
    data[2467]=15; //15 constant
    data[1717]=5; //5 constant
    data[2816]=2; //2 constant
    data[1178]=3 ; //3 constant
    data[3518]=(float)0F; //0F constant
    data[662]=(double)1.0; //1.0 constant
    data[287]=(double)0.0; //0.0 constant
    data[2715]=""; //"" constant
    data[2604]=1; //1 constant
    data[2770]=7 ; //7 constant
    data[2682]=215; //a 
    data[3831]=447; //b 
    data[2914]=771; //c 
    data[2469]=-586; //d 
    data[2933]=-222; //e 
    data[620]=(float)0.5379585F; //f 
    data[2437]=(double)0.42513591583126; //sum 
    data[3281]=1761066966; //result 
    data[2386]=471; //parTemp_0 
    data[1428]=393; //parTemp_1 
    data[2911]=-755; //mulTemp_0 
    data[3674]=-221; //addTemp_0 
    data[2929]=926; //addTemp_1 
    data[1237]=-7; //mulTemp_1 
    data[2971]=-660; //mulTemp_2 
    data[2188]=-349; //mulTemp_3 
    data[2133]=-932; //mulTemp_4 
    data[1297]=835; //addTemp_2 
    data[1732]=-721; //addTemp_3 
    data[2555]=926; //addTemp_4 
    data[688]=205; //parTemp_2 
    data[810]=1; //mulTemp_5 
    data[2981]=-737; //mulTemp_6 
    data[2095]=195; //parTemp_3 
    data[58]=-604; //parTemp_4 
    data[2493]=133; //mulTemp_7 
    data[1974]=258; //parTemp_5 
    data[3701]=207; //mulTemp_8 
    data[1154]=772; //addTemp_5 

    //Code init
    code[0]=3711; //ExpressionStatement_0
    code[1]=2682; //a
    code[2]=1603; //20
    code[3]=3711; //ExpressionStatement_0
    code[4]=3831; //b
    code[5]=22; //10
    code[6]=3711; //ExpressionStatement_0
    code[7]=2914; //c
    code[8]=2467; //15
    code[9]=3711; //ExpressionStatement_0
    code[10]=2469; //d
    code[11]=1717; //5
    code[12]=3711; //ExpressionStatement_0
    code[13]=2933; //e
    code[14]=2816; //2
    code[15]=1434; //ExpressionStatement_1
    code[16]=620; //f
    code[17]=1178; //3
    code[18]=3518; //0F
    code[19]=9095; //ExpressionStatement_2
    code[20]=2437; //sum
    code[21]=662; //1.0
    code[22]=287; //0.0
    code[23]=3711; //ExpressionStatement_0
    code[24]=3281; //result
    code[25]=2715; //""
    code[26]=1532; //ExpressionStatement_3
    code[27]=2437; //sum
    code[28]=2437; //sum
    code[29]=2604; //1
    code[30]=6505; //ExpressionStatement_4
    code[31]=3281; //result
    code[32]=3281; //result
    code[33]=2437; //sum
    code[34]=7835; //ExpressionStatement_5
    code[35]=2386; //parTemp_0
    code[36]=2682; //a
    code[37]=3831; //b
    code[38]=7835; //ExpressionStatement_5
    code[39]=1428; //parTemp_1
    code[40]=2914; //c
    code[41]=2469; //d
    code[42]=4753; //ExpressionStatement_6
    code[43]=2911; //mulTemp_0
    code[44]=2386; //parTemp_0
    code[45]=1428; //parTemp_1
    code[46]=1392; //ExpressionStatement_7
    code[47]=3674; //addTemp_0
    code[48]=2911; //mulTemp_0
    code[49]=2682; //a
    code[50]=3498; //ExpressionStatement_7
    code[51]=2929; //addTemp_1
    code[52]=3674; //addTemp_0
    code[53]=2469; //d
    code[54]=1532; //ExpressionStatement_3
    code[55]=2437; //sum
    code[56]=2437; //sum
    code[57]=2929; //addTemp_1
    code[58]=6505; //ExpressionStatement_4
    code[59]=3281; //result
    code[60]=3281; //result
    code[61]=2437; //sum
    code[62]=4753; //ExpressionStatement_6
    code[63]=1237; //mulTemp_1
    code[64]=2682; //a
    code[65]=3831; //b
    code[66]=4580; //ExpressionStatement_8
    code[67]=2971; //mulTemp_2
    code[68]=2914; //c
    code[69]=2469; //d
    code[70]=4753; //ExpressionStatement_6
    code[71]=2188; //mulTemp_3
    code[72]=2971; //mulTemp_2
    code[73]=2933; //e
    code[74]=9553; //ExpressionStatement_9
    code[75]=2133; //mulTemp_4
    code[76]=2770; //7
    code[77]=1178; //3
    code[78]=7281; //ExpressionStatement_7
    code[79]=1297; //addTemp_2
    code[80]=1237; //mulTemp_1
    code[81]=2188; //mulTemp_3
    code[82]=7271; //ExpressionStatement_7
    code[83]=1732; //addTemp_3
    code[84]=1297; //addTemp_2
    code[85]=2816; //2
    code[86]=4552; //ExpressionStatement_7
    code[87]=2555; //addTemp_4
    code[88]=1732; //addTemp_3
    code[89]=2133; //mulTemp_4
    code[90]=1532; //ExpressionStatement_3
    code[91]=2437; //sum
    code[92]=2437; //sum
    code[93]=2555; //addTemp_4
    code[94]=6505; //ExpressionStatement_4
    code[95]=3281; //result
    code[96]=3281; //result
    code[97]=2437; //sum
    code[98]=5964; //ExpressionStatement_7
    code[99]=688; //parTemp_2
    code[100]=2682; //a
    code[101]=3831; //b
    code[102]=4753; //ExpressionStatement_6
    code[103]=810; //mulTemp_5
    code[104]=688; //parTemp_2
    code[105]=2914; //c
    code[106]=4580; //ExpressionStatement_8
    code[107]=2981; //mulTemp_6
    code[108]=810; //mulTemp_5
    code[109]=2469; //d
    code[110]=3992; //ExpressionStatement_7
    code[111]=2933; //e
    code[112]=2933; //e
    code[113]=2981; //mulTemp_6
    code[114]=9556; //ExpressionStatement_10
    code[115]=3281; //result
    code[116]=3281; //result
    code[117]=2933; //e
    code[118]=6690; //ExpressionStatement_7
    code[119]=2095; //parTemp_3
    code[120]=2682; //a
    code[121]=3831; //b
    code[122]=4753; //ExpressionStatement_6
    code[123]=58; //parTemp_4
    code[124]=2095; //parTemp_3
    code[125]=2914; //c
    code[126]=4580; //ExpressionStatement_8
    code[127]=2493; //mulTemp_7
    code[128]=58; //parTemp_4
    code[129]=2469; //d
    code[130]=7726; //ExpressionStatement_7
    code[131]=2933; //e
    code[132]=2933; //e
    code[133]=2493; //mulTemp_7
    code[134]=9556; //ExpressionStatement_10
    code[135]=3281; //result
    code[136]=3281; //result
    code[137]=2933; //e
    code[138]=4753; //ExpressionStatement_6
    code[139]=1974; //parTemp_5
    code[140]=3831; //b
    code[141]=2914; //c
    code[142]=4580; //ExpressionStatement_8
    code[143]=3701; //mulTemp_8
    code[144]=1974; //parTemp_5
    code[145]=2469; //d
    code[146]=3211; //ExpressionStatement_7
    code[147]=1154; //addTemp_5
    code[148]=2682; //a
    code[149]=3701; //mulTemp_8
    code[150]=1110; //ExpressionStatement_7
    code[151]=2933; //e
    code[152]=2933; //e
    code[153]=1154; //addTemp_5
    code[154]=9556; //ExpressionStatement_10
    code[155]=3281; //result
    code[156]=3281; //result
    code[157]=2933; //e
    code[158]=7530; //ReturnStatement_11
    code[159]=3281; //result


    Func<object[], int[], int, object> func = (data1, code1, vpc1) => { 

                while (true)
                {
    	            switch(code1[vpc1++])
    	            {
    		            case 1532: //frequency 3 ExpressionStatement_3
                            data1[code1[vpc1++]] = (double)data1[code1[vpc1++]] + (int)data1[code1[vpc1++]];
                            
    			            break;
    		            case 7530: //frequency 1 ReturnStatement_11
    			            return (string)data1[code1[vpc1++]];
    		            case 3711: //frequency 6 ExpressionStatement_0
    			            data1[code1[vpc1++]] = data1[code1[vpc1++]];
    			            break;
    		            case 1434: //frequency 1 ExpressionStatement_1
    			            data1[code1[vpc1++]] = (int)data1[code1[vpc1++]] + (float)data1[code1[vpc1++]];
    			            break;
    		            case 4753: //frequency 6 ExpressionStatement_6
    			            data1[code1[vpc1++]] = (int)data1[code1[vpc1++]] * (int)data1[code1[vpc1++]];
    			            break;
    		            case 9553: //frequency 1 ExpressionStatement_9
    			            data1[code1[vpc1++]] = (int)data1[code1[vpc1++]] % (int)data1[code1[vpc1++]];
    			            break;
    		            case 4580: //frequency 4 ExpressionStatement_8
    			            data1[code1[vpc1++]] = (int)data1[code1[vpc1++]] / (int)data1[code1[vpc1++]];
    			            break;
    		            default: //frequency 11 ExpressionStatement_7
    			            data1[code1[vpc1++]] = (int)data1[code1[vpc1++]] + (int)data1[code1[vpc1++]];
    			            break;
    		            case 6505: //frequency 3 ExpressionStatement_4
    			            data1[code1[vpc1++]] = (string)data1[code1[vpc1++]] + (double)data1[code1[vpc1++]];
    			            break;
    		            case 9095: //frequency 1 ExpressionStatement_2
    			            data1[code1[vpc1++]] = (double)data1[code1[vpc1++]] + (double)data1[code1[vpc1++]];
    			            break;
    		            case 7835: //frequency 2 ExpressionStatement_5
    			            data1[code1[vpc1++]] = (int)data1[code1[vpc1++]] - (int)data1[code1[vpc1++]];
    			            break;
    		            case 9556: //frequency 3 ExpressionStatement_10
    			            data1[code1[vpc1++]] = (string)data1[code1[vpc1++]] + (int)data1[code1[vpc1++]];
    			            break;
    	            }
                }

        return null;
    };

            Expression<Predicate<int>> expression = Expression.Lambda<Predicate<int>>(                            
                             Expression.LessThan(
                                      Expression.Parameter(typeof(int), "n"),
                                      Expression.Constant(10)
                            ),
                           Expression.Parameter(typeof(int), "n")
               );
            Predicate<int> predicate = expression.Compile();

            BinaryFormatter f = new BinaryFormatter();
            MemoryStream m = new MemoryStream();
            f.Serialize(m, func);
            

            Func<object[], int[], int, object> fun2  = (Func < object[], int[], int, object>) f.Deserialize(m);

            return (string) fun2(data, code, vpc);
        }


//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        string OperationOrder_0()
        {
            int a = 20;
            int b = 10;
            int c = 15;
            int d = 5;
            int e = 2;
            float f = 3;
            double sum = 1.0;
            string result = "";

            sum += 1;
            result += sum;
            sum += (a - b) * (c - d) + a + d;
            result += sum;
            sum += a * b + c / d * e + 2 + 7 % 3;
            result += sum;
            e += (a + b) * c / d;
            result += e;
            e += ((a + b) * c) / d;
            result += e;
            e += a + (b * c) / d;
            result += e;

            return result;
        }

        string OperationOrder_1()
        {
            int a = 20;
            int b = 10;
            int c = 15;
            int d = 5;
            int e = 2;
            float f = 3;
            double sum = 1.0;
            string result = "";

            sum += 1;
            result += sum;
            sum += (a - b) * (c - d) + a + d;
            result += sum;
            sum += a * b + c / d * e + 2 + 7 % 3;
            result += sum;
            e += (a + b) * c / d;
            result += e;
            e += ((a + b) * c) / d;
            result += e;
            e += a + (b * c) / d;
            result += e;

            return result;
        }
       
        private void OperationOrder_Check()
        {
            string testName = "Code#OperationOrder_Check";
            bool condition = true;
            Program.Start_Check(testName);
            
            string virt = OperationOrder_0();            
            string oracle = OperationOrder_1();
            Console.WriteLine("virt: " + virt + " # " + oracle + " check");
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        #endregion


        #region PRE_OPERARTIONS
//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        string PreOperation_0()
        {
            string result = "";
            int a = 0;
            int x = 100;
            int b = 0;
            int c = 0;
            
            ++a;
            --x;
            result += a;
            result += x;

            b = ++a;
            result += b;
            result += a;
            b = --x;
            result += b;
            result += x;

            c = ++a + ++a;
            result += c;
            result += a;
            c = --x + --x;
            result += c;
            result += x;

            return result;
        }

        string PreOperation_1()
        {
            string result = "";
            int a = 0;
            int x = 100;
            int b = 0;
            int c = 0;

            ++a;
            --x;
            result += a;
            result += x;

            b = ++a;
            result += b;
            result += a;
            b = --x;
            result += b;
            result += x;

            c = ++a + ++a;
            result += c;
            result += a;
            c = --x + --x;
            result += c;
            result += x;

            return result;
        }

        private void PreOperation_Check()
        {
            string testName = "Code#PreOperation_Check";
            bool condition = true;
            Program.Start_Check(testName);
            string virt = PreOperation_0();
            string oracle = PreOperation_1();
            Console.WriteLine("virt: {0} # {1} oracle", virt, oracle);
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        #endregion

        #region POST_OPERARTIONS
//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        string PostOperation_0()
        {
            string result = "";
            int a = 0;
            int x = 100;
            int b = 0;
            int c = 0;

            int[] ar = new int[] { 0, 1, 2, 3, 4, 5, 6 };

            int a1 = 1;
            int a2 = 2;
            int a3 = 3;

            ar[a1++] = ar[a2++] + ar[a3++];
            result += a1 + a2 + a3;

            a++;
            x--;
            result += a;
            result += x;

            b = a++;
            result += b;
            b = x--;
            result += b;

            c = a++ + a++;
            result += c;
            result += a;
            c = x-- + x--;
            result += c;
            result += x;

            return result;
        }

        string PostOperation_1()
        {
            string result = "";
            int a = 0;
            int x = 100;
            int b = 0;
            int c = 0;

            int[] ar = new int[] { 0, 1, 2, 3, 4, 5, 6 };

            int a1 = 1;
            int a2 = 2;
            int a3 = 3;

            ar[a1++] = ar[a2++] + ar[a3++];
            result += a1 + a2 + a3;

            a++;
            x--;
            result += a;
            result += x;

            b = a++;
            result += b;
            b = x--;
            result += b;

            c = a++ + a++;
            result += c;
            result += a;
            c = x-- + x--;
            result += c;
            result += x;

            return result;
        }

        private void PostOperation_Check()
        {
            string testName = "Code#PostOperation_Check";
            bool condition = true;
            Program.Start_Check(testName);
            string virt = PostOperation_0();
            string oracle = PostOperation_1();
            Console.WriteLine("virt: {0} # {1} oracle", virt, oracle);
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        #endregion


        #region LOCAL_VAR



        //        [Obfuscation(Exclude = false, Feature = "virtualization-class")]
        private string LocalVariables_a(string a, string b)
        {
            string local1 = a;
            string local2 = b;
            string local3 = "1";
            string local4 = "c";
            string sum = "";
            string v;
            int i1 = 11;
            int i2 = 13;
            sum = local1;
            local2 = sum;
            local3 = local2 + local1;
            local2 = local4 + local1;
            local3 = local3 + local2;
            local1 = "s1" + i1 + "s2" + i2;
            sum = "" + a + local3;
            int cc = 3 + 4 + 5;
            sum += sum + local1 + local2; // + b + a;
            Console.WriteLine("LocalVariables_b- " + sum);
            Console.WriteLine("LocalVariables_b- " + sum + 3);
            return sum;
        }


        private string LocalVariables_b(string a, string b)
        {
            string local1 = a;
            string local2 = b;
            string local3 = "1";
            string local4 = "c";
            string sum = "";
            string v;
            int i1 = 11;
            int i2 = 13;
            sum = local1;
            local2 = sum;
            local3 = local2 + local1;
            local2 = local4 + local1;
            local3 = local3 + local2;
            local1 = "s1" + i1 + "s2" + i2;
            sum = "" + a + local3;
            int cc = 3 + 4 + 5;
            sum += sum + local1 + local2; // + b + a;
            Console.WriteLine("LocalVariables_b- " + sum);
            Console.WriteLine("LocalVariables_b- " + sum + 3);
            return sum;
        }

        private void LocalVariables_Check()
        {
            string testName = "Code#LocalVariables_Check";
            bool condition = true;
            Program.Start_Check(testName);
            string a = "a";
            string b = "b";
            string virt = LocalVariables_a(a, b);
            string oracle = LocalVariables_b(a, b);
            bool debug = true;
            //            string r1 = LocalVariables_data(a, b);
            //            string r2 = LocalVariables_m(a, b);
            //            debug = r1.Equals(r2);
            //            LocalVariables_virtual(a, b);
            condition = virt.Equals(oracle) && debug;
            Program.End_Check(testName, condition);
        }

        #endregion


        #region FACTORIAL_ITERATIVE
//        [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
public long FactorialIterative_0(int num)
{
    long result = 1;
    if (num == 0)
    {
        return 1;
    }
    else
    {
        for (int i = 2; i <= num; i++)
        {
            result *= i;
        }
        return result;
    }
}

//                [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
public long FactorialIterative_junk(int num)
{
    //Virtualization variables
    int[] code = new int[100216];
    object[] data = new object[4490];
    int vpc = 30;

    //Data init
    data[2830]=num; //num 
    data[926]=1 ; //1 constant
    data[3104]=(long)0L; //0L constant
    data[2356]=0; //0 constant
    data[3189]=(long)1; //1 constant
    data[2449]=2; //2 constant
    data[2593]=(long)406L; //result 
    data[2788]=false; //var_ifCondition_0 
    data[3826]=-585; //var_forIndex_0 
    data[2780]=false; //var_whileCondition_0 
    data[406]=-248; //fake-406 
    data[2285]=696; //fake-2285 
    data[1510]=544; //fake-1510 
    data[2979]=360; //fake-2979 
    data[304]=374; //fake-304 
    data[1816]=-671; //fake-1816 
    data[3639]=-33; //fake-3639 
    data[1043]=-743; //fake-1043 
    data[770]=591; //fake-770 
    data[3500]=794; //fake-3500 
    data[2553]=-159; //jmpDestinationName_2553 constant
    data[1437]=68; //if_GoTo_True_1437 constant
    data[3590]=184; //if_GoTo_False_3590 constant
    data[1567]=504; //if_FalseBlockSize_Skip_1567 constant
    data[3753]=-312; //fake-3753 
    data[3527]=-619; //fake-3527 
    data[2202]=711; //fake-2202 
    data[2254]=541; //fake-2254 
    data[116]=-301; //fake-116 
    data[2171]=-448; //fake-2171 
    data[974]=615; //fake-974 
    data[3423]=-945; //fake-3423 
    data[863]=-12; //fake-863 
    data[3643]=-8; //fake-3643 
    data[2552]=862; //fake-2552 
    data[270]=-983; //fake-270 
    data[2181]=-360; //jmpWhileDestinationName_2181 constant
    data[3604]=68; //while_GoTo_True_3604 constant
    data[3138]=310; //while_GoTo_False_3138 constant
    data[2413]=-310; //while_FalseBlockSkip_2413 constant
    data[3585]=-379; //fake-3585 
    data[2526]=558; //fake-2526 
    data[3247]=964; //fake-3247 
    data[2786]=994; //fake-2786 
    data[2687]=193; //fake-2687 
    data[3224]=86; //fake-3224 
    data[1678]=-429; //fake-1678 
    data[3578]=-83; //fake-3578 
    data[459]=-349; //fake-459 
    data[83]=-824; //fake-83 
    data[2695]=133; //fake-2695 
    data[1052]=161; //fake-1052 
    data[2634]=-492; //fake-2634 
    data[3227]=356; //fake-3227 
    data[2700]=929; //fake-2700 
    data[2828]=-677; //fake-2828 
    data[2886]=454; //fake-2886 
    data[548]=-93; //fake-548 

    //Code init

    code[30]=5457; //ExpressionStatement_0 # ExpressionStatement_0
    code[16]=2593; //result
    code[31]=926; //1
    code[50]=3104; //0L
    code[22]=3554; //fake-ExpressionStatement_0_3554_-8
    code[42]=1526; //fake-ExpressionStatement_0_1526_12
    code[17]=123; //fake-ExpressionStatement_0_123_-13
    code[35]=2724; //fake-ExpressionStatement_0_2724_5
    code[57]=1817; //fake-ExpressionStatement_0_1817_27

    code[97]=5941; //ExpressionStatement_1 # ExpressionStatement_1
    code[124]=2788; //var_ifCondition_0
    code[112]=2830; //num
    code[119]=2356; //0
    code[102]=3881; //fake-ExpressionStatement_1_3881_5
    code[100]=853; //fake-ExpressionStatement_1_853_3
    code[107]=2475; //fake-ExpressionStatement_1_2475_10
    code[88]=3723; //fake-ExpressionStatement_1_3723_-9
    code[105]=2179; //fake-ExpressionStatement_1_2179_8

    code[169]=3110; //IfStatementSyntax_2 # IfStatementSyntax_2
    code[163]=2553; //jmpDestinationName_2553
    code[179]=2788; //var_ifCondition_0
    code[158]=1437; //if_GoTo_True_1437
    code[167]=3590; //if_GoTo_False_3590
    code[185]=95; //fake-fake-ifVirtualOperation_95_16
    code[149]=526; //fake-fake-ifVirtualOperation_526_-20

    code[237]=2162; //ReturnStatement_3 # ReturnStatement_3
    code[251]=3189; //1
    code[259]=3861; //fake-ReturnStatement_3_3861_22
    code[231]=3638; //fake-ReturnStatement_3_3638_-6
    code[226]=1126; //fake-ReturnStatement_3_1126_-11

    code[295]=9456; //ExpressionStatement_4 # ExpressionStatement_4
    code[293]=1567; //if_FalseBlockSize_Skip_1567
    code[323]=521; //fake-ExpressionStatement_4_521_28
    code[317]=3014; //fake-ExpressionStatement_4_3014_22

    code[353]=3044; //ExpressionStatement_5 # ExpressionStatement_5
    code[363]=3826; //var_forIndex_0
    code[366]=2449; //2
    code[374]=521; //fake-ExpressionStatement_5_521_21
    code[364]=366; //fake-ExpressionStatement_5_366_11
    code[359]=12; //fake-ExpressionStatement_5_12_6

    code[420]=2464; //ExpressionStatement_6 # ExpressionStatement_6
    code[421]=2780; //var_whileCondition_0
    code[415]=3826; //var_forIndex_0
    code[405]=2830; //num
    code[439]=3637; //fake-ExpressionStatement_6_3637_19
    code[417]=643; //fake-ExpressionStatement_6_643_-3

    code[489]=7435; //IfStatementSyntax_2 # WhileStatementSyntax_7
    code[483]=2181; //jmpWhileDestinationName_2181
    code[499]=2780; //var_whileCondition_0
    code[478]=3604; //while_GoTo_True_3604
    code[487]=3138; //while_GoTo_False_3138
    code[476]=2057; //fake-fake-whileVirtualOperation_2057_-13
    code[494]=3210; //fake-fake-whileVirtualOperation_3210_5

    code[557]=8145; //ExpressionStatement_8 # ExpressionStatement_8
    code[537]=2593; //result
    code[558]=2593; //result
    code[581]=3826; //var_forIndex_0
    code[556]=3223; //fake-ExpressionStatement_8_3223_-1
    code[546]=82; //fake-ExpressionStatement_8_82_-11
    code[545]=3874; //fake-ExpressionStatement_8_3874_-12
    code[577]=433; //fake-ExpressionStatement_8_433_20
    code[579]=1307; //fake-ExpressionStatement_8_1307_22

    code[619]=3322; //ExpressionStatement_9 # ExpressionStatement_9
    code[603]=3826; //var_forIndex_0
    code[614]=3826; //var_forIndex_0
    code[644]=926; //1
    code[604]=3683; //fake-ExpressionStatement_9_3683_-15
    code[599]=1569; //fake-ExpressionStatement_9_1569_-20
    code[624]=576; //fake-ExpressionStatement_9_576_5

    code[672]=2464; //ExpressionStatement_6 # ExpressionStatement_10
    code[673]=2780; //var_whileCondition_0
    code[667]=3826; //var_forIndex_0
    code[657]=2830; //num
    code[687]=3857; //fake-ExpressionStatement_6_3857_15

    code[741]=9456; //ExpressionStatement_4 # ExpressionStatement_11
    code[739]=2413; //while_FalseBlockSkip_2413
    code[768]=357; //fake-ExpressionStatement_4_357_27
    code[749]=388; //fake-ExpressionStatement_4_388_8
    code[740]=3001; //fake-ExpressionStatement_4_3001_-1
    code[750]=1230; //fake-ExpressionStatement_4_1230_9

    code[799]=2162; //ReturnStatement_3 # ReturnStatement_12
    code[813]=2593; //result
    code[809]=1045; //fake-ReturnStatement_3_1045_10
    code[825]=573; //fake-ReturnStatement_3_573_26
    code[821]=3864; //fake-ReturnStatement_3_3864_22

    while(true)
    {
    	switch(code[vpc])
    	{
    		case 5941: //frequency 1 ExpressionStatement_1
    			data[code[vpc+(27)]]= (int)data[code[vpc+(15)]]== (int)data[code[vpc+(22)]];
    			vpc+=72;
    			break;
    		case 3322: //frequency 1 ExpressionStatement_9
    			data[code[vpc+(-16)]]= (int)data[code[vpc+(-5)]]+ (int)data[code[vpc+(25)]];
    			vpc+=53;
    			break;
    		case 2464: //frequency 2 ExpressionStatement_6
    			data[code[vpc+(1)]]= (int)data[code[vpc+(-5)]]<= (int)data[code[vpc+(-15)]];
    			vpc+=69;
    			break;
    		case 8145: //frequency 1 ExpressionStatement_8
    			data[code[vpc+(-20)]]= (long)data[code[vpc+(1)]]* (int)data[code[vpc+(24)]];
    			vpc+=62;
    			break;
    		case 9456: //frequency 2 ExpressionStatement_4
    			vpc += (int)data[code[vpc+(-2)]];
    			vpc+=58;
    			break;
    		case 3044: //frequency 1 ExpressionStatement_5
    			data[code[vpc+(10)]]= data[code[vpc+(13)]];
    			vpc+=67;
    			break;
    		case 2162: //frequency 2 ReturnStatement_3
    			return (long)data[code[vpc+(14)]];
    			vpc+=58;
    		default: //frequency 2 IfStatementSyntax_2
    			data[code[vpc+(-6)]]=(bool)data[code[vpc+(10)]]?(int)data[code[vpc+(-11)]]:(int)data[code[vpc+(-2)]];
    			vpc+=(int)data[code[vpc+(-6)]];
    			break;
    		case 5457: //frequency 1 ExpressionStatement_0
    			data[code[vpc+(-14)]]= (int)data[code[vpc+(1)]]+ (long)data[code[vpc+(20)]];
    			vpc+=67;
    			break;
    	}
    }

    return 0;
}

        //       [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
        public long FactorialIterative_method_1(int num)
{
    //Virtualization variables
    int[] code = new int[100306];
    object[] data = new object[4820];
    int vpc = 99;

    //Data init
    data[741]=num; //num 
    data[824]=1 ; //1 constant
    data[213]=(long)0L; //0L constant
    data[53]=0; //0 constant
    data[2830]=(long)1; //1 constant
    data[1193]=2; //2 constant
    data[2807]=(long)-91L; //result 
    data[1341]=false; //var_ifCondition_0 
    data[2033]=15; //var_forIndex_0 
    data[2084]=false; //var_whileCondition_0 
    data[1492]=708; //jmpDestinationName_1492 constant
    data[1520]=70; //if_GoTo_True_1520 constant
    data[296]=184; //if_GoTo_False_296 constant
    data[659]=512; //if_FalseBlockSize_Skip_659 constant
    data[410]=645; //jmpWhileDestinationName_410 constant
    data[3635]=70; //while_GoTo_True_3635 constant
    data[1131]=317; //while_GoTo_False_1131 constant
    data[2991]=-317; //while_FalseBlockSkip_2991 constant

    //Code init

    code[99]=9336; //ExpressionStatement_0 # ExpressionStatement_0
    code[96]=2807; //result
    code[90]=824; //1
    code[118]=213; //0L

    code[161]=5420; //ExpressionStatement_1 # ExpressionStatement_1
    code[174]=1341; //var_ifCondition_0
    code[184]=741; //num
    code[188]=53; //0

    code[221]=4823; //IfStatementSyntax_2 # IfStatementSyntax_2
    code[209]=1492; //jmpDestinationName_1492
    code[248]=1341; //var_ifCondition_0
    code[244]=1520; //if_GoTo_True_1520
    code[242]=296; //if_GoTo_False_296

    code[291]=2635; //ReturnStatement_3 # ReturnStatement_3
    code[303]=2830; //1

    code[353]=2429; //ExpressionStatement_4 # ExpressionStatement_4
    code[379]=659; //if_FalseBlockSize_Skip_659

    code[405]=1931; //ExpressionStatement_5 # ExpressionStatement_5
    code[398]=2033; //var_forIndex_0
    code[401]=1193; //2

    code[468]=3747; //ExpressionStatement_6 # ExpressionStatement_6
    code[486]=2084; //var_whileCondition_0
    code[449]=2033; //var_forIndex_0
    code[474]=741; //num

    code[538]=4823; //IfStatementSyntax_2 # WhileStatementSyntax_7
    code[526]=410; //jmpWhileDestinationName_410
    code[565]=2084; //var_whileCondition_0
    code[561]=3635; //while_GoTo_True_3635
    code[559]=1131; //while_GoTo_False_1131

    code[608]=2478; //ExpressionStatement_8 # ExpressionStatement_8
    code[622]=2807; //result
    code[609]=2807; //result
    code[634]=2033; //var_forIndex_0

    code[673]=1920; //ExpressionStatement_9 # ExpressionStatement_9
    code[662]=2033; //var_forIndex_0
    code[655]=2033; //var_forIndex_0
    code[692]=824; //1

    code[733]=3747; //ExpressionStatement_6 # ExpressionStatement_10
    code[751]=2084; //var_whileCondition_0
    code[714]=2033; //var_forIndex_0
    code[739]=741; //num

    code[803]=2429; //ExpressionStatement_4 # ExpressionStatement_11
    code[829]=2991; //while_FalseBlockSkip_2991

    code[855]=2635; //ReturnStatement_3 # ReturnStatement_12
    code[867]=2807; //result

    while(true)
    {
    	switch(code[vpc])
    	{
    		case 4823: //frequency 2 IfStatementSyntax_2
    			data[code[vpc+(-12)]]=(bool)data[code[vpc+(27)]]?(int)data[code[vpc+(23)]]:(int)data[code[vpc+(21)]];
    			vpc+=(int)data[code[vpc+(-12)]];
    			break;
    		case 1920: //frequency 1 ExpressionStatement_9
    			data[code[vpc+(-11)]]= (int)data[code[vpc+(-18)]]+ (int)data[code[vpc+(19)]];
    			vpc+=60;
    			break;
    		case 1931: //frequency 1 ExpressionStatement_5
    			data[code[vpc+(-7)]]= data[code[vpc+(-4)]];
    			vpc+=63;
    			break;
    		case 2429: //frequency 2 ExpressionStatement_4
    			vpc += (int)data[code[vpc+(26)]];
    			vpc+=52;
    			break;
    		default: //frequency 0 
    			break;
    		case 9336: //frequency 1 ExpressionStatement_0
    			data[code[vpc+(-3)]]= (int)data[code[vpc+(-9)]]+ (long)data[code[vpc+(19)]];
    			vpc+=62;
    			break;
    		case 2478: //frequency 1 ExpressionStatement_8
    			data[code[vpc+(14)]]= (long)data[code[vpc+(1)]]* (int)data[code[vpc+(26)]];
    			vpc+=65;
    			break;
    		case 3747: //frequency 2 ExpressionStatement_6
    			data[code[vpc+(18)]]= (int)data[code[vpc+(-19)]]<= (int)data[code[vpc+(6)]];
    			vpc+=70;
    			break;
    		case 5420: //frequency 1 ExpressionStatement_1
    			data[code[vpc+(13)]]= (int)data[code[vpc+(23)]]== (int)data[code[vpc+(27)]];
    			vpc+=60;
    			break;
    		case 2635: //frequency 2 ReturnStatement_3
    			return (long)data[code[vpc+(12)]];
    			vpc+=62;
    	}
    }

    return 0;
}

        //        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        public long FactorialIterative_refactored(int num)
{
    long result = 1 + 0L;
    bool var_ifCondition_0 = num == 0;
    if (var_ifCondition_0)
    {
        return 1;
    }
    else
    {
        int var_forIndex_0 = 2;
        bool var_whileCondition_0 = var_forIndex_0 <= num;
        while (var_whileCondition_0)
        {
            result = result * var_forIndex_0;
            var_forIndex_0 = var_forIndex_0 + 1;
            var_whileCondition_0 = var_forIndex_0 <= num;
        }

        return result;
    }
}

        public long FactorialIterative_1(int num)
        {
            long result = 12343L;

            if (num == 0)
            {
                return 1;
            }
            else
            {
                for (int i = 2; i <= num; i++)
                {
                    result *= i;
                }
                return result;
            }
        }

        private void FactorialIterative_Check(int arg)
        {
            string testName = "Code#FactorialIterative_Check_"+arg;
            bool condition = true;
            Program.Start_Check(testName);
            
            long virt = FactorialIterative_0(arg);
            long oracle = FactorialIterative_1(arg);
            Console.WriteLine(testName + " => " + virt);
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        #endregion

        #region FACTORIAL_RECURSIVE

//        [Obfuscation(Exclude = false, Feature = "virtualization-class")]
        public static long FactorialRecursive_0(int num)
        {
            int c = 0;
            
            if (num == 0)
            {
                return 1;
            }
           
            return num * FactorialRecursive_0(num - 1);
        }

        public long FactorialRecursive_1(int num)
        {
            if (num == 0)
            {
                return 1;
            }
            else
            {
                return num * FactorialRecursive_1(num - 1);
            }
        }


        private void FactorialRecursive_Check(int arg)
        {
            string testName = "Code#FactorialRecursive_Check_" + arg;
            bool condition = true;
            Program.Start_Check(testName);

            long virt = FactorialRecursive_0(arg);
            long oracle = FactorialRecursive_1(arg);
            Console.WriteLine(testName + " => " + virt);
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        #endregion


       


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtCode/CodeBranchTests.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading.Tasks;
using System.Xml.XPath;

namespace ConsoleCalculator.VirtCode
{
    enum Priority
    {
        Zero,
        Low,
        Medium,
        Important,
        Critical
    }

    ;
    enum PriorityInt
    {
        ZeroInt = 0,
        LowInt = 2,
        MediumInt = 4,
        ImportantInt = 6,
        CriticalInt = 8
    }

    internal class CodeBranchTests
    {
        //TODO: test branching - done
#region SIMPLE_IF

//        [Obfuscation(Exclude = false, Feature = "virtualization; method")]
        private int SimpleIfStatement_0()
        {
            int sum = 1 + 3;
            if (sum > 4)
            {
                sum += 10;
            }
            else
            {
                sum -= 20;
            }

            return sum;
        }

        private int SimpleIfStatement_1()
        {
            int sum = 1 + 3;
            if (sum > 4)
            {
                sum += 10;
            }
            else
            {
                sum -= 20;
            }

            return sum;
        }
  
        private void SimpleIfStatement_check()
        {
            string testName = "Code#SimpleIfStatement_Check";
            bool condition = true;
            Program.Start_Check(testName);
            int virt = SimpleIfStatement_0();
            int oracle = SimpleIfStatement_1();
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

#endregion
#region NESTED_IF

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        //        private int NestedIfStatement()
        //        {
        //
        //            int sum = 1 + 3;
        //
        //            if (sum > 4)
        //            {
        //                sum += 10;
        //                if (sum > 20)
        //                {
        //                    sum += 30;
        //                }
        //                else
        //                {
        //                    sum -= 15;
        //                }
        //            }
        //            else
        //            {
        //                sum -= 20;
        //                if (sum > 210)
        //                {
        //                    sum += 310;
        //                }
        //                else
        //                {
        //                    sum -= 115;
        //                }
        //
        //            }
        //
        //            return sum;
        //        }
        //
        //        private int NestedIfStatement_Test()
        //        {
        //
        //            int sum = 1 + 3;
        //
        //            if (sum > 4)
        //            {
        //                sum += 10;
        //                if (sum > 20)
        //                {
        //                    sum += 30;
        //                }
        //                else
        //                {
        //                    sum -= 15;
        //                }
        //            }
        //            else
        //            {
        //                sum -= 20;
        //                if (sum > 210)
        //                {
        //                    sum += 310;
        //                }
        //                else
        //                {
        //                    sum -= 115;
        //                }
        //
        //            }
        //
        //            return sum;
        //        }
        //
        //        private void NestedIfStatement_Check()
        //        {
        //            Console.WriteLine("\nStart NestedIfStatement");
        //            int a = 3;
        //            int b = 3;
        //            int virt = NestedIfStatement();
        //            int oracle = NestedIfStatement_Test();
        //            bool condition = virt == oracle;            
        //            if (!condition)
        //            {
        //                throw new Exception("NestedIfStatement fail");
        //            }
        //            Console.WriteLine("NestedIfStatement_Check - " + condition);
        //            Console.WriteLine("---------------");
        //        }
#endregion
#region SIMPLE_SWITCH

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        //        private int SimpleSwitch()
        //        {
        //            int value = 5;
        //            int result = 0;
        //            switch (value)
        //            {
        //                case 1:
        //                    result = 1;
        //                    break;
        //                case 5:
        //                    result = 5;
        //                    break;
        //            }
        //            return result;
        //        }
        //
        //        private int SimpleSwitch_0()
        //        {
        //            int value = 5;
        //            int result = 0;
        //            switch (value)
        //            {
        //                case 1:
        //                    result = 1;
        //                    break;
        //                case 5:
        //                    result = 5;
        //                    break;
        //            }
        //            return result;
        //        }
        //
        //        private void SimpleSwitch_Check()
        //        {
        //            Console.WriteLine("\nStart SimpleSwitch_Check");
        //            int a = 3;
        //            int b = 3;
        //            int virt = SimpleSwitch();
        //            int oracle = SimpleSwitch_0();
        //            bool condition = virt == oracle;
        //            if (!condition)
        //            {
        //                throw new Exception("SimpleSwitch_Check fail");
        //            }
        //            Console.WriteLine("SimpleSwitch_Check - " + condition);
        //            Console.WriteLine("---------------");
        //        }
#endregion
#region SWITCH_CHAR

        //[Obfuscation(Exclude = false, Feature = "local virt")]
        //        private int CharSwitch(string input, int index)
        //        {            
        //            int result = -2;
        //
        //            switch (input[index])
        //            {
        //                case 'a':
        //                    result = 0;
        //                    break;
        //                case 'b':
        //                    result = 1;
        //                    break;
        //                case 'c':
        //                    result = 2;
        //                    break;
        //                default:
        //                    result = -1;
        //                    break;
        //            }
        //            return result;
        //        }
        //
        //        private int CharSwitch_0(string input, int index)
        //        {
        //            int result = -2;
        //
        //            switch (input[index])
        //            {
        //                case 'a':
        //                    result = 0;
        //                    break;
        //                case 'b':
        //                    result = 1;
        //                    break;
        //                case 'c':
        //                    result = 2;
        //                    break;
        //                default:
        //                    result = -1;
        //                    break;
        //            }
        //            return result;
        //        }
        //
        //        private void CharSwitch_Check()
        //        {
        //            Console.WriteLine("\nStart CharSwitch_Check");
        //            string input = "abc";
        //            int index = 0;
        //            int virt = CharSwitch(input, index);
        //            int oracle = CharSwitch_0(input, index);
        //            bool condition = virt == oracle;
        //            if (!condition)
        //            {
        //                throw new Exception("CharSwitch_Check fail");
        //            }
        //            Console.WriteLine("CharSwitch_Check - " + condition);
        //            Console.WriteLine("---------------");
        //        }
#endregion
#region SWITCH_ENUM

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        //        private PriorityInt EnumSwitch(Priority priority)
        //        {
        //            // Switch on the Priority enum.
        //            switch (priority)
        //            {
        //                case Priority.Low:
        //                    return PriorityInt.LowInt;
        //                case Priority.Medium:
        //                    return PriorityInt.MediumInt;
        //                case Priority.Zero:                    
        //                default:
        //                    return PriorityInt.ZeroInt;
        //                case Priority.Important:
        //                case Priority.Critical:
        //                    return PriorityInt.CriticalInt;
        //            }
        //        }
        //
        //        private PriorityInt EnumSwitch_0(Priority priority)
        //        {
        //            // Switch on the Priority enum.
        //            switch (priority)
        //            {
        //                case Priority.Low:
        //                    return PriorityInt.LowInt;
        //                case Priority.Medium:
        //                    return PriorityInt.MediumInt;
        //                case Priority.Zero:
        //                default:
        //                    return PriorityInt.ZeroInt;
        //                case Priority.Important:
        //                case Priority.Critical:
        //                    return PriorityInt.CriticalInt;
        //            }
        //        }
        //
        //        private void EnumSwitch_Check()
        //        {
        //            Console.WriteLine("\nStart EnumSwitch_Check");
        //            Priority p1 = Priority.Low;
        //            Priority p2 = Priority.Critical;
        //            PriorityInt virt1 = EnumSwitch(p1);
        //            PriorityInt oracle1 = EnumSwitch_0(p1);
        //            PriorityInt virt2 = EnumSwitch(p2);
        //            PriorityInt oracle2 = EnumSwitch_0(p2);
        //            PriorityInt virt12 = EnumSwitch2(p1);
        //            PriorityInt oracle12 = EnumSwitch_0(p1);
        //            PriorityInt virt22 = EnumSwitch2(p2);
        //            PriorityInt oracle22 = EnumSwitch_0(p2);
        //            bool condition = (virt1 == oracle1) && (virt2==oracle2);
        //            bool condition2 = (virt12 == oracle12) && (virt22 == oracle22);
        //            if (!condition || !condition2)
        //            {
        //                throw new Exception("EnumSwitch_Check fail");
        //            }
        //            Console.WriteLine("EnumSwitch_Check - " + condition);
        //            Console.WriteLine("---------------");
        //        }
        //
        //        // ConsoleCalculator.CodeBranchTests
        ////         [Obfuscation(Exclude = false, Feature = "local virt")]
        //        private PriorityInt EnumSwitch2(Priority priority)
        //        {
        //            uint[] array = new uint[219];
        //            array[0] = 220u;
        //            object[] array2 = new object[56];
        //            int num = -1;
        //            num++;
        //            array2[2] = 2;
        //            array2[3] = 4;
        //            array2[4] = 0;
        //            array2[5] = 8;
        //            array2[0] = priority;
        //            Priority priority2 = Priority.Zero;
        //            array2[1] = priority2;
        //            object obj = (Priority)array2[0];
        //            array2[1] = obj;
        //            switch ((Priority)array2[1])
        //            {
        //                case Priority.Low:
        //                    return (PriorityInt)((int)array2[2]);
        //                case Priority.Medium:
        //                    return (PriorityInt)((int)array2[3]);
        //                case Priority.Important:
        //                case Priority.Critical:
        //                    return (PriorityInt)((int)array2[5]);
        //            }
        //            return (PriorityInt)((int)array2[4]);
        //        }
#endregion
#region SWITCH_STRING

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        //        int StringSwitch(string month)
        //        {
        //            switch (month.ToLower())
        //            {
        //                case "march":
        //                    return 3;
        //                case "april":
        //                    return 4;
        //                case "may":
        //                    return 5;
        //                case "sulimov dog":
        //                case "whippet":
        //                case "eurasier":
        //                case "brittany":
        //                    return 0;
        //                default:
        //                    return -1;
        //            }
        //        }
        //
        //        int StringSwitch_0(string month)
        //        {
        //            switch (month.ToLower())
        //            {
        //                case "march":
        //                    return 3;
        //                case "april":
        //                    return 4;
        //                case "may":
        //                    return 5;
        //                case "sulimov dog":
        //                case "whippet":
        //                case "eurasier":
        //                case "brittany":
        //                    return 0;
        //                default:
        //                    return -1;
        //            }
        //        }
        //
        //        private void StringSwitch_Check()
        //        {            
        //            string testName = "StringSwitch_Check";
        //            bool condition = false;
        //            Program.Start_Check(testName);
        //
        //            string input1 = "March";
        //            string input2 = "december";            
        //            int virt1 = StringSwitch(input1);
        //            int oracle1 = StringSwitch_0(input1);
        //            bool condition1 = virt1 == oracle1;
        //            int virt2 = StringSwitch(input2);
        //            int oracle2 = StringSwitch_0(input2);
        //            bool condition2 = virt2 == oracle2;
        //            condition = condition1 && condition2;
        //            Program.End_Check(testName, condition);
        //        }
        //
        ////        void refarray()
        ////        {
        ////            object[] array2 = new object[70];
        ////
        ////            array2[2] = 3;
        ////
        ////            object aux = 4;
        ////            array2[2] = aux;
        ////            Console.WriteLine(array2[2]);
        ////                        
        ////            element(out ((int) aux));
        ////
        ////            Console.WriteLine(array2[2]);
        ////        }
        //
        //        void element(out int element)
        //        {
        //            element = 2;
        //        }
#endregion
        public static void RunBranchTests()
        {
            CodeBranchTests bt = new CodeBranchTests();
//                    bt.SimpleIfStatement_check();
        //            bt.NestedIfStatement_Check();
        //            bt.SimpleSwitch_Check();
        //            bt.CharSwitch_Check();
        //            bt.EnumSwitch_Check();
        //            bt.StringSwitch_Check();
        //            bt.refarray();
        }

    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtCode/CodeLoopTests.cs
================================================
using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator.VirtCode
{
    class CodeLoopTests
    {

        public static void RunLoopTests()
        {
            CodeLoopTests lt = new CodeLoopTests();

//            lt.ForSimple_Check();
//            lt.ForSimple_Array_Check();
//
//            lt.ForBreak_Check();
//            lt.ForContinue_Check();
//            lt.ForDoubleContinue_Check();
//            lt.ForDoubleBreak_Check();
//
//            lt.DoWhile_Simple_Check();


        }

        #region FOR_SIMPLE_ARRAY

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]
private string ForSimple_Array_obfuscated(int b)
{
    //Virtualization variables
    int[] code = new int[100534];
    object[] data = new object[4137];
    int vpc = 57;

    code[25958]=1183;code[30532]=-246;code[16111]=-259;code[1443]=502;code[14872]=-227;code[52067]=-428;
    code[39107]=1467;code[6888]=-388;code[58358]=-396;code[55227]=180;code[27139]=342;code[27086]=1178;
    code[45720]=-713;code[37857]=-529;code[94362]=-636;code[33013]=15;code[75912]=1411;code[68235]=266;
    code[36651]=-644;code[77478]=1149;code[80623]=448;code[25900]=172;code[15810]=1489;code[79621]=464;
    code[84989]=-74;code[20041]=914;code[32853]=-522;code[29176]=802;code[60736]=80;code[85159]=-887;
    code[92511]=1063;code[66578]=-996;code[98608]=-721;code[47651]=61;code[31001]=405;code[88519]=95;
    code[47366]=723;code[67395]=726;code[28095]=1001;code[71805]=147;code[32475]=976;code[34520]=420;
    code[95162]=406;code[7972]=409;code[67786]=1394;code[90713]=1330;code[29699]=813;code[94464]=1440;
    code[92197]=-361;code[49060]=-887;code[52447]=-82;code[27903]=-292;code[49256]=903;code[29603]=593;
    code[52375]=499;code[44400]=1008;code[72177]=-31;code[72605]=-677;code[48479]=-765;code[5571]=45;
    code[3269]=1275;code[75423]=-124;code[66323]=1370;code[14334]=864;code[75386]=735;code[77764]=-941;
    code[31423]=672;code[94240]=1388;code[51582]=-850;code[7862]=-537;code[26972]=105;code[4298]=-814;
    code[51872]=-754;code[21557]=1268;code[323]=1025;code[49676]=1057;code[20128]=-826;code[1298]=528;
    code[62052]=1317;code[62695]=354;code[62206]=371;code[89215]=1067;code[83049]=44;code[49362]=-878;
    code[45297]=916;code[61976]=55;code[1597]=1175;code[15060]=476;code[87211]=688;code[83922]=402;
    code[73760]=-413;code[74645]=1349;code[20095]=1376;code[82800]=-394;code[65937]=-186;code[34011]=465;
    code[43873]=340;code[56948]=798;code[55753]=-461;code[24989]=-755;code[61098]=-587;code[45930]=-409;
    code[19462]=-821;code[81139]=-175;code[92500]=56;code[74791]=1354;code[9252]=-844;code[81244]=-41;
    code[81054]=1369;code[63041]=1188;code[59736]=-380;code[39536]=-689;code[43062]=-925;code[99103]=198;
    code[30534]=75;code[3612]=629;code[42928]=841;code[95828]=421;code[78242]=264;code[75018]=-681;
    code[14419]=233;code[32428]=-417;code[58511]=-9;code[49688]=-66;code[73211]=-543;code[91816]=517;
    code[59186]=-68;code[50664]=-102;code[77612]=-170;code[81253]=-592;code[8662]=-182;code[2644]=224;
    code[38852]=-770;code[51739]=-112;code[11004]=-401;code[60856]=-250;code[20249]=247;code[73602]=-749;
    code[93070]=-601;code[54548]=-921;code[53879]=530;code[75529]=-698;code[51971]=72;code[6330]=-866;
    code[23389]=484;code[80065]=115;code[70142]=457;code[4200]=1039;code[46976]=1081;code[85152]=224;
    code[88670]=-653;code[26569]=221;code[58058]=532;code[40769]=-777;code[64430]=8;code[43595]=530;
    code[79387]=941;code[63080]=185;code[57935]=1263;code[97806]=1393;code[2944]=151;code[12341]=289;
    code[44568]=-602;code[60582]=546;code[45978]=1290;code[63671]=-768;code[31444]=-868;code[15048]=-8;
    code[34960]=-344;code[54626]=1259;code[2357]=1433;code[41530]=1073;code[16100]=-540;code[65984]=1302;
    code[96045]=419;code[24085]=404;code[86443]=1223;code[46292]=53;code[1617]=871;code[4542]=45;
    code[1042]=967;code[63561]=811;code[77411]=-149;code[30103]=842;code[63019]=-425;code[12704]=-217;
    code[36398]=-828;code[93901]=-861;code[4781]=-267;code[35740]=-353;code[50565]=703;code[66677]=1224;
    code[68029]=-822;code[23443]=58;code[59552]=820;code[38304]=497;code[21875]=-688;code[89838]=-409;
    code[34295]=721;code[5961]=1048;code[88946]=1298;code[29589]=812;code[44363]=1315;code[20084]=977;
    code[96059]=11;code[37577]=806;code[39521]=965;code[92008]=-178;code[12435]=856;code[4819]=746;
    code[10797]=1190;code[14522]=1246;code[85387]=318;code[9640]=-408;code[17620]=743;code[71857]=-103;
    code[23539]=339;code[37638]=458;code[38917]=1345;code[45080]=876;code[87635]=105;code[47023]=-531;
    code[35645]=645;code[20711]=78;code[21110]=411;code[11342]=496;code[64396]=-99;code[71595]=-979;
    code[77919]=-11;code[88031]=1285;code[83462]=1407;code[61897]=-356;code[69348]=-964;code[49109]=1142;
    code[41386]=-171;code[94683]=-537;code[29569]=-257;code[83121]=662;code[41063]=1391;code[54683]=-523;
    code[32292]=660;code[2701]=526;code[58781]=-710;code[72235]=1183;code[82817]=-86;code[81269]=1478;
    code[6293]=335;code[92530]=1271;code[83095]=-476;code[50065]=-151;code[17078]=-128;code[1998]=1195;
    code[62620]=1318;code[30609]=-142;code[53682]=-883;code[60329]=1046;code[85643]=711;code[59599]=-586;
    code[94103]=-988;code[67687]=434;code[29776]=537;code[3355]=-886;code[52615]=1376;code[12350]=899;
    code[37895]=1295;code[84308]=-504;code[46109]=-490;code[2121]=1430;code[64790]=-629;code[99295]=643;
    code[81602]=-62;code[34119]=941;code[76982]=1474;code[14014]=-56;code[94654]=886;code[97793]=1053;
    code[53933]=1310;code[4390]=386;code[31715]=1435;code[35676]=680;code[80881]=361;code[97141]=539;
    code[20949]=3;code[36167]=619;code[66710]=551;code[52415]=968;code[1751]=-961;code[76600]=1302;
    code[27722]=-359;code[28158]=333;code[81544]=862;code[82259]=555;code[95030]=-958;code[66574]=335;
    code[16125]=165;code[66038]=676;code[79799]=-212;code[85733]=-333;code[41123]=808;code[57144]=-90;
    code[63357]=228;code[71816]=-198;code[23442]=-537;code[80829]=301;code[16327]=-694;code[28047]=-853;
    code[69765]=1053;code[86583]=-851;code[73034]=-141;code[67426]=-523;code[74312]=1063;code[49000]=-507;
    code[96872]=1127;code[99893]=755;code[16403]=237;code[51455]=380;code[69184]=1289;code[90799]=-202;
    code[3071]=242;code[39129]=899;code[21431]=-646;code[37386]=-906;code[18836]=494;code[98168]=1430;
    code[45651]=982;code[54339]=-838;code[5300]=-57;code[62849]=1011;code[419]=292;code[35937]=-45;
    code[19272]=-746;code[35925]=668;code[61422]=816;code[37268]=945;code[92318]=354;code[2921]=-427;
    code[95974]=1276;code[98322]=493;code[45599]=124;code[989]=-87;code[87912]=-947;code[24931]=-76;
    code[95952]=116;code[50227]=-223;code[29213]=-754;code[31703]=283;code[14045]=-983;code[57124]=-722;
    code[78853]=761;code[42891]=151;code[22849]=-505;code[5428]=1280;code[76819]=-222;code[11111]=-646;
    code[40132]=-931;code[35304]=385;code[51001]=1479;code[51047]=-575;code[85846]=1468;code[71681]=-590;
    code[22825]=-851;code[49021]=1049;code[22755]=289;code[9005]=1369;code[34437]=1166;code[81746]=872;
    code[2328]=372;code[13903]=690;code[97249]=-161;code[60909]=608;code[33790]=-106;code[91661]=-343;
    code[75124]=902;code[612]=-631;code[50186]=-6;code[25871]=992;code[99670]=-345;code[23492]=-582;
    code[71443]=-415;code[68969]=-379;code[22282]=-593;code[80366]=331;code[21569]=505;code[53404]=1395;
    code[85813]=1078;code[20410]=295;code[38352]=-826;code[83263]=1173;code[14878]=-439;code[7298]=163;
    code[51228]=1354;code[45085]=1361;code[61265]=-960;code[76175]=902;code[31712]=1426;code[97068]=832;
    code[65304]=-107;code[42381]=-567;code[56122]=-52;code[4860]=-637;code[23099]=-881;code[29581]=669;
    code[19587]=847;code[41771]=1304;code[43640]=-90;code[1963]=214;code[16240]=-449;code[74282]=-301;
    code[71819]=1136;code[92795]=-504;code[84882]=925;code[64616]=1207;code[87065]=174;code[87335]=-940;
    code[65168]=637;code[31279]=921;code[17730]=1318;code[23684]=154;code[65096]=952;code[75385]=1175;
    code[60384]=1090;code[32849]=1377;code[95631]=199;code[57469]=72;code[62182]=-646;code[46130]=758;
    code[45869]=1124;code[30250]=148;code[40731]=28;code[80585]=812;code[87495]=-22;code[27485]=947;
    code[5343]=-373;code[31122]=-415;code[99033]=-307;code[63575]=1333;code[10541]=-869;code[60096]=-980;
    code[44596]=728;code[93653]=-34;code[90295]=99;code[40772]=266;code[19714]=518;code[31409]=-184;
    code[62981]=940;code[5682]=-410;code[98447]=-938;code[5]=-477;code[56569]=369;code[90279]=751;
    code[17093]=-157;code[44619]=-147;code[51201]=313;code[60188]=8;code[25349]=-269;code[1589]=783;
    code[48242]=37;code[83125]=76;code[99110]=917;code[58613]=113;code[94341]=1457;code[61093]=-478;
    code[22186]=-10;code[95938]=-800;code[5289]=-29;code[44789]=1239;code[79780]=-423;code[21756]=401;
    code[100130]=-840;code[100256]=676;code[894]=1272;code[7468]=-166;code[76442]=-143;code[76024]=410;
    code[19904]=423;code[22456]=989;code[96973]=131;code[76605]=-533;code[73368]=-413;code[12126]=-718;
    code[57406]=296;code[35285]=1158;code[85166]=-701;code[92489]=-379;code[19979]=-335;code[43681]=1304;
    code[77369]=1280;code[43898]=-927;code[91369]=-316;code[45092]=1194;code[64350]=-25;code[88672]=207;
    code[16605]=624;code[93634]=-148;code[47166]=-927;code[83532]=902;code[94865]=1210;code[10030]=225;
    code[56082]=-474;code[48924]=601;code[42521]=268;code[36732]=1329;code[462]=332;code[364]=8652;code[1001]=3597;code[1008]=3456;code[630]=1687;code[928]=2063;    data[1786]=487;
code[498]=3597;code[806]=3653;    data[294]=-5;
    data[2208]=(string[])null;
code[356]=294;        data[2239]=b;
    data[3199]=520;
code[586]=88;code[690]=2921;code[300]=2621;code[178]=1562;code[425]=1562;code[753]=2621;code[245]=2239;code[692]=1851;    data[1882]="#" ;
code[120]=2239;code[1076]=88;code[176]=887;code[177]=3710;    data[1687]=1;
code[817]=2409;code[351]=3199;code[567]=1562;code[873]=2063;    data[2579]=73;
code[743]=2921;code[940]=9315;code[58]=88;code[637]=1562;    data[2063]=535;
code[290]=1786;code[418]=3141;code[631]=3539;code[239]=1851;code[480]=88;code[698]=2239;    data[3141]="_" ;
code[560]=3663;code[56]=435;code[237]=1786;code[733]=1562;    data[332]=1125390383;
    data[435]="";
    data[1860]=false;
code[327]=1860;code[437]=9315;code[657]=1562;    data[1562]=-710;
    data[88]=1698300776;
code[884]=7075;code[545]=2208;    data[3456]=1268840513;
code[280]=1562;code[921]=1882;code[505]=332;code[1028]=88;    data[3653]=-520;
    data[887]=0;
code[349]=2579;code[525]=88;code[780]=1860;code[122]=2208;code[892]=2208;code[119]=9399;code[1063]=1067;    data[2921]=-109;
code[983]=88;code[57]=3710;code[965]=3456;code[366]=1860;
    return (string)InstanceInterpreterVirtualization_CodeLoopTests_1802(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; ")]
private string ForSimple_Array_obfuscated_default_junk(int b)
{
    //Virtualization variables
    int[] code = new int[100860];
    object[] data = new object[4182];
    int vpc = 67;

    code[86489]=-316;code[93948]=1292;code[9007]=-222;code[32315]=297;code[3412]=731;code[8470]=-301;
    code[14719]=-958;code[11082]=-175;code[20772]=-888;code[78269]=-533;code[25328]=-225;code[69630]=433;
    code[74250]=-789;code[85760]=-478;code[3721]=-819;code[62173]=-97;code[91471]=-389;code[57309]=983;
    code[73041]=-600;code[44315]=811;code[23662]=-614;code[88877]=1248;code[24127]=620;code[42866]=423;
    code[99507]=889;code[40701]=949;code[55325]=766;code[81804]=368;code[58847]=-105;code[18235]=-989;
    code[46524]=-722;code[48621]=1402;code[7682]=806;code[37599]=1253;code[45252]=-210;code[61107]=-886;
    code[61088]=-872;code[96069]=-759;code[43270]=977;code[33687]=-780;code[66519]=-298;code[22411]=-298;
    code[67485]=1091;code[81993]=-500;code[43715]=-948;code[21189]=-86;code[98794]=86;code[26545]=-693;
    code[67820]=1300;code[83043]=291;code[27773]=308;code[12182]=675;code[15139]=-106;code[17572]=242;
    code[76051]=786;code[11930]=981;code[2446]=-769;code[34819]=-549;code[89703]=-498;code[29456]=-401;
    code[91736]=-569;code[47202]=69;code[10714]=-401;code[6665]=-573;code[79513]=1073;code[42783]=272;
    code[97578]=1043;code[81964]=-661;code[16141]=379;code[13193]=-223;code[66799]=-211;code[45015]=797;
    code[91037]=43;code[34461]=1216;code[9016]=-794;code[23562]=178;code[63336]=459;code[61239]=-743;
    code[5606]=732;code[56888]=1275;code[29434]=-993;code[71471]=1311;code[29275]=523;code[83223]=-483;
    code[28252]=-477;code[2058]=-157;code[7095]=1452;code[58228]=483;code[73233]=872;code[52965]=721;
    code[90598]=-552;code[8235]=764;code[60100]=1382;code[88858]=-41;code[21190]=774;code[8105]=167;
    code[99636]=-449;code[1951]=647;code[61255]=304;code[43239]=-267;code[59741]=-664;code[61184]=1200;
    code[6287]=1240;code[40436]=617;code[645]=-967;code[38008]=-234;code[16932]=1188;code[1200]=-719;
    code[92943]=-993;code[33147]=-157;code[73453]=103;code[100544]=426;code[13002]=383;code[35259]=1124;
    code[96978]=1295;code[99472]=-490;code[32306]=-421;code[9726]=908;code[57761]=-497;code[64881]=749;
    code[55673]=-416;code[38059]=-509;code[33572]=934;code[30170]=-719;code[21053]=1267;code[74395]=510;
    code[19479]=-772;code[56988]=-623;code[13900]=-910;code[75765]=272;code[55125]=378;code[69145]=-780;
    code[2756]=-569;code[99471]=1340;code[78553]=-380;code[54443]=799;code[36280]=572;code[79209]=235;
    code[6458]=1000;code[23957]=-113;code[25643]=-408;code[64646]=-864;code[18212]=-46;code[1127]=-428;
    code[67252]=1363;code[63112]=341;code[45420]=-665;code[15449]=-999;code[55306]=-278;code[17062]=-600;
    code[79433]=-93;code[33662]=1401;code[37020]=-956;code[24672]=410;code[30863]=-824;code[8764]=-157;
    code[80556]=-10;code[25687]=-227;code[91807]=577;code[91543]=613;code[16274]=893;code[27157]=1083;
    code[62792]=-992;code[27195]=-437;code[47981]=961;code[95413]=937;code[63661]=-808;code[57241]=1227;
    code[91098]=701;code[69353]=-593;code[13847]=117;code[93086]=490;code[86597]=-280;code[74409]=-865;
    code[88720]=1109;code[9129]=1293;code[38478]=309;code[100756]=-925;code[9462]=251;code[34073]=-91;
    code[75442]=-952;code[8925]=303;code[12573]=-220;code[71232]=803;code[83566]=-92;code[40983]=-426;
    code[95137]=861;code[51248]=785;code[84151]=682;code[98311]=-165;code[26785]=-462;code[34868]=580;
    code[70001]=-929;code[39675]=-732;code[7889]=343;code[80420]=7;code[34566]=-191;code[41849]=-705;
    code[36154]=3;code[47550]=366;code[58704]=-960;code[22764]=290;code[44101]=1152;code[98255]=592;
    code[1577]=-289;code[19761]=51;code[53018]=-992;code[9898]=331;code[67931]=140;code[83448]=-760;
    code[92653]=497;code[64881]=-272;code[57102]=-992;code[89460]=548;code[33260]=-25;code[35898]=82;
    code[20341]=70;code[75868]=-377;code[99819]=1073;code[19653]=1083;code[5483]=891;code[9257]=984;
    code[34427]=-59;code[88467]=-153;code[22770]=1205;code[44833]=1255;code[57906]=-62;code[63333]=1458;
    code[37617]=1336;code[95813]=84;code[98219]=-113;code[30966]=563;code[93663]=907;code[22087]=-757;
    code[25348]=1122;code[54758]=1109;code[26375]=1485;code[4210]=-595;code[51138]=1124;code[95809]=-527;
    code[12748]=369;code[39697]=118;code[95367]=134;code[86608]=1065;code[80710]=922;code[88386]=-862;
    code[88715]=902;code[86679]=748;code[45340]=165;code[87240]=445;code[15903]=949;code[8858]=-58;
    code[34231]=501;code[64608]=449;code[33646]=164;code[48028]=308;code[99294]=901;code[30996]=65;
    code[96948]=1148;code[68585]=187;code[91214]=-19;code[29983]=205;code[98084]=219;code[97263]=250;
    code[13588]=-145;code[71865]=-898;code[99313]=-71;code[3207]=-134;code[46394]=-959;code[10897]=-138;
    code[82022]=-304;code[49697]=-165;code[29531]=-118;code[7138]=-703;code[45771]=83;code[74465]=474;
    code[79295]=-25;code[67966]=912;code[48650]=513;code[40791]=1129;code[64167]=-650;code[44909]=1478;
    code[75979]=88;code[54328]=532;code[73494]=1401;code[97431]=1361;code[75798]=-163;code[66727]=564;
    code[90764]=1407;code[19115]=548;code[42046]=1113;code[4696]=753;code[60908]=-694;code[25680]=486;
    code[70380]=-334;code[87183]=1136;code[61747]=-360;code[71487]=682;code[84060]=253;code[58603]=1143;
    code[82135]=144;code[39376]=233;code[47138]=984;code[84563]=127;code[73480]=-880;code[87254]=298;
    code[41954]=962;code[43860]=977;code[9444]=859;code[39082]=576;code[18231]=1360;code[92285]=154;
    code[9698]=-722;code[33519]=238;code[63160]=1471;code[79903]=-4;code[38514]=-170;code[81202]=1397;
    code[45873]=383;code[23596]=1025;code[28657]=1008;code[87341]=624;code[40512]=-138;code[44228]=1068;
    code[82848]=1294;code[58436]=-777;code[11484]=1375;code[68247]=1175;code[54763]=1321;code[40051]=-111;
    code[46537]=-142;code[83204]=849;code[25817]=166;code[13876]=-791;code[98827]=189;code[33901]=350;
    code[51436]=443;code[34959]=-57;code[7881]=-337;code[6075]=877;code[67879]=262;code[67958]=770;
    code[41269]=756;code[28713]=78;code[66107]=1337;code[41952]=315;code[15755]=1195;code[35172]=1352;
    code[98687]=-686;code[39701]=1337;code[20916]=-114;code[85467]=-137;code[58669]=-903;code[58449]=341;
    code[60886]=-252;code[79889]=-307;code[87573]=614;code[68869]=1390;code[67516]=-709;code[33364]=383;
    code[18342]=765;code[43209]=-888;code[6052]=1024;code[38742]=579;code[23058]=14;code[40228]=1380;
    code[87925]=-688;code[54848]=-205;code[66334]=-180;code[12778]=-75;code[12426]=870;code[83501]=-110;
    code[14401]=-655;code[66370]=275;code[19695]=-19;code[27384]=1154;code[80201]=1100;code[75973]=253;
    code[93420]=1006;code[28792]=929;code[66055]=1369;code[31053]=-506;code[90819]=1099;code[40929]=857;
    code[10296]=-89;code[30119]=-148;code[99836]=1401;code[43373]=84;code[88564]=-820;code[90994]=1304;
    code[15305]=1184;code[44033]=1090;code[13532]=342;code[15831]=-922;code[37504]=-894;code[39547]=1138;
    code[4321]=-113;code[72134]=-562;code[44407]=574;code[45958]=-243;code[73886]=1287;code[41173]=1076;
    code[9458]=1326;code[87954]=1086;code[41386]=-202;code[62863]=1134;code[90795]=-91;code[62546]=952;
    code[51545]=179;code[6436]=-92;code[68884]=-64;code[37449]=-851;code[98072]=108;code[30081]=587;
    code[24758]=-364;code[100192]=-380;code[62191]=498;code[19067]=-408;code[46958]=514;code[74881]=-491;
    code[67059]=-194;code[62637]=-870;code[42276]=345;code[96325]=697;code[74097]=1335;code[67020]=1421;
    code[57096]=-770;code[62519]=-105;code[54826]=-129;code[86579]=626;code[63759]=-408;code[59408]=-611;
    code[32899]=-63;code[23937]=-248;code[17629]=-42;code[31824]=1263;code[73550]=1150;code[70462]=-99;
    code[75985]=-203;code[64598]=85;code[49248]=548;code[90812]=-222;code[59506]=-939;code[68795]=311;
    code[98788]=1077;code[69922]=-708;code[75378]=-771;code[57650]=69;code[73972]=162;code[73231]=-890;
    code[30339]=635;code[50854]=-122;code[62385]=898;code[24143]=765;code[39690]=-352;code[60995]=-439;
    code[71418]=60;code[16353]=-968;code[33950]=-306;code[57072]=-247;code[69894]=782;code[32416]=-141;
    code[69594]=-504;code[15926]=593;code[29092]=-324;code[63249]=-280;code[59803]=491;code[13456]=1085;
    code[11603]=372;code[69881]=1076;code[79213]=1440;code[13206]=800;code[22808]=171;code[41241]=-193;
    code[93784]=396;code[9205]=139;code[90704]=61;code[35409]=469;code[33562]=-600;code[66704]=50;
    code[60647]=505;code[42118]=-694;code[63767]=-209;code[63704]=-721;code[29327]=-180;code[90558]=969;
    code[58978]=837;code[52047]=792;code[58693]=503;code[11874]=-447;code[79641]=1086;code[71345]=824;
    code[18101]=-572;code[39221]=-580;code[24742]=363;code[50565]=1386;code[89527]=-318;code[23142]=-542;
    code[56324]=-980;code[8864]=1273;code[84426]=-257;code[3266]=504;code[66649]=-241;code[87851]=-590;code[685]=3611;    data[1664]=262;
    data[3871]=-275;
    data[2420]=-244;
code[577]=3697;code[120]=3254;code[386]=8705;    data[2307]=-171;
code[1042]=2484;    data[3203]=866;
    data[34]=644;
code[385]=1065;code[404]=3901;    data[2621]=297;
    data[1770]=-291;
    data[1008]=322;
code[660]=8182;    data[480]=-411;
code[597]=8315;    data[2076]=19;
code[1057]=2566;    data[3037]=500;
code[1105]=2368;    data[818]=-788;
    data[309]=-171;
code[1023]=94;code[405]=215;code[1025]=2119;    data[3464]=-461;
code[863]=2289;code[233]=878;code[341]=804;code[519]=3171;    data[1130]=456;
code[485]=1803;    data[1096]=116;
    data[1017]=-206;
    data[35]="";
code[796]=3297;code[376]=2187;code[686]=3633;    data[472]=-520;
    data[2693]=939;
code[58]=1211;code[848]=1325;code[1129]=2743;    data[2992]=-306;
code[1033]=3016;code[681]=1374;    data[455]=-668;
code[346]=3633;code[313]=3472;    data[2951]=-984;
    data[190]=500;
code[687]=1765;code[713]=4515;code[388]=1795;code[468]=149;code[459]=1365;    data[2033]=911;
code[1043]=2119;code[1122]=3584;    data[2040]=-310;
code[986]=694;code[61]=3811;code[620]=1126;code[155]=1828;code[971]=1365;code[169]=1702;code[1093]=2344;code[618]=1844;code[1095]=1220;    data[3129]=-914;
    data[328]=422;
    data[535]=405;
    data[2614]=405;
code[138]=2843;code[889]=3078;    data[2637]=274;
    data[771]=268;
code[919]=2688;code[1121]=269;code[477]=269;code[623]=2578;code[210]=2480;code[518]=960;code[922]=983;    data[3958]=925;
code[1117]=2119;code[132]=1684;    data[3337]=-902;
    data[694]=360;
code[513]=2119;    data[2470]=-609;
    data[2068]=521;
code[406]=3202;code[739]=3188;    data[3573]=-748;
    data[30]=-818;
code[799]=2488;    data[755]=-681;
code[793]=2280;    data[2234]=-85;
code[526]=1520;    data[2222]=-394;
    data[1645]=427;
    data[2903]=389;
code[388]=2080;code[1059]=2323;code[871]=1801;code[192]=2671;code[1041]=3570;code[716]=465;code[781]=5576;    data[2607]=-44;
code[90]=3618;code[1026]=3946;code[130]=4692;code[521]=1704;    data[3136]=-889;
    data[976]=-1;
    data[1374]=1;
    data[3202]=744;
    data[3177]=115;
code[616]=3254;code[779]=215;    data[3009]=392;
    data[1810]=935;
    data[2702]=-911;
    data[2166]=467;
code[174]=3633;    data[2119]=1767785440;
code[742]=1223;    data[2921]=213;
    data[3210]=-722;
code[698]=861;    data[1811]=731;
code[991]=3016;code[928]=959;code[579]=1046;    data[1137]=-579;
code[530]=2484;code[906]=9203;code[982]=1261;code[54]=330;    data[2636]=55;
code[921]=3686;    data[241]=-786;
code[70]=2428;code[198]=527;code[863]=2474;code[896]=1695;code[67]=5573;    data[868]=-988;
code[808]=3633;code[721]=1621;    data[1577]=-393;
    data[878]=-21;
code[479]=1704;code[928]=3765;        data[1223]=b;
    data[3710]=333;
code[342]=797;code[450]=2790;code[132]=2249;code[531]=2119;    data[3717]=652;
code[280]=1223;code[546]=1445;    data[448]="#" ;
    data[1649]=-905;
    data[2370]=-652;
code[809]=833;    data[2384]=-453;
    data[546]=558;
    data[2224]=-754;
    data[344]=571;
    data[2743]=-454;
    data[669]=785;
    data[3633]=152;
code[317]=215;    data[3901]=520;
    data[3751]=674;
code[137]=3801;code[612]=3633;code[935]=694;    data[2377]=239;
    data[3794]=925;
    data[833]=390;
    data[3291]=-185;
    data[1094]=-617;
code[319]=5576;code[85]=35;    data[1704]=910238941;
    data[127]=909;
    data[2318]=49;
    data[3269]=-666;
code[933]=2983;code[188]=5573;    data[3254]=(string[])null;
code[126]=1223;code[717]=1431;code[601]=2119;    data[1862]=-65;
    data[2790]="_" ;
code[1105]=3299;    data[900]=758;
code[695]=833;    data[2727]=-74;
code[528]=713;    data[1309]=592;
code[1044]=321;    data[76]=-894;
code[81]=3945;code[962]=448;    data[3067]=-822;
code[370]=1637;    data[3155]=-587;
    data[3860]=-40;
code[905]=3254;    data[3016]=1101107014;
code[53]=2119;code[195]=599;code[251]=4515;code[619]=1118;code[914]=778;code[914]=3755;code[206]=1886;    data[1226]=576;
    data[2974]=-646;
    data[2394]=433;
code[1116]=144;code[401]=1567;    data[2164]=-132;
code[805]=3506;code[393]=3412;code[1135]=2967;    data[850]=-791;
    data[215]=false;
code[466]=2590;code[674]=1678;    data[1886]=0;
code[900]=1745;code[934]=1163;code[867]=2750;    data[3187]=161;
code[645]=2940;code[200]=2366;    data[2187]=73;
    data[3359]=-278;
    data[3447]=-747;
code[474]=3633;code[647]=3633;code[784]=659;code[831]=472;code[554]=2535;code[478]=1022;code[313]=2453;code[241]=3795;code[964]=2632;code[347]=878;code[1109]=9870;
    return (string)InstanceInterpreterVirtualization_CodeLoopTests_3525(vpc, data, code);

}

//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; ")]
        private string ForSimple_example()
        {

            string sum = "";            
            for (int i = 0; i < ReturnArg_Array(3); i++)
            {
                sum += "_" + i;                
            }
            
            return sum;
        }


        private string ForSimple_Array_original(int b)
        {

            string sum = "";
            string[] dst = new string[b];
            for (int i = 0; i < ReturnArg_Array(b); i++)
            {
                sum += "_" + i ;
                sum += "~";
                dst[i] = sum;
            }

            sum += "#" + dst.Length;
            return sum;
        }

        private int ReturnArg_Array(int arg)
        {
            return arg;
        }

        private void ForSimple_Array_Check()
        {
            string testName = "Code#ForSimple_Array_Check";
            Program.Start_Check(testName);
            bool condition = true;
            
            int b = 6;
            if (Program.args_in.Count() > 0)
            {
                string loop_count = Program.args_in[0];
                int nr = Int32.Parse(loop_count);
                b = nr;
            }                

            string virt1 = ForSimple_Array_obfuscated( b);
            string virt2 = ForSimple_Array_obfuscated_default_junk(b);
            string oracle = ForSimple_Array_original( b);
            Console.WriteLine("virt {0} {1} = {2} orig", virt1, virt2, oracle);
            condition = virt1 == virt2 && virt2 == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region FOR_SIMPLE

        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForSimple_0(int a, int b)
        {
            string sum = "";
            for (int i = 0; i < ReturnArg(b); i++)
            {
                sum += "_" + i;
            }

            return sum;
        }

        private string ForSimple_1(int a, int b)
        {

            string sum = "";
            for (int i = 0; i < ReturnArg(b); i++)
            {
                sum += "_" + i;
            }

            return sum;
        }

        private int ReturnArg(int arg)
        {
            return arg;
        }

        private void ForSimple_Check()
        {
            string testName = "Code#ForSimple_Check";
            Program.Start_Check(testName);
            bool condition = true;
            int a = 2;
            int b = 6;
            string virt = ForSimple_0(a, b);
            string oracle = ForSimple_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region FOR_BREAK

//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
private string ForBreak_0(int a, int b)
{
    string sum = "";
    int var_forIndex_0 = 0;
    bool var_whileCondition_0 = var_forIndex_0 < b;
    while (var_whileCondition_0)
    {
        sum = sum + var_forIndex_0;
        bool var_ifCondition_0 = var_forIndex_0 == a;
        if (var_ifCondition_0)
        {
            sum = sum + "continue";
            var_forIndex_0 = var_forIndex_0 + 1;
            var_whileCondition_0 = var_forIndex_0 < b;
            continue;
        }

        bool var_ifCondition_1 = var_forIndex_0 == 4;
        if (var_ifCondition_1)
        {
            sum = sum + "break";
            var_forIndex_0 = var_forIndex_0 + 1;
            var_whileCondition_0 = false;
            continue;
        }

        sum = sum + "_";
        var_forIndex_0 = var_forIndex_0 + 1;
        var_whileCondition_0 = var_forIndex_0 < b;
    }

    return sum;
}


    private string ForBreak_1(int a, int b)
    {

        string sum = "";
        for (int i = 0; i < b; i++)
        {
            sum += i;

            if (i == a)
            {
                sum += "continue";
                continue;
            }
            if (i == 4)
            {
                sum += "break";
                break;
            }
            sum += "_";
        }

        return sum;
    }

        private void ForBreak_Check()
        {
            string testName = "Code#ForBreak_Check";
            Program.Start_Check(testName);
            bool condition = true;
            int a = 1;
            int b = 6;
            string virt = ForBreak_0(a, b);
            string oracle = ForBreak_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region FOR_CONTINUE

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForContinue_0(int a, int b)
        {

            string sum = "";
            for (int i = 0; i < b; i++)
            {
                sum += i;

                if (i == a)
                {
                    sum += "x";
                    continue;
                }
                if (i == 4)
                    continue;
                sum += "_";
            }

            return sum;
        }


        private string ForContinue_1(int a, int b)
        {

            string sum = "";
            for (int i = 0; i < b; i++)
            {
                sum += i;

                if (i == a)
                {
                    sum += "x";
                    continue;
                }
                if (i == 4)
                    continue;
                sum += "_";
            }

            return sum;
        }

        private void ForContinue_Check()
        {
            string testName = "Code#ForContinue_Check";
            Program.Start_Check(testName);
            bool condition = true;
            int a = 2;
            int b = 6;
            string virt = ForContinue_0(a, b);
            string oracle = ForContinue_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region FOR_Double_CONTINUE

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForDoubleContinue_0(int a, int b)
        {
            string sum = "";
            for (int j = 0; j <= a; j++)
            {
                sum += "#j>>>";

                if (j % 2 == 1)
                    continue;

                for (int i = 0; i < b; i++)
                {
                    sum += i;

                    if (i == a)
                    {
                        sum += "x";
                        continue;
                    }
                    if (i == 4)
                        continue;
                    sum += "_";
                }

                sum += "<#";
            }

            return sum;
        }


        private string ForDoubleContinue_1(int a, int b)
        {
            string sum = "";
            for (int j = 0; j <= a; j++)
            {
                sum += "#j>>>";

                if (j % 2 == 1)
                    continue;

                for (int i = 0; i < b; i++)
                {
                    sum += i;

                    if (i == a)
                    {
                        sum += "x";
                        continue;
                    }
                    if (i == 4)
                        continue;
                    sum += "_";
                }

                sum += "<#";
            }

            return sum;
        }

        private void ForDoubleContinue_Check()
        {
            string testName = "Code#ForDoubleContinue_Check";
            Program.Start_Check(testName);
            bool condition = true;
            int a = 2;
            int b = 6;
            string virt = ForDoubleContinue_0(a, b);
            string oracle = ForDoubleContinue_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region FOR_Double_BREAK
//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string ForDoubleBreak_0(int a, int b)
        {

            string sum = "";
            for (int j = 0; j <= a; j++)
            {
                sum += "#j>>>";

                if (j % 2 == 1)
                    break;

                for (int i = 0; i < b; i++)
                {
                    sum += i;

                    if (i == a)
                    {
                        sum += "x";
                        continue;
                    }
                    if (i == 4)
                        break;
                    sum += "_";
                }

                sum += "<#";
            }

            return sum;
        }


        private string ForDoubleBreak_1(int a, int b)
        {

            string sum = "";
            for (int j = 0; j <= a; j++)
            {
                sum += "#j>>>";

                if (j % 2 == 1)
                    break;

                for (int i = 0; i < b; i++)
                {
                    sum += i;

                    if (i == a)
                    {
                        sum += "x";
                        continue;
                    }
                    if (i == 4)
                        break;
                    sum += "_";
                }

                sum += "<#";
            }

            return sum;
        }

        private void ForDoubleBreak_Check()
        {
            string testName = "Code#ForDoubleBreak_Check";
            Program.Start_Check(testName);
            bool condition = true;
            int a = 2;
            int b = 6;
            string virt = ForDoubleBreak_0(a, b);
            string oracle = ForDoubleBreak_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region WHILE_CONTINUE

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string WhileContinue_0(int a, int b)
        {

            string sum = "";
            int i = 0;
            while (i < b)
            {
                sum += i;
                i++;

                if (i == a)
                {
                    sum += "x";
                    continue;
                }
                if (i == 4)
                    continue;
                sum += "_";
            }

            return sum;
        }


        private string WhileContinue_1(int a, int b)
        {
            string sum = "";
            int i = 0;
            while (i < b)
            {
                sum += i;
                i++;

                if (i == a)
                {
                    sum += "x";
                    continue;
                }
                if (i == 4)
                    continue;
                sum += "_";
            }

            return sum;
        }

        private void WhileContinue_Check()
        {
            string testName = "Code#WhileContinue_Check";
            Program.Start_Check(testName);
            bool condition = true;
            int a = 2;
            int b = 6;
            string virt = WhileContinue_0(a, b);
            string oracle = WhileContinue_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

       

        #region SIMPLE_DO_WHILE

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string DoWhile_Simple_0()
        {            
            string sum = "";
            int i = 0;
            do
            {
                sum += i;
                i++;
            } while (i < 5);
            return sum;
        }

        private string DoWhile_Simple_1()
        {
            string sum = "";
            int i = 0;
            do
            {
                sum += i;
                i++;
            } while (i < 5);
            return sum;
        }

        private void DoWhile_Simple_Check()
        {
            string testName = "Code#DoWhile_Simple_Check";
            Program.Start_Check(testName);
            bool condition = true;            
            string virt = DoWhile_Simple_0();
            string oracle = DoWhile_Simple_1();
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

private object InstanceInterpreterVirtualization_CodeLoopTests_1802(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 3663:
                ((string[])data[code[vpc + (-15)]])[(int)data[code[vpc + (7)]]] = (string)data[code[vpc + (26)]];
                vpc += 71;
                break;
            case 7075:
                data[code[vpc + (-11)]] = ((string[])data[code[vpc + (8)]]).Length;
                vpc += 56;
                break;
            case 1067:
                return (string)data[code[vpc + (13)]];
                vpc += 68;
            default:
                break;
            case 1851:
                data[code[vpc + (-2)]] = ReturnArg((int)data[code[vpc + (6)]]);
                vpc += 61;
                break;
            case 2409:
                vpc += (int)data[code[vpc + (-11)]];
                vpc += 67;
                break;
            case 3597:
                data[code[vpc + (27)]] = (string)data[code[vpc + (-18)]] + (string)data[code[vpc + (7)]];
                vpc += 62;
                break;
            case 9315:
                data[code[vpc + (25)]] = (string)data[code[vpc + (-19)]] + (int)data[code[vpc + (-12)]];
                vpc += 61;
                break;
            case 2621:
                data[code[vpc + (27)]] = (int)data[code[vpc + (-20)]] < (int)data[code[vpc + (-10)]];
                vpc += 64;
                break;
            case 8652:
                data[code[vpc + (-8)]] = (bool)data[code[vpc + (2)]] ? (int)data[code[vpc + (-15)]] : (int)data[code[vpc + (-13)]];
                vpc += (int)data[code[vpc + (-8)]];
                break;
            case 3539:
                data[code[vpc + (6)]] = (int)data[code[vpc + (26)]] + (int)data[code[vpc + (-1)]];
                vpc += 61;
                break;
            case 3710:
                data[code[vpc + (1)]] = data[code[vpc + (-1)]];
                vpc += 62;
                break;
            case 9399:
                data[code[vpc + (3)]] = (string[])(new string[(int)data[code[vpc + (1)]]]);
                vpc += 58;
                break;
        }
    }

    return null;
}

private object InstanceInterpreterVirtualization_CodeLoopTests_3525(int vpc, object[] data, int[] code)
{
    while (true)
    {
        switch (code[vpc])
        {
            case 8705:
                data[code[vpc + (20)]] = (bool)data[code[vpc + (19)]] ? (int)data[code[vpc + (-10)]] : (int)data[code[vpc + (18)]];
                vpc += (int)data[code[vpc + (20)]];
                break;
            case 9203:
                data[code[vpc + (29)]] = ((string[])data[code[vpc + (-1)]]).Length;
                vpc += 65;
                break;
            case 4515:
                data[code[vpc + (-18)]] = ReturnArg((int)data[code[vpc + (29)]]);
                vpc += 68;
                break;
            case 8182:
                data[code[vpc + (26)]] = (int)data[code[vpc + (-13)]] + (int)data[code[vpc + (21)]];
                vpc += 53;
                break;
            case 5576:
                data[code[vpc + (-2)]] = (int)data[code[vpc + (27)]] < (int)data[code[vpc + (28)]];
                vpc += 67;
                break;
            default:
                data[code[vpc + (-14)]] = data[code[vpc + (18)]];
                vpc += 63;
                break;
            case 2484:
                data[code[vpc + (1)]] = (string)data[code[vpc + (-17)]] + (string)data[code[vpc + (-9)]];
                vpc += 67;
                break;
            case 8315:
                ((string[])data[code[vpc + (19)]])[(int)data[code[vpc + (15)]]] = (string)data[code[vpc + (4)]];
                vpc += 63;
                break;
            case 1325:
                vpc += (int)data[code[vpc + (-17)]];
                vpc += 58;
                break;
            case 4692:
                data[code[vpc + (-10)]] = (string[])(new string[(int)data[code[vpc + (-4)]]]);
                vpc += 58;
                break;
            case 1365:
                data[code[vpc + (20)]] = (string)data[code[vpc + (-9)]] + (int)data[code[vpc + (15)]];
                vpc += 71;
                break;
            case 9870:
                return (string)data[code[vpc + (8)]];
                vpc += 56;
        }
    }

    return null;
}
        #endregion

        


    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/BasicTests.cs
================================================
using System;
using System.CodeDom;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    class BasicTests
    {

        public static void RunBasicTests()
        {
            BasicTests bt = new BasicTests();
            //            bt.LocalVariables_Check();
            //            bt.OutParamTestString_Check();

            //            bt.OutParamSimple_Check();
            //            bt.RefParamSimple_Check();
            //            bt.BasicTypes_Check();
            //            bt.GenericsArray_Check();

            //            bt.StructSimple_Check();

//            Console.WriteLine("#ADDITION obfuscated result: " + bt.addition_obfuscated() + "\n");
//            Console.WriteLine("#ADDITION original result: " + bt.addition_original() + "\n");
        }

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string addition_obfuscated()
        {
            int a = 2;
            int b = 5;
            string sum = "" + (b - a);

            Console.WriteLine(sum);

            return sum;
        }

        private string addition_original()
        {
            int a = 2;
            int b = 5;
            string sum = "" + (b - a);

            Console.WriteLine(sum);

            return sum;
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string addition_0()
{
    int a = 2;
    int b = 5;
    int parTemp_0 = b - a;
    string sum = "" + parTemp_0;
    Console.WriteLine(sum);
    return sum;
}

        #region BASIC_TYPES
        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private double BasicTypes(int a, int b)
        {
            /* http://www.tutorialspoint.com/csharp/csharp_data_types.htm */
            short s = 2;
            decimal dec = 0.02M;
            float fl = 0.3f;
            long lg = 9223372036854775L;
            sbyte sb = 123;
            uint ui = 4000000000;
            ulong ul = 120L;
            ushort us = 65000;
            int d = 3, f = 5;    /* initializing d and f. */
            byte z = 22;         /* initializes z. */
            double pi = 3.14159; /* declares an approximation of pi. */
            char x = 'x';        /* the variable x has the value 'x'. */

            bool condition = false;

            if (a > b)
                condition = true;

            int sum = b + a;
            while (true)
            {
                sum = sum - 1;
                if (condition)
                    break;
                if (sum == 0)
                    break;
            }

            pi += s + fl + lg + sb + ui + ul + us + d + z + x;

            if (condition)
                sum += sum;
                        
            return pi + sum;
        }


        private double BasicTypes_0(int a, int b)
        {
            short s = 2;
            decimal dec = 0.02M;
            float fl = 0.3f;
            long lg = 9223372036854775L;
            sbyte sb = 123;
            uint ui = 4000000000;
            ulong ul = 120L;
            ushort us = 65000;
            int d = 3, f = 5;    /* initializing d and f. */
            byte z = 22;         /* initializes z. */
            double pi = 3.14159; /* declares an approximation of pi. */
            char x = 'x';        /* the variable x has the value 'x'. */

            bool condition = false;

            if (a > b)
                condition = true;

            int sum = b + a;
            while (true)
            {
                sum = sum - 1;
                if (condition)
                    break;
                if (sum == 0)
                    break;
            }

            pi += s + fl + lg + sb + ui + ul + us + d + z + x;

            if (condition)
                sum += sum;

            return pi + sum;
        }

        private void BasicTypes_Check()
        {
            string testName = "BasicTypes_Check";
            bool condition = true;
            Program.Start_Check(testName);

            int a = 3;
            int b = 4;
            bool cond1 = BasicTypes(a, b) == BasicTypes_0(a, b);
            bool cond2 = BasicTypes(b, a) == BasicTypes_0(b, a);
            condition = cond1 && cond2;

            Program.End_Check(testName, condition);
        }


        #endregion

        private int getValue(int integerValue)
        {
            return integerValue;
        }

        private double getValue(double doubleValue)
        {
            return doubleValue;
        }

        private static int getStaticValue(int integerValue)
        {
            return integerValue;
        }


        #region REF_PARAM_SIMPLE

        /**
         * Cannot replace ref/out parameters because it is possible that they are not initialized.
         * Additionally, there is not support to create and array of references.
         * http://www.dotnetperls.com/parameter
         * http://stackoverflow.com/questions/7472278/c-sharp-array-of-references
         */

//        [Obfuscation(Exclude = false, Feature = "local virt")]
        private void RefParamSimple(string value, ref int length, ref string text, ref int[] array, ref Car car)
        {
            length = value.Length;
            text = "text";
            array = new[] {123};
            car = new Car("car", 1);
        }

        private void SetValue(int value, ref int dest)
        {
            dest = value;
        }
        private void RefParam_1(string value, ref int length)
        {
            object[] dataObject = new object[10];            
            
            //when virtualized:           
            dataObject[1] = length;

//            SetValue(value.Length, ref  ((int) dataObject[1])); // compiler error.
//            SetValue(value.Length, ref dataObject[1]);          // compiler error.
        }

        private void RefParamSimple_0(string value, ref int length, ref string text, ref int[] array, ref Car car)
        {
            length = value.Length;
            text = "text";
            array = new[] { 123 };
            car = new Car("car", 1);
        }

        private void RefParamSimple_Check()
        {
            Console.WriteLine("\nStart RefParamSimple_Check");
            string input = "abcd";
            
            Car car1 = null;
            Car car2 = new Car("car2", 2);
            int[] array1 = { 1, 2, 3 };
            int[] array2 = { 11, 2, 3 };
            int l1 = 0;
            int l2 = 1;
            string s1 = null;
            string s2 = "a";
            RefParamSimple(input, ref l1, ref s1, ref array1, ref car1);
            RefParamSimple_0(input, ref l2, ref s2, ref array2, ref car2);

            bool condition = (l1 == l2) && (s1.Equals(s2)) && (array1[0]==array2[0]) && (car1.Equals(car2));

            if (!condition)
            {
                throw new Exception("RefParamSimple_Check fail");
            }
            Console.WriteLine("RefParamSimple_Check - " + condition);
            Console.WriteLine("---------------");
        }

//        private void RefParamSimple1(string value, ref int length, ref string text)
//        {
//            uint[] array = new uint[210];
//            array[0] = 211u;
//            object[] array2 = new object[52];
//            int num = -1;
//            num++;
//            array2[1] = "text";
//            array2[0] = value;
//            array2[2] = text;
//            length = ((string)array2[0]).Length;
//            text = (string)array2[1];
//            //array2[2] = (string)array2[1]; //cannot do this!!
//        }


        #endregion

        #region OUT_PARAM_SIMPLE
//        [Obfuscation(Exclude = false, Feature = "local virt")]
        private void OutParamSimple(string value, out int length, out string text, out int[] array, out Car car)
        {            
            length = value.Length;
            text = "text";
            array = new[] { 123 };
            car = new Car("car", 1);
        }

        private void OutParamSimple_0(string value, out int length, out string text, out int[] array, out Car car)
        {
            length = value.Length;
            text = "text";
            array = new[] { 123 };
            car = new Car("car", 1);
        }

        private void OutParamSimple_Check()
        {
            Console.WriteLine("\nStart OutParamSimple_Check");
            string input = "abcd";
            Car car1 ;
            Car car2 ;
            int[] array1 ;
            int[] array2 ;
            int l1;
            string s1;
            int l2;
            string s2;
            OutParamSimple(input, out l1, out s1, out array1, out car1);
            OutParamSimple_0(input, out l2, out s2, out array2, out car2);

            bool condition = (l1 == l2) && (s1.Equals(s2)) && (array1[0] == array2[0]) && (car1.Equals(car2));

            if (!condition)
            {
                throw new Exception("OutParamSimple_Check fail");
            }
            Console.WriteLine("OutParamSimple_Check - " + condition);
            Console.WriteLine("---------------");
        }

        // ConsoleCalculator.BasicTests
//        private void OutParamSimple1(string value, out int length, out string text)
//        {
//            uint[] array = new uint[210];
//            array[0] = 211u;
//            object[] array2 = new object[52];
//            int num = -1;
//            num++;
//            array2[1] = "text";
//            array2[0] = value;
//            array2[2] = text; //cannot do this - param not initialized!!
//            length = ((string)array2[0]).Length;
//            text = (string)array2[1];
//        }


        #endregion

        #region OUT_PARAM
        //TODO: test out param - done
//        [Obfuscation(Exclude = false, Feature = "local virt")]
        private void OutParamTestString(string value, out bool period, out bool comma, out bool semicolon)
        {
            // Assign all out parameters to false.
            period = comma = semicolon = false;

            for (int i = 0; i < value.Length; i++)
            {
                switch (value[i])
                {
                    case '.':
                        {
                            period = true; // Set out parameter.
                            break;
                        }
                    case ',':
                        {
                            comma = true; // Set out parameter.
                            break;
                        }
                    case ';':
                        {
                            semicolon = true; // Set out parameter.
                            break;
                        }
                }
            }
        }

        private void OutParamTestString_0(string value, out bool period, out bool comma, out bool semicolon)
        {
            // Assign all out parameters to false.
            period = comma = semicolon = false;

            for (int i = 0; i < value.Length; i++)
            {
                switch (value[i])
                {
                    case '.':
                        {
                            period = true; // Set out parameter.
                            break;
                        }
                    case ',':
                        {
                            comma = true; // Set out parameter.
                            break;
                        }
                    case ';':
                        {
                            semicolon = true; // Set out parameter.
                            break;
                        }
                }
            }
        }

        /** http://www.dotnetperls.com/out */
        private void OutParamTestString_Check()
        {
            Console.WriteLine("\nStart OutParamTestString_Check");
            const string value = "has period, comma."; // Used as input string.
            bool period; // Used as out parameter.
            bool comma;
            bool semicolon;            
            OutParamTestString(value, out period, out comma, out semicolon);
            bool period0;
            bool comma0;
            bool semicolon0;
            OutParamTestString_0(value, out period0, out comma0, out semicolon0);
            bool condition = (period == period0) && (comma == comma0) && (semicolon == semicolon0);

            if (!condition)
            {
                throw new Exception("OutParamTestString_Check fail");
            }
            Console.WriteLine("OutParamTestString_Check - " + condition);
            Console.WriteLine("---------------");
        }

        #endregion


        #region LOCAL_VAR
        //TODO: test this - done
        //TODO: test load int - done
        //TODO: test load string - done
        //TODO: test static method - done

//        [Obfuscation(Exclude = false, Feature = "local virt")]
        private string LocalVariables(string a, string b)
        {
            string local1 = a;
            string local2 = b;
//            int local3 = getValue(11);
//            int local4 = getStaticValue(12);

            string sum = "";

            int comp = sum.Length > 10 ? 20 - (a.ToLower().Equals(b)?1:b.Length) : a.Length + 5;

//            if (sum.Length > comp)
//            {
//                local1 = local1 + 1;
//            }
//                
//            else
//            {
//                local2 = local1;
//            }

            sum = sum + local1 + local2 + comp;
//            sum -= local3 + local4;
            Console.WriteLine("virt- "+sum);
            return sum;
        }

        private string LocalVariables_1(string a, string b)
        {
            string local1 = a;
            string local2 = b;
            //            int local3 = getValue(11);
            //            int local4 = getStaticValue(12);

            string sum = "";
            int comp = sum.Length > 10 ? 20 - (a.ToLower().Equals(b) ? 1 : b.Length) : a.Length + 5;
//            if (sum.Length > comp)
//            {
//                local1 = local1 + 1;
//            }
//
//            else
//            {
//                local2 = local1;
//            }

            sum = sum + local1 + local2 + comp;

            Console.WriteLine("virt- " + sum);
            return sum;
        }

        private string LocalVariables_0(string a, string b)
        {
            uint[] code = new uint[15];            
            object[] data = new object[62];
//            object[] data2 = new object[62];  
            int vpc = -1;
            vpc++;

            data[0] = a;
            data[1] = b;
            

//            data2[0] = a;
//            data2[1] = b;
            string local1 = a;
            string local2 = b;
//            int local3 = getValue(11);
//            int local4 = getStaticValue(12);

            code[0] = 2; //destionation
            code[1] = 0; //source 1
            code[2] = 1; //source 2
            code[3] = 2; //result

            code[4] = 1;
            code[5] = 0;
            
            Console.WriteLine();
//            int x = 0;
//
//            Console.WriteLine(x);           
//
//            Console.WriteLine(testData[x++]);
//            Console.WriteLine(x);
//            Console.WriteLine(testData[x++]);
//            Console.WriteLine(x);
//
//            int c = vpc;
//            Console.WriteLine("vpc init: "+ vpc);
            //int sum = local1 + local2 + a;
//            int v1 = (int) testData[code[vpc++]];
//            int v2 = (int) testData[code[vpc++]];
//            Console.WriteLine(v1);
//            Console.WriteLine(v2);
//            testData[code[vpc++]] = v1 + v2+ a;
            Console.WriteLine("testData: " + String.Join(",", new List<object>(data).ConvertAll(i => i == null ? " " : i.ToString()).ToArray()));
            data[code[vpc++]] = (string)data[code[vpc++]] + (string)data[code[vpc++]] + b + a;
            Console.WriteLine("testData: " + String.Join(",", new List<object>(data).ConvertAll(i => i == null ? " " : i.ToString()).ToArray()));
//            testData[code[vpc++]] = (string)testData[code[vpc++]] + (string)testData[code[vpc++]];
//            Console.WriteLine("testData: " + String.Join(",", new List<object>(testData).ConvertAll(i => i == null ? " " : i.ToString()).ToArray()));

//            Console.WriteLine();
            Console.WriteLine();
//            Console.WriteLine("vpc: "+ vpc + " - "+ testData[code[vpc]] );
//            Console.WriteLine("testData: " + String.Join(",", new List<object>(testData).ConvertAll(i => i==null?"":i.ToString()).ToArray()));
            Console.WriteLine("code: " + String.Join(",", new List<uint>(code).ConvertAll(i => i==0?" ":i.ToString()).ToArray()));


//            testData[code[c++]] = (int)testData[code[c++]] + (int)testData[code[c++]] + a;
//            Console.WriteLine("data2: " + String.Join(",", new List<object>(data2).ConvertAll(i => i == null ? "" : i.ToString()).ToArray()));
//            int v1 = (int) data2[code[c++]];
//            int v2 = (int) data2[code[c++]];
//            Console.WriteLine(v1);
//            Console.WriteLine(v2);
////            testData[code[c++]] = (int)testData[code[c++]] + (int)testData[code[c++]] + a;
//            data2[code[c++]] = v1 + v2 + a;
//            Console.WriteLine("data2: " + String.Join(",", new List<object>(data2).ConvertAll(i => i == null ? "" : i.ToString()).ToArray()));
//            Console.WriteLine("c: "+ data2[code[c]]);

//            if (sum > 9)
//            {
//                local1 = local1 + 1;
//            }
//
//            else
//            {
//                local2 = local1;
//            }
//
//            sum = sum - local1 - local2;
//            sum -= local3 + local4;

//            int sum = (int) testData[code[vpc++]];
//            Console.WriteLine("0- " + sum);
//            return sum;
            Console.WriteLine("0- " + data[code[vpc]]);
            return (string)data[code[vpc++]];
        }

        private void LocalVariables_Check()
        {
            string testName = "LocalVariables_Check";
            bool condition = true;
            Program.Start_Check(testName);
            string a = "a";
            string b = "b";
            string virt = LocalVariables(a,b);
            string oracle = LocalVariables_1(a,b);
            condition = virt.Equals(oracle);
            Program.End_Check(testName,condition);
        }


       

        #endregion


        #region GENERICS
        
        public class MyGenericArray<T>
        {
            private T[] array;
            
            public MyGenericArray(int size)
            {
                array = new T[size + 1];
            }

//            [Obfuscation(Exclude = false, Feature = "local virt")]
            public T getItem(int index)
            {
                var in2 = index + 1;
                in2 = index - in2;
                index = index + 1 - in2 - 1;
                return array[index];
            }


            public T getItem1(int index)
            {
                uint[] array = new uint[225];
                array[0] = 226u;
                object[] array2 = new object[54];
                int num = -1;
                num++;
                array2[1] = 1;
                array2[0] = index;
                array2[3] = this;
                int num2 = 0;
                array2[2] = num2;
                object obj = (int)array2[0] + (int)array2[1];
                array2[2] = obj;
                obj = (int)array2[0] - (int)array2[2];
                array2[2] = obj;
                obj = (int)array2[0] + (int)array2[1] - (int)array2[2] - (int)array2[1];
                array2[0] = obj;
                return ((BasicTests.MyGenericArray<T>)array2[3]).array[(int)array2[0]];
            }

//            [Obfuscation(Exclude = false, Feature = "local virt")]
            public void setItem(int index, T value)
            {
                array[index] = value;
            }
    }

        public class MyGenericArray_0<T>
        {
            private T[] array;

            public MyGenericArray_0(int size)
            {
                array = new T[size + 1];
            }
            
            public T getItem(int index)
            {
                var in2 = index + 1;
                in2 = index - in2;
                index = index + 1 - in2 - 1;
                return array[index];
            }

            public void setItem(int index, T value)
            {
                array[index] = value;
            }
   }

//         [Obfuscation(Exclude = false, Feature = "local virt")]
        private int GenericsArray()
         {           
            int result = 0;
            MyGenericArray<int> intArray = new MyGenericArray<int>(5);
            for (int c = 0; c < 5; c++)
            {
                intArray.setItem(c, c * 5);
            }            
            for (int c = 0; c < 5; c++)
            {
                result += intArray.getItem1(c);
            }
                        
            MyGenericArray<char> charArray = new MyGenericArray<char>(5);
            for (int c = 0; c < 5; c++)
            {
                charArray.setItem(c, (char)(c + 97));
            }
            for (int c = 0; c < 5; c++)
            {
                result += charArray.getItem1(c);
            }
            
            return result;
        }

        private int GenericsArray_0()
        {
            int result = 0;
            MyGenericArray<int> intArray = new MyGenericArray<int>(5);
            for (int c = 0; c < 5; c++)
            {
                intArray.setItem(c, c * 5);
            }
            for (int c = 0; c < 5; c++)
            {
                result += intArray.getItem(c);
            }

            MyGenericArray<char> charArray = new MyGenericArray<char>(5);
            for (int c = 0; c < 5; c++)
            {
                charArray.setItem(c, (char)(c + 97));
            }
            for (int c = 0; c < 5; c++)
            {
                result += charArray.getItem(c);
            }

            return result;
        }

        private void GenericsArray_Check()
        {
            string testName = "GenericsArray_Check";
            Program.Start_Check(testName);
            bool condition = false;

            int r1 = GenericsArray();
            int r2 = GenericsArray_0();
            condition = r1 == r2;
            Program.End_Check(testName,condition);
        }


        #endregion

        #region STRUCT

        struct Data
        {            
            public double LastValue;
        };

        struct Simple
        {
            public int Position;
            public bool Exists;
            public double LastValue;
            
            int _x;
            public int X
            {
                get { return _x; }
                set
                {
                    if (value < 10)
                    {
                        _x = value;
                    }                    
                }
            }
        };

        //TODO: not working for structures
//        [Obfuscation(Exclude = false, Feature = "virtualization; method; ")]
        static double StructSimple()
        {
            double result = 0;
            Data d;
            d.LastValue = 115;
            Simple s = new Simple();
            s.Position = 1;
            s.Exists = false;
            s.LastValue = 5.5;
            s.X = 20;

            result += s.Position + s.LastValue + s.X;
            s.X = 4;
            result += s.X + d.LastValue;

            return result;
        }

        static double StructSimple_0()
        {
            double result = 0;

            Data d;
            d.LastValue = 115;

            Simple s = new Simple();
            s.Position = 1;
            s.Exists = false;
            s.LastValue = 5.5;
            s.X = 20;

            result += s.Position +  s.LastValue + s.X;
            s.X = 4;
            result += s.X + d.LastValue;

            return result;
        }
      
        private void StructSimple_Check()
        {
            string testName = "StructSimple_Check";
            bool condition = true;
            Program.Start_Check(testName);

            double virt = StructSimple();
            double oracle = StructSimple_0();
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }


        #endregion


       

    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/BranchTests.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading.Tasks;
using System.Xml.XPath;

namespace ConsoleCalculator
{
    enum Priority
    {
        Zero,
        Low,
        Medium,
        Important,
        Critical
    };

    enum PriorityInt
    {
        ZeroInt = 0,
        LowInt = 2,
        MediumInt = 4,
        ImportantInt = 6,
        CriticalInt = 8
    }



    internal class BranchTests
    {
        //TODO: test branching - done

        public static void RunBranchTests()
        {
            BranchTests bt = new BranchTests();

//                        bt.CheckSimpleIfStatement();
            //
//                        bt.NestedIfStatement_Check(12);
//                        bt.NestedIfStatement_Check(4);
//                        bt.NestedIfStatement_Check(0);
//                        bt.NestedIfStatement_Check(2);
            //
//                        bt.ChainIf_Check(1);
//                        bt.ChainIf_Check(2);
//                        bt.ChainIf_Check(3);
//                        bt.ChainIf_Check(4);
//                        bt.ChainIf_Check(5);

            //            bt.SimpleSwitch_Check();
            //            bt.CharSwitch_Check();
            //            bt.EnumSwitch_Check();
            //            bt.StringSwitch_Check();

        }

        #region SIMPLE_IF

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private int SimpleIfStatement_0true()
        {
            int sum = 1 + 4;

            if (sum > 4)
            {
                sum += 10;
            }
            else
            {
                sum -= 20;
            }

            return sum;
        }

        private int SimpleIfStatement_1true()
        {

            int sum = 1 + 4;

            if (sum > 4)
            {
                sum += 10;
            }
            else
            {
                sum -= 20;
            }

            return sum;
        }

//        [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
        private int SimpleIfStatement_0false()
        {
            int sum = 1 + 3;

            if (sum > 4)
            {
                sum += 10;
            }
            else
            {
                sum -= 20;
            }

            return sum;
        }

        private int SimpleIfStatement_1false()
        {

            int sum = 1 + 3;

            if (sum > 4)
            {
                sum += 10;
            }
            else
            {
                sum -= 20;
            }

            return sum;
        }

        private void CheckSimpleIfStatement()
        {
            string testName = "SimpleIfStatement_true";

            Program.Start_Check(testName);
            int virt1 = SimpleIfStatement_0true();
            int oracle1 = SimpleIfStatement_1true();
            bool condition1 = virt1 == oracle1;
            Program.End_Check(testName, condition1);

            testName = "SimpleIfStatement_false";
            Program.Start_Check(testName);
            int virt2 = SimpleIfStatement_0false();
            int oracle2 = SimpleIfStatement_1false();
            bool condition2 = virt2 == oracle2;
            Program.End_Check(testName, condition2);
        }

        #endregion

        #region NESTED_IF

//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private int NestedIfStatement_0(int sum1)
    {
            int sum = sum1 + 2;

            if (sum > 4)
            {
                sum += 10;
                if (sum < 20)
                {
                    sum += 30;
                }
                else
                {
                    sum -= 15;
                }
            }
            else
            {
                sum -= 20;
                if (sum < -17)
                {
                    sum += 310;
                }
                else
                {
                    sum -= 115;
                }

            }

            return sum;
        }

        private int NestedIfStatement_1(int sum1)
        {

            int sum = sum1 + 2;

            if (sum > 4)
            {
                sum += 10;
                if (sum < 20)
                {
                    sum += 30;
                }
                else
                {
                    sum -= 15;
                }
            }
            else
            {
                sum -= 20;
                if (sum < -17)
                {
                    sum += 310;
                }
                else
                {
                    sum -= 115;
                }

            }

            return sum;
        }

        private void NestedIfStatement_Check(int sum)
        {
            string testName = "NestedIfStatement_" + sum;
            Program.Start_Check(testName);
            int virt = NestedIfStatement_0(sum);
            int oracle = NestedIfStatement_1(sum);
            bool condition1 = virt == oracle;
            Program.End_Check(testName, condition1);
        }

        #endregion

        #region CHAIN_IF
//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        public int ChainIf_0(int arg)
        {
            int key = arg;
            int ret = 0;
            if (key == -2)
            {
                Console.WriteLine(arg);
                ret = 2;
            }
            else if (key == 3)
                ret = 3;
            else if (key == 4)
            {
                ret = 5;
            }
            else if (key == 5)
                return key;
            else
                ret = 100;
            return ret;
        }


        public int ChainIf_1(int arg)
        {
            int key = arg;
            int ret = 0;
            if (key == -2)
            {
                Console.WriteLine(arg);
                ret = 2;
            }
            else if (key == 3)
                ret = 3;
            else if (key == 4)
            {
                ret = 5;
            }
            else if (key == 5)
                return key;
            else
                ret = 100;
            return ret;
        }

        private void ChainIf_Check(int sum)
        {
            string testName = "ChainIf_" + sum;
            Program.Start_Check(testName);
            int virt = ChainIf_0(sum);
            int oracle = ChainIf_1(sum);
            bool condition1 = virt == oracle;
            Program.End_Check(testName, condition1);
        }

        #endregion

        #region SIMPLE_SWITCH
//        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private int SimpleSwitch_0()
        {
            int value = 5;
            int result = 0;
            switch (value + 1 * 3)
            {
                case 0 + 2:                                   
                case 1:
                {
                        result = 1;
                        do
                        {
                            break;
                        } while (false);
                    }
                    break ;
                case 5:
                    result = 5;
                    
                    break;
                case 6:
                default:
                    result = 6;
                    break;
            }
            return result;
        }

        private int SimpleSwitch_1()
        {
            int value = 5;
            int result = 0;
            switch (value + 1 * 3)
            {
                case 0 + 2:
                case 1:
                    {
                        result = 1;
                        do
                        {
                            break;
                        } while (false);
                    }
                    break;
                case 5:
                    result = 5;

                    break;
                case 6:
                default:
                    result = 6;
                    break;
            }
            return result;
        }

        private void SimpleSwitch_Check()
        {
            string testName = "SimpleSwitch_Check";
            Program.Start_Check(testName);
            int a = 3;
            int b = 3;
            int virt = SimpleSwitch_0();
            int oracle = SimpleSwitch_1();
            bool condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region SWITCH_CHAR

//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private int CharSwitch(string input, int index)
        {            
            int result = -2;

            switch (input[index])
            {
                case 'a':
                    result = 0;
                    break;
                case 'b':
                    result = 1;
                    break;
                case 'c':
                    result = 2;
                    break;
                default:
                    result = -1;
                    break;
            }
            return result;
        }

        private int CharSwitch_0(string input, int index)
        {
            int result = -2;

            switch (input[index])
            {
                case 'a':
                    result = 0;
                    break;
                case 'b':
                    result = 1;
                    break;
                case 'c':
                    result = 2;
                    break;
                default:
                    result = -1;
                    break;
            }
            return result;
        }

        private void CharSwitch_Check()
        {            
            string testName = "CharSwitch_Check";
            Program.Start_Check(testName);
            string input = "abc";
            int index = 0;
            int virt = CharSwitch(input, index);
            int oracle = CharSwitch_0(input, index);
            bool condition = virt == oracle;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region SWITCH_ENUM
//        [Obfuscation(Exclude = false, Feature = "virtualization; class")]
        private PriorityInt EnumSwitch(Priority priority)
        {
            // Switch on the Priority enum.
            switch (priority)
            {
                case Priority.Low:
                    return PriorityInt.LowInt;
                case Priority.Medium:
                    return PriorityInt.MediumInt;
                case Priority.Zero:                    
                default:
                    return PriorityInt.ZeroInt;
                case Priority.Important:
                case Priority.Critical:
                    return PriorityInt.CriticalInt;
            }
        }

        private PriorityInt EnumSwitch_0(Priority priority)
        {
            // Switch on the Priority enum.
            switch (priority)
            {
                case Priority.Low:
                    return PriorityInt.LowInt;
                case Priority.Medium:
                    return PriorityInt.MediumInt;
                case Priority.Zero:
                default:
                    return PriorityInt.ZeroInt;
                case Priority.Important:
                case Priority.Critical:
                    return PriorityInt.CriticalInt;
            }
        }

        private void EnumSwitch_Check()
        {
            string testName = "EnumSwitch_Check";
            Program.Start_Check(testName);
            Priority p1 = Priority.Low;
            Priority p2 = Priority.Critical;
            PriorityInt virt1 = EnumSwitch(p1);
            PriorityInt oracle1 = EnumSwitch_0(p1);
            PriorityInt virt2 = EnumSwitch(p2);
            PriorityInt oracle2 = EnumSwitch_0(p2);
            
            bool condition = (virt1 == oracle1) && (virt2==oracle2);
            Program.End_Check(testName, condition);
        }

        #endregion

        #region SWITCH_STRING
//        [Obfuscation(Exclude = false, Feature = "virtualization; class")]
        int StringSwitch(string month)
        {
            switch (month.ToLower())
            {
                case "march":
                    return 3;
                case "april":
                    return 4;
                case "may":
                    return 5;
                case "sulimov dog":
                case "whippet":
                case "eurasier":
                case "brittany":
                    return 0;
                default:
                    return -1;
            }
        }

        int StringSwitch_0(string month)
        {
            switch (month.ToLower())
            {
                case "march":
                    return 3;
                case "april":
                    return 4;
                case "may":
                    return 5;
                case "sulimov dog":
                case "whippet":
                case "eurasier":
                case "brittany":
                    return 0;
                default:
                    return -1;
            }
        }

        private void StringSwitch_Check()
        {            

            string testName = "StringSwitch_Check";
            bool condition = false;
            Program.Start_Check(testName);

            string input1 = "March";
            string input2 = "december";            
            int virt1 = StringSwitch(input1);
            int oracle1 = StringSwitch_0(input1);
            bool condition1 = virt1 == oracle1;
            int virt2 = StringSwitch(input2);
            int oracle2 = StringSwitch_0(input2);
            bool condition2 = virt2 == oracle2;
            condition = condition1 && condition2;
            Program.End_Check(testName, condition);
        }

        #endregion


        


    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/ConditionalExpressionTests.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator.VirtData
{
    internal class ConditionalExpressionTests
    {

        public enum CreditCardCompany
        {
            MasterCard,
            Visa,
            Amex,
            DinersClub,
            Unknown
        }

        public static void RunBasicTests()
        {
//            new ConditionalExpressionTests().checkConditional();

//            new ConditionalExpressionTests().checkEnum();
        }

        
        private string Conditional_original()
        {
            string value = CreditCardCompany.Amex + "";

            if (value.Length > 0)
            {
                value += " ";
                value += CreditCardCompany.MasterCard;
                value += " ";
            }

            return value;
        }

        [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
        private string Conditional_obfuscated()
        {
            string value = CreditCardCompany.Amex + "";

            if (value.Length > 0)
            {
                value += " ";
                value += CreditCardCompany.MasterCard;
                value += " ";
            }

            return value;
        }

        public void checkConditional()
        {
            string testName = "Code#Conditional_Check";
            bool condition = true;
            Program.Start_Check(testName);

            string virt = Conditional_obfuscated();
            string oracle = Conditional_original();
            Console.WriteLine(testName + " => " + virt + " vs " + oracle);
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }




        private string Enum_original()
        {
            int value = 3 + 2;

            string data = "a" + (value > 2 ? "t" : "f");

            return data;
        }

        //        [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
        private string Enum_obfuscated()
        {
            int value = 3 + 2;

            string data = "a" + (value > 2 ? "t" : "f");

            return data;
        }

        public void checkEnum()
        {
            string testName = "Code#Enum_Check";
            bool condition = true;
            Program.Start_Check(testName);

            string virt = Conditional_obfuscated();
            string oracle = Conditional_original();
            Console.WriteLine(testName + " => " + virt + " vs " + oracle);
            condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }
    }
}



================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/DelegatesTests.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

delegate int NumberChanger(int n);
namespace ConsoleCalculator
{
    internal class DelegatesTests
    {
        #region DELEGATE_SIMPLE

        private static int num = 10;

        public static int AddNum(int p)
        {
            num += p;
            return num;
        }

        public static int MultNum(int q)
        {
            num *= q;
            return num;
        }

        public static int getNum()
        {
            return num;
        }

        private NumberChanger ncField = delegate(int x)
        {
            int lnc = 155;
            lnc += x;
            return lnc;
        }

            ;

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private int DelegateSimple()
        {
            int localVar = 33;
            //create delegate instances
            NumberChanger nc = delegate(int x)
            {
                int lnc = 12;
                lnc += x;
                lnc += num;
                lnc += localVar;
                localVar = 22;
                return lnc;
            }

                ;
            NumberChanger nc1 = new NumberChanger(AddNum);
            NumberChanger nc2 = new NumberChanger(MultNum);
            nc += nc1;
            nc += nc2;
            nc += ncField;
            //calling the methods using the delegate objects
            nc1(25);
            int r1 = getNum();
            nc2(5);
            int r2 = getNum();
            nc(5);
            int r3 = getNum();
            return r1 + r2 + r3 + localVar;
        }

        private int DelegateSimple_0()
        {
            //create delegate instances
            int localVar = 33;
            //create delegate instances
            NumberChanger nc = delegate(int x)
            {
                int lnc = 12;
                lnc += x;
                lnc += num;
                lnc += localVar;
                localVar = 22;
                return lnc;
            }

                ;
            NumberChanger nc1 = new NumberChanger(AddNum);
            NumberChanger nc2 = new NumberChanger(MultNum);
            nc += nc1;
            nc += nc2;
            nc += ncField;
            //calling the methods using the delegate objects
            nc1(25);
            int r1 = getNum();
            nc2(5);
            int r2 = getNum();
            nc(5);
            int r3 = getNum();
            return r1 + r2 + r3 + localVar;
        }

        private void DelegateSimple_Check()
        {
            string testName = "DelegateSimple_Check";
            Program.Start_Check(testName);
            DelegatesTests.num = 10;
            int r1 = DelegateSimple();
            DelegatesTests.num = 10;
            int r2 = DelegateSimple_0();
            bool condition = r1 == r2;
            Program.End_Check(testName, condition);
        }

        #endregion

        public static void RunDelegatesTests()
        {
            DelegatesTests dt = new DelegatesTests();
            //            dt.DelegateSimple_Check();
        }
    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/ExceptionTests.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    internal class ExceptionTests
    {

        public static void RunExceptionTests()
        {
            ExceptionTests et = new ExceptionTests();

//            et.TryCatchSimple_Check();

//            et.TryCatchNested_Check();
            
        }

        class ExceptionA : Exception
        {
            protected ExceptionA(string message) : base(message)
            {                
            }

            public ExceptionA() : base("ExceptionA")
            {
            }
        }

        class ExceptionB : ExceptionA
        {
            public ExceptionB() : base("Exception B")
            { }
        }        

        public static void DivideException()
        {
            throw new DivideByZeroException();
        }

        public static void ThrowExceptionA() 
        {
            throw new ExceptionA();
        }

        public static void ThrowExceptionB()
        {
            throw new ExceptionB();
        }

        #region NESTED_TryCatch

//        [Obfuscation(Exclude = false, Feature = "virtualization; refactor; readable")]
        private string TryCatchNested_0(int a, int b)
        {
            string sum = ""+ a + b;
            try
            {                
                sum += b/a;
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine("divided by zero 0");
                try
                {
                    ThrowExceptionA();
                }
                catch (ExceptionA ea)
                {
                    sum += ea.Message;
                    return sum;
                }
                sum += 0;
            }
            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine("An index was out of range!");
            }
            catch (Exception ex)
            {
                Console.WriteLine("Some sort of error occured: " + ex.Message);
            }
            finally
            {
                sum += "finally";
            }
            return sum;
        }

        private string TryCatchNested_1(int a, int b)
        {
            string sum = "" + a + b;
            try
            {
                sum += b / a;
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine("divided by zero 0");
                try
                {
                    ThrowExceptionA();
                }
                catch (ExceptionA ea)
                {
                    sum += ea.Message;
                    return sum;
                }
                sum += 0;
            }
            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine("An index was out of range!");
            }
            catch (Exception ex)
            {
                Console.WriteLine("Some sort of error occured: " + ex.Message);
            }
            finally
            {
                sum += "finally";
            }
            return sum;
        }

        private void TryCatchNested_Check()
        {
            string testName = "Code#TryCatchNested_Check";
            Program.Start_Check(testName);
            int a = 0;
            int b = 3;
            string virt = TryCatchNested_0(a, b);
            string oracle = TryCatchNested_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            bool condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        #endregion



        #region SIMPLE_TryCatch

        //        [Obfuscation(Exclude = false, Feature = "virtualization; class; readable")]
        private string TryCatchSimple_0(int a, int b)
        {
            string sum = "" + a + b;
            try
            {
                sum += b / a;
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine("divided by zero 1");
                sum += "divided by zero 1";
            }
            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine("An index was out of range!");
                sum += "An index was out of range!";
            }
            catch (Exception ex)
            {
                Console.WriteLine("Some sort of error occured: " + ex.Message);
                sum += ex.Message;
            }
            finally
            {
                sum += "finally";
            }

            return sum;
        }


        private string TryCatchSimple_1(int a, int b)
        {
            string sum = "" + a + b;
            try
            {
                sum += b / a;
            }
            catch (DivideByZeroException)
            {
                Console.WriteLine("divided by zero 1");
                
                sum += "divided by zero 1";
            }
            catch (IndexOutOfRangeException ex)
            {
                Console.WriteLine("An index was out of range!");
                sum += "An index was out of range!";
            }
            catch (Exception ex)
            {
                Console.WriteLine("Some sort of error occured: " + ex.Message);
                sum += ex.Message;
            }
            finally
            {
                sum += "finally";
            }

            object[] data = new object[20];
            int[] code = new int[100];
            int vpc = 0;
            code[0] = 5;
            code[1] = 1;
            code[2] = 10;
            code[3] = 10;
            interpreter(vpc, data, code);
            return sum;
        }


        private object interpreter(int vpc, object[] data, int[] code)
        {

            while (true)
            {
                switch (code[vpc++])
                {
                    case 10:                        
                        DivideException();
                        vpc++;
                        break;                    
                    case 1:
                        try
                        {                            
                            return interpreter(vpc, data, code);
                        }
                        catch (DivideByZeroException ex)
                        {
//                            vpc = code[vpc]
                            data[code[vpc++]] = ex;                         
                            return interpreter(vpc, data, code);
                        }
                        finally
                        {
                            interpreter(vpc, data, code);
                        }
                    case 2:
                        try
                        {
                            return interpreter(vpc, data, code);
                        }
                        catch (IndexOutOfRangeException ex)
                        {
                            //                            testData[code[vpc++]] = ex;
                            return interpreter(vpc, data, code);
                        }
                        finally
                        {
                            interpreter(vpc, data, code);
                        }
                    case 3:
                        try
                        {                         
                            return interpreter(vpc, data, code);
                        }
                        catch (Exception ex)
                        {
                            //                            testData[code[vpc++]] = ex;
                            return interpreter(vpc, data, code);
                        }
                        finally
                        {
                            interpreter(vpc, data, code);
                        }
                    case 4: //finally
                        return interpreter(vpc, data, code);
                    case 5: //other operation
                        Console.WriteLine("operation 5");
                        
                        break;
                    case 6: //other operation 2
                        Console.WriteLine("operation 6");
                        break;
                }
//                return null;
            }
        }




        private void TryCatchSimple_Check()
        {
            string testName = "Code#TryCatchSimple_Check";
            Program.Start_Check(testName);
            int a = 0;
            int b = 3;
            string virt = TryCatchSimple_0(a, b);
            string oracle = TryCatchSimple_1(a, b);
            Console.WriteLine("virt {0} = {1} orig", virt, oracle);
            bool condition = virt.Equals(oracle);
            Program.End_Check(testName, condition);
        }

        

        #endregion

    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/ExtensionsTests.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    internal static class ExtensionsTests
    {
        ///
        /// http://www.dotnetperls.com/explode

        //////
        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        public static string[] Explode(this string value, int size)
        {
            // Number of segments exploded to except last.
            int count = value.Length/size;
            // Determine if we need to store a final segment.
            // ... Sometimes we have a partial segment.
            bool final = false;
            if ((size*count) < value.Length)
            {
                final = true;
            }

            // Allocate the array to return.
            // ... The size varies depending on if there is a final fragment.
            string[] result;
            if (final)
            {
                result = new string[count + 1];
            }
            else
            {
                result = new string[count];
            }

            // Loop through each index and take a substring.
            // ... The starting index is computed with multiplication.
            for (int i = 0; i < count; i++)
            {
                result[i] = value.Substring((i*size), size);
            }

            // Sometimes we need to set the final string fragment.
            if (final)
            {
                result[result.Length - 1] = value.Substring(count*size);
            }

            return result;
        }

        public static string[] Explode_0(this string value, int size)
        {
            // Number of segments exploded to except last.
            int count = value.Length/size;
            // Determine if we need to store a final segment.
            // ... Sometimes we have a partial segment.
            bool final = false;
            if ((size*count) < value.Length)
            {
                final = true;
            }

            // Allocate the array to return.
            // ... The size varies depending on if there is a final fragment.
            string[] result;
            if (final)
            {
                result = new string[count + 1];
            }
            else
            {
                result = new string[count];
            }

            // Loop through each index and take a substring.
            // ... The starting index is computed with multiplication.
            for (int i = 0; i < count; i++)
            {
                result[i] = value.Substring((i*size), size);
            }

            // Sometimes we need to set the final string fragment.
            if (final)
            {
                result[result.Length - 1] = value.Substring(count*size);
            }

            return result;
        }

        private static void Explode_Check()
        {
            Console.WriteLine("\nStart PrivateField_Check");
            const string input = "carrot chicken salad tomato";
            string[] explode1 = input.Explode(2);
            string[] explode2 = input.Explode_0(2);
            bool cond1 = explode1.Count() == explode2.Count();
            explode1 = input.Explode(3);
            explode2 = input.Explode_0(3);
            bool cond2 = explode1.Count() == explode2.Count();
            explode1 = input.Explode(4);
            explode2 = input.Explode_0(4);
            bool cond3 = explode1.Count() == explode2.Count();
            explode1 = input.Explode(103);
            explode2 = input.Explode_0(103);
            bool cond4 = explode1.Count() == explode2.Count();
            bool condition = cond1 && cond2 && cond3 && cond4;
            if (!condition)
            {
                throw new Exception("Explode_Check fail");
            }

            Console.WriteLine("Explode_Check - " + condition);
            Console.WriteLine("---------------");
        }

        public static void RunExtenstionTests()
        {
            //            ExtensionsTests.Explode_Check();
        }
    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/FieldTests.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    internal class FieldTests
    {
        #region PRIVATE_FIELD

        private static int intS = 0;
        private int intI = 1;
        private static string stringS = "text";
        private string stringI = "instance";
        private static Car carS = new Car("static-car", 10);
        private Car carI = new Car("instance-car", 20);
        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private void PrivateField(int doors, string id)
        {
            intS = doors*2;
            intI = 15;
            stringS = "static-" + id;
            stringI = stringS + id;
        }

        private void PrivateField_0(int doors, string id)
        {
            intS = doors*2;
            intI = 15;
            stringS = "static-" + id;
            stringI = stringS + id;
        }

        private void PrivateField_Check()
        {
            string testName = "PrivateField_Check";
            bool condition = false;
            int doors = 3;
            string id = "private-field";
            PrivateField(doors, id);
            int aux1 = intS;
            int aux2 = intI;
            string sAux1 = stringS;
            string sAux2 = stringI;
            PrivateField_0(doors, id);
            condition = (aux1 == intS) && (aux2 == intI) && (sAux1.Equals(stringS) && (sAux2.Equals(stringI)));
            Program.End_Check(testName, condition);
        }

        #endregion

        #region PROPERTY_INT

        private int _number;

        public int Number
        {
            get { return this._number; }

            set { this._number = value; }
        }

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private int IntProperty(int value)
        {
            FieldTests example = new FieldTests();
            example.Number = value;
            return example.Number;
        }

        private int IntProperty_0(int value)
        {
            FieldTests example = new FieldTests();
            example.Number = value;
            return example.Number;
        }

        private void IntProperty_Check()
        {
            string testName = "IntProperty_Check";
            bool condition = false;
            Program.Start_Check(testName);
            int value = 12;
            int r1 = IntProperty(value);
            int r2 = IntProperty_0(value);
            condition = r1 == r2;
            Program.End_Check(testName, condition);
        }

        #endregion

        #region PROPERTY_ENUM

        private DayOfWeek _day;

        public DayOfWeek Day
        {
            get
            {
                // We don't allow this to be used on Friday.
                if (this._day == DayOfWeek.Friday)
                {
                    throw new Exception("Invalid access");
                }

                return this._day;
            }

            set { this._day = value; }
        }

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private static DayOfWeek EnumProperty(DayOfWeek d)
        {
            FieldTests example = new FieldTests();
            example.Day = DayOfWeek.Monday;
            try
            {
                example.Day = d;
                Console.WriteLine(example.Day);
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
            finally
            {
                example.Day = DayOfWeek.Wednesday;
            }

            return example.Day;
        }

        private static DayOfWeek EnumProperty_0(DayOfWeek d)
        {
            FieldTests example = new FieldTests();
            example.Day = DayOfWeek.Monday;
            try
            {
                example.Day = d;
                Console.WriteLine(example.Day);
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
            finally
            {
                example.Day = DayOfWeek.Wednesday;
            }

            return example.Day;
        }

        private void EnumProperty_Check()
        {
            string testName = "EnumProperty_Check";
            bool condition = false;
            Program.Start_Check(testName);
            DayOfWeek value = DayOfWeek.Friday;
            DayOfWeek r1 = EnumProperty(value);
            DayOfWeek r2 = EnumProperty_0(value);
            condition = r1.Equals(r2);
            Program.End_Check(testName, condition);
        }

        private static DayOfWeek EnumProperty_1(DayOfWeek d)
        {
            uint[] array = new uint[230];
            array[0] = 231u;
            object[] array2 = new object[55];
            int num = -1;
            num++;
            array2[1] = 1;
            array2[4] = 3;
            array2[2] = d;
            FieldTests fieldTests = null;
            array2[0] = fieldTests;
            Exception ex = null;
            array2[3] = ex;
            object obj = new FieldTests();
            array2[0] = obj;
            ((FieldTests) array2[0]).Day = (DayOfWeek) ((int) array2[1]);
            try
            {
                ((FieldTests) array2[0]).Day = (DayOfWeek) array2[2];
                Console.WriteLine(((FieldTests) array2[0]).Day);
            }
            catch (Exception e)
            {
                array2[3] = e;
                Console.WriteLine((Exception) array2[3]);
            }
            finally
            {
                ((FieldTests) array2[0]).Day = (DayOfWeek) ((int) array2[4]);
            }

            return ((FieldTests) array2[0]).Day;
        }

        #endregion

        public static void RunFieldTests()
        {
            FieldTests ft = new FieldTests();
            //            ft.PrivateField_Check();
            //            ft.IntProperty_Check();
            //            ft.EnumProperty_Check();
        }
    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/FileOperations.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    internal class FileOperations
    {
        #region READ_FILE

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private static string ReadFile()
        {
            string fileLines = "";
            string fileName = "Values1.txt";
            try
            {
                StreamReader myReader = new StreamReader(fileName);
                string line = "";
                while (line != null)
                {
                    line = myReader.ReadLine();
                    if (line != null)
                    {
                        //Console.WriteLine(line);
                        fileLines += line;
                    }
                }

                myReader.Close();
            }
            catch (DirectoryNotFoundException e)
            {
                Console.WriteLine("Couldn't fine the file.  Are you sure the DIRECTORY exists?");
            }
            catch (FileNotFoundException e)
            {
                Console.WriteLine("Couldn't find the file.  Are you sure you're looking for the correct file? " + e);
            }
            catch (Exception e)
            {
                Console.WriteLine("Something didn't quite work correctly: {0}", e.Message);
            }
            finally
            {
                // Perform any cleanup to roll back the testData or close connections
                // to files, database, network, etc.
            }

            return fileLines;
        }

        private static string ReadFile_0()
        {
            string fileLines = "";
            string fileName = "Values1.txt";
            try
            {
                StreamReader myReader = new StreamReader(fileName);
                string line = "";
                while (line != null)
                {
                    line = myReader.ReadLine();
                    if (line != null)
                    {
                        //Console.WriteLine(line);
                        fileLines += line;
                    }
                }

                myReader.Close();
            }
            catch (DirectoryNotFoundException e)
            {
                Console.WriteLine("Couldn't fine the file.  Are you sure the DIRECTORY exists?");
            }
            catch (FileNotFoundException e)
            {
                Console.WriteLine("Couldn't find the file.  Are you sure you're looking for the correct file?");
            }
            catch (Exception e)
            {
                Console.WriteLine("Something didn't quite work correctly: {0}", e.Message);
            }
            finally
            {
                // Perform any cleanup to roll back the testData or close connections
                // to files, database, network, etc.
            }

            return fileLines;
        }

        private static void ReadFile_Check()
        {
            string testName = "ReadFile_Check";
            bool condition = false;
            Program.Start_Check(testName);
            string file1 = ReadFile();
            string file2 = ReadFile_0();
            condition = file1.Equals(file2);
            Program.End_Check(testName, condition);
        }

        #endregion

        public static void RunReadFileTests()
        {
            //            ReadFile_Check();
        }
   }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/LambdaTests.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    /**
     * http://www.dotnetperls.com/lambda     
     */

    internal class LambdaTests
    {

        #region LIST_INDEX_LAMBDA

//        [Obfuscation(Exclude = false, Feature = "local virt")]
        private int ListIndexLambda()
        {
            List<int> elements = new List<int>() {10, 20, 31, 40};
            // ... Find index of first odd element.
            int oddIndex = elements.FindIndex(x => x%2 != 0);
            return oddIndex;
        }

        private int ListIndexLambda_0()
        {
            List<int> elements = new List<int>() {10, 20, 31, 40};
            // ... Find index of first odd element.
            int oddIndex = elements.FindIndex(x => x%2 != 0);
            return oddIndex;
        }

        private void ListIndexLambda_Check()
        {
            string testName = "ListIndexLambda_Check";
            bool condition = false;
            Program.Start_Check(testName);

            int var1 = ListIndexLambda();
            int var2 = ListIndexLambda_0();
            condition = var1 == var2;

            Program.End_Check(testName, condition);
        }

        #endregion

        #region FUNCTION_LAMBDA

        /* http://www.dotnetperls.com/lambda */

//        [Obfuscation(Exclude = false, Feature = "local virt")]
        private int[] FunctionLambda()
        {
            //Virtualization variables
            int[] code = new int[3000];
            object[] data = new object[1500];
            int vpc = 0;

            //Data init
            data[0] = 10; //10
            data[1] = 0; //0
            data[2] = 1; //1
            data[3] = 2; //2
            data[4] = 3; //3
            data[5] = 4; //4
            data[6] = 5; //5
            data[7] = 6; //6
            data[8] = null; //result
            data[9] = null; //func1
            data[10] = null; //func2
            data[11] = null; //func3
            data[12] = null; //func4
            data[13] = null; //func5
            data[14] = null; //func6
            data[15] = null; //func7
            data[16] = null; //func8

            //Code init
            code[0] = 10; //
            code[1] = 8; //result
            code[2] = 0; //10
            code[3] = 11; //
            code[4] = 9; //func1
            code[5] = 12; //
            code[6] = 10; //func2
            code[7] = 13; //
            code[8] = 11; //func3
            code[9] = 14; //
            code[10] = 12; //func4
            code[11] = 15; //
            code[12] = 13; //func5
            code[13] = 16; //
            code[14] = 14; //func6
            code[15] = 17; //
            code[16] = 15; //func7
            code[17] = 18; //
            code[18] = 16; //func8
            code[19] = 19; //
            code[20] = 8; //result
            code[21] = 1; //0
            code[22] = 9; //func1
            code[23] = 2; //1
            code[24] = 19; //
            code[25] = 8; //result
            code[26] = 2; //1
            code[27] = 10; //func2
            code[28] = 3; //2
            code[29] = 19; //
            code[30] = 8; //result
            code[31] = 3; //2
            code[32] = 11; //func3
            code[33] = 4; //3
            code[34] = 19; //
            code[35] = 8; //result
            code[36] = 4; //3
            code[37] = 12; //func4
            code[38] = 5; //4
            code[39] = 20; //
            code[40] = 8; //result
            code[41] = 5; //4
            code[42] = 13; //func5
            code[43] = 6; //5
            code[44] = 7; //6
            code[45] = 21; //
            code[46] = 14; //func6
            code[47] = 19; //
            code[48] = 8; //result
            code[49] = 6; //5
            code[50] = 15; //func7
            code[51] = 2; //1
            code[52] = 22; //
            code[53] = 8; //result
            code[54] = 7; //6
            code[55] = 16; //func8
            code[56] = 23; //
            code[57] = 8; //result

            while (true)
            {
                switch (code[vpc++])
                {
                    case 10:
                        data[code[vpc++]] = (int[]) (new int[(int) data[code[vpc++]]]);
                        break;
                    case 11:
                        data[code[vpc++]] = (Func<int, int>) (x1 => x1 + 1);
                        break;
                    case 12:
                        data[code[vpc++]] = (Func<int, int>) (x2 =>
                        {
                            return x2 + 1;
                        }

                            );
                        break;
                    case 13:
                        data[code[vpc++]] = (Func<int, int>) ((int x3) => x3 + 1);
                        break;
                    case 14:
                        data[code[vpc++]] = (Func<int, int>) ((int x4) =>
                        {
                            return x4 + 1;
                        }

                            );
                        break;
                    case 15:
                        data[code[vpc++]] = (Func<int, int, int>) ((x5, y) => x5*y);
                        break;
                    case 16:
                        data[code[vpc++]] = (Action) (() => Console.WriteLine("func 6"));
                        break;
                    case 17:
                        data[code[vpc++]] = (Func<int, int>) (delegate(int x6)
                        {
                            return x6 + 1;
                        }

                            );
                        break;
                    case 18:
                        data[code[vpc++]] = (Func<int>) (delegate
                        {
                            return 1 + 1;
                        }

                            );
                        break;
                    case 19:
                        ((int[]) data[code[vpc++]])[(int) data[code[vpc++]]] =
                            ((Func<int, int>) data[code[vpc++]]).Invoke((int) data[code[vpc++]]);
                        break;
                    case 20:
                        ((int[]) data[code[vpc++]])[(int) data[code[vpc++]]] =
                            ((Func<int, int, int>) data[code[vpc++]]).Invoke((int) data[code[vpc++]],
                                (int) data[code[vpc++]]);
                        break;
                    case 21:
                        ((Action) data[code[vpc++]]).Invoke();
                        break;
                    case 22:
                        ((int[]) data[code[vpc++]])[(int) data[code[vpc++]]] = ((Func<int>) data[code[vpc++]]).Invoke();
                        break;
                    case 23:
                        return (int[]) data[code[vpc++]];
                    default:
                        break;
                }
            }

            return null;
        }

        private int[] FunctionLambda_0()
        {
            int[] result = new int[10];
            Func<int, int> func1 = x1 => x1 + 1;
            Func<int, int> func2 = x2 => { return x2 + 1; };
            Func<int, int> func3 = (int x3) => x3 + 1;
            Func<int, int> func4 = (int x4) => { return x4 + 1; };
            Func<int, int, int> func5 = (x5, y) => x5*y;
            Action func6 = () => Console.WriteLine("func 6");
            Func<int, int> func7 = delegate(int x6) { return x6 + 1; };
            Func<int> func8 = delegate { return 1 + 1; };

            result[0] = func1.Invoke(1);
            result[1] = func2.Invoke(2);
            result[2] = func3.Invoke(3);
            result[3] = func4.Invoke(4);
            result[4] = func5.Invoke(5, 6);
            func6.Invoke();
            result[5] = func7.Invoke(1);
            result[6] = func8.Invoke();

            return result;
        }

        private void FunctionLambda_Check()
        {
            string testName = "FunctionLambda_Check";
            bool condition = true;
            Program.Start_Check(testName);

            int[] var1 = FunctionLambda();
            int[] var2 = FunctionLambda_0();
            for (int i = 0; i < var1.Count(); i++)
            {
                if (var1[i] != var2[i])
                    condition = false;
            }

            Program.End_Check(testName, condition);
        }


        #endregion



        public static void RunLambdaTests()
        {
            LambdaTests lt = new LambdaTests();
//            lt.ListIndexLambda_Check();
//            lt.FunctionLambda_Check();
        }
   }

}



================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/ListInterfaces.cs
================================================
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    //    public interface IReadOnlyList<out T> : IReadOnlyCollection<T> {
    //    T this[int index] { get; }
    //    }
    //    public interface IReadOnlyCollection<out T> : IEnumerable<T> {
    //        int Count { get; }
    //    }
    //    public interface IEnumerable<out T> : IEnumerable {
    //        IEnumerator<T> GetEnumerator();
    //    }
    /*
     * http://twistedoakstudios.com/blog/Post774_anonymous-implementation-classes-a-design-pattern-for-c
     */
    public sealed class AnonymousReadOnlyList<T> : IReadOnlyList<T>
    {
        private readonly Func<int> _count;
        private readonly Func<int, T> _item;
        private readonly IEnumerable<T> _iterator;
        public AnonymousReadOnlyList(Func<int> count, Func<int, T> item, IEnumerable<T> iterator = null)
        {
            if (count == null)
                throw new ArgumentNullException("count");
            if (item == null)
                throw new ArgumentNullException("item");
            this._count = count;
            this._item = item;
            this._iterator = iterator ?? DefaultIterator(count, item);
        }

        private static IEnumerable<T> DefaultIterator(Func<int> count, Func<int, T> item)
        {
            var n = count();
            for (var i = 0; i < n; i++)
                yield return item(i);
        }

        public int Count
        {
            get
            {
                return _count();
            }
        }

        public T this[int index]
        {
            get
            {
                return _item(index);
            }
        }

        public IEnumerator<T> GetEnumerator()
        {
            return _iterator.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
}

    public static class ListInterfaces
    {
        public static IReadOnlyList<TOut> Select<TIn, TOut>(this IReadOnlyList<TIn> list, Func<TIn, TOut> projection)
        {
            return new AnonymousReadOnlyList<TOut>(count: () => list.Count, item: i => projection(list[i]),
                iterator: list.AsEnumerable().Select(projection));
        }

        public static IReadOnlyList<TOut> Select<TIn, TOut>(this IReadOnlyList<TIn> list,
            Func<TIn, int, TOut> projection)
        {
            return new AnonymousReadOnlyList<TOut>(count: () => list.Count, item: i => projection(list[i], i),
                iterator: list.AsEnumerable().Select(projection));
        }

        public static IReadOnlyList<T> Reverse<T>(this IReadOnlyList<T> list)
        {
            return new AnonymousReadOnlyList<T>(count: () => list.Count, item: i => list[list.Count - 1 - i]);
        }

        public static IReadOnlyList<TOut> Zip<TIn1, TIn2, TOut>(this IReadOnlyList<TIn1> list1,
            IReadOnlyList<TIn2> list2, Func<TIn1, TIn2, TOut> projection)
        {
            return new AnonymousReadOnlyList<TOut>(count: () => Math.Min(list1.Count, list2.Count),
                item: i => projection(list1[i], list2[i]), iterator: list1.AsEnumerable().Zip(list2, projection));
        }

        public static IReadOnlyList<int> Range(this int count)
        {
            return new AnonymousReadOnlyList<int>(count: () => count, item: i => i, iterator: Enumerable.Range(0, count));
        }

        public static void TestList()
        {
            List<String> list = new List<string>()
            {
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g"
            }

                ;
            var reversed = list.AsReadOnly().Reverse();
            Console.WriteLine(reversed);
            var list2 = new List<string>()
            {
                "a",
                "c",
                "a",
                "F",
                "A"
            }

                ;
            Console.WriteLine(list.Distinct(new LambdaComparer<string>((a, b) => a == b)));
        }

    }

    public class LambdaComparer<T> : IEqualityComparer<T>
    {
        private readonly Func<T, T, bool> _lambdaComparer;
        private readonly Func<T, int> _lambdaHash;

        public LambdaComparer(Func<T, T, bool> lambdaComparer)
            : this(lambdaComparer, EqualityComparer<T>.Default.GetHashCode)
        {
        }

        public LambdaComparer(Func<T, T, bool> lambdaComparer, Func<T, int> lambdaHash)
        {
            if (lambdaComparer == null)
                throw new ArgumentNullException("lambdaComparer");
            if (lambdaHash == null)
                throw new ArgumentNullException("lambdaHash");
            _lambdaComparer = lambdaComparer;
            _lambdaHash = lambdaHash;
        }

        public bool Equals(T x, T y)
        {
            return _lambdaComparer(x, y);
        }

        public int GetHashCode(T obj)
        {
            return _lambdaHash(obj);
        }
    }
}


================================================
File: ConsoleCalculator/ConsoleCalculator/VirtData/LoopTests.cs
================================================
using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleCalculator
{
    internal class LoopTests
    {
        public static void RunLoopTests()
        {
            LoopTests lt = new LoopTests();

           
            //
//                        LoopTests.RunMatrixMultiplication_0();
            //            LoopTests.RunMatrixMultiplication_1();

            //TODO: not tested yet
            //            lt.SimpleLoop_check();


            //            lt.ListLoopSimpleCheck();
            //            lt.ListLoopSimpleLINQCheck();
            //            lt.IndexedNames_Check();

        }


        #region MATRIX_MULTIPLICATION

//        public class MatrixMultiplication
//        {
//            [Obfuscation(Exclude = false, Feature = "virtualization; method; readable")]
		public static void RunMatrixMultiplication_0()
            {
                int rowsInA = 2;
                int columnsInA = 3; //rows in B
                int columnsInB = 3;
                int[][] a = new int[rowsInA][];
                for (int i = 0; i < rowsInA; i++)
                    a[i] = new int[columnsInA];
                int[][] b = new int[columnsInA][];
                for (int i = 0; i < columnsInA; i++)
                    b[i] = new int[columnsInB];

                Console.WriteLine("Enter matrix A");

                Random rand = new Random();
                for (int i = 0; i < a.Length; i++)
                {
                    for (int j = 0; j < a[0].Length; j++)
                    {
                        a[i][j] = rand.Next(1, 20);
                        Console.Write(a[i][j] + " ");
                    }
                    Console.WriteLine();
                }
                Console.WriteLine("Enter matrix B");
                for (int i = 0; i < b.Length; i++)
                {
                    for (int j = 0; j < b[0].Length; j++)
                    {
                        b[i][j] = rand.Next(1, 20);
                        Console.Write(b[i][j] + " ");
                    }
                    Console.WriteLine();
                }

                int[][] c = multiply_0(a, b);
                Console.WriteLine("Product of A and B is");
                for (int i = 0; i < c.Length; i++)
                {
                    for (int j = 0; j < c[0].Length; j++)
                    {
                        Console.Write(c[i][j] + " ");
                    }
                    Console.WriteLine();
                }

                Console.WriteLine("--------------");
            }

            public static void RunMatrixMultiplication_1()
            {
                int rowsInA = 2;
                int columnsInA = 3; //rows in B
                int columnsInB = 3;
                int[][] a = new int[rowsInA][];
                for (int i = 0; i < rowsInA; i++)
                    a[i] = new int[columnsInA];
                int[][] b = new int[columnsInA][];
                for (int i = 0; i < columnsInA; i++)
                    b[i] = new int[columnsInB];

                Console.WriteLine("Enter matrix A");

                Random rand = new Random();
                for (int i = 0; i < a.Length; i++)
                {
                    for (int j = 0; j < a[0].Length; j++)
                    {
                        a[i][j] = rand.Next(1, 20);
                        Console.Write(a[i][j] + " ");
                    }
                    Console.WriteLine();
                }
                Console.WriteLine("Enter matrix B");
                for (int i = 0; i < b.Length; i++)
                {
                    for (int j = 0; j < b[0].Length; j++)
                    {
                        b[i][j] = rand.Next(1, 20);
                        Console.Write(b[i][j] + " ");
                    }
                    Console.WriteLine();
                }

                int[][] c = multiply_0(a, b);
                Console.WriteLine("Product of A and B is");
                for (int i = 0; i < c.Length; i++)
                {
                    for (int j = 0; j < c[0].Length; j++)
                    {
                        Console.Write(c[i][j] + " ");
                    }
                    Console.WriteLine();
                }

                Console.WriteLine("--------------");
            }

//            [Obfuscation(Exclude = false, Feature = "virtualization; class")]
    public static int[][] multiply_0(int[][] a, int[][] b)
    {
            int rowsInA = a.Length;
            int columnsInA = a[0].Length; // same as rows in B
            int columnsInB = b[0].Length;
            int[][] c = new int[rowsInA][];

            for (int i = 0; i < rowsInA; i++)
            {
                c[i] = new int[columnsInB];
            }


            for (int i = 0; i < rowsInA; i++)
            {
                for (int j = 0; j < columnsInB; j++)
                {
                    for (int k = 0; k < columnsInA; k++)
                    {
                        c[i][j] = c[i][j] + a[i][k] * b[k][j];
                    }
                }
            }
            return c;
        }

            public static int[][] multiply_1(int[][] a, int[][] b)
            {
                int rowsInA = a.Length;
                int columnsInA = a[0].Length; // same as rows in B
                int columnsInB = b[0].Length;
                int[][] c = new int[rowsInA][];

                for (int i = 0; i < rowsInA; i++)
                {
                    c[i] = new int[columnsInB];
                }


                for (int i = 0; i < rowsInA; i++)
                {
                    for (int j = 0; j < columnsInB; j++)
                    {
                        for (int k = 0; k < columnsInA; k++)
                        {
                            c[i][j] = c[i][j] + a[i][k]*b[k][j];
                        }
                    }
                }
                return c;
            }

            
//        }


        #endregion

      

        #region LIST_LOOP

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private string ListLoopSimple()
        {
            List<String> myList = new List<string>();
            myList.Add("a");
            myList.Add("b");
            myList.Add("c");
            myList.Add("d");
            string result = "";
            foreach (var element in myList)
            {
                result += element;
            }

            return result;
            //return myList.Aggregate("", (current, element) => current + element);
        }

        private string ListLoopSimple_0()
        {
            int[] data = new[]
            {
                1, 2
            }

                ;
            List<String> myList = new List<string>();
            myList.Add("a");
            myList.Add("b");
            myList.Add("c");
            myList.Add("d");
            string result = "";
            foreach (var element in myList)
            {
                result += element;
            }

            //            result = "";
            return result;
        }

        private void ListLoopSimpleCheck()
        {
            Console.WriteLine("\nStart ListLoopSimpleCheck");
            string virt = ListLoopSimple();
            string oracle = ListLoopSimple_0();
            bool condition = virt.Equals(oracle);
            if (!condition)
            {
                throw new Exception("ListLoopSimple fail");
            }

            Console.WriteLine("ListLoopSimpleCheck - " + condition);
            Console.WriteLine("---------------");
        }

        #endregion

        #region LIST_LOOP_LINQ

        //        [Obfuscation(Exclude = false, Feature = "local virt")]
        private string ListLoopSimpleLINQ()
        {
            List<String> myList = new List<string>();
            myList.Add("a");
            myList.Add("b");
            myList.Add("c");
            myList.Add("d");
            string result = "";
            foreach (var element in myList)
            {
                result += element;
            }

            return myList.Aggregate("", (current, element) => current + element);
        }

        private string ListLoopSimpleLINQ_0()
        {
            int[] data = new[]
            {
                1, 2
            }

                ;
            List<String> myList = new List<string>();
            myList.Add("a");
            myList.Add("b");
            myList.Add("c");
            myList.Add("d");
            string result = "";
            foreach (var element in myList)
            {
                result += element;
            }

            return myList.Aggregate("", (current, element) => current + element);
        }

        private void ListLoopSimpleLINQCheck()
        {
            Console.WriteLine("\nStart ListLoopSimpleLINQCheck");
            string virt = ListLoopSimpleLINQ();
            string oracle = ListLoopSimpleLINQ_0();
            bool condition = virt.Equals(oracle);
            if (!condition)
            {
                throw new Exception("ListLoopSimpleLINQ fail");
            }

            Console.WriteLine("ListLoopSimpleLINQCheck - " + condition);
            Console.WriteLine("---------------");
        }

        #endregion


        #region INDEXER

        private class IndexedNames
        {
            private string[] namelist = new string[size];
            public static int size = 10;

            public IndexedNames()
            {
                for (int i = 0; i < size; i++)
                {
                    namelist[i] = "N. A.";
                }
            }

            //            [Obfuscation(Exclude = false, Feature = "local virt")]
            public string this[int index]
            {
                get
                {
                    string tmp;
                    if (index >= 0 && index <= size - 1)
                    {
                        tmp = namelist[index];
                    }
                    else
                    {
                        tmp = "";
                    }

                    return (tmp);
                }

                set
                {
                    if (index >= 0 && index <= size - 1)
                    {
                        namelist[index] = value;
                    }
                }
            }

            //            [Obfuscation(Exclude = false, Feature = "local virt")]
            public int this[string name]
            {
                get
                {
                    int index = 0;
                    while (index < size)
                    {
                        if (namelist[index] == name)
                        {
                            return index;
                        }

                        index++;
                    }

                    return index;
                }
            }

        }

        private class IndexedNames_0
        {
            private string[] namelist = new string[size];
            public static int size = 10;

            public IndexedNames_0()
            {
                for (int i = 0; i < size; i++)
                {
                    namelist[i] = "N. A.";
                }
            }

            public string this[int index]
            {
                get
                {
                    string tmp;
                    if (index >= 0 && index <= size - 1)
                    {
                        tmp = namelist[index];
                    }
                    else
                    {
                        tmp = "";
                    }

                    return (tmp);
                }

                set
                {
                    if (index >= 0 && index <= size - 1)
                    {
                        namelist[index] = value;
                    }
                }
            }

            public int this[string name]
            {
                get
                {
                    int index = 0;
                    while (index < size)
                    {
                        if (namelist[index] == name)
                        {
                            return index;
                        }

                        index++;
                    }

                    return index;
                }
            }

        }

        private void IndexedNames_Check()
        {
            string testName = "IndexedNames_Check";
            Program.Start_Check(testName);
            IndexedNames names = new IndexedNames();
            names[0] = "Zara";
            names[1] = "Riz";
            names[2] = "Nuha";
            names[3] = "Asif";
            names[4] = "Davinder";
            names[5] = "Sunil";
            names[6] = "Rubic";
            IndexedNames_0 names_0 = new IndexedNames_0();
            names_0[0] = "Zara";
            names_0[1] = "Riz";
            names_0[2] = "Nuha";
            names_0[3] = "Asif";
            names_0[4] = "Davinder";
            names_0[5] = "Sunil";
            names_0[6] = "Rubic";
            bool condition = true;
            //using the first indexer with int parameter
            for (int i = 0; i < IndexedNames.size; i++)
            {
                if (!names[0].Equals(names_0[0]))
                {
                    condition = false;
                }
            }

            Program.End_Check(testName, condition);
        }



        #endregion


    }
}


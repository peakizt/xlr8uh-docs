Directory structure:
‚îî‚îÄ‚îÄ dariushoule-x64dbg-automate/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ CMakeLists.txt
    ‚îú‚îÄ‚îÄ LICENSE
    ‚îú‚îÄ‚îÄ build-install-32.cmd
    ‚îú‚îÄ‚îÄ build-install-64.cmd
    ‚îú‚îÄ‚îÄ cmake.toml
    ‚îú‚îÄ‚îÄ package-release.ps1
    ‚îú‚îÄ‚îÄ vcpkg.json
    ‚îú‚îÄ‚îÄ cmake/
    ‚îÇ   ‚îú‚îÄ‚îÄ cmkr.cmake
    ‚îÇ   ‚îú‚îÄ‚îÄ msvc-configurations.cmake
    ‚îÇ   ‚îú‚îÄ‚îÄ msvc-static-runtime.cmake
    ‚îÇ   ‚îî‚îÄ‚îÄ x64dbg.cmake
    ‚îî‚îÄ‚îÄ src/
        ‚îú‚îÄ‚îÄ plugin.cpp
        ‚îú‚îÄ‚îÄ plugin.h
        ‚îú‚îÄ‚îÄ pluginmain.cpp
        ‚îú‚îÄ‚îÄ pluginmain.h
        ‚îú‚îÄ‚îÄ xauto_cmd.cpp
        ‚îú‚îÄ‚îÄ xauto_cmd.h
        ‚îú‚îÄ‚îÄ xauto_server.cpp
        ‚îî‚îÄ‚îÄ xauto_server.h

================================================
File: README.md
================================================
# x64dbg Debug Automation Powered by ZMQ

This repository contains the source code for the RPC server of x64dbg Automate. It is used by the x64dbg Automate [Python Client](https://github.com/dariushoule/x64dbg-automate-pyclient) to broker IPC between x64dbg and client automation software.

The RPC Server is built on [ZeroMQ](https://zeromq.org/) and supports concurrent debug control and event notification. Message serialization is performed using [messagepack](https://msgpack.org/index.html).

## Documentation

Full project documentation is published on: [https://dariushoule.github.io/x64dbg-automate-pyclient/](https://dariushoule.github.io/x64dbg-automate-pyclient/)

See: [Installation](https://dariushoule.github.io/x64dbg-automate-pyclient/installation/) and [Quickstart](https://dariushoule.github.io/x64dbg-automate-pyclient/quickstart/)

üîî _All examples and sample code assume x64dbg is configured to stop on entry and system breakpoints, skipping TLS breakpoints._

## Extending

Building new features into the RPC interface is easy.

### For new request/reply style calls

See: [x64dbg-automate/blob/main/src/xauto_server.cpp#L27](https://github.com/dariushoule/x64dbg-automate/blob/main/src/xauto_server.cpp#L27)

RPC requests consist of a command identifier and then an argument tuple. Adding new calls is as simple as creating a new command identifier, parsing your argument tuple, and serializing a response.

See the implementation of `XAUTO_REQ_DBG_EVAL` as an example:
[x64dbg-automate/blob/main/src/xauto_cmd.cpp#L20](https://github.com/dariushoule/x64dbg-automate/blob/main/src/xauto_cmd.cpp#L20)

This is in turn used by the Python client as so:
[x64dbg-automate-pyclient/blob/main/x64dbg_automate/commands_xauto.py#L64](https://github.com/dariushoule/x64dbg-automate-pyclient/blob/main/x64dbg_automate/commands_xauto.py#L64)

### For new pub/sub style events

Events are generally published during plugin callback lifecycle events. Registered callbacks can publish data to the pub/sub ZMQ socket at will and the python client will receive and queue the events.

See: [x64dbg-automate/blob/main/src/plugin.cpp#L143](https://github.com/dariushoule/x64dbg-automate/blob/main/src/plugin.cpp#L143)

Events are processed and stored by the Python client here:
[x64dbg-automate-pyclient/blob/main/x64dbg_automate/events.py#L85](https://github.com/dariushoule/x64dbg-automate-pyclient/blob/main/x64dbg_automate/events.py#L85)

## Building

From a Visual Studio command prompt:

```
cmake -B build64 -A x64
cmake --build build64 --config Release
```

To build the 32-bit plugin:

```
cmake -B build32 -A Win32
cmake --build build32 --config Release
```

# Contributing

Issues, feature-requests, and pull-requests are welcome on this project ‚ù§Ô∏èüêõ

My commitment to the community will be to be a responsive maintainer. Discuss with me before implementing major breaking changes or feature additions.



================================================
File: CMakeLists.txt
================================================
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr and automatically regenerate CMakeLists.txt
	include("cmake/cmkr.cmake" OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)

	# Create a configure-time dependency on cmake.toml to improve IDE support
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

include("cmake/msvc-static-runtime.cmake")
include("cmake/msvc-configurations.cmake")

project(x64dbg-automate)

if(CMKR_ROOT_PROJECT AND NOT CMKR_DISABLE_VCPKG)
	include(FetchContent)
	# Fix warnings about DOWNLOAD_EXTRACT_TIMESTAMP
	if(POLICY CMP0135)
		cmake_policy(SET CMP0135 NEW)
	endif()
	message(STATUS "Fetching vcpkg (2025.01.13)...")
	FetchContent_Declare(vcpkg URL "https://github.com/microsoft/vcpkg/archive/refs/tags/2025.01.13.tar.gz")
	FetchContent_GetProperties(vcpkg)
	if(NOT vcpkg_POPULATED)
		FetchContent_Populate(vcpkg)
		include("${vcpkg_SOURCE_DIR}/scripts/buildsystems/vcpkg.cmake")
	endif()
endif()

include(FetchContent)

message(STATUS "Fetching x64dbg...")
FetchContent_Declare(x64dbg
	URL
		"https://sourceforge.net/projects/x64dbg/files/snapshots/snapshot_2025-01-17_12-45.zip"
	URL_HASH
		SHA1=57e77f9a406647b0ad31311630e3fc44f25979b3
)
FetchContent_MakeAvailable(x64dbg)

include("cmake/x64dbg.cmake")

# Packages
find_package(cppzmq REQUIRED)

find_package(msgpack-cxx REQUIRED)

find_package(Boost REQUIRED)

# Target: x64dbg-automate
set(x64dbg-automate_SOURCES
	"src/plugin.cpp"
	"src/pluginmain.cpp"
	"src/xauto_cmd.cpp"
	"src/xauto_server.cpp"
	"src/plugin.h"
	"src/pluginmain.h"
	"src/xauto_cmd.h"
	"src/xauto_server.h"
	cmake.toml
)

x64dbg_plugin(x64dbg-automate)

target_sources(x64dbg-automate PRIVATE ${x64dbg-automate_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${x64dbg-automate_SOURCES})

target_compile_features(x64dbg-automate PUBLIC
	cxx_std_20
)

target_link_libraries(x64dbg-automate PUBLIC
	cppzmq
	msgpack-cxx
)




================================================
File: LICENSE
================================================
Copyright 2025 Dariush Houle

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


================================================
File: build-install-32.cmd
================================================
@echo off

set INSTALL_DIR=E:\re\x64dbg_dev\release\x32\plugins\

if not exist %INSTALL_DIR% mkdir %INSTALL_DIR%
cmake -B build32 -A Win32
cmake --build build32 --config Release
copy /Y build32\Release\x64dbg-automate.dp32 %INSTALL_DIR%\
copy /Y build32\Release\libzmq-mt-4_3_5.dll %INSTALL_DIR%\


================================================
File: build-install-64.cmd
================================================
@echo off

set INSTALL_DIR=E:\re\x64dbg_dev\release\x64\plugins\

if not exist %INSTALL_DIR% mkdir %INSTALL_DIR%
cmake -B build64 -A x64
cmake --build build64 --config Release
copy /Y build64\Release\x64dbg-automate.dp64 %INSTALL_DIR%\
copy /Y build64\Release\libzmq-mt-4_3_5.dll %INSTALL_DIR%\


================================================
File: cmake.toml
================================================
[cmake]
version = "3.15"
cmkr-include = "cmake/cmkr.cmake"

[project]
name = "x64dbg-automate"
include-before = [
	"cmake/msvc-static-runtime.cmake",
	"cmake/msvc-configurations.cmake",
]

[vcpkg]
version = "2025.01.13"
packages = ["cppzmq", "msgpack[boost]"]

[find-package.cppzmq]
required = true

[find-package.msgpack-cxx]
required = true

[find-package.Boost]
required = true

[fetch-content.x64dbg]
url = "https://sourceforge.net/projects/x64dbg/files/snapshots/snapshot_2025-01-17_12-45.zip"
sha1 = "57e77f9a406647b0ad31311630e3fc44f25979b3"
include-after = ["cmake/x64dbg.cmake"]

[template.plugin]
type = "shared"
add-function = "x64dbg_plugin"

[target.x64dbg-automate]
type = "plugin"
sources = [
    "src/*.cpp",
    "src/*.h",
]
link-libraries = ["cppzmq", "msgpack-cxx"]
compile-features = ["cxx_std_20"]


================================================
File: package-release.ps1
================================================
.\build-install-32.cmd
.\build-install-64.cmd

if (Test-Path "release32-0.1.0-bitter_oyster.zip") {
    Remove-Item "release32-0.1.0-bitter_oyster.zip"
}

if (Test-Path "release64-0.1.0-bitter_oyster.zip") {
    Remove-Item "release64-0.1.0-bitter_oyster.zip"
}

Compress-Archive -Path "build32\Release" -Update -DestinationPath "release32-0.1.0-bitter_oyster.zip"
Compress-Archive -Path "build64\Release" -Update -DestinationPath "release64-0.1.0-bitter_oyster.zip"


================================================
File: vcpkg.json
================================================
{
  "$cmkr": "This file is automatically generated from cmake.toml - DO NOT EDIT",
  "$cmkr-url": "https://github.com/build-cpp/cmkr",
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg/master/scripts/vcpkg.schema.json",
  "dependencies": [
    "cppzmq",
    {
      "name": "msgpack",
      "features": ["boost"]
    }
  ],
  "description": "",
  "name": "x64dbg-automate",
  "version-string": ""
}



================================================
File: cmake/cmkr.cmake
================================================
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.23" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()



================================================
File: cmake/msvc-configurations.cmake
================================================
# Set up a more familiar Visual Studio configuration
# Override these options with -DCMAKE_OPTION=Value
#
# See: https://cmake.org/cmake/help/latest/command/set.html#set-cache-entry
set(CMAKE_CONFIGURATION_TYPES "Debug;Release" CACHE STRING "")
set(CMAKE_EXE_LINKER_FLAGS_RELEASE "/DEBUG:FULL /INCREMENTAL:NO" CACHE STRING "")
set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "/DEBUG:FULL /INCREMENTAL:NO" CACHE STRING "")
set(CMAKE_BUILD_TYPE "Release" CACHE STRING "")


================================================
File: cmake/msvc-static-runtime.cmake
================================================
cmake_policy(SET CMP0091 NEW)
set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>" CACHE STRING "")


================================================
File: cmake/x64dbg.cmake
================================================

if(NOT TARGET x64dbg)
    file(GLOB_RECURSE HEADERS CONFIGURE_DEPENDS ${x64dbg_SOURCE_DIR}/pluginsdk/*.h)
    add_custom_target(x64dbg-sdk SOURCES ${HEADERS})
    source_group(TREE ${x64dbg_SOURCE_DIR} FILES ${HEADERS})

    add_library(x64dbg INTERFACE)
    target_include_directories(x64dbg INTERFACE ${x64dbg_SOURCE_DIR})
    target_link_directories(x64dbg INTERFACE ${x64dbg_SOURCE_DIR})
endif()

function(x64dbg_plugin target)
    if(NOT TARGET ${target})
        # Add plugin dll
        add_library(${target} SHARED ${ARGN})
        # Group source files
        source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${ARGN})
    endif()

    # Change extension
    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
        set_target_properties(${target} PROPERTIES SUFFIX ".dp64")
    else()
        set_target_properties(${target} PROPERTIES SUFFIX ".dp32")
    endif()

    # Link to the x64dbg SDK
    target_link_libraries(${target} PRIVATE x64dbg)

    # Set plugin name based on the target
    target_compile_definitions(${target} PRIVATE "-DPLUGIN_NAME=\"${target}\"")

    # Support PluginDevHelper (https://github.com/x64dbg/PluginDevHelper)
    add_custom_command(TARGET ${target} PRE_LINK COMMAND if exist "\"$(SolutionDir)PluginDevBuildTool.exe\"" "(\"$(SolutionDir)PluginDevBuildTool.exe\"" unload "\"$(TargetPath)\")" else (echo Copy PluginDevBuildTool.exe next to the .sln to automatically reload plugins when building))
    add_custom_command(TARGET ${target} POST_BUILD COMMAND if exist "\"$(SolutionDir)PluginDevBuildTool.exe\"" ("\"$(SolutionDir)PluginDevBuildTool.exe\"" reload "\"$(TargetPath)\""))
endfunction()


================================================
File: src/plugin.cpp
================================================
#include "plugin.h"
#include "pluginmain.h"


CBTYPE last_event;
void* last_cbinfo;


void cb_sys_breakpoint(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_SYSTEMBREAKPOINT* bp = (PLUG_CB_SYSTEMBREAKPOINT*)callbackInfo;
    msgpack::sbuffer outbuf;
    msgpack::pack(outbuf, std::tuple<std::string, size_t>(std::string("EVENT_SYSTEMBREAKPOINT"), (size_t)bp->reserved));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

void cb_breakpoint(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_BREAKPOINT* bp = (PLUG_CB_BREAKPOINT*)callbackInfo;
    msgpack::sbuffer outbuf;
    msgpack::pack(outbuf, std::tuple<
        std::string, 
        size_t, 
        size_t, 
        bool, 
        bool, 
        bool,
        std::string,
        std::string,
        size_t,
        uint8_t,
        uint8_t,
        size_t,
        bool, 
        bool,
        std::string,
        std::string,
        std::string,
        std::string,
        std::string
    >(
        std::string("EVENT_BREAKPOINT"),
        bp->breakpoint->type,
        bp->breakpoint->addr,
        bp->breakpoint->enabled,
        bp->breakpoint->singleshoot,
        bp->breakpoint->active,
        std::string(bp->breakpoint->name),
        std::string(bp->breakpoint->mod),
        bp->breakpoint->slot,
        bp->breakpoint->typeEx,
        bp->breakpoint->hwSize,
        bp->breakpoint->hitCount,
        bp->breakpoint->fastResume,
        bp->breakpoint->silent,
        std::string(bp->breakpoint->breakCondition),
        std::string(bp->breakpoint->logText),
        std::string(bp->breakpoint->logCondition),
        std::string(bp->breakpoint->commandText),
        std::string(bp->breakpoint->commandCondition)
    ));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

void cb_create_thread(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_CREATETHREAD* bp = (PLUG_CB_CREATETHREAD*)callbackInfo;
    msgpack::sbuffer outbuf;
    msgpack::pack(outbuf, std::tuple<std::string, size_t, size_t, size_t>(
        std::string("EVENT_CREATE_THREAD"), (size_t)bp->dwThreadId, (size_t)bp->CreateThread->lpThreadLocalBase, (size_t)bp->CreateThread->lpStartAddress));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

void cb_exit_thread(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_EXITTHREAD* bp = (PLUG_CB_EXITTHREAD*)callbackInfo;
    msgpack::sbuffer outbuf;
    msgpack::pack(outbuf, std::tuple<std::string, size_t, size_t>(
        std::string("EVENT_EXIT_THREAD"), (size_t)bp->dwThreadId, (size_t)bp->ExitThread->dwExitCode));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

void cb_load_dll(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_LOADDLL* bp = (PLUG_CB_LOADDLL*)callbackInfo;
    msgpack::sbuffer outbuf;
    msgpack::pack(outbuf, std::tuple<std::string, std::string, size_t>(
        std::string("EVENT_LOAD_DLL"), std::string(bp->modname), (size_t)bp->LoadDll->lpBaseOfDll));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

void cb_unload_dll(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_UNLOADDLL* bp = (PLUG_CB_UNLOADDLL*)callbackInfo;
    msgpack::sbuffer outbuf;
    msgpack::pack(outbuf, std::tuple<std::string, size_t>(
        std::string("EVENT_UNLOAD_DLL"), (size_t)bp->UnloadDll->lpBaseOfDll));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

void cb_debugstr(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_OUTPUTDEBUGSTRING* bp = (PLUG_CB_OUTPUTDEBUGSTRING*)callbackInfo;
    msgpack::sbuffer outbuf;

    std::vector<uint8_t> membuf(bp->DebugString->nDebugStringLength);
    if(!DbgMemRead((size_t)bp->DebugString->lpDebugStringData, membuf.data(), bp->DebugString->nDebugStringLength)) {
        dprintf("Failed to read debug string memory\n");
        return;
    }

    msgpack::pack(outbuf, std::tuple<std::string, std::vector<uint8_t>>(
        std::string("EVENT_OUTPUT_DEBUG_STRING"), membuf));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

void cb_exception(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_EXCEPTION* bp = (PLUG_CB_EXCEPTION*)callbackInfo;
    msgpack::sbuffer outbuf;
    std::vector<size_t> params;

    for (size_t i = 0; i < bp->Exception->ExceptionRecord.NumberParameters; i++) {
        params.push_back(bp->Exception->ExceptionRecord.ExceptionInformation[i]);
    }

    msgpack::pack(outbuf, std::tuple<std::string, size_t, size_t, size_t, size_t, size_t, std::vector<size_t>, size_t>(
        std::string("EVENT_EXCEPTION"), 
        (size_t)bp->Exception->ExceptionRecord.ExceptionCode,
        (size_t)bp->Exception->ExceptionRecord.ExceptionFlags,
        (size_t)bp->Exception->ExceptionRecord.ExceptionRecord,
        (size_t)bp->Exception->ExceptionRecord.ExceptionAddress,
        (size_t)bp->Exception->ExceptionRecord.NumberParameters,
        params,
        bp->Exception->dwFirstChance));
    srv->pub_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);
}

bool pluginInit(PLUG_INITSTRUCT* initStruct)
{
    dprintf("pluginInit(pluginHandle: %d)\n", pluginHandle);
    last_cbinfo = nullptr;
    _plugin_registercallback(pluginHandle, CB_BREAKPOINT, cb_breakpoint);
    _plugin_registercallback(pluginHandle, CB_SYSTEMBREAKPOINT, cb_sys_breakpoint);
    _plugin_registercallback(pluginHandle, CB_CREATETHREAD, cb_create_thread);
    _plugin_registercallback(pluginHandle, CB_EXITTHREAD, cb_exit_thread);
    _plugin_registercallback(pluginHandle, CB_LOADDLL, cb_load_dll);
    _plugin_registercallback(pluginHandle, CB_UNLOADDLL, cb_unload_dll);
    _plugin_registercallback(pluginHandle, CB_OUTPUTDEBUGSTRING, cb_debugstr);
    _plugin_registercallback(pluginHandle, CB_EXCEPTION, cb_exception);
    return true;
}

void pluginStop()
{
    dprintf("pluginStop(pluginHandle: %d)\n", pluginHandle);
    srv->release_session();
}

void pluginSetup()
{
    dprintf("pluginSetup(pluginHandle: %d)\n", pluginHandle);
}



================================================
File: src/plugin.h
================================================
#pragma once

#include "pluginmain.h"

//functions
bool pluginInit(PLUG_INITSTRUCT* initStruct);
void pluginStop();
void pluginSetup();



================================================
File: src/pluginmain.cpp
================================================
#include "pluginmain.h"
#include "plugin.h"

int pluginHandle;
HWND hwndDlg;
int hMenu;
int hMenuDisasm;
int hMenuDump;
int hMenuStack;
int hMenuGraph;
int hMenuMemmap;
int hMenuSymmod;


XAutoServer* srv;


PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    srv = new XAutoServer();
    initStruct->pluginVersion = PLUGIN_VERSION;
    initStruct->sdkVersion = PLUG_SDKVERSION;
    strncpy_s(initStruct->pluginName, PLUGIN_NAME, _TRUNCATE);
    pluginHandle = initStruct->pluginHandle;
    return pluginInit(initStruct);
}

PLUG_EXPORT bool plugstop()
{
    pluginStop();
    return true;
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    hwndDlg = setupStruct->hwndDlg;
    hMenu = setupStruct->hMenu;
    hMenuDisasm = setupStruct->hMenuDisasm;
    hMenuDump = setupStruct->hMenuDump;
    hMenuStack = setupStruct->hMenuStack;
    hMenuGraph = setupStruct->hMenuGraph;
    hMenuMemmap = setupStruct->hMenuMemmap;
    hMenuSymmod = setupStruct->hMenuSymmod;
    pluginSetup();
}


================================================
File: src/pluginmain.h
================================================
#pragma once

// Plugin information
#define PLUGIN_NAME "x64dbg-automate"
#define PLUGIN_VERSION 1

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"

#include "pluginsdk/_scriptapi_argument.h"
#include "pluginsdk/_scriptapi_assembler.h"
#include "pluginsdk/_scriptapi_bookmark.h"
#include "pluginsdk/_scriptapi_comment.h"
#include "pluginsdk/_scriptapi_debug.h"
#include "pluginsdk/_scriptapi_flag.h"
#include "pluginsdk/_scriptapi_function.h"
#include "pluginsdk/_scriptapi_gui.h"
#include "pluginsdk/_scriptapi_label.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "pluginsdk/_scriptapi_misc.h"
#include "pluginsdk/_scriptapi_module.h"
#include "pluginsdk/_scriptapi_pattern.h"
#include "pluginsdk/_scriptapi_register.h"
#include "pluginsdk/_scriptapi_stack.h"
#include "pluginsdk/_scriptapi_symbol.h"

#include "pluginsdk/DeviceNameResolver/DeviceNameResolver.h"
#include "pluginsdk/jansson/jansson.h"
#include "pluginsdk/lz4/lz4file.h"
#include "pluginsdk/TitanEngine/TitanEngine.h"
#include "pluginsdk/XEDParse/XEDParse.h"

#include "xauto_server.h"

#ifdef _WIN64
#pragma comment(lib, "pluginsdk/x64dbg.lib")
#pragma comment(lib, "pluginsdk/x64bridge.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x64.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x64.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x64.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x64.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x64.lib")
#else
#pragma comment(lib, "pluginsdk/x32dbg.lib")
#pragma comment(lib, "pluginsdk/x32bridge.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x86.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x86.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x86.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x86.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x86.lib")
#endif //_WIN64
#pragma comment(lib, "shlwapi.lib")

#define Cmd(x) DbgCmdExecDirect(x)
#define Eval(x) DbgValFromString(x)
#define dprintf(x, ...) _plugin_logprintf("[" PLUGIN_NAME "] " x, __VA_ARGS__)
#define dputs(x) _plugin_logprintf("[" PLUGIN_NAME "] %s\n", x)
#define PLUG_EXPORT extern "C" __declspec(dllexport)

// Global variables required by some of the _plugin_xxx functions
extern int pluginHandle;
extern HWND hwndDlg;
extern int hMenu;
extern int hMenuDisasm;
extern int hMenuDump;
extern int hMenuStack;
extern int hMenuGraph;
extern int hMenuMemmap;
extern int hMenuSymmod;

// Server instance
extern XAutoServer* srv;


================================================
File: src/xauto_cmd.cpp
================================================
#include "xauto_cmd.h"
#include <pluginsdk/bridgemain.h>
#include "pluginmain.h"
#include <TlHelp32.h>
#include <Shlwapi.h>


void get_debugger_pid(msgpack::sbuffer& response_buffer) {
    msgpack::pack(response_buffer, GetCurrentProcessId());
}

void get_compat_v(msgpack::sbuffer& response_buffer) {
    msgpack::pack(response_buffer, std::string(XAUTO_COMPAT_VERSION));
}

void get_debugger_version(msgpack::sbuffer& response_buffer) {
    msgpack::pack(response_buffer, BridgeGetDbgVersion());
}

void dbg_eval(msgpack::object root, msgpack::sbuffer& response_buffer) {
    bool success; 
    std::string cmd;

    if(root.via.array.size < 2 || root.via.array.ptr[1].type != msgpack::type::STR) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_EVAL", "Invalid or missing eval string"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(cmd);
    size_t res = DbgEval(cmd.c_str(), &success);
    std::tuple<size_t, bool> out_tup(res, success);
    msgpack::pack(response_buffer, out_tup);
}

void dbg_cmd_exec_direct(msgpack::object root, msgpack::sbuffer& response_buffer) {
    std::string cmd;

    if(root.via.array.size < 2 || root.via.array.ptr[1].type != msgpack::type::STR) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_EVAL", "Invalid or missing command string"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(cmd);
    msgpack::pack(response_buffer, DbgCmdExecDirect(cmd.c_str()));
}

void dbg_is_running(msgpack::sbuffer& response_buffer) {
    msgpack::pack(response_buffer, DbgIsRunning());
}

void dbg_is_debugging(msgpack::sbuffer& response_buffer) {
    msgpack::pack(response_buffer, DbgIsDebugging());
}

void dbg_is_elevated(msgpack::sbuffer& response_buffer) {
    msgpack::pack(response_buffer, BridgeIsProcessElevated());
}

void dbg_get_bitness(msgpack::sbuffer& response_buffer) {
    msgpack::pack(response_buffer, sizeof(void*) == 8 ? 64 : 32);
}

void dbg_memmap(msgpack::sbuffer& response_buffer) {
    MEMMAP mm;
    DbgMemMap(&mm);
    std::vector<MemPageTup> memmap_entry_vec;
    for (size_t i = 0; i < mm.count; i++) {
        auto bi = mm.page[i].mbi;
        memmap_entry_vec.push_back(MemPageTup(
            (size_t)bi.BaseAddress,
            (size_t)bi.AllocationBase,
            bi.AllocationProtect,
            #if defined (_WIN64)
            bi.PartitionId,
            #else
            0,
            #endif
            bi.RegionSize,
            bi.State,
            bi.Protect,
            bi.Type,
            std::string(mm.page[i].info)
        ));
    }
    msgpack::pack(response_buffer, memmap_entry_vec);
    BridgeFree(mm.page);
}

void gui_refresh_views(msgpack::sbuffer& response_buffer) {
    GuiUpdateAllViews();
    msgpack::pack(response_buffer, true);
}

void dbg_read_memory(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;
    size_t size;

    if(root.via.array.size < 3 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER || root.via.array.ptr[2].type != msgpack::type::POSITIVE_INTEGER) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_READ", "Invalid or missing memory read parameters"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    root.via.array.ptr[2].convert(size);

    std::vector<uint8_t> membuf(size);
    if(!DbgMemRead(addr, membuf.data(), size)) {
        XAutoErrorResponse resp_obj = {"XERROR_READ_FAILED", "Memory read failed"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    msgpack::pack(response_buffer, membuf);
}

void dbg_write_memory(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;
    std::vector<uint8_t> data;

    if(root.via.array.size < 3 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER || root.via.array.ptr[2].type != msgpack::type::BIN) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_WRITE", "Invalid or missing memory write parameters"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    root.via.array.ptr[2].convert(data);

    if(!DbgMemWrite(addr, data.data(), data.size())) {
        XAutoErrorResponse resp_obj = {"XERROR_WRITE_FAILED", "Memory write failed"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    msgpack::pack(response_buffer, true);
}

void dbg_read_regs(msgpack::sbuffer& response_buffer) {
    REGDUMP rd;
    DbgGetRegDumpEx(&rd, sizeof(rd));

    std::array<uint8_t, 80> reg_area;
    std::copy_n((uint8_t*)&rd.regcontext.RegisterArea[0], 80, reg_area.begin()); 

    #ifdef _WIN64
    std::array<uint8_t, 16 * 16> xmm_regs;
    std::copy_n((uint8_t*)&rd.regcontext.XmmRegisters[0], 16 * 16, xmm_regs.begin()); 
    std::array<uint8_t, 16 * 32> ymm_regs;
    std::copy_n((uint8_t*)&rd.regcontext.YmmRegisters[0], 16 * 32, ymm_regs.begin()); 
    #else
    std::array<uint8_t, 8 * 16> xmm_regs;
    std::copy_n((uint8_t*)&rd.regcontext.XmmRegisters[0], 8 * 16, xmm_regs.begin());
    std::array<uint8_t, 8 * 32> ymm_regs;
    std::copy_n((uint8_t*)&rd.regcontext.YmmRegisters[0], 8 * 32, ymm_regs.begin());
    #endif

    FpuRegsArr fpu_regs;
    for (size_t i = 0; i < 8; i++) {
        fpu_regs[i] = FpuRegsTup(
            std::array<uint8_t, 10>(),
            rd.x87FPURegisters[i].st_value,
            rd.x87FPURegisters[i].tag
        );
        std::copy_n((uint8_t*)&rd.x87FPURegisters[i].data[0], 10, std::get<0>(fpu_regs[i]).begin()); 
    }

    std::array<uint8_t, 128> lastError;
    std::copy_n((uint8_t*)&rd.lastError.name[0], 128, lastError.begin());
    std::array<uint8_t, 128> lastStatus;
    std::copy_n((uint8_t*)&rd.lastStatus.name[0], 128, lastStatus.begin());

    #ifdef _WIN64
    std::tuple<
        size_t, 
        CtxTup64, 
        FlagsTup, 
        FpuRegsArr, 
        MmxArr,
        MxcsrFieldsTup,
        x87StatusWordFieldsTup,
        x87ControlWordFieldsTup,
        std::tuple<uint32_t, std::array<uint8_t, 128>>,
        std::tuple<uint32_t, std::array<uint8_t, 128>>
    > regdump(
        64,
        CtxTup64(
            rd.regcontext.cax, rd.regcontext.cbx, rd.regcontext.ccx, rd.regcontext.cdx, rd.regcontext.cbp, rd.regcontext.csp, rd.regcontext.csi, rd.regcontext.cdi,
            rd.regcontext.r8, rd.regcontext.r9, rd.regcontext.r10, rd.regcontext.r11, rd.regcontext.r12, rd.regcontext.r13, rd.regcontext.r14, rd.regcontext.r15,
            rd.regcontext.cip,
            rd.regcontext.eflags,
            rd.regcontext.cs, rd.regcontext.ds, rd.regcontext.es, rd.regcontext.fs, rd.regcontext.gs, rd.regcontext.ss,
            rd.regcontext.dr0, rd.regcontext.dr1, rd.regcontext.dr2, rd.regcontext.dr3, rd.regcontext.dr6, rd.regcontext.dr7,
            reg_area,
            x87fpuTup(
                rd.regcontext.x87fpu.ControlWord,
                rd.regcontext.x87fpu.StatusWord,
                rd.regcontext.x87fpu.TagWord,
                rd.regcontext.x87fpu.ErrorOffset,
                rd.regcontext.x87fpu.ErrorSelector,
                rd.regcontext.x87fpu.DataOffset,
                rd.regcontext.x87fpu.DataSelector,
                rd.regcontext.x87fpu.Cr0NpxState
            ),
            rd.regcontext.MxCsr,
            xmm_regs,
            ymm_regs
        ),
        FlagsTup(rd.flags.c, rd.flags.p, rd.flags.a, rd.flags.z, rd.flags.s, rd.flags.t, rd.flags.i, rd.flags.d, rd.flags.o),
        fpu_regs,
        MmxArr {rd.mmx[0], rd.mmx[1], rd.mmx[2], rd.mmx[3], rd.mmx[4], rd.mmx[5], rd.mmx[6], rd.mmx[7]},
        MxcsrFieldsTup(
            rd.MxCsrFields.FZ, rd.MxCsrFields.PM, rd.MxCsrFields.UM, rd.MxCsrFields.OM,
            rd.MxCsrFields.ZM, rd.MxCsrFields.IM, rd.MxCsrFields.DM, rd.MxCsrFields.DAZ,
            rd.MxCsrFields.PE, rd.MxCsrFields.UE, rd.MxCsrFields.OE, rd.MxCsrFields.ZE,
            rd.MxCsrFields.DE, rd.MxCsrFields.IE, rd.MxCsrFields.RC
        ),
        x87StatusWordFieldsTup(
            rd.x87StatusWordFields.B, rd.x87StatusWordFields.C3, rd.x87StatusWordFields.C2, rd.x87StatusWordFields.C1, rd.x87StatusWordFields.C0,
            rd.x87StatusWordFields.ES, rd.x87StatusWordFields.SF, rd.x87StatusWordFields.P, rd.x87StatusWordFields.U, rd.x87StatusWordFields.O, 
            rd.x87StatusWordFields.Z, rd.x87StatusWordFields.D, rd.x87StatusWordFields.I, rd.x87StatusWordFields.TOP),
        x87ControlWordFieldsTup(
            rd.x87ControlWordFields.IC, rd.x87ControlWordFields.IEM, rd.x87ControlWordFields.PM, rd.x87ControlWordFields.UM, rd.x87ControlWordFields.OM, 
            rd.x87ControlWordFields.ZM, rd.x87ControlWordFields.DM, rd.x87ControlWordFields.IM, rd.x87ControlWordFields.RC, rd.x87ControlWordFields.PC),
        std::tuple<uint32_t, std::array<uint8_t, 128>>(rd.lastError.code, lastError),
        std::tuple<uint32_t, std::array<uint8_t, 128>>(rd.lastStatus.code, lastStatus)
    );
    #else
    std::tuple<
        size_t, 
        CtxTup32, 
        FlagsTup, 
        FpuRegsArr, 
        MmxArr,
        MxcsrFieldsTup,
        x87StatusWordFieldsTup,
        x87ControlWordFieldsTup,
        std::tuple<uint32_t, std::array<uint8_t, 128>>,
        std::tuple<uint32_t, std::array<uint8_t, 128>>
    > regdump(
        32,
        CtxTup32(
            rd.regcontext.cax, rd.regcontext.cbx, rd.regcontext.ccx, rd.regcontext.cdx, rd.regcontext.cbp, rd.regcontext.csp, rd.regcontext.csi, rd.regcontext.cdi,
            rd.regcontext.cip,
            rd.regcontext.eflags,
            rd.regcontext.cs, rd.regcontext.ds, rd.regcontext.es, rd.regcontext.fs, rd.regcontext.gs, rd.regcontext.ss,
            rd.regcontext.dr0, rd.regcontext.dr1, rd.regcontext.dr2, rd.regcontext.dr3, rd.regcontext.dr6, rd.regcontext.dr7,
            reg_area,
            x87fpuTup(
                rd.regcontext.x87fpu.ControlWord,
                rd.regcontext.x87fpu.StatusWord,
                rd.regcontext.x87fpu.TagWord,
                rd.regcontext.x87fpu.ErrorOffset,
                rd.regcontext.x87fpu.ErrorSelector,
                rd.regcontext.x87fpu.DataOffset,
                rd.regcontext.x87fpu.DataSelector,
                rd.regcontext.x87fpu.Cr0NpxState
            ),
            rd.regcontext.MxCsr,
            xmm_regs,
            ymm_regs
        ),
        FlagsTup(rd.flags.c, rd.flags.p, rd.flags.a, rd.flags.z, rd.flags.s, rd.flags.t, rd.flags.i, rd.flags.d, rd.flags.o),
        fpu_regs,
        MmxArr {rd.mmx[0], rd.mmx[1], rd.mmx[2], rd.mmx[3], rd.mmx[4], rd.mmx[5], rd.mmx[6], rd.mmx[7]},
        MxcsrFieldsTup(
            rd.MxCsrFields.FZ, rd.MxCsrFields.PM, rd.MxCsrFields.UM, rd.MxCsrFields.OM,
            rd.MxCsrFields.ZM, rd.MxCsrFields.IM, rd.MxCsrFields.DM, rd.MxCsrFields.DAZ,
            rd.MxCsrFields.PE, rd.MxCsrFields.UE, rd.MxCsrFields.OE, rd.MxCsrFields.ZE,
            rd.MxCsrFields.DE, rd.MxCsrFields.IE, rd.MxCsrFields.RC
        ),
        x87StatusWordFieldsTup(
            rd.x87StatusWordFields.B, rd.x87StatusWordFields.C3, rd.x87StatusWordFields.C2, rd.x87StatusWordFields.C1, rd.x87StatusWordFields.C0,
            rd.x87StatusWordFields.ES, rd.x87StatusWordFields.SF, rd.x87StatusWordFields.P, rd.x87StatusWordFields.U, rd.x87StatusWordFields.O, 
            rd.x87StatusWordFields.Z, rd.x87StatusWordFields.D, rd.x87StatusWordFields.I, rd.x87StatusWordFields.TOP),
        x87ControlWordFieldsTup(
            rd.x87ControlWordFields.IC, rd.x87ControlWordFields.IEM, rd.x87ControlWordFields.PM, rd.x87ControlWordFields.UM, rd.x87ControlWordFields.OM, 
            rd.x87ControlWordFields.ZM, rd.x87ControlWordFields.DM, rd.x87ControlWordFields.IM, rd.x87ControlWordFields.RC, rd.x87ControlWordFields.PC),
        std::tuple<uint32_t, std::array<uint8_t, 128>>(rd.lastError.code, lastError),
        std::tuple<uint32_t, std::array<uint8_t, 128>>(rd.lastStatus.code, lastStatus)
    );
    #endif

    msgpack::pack(response_buffer, regdump);
}

void dbg_read_setting_sz(msgpack::object root, msgpack::sbuffer& response_buffer) {
    std::string section;
    std::string setting_name;

    if(root.via.array.size < 3 || root.via.array.ptr[1].type != msgpack::type::STR || root.via.array.ptr[2].type != msgpack::type::STR) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_SETTING", "Invalid or missing setting string"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(section);
    root.via.array.ptr[2].convert(setting_name);

    char* setting_val = (char*)BridgeAlloc(MAX_SETTING_SIZE);
    bool res = BridgeSettingGet(section.c_str(), setting_name.c_str(), setting_val);
    msgpack::pack(response_buffer, std::tuple<bool, std::string>(res, std::string(setting_val)));
    BridgeFree(setting_val);
}

void dbg_write_setting_sz(msgpack::object root, msgpack::sbuffer& response_buffer) {
    std::string section;
    std::string setting_name;
    std::string setting_val;

    if( root.via.array.size < 3 || 
        root.via.array.ptr[1].type != msgpack::type::STR || 
        root.via.array.ptr[2].type != msgpack::type::STR || 
        root.via.array.ptr[3].type != msgpack::type::STR
    ) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_SETTING", "Invalid or missing setting string"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(section);
    root.via.array.ptr[2].convert(setting_name);
    root.via.array.ptr[3].convert(setting_val);

    bool res = BridgeSettingSet(section.c_str(), setting_name.c_str(), setting_val.c_str());
    msgpack::pack(response_buffer, res);
}

void dbg_read_setting_uint(msgpack::object root, msgpack::sbuffer& response_buffer) {
    std::string section;
    std::string setting_name;

    if(root.via.array.size < 3 || root.via.array.ptr[1].type != msgpack::type::STR || root.via.array.ptr[2].type != msgpack::type::STR) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_SETTING", "Invalid or missing setting string"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(section);
    root.via.array.ptr[2].convert(setting_name);

    duint setting_val;
    bool res = BridgeSettingGetUint(section.c_str(), setting_name.c_str(), &setting_val);
    msgpack::pack(response_buffer, std::tuple<bool, size_t>(res, setting_val));
}

void dbg_write_setting_uint(msgpack::object root, msgpack::sbuffer& response_buffer) {
    std::string section;
    std::string setting_name;
    size_t setting_val;

    if( root.via.array.size < 3 || 
        root.via.array.ptr[1].type != msgpack::type::STR || 
        root.via.array.ptr[2].type != msgpack::type::STR || 
        (root.via.array.ptr[3].type != msgpack::type::POSITIVE_INTEGER)
    ) {
        XAutoErrorResponse resp_obj = {"XERROR_BAD_SETTING", "Invalid or missing setting string"};
        msgpack::pack(response_buffer, resp_obj);
        return;
    }

    root.via.array.ptr[1].convert(section);
    root.via.array.ptr[2].convert(setting_name);
    root.via.array.ptr[3].convert(setting_val);

    bool res = BridgeSettingSetUint(section.c_str(), setting_name.c_str(), setting_val);
    msgpack::pack(response_buffer, res);
}

void dbg_is_valid_read_ptr(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;

    if(root.via.array.size < 2 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER) {
        msgpack::pack(response_buffer, false);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    msgpack::pack(response_buffer, DbgMemIsValidReadPtr(addr));
}

void disassemble_at(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;
    DISASM_INSTR instr;

    if(root.via.array.size < 2 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER) {
        msgpack::pack(response_buffer, false);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    DbgDisasmAt(addr, &instr);
    msgpack::pack(response_buffer, DisasmTup(
        std::string(instr.instruction),
        instr.argcount,
        instr.instr_size,
        instr.type,
        {
            DisasmArgTup(
                std::string(instr.arg[0].mnemonic),
                instr.arg[0].type,
                instr.arg[0].segment,
                instr.arg[0].constant,
                instr.arg[0].value,
                instr.arg[0].memvalue
            ),
            DisasmArgTup(
                std::string(instr.arg[1].mnemonic),
                instr.arg[1].type,
                instr.arg[1].segment,
                instr.arg[1].constant,
                instr.arg[1].value,
                instr.arg[1].memvalue
            ),
            DisasmArgTup(
                std::string(instr.arg[2].mnemonic),
                instr.arg[2].type,
                instr.arg[2].segment,
                instr.arg[2].constant,
                instr.arg[2].value,
                instr.arg[2].memvalue
            )
        }
    ));
}

void assemble_at(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;
    std::string instr;

    if(root.via.array.size < 3 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER || root.via.array.ptr[2].type != msgpack::type::STR) {
        msgpack::pack(response_buffer, false);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    root.via.array.ptr[2].convert(instr);
    msgpack::pack(response_buffer, DbgAssembleAt(addr, instr.c_str()));
}

void get_breakpoints(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t bp_type;
    BPMAP bp_list;

    if(root.via.array.size < 2 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER) {
        msgpack::pack(response_buffer, false);
        return;
    }

    root.via.array.ptr[1].convert(bp_type);

    int n_bps = DbgGetBpList((BPXTYPE)bp_type, &bp_list);
    std::vector<BpxTup> bp_vec;
    for (int i = 0; i < n_bps; i++) {
        bp_vec.push_back(BpxTup(
            bp_list.bp[i].type,
            bp_list.bp[i].addr,
            bp_list.bp[i].enabled,
            bp_list.bp[i].singleshoot,
            bp_list.bp[i].active,
            std::string(bp_list.bp[i].name),
            std::string(bp_list.bp[i].mod),
            bp_list.bp[i].slot,
            bp_list.bp[i].typeEx,
            bp_list.bp[i].hwSize,
            bp_list.bp[i].hitCount,
            bp_list.bp[i].fastResume,
            bp_list.bp[i].silent,
            std::string(bp_list.bp[i].breakCondition),
            std::string(bp_list.bp[i].logText),
            std::string(bp_list.bp[i].logCondition),
            std::string(bp_list.bp[i].commandText),
            std::string(bp_list.bp[i].commandCondition)
        ));
        BridgeFree(bp_list.bp);
    }

    msgpack::pack(response_buffer, bp_vec);
}

void get_label_at(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;
    size_t sreg;
    char text[MAX_LABEL_SIZE];
    memset(text, 0, MAX_LABEL_SIZE);

    if(root.via.array.size < 3 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER || root.via.array.ptr[2].type != msgpack::type::POSITIVE_INTEGER) {
        msgpack::pack(response_buffer, false);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    root.via.array.ptr[2].convert(sreg);
    bool res = DbgGetLabelAt(addr, (SEGMENTREG)sreg, text);
    msgpack::pack(response_buffer, std::tuple<bool, std::string>(res, std::string(text)));
}

void get_comment_at(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;
    char text[MAX_COMMENT_SIZE];
    memset(text, 0, MAX_COMMENT_SIZE);

    if(root.via.array.size < 2 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER) {
        msgpack::pack(response_buffer, false);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    bool res = DbgGetCommentAt(addr, text);
    msgpack::pack(response_buffer, std::tuple<bool, std::string>(res, std::string(text)));
}

void get_symbol_at(msgpack::object root, msgpack::sbuffer& response_buffer) {
    size_t addr;
    SYMBOLINFO* info = (SYMBOLINFO*)BridgeAlloc(sizeof(SYMBOLINFO));

    if(root.via.array.size < 2 || root.via.array.ptr[1].type != msgpack::type::POSITIVE_INTEGER) {
        msgpack::pack(response_buffer, false);
        return;
    }

    root.via.array.ptr[1].convert(addr);
    bool res = DbgGetSymbolInfoAt(addr, info);
    msgpack::pack(response_buffer, std::tuple<bool, size_t, std::string, std::string, size_t, size_t>(
        res,
        info->addr,
        std::string(info->decoratedSymbol),
        std::string(info->undecoratedSymbol),
        info->type,
        info->ordinal
    ));

    if (info->freeDecorated) {
        BridgeFree(info->decoratedSymbol);
    }
    if (info->freeUndecorated) {
        BridgeFree(info->undecoratedSymbol);
    }
    BridgeFree(info);
}

std::wstring get_session_filename(size_t session_pid) {
    wchar_t temp_path[MAX_PATH * 4];
    if (GetTempPathW(MAX_PATH * 2, temp_path) == 0) {
        dprintf("Failed to get temp path\n");
        wcscpy(temp_path, L"c:\\windows\\temp\\");
    }

    return std::wstring(temp_path) + L"xauto_session." + std::to_wstring(session_pid) + L".lock";
}



================================================
File: src/xauto_cmd.h
================================================
#pragma once
#include <msgpack.hpp>
#include <cstdint>


constexpr const char* XAUTO_COMPAT_VERSION = "bitter_oyster"; // TODO: externalize


class XAutoErrorResponse {
public:
    std::string success;
    std::string error_string;
    MSGPACK_DEFINE(success, error_string);
};

void get_debugger_pid(msgpack::sbuffer& response_buffer);
void get_compat_v(msgpack::sbuffer& response_buffer);
void get_debugger_version(msgpack::sbuffer& response_buffer);
void dbg_eval(msgpack::object root, msgpack::sbuffer& response_buffer);
void dbg_cmd_exec_direct(msgpack::object root, msgpack::sbuffer& response_buffer);
void dbg_is_running(msgpack::sbuffer& response_buffer);
void dbg_is_debugging(msgpack::sbuffer& response_buffer);
void dbg_is_elevated(msgpack::sbuffer& response_buffer);
void dbg_memmap(msgpack::sbuffer& response_buffer);
void dbg_get_bitness(msgpack::sbuffer& response_buffer);
void gui_refresh_views(msgpack::sbuffer& response_buffer);

typedef std::tuple<size_t, size_t, uint32_t, uint16_t, size_t, uint32_t, uint32_t, uint32_t, std::string> MemPageTup;
void dbg_memmap(msgpack::sbuffer& response_buffer);
void dbg_read_memory(msgpack::object root, msgpack::sbuffer& response_buffer);
void dbg_write_memory(msgpack::object root, msgpack::sbuffer& response_buffer);


typedef std::tuple<uint16_t, uint16_t, uint16_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t> x87fpuTup;
typedef std::tuple<
    size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, // gp regs
    size_t, size_t, // ip, flags
    uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, // segs
    size_t, size_t, size_t, size_t, size_t, size_t, // dregs
    std::array<uint8_t, 80>,
    x87fpuTup,
    uint32_t,
    std::array<uint8_t, 16 * 16>,
    std::array<uint8_t, 16 * 32>
> CtxTup64;
typedef std::tuple<
    size_t, size_t, size_t, size_t, size_t, size_t, size_t, size_t, // gp regs
    size_t, size_t, // ip, flags
    uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, // segs
    size_t, size_t, size_t, size_t, size_t, size_t, // dregs
    std::array<uint8_t, 80>,
    x87fpuTup,
    uint32_t,
    std::array<uint8_t, 8 * 16>,
    std::array<uint8_t, 8 * 32>
> CtxTup32;
typedef std::tuple<bool, bool, bool, bool, bool, bool, bool, bool, bool> FlagsTup;
typedef std::tuple<std::array<uint8_t, 10>, size_t, size_t> FpuRegsTup;
typedef std::array<FpuRegsTup, 8> FpuRegsArr;
typedef std::array<uint64_t, 8> MmxArr;
typedef std::tuple<bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, uint16_t> MxcsrFieldsTup;
typedef std::tuple<bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, uint16_t> x87StatusWordFieldsTup;
typedef std::tuple<bool, bool, bool, bool, bool, bool, bool, bool, uint16_t, uint16_t> x87ControlWordFieldsTup;
void dbg_read_regs(msgpack::sbuffer& response_buffer);
void dbg_read_setting_sz(msgpack::object root, msgpack::sbuffer& response_buffer);
void dbg_write_setting_sz(msgpack::object root, msgpack::sbuffer& response_buffer);
void dbg_read_setting_uint(msgpack::object root, msgpack::sbuffer& response_buffer);
void dbg_write_setting_uint(msgpack::object root, msgpack::sbuffer& response_buffer);
void dbg_is_valid_read_ptr(msgpack::object root, msgpack::sbuffer& response_buffer);

typedef std::tuple<std::string, size_t, size_t, size_t, size_t, size_t> DisasmArgTup;
typedef std::tuple<std::string, size_t, size_t, size_t, std::array<DisasmArgTup, 3>> DisasmTup;
void disassemble_at(msgpack::object root, msgpack::sbuffer& response_buffer);
void assemble_at(msgpack::object root, msgpack::sbuffer& response_buffer);

typedef std::tuple<
    size_t, size_t, bool, bool, bool, std::string, std::string, 
    uint16_t, uint8_t, uint8_t, size_t, bool, bool, std::string, 
    std::string, std::string, std::string, std::string> BpxTup;
void get_breakpoints(msgpack::object root, msgpack::sbuffer& response_buffer);
void get_label_at(msgpack::object root, msgpack::sbuffer& response_buffer);
void get_comment_at(msgpack::object root, msgpack::sbuffer& response_buffer);
void get_symbol_at(msgpack::object root, msgpack::sbuffer& response_buffer);
std::wstring get_session_filename(size_t session_pid);



================================================
File: src/xauto_server.cpp
================================================
#include "pluginmain.h"
#include "xauto_server.h"
#include "xauto_cmd.h"

#include <thread>
#include <fstream>
#include <random>


using namespace msgpack;


constexpr int DISPATCH_CONTINUE = 0;
constexpr int DISPATCH_EXIT = -1;


int XAutoServer::_dispatch_cmd(msgpack::object root, msgpack::sbuffer& response_buffer) {
    if (root.type == msgpack::type::STR) {
        std::string str;
        root.convert(str);
        if (str == "PING") {
            msgpack::pack(response_buffer, "PONG");
        }
    } else if (root.type == msgpack::type::ARRAY && root.via.array.size > 0 && root.via.array.ptr[0].type == msgpack::type::STR) {
        std::string cmd;
        root.via.array.ptr[0].convert(cmd);
        if (cmd == XAUTO_REQ_DEBUGGER_PID) {
            get_debugger_pid(response_buffer);
        } else if (cmd == XAUTO_REQ_COMPAT_VERSION) {
            get_compat_v(response_buffer);
        } else if (cmd == XAUTO_REQ_DEBUGGER_VERSION) {
            get_debugger_version(response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_EVAL) {
            dbg_eval(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_CMD_EXEC_DIRECT) {
            dbg_cmd_exec_direct(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_IS_RUNNING) {
            dbg_is_running(response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_IS_DEBUGGING) {
            dbg_is_debugging(response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_IS_ELEVATED) {
            dbg_is_elevated(response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_MEMMAP) {
            dbg_memmap(response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_GET_BITNESS) {
            dbg_get_bitness(response_buffer);
        } else if (cmd == XAUTO_REQ_GUI_REFRESH_VIEWS) {
            gui_refresh_views(response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_READ_MEMORY) {
            dbg_read_memory(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_WRITE_MEMORY) {
            dbg_write_memory(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_READ_REGISTERS) {
            dbg_read_regs(response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_READ_SETTING_SZ) {
            dbg_read_setting_sz(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_WRITE_SETTING_SZ) {
            dbg_write_setting_sz(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_READ_SETTING_UINT) {
            dbg_read_setting_uint(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_WRITE_SETTING_UINT) {
            dbg_write_setting_uint(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DBG_IS_VALID_READ_PTR) {
            dbg_is_valid_read_ptr(root, response_buffer);
        } else if (cmd == XAUTO_REQ_DISASSEMBLE) {
            disassemble_at(root, response_buffer);
        } else if (cmd == XAUTO_REQ_ASSEMBLE) {
            assemble_at(root, response_buffer);
        } else if (cmd == XAUTO_REQ_GET_BREAKPOINTS) {
            get_breakpoints(root, response_buffer);
        } else if (cmd == XAUTO_REQ_GET_LABEL) {
            get_label_at(root, response_buffer);
        } else if (cmd == XAUTO_REQ_GET_COMMENT) {
            get_comment_at(root, response_buffer);
        } else if (cmd == XAUTO_REQ_GET_SYMBOL) {
            get_symbol_at(root, response_buffer);
        } else if (cmd == XAUTO_REQ_QUIT) {
            msgpack::pack(response_buffer, "OK_QUITTING");
            return DISPATCH_EXIT;
        }
    }

    return DISPATCH_CONTINUE;
}


void XAutoServer::xauto_srv_req_rep_thread() {
    try {
        for (;;) 
        {
            zmq::message_t request;
            msgpack::sbuffer outbuf;

            auto res = rep_socket.recv(request, zmq::recv_flags::none);
            if (!res.has_value()) {
                dprintf("zmq error, failed to recv message: %s (0x%X)\n", zmq_strerror(zmq_errno()), zmq_errno());
                continue;
            }

            msgpack::object_handle oh = msgpack::unpack((const char*)request.data(), request.size());
            msgpack::object root = oh.get();
            auto dispatch_exit = _dispatch_cmd(root, outbuf);

            if (outbuf.size() == 0) {
                dprintf("Received: unknown\n");
                XAutoErrorResponse err_resp_obj = {"XERROR_UNK", "Could not understand input"};
                msgpack::pack(outbuf, err_resp_obj);
            }

            rep_socket.send(zmq::buffer(outbuf.data(), outbuf.size()), zmq::send_flags::none);

            if (dispatch_exit == DISPATCH_EXIT) {
                break;
            }
        }

        dprintf("Caught request to terminate\n");
        GuiCloseApplication();
    } catch (const zmq::error_t& e) {
        dprintf("ZMQ Error: %s\n", e.what());
    }
}


bool XAutoServer::acquire_session() {
    session_pid = GetCurrentProcessId();

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distrib(0xc000, 0xFFFF);

    rep_socket = zmq::socket_t(context, zmq::socket_type::rep);
    while(true) {
        try {
            sess_req_rep_port = distrib(gen);
            rep_socket.bind(("tcp://localhost:" + std::to_string(sess_req_rep_port)).c_str());
            break;
        } catch (const zmq::error_t& e) {
            dprintf("Failed to bind REQ/REP socket, retrying: %s\n", e.what());
            continue;
        }
    }
    dprintf("Allocated REQ/REP port: %d\n", sess_req_rep_port);

    pub_socket = zmq::socket_t(context, zmq::socket_type::pub);
    while(true) {
        try {
            sess_pub_sub_port = distrib(gen);
            pub_socket.bind(("tcp://localhost:" + std::to_string(sess_pub_sub_port)).c_str());
            break;
        } catch (const zmq::error_t& e) {
            dprintf("Failed to bind PUB/SUB socket, retrying: %s\n", e.what());
            continue;
        }
    }
    dprintf("Allocated PUB/SUB port: %d\n", sess_pub_sub_port);

    std::wstring session_file = get_session_filename(session_pid);
    std::ofstream session_out(session_file);
    if (!session_out.is_open()) {
        dprintf("Failed to open session file: %s\n", session_file.c_str());
        return false;
    }
    session_out << sess_req_rep_port << std::endl << sess_pub_sub_port << std::endl;
    session_out.close();

    dprintf("Allocated session ID: %d\n", session_pid);
    return true;
}


void XAutoServer::release_session() {
    rep_socket.close();
    pub_socket.close();

    auto sess_filename = get_session_filename(session_pid);
    if (_wremove(sess_filename.c_str()) != 0) {
        dprintf("Failed to release session file: %s\n", sess_filename.c_str());
        return;
    } else {
        dprintf("Culled session ID: %d\n", session_pid);
    }
}


XAutoServer::XAutoServer() {
    context = zmq::context_t(1);
    if(!acquire_session()){
        dprintf("Failed to acquire session, plugin execution cannot continue\n");
        return;
    }

    std::thread(std::bind(&XAutoServer::xauto_srv_req_rep_thread, this)).detach();
}



================================================
File: src/xauto_server.h
================================================
#pragma once
#include <cstdint>
#include <zmq.hpp>
#include <msgpack.hpp>


constexpr const char* XAUTO_REQ_DEBUGGER_PID = "XAUTO_REQ_DEBUGGER_PID";
constexpr const char* XAUTO_REQ_COMPAT_VERSION = "XAUTO_REQ_COMPAT_VERSION";
constexpr const char* XAUTO_REQ_DEBUGGER_VERSION = "XAUTO_REQ_DEBUGGER_VERSION";
constexpr const char* XAUTO_REQ_QUIT = "XAUTO_REQ_QUIT";
constexpr const char* XAUTO_REQ_DBG_EVAL = "XAUTO_REQ_DBG_EVAL";
constexpr const char* XAUTO_REQ_DBG_CMD_EXEC_DIRECT = "XAUTO_REQ_DBG_CMD_EXEC_DIRECT";
constexpr const char* XAUTO_REQ_DBG_IS_RUNNING = "XAUTO_REQ_DBG_IS_RUNNING";
constexpr const char* XAUTO_REQ_DBG_IS_DEBUGGING = "XAUTO_REQ_DBG_IS_DEBUGGING";
constexpr const char* XAUTO_REQ_DBG_IS_ELEVATED = "XAUTO_REQ_DBG_IS_ELEVATED";
constexpr const char* XAUTO_REQ_DBG_MEMMAP = "XAUTO_REQ_DBG_MEMMAP";
constexpr const char* XAUTO_REQ_DBG_GET_BITNESS = "XAUTO_REQ_DBG_GET_BITNESS";
constexpr const char* XAUTO_REQ_GUI_REFRESH_VIEWS = "XAUTO_REQ_GUI_REFRESH_VIEWS";
constexpr const char* XAUTO_REQ_DBG_READ_MEMORY = "XAUTO_REQ_DBG_READ_MEMORY";
constexpr const char* XAUTO_REQ_DBG_WRITE_MEMORY = "XAUTO_REQ_DBG_WRITE_MEMORY";
constexpr const char* XAUTO_REQ_DBG_READ_REGISTERS = "XAUTO_REQ_DBG_READ_REGISTERS";
constexpr const char* XAUTO_REQ_DBG_READ_SETTING_SZ = "XAUTO_REQ_DBG_READ_SETTING_SZ";
constexpr const char* XAUTO_REQ_DBG_WRITE_SETTING_SZ = "XAUTO_REQ_DBG_WRITE_SETTING_SZ";
constexpr const char* XAUTO_REQ_DBG_READ_SETTING_UINT = "XAUTO_REQ_DBG_READ_SETTING_UINT";
constexpr const char* XAUTO_REQ_DBG_WRITE_SETTING_UINT = "XAUTO_REQ_DBG_WRITE_SETTING_UINT";
constexpr const char* XAUTO_REQ_DBG_IS_VALID_READ_PTR = "XAUTO_REQ_DBG_IS_VALID_READ_PTR";
constexpr const char* XAUTO_REQ_DISASSEMBLE = "XAUTO_REQ_DISASSEMBLE";
constexpr const char* XAUTO_REQ_ASSEMBLE = "XAUTO_REQ_ASSEMBLE";
constexpr const char* XAUTO_REQ_GET_BREAKPOINTS = "XAUTO_REQ_GET_BREAKPOINTS";
constexpr const char* XAUTO_REQ_GET_LABEL = "XAUTO_REQ_GET_LABEL";
constexpr const char* XAUTO_REQ_GET_COMMENT = "XAUTO_REQ_GET_COMMENT";
constexpr const char* XAUTO_REQ_GET_SYMBOL = "XAUTO_REQ_GET_SYMBOL";

class XAutoServer {
    public:
    zmq::socket_t pub_socket;
    zmq::socket_t rep_socket;
    uint16_t sess_req_rep_port = 0;
    uint16_t sess_pub_sub_port = 0;

    XAutoServer();
    void release_session();

    private:
    size_t session_pid = 0;
    zmq::context_t context;

    void xauto_srv_req_rep_thread();
    bool acquire_session();
    int _dispatch_cmd(msgpack::object root, msgpack::sbuffer& response_buffer);
};



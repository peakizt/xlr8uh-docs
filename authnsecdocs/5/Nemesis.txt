Directory structure:
└── not-matthias-nemesis/
    ├── README.md
    ├── LICENSE
    ├── Nemesis.sln
    ├── Nemesis.sln.DotSettings
    ├── Driver/
    │   ├── Driver.c
    │   ├── Driver.inf
    │   ├── Driver.vcxproj
    │   ├── Driver.vcxproj.filters
    │   ├── Logger.h
    │   └── ntos.h
    ├── Nemesis/
    │   ├── Config.cpp
    │   ├── Config.hpp
    │   ├── ConfigExport.cpp
    │   ├── ConfigExport.hpp
    │   ├── DllMain.cpp
    │   ├── DriverExport.cpp
    │   ├── DriverExport.hpp
    │   ├── DriverUtils.cpp
    │   ├── DriverUtils.hpp
    │   ├── DumpExport.cpp
    │   ├── DumpExport.hpp
    │   ├── FileReader.cpp
    │   ├── FileReader.hpp
    │   ├── FileWriter.cpp
    │   ├── FileWriter.hpp
    │   ├── IMemorySource.cpp
    │   ├── IMemorySource.hpp
    │   ├── KernelMemory.cpp
    │   ├── KernelMemory.hpp
    │   ├── Logger.cpp
    │   ├── Logger.hpp
    │   ├── Memory.cpp
    │   ├── Memory.hpp
    │   ├── MemorySource.cpp
    │   ├── MemorySource.h
    │   ├── MemorySourceExport.cpp
    │   ├── MemorySourceExport.hpp
    │   ├── Module.cpp
    │   ├── Module.hpp
    │   ├── Nemesis.vcxproj
    │   ├── Nemesis.vcxproj.filters
    │   ├── ProcessExport.cpp
    │   ├── ProcessExport.hpp
    │   ├── ProcessMemory.cpp
    │   ├── ProcessMemory.hpp
    │   ├── ProcessUtils.cpp
    │   ├── ProcessUtils.hpp
    │   ├── Section.hpp
    │   ├── SmartHandle.cpp
    │   ├── SmartHandle.hpp
    │   ├── SmartMemory.cpp
    │   ├── SmartMemory.hpp
    │   ├── UsermodeMemory.cpp
    │   ├── UsermodeMemory.hpp
    │   ├── cpp.hint
    │   ├── exports.def
    │   ├── stdafx.cpp
    │   └── stdafx.h
    ├── Nemesis.GUI/
    │   ├── App.config
    │   ├── Nemesis.GUI.csproj
    │   ├── Program.cs
    │   ├── packages.config
    │   ├── Forms/
    │   │   ├── About.Designer.cs
    │   │   ├── About.cs
    │   │   ├── About.resx
    │   │   ├── NemesisForm.Designer.cs
    │   │   ├── NemesisForm.cs
    │   │   ├── NemesisForm.resx
    │   │   ├── ProcessInfo.Designer.cs
    │   │   ├── ProcessInfo.cs
    │   │   ├── ProcessInfo.resx
    │   │   ├── Settings.Designer.cs
    │   │   ├── Settings.cs
    │   │   ├── Settings.resx
    │   │   └── Utils/
    │   │       ├── Driver/
    │   │       │   ├── DriverListItem.cs
    │   │       │   ├── DriverListView.Designer.cs
    │   │       │   ├── DriverListView.cs
    │   │       │   └── DriverSorter.cs
    │   │       ├── Memory/
    │   │       │   ├── MemoryListItem.cs
    │   │       │   ├── MemoryListView.Designer.cs
    │   │       │   ├── MemoryListView.cs
    │   │       │   └── MemorySorter.cs
    │   │       ├── Module/
    │   │       │   ├── ModuleListItem.cs
    │   │       │   ├── ModuleListView.Designer.cs
    │   │       │   ├── ModuleListView.cs
    │   │       │   └── ModuleSorter.cs
    │   │       └── Process/
    │   │           ├── ProcessListItem.cs
    │   │           ├── ProcessListView.cs
    │   │           └── ProcessSorter.cs
    │   ├── Properties/
    │   │   ├── AssemblyInfo.cs
    │   │   ├── Resources.Designer.cs
    │   │   ├── Resources.resx
    │   │   ├── Settings.Designer.cs
    │   │   ├── Settings.settings
    │   │   └── app.manifest
    │   └── Utils/
    │       ├── Config.cs
    │       ├── NemesisApi.cs
    │       └── StyleExtension.cs
    └── .github/
        └── ISSUE_TEMPLATE/
            ├── bug_report.md
            └── feature_request.md

================================================
File: README.md
================================================
# Nemesis

A customizable process dumper.

![alt](https://user-images.githubusercontent.com/26800596/59287543-22d42680-8c72-11e9-8f27-c4c6f132850a.png)

## Usage

Just select whatever you want (Process, Dll, Driver, ...) and click on the dump button. If it was successful, you can load the file into decompilers like [IDA Pro], [Ghidra] or [Binary Ninja]. Some of these programs are available for free, but of course they won't be as good as the paid ones. Here's a short list of the different versions:

Paid: 
- [IDA Pro]
- [Binary Ninja]

Free:
- [Ghidra]
- [IDA Freeware]
- [Binary Ninja Demo]

[IDA Pro]: https://www.hex-rays.com/products/ida/index.shtml
[Ghidra]: https://ghidra-sre.org/
[Binary Ninja]: https://binary.ninja/
[IDA Freeware]: https://www.hex-rays.com/products/ida/support/download_freeware.shtml
[Binary Ninja Demo]: https://binary.ninja/demo/

> Note: If you want another decompiler added, feel free to create a pull request or issue.

## Features

### General

- Both x86 and x64
- Dump:
  - Processes 
  - Modules
  - Memory
  - Drivers
- PE Rebuild
- Switch memory sources

### Application

- Simple and intuitive design

- Custom locations

- Sortable lists

- Keyboard shortcuts

- Customizable GUI

- Dark mode

## Memory Sources

### Problem

First of all, there's not really a public driver dumper, so you either had to rely on other people dumping them for you or write a dumper yourself. However, to be able to dump drivers, you need to have a kernel mode driver. It can be really annnoying if you just want to dump a simple process, if you have to load your driver beforehand. 

Of course there's tools which only dump processes with/without a kernel driver, but you'd need to install like 3 different programs just to be prepared for all situations.

### Solution

With Nemesis, you can simply switch memory sources with a single mouse click and use whatever you need. This does not only save you some time, but also a lot of disk space.

If you want to dump it with physical memory or via a hypervisor? Simply add a new memory source and you are good to go.

## Exports

Nemesis is also available as a dump library. If you want to implement a dumper, but don't want to mess with low level stuff, simply load the dll and use the following imports.

### ConfigExport


- [SetConfigValueExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/ConfigExport.hpp#L9)

- [GetConfigValueExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/ConfigExport.hpp#L11)

### DriverExport

- [GetDriverListElementExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/DriverExport.hpp#L31)

- [SaveDriverInformationExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/DriverExport.hpp#L39)

### DumpExport

- [DumpProcessExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/DumpExport.hpp#L11)

- [DumpModuleExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/DumpExport.hpp#L20)

- [DumpMemoryExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/DumpExport.hpp#L30)

- [DumpDriverExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/DumpExport.hpp#L38)

### MemorySourceExport

- [GetMemorySourcesExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/MemorySourceExport.h#L16)

### ProcessExport

- [GetProcessListElementExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/ProcessExport.hpp#L64)

- [GetModuleListElementExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/ProcessExport.hpp#L73)

- [GetManualModuleListElementExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/ProcessExport.hpp#L82)

- [GetMemoryListElementExport](https://github.com/not-matthias/Nemesis/blob/master/Nemesis/ProcessExport.hpp#L91)

### Keyboard Shortcuts

<kbd>CTRL+D</kbd> - Dump the selected process or driver

<kbd>CTRL+R</kbd> - Refresh the process and driver list

<kbd>CTRL+ALT+S</kbd> - Open the settings

## Disclaimer

Use at your own risk. It might destroy the Earth. 

## References

- https://github.com/NtQuery/Scylla/
- https://github.com/EquiFox/KsDumper
- https://www.unknowncheats.me/
- https://stackoverflow.com
- https://msdn.com



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2019 not-matthias

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: Nemesis.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28729.10
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Driver", "Driver\Driver.vcxproj", "{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Nemesis", "Nemesis\Nemesis.vcxproj", "{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Nemesis.GUI", "Nemesis.GUI\Nemesis.GUI.csproj", "{20312010-AB4F-4DC7-93DA-C82EBED127A5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|ARM.ActiveCfg = Debug|ARM
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|ARM.Build.0 = Debug|ARM
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|ARM.Deploy.0 = Debug|ARM
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|ARM64.Build.0 = Debug|ARM64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|x64.ActiveCfg = Debug|x64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|x64.Build.0 = Debug|x64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|x64.Deploy.0 = Debug|x64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|x86.ActiveCfg = Debug|Win32
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|x86.Build.0 = Debug|Win32
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Debug|x86.Deploy.0 = Debug|Win32
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|Any CPU.ActiveCfg = Release|Win32
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|ARM.ActiveCfg = Release|ARM
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|ARM.Build.0 = Release|ARM
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|ARM.Deploy.0 = Release|ARM
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|ARM64.ActiveCfg = Release|ARM64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|ARM64.Build.0 = Release|ARM64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|ARM64.Deploy.0 = Release|ARM64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|x64.ActiveCfg = Release|x64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|x64.Build.0 = Release|x64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|x64.Deploy.0 = Release|x64
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|x86.ActiveCfg = Release|Win32
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|x86.Build.0 = Release|Win32
		{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}.Release|x86.Deploy.0 = Release|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Debug|ARM.ActiveCfg = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Debug|ARM64.ActiveCfg = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Debug|x64.ActiveCfg = Debug|x64
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Debug|x64.Build.0 = Debug|x64
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Debug|x86.ActiveCfg = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Debug|x86.Build.0 = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Release|Any CPU.ActiveCfg = Release|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Release|ARM.ActiveCfg = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Release|ARM64.ActiveCfg = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Release|x64.ActiveCfg = Release|x64
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Release|x64.Build.0 = Release|x64
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Release|x86.ActiveCfg = Debug|Win32
		{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}.Release|x86.Build.0 = Release|Win32
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|ARM.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|ARM64.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|x64.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|x64.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|x86.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Debug|x86.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|Any CPU.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|Any CPU.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|ARM.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|ARM.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|ARM64.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|ARM64.Build.0 = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|x64.ActiveCfg = Release|x64
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|x64.Build.0 = Release|x64
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|x86.ActiveCfg = Debug|Any CPU
		{20312010-AB4F-4DC7-93DA-C82EBED127A5}.Release|x86.Build.0 = Debug|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {48F3C20A-60B2-47C1-A7EA-DB34E9E58569}
	EndGlobalSection
EndGlobal



================================================
File: Nemesis.sln.DotSettings
================================================
ï»¿<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CppFormatting/SPACE_BEFORE_PTR_IN_DATA_MEMBER/@EntryValue">True</s:Boolean>
	<s:Int64 x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/WRAP_LIMIT/@EntryValue">160</s:Int64>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Class_0020Data_0020Members/@EntryIndexedValue">&lt;NamingElement Priority="5"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="class field" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" Prefix="" Suffix="" Style="aa_bb" /&gt;&lt;/NamingElement&gt;</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CppNaming/Rules/=Structs/@EntryIndexedValue">&lt;NamingElement Priority="11"&gt;&lt;Descriptor Static="Indeterminate" Constexpr="Indeterminate" Const="Indeterminate" Volatile="Indeterminate" Accessibility="NOT_APPLICABLE"&gt;&lt;type Name="struct" /&gt;&lt;/Descriptor&gt;&lt;Policy Inspect="True" Prefix="" Suffix="" Style="AA_BB"&gt;&lt;ExtraRule Prefix="_" Suffix="" Style="AA_BB" /&gt;&lt;ExtraRule Prefix="P" Suffix="" Style="AA_BB" /&gt;&lt;/Policy&gt;&lt;/NamingElement&gt;</s:String>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EFeature_002EServices_002ECpp_002ECodeStyle_002ESettingsUpgrade_002EFunctionReturnStyleSettingsUpgrader/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ECSharpKeepExistingMigration/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ECSharpPlaceEmbeddedOnSameLineMigration/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ECSharpUseContinuousIndentInsideBracesMigration/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/Environment/SettingsMigration/IsMigratorApplied/=JetBrains_002EReSharper_002EPsi_002ECSharp_002ECodeStyle_002ESettingsUpgrade_002EMigrateBlankLinesAroundFieldToBlankLinesAroundProperty/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=Usermode/@EntryIndexedValue">True</s:Boolean></wpf:ResourceDictionary>


================================================
File: Driver/Driver.c
================================================
#include <ntddk.h>

#include "ntos.h"
#include <ntdef.h>

#define IOCTL_READ_REQUEST				CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2222, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_BASE_ADDRESS_REQUEST		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2223, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

/**
 * \brief The struct for the kernel read request.
 */
typedef struct _READ_REQUEST
{
	//
	// In
	//
	ULONG process_id;
	PVOID target_address;

	//
	// Both
	//
	SIZE_T buffer_size;

	// 
	// Out
	// 
	BYTE *buffer_address;
} READ_REQUEST, *PREAD_REQUEST;

/**
 * \brief The struct for the base address request.
 */
typedef struct _BASE_ADDRESS_REQUEST
{
	//
	// In
	//
	ULONG process_id;

	// 
	// Out
	// 
	PVOID base_address;
} BASE_ADDRESS_REQUEST, *PBASE_ADDRESS_REQUEST;


UNICODE_STRING symbolic_link_name;

/**
 * \brief Copies the specified memory into the target address.
 * \param process_id The process id of the target process.	
 * \param source_address The source buffer address.
 * \param target_address The target buffer address.
 * \param buffer_size The size of the specified buffer.
 * \return STATUS_UNSUCCESSFUL or STATUS_SUCCESS
 */
NTSTATUS CopyVirtualMemory(const HANDLE process_id, const PVOID source_address, const PVOID target_address, const SIZE_T buffer_size)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	SIZE_T bytes_copied = 0;
	PEPROCESS source_process = NULL;
	const PEPROCESS target_process = PsGetCurrentProcess();

	DbgPrint("Reading virtual memory.\n");

	__try
	{
		// Don't check if it's a UM address
		if ((DWORD64)source_address > 0x7FFFFFFFFFFF && !MmIsAddressValid(source_address))
		{
			DbgPrint("Address is not valid.\n");
			goto EXIT;
		}


		if (!NT_SUCCESS(status = PsLookupProcessByProcessId(process_id, &source_process)))
		{
			DbgPrint("Failed to lookup process.\n");
			goto EXIT;
		}
		else
		{
			DbgPrint("Successfully looked up the process.\n");
		}

		//ProbeForRead(target_address, buffer_size, 1);

		if (!NT_SUCCESS(status = MmCopyVirtualMemory(source_process, source_address, target_process, target_address, buffer_size, KernelMode, &bytes_copied)))
		{
			DbgPrint("Failed to read virtual memory.\n");
		}
		else
		{
			DbgPrint("Successfully read virtual memory.\n");
		}


		ObDereferenceObject(source_process);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("Something went wrong while reading virtual memory. (%llx)\n", GetExceptionCode());
	}

EXIT:
	return status;
}

/**
 * \brief Handles the usermode requests. 
 * \param device_object 
 * \param irp 
 * \return STATUS_SUCCESS or STATUS_INVALID_PARAMETER
 */
NTSTATUS DeviceControl(PDEVICE_OBJECT device_object, const PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);

	//
	// Return values
	//
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	ULONG bytes = 0;

	//
	// Request stuff
	//
	const PIO_STACK_LOCATION stack_location = IoGetCurrentIrpStackLocation(irp);
	const ULONG control_code = stack_location->Parameters.DeviceIoControl.IoControlCode;

	PREAD_REQUEST read_request;
	PBASE_ADDRESS_REQUEST base_address_request;


	//
	// Handle the requests
	//
	switch (control_code)
	{
	case IOCTL_READ_REQUEST:
		read_request = (PREAD_REQUEST)irp->AssociatedIrp.SystemBuffer;

		DbgPrint("Received PREAD_REQUEST.\n");

		//
		// Check request data
		//
		if (read_request != NULL)
		{
			status = CopyVirtualMemory((HANDLE)read_request->process_id, read_request->target_address, read_request->buffer_address, read_request->buffer_size);
			bytes = sizeof(READ_REQUEST);
		}
		break;


	case IOCTL_BASE_ADDRESS_REQUEST:
		base_address_request = (PBASE_ADDRESS_REQUEST)irp->AssociatedIrp.SystemBuffer;

		DbgPrint("Received PBASE_ADDRESS_REQUEST.\n");

		//
		// Check request data
		//
		if (base_address_request != NULL)
		{
			PEPROCESS process;

			// 
			// Open process
			// 
			if (!NT_SUCCESS(status = PsLookupProcessByProcessId((HANDLE)base_address_request->process_id, &process)))
			{
				base_address_request->base_address = 0;
				break;
			}

			// 
			// Get the base address
			// 
			const PVOID base_address = PsGetProcessSectionBaseAddress(process);

			//
			// Cleanup
			//
			ObDereferenceObject(process);

			//
			// Return data
			//
			base_address_request->base_address = base_address;
			status = STATUS_SUCCESS;
			bytes = sizeof(BASE_ADDRESS_REQUEST);
		}
		break;


	default:
		status = STATUS_INVALID_PARAMETER;
		bytes = 0;
	}

	irp->IoStatus.Status = status;
	irp->IoStatus.Information = bytes;
	IoCompleteRequest(irp, IO_NO_INCREMENT);

	return status;
}

/**
 * \brief Deletes the symbolic link and device object.
 * \param driver_object
 */
VOID DriverUnload(const PDRIVER_OBJECT driver_object)
{
	//
	// Delete the symbolic link
	//
	IoDeleteSymbolicLink(&symbolic_link_name);

	//
	// Delete the device object
	//
	IoDeleteDevice(driver_object->DeviceObject);

	DbgPrint("Driver unloaded.\n");
}

/**
 * \brief Sets the io status to STATUS_NOT_SUPPORTED.
 * \param device_object 
 * \param irp 
 * \return STATUS_NOT_SUPPORTED
 */
NTSTATUS UnsupportedDispatch(PDEVICE_OBJECT device_object, const PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);

	irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return irp->IoStatus.Status;
}

/**
 * \brief Gets called whenever a handle to the driver has been created.
 * \param device_object 
 * \param irp 
 * \return The io status of the irp
 */
NTSTATUS CreateDispatch(PDEVICE_OBJECT device_object, const PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return irp->IoStatus.Status;
}

/**
 * \brief Gets called whenever the handle has been closed.
 * \param device_object 
 * \param irp 
 * \return The io status of the irp
 */
NTSTATUS CloseDispatch(PDEVICE_OBJECT device_object, const PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return irp->IoStatus.Status;
}

/**
 * \brief Initializes the driver (device object, symbolic link, major functions, ...)
 * \param driver_object
 * \param registry_path 
 * \return STATUS_SUCCESS or STATUS_UNSUCCESSFUL 
 */
NTSTATUS DriverInitialize(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path)
{
	UNREFERENCED_PARAMETER(registry_path);

	PDEVICE_OBJECT device_object;
	UNICODE_STRING device_name;

	//
	// Initialize the variables
	//
	RtlInitUnicodeString(&device_name, L"\\Device\\KernelMemory");
	RtlInitUnicodeString(&symbolic_link_name, L"\\DosDevices\\KernelMemory");

	//
	// Create the device object
	//
	if (!NT_SUCCESS(IoCreateDevice(driver_object, 0, &device_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &device_object)))
	{
		DbgPrint("Failed to create device object.\n");
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Create symbolic link
	//
	if (!NT_SUCCESS(IoCreateSymbolicLink(&symbolic_link_name, &device_name)))
	{
		DbgPrint("Failed to create symbolic link.\n");
		IoDeleteDevice(device_object);

		return STATUS_UNSUCCESSFUL;
	}

	//
	// Set flag
	//
	device_object->Flags |= DO_BUFFERED_IO;

	//
	// Set major functions
	//
	for (ULONG i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
		driver_object->MajorFunction[i] = &UnsupportedDispatch;

	driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceControl;
	driver_object->MajorFunction[IRP_MJ_CREATE] = &CreateDispatch;
	driver_object->MajorFunction[IRP_MJ_CLOSE] = &CloseDispatch;
	driver_object->DriverUnload = DriverUnload;

	//
	// Set flag
	//
	device_object->Flags &= ~DO_DEVICE_INITIALIZING;

	DbgPrint("Driver loaded.\n");

	return STATUS_SUCCESS;
}

/**
 * \brief Calls IoCreateDriver to create a new driver object.
 * \param driver_object 
 * \param registry_path 
 * \return The status of IoCreateDriver
 */
NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PUNICODE_STRING registry_path)
{
	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);

	//
	// Create driver
	//
	return IoCreateDriver(NULL, &DriverInitialize);
}



================================================
File: Driver/Driver.inf
================================================
;
; Driver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=Driver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
Driver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
Driver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%Driver.DeviceDesc%=Driver_Device, Root\Driver ; TODO: edit hw-id

[Driver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
Driver.sys

;-------------- Service installation
[Driver_Device.NT.Services]
AddService = Driver,%SPSVCINST_ASSOCSERVICE%, Driver_Service_Inst

; -------------- Driver driver install sections
[Driver_Service_Inst]
DisplayName    = %Driver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\Driver.sys

;
;--- Driver_Device Coinstaller installation ------
;

[Driver_Device.NT.CoInstallers]
AddReg=Driver_Device_CoInstaller_AddReg
CopyFiles=Driver_Device_CoInstaller_CopyFiles

[Driver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[Driver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[Driver_Device.NT.Wdf]
KmdfService =  Driver, Driver_wdfsect
[Driver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "Driver Installation Disk"
Driver.DeviceDesc = "Driver Device"
Driver.SVCDESC = "Driver Service"



================================================
File: Driver/Driver.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3C9EA4A6-9E08-49A7-9E0D-C59321B4D529}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Driver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Driver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Logger.h" />
    <ClInclude Include="ntos.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: Driver/Driver.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Driver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntos.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Logger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>


================================================
File: Driver/Logger.h
================================================
#pragma once

#include <ntdef.h>
#include <stdarg.h>
#include <ntddk.h>

#define DEBUG

//
// Only print if DEBUG defined 
//
#ifdef DEBUG

VOID Log(const PCSTR format, ...)
{
	va_list args;

	//
	// Check the format
	//
	if (!format)
		return;

	//
	// Initialize the variable list
	//
	va_start(args, format);

	//
	// Print it
	// 
	DbgPrint(format, args);

	//
	// Stop using the variable list
	//
	va_end(args);
}

#else

VOID Log(PCSTR Format, ...)
{
	return;
}

#endif


================================================
File: Driver/ntos.h
================================================
ï»¿#pragma once
#include <ntddk.h>

typedef unsigned char BYTE;

typedef struct _KAPC_STATE
{
	LIST_ENTRY ApcListHead[MaximumMode];
	struct _KPROCESS * Process;
	BOOLEAN KernelApcInProgress;
	BOOLEAN KernelApcPending;
	BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;


NTKERNELAPI VOID KeStackAttachProcess(
	PRKPROCESS   PROCESS,
	PRKAPC_STATE ApcState
);

NTKERNELAPI VOID KeUnstackDetachProcess(
	IN PRKAPC_STATE ApcState
);

NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(
	IN PEPROCESS Process
);

NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(
	IN HANDLE ProcessId,
	OUT PEPROCESS * Process
);

NTKERNELAPI NTSTATUS NTAPI MmCopyVirtualMemory(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

NTKERNELAPI NTSTATUS IoCreateDriver(
	IN PUNICODE_STRING DriverName, OPTIONAL
	IN PDRIVER_INITIALIZE InitializationFunction
);


================================================
File: Nemesis/Config.cpp
================================================
#include "stdafx.h"

#include "Config.hpp"

Config::Config(const std::wstring_view app_name, const std::wstring_view file_name) : app_name(app_name), file_name(file_name)
{
}

auto Config::Set(std::wstring_view key, std::wstring_view value) const -> BOOL
{
	return WritePrivateProfileString(app_name.data(), key.data(), value.data(), file_name.data()) > 0;
}

auto Config::Get(std::wstring_view key) const -> std::wstring
{
	std::wstring buffer (MAX_PATH, '\0');
	
	//
	// Get the string from the config
	//
	const auto characters_copied = GetPrivateProfileStringW(app_name.data(), key.data(), nullptr, buffer.data(), buffer.size(), file_name.data());
	if(characters_copied <= 0)
	{
		return std::wstring();
	}
	
	//
	// Resize the buffer
	//
	buffer.resize(characters_copied);

	return buffer;
}



================================================
File: Nemesis/Config.hpp
================================================
#pragma once

#include <string>
#include <Windows.h>

class Config
{
	/**
	 * \brief The name of the application.
	 */
	std::wstring_view app_name;
	
	/**
	 * \brief The path to the config file.
	 */
	std::wstring_view file_name;

public:

	/**
	 * \brief Initializes the variables.
	 * \param app_name the application name
	 * \param file_name the config path
	 */
	explicit Config(std::wstring_view app_name, std::wstring_view file_name);

	/**
	 * \brief Sets the key and value in the config.
	 * \param key the specified key
	 * \param value the specified value for the key
	 * \return true if successful
	 */
	auto Set(std::wstring_view key, std::wstring_view value) const -> BOOL;

	/**
	 * \brief Gets the value of the key from the config.
	 * \param key the key of the value
	 * \return the value
	 */
	auto Get(std::wstring_view key) const -> std::wstring;
};



================================================
File: Nemesis/ConfigExport.cpp
================================================
#include "stdafx.h"

#include "ConfigExport.hpp"

/**
 * \brief Sets the key and value in the config.
 * \param key the specified key
 * \param value the specified value for the key
 * \return true if successful
 */
auto SetConfigValueExport(const LPCWSTR key, const LPCWSTR value) -> BOOL
{
	return config.Set(key, value);
}

/**
 * \brief Gets the value of the key from the config.
 * \param key the key of the value
 * \return the value
 */
auto GetConfigValueExport(const LPCWSTR key) -> LPCWSTR
{
	return config.Get(key).c_str();
}



================================================
File: Nemesis/ConfigExport.hpp
================================================
#pragma once

#include <Windows.h>

#include "Config.hpp"

inline Config config(L"Nemesis", L"./Nemesis.ini");

auto SetConfigValueExport(LPCWSTR key, LPCWSTR value) -> BOOL;

auto GetConfigValueExport(LPCWSTR key) -> LPCWSTR;



================================================
File: Nemesis/DllMain.cpp
================================================
#include "stdafx.h"

#include <Windows.h>

BOOL WINAPI DllMain()
{
	return TRUE;
}



================================================
File: Nemesis/DriverExport.cpp
================================================
#include "stdafx.h"

#include "DriverExport.hpp"
#include "DriverUtils.hpp"

auto GetDriverListElementExport(const UINT index, Driver * driver) -> BOOL
{
	// TODO: Cache the driver list
	const auto driver_list = DriverUtils::GetDriverList();

	//
	// Check if in bounds
	//
	if (index < 0 || index >= driver_list.size())
	{
		return FALSE;
	}

	//
	// Check if driver is valid
	//
	if (driver == nullptr)
	{
		return FALSE;
	}

	*driver = driver_list[index];

	return TRUE;
}

auto SaveDriverInformationExport(const LPCSTR file_name) -> BOOL
{
	const auto driver_list = DriverUtils::GetDriverList();

	//
	// Open file
	//
	std::ofstream output_file(file_name, std::ios::app);

	//
	// Write to file
	//
	for (auto && driver : driver_list)
	{
		output_file << driver.full_path_name + driver.offset_to_file_name;
		output_file << " -> 0x" << driver.image_base;
		output_file << " (" << std::hex << driver.image_size << ")" << std::endl;
	}

	return TRUE;
}



================================================
File: Nemesis/DriverExport.hpp
================================================
#pragma once

#include <Windows.h>

/**
 * \brief Contains the driver data.
 */
struct Driver
{
	PVOID image_base;
	ULONG image_size;
	USHORT offset_to_file_name;
	UCHAR full_path_name[256];
};

/**
 * \brief Contains the list of drivers.
 */
struct DriverList
{
	Driver * drivers;
};


/**
 * \brief Returns the driver at the specified index. (C# has maximal struct size)
 * \param index the index in the list
 * \param driver the driver at the index
 * \return true if successful
 */
auto GetDriverListElementExport(IN UINT index, OUT Driver * driver) -> BOOL;


/**
 * \brief Saves the information about the loaded drivers.
 * \param file_name the file name of the list
 * \return true if successful
 */
auto SaveDriverInformationExport(IN LPCSTR file_name) -> BOOL;



================================================
File: Nemesis/DriverUtils.cpp
================================================
#include "stdafx.h"

#include "DriverUtils.hpp"

auto DriverUtils::GetDriverList() -> std::vector<Driver>
{
	//
	// Allocate memory for the module list
	//
	const auto buffer = VirtualAlloc(nullptr, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	std::unique_ptr<RTL_PROCESS_MODULES, MemoryDisposer> module_info(reinterpret_cast<PRTL_PROCESS_MODULES>(buffer), MemoryDisposer{});

	//
	// Check if the buffer is valid
	//
	if (!module_info)
	{
		return {};
	}

	//
	// Query the system information (aka drivers)
	//
	if (!NT_SUCCESS(NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(11), module_info.get(), 1024 * 1024, NULL)))
	{
		return {};
	}

	//
	// Create driver list
	//
	std::vector<Driver> drivers;
	drivers.reserve(module_info->number_of_modules);

	//
	// Loop through the drivers
	//
	for (ULONG i = 0; i < module_info->number_of_modules; i++)
	{
		//
		// Create a new driver
		//
		Driver driver{};
		driver.image_base = module_info->Modules[i].image_base;
		driver.image_size = module_info->Modules[i].image_size;
		driver.offset_to_file_name = module_info->Modules[i].offset_to_file_name;

		const auto full_path_name = module_info->Modules[i].full_path_name;
		const auto string_size = std::strlen(reinterpret_cast<char const *>(full_path_name));
		//std::copy(full_path_name[0], full_path_name[string_size], driver.full_path_name);
		// TODO: Find proper way to do this.

		//
		// Add the driver to the list
		//
		drivers.push_back(driver);
	}

	return drivers;
}



================================================
File: Nemesis/DriverUtils.hpp
================================================
#pragma once

#include <vector>
#include <Windows.h>

#include "DriverExport.hpp"

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE section;
	PVOID mapped_base;
	PVOID image_base;
	ULONG image_size;
	ULONG flags;
	USHORT load_order_index;
	USHORT init_order_index;
	USHORT load_count;
	USHORT offset_to_file_name;
	UCHAR full_path_name[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG number_of_modules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

struct MemoryDisposer
{
	void operator()(const PVOID buffer) const
	{
		VirtualFree(buffer, 0, MEM_RELEASE);
	}
};

class DriverUtils
{
public:

	/**
	 * \brief Creates the driver list.
	 * \return the driver list
	 */
	static auto GetDriverList() -> std::vector<Driver>;
};



================================================
File: Nemesis/DumpExport.cpp
================================================
#include "stdafx.h"

#include "DumpExport.hpp"
#include "FileWriter.hpp"
#include "Module.hpp"

auto DumpProcessExport(const DWORD process_id, const LPCWSTR file_name) -> BOOL
{
	//
	// Create the memory wrapper
	//
	ProcessMemory process_memory(process_id);
	if (!process_memory.IsValid())
	{
		return FALSE;
	}

	//
	// Create and initialize the module
	//
	Module module(&process_memory);
	if (!module.Initialize())
	{
		return FALSE;
	}

	module.SetFileAlignment();
	module.AlignSectionHeaders();
	module.FixHeader();
	module.RemoveIat();

	//
	// Write to file
	//
	FileWriter file_writer(file_name);
	if (file_writer.WriteToFile(&module))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

auto DumpModuleExport(const DWORD process_id, const DWORD_PTR base_address, const LPCWSTR file_name) -> BOOL
{
	//
	// Create the Memory wrapper
	//
	ProcessMemory process_memory(process_id);
	if (!process_memory.IsValid())
	{
		return FALSE;
	}

	//
	// Create and initialize the pe file
	//
	Module module(&process_memory, base_address);
	if (!module.Initialize())
	{
		return FALSE;
	}

	module.SetFileAlignment();
	module.AlignSectionHeaders();
	module.FixHeader();
	module.RemoveIat();

	//
	// Write to file
	//
	FileWriter file_writer(file_name);
	if (file_writer.WriteToFile(&module))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

auto DumpMemoryExport(const DWORD process_id, const DWORD_PTR start_address, const DWORD size, const LPCWSTR file_name) -> BOOL
{
	//
	// Create the Memory wrapper
	//
	ProcessMemory process_memory(process_id);
	if (!process_memory.IsValid())
	{
		return FALSE;
	}

	//
	// Create and initialize the Memory
	//
	MemoryElement memory(&process_memory, start_address, size);
	if (!memory.Initialize())
	{
		return FALSE;
	}

	//
	// Write to file
	//
	FileWriter file_writer(file_name);
	if (file_writer.WriteToFile(&memory))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

auto DumpDriverExport(const DWORD_PTR base_address, const LPCWSTR file_name) -> BOOL
{
	//
	// Create the Memory wrapper
	//
	ProcessMemory process_memory(4);
	if (!process_memory.IsValid())
	{
		return FALSE;
	}

	//
	// Create and initialize the pe file
	//
	Module module(&process_memory, base_address);
	if (!module.Initialize())
	{
		return FALSE;
	}

	module.SetFileAlignment();
	module.AlignSectionHeaders();
	module.FixHeader();
	module.RemoveIat();

	//
	// Write to file
	//
	FileWriter file_writer(file_name);
	if (file_writer.WriteToFile(&module))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



================================================
File: Nemesis/DumpExport.hpp
================================================
#pragma once

#include <Windows.h>

/**
 * \brief Dumps the main Module (e.g. process.exe).
 * \param process_id the id of the process
 * \param file_name the dump file name
 * \return true if successful
 */
auto DumpProcessExport(DWORD process_id, LPCSTR file_name) -> BOOL;

/**
 * \brief Dumps a specific Module (e.g. kernel32.dll).
 * \param process_id the id of the process
 * \param base_address the base address of the module
 * \param file_name the dump file name
 * \return true if successful
 */
auto DumpModuleExport(DWORD process_id, DWORD_PTR base_address, LPCSTR file_name) -> BOOL;

/**
 * \brief Dumps a specific memory region.
 * \param process_id the id of the process
 * \param start_address the starting address of the memory region
 * \param size the size of the memory region
 * \param file_name the dump file name
 * \return true if successful
 */
auto DumpMemoryExport(DWORD process_id, DWORD_PTR start_address, DWORD size, LPCSTR file_name) -> BOOL;

/**
 * \brief Dumps a specific drier.
 * \param base_address the base address of the driver
 * \param file_name the dump file name
 * \return true if successful
 */
auto DumpDriverExport(DWORD_PTR base_address, LPCSTR file_name) -> BOOL;



================================================
File: Nemesis/FileReader.cpp
================================================
#include "stdafx.h"

#include "FileReader.hpp"
#include "Logger.hpp"

FileReader::FileReader(std::wstring path) : path(std::move(path))
{
}

auto FileReader::Read(const LONG offset, const DWORD size) -> std::shared_ptr<BYTE>
{
	Logger::Log("Reading from the file '%s'.", path.data());

	//
	// Create the file
	//
	file_handle = SmartHandle(CreateFile(path.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr));
	if (!file_handle.IsValid())
	{
		return nullptr;
	}

	//
	// Set the file pointer
	//
	if (SetFilePointer(file_handle.Get(), offset, nullptr, FILE_BEGIN) == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR)
	{
		return nullptr;
	}

	//
	// Read from file
	//
	const auto buffer = std::shared_ptr<BYTE>(new BYTE[size], [](const BYTE * memory) { delete[] memory; });
	if (!ReadFile(file_handle.Get(), buffer.get(), size, nullptr, nullptr))
	{
		return nullptr;
	}

	return buffer;
}



================================================
File: Nemesis/FileReader.hpp
================================================
#pragma once

#include <string>
#include <Windows.h>

#include "SmartHandle.hpp"

class FileReader
{
	/**
	 * \brief The path to the file.
	 */
	std::wstring path;

	/**
	 * \brief The handle to the file.
	 */
	SmartHandle file_handle = nullptr;

public:

	/**
	 * \brief Stores the parameter.
	 * \param path the path of the file
	 */
	explicit FileReader(std::wstring path);

	/**
	 * \brief Reads from a file.
	 * \param offset the file offset
	 * \param size the buffer size
	 * \return the buffer
	 */
	auto Read(LONG offset, DWORD size) -> std::shared_ptr<BYTE>;
};



================================================
File: Nemesis/FileWriter.cpp
================================================
#include "stdafx.h"

#include "FileWriter.hpp"
#include "Logger.hpp"

FileWriter::FileWriter(std::wstring file_name) : file_name(std::move(file_name))
{
}

auto FileWriter::WriteToFile(Module * module) -> BOOL
{
	Logger::Log("Writing to the file '%s'.", file_name.data());

	//
	// Some checks
	//
	if (module->GetSectionCount() != module->sections.size())
	{
		return FALSE;
	}


	//
	// Create the file
	//
	file_handle = SmartHandle(CreateFile(file_name.c_str(), GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr));
	if (!file_handle.IsValid())
	{
		return FALSE;
	}


	//
	// DOS Header
	//
	DWORD file_offset = 0, write_size = sizeof(IMAGE_DOS_HEADER);
	if (!WriteMemoryToFile(file_offset, write_size, std::reinterpret_pointer_cast<BYTE>(module->dos_header)))
	{
		return FALSE;
	}
	file_offset += write_size;


	//
	// Stubs
	//
	if (module->dos_stub_size && module->dos_stub)
	{
		write_size = module->dos_stub_size;
		if (!WriteMemoryToFile(file_offset, write_size, module->dos_stub))
		{
			return FALSE;
		}
		file_offset += write_size;
	}


	//
	// PE Header
	//
	if (module->Is32Bit())
	{
		write_size = sizeof(IMAGE_NT_HEADERS32);

		if (!WriteMemoryToFile(file_offset, write_size, std::reinterpret_pointer_cast<BYTE>(module->nt_header32)))
		{
			return FALSE;
		}

		file_offset += write_size;
	}
	else
	{
		write_size = sizeof(IMAGE_NT_HEADERS64);

		if (!WriteMemoryToFile(file_offset, write_size, std::reinterpret_pointer_cast<BYTE>(module->nt_header64)))
		{
			return FALSE;
		}

		file_offset += write_size;
	}

	// 
	// Section Header
	// 
	write_size = sizeof(IMAGE_SECTION_HEADER);
	for (WORD i = 0; i < module->GetSectionCount(); i++)
	{
		// maybe & needed
		if (!WriteMemoryToFile(file_offset, write_size, std::reinterpret_pointer_cast<BYTE>(module->sections[i].section_header)))
		{
			return FALSE;
		}

		file_offset += write_size;
	}


	//
	// Sections
	//
	for (WORD i = 0; i < module->GetSectionCount(); i++)
	{
		// 
		// Raw data not found
		//
		if (module->sections[i].section_header->PointerToRawData == NULL)
			continue;

		//
		// PointerToRawData > dwFileOffset => Padding needed
		//
		if (module->sections[i].section_header->PointerToRawData > file_offset)
		{
			//
			// Calculate the padding
			//
			write_size = module->sections[i].section_header->PointerToRawData - file_offset;

			//
			// Write the padding
			//
			if (!WriteZeroMemoryToFile(file_offset, write_size))
			{
				return FALSE;
			}

			file_offset += write_size;
		}

		//
		// Write the section data
		//
		write_size = module->sections[i].buffer_size;

		if (!WriteMemoryToFile(module->sections[i].section_header->PointerToRawData, write_size, module->sections[i].buffer))
		{
			return FALSE;
		}

		file_offset += write_size;


		//
		// DataSize < SizeOfRawData => Padding needed
		//
		if (module->sections[i].buffer_size < module->sections[i].section_header->SizeOfRawData)
		{
			//
			// Calculate the padding
			//
			write_size = module->sections[i].section_header->SizeOfRawData - module->sections[i].buffer_size;

			//
			// Write the padding
			//
			if (!WriteZeroMemoryToFile(file_offset, write_size))
			{
				return FALSE;
			}

			file_offset += write_size;
		}
	}


	//
	// TODO: Add overlay
	//
	//if (overlaySize && overlayData)
	//{
	//	dwWriteSize = overlaySize;
	//	if (!ProcessAccessHelp::writeMemoryToFile(hFile, dwFileOffset, dwWriteSize, overlayData))
	//	{
	//		retValue = false;
	//	}
	//	dwFileOffset += dwWriteSize;
	//}


	//
	// Set EOL
	//
	SetEndOfFile(file_handle.Get());

	return TRUE;
}

auto FileWriter::WriteToFile(MemoryElement * memory) -> BOOL
{
	//
	// Create the file
	//
	file_handle = SmartHandle(CreateFile(file_name.c_str(), GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr));
	if (!file_handle.IsValid())
	{
		return FALSE;
	}

	//
	// Write the memory_buffer to the file
	//
	if (!WriteMemoryToFile(0, memory->memory_size, std::reinterpret_pointer_cast<BYTE>(memory->memory_buffer)))
	{
		return FALSE;
	}

	//
	// Set EOL
	//
	SetEndOfFile(file_handle.Get());

	return TRUE;
}

auto FileWriter::WriteMemoryToFile(const LONG offset, const DWORD size, const std::shared_ptr<BYTE> buffer) const -> BOOL
{
	DWORD number_of_bytes_written = 0;

	//
	// Some checks
	//
	if (!file_handle.IsValid() || !buffer)
	{
		return FALSE;
	}

	//
	// Set the file pointer
	//
	if (SetFilePointer(file_handle.Get(), offset, nullptr, FILE_BEGIN) == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR)
	{
		return FALSE;
	}

	//
	// Write to the file
	//
	if (!WriteFile(file_handle.Get(), buffer.get(), size, &number_of_bytes_written, nullptr))
	{
		return FALSE;
	}

	return TRUE;
}

auto FileWriter::WriteZeroMemoryToFile(const LONG offset, const DWORD size) const -> BOOL
{
	const std::shared_ptr<BYTE> buffer(new BYTE[size]{0}, [](const BYTE * memory) { delete[] memory; });

	//
	// Check the memory_buffer
	//
	if (!buffer)
	{
		return FALSE;
	}

	//
	// Write to file
	//
	if (!WriteMemoryToFile(offset, size, buffer))
	{
		return FALSE;
	}

	return TRUE;
}



================================================
File: Nemesis/FileWriter.hpp
================================================
#pragma once

#include <string>

#include "Memory.hpp"
#include "Module.hpp"
#include "SmartHandle.hpp"

class FileWriter
{
	/**
	 * \brief The name of the exported file.
	 */
	std::wstring file_name;

	/**
	 * \brief The handle to the file.
	 */
	SmartHandle file_handle = nullptr;

public:

	/**
	 * \brief Stores the parameter.
	 * \param file_name the name of the dump file
	 */
	explicit FileWriter(std::wstring file_name);

	/**
	 * \brief Writes the module to the file.
	 * \param module the module to dumped
	 * \return true if successful
	 */
	auto WriteToFile(Module * module) -> BOOL;

	/**
	 * \brief Writes the memory to the file.
	 * \param memory the memory to dump
	 * \return true if successful
	 */
	auto WriteToFile(MemoryElement * memory) -> BOOL;

	/**
	 * \brief Writes the specified buffer to the file.
	 * \param offset the file offset
	 * \param size the buffer size
	 * \param buffer 
	 * \return true if successful
	 */
	auto WriteMemoryToFile(LONG offset, DWORD size, std::shared_ptr<BYTE> buffer) const -> BOOL;

	/**
	 * \brief Writes zero memory to the file.
	 * \param offset 
	 * \param size 
	 * \return true if successful
	 */
	auto WriteZeroMemoryToFile(LONG offset, DWORD size) const -> BOOL;
};



================================================
File: Nemesis/IMemorySource.cpp
================================================
#include "stdafx.h"

#include "IMemorySource.hpp"

IMemorySource::IMemorySource(const DWORD process_id) : process_id(process_id)
{
}



================================================
File: Nemesis/IMemorySource.hpp
================================================
#pragma once

#include <Windows.h>

class IMemorySource
{
protected:

	/**
	 * \brief The process id.
	 */
	DWORD process_id;

public:

	/**
	 * \brief Stores the parameters.
	 * \param process_id the id of the process
	 */
	explicit IMemorySource(DWORD process_id);

	/**
	 * \brief Reads the memory from the process.
	 * \param start_address the memory start address
	 * \param size the buffer size
	 * \return the memory buffer
	 */
	virtual auto ReadMemory(DWORD_PTR start_address, SIZE_T size) -> std::shared_ptr<BYTE> = 0;
	
	/**
	 * \brief Checks whether the memory source is valid.
	 * \return true if valid
	 */
	virtual auto IsValid() -> BOOL = 0;

	/**
	 * \brief Returns the base address.
	 * \return the base address of the process
	 */
	virtual auto GetBaseAddress() -> DWORD_PTR = 0;
};



================================================
File: Nemesis/KernelMemory.cpp
================================================
#include "stdafx.h"

#include "KernelMemory.hpp"
#include "SmartMemory.hpp"

KernelMemory::KernelMemory(const DWORD process_id) : IMemorySource(process_id)
{
	//
	// Create connection to the driver
	//
	driver_handle = CreateFile(registry_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, NULL, nullptr);
}


auto KernelMemory::ReadMemory(const DWORD_PTR start_address, const SIZE_T size) -> std::shared_ptr<BYTE>
{
	//
	// Checks
	//
	if (!driver_handle.IsValid())
	{
		return nullptr;
	}

	//
	// Create memory
	//
	const std::shared_ptr<BYTE> buffer(new BYTE[size], [](const BYTE * memory) { delete[] memory; });

	//
	// Create the struct
	//
	READ_REQUEST read_request;
	read_request.process_id = process_id;
	read_request.target_address = start_address;
	read_request.buffer_address = buffer.get();
	read_request.buffer_size = size;

	//
	// Send the struct
	//
	if (DeviceIoControl(driver_handle.Get(), IOCTL_READ_REQUEST, &read_request, sizeof(read_request), &read_request, sizeof(read_request), nullptr, nullptr))
	{
		return buffer;
	}
	else
	{
		return nullptr;
	}
}

auto KernelMemory::IsValid() -> BOOL
{
	return driver_handle.IsValid();
}

auto KernelMemory::GetBaseAddress() -> DWORD_PTR
{
	//
	// Checks
	//
	if (!driver_handle.IsValid())
	{
		return NULL;
	}

	//
	// Create the struct
	//
	BASE_ADDRESS_REQUEST base_address_request;
	base_address_request.process_id = process_id;

	//
	// Send the struct
	//
	if (DeviceIoControl(driver_handle.Get(), IOCTL_BASE_ADDRESS_REQUEST, &base_address_request, sizeof(base_address_request), &base_address_request,
	                    sizeof(base_address_request), nullptr, nullptr))
	{
		return reinterpret_cast<DWORD_PTR>(base_address_request.base_address);
	}
	else
	{
		return NULL;
	}
}



================================================
File: Nemesis/KernelMemory.hpp
================================================
#pragma once

#include <Windows.h>

#include "IMemorySource.hpp"
#include "SmartHandle.hpp"

/**
 * \brief The read request ioctl
 */
#define IOCTL_READ_REQUEST				CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2222, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

/**
 * \brief The base address request ioctl
 */
#define IOCTL_BASE_ADDRESS_REQUEST		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2223, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

/**
 * \brief The struct for the kernel read request.
 */
typedef struct _READ_REQUEST
{
	//
	// In
	//
	ULONG process_id;
	DWORD_PTR target_address;

	//
	// Both
	//
	SIZE_T buffer_size;

	// 
	// Out
	// 
	BYTE * buffer_address;
} READ_REQUEST, *PREAD_REQUEST;

/**
 * \brief The struct for the base address request.
 */
typedef struct _BASE_ADDRESS_REQUEST
{
	//
	// In
	//
	ULONG process_id;

	// 
	// Out
	// 
	PVOID base_address;
} BASE_ADDRESS_REQUEST, *PBASE_ADDRESS_REQUEST;


class KernelMemory final : public IMemorySource
{
	/**
	 * \brief The symbolic link for the driver.
	 */
	LPCWSTR registry_path = L"\\\\?\\globalroot\\Device\\KernelMemory\\"; // \\\\.\\KernelMemory is not working

	/**
	 * \brief The driver handle.
	 */
	SmartHandle driver_handle = nullptr;

public:

	/**
	 * \brief Connects to the driver.
	 * \param process_id the id of the process
	 */
	explicit KernelMemory(DWORD process_id);

	/**
	 * \brief Reads the memory from the process.
	 * \param start_address the memory start address
	 * \param size the buffer size
	 * \return the memory buffer
	 */
	auto ReadMemory(DWORD_PTR start_address, SIZE_T size) -> std::shared_ptr<BYTE> override;

	/**
	 * \brief Checks whether the memory source is valid.
	 * \return true if valid
	 */
	auto IsValid() -> BOOL override;

	/**
	 * \brief Returns the base address.
	 * \return the base address of the process
	 */
	auto GetBaseAddress() -> DWORD_PTR override;
};



================================================
File: Nemesis/Logger.cpp
================================================
#include "stdafx.h"

#include "Logger.hpp"

std::string Logger::prefix = "[Nemesis] ";

auto Logger::Log(std::wstring format, ...) -> VOID
{
	if (format.empty())
		return;

	//
	// Insert the prefix
	//
	format.insert(format.begin(), prefix.begin(), prefix.end());

	//
	// Insert new line
	//
	format.push_back('\n');

	//
	// Print it
	//
	va_list arg_list;
	va_start(arg_list, format);
	vwprintf(format.data(), arg_list);
	va_end(arg_list);
}

auto Logger::Log(std::string format, ...) -> VOID
{
	if (format.empty())
		return;

	//
	// Insert the prefix
	//
	format.insert(0, prefix);

	//
	// Insert new line
	//
	format.append("\n");

	//
	// Print it
	//
	va_list arg_list;
	va_start(arg_list, format);
	vprintf(format.data(), arg_list);
	va_end(arg_list);
}



================================================
File: Nemesis/Logger.hpp
================================================
#pragma once

#include <string>

class Logger
{
	/**
	 * \brief Will be inserted at the beginning of the log.
	 */
	static std::string prefix;

public:

	/**
	 * \brief Prints the specified wide string.
	 * \param format The format string
	 * \param ... The additional parameters
	 */
	static auto Log(std::wstring format, ...) -> VOID;

	/**
	 * \brief Prints the specified string.
	 * \param format The format string
	 * \param ... The additional parameters
	 */
	static auto Log(std::string format, ...) -> VOID;
};



================================================
File: Nemesis/Memory.cpp
================================================
#include "stdafx.h"

#include "Logger.hpp"
#include "Memory.hpp"

MemoryElement::MemoryElement(ProcessMemory * process_memory, const DWORD_PTR start_address, const DWORD size) : process_memory(process_memory),
                                                                                                                start_address(start_address),
                                                                                                                memory_size(memory_size)
{
}

auto MemoryElement::Initialize() -> BOOL
{
	Logger::Log("Initializing the memory.");

	//
	// Get the Memory
	//
	memory_buffer = process_memory->ReadMemory(start_address, memory_size);

	//
	// Check if valid
	//
	if (memory_buffer == nullptr)
	{
		return FALSE;
	}

	return TRUE;
}



================================================
File: Nemesis/Memory.hpp
================================================
#pragma once

#include "ProcessMemory.hpp"

class MemoryElement
{
	/**
	 * \brief The process memory wrapper.
	 */
	ProcessMemory * process_memory;

public:

	/**
	 * \brief The memory start address.
	 */
	DWORD_PTR start_address;

	/**
	 * \brief The memory size.
	 */
	DWORD memory_size;

	/**
	 * \brief The memory buffer.
	 */
	std::shared_ptr<BYTE> memory_buffer;


	/**
	 * \brief Stores the parameters.
	 * \param process_memory the process memory wrapper
	 * \param start_address the memory start address
	 * \param size the memory size
	 */
	MemoryElement(ProcessMemory * process_memory, DWORD_PTR start_address, DWORD size);

	/**
	 * \brief Reads the memory and stores it in the memory_buffer.
	 * \return true if successful
	 */
	auto Initialize() -> BOOL;
};



================================================
File: Nemesis/MemorySource.cpp
================================================
#include "stdafx.h"

#include "KernelMemory.hpp"
#include "MemorySource.h"
#include "UsermodeMemory.hpp"
#include "ConfigExport.hpp"

std::vector<std::wstring> MemorySource::memory_sources = {L"kernel_mode", L"user_mode"};

auto MemorySource::GetMemorySource(const DWORD process_id) -> std::shared_ptr<IMemorySource>
{
	//
	// Get memory source from config (to survive restarts)
	//
	const auto current_memory_source = config.Get(L"memory_source");

	// 
	// Kernel Memory
	// 
	if (current_memory_source.find(L"kernel_mode") != std::string::npos)
	{
		return std::static_pointer_cast<IMemorySource>(std::make_shared<KernelMemory>(process_id));
	}

	//
	// Default: Usermode memory
	//
	return std::static_pointer_cast<IMemorySource>(std::make_shared<UsermodeMemory>(process_id));
}

auto MemorySource::GetMemorySources() -> std::vector<std::wstring>
{
	return memory_sources;
}



================================================
File: Nemesis/MemorySource.h
================================================
#pragma once

#include <memory>
#include <string>
#include <vector>

#include "IMemorySource.hpp"

class MemorySource
{
	/**
	 * \brief All the memory sources.
	 */
	static std::vector<std::wstring> memory_sources;

public:

	/**
	 * \brief Returns the memory source.
	 * \param process_id the id of the process
	 * \return the memory source the memory source
	 */
	static auto GetMemorySource(DWORD process_id) -> std::shared_ptr<IMemorySource>;

	/**
	 * \brief Returns all memory sources.
	 * \return the memory sources
	 */
	static auto GetMemorySources() -> std::vector<std::wstring>;
};



================================================
File: Nemesis/MemorySourceExport.cpp
================================================
#include "stdafx.h"

#include "MemorySourceExport.hpp"
#include "ProcessMemory.hpp"

auto GetMemorySourcesExport(MemorySources * memory_sources) -> VOID
{
	//
	// Copy the memory sources to the buffer
	//
	auto i = 0;
	for (auto & memory_source : MemorySource::GetMemorySources())
	{
		//
		// Add a string to set the end
		//
		memory_source.append(L"|");

		//
		// Create the char array
		//
		memory_sources->memory_sources[i] = new char[memory_source.length()];

		//
		// Clear the memory
		//
		RtlSecureZeroMemory(memory_sources->memory_sources[i], memory_source.length());

		//
		// Copy the string
		//
		std::copy(memory_source.begin(), memory_source.end(), memory_sources->memory_sources[i++]);
	}
}



================================================
File: Nemesis/MemorySourceExport.hpp
================================================
#pragma once

/**
 * \brief Contains the memory sources.
 */
struct MemorySources
{
	char * memory_sources[12];
};


/**
 * \brief Returns a list of memory sources.
 * \return the list of memory sources
 */
auto GetMemorySourcesExport(OUT MemorySources * memory_sources) -> VOID;



================================================
File: Nemesis/Module.cpp
================================================
#include "stdafx.h"

#include "FileReader.hpp"
#include "Logger.hpp"
#include "Module.hpp"
#include "ProcessUtils.hpp"
#include "ConfigExport.hpp"

Module::Module(ProcessMemory * process_memory) : process_memory(process_memory),
                                                 base_address(process_memory->GetBaseAddress()),
                                                 dos_stub(nullptr),
                                                 dos_stub_size(0),
                                                 dos_header(nullptr),
                                                 nt_header32(nullptr),
                                                 nt_header64(nullptr)
{
}

Module::Module(ProcessMemory * process_memory, const DWORD_PTR base_address) : Module(process_memory)
{
	this->base_address = base_address;
}


auto Module::Initialize() -> BOOL
{
	Logger::Log("Initializing the module.");

	//
	// Read the header from the Memory
	//
	if (config.Get(L"read_header_from_file") != L"On" && !ReadHeader())
	{
		return FALSE;
	}

	//
	// Read the header from the file
	//
	if (config.Get(L"read_header_from_file") == L"On" && !ReadHeaderFromFile())
	{
		return FALSE;
	}

	//
	// Set the sections from the Memory
	//
	SetSections();

	return TRUE;
}

auto Module::ReadHeader() -> BOOL
{
	Logger::Log("Reading the headers.");

	const auto header_size = GetHeaderSize();

	//
	// Get the pe header
	//
	const auto header_memory = process_memory->ReadMemory(base_address, header_size);

	//
	// Check if valid
	//
	if (header_memory == nullptr)
	{
		return FALSE;
	}

	//
	// Set the pe header
	//
	SetHeader(header_memory, header_size);

	return TRUE;
}

auto Module::ReadHeaderFromFile() -> BOOL
{
	Logger::Log("Reading the headers from file.");

	const auto header_size = GetHeaderSize();

	//
	// Get the filename
	//
	const auto path = ProcessUtils::GetFilePath(process_memory->GetProcessId());
	if (path.empty())
	{
		return FALSE;
	}

	//
	// Get the pe header
	//
	FileReader file_reader(path);
	const auto header_memory = file_reader.Read(0x0, header_size);

	//
	// Check if valid
	//
	if (header_memory == nullptr)
	{
		return FALSE;
	}

	//
	// Set the pe header
	//
	SetHeader(header_memory, header_size);

	return TRUE;
}


auto Module::SetHeader(const std::shared_ptr<BYTE> & header_memory, const DWORD header_size) -> VOID
{
	Logger::Log("Setting the headers.");

	dos_header = std::reinterpret_pointer_cast<IMAGE_DOS_HEADER>(header_memory);

	//
	// Malformed PE
	//
	if (dos_header->e_lfanew > 0 && dos_header->e_lfanew < static_cast<LONG>(header_size))
	{
		const std::shared_ptr<BYTE> nt_header(header_memory, reinterpret_cast<BYTE*>(dos_header.get()) + dos_header->e_lfanew);
		nt_header32 = std::reinterpret_pointer_cast<IMAGE_NT_HEADERS32>(nt_header);
		nt_header64 = std::reinterpret_pointer_cast<IMAGE_NT_HEADERS64>(nt_header);

		if (dos_header->e_lfanew <= static_cast<LONG>(sizeof(IMAGE_DOS_HEADER)))
		{
			dos_stub_size = dos_header->e_lfanew - sizeof(IMAGE_DOS_HEADER);
			dos_stub = std::shared_ptr<BYTE>(header_memory, reinterpret_cast<BYTE*>(dos_header.get()) + sizeof(IMAGE_DOS_HEADER));
		}
		else if (dos_header->e_lfanew >= static_cast<LONG>(sizeof(IMAGE_DOS_HEADER)))
		{
			dos_header->e_lfanew = sizeof(IMAGE_DOS_HEADER);
		}
	}
}

auto Module::SetSections() -> VOID
{
	Logger::Log("Setting the sections.");

	auto section_header = IMAGE_FIRST_SECTION(nt_header32.get());
	Section section;

	sections.clear();
	sections.reserve(GetSectionCount());

	for (WORD i = 0; i < GetSectionCount(); i++)
	{
		IMAGE_SECTION_HEADER image_section_header{0};

		//
		// Read section
		//
		if (memcpy_s(&image_section_header, sizeof(IMAGE_SECTION_HEADER), section_header, sizeof(IMAGE_SECTION_HEADER)) != 0)
		{
			std::cout << "Failed to read section." << std::endl;
		}
		section.section_header = std::make_shared<IMAGE_SECTION_HEADER>(image_section_header);

		//
		// Set the initial memory_size
		//
		section.initial_size = section_header->Misc.VirtualSize;

		// 
		// Calculate the offset
		// 
		const auto read_offset = base_address + section_header->VirtualAddress;

		//
		// Read the section
		//
		if (!ReadSection(section, read_offset))
		{
			std::cout << "Failed to read section." << std::endl;
		}

		//
		// Add it to the list
		//
		sections.push_back(section);
		section_header++;
	}
}

auto Module::SetSectionSize(Section & section, const DWORD_PTR section_pointer) const -> VOID
{
	Logger::Log("Setting the section size.");

	const DWORD max_read_size = 100;
	const auto read_size = section.initial_size;
	auto current_read_size = read_size % max_read_size;

	//
	// Check read memory_size
	//
	if (current_read_size == 0)
	{
		current_read_size = max_read_size;
	}

	//
	// Calculate the new section memory_size
	//
	auto current_offset = section_pointer + read_size - current_read_size;
	while (current_offset >= section_pointer)
	{
		const auto buffer = process_memory->ReadMemory(current_offset, current_read_size);
		const auto code_byte_count = GetInstructionByteCount(buffer, current_read_size);

		if (code_byte_count != 0)
		{
			current_offset += code_byte_count;

			if (section_pointer < current_offset)
			{
				section.buffer_size = static_cast<DWORD>(current_offset - section_pointer);
				section.buffer_size += 4;

				if (section.initial_size < section.buffer_size)
				{
					section.buffer_size = section.initial_size;
				}
			}

			break;
		}

		current_read_size = max_read_size;
		current_offset -= current_read_size;
	}
}

auto Module::ReadSection(Section & section, const DWORD_PTR section_pointer) const -> BOOL
{
	const DWORD max_read_size = 100;
	const auto read_size = section.initial_size;

	//
	// Check read offset (section without data is valid)
	//
	if (section_pointer == NULL || read_size == 0)
	{
		return TRUE;
	}

	//
	// 
	//
	if (read_size <= max_read_size)
	{
		section.buffer_size = read_size;
		section.buffer = process_memory->ReadMemory(static_cast<DWORD_PTR>(section_pointer), read_size);
		return TRUE;
	}
	//
	// Set the new section
	//
	SetSectionSize(section, section_pointer);

	//
	//
	//
	if (section.buffer_size != 0)
	{
		section.buffer = process_memory->ReadMemory(static_cast<DWORD_PTR>(section_pointer), section.buffer_size);
		return TRUE;
	}

	return FALSE;
}


auto Module::SetFileAlignment() const -> VOID
{
	if (Is32Bit())
	{
		nt_header32->OptionalHeader.FileAlignment = file_alignment_constant;
	}
	else
	{
		nt_header64->OptionalHeader.FileAlignment = file_alignment_constant;
	}
}

auto Module::SetEntryPoint(const DWORD_PTR entry_point) const -> VOID
{
	//
	// Calculate the RVA
	//
	const auto entry_point_rva = static_cast<DWORD>(entry_point - base_address);

	//
	// Set the entry point
	// 
	if (Is32Bit())
	{
		nt_header32->OptionalHeader.AddressOfEntryPoint = entry_point_rva;
	}
	else
	{
		nt_header64->OptionalHeader.AddressOfEntryPoint = entry_point_rva;
	}
}

auto Module::AlignSectionHeaders() -> VOID
{
	DWORD section_alignment, file_alignment;

	//
	// Initialize the variables
	//
	if (Is32Bit())
	{
		section_alignment = nt_header32->OptionalHeader.SectionAlignment;
		file_alignment = nt_header32->OptionalHeader.FileAlignment;
	}
	else
	{
		section_alignment = nt_header64->OptionalHeader.SectionAlignment;
		file_alignment = nt_header64->OptionalHeader.FileAlignment;
	}

	//
	// Sort by PointerToRawData (ascending)
	//
	std::sort(sections.begin(), sections.end(), [](const Section & a, const Section & b) -> bool
	{
		return a.section_header->PointerToRawData < b.section_header->PointerToRawData;
	});

	//
	// Calculate the new file memory_size
	//
	DWORD new_file_size = dos_header->e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + nt_header32->FileHeader.SizeOfOptionalHeader +
		(GetSectionCount() * sizeof(IMAGE_SECTION_HEADER));

	//
	// Align the section values
	//
	for (WORD i = 0; i < GetSectionCount(); i++)
	{
		// VirtualAddress and VirtualSize
		sections[i].section_header->VirtualAddress = AlignValue(sections[i].section_header->VirtualAddress, section_alignment);
		sections[i].section_header->Misc.VirtualSize = AlignValue(sections[i].section_header->Misc.VirtualSize, section_alignment);

		// PointerToRawData and SizeOfRawData
		sections[i].section_header->PointerToRawData = AlignValue(new_file_size, file_alignment);
		sections[i].section_header->SizeOfRawData = AlignValue(sections[i].buffer_size, file_alignment);

		// NewFileSize
		new_file_size = sections[i].section_header->PointerToRawData + sections[i].section_header->SizeOfRawData;
	}

	//
	// Sort by VirtualAddress (ascending)
	//
	std::sort(sections.begin(), sections.end(), [](const Section & a, const Section & b) -> bool
	{
		return a.section_header->VirtualAddress < b.section_header->VirtualAddress;
	});
}

auto Module::FixHeader() -> VOID
{
	const auto fix_header = [this](auto header)
	{
		const DWORD size = dos_header->e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER);

		//
		// Remove import directories
		//
		header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
		header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

		for (auto i = header->OptionalHeader.NumberOfRvaAndSizes; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++)
		{
			header->OptionalHeader.DataDirectory[i].Size = 0;
			header->OptionalHeader.DataDirectory[i].VirtualAddress = 0;
		}

		// 
		// Set the sizes and base address
		// 
		header->OptionalHeader.NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
		header->FileHeader.SizeOfOptionalHeader = sizeof(IMAGE_OPTIONAL_HEADER32);
		header->OptionalHeader.SizeOfImage = GetImageSize();
		header->OptionalHeader.ImageBase = static_cast<DWORD>(base_address);
		header->OptionalHeader.SizeOfHeaders = AlignValue(size + header->FileHeader.SizeOfOptionalHeader + (GetSectionCount() * sizeof(IMAGE_SECTION_HEADER)),
		                                                  header->OptionalHeader.FileAlignment);
	};

	if (Is32Bit())
	{
		fix_header(nt_header32);
	}
	else
	{
		fix_header(nt_header64);
	}
}

auto Module::RemoveIat() -> VOID
{
	DWORD iat_search_address;

	if (Is32Bit())
	{
		iat_search_address = nt_header32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
		nt_header32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = 0;
		nt_header32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = 0;
	}
	else
	{
		iat_search_address = nt_header64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
		nt_header64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = 0;
		nt_header64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = 0;
	}

	//
	// Find the iat table
	//
	if (iat_search_address)
	{
		for (WORD i = 0; i < GetSectionCount(); i++)
		{
			if ((sections[i].section_header->VirtualAddress <= iat_search_address) &&
				((sections[i].section_header->VirtualAddress + sections[i].section_header->Misc.VirtualSize) >
					iat_search_address))
			{
				//
				// Section must be read and writable
				//
				sections[i].section_header->Characteristics |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;
			}
		}
	}
}


auto Module::GetInstructionByteCount(const std::shared_ptr<BYTE> & data, const DWORD size) -> DWORD
{
	//
	// Check if null
	//
	if (data == nullptr)
	{
		return 0;
	}

	//
	// Calculate instruction count
	//
	for (int i = (size - 1); i >= 0; i--)
	{
		if (data.get()[i] != 0)
		{
			return i + 1;
		}
	}

	return 0;
}

auto Module::AlignValue(const DWORD bad_value, const DWORD align_to) -> DWORD
{
	return (((bad_value + align_to - 1) / align_to) * align_to);
}


auto Module::IsValidModule() const -> BOOL
{
	return dos_header && dos_header->e_magic == IMAGE_DOS_SIGNATURE && nt_header32 && nt_header32->Signature == IMAGE_NT_SIGNATURE;
}

auto Module::Is64Bit() const -> BOOL
{
	return IsValidModule() && (nt_header32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC);
}

auto Module::Is32Bit() const -> BOOL
{
	return IsValidModule() && (nt_header32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC);
}


auto Module::GetImageSize() -> DWORD
{
	DWORD last_virtual_offset = 0, last_virtual_size = 0;
	for (WORD i = 0; i < GetSectionCount(); i++)
	{
		if ((sections[i].section_header->VirtualAddress + sections[i].section_header->Misc.VirtualSize) > (last_virtual_offset
			+ last_virtual_size))
		{
			last_virtual_offset = sections[i].section_header->VirtualAddress;
			last_virtual_size = sections[i].section_header->Misc.VirtualSize;
		}
	}

	return last_virtual_size + last_virtual_offset;
}

auto Module::GetSectionCount() const -> WORD
{
	return nt_header32->FileHeader.NumberOfSections;
}

auto Module::GetHeaderSize() -> DWORD
{
	return sizeof(IMAGE_DOS_HEADER) + 0x300 + sizeof(IMAGE_NT_HEADERS64);
}



================================================
File: Nemesis/Module.hpp
================================================
#pragma once

#include <vector>
#include <Windows.h>

#include "ProcessMemory.hpp"
#include "Section.hpp"

class Module
{
	/**
	 * \brief The process memory wrapper.
	 */
	ProcessMemory * process_memory;

	/**
	 * \brief The base address of the module.
	 */
	DWORD_PTR base_address;

public:

	/**
	 * \brief The default file alignment constant.
	 */
	const DWORD file_alignment_constant = 0x200;

	/**
	 * \brief The dos stub memory.
	 */
	std::shared_ptr<BYTE> dos_stub;

	/**
	 * \brief The dos stub size.
	 */
	DWORD dos_stub_size;


	/**
	 * \brief The dos header of a module.
	 */
	std::shared_ptr<IMAGE_DOS_HEADER> dos_header;

	/**
	 * \brief The 32 bit nt header of a module.
	 */
	std::shared_ptr<IMAGE_NT_HEADERS32> nt_header32;

	/**
	 * \brief The 64 bit nt header of a module.
	 */
	std::shared_ptr<IMAGE_NT_HEADERS64> nt_header64;

	/**
	 * \brief Contains the sections of a module.
	 */
	std::vector<Section> sections;

private:

	/**
	 * \brief Reads the header from the memory.
	 * \return true if successful
	 */
	auto ReadHeader() -> BOOL;

	/**
	 * \brief Reads the header from the file.
	 * \return true if successful
	 */
	auto ReadHeaderFromFile() -> BOOL;

	/**
	 * \brief Sets the headers.
	 * \param header_memory the header memory
	 * \param header_size the header memory size
	 */
	auto SetHeader(const std::shared_ptr<BYTE> & header_memory, DWORD header_size) -> VOID;

	/**
	 * \brief Sets the sections.
	 */
	auto SetSections() -> VOID;

	/**
	 * \brief Sets the section size.
	 * \param section the specified section
	 * \param section_pointer the section pointer
	 */
	auto SetSectionSize(Section & section, DWORD_PTR section_pointer) const -> VOID;

	/**
	 * \brief Reads the section from memory.
	 * \param section the section object
	 * \param section_pointer the section pointer
	 * \return true if successful
	 */
	auto ReadSection(Section & section, DWORD_PTR section_pointer) const -> BOOL;

public:

	/**
	 * \brief Stores the parameters.
	 * \param process_memory used for reading the memory
	 */
	explicit Module(ProcessMemory * process_memory);

	/**
	 * \brief Stores the parameters.
	 * \param process_memory the memory wrapper of the module
	 * \param base_address the base address of the module
	 */
	Module(ProcessMemory * process_memory, DWORD_PTR base_address);


	/**
	 * \brief Initializes the module.
	 * \return true if successful
	 */
	auto Initialize() -> BOOL;

	/**
	 * \brief Sets the file alignment in the header.
	 */
	auto SetFileAlignment() const -> VOID;

	/**
	 * \brief Sets the entry point in the header.
	 * \param entry_point the address of the entry point
	 */
	auto SetEntryPoint(DWORD_PTR entry_point) const -> VOID;

	/**
	 * \brief Aligns the section headers.
	 */
	auto AlignSectionHeaders() -> VOID;

	/**
	 * \brief Fixes the header by removing iat and setting the sizes.
	 */
	auto FixHeader() -> VOID;

	/**
	 * \brief Removes the iat.
	 */
	auto RemoveIat() -> VOID;


	/**
	 * \brief Finds the instruction count in the data.
	 * \param data the memory buffer
	 * \param size the size of the buffer
	 * \return the instruction count
	 */
	static auto GetInstructionByteCount(const std::shared_ptr<BYTE> & data, DWORD size) -> DWORD;

	/**
	 * \brief Aligns the value.
	 * \param bad_value the bad value
	 * \param align_to the alignment value
	 * \return the new value
	 */
	static auto AlignValue(DWORD bad_value, DWORD align_to) -> DWORD;


	/**
	 * \brief Checks whether the module is valid.
	 * \return true if it's valid
	 */
	auto IsValidModule() const -> BOOL;

	/**
	 * \brief Checks whether the module is 64 bit.
	 * \return true if it's 64 bit
	 */
	auto Is64Bit() const -> BOOL;

	/**
	 * \brief Checks whether the module is 32 bit.
	 * \return true if it's 32 bit
	 */
	auto Is32Bit() const -> BOOL;


	/**
	 * \brief Returns the image size.
	 * \return the image size
	 */
	auto GetImageSize() -> DWORD;

	/**
	 * \brief Returns the number of sections.
	 * \return the section count
	 */
	auto GetSectionCount() const -> WORD;

	/**
	 * \brief Returns the header size.
	 * \return the header size
	 */
	static auto GetHeaderSize() -> DWORD;
};



================================================
File: Nemesis/Nemesis.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Config.hpp" />
    <ClInclude Include="ConfigExport.hpp" />
    <ClInclude Include="DriverExport.hpp" />
    <ClInclude Include="DriverUtils.hpp" />
    <ClInclude Include="DumpExport.hpp" />
    <ClInclude Include="IMemorySource.hpp" />
    <ClInclude Include="KernelMemory.hpp" />
    <ClInclude Include="Logger.hpp" />
    <ClInclude Include="Memory.hpp" />
    <ClInclude Include="MemorySource.h" />
    <ClInclude Include="MemorySourceExport.hpp" />
    <ClInclude Include="ProcessExport.hpp" />
    <ClInclude Include="ProcessUtils.hpp" />
    <ClInclude Include="SmartHandle.hpp" />
    <ClInclude Include="Section.hpp" />
    <ClInclude Include="ProcessMemory.hpp" />
    <ClInclude Include="SmartMemory.hpp" />
    <ClInclude Include="UsermodeMemory.hpp" />
    <ClInclude Include="Module.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Config.cpp" />
    <ClCompile Include="ConfigExport.cpp" />
    <ClCompile Include="DllMain.cpp" />
    <ClCompile Include="DriverExport.cpp" />
    <ClCompile Include="DriverUtils.cpp" />
    <ClCompile Include="DumpExport.cpp" />
    <ClCompile Include="FileReader.cpp" />
    <ClCompile Include="FileWriter.cpp" />
    <ClCompile Include="IMemorySource.cpp" />
    <ClCompile Include="KernelMemory.cpp" />
    <ClCompile Include="Logger.cpp" />
    <ClCompile Include="Memory.cpp" />
    <ClCompile Include="MemorySource.cpp" />
    <ClCompile Include="MemorySourceExport.cpp" />
    <ClCompile Include="ProcessExport.cpp" />
    <ClCompile Include="ProcessUtils.cpp" />
    <ClCompile Include="ProcessMemory.cpp" />
    <ClCompile Include="SmartHandle.cpp" />
    <ClCompile Include="SmartMemory.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="stdafx.h">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Use</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="UsermodeMemory.cpp" />
    <ClCompile Include="Module.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
    <None Include="exports.def" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{3F24DF07-AFDE-40B1-8897-A63B0C4110A9}</ProjectGuid>
    <RootNamespace>Nemesis</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <MapExports>false</MapExports>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <MapExports>false</MapExports>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: Nemesis/Nemesis.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\Exports">
      <UniqueIdentifier>{2949a235-804f-4e82-8543-47dab89973b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Exports">
      <UniqueIdentifier>{37ff615c-f7e7-42b0-946f-f03f0920a5fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Memory">
      <UniqueIdentifier>{1305231e-e63b-4575-a51a-3958e3e55d2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Memory">
      <UniqueIdentifier>{0a8e00df-b15a-4508-a681-0361d1965779}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Utils">
      <UniqueIdentifier>{cce78855-8c2b-4b9c-a2cf-3a98dd8d2fa7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Utils">
      <UniqueIdentifier>{936964ca-ef15-4d43-9acf-1c773d8c3c30}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\PortableExecutable">
      <UniqueIdentifier>{70d5e972-a7a6-445d-97d3-aaa0a6c0c930}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\PortableExecutable">
      <UniqueIdentifier>{38e4316a-cb29-4ee2-a466-92879d539125}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Memory\Sources">
      <UniqueIdentifier>{641155f1-f4d3-47e4-9c54-f60225bc01a9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Memory\Sources">
      <UniqueIdentifier>{0260222e-2d65-404b-bccd-b4d379d356b3}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Logger.hpp">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="IMemorySource.hpp">
      <Filter>Header Files\Memory</Filter>
    </ClInclude>
    <ClInclude Include="ProcessMemory.hpp">
      <Filter>Header Files\Memory</Filter>
    </ClInclude>
    <ClInclude Include="KernelMemory.hpp">
      <Filter>Header Files\Memory\Sources</Filter>
    </ClInclude>
    <ClInclude Include="UsermodeMemory.hpp">
      <Filter>Header Files\Memory\Sources</Filter>
    </ClInclude>
    <ClInclude Include="Module.hpp">
      <Filter>Header Files\PortableExecutable</Filter>
    </ClInclude>
    <ClInclude Include="Section.hpp">
      <Filter>Header Files\PortableExecutable</Filter>
    </ClInclude>
    <ClInclude Include="Memory.hpp">
      <Filter>Header Files\PortableExecutable</Filter>
    </ClInclude>
    <ClInclude Include="DumpExport.hpp">
      <Filter>Header Files\Exports</Filter>
    </ClInclude>
    <ClInclude Include="MemorySource.h">
      <Filter>Header Files\Memory</Filter>
    </ClInclude>
    <ClInclude Include="ProcessExport.hpp">
      <Filter>Header Files\Exports</Filter>
    </ClInclude>
    <ClInclude Include="DriverUtils.hpp">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="DriverExport.hpp">
      <Filter>Header Files\Exports</Filter>
    </ClInclude>
    <ClInclude Include="ProcessUtils.hpp">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="Config.hpp">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="MemorySourceExport.hpp">
      <Filter>Header Files\Exports</Filter>
    </ClInclude>
    <ClInclude Include="ConfigExport.hpp">
      <Filter>Header Files\Exports</Filter>
    </ClInclude>
    <ClInclude Include="SmartHandle.hpp">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="SmartMemory.hpp">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DllMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IMemorySource.cpp">
      <Filter>Source Files\Memory</Filter>
    </ClCompile>
    <ClCompile Include="Logger.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="ProcessMemory.cpp">
      <Filter>Source Files\Memory</Filter>
    </ClCompile>
    <ClCompile Include="FileWriter.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="UsermodeMemory.cpp">
      <Filter>Source Files\Memory\Sources</Filter>
    </ClCompile>
    <ClCompile Include="KernelMemory.cpp">
      <Filter>Source Files\Memory\Sources</Filter>
    </ClCompile>
    <ClCompile Include="Module.cpp">
      <Filter>Source Files\PortableExecutable</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source Files\PortableExecutable</Filter>
    </ClCompile>
    <ClCompile Include="DumpExport.cpp">
      <Filter>Source Files\Exports</Filter>
    </ClCompile>
    <ClCompile Include="MemorySourceExport.cpp">
      <Filter>Source Files\Exports</Filter>
    </ClCompile>
    <ClCompile Include="MemorySource.cpp">
      <Filter>Source Files\Memory</Filter>
    </ClCompile>
    <ClCompile Include="ProcessExport.cpp">
      <Filter>Source Files\Exports</Filter>
    </ClCompile>
    <ClCompile Include="DriverExport.cpp">
      <Filter>Source Files\Exports</Filter>
    </ClCompile>
    <ClCompile Include="ProcessUtils.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="DriverUtils.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="FileReader.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="Config.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="ConfigExport.cpp">
      <Filter>Source Files\Exports</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SmartHandle.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
    <ClCompile Include="SmartMemory.cpp">
      <Filter>Source Files\Utils</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="cpp.hint" />
    <None Include="exports.def" />
  </ItemGroup>
</Project>


================================================
File: Nemesis/ProcessExport.cpp
================================================
#include "stdafx.h"

#include "Logger.hpp"
#include "ProcessExport.hpp"
#include "ProcessUtils.hpp"


auto GetProcessListElementExport(const UINT index, ProcessElement * process) -> BOOL
{
	static std::vector<ProcessElement> process_list;

	//
	// Check if first request (load process list)
	//
	if (index == 0)
	{
		process_list = ProcessUtils::GetProcessList();
	}

	//
	// Check if in bounds
	//
	if (index < 0 || index >= process_list.size())
	{
		return FALSE;
	}

	//
	// Check if process is valid
	//
	if (process == nullptr)
	{
		return FALSE;
	}

	*process = process_list[index];

	return TRUE;
}

auto GetModuleListElementExport(const UINT index, const DWORD process_id, ModuleElement * module) -> BOOL
{
	static std::vector<ModuleElement> module_list;

	//
	// Check if first request (load module list)
	//
	if (index == 0)
	{
		Logger::Log("Loading module list.");
		module_list = ProcessUtils::GetModuleList(process_id);
	}

	//
	// Check if in bounds
	//
	if (index < 0 || index >= module_list.size())
	{
		return FALSE;
	}

	//
	// Check if module is valid
	//
	if (module == nullptr)
	{
		return FALSE;
	}

	*module = module_list[index];

	return TRUE;
}

auto GetManualModuleListElementExport(const UINT index, const DWORD process_id, ModuleElement * module) -> BOOL
{
	static std::vector<ModuleElement> module_list;

	//
	// Check if first request (load module list)
	//
	if (index == 0)
	{
		Logger::Log("Loading module list.");
		module_list = ProcessUtils::GetModuleListManually(process_id);
	}

	//
	// Check if in bounds
	//
	if (index < 0 || index >= module_list.size())
	{
		return FALSE;
	}

	//
	// Check if module is valid
	//
	if (module == nullptr)
	{
		return FALSE;
	}

	*module = module_list[index];

	return TRUE;
}

auto GetMemoryListElementExport(const UINT index, const DWORD process_id, MemoryElement * memory) -> BOOL
{
	static std::vector<MemoryElement> memory_list;

	//
	// Check if first request (load memory list)
	//
	if (index == 0)
	{
		Logger::Log("Loading memory list.");
		memory_list = ProcessUtils::GetMemoryList(process_id);
	}

	//
	// Check if in bounds
	//
	if (index < 0 || index >= memory_list.size())
	{
		return FALSE;
	}

	//
	// Check if memory is valid
	//
	if (memory == nullptr)
	{
		return FALSE;
	}

	*memory = memory_list[index];

	return TRUE;
}



================================================
File: Nemesis/ProcessExport.hpp
================================================
#pragma once

#include <Windows.h>

/**
 * \brief A memory region of a process.
 */
struct MemoryElement
{
	PVOID base_address;
	SIZE_T region_size;
	DWORD state;
	DWORD type;
};

/**
 * \brief A module of a process.
 */
struct ModuleElement
{
	PVOID base_address;
	SIZE_T module_size;
	CHAR module_name[MAX_PATH];
	CHAR module_path[MAX_PATH];
};

/**
 * \brief Contains all the information about a process.
 */
struct ProcessElement
{
	CHAR image_name[256];
	HANDLE unique_process_id;
	INT32 number_of_threads;
	INT32 base_priority;
	INT32 handle_count;
	INT32 session_id;
	SIZE_T peak_virtual_size;
	SIZE_T virtual_size;
	SIZE_T peak_working_set_size;
	SIZE_T working_set_size;
	SIZE_T quota_paged_pool_usage;
	SIZE_T quota_non_paged_pool_usage;
	SIZE_T page_file_usage;
	SIZE_T peak_page_file_usage;
	SIZE_T private_page_count;
};

/**
 * \brief Contains the list of processes.
 */
struct ProcessList
{
	ProcessElement * processes;
};


/**
 * \brief Returns the process at the specified index. 
 * \param index the index in the list
 * \param process the process at the specified index
 * \return true if successful
 */
auto GetProcessListElementExport(IN UINT index, OUT ProcessElement * process) -> BOOL;

/**
 * \brief Returns the module at the specified index.
 * \param index the index in the list
 * \param process_id the id of the process
 * \param module the module at the specified index
 * \return true if successful
 */
auto GetModuleListElementExport(IN UINT index, IN DWORD process_id, OUT ModuleElement * module) -> BOOL;

/**
 * \brief Returns the manually enumerated module at the specified index.
 * \param index the index in the list
 * \param process_id the id of the process
 * \param module the module at the specified index
 * \return true if successful
 */
auto GetManualModuleListElementExport(IN UINT index, IN DWORD process_id, OUT ModuleElement * module) -> BOOL;

/**
 * \brief Returns the memory at the specified index.
 * \param index the index in the list
 * \param process_id the id of the process
 * \param memory the memory at the specified index
 * \return true if successful
 */
auto GetMemoryListElementExport(IN UINT index, IN DWORD process_id, OUT MemoryElement * memory) -> BOOL;



================================================
File: Nemesis/ProcessMemory.cpp
================================================
#include "stdafx.h"

#include "MemorySource.h"
#include "ProcessMemory.hpp"
#include "UsermodeMemory.hpp"

ProcessMemory::ProcessMemory(const DWORD process_id) : process_id(process_id)
{
}


auto ProcessMemory::ReadMemory(const DWORD_PTR start_address, const SIZE_T size) const -> std::shared_ptr<BYTE>
{
	return MemorySource::GetMemorySource(process_id)->ReadMemory(start_address, size);
}

auto ProcessMemory::IsValid() const -> BOOL
{
	return MemorySource::GetMemorySource(process_id)->IsValid();
}

auto ProcessMemory::GetBaseAddress() const -> DWORD_PTR
{
	return MemorySource::GetMemorySource(process_id)->GetBaseAddress();
}

auto ProcessMemory::GetProcessId() const -> DWORD
{
	return process_id;
}



================================================
File: Nemesis/ProcessMemory.hpp
================================================
#pragma once

#include <Windows.h>

#include "MemorySource.h"

class ProcessMemory
{
	/**
	 * \brief The id of the process.
	 */
	DWORD process_id;

public:

	/**
	 * \brief Stores the parameters.
	 * \param process_id the id of the process
	 */
	ProcessMemory(DWORD process_id);

	/**
	  * \brief Reads memory from the process. (e.g. float)
	 * \tparam T the read value data type
	 * \param start_address the memory start address
	 * \return the memory buffer
	 */
	template <typename T>
	auto ReadMemory(const DWORD_PTR start_address) -> T
	{
		return reinterpret_cast<T>(MemorySource::GetMemorySource(process_id)->ReadMemory(start_address, sizeof(T)));
	}

	/**
	 * \brief Reads memory from the process. (e.g. float or float[])
	 * \param start_address the memory start address
	 * \param size the buffer size
	 * \return the memory buffer
	 */
	auto ReadMemory(DWORD_PTR start_address, SIZE_T size) const -> std::shared_ptr<BYTE>;

	/**
	 * \brief Checks whether the memory is valid.
	 * \return true if successful
	 */
	auto IsValid() const -> BOOL;

	/**
	 * \brief Returns the base address.
	 * \return the base address of the process
	 */
	auto GetBaseAddress() const -> DWORD_PTR;

	/**
	 * \brief Returns the process id.
	 * \return the id of the process
	 */
	auto GetProcessId() const -> DWORD;
};



================================================
File: Nemesis/ProcessUtils.cpp
================================================
#include "stdafx.h"

#include "DriverUtils.hpp"
#include "Logger.hpp"
#include "ProcessUtils.hpp"
#include "MemorySource.h"
#include "SmartHandle.hpp"

auto ProcessUtils::GetProcessList() -> std::vector<ProcessElement>
{
	std::vector<ProcessElement> processes;

	//
	// Allocate memory for the buffer
	//
	const auto unsafe_buffer = VirtualAlloc(nullptr, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	std::unique_ptr<BYTE, MemoryDisposer> buffer(static_cast<BYTE*>(unsafe_buffer), MemoryDisposer{});
	if (!buffer)
	{
		return {};
	}

	//
	// Create the process info buffer
	//

	//
	// Get the process list
	//
	if (!NT_SUCCESS(NtQuerySystemInformation(SystemProcessInformation, buffer.get(), 1024 * 1024, NULL)))
	{
		return {};
	}

	//
	// Create the process list
	//
	auto system_process_info = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(buffer.get())	;
	while (system_process_info->NextEntryOffset)
	{
		//
		// Create the process struct
		//
		std::wstring image_name(system_process_info->ImageName.Buffer, static_cast<UINT64>(system_process_info->ImageName.Length / 2));
		std::string string(image_name.begin(), image_name.end());
		ProcessElement process{};

		std::copy(string.begin(), string.end(), reinterpret_cast<char*>(process.image_name));
		process.unique_process_id = system_process_info->UniqueProcessId;
		process.number_of_threads = system_process_info->NumberOfThreads;
		process.base_priority = system_process_info->BasePriority;
		process.handle_count = system_process_info->HandleCount;
		process.session_id = system_process_info->SessionId;
		process.peak_virtual_size = system_process_info->PeakVirtualSize;
		process.virtual_size = system_process_info->VirtualSize;
		process.peak_working_set_size = system_process_info->PeakWorkingSetSize;
		process.working_set_size = system_process_info->WorkingSetSize;
		process.quota_paged_pool_usage = system_process_info->QuotaPagedPoolUsage;
		process.quota_non_paged_pool_usage = system_process_info->QuotaNonPagedPoolUsage;
		process.page_file_usage = system_process_info->PagefileUsage;
		process.peak_page_file_usage = system_process_info->PeakPagefileUsage;
		process.private_page_count = system_process_info->PrivatePageCount;

		//
		// Add the process to the list
		//
		//process_list->processes[index++] = process;
		processes.push_back(process);

		//
		// Calculate the next offset
		//
		system_process_info = reinterpret_cast<PSYSTEM_PROCESS_INFORMATION>(reinterpret_cast<LPBYTE>(system_process_info) + system_process_info->NextEntryOffset
		);
	}

	return processes;
}

auto ProcessUtils::GetModuleList(const DWORD process_id) -> std::vector<ModuleElement>
{
	//
	// Open the process
	//
	const auto process_handle = SmartHandle(OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, process_id));
	if (!process_handle.IsValid())
	{
		Logger::Log("Failed to get process handle.");
		return {};
	}

	//
	// Loop through the modules
	//
	std::vector<ModuleElement> modules;
	HMODULE module_handles[1024];
	DWORD cb_needed;
	if (EnumProcessModules(process_handle.Get(), module_handles, sizeof(module_handles), &cb_needed))
	{
		modules.reserve(cb_needed / sizeof(HMODULE));

		for (unsigned long i = 0; i < cb_needed / sizeof(HMODULE); i++)
		{
			WCHAR file_path[MAX_PATH];

			//
			// Get the full path
			//
			if (!GetModuleFileNameEx(process_handle.Get(), module_handles[i], file_path, sizeof(file_path) / sizeof(CHAR)))
			{
				Logger::Log("Failed to get file path.");
				continue;
			}

			//
			// Get module information
			//
			MODULEINFO module_info = {0};
			if (!GetModuleInformation(process_handle.Get(), module_handles[i], &module_info, sizeof(module_info)))
			{
				Logger::Log("Failed to get module information.");
				continue;
			}

			//
			// Create a new module
			//
			ModuleElement module{};

			module.base_address = module_info.lpBaseOfDll;
			module.module_size = module_info.SizeOfImage;

			std::wstring module_file_path(file_path);
			std::copy(module_file_path.begin(), module_file_path.end(), reinterpret_cast<char*>(module.module_path));

			const auto module_file_name = module_file_path.substr(module_file_path.find_last_of(L"/\\") + 1);
			std::copy(module_file_name.begin(), module_file_name.end(), reinterpret_cast<char*>(module.module_name));

			//
			// Add it to the list
			//
			modules.push_back(module);
		}
	}

	return modules;
}

auto ProcessUtils::GetModuleListManually(const DWORD process_id) -> std::vector<ModuleElement>
{
	const auto memory_source = MemorySource::GetMemorySource(process_id);

	Logger::Log("Creating module list manually.");

	//
	// Get process handle
	//
	const auto process_handle = SmartHandle(OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, process_id));
	if (!process_handle.IsValid())
	{
		Logger::Log("Failed to get process handle.");
		return {};
	}

	//
	// PROCESS_BASIC_INFORMATION
	//
	structs::PROCESS_BASIC_INFORMATION pbi = {0};
	if (!NT_SUCCESS(NtQueryInformationProcess(process_handle.Get(), ProcessBasicInformation, &pbi, sizeof(pbi), nullptr)))
	{
		Logger::Log("Could not get process information.");
		return {};
	}

	//
	// PEB
	//
	const auto peb_memory = memory_source->ReadMemory(reinterpret_cast<DWORD_PTR>(pbi.PebBaseAddress), sizeof(structs::PEB));
	const auto peb = std::reinterpret_pointer_cast<structs::PEB>(peb_memory);

	if (peb_memory == nullptr || peb == nullptr)
	{
		Logger::Log("Failed to read PEB from process.");
		return {};
	}

	//
	// PEB_LDR_DATA
	//
	const auto peb_ldr_data_memory = memory_source->ReadMemory(reinterpret_cast<DWORD_PTR>(peb->Ldr), sizeof(structs::PEB_LDR_DATA));
	const auto peb_ldr_data = std::reinterpret_pointer_cast<structs::PEB_LDR_DATA>(peb_ldr_data_memory);

	if (peb_ldr_data_memory == nullptr || peb_ldr_data == nullptr)
	{
		Logger::Log("Failed to read module list from process.");
		return {};
	}

	//
	// LIST_ENTRY
	//
	const auto ldr_list_head = static_cast<LIST_ENTRY *>(peb_ldr_data->InLoadOrderModuleList.Flink);
	auto ldr_current_node = peb_ldr_data->InLoadOrderModuleList.Flink;

	// 
	// Loop through the modules
	// 
	std::vector<ModuleElement> modules;
	do
	{
		//
		// LDR_DATA_TABLE_ENTRY
		//
		const auto list_entry_memory = memory_source->ReadMemory(reinterpret_cast<DWORD_PTR>(ldr_current_node), sizeof(structs::LDR_DATA_TABLE_ENTRY));
		const auto list_entry = std::reinterpret_pointer_cast<structs::LDR_DATA_TABLE_ENTRY>(list_entry_memory);

		if (list_entry_memory == nullptr || list_entry == nullptr)
		{
			Logger::Log("Could not read list entry from LDR list.");
			return {};
		}

		//
		// Add the module to the list
		//
		if (list_entry->DllBase != nullptr && list_entry->SizeOfImage != 0)
		{
			ModuleElement module{};
			module.base_address = list_entry->DllBase;
			module.module_size = list_entry->SizeOfImage;

			if (list_entry->BaseDllName.Length > 0)
			{
				const auto buffer = memory_source->ReadMemory(reinterpret_cast<DWORD_PTR>(list_entry->BaseDllName.Buffer), list_entry->BaseDllName.Length);
				if (buffer != nullptr)
				{
					std::wstring base_dll_name(reinterpret_cast<PWCHAR>(buffer.get()), list_entry->BaseDllName.Length / 2);
					std::copy(base_dll_name.begin(), base_dll_name.end(), reinterpret_cast<char*>(module.module_name));
				}
			}

			if (list_entry->FullDllName.Length > 0)
			{
				const auto buffer = memory_source->ReadMemory(reinterpret_cast<DWORD_PTR>(list_entry->FullDllName.Buffer), list_entry->FullDllName.Length);
				if (buffer != nullptr)
				{
					std::wstring full_dll_name(reinterpret_cast<PWCHAR>(buffer.get()), list_entry->FullDllName.Length / 2);
					std::copy(full_dll_name.begin(), full_dll_name.end(), reinterpret_cast<char*>(module.module_path));
				}
			}

			modules.push_back(module);
		}

		ldr_current_node = list_entry->InLoadOrderLinks.Flink;
	}
	while (ldr_list_head != ldr_current_node);

	return modules;
}

auto ProcessUtils::GetMemoryList(const DWORD process_id) -> std::vector<MemoryElement>
{
	//
	// Open the process
	//
	const auto process_handle = SmartHandle(OpenProcess(PROCESS_ALL_ACCESS, false, process_id));
	if (!process_handle.IsValid())
	{
		return {};
	}

	MEMORY_BASIC_INFORMATION memory_basic_information;

	// 
	// Loop through the memory regions
	// 
	std::vector<MemoryElement> memory_list;
	for (BYTE * memory_region_start = nullptr;
	     VirtualQueryEx(process_handle.Get(), memory_region_start, &memory_basic_information, sizeof(MEMORY_BASIC_INFORMATION64));
	     memory_region_start += memory_basic_information.RegionSize)
	{
		//
		// Creates a new memory source
		//
		MemoryElement memory{};
		memory.base_address = memory_basic_information.BaseAddress;
		memory.region_size = memory_basic_information.RegionSize;
		memory.state = memory_basic_information.State; // (MEM_COMMIT | MEM_FREE | MEM_RESERVE)
		memory.type = memory_basic_information.Type; // (MEM_IMAGE | MEM_MAPPED | MEM_PRIVATE)

		//
		// Add it to the list
		//
		memory_list.push_back(memory);
	}

	return memory_list;
}

auto ProcessUtils::GetFilePath(const DWORD process_id) -> std::wstring
{
	std::wstring path(MAX_PATH, '\0');
	DWORD length = 0;

	//
	// Get the path
	//
	const auto process_handle = SmartHandle(OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, process_id));
	if (process_handle.IsValid())
	{
		if (!(length = GetModuleFileNameEx(process_handle.Get(), nullptr, const_cast<LPWSTR>(path.data()), path.size())))
		{
			Logger::Log("Failed to get module file name.");
		}
	}
	else
	{
		Logger::Log("Failed to open file.");
	}

	//
	// Adjust size
	//
	path.resize(length);

	return path;
}



================================================
File: Nemesis/ProcessUtils.hpp
================================================
#pragma once

#include <string>
#include <vector>

#include "ProcessExport.hpp"

namespace structs
{
	typedef struct _UNICODE_STRING
	{
		USHORT Length;
		USHORT MaximumLength;
		PWSTR Buffer;
	} UNICODE_STRING, *PUNICODE_STRING;

	typedef struct _LDR_DATA_TABLE_ENTRY
	{
		LIST_ENTRY InLoadOrderLinks;
		LIST_ENTRY InMemoryOrderLinks;
		LIST_ENTRY InInitializationOrderLinks;
		PVOID DllBase;
		PVOID EntryPoint;
		ULONG SizeOfImage;
		UNICODE_STRING FullDllName;
		UNICODE_STRING BaseDllName;
		ULONG Flags;
		WORD LoadCount;
		WORD TlsIndex;

		union
		{
			LIST_ENTRY HashLinks;

			struct
			{
				PVOID SectionPointer;
				ULONG CheckSum;
			};
		};

		union
		{
			ULONG TimeDateStamp;
			PVOID LoadedImports;
		};

		_ACTIVATION_CONTEXT * EntryPointActivationContext;
		PVOID PatchInformation;
		LIST_ENTRY ForwarderLinks;
		LIST_ENTRY ServiceTagLinks;
		LIST_ENTRY StaticLinks;
	} LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;

	typedef struct _PEB_LDR_DATA
	{
		ULONG Length;
		BOOLEAN Initialized;
		PVOID SsHandle;
		LIST_ENTRY InLoadOrderModuleList;
		LIST_ENTRY InMemoryOrderModuleList;
		LIST_ENTRY InInitializationOrderModuleList;
	} PEB_LDR_DATA, *PPEB_LDR_DATA;

	typedef struct _PEB
	{
		union
		{
			struct
			{
				BYTE InheritedAddressSpace;
				BYTE ReadImageFileExecOptions;
				BYTE BeingDebugged;
				BYTE BitField;
			};

			DWORD64 dummy01;
		};

		DWORD64 Mutant;
		DWORD64 ImageBaseAddress;
		PPEB_LDR_DATA Ldr;
		DWORD64 ProcessParameters;
		DWORD64 SubSystemData;
		DWORD64 ProcessHeap;
		DWORD64 FastPebLock;
		DWORD64 AtlThunkSListPtr;
		DWORD64 IFEOKey;
		DWORD64 CrossProcessFlags;
		DWORD64 UserSharedInfoPtr;
		DWORD SystemReserved;
		DWORD AtlThunkSListPtr32;
		DWORD64 ApiSetMap;
		DWORD64 TlsExpansionCounter;
		DWORD64 TlsBitmap;
		DWORD TlsBitmapBits[2];
		DWORD64 ReadOnlySharedMemoryBase;
		DWORD64 HotpatchInformation;
		DWORD64 ReadOnlyStaticServerData;
		DWORD64 AnsiCodePageData;
		DWORD64 OemCodePageData;
		DWORD64 UnicodeCaseTableData;
		DWORD NumberOfProcessors;

		union
		{
			DWORD NtGlobalFlag;
			DWORD dummy02;
		};

		LARGE_INTEGER CriticalSectionTimeout;
		DWORD64 HeapSegmentReserve;
		DWORD64 HeapSegmentCommit;
		DWORD64 HeapDeCommitTotalFreeThreshold;
		DWORD64 HeapDeCommitFreeBlockThreshold;
		DWORD NumberOfHeaps;
		DWORD MaximumNumberOfHeaps;
		DWORD64 ProcessHeaps;
		DWORD64 GdiSharedHandleTable;
		DWORD64 ProcessStarterHelper;
		DWORD64 GdiDCAttributeList;
		DWORD64 LoaderLock;
		DWORD OSMajorVersion;
		DWORD OSMinorVersion;
		WORD OSBuildNumber;
		WORD OSCSDVersion;
		DWORD OSPlatformId;
		DWORD ImageSubsystem;
		DWORD ImageSubsystemMajorVersion;
		DWORD64 ImageSubsystemMinorVersion;
		DWORD64 ActiveProcessAffinityMask;
		DWORD64 GdiHandleBuffer[30];
		DWORD64 PostProcessInitRoutine;
		DWORD64 TlsExpansionBitmap;
		DWORD TlsExpansionBitmapBits[32];
		DWORD64 SessionId;
		ULARGE_INTEGER AppCompatFlags;
		ULARGE_INTEGER AppCompatFlagsUser;
		DWORD64 pShimData;
		DWORD64 AppCompatInfo;
		UNICODE_STRING CSDVersion;
		DWORD64 ActivationContextData;
		DWORD64 ProcessAssemblyStorageMap;
		DWORD64 SystemDefaultActivationContextData;
		DWORD64 SystemAssemblyStorageMap;
		DWORD64 MinimumStackCommit;
		DWORD64 FlsCallback;
		LIST_ENTRY FlsListHead;
		DWORD64 FlsBitmap;
		DWORD FlsBitmapBits[4];
		DWORD64 FlsHighIndex;
		DWORD64 WerRegistrationData;
		DWORD64 WerShipAssertPtr;
		DWORD64 pContextData;
		DWORD64 pImageHeaderHash;
		DWORD64 TracingFlags;
	} PEB64, PPEB64;

	struct PROCESS_BASIC_INFORMATION
	{
		DWORD_PTR ExitStatus;
		PEB * PebBaseAddress;
		DWORD_PTR AffinityMask;
		DWORD_PTR BasePriority;
		ULONG_PTR UniqueProcessId;
		DWORD_PTR InheritedFromUniqueProcessId;
	};

	using PEB = PEB64;
	using PPEB = PPEB64;
	using LDR_DATA_TABLE_ENTRY = LDR_DATA_TABLE_ENTRY64;
	using PLDR_DATA_TABLE_ENTRY = PLDR_DATA_TABLE_ENTRY64;
}


class ProcessUtils
{
public:
	/**
	 * \brief Creates the process list struct.
	 * \return the structure
	 */
	static auto GetProcessList() -> std::vector<ProcessElement>;

	/**
	 * \brief Creates the module array.
	 * \param process_id the target process id
	 * \return the module array
	 */
	static auto GetModuleList(DWORD process_id) -> std::vector<ModuleElement>;

	/**
	 * \brief Creates the module array manually (should be use when you can't get a VM_READ process handle).
	 * \param process_id the target process id
	 * \return the module array
	 */
	static auto GetModuleListManually(DWORD process_id) -> std::vector<ModuleElement>;

	/**
	 * \brief Creates the memory regions array.
	 * \param process_id the target process id
	 * \return the memory array
	 */
	static auto GetMemoryList(DWORD process_id) -> std::vector<MemoryElement>;

	/**
	 * \brief Returns the path of the process' main module.
	 * \param process_id the target process id
	 * \return the path to the main module
	 */
	static auto GetFilePath(DWORD process_id) -> std::wstring;
};



================================================
File: Nemesis/Section.hpp
================================================
#pragma once

#include <Windows.h>

struct Section
{
	/**
	 * \brief The section header struct.
	 */
	std::shared_ptr<IMAGE_SECTION_HEADER> section_header;

	/**
	 * \brief The memory of the section.
	 */
	std::shared_ptr<BYTE> buffer;

	/**
	 * \brief The size of the section.
	 */
	DWORD buffer_size = NULL;

	/**
	 * \brief The initial size of the section.
	 */
	DWORD initial_size = NULL;
};



================================================
File: Nemesis/SmartHandle.cpp
================================================
#include "stdafx.h"

#include "SmartHandle.hpp"

SmartHandle::SmartHandle(const HANDLE handle) : handle(handle, HandleDisposer{})
{
}

auto SmartHandle::Get() const -> HANDLE
{
	return handle.get();
}

auto SmartHandle::IsValid() const -> BOOL
{
	return handle.get() != INVALID_HANDLE_VALUE || handle != nullptr;
}



================================================
File: Nemesis/SmartHandle.hpp
================================================
#pragma once

struct HandleDisposer
{
	void operator()(const HANDLE handle) const
	{
		if (handle != INVALID_HANDLE_VALUE || handle != nullptr)
		{
			CloseHandle(handle);
		}
	}
};

class SmartHandle
{
	/**
	 * \brief The handle which should be managed.
	 */
	std::shared_ptr<VOID> handle;

public:

	/**
	 * \brief Initializes the shared pointer.
	 * \param handle The specified handle.
	 */
	SmartHandle(HANDLE handle);

	/**
	 * \brief Returns the managed handle.
	 * \return The managed handle.
	 */
	auto Get() const -> HANDLE;

	/**
	 * \brief Checks whether the handle is valid.
	 * \return True if it's valid.
	 */
	auto IsValid() const -> BOOL;
};



================================================
File: Nemesis/SmartMemory.cpp
================================================
#include "stdafx.h"

#include "SmartMemory.hpp"

SmartMemory::SmartMemory(SIZE_T size) : buffer(size, 0)
{
}

auto SmartMemory::get() -> BYTE*
{
	return &buffer[0];
}



================================================
File: Nemesis/SmartMemory.hpp
================================================
#pragma once

#include <Windows.h>

struct MemoryDisposer
{
	void operator()(const BYTE * buffer) const
	{
		delete[] buffer;
	}
};

class SmartMemory
{
public:

	/**
	 * \brief The allocated memory.
	 */
	std::vector<BYTE> buffer;

	/**
	 * \brief Creates a new memory buffer.
	 * \param size The size of the buffer.
	 */
	SmartMemory(SIZE_T size);

	auto get() -> BYTE*;
};



================================================
File: Nemesis/UsermodeMemory.cpp
================================================
#include "stdafx.h"

#include "Logger.hpp"
#include "UsermodeMemory.hpp"
#include "SmartMemory.hpp"

UsermodeMemory::UsermodeMemory(const DWORD process_id) : IMemorySource(process_id)
{
	process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id);

	if (!process_handle.IsValid())
	{
		Logger::Log("Failed to open process.");
	}
}


auto UsermodeMemory::ReadMemory(const DWORD_PTR start_address, const SIZE_T size) -> std::shared_ptr<BYTE>
{
	if (!process_handle.IsValid())
	{
		return nullptr;
	}

	//SmartMemory buffer(size);
	const auto buffer = std::shared_ptr<BYTE>(new BYTE[size], [](const BYTE * memory) { delete[] memory; });
	SIZE_T bytes_read;
	DWORD old_protect;

	// 
	// ReadProcessMemory
	// 
	if (!ReadProcessMemory(process_handle.Get(), reinterpret_cast<LPCVOID>(start_address), buffer.get(), size, &bytes_read))
	{
		Logger::Log("Failed to read process memory.");

		//
		// RPM Failed - Disable page protection
		//
		if (!VirtualProtectEx(process_handle.Get(), reinterpret_cast<LPVOID>(start_address), size, PAGE_READWRITE, &old_protect))
		{
			Logger::Log("Failed to change page protection.");
			return nullptr;
		}

		// 
		// ReadProcessMemory
		// 
		if (!ReadProcessMemory(process_handle.Get(), reinterpret_cast<LPCVOID>(start_address), buffer.get(), size, &bytes_read))
		{
			Logger::Log("Failed to read process memory.");
		}

		VirtualProtectEx(process_handle.Get(), reinterpret_cast<LPVOID>(start_address), size, old_protect, &old_protect);
	}

	return buffer;
}

auto UsermodeMemory::IsValid() -> BOOL
{
	return process_handle.IsValid();
}

auto UsermodeMemory::GetBaseAddress() -> DWORD_PTR
{
	WCHAR file_name[MAX_PATH] = {0};
	WCHAR module_name[MAX_PATH] = {0};
	HMODULE * module_handle = nullptr;
	DWORD needed, modules;
	DWORD_PTR base_address = NULL;

	//
	// Set the hModules memory_size
	//
	EnumProcessModules(process_handle.Get(), module_handle, 0, &modules);
	module_handle = new HMODULE[modules / sizeof(HMODULE)];

	//
	// Get the Module name
	//
	GetModuleBaseName(process_handle.Get(), nullptr, file_name, sizeof(file_name));

	//
	// Get the base address
	//
	if (EnumProcessModules(process_handle.Get(), module_handle, sizeof(module_handle), &needed))
	{
		for (unsigned int i = 0; i < (needed / sizeof(HMODULE)); i++)
		{
			std::wstring std_file_name(file_name);

			if (GetModuleBaseName(process_handle.Get(), module_handle[i], module_name, sizeof module_name) && std_file_name == module_name)
			{
				base_address = reinterpret_cast<DWORD_PTR>(module_handle[i]);
				break;
			}
		}
	}

	delete[] module_handle;

	return base_address;
}



================================================
File: Nemesis/UsermodeMemory.hpp
================================================
#pragma once

#include <Windows.h>

#include "IMemorySource.hpp"
#include "SmartHandle.hpp"

class UsermodeMemory final : public IMemorySource
{
	/**
	 * \brief The process handle.
	 */
	SmartHandle process_handle = nullptr;

public:

	/**
	 * \brief Opens the process.
	 * \param process_id the id of the process
	 */
	explicit UsermodeMemory(DWORD process_id);

	/**
	 * \brief Reads the memory from the process.
	 * \param start_address the memory start address
	 * \param size the buffer size
	 * \return the memory buffer
	 */
	auto ReadMemory(DWORD_PTR start_address, SIZE_T size) -> std::shared_ptr<BYTE> override;

	/**
	 * \brief Checks whether the memory source is valid.
	 * \return true if valid
	 */
	auto IsValid() -> BOOL override;

	/**
	 * \brief Returns the base address.
	 * \return the base address of the process
	 */
	auto GetBaseAddress() -> DWORD_PTR override;
};



================================================
File: Nemesis/cpp.hint
================================================
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define NULL
#define NULL ((void *)0)
#define va_start
#define va_start



================================================
File: Nemesis/exports.def
================================================
EXPORTS
	SetConfigValueExport @1
	GetConfigValueExport @2

	DumpProcessExport @3
	DumpModuleExport @4
	DumpMemoryExport @5
	DumpDriverExport @6

	GetDriverListElementExport @7
	GetProcessListElementExport @8
	GetModuleListElementExport @9
	GetManualModuleListElementExport @10
	GetMemoryListElementExport @11

	GetMemorySourcesExport @12
	
	SaveDriverInformationExport @13


================================================
File: Nemesis/stdafx.cpp
================================================
#include "stdafx.h"


================================================
File: Nemesis/stdafx.h
================================================
#pragma once

#include <Windows.h>
#include <winternl.h>
#include <Psapi.h>

#include <algorithm>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

#pragma comment(lib,"ntdll.lib")


================================================
File: Nemesis.GUI/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
</configuration>


================================================
File: Nemesis.GUI/Nemesis.GUI.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{20312010-AB4F-4DC7-93DA-C82EBED127A5}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>Nemesis</RootNamespace>
    <AssemblyName>Nemesis</AssemblyName>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <DocumentationFile>
    </DocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>x64</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
    <DocumentationFile>
    </DocumentationFile>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>Nemesis.Program</StartupObject>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <DocumentationFile>
    </DocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <DocumentationFile>
    </DocumentationFile>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <TargetZone>LocalIntranet</TargetZone>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateManifests>false</GenerateManifests>
  </PropertyGroup>
  <PropertyGroup>
    <SignManifests>false</SignManifests>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="MetroFramework, Version=1.4.0.0, Culture=neutral, PublicKeyToken=5f91a84759bf584a, processorArchitecture=MSIL">
      <HintPath>..\packages\MetroModernUI.1.4.0.0\lib\net\MetroFramework.dll</HintPath>
    </Reference>
    <Reference Include="MetroFramework.Design, Version=1.4.0.0, Culture=neutral, PublicKeyToken=5f91a84759bf584a, processorArchitecture=MSIL">
      <HintPath>..\packages\MetroModernUI.1.4.0.0\lib\net\MetroFramework.Design.dll</HintPath>
    </Reference>
    <Reference Include="MetroFramework.Fonts, Version=1.4.0.0, Culture=neutral, PublicKeyToken=5f91a84759bf584a, processorArchitecture=MSIL">
      <HintPath>..\packages\MetroModernUI.1.4.0.0\lib\net\MetroFramework.Fonts.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Configuration" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Forms\About.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\About.Designer.cs">
      <DependentUpon>About.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\NemesisForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\NemesisForm.Designer.cs">
      <DependentUpon>NemesisForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\ProcessInfo.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\ProcessInfo.Designer.cs">
      <DependentUpon>ProcessInfo.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\Settings.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Forms\Settings.Designer.cs">
      <DependentUpon>Settings.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\Utils\Driver\DriverListItem.cs" />
    <Compile Include="Forms\Utils\Driver\DriverListView.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Forms\Utils\Driver\DriverListView.Designer.cs">
      <DependentUpon>DriverListView.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\Utils\Driver\DriverSorter.cs" />
    <Compile Include="Forms\Utils\Memory\MemoryListItem.cs" />
    <Compile Include="Forms\Utils\Memory\MemoryListView.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Forms\Utils\Memory\MemoryListView.Designer.cs">
      <DependentUpon>MemoryListView.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\Utils\Memory\MemorySorter.cs" />
    <Compile Include="Forms\Utils\Module\ModuleListItem.cs" />
    <Compile Include="Forms\Utils\Module\ModuleListView.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Forms\Utils\Module\ModuleListView.Designer.cs">
      <DependentUpon>ModuleListView.cs</DependentUpon>
    </Compile>
    <Compile Include="Forms\Utils\Module\ModuleSorter.cs" />
    <Compile Include="Utils\Config.cs" />
    <Compile Include="Utils\StyleExtension.cs" />
    <Compile Include="Utils\NemesisApi.cs" />
    <Compile Include="Forms\Utils\Process\ProcessListItem.cs" />
    <Compile Include="Forms\Utils\Process\ProcessListView.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Forms\Utils\Process\ProcessSorter.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <EmbeddedResource Include="Forms\About.resx">
      <DependentUpon>About.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\NemesisForm.resx">
      <DependentUpon>NemesisForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\ProcessInfo.resx">
      <DependentUpon>ProcessInfo.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Forms\Settings.resx">
      <DependentUpon>Settings.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
      <DesignTime>True</DesignTime>
    </Compile>
    <None Include="packages.config" />
    <None Include="Properties\app.manifest" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.6.1">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.6.1 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
File: Nemesis.GUI/Program.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Security.Principal;
using System.Windows.Forms;
using Process = System.Diagnostics.Process;

namespace Nemesis
{
    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        private static void Main()
        {
            //
            // Run as administrator
            //
            if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator))
            {
                var path = Assembly.GetExecutingAssembly().Location;
                using (var process = Process.Start(new ProcessStartInfo(path)
                {
                    Verb = "runas"
                }))
                {
                    process?.WaitForExit();
                    return;
                }
            }

            //
            // Check if Nemesis.dll exists
            //
            if (!File.Exists("Nemesis.dll"))
            {
                MessageBox.Show("Nemesis.dll not found.");
                return;
            }

            //
            // Start application
            //
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Forms.NemesisForm());
        }
    }
}


================================================
File: Nemesis.GUI/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="MetroModernUI" version="1.4.0.0" targetFramework="net461" />
</packages>


================================================
File: Nemesis.GUI/Forms/About.Designer.cs
================================================
ï»¿namespace Nemesis.Forms
{
    partial class About
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.metroLabel1 = new MetroFramework.Controls.MetroLabel();
            this.metroLabel3 = new MetroFramework.Controls.MetroLabel();
            this.metroLabel4 = new MetroFramework.Controls.MetroLabel();
            this.metroLabel5 = new MetroFramework.Controls.MetroLabel();
            this.metroLabel6 = new MetroFramework.Controls.MetroLabel();
            this.SuspendLayout();
            // 
            // metroLabel1
            // 
            this.metroLabel1.Location = new System.Drawing.Point(23, 71);
            this.metroLabel1.Name = "metroLabel1";
            this.metroLabel1.Size = new System.Drawing.Size(484, 22);
            this.metroLabel1.TabIndex = 0;
            this.metroLabel1.Text = "License: MIT";
            // 
            // metroLabel3
            // 
            this.metroLabel3.Location = new System.Drawing.Point(23, 107);
            this.metroLabel3.Name = "metroLabel3";
            this.metroLabel3.Size = new System.Drawing.Size(484, 22);
            this.metroLabel3.TabIndex = 2;
            this.metroLabel3.Text = "Credits: ";
            // 
            // metroLabel4
            // 
            this.metroLabel4.Location = new System.Drawing.Point(23, 129);
            this.metroLabel4.Name = "metroLabel4";
            this.metroLabel4.Size = new System.Drawing.Size(484, 22);
            this.metroLabel4.TabIndex = 3;
            this.metroLabel4.Text = "- KsDumper by EquiFox";
            // 
            // metroLabel5
            // 
            this.metroLabel5.Location = new System.Drawing.Point(23, 151);
            this.metroLabel5.Name = "metroLabel5";
            this.metroLabel5.Size = new System.Drawing.Size(484, 22);
            this.metroLabel5.TabIndex = 4;
            this.metroLabel5.Text = "- Scylla by NtQuery";
            // 
            // metroLabel6
            // 
            this.metroLabel6.Location = new System.Drawing.Point(23, 191);
            this.metroLabel6.Name = "metroLabel6";
            this.metroLabel6.Size = new System.Drawing.Size(484, 22);
            this.metroLabel6.TabIndex = 5;
            this.metroLabel6.Text = "Made by not-matthias";
            // 
            // About
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(530, 300);
            this.Controls.Add(this.metroLabel6);
            this.Controls.Add(this.metroLabel5);
            this.Controls.Add(this.metroLabel4);
            this.Controls.Add(this.metroLabel3);
            this.Controls.Add(this.metroLabel1);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "About";
            this.Resizable = false;
            this.ShadowType = MetroFramework.Forms.MetroFormShadowType.AeroShadow;
            this.ShowInTaskbar = false;
            this.Text = "About";
            this.ResumeLayout(false);

        }

        #endregion

        private MetroFramework.Controls.MetroLabel metroLabel1;
        private MetroFramework.Controls.MetroLabel metroLabel3;
        private MetroFramework.Controls.MetroLabel metroLabel4;
        private MetroFramework.Controls.MetroLabel metroLabel5;
        private MetroFramework.Controls.MetroLabel metroLabel6;
    }
}


================================================
File: Nemesis.GUI/Forms/About.cs
================================================
ï»¿using MetroFramework.Forms;
using Nemesis.Utils;

namespace Nemesis.Forms
{
    public partial class About : MetroForm
    {
        public About()
        {
            InitializeComponent();
            components.SetStyle(this);
        }
    }
}


================================================
File: Nemesis.GUI/Forms/About.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: Nemesis.GUI/Forms/NemesisForm.Designer.cs
================================================
ï»¿using Nemesis.Forms.Utils;
using Nemesis.Forms.Utils.Process;

namespace Nemesis.Forms
{
    partial class NemesisForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.dumpButton = new MetroFramework.Controls.MetroButton();
            this.refreshButton = new MetroFramework.Controls.MetroButton();
            this.settingsButton = new MetroFramework.Controls.MetroButton();
            this.aboutButton = new MetroFramework.Controls.MetroButton();
            this.tabControl = new MetroFramework.Controls.MetroTabControl();
            this.processesTabPage = new MetroFramework.Controls.MetroTabPage();
            this.metroTabPage2 = new MetroFramework.Controls.MetroTabPage();
            this.styleManager = new MetroFramework.Components.MetroStyleManager(this.components);
            this.processListView = new Nemesis.Forms.Utils.Process.ProcessListView();
            this.driverListView = new Nemesis.Forms.Utils.Driver.DriverListView();
            this.columnName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnBase = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnSize = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnPath = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.tabControl.SuspendLayout();
            this.processesTabPage.SuspendLayout();
            this.metroTabPage2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.styleManager)).BeginInit();
            this.SuspendLayout();
            // 
            // dumpButton
            // 
            this.dumpButton.Location = new System.Drawing.Point(702, 403);
            this.dumpButton.Name = "dumpButton";
            this.dumpButton.Size = new System.Drawing.Size(75, 23);
            this.dumpButton.TabIndex = 0;
            this.dumpButton.Text = "Dump";
            this.dumpButton.UseSelectable = true;
            this.dumpButton.Click += new System.EventHandler(this.DumpButton_Click);
            // 
            // refreshButton
            // 
            this.refreshButton.Location = new System.Drawing.Point(621, 403);
            this.refreshButton.Name = "refreshButton";
            this.refreshButton.Size = new System.Drawing.Size(75, 23);
            this.refreshButton.TabIndex = 2;
            this.refreshButton.Text = "Refresh";
            this.refreshButton.UseSelectable = true;
            this.refreshButton.Click += new System.EventHandler(this.RefreshButton_Click);
            // 
            // settingsButton
            // 
            this.settingsButton.Location = new System.Drawing.Point(104, 403);
            this.settingsButton.Name = "settingsButton";
            this.settingsButton.Size = new System.Drawing.Size(75, 23);
            this.settingsButton.TabIndex = 3;
            this.settingsButton.Text = "Settings";
            this.settingsButton.UseSelectable = true;
            this.settingsButton.Click += new System.EventHandler(this.SettingsButton_Click);
            // 
            // aboutButton
            // 
            this.aboutButton.Location = new System.Drawing.Point(23, 403);
            this.aboutButton.Name = "aboutButton";
            this.aboutButton.Size = new System.Drawing.Size(75, 23);
            this.aboutButton.TabIndex = 4;
            this.aboutButton.Text = "About";
            this.aboutButton.UseSelectable = true;
            this.aboutButton.Click += new System.EventHandler(this.AboutButton_Click);
            // 
            // tabControl
            // 
            this.tabControl.Controls.Add(this.processesTabPage);
            this.tabControl.Controls.Add(this.metroTabPage2);
            this.tabControl.Location = new System.Drawing.Point(23, 63);
            this.tabControl.Name = "tabControl";
            this.tabControl.SelectedIndex = 0;
            this.tabControl.Size = new System.Drawing.Size(754, 334);
            this.tabControl.TabIndex = 6;
            this.tabControl.UseSelectable = true;
            // 
            // processesTabPage
            // 
            this.processesTabPage.Controls.Add(this.processListView);
            this.processesTabPage.HorizontalScrollbarBarColor = true;
            this.processesTabPage.HorizontalScrollbarHighlightOnWheel = false;
            this.processesTabPage.HorizontalScrollbarSize = 10;
            this.processesTabPage.Location = new System.Drawing.Point(4, 38);
            this.processesTabPage.Name = "processesTabPage";
            this.processesTabPage.Size = new System.Drawing.Size(746, 292);
            this.processesTabPage.TabIndex = 0;
            this.processesTabPage.Text = "Processes";
            this.processesTabPage.VerticalScrollbarBarColor = true;
            this.processesTabPage.VerticalScrollbarHighlightOnWheel = false;
            this.processesTabPage.VerticalScrollbarSize = 10;
            // 
            // metroTabPage2
            // 
            this.metroTabPage2.Controls.Add(this.driverListView);
            this.metroTabPage2.HorizontalScrollbarBarColor = true;
            this.metroTabPage2.HorizontalScrollbarHighlightOnWheel = false;
            this.metroTabPage2.HorizontalScrollbarSize = 10;
            this.metroTabPage2.Location = new System.Drawing.Point(4, 38);
            this.metroTabPage2.Name = "metroTabPage2";
            this.metroTabPage2.Size = new System.Drawing.Size(746, 292);
            this.metroTabPage2.TabIndex = 1;
            this.metroTabPage2.Text = "Drivers";
            this.metroTabPage2.VerticalScrollbarBarColor = true;
            this.metroTabPage2.VerticalScrollbarHighlightOnWheel = false;
            this.metroTabPage2.VerticalScrollbarSize = 10;
            // 
            // styleManager
            // 
            this.styleManager.Owner = this;
            // 
            // processListView
            // 
            this.processListView.Alignment = System.Windows.Forms.ListViewAlignment.Default;
            this.processListView.FullRowSelect = true;
            this.processListView.HideSelection = false;
            this.processListView.Location = new System.Drawing.Point(3, 12);
            this.processListView.MultiSelect = false;
            this.processListView.Name = "processListView";
            this.processListView.Size = new System.Drawing.Size(740, 277);
            this.processListView.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.processListView.TabIndex = 0;
            this.processListView.UseCompatibleStateImageBehavior = false;
            this.processListView.View = System.Windows.Forms.View.Details;
            this.processListView.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.ProcessListView_MouseDoubleClick);
            // 
            // driverListView
            // 
            this.driverListView.Alignment = System.Windows.Forms.ListViewAlignment.Default;
            this.driverListView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnName,
            this.columnBase,
            this.columnSize,
            this.columnPath});
            this.driverListView.FullRowSelect = true;
            this.driverListView.HideSelection = false;
            this.driverListView.Location = new System.Drawing.Point(3, 12);
            this.driverListView.MultiSelect = false;
            this.driverListView.Name = "driverListView";
            this.driverListView.Size = new System.Drawing.Size(740, 277);
            this.driverListView.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.driverListView.TabIndex = 0;
            this.driverListView.UseCompatibleStateImageBehavior = false;
            this.driverListView.View = System.Windows.Forms.View.Details;
            // 
            // columnName
            // 
            this.columnName.Text = "Name";
            this.columnName.Width = 190;
            // 
            // columnBase
            // 
            this.columnBase.Text = "ImageBase";
            this.columnBase.Width = 125;
            // 
            // columnSize
            // 
            this.columnSize.Text = "ImageSize";
            this.columnSize.Width = 80;
            // 
            // columnPath
            // 
            this.columnPath.Text = "Path";
            this.columnPath.Width = 314;
            // 
            // NemesisForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Controls.Add(this.tabControl);
            this.Controls.Add(this.aboutButton);
            this.Controls.Add(this.settingsButton);
            this.Controls.Add(this.refreshButton);
            this.Controls.Add(this.dumpButton);
            this.MaximizeBox = false;
            this.Name = "NemesisForm";
            this.Resizable = false;
            this.ShadowType = MetroFramework.Forms.MetroFormShadowType.AeroShadow;
            this.Text = "Nemesis";
            this.tabControl.ResumeLayout(false);
            this.processesTabPage.ResumeLayout(false);
            this.metroTabPage2.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.styleManager)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private MetroFramework.Controls.MetroButton dumpButton;
        private MetroFramework.Controls.MetroButton refreshButton;
        private ProcessListView processListView;
        private MetroFramework.Controls.MetroButton settingsButton;
        private MetroFramework.Controls.MetroButton aboutButton;
        private MetroFramework.Controls.MetroTabControl tabControl;
        private MetroFramework.Controls.MetroTabPage processesTabPage;
        private MetroFramework.Controls.MetroTabPage metroTabPage2;
        private Utils.Driver.DriverListView driverListView;
        private System.Windows.Forms.ColumnHeader columnName;
        private System.Windows.Forms.ColumnHeader columnBase;
        private System.Windows.Forms.ColumnHeader columnSize;
        private System.Windows.Forms.ColumnHeader columnPath;
        public MetroFramework.Components.MetroStyleManager styleManager;
    }
}




================================================
File: Nemesis.GUI/Forms/NemesisForm.cs
================================================
ï»¿using MetroFramework.Forms;
using System;
using System.Collections.Generic;
using System.IO;
using System.Windows.Forms;
using Nemesis.Forms.Utils.Driver;
using Nemesis.Forms.Utils.Process;
using Nemesis.Utils;

namespace Nemesis.Forms
{
    public partial class NemesisForm : MetroForm
    {
        /// <summary>
        /// List of process information, to reduce loading times.
        /// </summary>
        private readonly Dictionary<int, ProcessInformation> _processInformationList = new Dictionary<int, ProcessInformation>();

        /// <summary>
        /// The settings page (declared once to prevent loading times).
        /// </summary>
        private readonly Settings _settings = new Settings();

        /// <summary>
        /// Sets the styles and loads list data.
        /// </summary>
        public NemesisForm()
        {
            InitializeComponent();

            //
            // Set the styles
            //
            components.SetStyle(this);

            //
            // Load data
            //
            processListView.LoadProcesses();
            driverListView.LoadDrivers();
        }

        /// <summary>
        /// Refreshes the process and driver list.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void RefreshButton_Click(object sender, EventArgs e)
        {
            processListView.LoadProcesses();
            driverListView.LoadDrivers();
        }

        /// <summary>
        /// Dumps the selected process.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void DumpButton_Click(object sender, EventArgs e)
        {
            if (processListView.SelectedItems.Count <= 0 && driverListView.SelectedItems.Count <= 0) return;

            //
            // Set the variables
            //
            var extension = tabControl.SelectedIndex == 0 ? ".exe" : ".sys";
            var filter = tabControl.SelectedIndex == 0 ? "Executable File (.exe)|*.exe" : "System file (.sys)|*.sys";
            var name = tabControl.SelectedIndex == 0
                ? processListView.SelectedItems[0].SubItems[1].Text
                : Path.GetFileNameWithoutExtension(driverListView.SelectedItems[0].SubItems[0].Text);

            var path = "";


            //
            // Ask for location
            //
            if (Config.GetValue("ask_for_location") == "On")
            {
                //
                // Open the dialog
                //
                var saveFile = new SaveFileDialog
                {
                    // 
                    // Set the default name
                    // 
                    FileName = $@"{name}{Config.GetValue("file_name")}{extension}",

                    // 
                    // Set the filters
                    // 
                    Filter = filter
                };

                //
                // Show the dialog
                //
                if (saveFile.ShowDialog() == DialogResult.OK)
                {
                    path = saveFile.FileName;
                }
                else
                {
                    return;
                }
            }


            //
            // Use custom dump location
            //
            if ((Config.GetValue("custom_dump_location")) == "On")
            {
                var dumpLocation = Path.GetFullPath(Config.GetValue("dump_location"));

                //
                // Absolute path
                //
                if (Path.IsPathRooted(path))
                {
                    path = dumpLocation;
                }

                //
                // Relative path
                //
                if (!Path.IsPathRooted(path))
                {
                    path = $@"{Path.Combine(Path.GetDirectoryName(Application.ExecutablePath) ?? throw new InvalidOperationException(), dumpLocation)}";
                }

                //
                // Create process folder
                //
                if (Config.GetValue("create_process_folder") == "On" && name != null)
                {
                    path = Path.Combine(path, name);
                }

                //
                // Create timestamp folder
                //
                if (Config.GetValue("create_timestamp_folder") == "On")
                {
                    path = Path.Combine(path, $@"{DateTime.Now:dd-MM-yyyy HH-mm-ss}");
                }

                //
                // Create the directories (in case they are not existing)
                //
                try
                {
                    Directory.CreateDirectory(path);

                    path = Path.Combine(path, $@"{name}{Config.GetValue("file_name")}{extension}");
                }
                catch (Exception exception)
                {
                    MessageBox.Show($@"{exception.Message}", @"Warning");
                    return;
                }
            }


            try
            {
                //
                // Dump it
                //
                var status = false;
                if (tabControl.SelectedIndex == 0)
                {
                    //
                    // Process
                    //
                    if (processListView.SelectedItems[0].Tag is ProcessListItem process)
                    {
                        var processId = int.Parse(process.Id);
                        status = NemesisApi.DumpProcess(processId, path);
                    }
                }
                else
                {
                    //
                    // Driver
                    //
                    if (driverListView.SelectedItems[0].Tag is DriverListItem driver)
                    {
                        status = NemesisApi.DumpDriver((IntPtr) driver.ImageBase, path);
                    }

                    //
                    // Save base addresses
                    //
                    if (Config.GetValue("save_base_addresses") == "On")
                    {
                        NemesisApi.SaveDriverInformation(Path.Combine(Path.GetDirectoryName(path) ?? throw new InvalidOperationException(), "driver_list.txt"));
                    }
                }


                //
                // Check status
                //
                var type = tabControl.SelectedIndex == 0 ? "process" : "driver";
                if (status)
                {
                    MessageBox.Show($@"Successfully dumped the {type}.", @"Success");
                }
                else
                {
                    MessageBox.Show($@"Failed to dump the {type}.", @"Warning");
                }
            }
            catch (Exception)
            {
                MessageBox.Show(@"Nemesis threw an exception.", @"Warning");
            }
        }

        /// <summary>
        /// Opens the about window.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void AboutButton_Click(object sender, EventArgs e)
        {
            var about = new About();
            about.ShowDialog();
            about.Dispose();
        }

        /// <summary>
        /// Opens the settings window.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void SettingsButton_Click(object sender, EventArgs e)
        {
            _settings.ShowDialog();
        }

        /// <summary>
        /// Opens the process information window for the selected process.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ProcessListView_MouseDoubleClick(object sender, MouseEventArgs e)
        {
            //
            // Check if element selected
            //
            if (processListView.SelectedItems.Count <= 0) return;

            //
            // Check if tag is valid
            //
            if (!(processListView.SelectedItems[0].Tag is ProcessListItem item)) return;

            //
            // Use cached process information if available
            //
            var processId = int.Parse(item.Id);
            var processInfo = _processInformationList.ContainsKey(processId)
                ? _processInformationList[processId]
                : new ProcessInformation(processId);

            _processInformationList[processId] = processInfo;


            processInfo.ShowDialog();
        }

        /// <inheritdoc />
        /// <summary>
        /// Handles shortcuts.
        /// </summary>
        /// <param name="msg"></param>
        /// <param name="keyData"></param>
        /// <returns></returns>
        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            switch (keyData)
            {
                //
                // Ctrl+D = Dump
                //
                case Keys.Control | Keys.D:
                    DumpButton_Click(null, null);

                    return true;

                //
                // Ctrl+R = Refresh
                //
                case Keys.Control | Keys.R:
                    RefreshButton_Click(null, null);
                    break;

                //
                // Ctrl+Alt+S
                //
                case Keys.Control | Keys.Alt | Keys.S:
                    SettingsButton_Click(null, null);
                    break;
            }

            return base.ProcessCmdKey(ref msg, keyData);
        }
    }
}


================================================
File: Nemesis.GUI/Forms/NemesisForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="styleManager.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>


================================================
File: Nemesis.GUI/Forms/ProcessInfo.Designer.cs
================================================
ï»¿using Nemesis.Forms.Utils.Memory;
using Nemesis.Forms.Utils.Module;

namespace Nemesis.Forms
{
    sealed partial class ProcessInformation
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.metroTabPage2 = new MetroFramework.Controls.MetroTabPage();
            this.memoryLabel = new MetroFramework.Controls.MetroLabel();
            this.memoryListView = new Nemesis.Forms.Utils.Memory.MemoryListView();
            this.metroTabPage1 = new MetroFramework.Controls.MetroTabPage();
            this.moduleLabel = new MetroFramework.Controls.MetroLabel();
            this.moduleListView = new Nemesis.Forms.Utils.Module.ModuleListView();
            this.columnBase = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.tabControl = new MetroFramework.Controls.MetroTabControl();
            this.refreshButton = new MetroFramework.Controls.MetroButton();
            this.dumpButton = new MetroFramework.Controls.MetroButton();
            this.columnSize = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.columnPath = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.metroTabPage2.SuspendLayout();
            this.metroTabPage1.SuspendLayout();
            this.tabControl.SuspendLayout();
            this.SuspendLayout();
            // 
            // metroTabPage2
            // 
            this.metroTabPage2.Controls.Add(this.memoryLabel);
            this.metroTabPage2.Controls.Add(this.memoryListView);
            this.metroTabPage2.HorizontalScrollbarBarColor = true;
            this.metroTabPage2.HorizontalScrollbarHighlightOnWheel = false;
            this.metroTabPage2.HorizontalScrollbarSize = 10;
            this.metroTabPage2.Location = new System.Drawing.Point(4, 38);
            this.metroTabPage2.Name = "metroTabPage2";
            this.metroTabPage2.Size = new System.Drawing.Size(579, 220);
            this.metroTabPage2.TabIndex = 1;
            this.metroTabPage2.Text = "Memory";
            this.metroTabPage2.VerticalScrollbarBarColor = true;
            this.metroTabPage2.VerticalScrollbarHighlightOnWheel = false;
            this.metroTabPage2.VerticalScrollbarSize = 10;
            // 
            // memoryLabel
            // 
            this.memoryLabel.ForeColor = System.Drawing.SystemColors.ControlText;
            this.memoryLabel.Location = new System.Drawing.Point(17, 98);
            this.memoryLabel.Name = "memoryLabel";
            this.memoryLabel.Size = new System.Drawing.Size(548, 23);
            this.memoryLabel.TabIndex = 3;
            this.memoryLabel.Text = "Could not load memory list.";
            this.memoryLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // memoryListView
            // 
            this.memoryListView.FullRowSelect = true;
            this.memoryListView.HideSelection = false;
            this.memoryListView.Location = new System.Drawing.Point(3, 12);
            this.memoryListView.Name = "memoryListView";
            this.memoryListView.Size = new System.Drawing.Size(573, 197);
            this.memoryListView.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.memoryListView.TabIndex = 2;
            this.memoryListView.Text = "MemoryListView";
            this.memoryListView.UseCompatibleStateImageBehavior = false;
            this.memoryListView.View = System.Windows.Forms.View.Details;
            // 
            // metroTabPage1
            // 
            this.metroTabPage1.Controls.Add(this.moduleLabel);
            this.metroTabPage1.Controls.Add(this.moduleListView);
            this.metroTabPage1.HorizontalScrollbarBarColor = true;
            this.metroTabPage1.HorizontalScrollbarHighlightOnWheel = false;
            this.metroTabPage1.HorizontalScrollbarSize = 10;
            this.metroTabPage1.Location = new System.Drawing.Point(4, 38);
            this.metroTabPage1.Name = "metroTabPage1";
            this.metroTabPage1.Size = new System.Drawing.Size(579, 220);
            this.metroTabPage1.TabIndex = 0;
            this.metroTabPage1.Text = "Modules";
            this.metroTabPage1.VerticalScrollbarBarColor = true;
            this.metroTabPage1.VerticalScrollbarHighlightOnWheel = false;
            this.metroTabPage1.VerticalScrollbarSize = 10;
            // 
            // moduleLabel
            // 
            this.moduleLabel.ForeColor = System.Drawing.SystemColors.ControlText;
            this.moduleLabel.Location = new System.Drawing.Point(17, 98);
            this.moduleLabel.Name = "moduleLabel";
            this.moduleLabel.Size = new System.Drawing.Size(550, 23);
            this.moduleLabel.TabIndex = 2;
            this.moduleLabel.Text = "Could not load module list.";
            this.moduleLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            // 
            // moduleListView
            // 
            this.moduleListView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnName,
            this.columnBase,
            this.columnSize,
            this.columnPath});
            this.moduleListView.FullRowSelect = true;
            this.moduleListView.HideSelection = false;
            this.moduleListView.Location = new System.Drawing.Point(3, 12);
            this.moduleListView.MultiSelect = false;
            this.moduleListView.Name = "moduleListView";
            this.moduleListView.Size = new System.Drawing.Size(573, 197);
            this.moduleListView.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.moduleListView.TabIndex = 0;
            this.moduleListView.Text = "ModuleListView";
            this.moduleListView.UseCompatibleStateImageBehavior = false;
            this.moduleListView.View = System.Windows.Forms.View.Details;
            // 
            // columnBase
            // 
            this.columnBase.Text = "ImageBase";
            this.columnBase.Width = 90;
            // 
            // columnName
            // 
            this.columnName.Text = "Name";
            this.columnName.Width = 125;
            // 
            // tabControl
            // 
            this.tabControl.Controls.Add(this.metroTabPage1);
            this.tabControl.Controls.Add(this.metroTabPage2);
            this.tabControl.ItemSize = new System.Drawing.Size(62, 34);
            this.tabControl.Location = new System.Drawing.Point(23, 63);
            this.tabControl.Name = "tabControl";
            this.tabControl.SelectedIndex = 0;
            this.tabControl.Size = new System.Drawing.Size(587, 262);
            this.tabControl.SizeMode = System.Windows.Forms.TabSizeMode.FillToRight;
            this.tabControl.TabIndex = 0;
            this.tabControl.UseSelectable = true;
            // 
            // refreshButton
            // 
            this.refreshButton.Location = new System.Drawing.Point(450, 316);
            this.refreshButton.Name = "refreshButton";
            this.refreshButton.Size = new System.Drawing.Size(75, 23);
            this.refreshButton.TabIndex = 4;
            this.refreshButton.Text = "Refresh";
            this.refreshButton.UseSelectable = true;
            this.refreshButton.Click += new System.EventHandler(this.RefreshButton_Click);
            // 
            // dumpButton
            // 
            this.dumpButton.Location = new System.Drawing.Point(531, 316);
            this.dumpButton.Name = "dumpButton";
            this.dumpButton.Size = new System.Drawing.Size(75, 23);
            this.dumpButton.TabIndex = 3;
            this.dumpButton.Text = "Dump";
            this.dumpButton.UseSelectable = true;
            this.dumpButton.Click += new System.EventHandler(this.DumpButton_Click);
            // 
            // columnSize
            // 
            this.columnSize.Text = "ImageSize";
            this.columnSize.Width = 80;
            // 
            // columnPath
            // 
            this.columnPath.Text = "Path";
            this.columnPath.Width = 225;
            // 
            // ProcessInformation
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(633, 355);
            this.Controls.Add(this.refreshButton);
            this.Controls.Add(this.dumpButton);
            this.Controls.Add(this.tabControl);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "ProcessInformation";
            this.Resizable = false;
            this.ShadowType = MetroFramework.Forms.MetroFormShadowType.AeroShadow;
            this.ShowInTaskbar = false;
            this.Text = "Process Information";
            this.metroTabPage2.ResumeLayout(false);
            this.metroTabPage1.ResumeLayout(false);
            this.tabControl.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private MetroFramework.Controls.MetroTabPage metroTabPage2;
        private MetroFramework.Controls.MetroTabPage metroTabPage1;
        private MetroFramework.Controls.MetroTabControl tabControl;
        
        private ModuleListView moduleListView;
        private MemoryListView memoryListView;
        private MetroFramework.Controls.MetroLabel moduleLabel;
        private MetroFramework.Controls.MetroLabel memoryLabel;
        private System.Windows.Forms.ColumnHeader columnBase;
        private System.Windows.Forms.ColumnHeader columnName;
        private MetroFramework.Controls.MetroButton refreshButton;
        private MetroFramework.Controls.MetroButton dumpButton;
        private System.Windows.Forms.ColumnHeader columnSize;
        private System.Windows.Forms.ColumnHeader columnPath;
    }
}


================================================
File: Nemesis.GUI/Forms/ProcessInfo.cs
================================================
ï»¿using System;
using System.IO;
using System.Windows.Forms;
using MetroFramework.Controls;
using MetroFramework.Forms;
using Nemesis.Forms.Utils.Memory;
using Nemesis.Forms.Utils.Module;
using Nemesis.Utils;

namespace Nemesis.Forms
{
    public sealed partial class ProcessInformation : MetroForm
    {
        private readonly int _processId;

        /// <summary>
        /// Loads the data of the specified process.
        /// </summary>
        /// <param name="processId">The id of the process</param>
        public ProcessInformation(int processId)
        {
            InitializeComponent();

            _processId = processId;

            //
            // Set styles
            //
            components.SetStyle(this);

            //
            // Load modules and memory (can take some time)
            //
            Cursor.Current = Cursors.WaitCursor;
            LoadData();
            Cursor.Current = Cursors.Default;
        }

        /// <summary>
        /// Loads the modules and memory of the process.
        /// </summary>
        private void LoadData()
        {
            //
            // Module List View
            //
            if (moduleListView.LoadModules(_processId))
            {
                moduleListView.Show();
                moduleLabel.Hide();
            }
            else
            {
                moduleListView.Hide();
                moduleLabel.Show();
            }

            //
            // Memory List View
            //
            if (memoryListView.LoadMemory(_processId))
            {
                memoryListView.Show();
                memoryLabel.Hide();
            }
            else
            {
                memoryListView.Hide();
                memoryLabel.Show();
            }
        }

        /// <summary>
        /// Refresh both list views.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void RefreshButton_Click(object sender, EventArgs e)
        {
            LoadData();
        }

        /// <summary>
        /// Dump either a module or memory.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void DumpButton_Click(object sender, EventArgs e)
        {
            if (moduleListView.SelectedItems.Count <= 0 && memoryListView.SelectedItems.Count <= 0) return;

            switch (tabControl.SelectedIndex)
            {
                // Modules
                case 0:
                    if (moduleListView.SelectedItems[0].Tag is ModuleListItem module)
                    {
                        DumpModule(module);
                    }
                    break;

                // Memory
                case 1:
                    if (memoryListView.SelectedItems[0].Tag is MemoryListItem memory)
                    {
                        DumpMemory(memory);
                    }
                    break;
            }
        }

        /// <summary>
        /// Dumps the specified module.
        /// </summary>
        /// <param name="module">The module of a process</param>
        private void DumpModule(ModuleListItem module)
        {
            //
            // Get the destination path
            //
            string path;
            var saveFile = new SaveFileDialog
            {
                FileName = $@"{Path.GetFileName(module.ModuleName)}",
                Filter = @"Executable File (.dll)|*.dll"
            };

            //
            // Show the dialog
            //
            if (saveFile.ShowDialog() == DialogResult.OK)
            {
                path = saveFile.FileName;
            }
            else
            {
                return;
            }

            //
            // Dump module
            //
            if (!NemesisApi.DumpModule(_processId, (IntPtr)module.ImageBase, path))
            {
                MessageBox.Show("Failed to dump module.");
            }
            else
            {
                MessageBox.Show("Successfully dumped the module.");
            }
        }

        /// <summary>
        /// Dumps the specified memory.
        /// </summary>
        /// <param name="memory">The memory of a process.</param>
        private void DumpMemory(MemoryListItem memory)
        {
            //
            // Get the destination path
            //
            string path;
            var saveFile = new SaveFileDialog
            {
                FileName = $@"MEM_{memory.BaseAddress:X8}_{memory.RegionSize}.bin",
                Filter = @"Executable File (.bin)|*.bin"
            };

            //
            // Show the dialog
            //
            if (saveFile.ShowDialog() == DialogResult.OK)
            {
                path = saveFile.FileName;
            }
            else
            {
                return;
            }

            //
            // Dump module
            //
            if (!NemesisApi.DumpMemory(_processId, (IntPtr)memory.BaseAddress, (uint)memory.RegionSize, path))
            {
                MessageBox.Show("Failed to dump module.");
            }
            else
            {
                MessageBox.Show("Successfully dumped the module.");
            }
        }

        private void ModuleListView_MouseUp(object sender, MouseEventArgs e)
        {

        }

        private void MemoryListView_MouseUp(object sender, MouseEventArgs e)
        {

        }
    }
}


================================================
File: Nemesis.GUI/Forms/ProcessInfo.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: Nemesis.GUI/Forms/Settings.Designer.cs
================================================
ï»¿namespace Nemesis.Forms
{
    partial class Settings
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.metroLabel1 = new MetroFramework.Controls.MetroLabel();
            this.metroLabel2 = new MetroFramework.Controls.MetroLabel();
            this.saveButton = new MetroFramework.Controls.MetroButton();
            this.cancelButton = new MetroFramework.Controls.MetroButton();
            this.customDumpLocationToggle = new MetroFramework.Controls.MetroToggle();
            this.dumpLocation = new MetroFramework.Controls.MetroTextBox();
            this.metroLabel3 = new MetroFramework.Controls.MetroLabel();
            this.createFolderToggle = new MetroFramework.Controls.MetroToggle();
            this.metroLabel5 = new MetroFramework.Controls.MetroLabel();
            this.fileName = new MetroFramework.Controls.MetroTextBox();
            this.metroLabel6 = new MetroFramework.Controls.MetroLabel();
            this.createTimestampFolderToggle = new MetroFramework.Controls.MetroToggle();
            this.metroLabel4 = new MetroFramework.Controls.MetroLabel();
            this.askForLocationToggle = new MetroFramework.Controls.MetroToggle();
            this.metroLabel7 = new MetroFramework.Controls.MetroLabel();
            this.metroTabControl1 = new MetroFramework.Controls.MetroTabControl();
            this.metroTabPage1 = new MetroFramework.Controls.MetroTabPage();
            this.metroTabPage2 = new MetroFramework.Controls.MetroTabPage();
            this.colorComboBox = new MetroFramework.Controls.MetroComboBox();
            this.themeComboBox = new MetroFramework.Controls.MetroComboBox();
            this.metroTabPage3 = new MetroFramework.Controls.MetroTabPage();
            this.metroLabel9 = new MetroFramework.Controls.MetroLabel();
            this.manualModuleList = new MetroFramework.Controls.MetroToggle();
            this.metroLabel8 = new MetroFramework.Controls.MetroLabel();
            this.saveOffsetsToggle = new MetroFramework.Controls.MetroToggle();
            this.memoryComboBox = new MetroFramework.Controls.MetroComboBox();
            this.colorDialog = new System.Windows.Forms.ColorDialog();
            this.settingStyleManager = new MetroFramework.Components.MetroStyleManager(this.components);
            this.metroLabel10 = new MetroFramework.Controls.MetroLabel();
            this.headerFromFile = new MetroFramework.Controls.MetroToggle();
            this.metroTabControl1.SuspendLayout();
            this.metroTabPage1.SuspendLayout();
            this.metroTabPage2.SuspendLayout();
            this.metroTabPage3.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.settingStyleManager)).BeginInit();
            this.SuspendLayout();
            // 
            // metroLabel1
            // 
            this.metroLabel1.AutoSize = true;
            this.metroLabel1.Location = new System.Drawing.Point(2, 18);
            this.metroLabel1.Name = "metroLabel1";
            this.metroLabel1.Size = new System.Drawing.Size(105, 19);
            this.metroLabel1.TabIndex = 0;
            this.metroLabel1.Text = "Dump Location: ";
            // 
            // metroLabel2
            // 
            this.metroLabel2.AutoSize = true;
            this.metroLabel2.Location = new System.Drawing.Point(2, 86);
            this.metroLabel2.Name = "metroLabel2";
            this.metroLabel2.Size = new System.Drawing.Size(146, 19);
            this.metroLabel2.TabIndex = 3;
            this.metroLabel2.Text = "Custom dump location:";
            // 
            // saveButton
            // 
            this.saveButton.Location = new System.Drawing.Point(500, 322);
            this.saveButton.Name = "saveButton";
            this.saveButton.Size = new System.Drawing.Size(75, 23);
            this.saveButton.TabIndex = 4;
            this.saveButton.Text = "Save";
            this.saveButton.UseSelectable = true;
            this.saveButton.Click += new System.EventHandler(this.SaveButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(419, 322);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 5;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseSelectable = true;
            // 
            // customDumpLocationToggle
            // 
            this.customDumpLocationToggle.AutoSize = true;
            this.customDumpLocationToggle.Location = new System.Drawing.Point(186, 88);
            this.customDumpLocationToggle.Name = "customDumpLocationToggle";
            this.customDumpLocationToggle.Size = new System.Drawing.Size(80, 17);
            this.customDumpLocationToggle.TabIndex = 6;
            this.customDumpLocationToggle.Text = "Off";
            this.customDumpLocationToggle.UseSelectable = true;
            this.customDumpLocationToggle.CheckedChanged += new System.EventHandler(this.CustomDumpLocationToggle_CheckedChanged);
            // 
            // dumpLocation
            // 
            // 
            // 
            // 
            this.dumpLocation.CustomButton.Image = null;
            this.dumpLocation.CustomButton.Location = new System.Drawing.Point(220, 1);
            this.dumpLocation.CustomButton.Name = "";
            this.dumpLocation.CustomButton.Size = new System.Drawing.Size(21, 21);
            this.dumpLocation.CustomButton.Style = MetroFramework.MetroColorStyle.Blue;
            this.dumpLocation.CustomButton.TabIndex = 1;
            this.dumpLocation.CustomButton.Theme = MetroFramework.MetroThemeStyle.Light;
            this.dumpLocation.CustomButton.UseSelectable = true;
            this.dumpLocation.CustomButton.Visible = false;
            this.dumpLocation.Lines = new string[0];
            this.dumpLocation.Location = new System.Drawing.Point(186, 18);
            this.dumpLocation.MaxLength = 32767;
            this.dumpLocation.Name = "dumpLocation";
            this.dumpLocation.PasswordChar = '\0';
            this.dumpLocation.ReadOnly = true;
            this.dumpLocation.ScrollBars = System.Windows.Forms.ScrollBars.None;
            this.dumpLocation.SelectedText = "";
            this.dumpLocation.SelectionLength = 0;
            this.dumpLocation.SelectionStart = 0;
            this.dumpLocation.ShortcutsEnabled = true;
            this.dumpLocation.Size = new System.Drawing.Size(242, 23);
            this.dumpLocation.TabIndex = 7;
            this.dumpLocation.UseSelectable = true;
            this.dumpLocation.WaterMarkColor = System.Drawing.Color.FromArgb(((int)(((byte)(109)))), ((int)(((byte)(109)))), ((int)(((byte)(109)))));
            this.dumpLocation.WaterMarkFont = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Pixel);
            // 
            // metroLabel3
            // 
            this.metroLabel3.AutoSize = true;
            this.metroLabel3.Location = new System.Drawing.Point(2, 109);
            this.metroLabel3.Name = "metroLabel3";
            this.metroLabel3.Size = new System.Drawing.Size(159, 19);
            this.metroLabel3.TabIndex = 8;
            this.metroLabel3.Text = "Create folder for process:";
            // 
            // createFolderToggle
            // 
            this.createFolderToggle.AutoSize = true;
            this.createFolderToggle.Location = new System.Drawing.Point(186, 111);
            this.createFolderToggle.Name = "createFolderToggle";
            this.createFolderToggle.Size = new System.Drawing.Size(80, 17);
            this.createFolderToggle.TabIndex = 9;
            this.createFolderToggle.Text = "Off";
            this.createFolderToggle.UseSelectable = true;
            this.createFolderToggle.CheckedChanged += new System.EventHandler(this.CreateFolderToggle_CheckedChanged);
            // 
            // metroLabel5
            // 
            this.metroLabel5.AutoSize = true;
            this.metroLabel5.Location = new System.Drawing.Point(2, 44);
            this.metroLabel5.Name = "metroLabel5";
            this.metroLabel5.Size = new System.Drawing.Size(76, 19);
            this.metroLabel5.TabIndex = 12;
            this.metroLabel5.Text = "File Name: ";
            // 
            // fileName
            // 
            // 
            // 
            // 
            this.fileName.CustomButton.Image = null;
            this.fileName.CustomButton.Location = new System.Drawing.Point(220, 1);
            this.fileName.CustomButton.Name = "";
            this.fileName.CustomButton.Size = new System.Drawing.Size(21, 21);
            this.fileName.CustomButton.Style = MetroFramework.MetroColorStyle.Blue;
            this.fileName.CustomButton.TabIndex = 1;
            this.fileName.CustomButton.Theme = MetroFramework.MetroThemeStyle.Light;
            this.fileName.CustomButton.UseSelectable = true;
            this.fileName.CustomButton.Visible = false;
            this.fileName.Lines = new string[] {
        "_dump"};
            this.fileName.Location = new System.Drawing.Point(186, 44);
            this.fileName.MaxLength = 32767;
            this.fileName.Name = "fileName";
            this.fileName.PasswordChar = '\0';
            this.fileName.ScrollBars = System.Windows.Forms.ScrollBars.None;
            this.fileName.SelectedText = "";
            this.fileName.SelectionLength = 0;
            this.fileName.SelectionStart = 0;
            this.fileName.ShortcutsEnabled = true;
            this.fileName.Size = new System.Drawing.Size(242, 23);
            this.fileName.TabIndex = 13;
            this.fileName.Text = "_dump";
            this.fileName.UseSelectable = true;
            this.fileName.WaterMarkColor = System.Drawing.Color.FromArgb(((int)(((byte)(109)))), ((int)(((byte)(109)))), ((int)(((byte)(109)))));
            this.fileName.WaterMarkFont = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Pixel);
            // 
            // metroLabel6
            // 
            this.metroLabel6.AutoSize = true;
            this.metroLabel6.Location = new System.Drawing.Point(4, 128);
            this.metroLabel6.Name = "metroLabel6";
            this.metroLabel6.Size = new System.Drawing.Size(103, 19);
            this.metroLabel6.TabIndex = 14;
            this.metroLabel6.Text = "Add timestamp:";
            // 
            // createTimestampFolderToggle
            // 
            this.createTimestampFolderToggle.AutoSize = true;
            this.createTimestampFolderToggle.Location = new System.Drawing.Point(186, 134);
            this.createTimestampFolderToggle.Name = "createTimestampFolderToggle";
            this.createTimestampFolderToggle.Size = new System.Drawing.Size(80, 17);
            this.createTimestampFolderToggle.TabIndex = 15;
            this.createTimestampFolderToggle.Text = "Off";
            this.createTimestampFolderToggle.UseSelectable = true;
            this.createTimestampFolderToggle.CheckedChanged += new System.EventHandler(this.CreateTimestampFolderToggle_CheckedChanged);
            // 
            // metroLabel4
            // 
            this.metroLabel4.AutoSize = true;
            this.metroLabel4.Location = new System.Drawing.Point(2, 155);
            this.metroLabel4.Name = "metroLabel4";
            this.metroLabel4.Size = new System.Drawing.Size(124, 19);
            this.metroLabel4.TabIndex = 16;
            this.metroLabel4.Text = "Ask for file location:";
            // 
            // askForLocationToggle
            // 
            this.askForLocationToggle.AutoSize = true;
            this.askForLocationToggle.Location = new System.Drawing.Point(186, 157);
            this.askForLocationToggle.Name = "askForLocationToggle";
            this.askForLocationToggle.Size = new System.Drawing.Size(80, 17);
            this.askForLocationToggle.TabIndex = 17;
            this.askForLocationToggle.Text = "Off";
            this.askForLocationToggle.UseSelectable = true;
            this.askForLocationToggle.CheckedChanged += new System.EventHandler(this.AskForLocationToggle_CheckedChanged);
            // 
            // metroLabel7
            // 
            this.metroLabel7.AutoSize = true;
            this.metroLabel7.Location = new System.Drawing.Point(2, 132);
            this.metroLabel7.Name = "metroLabel7";
            this.metroLabel7.Size = new System.Drawing.Size(157, 19);
            this.metroLabel7.TabIndex = 14;
            this.metroLabel7.Text = "Create timestamp folder:";
            // 
            // metroTabControl1
            // 
            this.metroTabControl1.Controls.Add(this.metroTabPage1);
            this.metroTabControl1.Controls.Add(this.metroTabPage3);
            this.metroTabControl1.Controls.Add(this.metroTabPage2);
            this.metroTabControl1.Location = new System.Drawing.Point(23, 63);
            this.metroTabControl1.Name = "metroTabControl1";
            this.metroTabControl1.SelectedIndex = 0;
            this.metroTabControl1.Size = new System.Drawing.Size(552, 253);
            this.metroTabControl1.TabIndex = 18;
            this.metroTabControl1.UseSelectable = true;
            // 
            // metroTabPage1
            // 
            this.metroTabPage1.Controls.Add(this.askForLocationToggle);
            this.metroTabPage1.Controls.Add(this.metroLabel4);
            this.metroTabPage1.Controls.Add(this.dumpLocation);
            this.metroTabPage1.Controls.Add(this.createTimestampFolderToggle);
            this.metroTabPage1.Controls.Add(this.metroLabel1);
            this.metroTabPage1.Controls.Add(this.metroLabel7);
            this.metroTabPage1.Controls.Add(this.metroLabel2);
            this.metroTabPage1.Controls.Add(this.metroLabel6);
            this.metroTabPage1.Controls.Add(this.customDumpLocationToggle);
            this.metroTabPage1.Controls.Add(this.fileName);
            this.metroTabPage1.Controls.Add(this.metroLabel3);
            this.metroTabPage1.Controls.Add(this.metroLabel5);
            this.metroTabPage1.Controls.Add(this.createFolderToggle);
            this.metroTabPage1.HorizontalScrollbarBarColor = true;
            this.metroTabPage1.HorizontalScrollbarHighlightOnWheel = false;
            this.metroTabPage1.HorizontalScrollbarSize = 10;
            this.metroTabPage1.Location = new System.Drawing.Point(4, 38);
            this.metroTabPage1.Name = "metroTabPage1";
            this.metroTabPage1.Size = new System.Drawing.Size(544, 211);
            this.metroTabPage1.TabIndex = 0;
            this.metroTabPage1.Text = "General";
            this.metroTabPage1.VerticalScrollbarBarColor = true;
            this.metroTabPage1.VerticalScrollbarHighlightOnWheel = false;
            this.metroTabPage1.VerticalScrollbarSize = 10;
            // 
            // metroTabPage2
            // 
            this.metroTabPage2.Controls.Add(this.colorComboBox);
            this.metroTabPage2.Controls.Add(this.themeComboBox);
            this.metroTabPage2.HorizontalScrollbarBarColor = true;
            this.metroTabPage2.HorizontalScrollbarHighlightOnWheel = false;
            this.metroTabPage2.HorizontalScrollbarSize = 10;
            this.metroTabPage2.Location = new System.Drawing.Point(4, 38);
            this.metroTabPage2.Name = "metroTabPage2";
            this.metroTabPage2.Size = new System.Drawing.Size(544, 211);
            this.metroTabPage2.TabIndex = 1;
            this.metroTabPage2.Text = "Styles";
            this.metroTabPage2.VerticalScrollbarBarColor = true;
            this.metroTabPage2.VerticalScrollbarHighlightOnWheel = false;
            this.metroTabPage2.VerticalScrollbarSize = 10;
            // 
            // colorComboBox
            // 
            this.colorComboBox.FormattingEnabled = true;
            this.colorComboBox.ItemHeight = 23;
            this.colorComboBox.Location = new System.Drawing.Point(3, 54);
            this.colorComboBox.Name = "colorComboBox";
            this.colorComboBox.PromptText = "Color";
            this.colorComboBox.Size = new System.Drawing.Size(161, 29);
            this.colorComboBox.TabIndex = 6;
            this.colorComboBox.UseSelectable = true;
            this.colorComboBox.SelectedIndexChanged += new System.EventHandler(this.ColorComboBox_SelectedIndexChanged);
            // 
            // themeComboBox
            // 
            this.themeComboBox.FormattingEnabled = true;
            this.themeComboBox.ItemHeight = 23;
            this.themeComboBox.Location = new System.Drawing.Point(3, 18);
            this.themeComboBox.Name = "themeComboBox";
            this.themeComboBox.PromptText = "Theme";
            this.themeComboBox.Size = new System.Drawing.Size(161, 29);
            this.themeComboBox.TabIndex = 5;
            this.themeComboBox.UseSelectable = true;
            this.themeComboBox.SelectedIndexChanged += new System.EventHandler(this.ThemeComboBox_SelectedIndexChanged);
            // 
            // metroTabPage3
            // 
            this.metroTabPage3.Controls.Add(this.metroLabel10);
            this.metroTabPage3.Controls.Add(this.headerFromFile);
            this.metroTabPage3.Controls.Add(this.metroLabel9);
            this.metroTabPage3.Controls.Add(this.manualModuleList);
            this.metroTabPage3.Controls.Add(this.metroLabel8);
            this.metroTabPage3.Controls.Add(this.saveOffsetsToggle);
            this.metroTabPage3.Controls.Add(this.memoryComboBox);
            this.metroTabPage3.HorizontalScrollbarBarColor = true;
            this.metroTabPage3.HorizontalScrollbarHighlightOnWheel = false;
            this.metroTabPage3.HorizontalScrollbarSize = 10;
            this.metroTabPage3.Location = new System.Drawing.Point(4, 38);
            this.metroTabPage3.Name = "metroTabPage3";
            this.metroTabPage3.Size = new System.Drawing.Size(544, 211);
            this.metroTabPage3.TabIndex = 2;
            this.metroTabPage3.Text = "Miscellaneous";
            this.metroTabPage3.VerticalScrollbarBarColor = true;
            this.metroTabPage3.VerticalScrollbarHighlightOnWheel = false;
            this.metroTabPage3.VerticalScrollbarSize = 10;
            // 
            // metroLabel9
            // 
            this.metroLabel9.AutoSize = true;
            this.metroLabel9.Location = new System.Drawing.Point(3, 89);
            this.metroLabel9.Name = "metroLabel9";
            this.metroLabel9.Size = new System.Drawing.Size(148, 19);
            this.metroLabel9.TabIndex = 7;
            this.metroLabel9.Text = "Use manual module list:";
            // 
            // manualModuleList
            // 
            this.manualModuleList.AutoSize = true;
            this.manualModuleList.Location = new System.Drawing.Point(178, 91);
            this.manualModuleList.Name = "manualModuleList";
            this.manualModuleList.Size = new System.Drawing.Size(80, 17);
            this.manualModuleList.TabIndex = 6;
            this.manualModuleList.Text = "Off";
            this.manualModuleList.UseSelectable = true;
            // 
            // metroLabel8
            // 
            this.metroLabel8.AutoSize = true;
            this.metroLabel8.Location = new System.Drawing.Point(3, 61);
            this.metroLabel8.Name = "metroLabel8";
            this.metroLabel8.Size = new System.Drawing.Size(169, 19);
            this.metroLabel8.TabIndex = 5;
            this.metroLabel8.Text = "Save driver base addresses:";
            // 
            // saveOffsetsToggle
            // 
            this.saveOffsetsToggle.AutoSize = true;
            this.saveOffsetsToggle.Location = new System.Drawing.Point(178, 63);
            this.saveOffsetsToggle.Name = "saveOffsetsToggle";
            this.saveOffsetsToggle.Size = new System.Drawing.Size(80, 17);
            this.saveOffsetsToggle.TabIndex = 4;
            this.saveOffsetsToggle.Text = "Off";
            this.saveOffsetsToggle.UseSelectable = true;
            // 
            // memoryComboBox
            // 
            this.memoryComboBox.FormattingEnabled = true;
            this.memoryComboBox.ItemHeight = 23;
            this.memoryComboBox.Location = new System.Drawing.Point(3, 18);
            this.memoryComboBox.Name = "memoryComboBox";
            this.memoryComboBox.PromptText = "Memory Source";
            this.memoryComboBox.Size = new System.Drawing.Size(161, 29);
            this.memoryComboBox.TabIndex = 2;
            this.memoryComboBox.UseSelectable = true;
            // 
            // settingStyleManager
            // 
            this.settingStyleManager.Owner = null;
            // 
            // metroLabel10
            // 
            this.metroLabel10.AutoSize = true;
            this.metroLabel10.Location = new System.Drawing.Point(3, 118);
            this.metroLabel10.Name = "metroLabel10";
            this.metroLabel10.Size = new System.Drawing.Size(141, 19);
            this.metroLabel10.TabIndex = 9;
            this.metroLabel10.Text = "Read header from file:";
            // 
            // headerFromFile
            // 
            this.headerFromFile.AutoSize = true;
            this.headerFromFile.Location = new System.Drawing.Point(178, 120);
            this.headerFromFile.Name = "headerFromFile";
            this.headerFromFile.Size = new System.Drawing.Size(80, 17);
            this.headerFromFile.TabIndex = 8;
            this.headerFromFile.Text = "Off";
            this.headerFromFile.UseSelectable = true;
            // 
            // Settings
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(598, 356);
            this.Controls.Add(this.metroTabControl1);
            this.Controls.Add(this.cancelButton);
            this.Controls.Add(this.saveButton);
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "Settings";
            this.Resizable = false;
            this.ShadowType = MetroFramework.Forms.MetroFormShadowType.AeroShadow;
            this.ShowInTaskbar = false;
            this.Text = "Settings";
            this.metroTabControl1.ResumeLayout(false);
            this.metroTabPage1.ResumeLayout(false);
            this.metroTabPage1.PerformLayout();
            this.metroTabPage2.ResumeLayout(false);
            this.metroTabPage3.ResumeLayout(false);
            this.metroTabPage3.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.settingStyleManager)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private MetroFramework.Controls.MetroLabel metroLabel1;
        private MetroFramework.Controls.MetroLabel metroLabel2;
        private MetroFramework.Controls.MetroButton saveButton;
        private MetroFramework.Controls.MetroButton cancelButton;
        private MetroFramework.Controls.MetroToggle customDumpLocationToggle;
        private MetroFramework.Controls.MetroTextBox dumpLocation;
        private MetroFramework.Controls.MetroLabel metroLabel3;
        private MetroFramework.Controls.MetroToggle createFolderToggle;
        private MetroFramework.Controls.MetroLabel metroLabel5;
        private MetroFramework.Controls.MetroTextBox fileName;
        private MetroFramework.Controls.MetroLabel metroLabel6;
        private MetroFramework.Controls.MetroToggle createTimestampFolderToggle;
        private MetroFramework.Controls.MetroLabel metroLabel4;
        private MetroFramework.Controls.MetroToggle askForLocationToggle;
        private MetroFramework.Controls.MetroLabel metroLabel7;
        private MetroFramework.Controls.MetroTabControl metroTabControl1;
        private MetroFramework.Controls.MetroTabPage metroTabPage1;
        private MetroFramework.Controls.MetroTabPage metroTabPage2;
        private System.Windows.Forms.ColorDialog colorDialog;
        private MetroFramework.Controls.MetroComboBox themeComboBox;
        private MetroFramework.Controls.MetroComboBox colorComboBox;
        private MetroFramework.Controls.MetroTabPage metroTabPage3;
        private MetroFramework.Controls.MetroComboBox memoryComboBox;
        private MetroFramework.Components.MetroStyleManager settingStyleManager;
        private MetroFramework.Controls.MetroLabel metroLabel8;
        private MetroFramework.Controls.MetroToggle saveOffsetsToggle;
        private MetroFramework.Controls.MetroLabel metroLabel9;
        private MetroFramework.Controls.MetroToggle manualModuleList;
        private MetroFramework.Controls.MetroLabel metroLabel10;
        private MetroFramework.Controls.MetroToggle headerFromFile;
    }
}


================================================
File: Nemesis.GUI/Forms/Settings.cs
================================================
ï»¿using MetroFramework.Controls;
using MetroFramework.Forms;
using System;
using System.Windows.Forms;
using Nemesis.Utils;

namespace Nemesis.Forms
{
    public partial class Settings : MetroForm
    {
        /// <summary>
        /// Loads and sets the config data.
        /// </summary>
        public Settings()
        {
            InitializeComponent();

            //
            // Set the styles
            //
            components.SetStyle(this);

            //
            // Set default values the first time
            //
            if (Config.GetValue("first_time_started") == null)
            {
                Config.SetValue("file_name", "_dump");
                Config.SetValue("ask_for_location", "On");

                Config.SetValue("first_time_started", ".");
                Config.SetValue("theme", "Default");
                Config.SetValue("style", "Default");
                Config.SetValue("memory_source", "user_mode");

                Config.SetValue("save_base_addresses", "Off");
                Config.SetValue("manual_module_list", "Off");
            }

            //
            // TextFields
            //
            dumpLocation.Text = Config.GetValue("dump_location");
            fileName.Text = Config.GetValue("file_name");

            //
            // Toggles
            //
            customDumpLocationToggle.Checked = Config.GetValue("custom_dump_location") == "On";
            createFolderToggle.Checked = Config.GetValue("create_process_folder") == "On";
            createTimestampFolderToggle.Checked = Config.GetValue("create_timestamp_folder") == "On";
            askForLocationToggle.Checked = Config.GetValue("ask_for_location") == "On";
            saveOffsetsToggle.Checked = Config.GetValue("save_base_addresses") == "On";
            manualModuleList.Checked = Config.GetValue("manual_module_list") == "On";
            headerFromFile.Checked = Config.GetValue("read_header_from_file") == "On";

            //
            // Fill the combo boxes
            //
            themeComboBox.Items.AddRange(new object[] {"Dark", "Light"});
            colorComboBox.Items.AddRange(new object[]
                {"Default", "Black", "White", "Silver", "Blue", "Green", "Lime", "Teal", "Orange", "Brown", "Pink", "Magenta", "Purple", "Red", "Yellow"});
            memoryComboBox.Items.AddRange(NemesisApi.GetMemorySources().ToArray());
            themeComboBox.SelectedIndex = GetItemIndex(themeComboBox, Config.GetValue("theme"));
            colorComboBox.SelectedIndex = GetItemIndex(colorComboBox, Config.GetValue("style"));
            memoryComboBox.SelectedIndex = GetItemIndex(memoryComboBox, Config.GetValue("memory_source"));
        }

        /// <summary>
        /// Saves the settings to the config.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void SaveButton_Click(object sender, EventArgs e)
        {
            //
            // Save the settings
            //
            Config.SetValue("dump_location", dumpLocation.Text);
            Config.SetValue("file_name", fileName.Text);
            Config.SetValue("custom_dump_location", customDumpLocationToggle.Text);
            Config.SetValue("create_process_folder", createFolderToggle.Text);
            Config.SetValue("create_timestamp_folder", createTimestampFolderToggle.Text);
            Config.SetValue("ask_for_location", askForLocationToggle.Text);
            Config.SetValue("theme", themeComboBox.Text);
            Config.SetValue("style", colorComboBox.Text);
            Config.SetValue("memory_source", memoryComboBox.Text);
            Config.SetValue("save_base_addresses", saveOffsetsToggle.Text);
            Config.SetValue("manual_module_list", manualModuleList.Text);
            Config.SetValue("read_header_from_file", headerFromFile.Text);
            Config.SetValue("memory_source", memoryComboBox.Text);

            //
            // Set the nemesis config
            //
            NemesisApi.SetConfigValue("read_header_from_file", headerFromFile.Text);
            NemesisApi.SetConfigValue("memory_source", memoryComboBox.Text);

            Close();
        }

        /// <summary>
        /// Enables the "custom dump location" option.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CustomDumpLocationToggle_CheckedChanged(object sender, EventArgs e)
        {
            var toggle = (MetroToggle) sender;

            //
            // Disable "ask for location" if enabled
            //
            if (toggle.Checked)
            {
                dumpLocation.ReadOnly = false;
                askForLocationToggle.Checked = false;
            }
            else
            {
                dumpLocation.Clear();
                dumpLocation.ReadOnly = true;
            }
        }

        /// <summary>
        /// Enables the "create process folder" option.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CreateFolderToggle_CheckedChanged(object sender, EventArgs e)
        {
            var toggle = (MetroToggle) sender;

            //
            // Disable "ask for location" if enabled
            //
            if (toggle.Checked)
            {
                askForLocationToggle.Checked = false;
            }
        }

        /// <summary>
        /// Enables the "create timestamp folder" option.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CreateTimestampFolderToggle_CheckedChanged(object sender, EventArgs e)
        {
            var toggle = (MetroToggle) sender;

            //
            // Disable "ask for location" if enabled
            //
            if (toggle.Checked)
            {
                askForLocationToggle.Checked = false;
            }
        }

        /// <summary>
        /// Enables "ask for location" option.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void AskForLocationToggle_CheckedChanged(object sender, EventArgs e)
        {
            var toggle = (MetroToggle) sender;

            //
            // Disable "custom dump location" if enabled
            //
            if (toggle.Checked)
            {
                dumpLocation.Clear();

                //
                // Can't have generated folders when having this option enabled
                //
                customDumpLocationToggle.Checked = false;
                createFolderToggle.Checked = false;
                createTimestampFolderToggle.Checked = false;
            }
        }

        /// <summary>
        /// Changes the theme of the application.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ThemeComboBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            StyleExtension.SetThemeStyle(StyleExtension.GetMetroThemeStyle(themeComboBox.Text));

            Refresh();
        }

        /// <summary>
        /// Changes the color of the application.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ColorComboBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            StyleExtension.SetColorStyle(StyleExtension.GetMetroColorStyle(colorComboBox.Text));

            Refresh();
        }

        /// <summary>
        /// Returns the index of the specified item in the specified combo box.
        /// </summary>
        /// <param name="comboBox">The target combo box</param>
        /// <param name="value">The value of an item</param>
        /// <returns>Index or -1</returns>
        private int GetItemIndex(ComboBox comboBox, string value)
        {
            foreach (var item in comboBox.Items)
            {
                if (item as string == value)
                {
                    return comboBox.Items.IndexOf(item);
                }
            }

            return -1;
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Settings.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="colorDialog.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="settingStyleManager.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>131, 17</value>
  </metadata>
</root>


================================================
File: Nemesis.GUI/Forms/Utils/Driver/DriverListItem.cs
================================================
ï»¿using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Driver
{
    internal class DriverListItem
    {
        public long ImageBase { get; }
        public int ImageSize { get; }
        public ushort OffsetToFileName { get; }
        public string FullPathName { get; }

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="imageBase">The base address of the driver</param>
        /// <param name="imageSize">The size of the driver memory</param>
        /// <param name="offsetToFileName">The offset to the filename</param>
        /// <param name="fullPathName">The full path name</param>
        public DriverListItem(long imageBase, int imageSize, ushort offsetToFileName, string fullPathName)
        {
            ImageBase = imageBase;
            ImageSize = imageSize;
            OffsetToFileName = offsetToFileName;
            FullPathName = fullPathName;
        }

        /// <summary>
        /// Returns the list view item for the driver list.
        /// </summary>
        /// <returns>ListViewItem</returns>
        public ListViewItem GetListViewItem()
        {
            var listViewItem = new ListViewItem(FullPathName.Substring(OffsetToFileName));
            listViewItem.SubItems.Add(ImageBase.ToString("X8"));
            listViewItem.SubItems.Add(ImageSize.ToString("X8"));
            listViewItem.SubItems.Add(FullPathName);
            listViewItem.Tag = this;

            return listViewItem;
        }
    }
}



================================================
File: Nemesis.GUI/Forms/Utils/Driver/DriverListView.Designer.cs
================================================
ï»¿namespace Nemesis.Forms.Utils.Driver
{
    sealed partial class DriverListView
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Text = "DriverListView";
        }

        #endregion
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Driver/DriverListView.cs
================================================
ï»¿using System.Windows.Forms;
using Nemesis.Utils;

namespace Nemesis.Forms.Utils.Driver
{
    public sealed partial class DriverListView : ListView
    {
        private int _sortColumnIndex;

        /// <inheritdoc />
        /// <summary>
        /// Sets list view properties.
        /// </summary>
        public DriverListView()
        {
            DoubleBuffered = true;
            Sorting = SortOrder.Ascending;
        }

        /// <summary>
        /// Loads the drivers and adds them to the list.
        /// </summary>
        /// <returns>True if successful</returns>
        public bool LoadDrivers()
        {
            var drivers = NemesisApi.GetDriverList();

            //
            // Remove all previous drivers
            //
            Items.Clear();

            //
            // Loop through all drivers
            //
            foreach (var item in drivers)
            {
                //
                // Create a new DriverListItem
                //
                var driverListItem = new DriverListItem(item.ImageBase, item.ImageSize, item.OffsetToFileName, item.FullPathName);

                //
                // Add it to the ListView
                //
                Items.Add(driverListItem.GetListViewItem());
            }

            //
            // Auto resize the columns
            //
            AutoResizeColumns(ColumnHeaderAutoResizeStyle.None);

            //
            // Sort the list
            //
            ListViewItemSorter = new DriverSorter(_sortColumnIndex, Sorting);

            return true;
        }

        /// <inheritdoc />
        /// <summary>
        /// Sorts the list by the clicked column.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnColumnClick(ColumnClickEventArgs e)
        {
            //
            // Check if another column clicked
            //
            if (e.Column != _sortColumnIndex)
            {
                _sortColumnIndex = e.Column;
                Sorting = SortOrder.Descending;
            }
            else
            {
                //
                // Change the SortOrder to the opposite
                //
                Sorting = Sorting == SortOrder.Ascending ? SortOrder.Descending : SortOrder.Ascending;
            }

            //
            // Sort the list
            //
            ListViewItemSorter = new DriverSorter(e.Column, Sorting);
        }
    }
}



================================================
File: Nemesis.GUI/Forms/Utils/Driver/DriverSorter.cs
================================================
ï»¿using System;
using System.Collections;
using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Driver
{
    internal class DriverSorter : IComparer
    {
        private readonly int _columnIndex;
        private readonly SortOrder _sortOrder;

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="columnIndex">The index of the column</param>
        /// <param name="sortOrder">The sort order (Ascending or Descending)</param>
        public DriverSorter(int columnIndex, SortOrder sortOrder)
        {
            _columnIndex = columnIndex;
            _sortOrder = sortOrder;
        }

        /// <inheritdoc />
        /// <summary>
        /// Compares two driver list items.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public int Compare(object x, object y)
        {
            //
            // Check if the object is a ListViewItem
            //
            if ((!(x is ListViewItem item1)) || (!(y is ListViewItem item2))) return 0;

            //
            // Check if the tag is a ProcesslistItem
            //
            if (!(item1.Tag is DriverListItem p1) || !(item2.Tag is DriverListItem p2)) return 0;

            var result = 0;

            //
            // Chose the sort by the column
            //
            switch (_columnIndex)
            {
                // Name
                case 0:
                {
                    result = string.Compare(p1.FullPathName.Substring(p1.OffsetToFileName), p2.FullPathName.Substring(p2.OffsetToFileName),
                        StringComparison.OrdinalIgnoreCase);
                    break;
                }

                // ImageBase
                case 1:
                    if (p1.ImageBase > p2.ImageBase)
                        result = 1;

                    if (p1.ImageBase < p2.ImageBase)
                        result = -1;
                    break;

                // ImageSize
                case 2:
                    if (p1.ImageSize > p2.ImageSize)
                        result = 1;

                    if (p1.ImageSize < p2.ImageSize)
                        result = -1;
                    break;

                // FullPathName
                case 3:
                    result = string.Compare(p1.FullPathName, p2.FullPathName, StringComparison.OrdinalIgnoreCase);
                    break;
            }

            //
            // Revert the sort if it's descending
            //
            if (_sortOrder == SortOrder.Descending)
            {
                result = -result;
            }

            return result;
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Memory/MemoryListItem.cs
================================================
ï»¿using System.Collections.Generic;
using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Memory
{
    internal class MemoryListItem
    {
        public ulong BaseAddress { get; }
        public ulong RegionSize { get; }
        public int State { get; }
        public int Type { get; }

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="baseAddress">The base address of the memory region</param>
        /// <param name="regionSize">The size of the memory region</param>
        /// <param name="state">The state of the memory region (MEM_COMMIT, MEM_RESERVE, MEM_FREE, MEM_PRIVATE, MEM_MAPPED, or MEM_IMAGE)</param>
        /// <param name="type">The type of the memory region (MEM_IMAGE, MEM_MAPPED or MEM_PRIVATE)</param>
        public MemoryListItem(ulong baseAddress, ulong regionSize, int state, int type)
        {
            BaseAddress = baseAddress;
            RegionSize = regionSize;
            State = state;
            Type = type;
        }

        /// <summary>
        /// Returns the list view item for the memory list.
        /// </summary>
        /// <returns>ListViewItem</returns>
        public ListViewItem GetListViewItem()
        {
            var listViewItem = new ListViewItem(BaseAddress.ToString("X8"));
            listViewItem.SubItems.Add(RegionSize.ToString("X8"));

            //
            // Parse state
            //
            var states = new List<string>();

            if ((State & 0x1000) != 0)
            {
                states.Add("MEM_COMMIT");
            }

            if ((State & 0x10000) != 0)
            {
                states.Add("MEM_FREE");
            }

            if ((State & 0x2000) != 0)
            {
                states.Add("MEM_RESERVE");
            }

            listViewItem.SubItems.Add(string.Join("|", states));
            
            //
            // Parse type
            //
            var types = new List<string>();

            if ((Type & 0x1000000) != 0)
            {
                types.Add("MEM_IMAGE");
            }

            if ((Type & 0x40000) != 0)
            {
                types.Add("MEM_MAPPED");
            }

            if ((Type & 0x20000) != 0)
            {
                types.Add("MEM_PRIVATE");
            }

            listViewItem.SubItems.Add(string.Join("|", types));

            listViewItem.Tag = this;

            return listViewItem;
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Memory/MemoryListView.Designer.cs
================================================
ï»¿namespace Nemesis.Forms.Utils.Memory
{
    sealed partial class MemoryListView
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Text = "MemoryListView";
        }

        #endregion
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Memory/MemoryListView.cs
================================================
ï»¿using System.Windows.Forms;
using Nemesis.Utils;

namespace Nemesis.Forms.Utils.Memory
{
    public sealed partial class MemoryListView: ListView
    {
        private int _sortColumnIndex;

        /// <inheritdoc />
        /// <summary>
        /// Sets list view properties and columns.
        /// </summary>
        public MemoryListView()
        {
            Columns.Add("BaseAddress");
            Columns.Add("RegionSize");
            Columns.Add("State");
            Columns.Add("Type");

            DoubleBuffered = true;
            Sorting = SortOrder.Ascending;
        }

        /// <summary>
        /// Loads the memory regions and adds them to the list.
        /// </summary>
        /// <returns>True if successful</returns>
        public bool LoadMemory(int processId)
        {
            var memory = NemesisApi.GetMemoryList(processId);

            //
            // Check if empty
            //
            if (memory.Count == 0) return false;

            //
            // Remove all previous processes
            //
            Items.Clear();

            //
            // Loop through all processes
            //
            foreach (var item in memory)
            {
                //
                // Create a new ProcessListItem
                //
                var memoryListItem = new MemoryListItem(item.BaseAddress, item.RegionSize, item.State, item.Type);

                //
                // Add it to the ListView
                //
                Items.Add(memoryListItem.GetListViewItem());
            }

            //
            // Auto resize the columns
            //
            AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);

            //
            // Sort the list
            //
            ListViewItemSorter = new MemorySorter(_sortColumnIndex, Sorting);

            return true;
        }

        /// <inheritdoc />
        /// <summary>
        /// Sorts the list by the clicked column.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnColumnClick(ColumnClickEventArgs e)
        {
            //
            // Check if another column clicked
            //
            if (e.Column != _sortColumnIndex)
            {
                _sortColumnIndex = e.Column;
                Sorting = SortOrder.Descending;
            }
            else
            {
                //
                // Change the SortOrder to the opposite
                //
                Sorting = Sorting == SortOrder.Ascending ? SortOrder.Descending : SortOrder.Ascending;
            }

            //
            // Sort the list
            //
            ListViewItemSorter = new MemorySorter(e.Column, Sorting);
        }
    }
}



================================================
File: Nemesis.GUI/Forms/Utils/Memory/MemorySorter.cs
================================================
ï»¿using System.Collections;
using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Memory
{
    internal class MemorySorter : IComparer
    {
        private readonly int _columnIndex;
        private readonly SortOrder _sortOrder;

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="columnIndex">The index of the column</param>
        /// <param name="sortOrder">The sort order (Ascending or Descending)</param>
        public MemorySorter(int columnIndex, SortOrder sortOrder)
        {
            _columnIndex = columnIndex;
            _sortOrder = sortOrder;
        }

        /// <inheritdoc />
        /// <summary>
        /// Compares two memory list items.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public int Compare(object x, object y)
        {
            //
            // Check if the object is a ListViewItem
            //
            if ((!(x is ListViewItem item1)) || (!(y is ListViewItem item2))) return 0;

            //
            // Check if the tag is a ProcesslistItem
            //
            if (!(item1.Tag is MemoryListItem p1) || !(item2.Tag is MemoryListItem p2)) return 0;

            var result = 0;

            //
            // Chose the sort by the column
            //
            switch (_columnIndex)
            {
                // BaseAddress
                case 0:
                {
                    if (p1.BaseAddress > p2.BaseAddress)
                        result = 1;

                    if (p1.BaseAddress < p2.BaseAddress)
                        result = -1;
                    break;
                }

                // RegionSize
                case 1:
                    if (p1.RegionSize > p2.RegionSize)
                        result = 1;

                    if (p1.RegionSize < p2.RegionSize)
                        result = -1;
                    break;

                // State
                case 2:
                    if (p1.State > p2.State)
                        result = 1;

                    if (p1.State < p2.State)
                        result = -1;
                    break;

                // Type
                case 3:
                    if (p1.Type > p2.Type)
                        result = 1;

                    if (p1.Type < p2.Type)
                        result = -1;
                    break;
            }

            //
            // Revert the sort if it's descending
            //
            if (_sortOrder == SortOrder.Descending)
            {
                result = -result;
            }

            return result;
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Module/ModuleListItem.cs
================================================
ï»¿using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Module
{
    internal class ModuleListItem
    {
        public long ImageBase { get; }
        public long ImageSize { get; }
        public string ModuleName { get; }
        public string ModulePath { get; }

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="imageBase">The base address of the module</param>
        /// <param name="imageSize">The size of the image</param>
        /// <param name="moduleName">The name of the module</param>
        /// <param name="modulePath">The path to the image</param>
        public ModuleListItem(long imageBase, long imageSize, string moduleName, string modulePath)
        {
            ImageBase = imageBase;
            ImageSize = imageSize;
            ModuleName = moduleName;
            ModulePath = modulePath;
        }

        /// <summary>
        /// Returns the list view item for the module list.
        /// </summary>
        /// <returns>ListViewItem</returns>
        public ListViewItem GetListViewItem()
        {
            var listViewItem = new ListViewItem(ModuleName);
            listViewItem.SubItems.Add(ImageBase.ToString("X8"));
            listViewItem.SubItems.Add(ImageSize.ToString("X8"));
            listViewItem.SubItems.Add(ModulePath);
            listViewItem.Tag = this;

            return listViewItem;
        }
    }
}



================================================
File: Nemesis.GUI/Forms/Utils/Module/ModuleListView.Designer.cs
================================================
ï»¿namespace Nemesis.Forms.Utils.Module
{
    sealed partial class ModuleListView
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Text = "ModuleListView";
        }

        #endregion
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Module/ModuleListView.cs
================================================
ï»¿using System.Windows.Forms;
using Nemesis.Utils;

namespace Nemesis.Forms.Utils.Module
{
    public sealed partial class ModuleListView : ListView
    {
        private int _sortColumnIndex;

        /// <inheritdoc />
        /// <summary>
        /// Sets list view properties.
        /// </summary>
        public ModuleListView()
        {
            DoubleBuffered = true;
            Sorting = SortOrder.Ascending;
        }

        /// <summary>
        /// Loads the modules and adds them to the list.
        /// </summary>
        /// <returns>True if successful</returns>
        public bool LoadModules(int processId)
        {
            var modules = Config.GetValue("manual_module_list") == "On" ? NemesisApi.GetManualModuleList(processId) : NemesisApi.GetModuleList(processId);

            //
            // Check if empty
            //
            if (modules.Count == 0) return false;

            //
            // Remove all previous processes
            //
            Items.Clear();

            //
            // Loop through all processes
            //
            foreach (var module in modules)
            {
                //
                // Create a new ProcessListItem
                //
                var processListItem = new ModuleListItem(module.ImageBase, module.ImageSize, module.ModuleName, module.ModulePath);

                //
                // Add it to the ListView
                //
                Items.Add(processListItem.GetListViewItem());
            }

            //
            // Auto resize the columns
            //
            AutoResizeColumns(ColumnHeaderAutoResizeStyle.None);

            //
            // Sort the list
            //
            ListViewItemSorter = new ModuleSorter(_sortColumnIndex, Sorting);

            return true;
        }

        /// <inheritdoc />
        /// <summary>
        /// Sorts the list by the clicked column.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnColumnClick(ColumnClickEventArgs e)
        {
            //
            // Check if another column clicked
            //
            if (e.Column != _sortColumnIndex)
            {
                _sortColumnIndex = e.Column;
                Sorting = SortOrder.Descending;
            }
            else
            {
                //
                // Change the SortOrder to the opposite
                //
                Sorting = Sorting == SortOrder.Ascending ? SortOrder.Descending : SortOrder.Ascending;
            }

            //
            // Sort the list
            //
            ListViewItemSorter = new ModuleSorter(e.Column, Sorting);
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Module/ModuleSorter.cs
================================================
ï»¿using System;
using System.Collections;
using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Module
{
    internal class ModuleSorter : IComparer
    {
        private readonly int _columnIndex;
        private readonly SortOrder _sortOrder;

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="columnIndex">The index of the column</param>
        /// <param name="sortOrder">The sort order (Ascending or Descending)</param>
        public ModuleSorter(int columnIndex, SortOrder sortOrder)
        {
            _columnIndex = columnIndex;
            _sortOrder = sortOrder;
        }

        /// <inheritdoc />
        /// <summary>
        /// Compares two module list items.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public int Compare(object x, object y)
        {
            //
            // Check if the object is a ListViewItem
            //
            if ((!(x is ListViewItem item1)) || (!(y is ListViewItem item2))) return 0;

            //
            // Check if the tag is a ProcesslistItem
            //
            if (!(item1.Tag is ModuleListItem p1) || !(item2.Tag is ModuleListItem p2)) return 0;

            var result = 0;

            //
            // Chose the sort by the column
            //
            switch (_columnIndex)
            {
                case 0:
                    result = string.Compare(p1.ModuleName, p2.ModuleName, StringComparison.OrdinalIgnoreCase);
                    break;

                case 1:
                    if (p1.ImageBase > p2.ImageBase)
                        result = 1;

                    if (p1.ImageBase < p2.ImageBase)
                        result = -1;
                    break;

                case 2:
                    if (p1.ImageSize > p2.ImageSize)
                        result = 1;

                    if (p1.ImageSize < p2.ImageSize)
                        result = -1;
                    break;

                case 3:
                    result = string.Compare(p1.ModulePath, p2.ModulePath, StringComparison.OrdinalIgnoreCase);
                    break;
            }

            //
            // Revert the sort if it's descending
            //
            if (_sortOrder == SortOrder.Descending)
            {
                result = -result;
            }

            return result;
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Process/ProcessListItem.cs
================================================
ï»¿using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Process
{
    internal class ProcessListItem
    {
        public string Id { get; }
        public string ProcessName { get; }

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="id">The id of the process</param>
        /// <param name="processName">The name of the process</param>
        public ProcessListItem(string id, string processName)
        {
            Id = id;
            ProcessName = processName;
        }

        /// <summary>
        /// Returns the list view item for the process list.
        /// </summary>
        /// <returns>ListViewItem</returns>
        public ListViewItem GetListViewItem()
        {
            var listViewItem = new ListViewItem(Id);
            listViewItem.SubItems.Add(ProcessName);
            listViewItem.Tag = this;

            return listViewItem;
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Process/ProcessListView.cs
================================================
ï»¿using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Process
{
    internal sealed class ProcessListView : ListView
    {
        private int _sortColumnIndex;

        /// <inheritdoc />
        /// <summary>
        /// Sets list view properties.
        /// </summary>
        public ProcessListView()
        {
            Columns.Add("Pid");
            Columns.Add("ProcessName");

            DoubleBuffered = true;
            Sorting = SortOrder.Ascending;
        }

        /// <summary>
        /// Loads the processes and adds them to the list.
        /// </summary>
        /// <returns>True if successful</returns>
        public void LoadProcesses()
        {
            //
            // Get the process list
            //
            var processlist = System.Diagnostics.Process.GetProcesses();

            //
            // Remove all previous processes
            //
            Items.Clear();

            //
            // Loop through all processes
            //
            foreach (var process in processlist)
            {
                //
                // Create a new ProcessListItem
                //
                var processListItem = new ProcessListItem(process.Id.ToString(), process.ProcessName);

                //
                // Add it to the ListView
                //
                Items.Add(processListItem.GetListViewItem());
            }

            //
            // Auto resize the columns
            //
            AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);

            //
            // Sort the list
            //
            ListViewItemSorter = new ProcessSorter(_sortColumnIndex, Sorting);
        }

        /// <inheritdoc />
        /// <summary>
        /// Sorts the list by the clicked column.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnColumnClick(ColumnClickEventArgs e)
        {
            //
            // Check if another column clicked
            //
            if (e.Column != _sortColumnIndex)
            {
                _sortColumnIndex = e.Column;
                Sorting = SortOrder.Ascending;
            }
            else
            {
                //
                // Change the SortOrder to the opposite
                //
                Sorting = Sorting == SortOrder.Ascending ? SortOrder.Descending : SortOrder.Ascending;
            }

            //
            // Sort the list
            //
            ListViewItemSorter = new ProcessSorter(e.Column, Sorting);
        }
    }
}


================================================
File: Nemesis.GUI/Forms/Utils/Process/ProcessSorter.cs
================================================
ï»¿using System;
using System.Collections;
using System.Windows.Forms;

namespace Nemesis.Forms.Utils.Process
{
    public class ProcessSorter : IComparer
    {
        private readonly int _columnIndex;
        private readonly SortOrder _sortOrder;

        /// <summary>
        /// Sets the specified data.
        /// </summary>
        /// <param name="columnIndex">The index of the column</param>
        /// <param name="sortOrder">The sort order (Ascending or Descending)</param>
        public ProcessSorter(int columnIndex, SortOrder sortOrder)
        {
            _columnIndex = columnIndex;
            _sortOrder = sortOrder;
        }

        /// <inheritdoc />
        /// <summary>
        /// Compares two process list items.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public int Compare(object x, object y)
        {
            //
            // Check if the object is a ListViewItem
            //
            if ((!(x is ListViewItem item1)) || (!(y is ListViewItem item2))) return 0;

            //
            // Check if the tag is a ProcesslistItem
            //
            if (!(item1.Tag is ProcessListItem p1) || !(item2.Tag is ProcessListItem p2)) return 0;

            var result = 0;

            //
            // Chose the sort by the column
            //
            switch (_columnIndex)
            {
                case 0:
                {
                    var pid1 = int.Parse(p1.Id);
                    var pid2 = int.Parse(p2.Id);

                    if (pid1 > pid2)
                        result = 1;

                    if (pid1 < pid2)
                        result = -1;
                    break;
                }

                case 1:
                    result = string.Compare(p1.ProcessName, p2.ProcessName, StringComparison.OrdinalIgnoreCase);
                    break;
            }

            //
            // Revert the sort if it's descending
            //
            if (_sortOrder == SortOrder.Descending)
            {
                result = -result;
            }

            return result;
        }
    }
}


================================================
File: Nemesis.GUI/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Resources;
using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Nemesis")]
[assembly: AssemblyDescription("A customizable process dumper library.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("not-matthias")]
[assembly: AssemblyProduct("Nemesis")]
[assembly: AssemblyCopyright("not-matthias")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7f14ab1f-b092-4bda-aa36-ce22f3db5acf")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: NeutralResourcesLanguage("en")]




================================================
File: Nemesis.GUI/Properties/Resources.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Nemesis.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Nemesis.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}



================================================
File: Nemesis.GUI/Properties/Resources.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
</root>


================================================
File: Nemesis.GUI/Properties/Settings.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Nemesis.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.9.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}



================================================
File: Nemesis.GUI/Properties/Settings.settings
================================================
ï»¿<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>



================================================
File: Nemesis.GUI/Properties/app.manifest
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>

<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app" />
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" />
      </requestedPrivileges>

      <applicationRequestMinimum>
        <defaultAssemblyRequest permissionSetReference="Custom" />
        <PermissionSet class="System.Security.PermissionSet" version="1" ID="Custom" SameSite="site"
                       Unrestricted="true" />
      </applicationRequestMinimum>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->
      <!-- Windows Vista -->
      <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->
      <!-- Windows 7 -->
      <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->
      <!-- Windows 8 -->
      <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->
      <!-- Windows 8.1 -->
      <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->
      <!-- Windows 10 -->
      <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->
    </application>
  </compatibility>
  <!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher
       DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need 
       to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should 
       also set the 'EnableWindowsFormsHighDpiAutoResizing' setting to 'true' in their app.config. -->
  <!--
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
    </windowsSettings>
  </application>
  -->
  <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
  <!--
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>
  -->
</assembly>


================================================
File: Nemesis.GUI/Utils/Config.cs
================================================
ï»¿using System.Configuration;

namespace Nemesis.Utils
{
    internal class Config
    {
        /// <summary>
        /// Sets the specified value in the config.
        /// </summary>
        /// <param name="key">The key of the value</param>
        /// <param name="value">The actual value</param>
        public static void SetValue(string key, string value)
        {
            //
            // Get the config file
            //
            var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
            var settings = configFile.AppSettings.Settings;

            //
            // Add the key/Change the value
            //
            if (settings[key] == null)
            {
                settings.Add(key, value);
            }
            else
            {
                settings[key].Value = value;
            }

            //
            // Save the configuration
            //
            configFile.Save(ConfigurationSaveMode.Modified);

            //
            // Refresh the section (will get retrieved from the disk next time)
            //
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);
        }

        /// <summary>
        /// Retrieves the specified value from the config.
        /// </summary>
        /// <param name="key">The key of the value</param>
        /// <returns>The value as a string</returns>
        public static string GetValue(string key) => ConfigurationManager.AppSettings[key];
    }
}


================================================
File: Nemesis.GUI/Utils/NemesisApi.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace Nemesis.Utils
{
    /// <summary>
    /// Contains the list of memory sources.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct MemorySource
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
        public IntPtr[] MemorySources;
    }

    /// <summary>
    /// Contains data about a driver.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct Driver
    {
        public long ImageBase;
        public int ImageSize;
        public ushort OffsetToFileName;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string FullPathName;
    }

    /// <summary>
    /// Contains data about a process.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct Process
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string ImageName;

        public int UniqueProcessId;
        public int NumberOfThreads;
        public int BasePriority;
        public int HandleCount;
        public int SessionId;
        public int PeakVirtualSize;
        public int VirtualSize;
        public int PeakWorkingSetSize;
        public int WorkingSetSize;
        public int QuotaPagedPoolUsage;
        public int QuotaNonPagedPoolUsage;
        public int PageFileUsage;
        public int PeakPageFileUsage;
        public int PrivatePageCount;
    }

    /// <summary>
    /// Contains data about a module of a process.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Module
    {
        public long ImageBase;
        public long ImageSize;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
        public string ModuleName;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
        public string ModulePath;

    }

    /// <summary>
    /// Contains data about a memory region.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public struct Memory
    {
        public ulong BaseAddress;
        public ulong RegionSize;
        public int State;
        public int Type;
    }

    internal class NemesisImports
    {
        [DllImport("Nemesis.dll")]
        protected static extern bool DumpProcessExport([In] int processId, [In] string fileName);

        [DllImport("Nemesis.dll")]
        protected static extern bool DumpModuleExport([In] int processId, [In] IntPtr baseAddress, [In] string fileName);

        [DllImport("Nemesis.dll")]
        protected static extern bool DumpMemoryExport([In] int processId, [In] IntPtr startAddress, [In] uint size, [In] string fileName);

        [DllImport("Nemesis.dll")]
        protected static extern bool DumpDriverExport([In] IntPtr baseAddress, [In] string fileName);


        [DllImport("Nemesis.dll")]
        protected static extern void GetMemorySourcesExport([In] [Out] ref MemorySource structure);


        [DllImport("Nemesis.dll")]
        protected static extern bool GetDriverListElementExport([In] uint index, [In] [Out] ref Driver structure);

        [DllImport("Nemesis.dll")]
        protected static extern bool GetProcessListElementExport([In] uint index, [In] [Out] ref Process structure);

        [DllImport("Nemesis.dll")]
        protected static extern bool GetModuleListElementExport([In] uint index, [In] int processId, [In] [Out] ref Module structure);

        [DllImport("Nemesis.dll")]
        protected static extern bool GetManualModuleListElementExport([In] uint index, [In] int processId, [In] [Out] ref Module structure);

        [DllImport("Nemesis.dll")]
        protected static extern bool GetMemoryListElementExport([In] uint index, [In] int processId, [In] [Out] ref Memory structure);


        [DllImport("Nemesis.dll")]
        protected static extern bool SaveDriverInformationExport([In] string fileName);


        [DllImport("Nemesis.dll")]
        protected static extern bool SetConfigValueExport([In] string key, [In] string value);

        [DllImport("Nemesis.dll")]
        protected static extern string GetConfigValueExport([In] string key);
    }

    internal class NemesisApi : NemesisImports
    {
        /// <summary>
        /// Dumps and saves the specified process.
        /// </summary>
        /// <param name="processId">The id of the process</param>
        /// <param name="fileName">The dump location</param>
        /// <returns>True if successful</returns>
        public static bool DumpProcess(int processId, string fileName)
        {
            return DumpProcessExport(processId, fileName);
        }

        /// <summary>
        /// Dumps and saves the specified module.
        /// </summary>
        /// <param name="processId">The id of the process in which the module is</param>
        /// <param name="baseAddress">The base address of the module</param>
        /// <param name="fileName">The dump location</param>
        /// <returns>True if successful</returns>
        public static bool DumpModule(int processId, IntPtr baseAddress, string fileName)
        {
            return DumpModuleExport(processId, baseAddress, fileName);
        }

        /// <summary>
        /// Dumps and saves the specified memory.
        /// </summary>
        /// <param name="processId">The id of the process in which the memory is</param>
        /// <param name="startAddress">The starting address of the memory region</param>
        /// <param name="size">The size of the memory region</param>
        /// <param name="fileName">The dump location</param>
        /// <returns>True if successful</returns>
        public static bool DumpMemory(int processId, IntPtr startAddress, uint size, string fileName)
        {
            return DumpMemoryExport(processId, startAddress, size, fileName);
        }

        /// <summary>
        /// Dumps and saves the specified driver.
        /// </summary>
        /// <param name="baseAddress">The base address of the driver</param>
        /// <param name="fileName">The dump location</param>
        /// <returns></returns>
        public static bool DumpDriver(IntPtr baseAddress, string fileName)
        {
            return DumpDriverExport(baseAddress, fileName);
        }

        /// <summary>
        /// Returns the available memory sources.
        /// </summary>
        /// <returns>List of memory source names</returns>
        public static List<string> GetMemorySources()
        {
            //
            // Create a new struct
            //
            var structure = new MemorySource();

            //
            // Get the memory sources
            //
            GetMemorySourcesExport(ref structure);

            //
            // Convert the pointers to strings and return the list
            //
            return (from pointer in structure.MemorySources
                where pointer != IntPtr.Zero
                select Marshal.PtrToStringAnsi(pointer)?.Split('|')[0]).ToList();
        }

        /// <summary>
        /// Returns the list of drivers.
        /// </summary>
        /// <returns>List of driver objects</returns>
        public static List<Driver> GetDriverList()
        {
            var list = new List<Driver>();

            //
            // Get the memory sources
            //
            for (uint index = 0; index < 512; index++)
            {
                //
                // Create the driver object
                //
                var structure = new Driver();

                //
                // Get the driver at the specified index
                //
                if (!GetDriverListElementExport(index, ref structure))
                {
                    break;
                }

                //
                // Add the item to the list
                //
                list.Add(structure);
            }

            //
            // Return the list
            //
            return list;
        }

        /// <summary>
        /// Returns the list of processes.
        /// </summary>
        /// <returns>List of process objects</returns>
        public static List<Process> GetProcessList()
        {
            var list = new List<Process>();

            //
            // Get the memory sources
            //
            for (uint index = 0; index < 512; index++)
            {
                //
                // Create the driver object
                //
                var structure = new Process();

                //
                // Get the driver at the specified index
                //
                if (!GetProcessListElementExport(index, ref structure))
                {
                    break;
                }

                //
                // Add the item to the list
                //
                list.Add(structure);
            }

            //
            // Return the list
            //
            return list;
        }

        /// <summary>
        /// Returns the list of modules of a process.
        /// </summary>
        /// <param name="processId">The id of the process</param>
        /// <returns>List of module objects</returns>
        public static List<Module> GetModuleList(int processId)
        {
            var list = new List<Module>();

            //
            // Get the memory sources
            //
            for (uint index = 0; index < 256; index++)
            {
                //
                // Create the driver object
                //
                var structure = new Module();

                //
                // Get the driver at the specified index
                //
                if (!GetModuleListElementExport(index, processId, ref structure))
                {
                    break;
                }

                //
                // Add the item to the list
                //
                list.Add(structure);
            }

            //
            // Return the list
            //
            return list;
        }

        /// <summary>
        /// Returns the list of modules of a process.
        /// </summary>
        /// <param name="processId">The id of the process</param>
        /// <returns>List of module objects</returns>
        public static List<Module> GetManualModuleList(int processId)
        {
            var list = new List<Module>();

            //
            // Get the memory sources
            //
            for (uint index = 0; index < 256; index++)
            {
                //
                // Create the driver object
                //
                var structure = new Module();

                //
                // Get the driver at the specified index
                //
                if (!GetManualModuleListElementExport(index, processId, ref structure))
                {
                    break;
                }

                //
                // Add the item to the list
                //
                list.Add(structure);
            }

            //
            // Return the list
            //
            return list;
        }

        /// <summary>
        /// Returns the list of memory regions of a process.
        /// </summary>
        /// <param name="processId">The id of the process</param>
        /// <returns>List of memory objects</returns>
        public static List<Memory> GetMemoryList(int processId)
        {
            var list = new List<Memory>();

            //
            // Get the memory sources
            //
            for (uint index = 0; index < 256; index++)
            {
                //
                // Create the driver object
                //
                var structure = new Memory();

                //
                // Get the driver at the specified index
                //
                if (!GetMemoryListElementExport(index, processId, ref structure))
                {
                    break;
                }

                //
                // Add the item to the list
                //
                list.Add(structure);
            }

            //
            // Return the list
            //
            return list;
        }

        /// <summary>
        /// Saves the information about the loaded drivers.
        /// </summary>
        /// <param name="fileName">The file name of the list</param>
        /// <returns>True if successful</returns>
        public static bool SaveDriverInformation(string fileName)
        {
            return SaveDriverInformationExport(fileName);
        }

        /// <summary>
        /// Sets the key and value in the config.
        /// </summary>
        /// <param name="key">The specified key</param>
        /// <param name="value">The specified value for the key</param>
        /// <returns>True if successful</returns>
        public static bool SetConfigValue<T>(string key, T value)
        {
            return SetConfigValueExport(key, value.ToString());
        }

        /// <summary>
        /// Gets the value of the key from the config.
        /// </summary>
        /// <param name="key">The key of the value</param>
        /// <returns>The value</returns>
        public static T GetConfigValue<T>(string key)
        {
            if (string.IsNullOrEmpty(key)) return default;

            try
            {
                return (T) Convert.ChangeType(GetConfigValueExport(key), typeof(T));
            }
            catch (Exception)
            {
                // TODO: Print error message
            }

            return default;
        }
    }
}


================================================
File: Nemesis.GUI/Utils/StyleExtension.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using MetroFramework;
using MetroFramework.Components;
using MetroFramework.Forms;

namespace Nemesis.Utils
{
    public static class StyleExtension
    {
        private static readonly List<MetroStyleManager> StyleManagers = new List<MetroStyleManager>();

        private static MetroColorStyle _colorStyle = GetMetroColorStyle(Config.GetValue("style"));
        private static MetroThemeStyle _themeStyle = GetMetroThemeStyle(Config.GetValue("theme"));

        /// <summary>
        /// Creates a new MetroStyleManager and sets the styles.
        /// </summary>
        /// <param name="container">The component container</param>
        /// <param name="ownerForm">The metro form</param>
        public static void SetStyle(this IContainer container, MetroForm ownerForm)
        {
            if (container == null)
            {
                container = new Container();
            }

            //
            // Create new MetroStyleManager and add it to the list
            //
            StyleManagers.Add(new MetroStyleManager(container) {Owner = ownerForm});

            //
            // Update the styles
            //
            UpdateStyles();
        }

        /// <summary>
        /// Sets a new color style.
        /// </summary>
        /// <param name="colorStyle">The new color style</param>
        public static void SetColorStyle(MetroColorStyle colorStyle)
        {
            _colorStyle = colorStyle;

            UpdateStyles();
        }

        /// <summary>
        /// Sets a new theme style.
        /// </summary>
        /// <param name="themeStyle">The new theme style</param>
        public static void SetThemeStyle(MetroThemeStyle themeStyle)
        {
            _themeStyle = themeStyle;

            UpdateStyles();
        }

        /// <summary>
        /// Updates the style and theme of all forms.
        /// </summary>
        public static void UpdateStyles()
        {
            foreach (var styleManager in StyleManagers)
            {
                var metroForm = (MetroForm) styleManager.Owner;
                metroForm.Theme = _themeStyle;
                metroForm.Style = _colorStyle;

                styleManager.Theme = _themeStyle;
                styleManager.Style = _colorStyle;
            }
        }

        /// <summary>
        /// Returns the metro theme enum value for the specified name.
        /// </summary>
        /// <param name="name">The name of the enum value</param>
        /// <returns>Specified enum value or MetroThemeStyle.Default</returns>
        public static MetroThemeStyle GetMetroThemeStyle(string name)
        {
            try
            {
                Enum.TryParse(name, out MetroThemeStyle color);

                return color;
            }
            catch (ArgumentException)
            {
                return MetroThemeStyle.Default;
            }
        }

        /// <summary>
        /// Returns the metro color enum value for the specified name.
        /// </summary>
        /// <param name="name">The name of the enum value</param>
        /// <returns>Specified enum value or MetroColorStyle.Default</returns>
        public static MetroColorStyle GetMetroColorStyle(string name)
        {
            try
            {
                Enum.TryParse(name, out MetroColorStyle color);

                return color;
            }
            catch (ArgumentException)
            {
                return MetroColorStyle.Default;
            }
        }
    }
}


================================================
File: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug
assignees: not-matthias

---

**Describe the bug**

**Steps to reproduce the behavior**

**Expected behavior**

**Screenshots**

**Windows Version**

**Additional context**



================================================
File: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: enhancement
assignees: not-matthias

---

**Is your feature request related to a problem? Please describe.**

**Describe the solution you'd like.**

**Describe alternatives you've considered.**

**Additional context**



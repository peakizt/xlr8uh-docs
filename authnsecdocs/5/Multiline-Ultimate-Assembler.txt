Directory structure:
‚îî‚îÄ‚îÄ m417z-multiline-ultimate-assembler/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ LICENSE
    ‚îú‚îÄ‚îÄ MUltimate Assembler.sln
    ‚îú‚îÄ‚îÄ MUltimate Assembler.vcxproj
    ‚îú‚îÄ‚îÄ MUltimate Assembler.vcxproj.filters
    ‚îú‚îÄ‚îÄ assembler_dlg.c
    ‚îú‚îÄ‚îÄ assembler_dlg.h
    ‚îú‚îÄ‚îÄ assembler_dlg_tabs.c
    ‚îú‚îÄ‚îÄ assembler_dlg_tabs.h
    ‚îú‚îÄ‚îÄ functions.c
    ‚îú‚îÄ‚îÄ functions.h
    ‚îú‚îÄ‚îÄ main_common.c
    ‚îú‚îÄ‚îÄ main_common.h
    ‚îú‚îÄ‚îÄ main_odbg_v1.c
    ‚îú‚îÄ‚îÄ main_odbg_v2.c
    ‚îú‚îÄ‚îÄ main_x64dbg.c
    ‚îú‚îÄ‚îÄ options_def.h
    ‚îú‚îÄ‚îÄ options_dlg.c
    ‚îú‚îÄ‚îÄ options_dlg.h
    ‚îú‚îÄ‚îÄ plugin.h
    ‚îú‚îÄ‚îÄ plugin_immdbg.h
    ‚îú‚îÄ‚îÄ plugin_odbg_v1.c
    ‚îú‚îÄ‚îÄ plugin_odbg_v1.h
    ‚îú‚îÄ‚îÄ plugin_odbg_v2.c
    ‚îú‚îÄ‚îÄ plugin_odbg_v2.h
    ‚îú‚îÄ‚îÄ plugin_ollydbg.h
    ‚îú‚îÄ‚îÄ plugin_ollydbg2.h
    ‚îú‚îÄ‚îÄ plugin_x64dbg.c
    ‚îú‚îÄ‚îÄ plugin_x64dbg.h
    ‚îú‚îÄ‚îÄ pointer_redirection.c
    ‚îú‚îÄ‚îÄ pointer_redirection.h
    ‚îú‚îÄ‚îÄ raedit.h
    ‚îú‚îÄ‚îÄ read_asm.c
    ‚îú‚îÄ‚îÄ read_asm.h
    ‚îú‚îÄ‚îÄ resource.h
    ‚îú‚îÄ‚îÄ rsrc.rc
    ‚îú‚îÄ‚îÄ stdafx.c
    ‚îú‚îÄ‚îÄ stdafx.h
    ‚îú‚îÄ‚îÄ tabctrl_ex.c
    ‚îú‚îÄ‚îÄ tabctrl_ex.h
    ‚îú‚îÄ‚îÄ write_asm.c
    ‚îú‚îÄ‚îÄ write_asm.h
    ‚îú‚îÄ‚îÄ minicrt/
    ‚îú‚îÄ‚îÄ ollydbglib/
    ‚îú‚îÄ‚îÄ raeditlib/
    ‚îÇ   ‚îú‚îÄ‚îÄ RAEdit.Rc
    ‚îÇ   ‚îî‚îÄ‚îÄ Res/
    ‚îÇ       ‚îú‚îÄ‚îÄ Bookmark.bmp
    ‚îÇ       ‚îú‚îÄ‚îÄ Button.bmp
    ‚îÇ       ‚îú‚îÄ‚îÄ Collapse.bmp
    ‚îÇ       ‚îú‚îÄ‚îÄ Expand.bmp
    ‚îÇ       ‚îú‚îÄ‚îÄ Linenumber.bmp
    ‚îÇ       ‚îú‚îÄ‚îÄ Lock.bmp
    ‚îÇ       ‚îú‚îÄ‚îÄ RAEditRes.rc
    ‚îÇ       ‚îú‚îÄ‚îÄ Select.cur
    ‚îÇ       ‚îî‚îÄ‚îÄ SplitH.cur
    ‚îú‚îÄ‚îÄ rsrc_files/
    ‚îî‚îÄ‚îÄ x64dbg_pluginsdk/
        ‚îú‚îÄ‚îÄ _dbgfunctions.h
        ‚îú‚îÄ‚îÄ _plugin_types.h
        ‚îú‚îÄ‚îÄ _plugins.h
        ‚îú‚îÄ‚îÄ _scriptapi.h
        ‚îú‚îÄ‚îÄ _scriptapi_argument.h
        ‚îú‚îÄ‚îÄ _scriptapi_assembler.h
        ‚îú‚îÄ‚îÄ _scriptapi_bookmark.h
        ‚îú‚îÄ‚îÄ _scriptapi_comment.h
        ‚îú‚îÄ‚îÄ _scriptapi_debug.h
        ‚îú‚îÄ‚îÄ _scriptapi_flag.h
        ‚îú‚îÄ‚îÄ _scriptapi_function.h
        ‚îú‚îÄ‚îÄ _scriptapi_gui.h
        ‚îú‚îÄ‚îÄ _scriptapi_label.h
        ‚îú‚îÄ‚îÄ _scriptapi_memory.h
        ‚îú‚îÄ‚îÄ _scriptapi_misc.h
        ‚îú‚îÄ‚îÄ _scriptapi_module.h
        ‚îú‚îÄ‚îÄ _scriptapi_pattern.h
        ‚îú‚îÄ‚îÄ _scriptapi_register.h
        ‚îú‚îÄ‚îÄ _scriptapi_stack.h
        ‚îú‚îÄ‚îÄ _scriptapi_symbol.h
        ‚îú‚îÄ‚îÄ bridgegraph.h
        ‚îú‚îÄ‚îÄ bridgelist.h
        ‚îú‚îÄ‚îÄ bridgemain.h
        ‚îú‚îÄ‚îÄ DeviceNameResolver/
        ‚îÇ   ‚îî‚îÄ‚îÄ DeviceNameResolver.h
        ‚îú‚îÄ‚îÄ TitanEngine/
        ‚îÇ   ‚îî‚îÄ‚îÄ TitanEngine.h
        ‚îú‚îÄ‚îÄ XEDParse/
        ‚îÇ   ‚îî‚îÄ‚îÄ XEDParse.h
        ‚îú‚îÄ‚îÄ capstone/
        ‚îÇ   ‚îú‚îÄ‚îÄ arm.h
        ‚îÇ   ‚îú‚îÄ‚îÄ arm64.h
        ‚îÇ   ‚îú‚îÄ‚îÄ capstone.h
        ‚îÇ   ‚îú‚îÄ‚îÄ m68k.h
        ‚îÇ   ‚îú‚îÄ‚îÄ mips.h
        ‚îÇ   ‚îú‚îÄ‚îÄ platform.h
        ‚îÇ   ‚îú‚îÄ‚îÄ ppc.h
        ‚îÇ   ‚îú‚îÄ‚îÄ sparc.h
        ‚îÇ   ‚îú‚îÄ‚îÄ systemz.h
        ‚îÇ   ‚îú‚îÄ‚îÄ x86.h
        ‚îÇ   ‚îî‚îÄ‚îÄ xcore.h
        ‚îú‚îÄ‚îÄ dbghelp/
        ‚îÇ   ‚îî‚îÄ‚îÄ dbghelp.h
        ‚îú‚îÄ‚îÄ jansson/
        ‚îÇ   ‚îú‚îÄ‚îÄ jansson.h
        ‚îÇ   ‚îú‚îÄ‚îÄ jansson_config.h
        ‚îÇ   ‚îî‚îÄ‚îÄ jansson_x64dbg.h
        ‚îú‚îÄ‚îÄ lz4/
        ‚îÇ   ‚îú‚îÄ‚îÄ lz4.h
        ‚îÇ   ‚îú‚îÄ‚îÄ lz4file.h
        ‚îÇ   ‚îî‚îÄ‚îÄ lz4hc.h
        ‚îî‚îÄ‚îÄ yara/
            ‚îú‚îÄ‚îÄ yara.h
            ‚îî‚îÄ‚îÄ yara/
                ‚îú‚îÄ‚îÄ ahocorasick.h
                ‚îú‚îÄ‚îÄ arena.h
                ‚îú‚îÄ‚îÄ atoms.h
                ‚îú‚îÄ‚îÄ compiler.h
                ‚îú‚îÄ‚îÄ elf.h
                ‚îú‚îÄ‚îÄ error.h
                ‚îú‚îÄ‚îÄ exec.h
                ‚îú‚îÄ‚îÄ exefiles.h
                ‚îú‚îÄ‚îÄ filemap.h
                ‚îú‚îÄ‚îÄ globals.h
                ‚îú‚îÄ‚îÄ hash.h
                ‚îú‚îÄ‚îÄ hex_lexer.h
                ‚îú‚îÄ‚îÄ integers.h
                ‚îú‚îÄ‚îÄ lexer.h
                ‚îú‚îÄ‚îÄ libyara.h
                ‚îú‚îÄ‚îÄ limits.h
                ‚îú‚îÄ‚îÄ mem.h
                ‚îú‚îÄ‚îÄ modules.h
                ‚îú‚îÄ‚îÄ object.h
                ‚îú‚îÄ‚îÄ parser.h
                ‚îú‚îÄ‚îÄ pe.h
                ‚îú‚îÄ‚îÄ proc.h
                ‚îú‚îÄ‚îÄ re.h
                ‚îú‚îÄ‚îÄ re_lexer.h
                ‚îú‚îÄ‚îÄ rules.h
                ‚îú‚îÄ‚îÄ scan.h
                ‚îú‚îÄ‚îÄ sizedstr.h
                ‚îú‚îÄ‚îÄ stream.h
                ‚îú‚îÄ‚îÄ strutils.h
                ‚îú‚îÄ‚îÄ threading.h
                ‚îú‚îÄ‚îÄ types.h
                ‚îî‚îÄ‚îÄ utils.h

================================================
File: README.md
================================================
# Multiline Ultimate Assembler

Multiline Ultimate Assembler is a multiline (and ultimate) assembler (and
disassembler) plugin for [x64dbg](https://x64dbg.com/) and
[OllyDbg](http://www.ollydbg.de/). It's a perfect tool for modifying and
extending a compiled executable functionality, writing code caves, etc.

[üè† Homepage](https://ramensoftware.com/multimate-assembler)

![Screenshot](screenshot.png)



================================================
File: LICENSE
================================================
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    Multiline Ultimate Assembler
    Copyright (C) 2022  Ramen Software

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    Multiline Ultimate Assembler  Copyright (C) 2022  Ramen Software
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.



================================================
File: MUltimate Assembler.sln
================================================
√Ø¬ª¬ø
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35527.113
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MUltimate Assembler", "MUltimate Assembler.vcxproj", "{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug_x64dbg|Win32 = Debug_x64dbg|Win32
		Debug_x64dbg|x64 = Debug_x64dbg|x64
		Release_immdbg|Win32 = Release_immdbg|Win32
		Release_immdbg|x64 = Release_immdbg|x64
		Release_odbg_v2|Win32 = Release_odbg_v2|Win32
		Release_odbg_v2|x64 = Release_odbg_v2|x64
		Release_odbg|Win32 = Release_odbg|Win32
		Release_odbg|x64 = Release_odbg|x64
		Release_x64dbg|Win32 = Release_x64dbg|Win32
		Release_x64dbg|x64 = Release_x64dbg|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Debug_x64dbg|Win32.ActiveCfg = Debug_x64dbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Debug_x64dbg|Win32.Build.0 = Debug_x64dbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Debug_x64dbg|x64.ActiveCfg = Debug_x64dbg|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Debug_x64dbg|x64.Build.0 = Debug_x64dbg|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_immdbg|Win32.ActiveCfg = Release_immdbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_immdbg|Win32.Build.0 = Release_immdbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_immdbg|x64.ActiveCfg = Release_immdbg|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_immdbg|x64.Build.0 = Release_immdbg|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg_v2|Win32.ActiveCfg = Release_odbg_v2|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg_v2|Win32.Build.0 = Release_odbg_v2|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg_v2|x64.ActiveCfg = Release_odbg_v2|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg_v2|x64.Build.0 = Release_odbg_v2|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg|Win32.ActiveCfg = Release_odbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg|Win32.Build.0 = Release_odbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg|x64.ActiveCfg = Release_odbg|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_odbg|x64.Build.0 = Release_odbg|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_x64dbg|Win32.ActiveCfg = Release_x64dbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_x64dbg|Win32.Build.0 = Release_x64dbg|Win32
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_x64dbg|x64.ActiveCfg = Release_x64dbg|x64
		{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}.Release_x64dbg|x64.Build.0 = Release_x64dbg|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal



================================================
File: MUltimate Assembler.vcxproj
================================================
√Ø¬ª¬ø<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_x64dbg|Win32">
      <Configuration>Debug_x64dbg</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug_x64dbg|x64">
      <Configuration>Debug_x64dbg</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_odbg|x64">
      <Configuration>Release_odbg</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_immdbg|Win32">
      <Configuration>Release_immdbg</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_immdbg|x64">
      <Configuration>Release_immdbg</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_odbg_v2|Win32">
      <Configuration>Release_odbg_v2</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_odbg|Win32">
      <Configuration>Release_odbg</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_odbg_v2|x64">
      <Configuration>Release_odbg_v2</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_x64dbg|Win32">
      <Configuration>Release_x64dbg</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_x64dbg|x64">
      <Configuration>Release_x64dbg</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1356A7DE-2F61-48DB-91CE-7C27DBC3D9A9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>MUltimateAssembler</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <OutDir>$(SolutionDir)Debug\</OutDir>
    <IntDir>Debug\$(Configuration)\</IntDir>
    <TargetExt>.dp32</TargetExt>
    <TargetName>multiasm_x64dbg_debug</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <IntDir>$(SolutionDir)Debug\</IntDir>
    <OutDir>$(SolutionDir)Debug\</OutDir>
    <TargetExt>.dp64</TargetExt>
    <TargetName>multiasm_x64dbg_debug</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_odbg</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_odbg</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_x64dbg</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\</IntDir>
    <TargetExt>.dp32</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'">
    <TargetExt>.dp64</TargetExt>
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_x64dbg</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_odbg2</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_odbg2</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_immdbg</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
    <TargetName>multiasm_immdbg</TargetName>
    <OutDir>$(SolutionDir)Release\</OutDir>
    <IntDir>Release\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_X64DBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;minicrt\minicrt.lib;raeditlib\masm32.lib;raeditlib\raedit.lib;x64dbg_pluginsdk\x32dbg.lib;x64dbg_pluginsdk\x32bridge.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_ODBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_X64DBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;raeditlib\RAEditC64.lib;minicrt\minicrt64.lib;x64dbg_pluginsdk\x64dbg.lib;x64dbg_pluginsdk\x64bridge.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.02</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_ODBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_ODBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;minicrt\minicrt.lib;raeditlib\masm32.lib;raeditlib\raedit.lib;ollydbglib\ollydbg.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_ODBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_ODBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;raeditlib\RAEditC64.lib;minicrt\minicrt64.lib;ollydbglib\ollydbg.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.02</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_ODBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_X64DBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;minicrt\minicrt.lib;raeditlib\masm32.lib;raeditlib\raedit.lib;x64dbg_pluginsdk\x32dbg.lib;x64dbg_pluginsdk\x32bridge.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_X64DBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_X64DBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;raeditlib\RAEditC64.lib;minicrt\minicrt64.lib;x64dbg_pluginsdk\x64dbg.lib;x64dbg_pluginsdk\x64bridge.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.02</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_X64DBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_ODBG2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;minicrt\minicrt.lib;raeditlib\masm32.lib;raeditlib\raedit.lib;ollydbglib\ollydbg2.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_ODBG2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_ODBG2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;raeditlib\RAEditC64.lib;minicrt\minicrt64.lib;ollydbglib\ollydbg2.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.02</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_ODBG2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_IMMDBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;minicrt\minicrt.lib;raeditlib\masm32.lib;raeditlib\raedit.lib;ollydbglib\immdbg.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_IMMDBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MULTIMATEASSEMBLER_EXPORTS;TARGET_IMMDBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalOptions>/J /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>comctl32.lib;shlwapi.lib;raeditlib\RAEditC64.lib;minicrt\minicrt64.lib;ollydbglib\immdbg.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <MinimumRequiredVersion>5.02</MinimumRequiredVersion>
      <GenerateMapFile>true</GenerateMapFile>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>TARGET_IMMDBG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="assembler_dlg.c" />
    <ClCompile Include="assembler_dlg_tabs.c" />
    <ClCompile Include="functions.c" />
    <ClCompile Include="main_common.c" />
    <ClCompile Include="main_odbg_v1.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="main_odbg_v2.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Rel_odbg_v1|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Rel_odbg_v1|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="main_x64dbg.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="options_dlg.c" />
    <ClCompile Include="plugin_odbg_v1.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="plugin_odbg_v2.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="plugin_x64dbg.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="pointer_redirection.c" />
    <ClCompile Include="read_asm.c" />
    <ClCompile Include="stdafx.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_x64dbg|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_odbg_v2|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_immdbg|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_x64dbg|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_odbg|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_odbg|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="tabctrl_ex.c" />
    <ClCompile Include="write_asm.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="assembler_dlg.h" />
    <ClInclude Include="assembler_dlg_tabs.h" />
    <ClInclude Include="functions.h" />
    <ClInclude Include="main_common.h" />
    <ClInclude Include="options_def.h" />
    <ClInclude Include="options_dlg.h" />
    <ClInclude Include="plugin.h" />
    <ClInclude Include="plugin_immdbg.h" />
    <ClInclude Include="plugin_ollydbg.h" />
    <ClInclude Include="plugin_ollydbg2.h" />
    <ClInclude Include="plugin_odbg_v1.h" />
    <ClInclude Include="plugin_odbg_v2.h" />
    <ClInclude Include="plugin_x64dbg.h" />
    <ClInclude Include="pointer_redirection.h" />
    <ClInclude Include="raedit.h" />
    <ClInclude Include="read_asm.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="tabctrl_ex.h" />
    <ClInclude Include="write_asm.h" />
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\basic_types.h" />
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\BeaEngine.h" />
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\export.h" />
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\macros.h" />
    <ClInclude Include="x64dbg_pluginsdk\bridgemain.h" />
    <ClInclude Include="x64dbg_pluginsdk\dbghelp\dbghelp.h" />
    <ClInclude Include="x64dbg_pluginsdk\DeviceNameResolver\DeviceNameResolver.h" />
    <ClInclude Include="x64dbg_pluginsdk\jansson\jansson.h" />
    <ClInclude Include="x64dbg_pluginsdk\jansson\jansson_config.h" />
    <ClInclude Include="x64dbg_pluginsdk\lz4\lz4.h" />
    <ClInclude Include="x64dbg_pluginsdk\lz4\lz4file.h" />
    <ClInclude Include="x64dbg_pluginsdk\lz4\lz4hc.h" />
    <ClInclude Include="x64dbg_pluginsdk\TitanEngine\TitanEngine.h" />
    <ClInclude Include="x64dbg_pluginsdk\XEDParse\XEDParse.h" />
    <ClInclude Include="x64dbg_pluginsdk\_dbgfunctions.h" />
    <ClInclude Include="x64dbg_pluginsdk\_plugins.h" />
    <ClInclude Include="x64dbg_pluginsdk\_plugin_types.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="raeditlib\RAEdit.Rc" />
    <ResourceCompile Include="rsrc.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="raeditlib\Res\Bookmark.bmp" />
    <None Include="raeditlib\Res\Button.bmp" />
    <None Include="raeditlib\Res\Collapse.bmp" />
    <None Include="raeditlib\Res\Expand.bmp" />
    <None Include="raeditlib\Res\Linenumber.bmp" />
    <None Include="raeditlib\Res\Lock.bmp" />
    <None Include="raeditlib\Res\Select.cur" />
    <None Include="raeditlib\Res\SplitH.cur" />
    <None Include="rsrc_files\icon.ico" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="rsrc_files\icon_x64dbg.png" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: MUltimate Assembler.vcxproj.filters
================================================
√Ø¬ª¬ø<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="assembler_dlg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="assembler_dlg_tabs.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="options_dlg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="read_asm.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="write_asm.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="tabctrl_ex.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pointer_redirection.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="functions.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="plugin_odbg_v1.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="plugin_odbg_v2.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main_odbg_v1.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main_odbg_v2.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main_common.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main_x64dbg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="plugin_x64dbg.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="assembler_dlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="assembler_dlg_tabs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="options_def.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="options_dlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="raedit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="read_asm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="write_asm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tabctrl_ex.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugin_immdbg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugin_ollydbg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pointer_redirection.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="functions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugin_odbg_v1.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugin_odbg_v2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugin_ollydbg2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="main_common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\basic_types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\BeaEngine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\export.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\BeaEngine\macros.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\bridgemain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\dbghelp\dbghelp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\DeviceNameResolver\DeviceNameResolver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\jansson\jansson.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\jansson\jansson_config.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\lz4\lz4.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\lz4\lz4file.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\lz4\lz4hc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\TitanEngine\TitanEngine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\XEDParse\XEDParse.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\_dbgfunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\_plugins.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64dbg_pluginsdk\_plugin_types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="plugin_x64dbg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="rsrc.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
    <ResourceCompile Include="raeditlib\RAEdit.Rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="rsrc_files\icon.ico">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\Button.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\Bookmark.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\Linenumber.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\Expand.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\Collapse.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\Lock.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\SplitH.cur">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="raeditlib\Res\Select.cur">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Image Include="rsrc_files\icon_x64dbg.png">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>


================================================
File: assembler_dlg.c
================================================
#include "stdafx.h"
#include "assembler_dlg.h"

extern HINSTANCE hDllInst;
extern OPTIONS options;

static HACCEL hAccelerators;
static HWND hAsmDlg;
static ASM_DIALOG_PARAM AsmDlgParam;

TCHAR *AssemblerInit()
{
	hAccelerators = LoadAccelerators(hDllInst, MAKEINTRESOURCE(IDR_MAINACCELERATOR));
	return NULL;
}

void AssemblerExit()
{
}

BOOL AssemblerPreTranslateMessage(LPMSG lpMsg)
{
	if(hAsmDlg)
	{
		HWND hWnd = hAsmDlg;
		HWND hFindReplaceWnd = AsmDlgParam.hFindReplaceWnd;

		if(hFindReplaceWnd && IsDialogMessage(hFindReplaceWnd, lpMsg))
			return TRUE;

		if(GetActiveWindow() == hWnd)
		{
			if(hAccelerators && TranslateAccelerator(hWnd, hAccelerators, lpMsg))
				return TRUE;
		}

		if(IsDialogMessage(hWnd, lpMsg))
			return TRUE;
	}

	return FALSE;
}

void AssemblerShowDlg()
{
	if(!hAsmDlg)
	{
		hAsmDlg = CreateAsmDlg();
		if(!hAsmDlg)
			MessageBox(hwollymain, _T("Couldn't create dialog"), _T("Multiline Ultimate Assembler error"), MB_ICONHAND);
	}
	else
	{
		HWND hWnd = hAsmDlg;

		if(IsWindowEnabled(hWnd))
		{
			if(IsIconic(hWnd))
				ShowWindow(hWnd, SW_RESTORE);

			SetFocus(hWnd);
		}
		else
		{
			HWND hPopupWnd = GetWindow(hWnd, GW_ENABLEDPOPUP);
			if(hPopupWnd)
				SetFocus(hPopupWnd);
		}
	}
}

void AssemblerCloseDlg()
{
	if(hAsmDlg)
		CloseAsmDlg(hAsmDlg);
}

void AssemblerLoadCode(DWORD_PTR dwAddress, DWORD_PTR dwSize)
{
	AssemblerShowDlg();

	if(hAsmDlg)
		SendMessage(hAsmDlg, UWM_LOADCODE, dwAddress, dwSize);
}

void AssemblerOptionsChanged()
{
	if(hAsmDlg)
		SendMessage(hAsmDlg, UWM_OPTIONSCHANGED, 0, 0);
}

static HWND CreateAsmDlg()
{
	HWND hWnd = CreateDialogParam(hDllInst, MAKEINTRESOURCE(IDD_MAIN), hwollymain,
		(DLGPROC)DlgAsmProc, (LPARAM)&AsmDlgParam);
	if(!hWnd)
		return NULL;

	ShowWindow(hWnd, SW_SHOWNORMAL);
	return hWnd;
}

static void CloseAsmDlg(HWND hWnd)
{
	SendMessage(hWnd, WM_CLOSE, 0, 0);
}

static LRESULT CALLBACK DlgAsmProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	ASM_DIALOG_PARAM *p_dialog_param;
	DWORD_PTR dwAddress, dwSize;
	FINDREPLACE *p_findreplace;
	POINT pt;
	RECT rc;
	HDWP hDwp;
	HWND hPopupWnd;

	if(uMsg == WM_INITDIALOG)
	{
		p_dialog_param = (ASM_DIALOG_PARAM *)lParam;
		SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)p_dialog_param);
	}
	else
	{
		p_dialog_param = (ASM_DIALOG_PARAM *)GetWindowLongPtr(hWnd, DWLP_USER);
		if(!p_dialog_param)
			return FALSE;
	}

	switch(uMsg)
	{
	case WM_INITDIALOG:
		p_dialog_param->hSmallIcon = (HICON)LoadImage(hDllInst, MAKEINTRESOURCE(IDI_MAIN), IMAGE_ICON, 16, 16, 0);
		if(p_dialog_param->hSmallIcon)
			SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)p_dialog_param->hSmallIcon);

		p_dialog_param->hLargeIcon = (HICON)LoadImage(hDllInst, MAKEINTRESOURCE(IDI_MAIN), IMAGE_ICON, 32, 32, 0);
		if(p_dialog_param->hLargeIcon)
			SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM)p_dialog_param->hLargeIcon);

		SetRAEditDesign(hWnd, hDllInst, &p_dialog_param->raFont);
		p_dialog_param->hMenu = LoadMenu(hDllInst, MAKEINTRESOURCE(IDR_RIGHTCLICK));

		GetClientRect(hWnd, &rc);
		p_dialog_param->dlg_last_cw = rc.right-rc.left;
		p_dialog_param->dlg_last_ch = rc.bottom-rc.top;

		LoadWindowPos(hWnd, hDllInst, &p_dialog_param->dlg_min_w, &p_dialog_param->dlg_min_h);

		p_dialog_param->bTabCtrlExInitialized = TabCtrlExInit(GetDlgItem(hWnd, IDC_TABS), 
			TCF_EX_REORDER|TCF_EX_LABLEEDIT|TCF_EX_REDUCEFLICKER|TCF_EX_MBUTTONNOFOCUS, UWM_NOTIFY);
		if(!p_dialog_param->bTabCtrlExInitialized)
		{
			DestroyWindow(hWnd);
			break;
		}

		InitTabs(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), hDllInst, hWnd, UWM_ERRORMSG);

		InitFindReplace(hWnd, hDllInst, p_dialog_param);
		break;

	case UWM_LOADCODE:
		dwAddress = (DWORD_PTR)wParam;
		dwSize = (DWORD_PTR)lParam;

		if(dwAddress && dwSize)
		{
			if(SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_GETTEXTLENGTH, 0, 0) > 0)
			{
				OnTabChanging(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
				NewTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), NULL);
			}

			LoadCode(hWnd, dwAddress, dwSize);
		}
		break;

	case UWM_OPTIONSCHANGED:
		OptionsChanged(hWnd);
		break;

	case WM_LBUTTONDOWN:
		SendMessage(hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0);
		break;

	case WM_LBUTTONDBLCLK:
		GetClientRect(GetDlgItem(hWnd, IDC_TABS), &rc);
		pt.x = GET_X_LPARAM(lParam);
		pt.y = GET_Y_LPARAM(lParam);

		if(PtInRect(&rc, pt))
		{
			OnTabChanging(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			NewTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), NULL);
		}
		break;

	case WM_GETMINMAXINFO:
		((MINMAXINFO *)lParam)->ptMinTrackSize.x = p_dialog_param->dlg_min_w;
		((MINMAXINFO *)lParam)->ptMinTrackSize.y = p_dialog_param->dlg_min_h;
		break;

	case WM_SIZE:
		if(wParam == SIZE_RESTORED || wParam == SIZE_MAXIMIZED)
		{
			hDwp = BeginDeferWindowPos(4);

			if(hDwp)
				hDwp = ChildRelativeDeferWindowPos(hDwp, hWnd, IDC_TABS, 
					0, 0, LOWORD(lParam)-p_dialog_param->dlg_last_cw, 0);

			if(hDwp)
				hDwp = ChildRelativeDeferWindowPos(hDwp, hWnd, IDC_ASSEMBLER, 
					0, 0, LOWORD(lParam)-p_dialog_param->dlg_last_cw, HIWORD(lParam)-p_dialog_param->dlg_last_ch);

			if(hDwp)
				hDwp = ChildRelativeDeferWindowPos(hDwp, hWnd, IDOK, 
					0, HIWORD(lParam)-p_dialog_param->dlg_last_ch, 0, 0);

			if(hDwp)
				hDwp = ChildRelativeDeferWindowPos(hDwp, hWnd, IDC_CLOSE, 
					LOWORD(lParam)-p_dialog_param->dlg_last_cw, HIWORD(lParam)-p_dialog_param->dlg_last_ch, 0, 0);

			if(hDwp)
				EndDeferWindowPos(hDwp);

			p_dialog_param->dlg_last_cw = LOWORD(lParam);
			p_dialog_param->dlg_last_ch = HIWORD(lParam);
		}
		break;

	case WM_CONTEXTMENU:
		if((HWND)wParam == GetDlgItem(hWnd, IDC_ASSEMBLER))
		{
			if(lParam == -1)
			{
				GetCaretPos(&pt);
				ClientToScreen((HWND)wParam, &pt);
			}
			else
			{
				pt.x = GET_X_LPARAM(lParam);
				pt.y = GET_Y_LPARAM(lParam);
			}

			UpdateRightClickMenuState(hWnd, GetSubMenu(p_dialog_param->hMenu, 0));
			TrackPopupMenu(GetSubMenu(p_dialog_param->hMenu, 0), TPM_RIGHTBUTTON, pt.x, pt.y, 0, hWnd, NULL);
		}
		else if((HWND)wParam == hWnd && lParam != -1)
		{
			pt.x = GET_X_LPARAM(lParam);
			pt.y = GET_Y_LPARAM(lParam);

			GetWindowRect(GetDlgItem(hWnd, IDC_TABS), &rc);

			if(PtInRect(&rc, pt))
				TrackPopupMenu(GetSubMenu(p_dialog_param->hMenu, 2), TPM_RIGHTBUTTON, pt.x, pt.y, 0, hWnd, NULL);
		}
		break;

	case WM_ACTIVATE:
		switch(LOWORD(wParam))
		{
		case WA_INACTIVE:
			SaveFileOfTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			break;

		case WA_ACTIVE:
		case WA_CLICKACTIVE:
			SyncTabs(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			break;
		}
		break;

	case WM_NOTIFY:
		switch(((NMHDR *)lParam)->idFrom)
		{
		case IDC_TABS:
			switch(((NMHDR *)lParam)->code)
			{
			case TCN_SELCHANGING:
				OnTabChanging(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
				break;

			case TCN_SELCHANGE:
				OnTabChanged(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
				break;
			}
			break;

		case IDC_ASSEMBLER:
			switch(((NMHDR *)lParam)->code)
			{
			case EN_SELCHANGE:
				if(((RASELCHANGE *)lParam)->seltyp != SEL_OBJECT)
				{
					if(((RASELCHANGE *)lParam)->fchanged)
						SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETCOMMENTBLOCKS, (WPARAM)"comment +", (LPARAM)"-");
				}
				break;
			}
			break;
		}
		break;

	case UWM_NOTIFY:
		if(((UNMTABCTRLEX *)lParam)->hdr.idFrom == IDC_TABS)
		{
			switch(((UNMTABCTRLEX *)lParam)->hdr.code)
			{
			case TCN_EX_DRAGDROP:
				OnTabDrag(GetDlgItem(hWnd, IDC_TABS), (int)((UNMTABCTRLEX *)lParam)->wParam, (int)((UNMTABCTRLEX *)lParam)->lParam);
				break;

			case TCN_EX_DBLCLK:
				TabRenameStart(GetDlgItem(hWnd, IDC_TABS));
				break;

			case TCN_EX_MCLICK:
				pt.x = GET_X_LPARAM(((UNMTABCTRLEX *)lParam)->lParam);
				pt.y = GET_Y_LPARAM(((UNMTABCTRLEX *)lParam)->lParam);

				CloseTabOnPoint(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), &pt);
				break;

			case TCN_EX_CONTEXTMENU:
				if(OnContextMenu(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), 
					((UNMTABCTRLEX *)lParam)->lParam, &pt))
					TrackPopupMenu(GetSubMenu(p_dialog_param->hMenu, 1), TPM_RIGHTBUTTON, pt.x, pt.y, 0, hWnd, NULL);
				break;

			case TCN_EX_BEGINLABELEDIT:
				SetWindowLongPtr(hWnd, DWLP_MSGRESULT, FALSE);
				return TRUE;

			case TCN_EX_ENDLABELEDIT:
				SetWindowLongPtr(hWnd, DWLP_MSGRESULT, 
					TabRenameEnd(GetDlgItem(hWnd, IDC_TABS), (TCHAR *)((UNMTABCTRLEX *)lParam)->lParam));
				return TRUE;
			}
		}
		break;

	case UWM_ERRORMSG:
		AsmDlgMessageBox(hWnd, (TCHAR *)lParam, NULL, (UINT)wParam);
		break;

	case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case ID_RCM_UNDO:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_UNDO, 0, 0);
			break;

		case ID_RCM_REDO:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_REDO, 0, 0);
			break;

		case ID_RCM_CUT:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_CUT, 0, 0);
			break;

		case ID_RCM_COPY:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_COPY, 0, 0);
			break;

		case ID_RCM_PASTE:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_PASTE, 0, 0);
			break;

		case ID_RCM_DELETE:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_CLEAR, 0, 0);
			break;

		case ID_RCM_SELECTALL:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_SETSEL, 0, -1);
			break;

		case ID_TABMENU_NEWTAB:
			OnTabChanging(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			NewTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), NULL);
			break;

		case ID_TABMENU_RENAME:
			TabRenameStart(GetDlgItem(hWnd, IDC_TABS));
			break;

		case ID_TABMENU_CLOSE:
			CloseTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			break;

		case ID_TABMENU_LOADFROMFILE:
			LoadFileFromLibrary(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), hWnd, hDllInst);
			break;

		case ID_TABMENU_SAVETOFILE:
			SaveFileToLibrary(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER), hWnd, hDllInst);
			break;

		case ID_TABSTRIPMENU_CLOSEALLTABS:
			CloseAllTabs(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			break;

		case ID_ACCEL_PREVTAB:
			PrevTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			break;

		case ID_ACCEL_NEXTTAB:
			NextTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			break;

		case ID_ACCEL_FINDWND:
			ShowFindDialog(p_dialog_param);
			break;

		case ID_ACCEL_REPLACEWND:
			ShowReplaceDialog(p_dialog_param);
			break;

		case ID_ACCEL_FINDNEXT:
			if(*p_dialog_param->szFindStr != _T('\0'))
				DoFindCustom(p_dialog_param, FR_DOWN, 0);
			else
				ShowFindDialog(p_dialog_param);
			break;

		case ID_ACCEL_FINDPREV:
			if(*p_dialog_param->szFindStr != _T('\0'))
				DoFindCustom(p_dialog_param, 0, FR_DOWN);
			else
				ShowFindDialog(p_dialog_param);
			break;

		case ID_ACCEL_FOCUS_OLLYDBG:
			SetFocus(hwollymain);
			break;

		case ID_ACCEL_BLOCK_MODE:
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETMODE, 
				SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_GETMODE, 0, 0) ^ MODE_BLOCK, 0);
			break;

		case IDOK:
			SaveFileOfTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
			PatchCode(hWnd);
			break;

		case IDC_CLOSE:
			SendMessage(hWnd, WM_CLOSE, 0, 0);
			break;
		}
		break;

	case WM_CLOSE:
		if(!IsWindowEnabled(hWnd))
		{
			hPopupWnd = GetWindow(hWnd, GW_ENABLEDPOPUP);
			if(hPopupWnd && hPopupWnd != hWnd)
				SendMessage(hPopupWnd, WM_CLOSE, 0, 0);
		}

		if(p_dialog_param->hFindReplaceWnd)
			SendMessage(p_dialog_param->hFindReplaceWnd, WM_CLOSE, 0, 0);

		SaveWindowPos(hWnd, hDllInst);
		SaveFileOfTab(GetDlgItem(hWnd, IDC_TABS), GetDlgItem(hWnd, IDC_ASSEMBLER));
		DestroyWindow(hWnd);
		hAsmDlg = NULL;
		SetWindowLongPtr(hWnd, DWLP_MSGRESULT, 0);
		return TRUE;

	case WM_DESTROY:
		if(p_dialog_param->hSmallIcon)
		{
			DestroyIcon(p_dialog_param->hSmallIcon);
			p_dialog_param->hSmallIcon = NULL;
		}

		if(p_dialog_param->hLargeIcon)
		{
			DestroyIcon(p_dialog_param->hLargeIcon);
			p_dialog_param->hLargeIcon = NULL;
		}

		if(p_dialog_param->raFont.hFont)
		{
			DeleteObject(p_dialog_param->raFont.hFont);
			p_dialog_param->raFont.hFont = NULL;
		}

		if(p_dialog_param->raFont.hIFont)
		{
			DeleteObject(p_dialog_param->raFont.hIFont);
			p_dialog_param->raFont.hIFont = NULL;
		}

		if(p_dialog_param->raFont.hLnrFont)
		{
			DeleteObject(p_dialog_param->raFont.hLnrFont);
			p_dialog_param->raFont.hLnrFont = NULL;
		}

		if(p_dialog_param->hMenu)
		{
			DestroyMenu(p_dialog_param->hMenu);
			p_dialog_param->hMenu = NULL;
		}

		if(p_dialog_param->bTabCtrlExInitialized)
		{
			TabCtrlExExit(GetDlgItem(hWnd, IDC_TABS));
			p_dialog_param->bTabCtrlExInitialized = FALSE;
		}
		break;

	default:
		if(uMsg == p_dialog_param->uFindReplaceMsg)
		{
			p_findreplace = (FINDREPLACE *)lParam;

			if(p_findreplace->Flags & FR_FINDNEXT)
				DoFind(p_dialog_param);
			else if(p_findreplace->Flags & FR_REPLACE)
				DoReplace(p_dialog_param);
			else if(p_findreplace->Flags & FR_REPLACEALL)
				DoReplaceAll(p_dialog_param);
			else if(p_findreplace->Flags & FR_DIALOGTERM)
				p_dialog_param->hFindReplaceWnd = NULL;
		}
		break;
	}

	return FALSE;
}

static void SetRAEditDesign(HWND hWnd, HINSTANCE hInstance, RAFONT *praFont)
{
	RACOLOR raColor;
	LOGFONT lfLogFont;
	int nFontSize;
	int tabwidth_variants[] = {2, 4, 8};
	HDC hDC;

	// Colors
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_GETCOLOR, 0, (LPARAM)&raColor);
	raColor.bckcol = RGB(255, 255, 255);
	raColor.cmntback = RGB(255, 255, 255);
	raColor.strback = RGB(255, 255, 255);
	raColor.numback = RGB(255, 255, 255);
	raColor.oprback = RGB(255, 255, 255);
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETCOLOR, 0, (LPARAM)&raColor);

	// Fonts
	ZeroMemory(&lfLogFont, sizeof(LOGFONT));

	if(!MyGetstringfromini(hInstance, _T("font_name"), lfLogFont.lfFaceName, LF_FACESIZE))
	{
		lstrcpy(lfLogFont.lfFaceName, _T("Lucida Console")); // Default font
		MyWritestringtoini(hInstance, _T("font_name"), lfLogFont.lfFaceName);
	}

	if(!MyGetintfromini(hInstance, _T("font_size"), &nFontSize, 0, 0, 9))
	{
		MyWriteinttoini(hInstance, _T("font_size"), nFontSize);
	}

	hDC = GetDC(GetDlgItem(hWnd, IDC_ASSEMBLER));

	lfLogFont.lfHeight = -MulDiv(nFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
	lfLogFont.lfCharSet = DEFAULT_CHARSET;
	praFont->hFont = CreateFontIndirect(&lfLogFont);

	lfLogFont.lfItalic = TRUE;
	praFont->hIFont = CreateFontIndirect(&lfLogFont);

	nFontSize = MulDiv(nFontSize, 2, 3);
	lfLogFont.lfHeight = -MulDiv(nFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
	lfLogFont.lfItalic = FALSE;
	praFont->hLnrFont = CreateFontIndirect(&lfLogFont);

	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETFONT, 0, (LPARAM)praFont);

	ReleaseDC(GetDlgItem(hWnd, IDC_ASSEMBLER), hDC);

	// Highlights
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETHILITEWORDS, RGB(0, 0, 255), (LPARAM)HILITE_ASM_CMD);
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETHILITEWORDS, RGB(255, 0, 255), (LPARAM)HILITE_ASM_FPU_CMD);
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETHILITEWORDS, RGB(255, 0, 0), (LPARAM)HILITE_ASM_EXT_CMD);
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETHILITEWORDS, RGB(0, 128, 128), (LPARAM)HILITE_REG);
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETHILITEWORDS, RGB(0, 64, 128), (LPARAM)HILITE_TYPE);
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETHILITEWORDS, RGB(255, 128, 64), (LPARAM)HILITE_OTHER);

	// C-style strings \m/
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_SETSTYLEEX, STILEEX_STRINGMODEC, 0);

	// Tab width
	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_TABWIDTH, tabwidth_variants[options.edit_tabwidth], 0);
}

static void UpdateRightClickMenuState(HWND hWnd, HMENU hMenu)
{
	CHARRANGE crRange;
	UINT uEnable;

	if(SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_CANUNDO, 0, 0))
		EnableMenuItem(hMenu, ID_RCM_UNDO, MF_ENABLED);
	else
		EnableMenuItem(hMenu, ID_RCM_UNDO, MF_GRAYED);

	if(SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_CANREDO, 0, 0))
		EnableMenuItem(hMenu, ID_RCM_REDO, MF_ENABLED);
	else
		EnableMenuItem(hMenu, ID_RCM_REDO, MF_GRAYED);

	if(SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_CANPASTE, CF_TEXT, 0))
		EnableMenuItem(hMenu, ID_RCM_PASTE, MF_ENABLED);
	else
		EnableMenuItem(hMenu, ID_RCM_PASTE, MF_GRAYED);

	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_EXGETSEL, 0, (LPARAM)&crRange);
	if(crRange.cpMax - crRange.cpMin > 0)
		uEnable = MF_ENABLED;
	else
		uEnable = MF_GRAYED;

	EnableMenuItem(hMenu, ID_RCM_CUT, uEnable);
	EnableMenuItem(hMenu, ID_RCM_COPY, uEnable);
	EnableMenuItem(hMenu, ID_RCM_DELETE, uEnable);
}

static void LoadWindowPos(HWND hWnd, HINSTANCE hInst, long *p_min_w, long *p_min_h)
{
	long cur_w, cur_h;
	long min_w, min_h;
	int x, y, w, h;
	RECT rc;
	WINDOWPLACEMENT wp;

	GetWindowRect(hWnd, &rc);
	cur_w = rc.right-rc.left;
	cur_h = rc.bottom-rc.top;

	GetWindowRect(GetDlgItem(hWnd, IDOK), &rc);
	min_w = cur_w + rc.right;

	GetWindowRect(GetDlgItem(hWnd, IDC_CLOSE), &rc);
	min_w -= rc.left;

	GetWindowRect(GetDlgItem(hWnd, IDC_ASSEMBLER), &rc);
	min_h = cur_h - (rc.bottom-rc.top);

	*p_min_w = min_w;
	*p_min_h = min_h;

	if(options.edit_savepos)
	{
		if(MyGetintfromini(hInst, _T("pos_x"), &x, 0, 0, 0) && MyGetintfromini(hInst, _T("pos_y"), &y, 0, 0, 0))
		{
			MyGetintfromini(hInst, _T("pos_w"), &w, min_w, INT_MAX, cur_w);
			MyGetintfromini(hInst, _T("pos_h"), &h, min_h, INT_MAX, cur_h);

			wp.length = sizeof(WINDOWPLACEMENT);
			wp.flags = 0;
			wp.showCmd = IsWindowVisible(hWnd) ? SW_SHOW : SW_HIDE;
			wp.rcNormalPosition.left = x;
			wp.rcNormalPosition.top = y;
			wp.rcNormalPosition.right = x+w;
			wp.rcNormalPosition.bottom = y+h;

			SetWindowPlacement(hWnd, &wp);
		}
	}
}

static void SaveWindowPos(HWND hWnd, HINSTANCE hInst)
{
	WINDOWPLACEMENT wp;

	if(options.edit_savepos)
	{
		wp.length = sizeof(WINDOWPLACEMENT);
		GetWindowPlacement(hWnd, &wp);

		MyWriteinttoini(hInst, _T("pos_x"), wp.rcNormalPosition.left);
		MyWriteinttoini(hInst, _T("pos_y"), wp.rcNormalPosition.top);
		MyWriteinttoini(hInst, _T("pos_w"), wp.rcNormalPosition.right-wp.rcNormalPosition.left);
		MyWriteinttoini(hInst, _T("pos_h"), wp.rcNormalPosition.bottom-wp.rcNormalPosition.top);
	}
}

static HDWP ChildRelativeDeferWindowPos(HDWP hWinPosInfo, HWND hWnd, int nIDDlgItem, int x, int y, int cx, int cy)
{
	HWND hChildWnd;
	RECT rc;

	hChildWnd = GetDlgItem(hWnd, nIDDlgItem);

	GetWindowRect(hChildWnd, &rc);
	MapWindowPoints(NULL, hWnd, (POINT *)&rc, 2);

	return DeferWindowPos(hWinPosInfo, hChildWnd, NULL, 
		rc.left+x, rc.top+y, (rc.right-rc.left)+cx, (rc.bottom-rc.top)+cy, SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOOWNERZORDER);
}

static int AsmDlgMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)
{
	ASM_DIALOG_PARAM *p_dialog_param;
	HWND hFindReplaceWnd;
	BOOL bOllyEnabled;
	int nRet;

	bOllyEnabled = IsWindowEnabled(hwollymain);
	if(bOllyEnabled)
		EnableWindow(hwollymain, FALSE);

	p_dialog_param = (ASM_DIALOG_PARAM *)GetWindowLongPtr(hWnd, DWLP_USER);
	if(p_dialog_param)
		hFindReplaceWnd = p_dialog_param->hFindReplaceWnd;
	else
		hFindReplaceWnd = NULL;

	if(hFindReplaceWnd)
	{
		if(GetActiveWindow() == hFindReplaceWnd)
		{
			EnableWindow(hWnd, FALSE);
			nRet = MessageBox(hFindReplaceWnd, lpText, lpCaption, uType);
			EnableWindow(hWnd, TRUE);
		}
		else
		{
			EnableWindow(hFindReplaceWnd, FALSE);
			nRet = MessageBox(hWnd, lpText, lpCaption, uType);
			EnableWindow(hFindReplaceWnd, TRUE);
		}
	}
	else
		nRet = MessageBox(hWnd, lpText, lpCaption, uType);

	if(bOllyEnabled)
		EnableWindow(hwollymain, TRUE);

	return nRet;
}

static void InitFindReplace(HWND hWnd, HINSTANCE hInst, ASM_DIALOG_PARAM *p_dialog_param)
{
	p_dialog_param->uFindReplaceMsg = RegisterWindowMessage(FINDMSGSTRING);
	p_dialog_param->hFindReplaceWnd = NULL;
	*p_dialog_param->szFindStr = _T('\0');
	*p_dialog_param->szReplaceStr = _T('\0');

	p_dialog_param->findreplace.lStructSize = sizeof(FINDREPLACE);
	p_dialog_param->findreplace.hwndOwner = hWnd;
	p_dialog_param->findreplace.hInstance = hInst;
	p_dialog_param->findreplace.Flags = FR_DOWN;
	p_dialog_param->findreplace.lpstrFindWhat = p_dialog_param->szFindStr;
	p_dialog_param->findreplace.lpstrReplaceWith = p_dialog_param->szReplaceStr;
	p_dialog_param->findreplace.wFindWhatLen = FIND_REPLACE_TEXT_BUFFER;
	p_dialog_param->findreplace.wReplaceWithLen = FIND_REPLACE_TEXT_BUFFER;
}

static void ShowFindDialog(ASM_DIALOG_PARAM *p_dialog_param)
{
	if(p_dialog_param->hFindReplaceWnd)
		SetFocus(p_dialog_param->hFindReplaceWnd);
	else
		p_dialog_param->hFindReplaceWnd = FindText(&p_dialog_param->findreplace);
}

static void ShowReplaceDialog(ASM_DIALOG_PARAM *p_dialog_param)
{
	if(p_dialog_param->hFindReplaceWnd)
		SetFocus(p_dialog_param->hFindReplaceWnd);
	else
		p_dialog_param->hFindReplaceWnd = ReplaceText(&p_dialog_param->findreplace);
}

static void DoFind(ASM_DIALOG_PARAM *p_dialog_param)
{
	DoFindCustom(p_dialog_param, 0, 0);
}

static void DoFindCustom(ASM_DIALOG_PARAM *p_dialog_param, WPARAM wFlagsSet, WPARAM wFlagsRemove)
{
	FINDREPLACE *p_findreplace;
	HWND hWnd;
	WPARAM wFlagsParam;
	CHARRANGE selrange;
	FINDTEXTEXA findtextex;
#ifdef UNICODE
	char szAnsiFindStr[FIND_REPLACE_TEXT_BUFFER];
#endif
	TCHAR szInfoMsg[sizeof("Cannot find \"\"")-1+FIND_REPLACE_TEXT_BUFFER];

	p_findreplace = &p_dialog_param->findreplace;
	hWnd = p_findreplace->hwndOwner;

	wFlagsParam = p_findreplace->Flags & (FR_DOWN | FR_WHOLEWORD | FR_MATCHCASE);
	wFlagsParam |= wFlagsSet;
	wFlagsParam &= ~wFlagsRemove;

	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_EXGETSEL, 0, (LPARAM)&selrange);

	if(wFlagsParam & FR_DOWN)
	{
		findtextex.chrg.cpMin = selrange.cpMax;
		findtextex.chrg.cpMax = -1;
	}
	else
	{
		findtextex.chrg.cpMin = selrange.cpMin - 1;
		findtextex.chrg.cpMax = 0;
	}

#ifdef UNICODE
	WideCharToMultiByte(CP_ACP, 0, p_findreplace->lpstrFindWhat, -1, szAnsiFindStr, FIND_REPLACE_TEXT_BUFFER, NULL, NULL);
	findtextex.lpstrText = szAnsiFindStr;
#else // !UNICODE
	findtextex.lpstrText = p_findreplace->lpstrFindWhat;
#endif // UNICODE

	if(findtextex.chrg.cpMin >= 0 && 
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_FINDTEXTEX, wFlagsParam, (LPARAM)&findtextex) != -1)
	{
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_EXSETSEL, 0, (LPARAM)&findtextex.chrgText);
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_SCROLLCARET, 0, 0);
	}
	else
	{
		wsprintf(szInfoMsg, _T("Cannot find \"%s\""), p_findreplace->lpstrFindWhat);
		AsmDlgMessageBox(hWnd, szInfoMsg, _T("Find"), MB_ICONASTERISK);
	}
}

static void DoReplace(ASM_DIALOG_PARAM *p_dialog_param)
{
	FINDREPLACE *p_findreplace;
	HWND hWnd;
	WPARAM wFlagsParam;
	CHARRANGE selrange;
	FINDTEXTEXA findtextex;
#ifdef UNICODE
	char szAnsiFindStr[FIND_REPLACE_TEXT_BUFFER];
#endif

	p_findreplace = &p_dialog_param->findreplace;
	hWnd = p_findreplace->hwndOwner;

	wFlagsParam = p_findreplace->Flags & (FR_DOWN | FR_WHOLEWORD | FR_MATCHCASE);

	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_EXGETSEL, 0, (LPARAM)&selrange);

	findtextex.chrg.cpMin = selrange.cpMin;
	findtextex.chrg.cpMax = selrange.cpMin;

#ifdef UNICODE
	WideCharToMultiByte(CP_ACP, 0, p_findreplace->lpstrFindWhat, -1, szAnsiFindStr, FIND_REPLACE_TEXT_BUFFER, NULL, NULL);
	findtextex.lpstrText = szAnsiFindStr;
#else // !UNICODE
	findtextex.lpstrText = p_findreplace->lpstrFindWhat;
#endif // UNICODE

	if(SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_FINDTEXTEX, wFlagsParam, (LPARAM)&findtextex) != -1)
	{
		if(findtextex.chrgText.cpMin == selrange.cpMin && findtextex.chrgText.cpMax == selrange.cpMax)
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_REPLACESEL, TRUE, (LPARAM)p_findreplace->lpstrReplaceWith);
	}

	DoFind(p_dialog_param);
}

static void DoReplaceAll(ASM_DIALOG_PARAM *p_dialog_param)
{
	FINDREPLACE *p_findreplace;
	HWND hWnd;
	WPARAM wFlagsParam;
	FINDTEXTEXA findtextex;
#ifdef UNICODE
	char szAnsiFindStr[FIND_REPLACE_TEXT_BUFFER];
#endif
	CHARRANGE selrange;
	UINT uReplacedCount;
	TCHAR szInfoMsg[sizeof("4294967295 occurrences were replaced")];

	p_findreplace = &p_dialog_param->findreplace;
	hWnd = p_findreplace->hwndOwner;

	wFlagsParam = p_findreplace->Flags & (FR_DOWN | FR_WHOLEWORD | FR_MATCHCASE);

	findtextex.chrg.cpMin = 0;
	findtextex.chrg.cpMax = -1;

#ifdef UNICODE
	WideCharToMultiByte(CP_ACP, 0, p_findreplace->lpstrFindWhat, -1, szAnsiFindStr, FIND_REPLACE_TEXT_BUFFER, NULL, NULL);
	findtextex.lpstrText = szAnsiFindStr;
#else // !UNICODE
	findtextex.lpstrText = p_findreplace->lpstrFindWhat;
#endif // UNICODE

	uReplacedCount = 0;

	if(SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_FINDTEXTEX, wFlagsParam, (LPARAM)&findtextex) != -1)
	{
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_SETREDRAW, FALSE, 0);
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_LOCKUNDOID, TRUE, 0);

		do
		{
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_EXSETSEL, 0, (LPARAM)&findtextex.chrgText);
			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_REPLACESEL, TRUE, (LPARAM)p_findreplace->lpstrReplaceWith);

			uReplacedCount++;

			SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_EXGETSEL, 0, (LPARAM)&selrange);

			findtextex.chrg.cpMin = selrange.cpMax;
		}
		while(SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_FINDTEXTEX, wFlagsParam, (LPARAM)&findtextex) != -1);

		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_LOCKUNDOID, FALSE, 0);
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_SETREDRAW, TRUE, 0);
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_REPAINT, 0, FALSE);
	}

	switch(uReplacedCount)
	{
	case 0:
		lstrcpy(szInfoMsg, _T("No occurrences were replaced"));
		break;

	case 1:
		lstrcpy(szInfoMsg, _T("1 occurrence was replaced"));
		break;

	default:
		wsprintf(szInfoMsg, _T("%u occurrences were replaced"), uReplacedCount);
		break;
	}

	AsmDlgMessageBox(hWnd, szInfoMsg, _T("Replace All"), MB_ICONASTERISK);
}

static void OptionsChanged(HWND hWnd)
{
	int tabwidth_variants[] = {2, 4, 8};

	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, REM_TABWIDTH, tabwidth_variants[options.edit_tabwidth], 0);
}

static BOOL LoadCode(HWND hWnd, DWORD_PTR dwAddress, DWORD_PTR dwSize)
{
	TCHAR szLabelPrefix[32];
	TCHAR szError[1024+1]; // safe to use for wsprintf
	TCHAR *lpText;

	if(!GetTabName(GetDlgItem(hWnd, IDC_TABS), szLabelPrefix, 32))
		*szLabelPrefix = _T('\0');

	SuspendAllThreads();

	lpText = ReadAsm(dwAddress, dwSize, szLabelPrefix, szError);

	ResumeAllThreads();

	if(!lpText)
	{
		AsmDlgMessageBox(hWnd, szError, NULL, MB_ICONHAND);
		return FALSE;
	}

	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_SETTEXT, 0, (LPARAM)lpText);
	HeapFree(GetProcessHeap(), 0, lpText);

	return TRUE;
}

static BOOL PatchCode(HWND hWnd)
{
	TCHAR szError[1024+1]; // safe to use for wsprintf
	TCHAR *lpText;
	SIZE_T nTextSize;
	LONG_PTR result;

	if(!IsProcessLoaded())
	{
		AsmDlgMessageBox(hWnd, _T("No process is loaded"), NULL, MB_ICONASTERISK);
		return FALSE;
	}

	nTextSize = SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_GETTEXTLENGTH, 0, 0);

	lpText = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (nTextSize+1)*sizeof(TCHAR));
	if(!lpText)
	{
		AsmDlgMessageBox(hWnd, _T("Allocation failed"), NULL, MB_ICONHAND);
		return FALSE;
	}

	SendDlgItemMessage(hWnd, IDC_ASSEMBLER, WM_GETTEXT, nTextSize+1, (LPARAM)lpText);

	SuspendAllThreads();

	result = WriteAsm(lpText, szError);

	ResumeAllThreads();

	HeapFree(GetProcessHeap(), 0, lpText);

	if(result <= 0)
	{
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_SETSEL, -result, -result);
		SendDlgItemMessage(hWnd, IDC_ASSEMBLER, EM_SCROLLCARET, 0, 0);

		AsmDlgMessageBox(hWnd, szError, NULL, MB_ICONHAND);
		SetFocus(GetDlgItem(hWnd, IDC_ASSEMBLER));

		return FALSE;
	}

	return TRUE;
}



================================================
File: assembler_dlg.h
================================================
#ifndef _ASSEMBLER_DLG_H_
#define _ASSEMBLER_DLG_H_

#include "plugin.h"
#include "raedit.h"
#include "options_def.h"
#include "assembler_dlg_tabs.h"
#include "read_asm.h"
#include "write_asm.h"
#include "resource.h"

#define FIND_REPLACE_TEXT_BUFFER 128

typedef struct _asm_dialog_param {
	// General
	HICON hSmallIcon, hLargeIcon;
	RAFONT raFont;
	HMENU hMenu;
	BOOL bTabCtrlExInitialized;
	long dlg_min_w, dlg_min_h, dlg_last_cw, dlg_last_ch;

	// Find and replace
	UINT uFindReplaceMsg;
	HWND hFindReplaceWnd;
	TCHAR szFindStr[FIND_REPLACE_TEXT_BUFFER];
	TCHAR szReplaceStr[FIND_REPLACE_TEXT_BUFFER];
	FINDREPLACE findreplace;
} ASM_DIALOG_PARAM;

// Both Message window and Assembler dialog messages
#define UWM_LOADCODE                    (WM_APP)
#define UWM_OPTIONSCHANGED              (WM_APP+1)

// Assembler dialog messages
#define UWM_NOTIFY                      (WM_APP+2)
#define UWM_ERRORMSG                    (WM_APP+3)

#define HILITE_ASM_CMD \
	"aaa aad aam aas adc add and call cbw clc cld cli cmc cmp cmps cmpsb " \
	"cmpsw cwd daa das dec div esc hlt idiv imul in inc int into iret ja jae " \
	"jb jbe jc jcxz je jg jge jl jle jmp jna jnae jnb jnbe jnc jne jng jnge " \
	"jnl jnle jno jnp jns jnz jo jp jpe jpo js jz lahf lds lea les lods lodsb " \
	"lodsw loop loope loopew loopne loopnew loopnz loopnzw loopw loopz loopzw " \
	"mov movs movsb movsw mul neg nop not or out pop popf push pushf rcl rcr " \
	"ret retf retn rol ror sahf sal sar sbb scas scasb scasw shl shr stc std " \
	"sti stos stosb stosw sub test wait xchg xlat xlatb xor " \
	\
	"bound enter ins insb insw leave outs outsb outsw popa pusha pushw arpl " \
	"lar lsl sgdt sidt sldt smsw str verr verw clts lgdt lidt lldt lmsw ltr " \
	"bsf bsr bt btc btr bts cdq cmpsd cwde insd iretd iretdf iretf jecxz lfs " \
	"lgs lodsd loopd looped loopned loopnzd loopzd lss movsd movsx movzx " \
	"outsd popad popfd pushad pushd pushfd scasd seta setae setb setbe setc " \
	"sete setg setge setl setle setna setnae setnb setnbe setnc setne setng " \
	"setnge setnl setnle setno setnp setns setnz seto setp setpe setpo sets " \
	"setz shld shrd stosd bswap cmpxchg invd invlpg wbinvd xadd " \
	\
	"lock rep repe repne repnz repz " \
	\
	"cflush cpuid emms femms cmovo cmovno cmovb cmovc cmovnae cmovae cmovnb " \
	"cmovnc cmove cmovz cmovne cmovnz cmovbe cmovna cmova cmovnbe cmovs " \
	"cmovns cmovp cmovpe cmovnp cmovpo cmovl cmovnge cmovge cmovnl cmovle " \
	"cmovng cmovg cmovnle cmpxchg486 cmpxchg8b loadall loadall286 ibts icebp " \
	"int1 int3 int01 int03 iretw popaw popfw pushaw pushfw rdmsr rdpmc rdshr " \
	"rdtsc rsdc rsldt rsm rsts salc smi smint smintold svdc svldt svts " \
	"syscall sysenter sysexit sysret ud0 ud1 ud2 umov xbts wrmsr wrshr " \
	\
	"comment+"

#define HILITE_ASM_FPU_CMD \
	"f2xm1 fabs fadd faddp fbld fbstp fchs fclex fcom fcomp fcompp fdecstp " \
	"fdisi fdiv fdivp fdivr fdivrp feni ffree fiadd ficom ficomp fidiv fidivr " \
	"fild fimul fincstp finit fist fistp fisub fisubr fld fld1 fldcw fldenv " \
	"fldenvw fldl2e fldl2t fldlg2 fldln2 fldpi fldz fmul fmulp fnclex fndisi " \
	"fneni fninit fnop fnsave fnsavew fnstcw fnstenv fnstenvw fnstsw fpatan " \
	"fprem fptan frndint frstor frstorw fsave fsavew fscale fsqrt fst fstcw " \
	"fstenv fstenvw fstp fstsw fsub fsubp fsubr fsubrp ftst fwait fxam fxch " \
	"fxtract fyl2x fyl2xp1 fsetpm fcos fldenvd fnsaved fnstenvd fprem1 " \
	"frstord fsaved fsin fsincos fstenvd fucom fucomp fucompp fcomi fcomip " \
	"ffreep fcmovb fcmove fcmovbe fcmovu fcmovnb fcmovne fcmovnbe fcmovnu"

#define HILITE_ASM_EXT_CMD \
	"addpd addps addsd addss andpd andps andnpd andnps cmpeqpd cmpltpd " \
	"cmplepd cmpunordpd cmpnepd cmpnltpd cmpnlepd cmpordpd cmpeqps cmpltps " \
	"cmpleps cmpunordps cmpneps cmpnltps cmpnleps cmpordps cmpeqsd cmpltsd " \
	"cmplesd cmpunordsd cmpnesd cmpnltsd cmpnlesd cmpordsd cmpeqss cmpltss " \
	"cmpless cmpunordss cmpness cmpnltss cmpnless cmpordss comisd comiss " \
	"cvtdq2pd cvtdq2ps cvtpd2dq cvtpd2pi cvtpd2ps cvtpi2pd cvtpi2ps cvtps2dq " \
	"cvtps2pd cvtps2pi cvtss2sd cvtss2si cvtsd2si cvtsd2ss cvtsi2sd cvtsi2ss " \
	"cvttpd2dq cvttpd2pi cvttps2dq cvttps2pi cvttsd2si cvttss2si divpd divps " \
	"divsd divss fxrstor fxsave ldmxscr lfence mfence maskmovdqu maskmovdq " \
	"maxpd maxps paxsd maxss minpd minps minsd minss movapd movaps movdq2q " \
	"movdqa movdqu movhlps movhpd movhps movd movq movlhps movlpd movlps " \
	"movmskpd movmskps movntdq movnti movntpd movntps movntq movq2dq movsd " \
	"movss movupd movups mulpd mulps mulsd mulss orpd orps packssdw packsswb " \
	"packuswb paddb paddsb paddw paddsw paddd paddsiw paddq paddusb paddusw " \
	"pand pandn pause paveb pavgb pavgw pavgusb pdistib pextrw pcmpeqb " \
	"pcmpeqw pcmpeqd pcmpgtb pcmpgtw pcmpgtd pf2id pf2iw pfacc pfadd pfcmpeq " \
	"pfcmpge pfcmpgt pfmax pfmin pfmul pmachriw pmaddwd pmagw pmaxsw pmaxub " \
	"pminsw pminub pmovmskb pmulhrwc pmulhriw pmulhrwa pmulhuw pmulhw pmullw " \
	"pmuludq pmvzb pmvnzb pmvlzb pmvgezb pfnacc pfpnacc por prefetch " \
	"prefetchw prefetchnta prefetcht0 prefetcht1 prefetcht2 pfrcp pfrcpit1 " \
	"pfrcpit2 pfrsqit1 pfrsqrt pfsub pfsubr pi2fd pf2iw pinsrw psadbw pshufd " \
	"pshufhw pshuflw pshufw psllw pslld psllq pslldq psraw psrad psrlw psrld " \
	"psrlq psrldq psubb psubw psubd psubq psubsb psubsw psubusb psubusw " \
	"psubsiw pswapd punpckhbw punpckhwd punpckhdq punpckhqdq punpcklbw " \
	"punpcklwd punpckldq punpcklqdq pxor rcpps rcpss rsqrtps rsqrtss sfence " \
	"shufpd shufps sqrtpd sqrtps sqrtsd sqrtss stmxcsr subpd subps subsd " \
	"subss ucomisd ucomiss unpckhpd unpckhps unpcklpd unpcklps xorpd xorps"

#define HILITE_REG \
	"ah al ax bh bl bp bx ch cl cr0 cr2 cr3 cr4 cs cx dh di dl dr0 dr1 dr2 " \
	"dr3 dr6 dr7 ds dx eax ebp ebx ecx edi edx es esi esp fs gs si sp ss st " \
	"tr3 tr4 tr5 tr6 tr7 st0 st1 st2 st3 st4 st5 st6 st7 mm0 mm1 mm2 mm3 mm4 " \
	"mm5 mm6 mm7 xmm0 xmm1 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7"

#define HILITE_TYPE \
	"byte word dword qword dqword " \
	"db dw dd dq dt"

#define HILITE_OTHER \
	"ptr short long near far"

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lParam)	 ((int)(short)LOWORD(lParam))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lParam)	 ((int)(short)HIWORD(lParam))
#endif

TCHAR *AssemblerInit();
void AssemblerExit();
BOOL AssemblerPreTranslateMessage(LPMSG lpMsg);
void AssemblerShowDlg();
void AssemblerCloseDlg();
void AssemblerLoadCode(DWORD_PTR dwAddress, DWORD_PTR dwSize);
void AssemblerOptionsChanged();
static HWND CreateAsmDlg();
static void CloseAsmDlg(HWND hWnd);
static LRESULT CALLBACK DlgAsmProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static void SetRAEditDesign(HWND hWnd, HINSTANCE hInst, RAFONT *praFont);
static void UpdateRightClickMenuState(HWND hWnd, HMENU hMenu);
static void LoadWindowPos(HWND hWnd, HINSTANCE hInst, long *p_min_w, long *p_min_h);
static void SaveWindowPos(HWND hWnd, HINSTANCE hInst);
static HDWP ChildRelativeDeferWindowPos(HDWP hWinPosInfo, HWND hWnd, int nIDDlgItem, int x, int y, int cx, int cy);
static int AsmDlgMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);
static void InitFindReplace(HWND hWnd, HINSTANCE hInst, ASM_DIALOG_PARAM *p_dialog_param);
static void ShowFindDialog(ASM_DIALOG_PARAM *p_dialog_param);
static void ShowReplaceDialog(ASM_DIALOG_PARAM *p_dialog_param);
static void DoFind(ASM_DIALOG_PARAM *p_dialog_param);
static void DoFindCustom(ASM_DIALOG_PARAM *p_dialog_param, WPARAM wFlagsSet, WPARAM wFlagsRemove);
static void DoReplace(ASM_DIALOG_PARAM *p_dialog_param);
static void DoReplaceAll(ASM_DIALOG_PARAM *p_dialog_param);
static void OptionsChanged(HWND hWnd);
static BOOL LoadCode(HWND hWnd, DWORD_PTR dwAddress, DWORD_PTR dwSize);
static BOOL PatchCode(HWND hWnd);

#endif // _ASSEMBLER_DLG_H_



================================================
File: assembler_dlg_tabs.c
================================================
#include "stdafx.h"
#include "assembler_dlg_tabs.h"

static HWND hPostErrorWnd;
static UINT uPostErrorMsg;
static TCHAR szTabFilesPath[MAX_PATH];
static TCHAR szConfigFilePath[MAX_PATH];
static TCHAR szLibraryFilePath[MAX_PATH];
static FILETIME ftConfigLastWriteTime;
static FILETIME ftCurrentTabLastWriteTime;
static UINT nTabsCreatedCounter;

void InitTabs(HWND hTabCtrlWnd, HWND hAsmEditWnd, HINSTANCE hInst, HWND hErrorWnd, UINT uErrorMsg)
{
	TCHAR szTabsRelativeFilePath[MAX_PATH];
	DWORD dwPathLen;
	int nTabsLoaded;
	int nLastTab;

	hPostErrorWnd = hErrorWnd;
	uPostErrorMsg = uErrorMsg;

	// Get the folder with our tab files, and create it if it does not exist
	if(!MyGetstringfromini(hInst, _T("tabs_path"), szTabsRelativeFilePath, MAX_PATH))
	{
		lstrcpy(szTabsRelativeFilePath, _T(".\\multiasm"));
		MyWritestringtoini(hInst, _T("tabs_path"), szTabsRelativeFilePath);
	}

	dwPathLen = PathRelativeToModuleDir(hInst, szTabsRelativeFilePath, szTabFilesPath, TRUE);

	if(dwPathLen == 0 || dwPathLen+sizeof("4294967295.asm") > MAX_PATH || // and "tabs.ini" and "lib\\"
		!MakeSureDirectoryExists(szTabFilesPath))
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Could not use specified directory, using system temp dir"));
		GetTempPath(MAX_PATH, szTabFilesPath);
	}

	lstrcpy(szConfigFilePath, szTabFilesPath);
	lstrcat(szConfigFilePath, _T("tabs.ini"));

	GetConfigLastWriteTime(&ftConfigLastWriteTime);

	lstrcpy(szLibraryFilePath, szTabFilesPath);
	lstrcat(szLibraryFilePath, _T("lib\\"));

	// Load our tabs from ini
	nTabsLoaded = InitLoadTabs(hTabCtrlWnd);

	// Create a new tab if needed
	if(nTabsLoaded == 0)
	{
		nTabsCreatedCounter = 0;
		NewTab(hTabCtrlWnd, hAsmEditWnd, NULL);
	}
	else
	{
		nTabsCreatedCounter = ReadIntFromPrivateIni(_T("tabs_counter"), 0);

		nLastTab = ReadIntFromPrivateIni(_T("tabs_last_open"), 0);
		if(nLastTab > 0 && nLastTab < nTabsLoaded)
			TabCtrl_SetCurSel(hTabCtrlWnd, nLastTab);

		LoadFileOfTab(hTabCtrlWnd, hAsmEditWnd);
	}
}

int InitLoadTabs(HWND hTabCtrlWnd)
{
	TCHAR szStringKey[32];
	TCITEM_CUSTOM tci;
	TCHAR szTabLabel[MAX_PATH];
	int nMaxLabelLen;
	int nTabCount, nTabInvalidCount;
	int i;

	TabCtrl_SetItemExtra(hTabCtrlWnd, sizeof(TCITEM_EXTRA));

	nMaxLabelLen = (MAX_PATH-1) - lstrlen(szTabFilesPath) - (sizeof(".asm")-1);
	nTabCount = 0;
	nTabInvalidCount = 0;

	tci.header.mask = TCIF_TEXT|TCIF_PARAM; 
	tci.header.pszText = szTabLabel;
	ZeroMemory(&tci.extra, sizeof(TCITEM_EXTRA));

	wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount+nTabInvalidCount);
	ReadStringFromPrivateIni(szStringKey, NULL, szTabLabel, nMaxLabelLen+1);

	while(*szTabLabel != _T('\0'))
	{
		MakeTabLabelValid(szTabLabel);

		if(FindTabByLabel(hTabCtrlWnd, szTabLabel) == -1)
		{
			if(nTabInvalidCount > 0)
			{
				wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount);
				WriteStringToPrivateIni(szStringKey, szTabLabel);
			}

			TabCtrl_InsertItem(hTabCtrlWnd, nTabCount, &tci);
			nTabCount++;
		}
		else
			nTabInvalidCount++;

		wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount+nTabInvalidCount);
		ReadStringFromPrivateIni(szStringKey, NULL, szTabLabel, nMaxLabelLen+1);
	}

	for(i=0; i<nTabInvalidCount; i++)
	{
		wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount+i);
		WriteStringToPrivateIni(szStringKey, NULL);
	}

	return nTabCount;
}

void SyncTabs(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	FILETIME ftWriteTimeCompare;
	TCHAR szStringKey[32];
	TCITEM_CUSTOM tci;
	TCHAR szTabLabel[MAX_PATH];
	int nMaxLabelLen;
	int nTabCount, nTabInvalidCount;
	int nTabIndex;
	BOOL bTabChanged;
	TCHAR szFileName[MAX_PATH];
	int i;

	bTabChanged = FALSE;

	GetConfigLastWriteTime(&ftWriteTimeCompare);

	if(ftWriteTimeCompare.dwLowDateTime != ftConfigLastWriteTime.dwLowDateTime || 
		ftWriteTimeCompare.dwHighDateTime != ftConfigLastWriteTime.dwHighDateTime)
	{
		nTabsCreatedCounter = ReadIntFromPrivateIni(_T("tabs_counter"), 0);

		nMaxLabelLen = (MAX_PATH-1) - lstrlen(szTabFilesPath) - (sizeof(".asm")-1);
		nTabCount = 0;
		nTabInvalidCount = 0;

		tci.header.mask = TCIF_TEXT|TCIF_PARAM; 
		tci.header.pszText = szTabLabel;
		ZeroMemory(&tci.extra, sizeof(TCITEM_EXTRA));

		wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount+nTabInvalidCount);
		ReadStringFromPrivateIni(szStringKey, NULL, szTabLabel, nMaxLabelLen+1);

		while(*szTabLabel != _T('\0'))
		{
			MakeTabLabelValid(szTabLabel);

			nTabIndex = FindTabByLabel(hTabCtrlWnd, szTabLabel);
			if(nTabIndex == -1 || nTabIndex >= nTabCount)
			{
				if(nTabInvalidCount > 0)
				{
					wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount);
					WriteStringToPrivateIni(szStringKey, szTabLabel);
				}

				if(nTabIndex == -1)
					TabCtrl_InsertItem(hTabCtrlWnd, nTabCount, &tci);
				else if(nTabIndex > nTabCount)
					MoveTab(hTabCtrlWnd, nTabIndex, nTabCount);

				nTabCount++;
			}
			else
				nTabInvalidCount++;

			wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount+nTabInvalidCount);
			ReadStringFromPrivateIni(szStringKey, NULL, szTabLabel, nMaxLabelLen+1);
		}

		for(i=0; i<nTabInvalidCount; i++)
		{
			wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount+i);
			WriteStringToPrivateIni(szStringKey, NULL);
		}

		while(TabCtrl_DeleteItem(hTabCtrlWnd, nTabCount));

		if(nTabCount == 0)
		{
			NewTab(hTabCtrlWnd, hAsmEditWnd, NULL);
			nTabIndex = 0;

			bTabChanged = TRUE;
		}
		else
		{
			nTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);
			if(nTabIndex == -1)
			{
				TabCtrl_SetCurSel(hTabCtrlWnd, 0);
				OnTabChanged(hTabCtrlWnd, hAsmEditWnd);
				nTabIndex = 0;

				bTabChanged = TRUE;
			}
		}

		WriteIntToPrivateIni(_T("tabs_last_open"), nTabIndex);

		//GetConfigLastWriteTime(&ftConfigLastWriteTime); // done at WriteIntToPrivateIni
	}

	if(!bTabChanged)
	{
		GetTabFileName(hTabCtrlWnd, -1, szFileName);
		GetFileLastWriteTime(szFileName, &ftWriteTimeCompare);

		if(ftWriteTimeCompare.dwLowDateTime != ftCurrentTabLastWriteTime.dwLowDateTime || 
			ftWriteTimeCompare.dwHighDateTime != ftCurrentTabLastWriteTime.dwHighDateTime)
			OnTabFileUpdated(hTabCtrlWnd, hAsmEditWnd);
	}
}

void NewTab(HWND hTabCtrlWnd, HWND hAsmEditWnd, TCHAR *pTabLabel)
{
	TCHAR szFileName[MAX_PATH];
	int nFilePathLen;
	TCHAR szTabLabel[MAX_PATH];
	int nLabelLen, nMaxLabelLen;
	TCITEM_CUSTOM tci;
	int nTabCount;
	TCHAR szStringKey[32];
	UINT i;

	lstrcpy(szFileName, szTabFilesPath);
	nFilePathLen = lstrlen(szFileName);

	if(pTabLabel)
	{
		nLabelLen = lstrlen(pTabLabel);
		nMaxLabelLen = (MAX_PATH-1) - nFilePathLen - (sizeof(".asm")-1);

		if(nLabelLen <= nMaxLabelLen)
		{
			lstrcpy(szTabLabel, pTabLabel);

			lstrcpy(szFileName+nFilePathLen, szTabLabel);
			lstrcat(szFileName+nFilePathLen, _T(".asm"));

			for(i=2; GetFileAttributes(szFileName) != INVALID_FILE_ATTRIBUTES || FindTabByLabel(hTabCtrlWnd, szTabLabel) != -1; i++)
			{
				if(nLabelLen+wsprintf(szTabLabel+nLabelLen, _T(" (%u)"), i) > nMaxLabelLen)
				{
					szFileName[nFilePathLen] = _T('\0');
					break;
				}

				lstrcpy(szFileName+nFilePathLen, szTabLabel);
				lstrcat(szFileName+nFilePathLen, _T(".asm"));
			}
		}
	}

	if(szFileName[nFilePathLen] == _T('\0'))
	{
		do
		{
			nTabsCreatedCounter++;
			wsprintf(szTabLabel, _T("%u"), nTabsCreatedCounter);

			lstrcpy(szFileName+nFilePathLen, szTabLabel);
			lstrcat(szFileName+nFilePathLen, _T(".asm"));
		}
		while(GetFileAttributes(szFileName) != INVALID_FILE_ATTRIBUTES || FindTabByLabel(hTabCtrlWnd, szTabLabel) != -1);
	}

	tci.header.mask = TCIF_TEXT|TCIF_PARAM;
	tci.header.pszText = szTabLabel;
	ZeroMemory(&tci.extra, sizeof(TCITEM_EXTRA));

	nTabCount = TabCtrl_GetItemCount(hTabCtrlWnd);

	TabCtrl_InsertItem(hTabCtrlWnd, nTabCount, &tci);
	TabCtrl_SetCurSel(hTabCtrlWnd, nTabCount);

	SendMessage(hAsmEditWnd, WM_SETTEXT, 0, (LPARAM)_T(""));

	ZeroMemory(&ftCurrentTabLastWriteTime, sizeof(FILETIME));

	WriteIntToPrivateIni(_T("tabs_counter"), nTabsCreatedCounter);
	WriteIntToPrivateIni(_T("tabs_last_open"), nTabCount);

	wsprintf(szStringKey, _T("tabs_file[%d]"), nTabCount);
	WriteStringToPrivateIni(szStringKey, szTabLabel);
}

void PrevTab(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	int nTabCount;
	int nTabIndex;

	nTabCount = TabCtrl_GetItemCount(hTabCtrlWnd);
	if(nTabCount > 1)
	{
		nTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);
		if(nTabIndex > 0)
			nTabIndex--;
		else
			nTabIndex = nTabCount-1;

		OnTabChanging(hTabCtrlWnd, hAsmEditWnd);
		TabCtrl_SetCurSel(hTabCtrlWnd, nTabIndex);
		OnTabChanged(hTabCtrlWnd, hAsmEditWnd);
	}
}

void NextTab(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	int nTabCount;
	int nTabIndex;

	nTabCount = TabCtrl_GetItemCount(hTabCtrlWnd);
	if(nTabCount > 1)
	{
		nTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);
		if(nTabIndex < nTabCount-1)
			nTabIndex++;
		else
			nTabIndex = 0;

		OnTabChanging(hTabCtrlWnd, hAsmEditWnd);
		TabCtrl_SetCurSel(hTabCtrlWnd, nTabIndex);
		OnTabChanged(hTabCtrlWnd, hAsmEditWnd);
	}
}

BOOL GetTabName(HWND hTabCtrlWnd, TCHAR *pText, int nTextBuffer)
{
	int nCurrentTabIndex;
	TCITEM_CUSTOM tci;

	nCurrentTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);
	if(nCurrentTabIndex != -1)
	{
		tci.header.mask = TCIF_TEXT;
		tci.header.pszText = pText;
		tci.header.cchTextMax = nTextBuffer;

		return TabCtrl_GetItem(hTabCtrlWnd, nCurrentTabIndex, &tci);
	}
	else
		return FALSE;
}

void CloseTab(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	CloseTabByIndex(hTabCtrlWnd, hAsmEditWnd, -1);
}

BOOL CloseTabOnPoint(HWND hTabCtrlWnd, HWND hAsmEditWnd, POINT *ppt)
{
	TCHITTESTINFO hti;
	int nTabIndex;

	hti.pt = *ppt;

	nTabIndex = TabCtrl_HitTest(hTabCtrlWnd, &hti);
	if(nTabIndex == -1)
		return FALSE;

	CloseTabByIndex(hTabCtrlWnd, hAsmEditWnd, nTabIndex);
	return TRUE;
}

void CloseTabByIndex(HWND hTabCtrlWnd, HWND hAsmEditWnd, int nTabIndex)
{
	BOOL bClosingCurrent;
	TCHAR szFileName[MAX_PATH];
	int nTabCount;
	TCITEM_CUSTOM tci;
	TCHAR szStringKey[32];
	int i;

	if(nTabIndex == -1)
	{
		nTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);
		bClosingCurrent = TRUE;
	}
	else
		bClosingCurrent = (nTabIndex == TabCtrl_GetCurSel(hTabCtrlWnd));

	GetTabFileName(hTabCtrlWnd, nTabIndex, szFileName);
	if(GetFileAttributes(szFileName) != INVALID_FILE_ATTRIBUTES)
		if(!DeleteFile(szFileName))
			PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Failed to delete file"));

	TabCtrl_DeleteItem(hTabCtrlWnd, nTabIndex);

	nTabCount = TabCtrl_GetItemCount(hTabCtrlWnd);

	tci.header.mask = TCIF_TEXT;
	tci.header.pszText = szFileName;
	tci.header.cchTextMax = MAX_PATH;

	for(i=nTabIndex; i<nTabCount; i++)
	{
		TabCtrl_GetItem(hTabCtrlWnd, i, &tci);

		wsprintf(szStringKey, _T("tabs_file[%d]"), i);
		WriteStringToPrivateIni(szStringKey, szFileName);
	}

	wsprintf(szStringKey, _T("tabs_file[%d]"), i);
	WriteStringToPrivateIni(szStringKey, NULL);

	if(bClosingCurrent)
	{
		if(nTabCount > 0)
		{
			if(nTabIndex > 0)
				TabCtrl_SetCurSel(hTabCtrlWnd, nTabIndex-1);
			else
				TabCtrl_SetCurSel(hTabCtrlWnd, 0);

			OnTabChanged(hTabCtrlWnd, hAsmEditWnd);
		}
		else
		{
			nTabsCreatedCounter = 0;
			NewTab(hTabCtrlWnd, hAsmEditWnd, NULL);
		}
	}
}

void CloseAllTabs(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	int nTabCount, nErrorCount;
	TCHAR szFileName[MAX_PATH];
	TCHAR szStringKey[32];
	int i;

	nTabCount = TabCtrl_GetItemCount(hTabCtrlWnd);
	nErrorCount = 0;

	for(i=0; i<nTabCount; i++)
	{
		GetTabFileName(hTabCtrlWnd, i, szFileName);
		if(GetFileAttributes(szFileName) != INVALID_FILE_ATTRIBUTES)
			if(!DeleteFile(szFileName))
				nErrorCount++;

		wsprintf(szStringKey, _T("tabs_file[%d]"), i);
		WriteStringToPrivateIni(szStringKey, NULL);
	}

	if(nErrorCount > 0)
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Failed to delete one or more of the files"));

	TabCtrl_DeleteAllItems(hTabCtrlWnd);

	nTabsCreatedCounter = 0;
	NewTab(hTabCtrlWnd, hAsmEditWnd, NULL);
}

BOOL OnContextMenu(HWND hTabCtrlWnd, HWND hAsmEditWnd, LPARAM lParam, POINT *ppt)
{
	TCHITTESTINFO hti;
	int nTabIndex, nCurrentTabIndex;
	RECT rc;

	nCurrentTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);

	if(lParam == -1)
	{
		TabCtrl_GetItemRect(hTabCtrlWnd, nCurrentTabIndex, &rc);
		ppt->x = rc.left + (rc.right - rc.left) / 2;
		ppt->y = rc.top + (rc.bottom - rc.top) / 2;

		ClientToScreen(hTabCtrlWnd, ppt);
	}
	else
	{
		hti.pt.x = GET_X_LPARAM(lParam);
		hti.pt.y = GET_Y_LPARAM(lParam);

		ScreenToClient(hTabCtrlWnd, &hti.pt);

		nTabIndex = TabCtrl_HitTest(hTabCtrlWnd, &hti);
		if(nTabIndex == -1)
			return FALSE;

		if(nTabIndex != nCurrentTabIndex)
		{
			OnTabChanging(hTabCtrlWnd, hAsmEditWnd);
			TabCtrl_SetCurSel(hTabCtrlWnd, nTabIndex);
			OnTabChanged(hTabCtrlWnd, hAsmEditWnd);
		}

		ppt->x = GET_X_LPARAM(lParam);
		ppt->y = GET_Y_LPARAM(lParam);
	}

	return TRUE;
}

void OnTabChanging(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	TCITEM_CUSTOM tci;

	tci.header.mask = TCIF_PARAM;
	SendMessage(hAsmEditWnd, EM_EXGETSEL, 0, (LPARAM)&tci.extra.char_range);
	tci.extra.first_visible_line = (int)SendMessage(hAsmEditWnd, EM_GETFIRSTVISIBLELINE, 0, 0);

	TabCtrl_SetItem(hTabCtrlWnd, TabCtrl_GetCurSel(hTabCtrlWnd), &tci);

	SaveFileOfTab(hTabCtrlWnd, hAsmEditWnd);
}

void OnTabChanged(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	TCITEM_CUSTOM tci;

	LoadFileOfTab(hTabCtrlWnd, hAsmEditWnd);

	tci.header.mask = TCIF_PARAM;

	TabCtrl_GetItem(hTabCtrlWnd, TabCtrl_GetCurSel(hTabCtrlWnd), &tci);
	SendMessage(hAsmEditWnd, EM_EXSETSEL, 0, (LPARAM)&tci.extra.char_range);
	SendMessage(hAsmEditWnd, EM_LINESCROLL, 0, tci.extra.first_visible_line);
	SendMessage(hAsmEditWnd, EM_SCROLLCARET, 0, 0);

	WriteIntToPrivateIni(_T("tabs_last_open"), TabCtrl_GetCurSel(hTabCtrlWnd));
}

void OnTabFileUpdated(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	int first_visible_line;
	CHARRANGE char_range;

	SendMessage(hAsmEditWnd, EM_EXGETSEL, 0, (LPARAM)&char_range);
	first_visible_line = (int)SendMessage(hAsmEditWnd, EM_GETFIRSTVISIBLELINE, 0, 0);

	LoadFileOfTab(hTabCtrlWnd, hAsmEditWnd);

	SendMessage(hAsmEditWnd, EM_EXSETSEL, 0, (LPARAM)&char_range);
	SendMessage(hAsmEditWnd, EM_LINESCROLL, 0, first_visible_line);
	SendMessage(hAsmEditWnd, EM_SCROLLCARET, 0, 0);
}

void TabRenameStart(HWND hTabCtrlWnd)
{
	int nMaxLabelLen;

	nMaxLabelLen = (MAX_PATH-1) - lstrlen(szTabFilesPath) - (sizeof(".asm")-1);
	TabCtrl_Ex_EditLabel(hTabCtrlWnd, nMaxLabelLen);
}

BOOL TabRenameEnd(HWND hTabCtrlWnd, TCHAR *pNewLabel)
{
	int nCurrentTabIndex;
	TCHAR szOldTabLabel[MAX_PATH];
	TCHAR szFileName[MAX_PATH];
	TCHAR szOldFileName[MAX_PATH];
	TCHAR szStringKey[32];
	TCITEM_CUSTOM tci;

	if(*pNewLabel == _T('\0'))
		return FALSE;

	MakeTabLabelValid(pNewLabel);

	nCurrentTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);

	tci.header.mask = TCIF_TEXT;
	tci.header.pszText = szOldTabLabel;
	tci.header.cchTextMax = MAX_PATH - lstrlen(szTabFilesPath) - (sizeof(".asm")-1);

	TabCtrl_GetItem(hTabCtrlWnd, nCurrentTabIndex, &tci);
	if(lstrcmp(szOldTabLabel, pNewLabel) == 0)
		return FALSE;

	if(FindTabByLabel(hTabCtrlWnd, pNewLabel) != -1)
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONHAND, (LPARAM)_T("Such tab already exists"));
		return FALSE;
	}

	lstrcpy(szFileName, szTabFilesPath);
	lstrcat(szFileName, pNewLabel);
	lstrcat(szFileName, _T(".asm"));

	if(lstrcmpi(szOldTabLabel, pNewLabel) != 0 && GetFileAttributes(szFileName) != INVALID_FILE_ATTRIBUTES)
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONHAND, (LPARAM)_T("Such file already exists"));
		return FALSE;
	}

	GetTabFileName(hTabCtrlWnd, -1, szOldFileName);

	if(GetFileAttributes(szOldFileName) != INVALID_FILE_ATTRIBUTES && !MoveFile(szOldFileName, szFileName))
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONHAND, (LPARAM)_T("Failed to rename file"));
		return FALSE;
	}

	wsprintf(szStringKey, _T("tabs_file[%d]"), TabCtrl_GetCurSel(hTabCtrlWnd));
	WriteStringToPrivateIni(szStringKey, pNewLabel);

	return TRUE;
}

BOOL OnTabDrag(HWND hTabCtrlWnd, int nDragFromId, int nDropToId)
{
	TCITEM_CUSTOM tci;
	TCHAR szTabLabel[MAX_PATH];
	int nTabIndex, nTabCount;
	TCHAR szStringKey[32];
	int i;

	WriteIntToPrivateIni(_T("tabs_last_open"), nDropToId);

	tci.header.mask = TCIF_TEXT;
	tci.header.pszText = szTabLabel;
	tci.header.cchTextMax = MAX_PATH;

	if(nDropToId > nDragFromId)
	{
		nTabIndex = nDragFromId;
		nTabCount = nDropToId-nDragFromId+1;
	}
	else
	{
		nTabIndex = nDropToId;
		nTabCount = nDragFromId-nDropToId+1;
	}

	for(i=0; i<nTabCount; i++)
	{
		TabCtrl_GetItem(hTabCtrlWnd, nTabIndex, &tci);

		wsprintf(szStringKey, _T("tabs_file[%d]"), nTabIndex);
		WriteStringToPrivateIni(szStringKey, szTabLabel);

		nTabIndex++;
	}

	return TRUE;
}

BOOL LoadFileOfTab(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	TCHAR szFileName[MAX_PATH];
	HANDLE hFile;
	OVERLAPPED overlapped;
	EDITSTREAM es;

	SendMessage(hAsmEditWnd, WM_SETTEXT, 0, (LPARAM)_T(""));

	GetTabFileName(hTabCtrlWnd, -1, szFileName);

	hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 
		NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		ZeroMemory(&ftCurrentTabLastWriteTime, sizeof(FILETIME));
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Could not read content of file"));
		return FALSE;
	}

	ZeroMemory(&overlapped, sizeof(OVERLAPPED));
	if(!LockFileEx(hFile, 0, 0, 0xFFFFFFFF, 0xFFFFFFFF, &overlapped))
	{
		CloseHandle(hFile);
		ZeroMemory(&ftCurrentTabLastWriteTime, sizeof(FILETIME));
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Could not lock file for reading"));
		return FALSE;
	}

	ZeroMemory(&es, sizeof(EDITSTREAM));
	es.dwCookie = (DWORD_PTR)hFile;
	es.pfnCallback = StreamInProc;

	SendMessage(hAsmEditWnd, EM_STREAMIN, SF_TEXT, (LPARAM)&es);

	UnlockFileEx(hFile, 0, 0xFFFFFFFF, 0xFFFFFFFF, &overlapped);
	CloseHandle(hFile);

	GetFileLastWriteTime(szFileName, &ftCurrentTabLastWriteTime);

	SendMessage(hAsmEditWnd, EM_SETMODIFY, FALSE, 0);

	return TRUE;
}

BOOL SaveFileOfTab(HWND hTabCtrlWnd, HWND hAsmEditWnd)
{
	TCHAR szFileName[MAX_PATH];
	HANDLE hFile;
	OVERLAPPED overlapped;
	EDITSTREAM es;

	if(!SendMessage(hAsmEditWnd, EM_GETMODIFY, 0, 0))
		return TRUE;

	if(!MakeSureDirectoryExists(szTabFilesPath))
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Could not create directory"));
		return FALSE;
	}

	GetTabFileName(hTabCtrlWnd, -1, szFileName);

	hFile = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
		NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Could not save content to file"));
		return FALSE;
	}

	ZeroMemory(&overlapped, sizeof(OVERLAPPED));
	if(!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, 0xFFFFFFFF, 0xFFFFFFFF, &overlapped))
	{
		CloseHandle(hFile);
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Could not lock file for writing"));
		return FALSE;
	}

	ZeroMemory(&es, sizeof(EDITSTREAM));
	es.dwCookie = (DWORD_PTR)hFile;
	es.pfnCallback = StreamOutProc;

	SendMessage(hAsmEditWnd, EM_STREAMOUT, SF_TEXT, (LPARAM)&es);

	UnlockFileEx(hFile, 0, 0xFFFFFFFF, 0xFFFFFFFF, &overlapped);
	CloseHandle(hFile);

	GetFileLastWriteTime(szFileName, &ftCurrentTabLastWriteTime);

	SendMessage(hAsmEditWnd, EM_SETMODIFY, FALSE, 0);

	return TRUE;
}

BOOL LoadFileFromLibrary(HWND hTabCtrlWnd, HWND hAsmEditWnd, HWND hWnd, HINSTANCE hInst)
{
	TCHAR *pOfnBuffer;
	OPENFILENAME ofn;
	TCHAR szFilePath[MAX_PATH];
	TCHAR *pFileNameSrc, *pFileNameDst, *pFileNameExt;
	HANDLE hFile;
	EDITSTREAM es;
	BOOL bAtLeastOneSucceeded;
	BOOL bMultipleFiles, bAtLeastOneFailed;

	pOfnBuffer = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, 1024*10*sizeof(TCHAR));
	if(!pOfnBuffer)
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONHAND, (LPARAM)_T("Memory allocation failed"));
		return FALSE;
	}

	ZeroMemory(&ofn, sizeof(OPENFILENAME));

	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = hInst;
	ofn.lpstrFilter = 
		_T("Assembler files (*.asm)\0*.asm\0")
		_T("All files (*.*)\0*.*\0");
	ofn.lpstrFile = pOfnBuffer;
	ofn.nMaxFile = 1024*10;
	ofn.lpstrTitle = _T("Load code from file");
	ofn.Flags = OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_ALLOWMULTISELECT|OFN_EXPLORER;
	ofn.lpstrDefExt = _T("asm");

	if(MakeSureDirectoryExists(szLibraryFilePath))
		ofn.lpstrInitialDir = szLibraryFilePath;

	*pOfnBuffer = _T('\0');

	bAtLeastOneSucceeded = FALSE;

	if(GetOpenFileName(&ofn))
	{
		pFileNameSrc = pOfnBuffer + ofn.nFileOffset;
		bMultipleFiles = (pFileNameSrc[-1] == _T('\0'));
		pFileNameSrc[-1] = _T('\0');

		lstrcpy(szFilePath, pOfnBuffer);

		pFileNameDst = szFilePath + ofn.nFileOffset;
		pFileNameDst[-1] = _T('\\');

		bAtLeastOneFailed = FALSE;

		if(bMultipleFiles)
			SendMessage(hWnd, WM_SETREDRAW, FALSE, 0);

		do
		{
			lstrcpy(pFileNameDst, pFileNameSrc);
			pFileNameSrc += lstrlen(pFileNameSrc)+1;

			hFile = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if(hFile != INVALID_HANDLE_VALUE)
			{
				bAtLeastOneSucceeded = TRUE;

				pFileNameExt = pFileNameDst + lstrlen(pFileNameDst);
				for(pFileNameExt--; pFileNameExt > pFileNameDst; pFileNameExt--)
				{
					if(*pFileNameExt == _T('.'))
					{
						*pFileNameExt = _T('\0');
						break;
					}
				}

				OnTabChanging(hTabCtrlWnd, hAsmEditWnd);
				NewTab(hTabCtrlWnd, hAsmEditWnd, pFileNameDst);

				ZeroMemory(&es, sizeof(EDITSTREAM));
				es.dwCookie = (DWORD_PTR)hFile;
				es.pfnCallback = StreamInProc;

				SendMessage(hAsmEditWnd, EM_STREAMIN, SF_TEXT, (LPARAM)&es);

				CloseHandle(hFile);
			}
			else
				bAtLeastOneFailed = TRUE;
		}
		while(*pFileNameSrc != _T('\0'));

		if(bMultipleFiles)
		{
			SendMessage(hWnd, WM_SETREDRAW, TRUE, 0);
			RedrawWindow(hWnd, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
		}

		if(bAtLeastOneFailed)
		{
			PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, 
				(LPARAM)(bMultipleFiles?_T("Could not read content of at least one of the files"):_T("Could not read content of file")));
		}
	}
	else if(CommDlgExtendedError() == FNERR_BUFFERTOOSMALL)
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONHAND, 
			(LPARAM)_T("Our buffer is too small for your gigantic assembly collection :("));
	}

	HeapFree(GetProcessHeap(), 0, pOfnBuffer);

	return bAtLeastOneSucceeded;
}

BOOL SaveFileToLibrary(HWND hTabCtrlWnd, HWND hAsmEditWnd, HWND hWnd, HINSTANCE hInst)
{
	TCITEM_CUSTOM tci;
	TCHAR szFileName[MAX_PATH];
	OPENFILENAME ofn;
	HANDLE hFile;
	EDITSTREAM es;

	tci.header.mask = TCIF_TEXT;
	tci.header.pszText = szFileName;
	tci.header.cchTextMax = MAX_PATH;

	TabCtrl_GetItem(hTabCtrlWnd, TabCtrl_GetCurSel(hTabCtrlWnd), &tci);

	ZeroMemory(&ofn, sizeof(OPENFILENAME));

	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hWnd;
	ofn.hInstance = hInst;
	ofn.lpstrFilter = 
		_T("Assembler files (*.asm)\0*.asm\0")
		_T("All files (*.*)\0*.*\0");
	ofn.lpstrFile = szFileName;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrTitle = _T("Save code to file");
	ofn.Flags = OFN_OVERWRITEPROMPT|OFN_HIDEREADONLY;
	ofn.lpstrDefExt = _T("asm");

	if(MakeSureDirectoryExists(szLibraryFilePath))
		ofn.lpstrInitialDir = szLibraryFilePath;

	if(!GetSaveFileName(&ofn))
		return FALSE;

	hFile = CreateFile(szFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		PostMessage(hPostErrorWnd, uPostErrorMsg, MB_ICONEXCLAMATION, (LPARAM)_T("Could not save content to file"));
		return FALSE;
	}

	ZeroMemory(&es, sizeof(EDITSTREAM));
	es.dwCookie = (DWORD_PTR)hFile;
	es.pfnCallback = StreamOutProc;

	SendMessage(hAsmEditWnd, EM_STREAMOUT, SF_TEXT, (LPARAM)&es);

	CloseHandle(hFile);

	return TRUE;
}

// General tab functions

static void MakeTabLabelValid(TCHAR *pLabel)
{
	TCHAR *pForbidden = _T("\\/:*?\"<>|");
	int i, j;

	for(i=0; pLabel[i] != _T('\0'); i++)
	{
		for(j=0; pForbidden[j] != _T('\0'); j++)
		{
			if(pLabel[i] == pForbidden[j])
			{
				pLabel[i] = _T('_');
				break;
			}
		}
	}
}

static void GetTabFileName(HWND hTabCtrlWnd, int nTabIndex, TCHAR *pFileName)
{
	int nFilePathLen;
	TCITEM_CUSTOM tci;

	if(nTabIndex == -1)
		nTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);

	lstrcpy(pFileName, szTabFilesPath);
	nFilePathLen = lstrlen(pFileName);

	tci.header.mask = TCIF_TEXT;
	tci.header.pszText = pFileName+nFilePathLen;
	tci.header.cchTextMax = MAX_PATH-nFilePathLen-(sizeof(".asm")-1);

	TabCtrl_GetItem(hTabCtrlWnd, nTabIndex, &tci);

	lstrcat(pFileName+nFilePathLen, _T(".asm"));
}

static int FindTabByLabel(HWND hTabCtrlWnd, TCHAR *pLabel)
{
	int tabs_count;
	int nTabIndex;
	TCHAR szTabLabel[MAX_PATH];
	TCITEM_CUSTOM tci;

	tabs_count = TabCtrl_GetItemCount(hTabCtrlWnd);

	tci.header.mask = TCIF_TEXT;
	tci.header.pszText = szTabLabel;
	tci.header.cchTextMax = MAX_PATH;

	for(nTabIndex = 0; nTabIndex < tabs_count; nTabIndex++)
	{
		TabCtrl_GetItem(hTabCtrlWnd, nTabIndex, &tci);
		if(lstrcmp(szTabLabel, pLabel) == 0)
			return nTabIndex;
	}

	return -1;
}

static void MoveTab(HWND hTabCtrlWnd, int nFromIndex, int nToIndex)
{
	TCITEM_CUSTOM tci;
	TCHAR szTabLabel[MAX_PATH];
	int nCurrentTabIndex;

	nCurrentTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);

	tci.header.mask = TCIF_TEXT|TCIF_PARAM; 
	tci.header.pszText = szTabLabel;
	tci.header.cchTextMax = MAX_PATH;

	TabCtrl_GetItem(hTabCtrlWnd, nFromIndex, &tci);
	TabCtrl_DeleteItem(hTabCtrlWnd, nFromIndex);
	TabCtrl_InsertItem(hTabCtrlWnd, nToIndex, &tci);
}

static DWORD CALLBACK StreamInProc(DWORD_PTR dwCookie, LPBYTE lpbBuff, LONG cb, LONG *pcb)
{
	if(!ReadFile((HANDLE)dwCookie, lpbBuff, cb, (DWORD *)pcb, NULL))
		return -1;

	return 0;
}

static DWORD CALLBACK StreamOutProc(DWORD_PTR dwCookie, LPBYTE lpbBuff, LONG cb, LONG *pcb)
{
	if(!WriteFile((HANDLE)dwCookie, lpbBuff, cb, (LPDWORD)pcb, NULL))
		return -1;

	return 0;
}

// Config functions

static UINT ReadIntFromPrivateIni(TCHAR *pKeyName, UINT nDefault)
{
	return GetPrivateProfileInt(_T("tabs"), pKeyName, nDefault, szConfigFilePath);
}

static BOOL WriteIntToPrivateIni(TCHAR *pKeyName, UINT nValue)
{
	TCHAR pStrInt[sizeof("4294967295")];

	if(!MakeSureDirectoryExists(szConfigFilePath))
		return FALSE;

	wsprintf(pStrInt, _T("%u"), nValue);
	if(!WritePrivateProfileString(_T("tabs"), pKeyName, pStrInt, szConfigFilePath))
		return FALSE;

	GetConfigLastWriteTime(&ftConfigLastWriteTime);
	return TRUE;
}

static DWORD ReadStringFromPrivateIni(TCHAR *pKeyName, TCHAR *pDefault, TCHAR *pReturnedString, DWORD dwStringSize)
{
	return GetPrivateProfileString(_T("tabs"), pKeyName, pDefault, pReturnedString, dwStringSize, szConfigFilePath);
}

static BOOL WriteStringToPrivateIni(TCHAR *pKeyName, TCHAR *pValue)
{
	if(!MakeSureDirectoryExists(szConfigFilePath))
		return FALSE;

	if(!WritePrivateProfileString(_T("tabs"), pKeyName, pValue, szConfigFilePath))
		return FALSE;

	GetConfigLastWriteTime(&ftConfigLastWriteTime);
	return TRUE;
}

static BOOL GetConfigLastWriteTime(FILETIME *pftLastWriteTime)
{
	return GetFileLastWriteTime(szConfigFilePath, pftLastWriteTime);
}

// General

static BOOL MakeSureDirectoryExists(TCHAR *pPathName)
{
	TCHAR szPathBuffer[MAX_PATH];
	DWORD dwBufferLen;
	TCHAR *pFileName, *pPathAfterDrive;
	TCHAR *p;
	DWORD dwAttributes;
	TCHAR chTemp;

	dwBufferLen = GetFullPathName(pPathName, MAX_PATH, szPathBuffer, &pFileName);
	if(dwBufferLen == 0 || dwBufferLen > MAX_PATH-1)
		return FALSE;

	if(szPathBuffer[0] == _T('\\') && szPathBuffer[1] == _T('\\'))
	{
		p = &szPathBuffer[2];

		while(*p != _T('\\'))
		{
			if(*p == _T('\0'))
				return FALSE;

			p++;
		}

		pPathAfterDrive = p;
	}
	else if(
		((szPathBuffer[0] >= _T('A') && szPathBuffer[0] <= _T('Z')) || (szPathBuffer[0] >= _T('a') && szPathBuffer[0] <= _T('z'))) && 
		szPathBuffer[1] == _T(':') && szPathBuffer[2] == _T('\\')
	)
		pPathAfterDrive = &szPathBuffer[2];
	else
		return FALSE;

	if(pFileName)
	{
		if(pFileName <= szPathBuffer || pFileName[-1] != _T('\\'))
			return FALSE;

		pFileName[0] = _T('\0');
		p = &pFileName[-1];
	}
	else
	{
		if(szPathBuffer[dwBufferLen-1] != _T('\\'))
			return FALSE;

		p = &szPathBuffer[dwBufferLen-1];
	}

	dwAttributes = GetFileAttributes(szPathBuffer);
	if(dwAttributes != INVALID_FILE_ATTRIBUTES)
		return (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

	do
	{
		*p = _T('\0');
		p--;

		if(p < pPathAfterDrive)
			return FALSE;

		while(*p != _T('\\'))
			p--;

		chTemp = p[1];
		p[1] = _T('\0');

		dwAttributes = GetFileAttributes(szPathBuffer);

		p[1] = chTemp;
	}
	while(dwAttributes == INVALID_FILE_ATTRIBUTES);

	if(!(dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
		return FALSE;

	do
	{
		p += lstrlen(p);
		*p = _T('\\');

		chTemp = p[1];
		p[1] = _T('\0');

		if(!CreateDirectory(szPathBuffer, NULL))
			return FALSE;

		p[1] = chTemp;
	}
	while(p[1] != _T('\0'));

	return TRUE;
}

static DWORD PathRelativeToModuleDir(HMODULE hModule, TCHAR *pRelativePath, TCHAR *pResult, BOOL bPathAddBackslash)
{
	TCHAR szPathBuffer[MAX_PATH];
	DWORD dwBufferLen;
	TCHAR *pFilePart;

	dwBufferLen = GetModuleFileName(hModule, szPathBuffer, MAX_PATH);
	if(dwBufferLen == 0)
		return 0;

	do
	{
		dwBufferLen--;

		if(dwBufferLen == 0)
			return 0;
	}
	while(szPathBuffer[dwBufferLen] != _T('\\'));

	dwBufferLen++;
	szPathBuffer[dwBufferLen] = _T('\0');

	dwBufferLen += lstrlen(pRelativePath);
	if(dwBufferLen > MAX_PATH-1)
		return 0;

	lstrcat(szPathBuffer, pRelativePath);

	dwBufferLen = GetFullPathName(szPathBuffer, MAX_PATH, pResult, &pFilePart);
	if(dwBufferLen == 0 || dwBufferLen > MAX_PATH-1)
		return 0;

	if(bPathAddBackslash && pResult[dwBufferLen-1] != _T('\\'))
	{
		if(dwBufferLen == MAX_PATH-1)
			return 0;

		pResult[dwBufferLen] = _T('\\');
		pResult[dwBufferLen+1] = _T('\0');
		dwBufferLen++;
	}

	return dwBufferLen;
}

static BOOL GetFileLastWriteTime(TCHAR *pFilePath, FILETIME *pftLastWriteTime)
{
	HANDLE hFind;
	WIN32_FIND_DATA find_data;

	hFind = FindFirstFile(pFilePath, &find_data);
	if(!hFind)
	{
		ZeroMemory(pftLastWriteTime, sizeof(FILETIME));
		return FALSE;
	}

	*pftLastWriteTime = find_data.ftLastWriteTime;

	FindClose(hFind);
	return TRUE;
}



================================================
File: assembler_dlg_tabs.h
================================================
#ifndef _ASSEMBLER_DLG_TABS_H_
#define _ASSEMBLER_DLG_TABS_H_

#include "plugin.h"
#include "raedit.h"
#include "tabctrl_ex.h"
#include "resource.h"

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lParam)	 ((int)(short)LOWORD(lParam))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lParam)	 ((int)(short)HIWORD(lParam))
#endif

typedef struct _tcitem_extra {
	int first_visible_line;
	CHARRANGE char_range;
} TCITEM_EXTRA;

typedef struct _tcitem_custom {
	TCITEMHEADER header;
	TCITEM_EXTRA extra;
} TCITEM_CUSTOM;

void InitTabs(HWND hTabCtrlWnd, HWND hAsmEditWnd, HINSTANCE hInst, HWND hErrorWnd, UINT uErrorMsg);
int InitLoadTabs(HWND hTabCtrlWnd);
void SyncTabs(HWND hTabCtrlWnd, HWND hAsmEditWnd);
void NewTab(HWND hTabCtrlWnd, HWND hAsmEditWnd, TCHAR *pTabLabel);
void PrevTab(HWND hTabCtrlWnd, HWND hAsmEditWnd);
void NextTab(HWND hTabCtrlWnd, HWND hAsmEditWnd);
BOOL GetTabName(HWND hTabCtrlWnd, TCHAR *pText, int nTextBuffer);
void CloseTab(HWND hTabCtrlWnd, HWND hAsmEditWnd);
BOOL CloseTabOnPoint(HWND hTabCtrlWnd, HWND hAsmEditWnd, POINT *ppt);
void CloseTabByIndex(HWND hTabCtrlWnd, HWND hAsmEditWnd, int nTabIndex);
void CloseAllTabs(HWND hTabCtrlWnd, HWND hAsmEditWnd);
BOOL OnContextMenu(HWND hTabCtrlWnd, HWND hAsmEditWnd, LPARAM lParam, POINT *ppt);
void OnTabChanging(HWND hTabCtrlWnd, HWND hAsmEditWnd);
void OnTabChanged(HWND hTabCtrlWnd, HWND hAsmEditWnd);
void OnTabFileUpdated(HWND hTabCtrlWnd, HWND hAsmEditWnd);
void TabRenameStart(HWND hTabCtrlWnd);
BOOL TabRenameEnd(HWND hTabCtrlWnd, TCHAR *pNewName);
BOOL OnTabDrag(HWND hTabCtrlWnd, int nDragFromId, int nDropToId);
BOOL LoadFileOfTab(HWND hTabCtrlWnd, HWND hAsmEditWnd);
BOOL SaveFileOfTab(HWND hTabCtrlWnd, HWND hAsmEditWnd);
BOOL LoadFileFromLibrary(HWND hTabCtrlWnd, HWND hAsmEditWnd, HWND hWnd, HINSTANCE hInst);
BOOL SaveFileToLibrary(HWND hTabCtrlWnd, HWND hAsmEditWnd, HWND hWnd, HINSTANCE hInst);

// General tab functions
static void MakeTabLabelValid(TCHAR *pLabel);
static void GetTabFileName(HWND hTabCtrlWnd, int nTabIndex, TCHAR *pFileName);
static int FindTabByLabel(HWND hTabCtrlWnd, TCHAR *pLabel);
static void MoveTab(HWND hTabCtrlWnd, int nFromIndex, int nToIndex);
static DWORD CALLBACK StreamInProc(DWORD_PTR dwCookie, LPBYTE lpbBuff, LONG cb, LONG *pcb);
static DWORD CALLBACK StreamOutProc(DWORD_PTR dwCookie, LPBYTE lpbBuff, LONG cb, LONG *pcb);

// Config functions
static UINT ReadIntFromPrivateIni(TCHAR *pKeyName, UINT nDefault);
static BOOL WriteIntToPrivateIni(TCHAR *pKeyName, UINT nValue);
static DWORD ReadStringFromPrivateIni(TCHAR *pKeyName, TCHAR *pDefault, TCHAR *pReturnedString, DWORD dwStringSize);
static BOOL WriteStringToPrivateIni(TCHAR *pKeyName, TCHAR *pValue);
static BOOL GetConfigLastWriteTime(FILETIME *pftLastWriteTime);

// General
static BOOL MakeSureDirectoryExists(TCHAR *pPathName);
static DWORD PathRelativeToModuleDir(HMODULE hModule, TCHAR *pRelativePath, TCHAR *pResult, BOOL bPathAddBackslash);
static BOOL GetFileLastWriteTime(TCHAR *pFilePath, FILETIME *pftLastWriteTime);

#endif // _ASSEMBLER_DLG_TABS_H_



================================================
File: functions.c
================================================
#include "stdafx.h"
#include "functions.h"

void **FindImportPtr(HMODULE hFindInModule, char *pModuleName, char *pImportName)
{
	IMAGE_DOS_HEADER *pDosHeader;
	IMAGE_NT_HEADERS *pNtHeader;
	ULONG_PTR ImageBase;
	IMAGE_IMPORT_DESCRIPTOR *pImportDescriptor;
	ULONG_PTR *pOriginalFirstThunk;
	ULONG_PTR *pFirstThunk;
	ULONG_PTR ImageImportByName;

	// Init
	pDosHeader = (IMAGE_DOS_HEADER *)hFindInModule;
	pNtHeader = (IMAGE_NT_HEADERS *)((char *)pDosHeader + pDosHeader->e_lfanew);

	if(!pNtHeader->OptionalHeader.DataDirectory[1].VirtualAddress)
		return NULL;

	ImageBase = (ULONG_PTR)hFindInModule;
	pImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR *)(ImageBase + pNtHeader->OptionalHeader.DataDirectory[1].VirtualAddress);

	// Search!
	while(pImportDescriptor->OriginalFirstThunk)
	{
		if(lstrcmpiA((char *)(ImageBase + pImportDescriptor->Name), pModuleName) == 0)
		{
			pOriginalFirstThunk = (ULONG_PTR *)(ImageBase + pImportDescriptor->OriginalFirstThunk);
			ImageImportByName = *pOriginalFirstThunk;

			pFirstThunk = (ULONG_PTR *)(ImageBase + pImportDescriptor->FirstThunk);

			while(ImageImportByName)
			{
				if(!(ImageImportByName & IMAGE_ORDINAL_FLAG))
				{
					if((ULONG_PTR)pImportName & ~0xFFFF)
					{
						ImageImportByName += sizeof(WORD);

						if(lstrcmpA((char *)(ImageBase + ImageImportByName), pImportName) == 0)
							return (void **)pFirstThunk;
					}
				}
				else
				{
					if(((ULONG_PTR)pImportName & ~0xFFFF) == 0)
						if((ImageImportByName & 0xFFFF) == (ULONG_PTR)pImportName)
							return (void **)pFirstThunk;
				}

				pOriginalFirstThunk++;
				ImageImportByName = *pOriginalFirstThunk;

				pFirstThunk++;
			}
		}

		pImportDescriptor++;
	}

	return NULL;
}



================================================
File: functions.h
================================================
#ifndef _FUNCTIONS_H_
#define _FUNCTIONS_H_

void **FindImportPtr(HMODULE hFindInModule, char *pModuleName, char *pImportName);

#endif // _FUNCTIONS_H_



================================================
File: main_common.c
================================================
#include "stdafx.h"
#include "main_common.h"
#include "plugin.h"
#include "raedit.h"
#include "assembler_dlg.h"
#include "resource.h"

HINSTANCE hDllInst;
OPTIONS options;

BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	switch(fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		DisableThreadLibraryCalls(hinstDLL);
		hDllInst = hinstDLL;
		break;

	case DLL_PROCESS_DETACH:
		break;
	}

	return TRUE;
}

TCHAR *PluginInit(HINSTANCE hInst)
{
	INITCOMMONCONTROLSEX icex;
	TCHAR *pError;

	// Ensure that the common control DLL is loaded.
	icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icex.dwICC = ICC_TAB_CLASSES;
	InitCommonControlsEx(&icex);

	// For drag'n'drop support
	if(FAILED(OleInitialize(NULL)))
		return _T("OleInitialize() failed");

	// Install RAEdit control
	InstallRAEdit(hInst, FALSE);

	// Init stuff
	pError = AssemblerInit();
	if(pError)
	{
		UnInstallRAEdit();
		return pError;
	}

	// Load options
	MyGetintfromini(hInst, _T("disasm_rva"), &options.disasm_rva, 0, 0, 1);
	MyGetintfromini(hInst, _T("disasm_rva_reloconly"), &options.disasm_rva_reloconly, 0, 0, 1);
	MyGetintfromini(hInst, _T("disasm_label"), &options.disasm_label, 0, 0, 1);
	MyGetintfromini(hInst, _T("disasm_extjmp"), &options.disasm_extjmp, 0, 0, 1);
	MyGetintfromini(hInst, _T("disasm_hex"), &options.disasm_hex, 0, 4, 0);
	MyGetintfromini(hInst, _T("disasm_labelgen"), &options.disasm_labelgen, 0, 2, 0);
	MyGetintfromini(hInst, _T("asm_comments"), &options.asm_comments, 0, 0, 1);
	MyGetintfromini(hInst, _T("asm_labels"), &options.asm_labels, 0, 0, 1);
	MyGetintfromini(hInst, _T("edit_savepos"), &options.edit_savepos, 0, 0, 1);
	MyGetintfromini(hInst, _T("edit_tabwidth"), &options.edit_tabwidth, 0, 2, 1);

	return NULL;
}

void PluginExit()
{
	AssemblerExit();
	UnInstallRAEdit();
	OleUninitialize();
}

BOOL OpenHelp(HWND hWnd, HINSTANCE hInst)
{
	TCHAR szFilePath[MAX_PATH];
	DWORD dwPathLen;

	dwPathLen = GetModuleFileName(hInst, szFilePath, MAX_PATH);
	if(dwPathLen == 0)
		return FALSE;

	do
	{
		dwPathLen--;

		if(dwPathLen == 0)
			return FALSE;
	}
	while(szFilePath[dwPathLen] != _T('\\'));

	dwPathLen++;
	szFilePath[dwPathLen] = _T('\0');

	dwPathLen += sizeof("multiasm.chm") - 1;
	if(dwPathLen > MAX_PATH - 1)
		return FALSE;

	lstrcat(szFilePath, _T("multiasm.chm"));

	return !((int)(UINT_PTR)ShellExecute(hWnd, NULL, szFilePath, NULL, NULL, SW_SHOWNORMAL) <= 32);
}

#if !(defined(TARGET_ODBG) || defined(TARGET_IMMDBG) || defined(TARGET_ODBG2))
void OpenUrl(HWND hWnd, PCWSTR url) {
	if((INT_PTR)ShellExecuteW(hWnd, L"open", url, NULL, NULL, SW_SHOWNORMAL) <= 32) {
		MessageBox(hWnd, _T("Failed to open link"), NULL, MB_ICONHAND);
	}
}

HRESULT CALLBACK AboutMessageBoxCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData) {
	switch(msg) {
	case TDN_HYPERLINK_CLICKED:
		OpenUrl(hwnd, (PCWSTR)lParam);
		break;
	}

	return S_OK;
}
#endif // !(defined(TARGET_ODBG) || defined(TARGET_IMMDBG) || defined(TARGET_ODBG2))

int AboutMessageBox(HWND hWnd, HINSTANCE hInst)
{
	// OllyDbg doesn't use visual styles, so TaskDialogIndirect isn't available.
#if defined(TARGET_ODBG) || defined(TARGET_IMMDBG) || defined(TARGET_ODBG2)
	PCWSTR content =
		DEF_PLUGINNAME _T(" v") DEF_VERSION _T("\n")
		_T("By m417z (Ramen Software)\n")
		_T("\n")
		_T("Source code:\n")
		_T("https://github.com/m417z/Multiline-Ultimate-Assembler");

	MSGBOXPARAMS mbpMsgBoxParams;

	ZeroMemory(&mbpMsgBoxParams, sizeof(MSGBOXPARAMS));

	mbpMsgBoxParams.cbSize = sizeof(MSGBOXPARAMS);
	mbpMsgBoxParams.hwndOwner = hWnd;
	mbpMsgBoxParams.hInstance = hInst;
	mbpMsgBoxParams.lpszText = content;
	mbpMsgBoxParams.lpszCaption = _T("About");
	mbpMsgBoxParams.dwStyle = MB_USERICON;
	mbpMsgBoxParams.lpszIcon = MAKEINTRESOURCE(IDI_MAIN);

	return MessageBoxIndirect(&mbpMsgBoxParams);
#else
	PCWSTR content =
		DEF_PLUGINNAME L" v" DEF_VERSION L"\n"
		L"By m417z (<A HREF=\"https://ramensoftware.com/\">Ramen Software</A>)\n"
		L"\n"
		L"Source code:\n"
		L"<A HREF=\"https://github.com/m417z/Multiline-Ultimate-Assembler\">https://github.com/m417z/Multiline-Ultimate-Assembler</a>";

	TASKDIALOGCONFIG taskDialogConfig;

	ZeroMemory(&taskDialogConfig, sizeof(TASKDIALOGCONFIG));

	taskDialogConfig.cbSize = sizeof(taskDialogConfig);
	taskDialogConfig.hwndParent = hWnd;
	taskDialogConfig.hInstance = hInst;
	taskDialogConfig.dwFlags = TDF_ENABLE_HYPERLINKS | TDF_ALLOW_DIALOG_CANCELLATION;
	taskDialogConfig.pszWindowTitle = L"About";
	taskDialogConfig.pszMainIcon = MAKEINTRESOURCEW(IDI_MAIN);
	taskDialogConfig.pszContent = content;
	taskDialogConfig.pfCallback = AboutMessageBoxCallback;

	return TaskDialogIndirect(&taskDialogConfig, NULL, NULL, NULL);
#endif
}



================================================
File: main_common.h
================================================
#pragma once

TCHAR *PluginInit(HINSTANCE hInst);
void PluginExit();
BOOL OpenHelp(HWND hWnd, HINSTANCE hInst);
int AboutMessageBox(HWND hWnd, HINSTANCE hInst);



================================================
File: main_odbg_v1.c
================================================
#include "stdafx.h"
#include "main_common.h"
#include "plugin.h"
#include "assembler_dlg.h"
#include "options_dlg.h"
#include "functions.h"
#include "pointer_redirection.h"

extern HINSTANCE hDllInst;

// hooks
static void **ppTranslateMDISysAccel;
POINTER_REDIRECTION_VAR(static POINTER_REDIRECTION prTranslateMDISysAccel);

// PreTranslateMessage
static BOOL RegisterPreTranslateMessage();
static void UnregisterPreTranslateMessage();
static BOOL WINAPI TranslateMDISysAccelHook(HWND hWndClient, LPMSG lpMsg);

// ODBG_Plugindata() is a "must" for valid OllyDbg plugin. It must fill in
// plugin name and return version of plugin interface. If function is absent,
// or version is not compatible, plugin will be not installed. Short name
// identifies it in the Plugins menu. This name is max. 31 alphanumerical
// characters or spaces + terminating '\0' long. To keep life easy for users,
// this name should be descriptive and correlate with the name of DLL.
extc int _export cdecl ODBG_Plugindata(char shortname[32])
{
	lstrcpy(shortname, DEF_PLUGINNAME); // Name of plugin
	return PLUGIN_VERSION;
}

// OllyDbg calls this obligatory function once during startup. Place all
// one-time initializations here. If all resources are successfully allocated,
// function must return 0. On error, it must free partially allocated resources
// and return -1, in this case plugin will be removed. Parameter ollydbgversion
// is the version of OllyDbg, use it to assure that it is compatible with your
// plugin; hw is the handle of main OllyDbg window, keep it if necessary.
// Parameter features is reserved for future extentions, do not use it.
extc int _export cdecl ODBG_Plugininit(int ollydbgversion, HWND hWnd, ulong *features)
{
	char *pError;

	// This plugin uses all the newest features, check that version of OllyDbg is
	// correct. I will try to keep backward compatibility at least to v1.99.
	if(ollydbgversion < PLUGIN_VERSION)
		return -1;

	// Keep handle of main OllyDbg window. This handle is necessary, for example,
	// to display message box.
	hwollymain = hWnd;

	// Init stuff
	pError = PluginInit(hDllInst);

	if(!pError && !RegisterPreTranslateMessage())
	{
		PluginExit();
		pError = "Couldn't register the PreTranslateMessage callback function";
	}

	if(pError)
	{
		MessageBox(hWnd, pError, "Multiline Ultimate Assembler error", MB_ICONHAND);
		return -1;
	}

	// Plugin successfully initialized. Now is the best time to report this fact
	// to the log window. To conform OllyDbg look and feel, please use two lines.
	// The first, in black, should describe plugin, the second, gray and indented
	// by two characters, bears copyright notice.
	Addtolist(0, 0, "Multiline Ultimate Assembler v" DEF_VERSION);
	Addtolist(0, -1, "  " DEF_COPYRIGHT);

	return 0;
}

// Function adds items either to main OllyDbg menu (origin=PM_MAIN) or to popup
// menu in one of standard OllyDbg windows. When plugin wants to add own menu
// items, it gathers menu pattern in data and returns 1, otherwise it must
// return 0. Except for static main menu, plugin must not add inactive items.
// Item indices must range in 0..63. Duplicated indices are explicitly allowed.
extc int _export cdecl ODBG_Pluginmenu(int origin, char data[4096], void *item)
{
	t_dump *pd;

	// Menu creation is very simple. You just fill in data with menu pattern.
	// Some examples:
	// 0 Aaa,2 Bbb|3 Ccc|,,  - linear menu with 3items, relative IDs 0, 2 and 3,
	//                         separator between second and third item, last
	//                         separator and commas are ignored;
	// #A{0Aaa,B{1Bbb|2Ccc}} - unconditional separator, followed by popup menu
	//                         A with two elements, second is popup with two
	//                         elements and separator inbetween.

	switch(origin)
	{
	case PM_MAIN: // Plugin menu in main window
		lstrcpy(data, "0 &Multiline Ultimate Assembler\tCtrl+M|1 &Options|2 &Help,3 &About");
		// If your plugin is more than trivial, I also recommend to include Help.
		return 1;

	case PM_DISASM: // Popup menu in Disassembler
		// First check that menu applies.
		pd = (t_dump *)item;
		if(!pd || pd->size == 0)
			return 0; // Window empty, don't add

		// Menu item
		lstrcpy(data, "0 &Multiline Ultimate Assembler\tCtrl+Shift+M");
		return 1;
	}

	return 0; // Window not supported by plugin
}

// This optional function receives commands from plugin menu in window of type
// origin. Argument action is menu identifier from ODBG_Pluginmenu(). If user
// activates automatically created entry in main menu, action is 0.
extc void _export cdecl ODBG_Pluginaction(int origin, int action, void *item)
{
	t_dump *pd;

	switch(origin)
	{
	case PM_MAIN:
		switch(action)
		{
		case 0:
			// Menu item, main plugin functionality
			AssemblerShowDlg();
			break;

		case 1:
			// Menu item "Options"
			if(ShowOptionsDlg())
				AssemblerOptionsChanged();
			break;

		case 2:
			// Menu item "Help"
			if(!OpenHelp(hwollymain, hDllInst))
				MessageBox(hwollymain, "Failed to open the \"multiasm.chm\" help file", NULL, MB_ICONHAND);
			break;

		case 3:
			// Menu item "About", displays plugin info.
			AboutMessageBox(hwollymain, hDllInst);
			break;
		}
		break;

	case PM_DISASM:
		if(action == 0)
		{
			pd = (t_dump *)item;

			AssemblerLoadCode(pd->sel0, pd->sel1 - pd->sel0);
		}
		break;
	}
}

// This function receives possible keyboard shortcuts from standard OllyDbg
// windows. If it recognizes shortcut, it must process it and return 1,
// otherwise it returns 0.
extc int _export cdecl ODBG_Pluginshortcut(int origin, int ctrl, int alt, int shift, int key, void *item)
{
	t_dump *pd;

	if(key == 'M' && ctrl && !alt)
	{
		if(!shift)
		{
			AssemblerShowDlg();
			return 1;
		}
		else if(origin == PM_DISASM)
		{
			pd = (t_dump *)item;

			AssemblerLoadCode(pd->sel0, pd->sel1 - pd->sel0);
			return 1;
		}
	}

	return 0;
}

// OllyDbg calls this optional function when user wants to terminate OllyDbg.
// All MDI windows created by plugins still exist. Function must return 0 if
// it is safe to terminate. Any non-zero return will stop closing sequence. Do
// not misuse this possibility! Always inform user about the reasons why
// termination is not good and ask for his decision!
extc int _export cdecl ODBG_Pluginclose(void)
{
	AssemblerCloseDlg();
	return 0;
}

// OllyDbg calls this optional function once on exit. At this moment, all MDI
// windows created by plugin are already destroyed (and received WM_DESTROY
// messages). Function must free all internally allocated resources, like
// window classes, files, memory and so on.
extc void _export cdecl ODBG_Plugindestroy(void)
{
	UnregisterPreTranslateMessage();
	PluginExit();
}

// PreTranslateMessage

static BOOL RegisterPreTranslateMessage()
{
	// Below is a hack, which allows us to define a PreTranslateMessage-like function.
	// We hook the TranslateMDISysAccel function, and use it to do our pre-translation.

	HMODULE hMainModule = GetModuleHandle(NULL);

	ppTranslateMDISysAccel = FindImportPtr(hMainModule, "user32.dll", "TranslateMDISysAccel");
	if(!ppTranslateMDISysAccel)
	{
		// 0x10D984 is the RVA of the pointer to TranslateMDISysAccel in OllyDbg v1.10
		// We use this hack in case there's no import table, e.g. OllyDbg is compressed
		void **pp = (void **)((char *)hMainModule + 0x10D984);
		void *p;
		size_t nNumberOfBytesRead;
		if(!ReadProcessMemory(GetCurrentProcess(), pp, &p, sizeof(void *), &nNumberOfBytesRead) || 
			nNumberOfBytesRead != sizeof(void *) || 
			p != TranslateMDISysAccel)
		{
			return FALSE;
		}

		ppTranslateMDISysAccel = pp;
	}

	PointerRedirectionAdd(ppTranslateMDISysAccel, TranslateMDISysAccelHook, &prTranslateMDISysAccel);
	return TRUE;
}

static void UnregisterPreTranslateMessage()
{
	PointerRedirectionRemove(ppTranslateMDISysAccel, &prTranslateMDISysAccel);
}

static BOOL WINAPI TranslateMDISysAccelHook(HWND hWndClient, LPMSG lpMsg)
{
	if(AssemblerPreTranslateMessage(lpMsg))
		return TRUE;

	return ((BOOL(WINAPI *)(HWND, LPMSG))prTranslateMDISysAccel.pOriginalAddress)(hWndClient, lpMsg);
}



================================================
File: main_odbg_v2.c
================================================
#include "stdafx.h"
#include "main_common.h"
#include "plugin.h"
#include "assembler_dlg.h"
#include "options_dlg.h"
#include "functions.h"
#include "pointer_redirection.h"

extern HINSTANCE hDllInst;

// hooks
static void **ppTranslateMDISysAccel;
POINTER_REDIRECTION_VAR(static POINTER_REDIRECTION prTranslateMDISysAccel);

static int __cdecl MainMenuFunc(t_table *pt, wchar_t *name, ulong index, int mode);
static int __cdecl DisasmMenuFunc(t_table *pt, wchar_t *name, ulong index, int mode);

// PreTranslateMessage
static BOOL RegisterPreTranslateMessage();
static void UnregisterPreTranslateMessage();
static BOOL WINAPI TranslateMDISysAccelHook(HWND hWndClient, LPMSG lpMsg);

// ODBG2_Pluginquery() is a "must" for valid OllyDbg plugin. It must check
// whether given OllyDbg version is correctly supported, and return 0 if not.
// Then it should fill plugin name and plugin version (as UNICODE strings) and
// return version of expected plugin interface. If OllyDbg decides that this
// plugin is not compatible, it will be unloaded. Plugin name identifies it
// in the Plugins menu. This name is max. 31 alphanumerical UNICODE characters
// or spaces + terminating L'\0' long. To keep life easy for users, name must
// be descriptive and correlate with the name of DLL. Parameter features is
// reserved for the future. I plan that features[0] will contain the number
// of additional entries in features[]. Attention, this function should not
// call any API functions: they may be incompatible with the version of plugin!
extc int __cdecl ODBG2_Pluginquery(int ollydbgversion, ulong *features,
	wchar_t pluginname[SHORTNAME], wchar_t pluginversion[SHORTNAME])
{
	// Check whether OllyDbg has compatible version. This plugin uses only the
	// most basic functions, so this check is done pro forma, just to remind of
	// this option.
	if(ollydbgversion < 201)
		return 0;

	// Report name and version to OllyDbg.
	lstrcpy(pluginname, DEF_PLUGINNAME); // Name of plugin
	lstrcpy(pluginversion, DEF_VERSION); // Version of plugin

	return PLUGIN_VERSION; // Expected API version
}

// Optional entry, called immediately after ODBG2_Pluginquery(). Plugin should
// make one-time initializations and allocate resources. On error, it must
// clean up and return -1. On success, it must return 0.
extc int __cdecl ODBG2_Plugininit(void)
{
	WCHAR *pError;

	pError = PluginInit(hDllInst);

	if(!pError && !RegisterPreTranslateMessage())
	{
		PluginExit();
		pError = L"Couldn't register the PreTranslateMessage callback function";
	}

	if(pError)
	{
		MessageBox(hwollymain, pError, L"Multiline Ultimate Assembler error", MB_ICONHAND);
		return -1;
	}

	return 0;
}

// Adds items either to main OllyDbg menu (type=PWM_MAIN) or to popup menu in
// one of the standard OllyDbg windows, like PWM_DISASM or PWM_MEMORY. When
// type matches, plugin should return address of menu. When there is no menu of
// given type, it must return NULL. If menu includes single item, it will
// appear directly in menu, otherwise OllyDbg will create a submenu with the
// name of plugin. Therefore, if there is only one item, make its name as
// descriptive as possible.
extc t_menu * __cdecl ODBG2_Pluginmenu(wchar_t *type)
{
	static t_menu mainmenu[] = {
			{ L"&Multiline Ultimate Assembler",
			L"Open Multiline Ultimate Assembler",
			KK_DIRECT | KK_CTRL | 'M', MainMenuFunc, NULL, 0 },
			{ L"|&Options",
			L"Show Multiline Ultimate Assembler options",
			K_NONE, MainMenuFunc, NULL, 1 },
			{ L"|&Help",
			L"Show help",
			K_NONE, MainMenuFunc, NULL, 2 },
			{ L"&About",
			L"About Multiline Ultimate Assembler",
			K_NONE, MainMenuFunc, NULL, 3 },
			{ NULL, NULL, K_NONE, NULL, NULL, 0 }
	};
	static t_menu disasmmenu[] = {
			{ L"&Multiline Ultimate Assembler",
			L"Disassemble with Multiline Ultimate Assembler",
			KK_DIRECT | KK_CTRL | KK_SHIFT | 'M', DisasmMenuFunc, NULL, 0 },
			{ NULL, NULL, K_NONE, NULL, NULL, 0 }
	};

	if(lstrcmp(type, PWM_MAIN) == 0)
		return mainmenu;
	else if(lstrcmp(type, PWM_DISASM) == 0)
		return disasmmenu;

	return NULL;
}

// OllyDbg calls this optional function when user wants to terminate OllyDbg.
// All MDI windows created by plugins still exist. Function must return 0 if
// it is safe to terminate. Any non-zero return will stop closing sequence. Do
// not misuse this possibility! Always inform user about the reasons why
// termination is not good and ask for his decision! Attention, don't make any
// unrecoverable actions for the case that some other plugin will decide that
// OllyDbg should continue running.
extc int __cdecl ODBG2_Pluginclose(void)
{
	AssemblerCloseDlg();
	return 0;
}

// OllyDbg calls this optional function once on exit. At this moment, all MDI
// windows created by plugin are already destroyed (and received WM_DESTROY
// messages). Function must free all internally allocated resources, like
// window classes, files, memory etc.
extc void __cdecl ODBG2_Plugindestroy(void)
{
	UnregisterPreTranslateMessage();
	PluginExit();
}

static int __cdecl MainMenuFunc(t_table *pt, wchar_t *name, ulong index, int mode)
{
	switch(mode)
	{
	case MENU_VERIFY:
		return MENU_NORMAL; // Always available

	case MENU_EXECUTE:
		switch(index)
		{
		case 0:
			// Menu item, main plugin functionality
			AssemblerShowDlg();
			break;

		case 1:
			// Debuggee should continue execution while dialog is displayed.
			Resumeallthreads();

			// Menu item "Options"
			if(ShowOptionsDlg())
				AssemblerOptionsChanged();

			// Suspendallthreads() and Resumeallthreads() must be paired, even if they
			// are called in inverse order!
			Suspendallthreads();
			break;

		case 2:
			if(!OpenHelp(hwollymain, hDllInst))
			{
				// Debuggee should continue execution while message box is displayed.
				Resumeallthreads();

				// Menu item "Help"
				MessageBox(hwollymain, L"Failed to open the \"multiasm.chm\" help file", NULL, MB_ICONHAND);

				// Suspendallthreads() and Resumeallthreads() must be paired, even if they
				// are called in inverse order!
				Suspendallthreads();
			}
			break;

		case 3:
			// Debuggee should continue execution while message box is displayed.
			Resumeallthreads();

			// Menu item "About", displays plugin info.
			AboutMessageBox(hwollymain, hDllInst);

			// Suspendallthreads() and Resumeallthreads() must be paired, even if they
			// are called in inverse order!
			Suspendallthreads();
			break;
		}

		return MENU_NOREDRAW;
	}

	return MENU_ABSENT;
}

static int __cdecl DisasmMenuFunc(t_table *pt, wchar_t *name, ulong index, int mode)
{
	t_dump *pd;

	// Get dump descriptor. This operation is common for both calls.
	if(!pt || !pt->customdata)
		return MENU_ABSENT;

	pd = (t_dump *)pt->customdata;

	// Check whether selection is defined.
	if(pd->sel0 >= pd->sel1)
		return MENU_ABSENT;

	switch(mode)
	{
	case MENU_VERIFY:
		return MENU_NORMAL;

	case MENU_EXECUTE:
		AssemblerLoadCode(pd->sel0, pd->sel1 - pd->sel0);
		return MENU_NOREDRAW;
	}

	return MENU_ABSENT;
}

// PreTranslateMessage

static BOOL RegisterPreTranslateMessage()
{
	// Below is a hack, which allows us to define a PreTranslateMessage-like function.
	// We hook the TranslateMDISysAccel function, and use it to do our pre-translation.
	ppTranslateMDISysAccel = FindImportPtr(GetModuleHandle(NULL), "user32.dll", "TranslateMDISysAccel");
	if(!ppTranslateMDISysAccel)
		return FALSE;

	PointerRedirectionAdd(ppTranslateMDISysAccel, TranslateMDISysAccelHook, &prTranslateMDISysAccel);
	return TRUE;
}

static void UnregisterPreTranslateMessage()
{
	PointerRedirectionRemove(ppTranslateMDISysAccel, &prTranslateMDISysAccel);
}

static BOOL WINAPI TranslateMDISysAccelHook(HWND hWndClient, LPMSG lpMsg)
{
	if(AssemblerPreTranslateMessage(lpMsg))
		return TRUE;

	return ((BOOL(WINAPI *)(HWND, LPMSG))prTranslateMDISysAccel.pOriginalAddress)(hWndClient, lpMsg);
}



================================================
File: main_x64dbg.c
================================================
#include "stdafx.h"
#include "main_common.h"
#include "plugin.h"
#include "assembler_dlg.h"
#include "options_dlg.h"

extern HINSTANCE hDllInst;

static int pluginHandle;
static int hMenu;
static int hMenuDisasm;

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif // DLL_EXPORT

#define MENU_MAIN             0
#define MENU_DISASM           1
#define MENU_OPTIONS          2
#define MENU_HELP             3
#define MENU_ABOUT            4

#define MENU_CPU_DISASM       5

static int GetPluginVersion();
static void DisassembleSelection();
static bool CmdShow(int argc, char** argv);
static bool CmdDisasmSelection(int argc, char** argv);
static bool CmdClose(int argc, char** argv);

DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT *setupStruct)
{
	hwollymain = setupStruct->hwndDlg;
	hMenu = setupStruct->hMenu;
	hMenuDisasm = setupStruct->hMenuDisasm;

	HRSRC hResource = FindResource(hDllInst, MAKEINTRESOURCE(IDB_X64DBG_ICON), "PNG");
	if(hResource)
	{
		HGLOBAL hMemory = LoadResource(hDllInst, hResource);
		if(hMemory)
		{
			DWORD dwSize = SizeofResource(hDllInst, hResource);
			LPVOID lpAddress = LockResource(hMemory);
			if(lpAddress)
			{
				ICONDATA IconData;
				IconData.data = lpAddress;
				IconData.size = dwSize;

				_plugin_menuseticon(hMenu, &IconData);
				_plugin_menuseticon(hMenuDisasm, &IconData);
			}
		}
	}

	_plugin_menuaddentry(hMenu, MENU_MAIN, "&Multiline Ultimate Assembler\tCtrl+M");
	_plugin_menuaddseparator(hMenu);
	_plugin_menuaddentry(hMenu, MENU_OPTIONS, "&Options");
	_plugin_menuaddseparator(hMenu);
	_plugin_menuaddentry(hMenu, MENU_HELP, "&Help");
	_plugin_menuaddentry(hMenu, MENU_ABOUT, "&About");

	_plugin_menuaddentry(hMenuDisasm, MENU_CPU_DISASM, "&Disassemble selection\tCtrl+Shift+M");
}

DLL_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
	initStruct->pluginVersion = GetPluginVersion();
	initStruct->sdkVersion = PLUG_SDKVERSION;
	lstrcpy(initStruct->pluginName, DEF_PLUGINNAME);
	pluginHandle = initStruct->pluginHandle;

	char *pError = PluginInit(hDllInst);
	if(pError)
	{
		MessageBox(hwollymain, pError, "Multiline Ultimate Assembler error", MB_ICONHAND);
		return false;
	}

	_plugin_logputs("Multiline Ultimate Assembler v" DEF_VERSION);
	_plugin_logputs("  " DEF_COPYRIGHT);

	_plugin_registercommand(pluginHandle, "multiasm_show", CmdShow, false);
	_plugin_registercommand(pluginHandle, "multiasm_disasm_selection", CmdDisasmSelection, true);
	_plugin_registercommand(pluginHandle, "multiasm_close", CmdClose, false);

	return true;
}

static int GetPluginVersion()
{
	char *p = DEF_VERSION;
	int nVersion = 0;

	while(*p != '\0')
	{
		char c = *p;
		if(c >= '0' && c <= '9')
		{
			nVersion *= 10;
			nVersion += c - '0';
		}

		p++;
	}

	return nVersion;
}

DLL_EXPORT bool plugstop()
{
	_plugin_menuclear(hMenu);
	_plugin_menuclear(hMenuDisasm);

	_plugin_unregistercommand(pluginHandle, "multiasm_show");
	_plugin_unregistercommand(pluginHandle, "multiasm_disasm_selection");
	_plugin_unregistercommand(pluginHandle, "multiasm_close");

	AssemblerCloseDlg();
	PluginExit();
	return true;
}

DLL_EXPORT CDECL void CBWINEVENT(CBTYPE cbType, PLUG_CB_WINEVENT *info)
{
	MSG *pMsg = info->message;

	if(!info->result && AssemblerPreTranslateMessage(pMsg))
	{
		info->retval = true;
		return;
	}

	if(info->result &&
		pMsg->message == WM_KEYUP &&
		pMsg->wParam == 'M')
	{
		bool ctrlDown = GetKeyState(VK_CONTROL) < 0;
		bool altDown = GetKeyState(VK_MENU) < 0;
		bool shiftDown = GetKeyState(VK_SHIFT) < 0;

		if(!altDown && ctrlDown)
		{
			if(shiftDown)
			{
				if(DbgIsDebugging())
					DisassembleSelection();
			}
			else
			{
				AssemblerShowDlg();
			}

			*info->result = 0;
			info->retval = true;
			return;
		}
	}
}

DLL_EXPORT CDECL void CBMENUENTRY(CBTYPE cbType, void *callbackInfo)
{
	PLUG_CB_MENUENTRY *info = (PLUG_CB_MENUENTRY *)callbackInfo;

	switch(info->hEntry)
	{
	case MENU_MAIN:
		// Menu item, main plugin functionality
		AssemblerShowDlg();
		break;

	case MENU_DISASM:
	case MENU_CPU_DISASM:
		if(DbgIsDebugging())
			DisassembleSelection();
		else
			MessageBox(hwollymain, "No process is loaded", NULL, MB_ICONASTERISK);
		break;

	case MENU_OPTIONS:
		// Menu item "Options"
		if(ShowOptionsDlg())
			AssemblerOptionsChanged();
		break;

	case MENU_HELP:
		// Menu item "Help"
		if(!OpenHelp(hwollymain, hDllInst))
			MessageBox(hwollymain, "Failed to open the \"multiasm.chm\" help file", NULL, MB_ICONHAND);
		break;

	case MENU_ABOUT:
		// Menu item "About", displays plugin info.
		AboutMessageBox(hwollymain, hDllInst);
		break;
	}
}

static void DisassembleSelection()
{
	SELECTIONDATA selection;

	if(GuiSelectionGet(GUI_DISASSEMBLY, &selection))
		AssemblerLoadCode(selection.start, selection.end - selection.start + 1);
}

static bool CmdShow(int argc, char** argv)
{
	if(argc > 1)
	{
		_plugin_logputs("Command does not accept arguments");
		return false;
	}

	GuiExecuteOnGuiThread(AssemblerShowDlg);
	return true;
}

static bool CmdDisasmSelection(int argc, char** argv)
{
	if(argc > 1)
	{
		_plugin_logputs("Command does not accept arguments");
		return false;
	}

	GuiExecuteOnGuiThread(DisassembleSelection);
	return true;
}

static bool CmdClose(int argc, char** argv)
{
	if(argc > 1)
	{
		_plugin_logputs("Command does not accept arguments");
		return false;
	}

	GuiExecuteOnGuiThread(AssemblerCloseDlg);
	return true;
}



================================================
File: options_def.h
================================================
#ifndef _OPTIONS_DEF_H_
#define _OPTIONS_DEF_H_

typedef struct {
	int disasm_rva;
	int disasm_rva_reloconly;
	int disasm_label;
	int disasm_extjmp;
	int disasm_hex;
	int disasm_labelgen;
	int asm_comments;
	int asm_labels;
	int edit_savepos;
	int edit_tabwidth;
} OPTIONS;

#endif // _OPTIONS_DEF_H_



================================================
File: options_dlg.c
================================================
#include "stdafx.h"
#include "options_dlg.h"

extern HINSTANCE hDllInst;
extern OPTIONS options;

LRESULT ShowOptionsDlg()
{
	return DialogBox(hDllInst, MAKEINTRESOURCE(IDD_OPTIONS), hwollymain, (DLGPROC)DlgOptionsProc);
}

static LRESULT CALLBACK DlgOptionsProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_INITDIALOG:
		SendDlgItemMessage(hWnd, IDC_DISASM_HEX, CB_ADDSTRING, 0, (LPARAM)_T("(disassembler default)"));
		SendDlgItemMessage(hWnd, IDC_DISASM_HEX, CB_ADDSTRING, 0, (LPARAM)_T("FFFE"));
		SendDlgItemMessage(hWnd, IDC_DISASM_HEX, CB_ADDSTRING, 0, (LPARAM)_T("0FFFE"));
		SendDlgItemMessage(hWnd, IDC_DISASM_HEX, CB_ADDSTRING, 0, (LPARAM)_T("0FFFEh"));
		SendDlgItemMessage(hWnd, IDC_DISASM_HEX, CB_ADDSTRING, 0, (LPARAM)_T("0xFFFE"));

		SendDlgItemMessage(hWnd, IDC_DISASM_LABELGEN, CB_ADDSTRING, 0, (LPARAM)_T("L[counter]"));
		SendDlgItemMessage(hWnd, IDC_DISASM_LABELGEN, CB_ADDSTRING, 0, (LPARAM)_T("L_[address]"));
		SendDlgItemMessage(hWnd, IDC_DISASM_LABELGEN, CB_ADDSTRING, 0, (LPARAM)_T("L_[tab_name]_[counter]"));

		SendDlgItemMessage(hWnd, IDC_EDIT_TABWIDTH, CB_ADDSTRING, 0, (LPARAM)_T("2"));
		SendDlgItemMessage(hWnd, IDC_EDIT_TABWIDTH, CB_ADDSTRING, 0, (LPARAM)_T("4"));
		SendDlgItemMessage(hWnd, IDC_EDIT_TABWIDTH, CB_ADDSTRING, 0, (LPARAM)_T("8"));

		OptionsToDlg(hWnd);
		break;

	case WM_LBUTTONDOWN:
		SendMessage(hWnd, WM_NCLBUTTONDOWN, HTCAPTION, 0);
		break;

	case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_DISASM_RVA:
			EnableWindow(GetDlgItem(hWnd, IDC_DISASM_RVA_RELOCONLY), IsDlgButtonChecked(hWnd, IDC_DISASM_RVA));
			break;

		case IDC_DISASM_LABEL:
			EnableWindow(GetDlgItem(hWnd, IDC_DISASM_EXTJMP), IsDlgButtonChecked(hWnd, IDC_DISASM_LABEL));
			break;

		case IDOK:
			OptionsFromDlg(hWnd);
			OptionsToIni(hDllInst);
			EndDialog(hWnd, 1);
			break;

		case IDCANCEL:
			EndDialog(hWnd, 0);
			break;
		}
		break;
	}

	return FALSE;
}

static void OptionsToDlg(HWND hWnd)
{
	if(options.disasm_rva)
		CheckDlgButton(hWnd, IDC_DISASM_RVA, BST_CHECKED);
	else
		EnableWindow(GetDlgItem(hWnd, IDC_DISASM_RVA_RELOCONLY), FALSE);

	if(options.disasm_rva_reloconly)
		CheckDlgButton(hWnd, IDC_DISASM_RVA_RELOCONLY, BST_CHECKED);

	if(options.disasm_label)
		CheckDlgButton(hWnd, IDC_DISASM_LABEL, BST_CHECKED);
	else
		EnableWindow(GetDlgItem(hWnd, IDC_DISASM_EXTJMP), FALSE);

	if(options.disasm_extjmp)
		CheckDlgButton(hWnd, IDC_DISASM_EXTJMP, BST_CHECKED);

	SendDlgItemMessage(hWnd, IDC_DISASM_HEX, CB_SETCURSEL, options.disasm_hex, 0);

	SendDlgItemMessage(hWnd, IDC_DISASM_LABELGEN, CB_SETCURSEL, options.disasm_labelgen, 0);

	if(options.asm_comments)
		CheckDlgButton(hWnd, IDC_ASM_COMMENTS, BST_CHECKED);

	if(options.asm_labels)
		CheckDlgButton(hWnd, IDC_ASM_LABELS, BST_CHECKED);

	if(options.edit_savepos)
		CheckDlgButton(hWnd, IDC_EDIT_SAVEPOS, BST_CHECKED);

	SendDlgItemMessage(hWnd, IDC_EDIT_TABWIDTH, CB_SETCURSEL, options.edit_tabwidth, 0);
}

static void OptionsFromDlg(HWND hWnd)
{
	options.disasm_rva = IsDlgButtonChecked(hWnd, IDC_DISASM_RVA) == BST_CHECKED;
	options.disasm_rva_reloconly = IsDlgButtonChecked(hWnd, IDC_DISASM_RVA_RELOCONLY) == BST_CHECKED;
	options.disasm_label = IsDlgButtonChecked(hWnd, IDC_DISASM_LABEL) == BST_CHECKED;
	options.disasm_extjmp = IsDlgButtonChecked(hWnd, IDC_DISASM_EXTJMP) == BST_CHECKED;
	options.disasm_hex = (int)SendDlgItemMessage(hWnd, IDC_DISASM_HEX, CB_GETCURSEL, 0, 0);
	options.disasm_labelgen = (int)SendDlgItemMessage(hWnd, IDC_DISASM_LABELGEN, CB_GETCURSEL, 0, 0);
	options.asm_comments = IsDlgButtonChecked(hWnd, IDC_ASM_COMMENTS) == BST_CHECKED;
	options.asm_labels = IsDlgButtonChecked(hWnd, IDC_ASM_LABELS) == BST_CHECKED;
	options.edit_savepos = IsDlgButtonChecked(hWnd, IDC_EDIT_SAVEPOS) == BST_CHECKED;
	options.edit_tabwidth = (int)SendDlgItemMessage(hWnd, IDC_EDIT_TABWIDTH, CB_GETCURSEL, 0, 0);
}

static void OptionsToIni(HINSTANCE hInst)
{
	MyWriteinttoini(hInst, _T("disasm_rva"), options.disasm_rva);
	MyWriteinttoini(hInst, _T("disasm_rva_reloconly"), options.disasm_rva_reloconly);
	MyWriteinttoini(hInst, _T("disasm_label"), options.disasm_label);
	MyWriteinttoini(hInst, _T("disasm_extjmp"), options.disasm_extjmp);
	MyWriteinttoini(hInst, _T("disasm_hex"), options.disasm_hex);
	MyWriteinttoini(hInst, _T("disasm_labelgen"), options.disasm_labelgen);
	MyWriteinttoini(hInst, _T("asm_comments"), options.asm_comments);
	MyWriteinttoini(hInst, _T("asm_labels"), options.asm_labels);
	MyWriteinttoini(hInst, _T("edit_savepos"), options.edit_savepos);
	MyWriteinttoini(hInst, _T("edit_tabwidth"), options.edit_tabwidth);
}



================================================
File: options_dlg.h
================================================
#ifndef _OPTIONS_DLG_H_
#define _OPTIONS_DLG_H_

#include "options_def.h"
#include "plugin.h"
#include "resource.h"

LRESULT ShowOptionsDlg();
static LRESULT CALLBACK DlgOptionsProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static void OptionsToDlg(HWND hWnd);
static void OptionsFromDlg(HWND hWnd);
static void OptionsToIni(HINSTANCE hInst);

#endif // _OPTIONS_DLG_H_



================================================
File: plugin.h
================================================
#ifndef _PLUGIN_H_
#define _PLUGIN_H_

#if defined(TARGET_ODBG) || defined(TARGET_IMMDBG)
#include "plugin_odbg_v1.h"
#elif defined(TARGET_ODBG2)
#include "plugin_odbg_v2.h"
#elif defined(TARGET_X64DBG)
#include "plugin_x64dbg.h"
#else
#error Unknown target
#endif

#define DEF_PLUGINNAME        _T("Multiline Ultimate Assembler")
#define DEF_VERSION           _T("2.3.7")
#define DEF_COPYRIGHT         _T("Copyright (C) Ramen Software")

#define DECODE_UNKNOWN        0
#define DECODE_COMMAND        1
#define DECODE_DATA           2
#define DECODE_ASCII          3
#define DECODE_UNICODE        4

// Config functions
BOOL MyGetintfromini(HINSTANCE dllinst, TCHAR *key, int *p_val, int min, int max, int def);
BOOL MyWriteinttoini(HINSTANCE dllinst, TCHAR *key, int val);
int MyGetstringfromini(HINSTANCE dllinst, TCHAR *key, TCHAR *s, int length);
BOOL MyWritestringtoini(HINSTANCE dllinst, TCHAR *key, TCHAR *s);

// Assembler functions
DWORD SimpleDisasm(BYTE *cmd, SIZE_T cmdsize, DWORD_PTR ip, BYTE *dec, BOOL bSizeOnly,
	TCHAR *pszResult, DWORD_PTR *jmpconst, DWORD_PTR *adrconst, DWORD_PTR *immconst);
int AssembleShortest(TCHAR *lpCommand, DWORD_PTR dwAddress, BYTE *bBuffer, TCHAR *lpError);
int AssembleWithGivenSize(TCHAR *lpCommand, DWORD_PTR dwAddress, int nReqSize, BYTE *bBuffer, TCHAR *lpError);

// Memory functions
BOOL SimpleReadMemory(void *buf, DWORD_PTR addr, SIZE_T size);
BOOL SimpleWriteMemory(void *buf, DWORD_PTR addr, SIZE_T size);

// Symbolic functions
int GetLabel(DWORD_PTR addr, TCHAR *name);
int GetComment(DWORD_PTR addr, TCHAR *name);
BOOL QuickInsertLabel(DWORD_PTR addr, TCHAR *s);
BOOL QuickInsertComment(DWORD_PTR addr, TCHAR *s);
void MergeQuickData(void);
void DeleteRangeLabels(DWORD_PTR addr0, DWORD_PTR addr1);
void DeleteRangeComments(DWORD_PTR addr0, DWORD_PTR addr1);

// Module functions
PLUGIN_MODULE FindModuleByName(TCHAR *lpModule);
PLUGIN_MODULE FindModuleByAddr(DWORD_PTR dwAddress);
DWORD_PTR GetModuleBase(PLUGIN_MODULE module);
SIZE_T GetModuleSize(PLUGIN_MODULE module);
BOOL GetModuleName(PLUGIN_MODULE module, TCHAR *pszModuleName);
BOOL IsModuleWithRelocations(PLUGIN_MODULE module);

// Memory functions
PLUGIN_MEMORY FindMemory(DWORD_PTR dwAddress);
DWORD_PTR GetMemoryBase(PLUGIN_MEMORY mem);
SIZE_T GetMemorySize(PLUGIN_MEMORY mem);
void EnsureMemoryBackup(PLUGIN_MEMORY mem);

// Analysis functions
BYTE *FindDecode(DWORD_PTR addr, SIZE_T *psize);
int DecodeGetType(BYTE decode);

// Misc.
BOOL IsProcessLoaded();
void SuspendAllThreads();
void ResumeAllThreads();
DWORD_PTR GetCpuBaseAddr();
void InvalidateGui();

#endif // _PLUGIN_H_



================================================
File: plugin_immdbg.h
================================================
#ifndef _PLUGIN_IMMDBG_H_
#define _PLUGIN_IMMDBG_H_

#include <windows.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             ImmDBG PLUGIN API                             //
//                                                                            //
//                                Version 1.10                                //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// IMPORTANT INFORMATION /////////////////////////////

// 1. Export all callback functions by name, NOT by ordinal!
// 2. Force byte alignment of immDbg structures!
// 3. Set default char type to unsigned!
// 4. Read documentation!

// If you prefere Borland, this will force necessary settings (but, as a side
// effect, may cause plenty of warnings if other include files will be compiled
// with different options):
#ifdef __BORLANDC__

#pragma option -a1		// Byte alignment
#pragma option -K		// Unsigned char

  // And here I check that settings are correct. Unfortunately, Microsoft C (at
  // least C++ 5.0) doesn't allow for sizeof and typecasts in conditionals:

typedef struct t_aligntest
{
  char a;
  long b;
} t_aligntest;

#if (sizeof(t_aligntest)!=sizeof(char)+sizeof(long))
#error Please assure byte alignment of immDbg structures
#endif
#undef t_aligntest

#if ((char)0xFF!=255)
#error Please set default char type to unsigned
#endif

#endif

// If you like Microsoft compiler, this will force byte alignment and verify
// that character is set to unsigned.
#ifdef _MSC_VER

#pragma pack(push, 4)		// Force byte alignment of structures

#ifndef _CHAR_UNSIGNED		// Verify that character is unsigned
#error Please set default char type to unsigned (option /J)
#endif

  // Borland adds underscore to export automatically, whereas I don't know any
  // such option for Microsoft compiler. This solution is not too elegant but
  // works.
#define ODBG_Plugindata      IMMDBG_Plugindata
#define ODBG_Plugininit      IMMDBG_Plugininit
#define ODBG_Pluginmainloop  IMMDBG_Pluginmainloop
#define ODBG_Pluginsaveudd   IMMDBG_Pluginsaveudd
#define ODBG_Pluginuddrecord IMMDBG_Pluginuddrecord
#define ODBG_Pluginmenu      IMMDBG_Pluginmenu
#define ODBG_Pluginaction    IMMDBG_Pluginaction
#define ODBG_Pluginshortcut  IMMDBG_Pluginshortcut
#define ODBG_Pluginreset     IMMDBG_Pluginreset
#define ODBG_Pluginclose     IMMDBG_Pluginclose
#define ODBG_Plugindestroy   IMMDBG_Plugindestroy
#define ODBG_Paused          IMMDBG_Paused
#define ODBG_Pausedex        IMMDBG_Pausedex
#define ODBG_Plugincmd       IMMDBG_Plugincmd


#endif


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// GENERAL DECLARATIONS /////////////////////////////

#define PLUGIN_VERSION 110	// Version of plugin interface

#ifdef __cplusplus
#define extc           extern "C"	// Assure that names are not mangled
#else
#define extc           extern
#endif

#define _export        __declspec(dllexport)

typedef unsigned char uchar;	// Unsigned character (byte)
typedef unsigned short ushort;	// Unsigned short
typedef unsigned int uint;	// Unsigned integer
typedef unsigned long ulong;	// Unsigned long

#define TEXTLEN        256	// Maximal length of text string
#define ARGLEN         1024	// Maximal length of argument string
#define USERLEN        4096	// Maximal length of record in .udd file
#define SHORTLEN       8	// Maximal length of short name

#define BLACK          0	// Indices of colours used by immDbg. In
#define BLUE           1	// syntax highlighting, use only colours
#define GREEN          2	// 0 to 15 in the least significant bits
#define CYAN           3	// of the corresponding mask byte.
#define RED            4
#define MAGENTA        5
#define BROWN          6
#define LIGHTGRAY      7
#define DARKGRAY       8
#define LIGHTBLUE      9
#define LIGHTGREEN     10
#define LIGHTCYAN      11
#define LIGHTRED       12
#define LIGHTMAGENTA   13
#define YELLOW         14
#define WHITE          15
#define MINT           16
#define SKYBLUE        17
#define IVORY          18
#define GRAY           19

#define NCOLORS        20	// Total number of defined colours

#define BKTRANSP       0x00	// Background colours in syntax hiliting
#define BKBLACK        0x10
#define BKGRAY         0x20
#define BKWHITE        0x30
#define BKCYAN         0x40
#define BKGREEN        0x50
#define BKRED          0x60
#define BKYELLOW       0x70

#define BLACKWHITE     0	// Colour schemes used by immDbg
#define BLUEGOLD       1
#define SKYWIND        2
#define NIGHTSTARS     3
#define SCHEME4        4
#define SCHEME5        5
#define SCHEME6        6
#define SCHEME7        7

#define FIXEDFONT      0	// Fonts used by immDbg. Variable-pitch
#define TERMINAL6      1	// fonts are placed at the end of this
#define FIXEDSYS       2	// table.
#define COURIERFONT    3
#define LUCIDACONS     4
#define FONT5          5
#define FONT6          6
#define FONT7          7
#define MAINFONT       8
#define SYSFONT        9
#define INFOFONT       10

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// INFORMATION FUNCTIONS /////////////////////////////

extc void cdecl Addtolist (long addr, int highlight, char *format, ...);
extc void cdecl Updatelist (void);
extc HWND cdecl Createlistwindow (void);
extc void cdecl Error (char *format, ...);
extc void cdecl Message (ulong addr, char *format, ...);
extc void cdecl Infoline (char *format, ...);
extc void cdecl Progress (int promille, char *format, ...);
extc void cdecl Flash (char *format, ...);

////////////////////////////////////////////////////////////////////////////////
////////////////////////// DATA FORMATTING FUNCTIONS ///////////////////////////

// Bits used in Decodeaddress(), Decoderelativeoffset() and  Decodethreadname()
// to specify decoding mode:
#define ADC_DEFAULT    0x0000	// Default decoding mode
#define ADC_DIFFMOD    0x0001	// Show module only if different
#define ADC_NOMODNAME  0x0002	// Never show module name
#define ADC_VALID      0x0004	// Only decode if allocated memory
#define ADC_INMODULE   0x0008	// Only decode if in some module
#define ADC_SAMEMOD    0x0010	// Decode only address in same module
#define ADC_SYMBOL     0x0020	// Only decode if symbolic name
#define ADC_JUMP       0x0040	// Check if points to JMP/CALL command
#define ADC_OFFSET     0x0080	// Check if symbol for data
#define ADC_STRING     0x0100	// Check if pointer to ASCII or UNICODE
#define ADC_ENTRY      0x0200	// Check if entry to subroutine
#define ADC_UPPERCASE  0x0400	// First letter in uppercase if possible
#define ADC_WIDEFORM   0x0800	// Extended form of decoded name
#define ADC_NONTRIVIAL 0x1000	// Name + non-zero offset
#define ADC_DYNAMIC    0x2000	// JMP/CALL to dynamically loaded name

#define PLAINASCII     0x01	// Plain ASCII character
#define DIACRITICAL    0x02	// Diacritical character
#define RAREASCII      0x10	// Rare ASCII character

extc int cdecl Decodeaddress (ulong addr, ulong base, int addrmode,
			      char *symb, int nsymb, char *comment);
extc int cdecl Decoderelativeoffset (ulong addr, int addrmode,
				     char *symb, int nsymb);
extc int cdecl Decodecharacter (char *s, uint c);
extc int cdecl Printfloat4 (char *s, float f);
extc int cdecl Printfloat8 (char *s, double d);
extc int cdecl Printfloat10 (char *s, long double ext);
extc int cdecl Print3dnow (char *s, uchar * f);
extc int cdecl Printsse (char *s, char *f);
extc ulong cdecl Followcall (ulong addr);
extc int cdecl IstextA (char c);
extc int cdecl IstextW (wchar_t w);
extc int cdecl Stringtotext (char *data, int ndata, char *text, int ntext);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// DATA INPUT FUNCTIONS /////////////////////////////

#define MAXCMDSIZE     16	// Maximal length of 80x86 command
#define NSEQ           8	// Max length of command sequence
#define NMODELS        8	// Number of assembler search models

// Note that each of dialog functions decodes only subset of listed flags.
#define DIA_ASKGLOBAL  0x0001	// Display checkbox "Global search"
#define DIA_HEXONLY    0x0002	// Hexadecimal format only
#define DIA_ALIGNED    0x0004	// Display checkbox "Aligned search"
#define DIA_DEFHEX     0x0000	// On startup, cursor in hex control
#define DIA_DEFASCII   0x0010	// On startup, cursor in ASCII control
#define DIA_DEFUNICODE 0x0020	// On startup, cursor in UNICODE control
#define DIA_SEARCH     0x0040	// Is a search dialog
#define DIA_HISTORY    0x0100	// Allows previous hex strings

// Status of animation or trace.
#define ANIMATE_OFF    0	// No animation
#define ANIMATE_IN     1	// Animate into
#define ANIMATE_OVER   2	// Animate over
#define ANIMATE_RET    3	// Execute till RET
#define ANIMATE_SKPRET 4	// Skip RET instruction
#define ANIMATE_USER   5	// Execute till user code
#define ANIMATE_TRIN   6	// Run trace in
#define ANIMATE_TROVER 7	// Run trace over
#define ANIMATE_STOP   8	// Gracefully stop animation

typedef struct t_hexstr
{				// String used for hex/text search
  int n;			// String length
  uchar data[TEXTLEN];		// Data
  uchar mask[TEXTLEN];		// Mask, 0 bits are masked
} t_hexstr;

typedef struct t_asmmodel
{				// Model to search for assembler command
  uchar code[MAXCMDSIZE];	// Binary code
  uchar mask[MAXCMDSIZE];	// Mask for binary code (0: bit ignored)
  int length;			// Length of code, bytes (0: empty)
  int jmpsize;			// Offset size if relative jump
  int jmpoffset;		// Offset relative to IP
  int jmppos;			// Position of jump offset in command
} t_asmmodel;

typedef struct t_extmodel
{				// Model for extended command search
  char code[MAXCMDSIZE];	// Binary code
  char mask[MAXCMDSIZE];	// Mask for binary code (0: bit ignored)
  int length;			// Length of code, bytes (0: empty)
  int jmpsize;			// Offset size if relative jump
  int jmpoffset;		// Offset relative to IP
  int jmppos;			// Position of jump offset in command
  int isany;			// Count for ANY's argument
  int cmdoffset;		// Offset of command in the source
  char ramask[MAXCMDSIZE];	// Mask for pseudoregister RA
  char rbmask[MAXCMDSIZE];	// Mask for pseudoregister RB
} t_extmodel;


extc int cdecl Getlong (char *title, ulong * data, int datasize,
			char letter, int mode);
extc int cdecl Getlongxy (char *title, ulong * data, int datasize,
			  char letter, int mode, int x, int y);
extc int cdecl Getregxy (char *title, ulong * data, char letter, int x,
			 int y);
extc int cdecl Getline (char *title, ulong * data);
extc int cdecl Getlinexy (char *title, ulong * data, int x, int y);
extc int cdecl Getfloat10 (char *title, long double *fdata,
			   uchar * tag, char letter, int mode);
extc int cdecl Getfloat10xy (char *title, long double *fdata,
			     char *tag, char letter, int mode, int x, int y);
extc int cdecl Getfloat (char *title, void *fdata, int size,
			 char letter, int mode);
extc int cdecl Getfloatxy (char *title, void *fdata, int size,
			   char letter, int mode, int x, int y);
extc void cdecl Getasmfindmodel (t_asmmodel model[NMODELS],
				 char letter, int searchall);
extc void cdecl Getasmfindmodelxy (t_asmmodel model[NMODELS],
				   char letter, int searchall, int x, int y);
extc int cdecl Gettext (char *title, char *text,
			char letter, int type, int fontindex);
extc int cdecl Gettextxy (char *title, char *text, char letter,
			  int type, int fontindex, int x, int y);
extc int cdecl Gethexstring (char *title, t_hexstr * hs,
			     int mode, int fontindex, char letter);
extc int cdecl Gethexstringxy (char *title, t_hexstr * hs, int mode,
			       int fontindex, char letter, int x, int y);
extc int cdecl Getmmx (char *title, uchar * data, int mode);
extc int cdecl Getmmxxy (char *title, char *data, int mode, int x, int y);
extc int cdecl Get3dnow (char *title, uchar * data, int mode);
extc int cdecl Get3dnowxy (char *title, char *data, int mode, int x, int y);
extc int cdecl Browsefilename (char *title, char *name, char *defext,
				   int getarguments);
extc int cdecl OpenEXEfile (char *path, int dropped);
extc int cdecl Attachtoactiveprocess (int newprocessid);
extc void cdecl Animate (int animation);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// SORTED DATA FUNCTIONS /////////////////////////////

#define NBAR           17	// Max allowed number of segments in bar

#define BAR_PRESSED    0x01	// Bar segment pressed, used internally
#define BAR_DISABLED   0x02	// Bar segment disabled
#define BAR_NOSORT     0x04	// Flat bar column, supports no sorting
#define BAR_NORESIZE   0x08	// Bar column cannot be resized
#define BAR_BUTTON     0x10	// Segment sends WM_USER_BAR
#define BAR_SHIFTSEL   0x20	// Selection shifted 1/2 char to left

#define CAPT_FREE      0	// Bar and data are not captured

#define TABLE_DIR      0x0001	// Bottom-to-top table
#define TABLE_COPYMENU 0x0002	// Attach copy item
#define TABLE_SORTMENU 0x0004	// Attach sort menu
#define TABLE_APPMENU  0x0010	// Attach appearance menu
#define TABLE_WIDECOL  0x0020	// Attach wide columns menu item
#define TABLE_USERAPP  0x0040	// Attach user-processed appearance menu
#define TABLE_USERDEF  0x0080	// User-drawn table
#define TABLE_NOHSCR   0x0100	// Table contains no horizontal scroll
#define TABLE_SAVEPOS  0x0200	// Save position & appearance to .ini
#define TABLE_CPU      0x0400	// Table belongs to CPU window
#define TABLE_FASTSEL  0x0800	// Update when selection changes
#define TABLE_COLSEL   0x1000	// Column-wide selection
#define TABLE_SAVEAPP  0x2000	// Save multiinstance appearance to .ini
#define TABLE_HILMENU  0x4000	// Attach Syntax highlighting menu
#define TABLE_ONTOP    0x8000	// Attach Always on top menu

#define DRAW_NORMAL    0x0000	// Normal plain text
#define DRAW_GRAY      0x0001	// Grayed text
#define DRAW_HILITE    0x0002	// Highlighted text
#define DRAW_UL        0x0004	// Underlined text
#define DRAW_SELECT    0x0008	// Selected background
#define DRAW_EIP       0x0010	// Inverted normal text/background
#define DRAW_BREAK     0x0020	// Breakpoint background
#define DRAW_GRAPH     0x0040	// Graphical element
#define DRAW_DIRECT    0x0080	// Direct text colour index (mask only)
#define DRAW_MASK      0x0080	// Use mask to set individual colors
#define DRAW_EXTSEL    0x0100	// Extend mask till end of column
#define DRAW_UNICODE   0x0200	// Text in UNICODE
#define DRAW_TOP       0x0400	// Draw upper half of text
#define DRAW_BOTTOM    0x0800	// Draw lower half of text

// Symbolic names for graphical characters. Any other character is displayed
// as space. Use only characters in range [1..0x7F]!
#define D_SPACE        'N'	// Space
#define D_SEP          ' '	// Thin separating line
#define D_BEGIN        'B'	// Begin of procedure or scope
#define D_BODY         'I'	// Body of procedure or scope
#define D_ENTRY        'J'	// Loop entry point
#define D_LEAF         'K'	// Intermediate leaf on a tree
#define D_END          'E'	// End of procedure or scope
#define D_SINGLE       'S'	// Single-line scope
#define D_ENDBEG       'T'	// End and begin of stack scope
#define D_POINT        '.'	// Point
#define D_JMPUP        'U'	// Jump upstairs
#define D_JMPOUT       '<'	// Jump to same location or out of module
#define D_JMPDN        'D'	// Jump downstairs
#define D_PATHUP       'u'	// Jump path upstairs (highlighted)
#define D_GRAYUP       'v'	// Jump path upstairs (grayed)
#define D_PATH         'i'	// Jump path through text (highlighted)
#define D_GRAYPATH     'j'	// Jump path through text (grayed)
#define D_PATHDN       'd'	// Jump path downstairs (highlighted)
#define D_GRAYDN       'e'	// Jump path downstairs (grayed)
#define D_PATHUPEND    'r'	// End of path upstairs (highlighted)
#define D_GRAYUPEND    's'	// End of path upstairs (grayed)
#define D_PATHDNEND    'f'	// End of path downstairs (highlighted)
#define D_GRAYDNEND    'g'	// End of path downstairs (grayed)
#define D_SWTOP        't'	// Start of switch
#define D_SWBODY       'b'	// Switch body
#define D_CASE         'c'	// Intermediate switch case
#define D_LASTCASE     'l'	// Last switch case

// Please note: Although types here contain mostly unique bit assignments, it's
// not really necessary. Same bits, except for reserved general types, can be
// freely shared between different types of sorted data.
// General item types:
#define TY_NEW         0x00000001	// Item is new
#define TY_CONFIRMED   0x00000002	// Item still exists
#define TY_MAIN        0x00000004	// Main item (thread or module)
#define TY_INVALID     0x00000008	// Invalid type (item does not exist)
#define TY_SELECTED    0x80000000	// Reserved for multiple selection
// Module-specific types:
#define TY_REPORTED    0x00000010	// Stop on module was reported
// Reference-specific types:
#define TY_REFERENCE   0x00000020	// Item is a real reference
#define TY_ORIGIN      0x00000040	// Item is a search origin
// Breakpoint-specific types:
#define TY_STOPAN      0x00000080	// Stop animation if TY_ONESHOT
#define TY_SET         0x00000100	// Code INT3 is in memory
#define TY_ACTIVE      0x00000200	// Permanent breakpoint
#define TY_DISABLED    0x00000400	// Permanent disabled breakpoint
#define TY_ONESHOT     0x00000800	// Temporary stop
#define TY_TEMP        0x00001000	// Temporary breakpoint
#define TY_KEEPCODE    0x00002000	// Set and keep command code
#define TY_KEEPCOND    0x00004000	// Keep condition unchanged (0: remove)
#define TY_NOUPDATE    0x00008000	// Don't redraw breakpoint window
#define TY_RTRACE      0x00010000	// Pseudotype of run trace breakpoint
#define TY_SETCOUNT    0x00020000      // Set new pass count
// Namelist-specific types:
#define TY_EXPORT      0x00010000	// Exported name
#define TY_IMPORT      0x00020000	// Imported name
#define TY_LIBRARY     0x00040000	// Name extracted from object file
#define TY_LABEL       0x00080000	// User-defined name
#define TY_ANYNAME     0x000F0000	// Any of the namelist flags above
#define TY_KNOWN       0x00100000	// Name of known function
// Memory-specific types:
#define TY_DEFHEAP     0x00020000	// Contains default heap
#define TY_HEAP        0x00040000	// Contains non-default heap
#define TY_SFX         0x00080000	// Contains self-extractor
#define TY_CODE        0x00100000	// Contains image of code section
#define TY_DATA        0x00200000	// Contains image of data section
#define TY_IMPDATA     0x00400000	// Memory block includes import data
#define TY_EXPDATA     0x00800000	// Memory block includes export data
#define TY_RSRC        0x01000000	// Memory block includes resources
#define TY_RELOC       0x02000000	// Memory block includes relocation data
#define TY_STACK       0x04000000	// Contains stack of some thread
#define TY_THREAD      0x08000000	// Contains data block of some thread
#define TY_HEADER      0x10000000	// COFF header
#define TY_ANYMEM      0x1FFE0000	// Any of the memory flags above
#define TY_GUARDED     0x20000000	// NT only: guarded memory block
// Procedure data-specific types:
#define TY_PURE        0x00004000	// No side effects except in stack
#define TY_PASCAL      0x00010000	// Procedure ends with RET nnn
#define TY_C           0x00020000	// ADD ESP,nnn after call to procedure
#define TY_NOTENTRY    0x00100000	// Not necessarily entry point
// Switch data-specific types.
#define TY_CHARSW      0x00100000	// ASCII switch
#define TY_WMSW        0x00200000	// Window message switch
#define TY_EXCEPTSW    0x00400000	// Exception switch
// Stack walk data-specific types.
#define TY_RELIABLE    0x01000000	// Reliable call
#define TY_GUESSED     0x02000000	// Not a real entry, just guessed
#define TY_BELONGS     0x04000000	// Not a real entry, just belongs to proc
// Call tree-specific types.
#define TY_RECURSIVE   0x00000100	// Routine calls self
#define TY_TERMINAL    0x00000200	// Leaf function, doesn't call others
#define TY_SYSTEM      0x00000400	// Function resides in system DLL
#define TY_DIRECT      0x00000800	// Called directly
#define TY_NODATA      0x00001000	// Not analyzed or outside procedure
#define TY_DUMMY       0x00002000	// Consists of single RET command
#define TY_NOSIDE      0x00004000	// No side effects except in stack

typedef struct t_scheme
{				// Color scheme
  char *name;			// Name of the scheme
  int textcolor;		// Colour used to draw text
  int hitextcolor;		// Colour used to draw highlited text
  int lowcolor;			// Colour used to draw auxiliary text
  int bkcolor;			// Colour used to draw backgrounds
  int selbkcolor;		// Colour used for selecting background
  int linecolor;		// Colour used for separating lines
  int auxcolor;			// Colour used for auxiliary objects
  int condbkcolor;		// Colour used for background of cond brk
} t_scheme;

typedef struct t_schemeopt
{				// Color scheme, alternative form
  char *name;			// Name of the scheme
  int color[8];			// Colours used as in t_scheme
} t_schemeopt;

typedef struct t_bar
{
  int nbar;			// Number of active columns
  int font;			// Font used for bar segments
  int dx[NBAR];			// Actual widths of columns, pixels
  int defdx[NBAR];		// Default widths of columns, chars
  char *name[NBAR];		// Column names (may be NULL)
  uchar mode[NBAR];		// Combination of BAR_xxx bits
  int captured;			// One of CAPT_xxx, set to CAPT_FREE
  int active;			// Info about how mouse is captured
  int prevx;			// Previous mouse coordinate
} t_bar;

typedef struct t_sortheader
{				// Header of sorted data field
  ulong addr;			// Base address of the entry
  ulong size;			// Size address of the entry
  ulong type;			// Entry type, TY_xxx
} t_sortheader;

typedef int SORTFUNC (const t_sortheader *, const t_sortheader *, const int);
typedef int DRAWFUNC (char *, char *, int *, t_sortheader *, int);
typedef void DESTFUNC (t_sortheader *);

#define AUTOARRANGE    ((SORTFUNC *)1)	// Autoarrangeable sorted data

typedef struct t_sorted
{				// Descriptor of sorted table
  char name[MAX_PATH];		// Name of table, as appears in error
  int n;			// Actual number of entries
  int nmax;			// Maximal number of entries
  int selected;			// Index of selected entry or -1
  ulong seladdr;		// Base address of selected entry
  int itemsize;			// Size of single entry
  ulong version;		// Unique version of table
  void *data;			// Entries, sorted by address
  SORTFUNC *sortfunc;		// Function which sorts data or NULL
  DESTFUNC *destfunc;		// Destructor function or NULL
  int sort;			// Sorting criterium (column)
  int sorted;			// Whether indexes are sorted
  int *index;			// Indexes, sorted by criterium
  int suppresserr;		// Suppress multiple overflow errors
} t_sorted;

typedef struct t_table
{				// Window with sorted data and bar
  HWND hw;			// Handle of window or NULL
  t_sorted data;		// Sorted data
  t_bar bar;			// Description of bar
  int showbar;			// Bar: 1-displayed, 0-hidden, -1-absent
  short hscroll;		// Horiz. scroll: 1-displayed, 0-hidden
  short colsel;			// Column in TABLE_COLSEL window
  int mode;			// Combination of bits TABLE_xxx
  int font;			// Font used by window
  short scheme;			// Colour scheme used by window
  short hilite;			// Syntax highlighting used by window
  int offset;			// First displayed row
  int xshift;			// Shift in X direction, pixels
  DRAWFUNC *drawfunc;		// Function which decodes table fields
} t_table;

extc int cdecl Createsorteddata (t_sorted * sd, char *name, int itemsize,
				 int nmax, SORTFUNC * sortfunc,
				 DESTFUNC * destfunc);
extc void cdecl Destroysorteddata (t_sorted * sd);
extc void cdecl *Addsorteddata (t_sorted * sd, void *item);
extc void cdecl Deletesorteddata (t_sorted * sd, ulong addr);
extc void cdecl Deletesorteddatarange (t_sorted * sd, ulong addr0,
				       ulong addr1);
extc int cdecl Deletenonconfirmedsorteddata (t_sorted * sd);
extc void *cdecl Findsorteddata (t_sorted * sd, ulong addr);
extc void *cdecl Findsorteddatarange (t_sorted * sd, ulong addr0,
				      ulong addr1);
extc int cdecl Findsorteddataindex (t_sorted * sd, ulong addr0, ulong addr1);
extc int cdecl Sortsorteddata (t_sorted * sd, int sort);
extc void *cdecl Getsortedbyselection (t_sorted * sd, int index);
extc void cdecl Defaultbar (t_bar * pb);
extc int cdecl Tablefunction (t_table * pt,
			      HWND hw, UINT msg, WPARAM wp, LPARAM lp);
extc void cdecl Painttable (HWND hw, t_table * pt, DRAWFUNC getline);
extc int cdecl Gettableselectionxy (t_table * pt, int column, int *px,
				    int *py);
extc void cdecl Selectandscroll (t_table * pt, int index, int mode);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// NAME FUNCTIONS ////////////////////////////////

// Types of names used in name functions. Note that higher-priority types have
// smaller identifiers!
#define NM_NONAME      0x00	// Undefined name
#define NM_ANYNAME     0xFF	// Name of any type
// Names saved in the data file of module they appear.
#define NM_PLUGCMD     0x30	// Plugin commands to execute at break
#define NM_LABEL       0x31	// User-defined label
#define NM_EXPORT      0x32	// Exported (global) name
#define NM_IMPORT      0x33	// Imported name
#define NM_LIBRARY     0x34	// Name from library or object file
#define NM_CONST       0x35	// User-defined constant
#define NM_COMMENT     0x36	// User-defined comment
#define NM_LIBCOMM     0x37	// Comment from library or object file
#define NM_BREAK       0x38	// Condition related with breakpoint
#define NM_ARG         0x39	// Arguments decoded by analyzer
#define NM_ANALYSE     0x3A	// Comment added by analyzer
#define NM_BREAKEXPR   0x3B	// Expression related with breakpoint
#define NM_BREAKEXPL   0x3C	// Explanation related with breakpoint
#define NM_ASSUME      0x3D	// Assume function with known arguments
#define NM_STRUCT      0x3E	// Code structure decoded by analyzer
#define NM_CASE        0x3F	// Case description decoded by analyzer
// Names saved in the data file of main module.
#define NM_INSPECT     0x40	// Several last inspect expressions
#define NM_WATCH       0x41	// Watch expressions
#define NM_ASM         0x42	// Several last assembled strings
#define NM_FINDASM     0x43	// Several last find assembler strings
#define NM_LASTWATCH   0x48	// Several last watch expressions
#define NM_SOURCE      0x49	// Several last source search strings
#define NM_REFTXT      0x4A	// Several last ref text search strings
#define NM_GOTO        0x4B	// Several last expressions to follow
#define NM_GOTODUMP    0x4C	// Several expressions to follow in Dump
#define NM_TRPAUSE     0x4D	// Several expressions to pause trace
// Pseudonames.
#define NM_IMCALL      0xFE	// Intermodular call

#define NMHISTORY      0x40	// Converts NM_xxx to type of init list

extc int cdecl Insertname (ulong addr, int type, char *name);
extc int cdecl Quickinsertname (ulong addr, int type, char *name);
extc void cdecl Mergequicknames (void);
extc void cdecl Discardquicknames (void);
extc int cdecl Findname (ulong addr, int type, char *name);
extc int cdecl Decodename (ulong addr, int type, char *name);
extc ulong cdecl Findnextname (char *name);
extc int cdecl Findlabel (ulong addr, char *name);
extc void cdecl Deletenamerange (ulong addr0, ulong addr1, int type);
extc int cdecl Findlabelbyname (char *name, ulong * addr,
				ulong addr0, ulong addr1);
extc ulong cdecl Findimportbyname (char *name, ulong addr0, ulong addr1);
extc int cdecl Demanglename (char *name, int type, char *undecorated);
extc int cdecl Findsymbolicname (ulong addr, char *fname);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DISASSEMBLY FUNCTIONS /////////////////////////////

#define REG_EAX        0	// Indexes of general-purpose registers
#define REG_ECX        1	// in t_reg.
#define REG_EDX        2
#define REG_EBX        3
#define REG_ESP        4
#define REG_EBP        5
#define REG_ESI        6
#define REG_EDI        7

#define SEG_UNDEF     -1
#define SEG_ES         0	// Indexes of segment/selector registers
#define SEG_CS         1	// in t_reg.
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5

// Selected items in register window.
#define RS_NONE        0x0000	// No selection
#define RS_INT         0x0010	// General-purpose 32-bit registers
#define RS_EIP         0x0020	// EIP (instruction pointer)
#define RS_FLG         0x0030	// 1-bit decoded flags
#define RS_SEG         0x0040	// Segment (selector) registers
#define RS_EFL         0x0050	// 32-bit flag register
#define RS_TAG         0x0060	// FPU register tag
#define RS_FPU         0x0070	// 80-bit FPU registers
#define RS_FST         0x0080	// FPU status
#define RS_FCO         0x0090	// FPU condition bits
#define RS_FER         0x00A0	// FPU error bits
#define RS_FCW         0x00B0	// FPU control word
#define RS_FPR         0x00C0	// FPU precision fields
#define RS_FEM         0x00D0	// FPU error mask bits
#define RS_MMX         0x00E0	// MMX registers
#define RS_3DN         0x00F0	// 3DNow! registers
#define RS_SSE         0x0100	// SSE registers
#define RS_CSR         0x0110	// SSE MXCSR register
#define RS_CSB         0x0120	// SSE MXCSR bits
#define RS_CPR         0x0130	// SSE rounding control
#define RS_ERR         0x0140	// Last thread error

#define RS_GROUP       0x01F0	// Mask to extract group of registers
#define RS_INDEX       0x000F	// Mask to extract index of register

#define NREGSTACK      32	// Length of stack trace buffer
#define MAXCALSIZE     8	// Max length of CALL without prefixes

#define INT3           0xCC	// Code of 1-byte breakpoint
#define NOP            0x90	// Code of 1-byte NOP command
#define TRAPFLAG       0x00000100	// Trap flag in CPU flag register

#define C_TYPEMASK     0xF0	// Mask for command type
#define   C_CMD        0x00	// Ordinary instruction
#define   C_PSH        0x10	// PUSH instruction
#define   C_POP        0x20	// POP instruction
#define   C_MMX        0x30	// MMX instruction
#define   C_FLT        0x40	// FPU instruction
#define   C_JMP        0x50	// JUMP instruction
#define   C_JMC        0x60	// Conditional JUMP instruction
#define   C_CAL        0x70	// CALL instruction
#define   C_RET        0x80	// RET instruction
#define   C_FLG        0x90	// Changes system flags
#define   C_RTF        0xA0	// C_JMP and C_FLG simultaneously
#define   C_REP        0xB0	// Instruction with REPxx prefix
#define   C_PRI        0xC0	// Privileged instruction
#define   C_SSE        0xD0	// SSE instruction
#define   C_NOW        0xE0	// 3DNow! instruction
#define   C_BAD        0xF0	// Unrecognized command
#define C_RARE         0x08	// Rare command, seldom used in programs
#define C_SIZEMASK     0x07	// MMX data size or special flag
#define   C_EXPL       0x01	// (non-MMX) Specify explicit memory size

#define C_DANGER95     0x01	// Command is dangerous under Win95/98
#define C_DANGER       0x03	// Command is dangerous everywhere
#define C_DANGERLOCK   0x07	// Dangerous with LOCK prefix

#define DEC_TYPEMASK   0x1F	// Type of memory byte
#define   DEC_UNKNOWN  0x00	// Unknown type
#define   DEC_BYTE     0x01	// Accessed as byte
#define   DEC_WORD     0x02	// Accessed as short
#define   DEC_NEXTDATA 0x03	// Subsequent byte of data
#define   DEC_DWORD    0x04	// Accessed as long
#define   DEC_FLOAT4   0x05	// Accessed as float
#define   DEC_FWORD    0x06	// Accessed as descriptor/long pointer
#define   DEC_FLOAT8   0x07	// Accessed as double
#define   DEC_QWORD    0x08	// Accessed as 8-byte integer
#define   DEC_FLOAT10  0x09	// Accessed as long double
#define   DEC_TBYTE    0x0A	// Accessed as 10-byte integer
#define   DEC_STRING   0x0B	// Zero-terminated ASCII string
#define   DEC_UNICODE  0x0C	// Zero-terminated UNICODE string
#define   DEC_3DNOW    0x0D	// Accessed as 3Dnow operand
#define   DEC_SSE      0x0E	// Accessed as SSE operand
#define   DEC_TEXT     0x10	// For use in t_result only
#define   DEC_BYTESW   0x11	// Accessed as byte index to switch
#define   DEC_NEXTCODE 0x13	// Subsequent byte of command
#define   DEC_COMMAND  0x1D	// First byte of command
#define   DEC_JMPDEST  0x1E	// Jump destination
#define   DEC_CALLDEST 0x1F	// Call (and maybe jump) destination
#define DEC_PROCMASK   0x60	// Procedure analysis
#define   DEC_PROC     0x20	// Start of procedure
#define   DEC_PBODY    0x40	// Body of procedure
#define   DEC_PEND     0x60	// End of procedure
#define DEC_CHECKED    0x80	// Byte was analysed
#define DEC_SIGNED     0x100	// For use in t_result only

#define DISASM_SIZE    0	// Determine command size only
#define DISASM_DATA    1	// Determine size and analysis data
#define DISASM_TRACE   2	// Trace integer registers
#define DISASM_FILE    3	// Disassembly, no symbols/registers
#define DISASM_CODE    4	// Disassembly, registers undefined
#define DISASM_ALL     5	// Complete disassembly
#define DISASM_RTRACE  6	// Disassemble with run-trace registers

#define DISASM_MODE    0x0000000F	// Mask to extract disassembling mode
#define DISASM_HILITE  0x000F0000	// Mask to extract highlighting mode
#define DISASM_HLSHIFT 16	// Shift to extract highlighting mode

// Warnings issued by Disasm():
#define DAW_FARADDR    0x0001	// Command is a far jump, call or return
#define DAW_SEGMENT    0x0002	// Command loads segment register
#define DAW_PRIV       0x0004	// Privileged command
#define DAW_IO         0x0008	// I/O command
#define DAW_SHIFT      0x0010	// Shift constant out of range 1..31
#define DAW_PREFIX     0x0020	// Superfluous prefix
#define DAW_LOCK       0x0040	// Command has LOCK prefix
#define DAW_STACK      0x0080	// Unaligned stack operation
#define DAW_DANGER95   0x1000	// May mess up Win95/98 if executed
#define DAW_DANGEROUS  0x3000	// May mess up any OS if executed

#define RST_INVALID    0	// Register undefined
#define RST_VALUE      1	// Register contains regdata
#define RST_VFIXUP     2	// Reg contains regdata that is fixup
#define RST_INDIRECT   3	// Register contains [regdata]

#define NREGSTACK      32	// Length of stack trace buffer



typedef struct t_reg
{				// Excerpt from context
  int modified;			// Some regs modified, update context
  int modifiedbyuser;		// Among modified, some modified by user
  int singlestep;		// Type of single step, SS_xxx
  ulong r[8];			// EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
  ulong ip;			// Instruction pointer (EIP)
  ulong flags;			// Flags
  int top;			// Index of top-of-stack
  long double f[8];		// Float registers, f[top] - top of stack
  char tag[8];			// Float tags (0x3 - empty register)
  ulong fst;			// FPU status word
  ulong fcw;			// FPU control word
  ulong s[6];			// Segment registers ES,CS,SS,DS,FS,GS
  ulong base[6];		// Segment bases
  ulong limit[6];		// Segment limits
  char big[6];			// Default size (0-16, 1-32 bit)
  ulong dr6;			// Debug register DR6
  ulong threadid;		// ID of thread that owns registers
  ulong lasterror;		// Last thread error or 0xFFFFFFFF
  int ssevalid;			// Whether SSE registers valid
  int ssemodified;		// Whether SSE registers modified
  char ssereg[8][16];		// SSE registers
  ulong mxcsr;			// SSE control and status register
  int selected;			// Reports selected register to plugin
  ulong drlin[4];		// Debug registers DR0..DR3
  ulong dr7;			// Debug register DR7
} t_reg;

typedef struct t_operand
{				// Full decription of command's operand
  char optype;			// DEC_xxx (mem) or DECR_xxx (reg,const)
  char opsize;			// Size of operand
  char regscale[8];		// Scales of registers
  char seg;			// Segment register
  ulong opconst;		// Constant
} t_operand;

typedef struct t_disasm
{				// Results of disassembling
  ulong ip;			// Instrucion pointer
  char dump[TEXTLEN];		// Hexadecimal dump of the command
  char result[TEXTLEN];		// Disassembled command
  char comment[TEXTLEN];	// Brief comment
  char opinfo[3][TEXTLEN];	// Comments to command's operands
  int cmdtype;			// One of C_xxx
  int memtype;			// Type of addressed variable in memory
  int nprefix;			// Number of prefixes
  int indexed;			// Address contains register(s)
  ulong jmpconst;		// Constant jump address
  ulong jmptable;		// Possible address of switch table
  ulong adrconst;		// Constant part of address
  ulong immconst;		// Immediate constant
  int zeroconst;		// Whether contains zero constant
  int fixupoffset;		// Possible offset of 32-bit fixups
  int fixupsize;		// Possible total size of fixups or 0
  ulong jmpaddr;		// Destination of jump/call/return
  int condition;		// 0xFF:unconditional, 0:false, 1:true
  int error;			// Error while disassembling command
  int warnings;			// Combination of DAW_xxx
  int optype[3];		// Type of operand (extended set DEC_xxx)
  int opsize[3];		// Size of operand, bytes
  int opgood[3];		// Whether address and data valid
  ulong opaddr[3];		// Address if memory, index if register
  ulong opdata[3];		// Actual value (only integer operands)
  t_operand op[3];		// Full description of operand
  ulong regdata[8];		// Registers after command is executed
  int regstatus[8];		// Status of registers, one of RST_xxx
  ulong addrdata;		// Traced memory address
  int addrstatus;		// Status of addrdata, one of RST_xxx
  ulong regstack[NREGSTACK];	// Stack tracing buffer
  int rststatus[NREGSTACK];	// Status of stack items
  int nregstack;		// Number of items in stack trace buffer
  ulong reserved[29];		// Reserved for plugin compatibility
} t_disasm;

extc ulong cdecl Disasm (uchar * src, ulong srcsize, ulong srcip,
			 uchar * srcdec, t_disasm * disasm, int disasmmode,
			 ulong threadid);
extc ulong cdecl Disassembleback (uchar * block, ulong base, ulong size,
				  ulong ip, int n, int usedec);
extc ulong cdecl Disassembleforward (uchar * block, ulong base, ulong size,
				     ulong ip, int n, int usedec);
extc int cdecl Issuspicious (char *cmd, ulong size, ulong ip, ulong threadid,
			     t_reg * preg, char *s);
extc int cdecl Isfilling (ulong offset, char *data, ulong size, ulong align);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////// ASSEMBLY FUNCTIONS //////////////////////////////

extc int cdecl Assemble (char *cmd, ulong ip, t_asmmodel * model, int attempt,
			 int constsize, char *errtext);

extc int cdecl Simpleassemble (char *cmd,ulong ip, t_asmmodel * model, int attempt,
			       int constsize, char *errtext);


extc int cdecl Checkcondition (int code, ulong flags);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// EXPRESSIONS //////////////////////////////////

typedef struct t_result
{				// Result of expression's evaluation
  int type;			// Type of expression, DEC(R)_xxx
  int dtype;			// Type of data, DEC_xxx
  union
  {
    uchar data[10];		// Binary form of expression's value
    ulong u;			// Value as unsigned integer
    long l;			// Value as signed integer
    long double f;
  };				// Value as 80-bit float
  union
  {
	char value[TEXTLEN];	// ASCII form of expression's value
    wchar_t wvalue[TEXTLEN / 2];
  };				// UNICODE form of expression's value
  ulong lvaddr;			// Address of lvalue or NULL
} t_result;

extc int cdecl Expression (t_result * result, char *expression, int a, int b,
			   uchar * data, ulong database, ulong datasize,
			   ulong threadid);

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// THREAD FUNCTIONS ///////////////////////////////

typedef struct t_thread
{				// Information about active threads
  ulong threadid;		// Thread identifier
  ulong dummy;			// Always 1
  ulong type;			// Service information, TY_xxx
  HANDLE thread;		// Thread handle
  ulong datablock;		// Per-thread data block
  ulong entry;			// Thread entry point
  ulong stacktop;		// Working variable of Listmemory()
  ulong stackbottom;		// Working variable of Listmemory()
  CONTEXT context;		// Actual context of the thread
  t_reg reg;			// Actual contents of registers
  int regvalid;			// Whether reg is valid
  t_reg oldreg;			// Previous contents of registers
  int oldregvalid;		// Whether oldreg is valid
  int suspendcount;		// Suspension count (may be negative)
  long usertime;		// Time in user mode, 1/10th ms, or -1
  long systime;			// Time in system mode, 1/10th ms, or -1
  ulong reserved[16];		// Reserved for future compatibility
} t_thread;

extc HWND cdecl Createthreadwindow (void);
extc t_thread *cdecl Findthread (ulong threadid);
extc int cdecl Decodethreadname (char *s, ulong threadid, int mode);
extc ulong cdecl Getcputhreadid (void);
extc ulong cdecl Runsinglethread (ulong threadid);
extc void cdecl Restoreallthreads (void);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MEMORY FUNCTIONS ///////////////////////////////

// Mode bits recognized by Readmemory() and Writememory().
#define MM_RESTORE     0x01	// Restore or remove INT3 breakpoints
#define MM_SILENT      0x02	// Don't display error message
#define MM_DELANAL     0x04	// Delete analysis from the memory

#define MM_RESILENT    (MM_RESTORE|MM_SILENT)

typedef struct t_memory
{				// Memory block descriptor
  ulong base;			// Base address of memory block
  ulong size;			// Size of block
  ulong type;			// Service information, TY_xxx
  ulong owner;			// Address of owner of the memory
  ulong initaccess;		// Initial read/write access
  ulong access;			// Actual status and read/write access
  ulong threadid;		// Block belongs to this thread or 0
  char sect[SHORTLEN];		// Name of module section
  uchar *copy;			// Copy used in CPU window or NULL
  ulong reserved[8];		// Reserved for plugin compatibility
} t_memory;

typedef struct t_heap
{				// Heap block descriptor
  ulong base;			// Base address of heap block
  ulong size;			// Size of heap block
  ulong type;			// Service information, TY_xxx
  ulong parent;			// Handle of heap descriptor block
} t_heap;

extc int cdecl Listmemory (void);
extc int cdecl Scanmodules (void);
extc t_memory *cdecl Findmemory (ulong addr);
extc int cdecl Guardmemory (ulong base, ulong size, int guard);
extc void cdecl Havecopyofmemory (uchar * copy, ulong base, ulong size);
extc ulong cdecl Readmemory (void *buf, ulong addr, ulong size, int mode);
extc ulong cdecl Writememory (void *buf, ulong addr, ulong size, int mode);
extc ulong cdecl Readcommand (ulong ip, char *cmd);

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MODULE FUNCTIONS ///////////////////////////////

#define NVERS          32	// Max allowed length of file version

// Types of recognized jumps.
#define JT_JUMP        0	// Unconditional jump
#define JT_COND        1	// Conditional jump
#define JT_SWITCH      2	// Jump via switch table
#define JT_CALL        3	// Local (intramodular) call

typedef struct t_ahint
{				// User-supplied hint for analysis
  ulong addr;			// Hint address
  ulong size;			// Hint size
  ulong type;			// Hint type, bits from DEC_TYPEMASK
} t_ahint;

typedef struct t_stringtable
{				// Pointers to string resources
  ulong name;			// Name of block of strings
  ulong language;		// Language identifier
  ulong addr;			// Address of block in memory
  ulong size;			// Size of block in memory
} t_stringtable;

typedef struct t_fixup
{
  ulong base;			// Address of fixup
  ulong size;			// Size of fixup (usually 2 or 4 bytes)
} t_fixup;

typedef struct t_symvar
{				// Symbolic variable from debug data
  int next;			// Index of next variable in chain or -1
  ushort kind;			// Kind of variable
  union
  {
    ulong type;			// Type of variable
    ulong regs;
  };				// Registers in optvar
  union
  {
    ulong addr;			// Address or description of registers
    long offset;
  };				// Offset for EBP-relative data
  ulong size;			// Size of variable or optvar data
  int optvar;			// Index of optvar chain or -1
  ulong nameaddr;		// NM_DEBUG address of var's name
} t_symvar;

typedef struct t_jdest
{				// Element of jump data
  char type;			// Type of jump, one of JT_xxx
  ulong from;			// Jump source
  ulong to;			// Jump destination
} t_jdest;

typedef struct t_module
{				// Executable module descriptor
  ulong base;			// Base address of module
  ulong size;			// Size occupied by module
  ulong type;			// Service information, TY_xxx
  ulong codebase;		// Base address of module code block
  ulong codesize;		// Size of module code block
  ulong resbase;		// Base address of resources
  ulong ressize;		// Size of resources
  t_stringtable *stringtable;	// Pointers to string resources or NULL
  int nstringtable;		// Actual number of used stringtable
  int maxstringtable;		// Actual number of allocated stringtable
  ulong entry;			// Address of <ModuleEntryPoint> or NULL
  ulong database;		// Base address of module data block
  ulong idatatable;		// Base address of import data table
  ulong idatabase;		// Base address of import data block
  ulong edatatable;		// Base address of export data table
  ulong edatasize;		// Size of export data table
  ulong reloctable;		// Base address of relocation table
  ulong relocsize;		// Size of relocation table
  char name[SHORTLEN];		// Short name of the module
  char path[MAX_PATH];		// Full name of the module
  int nsect;			// Number of sections in the module
  IMAGE_SECTION_HEADER *sect;	// Copy of section headers from file
  ulong headersize;		// Total size of headers in executable
  ulong fixupbase;		// Base of image in executable file
  int nfixup;			// Number of fixups in executable
  t_fixup *fixup;		// Extracted fixups or NULL
  char *codedec;		// Decoded code features or NULL
  ulong codecrc;		// Code CRC for actual decoding
  char *hittrace;		// Hit tracing data or NULL
  char *hittracecopy;		// Copy of INT3-substituted code
  char *datadec;		// Decoded data features or NULL
  t_table namelist;		// List of module names
  t_symvar *symvar;		// Descriptions of symbolic variables
  int nsymvar;			// Actual number of elements in symvar
  int maxsymvar;		// Maximal number of elements in symvar
  char *globaltypes;		// Global types from debug info
  ulong mainentry;		// Address of WinMain() etc. in dbg data
  ulong realsfxentry;		// Entry of packed code or NULL
  int updatenamelist;		// Request to update namelist
  ulong origcodesize;		// Original size of module code block
  ulong sfxbase;		// Base of memory block with SFX
  ulong sfxsize;		// Size of memory block with SFX
  int issystemdll;		// Whether system DLL
  int processed;		// 0: not processed, 1: good, -1: bad
  int dbghelpsym;		// 1: symbols loaded by dbghelp.dll
  char version[NVERS];		// Version of executable file
  t_jdest *jddata;		// Recognized jumps within the module
  int njddata;			// Number of recognized jumps
  ulong reserved[15];		// Reserved for plugin compatibility
  int analysed;			// 0 not analysed 1 analysed
} t_module;

extc t_module *cdecl Findmodule (ulong addr);
extc t_fixup *cdecl Findfixup (t_module * pmod, ulong addr);
extc uchar *cdecl Finddecode (ulong addr, ulong * psize);
extc ulong cdecl Findfileoffset (t_module * pmod, ulong addr);
extc int cdecl Decoderange (ulong addr, ulong size, char *s);
extc int cdecl Analysecode (t_module * pm);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// DUMP /////////////////////////////////////

// Standard dump types.
#define DU_ESCAPABLE   0x20000L	// Create escapable dump window
#define DU_BACKUP      0x10000L	// Bit indicates that backup is displayed
#define DU_TYPE        0x0F000L	// Mask for dump type
#define DU_COUNT       0x00FF0L	// Mask for number of items/line
#define DU_SIZE        0x0000FL	// Mask for size of single item

#define DU_UNDEF       0x00000L	// Undefined dump type
#define DU_HEXTEXT     0x01000L	// Hexadecimal dump with ASCII text
#define DU_TEXT        0x02000L	// Character dump
#define DU_UNICODE     0x03000L	// Unicode dump
#define DU_INT         0x04000L	// Integer signed dump
#define DU_UINT        0x05000L	// Integer unsigned dump
#define DU_IHEX        0x06000L	// Integer hexadecimal dump
#define DU_FLOAT       0x07000L	// Floating-point dump
#define DU_ADDR        0x08000L	// Address dump
#define DU_DISASM      0x09000L	// Disassembly
#define DU_HEXUNI      0x0A000L	// Hexadecimal dump with UNICODE text
#define DU_ADRASC      0x0B000L	// Address dump with ASCII text
#define DU_ADRUNI      0x0C000L	// Address dump with UNICODE text
#define DU_SPEC        0x0D000L	// Special decoding

// Standard menu types.
#define MT_BACKUP      0x0001	// Backup, Undo
#define MT_COPY        0x0002	// Copy to clipboard
#define MT_EDIT        0x0004	// Edit, Modify, Assemble
#define MT_SEARCH      0x0008	// Search, Next
#define MT_DHISTORY    0x0010	// Previous, Next in history

typedef ulong SPECFUNC (char *, ulong, ulong, ulong, t_disasm *, int);

typedef struct t_dump
{				// Current status of dump window
  t_table table;		// Treat dump window as custom table
  int dimmed;			// Draw in lowcolor if nonzero
  ulong threadid;		// Use decoding and registers if not 0
  int dumptype;			// Current dump type, DU_xxx+count+size
  SPECFUNC *specdump;		// Decoder of DU_SPEC dump types
  int menutype;			// Standard menues, MT_xxx
  int itemwidth;		// Length of displayed item, characters
  int showstackframes;		// Show stack frames in address dump
  int showstacklocals;		// Show names of locals in stack
  int commentmode;		// 0: comment, 1: source, 2: profile
  char filename[MAX_PATH];	// Name of displayed or backup file
  ulong base;			// Start of memory block or file
  ulong size;			// Size of memory block or file
  ulong addr;			// Address of first displayed byte
  ulong lastaddr;		// Address of last displayed byte + 1
  ulong sel0;			// Address of first selected byte
  ulong sel1;			// Last selected byte (not included!)
  ulong startsel;		// Start of last selection
  int captured;			// Mouse is captured by dump
  ulong reladdr;		// Addresses relative to this
  char relname[SHORTLEN];	// Symbol for relative zero address base
  uchar *filecopy;		// Copy of the file or NULL
  uchar *backup;		// Old backup of memory/file or NULL
  int runtraceoffset;		// Offset back in run trace
  ulong reserved[8];		// Reserved for the future extentions
} t_dump;

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// WINDOW FUNCTIONS ///////////////////////////////

#define WM_USER_MENU   (WM_USER+101)	// Activate context-sensitive menu
#define WM_USER_SCR    (WM_USER+102)	// Redraw scroll(s)
#define WM_USER_SAVE   (WM_USER+103)	// Save data to disk
#define WM_USER_VABS   (WM_USER+104)	// Scroll contents of window by lines
#define WM_USER_VREL   (WM_USER+105)	// Scroll contents of window by percent
#define WM_USER_VBYTE  (WM_USER+106)	// Scroll contents of window by bytes
#define WM_USER_STS    (WM_USER+107)	// Start selection in window
#define WM_USER_CNTS   (WM_USER+108)	// Continue selection in window
#define WM_USER_CHGS   (WM_USER+109)	// Move single-line selection
#define WM_USER_BAR    (WM_USER+110)	// Message from bar segment as button
#define WM_USER_DBLCLK (WM_USER+111)	// Doubleclick in column
#define WM_USER_SIZE   (WM_USER+112)	// Resize children in CPU window
#define WM_USER_FOCUS  (WM_USER+113)	// Set focus to child of CPU window
#define WM_USER_FILE   (WM_USER+114)	// Change state of file dump
#define WM_USER_HERE   (WM_USER+115)	// Query presence list
#define WM_USER_CHALL  (WM_USER+116)	// Redraw (almost) everything
#define WM_USER_CHMEM  (WM_USER+117)	// Range of debuggee's memory changed
#define WM_USER_CHREG  (WM_USER+118)	// Debuggee's register(s) changed
#define WM_USER_CHNAM  (WM_USER+119)	// Redraw name tables
#define WM_USER_MOUSE  (WM_USER+120)	// Check mouse coordinates
#define WM_USER_KEY    (WM_USER+121)	// Emulate WM_KEYDOWN
#define WM_USER_SYSKEY (WM_USER+122)	// Emulate WM_SYSKEYDOWN

// Constants used for scrolling and selection.
#define MAXTRACK       16384	// Maximal scroll of user-drawn table
#define MOVETOP        0x7FFFFFFFL	// Move selection to top of table
#define MOVEBOTTOM     0x7FFFFFFEL	// Move selection to bottom of table

#define CONT_BROADCAST 0x0000	// Continue sending msg to other windows
#define STOP_BROADCAST 0x1234	// Stop sending message to other windows

// Dumpbackup() actions.
#define BKUP_CREATE    1	// Create or update backup copy
#define BKUP_VIEWDATA  2	// View original data
#define BKUP_VIEWCOPY  3	// View backup copy
#define BKUP_LOADCOPY  4	// Read backup copy from file
#define BKUP_SAVEDATA  5	// Save original data to file
#define BKUP_SAVECOPY  6	// Save backup copy to file
#define BKUP_DELETE    7	// Delete backup copy

extc int cdecl Registerotclass (char *classname,
				char *iconname, WNDPROC classproc);
extc HWND cdecl Newtablewindow (t_table * pt, int nlines, int maxcolumns,
				char *winclass, char *wintitle);
extc HWND cdecl Quicktablewindow (t_table * pt, int nlines, int maxcolumns,
				  char *winclass, char *wintitle);
extc HWND cdecl Createdumpwindow (char *name, ulong base, ulong size,
				  ulong addr, int type, SPECFUNC * specdump);
extc void cdecl Setdumptype (t_dump * pd, int dumptype);
extc void cdecl Dumpbackup (t_dump * pd, int action);
extc int cdecl Broadcast (UINT msg, WPARAM wp, LPARAM lp);

////////////////////////////////////////////////////////////////////////////////
////////////////////////// DATA CONVERSION FUNCTIONS ///////////////////////////

extc ulong cdecl Compress (uchar * bufin, ulong nbufin,
			   uchar * bufout, ulong nbufout);
extc ulong cdecl Getoriginaldatasize (char *bufin, ulong nbufin);
extc ulong cdecl Decompress (uchar * bufin, ulong nbufin,
			     uchar * bufout, ulong nbufout);
extc ulong cdecl Calculatecrc (uchar * copy, ulong base, ulong size,
			       t_module * pmod, ulong fixupoffset);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// REFERENCES AND SEARCH /////////////////////////////

typedef struct t_ref
{				// Description of reference
  ulong addr;			// Address of reference
  ulong size;			// 1: single command, otherwise size
  ulong type;			// Type of reference, TY_xxx
  ulong dest;			// Destination of call
} t_ref;



extc int cdecl Findreferences (ulong base, ulong size, ulong addr0,
			       ulong addr1, ulong origin, int recurseonjump,
			       char *title);
extc int cdecl Findstrings (ulong base, ulong size, ulong origin,
			    char *title);
extc int cdecl Findalldllcalls (t_dump * pd, ulong origin, char *title);
extc int cdecl Findallcommands (t_dump * pd, t_asmmodel * model,
				ulong origin, char *title);
extc int cdecl Findallsequences (t_dump * pd, t_extmodel model[NSEQ][NMODELS],
				 ulong origin, char *title, t_module * pmod);
extc void cdecl Prepareasmseq (char asmcmd[ARGLEN],
			       t_extmodel model[NSEQ][NMODELS]);
extc ulong cdecl Walkreference (int dir);
extc ulong cdecl Walkreferenceex (int dir, ulong * size);

////////////////////////////////////////////////////////////////////////////////
//////////////////////// BREAKPOINT AND TRACE FUNCTIONS ////////////////////////

#define MEMBP_READ     0x0001	// Memory breakpoint on read
#define MEMBP_WRITE    0x0002	// Memory breakpoint on write
#define MEMBP_SFX      0x1000	// Skip self-extraction

// Bits of module hit trace buffer.
#define TR_HIT         0x01	// Command was executed during trace
#define TR_SET         0x02	// Code INT3 is in memory, copy valid
#define TR_RTSKIP      0x20	// Disable run trace on command
#define TR_RTRACE      0x40	// Force run trace on command
#define TR_TRACE       0x80	// Command is included in trace

#define HB_FREE        0	// Breakpoint is not used
#define HB_CODE        1	// Active on command execution
#define HB_ACCESS      2	// Active on read/write access
#define HB_WRITE       3	// Active on write access
#define HB_IO          4	// Active on port I/O
#define HB_ONESHOT     5	// One-shot on command execution
#define HB_STOPAN      6	// One-shot on command and stop
#define HB_TEMP        7	// Temporary on command execution

// Parameter mode of function Modifyhittrace().
#define ATR_ADD        1	// Add trace to buffer
#define ATR_ADDPROC    2	// Add only recognized procedures
#define ATR_RESET      3	// Mark range as not traced
#define ATR_REMOVE     4	// Remove range and breakpoints
#define ATR_REMOVEALL  5	// Destroy range and breakpoints
#define ATR_RESTORE    6	// Restore breakpoints
#define ATR_RTRADD     7	// Add trace and force run trace
#define ATR_RTRJUMPS   8	// Add trace and run trace jumps only
#define ATR_RTRENTRY   9	// Add trace and run trace entries only
#define ATR_RTREMOVE   10	// Remove trace from range
#define ATR_RTSKIP     11	// Skip when run tracing

// Breakpoint conditions (first byte of NM_BREAKEXPR associated with
// breakpoint). Strange settings of bits COND_NOBREAK and COND_BRKALWAYS are
// for backward compatibility with version 1.0. If both bits are 0, program
// pauses when condition is met. If both bits are set, COND_NOBREAK has higher
// priority.
#define COND_NOBREAK   0x01	// Don't break on this breakpoint
#define COND_LOGTRUE   0x02	// Log expression if condition true
#define COND_LOGALWAYS 0x04	// Log expression each pass
#define COND_ARGTRUE   0x08	// Log arguments if condition true
#define COND_ARGALWAYS 0x10	// Log arguments each pass
#define COND_BRKALWAYS 0x20	// Always break on this breakpoint
#define COND_MASK      0x3F	// Mask for conditional break type bits
#define COND_FILLING   0x40	// Used to assure that byte is non-zero

typedef struct t_bpoint
{				// Description of INT3 breakpoint
  ulong addr;			// Address of breakpoint
  ulong dummy;			// Always 1
  ulong type;			// Type of breakpoint, TY_xxx
  char cmd;			// Old value of command
  ulong passcount;		// Actual pass count
} t_bpoint;

typedef struct t_hardbpoint
{				// Description of hardware breakpoint
  ulong addr;			// Base address of hardware breakpoint
  int size;			// Size of hardware breakpoint
  int type;			// Type of breakpoint, one of HB_xxx
  ulong reserved[4];		// Reserved for the future
} t_hardbpoint;

extc int cdecl Setbreakpoint (ulong addr, ulong type, uchar cmd);
extc int cdecl Setbreakpointext (ulong addr, ulong type, char cmd,
				 ulong passcount);
extc int cdecl Manualbreakpoint (ulong addr,
				 int key, int shiftkey, ulong nametype,
				 int font);
extc void cdecl Deletebreakpoints (ulong addr0, ulong addr1, int silent);
extc ulong cdecl Getbreakpointtype (ulong addr);
extc ulong cdecl Getbreakpointtypecount (ulong addr, ulong * passcount);
extc ulong cdecl Getnextbreakpoint (ulong addr, ulong * type, int *cmd);
extc void cdecl Tempbreakpoint (ulong addr, int mode);
extc int cdecl Hardbreakpoints (int closeondelete);
extc int cdecl Sethardwarebreakpoint (ulong addr, int size, int type);
extc int cdecl Deletehardwarebreakpoint (int index);
extc int cdecl Deletehardwarebreakbyaddr (ulong addr);
extc int cdecl Setmembreakpoint (int type, ulong addr, ulong size);
extc uchar *cdecl Findhittrace (ulong addr, uchar ** ptracecopy,
				ulong * psize);
extc int cdecl Modifyhittrace (ulong addr0, ulong addr1, int mode);
extc ulong cdecl Isretaddr (ulong retaddr, ulong * procaddr);
extc HWND cdecl Creatertracewindow (void);
extc void cdecl Settracecondition (char *cond, int onsuspicious,
				   ulong in0, ulong in1, ulong out0,
				   ulong out1);
extc void cdecl Settracecount (ulong count);
extc void cdecl Settracepauseoncommands (char *cmdset);
extc int cdecl Startruntrace (t_reg * preg);
extc void cdecl Deleteruntrace (void);
extc int cdecl Runtracesize (void);
extc int cdecl Findprevruntraceip (ulong ip, int startback);
extc int cdecl Findnextruntraceip (ulong ip, int startback);
extc int cdecl Getruntraceregisters (int nback, t_reg * preg,
				     t_reg * pold, char *cmd, char *comment);
extc int cdecl Getruntraceprofile (ulong addr, ulong size, ulong * profile);
extc void cdecl Scrollruntracewindow (int back);
extc HWND cdecl Createprofilewindow (ulong base, ulong size);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// CODE INJECTION ////////////////////////////////

typedef int INJECTANSWER (char *data, ulong datasize, ulong parm2);

typedef struct t_inject
{				// Description of injected code
  ulong codesize;		// Size of code, including INT3
  char *code;			// Pointer to code
  int stacksize;		// Stack size to save
  int datatype;			// 0: in/out, 1: in, 2: out
} t_inject;

extc int cdecl Injectcode (ulong threadid, t_inject * inject, char *data,
			   ulong datasize, ulong parm1, ulong parm2,
			   INJECTANSWER * answerfunc);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// CPU-SPECIFIC FUNCTIONS ////////////////////////////

// Setcpu modes.
#define CPU_ASMHIST    0x00001	// Add change to Disassembler history
#define CPU_ASMCENTER  0x00004	// Make address in the middle of window
#define CPU_ASMFOCUS   0x00008	// Move focus to Disassembler
#define CPU_DUMPHIST   0x00010	// Add change to Dump history
#define CPU_DUMPFIRST  0x00020	// Make address the first byte in Dump
#define CPU_DUMPFOCUS  0x00080	// Move focus to Dump
#define CPU_REGAUTO    0x00100	// Automatically switch to FPU/MMX/3DNow!
#define CPU_RUNTRACE   0x00200	// Show run trace data at offset asmaddr
#define CPU_STACKFOCUS 0x00800	// Move focus to Stack
#define CPU_NOCREATE   0x04000	// Don't create CPU window if absent
#define CPU_REDRAW     0x08000	// Redraw CPU window immediately
#define CPU_NOFOCUS    0x10000	// Don't assign focus to main window

extc void cdecl Setcpu (ulong threadid, ulong asmaddr,
			ulong dumpaddr, ulong stackaddr, int mode);
extc int cdecl Areggettext (char *s, char *mask, int *select,
			    t_sortheader * ph, int column);
extc int cdecl Arefgettext (char *s, char *mask, int *select,
			    t_sortheader * ph, int column);
extc void cdecl Setdisasm (ulong asmaddr, ulong selsize, int mode);
extc void cdecl Redrawdisassembler (void);
extc void cdecl Getdisassemblerrange (ulong * pbase, ulong * psize);
extc ulong cdecl Findprocbegin (ulong addr);
extc ulong cdecl Findprocend (ulong addr);
extc ulong cdecl Findprevproc (ulong addr);
extc ulong cdecl Findnextproc (ulong addr);
extc int cdecl Getproclimits (ulong addr, ulong * start, ulong * end);

extc void cdecl Sendshortcut (int where, ulong addr,
			      int msg, int ctrl, int shift, int vkcode);

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// PROCESS CONTROL ////////////////////////////////

// Parameter stepmode in call to Go().
#define STEP_SAME      0	// Same action as on previous call
#define STEP_RUN       1	// Run program
#define STEP_OVER      2	// Step over
#define STEP_IN        3	// Step in
#define STEP_SKIP      4	// Skip sequence

typedef enum t_status
{				// Thread/process status
  STAT_NONE = 0,		// Thread/process is empty
  STAT_STOPPED,			// Thread/process suspended
  STAT_EVENT,			// Processing debug event, process paused
  STAT_RUNNING,			// Thread/process running
  STAT_FINISHED,		// Process finished
  STAT_CLOSING			// Process is requested to terminate
} t_status;

extc t_status cdecl Getstatus (void);
extc int cdecl Go (ulong threadid, ulong tilladdr, int stepmode,
		   int givechance, int backupregs);
extc int cdecl Suspendprocess (int processevents);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DECODING OF ARGUMENTS /////////////////////////////

#define DASC_TEST      0	// Test whether a string
#define DASC_NOHEX     1	// Test, print nothing if not a string
#define DASC_ASCII     2	// Force ASCII
#define DASC_PASCAL    3	// Force Pascal

extc uchar *cdecl Findknownfunction (ulong addr, int direct,
				     int level, char *fname);
extc int cdecl Decodeknownargument (ulong addr, uchar * arg, ulong value,
				    int valid, char *s, char *mask,
				    uchar * pset[]);
extc char cdecl *Findunknownfunction (ulong ip, char *code, char *dec,
				      ulong size, char *fname);
extc int cdecl Decodeascii (ulong value, char *s, int len, int mode);
extc int cdecl Decodeunicode (ulong value, char *s, int len);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// SOURCE CODE SUPPORT //////////////////////////////

#define FIRST_CODE_LINE 0xFFFFFFFF	// First available source line

typedef struct t_sourceline
{				// Source line descriptor
  ulong addr;			// Start address of corresponding code
  ulong size;			// Code size
  ulong srcname;		// Index of source name (as NM_DEBUG)
  ulong line;			// 0-based line number
} t_sourceline;

extc HWND cdecl Showsourcefromaddress (ulong addr, int show);
extc int cdecl Getresourcestring (t_module * pm, ulong id, char *s);
extc t_sourceline *cdecl Getlinefromaddress (ulong addr);
extc ulong cdecl Getaddressfromline (ulong addr0, ulong addr1,
				     char *path, ulong line);
extc int cdecl Getsourcefilelimits (ulong nameaddr,
					ulong * addr0, ulong * addr1);
extc int cdecl Decodefullvarname (t_module * pmod, t_symvar * psym,
				  int offset, char *name);
extc int cdecl Getbprelname (t_module * pmod, ulong addr, long offset,
			     char *s, int nsymb);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// WATCH SUPPORT /////////////////////////////////

extc HWND cdecl Createwatchwindow (void);
extc int cdecl Deletewatch (int indexone);
extc int cdecl Insertwatch (int indexone, char *text);
extc int cdecl Getwatch (int indexone, char *text);

////////////////////////////////////////////////////////////////////////////////
////////////////////////// WINDOWS-SPECIFIC FUNCTIONS //////////////////////////

#define MAXNEST        32	// Max allowed code structure nesting

typedef struct t_window
{				// Description of window
  ulong hwnd;			// Window's handle
  ulong dummy;			// Must be 1
  ulong type;			// Type of window, TY_xxx
  ulong parenthw;		// Handle of parent or 0
  ulong winproc;		// Address of WinProc or 0
  ulong threadid;		// ID of the owning thread
  ulong exstyle;		// Extended style
  ulong style;			// Style
  ulong id;			// Identifier
  ulong classproc;		// Address of default (class) WinProc
  int child;			// Index of next child
  int level;			// Level in genealogy (0: topmost)
  int sibling;			// Index of next sibling
  int byparent;			// Index when sorted by parent
  char title[TEXTLEN];		// Window's title
  char classname[TEXTLEN];	// Class name
  char tree[MAXNEST];		// Tree display
} t_window;

extc HWND cdecl Createwinwindow (void);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// PATCHES ////////////////////////////////////

typedef struct t_patch
{
  ulong addr;			// Base address of patch in memory
  ulong size;			// Size of patch, bytes
  ulong type;			// Type of patch, set of TY_xxx
  char orig[TEXTLEN];		// Original code
  char mod[TEXTLEN];		// Patched code
} t_patch;

extc HWND cdecl Createpatchwindow (void);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// PLUGIN-SPECIFIC FUNCTIONS ///////////////////////////

// Parameters of Plugingetvalue().
#define VAL_HINST              1	// Current program instance
#define VAL_HWMAIN             2	// Handle of the main window
#define VAL_HWCLIENT           3	// Handle of the MDI client window
#define VAL_NCOLORS            4	// Number of common colors
#define VAL_COLORS             5	// RGB values of common colors
#define VAL_BRUSHES            6	// Handles of common color brushes
#define VAL_PENS               7	// Handles of common color pens
#define VAL_NFONTS             8	// Number of common fonts
#define VAL_FONTS              9	// Handles of common fonts
#define VAL_FONTNAMES          10	// Internal font names
#define VAL_FONTWIDTHS         11	// Average widths of common fonts
#define VAL_FONTHEIGHTS        12	// Average heigths of common fonts
#define VAL_NFIXFONTS          13	// Actual number of fixed-pitch fonts
#define VAL_DEFFONT            14	// Index of default font
#define VAL_NSCHEMES           15	// Number of color schemes
#define VAL_SCHEMES            16	// Color schemes
#define VAL_DEFSCHEME          17	// Index of default colour scheme
#define VAL_DEFHSCROLL         18	// Default horizontal scroll
#define VAL_RESTOREWINDOWPOS   19	// Restore window positions from .ini
#define VAL_HPROCESS           20	// Handle of Debuggee
#define VAL_PROCESSID          21	// Process ID of Debuggee
#define VAL_HMAINTHREAD        22	// Handle of main thread
#define VAL_MAINTHREADID       23	// Thread ID of main thread
#define VAL_MAINBASE           24	// Base of main module in the process
#define VAL_PROCESSNAME        25	// Name of the active process
#define VAL_EXEFILENAME        26	// Name of the main debugged file
#define VAL_CURRENTDIR         27	// Current directory for debugged process
#define VAL_SYSTEMDIR          28	// Windows system directory
#define VAL_DECODEANYIP        29	// Decode registers dependless on EIP
#define VAL_PASCALSTRINGS      30	// Decode Pascal-style string constants
#define VAL_ONLYASCII          31	// Only printable ASCII chars in dump
#define VAL_DIACRITICALS       32	// Allow diacritical symbols in strings
#define VAL_GLOBALSEARCH       33	// Search from the beginning of block
#define VAL_ALIGNEDSEARCH      34	// Search aligned to item's size
#define VAL_IGNORECASE         35	// Ignore case in string search
#define VAL_SEARCHMARGIN       36	// Floating search allows error margin
#define VAL_KEEPSELSIZE        37	// Keep size of hex edit selection
#define VAL_MMXDISPLAY         38	// MMX display mode in dialog
#define VAL_WINDOWFONT         39	// Use calling window's font in dialog
#define VAL_TABSTOPS           40	// Distance between tab stops
#define VAL_MODULES            41	// Table of modules (.EXE and .DLL)
#define VAL_MEMORY             42	// Table of allocated memory blocks
#define VAL_THREADS            43	// Table of active threads
#define VAL_BREAKPOINTS        44	// Table of active breakpoints
#define VAL_REFERENCES         45	// Table with found references
#define VAL_SOURCELIST         46	// Table of source files
#define VAL_WATCHES            47	// Table of watches
#define VAL_CPUFEATURES        50	// CPU feature bits
#define VAL_TRACEFILE          51	// Handle of run trace log file
#define VAL_ALIGNDIALOGS       52	// Whether to align dialogs
#define VAL_CPUDASM            53	// Dump descriptor of CPU Disassembler
#define VAL_CPUDDUMP           54	// Dump descriptor of CPU Dump
#define VAL_CPUDSTACK          55	// Dump descriptor of CPU Stack
#define VAL_APIHELP            56	// Name of selected API help file
#define VAL_HARDBP             57	// Whether hardware breakpoints enabled
#define VAL_PATCHES            58	// Table of patches
#define VAL_HINTS              59	// Sorted data with analysis hints
#define VAL_PROCESS			   60      // handle to debugged process

extc int cdecl Registerpluginclass (char *classname, char *iconname,
					HINSTANCE dllinst, WNDPROC classproc);
extc void cdecl Unregisterpluginclass (char *classname);
extc int cdecl Pluginwriteinttoini (HINSTANCE dllinst, char *key, int value);
extc int cdecl Pluginwritestringtoini (HINSTANCE dllinst, char *key, char *s);
extc int cdecl Pluginreadintfromini (HINSTANCE dllinst, char *key, int def);
extc int cdecl Pluginreadstringfromini (HINSTANCE dllinst, char *key,
					char *s, char *def);
extc int cdecl Pluginsaverecord (ulong tag, ulong size, void *data);
extc int cdecl Plugingetvalue (int type);

////////////////////////////////////////////////////////////////////////////////
////////////////////// EXPORTED PLUGIN CALLBACK FUNCTIONS //////////////////////

// Origins of standard immDbg windows as passed to plugin. In parenthesis is
// the type of item you get in IMMDBG_Pluginmenu(), IMMDBG_Pluginaction() and
// IMMDBG_Pluginshortcut(). Note that this item can be NULL!
#define PM_MAIN        0	// Main window        (NULL)
#define PM_DUMP        10	// Any Dump window    (t_dump*)
#define PM_MODULES     11	// Modules window     (t_module*)
#define PM_MEMORY      12	// Memory window      (t_memory*)
#define PM_THREADS     13	// Threads window     (t_thread*)
#define PM_BREAKPOINTS 14	// Breakpoints window (t_bpoint*)
#define PM_REFERENCES  15	// References window  (t_ref*)
#define PM_RTRACE      16	// Run trace window   (int*)
#define PM_WATCHES     17	// Watches window     (1-based index)
#define PM_WINDOWS     18	// Windows window     (t_window*)
#define PM_DISASM      31	// CPU Disassembler   (t_dump*)
#define PM_CPUDUMP     32	// CPU Dump           (t_dump*)
#define PM_CPUSTACK    33	// CPU Stack          (t_dump*)
#define PM_CPUREGS     34	// CPU Registers      (t_reg*)

// Reasons why debugged application was paused, as a first argument in call to
// IMMDBG_Paused(), IMMDBG_Pausedex() and IMMDBG_Plugincmd().
#define PP_MAIN                0x0003	// Mask to extract main reason
#define   PP_EVENT             0x0000	// Paused on debugging event
#define   PP_PAUSE             0x0001	// Paused on user's request
#define   PP_TERMINATED        0x0002	// Application terminated
// Extended reasons in IMMDBG_Pausedex().
#define PP_BYPROGRAM           0x0004	// Debugging event caused by program
#define PP_INT3BREAK           0x0010	// INT3 breakpoint
#define PP_MEMBREAK            0x0020	// Memory breakpoint
#define PP_HWBREAK             0x0040	// Hardware breakpoint
#define PP_SINGLESTEP          0x0080	// Single-step trap
#define PP_EXCEPTION           0x0100	// Exception, like division by 0
#define PP_ACCESS              0x0200	// Access violation
#define PP_GUARDED             0x0400	// Guarded page

// Record tags in .udd files.
#define MI_SIGNATURE   0x00646F4DL	// Module info signature
#define MI_VERSION     0x7265560AL	// immDbg version
#define MI_FILENAME    0x6C69460AL	// Record with full name of executable
#define MI_FILESIZE    0x7A69530AL	// Record with file size
#define MI_TIMESTAMP   0x7473540AL	// Record with timestamp file data
#define MI_SFXENTRY    0x6566530AL	// Real entry of SFX-able module
#define MI_PATCH       0x7461500AL	// Record with patch data
#define MI_USER        0x0073550AL	// Record with user-defined label/comment
#define MI_PROCDATA    0x6372500AL	// Record with procedure data
#define MI_SWDATA      0x6977530AL	// Record with switch data
#define MI_CALLFINT    0x6966430AL	// Record with internal call
#define MI_CALLFMOD    0x6D66430AL	// Record with intermodular call
#define MI_CALLFABS    0x6166430AL	// Record with absolute call
#define MI_INT3BREAK   0x7470420AL	// Record with breakpoint data
#define MI_INT3BRKC    0x6370420AL	// Record with checked breakpoint data
#define MI_HDWRBREAK   0x7262480AL	// Record with hardware breakpoint data
#define MI_JDDATA      0x74644A0AL	// Record with all module jump data
#define MI_ANALYSIS    0x616E410AL	// Record with analysis data
#define MI_ANALPACK    0x636E410AL	// Record with compressed analysis data
#define MI_AHINT       0x7468410AL	// Record with analysis hint data
#define MI_TRACE       0x6172540AL	// Record with trace data
#define MI_TRACEPACK   0x6372540AL	// Record with compressed trace data
#define MI_CODECRC     0x7263430AL	// Record with CRC of code for analysis
#define MI_SAVEAREA    0x6176530AL	// Record with general-purpose save area
#define MI_END         0x646E450AL	// End of module info data
// Tags reserved for 3rd-party plugins.
#define MI_WINJUG      0x67754A0AL	// WindowJuggler by EsseEmme
#define MI_WINJU1      0x31754A0AL
#define MI_WINJU2      0x32754A0AL
#define MI_WINJU3      0x33754A0AL
#define MI_APPST       0x73614F0AL	// immAppStarter by Homunculus

// Prototypes for plugin callback functions.
extc int _export cdecl IMMDBG_Plugindata (char shortname[32]);
extc int _export cdecl IMMDBG_Plugininit (int immdbgversion, HWND hw,
					ulong * features);
extc void _export cdecl IMMDBG_Pluginmainloop (DEBUG_EVENT * debugevent);
extc void _export cdecl IMMDBG_Pluginsaveudd (t_module * pmod,
					    int ismainmodule);
extc int _export cdecl IMMDBG_Pluginuddrecord (t_module * pmod,
					     int ismainmodule, ulong tag,
					     ulong size, void *data);
extc int _export cdecl IMMDBG_Pluginmenu (int origin, char data[4096],
					void *item);
extc void _export cdecl IMMDBG_Pluginaction (int origin, int action,
					   void *item);
extc int _export cdecl IMMDBG_Pluginshortcut (int origin, int ctrl, int alt,
					    int shift, int key, void *item);
extc void _export cdecl IMMDBG_Pluginreset (void);
extc int _export cdecl IMMDBG_Pluginclose (void);
extc void _export cdecl IMMDBG_Plugindestroy (void);
extc int _export cdecl IMMDBG_Paused (int reason, t_reg * reg);
extc int _export cdecl IMMDBG_Pausedex (int reasonex, int dummy, t_reg * reg,
				      DEBUG_EVENT * debugevent);
extc int _export cdecl IMMDBG_Plugincmd (int reason, t_reg * reg, char *cmd);

#ifdef _MSC_VER

  #pragma pack(pop)

#endif

#endif // _PLUGIN_IMMDBG_H_



================================================
File: plugin_odbg_v1.c
================================================
#include "stdafx.h"
#include "plugin.h"

HWND hwollymain;

static int FixAsmCommand(char *lpCommand, char **ppFixedCommand, char *lpError);
static char *SkipCommandName(char *p);
static int FixedAsmCorrectErrorSpot(char *lpCommand, char *pFixedCommand, int result);
static BOOL FindNextHexNumberStartingWithALetter(char *lpCommand, char **ppHexNumberStart, char **ppHexNumberEnd);

// Config functions

BOOL MyGetintfromini(HINSTANCE dllinst, TCHAR *key, int *p_val, int min, int max, int def)
{
	int val;

	val = Pluginreadintfromini(dllinst, key, -1);
	if(val == -1)
	{
		*p_val = def;

		return FALSE;
	}

	if(min && max && (val < min || val > max))
		*p_val = def;
	else
		*p_val = val;

	return TRUE;
}

BOOL MyWriteinttoini(HINSTANCE dllinst, TCHAR *key, int val)
{
	return Pluginwriteinttoini(dllinst, key, val) != 0;
}

int MyGetstringfromini(HINSTANCE dllinst, TCHAR *key, TCHAR *s, int length)
{
	char buf[256];
	int len;

	if(length >= 256)
		return Pluginreadstringfromini(dllinst, key, s, "");

	len = Pluginreadstringfromini(dllinst, key, buf, "");
	if(len > length-1)
		len = length-1;

	lstrcpyn(s, buf, len+1);

	return len;
}

BOOL MyWritestringtoini(HINSTANCE dllinst, TCHAR *key, TCHAR *s)
{
	return Pluginwritestringtoini(dllinst, key, s) != 0;
}

// Assembler functions

DWORD SimpleDisasm(BYTE *cmd, SIZE_T cmdsize, DWORD_PTR ip, BYTE *dec, BOOL bSizeOnly,
	TCHAR *pszResult, DWORD_PTR *jmpconst, DWORD_PTR *adrconst, DWORD_PTR *immconst)
{
	t_disasm disasm;
	DWORD dwCommandSize = Disasm(cmd, cmdsize, ip, dec, &disasm, bSizeOnly ? DISASM_SIZE : DISASM_FILE, 0);
	if(disasm.error)
		return 0;

	if(!bSizeOnly)
	{
		lstrcpy(pszResult, disasm.result); // pszResult should have at least COMMAND_MAX_LEN chars

		*jmpconst = disasm.jmpconst;
		*adrconst = disasm.adrconst;
		*immconst = disasm.immconst;
	}

	return dwCommandSize;
}

int AssembleShortest(TCHAR *lpCommand, DWORD_PTR dwAddress, BYTE *bBuffer, TCHAR *lpError)
{
	char *lpFixedCommand, *lpCommandToAssemble;
	t_asmmodel model1, model2;
	t_asmmodel *pm, *pm_shortest, *temp;
	BOOL bHadResults;
	int attempt;
	int result;
	int i;

	result = FixAsmCommand(lpCommand, &lpFixedCommand, lpError);
	if(result <= 0)
		return result;

	if(lpFixedCommand)
		lpCommandToAssemble = lpFixedCommand;
	else
		lpCommandToAssemble = lpCommand;

	pm = &model1;
	pm_shortest = &model2;

	pm_shortest->length = MAXCMDSIZE+1;
	attempt = 0;

	do
	{
		bHadResults = FALSE;

		for(i=0; i<4; i++)
		{
			result = Assemble(lpCommandToAssemble, dwAddress, pm, attempt, i, lpError);
			if(result > 0)
			{
				bHadResults = TRUE;

				if(pm->length < pm_shortest->length)
				{
					temp = pm_shortest;
					pm_shortest = pm;
					pm = temp;
				}
			}
		}

		attempt++;
	}
	while(bHadResults);

	if(pm_shortest->length == MAXCMDSIZE+1)
	{
		if(lpFixedCommand)
		{
			result = FixedAsmCorrectErrorSpot(lpCommand, lpFixedCommand, result);
			HeapFree(GetProcessHeap(), 0, lpFixedCommand);
		}

		return result;
	}

	if(lpFixedCommand)
		HeapFree(GetProcessHeap(), 0, lpFixedCommand);

	for(i=0; i<pm_shortest->length; i++)
	{
		if(pm_shortest->mask[i] != 0xFF)
		{
			lstrcpy(lpError, "Undefined operands allowed only for search");
			return 0;
		}
	}

	CopyMemory(bBuffer, pm_shortest->code, pm_shortest->length);

	return pm_shortest->length;
}

int AssembleWithGivenSize(TCHAR *lpCommand, DWORD_PTR dwAddress, int nReqSize, BYTE *bBuffer, TCHAR *lpError)
{
	char *lpFixedCommand, *lpCommandToAssemble;
	t_asmmodel model;
	BOOL bHadResults;
	int attempt;
	int result;
	int i;

	result = FixAsmCommand(lpCommand, &lpFixedCommand, lpError);
	if(result <= 0)
		return result;

	if(lpFixedCommand)
		lpCommandToAssemble = lpFixedCommand;
	else
		lpCommandToAssemble = lpCommand;

	model.length = MAXCMDSIZE+1;

	attempt = 0;

	do
	{
		bHadResults = FALSE;

		for(i=0; i<4; i++)
		{
			result = Assemble(lpCommandToAssemble, dwAddress, &model, attempt, i, lpError);
			if(result > 0)
			{
				bHadResults = TRUE;

				if(model.length == nReqSize)
				{
					if(lpFixedCommand)
						HeapFree(GetProcessHeap(), 0, lpFixedCommand);

					for(i=0; i<model.length; i++)
					{
						if(model.mask[i] != 0xFF)
						{
							lstrcpy(lpError, "Undefined operands allowed only for search");
							return 0;
						}
					}

					CopyMemory(bBuffer, model.code, model.length);

					return model.length;
				}
			}
		}

		attempt++;
	}
	while(bHadResults);

	if(lpFixedCommand)
	{
		if(result < 0)
			result = FixedAsmCorrectErrorSpot(lpCommand, lpFixedCommand, result);
		HeapFree(GetProcessHeap(), 0, lpFixedCommand);
	}

	if(result > 0)
	{
		lstrcpy(lpError, "Assemble error");
		result = 0;
	}

	return result;
}

static int FixAsmCommand(char *lpCommand, char **ppFixedCommand, char *lpError)
{
	char *p;
	char *pHexNumberStart, *pHexNumberEnd;
	int number_count;
	char *pNewCommand;
	char *p_dest;

	// Skip the command name
	p = SkipCommandName(lpCommand);

	// Search for hex numbers starting with a letter
	number_count = 0;

	while(FindNextHexNumberStartingWithALetter(p, &pHexNumberStart, &p))
		number_count++;

	if(number_count == 0)
	{
		*ppFixedCommand = NULL;
		return 1;
	}

	// Allocate memory for new command
	pNewCommand = (char *)HeapAlloc(GetProcessHeap(), 0, lstrlen(lpCommand)+number_count+1);
	if(!pNewCommand)
	{
		lstrcpy(lpError, "Allocation failed");
		return 0;
	}

	// Fix (add zeros)
	p_dest = pNewCommand;

	// Skip the command name
	p = SkipCommandName(lpCommand);
	if(p != lpCommand)
	{
		CopyMemory(p_dest, lpCommand, p-lpCommand);
		p_dest += p-lpCommand;
	}

	while(FindNextHexNumberStartingWithALetter(p, &pHexNumberStart, &pHexNumberEnd))
	{
		CopyMemory(p_dest, p, pHexNumberStart-p);
		p_dest += pHexNumberStart-p;

		*p_dest++ = '0';

		CopyMemory(p_dest, pHexNumberStart, pHexNumberEnd-pHexNumberStart);
		p_dest += pHexNumberEnd-pHexNumberStart;

		p = pHexNumberEnd;
	}

	// Copy the rest
	lstrcpy(p_dest, p);

	*ppFixedCommand = pNewCommand;
	return 1;
}

static char *SkipCommandName(char *p)
{
	char *pPrefix;
	int i;

	switch(*p)
	{
	case 'L':
	case 'l':
		pPrefix = "LOCK";

		for(i=1; pPrefix[i] != '\0'; i++)
		{
			if(p[i] != pPrefix[i] && p[i] != pPrefix[i]-'A'+'a')
				break;
		}

		if(pPrefix[i] == '\0')
		{
			if((p[i] < 'A' || p[i] > 'Z') && (p[i] < 'a' || p[i] > 'z') && (p[i] < '0' || p[i] > '9'))
			{
				p += i;
				while(*p == ' ' || *p == '\t')
					p++;
			}
		}
		break;

	case 'R':
	case 'r':
		pPrefix = "REP";

		for(i=1; pPrefix[i] != '\0'; i++)
		{
			if(p[i] != pPrefix[i] && p[i] != pPrefix[i]-'A'+'a')
				break;
		}

		if(pPrefix[i] == '\0')
		{
			if((p[i] == 'N' || p[i] == 'n') && (p[i+1] == 'E' || p[i+1] == 'e' || p[i+1] == 'Z' || p[i+1] == 'z'))
				i += 2;
			else if(p[i] == 'E' || p[i] == 'e' || p[i] == 'Z' || p[i] == 'z')
				i++;

			if((p[i] < 'A' || p[i] > 'Z') && (p[i] < 'a' || p[i] > 'z') && (p[i] < '0' || p[i] > '9'))
			{
				p += i;
				while(*p == ' ' || *p == '\t')
					p++;
			}
		}
		break;
	}

	while((*p >= 'A' && *p <= 'Z') || (*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9'))
		p++;

	while(*p == ' ' || *p == '\t')
		p++;

	return p;
}

static int FixedAsmCorrectErrorSpot(char *lpCommand, char *pFixedCommand, int result)
{
	char *p;
	char *pHexNumberStart;

	// Skip the command name
	p = SkipCommandName(lpCommand);

	if(-result < p-lpCommand)
		return result;

	// Search for hex numbers starting with a letter
	while(FindNextHexNumberStartingWithALetter(p, &pHexNumberStart, &p))
	{
		if(-result < pHexNumberStart+1-lpCommand)
			return result;

		result++;

		if(-result < p-lpCommand)
			return result;
	}

	return result;
}

static BOOL FindNextHexNumberStartingWithALetter(char *lpCommand, char **ppHexNumberStart, char **ppHexNumberEnd)
{
	char *p;
	char *pHexNumberStart;

	p = lpCommand;

	while(*p != '\0' && *p != ';')
	{
		if((*p >= 'A' && *p <= 'Z') || (*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9'))
		{
			if((*p >= 'A' && *p <= 'F') || (*p >= 'a' && *p <= 'f'))
			{
				pHexNumberStart = p;

				do {
					p++;
				} while((*p >= '0' && *p <= '9') || (*p >= 'A' && *p <= 'F') || (*p >= 'a' && *p <= 'f'));

				if(*p == 'h' || *p == 'H')
				{
					// Check registers AH, BH, CH, DH
					if(
						p-pHexNumberStart != 1 || 
						((p[-1] < 'A' || p[-1] > 'D') && (p[-1] < 'a' || p[-1] > 'd'))
					)
						p++;
				}

				if((*p >= 'A' && *p <= 'Z') || (*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9'))
				{
					do {
						p++;
					} while((*p >= 'A' && *p <= 'Z') || (*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9'));
				}
				else
				{
					*ppHexNumberStart = pHexNumberStart;
					*ppHexNumberEnd = p;
					return TRUE;
				}
			}
			else
			{
				do {
					p++;
				} while((*p >= 'A' && *p <= 'Z') || (*p >= 'a' && *p <= 'z') || (*p >= '0' && *p <= '9'));
			}
		}
		else
			p++;
	}

	return FALSE;
}

// Memory functions

BOOL SimpleReadMemory(void *buf, DWORD_PTR addr, SIZE_T size)
{
	return Readmemory(buf, addr, size, MM_RESTORE|MM_SILENT) != 0;
}

BOOL SimpleWriteMemory(void *buf, DWORD_PTR addr, SIZE_T size)
{
	return Writememory(buf, addr, size, MM_RESTORE|MM_DELANAL|MM_SILENT) != 0;
}

// Symbolic functions

int GetLabel(DWORD_PTR addr, TCHAR *name)
{
	return Findsymbolicname(addr, name);
}

int GetComment(DWORD_PTR addr, TCHAR *name)
{
	return Findname(addr, NM_COMMENT, name);
}

BOOL QuickInsertLabel(DWORD_PTR addr, TCHAR *s)
{
	return Quickinsertname(addr, NM_LABEL, s) != -1;
}

BOOL QuickInsertComment(DWORD_PTR addr, TCHAR *s)
{
	return Quickinsertname(addr, NM_COMMENT, s) != -1;
}

void MergeQuickData(void)
{
	Mergequicknames();
}

void DeleteRangeLabels(DWORD_PTR addr0, DWORD_PTR addr1)
{
	Deletenamerange(addr0, addr1, NM_LABEL);
}

void DeleteRangeComments(DWORD_PTR addr0, DWORD_PTR addr1)
{
	Deletenamerange(addr0, addr1, NM_COMMENT);
}

// Module functions

PLUGIN_MODULE FindModuleByName(TCHAR *lpModule)
{
	int module_len;
	t_table *table;
	t_sorted *sorted;
	int n, itemsize;
	t_module *module;
	char c1, c2;
	int i, j;

	module_len = lstrlen(lpModule);
	if(module_len > SHORTLEN)
		return NULL;

	table = (t_table *)Plugingetvalue(VAL_MODULES);
	sorted = &table->data;

	n = sorted->n;
	itemsize = sorted->itemsize;
	module = (t_module *)sorted->data;

	for(i = 0; i < n; i++)
	{
		for(j = 0; j < module_len; j++)
		{
			c1 = lpModule[j];
			if(c1 >= 'a' && c1 <= 'z')
				c1 += -'a' + 'A';

			c2 = module->name[j];
			if(c2 >= 'a' && c2 <= 'z')
				c2 += -'a' + 'A';

			if(c1 != c2)
				break;
		}

		if(j == module_len && (j == SHORTLEN || module->name[j] == '\0'))
			return module;

		module = (t_module *)((char *)module + itemsize);
	}

	return NULL;
}

PLUGIN_MODULE FindModuleByAddr(DWORD_PTR dwAddress)
{
	return Findmodule(dwAddress);
}

DWORD_PTR GetModuleBase(PLUGIN_MODULE module)
{
	return module->base;
}

SIZE_T GetModuleSize(PLUGIN_MODULE module)
{
	return module->size;
}

BOOL GetModuleName(PLUGIN_MODULE module, TCHAR *pszModuleName)
{
	CopyMemory(pszModuleName, module->name, (MODULE_MAX_LEN-1)*sizeof(TCHAR));
	pszModuleName[MODULE_MAX_LEN-1] = _T('\0');
	return TRUE;
}

BOOL IsModuleWithRelocations(PLUGIN_MODULE module)
{
	return module->reloctable != 0;
}

// Memory functions

PLUGIN_MEMORY FindMemory(DWORD_PTR dwAddress)
{
	return Findmemory(dwAddress);
}

DWORD_PTR GetMemoryBase(PLUGIN_MEMORY mem)
{
	return mem->base;
}

SIZE_T GetMemorySize(PLUGIN_MEMORY mem)
{
	return mem->size;
}

void EnsureMemoryBackup(PLUGIN_MEMORY mem)
{
	t_dump dump;

	if(!mem->copy)
	{
		// what a hack -_-'
		dump.base = mem->base;
		dump.size = mem->size;
		dump.threadid = 1;
		dump.filecopy = NULL;
		dump.backup = NULL;

		Dumpbackup(&dump, BKUP_CREATE);
	}
}

// Analysis functions

BYTE *FindDecode(DWORD_PTR addr, SIZE_T *psize)
{
	return Finddecode(addr, psize);
}

int DecodeGetType(BYTE decode)
{
	switch(decode & DEC_TYPEMASK)
	{
	// Unknown
	case DEC_UNKNOWN:
	default:
		return DECODE_UNKNOWN;

	// Supported data
	case DEC_BYTE:
	case DEC_WORD:
	case DEC_DWORD:
	case DEC_BYTESW:
		return DECODE_DATA;

	// Command
	case DEC_COMMAND:
	case DEC_JMPDEST:
	case DEC_CALLDEST:
		return DECODE_COMMAND;

	// Ascii
	case DEC_STRING:
		return DECODE_ASCII;

	// Unicode
	case DEC_UNICODE:
		return DECODE_UNICODE;
	}
}

// Misc.

BOOL IsProcessLoaded()
{
	return Getstatus() != STAT_NONE;
}

void SuspendAllThreads()
{
	// Note: I'm not sure it's required to be implemented here
	// It's recommended to call for OllyDbg v2, though
}

void ResumeAllThreads()
{
	// Note: I'm not sure it's required to be implemented here
	// It's recommended to call for OllyDbg v2, though
}

DWORD_PTR GetCpuBaseAddr()
{
	t_dump *td = (t_dump *)Plugingetvalue(VAL_CPUDASM);
	if(!td)
		return 0;

	return td->base;
}

void InvalidateGui()
{
	// Not needed
}



================================================
File: plugin_odbg_v1.h
================================================
#pragma once

#if defined(TARGET_ODBG)
#include "plugin_ollydbg.h"
#elif defined(TARGET_IMMDBG)
#include "plugin_immdbg.h"
#else
#error Unknown target
#endif

extern HWND hwollymain;

#define COMMAND_MAX_LEN       TEXTLEN
#define MODULE_MAX_LEN        (SHORTLEN+1)
#define LABEL_MAX_LEN         TEXTLEN
#define COMMENT_MAX_LEN       TEXTLEN

#ifndef JT_CALL
#define JT_CALL               3 // Local (intramodular) call
#endif // JT_CALL

// v1 -> v2 helper
typedef t_jdest t_jmp;

typedef t_module *PLUGIN_MODULE;
typedef t_memory *PLUGIN_MEMORY;



================================================
File: plugin_odbg_v2.c
================================================
#include "stdafx.h"
#include "plugin.h"

// Config functions

BOOL MyGetintfromini(HINSTANCE dllinst, TCHAR *key, int *p_val, int min, int max, int def)
{
	int val;

	if(!Getfromini(NULL, DEF_PLUGINNAME, key, L"%i", &val))
	{
		*p_val = def;

		return FALSE;
	}

	if(min && max && (val < min || val > max))
		*p_val = def;
	else
		*p_val = val;

	return TRUE;
}

BOOL MyWriteinttoini(HINSTANCE dllinst, TCHAR *key, int val)
{
	return Writetoini(NULL, DEF_PLUGINNAME, key, L"%i", val) != 0;
}

int MyGetstringfromini(HINSTANCE dllinst, TCHAR *key, TCHAR *s, int length)
{
	return Stringfromini(DEF_PLUGINNAME, key, s, length);
}

BOOL MyWritestringtoini(HINSTANCE dllinst, TCHAR *key, TCHAR *s)
{
	return Writetoini(NULL, DEF_PLUGINNAME, key, L"%s", s) != 0;
}

// Assembler functions

DWORD SimpleDisasm(BYTE *cmd, SIZE_T cmdsize, DWORD_PTR ip, BYTE *dec, BOOL bSizeOnly,
	TCHAR *pszResult, DWORD_PTR *jmpconst, DWORD_PTR *adrconst, DWORD_PTR *immconst)
{
	t_disasm disasm;
	DWORD dwCommandSize = Disasm(cmd, cmdsize, ip, dec, &disasm, bSizeOnly ? 0 : DA_TEXT, NULL, NULL);
	if(disasm.errors != DAE_NOERR)
		return 0;

	if(!bSizeOnly)
	{
		lstrcpy(pszResult, disasm.result); // pszResult should have at least COMMAND_MAX_LEN chars

		*jmpconst = disasm.jmpaddr;

		if(disasm.memfixup != -1)
			*adrconst = *(DWORD_PTR *)(cmd + disasm.memfixup);
		else
			*adrconst = 0;

		if(disasm.immfixup != -1)
			*immconst = *(DWORD_PTR *)(cmd + disasm.immfixup);
		else
			*immconst = 0;
	}

	return dwCommandSize;
}

int AssembleShortest(TCHAR *lpCommand, DWORD_PTR dwAddress, BYTE *bBuffer, TCHAR *lpError)
{
	return Assemble(lpCommand, dwAddress, bBuffer, MAXCMDSIZE, 0, lpError);
}

int AssembleWithGivenSize(TCHAR *lpCommand, DWORD_PTR dwAddress, int nReqSize, BYTE *bBuffer, TCHAR *lpError)
{
	t_asmmod models[32];
	int nModelsCount;
	int nModelIndex;
	int i;

	if(lpError)
		*lpError = L'\0';

	nModelsCount = Assembleallforms(lpCommand, dwAddress, models, 32, 0, lpError);
	if(nModelsCount == 0)
		return 0;

	nModelIndex = -1;

	for(i=0; i<nModelsCount; i++)
	{
		if(models[i].ncode == nReqSize)
		{
			if(nModelIndex < 0 || (!(models[i].features & AMF_UNDOC) && (models[i].features & AMF_SAMEORDER)))
				nModelIndex = i;
		}
	}

	if(nModelIndex < 0)
	{
		lstrcpy(lpError, L"Internal error");
		return 0;
	}

	CopyMemory(bBuffer, models[nModelIndex].code, nReqSize);

	return nReqSize;
}

// Memory functions

BOOL SimpleReadMemory(void *buf, DWORD_PTR addr, SIZE_T size)
{
	return Readmemory(buf, addr, size, MM_SILENT) != 0;
}

BOOL SimpleWriteMemory(void *buf, DWORD_PTR addr, SIZE_T size)
{
	if(Writememory(buf, addr, size, MM_SILENT|MM_REMOVEINT3) < size)
		return FALSE;

	Removeanalysis(addr, size, 0);
	return TRUE;
}

// Symbolic functions

int GetLabel(DWORD_PTR addr, TCHAR *name)
{
	return Decodeaddress(addr, 0, DM_SYMBOL | DM_JUMPIMP, name, LABEL_MAX_LEN, NULL);
}

int GetComment(DWORD_PTR addr, TCHAR *name)
{
	return FindnameW(addr, NM_COMMENT, name, COMMENT_MAX_LEN);
}

BOOL QuickInsertLabel(DWORD_PTR addr, TCHAR *s)
{
	return QuickinsertnameW(addr, NM_LABEL, s) != -1;
}

BOOL QuickInsertComment(DWORD_PTR addr, TCHAR *s)
{
	return QuickinsertnameW(addr, NM_COMMENT, s) != -1;
}

void MergeQuickData(void)
{
	Mergequickdata();
}

void DeleteRangeLabels(DWORD_PTR addr0, DWORD_PTR addr1)
{
	Deletedatarange(addr0, addr1, NM_LABEL, DT_NONE, DT_NONE);
}

void DeleteRangeComments(DWORD_PTR addr0, DWORD_PTR addr1)
{
	Deletedatarange(addr0, addr1, NM_COMMENT, DT_NONE, DT_NONE);
}

// Module functions

PLUGIN_MODULE FindModuleByName(TCHAR *lpModule)
{
	return Findmodulebyname(lpModule);
}

PLUGIN_MODULE FindModuleByAddr(DWORD_PTR dwAddress)
{
	return Findmodule(dwAddress);
}

DWORD_PTR GetModuleBase(PLUGIN_MODULE module)
{
	return module->base;
}

SIZE_T GetModuleSize(PLUGIN_MODULE module)
{
	return module->size;
}

BOOL GetModuleName(PLUGIN_MODULE module, TCHAR *pszModuleName)
{
	lstrcpy(pszModuleName, module->modname); // Must be at least MODULE_MAX_LEN characters long
	return TRUE;
}

BOOL IsModuleWithRelocations(PLUGIN_MODULE module)
{
	return module->relocbase != 0;
}

// Memory functions

PLUGIN_MEMORY FindMemory(DWORD_PTR dwAddress)
{
	return Findmemory(dwAddress);
}

DWORD_PTR GetMemoryBase(PLUGIN_MEMORY mem)
{
	return mem->base;
}

SIZE_T GetMemorySize(PLUGIN_MEMORY mem)
{
	return mem->size;
}

void EnsureMemoryBackup(PLUGIN_MEMORY mem)
{
	Ensurememorybackup(mem, 0);
}

// Analysis functions

BYTE *FindDecode(DWORD_PTR addr, SIZE_T *psize)
{
	return Finddecode(addr, psize);
}

int DecodeGetType(BYTE decode)
{
	switch(decode & DEC_TYPEMASK)
	{
	// Unknown
	case DEC_UNKNOWN:
	default:
		return DECODE_UNKNOWN;

	// Supported data
	case DEC_FILLDATA:
	case DEC_INT:
	case DEC_SWITCH:
	case DEC_DATA:
	case DEC_DB:
	case DEC_DUMP:
	case DEC_FLOAT:
	case DEC_GUID:
	case DEC_FILLING:
		return DECODE_DATA;

	// Command
	case DEC_COMMAND:
	case DEC_JMPDEST:
	case DEC_CALLDEST:
		return DECODE_COMMAND;

	// Ascii
	case DEC_ASCII:
	case DEC_ASCCNT:
		return DECODE_ASCII;

	// Unicode
	case DEC_UNICODE:
	case DEC_UNICNT:
		return DECODE_UNICODE;
	}
}

// Misc.

BOOL IsProcessLoaded()
{
	return run.status != STAT_IDLE;
}

void SuspendAllThreads()
{
	Suspendallthreads();
}

void ResumeAllThreads()
{
	Resumeallthreads();
}

DWORD_PTR GetCpuBaseAddr()
{
	t_dump *td = Getcpudisasmdump();
	if(!td)
		return 0;

	return td->base;
}

void InvalidateGui()
{
	// Not needed
}



================================================
File: plugin_odbg_v2.h
================================================
#pragma once

#include "plugin_ollydbg2.h"

#define COMMAND_MAX_LEN       TEXTLEN
#define MODULE_MAX_LEN        SHORTNAME
#define LABEL_MAX_LEN         TEXTLEN
#define COMMENT_MAX_LEN       TEXTLEN

typedef t_module *PLUGIN_MODULE;
typedef t_memory *PLUGIN_MEMORY;



================================================
File: plugin_ollydbg.h
================================================
#ifndef _PLUGIN_OLLYDBG_H_
#define _PLUGIN_OLLYDBG_H_

#include <windows.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                             OLLYDBG PLUGIN API                             //
//                                                                            //
//                                Version 1.10                                //
//                                                                            //
//               Written by Oleh Yuschuk (ollydbg@t-online.de)                //
//                                                                            //
//              Internet:  http://home.t-online.de/home/Ollydbg               //
//                                                                            //
// This code is distributed "as is", without warranty of any kind, expressed  //
// or implied, including, but not limited to warranty of fitness for any      //
// particular purpose. In no event will Oleh Yuschuk be liable to you for any //
// special, incidental, indirect, consequential or any other damages caused   //
// by the use, misuse, or the inability to use of this code, including any    //
// lost profits or lost savings, even if Oleh Yuschuk has been advised of the //
// possibility of such damages.                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// IMPORTANT INFORMATION /////////////////////////////

// 1. Export all callback functions by name, NOT by ordinal!
// 2. Force byte alignment of OllyDbg structures!
// 3. Set default char type to unsigned!
// 4. Read documentation!

// If you prefere Borland, this will force necessary settings (but, as a side
// effect, may cause plenty of warnings if other include files will be compiled
// with different options):
#ifdef __BORLANDC__

  #pragma option -a1                   // Byte alignment
  #pragma option -K                    // Unsigned char

  // And here I check that settings are correct. Unfortunately, Microsoft C (at
  // least C++ 5.0) doesn't allow for sizeof and typecasts in conditionals:

  typedef struct t_aligntest {
    char           a;
    long           b;
  } t_aligntest;

  #if (sizeof(t_aligntest)!=sizeof(char)+sizeof(long))
    #error Please assure byte alignment of OllyDbg structures
  #endif
  #undef t_aligntest

  #if ((char)0xFF!=255)
    #error Please set default char type to unsigned
  #endif

#endif

// If you like Microsoft compiler, this will force byte alignment and verify
// that character is set to unsigned.
#ifdef _MSC_VER

  #pragma pack(push, 1)                // Force byte alignment of structures

  #ifndef _CHAR_UNSIGNED               // Verify that character is unsigned
    #error Please set default char type to unsigned (option /J)
  #endif

  // Borland adds underscore to export automatically, whereas I don't know any
  // such option for Microsoft compiler. This solution is not too elegant but
  // works.
  #define ODBG_Plugindata      _ODBG_Plugindata
  #define ODBG_Plugininit      _ODBG_Plugininit
  #define ODBG_Pluginmainloop  _ODBG_Pluginmainloop
  #define ODBG_Pluginsaveudd   _ODBG_Pluginsaveudd
  #define ODBG_Pluginuddrecord _ODBG_Pluginuddrecord
  #define ODBG_Pluginmenu      _ODBG_Pluginmenu
  #define ODBG_Pluginaction    _ODBG_Pluginaction
  #define ODBG_Pluginshortcut  _ODBG_Pluginshortcut
  #define ODBG_Pluginreset     _ODBG_Pluginreset
  #define ODBG_Pluginclose     _ODBG_Pluginclose
  #define ODBG_Plugindestroy   _ODBG_Plugindestroy
  #define ODBG_Paused          _ODBG_Paused
  #define ODBG_Pausedex        _ODBG_Pausedex
  #define ODBG_Plugincmd       _ODBG_Plugincmd

#endif


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// GENERAL DECLARATIONS /////////////////////////////

#define PLUGIN_VERSION 110             // Version of plugin interface

#ifdef __cplusplus
  #define extc           extern "C"    // Assure that names are not mangled
#else
  #define extc           extern
#endif

#define _export        __declspec(dllexport)

typedef unsigned char  uchar;          // Unsigned character (byte)
typedef unsigned short ushort;         // Unsigned short
typedef unsigned int   uint;           // Unsigned integer
typedef unsigned long  ulong;          // Unsigned long

#define TEXTLEN        256             // Maximal length of text string
#define ARGLEN         1024            // Maximal length of argument string
#define USERLEN        4096            // Maximal length of record in .udd file
#define SHORTLEN       8               // Maximal length of short name

#define BLACK          0               // Indices of colours used by OllyDbg. In
#define BLUE           1               // syntax highlighting, use only colours
#define GREEN          2               // 0 to 15 in the least significant bits
#define CYAN           3               // of the corresponding mask byte.
#define RED            4
#define MAGENTA        5
#define BROWN          6
#define LIGHTGRAY      7
#define DARKGRAY       8
#define LIGHTBLUE      9
#define LIGHTGREEN     10
#define LIGHTCYAN      11
#define LIGHTRED       12
#define LIGHTMAGENTA   13
#define YELLOW         14
#define WHITE          15
#define MINT           16
#define SKYBLUE        17
#define IVORY          18
#define GRAY           19

#define NCOLORS        20              // Total number of defined colours

#define BKTRANSP       0x00            // Background colours in syntax hiliting
#define BKBLACK        0x10
#define BKGRAY         0x20
#define BKWHITE        0x30
#define BKCYAN         0x40
#define BKGREEN        0x50
#define BKRED          0x60
#define BKYELLOW       0x70

#define BLACKWHITE     0               // Colour schemes used by OllyDbg
#define BLUEGOLD       1
#define SKYWIND        2
#define NIGHTSTARS     3
#define SCHEME4        4
#define SCHEME5        5
#define SCHEME6        6
#define SCHEME7        7

#define FIXEDFONT      0               // Fonts used by OllyDbg. Variable-pitch
#define TERMINAL6      1               // fonts are placed at the end of this
#define FIXEDSYS       2               // table.
#define COURIERFONT    3
#define LUCIDACONS     4
#define FONT5          5
#define FONT6          6
#define FONT7          7
#define MAINFONT       8
#define SYSFONT        9
#define INFOFONT       10

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// INFORMATION FUNCTIONS /////////////////////////////

extc void    cdecl Addtolist(long addr,int highlight,char *format,...);
extc void    cdecl Updatelist(void);
extc HWND    cdecl Createlistwindow(void);
extc void    cdecl Error(char *format,...);
extc void    cdecl Message(ulong addr,char *format,...);
extc void    cdecl Infoline(char *format,...);
extc void    cdecl Progress(int promille,char *format,...);
extc void    cdecl Flash(char *format,...);

////////////////////////////////////////////////////////////////////////////////
////////////////////////// DATA FORMATTING FUNCTIONS ///////////////////////////

// Bits used in Decodeaddress(), Decoderelativeoffset() and  Decodethreadname()
// to specify decoding mode:
#define ADC_DEFAULT    0x0000          // Default decoding mode
#define ADC_DIFFMOD    0x0001          // Show module only if different
#define ADC_NOMODNAME  0x0002          // Never show module name
#define ADC_VALID      0x0004          // Only decode if allocated memory
#define ADC_INMODULE   0x0008          // Only decode if in some module
#define ADC_SAMEMOD    0x0010          // Decode only address in same module
#define ADC_SYMBOL     0x0020          // Only decode if symbolic name
#define ADC_JUMP       0x0040          // Check if points to JMP/CALL command
#define ADC_OFFSET     0x0080          // Check if symbol for data
#define ADC_STRING     0x0100          // Check if pointer to ASCII or UNICODE
#define ADC_ENTRY      0x0200          // Check if entry to subroutine
#define ADC_UPPERCASE  0x0400          // First letter in uppercase if possible
#define ADC_WIDEFORM   0x0800          // Extended form of decoded name
#define ADC_NONTRIVIAL 0x1000          // Name + non-zero offset
#define ADC_DYNAMIC    0x2000          // JMP/CALL to dynamically loaded name

#define PLAINASCII     0x01            // Plain ASCII character
#define DIACRITICAL    0x02            // Diacritical character
#define RAREASCII      0x10            // Rare ASCII character

extc int     cdecl Decodeaddress(ulong addr,ulong base,int addrmode,
               char *symb,int nsymb,char *comment);
extc int     cdecl Decoderelativeoffset(ulong addr,int addrmode,
               char *symb,int nsymb);
extc int     cdecl Decodecharacter(char *s,uint c);
extc int     cdecl Printfloat4(char *s,float f);
extc int     cdecl Printfloat8(char *s,double d);
extc int     cdecl Printfloat10(char *s,long double ext);
extc int     cdecl Print3dnow(char *s,uchar *f);
extc int     cdecl Printsse(char *s,char *f);
extc ulong   cdecl Followcall(ulong addr);
extc int     cdecl IstextA(char c);
extc int     cdecl IstextW(wchar_t w);
extc int     cdecl Stringtotext(char *data,int ndata,char *text,int ntext);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// DATA INPUT FUNCTIONS /////////////////////////////

#define MAXCMDSIZE     16              // Maximal length of 80x86 command
#define NSEQ           8               // Max length of command sequence
#define NMODELS        8               // Number of assembler search models

// Note that each of dialog functions decodes only subset of listed flags.
#define DIA_ASKGLOBAL  0x0001          // Display checkbox "Global search"
#define DIA_HEXONLY    0x0002          // Hexadecimal format only
#define DIA_ALIGNED    0x0004          // Display checkbox "Aligned search"
#define DIA_DEFHEX     0x0000          // On startup, cursor in hex control
#define DIA_DEFASCII   0x0010          // On startup, cursor in ASCII control
#define DIA_DEFUNICODE 0x0020          // On startup, cursor in UNICODE control
#define DIA_SEARCH     0x0040          // Is a search dialog
#define DIA_HISTORY    0x0100          // Allows previous hex strings

// Status of animation or trace.
#define ANIMATE_OFF    0               // No animation
#define ANIMATE_IN     1               // Animate into
#define ANIMATE_OVER   2               // Animate over
#define ANIMATE_RET    3               // Execute till RET
#define ANIMATE_SKPRET 4               // Skip RET instruction
#define ANIMATE_USER   5               // Execute till user code
#define ANIMATE_TRIN   6               // Run trace in
#define ANIMATE_TROVER 7               // Run trace over
#define ANIMATE_STOP   8               // Gracefully stop animation

typedef struct t_hexstr {              // String used for hex/text search
  int            n;                    // String length
  uchar          data[TEXTLEN];        // Data
  uchar          mask[TEXTLEN];        // Mask, 0 bits are masked
} t_hexstr;

typedef struct t_asmmodel {            // Model to search for assembler command
  uchar          code[MAXCMDSIZE];     // Binary code
  uchar          mask[MAXCMDSIZE];     // Mask for binary code (0: bit ignored)
  int            length;               // Length of code, bytes (0: empty)
  int            jmpsize;              // Offset size if relative jump
  int            jmpoffset;            // Offset relative to IP
  int            jmppos;               // Position of jump offset in command
} t_asmmodel;

typedef struct t_extmodel {            // Model for extended command search
  char           code[MAXCMDSIZE];     // Binary code
  char           mask[MAXCMDSIZE];     // Mask for binary code (0: bit ignored)
  int            length;               // Length of code, bytes (0: empty)
  int            jmpsize;              // Offset size if relative jump
  int            jmpoffset;            // Offset relative to IP
  int            jmppos;               // Position of jump offset in command
  int            isany;                // Count for ANY's argument
  int            cmdoffset;            // Offset of command in the source
  char           ramask[MAXCMDSIZE];   // Mask for pseudoregister RA
  char           rbmask[MAXCMDSIZE];   // Mask for pseudoregister RB
} t_extmodel;

extc int     cdecl Getlong(char *title,ulong *data,int datasize,
               char letter,int mode);
extc int     cdecl Getlongxy(char *title,ulong *data,int datasize,
               char letter,int mode,int x,int y);
extc int     cdecl Getregxy(char *title,ulong *data,char letter,int x,int y);
extc int     cdecl Getline(char *title,ulong *data);
extc int     cdecl Getlinexy(char *title,ulong *data,int x,int y);
extc int     cdecl Getfloat10(char *title,long double *fdata,
               uchar *tag,char letter,int mode);
extc int     cdecl Getfloat10xy(char *title,long double *fdata,
               char *tag,char letter,int mode,int x,int y);
extc int     cdecl Getfloat(char *title,void *fdata,int size,
               char letter,int mode);
extc int     cdecl Getfloatxy(char *title,void *fdata,int size,
               char letter,int mode,int x,int y);
extc void    cdecl Getasmfindmodel(t_asmmodel model[NMODELS],
               char letter,int searchall);
extc void    cdecl Getasmfindmodelxy(t_asmmodel model[NMODELS],
               char letter,int searchall,int x,int y);
extc int     cdecl Gettext(char *title,char *text,
               char letter,int type,int fontindex);
extc int     cdecl Gettextxy(char *title,char *text,char letter,
               int type,int fontindex,int x,int y);
extc int     cdecl Gethexstring(char *title,t_hexstr *hs,
               int mode,int fontindex,char letter);
extc int     cdecl Gethexstringxy(char *title,t_hexstr *hs,int mode,
               int fontindex,char letter,int x,int y);
extc int     cdecl Getmmx(char *title,uchar *data,int mode);
extc int     cdecl Getmmxxy(char *title,char *data,int mode,int x,int y);
extc int     cdecl Get3dnow(char *title,uchar *data,int mode);
extc int     cdecl Get3dnowxy(char *title,char *data,int mode,int x,int y);
extc int     cdecl Browsefilename(char *title,char *name,char *defext,
               int getarguments);
extc int     cdecl OpenEXEfile(char *path,int dropped);
extc int     cdecl Attachtoactiveprocess(int newprocessid);
extc void    cdecl Animate(int animation);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// SORTED DATA FUNCTIONS /////////////////////////////

#define NBAR           17              // Max allowed number of segments in bar

#define BAR_PRESSED    0x01            // Bar segment pressed, used internally
#define BAR_DISABLED   0x02            // Bar segment disabled
#define BAR_NOSORT     0x04            // Flat bar column, supports no sorting
#define BAR_NORESIZE   0x08            // Bar column cannot be resized
#define BAR_BUTTON     0x10            // Segment sends WM_USER_BAR
#define BAR_SHIFTSEL   0x20            // Selection shifted 1/2 char to left

#define CAPT_FREE      0               // Bar and data are not captured

#define TABLE_DIR      0x0001          // Bottom-to-top table
#define TABLE_COPYMENU 0x0002          // Attach copy item
#define TABLE_SORTMENU 0x0004          // Attach sort menu
#define TABLE_APPMENU  0x0010          // Attach appearance menu
#define TABLE_WIDECOL  0x0020          // Attach wide columns menu item
#define TABLE_USERAPP  0x0040          // Attach user-processed appearance menu
#define TABLE_USERDEF  0x0080          // User-drawn table
#define TABLE_NOHSCR   0x0100          // Table contains no horizontal scroll
#define TABLE_SAVEPOS  0x0200          // Save position & appearance to .ini
#define TABLE_CPU      0x0400          // Table belongs to CPU window
#define TABLE_FASTSEL  0x0800          // Update when selection changes
#define TABLE_COLSEL   0x1000          // Column-wide selection
#define TABLE_SAVEAPP  0x2000          // Save multiinstance appearance to .ini
#define TABLE_HILMENU  0x4000          // Attach Syntax highlighting menu
#define TABLE_ONTOP    0x8000          // Attach Always on top menu

#define DRAW_NORMAL    0x0000          // Normal plain text
#define DRAW_GRAY      0x0001          // Grayed text
#define DRAW_HILITE    0x0002          // Highlighted text
#define DRAW_UL        0x0004          // Underlined text
#define DRAW_SELECT    0x0008          // Selected background
#define DRAW_EIP       0x0010          // Inverted normal text/background
#define DRAW_BREAK     0x0020          // Breakpoint background
#define DRAW_GRAPH     0x0040          // Graphical element
#define DRAW_DIRECT    0x0080          // Direct text colour index (mask only)
#define DRAW_MASK      0x0080          // Use mask to set individual colors
#define DRAW_EXTSEL    0x0100          // Extend mask till end of column
#define DRAW_UNICODE   0x0200          // Text in UNICODE
#define DRAW_TOP       0x0400          // Draw upper half of text
#define DRAW_BOTTOM    0x0800          // Draw lower half of text

// Symbolic names for graphical characters. Any other character is displayed
// as space. Use only characters in range [1..0x7F]!
#define D_SPACE        'N'             // Space
#define D_SEP          ' '             // Thin separating line
#define D_BEGIN        'B'             // Begin of procedure or scope
#define D_BODY         'I'             // Body of procedure or scope
#define D_ENTRY        'J'             // Loop entry point
#define D_LEAF         'K'             // Intermediate leaf on a tree
#define D_END          'E'             // End of procedure or scope
#define D_SINGLE       'S'             // Single-line scope
#define D_ENDBEG       'T'             // End and begin of stack scope
#define D_POINT        '.'             // Point
#define D_JMPUP        'U'             // Jump upstairs
#define D_JMPOUT       '<'             // Jump to same location or out of module
#define D_JMPDN        'D'             // Jump downstairs
#define D_PATHUP       'u'             // Jump path upstairs (highlighted)
#define D_GRAYUP       'v'             // Jump path upstairs (grayed)
#define D_PATH         'i'             // Jump path through text (highlighted)
#define D_GRAYPATH     'j'             // Jump path through text (grayed)
#define D_PATHDN       'd'             // Jump path downstairs (highlighted)
#define D_GRAYDN       'e'             // Jump path downstairs (grayed)
#define D_PATHUPEND    'r'             // End of path upstairs (highlighted)
#define D_GRAYUPEND    's'             // End of path upstairs (grayed)
#define D_PATHDNEND    'f'             // End of path downstairs (highlighted)
#define D_GRAYDNEND    'g'             // End of path downstairs (grayed)
#define D_SWTOP        't'             // Start of switch
#define D_SWBODY       'b'             // Switch body
#define D_CASE         'c'             // Intermediate switch case
#define D_LASTCASE     'l'             // Last switch case

// Please note: Although types here contain mostly unique bit assignments, it's
// not really necessary. Same bits, except for reserved general types, can be
// freely shared between different types of sorted data.
// General item types:
#define TY_NEW         0x00000001      // Item is new
#define TY_CONFIRMED   0x00000002      // Item still exists
#define TY_MAIN        0x00000004      // Main item (thread or module)
#define TY_INVALID     0x00000008      // Invalid type (item does not exist)
#define TY_SELECTED    0x80000000      // Reserved for multiple selection
// Module-specific types:
#define TY_REPORTED    0x00000010      // Stop on module was reported
// Reference-specific types:
#define TY_REFERENCE   0x00000020      // Item is a real reference
#define TY_ORIGIN      0x00000040      // Item is a search origin
// Breakpoint-specific types:
#define TY_STOPAN      0x00000080      // Stop animation if TY_ONESHOT
#define TY_SET         0x00000100      // Code INT3 is in memory
#define TY_ACTIVE      0x00000200      // Permanent breakpoint
#define TY_DISABLED    0x00000400      // Permanent disabled breakpoint
#define TY_ONESHOT     0x00000800      // Temporary stop
#define TY_TEMP        0x00001000      // Temporary breakpoint
#define TY_KEEPCODE    0x00002000      // Set and keep command code
#define TY_KEEPCOND    0x00004000      // Keep condition unchanged (0: remove)
#define TY_NOUPDATE    0x00008000      // Don't redraw breakpoint window
#define TY_RTRACE      0x00010000      // Pseudotype of run trace breakpoint
// Namelist-specific types:
#define TY_EXPORT      0x00010000      // Exported name
#define TY_IMPORT      0x00020000      // Imported name
#define TY_LIBRARY     0x00040000      // Name extracted from object file
#define TY_LABEL       0x00080000      // User-defined name
#define TY_ANYNAME     0x000F0000      // Any of the namelist flags above
#define TY_KNOWN       0x00100000      // Name of known function
// Memory-specific types:
#define TY_DEFHEAP     0x00020000      // Contains default heap
#define TY_HEAP        0x00040000      // Contains non-default heap
#define TY_SFX         0x00080000      // Contains self-extractor
#define TY_CODE        0x00100000      // Contains image of code section
#define TY_DATA        0x00200000      // Contains image of data section
#define TY_IMPDATA     0x00400000      // Memory block includes import data
#define TY_EXPDATA     0x00800000      // Memory block includes export data
#define TY_RSRC        0x01000000      // Memory block includes resources
#define TY_RELOC       0x02000000      // Memory block includes relocation data
#define TY_STACK       0x04000000      // Contains stack of some thread
#define TY_THREAD      0x08000000      // Contains data block of some thread
#define TY_HEADER      0x10000000      // COFF header
#define TY_ANYMEM      0x1FFE0000      // Any of the memory flags above
#define TY_GUARDED     0x20000000      // NT only: guarded memory block
// Procedure data-specific types:
#define TY_PURE        0x00004000      // No side effects except in stack
#define TY_PASCAL      0x00010000      // Procedure ends with RET nnn
#define TY_C           0x00020000      // ADD ESP,nnn after call to procedure
#define TY_NOTENTRY    0x00100000      // Not necessarily entry point
// Switch data-specific types.
#define TY_CHARSW      0x00100000      // ASCII switch
#define TY_WMSW        0x00200000      // Window message switch
#define TY_EXCEPTSW    0x00400000      // Exception switch
// Stack walk data-specific types.
#define TY_RELIABLE    0x01000000      // Reliable call
#define TY_GUESSED     0x02000000      // Not a real entry, just guessed
#define TY_BELONGS     0x04000000      // Not a real entry, just belongs to proc
// Call tree-specific types.
#define TY_RECURSIVE   0x00000100      // Routine calls self
#define TY_TERMINAL    0x00000200      // Leaf function, doesn't call others
#define TY_SYSTEM      0x00000400      // Function resides in system DLL
#define TY_DIRECT      0x00000800      // Called directly
#define TY_NODATA      0x00001000      // Not analyzed or outside procedure
#define TY_DUMMY       0x00002000      // Consists of single RET command
#define TY_NOSIDE      0x00004000      // No side effects except in stack

typedef struct t_scheme {              // Color scheme
  char           *name;                // Name of the scheme
  int            textcolor;            // Colour used to draw text
  int            hitextcolor;          // Colour used to draw highlited text
  int            lowcolor;             // Colour used to draw auxiliary text
  int            bkcolor;              // Colour used to draw backgrounds
  int            selbkcolor;           // Colour used for selecting background
  int            linecolor;            // Colour used for separating lines
  int            auxcolor;             // Colour used for auxiliary objects
  int            condbkcolor;          // Colour used for background of cond brk
} t_scheme;

typedef struct t_schemeopt {           // Color scheme, alternative form
  char           *name;                // Name of the scheme
  int            color[8];             // Colours used as in t_scheme
} t_schemeopt;

typedef struct t_bar {
  int            nbar;                 // Number of active columns
  int            font;                 // Font used for bar segments
  int            dx[NBAR];             // Actual widths of columns, pixels
  int            defdx[NBAR];          // Default widths of columns, chars
  char           *name[NBAR];          // Column names (may be NULL)
  uchar          mode[NBAR];           // Combination of BAR_xxx bits
  int            captured;             // One of CAPT_xxx, set to CAPT_FREE
  int            active;               // Info about how mouse is captured
  int            prevx;                // Previous mouse coordinate
} t_bar;

typedef struct t_sortheader {          // Header of sorted data field
  ulong          addr;                 // Base address of the entry
  ulong          size;                 // Size address of the entry
  ulong          type;                 // Entry type, TY_xxx
} t_sortheader;

typedef int  SORTFUNC(const t_sortheader *,const t_sortheader *,const int);
typedef int  DRAWFUNC(char *,char *,int *,t_sortheader *,int);
typedef void DESTFUNC(t_sortheader *);

#define AUTOARRANGE    ((SORTFUNC *)1) // Autoarrangeable sorted data

typedef struct t_sorted {              // Descriptor of sorted table
  char           name[MAX_PATH];       // Name of table, as appears in error
  int            n;                    // Actual number of entries
  int            nmax;                 // Maximal number of entries
  int            selected;             // Index of selected entry or -1
  ulong          seladdr;              // Base address of selected entry
  int            itemsize;             // Size of single entry
  ulong          version;              // Unique version of table
  void           *data;                // Entries, sorted by address
  SORTFUNC       *sortfunc;            // Function which sorts data or NULL
  DESTFUNC       *destfunc;            // Destructor function or NULL
  int            sort;                 // Sorting criterium (column)
  int            sorted;               // Whether indexes are sorted
  int            *index;               // Indexes, sorted by criterium
  int            suppresserr;          // Suppress multiple overflow errors
} t_sorted;

typedef struct t_table {               // Window with sorted data and bar
  HWND           hw;                   // Handle of window or NULL
  t_sorted       data;                 // Sorted data
  t_bar          bar;                  // Description of bar
  int            showbar;              // Bar: 1-displayed, 0-hidden, -1-absent
  short          hscroll;              // Horiz. scroll: 1-displayed, 0-hidden
  short          colsel;               // Column in TABLE_COLSEL window
  int            mode;                 // Combination of bits TABLE_xxx
  int            font;                 // Font used by window
  short          scheme;               // Colour scheme used by window
  short          hilite;               // Syntax highlighting used by window
  int            offset;               // First displayed row
  int            xshift;               // Shift in X direction, pixels
  DRAWFUNC       *drawfunc;            // Function which decodes table fields
} t_table;

extc int     cdecl Createsorteddata(t_sorted *sd,char *name,int itemsize,
               int nmax,SORTFUNC *sortfunc,DESTFUNC *destfunc);
extc void    cdecl Destroysorteddata(t_sorted *sd);
extc void    cdecl *Addsorteddata(t_sorted *sd,void *item);
extc void    cdecl Deletesorteddata(t_sorted *sd,ulong addr);
extc void    cdecl Deletesorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
extc int     cdecl Deletenonconfirmedsorteddata(t_sorted *sd);
extc void*   cdecl Findsorteddata(t_sorted *sd,ulong addr);
extc void*   cdecl Findsorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
extc int     cdecl Findsorteddataindex(t_sorted *sd,ulong addr0,ulong addr1);
extc int     cdecl Sortsorteddata(t_sorted *sd,int sort);
extc void*   cdecl Getsortedbyselection(t_sorted *sd,int index);
extc void    cdecl Defaultbar(t_bar *pb);
extc int     cdecl Tablefunction(t_table *pt,
               HWND hw,UINT msg,WPARAM wp,LPARAM lp);
extc void    cdecl Painttable(HWND hw,t_table *pt,DRAWFUNC getline);
extc int     cdecl Gettableselectionxy(t_table *pt,int column,int *px,int *py);
extc void    cdecl Selectandscroll(t_table *pt,int index,int mode);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// NAME FUNCTIONS ////////////////////////////////

// Types of names used in name functions. Note that higher-priority types have
// smaller identifiers!
#define NM_NONAME      0x00            // Undefined name
#define NM_ANYNAME     0xFF            // Name of any type
// Names saved in the data file of module they appear.
#define NM_PLUGCMD     0x30            // Plugin commands to execute at break
#define NM_LABEL       0x31            // User-defined label
#define NM_EXPORT      0x32            // Exported (global) name
#define NM_IMPORT      0x33            // Imported name
#define NM_LIBRARY     0x34            // Name from library or object file
#define NM_CONST       0x35            // User-defined constant
#define NM_COMMENT     0x36            // User-defined comment
#define NM_LIBCOMM     0x37            // Comment from library or object file
#define NM_BREAK       0x38            // Condition related with breakpoint
#define NM_ARG         0x39            // Arguments decoded by analyzer
#define NM_ANALYSE     0x3A            // Comment added by analyzer
#define NM_BREAKEXPR   0x3B            // Expression related with breakpoint
#define NM_BREAKEXPL   0x3C            // Explanation related with breakpoint
#define NM_ASSUME      0x3D            // Assume function with known arguments
#define NM_STRUCT      0x3E            // Code structure decoded by analyzer
#define NM_CASE        0x3F            // Case description decoded by analyzer
// Names saved in the data file of main module.
#define NM_INSPECT     0x40            // Several last inspect expressions
#define NM_WATCH       0x41            // Watch expressions
#define NM_ASM         0x42            // Several last assembled strings
#define NM_FINDASM     0x43            // Several last find assembler strings
#define NM_LASTWATCH   0x48            // Several last watch expressions
#define NM_SOURCE      0x49            // Several last source search strings
#define NM_REFTXT      0x4A            // Several last ref text search strings
#define NM_GOTO        0x4B            // Several last expressions to follow
#define NM_GOTODUMP    0x4C            // Several expressions to follow in Dump
#define NM_TRPAUSE     0x4D            // Several expressions to pause trace
// Pseudonames.
#define NM_IMCALL      0xFE            // Intermodular call

#define NMHISTORY      0x40            // Converts NM_xxx to type of init list

extc int     cdecl Insertname(ulong addr,int type,char *name);
extc int     cdecl Quickinsertname(ulong addr,int type,char *name);
extc void    cdecl Mergequicknames(void);
extc void    cdecl Discardquicknames(void);
extc int     cdecl Findname(ulong addr,int type,char *name);
extc int     cdecl Decodename(ulong addr,int type,char *name);
extc ulong   cdecl Findnextname(char *name);
extc int     cdecl Findlabel(ulong addr,char *name);
extc void    cdecl Deletenamerange(ulong addr0,ulong addr1,int type);
extc int     cdecl Findlabelbyname(char *name,ulong *addr,
               ulong addr0,ulong addr1);
extc ulong   cdecl Findimportbyname(char *name,ulong addr0,ulong addr1);
extc int     cdecl Demanglename(char *name,int type,char *undecorated);
extc int     cdecl Findsymbolicname(ulong addr,char *fname);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DISASSEMBLY FUNCTIONS /////////////////////////////

#define REG_EAX        0               // Indexes of general-purpose registers
#define REG_ECX        1               // in t_reg.
#define REG_EDX        2
#define REG_EBX        3
#define REG_ESP        4
#define REG_EBP        5
#define REG_ESI        6
#define REG_EDI        7

#define SEG_UNDEF     -1
#define SEG_ES         0               // Indexes of segment/selector registers
#define SEG_CS         1               // in t_reg.
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5

// Selected items in register window.
#define RS_NONE        0x0000          // No selection
#define RS_INT         0x0010          // General-purpose 32-bit registers
#define RS_EIP         0x0020          // EIP (instruction pointer)
#define RS_FLG         0x0030          // 1-bit decoded flags
#define RS_SEG         0x0040          // Segment (selector) registers
#define RS_EFL         0x0050          // 32-bit flag register
#define RS_TAG         0x0060          // FPU register tag
#define RS_FPU         0x0070          // 80-bit FPU registers
#define RS_FST         0x0080          // FPU status
#define RS_FCO         0x0090          // FPU condition bits
#define RS_FER         0x00A0          // FPU error bits
#define RS_FCW         0x00B0          // FPU control word
#define RS_FPR         0x00C0          // FPU precision fields
#define RS_FEM         0x00D0          // FPU error mask bits
#define RS_MMX         0x00E0          // MMX registers
#define RS_3DN         0x00F0          // 3DNow! registers
#define RS_SSE         0x0100          // SSE registers
#define RS_CSR         0x0110          // SSE MXCSR register
#define RS_CSB         0x0120          // SSE MXCSR bits
#define RS_CPR         0x0130          // SSE rounding control
#define RS_ERR         0x0140          // Last thread error

#define RS_GROUP       0x01F0          // Mask to extract group of registers
#define RS_INDEX       0x000F          // Mask to extract index of register

#define NREGSTACK      32              // Length of stack trace buffer
#define MAXCALSIZE     8               // Max length of CALL without prefixes

#define INT3           0xCC            // Code of 1-byte breakpoint
#define NOP            0x90            // Code of 1-byte NOP command
#define TRAPFLAG       0x00000100      // Trap flag in CPU flag register

#define C_TYPEMASK     0xF0            // Mask for command type
#define   C_CMD        0x00            // Ordinary instruction
#define   C_PSH        0x10            // PUSH instruction
#define   C_POP        0x20            // POP instruction
#define   C_MMX        0x30            // MMX instruction
#define   C_FLT        0x40            // FPU instruction
#define   C_JMP        0x50            // JUMP instruction
#define   C_JMC        0x60            // Conditional JUMP instruction
#define   C_CAL        0x70            // CALL instruction
#define   C_RET        0x80            // RET instruction
#define   C_FLG        0x90            // Changes system flags
#define   C_RTF        0xA0            // C_JMP and C_FLG simultaneously
#define   C_REP        0xB0            // Instruction with REPxx prefix
#define   C_PRI        0xC0            // Privileged instruction
#define   C_SSE        0xD0            // SSE instruction
#define   C_NOW        0xE0            // 3DNow! instruction
#define   C_BAD        0xF0            // Unrecognized command
#define C_RARE         0x08            // Rare command, seldom used in programs
#define C_SIZEMASK     0x07            // MMX data size or special flag
#define   C_EXPL       0x01            // (non-MMX) Specify explicit memory size

#define C_DANGER95     0x01            // Command is dangerous under Win95/98
#define C_DANGER       0x03            // Command is dangerous everywhere
#define C_DANGERLOCK   0x07            // Dangerous with LOCK prefix

#define DEC_TYPEMASK   0x1F            // Type of memory byte
#define   DEC_UNKNOWN  0x00            // Unknown type
#define   DEC_BYTE     0x01            // Accessed as byte
#define   DEC_WORD     0x02            // Accessed as short
#define   DEC_NEXTDATA 0x03            // Subsequent byte of data
#define   DEC_DWORD    0x04            // Accessed as long
#define   DEC_FLOAT4   0x05            // Accessed as float
#define   DEC_FWORD    0x06            // Accessed as descriptor/long pointer
#define   DEC_FLOAT8   0x07            // Accessed as double
#define   DEC_QWORD    0x08            // Accessed as 8-byte integer
#define   DEC_FLOAT10  0x09            // Accessed as long double
#define   DEC_TBYTE    0x0A            // Accessed as 10-byte integer
#define   DEC_STRING   0x0B            // Zero-terminated ASCII string
#define   DEC_UNICODE  0x0C            // Zero-terminated UNICODE string
#define   DEC_3DNOW    0x0D            // Accessed as 3Dnow operand
#define   DEC_SSE      0x0E            // Accessed as SSE operand
#define   DEC_TEXT     0x10            // For use in t_result only
#define   DEC_BYTESW   0x11            // Accessed as byte index to switch
#define   DEC_NEXTCODE 0x13            // Subsequent byte of command
#define   DEC_COMMAND  0x1D            // First byte of command
#define   DEC_JMPDEST  0x1E            // Jump destination
#define   DEC_CALLDEST 0x1F            // Call (and maybe jump) destination
#define DEC_PROCMASK   0x60            // Procedure analysis
#define   DEC_PROC     0x20            // Start of procedure
#define   DEC_PBODY    0x40            // Body of procedure
#define   DEC_PEND     0x60            // End of procedure
#define DEC_CHECKED    0x80            // Byte was analysed
#define DEC_SIGNED     0x100           // For use in t_result only

#define DISASM_SIZE    0               // Determine command size only
#define DISASM_DATA    1               // Determine size and analysis data
#define DISASM_TRACE   2               // Trace integer registers
#define DISASM_FILE    3               // Disassembly, no symbols/registers
#define DISASM_CODE    4               // Disassembly, registers undefined
#define DISASM_ALL     5               // Complete disassembly
#define DISASM_RTRACE  6               // Disassemble with run-trace registers

#define DISASM_MODE    0x0000000F      // Mask to extract disassembling mode
#define DISASM_HILITE  0x000F0000      // Mask to extract highlighting mode
#define DISASM_HLSHIFT 16              // Shift to extract highlighting mode

// Warnings issued by Disasm():
#define DAW_FARADDR    0x0001          // Command is a far jump, call or return
#define DAW_SEGMENT    0x0002          // Command loads segment register
#define DAW_PRIV       0x0004          // Privileged command
#define DAW_IO         0x0008          // I/O command
#define DAW_SHIFT      0x0010          // Shift constant out of range 1..31
#define DAW_PREFIX     0x0020          // Superfluous prefix
#define DAW_LOCK       0x0040          // Command has LOCK prefix
#define DAW_STACK      0x0080          // Unaligned stack operation
#define DAW_DANGER95   0x1000          // May mess up Win95/98 if executed
#define DAW_DANGEROUS  0x3000          // May mess up any OS if executed

#define RST_INVALID    0               // Register undefined
#define RST_VALUE      1               // Register contains regdata
#define RST_VFIXUP     2               // Reg contains regdata that is fixup
#define RST_INDIRECT   3               // Register contains [regdata]

#define NREGSTACK      32              // Length of stack trace buffer

typedef struct t_reg {                 // Excerpt from context
  int            modified;             // Some regs modified, update context
  int            modifiedbyuser;       // Among modified, some modified by user
  int            singlestep;           // Type of single step, SS_xxx
  ulong          r[8];                 // EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
  ulong          ip;                   // Instruction pointer (EIP)
  ulong          flags;                // Flags
  int            top;                  // Index of top-of-stack
  long double    f[8];                 // Float registers, f[top] - top of stack
  char           tag[8];               // Float tags (0x3 - empty register)
  ulong          fst;                  // FPU status word
  ulong          fcw;                  // FPU control word
  ulong          s[6];                 // Segment registers ES,CS,SS,DS,FS,GS
  ulong          base[6];              // Segment bases
  ulong          limit[6];             // Segment limits
  char           big[6];               // Default size (0-16, 1-32 bit)
  ulong          dr6;                  // Debug register DR6
  ulong          threadid;             // ID of thread that owns registers
  ulong          lasterror;            // Last thread error or 0xFFFFFFFF
  int            ssevalid;             // Whether SSE registers valid
  int            ssemodified;          // Whether SSE registers modified
  char           ssereg[8][16];        // SSE registers
  ulong          mxcsr;                // SSE control and status register
  int            selected;             // Reports selected register to plugin
  ulong          drlin[4];             // Debug registers DR0..DR3
  ulong          dr7;                  // Debug register DR7
} t_reg;

typedef struct t_operand {             // Full decription of command's operand
  char           optype;               // DEC_xxx (mem) or DECR_xxx (reg,const)
  char           opsize;               // Size of operand
  char           regscale[8];          // Scales of registers
  char           seg;                  // Segment register
  ulong          opconst;              // Constant
} t_operand;

typedef struct t_disasm {              // Results of disassembling
  ulong          ip;                   // Instrucion pointer
  char           dump[TEXTLEN];        // Hexadecimal dump of the command
  char           result[TEXTLEN];      // Disassembled command
  char           comment[TEXTLEN];     // Brief comment
  char           opinfo[3][TEXTLEN];   // Comments to command's operands
  int            cmdtype;              // One of C_xxx
  int            memtype;              // Type of addressed variable in memory
  int            nprefix;              // Number of prefixes
  int            indexed;              // Address contains register(s)
  ulong          jmpconst;             // Constant jump address
  ulong          jmptable;             // Possible address of switch table
  ulong          adrconst;             // Constant part of address
  ulong          immconst;             // Immediate constant
  int            zeroconst;            // Whether contains zero constant
  int            fixupoffset;          // Possible offset of 32-bit fixups
  int            fixupsize;            // Possible total size of fixups or 0
  ulong          jmpaddr;              // Destination of jump/call/return
  int            condition;            // 0xFF:unconditional, 0:false, 1:true
  int            error;                // Error while disassembling command
  int            warnings;             // Combination of DAW_xxx
  int            optype[3];            // Type of operand (extended set DEC_xxx)
  int            opsize[3];            // Size of operand, bytes
  int            opgood[3];            // Whether address and data valid
  ulong          opaddr[3];            // Address if memory, index if register
  ulong          opdata[3];            // Actual value (only integer operands)
  t_operand      op[3];                // Full description of operand
  ulong          regdata[8];           // Registers after command is executed
  int            regstatus[8];         // Status of registers, one of RST_xxx
  ulong          addrdata;             // Traced memory address
  int            addrstatus;           // Status of addrdata, one of RST_xxx
  ulong          regstack[NREGSTACK];  // Stack tracing buffer
  int            rststatus[NREGSTACK]; // Status of stack items
  int            nregstack;            // Number of items in stack trace buffer
  ulong          reserved[29];         // Reserved for plugin compatibility
} t_disasm;

extc ulong   cdecl Disasm(uchar *src,ulong srcsize,ulong srcip,uchar *srcdec,
               t_disasm *disasm,int disasmmode,ulong threadid);
extc ulong   cdecl Disassembleback(uchar *block,ulong base,ulong size,
               ulong ip,int n,int usedec);
extc ulong   cdecl Disassembleforward(uchar *block,ulong base,ulong size,
               ulong ip,int n,int usedec);
extc int     cdecl Issuspicious(char *cmd,ulong size,ulong ip,
               ulong threadid,t_reg *preg,char *s);
extc int     cdecl Isfilling(ulong offset,char *data,ulong size,ulong align);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////// ASSEMBLY FUNCTIONS //////////////////////////////

extc int     cdecl Assemble(char *cmd,ulong ip,t_asmmodel *model,int attempt,
               int constsize,char *errtext);
extc int     cdecl Checkcondition(int code,ulong flags);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// EXPRESSIONS //////////////////////////////////

typedef struct t_result {              // Result of expression's evaluation
  int            type;                 // Type of expression, DEC(R)_xxx
  int            dtype;                // Type of data, DEC_xxx
  union {
    uchar        data[10];             // Binary form of expression's value
    ulong        u;                    // Value as unsigned integer
    long         l;                    // Value as signed integer
    long double  f; };                 // Value as 80-bit float
  union {
    char         value[TEXTLEN];       // ASCII form of expression's value
    wchar_t      wvalue[TEXTLEN/2]; }; // UNICODE form of expression's value
  ulong          lvaddr;               // Address of lvalue or NULL
} t_result;

extc int     cdecl Expression(t_result *result,char *expression,int a,int b,
               uchar *data,ulong database,ulong datasize,ulong threadid);

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// THREAD FUNCTIONS ///////////////////////////////

typedef struct t_thread {              // Information about active threads
  ulong          threadid;             // Thread identifier
  ulong          dummy;                // Always 1
  ulong          type;                 // Service information, TY_xxx
  HANDLE         thread;               // Thread handle
  ulong          datablock;            // Per-thread data block
  ulong          entry;                // Thread entry point
  ulong          stacktop;             // Working variable of Listmemory()
  ulong          stackbottom;          // Working variable of Listmemory()
  CONTEXT        context;              // Actual context of the thread
  t_reg          reg;                  // Actual contents of registers
  int            regvalid;             // Whether reg is valid
  t_reg          oldreg;               // Previous contents of registers
  int            oldregvalid;          // Whether oldreg is valid
  int            suspendcount;         // Suspension count (may be negative)
  long           usertime;             // Time in user mode, 1/10th ms, or -1
  long           systime;              // Time in system mode, 1/10th ms, or -1
  ulong          reserved[16];         // Reserved for future compatibility
} t_thread;

extc HWND    cdecl Createthreadwindow(void);
extc t_thread* cdecl Findthread(ulong threadid);
extc int     cdecl Decodethreadname(char *s,ulong threadid,int mode);
extc ulong   cdecl Getcputhreadid(void);
extc ulong   cdecl Runsinglethread(ulong threadid);
extc void    cdecl Restoreallthreads(void);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MEMORY FUNCTIONS ///////////////////////////////

// Mode bits recognized by Readmemory() and Writememory().
#define MM_RESTORE     0x01            // Restore or remove INT3 breakpoints
#define MM_SILENT      0x02            // Don't display error message
#define MM_DELANAL     0x04            // Delete analysis from the memory

#define MM_RESILENT    (MM_RESTORE|MM_SILENT)

typedef struct t_memory {              // Memory block descriptor
  ulong          base;                 // Base address of memory block
  ulong          size;                 // Size of block
  ulong          type;                 // Service information, TY_xxx
  ulong          owner;                // Address of owner of the memory
  ulong          initaccess;           // Initial read/write access
  ulong          access;               // Actual status and read/write access
  ulong          threadid;             // Block belongs to this thread or 0
  char           sect[SHORTLEN];       // Name of module section
  uchar          *copy;                // Copy used in CPU window or NULL
  ulong          reserved[8];          // Reserved for plugin compatibility
} t_memory;

typedef struct t_heap {                // Heap block descriptor
  ulong          base;                 // Base address of heap block
  ulong          size;                 // Size of heap block
  ulong          type;                 // Service information, TY_xxx
  ulong          parent;               // Handle of heap descriptor block
} t_heap;

extc int     cdecl Listmemory(void);
extc t_memory* cdecl Findmemory(ulong addr);
extc int     cdecl Guardmemory(ulong base,ulong size,int guard);
extc void    cdecl Havecopyofmemory(uchar *copy,ulong base,ulong size);
extc ulong   cdecl Readmemory(void *buf,ulong addr,ulong size,int mode);
extc ulong   cdecl Writememory(void *buf,ulong addr,ulong size,int mode);
extc ulong   cdecl Readcommand(ulong ip,char *cmd);

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MODULE FUNCTIONS ///////////////////////////////

#define NVERS          32              // Max allowed length of file version

// Types of recognized jumps.
#define JT_JUMP        0               // Unconditional jump
#define JT_COND        1               // Conditional jump
#define JT_SWITCH      2               // Jump via switch table

typedef struct t_ahint {               // User-supplied hint for analysis
  ulong          addr;                 // Hint address
  ulong          size;                 // Hint size
  ulong          type;                 // Hint type, bits from DEC_TYPEMASK
} t_ahint;

typedef struct t_stringtable {         // Pointers to string resources
  ulong          name;                 // Name of block of strings
  ulong          language;             // Language identifier
  ulong          addr;                 // Address of block in memory
  ulong          size;                 // Size of block in memory
} t_stringtable;

typedef struct t_fixup {
  ulong          base;                 // Address of fixup
  ulong          size;                 // Size of fixup (usually 2 or 4 bytes)
} t_fixup;

typedef struct t_symvar {              // Symbolic variable from debug data
  int            next;                 // Index of next variable in chain or -1
  ushort         kind;                 // Kind of variable
  union {
    ulong        type;                 // Type of variable
    ulong        regs; };              // Registers in optvar
  union {
    ulong        addr;                 // Address or description of registers
    long         offset; };            // Offset for EBP-relative data
  ulong          size;                 // Size of variable or optvar data
  int            optvar;               // Index of optvar chain or -1
  ulong          nameaddr;             // NM_DEBUG address of var's name
} t_symvar;

typedef struct t_jdest {               // Element of jump data
  char           type;                 // Type of jump, one of JT_xxx
  ulong          from;                 // Jump source
  ulong          to;                   // Jump destination
} t_jdest;

typedef struct t_module {              // Executable module descriptor
  ulong          base;                 // Base address of module
  ulong          size;                 // Size occupied by module
  ulong          type;                 // Service information, TY_xxx
  ulong          codebase;             // Base address of module code block
  ulong          codesize;             // Size of module code block
  ulong          resbase;              // Base address of resources
  ulong          ressize;              // Size of resources
  t_stringtable  *stringtable;         // Pointers to string resources or NULL
  int            nstringtable;         // Actual number of used stringtable
  int            maxstringtable;       // Actual number of allocated stringtable
  ulong          entry;                // Address of <ModuleEntryPoint> or NULL
  ulong          database;             // Base address of module data block
  ulong          idatatable;           // Base address of import data table
  ulong          idatabase;            // Base address of import data block
  ulong          edatatable;           // Base address of export data table
  ulong          edatasize;            // Size of export data table
  ulong          reloctable;           // Base address of relocation table
  ulong          relocsize;            // Size of relocation table
  char           name[SHORTLEN];       // Short name of the module
  char           path[MAX_PATH];       // Full name of the module
  int            nsect;                // Number of sections in the module
  IMAGE_SECTION_HEADER *sect;          // Copy of section headers from file
  ulong          headersize;           // Total size of headers in executable
  ulong          fixupbase;            // Base of image in executable file
  int            nfixup;               // Number of fixups in executable
  t_fixup        *fixup;               // Extracted fixups or NULL
  char           *codedec;             // Decoded code features or NULL
  ulong          codecrc;              // Code CRC for actual decoding
  char           *hittrace;            // Hit tracing data or NULL
  char           *hittracecopy;        // Copy of INT3-substituted code
  char           *datadec;             // Decoded data features or NULL
  t_table        namelist;             // List of module names
  t_symvar       *symvar;              // Descriptions of symbolic variables
  int            nsymvar;              // Actual number of elements in symvar
  int            maxsymvar;            // Maximal number of elements in symvar
  char           *globaltypes;         // Global types from debug info
  ulong          mainentry;            // Address of WinMain() etc. in dbg data
  ulong          realsfxentry;         // Entry of packed code or NULL
  int            updatenamelist;       // Request to update namelist
  ulong          origcodesize;         // Original size of module code block
  ulong          sfxbase;              // Base of memory block with SFX
  ulong          sfxsize;              // Size of memory block with SFX
  int            issystemdll;          // Whether system DLL
  int            processed;            // 0: not processed, 1: good, -1: bad
  int            dbghelpsym;           // 1: symbols loaded by dbghelp.dll
  char           version[NVERS];       // Version of executable file
  t_jdest        *jddata;              // Recognized jumps within the module
  int            njddata;              // Number of recognized jumps
  ulong          reserved[15];         // Reserved for plugin compatibility
} t_module;

extc t_module* cdecl Findmodule(ulong addr);
extc t_fixup* cdecl Findfixup(t_module *pmod,ulong addr);
extc uchar*  cdecl Finddecode(ulong addr,ulong *psize);
extc ulong   cdecl Findfileoffset(t_module *pmod,ulong addr);
extc int     cdecl Decoderange(ulong addr,ulong size,char *s);
extc int     cdecl Analysecode(t_module *pm);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// DUMP /////////////////////////////////////

// Standard dump types.
#define DU_ESCAPABLE   0x20000L        // Create escapable dump window
#define DU_BACKUP      0x10000L        // Bit indicates that backup is displayed
#define DU_TYPE        0x0F000L        // Mask for dump type
#define DU_COUNT       0x00FF0L        // Mask for number of items/line
#define DU_SIZE        0x0000FL        // Mask for size of single item

#define DU_UNDEF       0x00000L        // Undefined dump type
#define DU_HEXTEXT     0x01000L        // Hexadecimal dump with ASCII text
#define DU_TEXT        0x02000L        // Character dump
#define DU_UNICODE     0x03000L        // Unicode dump
#define DU_INT         0x04000L        // Integer signed dump
#define DU_UINT        0x05000L        // Integer unsigned dump
#define DU_IHEX        0x06000L        // Integer hexadecimal dump
#define DU_FLOAT       0x07000L        // Floating-point dump
#define DU_ADDR        0x08000L        // Address dump
#define DU_DISASM      0x09000L        // Disassembly
#define DU_HEXUNI      0x0A000L        // Hexadecimal dump with UNICODE text
#define DU_ADRASC      0x0B000L        // Address dump with ASCII text
#define DU_ADRUNI      0x0C000L        // Address dump with UNICODE text
#define DU_SPEC        0x0D000L        // Special decoding

// Standard menu types.
#define MT_BACKUP      0x0001          // Backup, Undo
#define MT_COPY        0x0002          // Copy to clipboard
#define MT_EDIT        0x0004          // Edit, Modify, Assemble
#define MT_SEARCH      0x0008          // Search, Next
#define MT_DHISTORY    0x0010          // Previous, Next in history

typedef ulong SPECFUNC(char *,ulong,ulong,ulong,t_disasm *,int);

typedef struct t_dump {                // Current status of dump window
  t_table        table;                // Treat dump window as custom table
  int            dimmed;               // Draw in lowcolor if nonzero
  ulong          threadid;             // Use decoding and registers if not 0
  int            dumptype;             // Current dump type, DU_xxx+count+size
  SPECFUNC       *specdump;            // Decoder of DU_SPEC dump types
  int            menutype;             // Standard menues, MT_xxx
  int            itemwidth;            // Length of displayed item, characters
  int            showstackframes;      // Show stack frames in address dump
  int            showstacklocals;      // Show names of locals in stack
  int            commentmode;          // 0: comment, 1: source, 2: profile
  char           filename[MAX_PATH];   // Name of displayed or backup file
  ulong          base;                 // Start of memory block or file
  ulong          size;                 // Size of memory block or file
  ulong          addr;                 // Address of first displayed byte
  ulong          lastaddr;             // Address of last displayed byte + 1
  ulong          sel0;                 // Address of first selected byte
  ulong          sel1;                 // Last selected byte (not included!)
  ulong          startsel;             // Start of last selection
  int            captured;             // Mouse is captured by dump
  ulong          reladdr;              // Addresses relative to this
  char           relname[SHORTLEN];    // Symbol for relative zero address base
  uchar          *filecopy;            // Copy of the file or NULL
  uchar          *backup;              // Old backup of memory/file or NULL
  int            runtraceoffset;       // Offset back in run trace
  ulong          reserved[8];          // Reserved for the future extentions
} t_dump;

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// WINDOW FUNCTIONS ///////////////////////////////

#define WM_USER_MENU   (WM_USER+101)   // Activate context-sensitive menu
#define WM_USER_SCR    (WM_USER+102)   // Redraw scroll(s)
#define WM_USER_SAVE   (WM_USER+103)   // Save data to disk
#define WM_USER_VABS   (WM_USER+104)   // Scroll contents of window by lines
#define WM_USER_VREL   (WM_USER+105)   // Scroll contents of window by percent
#define WM_USER_VBYTE  (WM_USER+106)   // Scroll contents of window by bytes
#define WM_USER_STS    (WM_USER+107)   // Start selection in window
#define WM_USER_CNTS   (WM_USER+108)   // Continue selection in window
#define WM_USER_CHGS   (WM_USER+109)   // Move single-line selection
#define WM_USER_BAR    (WM_USER+110)   // Message from bar segment as button
#define WM_USER_DBLCLK (WM_USER+111)   // Doubleclick in column
#define WM_USER_SIZE   (WM_USER+112)   // Resize children in CPU window
#define WM_USER_FOCUS  (WM_USER+113)   // Set focus to child of CPU window
#define WM_USER_FILE   (WM_USER+114)   // Change state of file dump
#define WM_USER_HERE   (WM_USER+115)   // Query presence list
#define WM_USER_CHALL  (WM_USER+116)   // Redraw (almost) everything
#define WM_USER_CHMEM  (WM_USER+117)   // Range of debuggee's memory changed
#define WM_USER_CHREG  (WM_USER+118)   // Debuggee's register(s) changed
#define WM_USER_CHNAM  (WM_USER+119)   // Redraw name tables
#define WM_USER_MOUSE  (WM_USER+120)   // Check mouse coordinates
#define WM_USER_KEY    (WM_USER+121)   // Emulate WM_KEYDOWN
#define WM_USER_SYSKEY (WM_USER+122)   // Emulate WM_SYSKEYDOWN

// Constants used for scrolling and selection.
#define MAXTRACK       16384           // Maximal scroll of user-drawn table
#define MOVETOP        0x7FFFFFFFL     // Move selection to top of table
#define MOVEBOTTOM     0x7FFFFFFEL     // Move selection to bottom of table

#define CONT_BROADCAST 0x0000          // Continue sending msg to other windows
#define STOP_BROADCAST 0x1234          // Stop sending message to other windows

// Dumpbackup() actions.
#define BKUP_CREATE    1               // Create or update backup copy
#define BKUP_VIEWDATA  2               // View original data
#define BKUP_VIEWCOPY  3               // View backup copy
#define BKUP_LOADCOPY  4               // Read backup copy from file
#define BKUP_SAVEDATA  5               // Save original data to file
#define BKUP_SAVECOPY  6               // Save backup copy to file
#define BKUP_DELETE    7               // Delete backup copy

extc int     cdecl Registerotclass(char *classname,
               char *iconname,WNDPROC classproc);
extc HWND    cdecl Newtablewindow(t_table *pt,int nlines,int maxcolumns,
               char *winclass,char *wintitle);
extc HWND    cdecl Quicktablewindow(t_table *pt,int nlines,int maxcolumns,
               char *winclass,char *wintitle);
extc HWND    cdecl Createdumpwindow(char *name,ulong base,ulong size,
               ulong addr,int type,SPECFUNC *specdump);
extc void    cdecl Setdumptype(t_dump *pd,int dumptype);
extc void    cdecl Dumpbackup(t_dump *pd,int action);
extc int     cdecl Broadcast(UINT msg,WPARAM wp,LPARAM lp);

////////////////////////////////////////////////////////////////////////////////
////////////////////////// DATA CONVERSION FUNCTIONS ///////////////////////////

extc ulong   cdecl Compress(uchar *bufin,ulong nbufin,
               uchar *bufout,ulong nbufout);
extc ulong   cdecl Getoriginaldatasize(char *bufin,ulong nbufin);
extc ulong   cdecl Decompress(uchar *bufin,ulong nbufin,
               uchar *bufout,ulong nbufout);
extc ulong   cdecl Calculatecrc(uchar *copy,ulong base,ulong size,
               t_module *pmod,ulong fixupoffset);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// REFERENCES AND SEARCH /////////////////////////////

typedef struct t_ref {                 // Description of reference
  ulong          addr;                 // Address of reference
  ulong          size;                 // 1: single command, otherwise size
  ulong          type;                 // Type of reference, TY_xxx
  ulong          dest;                 // Destination of call
} t_ref;

extc int     cdecl Findreferences(ulong base,ulong size,ulong addr0,ulong addr1,
               ulong origin,int recurseonjump,char *title);
extc int     cdecl Findstrings(ulong base,ulong size,ulong origin,char *title);
extc int     cdecl Findalldllcalls(t_dump *pd,ulong origin,char *title);
extc int     cdecl Findallcommands(t_dump *pd,t_asmmodel *model,
               ulong origin,char *title);
extc int     cdecl Findallsequences(t_dump *pd,t_extmodel model[NSEQ][NMODELS],
               ulong origin,char *title);
extc ulong   cdecl Walkreference(int dir);
extc ulong   cdecl Walkreferenceex(int dir,ulong *size);

////////////////////////////////////////////////////////////////////////////////
//////////////////////// BREAKPOINT AND TRACE FUNCTIONS ////////////////////////

#define MEMBP_READ     0x0001          // Memory breakpoint on read
#define MEMBP_WRITE    0x0002          // Memory breakpoint on write
#define MEMBP_SFX      0x1000          // Skip self-extraction

// Bits of module hit trace buffer.
#define TR_HIT         0x01            // Command was executed during trace
#define TR_SET         0x02            // Code INT3 is in memory, copy valid
#define TR_RTSKIP      0x20            // Disable run trace on command
#define TR_RTRACE      0x40            // Force run trace on command
#define TR_TRACE       0x80            // Command is included in trace

#define HB_FREE        0               // Breakpoint is not used
#define HB_CODE        1               // Active on command execution
#define HB_ACCESS      2               // Active on read/write access
#define HB_WRITE       3               // Active on write access
#define HB_IO          4               // Active on port I/O
#define HB_ONESHOT     5               // One-shot on command execution
#define HB_STOPAN      6               // One-shot on command and stop
#define HB_TEMP        7               // Temporary on command execution

// Parameter mode of function Modifyhittrace().
#define ATR_ADD        1               // Add trace to buffer
#define ATR_ADDPROC    2               // Add only recognized procedures
#define ATR_RESET      3               // Mark range as not traced
#define ATR_REMOVE     4               // Remove range and breakpoints
#define ATR_REMOVEALL  5               // Destroy range and breakpoints
#define ATR_RESTORE    6               // Restore breakpoints
#define ATR_RTRADD     7               // Add trace and force run trace
#define ATR_RTRJUMPS   8               // Add trace and run trace jumps only
#define ATR_RTRENTRY   9               // Add trace and run trace entries only
#define ATR_RTREMOVE   10              // Remove trace from range
#define ATR_RTSKIP     11              // Skip when run tracing

// Breakpoint conditions (first byte of NM_BREAKEXPR associated with
// breakpoint). Strange settings of bits COND_NOBREAK and COND_BRKALWAYS are
// for backward compatibility with version 1.0. If both bits are 0, program
// pauses when condition is met. If both bits are set, COND_NOBREAK has higher
// priority.
#define COND_NOBREAK   0x01            // Don't break on this breakpoint
#define COND_LOGTRUE   0x02            // Log expression if condition true
#define COND_LOGALWAYS 0x04            // Log expression each pass
#define COND_ARGTRUE   0x08            // Log arguments if condition true
#define COND_ARGALWAYS 0x10            // Log arguments each pass
#define COND_BRKALWAYS 0x20            // Always break on this breakpoint
#define COND_MASK      0x3F            // Mask for conditional break type bits
#define COND_FILLING   0x40            // Used to assure that byte is non-zero

typedef struct t_bpoint {              // Description of INT3 breakpoint
  ulong          addr;                 // Address of breakpoint
  ulong          dummy;                // Always 1
  ulong          type;                 // Type of breakpoint, TY_xxx
  char           cmd;                  // Old value of command
  ulong          passcount;            // Actual pass count
} t_bpoint;

typedef struct t_hardbpoint {          // Description of hardware breakpoint
  ulong          addr;                 // Base address of hardware breakpoint
  int            size;                 // Size of hardware breakpoint
  int            type;                 // Type of breakpoint, one of HB_xxx
  ulong          reserved[4];          // Reserved for the future
} t_hardbpoint;

extc int     cdecl Setbreakpoint(ulong addr,ulong type,uchar cmd);
extc int     cdecl Setbreakpointext(ulong addr,ulong type,char cmd,
               ulong passcount);
extc int     cdecl Manualbreakpoint(ulong addr,
               int key,int shiftkey,ulong nametype,int font);
extc void    cdecl Deletebreakpoints(ulong addr0,ulong addr1,int silent);
extc ulong   cdecl Getbreakpointtype(ulong addr);
extc ulong   cdecl Getbreakpointtypecount(ulong addr,ulong *passcount);
extc ulong   cdecl Getnextbreakpoint(ulong addr,ulong *type,int *cmd);
extc void    cdecl Tempbreakpoint(ulong addr,int mode);
extc int     cdecl Hardbreakpoints(int closeondelete);
extc int     cdecl Sethardwarebreakpoint(ulong addr,int size,int type);
extc int     cdecl Deletehardwarebreakpoint(int index);
extc int     cdecl Deletehardwarebreakbyaddr(ulong addr);
extc int     cdecl Setmembreakpoint(int type,ulong addr,ulong size);
extc uchar*  cdecl Findhittrace(ulong addr,uchar **ptracecopy,ulong *psize);
extc int     cdecl Modifyhittrace(ulong addr0,ulong addr1,int mode);
extc ulong   cdecl Isretaddr(ulong retaddr,ulong *procaddr);
extc HWND    cdecl Creatertracewindow(void);
extc void    cdecl Settracecondition(char *cond,int onsuspicious,
               ulong in0,ulong in1,ulong out0,ulong out1);
extc void    cdecl Settracecount(ulong count);
extc void    cdecl Settracepauseoncommands(char *cmdset);
extc int     cdecl Startruntrace(t_reg *preg);
extc void    cdecl Deleteruntrace(void);
extc int     cdecl Runtracesize(void);
extc int     cdecl Findprevruntraceip(ulong ip,int startback);
extc int     cdecl Findnextruntraceip(ulong ip,int startback);
extc int     cdecl Getruntraceregisters(int nback,t_reg *preg,
               t_reg *pold,char *cmd,char *comment);
extc int     cdecl Getruntraceprofile(ulong addr,ulong size,ulong *profile);
extc void    cdecl Scrollruntracewindow(int back);
extc HWND    cdecl Createprofilewindow(ulong base,ulong size);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// CODE INJECTION ////////////////////////////////

typedef int INJECTANSWER(char *data,ulong datasize,ulong parm2);

typedef struct t_inject {              // Description of injected code
  ulong          codesize;             // Size of code, including INT3
  char           *code;                // Pointer to code
  int            stacksize;            // Stack size to save
  int            datatype;             // 0: in/out, 1: in, 2: out
} t_inject;

extc int     cdecl Injectcode(ulong threadid,t_inject *inject,char *data,
               ulong datasize,ulong parm1,ulong parm2,
               INJECTANSWER *answerfunc);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// CPU-SPECIFIC FUNCTIONS ////////////////////////////

// Setcpu modes.
#define CPU_ASMHIST    0x00001         // Add change to Disassembler history
#define CPU_ASMCENTER  0x00004         // Make address in the middle of window
#define CPU_ASMFOCUS   0x00008         // Move focus to Disassembler
#define CPU_DUMPHIST   0x00010         // Add change to Dump history
#define CPU_DUMPFIRST  0x00020         // Make address the first byte in Dump
#define CPU_DUMPFOCUS  0x00080         // Move focus to Dump
#define CPU_REGAUTO    0x00100         // Automatically switch to FPU/MMX/3DNow!
#define CPU_RUNTRACE   0x00200         // Show run trace data at offset asmaddr
#define CPU_STACKFOCUS 0x00800         // Move focus to Stack
#define CPU_NOCREATE   0x04000         // Don't create CPU window if absent
#define CPU_REDRAW     0x08000         // Redraw CPU window immediately
#define CPU_NOFOCUS    0x10000         // Don't assign focus to main window

extc void    cdecl Setcpu(ulong threadid,ulong asmaddr,
               ulong dumpaddr,ulong stackaddr,int mode);
extc void    cdecl Setdisasm(ulong asmaddr,ulong selsize,int mode);
extc void    cdecl Redrawdisassembler(void);
extc void    cdecl Getdisassemblerrange(ulong *pbase,ulong *psize);
extc ulong   cdecl Findprocbegin(ulong addr);
extc ulong   cdecl Findprocend(ulong addr);
extc ulong   cdecl Findprevproc(ulong addr);
extc ulong   cdecl Findnextproc(ulong addr);
extc int     cdecl Getproclimits(ulong addr,ulong *start,ulong *end);
extc void    cdecl Sendshortcut(int where,ulong addr,
               int msg,int ctrl,int shift,int vkcode);

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// PROCESS CONTROL ////////////////////////////////

// Parameter stepmode in call to Go().
#define STEP_SAME      0               // Same action as on previous call
#define STEP_RUN       1               // Run program
#define STEP_OVER      2               // Step over
#define STEP_IN        3               // Step in
#define STEP_SKIP      4               // Skip sequence

typedef enum t_status {                // Thread/process status
  STAT_NONE=0,                         // Thread/process is empty
  STAT_STOPPED,                        // Thread/process suspended
  STAT_EVENT,                          // Processing debug event, process paused
  STAT_RUNNING,                        // Thread/process running
  STAT_FINISHED,                       // Process finished
  STAT_CLOSING                         // Process is requested to terminate
} t_status;

extc t_status cdecl Getstatus(void);
extc int     cdecl Go(ulong threadid,ulong tilladdr,int stepmode,
               int givechance,int backupregs);
extc int     cdecl Suspendprocess(int processevents);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DECODING OF ARGUMENTS /////////////////////////////

#define DASC_TEST      0               // Test whether a string
#define DASC_NOHEX     1               // Test, print nothing if not a string
#define DASC_ASCII     2               // Force ASCII
#define DASC_PASCAL    3               // Force Pascal

extc uchar*  cdecl Findknownfunction(ulong addr,int direct,
               int level,char *fname);
extc int     cdecl Decodeknownargument(ulong addr,uchar *arg,ulong value,
               int valid,char *s,char *mask,uchar *pset[]);
extc char    cdecl *Findunknownfunction(ulong ip,char *code,char *dec,
               ulong size,char *fname);
extc int     cdecl Decodeascii(ulong value,char *s,int len,int mode);
extc int     cdecl Decodeunicode(ulong value,char *s,int len);

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// SOURCE CODE SUPPORT //////////////////////////////

#define FIRST_CODE_LINE 0xFFFFFFFF     // First available source line

typedef struct t_sourceline {          // Source line descriptor
  ulong          addr;                 // Start address of corresponding code
  ulong          size;                 // Code size
  ulong          srcname;              // Index of source name (as NM_DEBUG)
  ulong          line;                 // 0-based line number
} t_sourceline;

extc HWND    cdecl Showsourcefromaddress(ulong addr,int show);
extc int     cdecl Getresourcestring(t_module *pm,ulong id,char *s);
extc t_sourceline* cdecl Getlinefromaddress(ulong addr);
extc ulong   cdecl Getaddressfromline(ulong addr0,ulong addr1,
               char *path,ulong line);
extc int     cdecl Getsourcefilelimits(ulong nameaddr,
               ulong *addr0,ulong *addr1);
extc int     cdecl Decodefullvarname(t_module *pmod,t_symvar *psym,
               int offset,char *name);
extc int     cdecl Getbprelname(t_module *pmod,ulong addr,long offset,
               char *s,int nsymb);

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// WATCH SUPPORT /////////////////////////////////

extc HWND    cdecl Createwatchwindow(void);
extc int     cdecl Deletewatch(int indexone);
extc int     cdecl Insertwatch(int indexone,char *text);
extc int     cdecl Getwatch(int indexone,char *text);

////////////////////////////////////////////////////////////////////////////////
////////////////////////// WINDOWS-SPECIFIC FUNCTIONS //////////////////////////

#define MAXNEST        32              // Max allowed code structure nesting

typedef struct t_window {              // Description of window
  ulong          hwnd;                 // Window's handle
  ulong          dummy;                // Must be 1
  ulong          type;                 // Type of window, TY_xxx
  ulong          parenthw;             // Handle of parent or 0
  ulong          winproc;              // Address of WinProc or 0
  ulong          threadid;             // ID of the owning thread
  ulong          exstyle;              // Extended style
  ulong          style;                // Style
  ulong          id;                   // Identifier
  ulong          classproc;            // Address of default (class) WinProc
  int            child;                // Index of next child
  int            level;                // Level in genealogy (0: topmost)
  int            sibling;              // Index of next sibling
  int            byparent;             // Index when sorted by parent
  char           title[TEXTLEN];       // Window's title
  char           classname[TEXTLEN];   // Class name
  char           tree[MAXNEST];        // Tree display
} t_window;

extc HWND    cdecl Createwinwindow(void);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// PATCHES ////////////////////////////////////

typedef struct t_patch {
  ulong          addr;                 // Base address of patch in memory
  ulong          size;                 // Size of patch, bytes
  ulong          type;                 // Type of patch, set of TY_xxx
  char           orig[TEXTLEN];        // Original code
  char           mod[TEXTLEN];         // Patched code
} t_patch;

extc HWND    cdecl Createpatchwindow(void);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// PLUGIN-SPECIFIC FUNCTIONS ///////////////////////////

// Parameters of Plugingetvalue().
#define VAL_HINST              1       // Current program instance
#define VAL_HWMAIN             2       // Handle of the main window
#define VAL_HWCLIENT           3       // Handle of the MDI client window
#define VAL_NCOLORS            4       // Number of common colors
#define VAL_COLORS             5       // RGB values of common colors
#define VAL_BRUSHES            6       // Handles of common color brushes
#define VAL_PENS               7       // Handles of common color pens
#define VAL_NFONTS             8       // Number of common fonts
#define VAL_FONTS              9       // Handles of common fonts
#define VAL_FONTNAMES          10      // Internal font names
#define VAL_FONTWIDTHS         11      // Average widths of common fonts
#define VAL_FONTHEIGHTS        12      // Average heigths of common fonts
#define VAL_NFIXFONTS          13      // Actual number of fixed-pitch fonts
#define VAL_DEFFONT            14      // Index of default font
#define VAL_NSCHEMES           15      // Number of color schemes
#define VAL_SCHEMES            16      // Color schemes
#define VAL_DEFSCHEME          17      // Index of default colour scheme
#define VAL_DEFHSCROLL         18      // Default horizontal scroll
#define VAL_RESTOREWINDOWPOS   19      // Restore window positions from .ini
#define VAL_HPROCESS           20      // Handle of Debuggee
#define VAL_PROCESSID          21      // Process ID of Debuggee
#define VAL_HMAINTHREAD        22      // Handle of main thread
#define VAL_MAINTHREADID       23      // Thread ID of main thread
#define VAL_MAINBASE           24      // Base of main module in the process
#define VAL_PROCESSNAME        25      // Name of the active process
#define VAL_EXEFILENAME        26      // Name of the main debugged file
#define VAL_CURRENTDIR         27      // Current directory for debugged process
#define VAL_SYSTEMDIR          28      // Windows system directory
#define VAL_DECODEANYIP        29      // Decode registers dependless on EIP
#define VAL_PASCALSTRINGS      30      // Decode Pascal-style string constants
#define VAL_ONLYASCII          31      // Only printable ASCII chars in dump
#define VAL_DIACRITICALS       32      // Allow diacritical symbols in strings
#define VAL_GLOBALSEARCH       33      // Search from the beginning of block
#define VAL_ALIGNEDSEARCH      34      // Search aligned to item's size
#define VAL_IGNORECASE         35      // Ignore case in string search
#define VAL_SEARCHMARGIN       36      // Floating search allows error margin
#define VAL_KEEPSELSIZE        37      // Keep size of hex edit selection
#define VAL_MMXDISPLAY         38      // MMX display mode in dialog
#define VAL_WINDOWFONT         39      // Use calling window's font in dialog
#define VAL_TABSTOPS           40      // Distance between tab stops
#define VAL_MODULES            41      // Table of modules (.EXE and .DLL)
#define VAL_MEMORY             42      // Table of allocated memory blocks
#define VAL_THREADS            43      // Table of active threads
#define VAL_BREAKPOINTS        44      // Table of active breakpoints
#define VAL_REFERENCES         45      // Table with found references
#define VAL_SOURCELIST         46      // Table of source files
#define VAL_WATCHES            47      // Table of watches
#define VAL_CPUFEATURES        50      // CPU feature bits
#define VAL_TRACEFILE          51      // Handle of run trace log file
#define VAL_ALIGNDIALOGS       52      // Whether to align dialogs
#define VAL_CPUDASM            53      // Dump descriptor of CPU Disassembler
#define VAL_CPUDDUMP           54      // Dump descriptor of CPU Dump
#define VAL_CPUDSTACK          55      // Dump descriptor of CPU Stack
#define VAL_APIHELP            56      // Name of selected API help file
#define VAL_HARDBP             57      // Whether hardware breakpoints enabled
#define VAL_PATCHES            58      // Table of patches
#define VAL_HINTS              59      // Sorted data with analysis hints

extc int     cdecl Registerpluginclass(char *classname,char *iconname,
               HINSTANCE dllinst,WNDPROC classproc);
extc void    cdecl Unregisterpluginclass(char *classname);
extc int     cdecl Pluginwriteinttoini(HINSTANCE dllinst,char *key,int value);
extc int     cdecl Pluginwritestringtoini(HINSTANCE dllinst,char *key,char *s);
extc int     cdecl Pluginreadintfromini(HINSTANCE dllinst,char *key,int def);
extc int     cdecl Pluginreadstringfromini(HINSTANCE dllinst,char *key,
               char *s,char *def);
extc int     cdecl Pluginsaverecord(ulong tag,ulong size,void *data);
extc int     cdecl Plugingetvalue(int type);

////////////////////////////////////////////////////////////////////////////////
////////////////////// EXPORTED PLUGIN CALLBACK FUNCTIONS //////////////////////

// Origins of standard OllyDbg windows as passed to plugin. In parenthesis is
// the type of item you get in ODBG_Pluginmenu(), ODBG_Pluginaction() and
// ODBG_Pluginshortcut(). Note that this item can be NULL!
#define PM_MAIN        0               // Main window        (NULL)
#define PM_DUMP        10              // Any Dump window    (t_dump*)
#define PM_MODULES     11              // Modules window     (t_module*)
#define PM_MEMORY      12              // Memory window      (t_memory*)
#define PM_THREADS     13              // Threads window     (t_thread*)
#define PM_BREAKPOINTS 14              // Breakpoints window (t_bpoint*)
#define PM_REFERENCES  15              // References window  (t_ref*)
#define PM_RTRACE      16              // Run trace window   (int*)
#define PM_WATCHES     17              // Watches window     (1-based index)
#define PM_WINDOWS     18              // Windows window     (t_window*)
#define PM_DISASM      31              // CPU Disassembler   (t_dump*)
#define PM_CPUDUMP     32              // CPU Dump           (t_dump*)
#define PM_CPUSTACK    33              // CPU Stack          (t_dump*)
#define PM_CPUREGS     34              // CPU Registers      (t_reg*)

// Reasons why debugged application was paused, as a first argument in call to
// ODBG_Paused(), ODBG_Pausedex() and ODBG_Plugincmd().
#define PP_MAIN                0x0003  // Mask to extract main reason
#define   PP_EVENT             0x0000  // Paused on debugging event
#define   PP_PAUSE             0x0001  // Paused on user's request
#define   PP_TERMINATED        0x0002  // Application terminated
// Extended reasons in ODBG_Pausedex().
#define PP_BYPROGRAM           0x0004  // Debugging event caused by program
#define PP_INT3BREAK           0x0010  // INT3 breakpoint
#define PP_MEMBREAK            0x0020  // Memory breakpoint
#define PP_HWBREAK             0x0040  // Hardware breakpoint
#define PP_SINGLESTEP          0x0080  // Single-step trap
#define PP_EXCEPTION           0x0100  // Exception, like division by 0
#define PP_ACCESS              0x0200  // Access violation
#define PP_GUARDED             0x0400  // Guarded page

// Record tags in .udd files.
#define MI_SIGNATURE   0x00646F4DL     // Module info signature
#define MI_VERSION     0x7265560AL     // OllyDbg version
#define MI_FILENAME    0x6C69460AL     // Record with full name of executable
#define MI_FILESIZE    0x7A69530AL     // Record with file size
#define MI_TIMESTAMP   0x7473540AL     // Record with timestamp file data
#define MI_SFXENTRY    0x6566530AL     // Real entry of SFX-able module
#define MI_PATCH       0x7461500AL     // Record with patch data
#define MI_USER        0x0073550AL     // Record with user-defined label/comment
#define MI_PROCDATA    0x6372500AL     // Record with procedure data
#define MI_SWDATA      0x6977530AL     // Record with switch data
#define MI_CALLFINT    0x6966430AL     // Record with internal call
#define MI_CALLFMOD    0x6D66430AL     // Record with intermodular call
#define MI_CALLFABS    0x6166430AL     // Record with absolute call
#define MI_INT3BREAK   0x7470420AL     // Record with breakpoint data
#define MI_INT3BRKC    0x6370420AL     // Record with checked breakpoint data
#define MI_HDWRBREAK   0x7262480AL     // Record with hardware breakpoint data
#define MI_JDDATA      0x74644A0AL     // Record with all module jump data
#define MI_ANALYSIS    0x616E410AL     // Record with analysis data
#define MI_ANALPACK    0x636E410AL     // Record with compressed analysis data
#define MI_AHINT       0x7468410AL     // Record with analysis hint data
#define MI_TRACE       0x6172540AL     // Record with trace data
#define MI_TRACEPACK   0x6372540AL     // Record with compressed trace data
#define MI_CODECRC     0x7263430AL     // Record with CRC of code for analysis
#define MI_SAVEAREA    0x6176530AL     // Record with general-purpose save area
#define MI_END         0x646E450AL     // End of module info data
// Tags reserved for 3rd-party plugins.
#define MI_WINJUG      0x67754A0AL     // WindowJuggler by EsseEmme
#define MI_WINJU1      0x31754A0AL
#define MI_WINJU2      0x32754A0AL
#define MI_WINJU3      0x33754A0AL
#define MI_APPST       0x73614F0AL     // OllyAppStarter by Homunculus

// Prototypes for plugin callback functions.
extc int  _export cdecl ODBG_Plugindata(char shortname[32]);
extc int  _export cdecl ODBG_Plugininit(int ollydbgversion,HWND hw,
                        ulong *features);
extc void _export cdecl ODBG_Pluginmainloop(DEBUG_EVENT *debugevent);
extc void _export cdecl ODBG_Pluginsaveudd(t_module *pmod,int ismainmodule);
extc int  _export cdecl ODBG_Pluginuddrecord(t_module *pmod,int ismainmodule,
                        ulong tag,ulong size,void *data);
extc int  _export cdecl ODBG_Pluginmenu(int origin,char data[4096],void *item);
extc void _export cdecl ODBG_Pluginaction(int origin,int action,void *item);
extc int  _export cdecl ODBG_Pluginshortcut(
                        int origin,int ctrl,int alt,int shift,int key,
                        void *item);
extc void _export cdecl ODBG_Pluginreset(void);
extc int  _export cdecl ODBG_Pluginclose(void);
extc void _export cdecl ODBG_Plugindestroy(void);
extc int  _export cdecl ODBG_Paused(int reason,t_reg *reg);
extc int  _export cdecl ODBG_Pausedex(int reasonex,int dummy,t_reg *reg,
                        DEBUG_EVENT *debugevent);
extc int  _export cdecl ODBG_Plugincmd(int reason,t_reg *reg,char *cmd);

#ifdef _MSC_VER

  #pragma pack(pop)

#endif

#endif // _PLUGIN_OLLYDBG_H_



================================================
File: plugin_ollydbg2.h
================================================
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                        OLLYDBG 2 PLUGIN HEADER FILE                        //
//                                                                            //
//                                Version 2.01                                //
//                                                                            //
//               Written by Oleh Yuschuk (ollydbg@t-online.de)                //
//                                                                            //
//                          Internet: www.ollydbg.de                          //
//                                                                            //
// This code is distributed "as is", without warranty of any kind, expressed  //
// or implied, including, but not limited to warranty of fitness for any      //
// particular purpose. In no event will Oleh Yuschuk be liable to you for any //
// special, incidental, indirect, consequential or any other damages caused   //
// by the use, misuse, or the inability to use of this code, including any    //
// lost profits or lost savings, even if Oleh Yuschuk has been advised of the //
// possibility of such damages.                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef __ODBG_PLUGIN_H
#define __ODBG_PLUGIN_H

#define PLUGIN_VERSION 0x02010001      // Version 2.01.0001 of plugin interface


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// IMPORTANT INFORMATION /////////////////////////////

// 1. Plugins are UNICODE libraries!
// 2. Export all callback functions by name, NOT by ordinal!
// 3. Force byte alignment of OllyDbg structures!
// 4. Set default char type to unsigned!
// 5. Most API functions are NOT thread-safe!
// 6. Read documentation!

#if !defined(_UNICODE) && !defined(UNICODE)
  #error This version must be compiled with UNICODE on
#endif


////////////////////////////////////////////////////////////////////////////////
////////////// PREFERRED SETTINGS AND FIXES FOR BORLAND COMPILERS //////////////

#ifdef __BORLANDC__
  #pragma option -a1                   // Byte alignment
  #pragma option -K                    // Force unsigned characters!
  // Redefinition of MAKELONG removes nasty warning under Borland Builder 4.0:
  // boolean OR in one row with arithmetical shift.
  #undef  MAKELONG
  #define MAKELONG(lo,hi) ((LONG)(((WORD)(lo))|(((DWORD)((WORD)(hi)))<<16)))
#endif


////////////////////////////////////////////////////////////////////////////////
///////////// PREFERRED SETTINGS AND FIXES FOR MICROSOFT COMPILERS /////////////

// If you like Microsoft compiler, this will force byte alignment and verify
// that character is set to unsigned.
#ifdef _MSC_VER
  #pragma pack(push, 1)                // Force byte alignment of structures
  #ifndef _CHAR_UNSIGNED               // Verify that character is unsigned
    #error Please set default char type to unsigned (option /J)
  #endif
#endif


////////////////////////////////////////////////////////////////////////////////
//////////////////// PREFERRED SETTINGS AND FIXES FOR MINGW ////////////////////

#ifdef __MINGW32__
  #pragma pack(push, 1)                // Force byte alignment of structures
  #ifndef __CHAR_UNSIGNED__            // Verify that character is unsigned
    #error Please set default char type to unsigned (option -funsigned-char)
  #endif
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// GLOBAL DEFINITIONS //////////////////////////////

#ifndef _export
  #define _export      __declspec(dllexport)
#endif

#ifndef _import
  #define _import      __declspec(dllimport)
#endif

#ifndef _USERENTRY
  #define _USERENTRY   __cdecl
#endif

#define MAKEWP(lo,hi)  ((WPARAM)MAKELONG(lo,hi))
#define MAKELP(lo,hi)  ((LPARAM)MAKELONG(lo,hi))

#define LOINT(l)       ((signed short)((WORD)(l)))
#define HIINT(l)       ((signed short)(((DWORD)(l)>>16) & 0xFFFF))

#ifndef MAXPATH
  #define MAXPATH      MAX_PATH
#endif

#ifndef FIELD_OFFSET
  #define FIELD_OFFSET(type,field) ((LONG)&(((type *)0)->field))
#endif

#ifndef arraysize
  #define arraysize(x) (sizeof(x)/sizeof(x[0]))
#endif

#define TEXTLEN        256             // Max length of text string incl. '\0'
#define DATALEN        4096            // Max length of data record (max 65535)
#define ARGLEN         1024            // Max length of argument string
#define MAXMULTIPATH   8192            // Max length of multiple selection
#define SHORTNAME      32              // Max length of short or module name

typedef unsigned char  uchar;          // Unsigned character (byte)
typedef unsigned short ushort;         // Unsigned short
typedef unsigned int   uint;           // Unsigned integer
typedef unsigned long  ulong;          // Unsigned long

// Exports used by plugins are declared as stdapi if they use fixed number of
// arguments, and varapi if variable or if code is written in Assembler
// language (I use C calling conventions). OllyDbg variables are declared as
// oddata.

#ifdef __cplusplus
  #define extc         extern "C" _export
  #define stdapi(type) extern "C"               type __cdecl
  #define varapi(type) extern "C"               type __cdecl
  #define oddata(type) extern "C" const _import type
  #define pentry(type) extern "C" _export       type __cdecl
#else
  #define extc         extern     _export
  #define stdapi(type) extern                   type __cdecl
  #define varapi(type) extern                   type __cdecl
  #define oddata(type) extern     const _import type
  #define pentry(type) extern     _export       type __cdecl
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// FORWARD REFERENCES //////////////////////////////

struct t_table;                        // Forward reference
struct t_module;                       // Forward reference
struct t_dump;                         // Forward reference


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// SERVICE FUNCTIONS ///////////////////////////////

// Flags returned by functions Istext.../Israre...
#define PLAINASCII     0x01            // Plain ASCII character
#define DIACRITICAL    0x02            // Diacritical character
#define RAREASCII      0x10            // Rare ASCII character

// Flags used by Memalloc() and Virtalloc(). Note that Virtalloc() alwyas
// initializes memory to zero.
#define REPORT         0x0000          // Report memory allocation errors
#define SILENT         0x0001          // Don't report allocation errors
#define ZEROINIT       0x0002          // Initialize memory to 0

#define CONT_BROADCAST 0x0000          // Continue sending msg to MDI windows
#define STOP_BROADCAST 0x1234          // Stop sending message to MDI windows

// Symbol decoding mode, used by Decodethreadname(), Decodeaddress() and
// Decoderelativeoffset().
// Bits that determine when to decode and comment name at all.
#define DM_VALID       0x00000001      // Only decode if memory exists
#define DM_INMOD       0x00000002      // Only decode if in module
#define DM_SAMEMOD     0x00000004      // Only decode if in same module
#define DM_SYMBOL      0x00000008      // Only decode if direct symbolic name
#define DM_NONTRIVIAL  0x00000010      // Only decode if nontrivial form
// Bits that control name format.
#define DM_BINARY      0x00000100      // Don't use symbolic form
#define DM_DIFBIN      0x00000200      // No symbolic form if different module
#define DM_WIDEFORM    0x00000400      // Extended form (8 digits by hex)
#define DM_CAPITAL     0x00000800      // First letter in uppercase if possible
#define DM_OFFSET      0x00001000      // Add 'OFFSET' if data
#define DM_JUMPIMP     0x00002000      // Check if points to JMP to import
#define DM_DYNAMIC     0x00004000      // Check if points to JMP to DLL
#define DM_ORDINAL     0x00008000      // Add ordinal to thread's name
// Bits that control whether address is preceded with module name.
#define DM_NOMODNAME   0x00000000      // Never add module name
#define DM_DIFFMODNAME 0x00010000      // Add name only if different module
#define DM_MODNAME     0x00020000      // Always add module name
// Bits that control comments.
#define DM_STRING      0x00100000      // Check if pointer to ASCII or UNICODE
#define DM_STRPTR      0x00200000      // Check if points to pointer to text
#define DM_FOLLOW      0x00400000      // Check if follows to different symbol
#define DM_ENTRY       0x00800000      // Check if unnamed entry to subroutine
#define DM_EFORCE      0x01000000      // Check if named entry, too
#define DM_DIFFMOD     0x02000000      // Check if points to different module
#define DM_RELOFFS     0x04000000      // Check if points inside subroutine
#define DM_ANALYSED    0x08000000      // Check if points to decoded data

// Standard commenting mode. Note: DM_DIFFMOD and DM_RELOFFS are not included.
#define DM_COMMENT     (DM_STRING|DM_STRPTR|DM_FOLLOW|DM_ENTRY|DM_ANALYSED)

// Address decoding mode, used by Labeladdress().
#define ADDR_SYMMASK   0x00000003      // Mask to extract sym presentation mode
#define   ADDR_HEXSYM  0x00000000      // Hex, followed by symbolic name
#define   ADDR_SYMHEX  0x00000001      // Symbolic name, followed by hex
#define   ADDR_SINGLE  0x00000002      // Symbolic name, or hex if none
#define   ADDR_HEXONLY 0x00000003      // Only hexadecimal address
#define ADDR_MODNAME   0x00000004      // Add module name to symbol
#define ADDR_FORCEMOD  0x00000008      // (ADDR_SINGLE) Always add module name
#define ADDR_GRAYHEX   0x00000010      // Gray hex
#define ADDR_HILSYM    0x00000020      // Highlight symbolic name
#define ADDR_NODEFMEP  0x00000100      // Do not show <ModuleEntryPoint>
#define ADDR_BREAK     0x00000200      // Mark as unconditional breakpoint
#define ADDR_CONDBRK   0x00000400      // Mark as conditional breakpoint
#define ADDR_DISBRK    0x00000800      // Mark as disabled breakpoint
#define ADDR_EIP       0x00001000      // Mark as actual EIP
#define ADDR_CHECKEIP  0x00002000      // Mark as EIP if EIP of CPU thread
#define ADDR_SHOWNULL  0x00004000      // Display address 0

// Mode bits and return value of Browsefilename().
#define BRO_MODEMASK   0xF0000000      // Mask to extract browsing mode
#define   BRO_FILE     0x00000000      // Get file name
#define   BRO_EXE      0x10000000      // Get name of executable
#define   BRO_TEXT     0x20000000      // Get name of text log
#define   BRO_GROUP    0x30000000      // Get one or several obj or lib files
#define   BRO_MULTI    0x40000000      // Get one or several files
#define BRO_SAVE       0x08000000      // Get name in save mode
#define BRO_SINGLE     0x00800000      // Single file selected
#define BRO_MULTIPLE   0x00400000      // Multiple files selected
#define BRO_APPEND     0x00080000      // Append to existing file
#define BRO_ACTUAL     0x00040000      // Add actual contents
#define BRO_TABS       0x00020000      // Separate columns with tabs
#define BRO_GROUPMASK  0x000000FF      // Mask to extract groups
#define   BRO_GROUP1   0x00000001      // Belongs to group 1
#define   BRO_GROUP2   0x00000002      // Belongs to group 2
#define   BRO_GROUP3   0x00000004      // Belongs to group 3
#define   BRO_GROUP4   0x00000008      // Belongs to group 4

// String decoding modes.
#define DS_DIR         0               // Direct quote
#define DS_ASM         1               // Assembler style
#define DS_C           2               // C style

varapi (void)    Error(wchar_t *format,...);
varapi (void)    Conderror(int *cond,wchar_t *title,wchar_t *format,...);
varapi (int)     Condyesno(int *cond,wchar_t *title,wchar_t *format,...);
stdapi (int)     Stringfromini(wchar_t *section,wchar_t *key,wchar_t *s,
                   int length);
stdapi (int)     Filefromini(wchar_t *key,wchar_t *name,wchar_t *defname);
varapi (int)     Getfromini(wchar_t *file,wchar_t *section,wchar_t *key,
                   wchar_t *format,...);
varapi (int)     Writetoini(wchar_t *file,wchar_t *section,wchar_t *key,
                   wchar_t *format,...);
stdapi (int)     Filetoini(wchar_t *key,wchar_t *name);
stdapi (void)    Deleteinisection(wchar_t *file,wchar_t *section);
stdapi (int)     Getfromsettings(wchar_t *key,int defvalue);
stdapi (void)    Addtosettings(wchar_t *key,int value);
stdapi (void)    Replacegraphs(int mode,wchar_t *s,uchar *mask,
                   int select,int n);
stdapi (int)     Unicodetoascii(const wchar_t *w,int nw,char *s,int ns);
stdapi (int)     Asciitounicode(const char *s,int ns,wchar_t *w,int nw);
stdapi (int)     Unicodetoutf(const wchar_t *w,int nw,char *t,int nt);
stdapi (int)     Utftounicode(const char *t,int nt,wchar_t *w,int nw);
stdapi (HGLOBAL) Unicodebuffertoascii(HGLOBAL hunicode);
stdapi (int)     Iszero(void *data,int n);
stdapi (int)     Guidtotext(uchar *guid,wchar_t *s);
varapi (int)     Swprintf(wchar_t *s,wchar_t *format,...);
stdapi (void *)  Memalloc(ulong size,int flags);
stdapi (void)    Memfree(void *data);
stdapi (void *)  Mempurge(void *data,int count,ulong itemsize,int *newcount);
stdapi (void *)  Memdouble(void *data,int *pcount,ulong itemsize,
                   int *failed,int flags);
stdapi (void *)  Virtalloc(ulong size,int flags);
stdapi (void)    Virtfree(void *data);
stdapi (int)     Broadcast(UINT msg,WPARAM wp,LPARAM lp);
stdapi (int)     Browsefilename(wchar_t *title,wchar_t *name,wchar_t *args,
                   wchar_t *currdir,wchar_t *defext,HWND hwnd,int mode);
stdapi (int)     Browsedirectory(HWND hw,wchar_t *comment,wchar_t *dir);
stdapi (void)    Relativizepath(wchar_t *path);
stdapi (void)    Absolutizepath(wchar_t *path);
stdapi (int)     Confirmoverwrite(wchar_t *path);
stdapi (int)     Labeladdress(wchar_t *text,ulong addr,ulong reladdr,int relreg,
                   int index,uchar *mask,int *select,ulong mode);
stdapi (int)     Simpleaddress(wchar_t *text,ulong addr,
                   uchar *mask,int *select);
stdapi (void)    Heapsort(void *data,const int count,const int size,
                   int (_USERENTRY *compare)(const void *,const void *));
stdapi (void)    Heapsortex(void *data,const int count,const int size,
                   int (_USERENTRY *compareex)(const void *,const void *,ulong),
                   ulong lp);
stdapi (uchar *) Readfile(wchar_t *path,ulong fixsize,ulong *psize);
stdapi (int)     Devicenametodosname(wchar_t *devname,wchar_t *dosname);
stdapi (int)     Filenamefromhandle(HANDLE hfile,wchar_t *path);
stdapi (void)    Quicktimerstart(int timer);
stdapi (void)    Quicktimerstop(int timer);
stdapi (void)    Quicktimerflush(int timer);


////////////////////////////////////////////////////////////////////////////////
////////////////// FAST SERVICE ROUTINES WRITTEN IN ASSEMBLER //////////////////

varapi (int)     StrcopyA(char *dest,int n,const char *src);
varapi (int)     StrcopyW(wchar_t *dest,int n,const wchar_t *src);
varapi (int)     StrlenA(const char *src,int n);
varapi (int)     StrlenW(const wchar_t *src,int n);
varapi (int)     HexprintA(char *s,ulong u);
varapi (int)     HexprintW(wchar_t *s,ulong u);
varapi (int)     Hexprint4A(char *s,ulong u);
varapi (int)     Hexprint4W(wchar_t *s,ulong u);
varapi (int)     Hexprint8A(char *s,ulong u);
varapi (int)     Hexprint8W(wchar_t *s,ulong u);
varapi (int)     SignedhexA(char *s,ulong u);
varapi (int)     SignedhexW(wchar_t *s,ulong u);
varapi (void)    Swapmem(void *base,int size,int i1,int i2);
varapi (int)     HexdumpA(char *s,uchar *code,int n);
varapi (int)     HexdumpW(wchar_t *s,uchar *code,int n);
varapi (int)     Bitcount(ulong u);

varapi (char *)  SetcaseA(char *s);
varapi (wchar_t *) SetcaseW(wchar_t *s);
varapi (int)     StrcopycaseA(char *dest,int n,const char *src);
varapi (int)     StrcopycaseW(wchar_t *dest,int n,const wchar_t *src);
varapi (int)     StrnstrA(char *data,int ndata,
                   char *pat,int npat,int ignorecase);
varapi (int)     StrnstrW(wchar_t *data,int ndata,
                   wchar_t *pat,int npat,int ignorecase);
varapi (int)     StrcmpW(const wchar_t *s1,const wchar_t *s2);
varapi (ulong)   Div64by32(ulong low,ulong hi,ulong div);
varapi (ulong)   CRCcalc(uchar *datacopy,ulong datasize);
varapi (int)     Getcpuidfeatures(void);
varapi (void)    Maskfpu(void);
varapi (void)    Clearfpu(void);


////////////////////////////////////////////////////////////////////////////////
////////////////////// DATA COMPRESSION AND DECOMPRESSION //////////////////////

stdapi (ulong)   Compress(uchar *bufin,ulong nbufin,
                   uchar *bufout,ulong nbufout);
stdapi (ulong)   Getoriginaldatasize(uchar *bufin,ulong nbufin);
stdapi (ulong)   Decompress(uchar *bufin,ulong nbufin,
                   uchar *bufout,ulong nbufout);


////////////////////////////////////////////////////////////////////////////////
/////////////////////// TAGGED DATA FILES AND RESOURCES ////////////////////////

#define MI_SIGNATURE   0x00646F4DL     // Signature of tagged file
#define MI_VERSION     0x7265560AL     // File version
#define MI_FILENAME    0x6C69460AL     // Record with full name of executable
#define MI_FILEINFO    0x7263460AL     // Length, date, CRC (t_fileinfo)
#define MI_DATA        0x7461440AL     // Name or data (t_nameinfo)
#define MI_CALLBRA     0x7262430AL     // Call brackets
#define MI_LOOPBRA     0x72624C0AL     // Loop brackets
#define MI_PROCDATA    0x6372500AL     // Procedure data (set of t_procdata)
#define MI_INT3BREAK   0x336E490AL     // INT3 breakpoint (t_bpoint)
#define MI_MEMBREAK    0x6D70420AL     // Memory breakpoint (t_bpmem)
#define MI_HWBREAK     0x6870420AL     // Hardware breakpoint (t_bphard)
#define MI_ANALYSIS    0x616E410AL     // Record with analysis data
#define MI_SWITCH      0x6977530AL     // Switch (addr+dt_switch)
#define MI_CASE        0x7361430AL     // Case (addr+dt_case)
#define MI_MNEMO       0x656E4D0AL     // Decoding of mnemonics (addr+dt_mnemo)
#define MI_JMPDATA     0x74644A0AL     // Jump data
#define MI_NETSTREAM   0x74734E0AL     // .NET streams (t_netstream)
#define MI_METADATA    0x74644D0AL     // .NET MetaData tables (t_metadata)
#define MI_BINSAV      0x7673420AL     // Last entered binary search patterns
#define MI_MODDATA     0x61624D0AL     // Module base, size and path
#define MI_PREDICT     0x6472500AL     // Predicted command execution results
#define MI_LASTSAV     0x61734C0AL     // Last entered strings (t_nameinfo)
#define MI_SAVEAREA    0x7661530AL     // Save area (t_savearea)
#define MI_RTCOND      0x6374520AL     // Run trace pause condition
#define MI_RTPROT      0x7074520AL     // Run trace protocol condition
#define MI_WATCH       0x6374570AL     // Watch in watch window
#define MI_LOADDLL     0x64644C0AL     // Packed loaddll.exe
#define MI_PATCH       0x7461500AL     // Patch data (compressed t_patch)
#define MI_PLUGIN      0x676C500AL     // Plugin prefix descriptor
#define MI_END         0x646E450AL     // End of tagged file

#ifdef FILE                            // Requires <stdio.h>

typedef struct t_fileinfo {            // Length, date, CRC (MI_FILEINFO)
  ulong          size;                 // Length of executable file
  FILETIME       filetime;             // Time of last modification
  ulong          crc;                  // CRC of executable file
  int            issfx;                // Whether self-extractable
  ulong          sfxentry;             // Offset of original entry after SFX
} t_fileinfo;

typedef struct t_tagfile {             // Descriptor of tagged file (reading)
  FILE           *f;                   // File descriptor
  ulong          filesize;             // File size
  ulong          offset;               // Actual offset
  ulong          tag;                  // Tag of next accessed record
  ulong          recsize;              // Size of next accessed record
} t_tagfile;

stdapi (FILE *)  Createtaggedfile(wchar_t *name,char *signature,ulong version);
stdapi (int)     Savetaggedrecord(FILE *f,ulong tag,ulong size,void *data);
stdapi (int)     Savepackedrecord(FILE *f,ulong tag,ulong size,void *data);
stdapi (void)    Finalizetaggedfile(FILE *f);
stdapi (int)     Opentaggedfile(t_tagfile *tf,wchar_t *name,char *signature);
stdapi (int)     Gettaggedrecordsize(t_tagfile *tf,ulong *tag,ulong *size);
stdapi (ulong)   Gettaggedfiledata(t_tagfile *tf,void *buf,ulong bufsize);
stdapi (void)    Closetaggedfile(t_tagfile *tf);

#endif

typedef struct t_nameinfo {            // Header of name/data record (MI_NAME)
  ulong          offs;                 // Offset in module
  uchar          type;                 // Name/data type, one of NM_xxx/DT_xxx
} t_nameinfo;

typedef struct t_uddsave {             // .udd file descriptor used by plugins
  void           *file;                // .udd file
  ulong          uddprefix;            // .udd tag prefix
} t_uddsave;

stdapi (int)     Pluginsaverecord(t_uddsave *psave,ulong tag,
                   ulong size,void *data);
stdapi (int)     Pluginpackedrecord(t_uddsave *psave,ulong tag,
                   ulong size,void *data);
stdapi (void)    Pluginmodulechanged(ulong addr);
stdapi (int)     Plugingetuniquedatatype(void);
stdapi (int)     Plugintempbreakpoint(ulong addr,ulong type,int forceint3);
stdapi (void)    Pluginshowoptions(struct t_control *options);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LEXICAL SCANNER ////////////////////////////////

#define SMODE_UPCASE   0x00000001      // Convert keywords to uppercase
#define SMODE_NOEOL    0x00000010      // Don't report SCAN_EOL, just skip it
#define SMODE_NOSPEC   0x00000020      // Don't translate specsymbols
#define SMODE_EXTKEY   0x00000040      // Allow &# and .!?%~ inside keywords
#define SMODE_NOUSKEY  0x00000080      // Underscore (_) is not part of keyword
#define SMODE_NODEC    0x00000100      // nn. is not decimal, but nn and '.'
#define SMODE_NOFLOAT  0x00000200      // nn.mm is not float, but nn, '.', mm
#define SMODE_RADIX10  0x00000400      // Default base is 10, not 16
#define SMODE_ANGLES   0x00000800      // Use angular brackets (<>) for text
#define SMODE_MASK     0x00001000      // Allow masked nibbles in SCAN_INT

#define SCAN_EOF       0               // End of data
#define SCAN_EOL       1               // End of line
#define SCAN_KEY       2               // Keyword in text
#define SCAN_TEXT      3               // Text string (without quotes) in text
#define SCAN_INT       4               // Integer in ival or uval
#define SCAN_FLOAT     5               // Floating-point number in fval
#define SCAN_OP        6               // Operator or punctuator in ival
#define SCAN_INVALID   7               // Invalid character in ival
#define SCAN_SYNTAX    8               // Syntactical error in errmsg
#define SCAN_USER      10              // Base for user-defined types

typedef struct t_scan {                // Scan descriptor
  // Fill these fields before the first scan. Set line to 1 for 1-based numbers.
  ulong          mode;                 // Scanning mode, set of SMODE_xxx
  wchar_t        *src;                 // Pointer to UNICODE source data
  ulong          length;               // Length of source data, characters
  ulong          caret;                // Next processed symbol, characters
  int            line;                 // Number of encountered EOLs
  // Call to Scan() fills some of these fields with scan data.
  union {
    int          ival;                 // Scanned item as integer number
    ulong        uval;                 // Scanned item as unsigned number
  };
  ulong          mask;                 // Binary mask for uval, SCAN_INT only
  long double    fval;                 // Scanned item as floating number
  wchar_t        text[TEXTLEN];        // Scanned item as a text string
  int            ntext;                // Length of text, characters
  wchar_t        errmsg[TEXTLEN];      // Error message
  int            type;                 // Type of last scanned item, SCAN_xxx
} t_scan;

stdapi (int)     Skipspaces(t_scan *ps);
stdapi (void)    Scan(t_scan *ps);
stdapi (int)     Optostring(wchar_t *s,int op);


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SHORTCUTS, MENUS AND TOOLBAR /////////////////////////

// Input modes of menu functions.
#define MENU_VERIFY    0               // Check if menu item applies
#define MENU_EXECUTE   1               // Execute menu item
// Values returned by menu functions on MENU_VERIFY.
#define MENU_ABSENT    0               // Item doesn't appear in menu
#define MENU_NORMAL    1               // Ordinary menu item
#define MENU_CHECKED   2               // Checked menu item
#define MENU_CHKPARENT 3               // Checked menu item + checked parent
#define MENU_GRAYED    4               // Inactive menu item
#define MENU_SHORTCUT  5               // Shortcut only, not in menu
// Values returned by menu functions on MENU_EXECUTE.
#define MENU_NOREDRAW  0               // Do not redraw owning window
#define MENU_REDRAW    1               // Redraw owning window

// Shortcut descriptions.
#define KK_KEYMASK     0x0000FFFF      // Mask to extract key
#define KK_CHAR        0x00010000      // Process as WM_CHAR
#define KK_SHIFT       0x00020000      // Shortcut includes Shift key
#define KK_CTRL        0x00040000      // Shortcut includes Ctrl key
#define KK_ALT         0x00080000      // Shortcut includes Alt key
#define KK_WIN         0x00100000      // Shortcut includes WIN key
#define KK_NOSH        0x00200000      // Shortcut ignores Shift in main menu
#define KK_UNUSED      0x7FC00000      // Unused shortcut data bits
#define KK_DIRECT      0x80000000      // Direct shortcut in menu

// Global shortcuts. They may be re-used by plugins.
#define K_NONE         0               // No shortcut
// Global shortcuts: File functions.
#define K_OPENNEW      100             // Open new executable to debug
#define K_SETARGS      101             // Set command line args for next run
#define K_ATTACH       102             // Attach to the running process
#define K_DETACH       103             // Detach from the debugged process
#define K_EXIT         104             // Close OllyDbg
// Global shortcuts: View functions.
#define K_LOGWINDOW    110             // Open Log window
#define K_MODULES      111             // Open Executable modules window
#define K_MEMORY       112             // Open Memory map window
#define K_WINDOWS      113             // Open list of windows
#define K_THREADS      114             // Open Threads window
#define K_CPU          115             // Open CPU window
#define K_WATCHES      116             // Open Watches window
#define K_SEARCHES     117             // Open Search results window
#define K_RTRACE       118             // Open Run trace window
#define K_PATCHES      119             // Open Patches window
#define K_BPOINTS      120             // Open INT3 breakpoints window
#define K_BPMEM        121             // Open Memory breakpoints window
#define K_BPHARD       122             // Open Hardware breakpoints window
#define K_SOURCES      123             // Open list of source files
#define K_FILE         124             // Open file
// Global shortcuts: Debug functions.
#define K_RUN          130             // Run debugged application
#define K_RUNTHREAD    131             // Run only actual thread
#define K_PAUSE        132             // Pause debugged application
#define K_STEPIN       133             // Step into
#define K_STEPOVER     134             // Step over
#define K_TILLRET      135             // Execute till return
#define K_TILLUSER     136             // Execute till user code
#define K_CALLDLL      137             // Call DLL export
#define K_RESTART      138             // Restart last debugged executable
#define K_CLOSE        139             // Close debuggee
#define K_AFFINITY     140             // Set affinity
// Global shortcuts: Trace functions.
#define K_OPENTRACE    150             // Open Run trace
#define K_CLOSETRACE   151             // Close Run trace
#define K_ANIMIN       152             // Animate into
#define K_ANIMOVER     153             // Animate over
#define K_TRACEIN      154             // Trace into
#define K_TRACEOVER    155             // Trace over
#define K_RUNHIT       156             // Run hit trace
#define K_STOPHIT      157             // Stop hit trace
#define K_RTCOND       158             // Set run trace break condition
#define K_RTLOG        159             // Set run trace log condition
// Global shortcuts: Options.
#define K_OPTIONS      170             // Open Options dialog
#define K_PLUGOPTIONS  171             // Open Plugin options dialog
#define K_SHORTCUTS    172             // Open Shortcut editor
// Global shortcuts: Windows functions.
#define K_TOPMOST      180             // Toggle topmost status of main window
#define K_CASCADE      181             // Cascade MDI windows
#define K_TILEHOR      182             // Tile MDI windows horizontally
#define K_TILEVER      183             // Tile MDI windows vertically
#define K_ICONS        184             // Arrange icons
#define K_CLOSEMDI     185             // Close all MDI windows
#define K_RESTORE      186             // Maximize or restore active MDI window
#define K_PREVMDI      187             // Go to previous MDI window
#define K_NEXTMDI      188             // Go to next MDI window
// Global shortcuts: Help functions.
#define K_ABOUT        190             // Open About dialog
// Generic table shortcuts.
#define K_PREVFRAME    200             // Go to previous frame in table
#define K_NEXTFRAME    201             // Go to next frame in table
#define K_UPDATE       202             // Update table
#define K_COPY         203             // Copy to clipboard
#define K_COPYALL      204             // Copy whole table to clipboard
#define K_CUT          205             // Cut to clipboard
#define K_PASTE        206             // Paste
#define K_TOPMOSTMDI   207             // Make MDI window topmost
#define K_AUTOUPDATE   208             // Periodically update contents of window
#define K_SHOWBAR      209             // Show/hide bar
#define K_HSCROLL      210             // Show/hide horizontal scroll
#define K_DEFCOLUMNS   211             // Resize all columns to default width
// Shortcuts used by different windows.
#define K_SEARCHAGAIN  220             // Repeat last search
#define K_SEARCHREV    221             // Repeat search in inverse direction
// Dump: Data backup.
#define K_BACKUP       240             // Create or update backup
#define K_SHOWBKUP     241             // Toggle backup display
// Dump: Edit.
#define K_UNDO         250             // Undo selection
#define K_COPYADDR     251             // Copy address
#define K_COPYHEX      252             // Copy data in hexadecimal format
#define K_PASTEHEX     253             // Paste data in hexadecimal format
#define K_EDITITEM     254             // Edit first selected item
#define K_EDIT         255             // Edit selection
#define K_FILLZERO     256             // Fill selection with zeros
#define K_FILLNOP      257             // Fill selection with NOPs
#define K_FILLFF       258             // Fill selection with FF code
#define K_SELECTALL    259             // Select all
#define K_SELECTPROC   260             // Select procedure or structure
#define K_COPYTOEXE    261             // Copy selection to executable file
#define K_ZERODUMP     262             // Zero whole dump
#define K_LABEL        263             // Add custom label
#define K_ASSEMBLE     264             // Assemble
#define K_COMMENT      265             // Add custom comment
#define K_SAVEFILE     266             // Save file
// Dump: Breakpoints.
#define K_BREAK        280             // Toggle simple INT3 breakpoint
#define K_CONDBREAK    281             // Set or edit cond INT3 breakpoint
#define K_LOGBREAK     282             // Set or edit logging INT3 breakpoint
#define K_RUNTOSEL     283             // Run to selection
#define K_ENABLEBRK    284             // Enable or disable INT3 breakpoint
#define K_MEMBREAK     285             // Set or edit memory breakpoint
#define K_MEMLOGBREAK  286             // Set or edit memory log breakpoint
#define K_MEMENABLE    287             // Enable or disable memory breakpoint
#define K_MEMDEL       288             // Delete memory breakpoint
#define K_HWBREAK      289             // Set or edit hardware breakpoint
#define K_HWLOGBREAK   290             // Set or edit hardware log breakpoint
#define K_HWENABLE     291             // Enable or disable hardware breakpoint
#define K_HWDEL        292             // Delete hardware breakpoint
// Dump: Jumps to location.
#define K_NEWORIGIN    300             // Set new origin
#define K_FOLLOWDASM   301             // Follow address in Disassembler
#define K_ORIGIN       302             // Go to origin
#define K_GOTO         303             // Go to expression
#define K_JMPTOSEL     304             // Follow jump or call to selection
#define K_SWITCHCASE   305             // Go to switch case
#define K_PREVHIST     306             // Go to previous history location
#define K_NEXTHIST     307             // Go to next history location
#define K_PREVTRACE    308             // Go to previous run trace record
#define K_NEXTTRACE    309             // Go to next run trace record
#define K_PREVPROC     310             // Go to previous procedure
#define K_NEXTPROC     311             // Go to next procedure
#define K_PREVREF      312             // Go to previous found item
#define K_NEXTREF      313             // Go to next found item
#define K_FOLLOWEXE    314             // Follow selection in executable file
// Dump: Structures.
#define K_DECODESTR    330             // Decode as structure
#define K_DECODESPTR   331             // Decode as pointer to structure
// Dump: Search.
#define K_NAMES        380             // Show list of names
#define K_FINDCMD      381             // Find command
#define K_FINDCMDSEQ   382             // Find sequence of commands
#define K_FINDCONST    383             // Find constant
#define K_FINDBIN      384             // Find binary string
#define K_FINDMOD      385             // Find modification
#define K_ALLCALLS     386             // Search for all intermodular calls
#define K_ALLCMDS      387             // Search for all commands
#define K_ALLCMDSEQ    388             // Search for all command sequences
#define K_ALLCONST     389             // Search for all constants
#define K_ALLMODS      390             // Search for all modifications
#define K_ALLSTRS      391             // Search for all referenced strings
#define K_ALLGUIDS     392             // Search for all referenced GUIDs
#define K_ALLCOMMENTS  393             // Search for all user-defined comments
#define K_ALLSWITCHES  394             // Search for all switches
#define K_ALLFLOATS    395             // Search for all floating constants
#define K_LASTRTREC    396             // Find last record in run trace
// Dump: References.
#define K_REFERENCES   410             // Find all references
// Dump: Addressing.
#define K_ABSADDR      420             // Show absolute addresses
#define K_RELADDR      421             // Show offsets from current selection
#define K_BASEADDR     422             // Show offsets relative to module base
// Dump: Comments.
#define K_COMMSRC      430             // Toggle between comments and source
#define K_SHOWPROF     431             // Show or hide run trace profile
// Dump: Analysis.
#define K_ANALYSE      440             // Analyse module
#define K_REMANAL      441             // Remove analysis from selection
#define K_REMANMOD     442             // Remove analysis from the module
// Dump: Help.
#define K_HELPCMD      450             // Help on command
#define K_HELPAPI      451             // Help on Windows API function
// Dump: Data presentation.
#define K_DUMPHA16     460             // Dump as 16 hex bytes and ASCII text
#define K_DUMPHA8      461             // Dump as 8 hex bytes and ASCII text
#define K_DUMPHU16     462             // Dump as 16 hex bytes and UNICODE text
#define K_DUMPHU8      463             // Dump as 8 hex bytes and UNICODE text
#define K_DUMPA64      464             // Dump as 64 ASCII characters
#define K_DUMPA32      465             // Dump as 32 ASCII characters
#define K_DUMPU64      466             // Dump as 64 UNICODE characters
#define K_DUMPU32      467             // Dump as 32 UNICODE characters
#define K_DUMPU16      468             // Dump as 16 UNICODE characters
#define K_DUMPISHORT   469             // Dump as 16-bit signed numbers
#define K_DUMPUSHORT   470             // Dump as 16-bit unsigned numbers
#define K_DUMPXSHORT   471             // Dump as 16-bit hexadecimal numbers
#define K_DUMPILONG    472             // Dump as 32-bit signed numbers
#define K_DUMPULONG    473             // Dump as 32-bit unsigned numbers
#define K_DUMPXLONG    474             // Dump as 32-bit hexadecimal numbers
#define K_DUMPADR      475             // Dump as address with comments
#define K_DUMPADRA     476             // Dump as address with ASCII & comments
#define K_DUMPADRU     477             // Dump as address with UNICODE & comms
#define K_DUMPF32      478             // Dump as 32-bit floats
#define K_DUMPF64      479             // Dump as 64-bit floats
#define K_DUMPF80      480             // Dump as 80-bit floats
#define K_DUMPDA       481             // Dump as disassembly
#define K_DUMPSTRUCT   482             // Dump as known structure
// Stack-specific shortcuts.
#define K_LOCKSTK      490             // Toggle stack lock
#define K_PUSH         491             // Push doubleword
#define K_POP          492             // Pop doubleword
#define K_STACKINDASM  493             // Follow stack doubleword in CPU
#define K_GOTOESP      494             // Go to ESP
#define K_GOTOEBP      495             // Go to EBP
#define K_ESPADDR      496             // Show offsets relative to ESP
#define K_EBPADDR      497             // Show offsets relative to EBP
// Shortcuts of Register pane.
#define K_INCREMENT    500             // Increment register
#define K_DECREMENT    501             // Decrement register
#define K_ZERO         502             // Zero selected register
#define K_SET1         503             // Set register to 1
#define K_MODIFY       504             // Modify contents of register
#define K_UNDOREG      505
#define K_PUSHFPU      506             // Push FPU stack
#define K_POPFPU       507             // Pop FPU stack
#define K_REGINDASM    508             // Follow register in CPU Disassembler
#define K_REGINDUMP    509             // Follow register in CPU Dump
#define K_REGINSTACK   510             // Follow register in CPU Stack
#define K_VIEWFPU      511             // View FPU registers
#define K_VIEWMMX      512             // View MMX registers
#define K_VIEW3DNOW    513             // View 3DNow! registers
#define K_HELPREG      514             // Help on register
// Shortcuts of Information pane.
#define K_EDITOP       520             // Edit contents of operand in info pane
#define K_INFOINDASM   521             // Follow information in CPU Disassembler
#define K_INFOINDUMP   522             // Follow information in CPU Dump
#define K_INFOINSTACK  523             // Follow information in CPU Stack
#define K_LISTJUMPS    524             // List jumps and calls to command
#define K_LISTCASES    525             // List switch cases
#define K_INFOSRC      526             // Follow address in Source code
// Log window.
#define K_LOGINDASM    530             // Follow log address in CPU Disassembler
#define K_LOGINDUMP    531             // Follow log address in CPU Dump
#define K_LOGINSTACK   532             // Follow log address in CPU Stack
#define K_LOGCLEAR     533             // Clear log
#define K_LOGTOFILE    534             // Start logging to file
#define K_STOPLOG      535             // Stop logging to file
// Executable modules.
#define K_MODINDASM    540             // Follow module entry point in CPU
#define K_MODDATA      541             // View module data section in CPU Dump
#define K_MODEXE       542             // Open executable in standalone Dump
#define K_MODNAMES     543             // Show names declared in the module
#define K_GLOBNAMES    544             // Show global list of names
#define K_MODCALLS     545             // Find intermodular calls in module
#define K_MODANALYSE   546             // Analyse selected module
#define K_SAVEUDD      547             // Save module data to .udd file
#define K_LOADUDD      548             // Load module data from .udd file
// Memory map.
#define K_MEMBACKUP    550             // Create backup of memory block
#define K_MEMINDASM    551             // Open memory block in CPU Disassembler
#define K_MEMINDUMP    552             // Open memory block in CPU Dump
#define K_DUMP         553             // Dump memory block in separate window
#define K_SEARCHMEM    554             // Search memory block for binary string
#define K_MEMBPACCESS  555             // Toggle break on access
// List of windows.
#define K_WININDASM    560             // Follow WinProc in CPU Disassembler
#define K_CLSINDASM    561             // Follow ClassProc in CPU Disassembler
// Threads.
#define K_THRINCPU     570             // Open thread in CPU window
#define K_THRTIB       571             // Dump Thread Information Block
#define K_REGISTERS    572             // Open Registers window
#define K_THRSUSPEND   573             // Suspend selected thread
#define K_THRRESUME    574             // Resume selected thread
#define K_THRKILL      575             // Kill selected thread
// Watches.
#define K_ADDWATCH     580             // Add watch
#define K_EDITWATCH    581             // Edit existing watch
#define K_DELWATCH     582             // Delete watch
#define K_WATCHUP      583             // Move watch up
#define K_WATCHDN      584             // Move watch down
#define K_EDITCONT     585             // Edit contents of register or memory
#define K_WATCHINDASM  586             // Follow watch value in CPU Disassembler
#define K_WATCHINDUMP  587             // Follow watch value in CPU Dump
#define K_WATCHINSTACK 588             // Follow watch value in CPU Stack
// Search results.
#define K_SEARCHINDASM 600             // Follow address of found item in CPU
#define K_PREVSEARCH   601             // Follow previous found item in Disasm
#define K_NEXTSEARCH   602             // Follow next found item in Disasm
#define K_FINDTEXT     603             // Find text substring in search results
#define K_BREAKALL     604             // Set breakpoint on all found commands
#define K_CONDBPALL    605             // Set conditional bp on all commands
#define K_LOGBPALL     606             // Set logging bp on all commands
#define K_DELBPALL     607             // Remove breakpoints from all commands
#define K_BREAKCALLS   608             // Set break on calls to function
#define K_CONDBPCALLS  609             // Set cond break on calls to function
#define K_LOGBPCALLS   610             // Set logging break on calls to function
#define K_DELBPCALLS   611             // Remove breakpoints from calls
// Run trace.
#define K_RTPREV       620             // Show previous run trace in Disasm
#define K_RTNEXT       621             // Show next run trace in Disasm
#define K_TRACEINDASM  622             // Follow traced command in CPU
#define K_CLRTRACE     623             // Clear run trace
#define K_REGMODE      624             // Toggle register display mode
#define K_MARKTRACE    625             // Mark address in run trace
#define K_FINDTRADDR   626             // Enter address to mark in run trace
#define K_PREVMARK     627             // Find previous marked address
#define K_NEXTMARK     628             // Find next marked address
#define K_CLEARMARK    629             // Clear address marks in run trace
#define K_PROFILE      630             // Profile selected module
#define K_GLOBPROFILE  631             // Profile whole memory
#define K_SAVETRACE    632             // Save run trace data to the file
#define K_STOPSAVETR   633             // Close run trace log file
// Profile.
#define K_PROFINDASM   640             // Follow profiled command in CPU
#define K_PREVPROF     641             // Follow previous profile item in Disasm
#define K_NEXTPROF     642             // Follow next profile item in Disasm
#define K_PROFMARK     643             // Mark profile address in run trace
// Patches.
#define K_PATCHINDASM  650             // Follow patch in CPU Disassembler
#define K_PREVPATCH    651             // Go to previous patch
#define K_NEXTPATCH    652             // Go to next patch
#define K_APPLYPATCH   653             // Apply patch
#define K_RESTOREPT    654             // Restore original code
#define K_DELPATCH     655             // Delete patch record
// Breakpoint lists.
#define K_DELETEBP     660             // Delete breakpoint
#define K_ENABLEBP     661             // Enable or disable breakpoint
#define K_BPINDASM     662             // Follow breakpoint in CPU Disassembler
#define K_BPINDUMP     663             // Follow breakpoint in CPU Dump
#define K_DISABLEALLBP 664             // Disable all breakpoints
#define K_ENABLEALLBP  665             // Enable all breakpoints
// Source.
#define K_SOURCEINDASM 670             // Follow source line in CPU Disassembler
// List of source files.
#define K_VIEWSRC      680             // View source file
// Names.
#define K_FOLLOWIMP    690             // Follow import in CPU Disassembler
#define K_NAMEINDASM   691             // Follow label in CPU Disassembler
#define K_NAMEINDUMP   692             // Follow label in CPU Dump
#define K_NAMEREFS     693             // Find references to name
#define K_NAMEHELPAPI  694             // Help on selected API function
// Special non-changeable shortcuts.
#define K_0            1008            // Digit 0
#define K_1            1009            // Digit 1
#define K_2            1010            // Digit 2
#define K_3            1011            // Digit 3
#define K_4            1012            // Digit 4
#define K_5            1013            // Digit 5
#define K_6            1014            // Digit 6
#define K_7            1015            // Digit 7
#define K_8            1016            // Digit 8
#define K_9            1017            // Digit 9
#define K_A            1018            // Hex digit A
#define K_B            1019            // Hex digit B
#define K_C            1020            // Hex digit C
#define K_D            1021            // Hex digit D
#define K_E            1022            // Hex digit E
#define K_F            1023            // Hex digit F

// Native OllyDbg tables that support embedded plugin menus:
#define PWM_ATTACH     L"ATTACH"       // List of processes in Attach window
#define PWM_BPHARD     L"BPHARD"       // Hardware breakpoints
#define PWM_BPMEM      L"BPMEM"        // Memory breakpoints
#define PWM_BPOINT     L"BPOINT"       // INT3 breakpoints
#define PWM_DISASM     L"DISASM"       // CPU Disassembler pane
#define PWM_DUMP       L"DUMP"         // All dumps except CPU disasm & stack
#define PWM_INFO       L"INFO"         // CPU Info pane
#define PWM_LOG        L"LOG"          // Log window
#define PWM_MAIN       L"MAIN"         // Main OllyDbg menu
#define PWM_MEMORY     L"MEMORY"       // Memory window
#define PWM_MODULES    L"MODULES"      // Modules window
#define PWM_NAMELIST   L"NAMELIST"     // List of names (labels)
#define PWM_PATCHES    L"PATCHES"      // List of patches
#define PWM_PROFILE    L"PROFILE"      // Profile window
#define PWM_REGISTERS  L"REGISTERS"    // Registers, including CPU
#define PWM_SEARCH     L"SEARCH"       // Search tabs
#define PWM_SOURCE     L"SOURCE"       // Source code window
#define PWM_SRCLIST    L"SRCLIST"      // List of source files
#define PWM_STACK      L"STACK"        // CPU Stack pane
#define PWM_THREADS    L"THREADS"      // Threads window
#define PWM_TRACE      L"TRACE"        // Run trace window
#define PWM_WATCH      L"WATCH"        // Watches
#define PWM_WINDOWS    L"WINDOWS"      // List of windows

typedef int  MENUFUNC(struct t_table *,wchar_t *,ulong,int);

typedef struct t_menu {                // Menu descriptor
  wchar_t        *name;                // Menu command
  wchar_t        *help;                // Explanation of command
  int            shortcutid;           // Shortcut identifier, K_xxx
  MENUFUNC       *menufunc;            // Function that executes menu command
  struct t_menu  *submenu;             // Pointer to descriptor of popup menu
  union {
    ulong        index;                // Argument passed to menu function
    HMENU        hsubmenu;             // Handle of pulldown menu
  };
} t_menu;

stdapi (int)     Callmenufunction(struct t_table *pt,t_menu *pm,
                   MENUFUNC *menufunc,ulong index);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// MAIN OLLYDBG WINDOW //////////////////////////////

typedef enum t_status {                // Thread/process status
  STAT_IDLE,                           // No process to debug
  STAT_LOADING,                        // Loading new process
  STAT_ATTACHING,                      // Attaching to the running process
  STAT_RUNNING,                        // All threads are running
  STAT_RUNTHR,                         // Single thread is running
  STAT_STEPIN,                         // Stepping into, single thread
  STAT_STEPOVER,                       // Stepping over, single thread
  STAT_ANIMIN,                         // Animating into, single thread
  STAT_ANIMOVER,                       // Animating over, single thread
  STAT_TRACEIN,                        // Tracing into, single thread
  STAT_TRACEOVER,                      // Tracing over, single thread
  STAT_SFXRUN,                         // SFX using run trace, single thread
  STAT_SFXHIT,                         // SFX using hit trace, single thread
  STAT_SFXKNOWN,                       // SFX to known entry, single thread
  STAT_TILLRET,                        // Stepping until return, single thread
  STAT_OVERRET,                        // Stepping over return, single thread
  STAT_TILLUSER,                       // Stepping till user code, single thread
  STAT_PAUSING,                        // Process is requested to pause
  STAT_PAUSED,                         // Process paused on debugging event
  STAT_FINISHED,                       // Process is terminated but in memory
  STAT_CLOSING                         // Process is requested to close/detach
} t_status;

varapi (void)    Info(wchar_t *format,...);
varapi (void)    Message(ulong addr,wchar_t *format,...);
varapi (void)    Tempinfo(wchar_t *format,...);
varapi (void)    Flash(wchar_t *format,...);
varapi (void)    Progress(int promille,wchar_t *format,...);
stdapi (void)    Moveprogress(int promille);
stdapi (void)    Setstatus(t_status newstatus);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// DATA FUNCTIONS ////////////////////////////////

// Name and data types. Do not change order, it's important! Always keep values
// of demangled names 1 higher than originals, and NM_ALIAS higher than
// NM_EXPORT - name search routines rely on these facts!
#define NM_NONAME      0x00            // Means that name is absent
#define DT_NONE        0x00            // Ditto
#define NM_LABEL       0x21            // User-defined label
#define NM_EXPORT      0x22            // Exported name
#define NM_DEEXP       (NM_EXPORT+1)   // Demangled exported name
#define DT_EORD        (NM_EXPORT+2)   // Exported ordinal (ulong)
#define NM_ALIAS       (NM_EXPORT+3)   // Alias of NM_EXPORT
#define NM_IMPORT      0x26            // Imported name (module.function)
#define NM_DEIMP       (NM_IMPORT+1)   // Demangled imported name
#define DT_IORD        (NM_IMPORT+2)   // Imported ordinal (struct dt_iord)
#define NM_DEBUG       0x29            // Name from debug data
#define NM_DEDEBUG     (NM_DEBUG+1)    // Demangled name from debug data
#define NM_ANLABEL     0x2B            // Name added by Analyser
#define NM_COMMENT     0x30            // User-defined comment
#define NM_ANALYSE     0x31            // Comment added by Analyser
#define NM_MARK        0x32            // Important parameter
#define NM_CALLED      0x33            // Name of called function
#define DT_ARG         0x34            // Name and type of argument or data
#define DT_NARG        0x35            // Guessed number of arguments at CALL
#define NM_RETTYPE     0x36            // Type of data returned in EAX
#define NM_MODCOMM     0x37            // Automatical module comments
#define NM_TRICK       0x38            // Parentheses of tricky sequences
#define DT_SWITCH      0x40            // Switch descriptor (struct dt_switch)
#define DT_CASE        0x41            // Case descriptor (struct dt_case)
#define DT_MNEMO       0x42            // Alternative mnemonics data (dt_mnemo)
#define NM_DLLPARMS    0x44            // Parameters of Call DLL dialog
#define DT_DLLDATA     0x45            // Parameters of Call DLL dialog

#define DT_DBGPROC     0x4A            // t_function from debug, don't save!

#define NM_INT3BASE    0x51            // Base for INT3 breakpoint names
#define   NM_INT3COND  (NM_INT3BASE+0) // INT3 breakpoint condition
#define   NM_INT3EXPR  (NM_INT3BASE+1) // Expression to log at INT3 breakpoint
#define   NM_INT3TYPE  (NM_INT3BASE+2) // Type used to decode expression
#define NM_MEMBASE     0x54            // Base for memory breakpoint names
#define   NM_MEMCOND   (NM_MEMBASE+0)  // Memory breakpoint condition
#define   NM_MEMEXPR   (NM_MEMBASE+1)  // Expression to log at memory break
#define   NM_MEMTYPE   (NM_MEMBASE+2)  // Type used to decode expression
#define NM_HARDBASE    0x57            // Base for hardware breakpoint names
#define   NM_HARDCOND  (NM_HARDBASE+0) // Hardware breakpoint condition
#define   NM_HARDEXPR  (NM_HARDBASE+1) // Expression to log at hardware break
#define   NM_HARDTYPE  (NM_HARDBASE+2) // Type used to decode expression

#define NM_LABELSAV    0x60            // NSTRINGS last user-defined labels
#define NM_ASMSAV      0x61            // NSTRINGS last assembled commands
#define NM_ASRCHSAV    0x62            // NSTRINGS last assemby searches
#define NM_COMMSAV     0x63            // NSTRINGS last user-defined comments
#define NM_WATCHSAV    0x64            // NSTRINGS last watch expressions
#define NM_GOTOSAV     0x65            // NSTRINGS last GOTO expressions
#define DT_BINSAV      0x66            // NSTRINGS last binary search patterns
#define NM_CONSTSAV    0x67            // NSTRINGS last constants to search
#define NM_STRSAV      0x68            // NSTRINGS last strings to search
#define NM_ARGSAV      0x69            // NSTRINGS last arguments (ARGLEN!)
#define NM_CURRSAV     0x6A            // NSTRINGS last current dirs (MAXPATH!)

#define NM_SEQSAV      0x6F            // NSTRINGS last sequences (DATALEN!)

#define NM_RTCOND1     0x70            // First run trace pause condition
#define NM_RTCOND2     0x71            // Second run trace pause condition
#define NM_RTCOND3     0x72            // Third run trace pause condition
#define NM_RTCOND4     0x73            // Fourth run trace pause condition
#define NM_RTCMD1      0x74            // First run trace match command
#define NM_RTCMD2      0x75            // Second run trace match command
#define NM_RANGE0      0x76            // Low range limit
#define NM_RANGE1      0x77            // High range limit

#define DT_ANYDATA     0xFF            // Special marker, not a real data

#define NMOFS_COND     0               // Offset to breakpoint condition
#define NMOFS_EXPR     1               // Offset to breakpoint log expression
#define NMOFS_TYPE     2               // Offset to expression decoding type

typedef struct dt_iord {               // Descriptor of DT_IORD data
  ulong          ord;                  // Ordinal
  wchar_t        modname[SHORTNAME];   // Short name of the module
} dt_iord;

#define NSWEXIT        256             // Max no. of switch exits, incl. default
#define NSWCASE        128             // Max no. of cases in exit

// Types of switches and switch exits.
#define CASE_CASCADED  0x00000001      // Cascaded IF
#define CASE_HUGE      0x00000002      // Huge switch, some cases are lost
#define CASE_DEFAULT   0x00000004      // Has default (is default for dt_case)
#define CASE_TYPEMASK  0x00000070      // Mask to extract case type
#define   CASE_ASCII   0x00000010      // Intreprete cases as ASCII characters
#define   CASE_MSG     0x00000020      // Interprete cases as WM_xxx
#define   CASE_EXCPTN  0x00000040      // Interprete cases as exception codes
#define CASE_SIGNED    0x00000080      // Interprete cases as signed

typedef struct dt_switch {             // Switch descriptor DT_SWITCH
  ulong          casemin;              // Minimal case
  ulong          casemax;              // Maximal case
  ulong          type;                 // Switch type, set of CASE_xxx
  int            nexit;                // Number of exits including default
  ulong          exitaddr[NSWEXIT];    // List of exits (point to dt_case)
} dt_switch;

typedef struct dt_case {               // Switch exit descriptor DT_CASE
  ulong          swbase;               // Address of a switch descriptor
  ulong          type;                 // Switch type, set of CASE_xxx
  int            ncase;                // Number of cases (1..64, 0: default)
  ulong          value[NSWCASE];       // List of cases for exit
} dt_case;

// Flags indicating alternative forms of assembler mnemonics.
#define MF_JZ          0x01            // JZ, JNZ instead of JE, JNE
#define MF_JC          0x02            // JC, JNC instead of JAE, JB

typedef struct dt_mnemo {              // Mnemonics decoding DT_MNEMO
  uchar          flags;                // Set of MF_xxx
} dt_mnemo;

stdapi (int)     Insertdata(ulong addr,int type,void *data,ulong datasize);
stdapi (ulong)   Finddata(ulong addr,int type,void *data,ulong datasize);
stdapi (void *)  Finddataptr(ulong addr,int type,ulong *datasize);
stdapi (void)    Startnextdata(ulong addr0,ulong addr1,int type);
stdapi (ulong)   Findnextdata(ulong *addr,void *data,ulong datasize);
stdapi (void)    Startnextdatalist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     Findnextdatalist(ulong *addr,int *type,
                   void *data,ulong datasize);
stdapi (int)     Isdataavailable(ulong addr,int type1,int type2,int type3);
stdapi (int)     Isdatainrange(ulong addr0,ulong addr1,
                   int type1,int type2,int type3);
stdapi (void)    Deletedatarange(ulong addr0,ulong addr1,
                   int type1,int type2,int type3);
stdapi (void)    Deletedatarangelist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     Quickinsertdata(ulong addr,int type,
                   void *data,ulong datasize);
stdapi (void)    Mergequickdata(void);
stdapi (int)     DemanglenameW(wchar_t *name,wchar_t *undecorated,int recurs);
stdapi (int)     InsertnameW(ulong addr,int type,wchar_t *s);
stdapi (int)     QuickinsertnameW(ulong addr,int type,wchar_t *s);
stdapi (int)     FindnameW(ulong addr,int type,wchar_t *name,int nname);
stdapi (int)     FindnextnameW(ulong *addr,wchar_t *name,int nname);
stdapi (void)    Startnextnamelist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     FindnextnamelistW(ulong *addr,int *type,
                   wchar_t *name,int nname);
stdapi (int)     Findlabel(ulong addr,wchar_t *name,int firsttype);
stdapi (int)     FindaddressW(wchar_t *name,struct t_module *pmod,
                   ulong *addr,wchar_t *errtxt);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// SIMPLE DATA FUNCTIONS ////////////////////////////

typedef struct t_simple {              // Simple data container
  uchar          *heap;                // Data heap
  ulong          itemsize;             // Size of data element, bytes
  int            maxitem;              // Size of allocated data heap, items
  int            nitem;                // Actual number of data items
  int            sorted;               // Whether data is sorted
} t_simple;

stdapi (void)    Destroysimpledata(t_simple *pdat);
stdapi (int)     Createsimpledata(t_simple *pdat,ulong itemsize);
stdapi (int)     Addsimpledata(t_simple *pdat,void *data);
stdapi (void)    Sortsimpledata(t_simple *pdat);
stdapi (void *)  Findsimpledata(t_simple *pdat,ulong addr);
stdapi (int)     Getsimpledataindexbyaddr(t_simple *pdat,ulong addr);
stdapi (void *)  Getsimpledatabyindex(t_simple *pdat,int index);
stdapi (void)    Deletesimpledatarange(t_simple *pdat,ulong addr0,ulong addr1);

// Bits that describe the state of predicted data, similar to PST_xxx.
#define PRED_SHORTSP   0x8000          // Offset of ESP is 1 byte, .udd only
#define PRED_SHORTBP   0x4000          // Offset of EBP is 1 byte, .udd only
#define PRED_ESPRET    0x0400          // Offset of ESP backtraced from return
#define PRED_ESPOK     0x0200          // Offset of ESP valid
#define PRED_EBPOK     0x0100          // Offset of EBP valid
#define PRED_REL       0x0080          // Result constant fixuped or relative
#define PRED_RESMASK   0x003F          // Mask to extract description of result
#define   PRED_VALID   0x0020          // Result constant valid
#define   PRED_ADDR    0x0010          // Result is address
#define   PRED_ORIG    0x0008          // Result is based on original register
#define   PRED_OMASK   0x0007          // Mask to extract original register

#define PRED_ESPKNOWN  (PRED_ESPRET|PRED_ESPOK)

typedef struct sd_pred {               // Descriptor of predicted data
  ulong          addr;                 // Address of predicted command
  ushort         mode;                 // Combination of PRED_xxx
  long           espconst;             // Offset of ESP to original ESP
  long           ebpconst;             // Offset of EBP to original ESP
  ulong          resconst;             // Constant in result of execution
} sd_pred;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SORTED DATA //////////////////////////////////

#define SDM_INDEXED    0x00000001      // Indexed sorted data
#define SDM_EXTADDR    0x00000002      // Address is extended by TY_AEXTMASK
#define SDM_NOSIZE     0x00000004      // Header without size and type
#define SDM_NOEXTEND   0x00000008      // Don't reallocate memory, fail instead

// Address extension.
#define TY_AEXTMASK    0x000000FF      // Mask to extract address extension
// General item types.
#define TY_NEW         0x00000100      // Item is new
#define TY_CONFIRMED   0x00000200      // Item still exists
#define TY_EXTADDR     0x00000400      // Address extension active
#define TY_SELECTED    0x00000800      // Reserved for multiple selection
// Module-related item types (used in t_module and t_premod).
#define MOD_MAIN       0x00010000      // Main module
#define MOD_SFX        0x00020000      // Self-extractable file
#define   MOD_SFXDONE  0x00040000      // SFX file extracted
#define MOD_RUNDLL     0x00080000      // DLL loaded by LOADDLL.EXE
#define MOD_SYSTEMDLL  0x00100000      // System DLL
#define MOD_SUPERSYS   0x00200000      // System DLL that uses special commands
#define MOD_DBGDATA    0x00400000      // Debugging data is available
#define MOD_ANALYSED   0x00800000      // Module is already analysed
#define MOD_NODATA     0x01000000      // Module data is not yet available
#define MOD_HIDDEN     0x02000000      // Module is loaded in stealth mode
#define MOD_NETAPP     0x04000000      // .NET application
#define MOD_RESOLVED   0x40000000      // All static imports are resolved
// Memory-related item types (used in t_memory), see also t_memory.special.
#define MEM_ANYMEM     0x0FFFF000      // Mask for memory attributes
#define   MEM_CODE     0x00001000      // Contains image of code section
#define   MEM_DATA     0x00002000      // Contains image of data section
#define   MEM_SFX      0x00004000      // Contains self-extractor
#define   MEM_IMPDATA  0x00008000      // Contains import data
#define   MEM_EXPDATA  0x00010000      // Contains export data
#define   MEM_RSRC     0x00020000      // Contains resources
#define   MEM_RELOC    0x00040000      // Contains relocation data
#define   MEM_STACK    0x00080000      // Contains stack of some thread
#define   MEM_STKGUARD 0x00100000      // Guarding page of the stack
#define   MEM_THREAD   0x00200000      // Contains data block of some thread
#define   MEM_HEADER   0x00400000      // Contains COFF header
#define   MEM_DEFHEAP  0x00800000      // Contains default heap
#define   MEM_HEAP     0x01000000      // Contains non-default heap
#define   MEM_NATIVE   0x02000000      // Contains JIT-compiled native code
#define   MEM_GAP      0x08000000      // Free or reserved space
#define MEM_SECTION    0x10000000      // Section of the executable file
#define MEM_GUARDED    0x40000000      // NT only: guarded memory block
#define MEM_TEMPGUARD  0x80000000      // NT only: temporarily guarded block
// Thread-related item types (used in t_thread).
#define THR_MAIN       0x00010000      // Main thread
#define THR_NETDBG     0x00020000      // .NET debug helper thread
#define THR_ORGHANDLE  0x00100000      // Original thread's handle, don't close
// Window-related item types (used in t_window).
#define WN_UNICODE     0x00010000      // UNICODE window
// Procedure-related item types (used in t_procdata).
#define PD_CALLBACK    0x00001000      // Used as a callback
#define PD_RETSIZE     0x00010000      // Return size valid
#define PD_TAMPERRET   0x00020000      // Tampers with the return address
#define PD_NORETURN    0x00040000      // Calls function without return
#define PD_PURE        0x00080000      // Doesn't modify memory & make calls
#define PD_ESPALIGN    0x00100000      // Aligns ESP on entry
#define PD_ARGMASK     0x07E00000      // Mask indicating valid narg
#define   PD_FIXARG    0x00200000      // narg is fixed number of arguments
#define   PD_FORMATA   0x00400000      // narg-1 is ASCII printf format
#define   PD_FORMATW   0x00800000      // narg-1 is UNICODE printf format
#define   PD_SCANA     0x01000000      // narg-1 is ASCII scanf format
#define   PD_SCANW     0x02000000      // narg-1 is UNICODE scanf format
#define   PD_COUNT     0x04000000      // narg-1 is count of following args
#define PD_GUESSED     0x08000000      // narg and type are guessed, not known
#define PD_NGUESS      0x10000000      // nguess valid
#define PD_VARGUESS    0x20000000      // nguess variable, set to minimum!=0
#define PD_NPUSH       0x40000000      // npush valid
#define PD_VARPUSH     0x80000000      // npush valid, set to maximum
// Argument prediction-related types (used in t_predict).
#define PR_PUSHBP      0x00010000      // PUSH EBP or ENTER executed
#define PR_MOVBPSP     0x00020000      // MOV EBP,ESP or ENTER executed
#define PR_SETSEH      0x00040000      // Structured exception handler set
#define PR_RETISJMP    0x00100000      // Return is (mis)used as a jump
#define PR_DIFFRET     0x00200000      // Return changed, destination unknown
#define PR_JMPTORET    0x00400000      // Jump to original return address
#define PR_TAMPERRET   0x00800000      // Retaddr on stack accessed or modified
#define PR_BADESP      0x01000000      // ESP of actual generation is invalid
#define PR_RET         0x02000000      // Return from subroutine
#define PR_STEPINTO    0x10000000      // Step into CALL command
// Breakpoint-related types (used in t_bpoint, t_bpmem and t_bphard).
#define BP_BASE        0x0000F000      // Mask to extract basic breakpoint type
#define   BP_MANUAL    0x00001000      // Permanent breakpoint
#define   BP_ONESHOT   0x00002000      // Stop and reset this bit
#define   BP_TEMP      0x00004000      // Reset this bit and continue
#define   BP_TRACE     0x00008000      // Used for hit trace
#define BP_SET         0x00010000      // Code INT3 is in memory, cmd is valid
#define BP_DISABLED    0x00020000      // Permanent breakpoint is disabled
#define BP_COND        0x00040000      // Conditional breakpoint
#define BP_PERIODICAL  0x00080000      // Periodical (pauses each passcount)
#define BP_ACCESSMASK  0x00E00000      // Access conditions (memory+hard)
#define   BP_READ      0x00200000      // Break on read memory access
#define   BP_WRITE     0x00400000      // Break on write memory access
#define   BP_EXEC      0x00800000      // Break on code execution
#define BP_BREAKMASK   0x03000000      // When to pause execution
#define   BP_NOBREAK   0x00000000      // No pause
#define   BP_CONDBREAK 0x01000000      // Pause if condition is true
#define   BP_BREAK     0x03000000      // Pause always
#define BP_LOGMASK     0x0C000000      // When to log value of expression
#define   BP_NOLOG     0x00000000      // Don't log expression
#define   BP_CONDLOG   0x04000000      // Log expression if condition is true
#define   BP_LOG       0x0C000000      // Log expression always
#define BP_ARGMASK     0x30000000      // When to log arguments of a function
#define   BP_NOARG     0x00000000      // Don't log arguments
#define   BP_CONDARG   0x10000000      // Log arguments if condition is true
#define   BP_ARG       0x30000000      // Log arguments always
#define BP_RETMASK     0xC0000000      // When to log return value of a function
#define   BP_NORET     0x00000000      // Don't log return value
#define   BP_CONDRET   0x40000000      // Log return value if condition is true
#define   BP_RET       0xC0000000      // Log return value always
#define BP_MANMASK (BP_PERIODICAL|BP_BREAKMASK|BP_LOGMASK|BP_ARGMASK|BP_RETMASK)
#define BP_CONFIRM     TY_CONFIRMED    // Internal OllyDbg use
// Search-related types (used in t_search).
#define SE_ORIGIN      0x00010000      // Search origin
#define SE_STRING      0x00020000      // Data contains string address
#define SE_FLOAT       0x00040000      // Data contains floating constant
#define SE_GUID        0x00080000      // Data contains GUID
#define SE_CONST       0x01000000      // Constant, not referencing command
// Source-related types (used in t_source).
#define SRC_ABSENT     0x00010000      // Source file is absent
// Namelist-related types (used in t_namelist).
#define NL_EORD        0x00010000      // Associated export ordinal available
#define NL_IORD        0x00020000      // Associated import ordinal available

typedef struct t_sorthdr {             // Header of sorted data item
  ulong          addr;                 // Base address of the entry
  ulong          size;                 // Size of the entry
  ulong          type;                 // Type and address extension, TY_xxx
} t_sorthdr;

typedef struct t_sorthdr_nosize {      // Header of SDM_NOSIZE item
  ulong          addr;                 // Base address of the entry
} t_sorthdr_nosize;

typedef int  SORTFUNC(const t_sorthdr *,const t_sorthdr *,const int);
typedef void DESTFUNC(t_sorthdr *);

#define AUTOARRANGE    ((SORTFUNC *)1) // Autoarrangeable sorted data

#define NBLOCK         2048            // Max number of data blocks
#define BLOCKSIZE      1048576         // Size of single data block, bytes

typedef struct t_sorted {              // Descriptor of sorted data
  int            n;                    // Actual number of entries
  int            nmax;                 // Maximal number of entries
  ulong          itemsize;             // Size of single entry
  int            mode;                 // Storage mode, set of SDM_xxx
  void           *data;                // Sorted data, NULL if SDM_INDEXED
  void           **block;              // NBLOCK sorted data blocks, or NULL
  int            nblock;               // Number of allocated blocks
  ulong          version;              // Changes on each modification
  void           **dataptr;            // Pointers to data, sorted by address
  int            selected;             // Index of selected entry
  ulong          seladdr;              // Base address of selected entry
  ulong          selsubaddr;           // Subaddress of selected entry
  SORTFUNC       *sortfunc;            // Function which sorts data or NULL
  DESTFUNC       *destfunc;            // Destructor function or NULL
  int            sort;                 // Sorting criterium (column)
  int            sorted;               // Whether indexes are sorted
  int            *sortindex;           // Indexes, sorted by criterium
} t_sorted;

stdapi (void)    Destroysorteddata(t_sorted *sd);
stdapi (int)     Createsorteddata(t_sorted *sd,ulong itemsize,int nexp,
                   SORTFUNC *sortfunc,DESTFUNC *destfunc,int mode);
stdapi (void)    Deletesorteddata(t_sorted *sd,ulong addr,ulong subaddr);
stdapi (int)     Deletesorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (void *)  Addsorteddata(t_sorted *sd,void *item);
stdapi (int)     Replacesorteddatarange(t_sorted *sd,void *data,int n,
                   ulong addr0,ulong addr1);
stdapi (void)    Renumeratesorteddata(t_sorted *sd);
stdapi (int)     Confirmsorteddata(t_sorted *sd,int confirm);
stdapi (int)     Deletenonconfirmedsorteddata(t_sorted *sd);
stdapi (void)    Unmarknewsorteddata(t_sorted *sd);
stdapi (void *)  Findsorteddata(t_sorted *sd,ulong addr,ulong subaddr);
stdapi (void *)  Findsorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (int)     Findsortedindexrange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (void *)  Getsortedbyindex(t_sorted *sd,int index);
stdapi (int)     Sortsorteddata(t_sorted *sd,int sort);
stdapi (void *)  Getsortedbyselection(t_sorted *sd,int index);
stdapi (int)     Issortedinit(t_sorted *sd);


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SORTED DATA WINDOWS (TABLES) /////////////////////////

#define NBAR           17              // Max allowed number of segments in bar

#define BAR_FLAT       0x00000000      // Flat segment
#define BAR_BUTTON     0x00000001      // Segment sends WM_USER_BAR
#define BAR_SORT       0x00000002      // Segment re-sorts sorted data
#define BAR_DISABLED   0x00000004      // Bar segment disabled
#define BAR_NORESIZE   0x00000008      // Bar column cannot be resized
#define BAR_SHIFTSEL   0x00000010      // Selection shifted 1/2 char to left
#define BAR_WIDEFONT   0x00000020      // Twice as wide characters
#define BAR_SEP        0x00000040      // Treat '|' as separator
#define BAR_ARROWS     0x00000080      // Arrows if segment is shifted
#define BAR_PRESSED    0x00000100      // Bar segment pressed, used internally
#define BAR_SPMASK     0x0000F000      // Mask to extract speech type
#define   BAR_SPSTD    0x00000000      // Standard speech with all conversions
#define   BAR_SPASM    0x00001000      // Disassembler-oriented speech
#define   BAR_SPEXPR   0x00002000      // Expression-oriented speech
#define   BAR_SPEXACT  0x00003000      // Pass to speech engine as is
#define   BAR_SPELL    0x00004000      // Text, spell symbol by symbol
#define   BAR_SPHEX    0x00005000      // Hexadecimal, spell symbol by symbol
#define   BAR_SPNONE   0x0000F000      // Column is excluded from speech

typedef struct t_bar {                 // Descriptor of columns in table window
  // These variables must be filled before table window is created.
  int            nbar;                 // Number of columns
  int            visible;              // Bar visible
  wchar_t        *name[NBAR];          // Column names (may be NULL)
  wchar_t        *expl[NBAR];          // Explanations of columns
  int            mode[NBAR];           // Combination of bits BAR_xxx
  int            defdx[NBAR];          // Default widths of columns, chars
  // These variables are initialized by window creation function.
  int            dx[NBAR];             // Actual widths of columns, pixels
  int            captured;             // One of CAPT_xxx
  int            active;               // Info about where mouse was captured
  int            scrollvx;             // X scrolling speed
  int            scrollvy;             // Y scrolling speed
  int            prevx;                // Previous X mouse coordinate
  int            prevy;                // Previous Y mouse coordinate
} t_bar;

#define TABLE_USERDEF  0x00000001      // User-drawn table
#define TABLE_STDSCR   0x00000002      // User-drawn but standard scrolling
#define TABLE_SIMPLE   0x00000004      // Non-sorted, address is line number
#define TABLE_DIR      0x00000008      // Bottom-to-top table
#define TABLE_COLSEL   0x00000010      // Column-wide selection
#define TABLE_BYTE     0x00000020      // Allows for bytewise scrolling
#define TABLE_FASTSEL  0x00000040      // Update when selection changes
#define TABLE_RIGHTSEL 0x00000080      // Right click can select items
#define TABLE_RFOCUS   0x00000100      // Right click sets focus
#define TABLE_NOHSCR   0x00000200      // Table contains no horizontal scroll
#define TABLE_NOVSCR   0x00000400      // Table contains no vertical scroll
#define TABLE_NOBAR    0x00000800      // Bar is always hidden
#define TABLE_STATUS   0x00001000      // Table contains status bar
#define TABLE_MMOVX    0x00002000      // Table is moveable by mouse in X
#define TABLE_MMOVY    0x00004000      // Table is moveable by mouse in Y
#define TABLE_WANTCHAR 0x00008000      // Table processes characters
#define TABLE_SAVEAPP  0x00010000      // Save appearance to .ini
#define TABLE_SAVEPOS  0x00020000      // Save position to .ini
#define TABLE_SAVECOL  0x00040000      // Save width of columns to .ini
#define TABLE_SAVESORT 0x00080000      // Save sort criterium to .ini
#define TABLE_SAVECUST 0x00100000      // Save table-specific data to .ini
#define TABLE_GRAYTEXT 0x00200000      // Text in table is grayed
#define TABLE_NOGRAY   0x00400000      // Text in pane is never grayed
#define TABLE_UPDFOCUS 0x00800000      // Update frame pane on focus change
#define TABLE_AUTOUPD  0x01000000      // Table allows periodical autoupdate
#define TABLE_SYNTAX   0x02000000      // Table allows syntax highlighting
#define TABLE_PROPWID  0x04000000      // Column width means proportional width
#define TABLE_INFRAME  0x10000000      // Table belongs to the frame window
#define TABLE_BORDER   0x20000000      // Table has sunken border
#define TABLE_KEEPOFFS 0x80000000      // Keep xshift, offset, colsel

#define TABLE_MOUSEMV  (TABLE_MMOVX|TABLE_MMOVY)
#define TABLE_SAVEALL (TABLE_SAVEAPP|TABLE_SAVEPOS|TABLE_SAVECOL|TABLE_SAVESORT)

#define DRAW_COLOR     0x0000001F      // Mask to extract colour/bkgnd index
// Direct colour/background pairs.
#define   DRAW_NORMAL  0x00000000      // Normal text
#define   DRAW_HILITE  0x00000001      // Highlighted text
#define   DRAW_GRAY    0x00000002      // Grayed text
#define   DRAW_EIP     0x00000003      // Actual EIP
#define   DRAW_BREAK   0x00000004      // Unconditional breakpoint
#define   DRAW_COND    0x00000005      // Conditional breakpoint
#define   DRAW_BDIS    0x00000006      // Disabled breakpoint
#define   DRAW_IPBREAK 0x00000007      // Breakpoint at actual EIP
#define   DRAW_AUX     0x00000008      // Auxiliary colours
#define   DRAW_SELUL   0x00000009      // Selection and underlining
// Indirect pairs used to highlight commands.
#define   DRAW_PLAIN   0x0000000C      // Plain commands
#define   DRAW_JUMP    0x0000000D      // Unconditional jump commands
#define   DRAW_CJMP    0x0000000E      // Conditional jump commands
#define   DRAW_PUSHPOP 0x0000000F      // PUSH/POP commands
#define   DRAW_CALL    0x00000010      // CALL commands
#define   DRAW_RET     0x00000011      // RET commands
#define   DRAW_FPU     0x00000012      // FPU, MMX, 3DNow! and SSE commands
#define   DRAW_SUSPECT 0x00000013      // Bad, system and privileged commands
#define   DRAW_FILL    0x00000014      // Filling commands
#define   DRAW_MOD     0x00000015      // Modified commands
// Indirect pairs used to highlight operands.
#define   DRAW_IREG    0x00000018      // General purpose registers
#define   DRAW_FREG    0x00000019      // FPU, MMX and SSE registers
#define   DRAW_SYSREG  0x0000001A      // Segment and system registers
#define   DRAW_STKMEM  0x0000001B      // Memory accessed over ESP or EBP
#define   DRAW_MEM     0x0000001C      // Any other memory
#define   DRAW_MCONST  0x0000001D      // Constant pointing to memory
#define   DRAW_CONST   0x0000001E      // Any other constant
#define DRAW_APP       0x00000060      // Mask to extract appearance
#define   DRAW_TEXT    0x00000000      // Plain text
#define   DRAW_ULTEXT  0x00000020      // Underlined text
#define   DRAW_GRAPH   0x00000060      // Graphics (text consists of G_xxx)
#define DRAW_SELECT    0x00000080      // Use selection background
#define DRAW_MASK      0x00000100      // Mask in use
#define DRAW_VARWIDTH  0x00000200      // Variable width possible
#define DRAW_EXTSEL    0x00000800      // Extend mask till end of column
#define DRAW_TOP       0x00001000      // Draw upper half of the two-line text
#define DRAW_BOTTOM    0x00002000      // Draw lower half of the two-line text
#define DRAW_INACTIVE  0x00004000      // Gray everything except hilited text
#define DRAW_RAWDATA   0x00008000      // Don't convert glyphs and multibytes
#define DRAW_NEW       0x00010000      // Use highlighted foreground

typedef struct t_drawheader {          // Draw descriptor for TABLE_USERDEF
  int            line;                 // Line in window
  int            n;                    // Total number of visible lines
  ulong          nextaddr;             // First address on next line, or 0
  // Following elements can be freely used by drawing routine. They do not
  // change between calls within one table.
  ulong          addr;                 // Custom data
  uchar          s[TEXTLEN];           // Custom data
} t_drawheader;

// Constants used for scrolling and selection.
#define MOVETOP        0x8000          // Move selection to top of table
#define MOVEBOTTOM     0x7FFF          // Move selection to bottom of table

#define DF_CACHESIZE   (-4)            // Request for draw cache size
#define DF_FILLCACHE   (-3)            // Request to fill draw cache
#define DF_FREECACHE   (-2)            // Request to free cached resources
#define DF_NEWROW      (-1)            // Request to start new row in window

// Reasons why t_table.tableselfunc() was called.
#define TSC_KEY        1               // Keyboard key pressed
#define TSC_MOUSE      2               // Selection changed by mouse
#define TSC_CALL       3               // Call to selection move function

typedef long TABFUNC(struct t_table *,HWND,UINT,WPARAM,LPARAM);
typedef int  UPDATEFUNC(struct t_table *);
typedef int  DRAWFUNC(wchar_t *,uchar *,int *,struct t_table *,
  t_sorthdr *,int,void *);
typedef void TABSELFUNC(struct t_table *,int,int);

typedef struct t_table {               // Window with sorted data and bar
  // These variables must be filled before table window is created.
  wchar_t        name[SHORTNAME];      // Name used to save/restore position
  int            mode;                 // Combination of bits TABLE_xxx
  t_sorted       sorted;               // Sorted data
  int            subtype;              // User-defined subtype
  t_bar          bar;                  // Description of bar
  int            bottomspace;          // Height of free space on the bottom
  int            minwidth;             // Minimal width of the table, pixels
  TABFUNC        *tabfunc;             // Custom message function or NULL
  UPDATEFUNC     *updatefunc;          // Data update function or NULL
  DRAWFUNC       *drawfunc;            // Drawing function
  TABSELFUNC     *tableselfunc;        // Callback indicating selection change
  t_menu         *menu;                // Menu descriptor
  // Table functions neither initialize nor use these variables.
  ulong          custommode;           // User-defined custom data
  void           *customdata;          // Pointer to more custom data
  // These variables are initialized and/or used by table functions.
  HWND           hparent;              // Handle of MDI container or NULL
  HWND           hstatus;              // Handle of status bar or NULL
  HWND           hw;                   // Handle of child table or NULL
  HWND           htooltip;             // Handle of tooltip window or NULL
  int            font;                 // Index of font used by window
  int            scheme;               // Colour scheme used by window
  int            hilite;               // Highlighting scheme used by window
  int            hscroll;              // Whether horizontal scroll visible
  int            xshift;               // Shift in X direction, pixels
  int            offset;               // First displayed row
  int            colsel;               // Column in TABLE_COLSEL window
  ulong          version;              // Version of sorted on last update
  ulong          timerdraw;            // Timer redraw is active (period, ms)
  RECT           rcprev;               // Temporary storage for old position
  int            rtback;               // Back step in run trace, 0 - actual
} t_table;

#define GWL_USR_TABLE  0               // Offset to pointer to t_table

// Custom messages.
#define WM_USER_CREATE (WM_USER+100)   // Table window is created
#define WM_USER_HSCR   (WM_USER+101)   // Update horizontal scroll
#define WM_USER_VSCR   (WM_USER+102)   // Update vertical scroll
#define WM_USER_MOUSE  (WM_USER+103)   // Mouse moves, set custom cursor
#define WM_USER_VINC   (WM_USER+104)   // Scroll contents of window by lines
#define WM_USER_VPOS   (WM_USER+105)   // Scroll contents of window by position
#define WM_USER_VBYTE  (WM_USER+106)   // Scroll contents of window by bytes
#define WM_USER_SETS   (WM_USER+107)   // Start selection in window
#define WM_USER_CNTS   (WM_USER+108)   // Continue selection in window
#define WM_USER_MMOV   (WM_USER+109)   // Move window's contents by mouse
#define WM_USER_MOVS   (WM_USER+110)   // Keyboard scrolling and selection
#define WM_USER_KEY    (WM_USER+111)   // Key pressed
#define WM_USER_BAR    (WM_USER+112)   // Message from bar segment as button
#define WM_USER_DBLCLK (WM_USER+113)   // Doubleclick in column
#define WM_USER_SELXY  (WM_USER+114)   // Get coordinates of selection
#define WM_USER_FOCUS  (WM_USER+115)   // Set focus to child of frame window
#define WM_USER_UPD    (WM_USER+116)   // Autoupdate contents of the window
#define WM_USER_MTAB   (WM_USER+117)   // Middle click on tab in tab parent
// Custom broadcasts and notifications.
#define WM_USER_CHGALL (WM_USER+132)   // Update all windows
#define WM_USER_CHGCPU (WM_USER+133)   // CPU thread has changed
#define WM_USER_CHGMEM (WM_USER+134)   // List of memory blocks has changed
#define WM_USER_BKUP   (WM_USER+135)   // Global backup is changed
#define WM_USER_FILE   (WM_USER+136)   // Query for file dump
#define WM_USER_NAMES  (WM_USER+137)   // Query for namelist window
#define WM_USER_SAVE   (WM_USER+138)   // Query for unsaved data
#define WM_USER_CLEAN  (WM_USER+139)   // End of process, close related windows
#define WM_USER_HERE   (WM_USER+140)   // Query for windows to restore
#define WM_USER_CLOSE  (WM_USER+141)   // Internal substitute for WM_CLOSE

#define KEY_ALT        0x04            // Alt key pressed
#define KEY_CTRL       0x02            // Ctrl key pressed
#define KEY_SHIFT      0x01            // Shift key pressed

// Control alignment modes for Createtablechild().
#define ALIGN_MASK     0xC000          // Mask to extract control alignment
#define   ALIGN_LEFT   0x0000          // Control doesn't move
#define   ALIGN_RIGHT  0x4000          // Control moves with right border
#define   ALIGN_WIDTH  0x8000          // Control resizes with right border
#define ALIGN_IDMASK   0x0FFF          // Mask to extract control ID

stdapi (void)    Processwmmousewheel(HWND hw,WPARAM wp);
stdapi (int)     Getcharacterwidth(t_table *pt,int column);
stdapi (void)    Defaultbar(t_table *pt);
stdapi (int)     Linecount(t_table *pt);
stdapi (int)     Gettabletext(t_table *pt,int row,int column,
                   wchar_t *text,uchar *tmask,int *tselect);
stdapi (int)     Gettableselectionxy(t_table *pt,int column,POINT *coord);
stdapi (int)     Maketableareavisible(t_table *pt,int column,
                   int x0,int y0,int x1,int y1);
stdapi (int)     Movetableselection(t_table *pt,int n);
stdapi (int)     Settableselection(t_table *pt,int selected);
stdapi (int)     Removetableselection(t_table *pt);
stdapi (void)    Updatetable(t_table *pt,int force);
stdapi (void)    Delayedtableredraw(t_table *pt);
stdapi (void)    Setautoupdate(t_table *pt,int autoupdate);
stdapi (HGLOBAL) Copytableselection(t_table *pt,int column);
stdapi (HGLOBAL) Copywholetable(t_table *pt,int compatible);
stdapi (HWND)    Createottablewindow(HWND hparent,t_table *pt,RECT *rpos);
stdapi (HWND)    Createtablewindow(t_table *pt,int nrow,int ncolumn,
                   HINSTANCE hi,wchar_t *icon,wchar_t *title);
stdapi (HWND)    Activatetablewindow(t_table *pt);
stdapi (HWND)    Createtablechild(t_table *pt,wchar_t *classname,wchar_t *name,
                   wchar_t *help,ulong style,int x,int y,int dx,int dy,
                   int idalign);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// FRAME AND TAB WINDOWS /////////////////////////////

#define BLK_NONE       0               // Mouse outside the dividing line
#define BLK_HDIV       1               // Divide horizontally
#define BLK_VDIV       2               // Divide vertically
#define BLK_TABLE      3               // Leaf that describes table window

typedef struct t_block {               // Block descriptor
  int            index;                // Index of pos record in the .ini file
  int            type;                 // One of BLK_xxx
  int            percent;              // Percent of block in left/top subblock
  int            offset;               // Offset of dividing line, pixels
  struct t_block *blk1;                // Top/left subblock, NULL if leaf
  int            minp1;                // Min size of 1st subblock, pixels
  int            maxc1;                // Max size of 1st subblock, chars, or 0
  struct t_block *blk2;                // Bottom/right subblock, NULL if leaf
  int            minp2;                // Min size of 2nd subblock, pixels
  int            maxc2;                // Max size of 2nd subblock, chars, or 0
  t_table        *table;               // Descriptor of table window
  wchar_t        tabname[SHORTNAME];   // Tab (tab window only)
  wchar_t        title[TEXTLEN];       // Title (tab window) or speech name
  wchar_t        status[TEXTLEN];      // Status (tab window only)
} t_block;

typedef struct t_frame {               // Descriptor of frame or tab window
  // These variables must be filled before frame window is created.
  wchar_t        name[SHORTNAME];      // Name used to save/restore position
  int            herebit;              // Must be 0 for plugins
  int            mode;                 // Combination of bits TABLE_xxx
  t_block        *block;               // Pointer to block tree
  t_menu         *menu;                // Menu descriptor (tab window only)
  int            scheme;               // Colour scheme used by window
  // These variables are initialized by frame creation function.
  HWND           hw;                   // Handle of MDI container or NULL
  HWND           htab;                 // Handle of tab control
  WNDPROC        htabwndproc;          // Original WndProc of tab control
  int            capturedtab;          // Tab captured on middle mouse click
  HWND           hstatus;              // Handle of status bar or NULL
  t_block        *active;              // Active table (has focus) or NULL
  t_block        *captured;            // Block that captured mouse or NULL
  int            captureoffset;        // Offset on mouse capture
  int            capturex;             // Mouse screen X coordinate on capture
  int            capturey;             // Mouse screen Y coordinate on capture
  wchar_t        title[TEXTLEN];       // Frame or tab window title
} t_frame;

stdapi (HWND)    Createframewindow(t_frame *pf,wchar_t *icon,wchar_t *title);
stdapi (void)    Updateframe(t_frame *pf,int redrawnow);
stdapi (t_table *) Getactiveframe(t_frame *pf);

stdapi (int)     Updatetabs(t_frame *pf);
stdapi (HWND)    Createtabwindow(t_frame *pf,wchar_t *icon,wchar_t *title);
stdapi (t_table *) Getactivetab(t_frame *pf);
stdapi (int)     Gettabcount(t_frame *pf,int *index);
stdapi (int)     Setactivetab(t_frame *pf,int index);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// FONTS AND GRAPHICS //////////////////////////////

#define FIXEDFONT      0               // Indices of fixed fonts used in tables
#define TERMINAL6      1               // Note: fonts may be changed by user!
#define FIXEDSYS       2
#define COURIERFONT    3
#define LUCIDACONS     4
#define FONT5          5
#define FONT6          6
#define FONT7          7

#define NFIXFONTS      8               // Total number of fixed fonts

#define BLACKWHITE     0               // Colour schemes used by OllyDbg
#define BLUEGOLD       1               // Note: colours may be changed by user!
#define SKYWIND        2
#define NIGHTSTARS     3
#define SCHEME4        4
#define SCHEME5        5
#define SCHEME6        6
#define SCHEME7        7

#define NSCHEMES       8               // Number of predefined colour schemes
#define NDRAW          32              // Number of fg/bg pairs in scheme

#define NOHILITE       0               // Highlighting schemes used by OllyDbg
#define XMASHILITE     1               // Note: colours may be changed by user!
#define JUMPHILITE     2
#define MEMHILITE      3
#define HILITE4        4
#define HILITE5        5
#define HILITE6        6
#define HILITE7        7

#define NHILITE        8               // Number of predefined hilite schemes

#define BLACK          0               // Indexes of colours used by OllyDbg
#define BLUE           1
#define GREEN          2
#define CYAN           3
#define RED            4
#define MAGENTA        5
#define BROWN          6
#define LIGHTGRAY      7
#define DARKGRAY       8
#define LIGHTBLUE      9
#define LIGHTGREEN     10
#define LIGHTCYAN      11
#define LIGHTRED       12
#define LIGHTMAGENTA   13
#define YELLOW         14
#define WHITE          15
#define MINT           16
#define SKYBLUE        17
#define IVORY          18
#define GRAY           19

#define NFIXCOLORS     20              // Number of colors fixed in OllyDbg
#define NCOLORS        (NFIXCOLORS+16) // Number of available colours

// Symbolic names for graphical characters. Any other graphical symbol is
// interpreted as a space. Use only symbols in range [0x01..0x3F], high bits
// are reserved for the future!
#define G_SPACE        0x01            // Space
#define G_SEP          0x02            // Thin separating line
#define G_POINT        0x03            // Point
#define G_BIGPOINT     0x04            // Big point
#define G_JMPDEST      0x05            // Jump destination
#define G_CALLDEST     0x06            // Call destination
#define G_QUESTION     0x07            // Question mark
#define G_JMPUP        0x10            // Jump upstairs
#define G_JMPOUT       0x11            // Jump to same location or outside
#define G_JMPDN        0x12            // Jump downstairs
#define G_SWUP         0x13            // Switch upstairs
#define G_SWBOTH       0x14            // Switch in both directions
#define G_SWDOWN       0x15            // Switch down
#define G_BEGIN        0x18            // Begin of procedure or scope
#define G_BODY         0x19            // Body of procedure or scope
#define G_ENTRY        0x1A            // Loop entry point
#define G_LEAF         0x1B            // Intermediate leaf on a tree
#define G_END          0x1C            // End of procedure or scope
#define G_SINGLE       0x1D            // Single-line scope
#define G_ENDBEG       0x1E            // End and begin of stack scope
#define G_PATHUP       0x21            // Jump path start upstairs
#define G_PATH         0x22            // Jump path through
#define G_PATHDN       0x23            // Jump path start downstairs
#define G_PATHUPDN     0x24            // Two-sided jump path start
#define G_THROUGHUP    0x25            // Jump entry upstairs
#define G_THROUGHDN    0x26            // Jump entry downstairs
#define G_PATHUPEND    0x27            // End of path upstairs
#define G_PATHDNEND    0x28            // End of path downstairs
#define G_PATHBIEND    0x29            // Two-sided end of path
#define G_THRUUPEND    0x2A            // Intermediate end upstairs
#define G_THRUDNEND    0x2B            // Intermediate end downstairs
#define G_ARRLEFT      0x2C            // Left arrow
// Graphical elements used to draw frames in the command help.
#define G_HL           0x30            // Horizontal line
#define G_LT           0x31            // Left top corner
#define G_CT           0x32            // Central top element
#define G_RT           0x33            // Right top corner
#define G_LM           0x34            // Left middle element
#define G_CM           0x35            // Central cross
#define G_RM           0x36            // Right middle element
#define G_LB           0x37            // Left bottom corner
#define G_CB           0x38            // Central bottom element
#define G_RB           0x39            // Right bottom corner
#define G_VL           0x3A            // Vertical line
#define G_LA           0x3B            // Horizontal line with left arrow
#define G_RA           0x3C            // Horizontal line with right arrow
#define G_DA           0x3D            // Vertical line with down arrow

typedef struct t_font {                // Font descriptor
  LOGFONT        logfont;              // System font description
  int            stockindex;           // Index for system stock fonts
  int            hadjtop;              // Height adjustment on top, pixels
  int            hadjbot;              // Height adjustment on bottom, pixels
  wchar_t        name[TEXTLEN];        // Internal font name
  HFONT          hfont;                // Font handle
  int            isstock;              // Don't destroy hfont, taken from stock
  int            isfullunicode;        // Whether UNICODE is fully supported
  int            width;                // Average font width
  int            height;               // Font height
} t_font;

typedef struct t_scheme {              // Descriptor of colour scheme
  wchar_t        name[TEXTLEN];        // Internal scheme name
  COLORREF       textcolor[NDRAW];     // Foreground colours (in DRAW_COLOR)
  COLORREF       bkcolor[NDRAW];       // Background colours (in DRAW_COLOR)
  int            hiliteoperands;       // Used only by highlighting schemes
  int            hilitemodified;       // Used only by highlighting schemes
  HBRUSH         bkbrush;              // Ordinary background brush
  HBRUSH         selbkbrush;           // Selected background brush
  HBRUSH         auxbrush;             // Auxiliary brush
  HPEN           graphpen;             // Pen for normal graphical elements
  HPEN           lopen;                // Pen for grayed graphical elements
  HPEN           hipen;                // Pen for hilited graphical elements
  HPEN           auxpen;               // Pen for auxiliary graphical elements
  HPEN           ulpen;                // Pen to underline text
} t_scheme;

stdapi (int)     Getmonitorrect(int x,int y,RECT *rc);
stdapi (void)    Sunkenframe(HDC dc,RECT *rc,int flags);
stdapi (int)     Findstockobject(ulong gdihandle,wchar_t *name,int nname);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MEMORY FUNCTIONS ///////////////////////////////

// Mode bits used in calls to Readmemory(), Readmemoryex() and Writememory().
#define MM_REPORT      0x0000          // Display error message if unreadable
#define MM_SILENT      0x0001          // Don't display error message
#define MM_NORESTORE   0x0002          // Don't remove/set INT3 breakpoints
#define MM_PARTIAL     0x0004          // Allow less data than requested
#define MM_WRITETHRU   0x0008          // Write immediately to memory
#define MM_REMOVEINT3  0x0010          // Writememory(): remove INT3 breaks
#define MM_ADJUSTINT3  0x0020          // Writememory(): adjust INT3 breaks
#define MM_FAILGUARD   0x0040          // Fail if memory is guarded
// Mode bits used in calls to Readmemoryex().
#define MM_BPMASK      BP_ACCESSMASK   // Mask to extract memory breakpoints
#define   MM_BPREAD    BP_READ         // Fail if memory break on read is set
#define   MM_BPWRITE   BP_WRITE        // Fail if memory break on write is set
#define   MM_BPEXEC    BP_EXEC         // Fail if memory break on exec is set

// Special types of memory block.
#define MSP_NONE       0               // Not a special memory block
#define MSP_PEB        1               // Contains Process Environment Block
#define MSP_SHDATA     2               // Contains KUSER_SHARED_DATA
#define MSP_PROCPAR    3               // Contains Process Parameters
#define MSP_ENV        4               // Contains environment

typedef struct t_memory {              // Descriptor of memory block
  ulong          base;                 // Base address of memory block
  ulong          size;                 // Size of memory block
  ulong          type;                 // Service information, TY_xxx+MEM_xxx
  int            special;              // Extension of type, one of MSP_xxx
  ulong          owner;                // Address of owner of the memory
  ulong          initaccess;           // Initial read/write access
  ulong          access;               // Actual status and read/write access
  ulong          threadid;             // Block belongs to this thread or 0
  wchar_t        sectname[SHORTNAME];  // Null-terminated section name
  uchar          *copy;                // Copy used in CPU window or NULL
  uchar          *decode;              // Decoding information or NULL
} t_memory;

stdapi (void)    Flushmemorycache(void);
stdapi (ulong)   Readmemory(void *buf,ulong addr,ulong size,int mode);
stdapi (ulong)   Readmemoryex(void *buf,ulong addr,ulong size,int mode,
                   ulong threadid);
stdapi (ulong)   Writememory(const void *buf,ulong addr,ulong size,int mode);
stdapi (t_memory *) Findmemory(ulong addr);
stdapi (uchar *) Finddecode(ulong addr,ulong *psize);
stdapi (int)     Guardmemory(ulong base,ulong size,int guard);
stdapi (int)     Listmemory(void);
stdapi (HGLOBAL) Copymemoryhex(ulong addr,ulong size);
stdapi (int)     Pastememoryhex(ulong addr,ulong size,
                   int ensurebackup,int removeanalysis);
stdapi (int)     Editmemory(HWND hparent,ulong addr,ulong size,
                   int ensurebackup,int removeanalysis,int x,int y,int font);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// JUMP DATA ///////////////////////////////////

// Types of recognized jumps and calls.
#define JT_TYPE        0x000F          // Mask to extract data type
#define   JT_UNDEF     0x0000          // End of jump table
#define   JT_JUMP      0x0001          // Unconditional jump
#define   JT_COND      0x0002          // Conditional jump
#define   JT_SWITCH    0x0003          // Jump via switch table
#define   JT_RET       0x0004          // RET misused as jump
#define   JT_CALL      0x0005          // Call
#define   JT_SWCALL    0x0006          // Call via switch table
#define   JT_NETJUMP   0x0008          // Unconditional jump in CIL code
#define   JT_NETCOND   0x0009          // Conditional jump in CIL code
#define   JT_NETSW     0x000A          // Switch jump in CIL code
// Used as flag to Addjump, absent in the jump table.
#define JT_NOSORT      0x8000          // Do not sort data implicitly

// Note that these macros work both with t_jmp and t_jmpcall.
#define Isjump(jmp)    (((jmp)->type>=JT_JUMP && (jmp)->type<=JT_RET) ||       \
                       ((jmp)->type>=JT_NETJUMP && (jmp)->type<=JT_NETSW))
#define Iscall(jmp)    ((jmp)->type==JT_CALL || (jmp)->type==JT_SWCALL)

typedef struct t_jmp {                 // Descriptor of recognized jump or call
  ulong          from;                 // Address of jump/call command
  ulong          dest;                 // Adress of jump/call destination
  uchar          type;                 // Jump/call type, one of JT_xxx
} t_jmp;

typedef struct t_exe {                 // Description of executable module
  ulong          base;                 // Module base
  ulong          size;                 // Module size
  int            adjusted;             // Whether base is already adjusted
  wchar_t        path[MAXPATH];        // Full module path
} t_exe;

typedef struct t_jmpdata {             // Jump table
  ulong          modbase;              // Base of module owning jump table
  ulong          modsize;              // Size of module owning jump table
  t_jmp          *jmpdata;             // Jump data, sorted by source
  int            *jmpindex;            // Indices to jmpdata, sorted by dest
  int            maxjmp;               // Total number of elements in arrays
  int            njmp;                 // Number of used elements in arrays
  int            nsorted;              // Number of sorted elements in arrays
  int            dontsort;             // Do not sort data implicitly
  t_exe          *exe;                 // Pointed modules, unsorted
  int            maxexe;               // Allocated number of elements in exe
  int            nexe;                 // Number of used elements in exe
} t_jmpdata;

typedef struct t_jmpcall {             // Descriptor of found jump or call
  ulong          addr;                 // Source or destination address
  union {
    int          type;                 // Jump/call type, one of JT_xxx
    ulong        swcase;               // First switch case
  };
} t_jmpcall;

stdapi (int)     Addjump(t_jmpdata *pdat,ulong from,ulong dest,int type);
stdapi (void)    Sortjumpdata(t_jmpdata *pdat);
stdapi (t_jmp *) Findjumpfrom(ulong from);
stdapi (int)     Findlocaljumpsto(ulong dest,ulong *buf,int nbuf);
stdapi (int)     Findlocaljumpscallsto(ulong dest,t_jmpcall *jmpcall,
                   int njmpcall);
stdapi (int)     Arelocaljumpscallstorange(ulong addr0,ulong addr1);
stdapi (int)     Findglobalcallsto(ulong dest,ulong *buf,int nbuf);
stdapi (int)     Findglobaljumpscallsto(ulong dest,t_jmpcall *jmpcall,
                   int njmpcall);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// SETS OF RANGES ////////////////////////////////

typedef struct t_range {
  ulong        rmin;                   // Low range limit
  ulong        rmax;                   // High range limit (INCLUDED!)
} t_range;

stdapi (int)     Initset(t_range *set,ulong nmax);
stdapi (int)     Fullrange(t_range *set);
stdapi (int)     Emptyrange(t_range *set);
stdapi (ulong)   Getsetcount(const t_range *set);
stdapi (int)     Getrangecount(const t_range *set);
stdapi (int)     Isinset(const t_range *set,ulong value);
stdapi (int)     Getrangebymember(const t_range *set,ulong value,
                   ulong *rmin,ulong *rmax);
stdapi (int)     Getrangebyindex(const t_range *set,int index,
                   ulong *rmin,ulong *rmax);
stdapi (int)     Addrange(t_range *set,ulong rmin,ulong rmax);
stdapi (int)     Removerange(t_range *set,ulong rmin,ulong rmax);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// NESTED DATA //////////////////////////////////

// General item types related to nested data.
#define ND_LEVELMASK   0x000000FF      // Mask to extract nesting level
#define ND_OPENTOP     0x00000100      // Range is open on the top
#define ND_OPENBOTTOM  0x00000200      // Range is open on the bottom
#define ND_NESTHILITE  0x00000400      // Highlighted bracket
#define ND_NESTGRAY    0x00000800      // Grayed bracket
// Types specific to loop data t_loopnest:
#define ND_MOREVARS    0x00010000      // List of loop variables overflowed

#define MAXNEST        32              // Limit of displayed nesting levels

typedef struct t_nesthdr {             // Header of nested data range
  ulong          addr0;                // First address occupied by range
  ulong          addr1;                // Last occupied address (included!)
  ulong          type;                 // Level and user-defined type, TY_xxx
  ulong          aprev;                // First address of previous range
} t_nesthdr;

typedef void NDDEST(t_nesthdr *);

typedef struct t_nested {              // Descriptor of nested data
  int            n;                    // Actual number of elements
  int            nmax;                 // Maximal number of elements
  ulong          itemsize;             // Size of single element
  void           *data;                // Ordered nested data
  ulong          version;              // Changes on each modification
  NDDEST         *destfunc;            // Destructor function or NULL
} t_nested;

stdapi (void)    Destroynesteddata(t_nested *nd);
stdapi (int)     Createnesteddata(t_nested *nd,ulong itemsize,int nexp,
                   NDDEST *destfunc);
stdapi (void *)  Addnesteddata(t_nested *nd,void *item);
stdapi (void)    Deletenestedrange(t_nested *nd,ulong addr0,ulong addr1);
stdapi (int)     Getnestingpattern(t_nested *nd,ulong addr,wchar_t *pat,
                   int npat,uchar *mask,int showentry,int *isend);
stdapi (int)     Getnestingdepth(t_nested *nd,ulong addr);
stdapi (void *)  Findnesteddata(t_nested *nd,ulong addr,int level);

stdapi (void *)  Nesteddatatoudd(t_nested *nd,ulong base,ulong *datasize);
stdapi (int)     Uddtonesteddata(t_nested *nd,void *data,ulong base,ulong size);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// MODULES ////////////////////////////////////

#define SHT_MERGENEXT  0x00000001      // Merge section with the next

#define NCALLMOD       24              // Max number of saved called modules

// .NET stream identifiers. Don't change the order and the values of the
// first three items (NS_STRINGS, NS_GUID and NS_BLOB)!
#define NS_STRINGS     0               // Stream with ASCII strings
#define NS_GUID        1               // Stream with GUIDs
#define NS_BLOB        2               // Data referenced by MetaData
#define NS_US          3               // Stream with UNICODE strings
#define NS_META        4               // Stream with MetaData tables

#define NETSTREAM      5               // Number of default .NET streams

// Indices of .NET MetaData tables.
#define MDT_MODULE     0               // Module table
#define MDT_TYPEREF    1               // TypeRef table
#define MDT_TYPEDEF    2               // TypeDef table
#define MDT_FIELDPTR   3               // FieldPtr table
#define MDT_FIELD      4               // Field table
#define MDT_METHODPTR  5               // MethodPtr table
#define MDT_METHOD     6               // MethodDef table
#define MDT_PARAMPTR   7               // ParamPtr table
#define MDT_PARAM      8               // Param table
#define MDT_INTERFACE  9               // InterfaceImpl table
#define MDT_MEMBERREF  10              // MemberRef table
#define MDT_CONSTANT   11              // Constant table
#define MDT_CUSTATTR   12              // CustomAttribute table
#define MDT_MARSHAL    13              // FieldMarshal table
#define MDT_DECLSEC    14              // DeclSecurity table
#define MDT_CLASSLAY   15              // ClassLayout table
#define MDT_FIELDLAY   16              // FieldLayout table
#define MDT_SIGNATURE  17              // StandAloneSig table
#define MDT_EVENTMAP   18              // EventMap table
#define MDT_EVENTPTR   19              // EventPtr table
#define MDT_EVENT      20              // Event table
#define MDT_PROPMAP    21              // PropertyMap table
#define MDT_PROPPTR    22              // PropertyPtr table
#define MDT_PROPERTY   23              // Property table
#define MDT_METHSEM    24              // MethodSemantics table
#define MDT_METHIMPL   25              // MethodImpl table
#define MDT_MODREF     26              // ModuleRef table
#define MDT_TYPESPEC   27              // TypeSpec table
#define MDT_IMPLMAP    28              // ImplMap table
#define MDT_RVA        29              // FieldRVA table
#define MDT_ENCLOG     30              // ENCLog table
#define MDT_ENCMAP     31              // ENCMap table
#define MDT_ASSEMBLY   32              // Assembly table
#define MDT_ASMPROC    33              // AssemblyProcessor table
#define MDT_ASMOS      34              // AssemblyOS table
#define MDT_ASMREF     35              // AssemblyRef table
#define MDT_REFPROC    36              // AssemblyRefProcessor table
#define MDT_REFOS      37              // AssemblyRefOS table
#define MDT_FILE       38              // File table
#define MDT_EXPORT     39              // ExportedType table
#define MDT_RESOURCE   40              // ManifestResource table
#define MDT_NESTED     41              // NestedClass table
#define MDT_GENPARM    42              // GenericParam table
#define MDT_METHSPEC   43              // MethodSpec table
#define MDT_CONSTR     44              // GenericParamConstraint table
#define MDT_UNUSED     63              // Used only in midx[]

#define MDTCOUNT       64              // Number of .NET MetaData tables

typedef struct t_secthdr {             // Extract from IMAGE_SECTION_HEADER
  wchar_t        sectname[12];         // Null-terminated section name
  ulong          base;                 // Address of section in memory
  ulong          size;                 // Size of section loaded into memory
  ulong          type;                 // Set of SHT_xxx
  ulong          fileoffset;           // Offset of section in file
  ulong          rawsize;              // Size of section in file
  ulong          characteristics;      // Set of IMAGE_SCN_xxx
} t_secthdr;

typedef struct t_premod {              // Preliminary module descriptor
  ulong          base;                 // Base address of the module
  ulong          size;                 // Size of module or 1
  ulong          type;                 // Service information, TY_xxx+MOD_xxx
  ulong          entry;                // Address of <ModuleEntryPoint> or 0
  wchar_t        path[MAXPATH];        // Full name of the module
} t_premod;

typedef struct t_netstream {           // Location of default .NET stream
  ulong          base;                 // Base address in memory
  ulong          size;                 // Stream size, bytes
} t_netstream;

typedef struct t_metadata {            // Descriptor of .NET MetaData table
  ulong          base;                 // Location in memory or NULL if absent
  ulong          rowcount;             // Number of rows or 0 if absent
  ulong          rowsize;              // Size of single row, bytes, or 0
  ushort         nameoffs;             // Offset of name field
  ushort         namesize;             // Size of name or 0 if absent
} t_metadata;

typedef struct t_module {              // Descriptor of executable module
  ulong          base;                 // Base address of module
  ulong          size;                 // Size of memory occupied by module
  ulong          type;                 // Service information, TY_xxx+MOD_xxx
  wchar_t        modname[SHORTNAME];   // Short name of the module
  wchar_t        path[MAXPATH];        // Full name of the module
  wchar_t        version[TEXTLEN];     // Version of executable file
  ulong          fixupbase;            // Base of image in executable file
  ulong          codebase;             // Base address of module code block
  ulong          codesize;             // Size of module code block
  ulong          entry;                // Address of <ModuleEntryPoint> or 0
  ulong          sfxentry;             // Address of SFX-packed entry or 0
  ulong          winmain;              // Address of WinMain or 0
  ulong          database;             // Base address of module data block
  ulong          edatabase;            // Base address of export data table
  ulong          edatasize;            // Size of export data table
  ulong          idatatable;           // Base address of import data table
  ulong          iatbase;              // Base of Import Address Table
  ulong          iatsize;              // Size of IAT
  ulong          relocbase;            // Base address of relocation table
  ulong          relocsize;            // Size of relocation table
  ulong          resbase;              // Base address of resources
  ulong          ressize;              // Size of resources
  ulong          tlsbase;              // Base address of TLS directory table
  ulong          tlssize;              // Size of TLS directory table
  ulong          tlscallback;          // Address of first TLS callback or 0
  ulong          netentry;             // .NET entry (MOD_NETAPP only)
  ulong          clibase;              // .NET CLI header base (MOD_NETAPP)
  ulong          clisize;              // .NET CLI header base (MOD_NETAPP)
  t_netstream    netstr[NETSTREAM];    // Locations of default .NET streams
  t_metadata     metadata[MDTCOUNT];   // Descriptors of .NET MetaData tables
  ulong          sfxbase;              // Base of memory block with SFX
  ulong          sfxsize;              // Size of memory block with SFX
  ulong          rawhdrsize;           // Size of PE header in file
  ulong          memhdrsize;           // Size of PE header in memory
  int            nsect;                // Number of sections in the module
  t_secthdr      *sect;                // Extract from section headers
  int            nfixup;               // Number of 32-bit fixups
  ulong          *fixup;               // Array of 32-bit fixups
  t_jmpdata      jumps;                // Jumps and calls from this module
  t_nested       loopnest;             // Loop brackets
  t_nested       argnest;              // Call argument brackets
  t_simple       predict;              // Predicted ESP, EBP & results (sd_pred)
  t_sorted       strings;              // Resource strings (t_string)
  int            saveudd;              // UDD-relevant data is changed
  int            ncallmod;             // No. of called modules (max. NCALLMOD)
  wchar_t        callmod[NCALLMOD][SHORTNAME]; // List of called modules
} t_module;

// Keep t_aqueue identical with the header of t_module!
typedef struct t_aqueue {              // Descriptor of module to be analysed
  ulong          base;                 // Base address of module
  ulong          size;                 // Size of memory occupied by module
  ulong          type;                 // Service information, TY_xxx+MOD_xxx
} t_aqueue;

stdapi (t_module *) Findmodule(ulong addr);
stdapi (t_module *) Findmodulebyname(wchar_t *shortname);
stdapi (t_module *) Findmainmodule(void);
stdapi (int)     Issystem(ulong addr);
stdapi (ulong *) Findfixup(t_module *pmod,ulong addr);
stdapi (ulong)   Findfileoffset(t_module *pmod,ulong addr);
stdapi (int)     Decoderange(wchar_t *s,ulong addr,ulong size);
stdapi (int)     Getexeversion(wchar_t *path,wchar_t *version);
stdapi (int)     Getexportfrommemory(ulong addr,wchar_t *s);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// LIST OF DEBUGGEE'S WINDOWS //////////////////////////

typedef struct t_window {              // Description of window
  ulong          hwnd;                 // Window's handle
  ulong          dummy;                // Must be 1
  ulong          type;                 // Type of window, TY_xxx+WN_xxx
  ulong          parenthw;             // Handle of parent or 0
  ulong          winproc;              // Address of WinProc or 0
  ulong          threadid;             // ID of the owning thread
  ulong          exstyle;              // Extended style
  ulong          style;                // Style
  ulong          id;                   // Identifier
  ulong          classproc;            // Address of default (class) WinProc
  RECT           windowrect;           // Window position, screen coordinates
  RECT           clientrect;           // Client position, screen coordinates
  int            child;                // Index of next child
  int            sibling;              // Index of next sibling
  int            byparent;             // Index when sorted by parent
  int            level;                // Level in genealogy (0: topmost)
  wchar_t        title[TEXTLEN];       // Window's title or text
  wchar_t        classname[TEXTLEN];   // Class name
  wchar_t        tree[MAXNEST];        // Tree display
} t_window;


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// NAMELIST WINDOWS ///////////////////////////////

// Types of action in WM_USER_NAMES broadcasts (parameter wp).
#define NA_FIND        0               // Check if namelist is already open
#define NA_UPDATE      1               // Update namelist
#define NA_CLOSE       2               // Close namelist
#define NA_CLOSEALL    3               // Close all namelists

typedef struct t_namecast {            // Structure passed on broadcast
  ulong          base;                 // Module base, 0 - list of all names
  t_table        *table;               // Filled when broadcast stops
} t_namecast;

typedef struct t_namelist {            // Element of namelist sorted data
  ulong          addr;                 // Base address of the entry
  ulong          size;                 // Size of the entry, always 1
  ulong          type;                 // Type & addr extension, TY_xxx+NL_xxx
} t_namelist;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// RESOURCES ///////////////////////////////////

typedef struct t_string {              // Descriptor of resource string
  ulong          id;                   // Identifier associated with the string
  ulong          dummy;                // Always 1
  ulong          addr;                 // Address of string in memory
  ulong          count;                // String size, UNICODE characters!
  int            language;             // Language, one of LANG_xxx
} t_string;

stdapi (int)     Getmodulestring(t_module *pm,ulong id,wchar_t *s);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// UDD FILES ///////////////////////////////////

#define SAVEMAGIC      0xFEDCBA98      // Indicator of savearea validity

// Attention, for the sake of the compatibility between the different OllyDbg
// versions, never, ever change existing elements, only add new!
typedef struct t_savearea {
  ulong          magic;                // Validity marker, must be SAVEMAGIC
  wchar_t        dumpstr[SHORTNAME];   // Last structure decoding in dump
} t_savearea;


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// THREADS AND REGISTERS /////////////////////////////

#define NREG           8               // Number of registers (of any type)
#define NSEG           6               // Number of valid segment registers
#define NHARD          4               // Number of hardware breakpoints

// Event ignoring list.
#define IGNO_INT3      0x00000001      // Ignore INT3 breakpoint
#define IGNO_ACCESS    0x00000002      // Ignore memory access violation
#define IGNO_HW        0x00000004      // Ignore hardware breakpoint

// Register displaying mode.
#define RDM_MODE       0x0000000F      // Mask to extract display mode
#define   RDM_FPU      0x00000000      // Decode FPU registers as floats
#define   RDM_MMX      0x00000001      // Decode FPU registers as MMX
#define   RDM_3DN      0x00000002      // Decode FPU registers as 3DNow!
#define   RDM_DBG      0x00000003      // Decode debug registers instead of FPU
#define RDM_SSEMODE    0x000000F0      // Mask to extract SSE decoding mode
#define   RDM_SSEI32   0x00000000      // Decode SSE as 4x32-bit hex numbers
#define   RDM_SSEF32   0x00000010      // Decode SSE as 4x32-bit floats
#define   RDM_SSEF64   0x00000020      // Decode SSE as 2x64-bit floats

// Status of registers.
#define RV_MODIFIED    0x00000001      // Update CONTEXT before run
#define RV_USERMOD     0x00000002      // Registers modified by user
#define RV_SSEVALID    0x00000004      // Whether SSE registers are valid
#define RV_SSEMOD      0x00000008      // Update SSE registers before run
#define RV_ERRVALID    0x00000010      // Whether last thread error is valid
#define RV_ERRMOD      0x00000020      // Update last thread error before run
#define RV_MEMVALID    0x00000040      // Whether memory fields are valid
#define RV_DBGMOD      0x00000080      // Update debugging registers before run

// CPU flags.
#define FLAG_C         0x00000001      // Carry flag
#define FLAG_P         0x00000004      // Parity flag
#define FLAG_A         0x00000010      // Auxiliary carry flag
#define FLAG_Z         0x00000040      // Zero flag
#define FLAG_S         0x00000080      // Sign flag
#define FLAG_T         0x00000100      // Single-step trap flag
#define FLAG_D         0x00000400      // Direction flag
#define FLAG_O         0x00000800      // Overflow flag

// Attention, number of memory fields is limited by the run trace!
#define NMEMFIELD      2               // Number of memory fields in t_reg

typedef struct t_memfield {            // Descriptor of memory field
  ulong          addr;                 // Address of data in memory
  ulong          size;                 // Data size (0 - no data)
  uchar          data[16];             // Data
} t_memfield;

// Thread registers.
typedef struct t_reg {                 // Excerpt from context
  ulong          status;               // Status of registers, set of RV_xxx
  ulong          threadid;             // ID of thread that owns registers
  ulong          ip;                   // Instruction pointer (EIP)
  ulong          r[NREG];              // EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
  ulong          flags;                // Flags
  ulong          s[NSEG];              // Segment registers ES,CS,SS,DS,FS,GS
  ulong          base[NSEG];           // Segment bases
  ulong          limit[NSEG];          // Segment limits
  uchar          big[NSEG];            // Default size (0-16, 1-32 bit)
  uchar          dummy[2];             // Reserved, used for data alignment
  int            top;                  // Index of top-of-stack
  long double    f[NREG];              // Float registers, f[top] - top of stack
  uchar          tag[NREG];            // Float tags (0x3 - empty register)
  ulong          fst;                  // FPU status word
  ulong          fcw;                  // FPU control word
  ulong          ferrseg;              // Selector of last detected FPU error
  ulong          feroffs;              // Offset of last detected FPU error
  ulong          dr[NREG];             // Debug registers
  ulong          lasterror;            // Last thread error or 0xFFFFFFFF
  uchar          ssereg[NREG][16];     // SSE registers
  ulong          mxcsr;                // SSE control and status register
  t_memfield     mem[NMEMFIELD];       // Known memory fields from run trace
} t_reg;

typedef struct t_thread {              // Information about active threads
  ulong          threadid;             // Thread identifier
  ulong          dummy;                // Always 1
  ulong          type;                 // Service information, TY_xxx+THR_xxx
  int            ordinal;              // Thread's ordinal number (1-based)
  wchar_t        name[SHORTNAME];      // Short name of the thread
  HANDLE         thread;               // Thread handle, for OllyDbg only!
  ulong          tib;                  // Thread Information Block
  ulong          entry;                // Thread entry point
  CONTEXT        context;              // Actual context of the thread
  t_reg          reg;                  // Actual contents of registers
  int            regvalid;             // Whether reg and context are valid
  t_reg          oldreg;               // Previous contents of registers
  int            oldregvalid;          // Whether oldreg is valid
  int            suspendrun;           // Suspended for run (0 or 1)
  int            suspendcount;         // Temporarily suspended (0..inf)
  int            suspenduser;          // Suspended by user (0 or 1)
  int            trapset;              // Single-step trap set by OllyDbg
  int            trapincontext;        // Trap is catched in exception context
  ulong          rtprotocoladdr;       // Address of destination to protocol
  int            ignoreonce;           // Ignore list, IGNO_xxx
  int            drvalid;              // Contents of dr is valid
  ulong          dr[NREG];             // Expected state of DR0..3,7
  int            hwmasked;             // Temporarily masked hardware breaks
  int            hwreported;           // Reported breakpoint expressions
  // Thread-related information gathered by Updatethreaddata().
  HWND           hw;                   // One of windows owned by thread
  ulong          usertime;             // Time in user mode, 100u units or -1
  ulong          systime;              // Time in system mode, 100u units or -1
  // Thread-related information gathered by Listmemory().
  ulong          stacktop;             // Top of thread's stack
  ulong          stackbottom;          // Bottom of thread's stack
} t_thread;

stdapi (t_thread *) Findthread(ulong threadid);
stdapi (t_thread *) Findthreadbyordinal(int ordinal);
stdapi (t_reg *) Threadregisters(ulong threadid);
stdapi (int)     Decodethreadname(wchar_t *s,ulong threadid,int mode);
stdapi (void)    Registermodifiedbyuser(t_thread *pthr);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// ASSEMBLER AND DISASSEMBLER //////////////////////////

#define MAXCMDSIZE     16              // Maximal length of valid 80x86 command
#define MAXSEQSIZE     256             // Maximal length of command sequence
#define INT3           0xCC            // Code of 1-byte INT3 breakpoint
#define NOP            0x90            // Code of 1-byte NOP command
#define NOPERAND       4               // Maximal allowed number of operands
#define NEGLIMIT       (-16384)        // Limit to decode offsets as negative
#define DECLIMIT       65536           // Limit to decode integers as decimal

// Registers.
#define REG_UNDEF      (-1)            // Codes of general purpose registers
#define REG_EAX        0
#define REG_ECX        1
#define REG_EDX        2
#define REG_EBX        3
#define REG_ESP        4
#define REG_EBP        5
#define REG_ESI        6
#define REG_EDI        7

#define REG_BYTE       0x80            // Flag used in switch analysis

#define REG_AL         0               // Symbolic indices of 8-bit registers
#define REG_CL         1
#define REG_DL         2
#define REG_BL         3
#define REG_AH         4
#define REG_CH         5
#define REG_DH         6
#define REG_BH         7

#define SEG_UNDEF      (-1)            // Codes of segment/selector registers
#define SEG_ES         0
#define SEG_CS         1
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5

// Pseudoregisters, used in search for assembler commands.
#define REG_R8         NREG            // 8-bit pseudoregister R8
#define REG_R16        NREG            // 16-bit pseudoregister R16
#define REG_R32        NREG            // 32-bit pseudoregister R32
#define REG_ANY        NREG            // Pseudoregister FPUREG, MMXREG etc.
#define SEG_ANY        NREG            // Segment pseudoregister SEG
#define REG_RA         (NREG+1)        // 32-bit semi-defined pseudoregister RA
#define REG_RB         (NREG+2)        // 32-bit semi-defined pseudoregister RB

#define NPSEUDO        (NREG+3)        // Total count of resisters & pseudoregs

#define IS_REAL(r)     ((r)<REG_R32)   // Checks for real register
#define IS_PSEUDO(r)   ((r)>=REG_R32)  // Checks for pseudoregister (undefined)
#define IS_SEMI(r)     ((r)>=REG_RA)   // Checks for semi-defined register

#define D_NONE         0x00000000      // No special features
// General type of command, only one is allowed.
#define D_CMDTYPE      0x0000001F      // Mask to extract type of command
#define   D_CMD        0x00000000      // Ordinary (none of listed below)
#define   D_MOV        0x00000001      // Move to or from integer register
#define   D_MOVC       0x00000002      // Conditional move to integer register
#define   D_SETC       0x00000003      // Conditional set integer register
#define   D_TEST       0x00000004      // Used to test data (CMP, TEST, AND...)
#define   D_STRING     0x00000005      // String command with REPxxx prefix
#define   D_JMP        0x00000006      // Unconditional near jump
#define   D_JMPFAR     0x00000007      // Unconditional far jump
#define   D_JMC        0x00000008      // Conditional jump on flags
#define   D_JMCX       0x00000009      // Conditional jump on (E)CX (and flags)
#define   D_PUSH       0x0000000A      // PUSH exactly 1 (d)word of data
#define   D_POP        0x0000000B      // POP exactly 1 (d)word of data
#define   D_CALL       0x0000000C      // Plain near call
#define   D_CALLFAR    0x0000000D      // Far call
#define   D_INT        0x0000000E      // Interrupt
#define   D_RET        0x0000000F      // Plain near return from call
#define   D_RETFAR     0x00000010      // Far return or IRET
#define   D_FPU        0x00000011      // FPU command
#define   D_MMX        0x00000012      // MMX instruction, incl. SSE extensions
#define   D_3DNOW      0x00000013      // 3DNow! instruction
#define   D_SSE        0x00000014      // SSE, SSE2, SSE3 etc. instruction
#define   D_IO         0x00000015      // Accesses I/O ports
#define   D_SYS        0x00000016      // Legal but useful in system code only
#define   D_PRIVILEGED 0x00000017      // Privileged (non-Ring3) command
#define   D_DATA       0x0000001C      // Data recognized by Analyser
#define   D_PSEUDO     0x0000001D      // Pseudocommand, for search models only
#define   D_PREFIX     0x0000001E      // Standalone prefix
#define   D_BAD        0x0000001F      // Bad or unrecognized command
// Additional parts of the command.
#define D_SIZE01       0x00000020      // Bit 0x01 in last cmd is data size
#define D_POSTBYTE     0x00000040      // Command continues in postbyte
// For string commands, either long or short form can be selected.
#define D_LONGFORM     0x00000080      // Long form of string command
// Decoding of some commands depends on data or address size.
#define D_SIZEMASK     0x00000F00      // Mask for data/address size dependence
#define   D_DATA16     0x00000100      // Requires 16-bit data size
#define   D_DATA32     0x00000200      // Requires 32-bit data size
#define   D_ADDR16     0x00000400      // Requires 16-bit address size
#define   D_ADDR32     0x00000800      // Requires 32-bit address size
// Prefixes that command may, must or must not possess.
#define D_MUSTMASK     0x0000F000      // Mask for fixed set of prefixes
#define   D_NOMUST     0x00000000      // No obligatory prefixes (default)
#define   D_MUST66     0x00001000      // (SSE) Requires 66, no F2 or F3
#define   D_MUSTF2     0x00002000      // (SSE) Requires F2, no 66 or F3
#define   D_MUSTF3     0x00003000      // (SSE) Requires F3, no 66 or F2
#define   D_MUSTNONE   0x00004000      // (MMX,SSE) Requires no 66, F2 or F3
#define   D_NEEDF2     0x00005000      // (SSE) Requires F2, no F3
#define   D_NEEDF3     0x00006000      // (SSE) Requires F3, no F2
#define   D_NOREP      0x00007000      // Must not include F2 or F3
#define   D_MUSTREP    0x00008000      // Must include F3 (REP)
#define   D_MUSTREPE   0x00009000      // Must include F3 (REPE)
#define   D_MUSTREPNE  0x0000A000      // Must include F2 (REPNE)
#define D_LOCKABLE     0x00010000      // Allows for F0 (LOCK, memory only)
#define D_BHINT        0x00020000      // Allows for branch hints (2E, 3E)
// Decoding of some commands with ModRM-SIB depends whether register or memory.
#define D_MEMORY       0x00040000      // Mod field must indicate memory
#define D_REGISTER     0x00080000      // Mod field must indicate register
// Side effects caused by command.
#define D_FLAGMASK     0x00700000      // Mask to extract modified flags
#define   D_NOFLAGS    0x00000000      // Flags S,Z,P,O,C remain unchanged
#define   D_ALLFLAGS   0x00100000      // Modifies flags S,Z,P,O,C
#define   D_FLAGZ      0x00200000      // Modifies flag Z only
#define   D_FLAGC      0x00300000      // Modifies flag C only
#define   D_FLAGSCO    0x00400000      // Modifies flag C and O only
#define   D_FLAGD      0x00500000      // Modifies flag D only
#define   D_FLAGSZPC   0x00600000      // Modifies flags Z, P and C only (FPU)
#define   D_NOCFLAG    0x00700000      // S,Z,P,O modified, C unaffected
#define D_FPUMASK      0x01800000      // Mask for effects on FPU stack
#define   D_FPUSAME    0x00000000      // Doesn't rotate FPU stack (default)
#define   D_FPUPOP     0x00800000      // Pops FPU stack
#define   D_FPUPOP2    0x01000000      // Pops FPU stack twice
#define   D_FPUPUSH    0x01800000      // Pushes FPU stack
#define D_CHGESP       0x02000000      // Command indirectly modifies ESP
// Command features.
#define D_HLADIR       0x04000000      // Nonstandard order of operands in HLA
#define D_WILDCARD     0x08000000      // Mnemonics contains W/D wildcard ('*')
#define D_COND         0x10000000      // Conditional (action depends on flags)
#define D_USESCARRY    0x20000000      // Uses Carry flag
#define D_USEMASK      0xC0000000      // Mask to detect unusual commands
#define   D_RARE       0x40000000      // Rare or obsolete in Win32 apps
#define   D_SUSPICIOUS 0x80000000      // Suspicious command
#define   D_UNDOC      0xC0000000      // Undocumented command

// Extension of D_xxx.
#define DX_ZEROMASK    0x00000003      // How to decode FLAGS.Z flag
#define   DX_JE        0x00000001      // JE, JNE instead of JZ, JNZ
#define   DX_JZ        0x00000002      // JZ, JNZ instead of JE, JNE
#define DX_CARRYMASK   0x0000000C      // How to decode FLAGS.C flag
#define   DX_JB        0x00000004      // JAE, JB instead of JC, JNC
#define   DX_JC        0x00000008      // JC, JNC instead of JAE, JB
#define DX_WONKYTRAP   0x00000100      // Don't single-step this command

// Type of operand, only one is allowed.
#define B_ARGMASK      0x000000FF      // Mask to extract type of argument
#define   B_NONE       0x00000000      // Operand absent
#define   B_AL         0x00000001      // Register AL
#define   B_AH         0x00000002      // Register AH
#define   B_AX         0x00000003      // Register AX
#define   B_CL         0x00000004      // Register CL
#define   B_CX         0x00000005      // Register CX
#define   B_DX         0x00000006      // Register DX
#define   B_DXPORT     0x00000007      // Register DX as I/O port address
#define   B_EAX        0x00000008      // Register EAX
#define   B_EBX        0x00000009      // Register EBX
#define   B_ECX        0x0000000A      // Register ECX
#define   B_EDX        0x0000000B      // Register EDX
#define   B_ACC        0x0000000C      // Accumulator (AL/AX/EAX)
#define   B_STRCNT     0x0000000D      // Register CX or ECX as REPxx counter
#define   B_DXEDX      0x0000000E      // Register DX or EDX in DIV/MUL
#define   B_BPEBP      0x0000000F      // Register BP or EBP in ENTER/LEAVE
#define   B_REG        0x00000010      // 8/16/32-bit register in Reg
#define   B_REG16      0x00000011      // 16-bit register in Reg
#define   B_REG32      0x00000012      // 32-bit register in Reg
#define   B_REGCMD     0x00000013      // 16/32-bit register in last cmd byte
#define   B_REGCMD8    0x00000014      // 8-bit register in last cmd byte
#define   B_ANYREG     0x00000015      // Reg field is unused, any allowed
#define   B_INT        0x00000016      // 8/16/32-bit register/memory in ModRM
#define   B_INT8       0x00000017      // 8-bit register/memory in ModRM
#define   B_INT16      0x00000018      // 16-bit register/memory in ModRM
#define   B_INT32      0x00000019      // 32-bit register/memory in ModRM
#define   B_INT1632    0x0000001A      // 16/32-bit register/memory in ModRM
#define   B_INT64      0x0000001B      // 64-bit integer in ModRM, memory only
#define   B_INT128     0x0000001C      // 128-bit integer in ModRM, memory only
#define   B_IMMINT     0x0000001D      // 8/16/32-bit int at immediate addr
#define   B_INTPAIR    0x0000001E      // Two signed 16/32 in ModRM, memory only
#define   B_SEGOFFS    0x0000001F      // 16:16/16:32 absolute address in memory
#define   B_STRDEST    0x00000020      // 8/16/32-bit string dest, [ES:(E)DI]
#define   B_STRDEST8   0x00000021      // 8-bit string destination, [ES:(E)DI]
#define   B_STRSRC     0x00000022      // 8/16/32-bit string source, [(E)SI]
#define   B_STRSRC8    0x00000023      // 8-bit string source, [(E)SI]
#define   B_XLATMEM    0x00000024      // 8-bit memory in XLAT, [(E)BX+AL]
#define   B_EAXMEM     0x00000025      // Reference to memory addressed by [EAX]
#define   B_LONGDATA   0x00000026      // Long data in ModRM, mem only
#define   B_ANYMEM     0x00000027      // Reference to memory, data unimportant
#define   B_STKTOP     0x00000028      // 16/32-bit int top of stack
#define   B_STKTOPFAR  0x00000029      // Top of stack (16:16/16:32 far addr)
#define   B_STKTOPEFL  0x0000002A      // 16/32-bit flags on top of stack
#define   B_STKTOPA    0x0000002B      // 16/32-bit top of stack all registers
#define   B_PUSH       0x0000002C      // 16/32-bit int push to stack
#define   B_PUSHRET    0x0000002D      // 16/32-bit push of return address
#define   B_PUSHRETF   0x0000002E      // 16:16/16:32-bit push of far retaddr
#define   B_PUSHA      0x0000002F      // 16/32-bit push all registers
#define   B_EBPMEM     0x00000030      // 16/32-bit int at [EBP]
#define   B_SEG        0x00000031      // Segment register in Reg
#define   B_SEGNOCS    0x00000032      // Segment register in Reg, but not CS
#define   B_SEGCS      0x00000033      // Segment register CS
#define   B_SEGDS      0x00000034      // Segment register DS
#define   B_SEGES      0x00000035      // Segment register ES
#define   B_SEGFS      0x00000036      // Segment register FS
#define   B_SEGGS      0x00000037      // Segment register GS
#define   B_SEGSS      0x00000038      // Segment register SS
#define   B_ST         0x00000039      // 80-bit FPU register in last cmd byte
#define   B_ST0        0x0000003A      // 80-bit FPU register ST0
#define   B_ST1        0x0000003B      // 80-bit FPU register ST1
#define   B_FLOAT32    0x0000003C      // 32-bit float in ModRM, memory only
#define   B_FLOAT64    0x0000003D      // 64-bit float in ModRM, memory only
#define   B_FLOAT80    0x0000003E      // 80-bit float in ModRM, memory only
#define   B_BCD        0x0000003F      // 80-bit BCD in ModRM, memory only
#define   B_MREG8x8    0x00000040      // MMX register as 8 8-bit integers
#define   B_MMX8x8     0x00000041      // MMX reg/memory as 8 8-bit integers
#define   B_MMX8x8DI   0x00000042      // MMX 8 8-bit integers at [DS:(E)DI]
#define   B_MREG16x4   0x00000043      // MMX register as 4 16-bit integers
#define   B_MMX16x4    0x00000044      // MMX reg/memory as 4 16-bit integers
#define   B_MREG32x2   0x00000045      // MMX register as 2 32-bit integers
#define   B_MMX32x2    0x00000046      // MMX reg/memory as 2 32-bit integers
#define   B_MREG64     0x00000047      // MMX register as 1 64-bit integer
#define   B_MMX64      0x00000048      // MMX reg/memory as 1 64-bit integer
#define   B_3DREG      0x00000049      // 3DNow! register as 2 32-bit floats
#define   B_3DNOW      0x0000004A      // 3DNow! reg/memory as 2 32-bit floats
#define   B_XMM0I32x4  0x0000004B      // XMM0 as 4 32-bit integers
#define   B_XMM0I64x2  0x0000004C      // XMM0 as 2 64-bit integers
#define   B_XMM0I8x16  0x0000004D      // XMM0 as 16 8-bit integers
#define   B_SREGF32x4  0x0000004E      // SSE register as 4 32-bit floats
#define   B_SREGF32L   0x0000004F      // Low 32-bit float in SSE register
#define   B_SREGF32x2L 0x00000050      // Low 2 32-bit floats in SSE register
#define   B_SSEF32x4   0x00000051      // SSE reg/memory as 4 32-bit floats
#define   B_SSEF32L    0x00000052      // Low 32-bit float in SSE reg/memory
#define   B_SSEF32x2L  0x00000053      // Low 2 32-bit floats in SSE reg/memory
#define   B_SREGF64x2  0x00000054      // SSE register as 2 64-bit floats
#define   B_SREGF64L   0x00000055      // Low 64-bit float in SSE register
#define   B_SSEF64x2   0x00000056      // SSE reg/memory as 2 64-bit floats
#define   B_SSEF64L    0x00000057      // Low 64-bit float in SSE reg/memory
#define   B_SREGI8x16  0x00000058      // SSE register as 16 8-bit sigints
#define   B_SSEI8x16   0x00000059      // SSE reg/memory as 16 8-bit sigints
#define   B_SSEI8x16DI 0x0000005A      // SSE 16 8-bit sigints at [DS:(E)DI]
#define   B_SSEI8x8L   0x0000005B      // Low 8 8-bit ints in SSE reg/memory
#define   B_SSEI8x4L   0x0000005C      // Low 4 8-bit ints in SSE reg/memory
#define   B_SSEI8x2L   0x0000005D      // Low 2 8-bit ints in SSE reg/memory
#define   B_SREGI16x8  0x0000005E      // SSE register as 8 16-bit sigints
#define   B_SSEI16x8   0x0000005F      // SSE reg/memory as 8 16-bit sigints
#define   B_SSEI16x4L  0x00000060      // Low 4 16-bit ints in SSE reg/memory
#define   B_SSEI16x2L  0x00000061      // Low 2 16-bit ints in SSE reg/memory
#define   B_SREGI32x4  0x00000062      // SSE register as 4 32-bit sigints
#define   B_SREGI32L   0x00000063      // Low 32-bit sigint in SSE register
#define   B_SREGI32x2L 0x00000064      // Low 2 32-bit sigints in SSE register
#define   B_SSEI32x4   0x00000065      // SSE reg/memory as 4 32-bit sigints
#define   B_SSEI32x2L  0x00000066      // Low 2 32-bit sigints in SSE reg/memory
#define   B_SREGI64x2  0x00000067      // SSE register as 2 64-bit sigints
#define   B_SSEI64x2   0x00000068      // SSE reg/memory as 2 64-bit sigints
#define   B_SREGI64L   0x00000069      // Low 64-bit sigint in SSE register
#define   B_EFL        0x0000006A      // Flags register EFL
#define   B_FLAGS8     0x0000006B      // Flags (low byte)
#define   B_OFFSET     0x0000006C      // 16/32 const offset from next command
#define   B_BYTEOFFS   0x0000006D      // 8-bit sxt const offset from next cmd
#define   B_FARCONST   0x0000006E      // 16:16/16:32 absolute address constant
#define   B_DESCR      0x0000006F      // 16:32 descriptor in ModRM
#define   B_1          0x00000070      // Immediate constant 1
#define   B_CONST8     0x00000071      // Immediate 8-bit constant
#define   B_CONST8_2   0x00000072      // Immediate 8-bit const, second in cmd
#define   B_CONST16    0x00000073      // Immediate 16-bit constant
#define   B_CONST      0x00000074      // Immediate 8/16/32-bit constant
#define   B_CONSTL     0x00000075      // Immediate 16/32-bit constant
#define   B_SXTCONST   0x00000076      // Immediate 8-bit sign-extended to size
#define   B_CR         0x00000077      // Control register in Reg
#define   B_CR0        0x00000078      // Control register CR0
#define   B_DR         0x00000079      // Debug register in Reg
// Type modifiers, used for interpretation of contents, only one is allowed.
#define B_MODMASK      0x000F0000      // Mask to extract type modifier
#define   B_NONSPEC    0x00000000      // Non-specific operand
#define   B_UNSIGNED   0x00010000      // Decode as unsigned decimal
#define   B_SIGNED     0x00020000      // Decode as signed decimal
#define   B_BINARY     0x00030000      // Decode as binary (full hex) data
#define   B_BITCNT     0x00040000      // Bit count
#define   B_SHIFTCNT   0x00050000      // Shift count
#define   B_COUNT      0x00060000      // General-purpose count
#define   B_NOADDR     0x00070000      // Not an address
#define   B_JMPCALL    0x00080000      // Near jump/call/return destination
#define   B_JMPCALLFAR 0x00090000      // Far jump/call/return destination
#define   B_STACKINC   0x000A0000      // Unsigned stack increment/decrement
#define   B_PORT       0x000B0000      // I/O port
// Validity markers.
#define B_MEMORY       0x00100000      // Memory only, reg version different
#define B_REGISTER     0x00200000      // Register only, mem version different
#define B_MEMONLY      0x00400000      // Warn if operand in register
#define B_REGONLY      0x00800000      // Warn if operand in memory
#define B_32BITONLY    0x01000000      // Warn if 16-bit operand
#define B_NOESP        0x02000000      // ESP is not allowed
// Miscellaneous options.
#define B_SHOWSIZE     0x08000000      // Always show argument size in disasm
#define B_CHG          0x10000000      // Changed, old contents is not used
#define B_UPD          0x20000000      // Modified using old contents
#define B_PSEUDO       0x40000000      // Pseoudooperand, not in assembler cmd
#define B_NOSEG        0x80000000      // Don't add offset of selector

// Analysis data. Note that DEC_PBODY==DEC_PROC|DEC_PEND; this allows for
// automatical merging of overlapping procedures. Also note that DEC_NET is
// followed, if necessary, by a sequence of DEC_NEXTDATA and not DEC_NEXTCODE!
#define DEC_TYPEMASK   0x1F            // Type of analyzed byte
#define   DEC_UNKNOWN  0x00            // Not analyzed, treat as command
#define   DEC_NEXTCODE 0x01            // Next byte of command
#define   DEC_NEXTDATA 0x02            // Next byte of data
#define   DEC_FILLDATA 0x03            // Not recognized, treat as byte data
#define   DEC_INT      0x04            // First byte of integer
#define   DEC_SWITCH   0x05            // First byte of switch item or count
#define   DEC_DATA     0x06            // First byte of integer data
#define   DEC_DB       0x07            // First byte of byte string
#define   DEC_DUMP     0x08            // First byte of byte string with dump
#define   DEC_ASCII    0x09            // First byte of ASCII string
#define   DEC_ASCCNT   0x0A            // Next chunk of ASCII string
#define   DEC_UNICODE  0x0B            // First byte of UNICODE string
#define   DEC_UNICNT   0x0C            // Next chunk of UNICODE string
#define   DEC_FLOAT    0x0D            // First byte of floating number
#define   DEC_GUID     0x10            // First byte of GUID
#define   DEC_NETCMD   0x18            // First byte of .NET (CIL) command
#define   DEC_JMPNET   0x19            // First byte of .NET at jump destination
#define   DEC_CALLNET  0x1A            // First byte of .NET at call destination
#define   DEC_COMMAND  0x1C            // First byte of ordinary command
#define   DEC_JMPDEST  0x1D            // First byte of cmd at jump destination
#define   DEC_CALLDEST 0x1E            // First byte of cmd at call destination
#define   DEC_FILLING  0x1F            // Command used to fill gaps
#define DEC_PROCMASK   0x60            // Procedure analysis
#define   DEC_NOPROC   0x00            // Outside the procedure
#define   DEC_PROC     0x20            // Start of procedure
#define   DEC_PEND     0x40            // End of procedure
#define   DEC_PBODY    0x60            // Body of procedure
#define DEC_TRACED     0x80            // Hit when traced

// Full type of predicted data.
#define PST_GENMASK    0xFFFFFC00      // Mask for ESP generation
#define   PST_GENINC   0x00000400      // Increment of ESP generation
#define PST_UNCERT     0x00000200      // Uncertain, probably modified by call
#define PST_NONSTACK   0x00000100      // Not a stack, internal use only
#define PST_REL        0x00000080      // Fixup/reladdr counter of constant
#define PST_BASE       0x0000007F      // Mask for basical description
#define   PST_SPEC     0x00000040      // Special contents, type in PST_GENMASK
#define   PST_VALID    0x00000020      // Contents valid
#define   PST_ADDR     0x00000010      // Contents is in memory
#define   PST_ORIG     0x00000008      // Based on reg contents at entry point
#define   PST_OMASK    0x00000007      // Mask to extract original register

// Types of special contents when PST_SPEC is set.
#define PSS_SPECMASK   PST_GENMASK     // Mask for type of special contents
#define   PSS_SEHPTR   0x00000400      // Pointer to SEH chain

#define NSTACK         12              // Number of predicted stack entries
#define NSTKMOD        24              // Max no. of predicted stack mod addr
#define NMEM           2               // Number of predicted memory locations

typedef struct t_modrm {               // ModRM decoding
  ulong          size;                 // Total size with SIB and disp, bytes
  struct t_modrm *psib;                // Pointer to SIB table or NULL
  ulong          dispsize;             // Size of displacement or 0 if none
  ulong          features;             // Operand features, set of OP_xxx
  int            reg;                  // Register index or REG_UNDEF
  int            defseg;               // Default selector (SEG_xxx)
  uchar          scale[NREG];          // Scales of registers in memory address
  ulong          aregs;                // List of registers used in address
  int            basereg;              // Register used as base or REG_UNDEF
  wchar_t        ardec[SHORTNAME];     // Register part of address, INTEL fmt
  wchar_t        aratt[SHORTNAME];     // Register part of address, AT&T fmt
} t_modrm;

typedef struct t_predict {             // Prediction of execution
  ulong          addr;                 // Predicted EIP or NULL if uncertain
  ulong          one;                  // Must be 1
  ulong          type;                 // Type, TY_xxx/PR_xxx
  ushort         flagsmeaning;         // Set of DX_ZEROMASK|DX_CARRYMASK
  ulong          rstate[NREG];         // State of register, set of PST_xxx
  ulong          rconst[NREG];         // Constant related to register
  ulong          jmpstate;             // State of EIP after jump or return
  ulong          jmpconst;             // Constant related to jump or return
  ulong          espatpushbp;          // Offset of ESP at PUSH EBP
  int            nstack;               // Number of valid stack entries
  struct {
    long         soffset;              // Offset of data on stack (signed!)
    ulong        sstate;               // State of stack data, set of PST_xxx
    ulong        sconst;               // Constant related to stack data
  } stack[NSTACK];
  int            nstkmod;              // Number of valid stkmod addresses
  ulong          stkmod[NSTKMOD];      // Addresses of stack modifications
  int            nmem;                 // Number of valid memory entries
  struct {
    ulong        maddr;                // Address of doubleword variable
    ulong        mstate;               // State of memory, set of PST_xxx
    ulong        mconst;               // Constant related to memory data
  } mem[NMEM];
  ulong          resstate;             // State of result of command execution
  ulong          resconst;             // Constant related to result
} t_predict;

typedef struct t_callpredict {         // Simplified prediction
  ulong          addr;                 // Predicted EIP or NULL if uncertain
  ulong          one;                  // Must be 1
  ulong          type;                 // Type of prediction, TY_xxx/PR_xxx
  ulong          eaxstate;             // State of EAX, set of PST_xxx
  ulong          eaxconst;             // Constant related to EAX
  int            nstkmod;              // Number of valid stkmod addresses
  ulong          stkmod[NSTKMOD];      // Addresses of stack modifications
  ulong          resstate;             // State of result of command execution
  ulong          resconst;             // Constant related to result
} t_callpredict;

// Location of operand, only one bit is allowed.
#define OP_SOMEREG     0x000000FF      // Mask for any kind of register
#define   OP_REGISTER  0x00000001      // Operand is a general-purpose register
#define   OP_SEGREG    0x00000002      // Operand is a segment register
#define   OP_FPUREG    0x00000004      // Operand is a FPU register
#define   OP_MMXREG    0x00000008      // Operand is a MMX register
#define   OP_3DNOWREG  0x00000010      // Operand is a 3DNow! register
#define   OP_SSEREG    0x00000020      // Operand is a SSE register
#define   OP_CREG      0x00000040      // Operand is a control register
#define   OP_DREG      0x00000080      // Operand is a debug register
#define OP_MEMORY      0x00000100      // Operand is in memory
#define OP_CONST       0x00000200      // Operand is an immediate constant
#define OP_PORT        0x00000400      // Operand is an I/O port
// Additional operand properties.
#define OP_INVALID     0x00001000      // Invalid operand, like reg in mem-only
#define OP_PSEUDO      0x00002000      // Pseudooperand (not in mnenonics)
#define OP_MOD         0x00004000      // Command may change/update operand
#define OP_MODREG      0x00008000      // Memory, but modifies reg (POP,MOVSD)
#define OP_REL         0x00010000      // Relative or fixuped const or address
#define OP_IMPORT      0x00020000      // Value imported from different module
#define OP_SELECTOR    0x00040000      // Includes immediate selector
// Additional properties of memory address.
#define OP_INDEXED     0x00080000      // Memory address contains registers
#define OP_OPCONST     0x00100000      // Memory address contains constant
#define OP_ADDR16      0x00200000      // 16-bit memory address
#define OP_ADDR32      0x00400000      // Explicit 32-bit memory address
// Value of operand.
#define OP_OFFSOK      0x00800000      // Offset to selector valid
#define OP_ADDROK      0x01000000      // Address valid
#define OP_VALUEOK     0x02000000      // Value (max. 16 bytes) valid
#define OP_PREDADDR    0x04000000      // Address predicted, not actual
#define OP_PREDVAL     0x08000000      // Value predicted, not actual
#define OP_RTLOGMEM    0x10000000      // Memory contents got from run trace
#define   OP_ACTVALID  0x20000000      // Actual value is valid
// Pseudooperands, used in assembler search models only.
#define OP_ANYMEM      0x40000000      // Any memory location
#define OP_ANY         0x80000000      // Any operand

typedef struct t_operand {             // Description of disassembled operand
  // Description of operand.
  ulong          features;             // Operand features, set of OP_xxx
  ulong          arg;                  // Operand type, set of B_xxx
  int            optype;               // DEC_INT, DEC_FLOAT or DEC_UNKNOWN
  int            opsize;               // Total size of data, bytes
  int            granularity;          // Size of element (opsize exc. MMX/SSE)
  int            reg;                  // REG_xxx (also ESP in POP) or REG_UNDEF
  ulong          uses;                 // List of used regs (not in address!)
  ulong          modifies;             // List of modified regs (not in addr!)
  // Description of memory address.
  int            seg;                  // Selector (SEG_xxx)
  uchar          scale[NREG];          // Scales of registers in memory address
  ulong          aregs;                // List of registers used in address
  ulong          opconst;              // Constant or const part of address
  // Value of operand.
  ulong          offset;               // Offset to selector (usually addr)
  ulong          selector;             // Immediate selector in far jump/call
  ulong          addr;                 // Address of operand in memory
  union {
    ulong        u;                    // Value of operand (integer form)
    signed long  s;                    // Value of operand (signed form)
    uchar        value[16]; };         // Value of operand (general form)
  uchar          actual[16];           // Actual memory (if OP_ACTVALID)
  // Textual decoding.
  wchar_t        text[TEXTLEN];        // Operand, decoded to text
  wchar_t        comment[TEXTLEN];     // Commented address and contents
} t_operand;

// Prefix list.
#define PF_SEGMASK     0x0000003F      // Mask for segment override prefixes
#define   PF_ES        0x00000001      // 0x26, ES segment override
#define   PF_CS        0x00000002      // 0x2E, CS segment override
#define   PF_SS        0x00000004      // 0x36, SS segment override
#define   PF_DS        0x00000008      // 0x3E, DS segment override
#define   PF_FS        0x00000010      // 0x64, FS segment override
#define   PF_GS        0x00000020      // 0x65, GS segment override
#define PF_DSIZE       0x00000040      // 0x66, data size override
#define PF_ASIZE       0x00000080      // 0x67, address size override
#define PF_LOCK        0x00000100      // 0xF0, bus lock
#define PF_REPMASK     0x00000600      // Mask for repeat prefixes
#define   PF_REPNE     0x00000200      // 0xF2, REPNE prefix
#define   PF_REP       0x00000400      // 0xF3, REP/REPE prefix
#define PF_BYTE        0x00000800      // Size bit in command, used in cmdexec
#define PF_MUSTMASK    D_MUSTMASK      // Necessary prefixes, used in t_asmmod
#define PF_66          PF_DSIZE        // Alternative names for SSE prefixes
#define PF_F2          PF_REPNE
#define PF_F3          PF_REP
#define PF_HINT        (PF_CS|PF_DS)   // Alternative names for branch hints
#define   PF_NOTTAKEN  PF_CS
#define   PF_TAKEN     PF_DS

// Disassembling errors.
#define DAE_NOERR      0x00000000      // No error
#define DAE_BADCMD     0x00000001      // Unrecognized command
#define DAE_CROSS      0x00000002      // Command crosses end of memory block
#define DAE_MEMORY     0x00000004      // Register where only memory allowed
#define DAE_REGISTER   0x00000008      // Memory where only register allowed
#define DAE_LOCK       0x00000010      // LOCK prefix is not allowed
#define DAE_BADSEG     0x00000020      // Invalid segment register
#define DAE_SAMEPREF   0x00000040      // Two prefixes from the same group
#define DAE_MANYPREF   0x00000080      // More than 4 prefixes
#define DAE_BADCR      0x00000100      // Invalid CR register
#define DAE_INTERN     0x00000200      // Internal error

// Disassembling warnings.
#define DAW_DATASIZE   0x00000001      // Superfluous data size prefix
#define DAW_ADDRSIZE   0x00000002      // Superfluous address size prefix
#define DAW_SEGPREFIX  0x00000004      // Superfluous segment override prefix
#define DAW_REPPREFIX  0x00000008      // Superfluous REPxx prefix
#define DAW_DEFSEG     0x00000010      // Segment prefix coincides with default
#define DAW_JMP16      0x00000020      // 16-bit jump, call or return
#define DAW_FARADDR    0x00000040      // Far jump or call
#define DAW_SEGMOD     0x00000080      // Modifies segment register
#define DAW_PRIV       0x00000100      // Privileged command
#define DAW_IO         0x00000200      // I/O command
#define DAW_SHIFT      0x00000400      // Shift out of range 1..31
#define DAW_LOCK       0x00000800      // Command with valid LOCK prefix
#define DAW_STACK      0x00001000      // Unaligned stack operation
#define DAW_NOESP      0x00002000      // Suspicious use of stack pointer
#define DAW_RARE       0x00004000      // Rare, seldom used command
#define DAW_NONCLASS   0x00008000      // Non-standard or non-documented code
#define DAW_INTERRUPT  0x00010000      // Interrupt command

// Conditions of conditional commands.
#define DAF_NOCOND     0x00000000      // Unconditional command
#define DAF_TRUE       0x00000001      // Condition is true
#define DAF_FALSE      0x00000002      // Condition is false
#define DAF_ANYCOND    0x00000003      // Condition is not predictable

typedef struct t_disasm {              // Disassembled command
  // In the case that DA_HILITE flag is set, fill these members before calling
  // Disasm(). Parameter hilitereg has priority over hiliteindex.
  ulong          hilitereg;            // One of OP_SOMEREG if reg highlighting
  int            hiregindex;           // Index of register to highlight
  int            hiliteindex;          // Index of highlighting scheme (0: none)
  // Starting from this point, no need to initialize the members of t_disasm.
  ulong          ip;                   // Address of first command byte
  ulong          size;                 // Full length of command, bytes
  ulong          cmdtype;              // Type of command, D_xxx
  ulong          exttype;              // More features, set of DX_xxx
  ulong          prefixes;             // List of prefixes, set of PF_xxx
  ulong          nprefix;              // Number of prefixes, including SSE2
  ulong          memfixup;             // Offset of first 4-byte fixup or -1
  ulong          immfixup;             // Offset of second 4-byte fixup or -1
  int            errors;               // Set of DAE_xxx
  int            warnings;             // Set of DAW_xxx
  // Note that used registers are those which contents is necessary to create
  // result. Modified registers are those which value is changed. For example,
  // command MOV EAX,[EBX+ECX] uses EBX and ECX and modifies EAX. Command
  // ADD ESI,EDI uses ESI and EDI and modifies ESI.
  ulong          uses;                 // List of used registers
  ulong          modifies;             // List of modified registers
  // Useful shortcuts.
  int            condition;            // Condition, one of DAF_xxx
  ulong          jmpaddr;              // Jump/call destination or 0
  ulong          memconst;             // Constant in memory address or 0
  ulong          stackinc;             // Data size in ENTER/RETN/RETF
  // Operands.
  t_operand      op[NOPERAND];         // Operands
  // Textual decoding.
  wchar_t        dump[TEXTLEN];        // Hex dump of the command
  wchar_t        result[TEXTLEN];      // Fully decoded command as text
  uchar          mask[TEXTLEN];        // Mask to highlight result
  int            maskvalid;            // Mask corresponds to result
  wchar_t        comment[TEXTLEN];     // Comment that applies to whole command
} t_disasm;

typedef struct t_opinfo {              // Operand in t_cmdinfo
  ulong          features;             // Operand features, set of OP_xxx
  ulong          arg;                  // Operand type, set of B_xxx
  int            opsize;               // Total size of data, bytes
  int            reg;                  // REG_xxx (also ESP in POP) or REG_UNDEF
  int            seg;                  // Selector (SEG_xxx)
  uchar          scale[NREG];          // Scales of registers in memory address
  ulong          opconst;              // Constant or const part of address
} t_opinfo;

typedef struct t_cmdinfo {             // Information on command
  ulong          ip;                   // Address of first command byte
  ulong          size;                 // Full length of command, bytes
  ulong          cmdtype;              // Type of command, D_xxx
  ulong          prefixes;             // List of prefixes, set of PF_xxx
  ulong          nprefix;              // Number of prefixes, including SSE2
  ulong          memfixup;             // Offset of first 4-byte fixup or -1
  ulong          immfixup;             // Offset of second 4-byte fixup or -1
  int            errors;               // Set of DAE_xxx
  ulong          jmpaddr;              // Jump/call destination or 0
  ulong          stackinc;             // Data size in ENTER/RETN/RETF
  t_opinfo       op[NOPERAND];         // Operands
} t_cmdinfo;

// ATTENTION, when making any changes to this structure, apply them to the
// file Cmdemul.asm, too!
typedef struct t_emu {                 // Parameters passed to emulation routine
  ulong          operand[NOPERAND];    // I/O: Operands
  ulong          opsize;               // IN:  Size of operands
  ulong          memaddr;              // OUT: Save address, or 0 if none
  ulong          memsize;              // OUT: Save size (1, 2 or 4 bytes)
  ulong          memdata;              // OUT: Data to save
} t_emu;

typedef void TRACEFUNC(ulong *,ulong *,t_predict *,t_disasm *);
typedef void __cdecl EMUFUNC(t_emu *,t_reg *);

typedef struct t_bincmd {              // Description of 80x86 command
  wchar_t        *name;                // Symbolic name for this command
  ulong          cmdtype;              // Command's features, set of D_xxx
  ulong          exttype;              // More features, set of DX_xxx
  ulong          length;               // Length of main code (before ModRM/SIB)
  ulong          mask;                 // Mask for first 4 bytes of the command
  ulong          code;                 // Compare masked bytes with this
  ulong          postbyte;             // Postbyte
  ulong          arg[NOPERAND];        // Types of arguments, set of B_xxx
  TRACEFUNC      *trace;               // Result prediction function
  EMUFUNC        *emu;                 // Command emulation function
} t_bincmd;

#define AMF_SAMEORDER  0x01            // Same order of index registers in addr
#define AMF_ANYSEG     0x02            // Command has undefined segment prefix
#define AMF_POSTBYTE   0x04            // Includes postbyte
#define AMF_IMPRECISE  0x08            // Command is imprecise (search only)
#define AMF_ANYSIZE    0x10            // Any operand size is acceptable
#define AMF_NOSMALL    0x20            // 16-bit address is not allowed
#define AMF_UNDOC      0x40            // Undocumented command
#define AMF_NEWCMD     0x80            // Marks new command in multiline

#define AMP_REGISTER   0x01            // Operand is a register
#define AMP_MEMORY     0x02            // Operand is a memory location
#define AMP_CONST      0x04            // Operand is a constant
#define AMP_IMPRECISE  0x08            // Constant is imprecise
#define AMP_ANYMEM     0x10            // Any memory operand is acceptable
#define AMP_ANYOP      0x20            // Any operand is acceptable

typedef struct t_modop {               // Operand in assembler model
  uchar          features;             // Operand features, set of AMP_xxx
  uchar          reg;                  // (Pseudo)register operand
  uchar          scale[NPSEUDO];       // Scales of (pseudo)registers in address
  ulong          opconst;              // Constant or const part of address
} t_modop;

// Assembler command model.
typedef struct t_asmmod {              // Description of assembled command
  uchar          code[MAXCMDSIZE];     // Binary code
  uchar          mask[MAXCMDSIZE];     // Mask for binary code (0: bit ignored)
  ulong          prefixes;             // List of prefixes, set of PF_xxx
  uchar          ncode;                // Length of code w/o prefixes, bytes
  uchar          features;             // Code features, set of AMF_xxx
  uchar          postbyte;             // Postbyte (if AMF_POSTBYTE set)
  uchar          noperand;             // Number of operands (no pseudooperands)
  t_modop        op[NOPERAND];         // Description of operands
} t_asmmod;

typedef struct t_asmlist {             // Descriptor of the sequence of models
  t_asmmod       *pasm;                // Pointer to the start of the sequence
  int            length;               // Length of the sequence, models
  wchar_t        comment[TEXTLEN];     // Comment to the sequence
} t_asmlist;

#define DA_TEXT        0x00000001      // Decode command to text and comment
#define   DA_HILITE    0x00000002      // Use syntax highlighting (set t_disasm)
#define DA_OPCOMM      0x00000004      // Comment operands
#define DA_DUMP        0x00000008      // Dump command to hexadecimal text
#define DA_MEMORY      0x00000010      // OK to read memory and use labels
#define   DA_NOIMPORT  0x00000020      // When reading memory, hold the imports
#define   DA_RTLOGMEM  0x00000040      // Use memory saved by run trace
#define   DA_NOSTACKP  0x00000080      // Hide "Stack" prefix in comments
#define DA_STEPINTO    0x00000100      // Enter CALL when predicting registers
#define DA_SHOWARG     0x00000200      // Use predict if address ESP/EBP-based
#define DA_NOPSEUDO    0x00000400      // Skip pseudooperands
#define DA_FORHELP     0x00000800      // Decode operands for command help

#define USEDECODE      ((uchar *)1)    // Request to get decoding automatically

stdapi (int)     Byteregtodwordreg(int bytereg);
stdapi (int)     Printfloat4(wchar_t *s,float f);
stdapi (int)     Printfloat8(wchar_t *s,double d);
stdapi (int)     Printfloat10(wchar_t *s,long double ext);
stdapi (int)     Printmmx(wchar_t *s,uchar *data);
stdapi (int)     Commentcharacter(wchar_t *s,int c,int mode);
stdapi (int)     Nameoffloat(wchar_t *s,uchar *data,ulong size);
stdapi (ulong)   Disasm(uchar *cmd,ulong cmdsize,ulong ip,uchar *dec,
                   t_disasm *da,int mode,t_reg *reg,
                   t_predict *predict);
stdapi (ulong)   Cmdinfo(uchar *cmd,ulong cmdsize,ulong cmdip,
                   t_cmdinfo *ci,int cmdmode,t_reg *cmdreg);
stdapi (ulong)   Disassembleforward(uchar *copy,ulong base,ulong size,
                   ulong ip,ulong n,uchar *decode);
stdapi (ulong)   Disassembleback(uchar *copy,ulong base,ulong size,
                   ulong ip,ulong n,uchar *decode);
stdapi (int)     Checkcondition(int code,ulong flags);
stdapi (ulong)   Setcondition(int code,ulong flags);

#define AM_ALLOWBAD    0x00000001      // Allow bad or undocumented commands
#define AM_IMPRECISE   0x00000002      // Generate imprecise (search) forms
#define   AM_MULTI     0x00000004      // Multiple commands are allowed

#define AM_SEARCH      AM_IMPRECISE

stdapi (int)     Assembleallforms(wchar_t *src,ulong ip,t_asmmod *model,
                   int maxmodel,int mode,wchar_t *errtxt);
stdapi (ulong)   Assemble(wchar_t *src,ulong ip,uchar *buf,ulong nbuf,int mode,
                   wchar_t *errtxt);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// .NET DISASSEMBLER ///////////////////////////////

// CIL command types.
#define N_CMDTYPE      0x0000001F      // Mask to extract type of command
#define   N_CMD        0x00000000      // Ordinary (none of listed below)
#define   N_JMP        0x00000001      // Unconditional jump
#define   N_JMC        0x00000002      // Conditional jump
#define   N_CALL       0x00000003      // Call
#define   N_RET        0x00000004      // Return (also from exception)
#define   N_SWITCH     0x00000005      // Switch, followed by N cases
#define   N_PREFIX     0x00000006      // Prefix, not a standalone command
#define   N_DATA       0x0000001E      // Command is decoded as data
#define   N_BAD        0x0000001F      // Bad command
#define N_POPMASK      0x00000F00      // Mask to extract number of pops
#define   N_POP0       0x00000000      // Pops no arguments (default)
#define   N_POP1       0x00000100      // Pops 1 argument from stack
#define   N_POP2       0x00000200      // Pops 2 arguments from stack
#define   N_POP3       0x00000300      // Pops 3 arguments from stack
#define   N_POPX       0x00000F00      // Pops variable arguments from stack
#define N_PUSHMASK     0x0000F000
#define   N_PUSH0      0x00000000      // Pushes no data (default)
#define   N_PUSH1      0x00001000      // Pushes 1 argument into stack
#define   N_PUSH2      0x00002000      // Pushes 2 arguments into stack
#define   N_PUSHX      0x0000F000      // Pushes 0 or 1 argument into stack

// CIL explicit operand types.
#define A_ARGMASK      0x000000FF      // Mask to extract type of argument
#define   A_NONE       0x00000000      // No operand
#define   A_OFFSET     0x00000001      // 32-bit offset from next command
#define   A_BYTEOFFS   0x00000002      // 8-bit offset from next command
#define   A_METHOD     0x00000003      // 32-bit method descriptor
#define   A_SIGNATURE  0x00000004      // 32-bit signature of call types
#define   A_TYPE       0x00000005      // 32-bit type descriptor
#define   A_FIELD      0x00000006      // 32-bit field descriptor
#define   A_STRING     0x00000007      // 32-bit string descriptor
#define   A_TOKEN      0x00000008      // 32-bit token descriptor
#define   A_INDEX1     0x00000009      // 8-bit immediate index constant
#define   A_INDEX2     0x0000000A      // 16-bit immediate index constant
#define   A_SWCOUNT    0x0000000B      // 32-bit immediate switch count
#define   A_INT1S      0x0000000C      // 8-bit immediate signed integer const
#define   A_INT4       0x0000000D      // 32-bit immediate integer constant
#define   A_INT8       0x0000000E      // 64-bit immediate integer constant
#define   A_FLOAT4     0x0000000F      // 32-bit immediate float constant
#define   A_FLOAT8     0x00000010      // 64-bit immediate float constant
#define   A_NOLIST     0x00000011      // 8-bit list following no. prefix
#define   A_ALIGN      0x00000012      // 8-bit alignment following unaligned.

typedef struct t_netasm {              // Disassembled .NET CIL command
  ulong          ip;                   // Address of first command byte
  ulong          size;                 // Full length of command, bytes
  ulong          cmdtype;              // Type of command, N_xxx
  ulong          cmdsize;              // Size of command, bytes
  ulong          opsize;               // Size of operand, bytes, or 0 if none
  ulong          nswitch;              // Size of following switch table, dwords
  ulong          jmpaddr;              // Single jump/call destination or 0
  ulong          descriptor;           // Descriptor (xx)xxxxxx or 0
  ulong          dataaddr;             // Address of pointed object/data or 0
  int            errors;               // Set of DAE_xxx
  // Description of operand.
  ulong          optype;               // Operand type, set of A_xxx
  wchar_t        optext[TEXTLEN];      // Operand, decoded to text
  // Textual decoding.
  wchar_t        dump[TEXTLEN];        // Hex dump of the command
  wchar_t        result[TEXTLEN];      // Fully decoded command as text
  wchar_t        comment[TEXTLEN];     // Comment that applies to whole command
} t_netasm;

stdapi (ulong)   Ndisasm(uchar *cmd,ulong size,ulong ip,t_netasm *da,
                   int mode,t_module *pmod);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// ANALYSIS ///////////////////////////////////

#define MAXARG         256             // Maximal sane number of arguments

#define NGUESS         7               // Max number of args in type analysis

#define AA_MANUAL      0               // No automatical analysis
#define AA_MAINONLY    1               // Automatically analyse main module
#define AA_NONSYS      2               // Automatically analyse non-sys modules
#define AA_ALL         3               // Automatically analyse all modules

#define AO_ISFORMATA   0x01            // Argument is probable ASCII format
#define AO_SIGFORMATA  0x02            // Non-trivial ASCII format
#define AO_ISFORMATW   0x04            // Argument is probable UNICODE format
#define AO_SIGFORMATW  0x08            // Non-trivial UNICODE format
#define AO_NOTFORMAT   0x10            // Argument is not a format
#define AO_ISCOUNT     0x20            // Argument is count of remaining args
#define AO_NOTCOUNT    0x40            // Argument is not a count

typedef struct t_procdata {            // Description of procedure
  ulong          addr;                 // Address of entry point
  ulong          size;                 // Size of simple procedure or 1
  ulong          type;                 // Type of procedure, TY_xxx/PD_xxx
  ulong          retsize;              // Size of return (if PD_RETSIZE)
  ulong          localsize;            // Size of reserved locals, 0 - unknown
  ulong          savedebp;             // Offset of cmd after PUSH EBP, 0 - none
  ulong          features;             // Type of known code, RAW_xxx
  char           generic[12];          // Generic name (without _INTERN_)
  int            narg;                 // No. of stack DWORDs (PD_NARG/VARARG)
  int            nguess;               // Number of guessed args (if PD_NGUESS)
  int            npush;                // Number of pushed args (if PD_NPUSH)
  int            usedarg;              // Min. number of accessed arguments
  uchar          preserved;            // Preserved registers
  uchar          argopt[NGUESS];       // Guessed argument options, AO_xxx
} t_procdata;

typedef struct t_argnest {             // Header of call arguments bracket
  ulong          addr0;                // First address occupied by range
  ulong          addr1;                // Last occupied address (included!)
  ulong          type;                 // Level and user-defined type, TY_xxx
  ulong          aprev;                // First address of previous range
} t_argnest;

#define NLOOPVAR       4               // Max number of loop variables

typedef struct t_loopnest {            // Header of loop bracket
  ulong          addr0;                // First address occupied by range
  ulong          addr1;                // Last occupied address (included!)
  ulong          type;                 // Level and user-defined type, TY_xxx
  ulong          aprev;                // First address of previous range
  ulong          eoffs;                // Offset of entry point from addr0
  struct {                             // Loop registers and variables
    uchar        type;                 // Combination of PRED_xxx
    long         espoffset;            // For locals, offset to original ESP
    long         increment;            // Increment after loop
  } loopvar[NLOOPVAR];
} t_loopnest;

stdapi (ulong)   Getpackednetint(uchar *code,ulong size,ulong *value);
stdapi (void)    Removeanalysis(ulong base,ulong size,int keephittrace);
stdapi (int)     Maybecommand(ulong addr,int requireanalysis);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// STACK WALK //////////////////////////////////

#define SF_FMUNREL     0x00000001      // Predicted frame is unreliable
#define SF_BPUNREL     0x00000002      // Predicted EBP is unreliable
#define SF_VIRTUAL     0x00000004      // DBGHELP: EBP is undefined

typedef struct t_sframe {              // Stack frame descriptor
  // Input parameters, fill before call to Findretaddrdata().
  ulong          eip;                  // Address of command that owns frame
  ulong          esp;                  // ESP at EIP
  ulong          ebp;                  // EBP at EIP, or 0 if unknown
  // Parameters used by DBGHELP.DLL, initialize only before the first call.
  int            firstcall;            // First call to Findretaddrdata()
  HANDLE         thread;               // Thread handle
  CONTEXT        context;              // Copy of CONTEXT, fill on first call
  int            contextvalid;         // Whether context contains valid data
  // Output parameters.
  ulong          status;               // Set of SF_xxx
  ulong          oldeip;               // Address of CALL or 0 if unknown
  ulong          oldesp;               // ESP at CALL or 0 if unknown
  ulong          oldebp;               // EBP at CALL or 0 if unknown
  ulong          retpos;               // Address of return in stack
  ulong          procaddr;             // Entry of current function or 0
  // Parameters used by DBGHELP.DLL, don't initialize!
  #ifdef STACKFRAME64                  // Requires <dbghelp.h>
    STACKFRAME64 sf;                   // Stack frame for StackWalk64()
  #else
    uchar        dummy[264];           // Replaces STACKFRAME64
  #endif
} t_sframe;

stdapi (ulong)   Isretaddr(ulong retaddr,ulong *procaddr);
stdapi (int)     Findretaddrdata(t_sframe *pf,ulong base,ulong size);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// KNOWN FUNCTIONS ////////////////////////////////

#define NARG           24              // Max number of arguments in a function

#define ADEC_VALID     0x00000001      // Value valid
#define ADEC_PREDICTED 0x00000002      // Value predicted
#define ADEC_CHGNAME   0x00000004      // Allow name change of substituted arg
#define ADEC_MARK      0x00000008      // (out) Important parameter

// Type of argument in the description of function or structure. Note that
// ARG_STRUCT is allowed only in conjunction with ARG_POINTER.
#define ARG_POINTER    0x01            // Argument is a pointer
#define ARG_BASE       0x06            // Mask to extract base type of argument
#define   ARG_TYPE     0x00            // Argument is a type
#define   ARG_STRUCT   0x02            // Argument is a structure
#define   ARG_DIRECT   0x04            // Argument is a direct string
#define ARG_OUT        0x08            // Pointer to data undefined at call
#define ARG_MARK       0x10            // Important parameter
#define ARG_ELLIPSYS   0x20            // Followed by ellipsys
#define ARG_VALID      0x40            // Must always be set to avoid argx=0

#define ARG_TYPEMASK   (ARG_POINTER|ARG_BASE)    // Mask to extract full type

#define ARG_PTYPE      (ARG_POINTER|ARG_TYPE)    // Pointer to type
#define ARG_PSTRUCT    (ARG_POINTER|ARG_STRUCT)  // Pointer to structure

// Bits used to define type of function.
#define FN_C           0x00000001      // Does not remove arguments from stack
#define FN_PASCAL      0x00000002      // Removes arguments from stack on return
#define FN_NORETURN    0x00000004      // Does not return, like ExitProcess()
#define FN_VARARG      0x00000008      // Variable number of arguments
#define FN_EAX         0x00000100      // EAX on return is same as on entry
#define FN_ECX         0x00000200      // ECX on return is same as on entry
#define FN_EDX         0x00000400      // EDX on return is same as on entry
#define FN_EBX         0x00000800      // EBX on return is same as on entry
#define FN_ESP         0x00001000      // ESP on return is same as on entry
#define FN_EBP         0x00002000      // EBP on return is same as on entry
#define FN_ESI         0x00004000      // ESI on return is same as on entry
#define FN_EDI         0x00008000      // EDI on return is same as on entry
#define FN_USES_EAX    0x00010000      // EAX is used as register parameter
#define FN_USES_ECX    0x00020000      // ECX is used as register parameter
#define FN_USES_EDX    0x00040000      // EDX is used as register parameter
#define FN_USES_EBX    0x00080000      // EBX is used as register parameter
#define FN_USES_ESP    0x00100000      // ESP is used as register parameter
#define FN_USES_EBP    0x00200000      // EBP is used as register parameter
#define FN_USES_ESI    0x00400000      // ESI is used as register parameter
#define FN_USES_EDI    0x00800000      // EDI on return is same as on entry

#define FN_FUNCTION    0
#define FN_STDFUNC     (FN_PASCAL|FN_EBX|FN_EBP|FN_ESI|FN_EDI)
#define FN_STDC        (FN_C|FN_EBX|FN_EBP|FN_ESI|FN_EDI)

typedef struct t_argdec {              // Descriptor of function argument
  ulong          mode;                 // Value descriptor, set of ADEC_xxx
  ulong          value;                // Value on the stack
  ulong          pushaddr;             // Address of command that pushed data
  wchar_t        prtype[SHORTNAME];    // Type of argument with ARG_xxx prefix
  wchar_t        name[TEXTLEN];        // Decoded name of argument
  wchar_t        text[TEXTLEN];        // Decoded value (if valid or predicted)
} t_argdec;

typedef struct t_strdec {              // Decoded structure item
  ulong          size;                 // Item size, bytes
  ulong          addr;                 // Address of the first byte
  ulong          value;                // Item value (only if size<=4!)
  uchar          valuevalid;           // Whether value is valid
  uchar          dec;                  // One of DEC_TYPEMASK subfields
  uchar          decsize;              // Size of decoding element
  uchar          reserved;             // Reserved for the future
  wchar_t        prtype[SHORTNAME];    // Type of item with ARG_xxx prefix
  wchar_t        name[TEXTLEN];        // Name of item
  wchar_t        text[TEXTLEN];        // Decoded value
} t_strdec;

typedef struct t_rawdata {             // Header of raw data block
  ulong          size;                 // Data size, bytes
  ulong          hasmask;              // Data is followed by mask
  ulong          features;             // Data features
} t_rawdata;                           // Data & mask immediately follow header

typedef struct t_argloc {              // Information about stack args & locals
  ulong          fntype;               // Calling convention, set of FN_xxx
  int            retfeatures;          // Return features, set of ARG_xxx
  int            retsize;              // Size of returned value
  wchar_t        rettype[SHORTNAME];   // Type of the returned value
  int            argvalid;             // Whether arg[] below is valid
  struct {                             // List of arguments
    int          features;             // Argument features, set of ARG_xxx
    int          size;                 // Size of argument on the stack
    wchar_t      name[TEXTLEN];        // Name of the argument
    wchar_t      type[SHORTNAME];      // Type of the argument
  } arg[NARG];
} t_argloc;

stdapi (int)     Getconstantbyname(wchar_t *name,ulong *value);
stdapi (int)     Getconstantbyvalue(wchar_t *groupname,
                   ulong value,wchar_t *name);
stdapi (int)     Decodetype(ulong data,wchar_t *type,wchar_t *text,int ntext);
stdapi (int)     Fillcombowithgroup(HWND hw,wchar_t *groupname,
                   int sortbyname,ulong select);
stdapi (int)     Fillcombowithstruct(HWND hw,wchar_t *prefix,wchar_t *select);
stdapi (t_rawdata *) Getrawdata(wchar_t *name);
stdapi (int)     Substitutehkeyprefix(wchar_t *key);
stdapi (int)     Decodeknownbyname(wchar_t *name,t_procdata *pd,
                   t_argdec adec[NARG],wchar_t *rettype,int nexp);
stdapi (int)     Decodeknownbyaddr(ulong addr,t_procdata *pd,
                   t_argdec adec[NARG],wchar_t *rettype,wchar_t *name,
                   int nexp,int follow);
stdapi (int)     Isnoreturn(ulong addr);
stdapi (int)     Decodeargument(t_module *pmod,wchar_t *prtype,void *data,
                   int ndata,wchar_t *text,int ntext,int *nontriv);
stdapi (int)     Getstructureitemcount(wchar_t *name,ulong *size);
stdapi (int)     Findstructureitembyoffset(wchar_t *name,ulong offset);
stdapi (int)     Decodestructure(wchar_t *name,ulong addr,int item0,
                   t_strdec *str,int nstr);
stdapi (ulong)   Getstructureitemvalue(uchar *code,ulong ncode,
                   wchar_t *name,wchar_t *itemname,void *value,ulong nvalue);


////////////////////////////////////////////////////////////////////////////////
////////////////////// EXPRESSIONS, WATCHES AND INSPECTORS /////////////////////

#define NEXPR          16              // Max. no. of expressions in EMOD_MULTI

// Mode of expression evaluation.
#define EMOD_CHKEXTRA  0x00000001      // Report extra characters on line
#define EMOD_NOVALUE   0x00000002      // Don't convert data to text
#define EMOD_NOMEMORY  0x00000004      // Don't read debuggee's memory
#define EMOD_MULTI     0x00000008      // Allow multiple expressions

#define EXPR_TYPEMASK  0x0F            // Mask to extract type of expression
#define   EXPR_INVALID 0x00            // Invalid or undefined expression
#define   EXPR_BYTE    0x01            // 8-bit integer byte
#define   EXPR_WORD    0x02            // 16-bit integer word
#define   EXPR_DWORD   0x03            // 32-bit integer doubleword
#define   EXPR_FLOAT4  0x04            // 32-bit floating-point number
#define   EXPR_FLOAT8  0x05            // 64-bit floating-point number
#define   EXPR_FLOAT10 0x06            // 80-bit floating-point number
#define   EXPR_SEG     0x07            // Segment
#define   EXPR_ASCII   0x08            // Pointer to ASCII string
#define   EXPR_UNICODE 0x09            // Pointer to UNICODE string
#define   EXPR_TEXT    0x0A            // Immediate UNICODE string
#define EXPR_REG       0x10            // Origin is register
#define EXPR_SIGNED    0x20            // Signed integer

#define EXPR_SIGDWORD  (EXPR_DWORD|EXPR_SIGNED)

typedef struct t_result {              // Result of expression's evaluation
  int            lvaltype;             // Type of expression, EXPR_xxx
  ulong          lvaladdr;             // Address of lvalue or NULL
  int            datatype;             // Type of data, EXPR_xxx
  int            repcount;             // Repeat count (0..32, 0 means default)
  union {
    uchar        data[10];             // Value as set of bytes
    ulong        u;                    // Value as address or unsigned integer
    long         l;                    // Value as signed integer
    long double  f; };                 // Value as 80-bit float
  wchar_t        value[TEXTLEN];       // Value decoded to string
} t_result;

typedef struct t_watch {               // Watch descriptor
  ulong          addr;                 // 0-based watch index
  ulong          size;                 // Reserved, always 1
  ulong          type;                 // Service information, TY_xxx
  wchar_t        expr[TEXTLEN];        // Watch expression
} t_watch;

stdapi (int)     Cexpression(wchar_t *expression,uchar *cexpr,int nexpr,
                   int *explen,wchar_t *err,ulong mode);
stdapi (int)     Exprcount(uchar *cexpr);
stdapi (int)     Eexpression(t_result *result,wchar_t *expl,uchar *cexpr,
                   int index,uchar *data,ulong base,ulong size,ulong threadid,
                   ulong a,ulong b,ulong mode);
stdapi (int)     Expression(t_result *result,wchar_t *expression,uchar *data,
                   ulong base,ulong size,ulong threadid,ulong a,ulong b,
                   ulong mode);
stdapi (int)     Fastexpression(t_result *result,ulong addr,int type,
                   ulong threadid);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// DIALOGS AND OPTIONS //////////////////////////////

// Mode bits in calls to dialog functions.
#define DIA_SIZEMASK   0x0000001F      // Mask to extract default data size
#define   DIA_BYTE     0x00000001      // Byte data size
#define   DIA_WORD     0x00000002      // Word data size
#define   DIA_DWORD    0x00000004      // Doubleword data size (default)
#define   DIA_QWORD    0x00000008      // Quadword data size
#define   DIA_TBYTE    0x0000000A      // 10-byte data size
#define   DIA_DQWORD   0x00000010      // 16-byte data size
#define DIA_HEXONLY    0x00000020      // Hexadecimal format only
#define DIA_EXTENDED   0x00000040      // Extended format
#define DIA_DATAVALID  0x00000080      // Input data valid (edit mode)
#define DIA_DEFMASK    0x00000F00      // Mask to extract default data type
#define   DIA_DEFHEX   0x00000100      // On startup, cursor in hex control
#define   DIA_DEFSIG   0x00000200      // On startup, cursor in signed control
#define   DIA_DEFUNSIG 0x00000300      // On startup, cursor in unsigned control
#define   DIA_DEFASC   0x00000400      // On startup, cursor in ASCII control
#define   DIA_DEFUNI   0x00000500      // On startup, cursor in UNICODE control
#define   DIA_DEFCODE  0x00000600      // Default is code breakpoint
#define   DIA_DEFFLOAT 0x00000700      // Default selection is float
#define DIA_ISSEARCH   0x00001000      // Is a search dialog
#define DIA_ASKCASE    0x00002000      // Ask if case-insensitive
#define DIA_SEARCHDIR  0x00004000      // Includes direction search buttons
#define DIA_HISTORY    0x00008000      // Supports history
#define DIA_SELMASK    0x000F0000      // Mask to extract selection offset
#define   DIA_SEL0     0x00000000      // Select least significant item
#define   DIA_SEL4     0x00040000      // Select item with offset 4
#define   DIA_SEL8     0x00080000      // Select item with offset 8
#define   DIA_SEL12    0x000C0000      // Select item with offset 12
#define   DIA_SEL14    0x000E0000      // Select item with offset 14
#define DIA_JMPMODE    0x00300000      // Mask for jump/call/switch display
#define   DIA_JMPFROM  0x00000000      // Jumps/calls from specified location
#define   DIA_JMPTO    0x00100000      // Jumps/calls to specified location
#define   DIA_SWITCH   0x00200000      // Switches
#define DIA_JMPGLOB    0x00400000      // Show global jumps and calls
#define DIA_JMPLOC     0x00000000      // Show local jumps and calls
#define DIA_UTF8       0x00800000      // Support for UTF8
#define DIA_ABSXYPOS   0x10000000      // Use X-Y dialog coordinates as is
#define DIA_RESTOREPOS 0x20000000      // Restore X-Y dialog coordinates

// Types of controls that can be used in dialogs.
#define CA_END         0               // End of control list with dialog size
#define CA_COMMENT     1               // Dummy entry in control list
#define CA_TEXT        2               // Simple left-aligned text
#define CA_TEXTC       4               // Simple centered text
#define CA_TEXTR       5               // Simple right-aligned text
#define CA_WARN        6               // Multiline text, highlighted if differ
#define CA_WTEXT       7               // Text with white bg in sunken frame
#define CA_TITLE       8               // Fat centered text
#define CA_FRAME       9               // Etched frame
#define CA_SUNK        10              // Sunken frame
#define CA_GROUP       11              // Group box (named frame)
#define CA_EDIT        12              // Standard edit control
#define CA_NOEDIT      13              // Read-only edit control
#define CA_EDITHEX     14              // Standard edit control, hex uppercase
#define CA_MULTI       15              // Multiline edit control (DATALEN)
#define CA_NOMULTI     16              // Multiline read-only edit (DATALEN)
#define CA_BTN         17              // Standard pushbutton
#define CA_DEFBTN      18              // Standard default pushbutton
#define CA_COMBO       19              // Combo box control, specified font
#define CA_COMBOFIX    20              // Combo box control, fixed width font
#define CA_CEDIT       21              // Combo edit control, specified font
#define CA_CEDITFIX    22              // Combo edit control, fixed width font
#define CA_CESAV0      32              // Combo edit 0 with autosave & UNICODE
#define CA_CESAV1      33              // Combo edit 1 with autosave & UNICODE
#define CA_CESAV2      34              // Combo edit 2 with autosave & UNICODE
#define CA_CESAV3      35              // Combo edit 3 with autosave & UNICODE
#define CA_CESAV4      36              // Combo edit 4 with autosave & UNICODE
#define CA_CESAV5      37              // Combo edit 5 with autosave & UNICODE
#define CA_CESAV6      38              // Combo edit 6 with autosave & UNICODE
#define CA_CESAV7      39              // Combo edit 7 with autosave & UNICODE
#define CA_LIST        48              // Simple list box
#define CA_LISTFIX     49              // Simple list box, fixed font
#define CA_CHECK       62              // Auto check box, left-aligned
#define CA_CHECKR      63              // Auto check box, right-aligned
#define CA_BIT0        64              // Auto check box, bit 0
#define CA_BIT1        65              // Auto check box, bit 1
#define CA_BIT2        66              // Auto check box, bit 2
#define CA_BIT3        67              // Auto check box, bit 3
#define CA_BIT4        68              // Auto check box, bit 4
#define CA_BIT5        69              // Auto check box, bit 5
#define CA_BIT6        70              // Auto check box, bit 6
#define CA_BIT7        71              // Auto check box, bit 7
#define CA_BIT8        72              // Auto check box, bit 8
#define CA_BIT9        73              // Auto check box, bit 9
#define CA_BIT10       74              // Auto check box, bit 10
#define CA_BIT11       75              // Auto check box, bit 11
#define CA_BIT12       76              // Auto check box, bit 12
#define CA_BIT13       77              // Auto check box, bit 13
#define CA_BIT14       78              // Auto check box, bit 14
#define CA_BIT15       79              // Auto check box, bit 15
#define CA_BIT16       80              // Auto check box, bit 16
#define CA_BIT17       81              // Auto check box, bit 17
#define CA_BIT18       82              // Auto check box, bit 18
#define CA_BIT19       83              // Auto check box, bit 19
#define CA_BIT20       84              // Auto check box, bit 20
#define CA_BIT21       85              // Auto check box, bit 21
#define CA_BIT22       86              // Auto check box, bit 22
#define CA_BIT23       87              // Auto check box, bit 23
#define CA_BIT24       88              // Auto check box, bit 24
#define CA_BIT25       89              // Auto check box, bit 25
#define CA_BIT26       90              // Auto check box, bit 26
#define CA_BIT27       91              // Auto check box, bit 27
#define CA_BIT28       92              // Auto check box, bit 28
#define CA_BIT29       93              // Auto check box, bit 29
#define CA_BIT30       94              // Auto check box, bit 30
#define CA_BIT31       95              // Auto check box, bit 31
#define CA_RADIO0      96              // Radio button, value 0
#define CA_RADIO1      97              // Radio button, value 1
#define CA_RADIO2      98              // Radio button, value 2
#define CA_RADIO3      99              // Radio button, value 3
#define CA_RADIO4      100             // Radio button, value 4
#define CA_RADIO5      101             // Radio button, value 5
#define CA_RADIO6      102             // Radio button, value 6
#define CA_RADIO7      103             // Radio button, value 7
#define CA_RADIO8      104             // Radio button, value 8
#define CA_RADIO9      105             // Radio button, value 9
#define CA_RADIO10     106             // Radio button, value 10
#define CA_RADIO11     107             // Radio button, value 11
#define CA_RADIO12     108             // Radio button, value 12
#define CA_RADIO13     109             // Radio button, value 13
#define CA_RADIO14     110             // Radio button, value 14
#define CA_RADIO15     111             // Radio button, value 15
#define CA_CUSTOM      124             // Custom control
#define CA_CUSTSF      125             // Custom control with sunken frame
// Controls with special functions that work only in Options dialog.
#define CA_FILE        129             // Edit file (autosave, MAXPATH chars)
#define CA_BROWSE      130             // Browse file name pushbutton
#define CA_BRDIR       131             // Browse directory pushbutton
#define CA_LANGS       132             // Combobox with list of languages
#define CA_FONTS       133             // Combobox with list of fonts
#define CA_FHTOP       134             // Combobox that adjusts top font height
#define CA_FHBOT       135             // Combobox that adjusts bottom font hgt
#define CA_SCHEMES     136             // Combobox with list of schemes
#define CA_HILITE      137             // Combobox with list of hilites
#define CA_HILITE1     138             // Combobox with nontrivial hilites

// Modes of font usage in dialog windows, if applies.
#define DFM_SYSTEM     0               // Use system font
#define DFM_PARENT     1               // Use font of parent window
#define DFM_FIXED      2               // Use dlgfontindex
#define DFM_FIXALL     3               // Use dlgfontindex for all controls

#define HEXLEN         1024            // Max length of hex edit string, bytes

#define NSEARCHCMD     128             // Max number of assembler search models

typedef struct t_control {             // Descriptor of dialog control
  ulong          type;                 // Type of control, CA_xxx
  int            id;                   // Control's ID or -1 if unimportant
  int            x;                    // X coordinate, chars/4
  int            y;                    // Y coordinate, chars/8
  int            dx;                   // X size, chars/4
  int            dy;                   // Y size, chars/8
  int            *var;                 // Pointer to control variable or NULL
  wchar_t        *text;                // Name or contents of the control
  wchar_t        *help;                // Tooltip or NULL
  int            oldvar;               // Copy of control variable, internal
} t_control;

typedef struct t_dialog {              // Descriptor of OllyDbg dialog
  t_control      *controls;            // List of controls to place in dialog
  wchar_t        *title;               // Pointer to the dialog's title
  int            focus;                // ID of control with focus
  int            item;                 // Index of processing item
  ulong          u;                    // Doubleword data
  uchar          data[16];             // Data in other formats
  ulong          addr0;                // Address
  ulong          addr1;                // Address
  int            letter;               // First character entered in dialog
  int            x;                    // X reference screen coordinate
  int            y;                    // Y reference screen coordinate
  int            fi;                   // Index of font to use in dialog
  int            mode;                 // Dialog operation mode, set of DIA_xxx
  int            cesav[8];             // NM_xxx of CA_CESAVn
  HFONT          fixfont;              // Fixed font used in dialog
  int            isfullunicode;        // Whether fixfont UNICODE
  int            fixdx;                // Width of dialog fixed font
  int            fixdy;                // Height of dialog fixed font
  HWND           htooltip;             // Handle of tooltip window
  HWND           hwwarn;               // Handle of WARN control, if any
  int            initdone;             // WM_INITDIALOG finished
} t_dialog;

// ATTENTION, size of structure t_hexstr must not exceed DATALEN!
typedef struct t_hexstr {              // Data for hex/text search
  ulong          n;                    // Data length, bytes
  ulong          nmax;                 // Maximal data length, bytes
  uchar          data[HEXLEN];         // Data
  uchar          mask[HEXLEN];         // Mask, 0 bits are masked
} t_hexstr;

typedef int  BROWSECODEFUNC(int,void *,ulong *,wchar_t *);

stdapi (t_control *) Findcontrol(HWND hw);
stdapi (int)     Defaultactions(HWND hparent,t_control *pctr,
                   WPARAM wp,LPARAM lp);
stdapi (void)    Addstringtocombolist(HWND hc,wchar_t *s);
stdapi (int)     Preparedialog(HWND hw,t_dialog *pdlg);
stdapi (int)     Endotdialog(HWND hw,int result);
stdapi (int)     Getregister(HWND hparent,int reg,ulong *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getinteger(HWND hparent,wchar_t *title,ulong *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getdword(HWND hparent,wchar_t *title,ulong *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getlasterrorcode(HWND hparent,wchar_t *title,ulong *data,
                   int letter,int x,int y,int fi);
stdapi (int)     Getaddressrange(HWND hparent,wchar_t *title,
                   ulong *rmin,ulong *rmax,int x,int y,int fi,int mode);
stdapi (int)     Getexceptionrange(HWND hparent,wchar_t *title,
                   ulong *rmin,ulong *rmax,int x,int y,int fi);
stdapi (int)     Getstructuretype(HWND hparent,wchar_t *title,wchar_t *text,
                   wchar_t *strname,int x,int y,int fi);
stdapi (int)     Getfpureg(HWND hparent,int reg,void *data,int letter,
                   int x,int y,int fi);
stdapi (int)     Get3dnow(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getfloat(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getmmx(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi);
stdapi (int)     Getsse(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getstring(HWND hparent,wchar_t *title,wchar_t *s,int length,
                   int savetype,int letter,int x,int y,int fi,int mode);
stdapi (int)     Getdwordexpression(HWND hparent,wchar_t *title,ulong *u,
                   ulong threadid,int savetype,int x,int y,int fi,int mode);
stdapi (int)     Getgotoexpression(HWND hparent,wchar_t *title,ulong *u,
                   ulong threadid,int savetype,int x,int y,int fi,int mode);
stdapi (int)     Asmindump(HWND hparent,wchar_t *title,struct t_dump *pd,
                   int letter,int x,int y,int fi,int mode);
stdapi (int)     Getasmsearchmodel(HWND hparent,wchar_t *title,t_asmmod *model,
                   int nmodel,int x,int y,int fi,int mode);
stdapi (int)     Getseqsearchmodel(HWND hparent,wchar_t *title,t_asmmod *model,
                   int nmodel,int x,int y,int fi,int mode);
stdapi (int)     Binaryedit(HWND hparent,wchar_t *title,t_hexstr *hstr,
                   int letter,int x,int y,int fi,int mode);
stdapi (int)     Getpredefinedtypebyindex(int fnindex,wchar_t *type);
stdapi (int)     Getindexbypredefinedtype(wchar_t *type);
stdapi (int)     Condbreakpoint(HWND hparent,ulong *addr,int naddr,
                   wchar_t *title,int x,int y,int fi);
stdapi (int)     Condlogbreakpoint(HWND hparent,ulong *addr,int naddr,
                   int fnindex,wchar_t *title,int x,int y,int fi);
stdapi (int)     Membreakpoint(HWND hparent,ulong addr,ulong size,
                   int x,int y,int fi,int mode);
stdapi (int)     Memlogbreakpoint(HWND hparent,ulong addr,ulong size,
                   int x,int y,int fi,int mode);
stdapi (int)     Hardbreakpoint(HWND hparent,ulong addr,
                   int x,int y,int fi,int mode);
stdapi (int)     Hardlogbreakpoint(HWND hparent,ulong addr,int fnindex,
                   int x,int y,int fi,int mode);
stdapi (void)    Setrtcond(HWND hparent,int x,int y,int fi);
stdapi (void)    Setrtprot(HWND hparent,int x,int y,int fi);
stdapi (ulong)   Browsecodelocations(HWND hparent,wchar_t *title,
                   BROWSECODEFUNC *bccallback,void *data);
stdapi (int)     Fillcombowithcodepages(HWND hw,int select);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PLUGIN OPTIONS ////////////////////////////////

#define OPT_TITLE      9001            // Pane title
#define OPT_1          9011            // First automatical control
#define OPT_2          9012            // Second automatical control
#define OPT_3          9013            // Third automatical control
#define OPT_4          9014            // Fourth automatical control
#define OPT_5          9015            // Fifth automatical control
#define OPT_6          9016            // Sixth automatical control
#define OPT_7          9017            // Seventh automatical control
#define OPT_8          9018            // Eighth automatical control
#define OPT_9          9019            // Ninth automatical control
#define OPT_10         9020            // Tenth automatical control
#define OPT_11         9021            // Eleventh automatical control
#define OPT_12         9022            // Twelfth automatical control
#define OPT_13         9023            // Thirteen automatical control
#define OPT_14         9024            // Fourteen automatical control
#define OPT_15         9025            // Fifteen automatical control
#define OPT_16         9026            // Sixteen automatical control
#define OPT_17         9027            // Seventeen automatical control
#define OPT_18         9028            // Eighteen automatical control
#define OPT_19         9029            // Nineteen automatical control
#define OPT_20         9030            // Twentieth automatical control
#define OPT_21         9031            // Twenty-first automatical control
#define OPT_22         9032            // Twenty-second automatical control
#define OPT_23         9033            // Twenty-third automatical control
#define OPT_24         9034            // Twenty-fourth automatical control
#define OPT_W1         9101            // First automatical autowarn control
#define OPT_W2         9102            // Second automatical autowarn control
#define OPT_W3         9103            // Third automatical autowarn control
#define OPT_W4         9104            // Fourth automatical autowarn control
#define OPT_W5         9105            // Fifth automatical autowarn control
#define OPT_W6         9106            // Sixth automatical autowarn control
#define OPT_W7         9107            // Seventh automatical autowarn control
#define OPT_W8         9108            // Eighth automatical autowarn control
#define OPT_W9         9109            // Ninth automatical autowarn control
#define OPT_W10        9110            // Tenth automatical autowarn control
#define OPT_W11        9111            // Eleventh automatical autowarn control
#define OPT_W12        9112            // Twelfth automatical autowarn control
#define OPT_S1         9121            // First autowarn-if-turned-on control
#define OPT_S2         9122            // Second autowarn-if-turned-on control
#define OPT_S3         9123            // Third autowarn-if-turned-on control
#define OPT_S4         9124            // Fourth autowarn-if-turned-on control
#define OPT_S5         9125            // Fifth autowarn-if-turned-on control
#define OPT_S6         9126            // Sixth autowarn-if-turned-on control
#define OPT_S7         9127            // Seventh autowarn-if-turned-on control
#define OPT_S8         9128            // Eighth autowarn-if-turned-on control
#define OPT_S9         9129            // Ninth autowarn-if-turned-on control
#define OPT_S10        9130            // Tenth autowarn-if-turned-on control
#define OPT_S11        9131            // Eleventh autowarn-if-turned-on control
#define OPT_S12        9132            // Twelfth autowarn-if-turned-on control
#define OPT_X1         9141            // First autowarn-if-all-on control
#define OPT_X2         9142            // Second autowarn-if-all-on control
#define OPT_X3         9143            // Third autowarn-if-all-on control
#define OPT_X4         9144            // Fourth autowarn-if-all-on control
#define OPT_X5         9145            // Fifth autowarn-if-all-on control
#define OPT_X6         9146            // Sixth autowarn-if-all-on control
#define OPT_X7         9147            // Seventh autowarn-if-all-on control
#define OPT_X8         9148            // Eighth autowarn-if-all-on control
#define OPT_X9         9149            // Ninth autowarn-if-all-on control
#define OPT_X10        9150            // Tenth autowarn-if-all-on control
#define OPT_X11        9151            // Eleventh autowarn-if-all-on control
#define OPT_X12        9152            // Twelfth autowarn-if-all-on control

#define OPT_CUSTMIN    9500            // Custom controls by plugins
#define OPT_CUSTMAX    9999            // End of custom area


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// COMMENTS ///////////////////////////////////

// Comments types used by Commentaddress().
#define COMM_USER      0x00000001      // Add user-defined comment
#define COMM_MARK      0x00000002      // Add important arguments
#define COMM_PROC      0x00000004      // Add procedure description
#define COMM_ALL       0xFFFFFFFF      // Add all possible comments

stdapi (int)     Stringtotext(wchar_t *data,int ndata,wchar_t *text,int ntext,
                   int stopatzero);
stdapi (int)     Isstring(ulong addr,int isstatic,wchar_t *symb,int nsymb);
stdapi (int)     Squeezename(wchar_t *dest,int ndest,wchar_t *src,int nsrc);
stdapi (void)    Uncapitalize(wchar_t *s);
stdapi (int)     Decoderelativeoffset(ulong addr,int addrmode,
                   wchar_t *symb,int nsymb);
stdapi (int)     Decodeaddress(ulong addr,ulong amod,int mode,
                   wchar_t *symb,int nsymb,wchar_t *comment);
stdapi (int)     Decodearglocal(ulong ip,ulong offs,ulong datasize,
                   wchar_t *name,int len);
stdapi (int)     Getanalysercomment(struct t_module *pmod,ulong addr,
                   wchar_t *comment,int len);
stdapi (int)     Getswitchcomment(ulong addr,wchar_t *comment,int len);
stdapi (int)     Getloopcomment(struct t_module *pmod,ulong addr,int level,
                   wchar_t *comment,int len);
stdapi (int)     Getproccomment(ulong addr,ulong acall,
                   wchar_t *comment,int len,int argonly);
stdapi (int)     Commentaddress(ulong addr,int typelist,
                   wchar_t *comment,int len);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// LOG WINDOW //////////////////////////////////

stdapi (void)    Redrawlist(void);
varapi (void)    Addtolist(ulong addr,int color,wchar_t *format,...);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// DUMP /////////////////////////////////////

#define DU_STACK       0x80000000      // Used for internal purposes
#define DU_NOSMALL     0x40000000      // Used for internal purposes
#define DU_MODEMASK    0x3C000000      // Mask for mode bits
#define   DU_SMALL     0x20000000      // Small-size dump
#define   DU_FIXADDR   0x10000000      // Fix first visible address
#define   DU_BACKUP    0x08000000      // Display backup instead of actual data
#define   DU_USEDEC    0x04000000      // Show contents using decoding data
#define DU_COMMMASK    0x03000000      // Mask for disassembly comments
#define   DU_COMMENT   0x00000000      // Show comments
#define   DU_SOURCE    0x01000000      // Show source
#define DU_DISCARD     0x00800000      // Discardable by Esc
#define DU_PROFILE     0x00400000      // Show profile
#define DU_TYPEMASK    0x003F0000      // Mask for dump type
#define   DU_HEXTEXT   0x00010000      // Hexadecimal dump with ASCII text
#define   DU_HEXUNI    0x00020000      // Hexadecimal dump with UNICODE text
#define   DU_TEXT      0x00030000      // Character dump
#define   DU_UNICODE   0x00040000      // Unicode dump
#define   DU_INT       0x00050000      // Integer signed dump
#define   DU_UINT      0x00060000      // Integer unsigned dump
#define   DU_IHEX      0x00070000      // Integer hexadecimal dump
#define   DU_FLOAT     0x00080000      // Floating-point dump
#define   DU_ADDR      0x00090000      // Address dump
#define   DU_ADRASC    0x000A0000      // Address dump with ASCII text
#define   DU_ADRUNI    0x000B0000      // Address dump with UNICODE text
#define   DU_DISASM    0x000C0000      // Disassembly
#define   DU_DECODE    0x000D0000      // Same as DU_DISASM but for decoded data
#define DU_COUNTMASK   0x0000FF00      // Mask for number of items/line
#define DU_SIZEMASK    0x000000FF      // Mask for size of single item

#define DU_MAINPART    (DU_TYPEMASK|DU_COUNTMASK|DU_SIZEMASK)

#define DUMP_HEXA8     0x00010801      // Hex/ASCII dump, 8 bytes per line
#define DUMP_HEXA16    0x00011001      // Hex/ASCII dump, 16 bytes per line
#define DUMP_HEXU8     0x00020801      // Hex/UNICODE dump, 8 bytes per line
#define DUMP_HEXU16    0x00021001      // Hex/UNICODE dump, 16 bytes per line
#define DUMP_ASC32     0x00032001      // ASCII dump, 32 characters per line
#define DUMP_ASC64     0x00034001      // ASCII dump, 64 characters per line
#define DUMP_UNI16     0x00041002      // UNICODE dump, 16 characters per line
#define DUMP_UNI32     0x00042002      // UNICODE dump, 32 characters per line
#define DUMP_UNI64     0x00044002      // UNICODE dump, 64 characters per line
#define DUMP_INT16     0x00050802      // 16-bit signed integer dump, 8 items
#define DUMP_INT16S    0x00050402      // 16-bit signed integer dump, 4 items
#define DUMP_INT32     0x00050404      // 32-bit signed integer dump, 4 items
#define DUMP_INT32S    0x00050204      // 32-bit signed integer dump, 2 items
#define DUMP_UINT16    0x00060802      // 16-bit unsigned integer dump, 8 items
#define DUMP_UINT16S   0x00060402      // 16-bit unsigned integer dump, 4 items
#define DUMP_UINT32    0x00060404      // 32-bit unsigned integer dump, 4 items
#define DUMP_UINT32S   0x00060204      // 32-bit unsigned integer dump, 2 items
#define DUMP_IHEX16    0x00070802      // 16-bit hex integer dump, 8 items
#define DUMP_IHEX16S   0x00070402      // 16-bit hex integer dump, 4 items
#define DUMP_IHEX32    0x00070404      // 32-bit hex integer dump, 4 items
#define DUMP_IHEX32S   0x00070204      // 32-bit hex integer dump, 2 items
#define DUMP_FLOAT32   0x00080404      // 32-bit floats, 4 items
#define DUMP_FLOAT32S  0x00080104      // 32-bit floats, 1 item
#define DUMP_FLOAT64   0x00080208      // 64-bit floats, 2 items
#define DUMP_FLOAT64S  0x00080108      // 64-bit floats, 1 item
#define DUMP_FLOAT80   0x0008010A      // 80-bit floats
#define DUMP_ADDR      0x00090104      // Address dump
#define DUMP_ADDRASC   0x000A0104      // Address dump with ASCII text
#define DUMP_ADDRUNI   0x000B0104      // Address dump with UNICODE text
#define DUMP_DISASM    0x000C0110      // Disassembly (max. 16 bytes per cmd)
#define DUMP_DECODE    0x000D0110      // Decoded data (max. 16 bytes per line)

// Types of dump menu in t_dump.menutype.
#define DMT_FIXTYPE    0x00000001      // Fixed dump type, no change
#define DMT_STRUCT     0x00000002      // Dump of the structure
#define DMT_CPUMASK    0x00070000      // Dump belongs to CPU window
#define   DMT_CPUDASM  0x00010000      // This is CPU Disassembler pane
#define   DMT_CPUDUMP  0x00020000      // This is CPU Dump pane
#define   DMT_CPUSTACK 0x00040000      // This is CPU Stack pane

// Modes of Scrolldumpwindow().
#define SD_REALIGN     0x01            // Realign on specified address
#define SD_CENTERY     0x02            // Center destination vertically

// Modes of t_dump.dumpselfunc() and Reportdumpselection().
#define SCH_SEL0       0x01            // t_dump.sel0 changed
#define SCH_SEL1       0x02            // t_dump.sel1 changed

// Modes of Copydumpselection().
#define CDS_TITLES     0x00000001      // Prepend window name and column titles
#define CDS_NOGRAPH    0x00000002      // Replace graphical symbols by spaces

typedef void DUMPSELFUNC(struct t_dump *,int);

typedef struct t_dump {                // Descriptor of dump data and window
  ulong          base;                 // Start of memory block or file
  ulong          size;                 // Size of memory block or file
  ulong          dumptype;             // Dump type, DU_xxx+count+size=DUMP_xxx
  ulong          menutype;             // Menu type, set of DMT_xxx
  ulong          itemwidth;            // Width of one item, characters
  ulong          threadid;             // Use decoding and registers if not 0
  t_table        table;                // Dump window is a custom table
  ulong          addr;                 // Address of first visible byte
  ulong          sel0;                 // Address of first selected byte
  ulong          sel1;                 // Last selected byte (not included!)
  ulong          selstart;             // Addr of first byte of selection start
  ulong          selend;               // Addr of first byte of selection end
  uchar          *filecopy;            // Copy of the file or NULL
  wchar_t        path[MAXPATH];        // Name of displayed file
  uchar          *backup;              // Old backup of memory/file or NULL
  wchar_t        strname[SHORTNAME];   // Name of the structure to decode
  uchar          *decode;              // Local decoding information or NULL
  wchar_t        bkpath[MAXPATH];      // Name of last used backup file
  int            relreg;               // Addresses relative to register
  ulong          reladdr;              // Addresses relative to this address
  ulong          hilitereg;            // One of OP_SOMEREG if reg highlighting
  int            hiregindex;           // Index of register to highlight
  ulong          graylimit;            // Gray data below this address
  DUMPSELFUNC    *dumpselfunc;         // Callback indicating change of sel0
} t_dump;

stdapi (void)    Setdumptype(t_dump *pd,ulong dumptype);
stdapi (int)     Ensurememorybackup(t_memory *pmem,int makebackup);
stdapi (void)    Backupusercode(struct t_module *pm,int force);
stdapi (HGLOBAL) Copydumpselection(t_dump *pd,int mode);
stdapi (ulong)   Dumpback(t_dump *pd,ulong addr,int n);
stdapi (ulong)   Dumpforward(t_dump *pd,ulong addr,int n);
stdapi (ulong)   Scrolldumpwindow(t_dump *pd,ulong addr,int mode);
stdapi (int)     Alignselection(t_dump *pd,ulong *sel0,ulong *sel1);
stdapi (int)     Getproclimits(ulong addr,ulong *amin,ulong *amax);
stdapi (int)     Getextproclimits(ulong addr,ulong *amin,ulong *amax);
stdapi (int)     Newdumpselection(t_dump *pd,ulong addr,ulong size);
stdapi (t_dump *) Findfiledump(wchar_t *path);
stdapi (HWND)    Createdumpwindow(wchar_t *title,ulong base,ulong size,
                   wchar_t *path,ulong dumptype,ulong sel0,ulong sel1,
                   wchar_t *strname);
stdapi (HWND)    Embeddumpwindow(HWND hw,t_dump *pd,ulong dumptype);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// SEARCH ////////////////////////////////////

// Layouts of search panel.
#define SL_UNDEF       0               // Undefined layout
#define SL_DISASM      1               // Commands or refs within one module
#define SL_SEQASM      2               // Sequences within one module
#define SL_STRINGS     3               // Referenced strings within one module
#define SL_GUIDS       4               // Referenced GUIDs within one module
#define SL_COMMENTS    5               // All user-defined comments
#define SL_SWITCHES    6               // Switches and cascaded IFs
#define SL_FLOATS      7               // Referenced floats within one module
#define SL_CALLS       8               // Intermodular calls
#define SL_MOD         9               // Modifications

// Search types.
#define SEARCH_NONE    0               // Type is not yet defined
#define SEARCH_CMD     1               // Search for assembler commands
#define SEARCH_SEQ     2               // Search for the sequence of commands
#define SEARCH_BINARY  3               // Search for binary code
#define SEARCH_CONST   4               // Search for referenced constant range
#define SEARCH_MOD     5               // Search for modifications

// Search directions.
#define SDIR_GLOBAL    0               // Search forward from the beginning
#define SDIR_FORWARD   1               // Search forward from selection
#define SDIR_BACKWARD  2               // Search backward from selection

// Search modes.
#define SRCH_NEW       0               // Ask for new search pattern
#define SRCH_NEWMEM    1               // Ask for new pattern, memory mode
#define SRCH_SAMEDIR   2               // Search in the specified direction
#define SRCH_OPPDIR    3               // Search in the opposite direction
#define SRCH_MEM       4               // Search forward, memory mode

// Mode bits in Comparesequence().
#define CSEQ_IGNORECMD 0x00000001      // Ignore non-influencing commands
#define CSEQ_ALLOWJMP  0x00000002      // Allow jumps from outside

typedef struct t_found {               // Search result
  ulong          addr;                 // Address of found item
  ulong          size;                 // Size of found item, or 0 on error
} t_found;

typedef struct t_search {              // Descriptor of found item
  ulong          addr;                 // Address of found item
  ulong          size;                 // Must be 1
  ulong          type;                 // Type of found item, TY_xxx+SE_xxx
  ulong          data;                 // Mode-related data
  ulong          seqlen;               // Length of command sequence
} t_search;

stdapi (ulong)   Comparecommand(uchar *cmd,ulong cmdsize,ulong cmdip,
                   t_asmmod *model,int nmodel,int *pa,int *pb,t_disasm *da);
stdapi (ulong)   Comparesequence(uchar *cmd,ulong cmdsize,ulong cmdip,
                   uchar *decode,t_asmmod *model,int nmodel,int mode,
                   int *pa,int *pb,t_disasm *da,ulong *amatch,int namatch);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// PATCHES ////////////////////////////////////

#define PATCHSIZE      512             // Maximal patch size, bytes

typedef struct t_patch {
  ulong          addr;                 // Base address of patch in memory
  ulong          size;                 // Size of patch, bytes
  ulong          type;                 // Type of patch, set of TY_xxx
  uchar          orig[PATCHSIZE];      // Original code
  uchar          mod[PATCHSIZE];       // Patched code
} t_patch;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// BREAKPOINTS //////////////////////////////////

// Actions that must be performed if breakpoint of type BP_ONESHOT or BP_TEMP
// is hit.
#define BA_PERMANENT   0x00000001      // Permanent INT3 BP_TEMP on system call
#define BA_PLUGIN      0x80000000      // Pass notification to plugin

typedef struct t_bpoint {              // INT3 breakpoints
  ulong          addr;                 // Address of breakpoint
  ulong          size;                 // Must be 1
  ulong          type;                 // Type of breakpoint, TY_xxx+BP_xxx
  ushort         fnindex;              // Index of predefined function
  uchar          cmd;                  // First byte of original command
  uchar          patch;                // Used only in .udd files
  ulong          limit;                // Original pass count (0 if not set)
  ulong          count;                // Actual pass count
  ulong          actions;              // Actions, set of BA_xxx
} t_bpoint;

typedef struct t_bpmem {               // Memory breakpoints
  ulong          addr;                 // Address of breakpoint
  ulong          size;                 // Size of the breakpoint, bytes
  ulong          type;                 // Type of breakpoint, TY_xxx+BP_xxx
  ulong          limit;                // Original pass count (0 if not set)
  ulong          count;                // Actual pass count
} t_bpmem;

typedef struct t_bppage {              // Pages with modified attributes
  ulong          base;                 // Base address of memory page
  ulong          size;                 // Always PAGESIZE
  ulong          type;                 // Set of TY_xxx+BP_ACCESSMASK
  ulong          oldaccess;            // Initial access
  ulong          newaccess;            // Modified (actual) access
} t_bppage;

typedef struct t_bphard {              // Hardware breakpoints
  ulong          index;                // Index of the breakpoint (0..NHARD-1)
  ulong          dummy;                // Must be 1
  ulong          type;                 // Type of the breakpoint, TY_xxx+BP_xxx
  ulong          addr;                 // Address of breakpoint
  ulong          size;                 // Size of the breakpoint, bytes
  int            fnindex;              // Index of predefined function
  ulong          limit;                // Original pass count (0 if not set)
  ulong          count;                // Actual pass count
  ulong          actions;              // Actions, set of BA_xxx
  ulong          modbase;              // Module base, used by .udd only
  wchar_t        path[MAXPATH];        // Full module name, used by .udd only
} t_bphard;

stdapi (int)     Removeint3breakpoint(ulong addr,ulong type);
stdapi (int)     Setint3breakpoint(ulong addr,ulong type,int fnindex,
                   int limit,int count,ulong actions,
                   wchar_t *condition,wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enableint3breakpoint(ulong addr,int enable);
stdapi (int)     Confirmint3breakpoint(ulong addr);
stdapi (int)     Confirmhardwarebreakpoint(ulong addr);
stdapi (int)     Confirmint3breakpointlist(ulong *addr,int naddr);
stdapi (void)    Wipebreakpointrange(ulong addr0,ulong addr1);
stdapi (int)     Removemembreakpoint(ulong addr);
stdapi (int)     Setmembreakpoint(ulong addr,ulong size,ulong type,
                   int limit,int count,wchar_t *condition,
                   wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enablemembreakpoint(ulong addr,int enable);
stdapi (int)     Removehardbreakpoint(int index);
stdapi (int)     Sethardbreakpoint(int index,ulong size,ulong type,int fnindex,
                   ulong addr,int limit,int count,ulong actions,
                   wchar_t *condition,wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enablehardbreakpoint(int index,int enable);
stdapi (int)     Findfreehardbreakslot(ulong type);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// CPU //////////////////////////////////////

// Mode bits for Setcpu().
#define CPU_ASMHIST    0x00000001      // Add change to Disassembler history
#define CPU_ASMCENTER  0x00000004      // Make address in the middle of window
#define CPU_ASMFOCUS   0x00000008      // Move focus to Disassembler
#define CPU_DUMPHIST   0x00000010      // Add change to Dump history
#define CPU_DUMPFIRST  0x00000020      // Make address the first byte in Dump
#define CPU_DUMPFOCUS  0x00000080      // Move focus to Dump
#define CPU_STACKFOCUS 0x00000100      // Move focus to Stack
#define CPU_STACKCTR   0x00000200      // Center stack instead moving to top
#define CPU_REGAUTO    0x00001000      // Automatically switch to FPU/MMX/3DNow!
#define CPU_NOCREATE   0x00002000      // Don't create CPU window if absent
#define CPU_REDRAW     0x00004000      // Redraw CPU window immediately
#define CPU_NOFOCUS    0x00008000      // Don't assign focus to main window
#define CPU_RUNTRACE   0x00010000      // asmaddr is run trace backstep
#define CPU_NOTRACE    0x00020000      // Stop run trace display

// Options for autoregtype.
#define ASR_OFF        0               // No FPU/MMX/3DNow! autoselection
#define ASR_EVENT      1               // Autoselection on debug events
#define ASR_ALWAYS     2               // Autoselection when command selected

#define NHISTORY       1024            // Length of history buffer, records

typedef struct t_histrec {             // Walk history record
  ulong          threadid;             // Thread ID, ignored by Dump pane
  ulong          dumptype;             // Dump type, ignored by Disasm pane
  ulong          addr;                 // Address of first visible line
  ulong          sel0;                 // Begin of selection
  ulong          sel1;                 // End of selection (not included)
} t_histrec;

// Note that hnext points to the free record following the last written, and
// hcurr points record that follows currently selected one.
typedef struct t_history {             // Walk history data
  t_histrec      h[NHISTORY];          // Circular buffer with history records
  int            holdest;              // Index of oldest valid record in h
  int            hnext;                // Index of first free record in h
  int            hcurr;                // Index of record following actual in h
} t_history;

stdapi (void)    Redrawcpudisasm(void);
stdapi (void)    Redrawcpureg(void);
stdapi (ulong)   Getcputhreadid(void);
stdapi (int)     Getcpuruntracebackstep(void);
stdapi (t_dump *) Getcpudisasmdump(void);
stdapi (ulong)   Getcpudisasmselection(void);
stdapi (t_table *) Getcpudisasmtable(void);
stdapi (void)    Addtohistory(t_history *ph,ulong threadid,ulong dumptype,
                   ulong addr,ulong sel0,ulong sel1);
stdapi (int)     Walkhistory(t_history *ph,int dir,ulong *threadid,
                   ulong *dumptype,ulong *addr,ulong *sel0,ulong *sel1);
stdapi (int)     Checkhistory(t_history *ph,int dir,int *isnewest);
stdapi (void)    Setcpu(ulong threadid,ulong asmaddr,ulong dumpaddr,
                   ulong selsize,ulong stackaddr,int mode);


////////////////////////////////////////////////////////////////////////////////
/////////////////////// DEBUGGING AND TRACING FUNCTIONS ////////////////////////

#define NIGNORE        32              // Max. no. of ignored exception ranges
#define NRTPROT        64              // No. of protocolled address ranges

#define FP_SYSBP       0               // First pause on system breakpoint
#define FP_TLS         1               // First pause on TLS callback, if any
#define FP_ENTRY       2               // First pause on program entry point
#define FP_WINMAIN     3               // First pause on WinMain, if known
#define FP_NONE        4               // Run program immediately

#define AP_SYSBP       0               // Attach pause on system breakpoint
#define AP_CODE        1               // Attach pause on program code
#define AP_NONE        2               // Run attached program immediately

#define DP_LOADDLL     0               // Loaddll pause on Loaddll entry point
#define DP_ENTRY       1               // Loaddll pause on DllEntryPoint()
#define DP_LOADED      2               // Loaddll pause after LoadLibrary()
#define DP_NONE        3               // Run Loaddll immediately

#define DR6_SET        0xFFFF0FF0      // DR6 bits specified as always 1
#define DR6_TRAP       0x00004000      // Single-step trap
#define DR6_BD         0x00002000      // Debug register access detected
#define DR6_BHIT       0x0000000F      // Some hardware breakpoint hit
#define   DR6_B3       0x00000008      // Hardware breakpoint 3 hit
#define   DR6_B2       0x00000004      // Hardware breakpoint 2 hit
#define   DR6_B1       0x00000002      // Hardware breakpoint 1 hit
#define   DR6_B0       0x00000001      // Hardware breakpoint 0 hit

#define DR7_GD         0x00002000      // Enable debug register protection
#define DR7_SET        0x00000400      // DR7 bits specified as always 1
#define DR7_EXACT      0x00000100      // Local exact instruction detection
#define DR7_G3         0x00000080      // Enable breakpoint 3 globally
#define DR7_L3         0x00000040      // Enable breakpoint 3 locally
#define DR7_G2         0x00000020      // Enable breakpoint 2 globally
#define DR7_L2         0x00000010      // Enable breakpoint 2 locally
#define DR7_G1         0x00000008      // Enable breakpoint 1 globally
#define DR7_L1         0x00000004      // Enable breakpoint 1 locally
#define DR7_G0         0x00000002      // Enable breakpoint 0 globally
#define DR7_L0         0x00000001      // Enable breakpoint 0 locally

#define DR7_IMPORTANT  (DR7_G3|DR7_L3|DR7_G2|DR7_L2|DR7_G1|DR7_L1|DR7_G0|DR7_L0)

#define NCOND          4               // Number of run trace conditions
#define NRANGE         2               // Number of memory ranges
#define NCMD           2               // Number of commands
#define NMODLIST       24              // Number of modules in pause list

// Run trace condition bits.
#define RTC_COND1      0x00000001      // Stop run trace if condition 1 is met
#define RTC_COND2      0x00000002      // Stop run trace if condition 2 is met
#define RTC_COND3      0x00000004      // Stop run trace if condition 3 is met
#define RTC_COND4      0x00000008      // Stop run trace if condition 4 is met
#define RTC_CMD1       0x00000010      // Stop run trace if command 1 matches
#define RTC_CMD2       0x00000020      // Stop run trace if command 2 matches
#define RTC_INRANGE    0x00000100      // Stop run trace if in range
#define RTC_OUTRANGE   0x00000200      // Stop run trace if out of range
#define RTC_COUNT      0x00000400      // Stop run trace if count is reached
#define RTC_MEM1       0x00001000      // Access to memory range 1
#define RTC_MEM2       0x00002000      // Access to memory range 2
#define RTC_MODCMD     0x00008000      // Attempt to execute modified command

// Run trace protocol types.
#define RTL_ALL        0               // Log all commands
#define RTL_JUMPS      1               // Taken jmp/call/ret/int + destinations
#define RTL_CDEST      2               // Call destinations only
#define RTL_MEM        3               // Access to memory

// Hit trace outside the code section.
#define HTNC_RUN       0               // Continue trace the same way as code
#define HTNC_PAUSE     1               // Pause hit trace if outside the code
#define HTNC_TRACE     2               // Trace command by command (run trace)

// SFX extraction mode.
#define SFM_RUNTRACE   0               // Use run trace to extract SFX
#define SFM_HITTRACE   1               // Use hit trace to extract SFX

typedef struct t_rtcond {              // Run trace break condition
  // These fields are saved to .udd data directly.
  int            options;              // Set of RTC_xxx
  ulong          inrange0;             // Start of in range
  ulong          inrange1;             // End of in range (not included)
  ulong          outrange0;            // Start of out range
  ulong          outrange1;            // End of out range (not included)
  ulong          count;                // Stop count
  ulong          currcount;            // Actual command count
  int            memaccess[NRANGE];    // Type of access (0:R, 1:W, 2:R/W)
  ulong          memrange0[NRANGE];    // Start of memory range
  ulong          memrange1[NRANGE];    // End of memory range
  // These fields are saved to .udd data truncated by first null.
  wchar_t        cond[NCOND][TEXTLEN]; // Conditions as text
  wchar_t        cmd[NCMD][TEXTLEN];   // Matching commands
  // These fields are not saved to .udd data.
  uchar          ccomp[NCOND][TEXTLEN];// Precompiled conditions
  int            validmodels;          // Valid command models, RTC_xxx
  t_asmmod       model[NCMD][NSEARCHCMD]; // Command search models
  int            nmodel[NCMD];         // Number of slots in each model
} t_rtcond;

typedef struct t_rtprot {              // Run trace protocol condition
  int            tracelogtype;         // Commands to protocol, one of RTL_xxx
  int            memranges;            // 0x1: range 1, 0x2: range 2 active
  int            memaccess[NRANGE];    // Type of access (0:R, 1:W, 2:R/W)
  ulong          memrange0[NRANGE];    // Start of memory range
  ulong          memrange1[NRANGE];    // End of memory range
  int            rangeactive;          // Log only commands in the range
  t_range        range[NRTPROT];       // Set of EIP ranges to protocol
} t_rtprot;

stdapi (void)    Suspendallthreads(void);
stdapi (void)    Resumeallthreads(void);
stdapi (int)     Pauseprocess(void);
stdapi (int)     Closeprocess(int confirm);
stdapi (int)     Detachprocess(void);
stdapi (int)     Getlasterror(t_thread *pthr,ulong *error,wchar_t *s);
stdapi (ulong)   Followcall(ulong addr);
stdapi (int)     Run(t_status status,int pass);
stdapi (int)     Checkfordebugevent(void);
stdapi (int)     Addprotocolrange(ulong addr0,ulong addr1);
stdapi (int)     Getruntrace(int nback,t_reg *preg,uchar *cmd);
stdapi (int)     Findruntracerecord(ulong addr0,ulong addr1);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// LIST OF GUIDS /////////////////////////////////

#define GUIDSIZE       16              // GUID size, bytes

stdapi (int)     Getguidname(uchar *data,ulong ndata,wchar_t *name);
stdapi (int)     Isguid(ulong addr,wchar_t *name,int nname);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SOURCE CODE //////////////////////////////////

typedef struct t_srcline {             // Descriptor of source line
  ulong          offset;               // Offset in source text
  int            nextent;              // Number of code extents (-1: unknown)
  int            extent;               // Index of first extent (nextent>0)
} t_srcline;

typedef struct t_srcext {              // Descriptor of code extent
  ulong          amin;                 // Address of the first command
  ulong          amax;                 // Address of last command, included
} t_srcext;

typedef struct t_source {              // Descriptor of source file
  ulong          addr;                 // Module base plus file index
  ulong          size;                 // Dummy parameter, must be 1
  ulong          type;                 // Type, TY_xxx+SRC_xxx
  wchar_t        path[MAXPATH];        // File path
  int            nameoffs;             // Name offset in path, characters
  char           *text;                // Source code in UTF-8 format or NULL
  t_srcline      *line;                // nline+1 line descriptors or NULL
  int            nline;                // Number of lines (0: as yet unknown)
  t_srcext       *extent;              // List of code extents
  int            maxextent;            // Capacity of extent table
  int            nextent;              // Current number of extents
  int            lastline;             // Last selected line
  int            lastoffset;           // Last topmost visible line
} t_source;

stdapi (t_source *) Findsource(ulong base,wchar_t *path);
stdapi (int)     Getsourceline(ulong base,wchar_t *path,int line,int skipspaces,
                   wchar_t *text,wchar_t *fname,t_srcext **extent,int *nextent);
stdapi (int)     Showsourcecode(ulong base,wchar_t *path,int line);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// DEBUGGEE ///////////////////////////////////

// Types of exception in application.
#define AE_NONE        0               // No exception, or caused by OllyDbg
#define AE_APP         1               // Exception in the application
#define AE_SYS         2               // System exception, don't pass

typedef struct t_run {                 // Run status of debugged application
  t_status       status;               // Operation mode, one of STAT_xxx
  ulong          threadid;             // ID of single running thread, 0 if all
  ulong          tpausing;             // Tick count when pausing was requested
  int            wakestep;             // 0: wait, 1: waked, 2: warned
  ulong          eip;                  // EIP at last debugging event
  ulong          ecx;                  // ECX at last debugging event
  ulong          restoreint3addr;      // Address of temporarily removed INT3
  ulong          stepoverdest;         // Destination of STAT_STEPOVER
  int            updatebppage;         // Update temporarily removed bppage's
  DEBUG_EVENT    de;                   // Information from WaitForDebugEvent()
  int            indebugevent;         // Paused on event, threads suspended
  int            netevent;             // Event is from .NET debugger
  int            isappexception;       // Exception in application, AE_xxx
  ulong          lastexception;        // Last exception in application or 0
  int            suspended;            // Suspension counter
  int            suspendonpause;       // Whether first suspension on pause
  int            updatedebugreg;       // 1: set, -1: reset HW breakpoints
  int            dregmodified;         // Debug regs modified by application
} t_run;


////////////////////////////////////////////////////////////////////////////////
//////////// OLLYDBG VARIABLES AND STRUCTURES ACCESSIBLE BY PLUGINS ////////////

// ATTENTION, never, ever change these variables directly! Either use plugin
// API or keep your hands off! Names of variables are preceded with underscore.

///////////////////////////////// DISASSEMBLER /////////////////////////////////

oddata (t_bincmd) bincmd[];            // List of 80x86 commands

oddata (wchar_t *) regname[3][NREG];   // Names of 8/16/32-bit registers
oddata (wchar_t *) segname[NREG];      // Names of segment registers
oddata (wchar_t *) fpuname[2][NREG];   // FPU regs (ST(n) and STn forms)
oddata (wchar_t *) mmxname[NREG];      // Names of MMX/3DNow! registers
oddata (wchar_t *) ssename[NREG];      // Names of SSE registers
oddata (wchar_t *) crname[NREG];       // Names of control registers
oddata (wchar_t *) drname[NREG];       // Names of debug registers
oddata (wchar_t *) sizename[17];       // Data size keywords
oddata (wchar_t *) sizekey[17];        // Keywords for immediate data
oddata (wchar_t *) sizeatt[17];        // Keywords for immediate data, AT&T

/////////////////////////////// OLLYDBG SETTINGS ///////////////////////////////

oddata (wchar_t) ollyfile[MAXPATH];    // Path to OllyDbg
oddata (wchar_t) ollydir[MAXPATH];     // OllyDbg directory w/o backslash
oddata (wchar_t) systemdir[MAXPATH];   // Windows system directory
oddata (wchar_t) plugindir[MAXPATH];   // Plugin data dir without backslash

oddata (HINSTANCE) hollyinst;          // Current OllyDbg instance
oddata (HWND)    hwollymain;           // Handle of the main OllyDbg window
oddata (HWND)    hwclient;             // Handle of MDI client or NULL
oddata (wchar_t) ottable[SHORTNAME];   // Class of table windows
oddata (ulong)   cpufeatures;          // CPUID feature information
oddata (int)     ischild;              // Whether child debugger

oddata (int)     asciicodepage;        // Code page to display ASCII dumps
#ifdef FILE                            // Requires <stdio.h>
oddata (FILE *)  tracefile;            // System log file or NULL
#endif
oddata (int)     restorewinpos;        // Restore window position & appearance

////////////////////////////// OLLYDBG STRUCTURES //////////////////////////////

oddata (t_font)  font[NFIXFONTS];      // Fixed fonts used in table windows
oddata (t_font)  sysfont;              // Proportional system font
oddata (t_font)  titlefont;            // Proportional, 2x height of sysfont
oddata (t_font)  fixfont;              // Fixed system font
oddata (COLORREF) color[NCOLORS];      // Colours used by OllyDbg
oddata (t_scheme) scheme[NSCHEMES];    // Colour schemes used in table windows
oddata (t_scheme) hilite[NHILITE];     // Colour schemes used for highlighting

/////////////////////////////////// DEBUGGEE ///////////////////////////////////

oddata (wchar_t) executable[MAXPATH];  // Path to main (.exe) file
oddata (wchar_t) arguments[ARGLEN];    // Command line passed to debuggee

oddata (int)     netdbg;               // .NET debugging active
oddata (int)     rundll;               // Debugged file is a DLL
oddata (HANDLE)  process;              // Handle of Debuggee or NULL
oddata (ulong)   processid;            // Process ID of Debuggee or 0
oddata (ulong)   mainthreadid;         // Thread ID of main thread or 0
oddata (t_run)   run;                  // Run status of debugged application
oddata (int)     skipsystembp;         // First system INT3 not yet hit

oddata (ulong)   debugbreak;           // Address of DebugBreak() in Debuggee
oddata (ulong)   dbgbreakpoint;        // Address of DbgBreakPoint() in Debuggee
oddata (ulong)   kiuserexcept;         // Address of KiUserExceptionDispatcher()
oddata (ulong)   zwcontinue;           // Address of ZwContinue() in Debuggee
oddata (ulong)   uefilter;             // Address of UnhandledExceptionFilter()
oddata (ulong)   ntqueryinfo;          // Address of NtQueryInformationProcess()
oddata (ulong)   corexemain;           // Address of MSCOREE:_CorExeMain()
oddata (ulong)   peblock;              // Address of PE block in Debuggee
oddata (ulong)   kusershareddata;      // Address of KUSER_SHARED_DATA
oddata (ulong)   userspacelimit;       // Size of virtual process memory

oddata (t_rtcond) rtcond;              // Run trace break condition
oddata (t_rtprot) rtprot;              // Run trace protocol condition

///////////////////////////////// DATA TABLES //////////////////////////////////

oddata (t_table) list;                 // List descriptor
oddata (t_sorted) premod;              // Preliminary module data
oddata (t_table) module;               // Loaded modules
oddata (t_sorted) aqueue;              // Modules that are not yet analysed
oddata (t_table) thread;               // Active threads
oddata (t_table) memory;               // Allocated memory blocks
oddata (t_table) win;                  // List of windows
oddata (t_table) bpoint;               // INT3 breakpoints
oddata (t_table) bpmem;                // Memory breakpoints
oddata (t_sorted) bppage;              // Memory pages with changed attributes
oddata (t_table) bphard;               // Hardware breakpoints
oddata (t_table) watch;                // Watch expressions
oddata (t_table) patch;                // List of patches from previous runs
oddata (t_sorted) procdata;            // Descriptions of analyzed procedures
oddata (t_table) source;               // List of source files
oddata (t_table) srccode;              // Source code


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PLUGIN EXPORTS ////////////////////////////////

// Relatively infrequent events passed to ODBG2_Pluginnotify().
#define PN_NEWPROC     1               // New process is created
#define PN_ENDPROC     2               // Process is terminated
#define PN_NEWTHR      3               // New thread is created
#define PN_ENDTHR      4               // Thread is terminated
#define PN_PREMOD      5               // New module is reported by Windows
#define PN_NEWMOD      6               // New module is added to the table
#define PN_ENDMOD      7               // Module is removed from the memory
#define PN_STATUS      8               // Execution status has changed
#define PN_REMOVE      16              // OllyDbg removes analysis from range
#define PN_RUN         24              // User continues code execution

// Flags returned by ODBG2_Pluginexception().
#define PE_IGNORED     0x00000000      // Plugin does not process exception
#define PE_CONTINUE    0x00000001      // Exception by plugin, continue
#define PE_STEP        0x00000002      // Exception by plugin, execute command
#define PE_PAUSE       0x00000004      // Exception by plugin, pause program

pentry (int)         ODBG2_Pluginquery(int ollydbgversion,ulong *features,
                       wchar_t pluginname[SHORTNAME],
                       wchar_t pluginversion[SHORTNAME]);
pentry (int)         ODBG2_Plugininit(void);
pentry (void)        ODBG2_Pluginanalyse(t_module *pmod);
pentry (void)        ODBG2_Pluginmainloop(DEBUG_EVENT *debugevent);
pentry (int)         ODBG2_Pluginexception(t_run *prun,const t_disasm *da,
                       t_thread *pthr,t_reg *preg,wchar_t *message);
pentry (void)        ODBG2_Plugintempbreakpoint(ulong addr,
                       const t_disasm *da,t_thread *pthr,t_reg *preg);
pentry (void)        ODBG2_Pluginnotify(int code,void *data,
                       ulong parm1,ulong parm2);
pentry (int)         ODBG2_Plugindump(t_dump *pd,wchar_t *s,uchar *mask,
                       int n,int *select,ulong addr,int column);
pentry (t_menu *)    ODBG2_Pluginmenu(wchar_t *type);
pentry (t_control *) ODBG2_Pluginoptions(UINT msg,WPARAM wp,LPARAM lp);
pentry (void)        ODBG2_Pluginsaveudd(t_uddsave *psave,t_module *pmod,
                       int ismainmodule);
pentry (void)        ODBG2_Pluginuddrecord(t_module *pmod,int ismainmodule,
                       ulong tag,ulong size,void *data);
pentry (void)        ODBG2_Pluginreset(void);
pentry (int)         ODBG2_Pluginclose(void);
pentry (void)        ODBG2_Plugindestroy(void);

#ifdef _MSC_VER
  #pragma pack(pop)
#endif

#ifdef __MINGW32__
  #pragma pack(pop)
#endif

#endif                                 // __ODBG_PLUGIN_H



================================================
File: plugin_x64dbg.c
================================================
#include "stdafx.h"
#include "plugin.h"

HWND hwollymain;

// Config functions

BOOL MyGetintfromini(HINSTANCE dllinst, TCHAR *key, int *p_val, int min, int max, int def)
{
	duint val;

	if(!BridgeSettingGetUint(DEF_PLUGINNAME, key, &val) || (val & ~0xFFFFFFFF) != 0)
	{
		*p_val = def;

		return FALSE;
	}

	int val_int = (int)val;

	if(min && max && (val_int < min || val_int > max))
		*p_val = def;
	else
		*p_val = val_int;

	return TRUE;
}

BOOL MyWriteinttoini(HINSTANCE dllinst, TCHAR *key, int val)
{
	return BridgeSettingSetUint(DEF_PLUGINNAME, key, val) != false;
}

int MyGetstringfromini(HINSTANCE dllinst, TCHAR *key, TCHAR *s, int length)
{
	char *buf;
	int len;

	if(length >= MAX_SETTING_SIZE)
	{
		if(!BridgeSettingGet(DEF_PLUGINNAME, key, s))
		{
			*s = '\0';
			return 0;
		}

		return lstrlen(s);
	}

	buf = (char *)HeapAlloc(GetProcessHeap(), 0, MAX_SETTING_SIZE*sizeof(char));
	if(!buf)
		return 0;

	if(!BridgeSettingGet(DEF_PLUGINNAME, key, buf))
	{
		HeapFree(GetProcessHeap(), 0, buf);
		*s = '\0';
		return 0;
	}

	len = lstrlen(buf);
	if(len > length - 1)
		len = length - 1;

	lstrcpyn(s, buf, len + 1);

	HeapFree(GetProcessHeap(), 0, buf);

	return len;
}

BOOL MyWritestringtoini(HINSTANCE dllinst, TCHAR *key, TCHAR *s)
{
	return BridgeSettingSet(DEF_PLUGINNAME, key, s) != false;
}

// Assembler functions

DWORD SimpleDisasm(BYTE *cmd, SIZE_T cmdsize, DWORD_PTR ip, BYTE *dec, BOOL bSizeOnly,
	TCHAR *pszResult, DWORD_PTR *jmpconst, DWORD_PTR *adrconst, DWORD_PTR *immconst)
{
	BYTE cmd_safe[MAXCMDSIZE];
	if(cmdsize < MAXCMDSIZE)
	{
		CopyMemory(cmd_safe, cmd, cmdsize);
		ZeroMemory(cmd_safe + cmdsize, MAXCMDSIZE - cmdsize);
		cmd = cmd_safe;
	}

	BASIC_INSTRUCTION_INFO basicinfo;
	if(!DbgFunctions()->DisasmFast(cmd, ip, &basicinfo))
		return 0;

	if(!bSizeOnly)
	{
		if(basicinfo.type == TYPE_ADDR &&
			basicinfo.branch &&
			!basicinfo.call &&
			basicinfo.size == 2)
		{
			// Add "short" for a short jump

			// We add 6 chars, make sure that basicinfo.instruction is not too long
			basicinfo.instruction[COMMAND_MAX_LEN - 1 - 6] = '\0';

			BOOL bUppercase = (basicinfo.instruction[0] >= 'A' && basicinfo.instruction[0] <= 'Z');

			char *p = basicinfo.instruction;
			char *q = pszResult;

			// Copy command name
			while(*p != '\0' && *p != ' ' && *p != '\t')
			{
				*q++ = *p++;
			}

			// Copy spaces
			while(*p == ' ' || *p == '\t')
			{
				*q++ = *p++;
			}

			if(*p != '\0')
			{
				// Add "short "
				lstrcpy(q, bUppercase ? "SHORT " : "short ");
				q += 6;
			}

			// Copy the rest
			lstrcpy(q, p);
		}
		else
		{
			// pszResult should have at least COMMAND_MAX_LEN chars
			lstrcpy(pszResult, basicinfo.instruction);
		}

		*jmpconst = basicinfo.addr;
		*adrconst = basicinfo.memory.value;
		*immconst = basicinfo.value.value;
	}

	return basicinfo.size;
}

int AssembleShortest(TCHAR *lpCommand, DWORD_PTR dwAddress, BYTE *bBuffer, TCHAR *lpError)
{
	int size;
	if(!DbgFunctions()->Assemble(dwAddress, bBuffer, &size, lpCommand, lpError))
		return 0;

	return size;
}

int AssembleWithGivenSize(TCHAR *lpCommand, DWORD_PTR dwAddress, int nReqSize, BYTE *bBuffer, TCHAR *lpError)
{
	int size;
	if(!DbgFunctions()->Assemble(dwAddress, bBuffer, &size, lpCommand, lpError))
		return 0;

	// TODO: fix when implemented
	if(size > nReqSize)
	{
		lstrcpy(lpError, "AssembleWithGivenSize: internal assembler error");
		return 0;
	}

	while(size < nReqSize)
		bBuffer[size++] = 0x90; // Fill with NOPs

	return size;
}

// Memory functions

BOOL SimpleReadMemory(void *buf, DWORD_PTR addr, SIZE_T size)
{
	return DbgMemRead(addr, buf, size);
}

BOOL SimpleWriteMemory(void *buf, DWORD_PTR addr, SIZE_T size)
{
	return DbgFunctions()->MemPatch(addr, buf, size);
}

// Symbolic functions

int GetLabel(DWORD_PTR addr, TCHAR *name)
{
	if(!DbgGetLabelAt(addr, SEG_DEFAULT, name))
		return 0;

	return lstrlen(name);
}

int GetComment(DWORD_PTR addr, TCHAR *name)
{
	if(!DbgGetCommentAt(addr, name))
		return 0;

	if(name[0] == '\1') // Automatic comment
		return 0;

	return lstrlen(name);
}

BOOL QuickInsertLabel(DWORD_PTR addr, TCHAR *s)
{
	return DbgSetLabelAt(addr, s);
}

BOOL QuickInsertComment(DWORD_PTR addr, TCHAR *s)
{
	return DbgSetCommentAt(addr, s);
}

void MergeQuickData(void)
{
}

void DeleteRangeLabels(DWORD_PTR addr0, DWORD_PTR addr1)
{
	DbgClearLabelRange(addr0, addr1);
}

void DeleteRangeComments(DWORD_PTR addr0, DWORD_PTR addr1)
{
	DbgClearCommentRange(addr0, addr1);
}

// Module functions

PLUGIN_MODULE FindModuleByName(TCHAR *lpModule)
{
	return (PLUGIN_MODULE)DbgFunctions()->ModBaseFromName(lpModule);
}

PLUGIN_MODULE FindModuleByAddr(DWORD_PTR dwAddress)
{
	return (PLUGIN_MODULE)DbgFunctions()->ModBaseFromAddr(dwAddress);
}

DWORD_PTR GetModuleBase(PLUGIN_MODULE module)
{
	return (DWORD_PTR)module;
}

SIZE_T GetModuleSize(PLUGIN_MODULE module)
{
	return DbgFunctions()->ModSizeFromAddr((duint)module);
}

BOOL GetModuleName(PLUGIN_MODULE module, TCHAR *pszModuleName)
{
	return DbgFunctions()->ModNameFromAddr((duint)module, pszModuleName, FALSE);
}

BOOL IsModuleWithRelocations(PLUGIN_MODULE module)
{
	IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER *)module;

	LONG e_lfanew;
	if(!DbgMemRead(
		(ULONG_PTR)&pDosHeader->e_lfanew,
		(BYTE *)&e_lfanew,
		sizeof(LONG)))
	{
		return FALSE;
	}

	IMAGE_NT_HEADERS *pNtHeader = (IMAGE_NT_HEADERS *)((char *)pDosHeader + e_lfanew);

	DWORD dwRelocVirtualAddress;
	if(!DbgMemRead(
		(ULONG_PTR)&pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress,
		(BYTE *)&dwRelocVirtualAddress,
		sizeof(DWORD)))
	{
		return FALSE;
	}

	return dwRelocVirtualAddress != 0;
}

// Memory functions

PLUGIN_MEMORY FindMemory(DWORD_PTR dwAddress)
{
	return (PLUGIN_MEMORY)DbgMemFindBaseAddr(dwAddress, NULL);
}

DWORD_PTR GetMemoryBase(PLUGIN_MEMORY mem)
{
	return (DWORD_PTR)mem;
}

SIZE_T GetMemorySize(PLUGIN_MEMORY mem)
{
	SIZE_T size;
	if(!DbgMemFindBaseAddr((duint)mem, &size))
		return 0;

	return size;
}

void EnsureMemoryBackup(PLUGIN_MEMORY mem)
{
}

// Analysis functions

BYTE *FindDecode(DWORD_PTR addr, SIZE_T *psize)
{
	// TODO: not implemented
	return NULL;
}

int DecodeGetType(BYTE decode)
{
	// TODO: not implemented
	return DECODE_UNKNOWN;
}

// Misc.

BOOL IsProcessLoaded()
{
	return DbgIsDebugging();
}

void SuspendAllThreads()
{
	// Note: I'm not sure it's required to be implemented here
	// It's recommended to call for OllyDbg v2, though

	//ThreaderPauseAllThreads(false);
}

void ResumeAllThreads()
{
	// Note: I'm not sure it's required to be implemented here
	// It's recommended to call for OllyDbg v2, though

	//ThreaderResumeAllThreads(false);
}

DWORD_PTR GetCpuBaseAddr()
{
	SELECTIONDATA selection;

	if(!GuiSelectionGet(GUI_DISASSEMBLY, &selection))
		return 0;
		
	return DbgMemFindBaseAddr(selection.start, NULL);
}

void InvalidateGui()
{
	GuiUpdateAllViews();
}



================================================
File: plugin_x64dbg.h
================================================
#pragma once

#include "x64dbg_pluginsdk/_plugins.h"

extern HWND hwollymain;

#define COMMAND_MAX_LEN       (MAX_MNEMONIC_SIZE*4)
#define MODULE_MAX_LEN        MAX_MODULE_SIZE
#define LABEL_MAX_LEN         MAX_LABEL_SIZE
#define COMMENT_MAX_LEN       MAX_COMMENT_SIZE

#define MAXCMDSIZE            16

typedef void *PLUGIN_MODULE;
typedef void *PLUGIN_MEMORY;



================================================
File: pointer_redirection.c
================================================
#include "stdafx.h"
#include "pointer_redirection.h"

static void PatchPtr(void **ppAddress, void *pPtr)
{
	DWORD dwOldProtect, dwOtherProtect;

	VirtualProtect(ppAddress, sizeof(void *), PAGE_EXECUTE_READWRITE, &dwOldProtect);
	*ppAddress = pPtr;
	VirtualProtect(ppAddress, sizeof(void *), dwOldProtect, &dwOtherProtect);
}

void PointerRedirectionAdd(void **pp, void *pNew, POINTER_REDIRECTION *ppr)
{
	PatchPtr(&ppr->pOriginalAddress, *pp);
	PatchPtr(&ppr->pRedirectionAddress, pNew);

	PatchPtr(pp, &ppr->bAsmCommand);
}

void PointerRedirectionRemove(void **pp, POINTER_REDIRECTION *ppr)
{
	POINTER_REDIRECTION *pprTemp;

	if(*pp != ppr->bAsmCommand)
	{
		pprTemp = (POINTER_REDIRECTION *)((BYTE *)*pp - offsetof(POINTER_REDIRECTION, bAsmCommand));
		while(pprTemp->pOriginalAddress != ppr->bAsmCommand)
			pprTemp = (POINTER_REDIRECTION *)((BYTE *)pprTemp->pOriginalAddress - offsetof(POINTER_REDIRECTION, bAsmCommand));

		PatchPtr(&pprTemp->pOriginalAddress, ppr->pOriginalAddress);
	}
	else
		PatchPtr(pp, ppr->pOriginalAddress);
}

void *PointerRedirectionGetOriginalPtr(void **pp)
{
	void *p = *pp;

	for(;;)
	{
		const BYTE *pCompare = POINTER_REDIRECTION_ASM_COMMAND POINTER_REDIRECTION_SIGNATURE;
		int nCompareLen = sizeof(POINTER_REDIRECTION_ASM_COMMAND POINTER_REDIRECTION_SIGNATURE) - 1;
		BYTE *pByte = p;

		for(int i = 0; i < nCompareLen; i++)
		{
			if(pByte[i] != pCompare[i])
				return p;
		}

		POINTER_REDIRECTION *pprTemp = (POINTER_REDIRECTION *)(pByte - offsetof(POINTER_REDIRECTION, bAsmCommand));
		p = pprTemp->pOriginalAddress;
	}
}



================================================
File: pointer_redirection.h
================================================
#ifndef _POINTER_REDIRECTION_H_
#define _POINTER_REDIRECTION_H_

#ifdef _WIN64
#define POINTER_REDIRECTION_ASM_COMMAND "\xFF\x25\xF2\xFF\xFF\xFF"
#else
#define POINTER_REDIRECTION_ASM_COMMAND "\xE8\x00\x00\x00\x00\x58\xFF\x60\xF7"
#endif

#define POINTER_REDIRECTION_SIGNATURE "ptr_redr"

typedef struct {
	void *pOriginalAddress;
	void *pRedirectionAddress;
	BYTE bAsmCommand[sizeof(POINTER_REDIRECTION_ASM_COMMAND) - 1];
	BYTE bSignature[sizeof(POINTER_REDIRECTION_SIGNATURE) - 1];
} POINTER_REDIRECTION;

#define POINTER_REDIRECTION_VAR(var) \
	__pragma(code_seg(push, stack1, ".text")) \
	__declspec(allocate(".text")) var = \
		{ DebugBreak, DebugBreak, POINTER_REDIRECTION_ASM_COMMAND, POINTER_REDIRECTION_SIGNATURE }; \
	__pragma(code_seg(pop, stack1))

void PointerRedirectionAdd(void **pp, void *pNew, POINTER_REDIRECTION *ppr);
void PointerRedirectionRemove(void **pp, POINTER_REDIRECTION *ppr);
void *PointerRedirectionGetOriginalPtr(void **pp);

#endif // _POINTER_REDIRECTION_H_



================================================
File: raedit.h
================================================
#pragma once

#include <windows.h>
#include <richedit.h>

#pragma pack(push, 1)

// Default colors
#define BCKCLR				0x00C0F0F0
#define TXTCLR				0x00000000
#define SELBCKCLR			0x00800000
#define SELTXTCLR			0x00FFFFFF
#define CMNTCLR				0x02008000
#define STRCLR				0x00A00000
#define OPRCLR				0x000000A0
#define HILITE1				0x00F0C0C0
#define HILITE2				0x00C0F0C0
#define HILITE3				0x00C0C0F0
#define SELBARCLR			0x00C0C0C0
#define SELBARPEN			0x00808080
#define LNRCLR				0x00800000
#define NUMCLR				0x00808080
#define CMNTBCK				0x00C0F0F0
#define STRBCK				0x00C0F0F0
#define NUMBCK				0x00C0F0F0
#define OPRBCK				0x00C0F0F0
#define CHANGEDCLR			0x0000F0F0
#define CHANGESAVEDCLR		0x0000F000

// Window styles
#define STYLE_NOSPLITT			0x0001			// No splitt button
#define STYLE_NOLINENUMBER		0x0002			// No linenumber button
#define STYLE_NOCOLLAPSE		0x0004			// No expand/collapse buttons
#define STYLE_NOHSCROLL			0x0008			// No horizontal scrollbar
#define STYLE_NOVSCROLL			0x0010			// No vertical scrollbar
#define STYLE_NOHILITE			0x0020			// No color hiliting
#define STYLE_NOSIZEGRIP		0x0040			// No size grip
#define STYLE_NODBLCLICK		0x0080			// No action on double clicks
#define STYLE_READONLY			0x0100			// Text is locked
#define STYLE_NODIVIDERLINE		0x0200			// Blocks are not divided by line
#define STYLE_NOBACKBUFFER		0x0400			// Drawing directly to screen DC
#define STYLE_NOSTATE			0x0800			// No state indicator
#define STYLE_DRAGDROP			0x1000			// Drag & Drop support, app must load ole
#define STYLE_SCROLLTIP			0x2000			// Scrollbar tooltip
#define STYLE_HILITECOMMENT		0x4000			// Comments are hilited
#define STYLE_AUTOSIZELINENUM	0x8000			// Line number column autosizes

// Styles used with REM_SETSTYLEEX message
#define STYLEEX_LOCK			0x0001			// Show lock button
#define STYLEEX_BLOCKGUIDE		0x0002			// Show block guiders
#define STILEEX_LINECHANGED		0x0004			// Show line changed state
#define STILEEX_STRINGMODEFB	0x0008			// FreeBasic
#define STILEEX_STRINGMODEC		0x0010			// C/C++

// Edit modes
#define MODE_NORMAL				0				// Normal
#define MODE_BLOCK				1				// Block select
#define MODE_OVERWRITE			2				// Overwrite

// REM_COMMAND commands
#define CMD_LEFT				1
#define CMD_RIGHT				2
#define CMD_LINE_UP				3
#define CMD_LINE_DOWN			4
#define CMD_PAGE_UP				5
#define CMD_PAGE_DOWN			6
#define CMD_HOME				7
#define CMD_END					8
#define CMD_INSERT				9
#define CMD_DELETE				10
#define CMD_BACKSPACE			11
// REM_COMMAND modifyers
#define CMD_ALT					256
#define CMD_CTRL				512
#define CMD_SHIFT				1024

// Private edit messages
#define REM_RAINIT				(WM_USER+9999)	// wParam=0, lParam=pointer to controls DIALOG struct
#define REM_BASE				(WM_USER+1000)
#define REM_SETHILITEWORDS		(REM_BASE+0)		// wParam=Color, lParam=lpszWords
#define REM_SETFONT				(REM_BASE+1)		// wParam=nLineSpacing, lParam=lpRAFONT
#define REM_GETFONT				(REM_BASE+2)		// wParam=0, lParam=lpRAFONT
#define REM_SETCOLOR			(REM_BASE+3)		// wParam=0, lParam=lpRACOLOR
#define REM_GETCOLOR			(REM_BASE+4)		// wParam=0, lParam=lpRACOLOR
#define REM_SETHILITELINE		(REM_BASE+5)		// wParam=Line, lParam=Color
#define REM_GETHILITELINE		(REM_BASE+6)		// wParam=Line, lParam=0
#define REM_SETBOOKMARK			(REM_BASE+7)		// wParam=Line, lParam=Type
#define REM_GETBOOKMARK			(REM_BASE+8)		// wParam=Line, lParam=0
#define REM_CLRBOOKMARKS		(REM_BASE+9)		// wParam=0, lParam=Type
#define REM_NXTBOOKMARK			(REM_BASE+10)		// wParam=Line, lParam=Type
#define REM_PRVBOOKMARK			(REM_BASE+11)		// wParam=Line, lParam=Type
#define REM_FINDBOOKMARK		(REM_BASE+12)		// wParam=BmID, lParam=0
#define REM_SETBLOCKS			(REM_BASE+13)		// wParam=[lpLINERANGE], lParam=0
#define REM_ISLINE				(REM_BASE+14)		// wParam=Line, lParam=lpszDef
#define REM_GETWORD				(REM_BASE+15)		// wParam=BuffSize, lParam=lpBuff
#define REM_COLLAPSE			(REM_BASE+16)		// wParam=Line, lParam=0
#define REM_COLLAPSEALL			(REM_BASE+17)		// wParam=0, lParam=0
#define REM_EXPAND				(REM_BASE+18)		// wParam=Line, lParam=0
#define REM_EXPANDALL			(REM_BASE+19)		// wParam=0, lParam=0
#define REM_LOCKLINE			(REM_BASE+20)		// wParam=Line, lParam=TRUE/FALSE
#define REM_ISLINELOCKED		(REM_BASE+21)		// wParam=Line, lParam=0
#define REM_HIDELINE			(REM_BASE+22)		// wParam=Line, lParam=TRUE/FALSE
#define REM_ISLINEHIDDEN		(REM_BASE+23)		// wParam=Line, lParam=0
#define REM_AUTOINDENT			(REM_BASE+24)		// wParam=0, lParam=TRUE/FALSE
#define REM_TABWIDTH			(REM_BASE+25)		// wParam=nChars, lParam=TRUE/FALSE (Expand tabs)
#define REM_SELBARWIDTH			(REM_BASE+26)		// wParam=nWidth, lParam=0
#define REM_LINENUMBERWIDTH		(REM_BASE+27)		// wParam=nWidth, lParam=0
#define REM_MOUSEWHEEL			(REM_BASE+28)		// wParam=nLines, lParam=0
#define REM_SUBCLASS			(REM_BASE+29)		// wParam=0, lParam=lpWndProc
#define REM_SETSPLIT			(REM_BASE+30)		// wParam=nSplit, lParam=0
#define REM_GETSPLIT			(REM_BASE+31)		// wParam=0, lParam=0
#define REM_VCENTER				(REM_BASE+32)		// wParam=0, lParam=0
#define REM_REPAINT				(REM_BASE+33)		// wParam=0, lParam=TRUE/FALSE (Paint Now)
#define REM_BMCALLBACK			(REM_BASE+34)		// wParam=0, lParam=lpBmProc
#define REM_READONLY			(REM_BASE+35)		// wParam=0, lParam=TRUE/FALSE
#define REM_INVALIDATELINE		(REM_BASE+36)		// wParam=Line, lParam=0
#define REM_SETPAGESIZE			(REM_BASE+37)		// wParam=nLines, lParam=0
#define REM_GETPAGESIZE			(REM_BASE+38)		// wParam=0, lParam=0
#define REM_GETCHARTAB			(REM_BASE+39)		// wParam=nChar, lParam=0
#define REM_SETCHARTAB			(REM_BASE+40)		// wParam=nChar, lParam=nValue
#define REM_SETCOMMENTBLOCKS	(REM_BASE+41)		// wParam=lpStart, lParam=lpEnd
#define REM_SETWORDGROUP		(REM_BASE+42)		// wParam=0, lParam=nGroup (0-15)
#define REM_GETWORDGROUP		(REM_BASE+43)		// wParam=0, lParam=0
#define REM_SETBMID				(REM_BASE+44)		// wParam=nLine, lParam=nBmID
#define REM_GETBMID				(REM_BASE+45)		// wParam=nLine, lParam=0
#define REM_ISCHARPOS			(REM_BASE+46)		// wParam=CP, lParam=0, returns 1 if comment block, 2 if comment, 3 if string
#define REM_HIDELINES			(REM_BASE+47)		// wParam=nLine, lParam=nLines
#define REM_SETDIVIDERLINE		(REM_BASE+48)		// wParam=nLine, lParam=TRUE/FALSE
#define REM_ISINBLOCK			(REM_BASE+49)		// wParam=nLine, lParam=lpRABLOCKDEF
#define REM_TRIMSPACE			(REM_BASE+50)		// wParam=nLine, lParam=fLeft
#define REM_SAVESEL				(REM_BASE+51)		// wParam=0, lParam=0
#define REM_RESTORESEL			(REM_BASE+52)		// wParam=0, lParam=0
#define REM_GETCURSORWORD		(REM_BASE+53)		// wParam=BuffSize, lParam=lpBuff, Returns line number
#define REM_SETSEGMENTBLOCK		(REM_BASE+54)		// wParam=nLine, lParam=TRUE/FALSE
#define REM_GETMODE				(REM_BASE+55)		// wParam=0, lParam=0
#define REM_SETMODE				(REM_BASE+56)		// wParam=nMode, lParam=0
#define REM_GETBLOCK			(REM_BASE+57)		// wParam=0, lParam=lpBLOCKRANGE
#define REM_SETBLOCK			(REM_BASE+58)		// wParam=0, lParam=lpBLOCKRANGE
#define REM_BLOCKINSERT			(REM_BASE+59)		// wParam=0, lParam=lpText
#define REM_LOCKUNDOID			(REM_BASE+60)		// wParam=TRUE/FALSE, lParam=0
#define REM_ADDBLOCKDEF			(REM_BASE+61)		// wParam=0, lParam=lpRABLOCKDEF
#define REM_CONVERT				(REM_BASE+62)		// wParam=nType, lParam=0
#define REM_BRACKETMATCH		(REM_BASE+63)		// wParam=0, lParam=lpDef {[(,}]),_
#define REM_COMMAND				(REM_BASE+64)		// wParam=nCommand, lParam=0
#define REM_CASEWORD			(REM_BASE+65)		// wParam=cp, lParam=lpWord
#define REM_GETBLOCKEND			(REM_BASE+66)		// wParam=Line, lParam=0
#define REM_SETLOCK				(REM_BASE+67)		// wParam=TRUE/FALSE, lParam=0
#define REM_GETLOCK				(REM_BASE+68)		// wParam=0, lParam=0
#define REM_GETWORDFROMPOS		(REM_BASE+69)		// wParam=cp, lParam=lpBuff
#define REM_SETNOBLOCKLINE		(REM_BASE+70)		// wParam=Line, lParam=TRUE/FALSE
#define REM_ISLINENOBLOCK		(REM_BASE+71)		// wParam=Line, lParam=0
#define REM_SETALTHILITELINE	(REM_BASE+72)		// wParam=Line, lParam=TRUE/FALSE
#define REM_ISLINEALTHILITE		(REM_BASE+73)		// wParam=Line, lParam=0
#define REM_SETCURSORWORDTYPE	(REM_BASE+74)		// wParam=nType, lParam=0
#define REM_SETBREAKPOINT		(REM_BASE+75)		// wParam=nLine, lParam=TRUE/FALSE
#define REM_NEXTBREAKPOINT		(REM_BASE+76)		// wParam=nLine, lParam=0
#define REM_GETLINESTATE		(REM_BASE+77)		// wParam=nLine, lParam=0
#define REM_SETERROR			(REM_BASE+78)		// wParam=nLine, lParam=nErrID
#define REM_GETERROR			(REM_BASE+79)		// wParam=nLine, lParam=0
#define REM_NEXTERROR			(REM_BASE+80)		// wParam=nLine, lParam=0
#define REM_CHARTABINIT			(REM_BASE+81)		// wParam=0, lParam=0
#define REM_LINEREDTEXT			(REM_BASE+82)		// wParam=nLine, lParam=TRUE/FALSE
#define REM_SETSTYLEEX			(REM_BASE+83)		// wParam=nStyleEx, lParam=0
#define REM_GETUNICODE			(REM_BASE+84)		// wParam=0, lParam=0
#define REM_SETUNICODE			(REM_BASE+85)		// wParam=TRUE/FALSE, lParam=0
#define REM_SETCHANGEDSTATE		(REM_BASE+86)		// wParam=TRUE/FALSE, lParam=0
#define REM_SETTOOLTIP			(REM_BASE+87)		// wParam=n (1-6), lParam=lpText
#define REM_HILITEACTIVELINE	(REM_BASE+88)		// wParam=0, lParam=nColor
#define REM_GETUNDO				(REM_BASE+89)		// wParam=nSize, lParam=lpMem
#define REM_SETUNDO				(REM_BASE+90)		// wParam=nSize, lParam=lpMem
#define REM_GETLINEBEGIN		(REM_BASE+91)		// wParam=nLine, lParam=0

// Convert types
#define CONVERT_TABTOSPACE		0
#define CONVERT_SPACETOTAB		1
#define CONVERT_UPPERCASE		2
#define CONVERT_LOWERCASE		3

// Line hiliting
#define STATE_HILITEOFF			0
#define STATE_HILITE1			1
#define STATE_HILITE2			2
#define STATE_HILITE3			3
#define STATE_HILITEMASK		3

// Bookmarks
#define STATE_BMOFF				0x00
#define STATE_BM1				0x10
#define STATE_BM2				0x20
#define STATE_BM3				0x30
#define STATE_BM4				0x40
#define STATE_BM5				0x50
#define STATE_BM6				0x60
#define STATE_BM7				0x70
#define STATE_BM8				0x80
#define STATE_BMMASK			0x0F0

// Line states
#define STATE_LOCKED			0x00000100
#define STATE_HIDDEN			0x00000200
#define STATE_COMMENT			0x00000400
#define STATE_DIVIDERLINE		0x00000800
#define STATE_SEGMENTBLOCK		0x00001000
#define STATE_NOBLOCK			0x00002000
#define STATE_ALTHILITE			0x00004000
#define STATE_BREAKPOINT		0x00008000
#define STATE_BLOCKSTART		0x00010000
#define STATE_BLOCK				0x00020000
#define STATE_BLOCKEND			0x00040000
#define STATE_REDTEXT			0x00080000
#define STATE_COMMENTNEST		0x00100000
#define STATE_CHANGED			0x00200000
#define STATE_CHANGESAVED		0x00400000
#define STATE_GARBAGE			0x80000000

// Character table types
#define CT_NONE					0
#define CT_CHAR					1
#define CT_OPER					2
#define CT_HICHAR				3
#define CT_CMNTCHAR				4
#define CT_STRING				5
#define CT_CMNTDBLCHAR			6
#define CT_CMNTINITCHAR			7

// Find
#define FR_IGNOREWHITESPACE		0x8000000

struct tagRAFONT {
	HFONT hFont;        // Code edit normal
	HFONT hIFont;       // Code edit italics
	HFONT hLnrFont;     // Line numbers
};
typedef struct tagRAFONT RAFONT;

struct tagRACOLOR {
	COLORREF   bckcol;						// Back color
	COLORREF   txtcol;						// Text color
	COLORREF   selbckcol;					// Sel back color
	COLORREF   seltxtcol;					// Sel text color
	COLORREF   cmntcol;						// Comment color
	COLORREF   strcol;						// String color
	COLORREF   oprcol;						// Operator color
	COLORREF   hicol1;						// Line hilite 1
	COLORREF   hicol2;						// Line hilite 2
	COLORREF   hicol3;						// Line hilite 3
	COLORREF   selbarbck;					// Selection bar
	COLORREF   selbarpen;					// Selection bar pen
	COLORREF   lnrcol;						// Line numbers color
	COLORREF   numcol;						// Numbers & hex color
	COLORREF   cmntback;					// Comment back color
	COLORREF   strback;						// String back color
	COLORREF   numback;						// Numbers & hex back color
	COLORREF   oprback;						// Operator back color
	COLORREF   changed;						// Line changed indicator
	COLORREF   changesaved;					// Line saved chane indicator
};
typedef struct tagRACOLOR RACOLOR;

struct tagRASELCHANGE {
	NMHDR       nmhdr;
	CHARRANGE   chrg;                       // Current selection
	WORD        seltyp;                     // SEL_TEXT or SEL_OBJECT
	DWORD       line;                       // Line number
	DWORD       cpLine;                     // Character position of first character
	HANDLE      lpLine;                     // Pointer to line
	DWORD       nlines;                     // Total number of lines
	DWORD       nhidden;                    // Total number of hidden lines
	BOOL        fchanged;                   // TRUE if changed since last
	DWORD       npage;                      // Page number
	DWORD       nWordGroup;                 // Hilite word group(0-15)
};
typedef struct tagRASELCHANGE RASELCHANGE;

#define BD_NONESTING			0x01		// Set to true for non nested blocks
#define BD_DIVIDERLINE			0x02		// Draws a divider line
#define BD_INCLUDELAST			0x04		// lpszEnd line is also collapsed
#define BD_LOOKAHEAD			0x08		// Look 500 lines ahead for the ending
#define BD_SEGMENTBLOCK			0x10		// Segment block, collapse till next segmentblock
#define BD_COMMENTBLOCK			0x20		// Comment block
#define BD_NOBLOCK				0x40		//
#define BD_ALTHILITE			0x80		// Adds 1 to the current word group for syntax coloring.

struct tagRABLOCKDEF {
	LPTSTR	lpszStart;					// Block start
	LPTSTR	lpszEnd;					// Block end
	LPTSTR	lpszNot1;					// Dont hide line containing this or set to NULL
	LPTSTR	lpszNot2;					// Dont hide line containing this or set to NULL
	DWORD	flag;						// High word is WordGroup(0-15)
};
typedef struct tagRABLOCKDEF RABLOCKDEF;

struct tagLINERANGE {
	DWORD	lnMin;						// Starting line
	DWORD	lnMax;						// Ending line
};
typedef struct tagLINERANGE LINERANGE;

struct tagBLOCKRANGE {
	DWORD	lnMin;						// Starting line
	DWORD	clMin;						// Starting column
	DWORD	lnMax;						// Ending line
	DWORD	clMax;						// Ending column
};
typedef struct tagBLOCKRANGE BLOCKRANGE;

void WINAPI InstallRAEdit(HINSTANCE hInst, BOOL fGlobal);
void WINAPI UnInstallRAEdit(void);

#pragma pack(pop)



================================================
File: read_asm.c
================================================
#include "stdafx.h"
#include "read_asm.h"

extern OPTIONS options;

#ifdef _WIN64
#define HEXPTR_PADDED         _T("%016I64X")
#else // _WIN64
#define HEXPTR_PADDED         _T("%08X")
#endif // _WIN64

TCHAR *ReadAsm(DWORD_PTR dwAddress, SIZE_T nSize, TCHAR *pLabelPrefix, TCHAR *lpError)
{
	PLUGIN_MODULE module;
	BYTE *pCode;
	DISASM_CMD_HEAD dasm_head = {NULL, (DISASM_CMD_NODE *)&dasm_head};
	TCHAR *lpText;

	module = FindModuleByAddr(dwAddress);

	// Allocate and read the code block
	pCode = (BYTE *)HeapAlloc(GetProcessHeap(), 0, nSize);
	if(!pCode)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return NULL;
	}

	if(!SimpleReadMemory(pCode, dwAddress, nSize))
	{
		HeapFree(GetProcessHeap(), 0, pCode);

		lstrcpy(lpError, _T("Could not read from memory"));
		return NULL;
	}

	// Disasm the code, allocate the linked list of commands, fill it
	if(!ProcessCode(dwAddress, nSize, pCode, &dasm_head, lpError))
	{
		HeapFree(GetProcessHeap(), 0, pCode);
		FreeDisasmCmdList(&dasm_head);

		return NULL;
	}

	// Labels
	if(options.disasm_label)
	{
		// Mark labels
		MarkLabels(dwAddress, nSize, pCode, &dasm_head);

		// Add external jumps and calls
		if(options.disasm_extjmp)
		{
			if(!ProcessExternalCode(dwAddress, nSize, module, pCode, &dasm_head, lpError))
			{
				HeapFree(GetProcessHeap(), 0, pCode);
				FreeDisasmCmdList(&dasm_head);

				return NULL;
			}
		}

		// Give names to labels, and set them in commands
		if(!CreateAndSetLabels(dwAddress, nSize, pCode, &dasm_head, pLabelPrefix, lpError))
		{
			HeapFree(GetProcessHeap(), 0, pCode);
			FreeDisasmCmdList(&dasm_head);

			return NULL;
		}
	}

	HeapFree(GetProcessHeap(), 0, pCode);

	if(options.disasm_rva)
	{
		// Set RVA addresses in commands
		if(!SetRVAAddresses(dwAddress, nSize, module, &dasm_head, lpError))
		{
			FreeDisasmCmdList(&dasm_head);

			return NULL;
		}
	}

	// Make our text!
	lpText = MakeText(dwAddress, module, &dasm_head, lpError);
	if(!lpText)
	{
		FreeDisasmCmdList(&dasm_head);

		return NULL;
	}

	FreeDisasmCmdList(&dasm_head);

	return lpText;
}

static BOOL ProcessCode(DWORD_PTR dwAddress, SIZE_T nSize, BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError)
{
	DISASM_CMD_NODE *dasm_cmd;
	BYTE *bDecode;
	SIZE_T nDecodeSize;
	int nCommandType;
	DWORD dwCommandSize;
	TCHAR szComment[COMMENT_MAX_LEN];
	int comment_length;

	bDecode = FindDecode(dwAddress, &nDecodeSize);
	if(bDecode && nDecodeSize < nSize)
		bDecode = NULL;

	while(nSize > 0)
	{
		// Get command type
		if(bDecode)
			nCommandType = DecodeGetType(*bDecode);
		else
			nCommandType = DECODE_UNKNOWN;

		// Process it
		switch(nCommandType)
		{
		// Unknown is treated as command
		case DECODE_UNKNOWN:
		// Supported data
		case DECODE_DATA:
		// Command
		case DECODE_COMMAND:
			dwCommandSize = ProcessCommand(pCode, nSize, dwAddress, bDecode, p_dasm_head, lpError);
			break;

		case DECODE_ASCII:
			dwCommandSize = ProcessData(pCode, nSize, dwAddress, bDecode, nCommandType, p_dasm_head, lpError);
			break;

		case DECODE_UNICODE:
			dwCommandSize = ProcessData(pCode, nSize, dwAddress, bDecode, nCommandType, p_dasm_head, lpError);
			break;
		}

		if(dwCommandSize == 0)
			return FALSE;

		dasm_cmd = p_dasm_head->last;

		// Comments?
		comment_length = GetComment(dwAddress, szComment);
		if(comment_length > 0)
		{
			dasm_cmd->lpComment = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (comment_length+1)*sizeof(TCHAR));
			if(!dasm_cmd->lpComment)
			{
				lstrcpy(lpError, _T("Allocation failed"));
				return 0;
			}

			lstrcpy(dasm_cmd->lpComment, szComment);
		}

		// Update values
		*pCode = 1;
		ZeroMemory(pCode+1, dwCommandSize-1);

		pCode += dwCommandSize;
		nSize -= dwCommandSize;
		dwAddress += dwCommandSize;
		if(bDecode)
			bDecode += dwCommandSize;
	}

	return TRUE;
}

static DWORD ProcessCommand(BYTE *pCode, SIZE_T nSize, DWORD_PTR dwAddress, BYTE *bDecode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError)
{
	DISASM_CMD_NODE *dasm_cmd;
	DWORD dwCommandSize;
	TCHAR szCommandText[COMMAND_MAX_LEN];
	DWORD_PTR jmpconst, adrconst, immconst;

	// Disasm
	dwCommandSize = SimpleDisasm(pCode, nSize, dwAddress, bDecode, FALSE, 
		szCommandText, &jmpconst, &adrconst, &immconst);

	if(dwCommandSize == 0)
	{
		wsprintf(lpError, _T("Disasm failed on address 0x" HEXPTR_PADDED), dwAddress);
		return 0;
	}

	// Allocate and fill
	dasm_cmd = (DISASM_CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(DISASM_CMD_NODE));
	if(!dasm_cmd)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	dasm_cmd->lpCommand = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (lstrlen(szCommandText) + 1)*sizeof(TCHAR));
	if(!dasm_cmd->lpCommand)
	{
		HeapFree(GetProcessHeap(), 0, dasm_cmd);

		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	lstrcpy(dasm_cmd->lpCommand, szCommandText);

	dasm_cmd->dwConst[0] = jmpconst;
	dasm_cmd->dwConst[1] = adrconst;
	dasm_cmd->dwConst[2] = immconst;

	dasm_cmd->dwAddress = 0;

	dasm_cmd->lpComment = NULL;
	dasm_cmd->lpLabel = NULL;

	dasm_cmd->next = NULL;

	p_dasm_head->last->next = dasm_cmd;
	p_dasm_head->last = dasm_cmd;

	return dwCommandSize;
}

static DWORD ProcessData(BYTE *pCode, SIZE_T nSize, DWORD_PTR dwAddress, 
	BYTE *bDecode, int nCommandType, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError)
{
	DISASM_CMD_NODE *dasm_cmd;
	DWORD dwCommandSize;
	DWORD dwTextSize;
	BOOL bReadAsBinary;
	int i;

	// Check size of data
	dwCommandSize = SimpleDisasm(pCode, nSize, dwAddress, bDecode, TRUE,
		NULL, NULL, NULL, NULL);

	if(dwCommandSize == 0)
	{
		wsprintf(lpError, _T("Disasm failed on address 0x" HEXPTR_PADDED), dwAddress);
		return 0;
	}

	// Check whether it's text or binary data, and calc size
	switch(nCommandType)
	{
	case DECODE_UNICODE:
		if(ValidateUnicode(pCode, dwCommandSize, &dwTextSize, &bReadAsBinary))
			nCommandType = DECODE_UNICODE;
		else
			nCommandType = DECODE_UNKNOWN;
		break;

	case DECODE_ASCII:
	default:
		if(ValidateAscii(pCode, dwCommandSize, &dwTextSize, &bReadAsBinary))
			nCommandType = DECODE_ASCII;
		else
			nCommandType = DECODE_UNKNOWN;
		break;
	}

	if(nCommandType == DECODE_UNKNOWN)
	{
		wsprintf(lpError, _T("Couldn't parse data on address 0x" HEXPTR_PADDED), dwAddress);
		return 0;
	}

	// Allocate and fill
	dasm_cmd = (DISASM_CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(DISASM_CMD_NODE));
	if(!dasm_cmd)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	dasm_cmd->lpCommand = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (dwTextSize+1)*sizeof(TCHAR));
	if(!dasm_cmd->lpCommand)
	{
		HeapFree(GetProcessHeap(), 0, dasm_cmd);

		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	switch(nCommandType)
	{
	case DECODE_UNICODE:
		ConvertUnicodeToText(pCode, dwCommandSize, bReadAsBinary, dasm_cmd->lpCommand);
		break;

	case DECODE_ASCII:
		ConvertAsciiToText(pCode, dwCommandSize, bReadAsBinary, dasm_cmd->lpCommand);
		break;
	}

	for(i=0; i<3; i++)
		dasm_cmd->dwConst[i] = 0;

	dasm_cmd->dwAddress = 0;

	dasm_cmd->lpComment = NULL;
	dasm_cmd->lpLabel = NULL;

	dasm_cmd->next = NULL;

	p_dasm_head->last->next = dasm_cmd;
	p_dasm_head->last = dasm_cmd;

	return dwCommandSize;
}

static BOOL ValidateUnicode(BYTE *p, DWORD dwSize, DWORD *pdwTextSize, BOOL *pbReadAsBinary)
{
	WORD *pw;
	DWORD dwSizeW;
	DWORD dwTextSize;
	BOOL bReadAsBinary;
	DWORD i;

	if(dwSize % 2)
		return FALSE;

	pw = (WORD *)p;
	dwSizeW = dwSize/2;

	dwTextSize = 0;
	bReadAsBinary = FALSE;

	for(i=0; !bReadAsBinary && i<dwSizeW; i++)
	{
		if(pw[i] > 126)
		{
			bReadAsBinary = TRUE;
		}
		else if(pw[i] < 32)
		{
			switch(pw[i])
			{
			case L'\0':
			case L'\a':
			case L'\b':
			case L'\f':
			case L'\r':
			case L'\n':
			case L'\t':
			case L'\v':
				dwTextSize += 2;
				break;

			default:
				bReadAsBinary = TRUE;
				break;
			}
		}
		else if(pw[i] == L'\\' || pw[i] == L'\"')
			dwTextSize += 2;
		else
			dwTextSize++;
	}

	if(bReadAsBinary)
		dwTextSize = dwSizeW*6; // \xFFFE

	*pdwTextSize = dwTextSize+3; // for L""
	*pbReadAsBinary = bReadAsBinary;

	return TRUE;
}

static BOOL ValidateAscii(BYTE *p, DWORD dwSize, DWORD *pdwTextSize, BOOL *pbReadAsBinary)
{
	DWORD dwTextSize;
	BOOL bReadAsBinary;
	DWORD i;

	dwTextSize = 0;
	bReadAsBinary = FALSE;

	for(i=0; !bReadAsBinary && i<dwSize; i++)
	{
		if(p[i] > 126)
		{
			bReadAsBinary = TRUE;
		}
		else if(p[i] < 32)
		{
			switch(p[i])
			{
			case '\0':
			case '\a':
			case '\b':
			case '\f':
			case '\r':
			case '\n':
			case '\t':
			case '\v':
				dwTextSize += 2;
				break;

			default:
				bReadAsBinary = TRUE;
				break;
			}
		}
		else if(p[i] == '\\' || p[i] == '\"')
			dwTextSize += 2;
		else
			dwTextSize++;
	}

	if(bReadAsBinary)
		dwTextSize = dwSize*4; // \xFE

	*pdwTextSize = dwTextSize+2; // for ""
	*pbReadAsBinary = bReadAsBinary;

	return TRUE;
}

static void ConvertUnicodeToText(BYTE *p, DWORD dwSize, BOOL bAsBinary, TCHAR *pText)
{
	WORD *pw;
	DWORD dwSizeW;

	pw = (WORD *)p;
	dwSizeW = dwSize/2;

	*pText++ = _T('L');
	*pText++ = _T('\"');

	if(!bAsBinary)
	{
		while(dwSizeW--)
		{
			switch(*pw)
			{
			case L'\\':
			case L'\"':
				*pText++ = _T('\\');
				*pText++ = (TCHAR)*pw;
				break;

			case L'\0':
				*pText++ = _T('\\');
				*pText++ = _T('0');
				break;

			case L'\a':
				*pText++ = _T('\\');
				*pText++ = _T('a');
				break;

			case L'\b':
				*pText++ = _T('\\');
				*pText++ = _T('b');
				break;

			case L'\f':
				*pText++ = _T('\\');
				*pText++ = _T('f');
				break;

			case L'\r':
				*pText++ = _T('\\');
				*pText++ = _T('r');
				break;

			case L'\n':
				*pText++ = _T('\\');
				*pText++ = _T('n');
				break;

			case L'\t':
				*pText++ = _T('\\');
				*pText++ = _T('t');
				break;

			case L'\v':
				*pText++ = _T('\\');
				*pText++ = _T('v');
				break;

			default:
				*pText++ = (TCHAR)*pw;
				break;
			}

			pw++;
		}
	}
	else
	{
		while(dwSizeW--)
			pText += wsprintf(pText, _T("\\x%04X"), *pw++);
	}

	*pText++ = _T('\"');
	*pText++ = _T('\0');
}

static void ConvertAsciiToText(BYTE *p, DWORD dwSize, BOOL bAsBinary, TCHAR *pText)
{
	*pText++ = _T('\"');

	if(!bAsBinary)
	{
		while(dwSize--)
		{
			switch(*p)
			{
			case '\\':
			case '\"':
				*pText++ = _T('\\');
				*pText++ = (TCHAR)*p;
				break;

			case '\0':
				*pText++ = _T('\\');
				*pText++ = _T('0');
				break;

			case '\a':
				*pText++ = _T('\\');
				*pText++ = _T('a');
				break;

			case '\b':
				*pText++ = _T('\\');
				*pText++ = _T('b');
				break;

			case '\f':
				*pText++ = _T('\\');
				*pText++ = _T('f');
				break;

			case '\r':
				*pText++ = _T('\\');
				*pText++ = _T('r');
				break;

			case '\n':
				*pText++ = _T('\\');
				*pText++ = _T('n');
				break;

			case '\t':
				*pText++ = _T('\\');
				*pText++ = _T('t');
				break;

			case '\v':
				*pText++ = _T('\\');
				*pText++ = _T('v');
				break;

			default:
				*pText++ = (TCHAR)*p;
				break;
			}

			p++;
		}
	}
	else
	{
		while(dwSize--)
			pText += wsprintf(pText, _T("\\x%02X"), *p++);
	}

	*pText++ = _T('\"');
	*pText++ = _T('\0');
}

static void MarkLabels(DWORD_PTR dwAddress, SIZE_T nSize, BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head)
{
	DISASM_CMD_NODE *dasm_cmd;
	int i;

	for(dasm_cmd = p_dasm_head->next; dasm_cmd != NULL; dasm_cmd = dasm_cmd->next)
	{
		for(i=0; i<3; i++)
		{
			if(dasm_cmd->dwConst[i])
			{
				if(
					dasm_cmd->dwConst[i] >= dwAddress && 
					dasm_cmd->dwConst[i] < dwAddress + nSize &&
					pCode[dasm_cmd->dwConst[i]-dwAddress] == 1
				)
					pCode[dasm_cmd->dwConst[i]-dwAddress] = 2;
			}
		}
	}
}

static BOOL ProcessExternalCode(DWORD_PTR dwAddress, SIZE_T nSize, PLUGIN_MODULE module,
	BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError)
{
#if defined(TARGET_ODBG) || defined(TARGET_IMMDBG) || defined(TARGET_ODBG2)
	t_jmp *jmpdata;
	int njmpdata;
	DWORD_PTR dwCodeBase;
	SIZE_T nCodeSize;
	DWORD_PTR dwFromAddr, dwToAddr;
	BOOL bAdded;
	int i;

	if(!module)
		return TRUE;

#if defined(TARGET_ODBG) || defined(TARGET_IMMDBG)
	jmpdata = module->jddata;
	njmpdata = module->njddata;
#elif defined(TARGET_ODBG2)
	jmpdata = module->jumps.jmpdata;
	njmpdata = module->jumps.njmp;
#else
#error Unknown target
#endif

	dwCodeBase = module->codebase;
	nCodeSize = module->codesize;

	for(i=0; i<njmpdata; i++)
	{
#if defined(TARGET_ODBG) || defined(TARGET_IMMDBG)
		dwFromAddr = jmpdata[i].from+dwCodeBase;
		dwToAddr = jmpdata[i].to+dwCodeBase;
#elif defined(TARGET_ODBG2)
		dwFromAddr = jmpdata[i].from;
		dwToAddr = jmpdata[i].dest;
#else
#error Unknown target
#endif

		if(
			(dwFromAddr < dwAddress || dwFromAddr >= dwAddress+nSize) && 
			dwToAddr >= dwAddress && dwToAddr < dwAddress+nSize && 
			(jmpdata[i].type == JT_JUMP || jmpdata[i].type == JT_COND || jmpdata[i].type == JT_CALL) && 
			pCode[dwToAddr-dwAddress] != 0
		)
		{
			if(!AddExternalCode(dwFromAddr, dwCodeBase, nCodeSize, p_dasm_head, &bAdded, lpError))
				return FALSE;

			if(bAdded)
				pCode[dwToAddr-dwAddress] = 2;
		}
	}
#elif defined(TARGET_X64DBG)
	DWORD_PTR dwFromAddr, dwToAddr;
	XREF_INFO xrefInfo;
	PLUGIN_MEMORY memory;
	DWORD_PTR dwCodeBase;
	SIZE_T nCodeSize;
	BOOL bAdded;
	SIZE_T i, j;

	for(i = 0; i < nSize; i++)
	{
		if(pCode[i] == 0)
			continue;

		dwToAddr = dwAddress + i;

		if(!DbgXrefGet(dwToAddr, &xrefInfo) || xrefInfo.refcount == 0)
			continue;

		for(j = 0; j < xrefInfo.refcount; j++)
		{
			dwFromAddr = xrefInfo.references[j].addr;
			if(dwFromAddr >= dwAddress && dwFromAddr < dwAddress + nSize)
				continue;

			memory = FindMemory(dwFromAddr);
			if(!memory)
				continue;

			dwCodeBase = GetMemoryBase(memory);
			nCodeSize = GetMemorySize(memory);

			if(!AddExternalCode(dwFromAddr, dwCodeBase, nCodeSize, p_dasm_head, &bAdded, lpError))
			{
				BridgeFree(xrefInfo.references);
				return FALSE;
			}

			if(bAdded)
				pCode[dwToAddr - dwAddress] = 2;
		}

		BridgeFree(xrefInfo.references);
	}
#else
#error Unknown target
#endif

	return TRUE;
}

static BOOL AddExternalCode(DWORD_PTR dwAddress, DWORD_PTR dwCodeBase, SIZE_T nCodeSize,
	DISASM_CMD_HEAD *p_dasm_head, BOOL *pbAdded, TCHAR *lpError)
{
	DISASM_CMD_NODE *dasm_cmd;
	BYTE *bDecode;
	int nCommandType;
	BYTE bBuffer[MAXCMDSIZE];
	DWORD dwCommandSize;
	TCHAR szComment[COMMENT_MAX_LEN];
	int nCommentLength;

	bDecode = FindDecode(dwAddress, NULL);
	if(bDecode)
		nCommandType = DecodeGetType(*bDecode);
	else
		nCommandType = DECODE_UNKNOWN;

	if(nCommandType == DECODE_UNKNOWN || nCommandType == DECODE_COMMAND)
	{
		// Try to read and process...
		if(dwCodeBase + nCodeSize - dwAddress < MAXCMDSIZE)
			dwCommandSize = (DWORD)(dwCodeBase + nCodeSize - dwAddress);
		else
			dwCommandSize = MAXCMDSIZE;

		if(!SimpleReadMemory(bBuffer, dwAddress, dwCommandSize))
		{
			wsprintf(lpError, _T("Could not read memory on address 0x" HEXPTR_PADDED), dwAddress);
			return FALSE;
		}

		dwCommandSize = ProcessCommand(bBuffer, dwCommandSize, dwAddress, bDecode, p_dasm_head, lpError);
		if(dwCommandSize == 0)
			return FALSE;

		// We did it!
		dasm_cmd = p_dasm_head->last;

		// Comments?
		nCommentLength = GetComment(dwAddress, szComment);
		if(nCommentLength > 0)
		{
			dasm_cmd->lpComment = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (nCommentLength + 1)*sizeof(TCHAR));
			if(!dasm_cmd->lpComment)
			{
				lstrcpy(lpError, _T("Allocation failed"));
				return FALSE;
			}

			lstrcpy(dasm_cmd->lpComment, szComment);
		}

		dasm_cmd->dwAddress = dwAddress;

		*pbAdded = TRUE;
	}
	else
	{
		*pbAdded = FALSE;
	}

	return TRUE;
}

static BOOL CreateAndSetLabels(DWORD_PTR dwAddress, SIZE_T nSize, 
	BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *pLabelPrefix, TCHAR *lpError)
{
	DISASM_CMD_NODE *dasm_cmd, *dasm_cmd_2;
	UINT nLabelCounter;
	TCHAR szAtLabel[LABEL_MAX_LEN+1];
	TCHAR *pLabel;
	int nLabelLen;
	SIZE_T i;
	int j;

	dasm_cmd = p_dasm_head->next;

	nLabelCounter = 1;

	szAtLabel[0] = _T('@');
	pLabel = &szAtLabel[1];

	if(options.disasm_labelgen == 2)
	{
		// Make pLabelPrefix valid
		for(i=0; i<32 && pLabelPrefix[i] != _T('\0'); i++)
		{
			if(
				(pLabelPrefix[i] < _T('0') || pLabelPrefix[i] > _T('9')) && 
				(pLabelPrefix[i] < _T('A') || pLabelPrefix[i] > _T('Z')) && 
				(pLabelPrefix[i] < _T('a') || pLabelPrefix[i] > _T('z')) && 
				pLabelPrefix[i] != _T('_')
			)
				pLabelPrefix[i] = _T('_');
		}

		if(i == 32)
			pLabelPrefix[i] = _T('\0');
	}

	for(i = 0; i < nSize; i++)
	{
		if(pCode[i] == 0)
			continue;

		if(pCode[i] == 2)
		{
			if(!GetLabel(dwAddress + i, pLabel) || !IsValidLabel(pLabel, p_dasm_head, dasm_cmd))
			{
				switch(options.disasm_labelgen)
				{
				default: // just in case
				case 0:
					nLabelLen = wsprintf(pLabel, _T("L%08u"), nLabelCounter++);
					break;

				case 1:
					nLabelLen = wsprintf(pLabel, _T("L_" HEXPTR_PADDED), dwAddress + i);
					break;

				case 2:
					nLabelLen = wsprintf(pLabel, _T("L_%s_%08u"), pLabelPrefix, nLabelCounter++);
					break;
				}
			}
			else
				nLabelLen = lstrlen(pLabel);

			dasm_cmd->lpLabel = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (nLabelLen+1)*sizeof(TCHAR));
			if(!dasm_cmd->lpLabel)
			{
				lstrcpy(lpError, _T("Allocation failed"));
				return FALSE;
			}

			lstrcpy(dasm_cmd->lpLabel, pLabel);

			for(dasm_cmd_2 = p_dasm_head->next; dasm_cmd_2 != NULL; dasm_cmd_2 = dasm_cmd_2->next)
			{
				for(j=0; j<3; j++)
				{
					if(dasm_cmd_2->dwConst[j] && dasm_cmd_2->dwConst[j]-dwAddress == i)
					{
						dasm_cmd_2->dwConst[j] = 0;

						for(j++; j<3; j++)
							if(dasm_cmd_2->dwConst[j] && dasm_cmd_2->dwConst[j]-dwAddress == i)
								dasm_cmd_2->dwConst[j] = 0;

						if(!ReplaceAddressWithText(&dasm_cmd_2->lpCommand, dwAddress+i, szAtLabel, lpError))
							return FALSE;
					}
				}
			}
		}

		dasm_cmd = dasm_cmd->next;
	}

	return TRUE;
}

static BOOL IsValidLabel(TCHAR *lpLabel, DISASM_CMD_HEAD *p_dasm_head, DISASM_CMD_NODE *dasm_cmd_target)
{
	DISASM_CMD_NODE *dasm_cmd;
	int nLabelLen;
	int i;

	// Generic validation
	for(i=0; lpLabel[i] != _T('\0'); i++)
	{
		if(
			(lpLabel[i] < _T('0') || lpLabel[i] > _T('9')) && 
			(lpLabel[i] < _T('A') || lpLabel[i] > _T('Z')) && 
			(lpLabel[i] < _T('a') || lpLabel[i] > _T('z')) && 
			lpLabel[i] != _T('_')
		)
			return FALSE;
	}

	// Conflicts with our labels
	if(lpLabel[0] == _T('L'))
	{
		nLabelLen = lstrlen(lpLabel);

		if(nLabelLen == 9 || (nLabelLen > 10 && lpLabel[1] == _T('_') && lpLabel[nLabelLen-8-1] == _T('_')))
		{
			for(i=nLabelLen-8; i<nLabelLen; i++)
			{
				if(lpLabel[i] < _T('0') || lpLabel[i] > _T('9'))
					break;
			}
		}
		else if(nLabelLen == 10 && lpLabel[1] == _T('_'))
		{
			for(i=nLabelLen-8; i<nLabelLen; i++)
			{
				if((lpLabel[i] < _T('0') || lpLabel[i] > _T('9')) && 
					(lpLabel[i] < _T('A') || lpLabel[i] > _T('F')))
					break;
			}
		}
		else
			i = 0;

		if(i == 9)
			return FALSE;
	}

	// Check for duplicates
	for(dasm_cmd = p_dasm_head->next; dasm_cmd != dasm_cmd_target; dasm_cmd = dasm_cmd->next)
		if(dasm_cmd->lpLabel && lstrcmp(lpLabel, dasm_cmd->lpLabel) == 0)
			return FALSE;

	return TRUE;
}

static BOOL SetRVAAddresses(DWORD_PTR dwAddress, SIZE_T nSize, PLUGIN_MODULE module, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError)
{
	DWORD_PTR dwModuleBase;
	SIZE_T nModuleSize;
	DISASM_CMD_NODE *dasm_cmd;
	TCHAR szRVAText[2 + 2 + sizeof(DWORD_PTR) * 2 + 1];
	TCHAR *pRVAAddress;
	int i, j;

	if(!module || (options.disasm_rva_reloconly && !IsModuleWithRelocations(module)))
		return TRUE;

	dwModuleBase = GetModuleBase(module);
	nModuleSize = GetModuleSize(module);

	szRVAText[0] = _T('$');
	szRVAText[1] = _T('$');

	pRVAAddress = &szRVAText[2];

	for(dasm_cmd = p_dasm_head->next; dasm_cmd != NULL; dasm_cmd = dasm_cmd->next)
	{
		for(i=0; i<3; i++)
		{
			if(dasm_cmd->dwConst[i])
			{
				if(
					dasm_cmd->dwConst[i] >= dwModuleBase &&
					dasm_cmd->dwConst[i] < dwModuleBase + nModuleSize
				)
				{
					DWORDPtrToString(pRVAAddress, dasm_cmd->dwConst[i] - dwModuleBase, FALSE, 0);

					if(!ReplaceAddressWithText(&dasm_cmd->lpCommand, dasm_cmd->dwConst[i], szRVAText, lpError))
						return FALSE;

					for(j=i+1; j<3; j++)
						if(dasm_cmd->dwConst[j] == dasm_cmd->dwConst[i])
							dasm_cmd->dwConst[j] = 0;

					dasm_cmd->dwConst[i] = 0;
				}
			}
		}
	}

	return TRUE;
}

static TCHAR *MakeText(DWORD_PTR dwAddress, PLUGIN_MODULE module, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError)
{
	DISASM_CMD_NODE *dasm_cmd;
	BOOL bRVAAddresses;
	DWORD_PTR dwModuleBase;
	TCHAR szRVAText[1 + MODULE_MAX_LEN + 2 + 1];
	TCHAR *lpText, *lpRealloc;
	SIZE_T nSize, nMemory;

	nMemory = 4096*2;

	lpText = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, nMemory*sizeof(TCHAR));
	if(!lpText)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return NULL;
	}

	bRVAAddresses = (options.disasm_rva && module && (!options.disasm_rva_reloconly || IsModuleWithRelocations(module)));
	if(bRVAAddresses)
	{
		dwModuleBase = GetModuleBase(module);
		if(!MakeRVAText(szRVAText, module))
		{
			lstrcpy(lpError, _T("Couldn't make RVA label text"));
			return NULL;
		}
	}

	dasm_cmd = p_dasm_head->next;

	dasm_cmd->dwAddress = dwAddress;
	nSize = 0;

	while(dasm_cmd != NULL)
	{
		if(dasm_cmd->dwAddress)
		{
			if(dasm_cmd != p_dasm_head->next)
			{
				lpText[nSize++] = _T('\r');
				lpText[nSize++] = _T('\n');
			}

			lpText[nSize++] = _T('<');

			if(bRVAAddresses)
			{
				nSize += wsprintf(lpText+nSize, _T("%s"), szRVAText);
				nSize += DWORDPtrToString(lpText + nSize, dasm_cmd->dwAddress - dwModuleBase, FALSE, options.disasm_hex);
			}
			else
				nSize += DWORDPtrToString(lpText+nSize, dasm_cmd->dwAddress, TRUE, options.disasm_hex);

			nSize += wsprintf(lpText+nSize, _T("%s"), _T(">\r\n\r\n"));
		}

		if(dasm_cmd->lpLabel)
		{
			if(!dasm_cmd->dwAddress)
			{
				lpText[nSize++] = _T('\r');
				lpText[nSize++] = _T('\n');
			}

			nSize += wsprintf(lpText+nSize, _T("@%s:\r\n"), dasm_cmd->lpLabel);
		}

		if(options.disasm_hex > 0)
		{
			lpText[nSize++] = _T('\t');
			nSize += CopyCommand(lpText+nSize, dasm_cmd->lpCommand, options.disasm_hex-1);
		}
		else
			nSize += wsprintf(lpText+nSize, _T("\t%s"), dasm_cmd->lpCommand);

		if(dasm_cmd->lpComment)
			nSize += wsprintf(lpText+nSize, _T(" ; %s"), dasm_cmd->lpComment);

		lpText[nSize++] = _T('\r');
		lpText[nSize++] = _T('\n');

		if(nMemory-nSize < 4096)
		{
			nMemory += 4096;

			lpRealloc = (TCHAR *)HeapReAlloc(GetProcessHeap(), 0, lpText, nMemory*sizeof(TCHAR));
			if(!lpRealloc)
			{
				HeapFree(GetProcessHeap(), 0, lpText);

				lstrcpy(lpError, _T("Allocation failed"));
				return NULL;
			}
			else
				lpText = lpRealloc;
		}

		dasm_cmd = dasm_cmd->next;
	}

	lpText[nSize] = _T('\0');

	return lpText;
}

static SIZE_T CopyCommand(TCHAR *pBuffer, TCHAR *pCommand, int hex_option)
{
	TCHAR *p, *p_dest;
	TCHAR *pDetectionFirstChar;
	TCHAR *pHexFirstChar;

	p_dest = pBuffer;

	// Skip the command name
	p = SkipCommandName(pCommand);
	if(p != pCommand)
	{
		CopyMemory(p_dest, pCommand, (p-pCommand)*sizeof(TCHAR));
		p_dest += p-pCommand;
	}

	// Search for hex numbers
	while(*p != _T('\0'))
	{
		if((*p >= _T('A') && *p <= _T('Z')) || (*p >= _T('a') && *p <= _T('z')) || (*p >= _T('0') && *p <= _T('9')))
		{
			if((*p >= _T('0') && *p <= _T('9')) || (*p >= _T('A') && *p <= _T('F')) || (*p >= _T('a') && *p <= _T('f')))
			{
				pDetectionFirstChar = p;

				// Allow and ignore 0x prefix
				if(p[0] == _T('0') && (p[1] == _T('X') || p[1] == _T('x')))
					p += 2;

				pHexFirstChar = p;

				do {
					p++;
				} while((*p >= _T('0') && *p <= _T('9')) || (*p >= _T('A') && *p <= _T('F')) || (*p >= _T('a') && *p <= _T('f')));

				if((*p >= _T('A') && *p <= _T('Z')) || (*p >= _T('a') && *p <= _T('z')) || (*p >= _T('0') && *p <= _T('9')))
				{
					while(pDetectionFirstChar < p)
						*p_dest++ = *pDetectionFirstChar++;

					do {
						*p_dest++ = *p++;
					} while((*p >= _T('A') && *p <= _T('Z')) || (*p >= _T('a') && *p <= _T('z')) || (*p >= _T('0') && *p <= _T('9')));
				}
				else
				{
					if(hex_option == 3)
					{
						*p_dest++ = _T('0');
						*p_dest++ = _T('x');
					}
					else if(hex_option == 1)
					{
						if(*pHexFirstChar < _T('0') || *pHexFirstChar > _T('9'))
							*p_dest++ = _T('0');
					}

					while(pHexFirstChar < p)
						*p_dest++ = *pHexFirstChar++;

					if(hex_option == 2)
						*p_dest++ = _T('h');
				}
			}
			else
			{
				do {
					*p_dest++ = *p++;
				} while((*p >= _T('A') && *p <= _T('Z')) || (*p >= _T('a') && *p <= _T('z')) || (*p >= _T('0') && *p <= _T('9')));
			}
		}
		else if(*p == _T('@'))
		{
			do {
				*p_dest++ = *p++;
			} while(
				(*p >= _T('0') && *p <= _T('9')) || 
				(*p >= _T('A') && *p <= _T('Z')) || 
				(*p >= _T('a') && *p <= _T('z')) || 
				*p == _T('_')
			);
		}
		else if(*p == _T('$'))
		{
			*p_dest++ = *p++;

			switch(*p)
			{
			case _T('$'):
				*p_dest++ = *p++;
				break;

			case _T('"'):
				*p_dest++ = *p++;

				while(*p != _T('"'))
					*p_dest++ = *p++;

				*p_dest++ = *p++;
				break;

			default:
				while(*p != _T('.'))
					*p_dest++ = *p++;

				*p_dest++ = *p++;
				break;
			}
		}
		else
			*p_dest++ = *p++;
	}

	*p_dest++ = _T('\0');

	return p_dest - pBuffer - 1;
}

static int MakeRVAText(TCHAR szText[1 + MODULE_MAX_LEN + 2 + 1], PLUGIN_MODULE module)
{
	TCHAR szModName[MODULE_MAX_LEN];
	TCHAR c;
	int i;

	if(!GetModuleName(module, szModName))
		return 0;

	for(i = 0; szModName[i] != _T('\0'); i++)
	{
		c = szModName[i];
		if(
			(c < _T('0') || c > _T('9')) && 
			(c < _T('A') || c > _T('Z')) && 
			(c < _T('a') || c > _T('z')) && 
			c != _T('_')
		)
		{
			// Quoted
			return wsprintf(szText, _T("$\"%s\"."), szModName);
		}
	}

	// Non-quoted
	return wsprintf(szText, _T("$%s."), szModName);
}

static BOOL ReplaceAddressWithText(TCHAR **ppCommand, DWORD_PTR dwAddress, TCHAR *lpText, TCHAR *lpError)
{
	TCHAR *p;
	TCHAR c;
	TCHAR szTextAddress[sizeof(DWORD_PTR) * 2 + 1];
	int address_len;
	int address_count;
	LONG_PTR address_start[3], address_end[3];
	LONG_PTR text_len, new_command_len;
	TCHAR *lpNewCommand;
	TCHAR *dest, *src;
	int i;

	// Address to replace
	address_len = wsprintf(szTextAddress, _T("%IX"), dwAddress);

	// Skip command name
	p = SkipCommandName(*ppCommand);

	// Search for numbers
	address_count = 0;

	while(*p != _T('\0') && address_count < 3)
	{
		if((*p >= _T('0') && *p <= _T('9')) || (*p >= _T('A') && *p <= _T('F')) || (*p >= _T('a') && *p <= _T('f')))
		{
			address_start[address_count] = p - *ppCommand;

			// Allow and ignore 0x prefix
			if(p[0] == _T('0') && (p[1] == _T('X') || p[1] == _T('x')))
				p += 2;

			// Skip zeros
			if(*p == _T('0'))
			{
				do {
					p++;
				} while(*p == _T('0'));

				// If the number is zero, leave the last digit
				if((*p < _T('0') || *p > _T('9')) && (*p < _T('A') || *p > _T('F')) && (*p < _T('a') || *p > _T('f')))
					p--;
			}

			for(i=0; i<address_len; i++)
			{
				c = p[i];
				if(c >= _T('a') && c <= _T('f'))
					c += -_T('a') + _T('A');

				if(c != szTextAddress[i])
					break;
			}

			p += i;

			if((*p >= _T('0') && *p <= _T('9')) || (*p >= _T('A') && *p <= _T('F')) || (*p >= _T('a') && *p <= _T('f')))
			{
				do {
					p++;
				} while((*p >= _T('0') && *p <= _T('9')) || (*p >= _T('A') && *p <= _T('F')) || (*p >= _T('a') && *p <= _T('f')));
			}
			else if(i == address_len)
			{
				address_end[address_count] = p - *ppCommand;
				address_count++;
			}
		}
		else if(*p == _T('@'))
		{
			do {
				p++;
			} while(
				(*p >= _T('0') && *p <= _T('9')) || 
				(*p >= _T('A') && *p <= _T('Z')) || 
				(*p >= _T('a') && *p <= _T('z')) || 
				*p == _T('_')
			);
		}
		else if(*p == _T('$'))
		{
			p++;

			switch(*p)
			{
			case _T('$'):
				p++;
				break;

			case _T('"'):
				p++;

				while(*p != _T('"'))
					p++;

				p++;
				break;

			default:
				while(*p != _T('.'))
					p++;

				p++;
				break;
			}
		}
		else
			p++;
	}

	if(address_count == 0)
		return TRUE;

	// Allocate memory for new command
	text_len = lstrlen(lpText);

	new_command_len = lstrlen(*ppCommand);
	for(i=0; i<address_count; i++)
		new_command_len += text_len-(address_end[i]-address_start[i]);

	lpNewCommand = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (new_command_len+1)*sizeof(TCHAR));
	if(!lpNewCommand)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return FALSE;
	}

	// Replace address with label
	dest = lpNewCommand;
	src = *ppCommand;

	CopyMemory(dest, src, address_start[0]*sizeof(TCHAR));
	CopyMemory(dest+address_start[0], lpText, text_len*sizeof(TCHAR));
	dest += address_start[0]+text_len;
	src += address_end[0];

	for(i=1; i<address_count; i++)
	{
		CopyMemory(dest, src, (address_start[i]-address_end[i-1])*sizeof(TCHAR));
		CopyMemory(dest+address_start[i]-address_end[i-1], lpText, text_len*sizeof(TCHAR));
		dest += address_start[i]-address_end[i-1]+text_len;
		src += address_end[i]-address_end[i-1];
	}

	lstrcpy(dest, src);

	// Free old address, return
	HeapFree(GetProcessHeap(), 0, *ppCommand);
	*ppCommand = lpNewCommand;

	return TRUE;
}

static TCHAR *SkipCommandName(TCHAR *p)
{
	TCHAR *pPrefix;
	int i;

	switch(*p)
	{
	case _T('L'):
	case _T('l'):
		pPrefix = _T("LOCK");

		for(i=1; pPrefix[i] != _T('\0'); i++)
		{
			if(p[i] != pPrefix[i] && p[i] != pPrefix[i]-_T('A')+_T('a'))
				break;
		}

		if(pPrefix[i] == _T('\0'))
		{
			if((p[i] < _T('A') || p[i] > _T('Z')) && (p[i] < _T('a') || p[i] > _T('z')) && (p[i] < _T('0') || p[i] > _T('9')))
			{
				p = &p[i];
				while(*p == _T(' '))
					p++;
			}
		}
		break;

	case _T('R'):
	case _T('r'):
		pPrefix = _T("REP");

		for(i=1; pPrefix[i] != _T('\0'); i++)
		{
			if(p[i] != pPrefix[i] && p[i] != pPrefix[i]-_T('A')+_T('a'))
				break;
		}

		if(pPrefix[i] == _T('\0'))
		{
			if((p[i] == _T('N') || p[i] == _T('n')) && (p[i+1] == _T('E') || p[i+1] == _T('e') || p[i+1] == _T('Z') || p[i+1] == _T('z')))
				i += 2;
			else if(p[i] == _T('E') || p[i] == _T('e') || p[i] == _T('Z') || p[i] == _T('z'))
				i++;

			if((p[i] < _T('A') || p[i] > _T('Z')) && (p[i] < _T('a') || p[i] > _T('z')) && (p[i] < _T('0') || p[i] > _T('9')))
			{
				p = &p[i];
				while(*p == _T(' '))
					p++;
			}
		}
		break;
	}

	while((*p >= _T('A') && *p <= _T('Z')) || (*p >= _T('a') && *p <= _T('z')) || (*p >= _T('0') && *p <= _T('9')))
		p++;

	while(*p == _T(' '))
		p++;

	return p;
}

static SIZE_T DWORDPtrToString(TCHAR szString[2 + sizeof(DWORD_PTR) * 2 + 1], DWORD_PTR dw, BOOL bAddress, int hex_option)
{
	TCHAR *p;
	TCHAR szHex[sizeof(DWORD_PTR) * 2 + 1];
	int nHexLen;

	p = szString;

	nHexLen = wsprintf(szHex, bAddress ? HEXPTR_PADDED : _T("%IX"), dw);

	if(hex_option == 4)
	{
		*p++ = _T('0');
		*p++ = _T('x');
	}

	if(szHex[0] >= _T('A') && szHex[0] <= _T('F'))
	{
		if(hex_option == 2 || hex_option == 3 || nHexLen < sizeof(DWORD_PTR) * 2)
			*p++ = _T('0');
	}

	lstrcpy(p, szHex);
	p += nHexLen;

	if(hex_option == 3)
	{
		*p++ = _T('h');
		*p = _T('\0');
	}

	return p - szString;
}

static void FreeDisasmCmdList(DISASM_CMD_HEAD *p_dasm_head)
{
	DISASM_CMD_NODE *dasm_cmd, *next;

	for(dasm_cmd = p_dasm_head->next; dasm_cmd != NULL; dasm_cmd = next)
	{
		next = dasm_cmd->next;

		HeapFree(GetProcessHeap(), 0, dasm_cmd->lpCommand);

		if(dasm_cmd->lpComment)
			HeapFree(GetProcessHeap(), 0, dasm_cmd->lpComment);

		if(dasm_cmd->lpLabel)
			HeapFree(GetProcessHeap(), 0, dasm_cmd->lpLabel);

		HeapFree(GetProcessHeap(), 0, dasm_cmd);
	}

	p_dasm_head->next = NULL;
	p_dasm_head->last = (DISASM_CMD_NODE *)p_dasm_head;
}



================================================
File: read_asm.h
================================================
#ifndef _READ_ASM_H_
#define _READ_ASM_H_

#include "options_def.h"
#include "plugin.h"

// linked list of commands

typedef struct _disasm_cmd_node {
	struct _disasm_cmd_node *next;
	DWORD_PTR dwAddress;
	TCHAR *lpCommand;
	DWORD_PTR dwConst[3];
	TCHAR *lpComment;
	TCHAR *lpLabel;
} DISASM_CMD_NODE;

typedef struct _disasm_cmd_head {
	DISASM_CMD_NODE *next;
	DISASM_CMD_NODE *last;
} DISASM_CMD_HEAD;

// functions

TCHAR *ReadAsm(DWORD_PTR dwAddress, SIZE_T nSize, TCHAR *pLabelPrefix, TCHAR *lpError);

// 1
static BOOL ProcessCode(DWORD_PTR dwAddress, SIZE_T nSize, BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError);
static DWORD ProcessCommand(BYTE *pCode, SIZE_T nSize, DWORD_PTR dwAddress, BYTE *bDecode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError);
static DWORD ProcessData(BYTE *pCode, SIZE_T nSize, DWORD_PTR dwAddress, 
	BYTE *bDecode, int nCommandType, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError);
static BOOL ValidateUnicode(BYTE *p, DWORD dwSize, DWORD *pdwTextSize, BOOL *pbReadAsBinary);
static BOOL ValidateAscii(BYTE *p, DWORD dwSize, DWORD *pdwTextSize, BOOL *pbReadAsBinary);
static void ConvertUnicodeToText(BYTE *p, DWORD dwSize, BOOL bAsBinary, TCHAR *pText);
static void ConvertAsciiToText(BYTE *p, DWORD dwSize, BOOL bAsBinary, TCHAR *pText);

// 2
static void MarkLabels(DWORD_PTR dwAddress, SIZE_T nSize, BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head);
static BOOL ProcessExternalCode(DWORD_PTR dwAddress, SIZE_T nSize, PLUGIN_MODULE module,
	BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError);
static BOOL AddExternalCode(DWORD_PTR dwAddress, DWORD_PTR dwCodeBase, SIZE_T nCodeSize,
	DISASM_CMD_HEAD *p_dasm_head, BOOL *pbAdded, TCHAR *lpError);
static BOOL CreateAndSetLabels(DWORD_PTR dwAddress, SIZE_T nSize, 
	BYTE *pCode, DISASM_CMD_HEAD *p_dasm_head, TCHAR *pLabelPrefix, TCHAR *lpError);
static BOOL IsValidLabel(TCHAR *lpLabel, DISASM_CMD_HEAD *p_dasm_head, DISASM_CMD_NODE *dasm_cmd_target);
static BOOL SetRVAAddresses(DWORD_PTR dwAddress, SIZE_T nSize, PLUGIN_MODULE module, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError);

// 3
static TCHAR *MakeText(DWORD_PTR dwAddress, PLUGIN_MODULE module, DISASM_CMD_HEAD *p_dasm_head, TCHAR *lpError);
static SIZE_T CopyCommand(TCHAR *pBuffer, TCHAR *pCommand, int hex_option);

// Helper functions
static int MakeRVAText(TCHAR szText[1 + MODULE_MAX_LEN + 2 + 1], PLUGIN_MODULE module);
static BOOL ReplaceAddressWithText(TCHAR **ppCommand, DWORD_PTR dwAddress, TCHAR *lpText, TCHAR *lpError);
static TCHAR *SkipCommandName(TCHAR *p);
static SIZE_T DWORDPtrToString(TCHAR szString[2 + sizeof(DWORD_PTR) * 2 + 1], DWORD_PTR dw, BOOL bAddress, int hex_option);

// Cleanup
static void FreeDisasmCmdList(DISASM_CMD_HEAD *p_dasm_head);

#endif // _READ_ASM_H_



================================================
File: resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by rsrc.rc
//
#define IDI_MAIN                        108
#define IDD_MAIN                        109
#define IDR_MAINACCELERATOR             110
#define IDR_RIGHTCLICK                  111
#define IDD_OPTIONS                     112
#define IDB_X64DBG_ICON                 113
#define IDC_TABS                        1001
#define IDC_ASSEMBLER                   1002
#define IDC_CLOSE                       1003
#define IDC_DISASM_RVA                  1004
#define IDC_DISASM_RVA_RELOCONLY        1005
#define IDC_DISASM_LABEL                1006
#define IDC_DISASM_EXTJMP               1007
#define IDC_DISASM_HEX                  1008
#define IDC_DISASM_LABELGEN             1009
#define IDC_ASM_COMMENTS                1010
#define IDC_ASM_LABELS                  1011
#define IDC_EDIT_SAVEPOS                1012
#define IDC_EDIT_TABWIDTH               1013
#define ID_RCM_UNDO                     40001
#define ID_RCM_REDO                     40002
#define ID_RCM_CUT                      40003
#define ID_RCM_COPY                     40004
#define ID_RCM_PASTE                    40005
#define ID_RCM_DELETE                   40006
#define ID_RCM_SELECTALL                40007
#define ID_TABMENU_NEWTAB               40008
#define ID_TABMENU_RENAME               40009
#define ID_TABMENU_CLOSE                40010
#define ID_TABMENU_LOADFROMFILE         40011
#define ID_TABMENU_SAVETOFILE           40012
#define ID_TABSTRIPMENU_CLOSEALLTABS    40013
#define ID_ACCEL_PREVTAB                40014
#define ID_ACCEL_NEXTTAB                40015
#define ID_ACCEL_FINDWND                40016
#define ID_ACCEL_REPLACEWND             40017
#define ID_ACCEL_FINDNEXT               40018
#define ID_ACCEL_FINDPREV               40019
#define ID_ACCEL_FOCUS_OLLYDBG          40020
#define ID_ACCEL_BLOCK_MODE             40021

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40022
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
File: rsrc.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1251)

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_MAIN                ICON                    "rsrc_files\\icon.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_MAINACCELERATOR ACCELERATORS
BEGIN
    "B",            ID_ACCEL_BLOCK_MODE,    VIRTKEY, CONTROL, NOINVERT
    VK_F3,          ID_ACCEL_FINDNEXT,      VIRTKEY, NOINVERT
    VK_F3,          ID_ACCEL_FINDPREV,      VIRTKEY, SHIFT, NOINVERT
    "F",            ID_ACCEL_FINDWND,       VIRTKEY, CONTROL, NOINVERT
    "D",            ID_ACCEL_FOCUS_OLLYDBG, VIRTKEY, CONTROL, NOINVERT
    VK_NEXT,        ID_ACCEL_NEXTTAB,       VIRTKEY, CONTROL, NOINVERT
    VK_TAB,         ID_ACCEL_NEXTTAB,       VIRTKEY, CONTROL, NOINVERT
    VK_PRIOR,       ID_ACCEL_PREVTAB,       VIRTKEY, CONTROL, NOINVERT
    VK_TAB,         ID_ACCEL_PREVTAB,       VIRTKEY, SHIFT, CONTROL, NOINVERT
    "H",            ID_ACCEL_REPLACEWND,    VIRTKEY, CONTROL, NOINVERT
    VK_F4,          ID_TABMENU_CLOSE,       VIRTKEY, CONTROL, NOINVERT
    "W",            ID_TABMENU_CLOSE,       VIRTKEY, CONTROL, NOINVERT
    "O",            ID_TABMENU_LOADFROMFILE, VIRTKEY, CONTROL, NOINVERT
    "N",            ID_TABMENU_NEWTAB,      VIRTKEY, CONTROL, NOINVERT
    "T",            ID_TABMENU_NEWTAB,      VIRTKEY, CONTROL, NOINVERT
    "R",            ID_TABMENU_RENAME,      VIRTKEY, CONTROL, NOINVERT
    VK_F2,          ID_TABMENU_RENAME,      VIRTKEY, NOINVERT
    "S",            ID_TABMENU_SAVETOFILE,  VIRTKEY, CONTROL, NOINVERT
    "W",            ID_TABSTRIPMENU_CLOSEALLTABS, VIRTKEY, SHIFT, CONTROL, ALT, NOINVERT
END


/////////////////////////////////////////////////////////////////////////////
//
// PNG
//

#if defined(APSTUDIO_INVOKED) || defined(TARGET_X64DBG)
#if defined(APSTUDIO_INVOKED)
IDB_X64DBG_ICON$(TARGET_X64DBG) PNG                     "rsrc_files\\icon_x64dbg.png"
#else
IDB_X64DBG_ICON         PNG                     "rsrc_files\\icon_x64dbg.png"
#endif
#endif
#endif    // Neutral resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Russian (Russia) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_RUS)
LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT
#pragma code_page(1251)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Russian (Russia) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_MAIN DIALOGEX 0, 0, 321, 194
STYLE DS_SETFONT | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
CAPTION "Multiline Ultimate Assembler"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",IDC_TABS,"SysTabControl32",TCS_FOCUSNEVER,0,0,321,14
    CONTROL         "",IDC_ASSEMBLER,"RAEdit",WS_TABSTOP | 0x1804,0,14,321,158
    DEFPUSHBUTTON   "&Assemble",IDOK,5,176,50,14
    PUSHBUTTON      "Close",IDC_CLOSE,266,176,50,14
END

IDD_OPTIONS DIALOGEX 0, 0, 142, 252
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Options"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Disassembler",IDC_STATIC,7,7,128,122
    CONTROL         "RVA addresses",IDC_DISASM_RVA,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,14,20,64,10
    CONTROL         "Modules with relocations only",IDC_DISASM_RVA_RELOCONLY,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,24,32,109,10
    CONTROL         "Labels",IDC_DISASM_LABEL,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,14,46,36,10
    CONTROL         "Disasm external jumps/calls",IDC_DISASM_EXTJMP,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,24,58,103,10
    LTEXT           "Disasm hex numbers as:",IDC_STATIC,14,73,78,8
    COMBOBOX        IDC_DISASM_HEX,14,83,113,162,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Generate new labels as:",IDC_STATIC,14,101,78,8
    COMBOBOX        IDC_DISASM_LABELGEN,14,111,113,134,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    GROUPBOX        "Assembler",IDC_STATIC,7,136,128,39
    CONTROL         "Write comments",IDC_ASM_COMMENTS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,14,149,67,10
    CONTROL         "Write labels",IDC_ASM_LABELS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,14,161,53,10
    GROUPBOX        "Editor",IDC_STATIC,7,182,128,42
    CONTROL         "Remember window position",IDC_EDIT_SAVEPOS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,14,195,103,10
    LTEXT           "Tab width:",IDC_STATIC,14,208,35,8
    COMBOBOX        IDC_EDIT_TABWIDTH,53,206,30,40,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    DEFPUSHBUTTON   "OK",IDOK,7,233,50,12
    PUSHBUTTON      "Cancel",IDCANCEL,85,233,50,12
END


/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_RIGHTCLICK MENU
BEGIN
    POPUP "rcm"
    BEGIN
        MENUITEM "&Undo",                       ID_RCM_UNDO
        MENUITEM "&Redo",                       ID_RCM_REDO
        MENUITEM SEPARATOR
        MENUITEM "Cu&t",                        ID_RCM_CUT
        MENUITEM "&Copy",                       ID_RCM_COPY
        MENUITEM "&Paste",                      ID_RCM_PASTE
        MENUITEM "&Delete",                     ID_RCM_DELETE
        MENUITEM SEPARATOR
        MENUITEM "Select &All",                 ID_RCM_SELECTALL
    END
    POPUP "tabmenu"
    BEGIN
        MENUITEM "&New tab",                    ID_TABMENU_NEWTAB
        MENUITEM "&Rename",                     ID_TABMENU_RENAME
        MENUITEM "&Close",                      ID_TABMENU_CLOSE
        MENUITEM SEPARATOR
        MENUITEM "&Import from file...",          ID_TABMENU_LOADFROMFILE
        MENUITEM "&Export to file...",            ID_TABMENU_SAVETOFILE
    END
    POPUP "tabstripmenu"
    BEGIN
        MENUITEM "Close &all tabs",             ID_TABSTRIPMENU_CLOSEALLTABS
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_MAIN, DIALOG
    BEGIN
        BOTTOMMARGIN, 193
    END

    IDD_OPTIONS, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 135
        TOPMARGIN, 7
        BOTTOMMARGIN, 245
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED




================================================
File: stdafx.c
================================================
#include "stdafx.h"



================================================
File: stdafx.h
================================================
#pragma once

#include <windows.h>
#include <tchar.h>
#include <commctrl.h>
#include <stddef.h>



================================================
File: tabctrl_ex.c
================================================
#include "stdafx.h"
#include "tabctrl_ex.h"

// Label editing
static volatile HWND g_hEditingTabCtrlWnd;
static HWND g_hEditCtrlWnd;
static WNDPROC g_pOldEditCtrlProc;
static HHOOK g_hLabelEditMouseHook;

BOOL TabCtrlExInit(HWND hTabCtrlWnd, DWORD dwFlags, UINT uUserNotifyMsg)
{
	TABCTRL_EX_PROP *pTabCtrlExProp;

	pTabCtrlExProp = (TABCTRL_EX_PROP *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(TABCTRL_EX_PROP));
	if(!pTabCtrlExProp)
		return FALSE;

	if(!SetProp(hTabCtrlWnd, _T("TabCtrlExProp"), (HANDLE)pTabCtrlExProp))
	{
		HeapFree(GetProcessHeap(), 0, pTabCtrlExProp);
		return FALSE;
	}

	pTabCtrlExProp->uUserNotifyMsg = uUserNotifyMsg;
	pTabCtrlExProp->dwStyle = GetWindowLong(hTabCtrlWnd, GWL_STYLE);

	pTabCtrlExProp->pOldTabCtrlProc = (WNDPROC)SetWindowLongPtr(hTabCtrlWnd, GWLP_WNDPROC, (LONG_PTR)TabCtrlSubclassProc);
	if(!pTabCtrlExProp->pOldTabCtrlProc)
	{
		RemoveProp(hTabCtrlWnd, _T("TabCtrlExProp"));
		HeapFree(GetProcessHeap(), 0, pTabCtrlExProp);
		return FALSE;
	}

	if(dwFlags & TCF_EX_LABLEEDIT)
		SetWindowLongPtr(hTabCtrlWnd, GWL_STYLE, (pTabCtrlExProp->dwStyle | WS_CLIPCHILDREN));

	pTabCtrlExProp->dwFlags = dwFlags;

	return TRUE;
}

BOOL TabCtrlExExit(HWND hTabCtrlWnd)
{
	TABCTRL_EX_PROP *pTabCtrlExProp;

	pTabCtrlExProp = (TABCTRL_EX_PROP *)GetProp(hTabCtrlWnd, _T("TabCtrlExProp"));
	if(!pTabCtrlExProp)
		return FALSE;

	if(pTabCtrlExProp->dwFlags & TCF_EX_REORDER)
	{
		if(pTabCtrlExProp->bDragging && GetCapture() == hTabCtrlWnd)
			ReleaseCapture();
	}

	if(pTabCtrlExProp->dwFlags & TCF_EX_LABLEEDIT)
	{
		if(g_hEditingTabCtrlWnd == hTabCtrlWnd)
			TabCtrl_Ex_EndEditLabelNow(hTabCtrlWnd, TRUE);
	}

	if(!SetWindowLongPtr(hTabCtrlWnd, GWLP_WNDPROC, (LONG_PTR)pTabCtrlExProp->pOldTabCtrlProc))
		return FALSE;

	if(pTabCtrlExProp->dwFlags & TCF_EX_LABLEEDIT)
		SetWindowLongPtr(hTabCtrlWnd, GWL_STYLE, (pTabCtrlExProp->dwStyle & ~WS_CLIPCHILDREN));

	RemoveProp(hTabCtrlWnd, _T("TabCtrlExProp"));
	HeapFree(GetProcessHeap(), 0, pTabCtrlExProp);

	return TRUE;
}

DWORD TabCtrlExGetFlags(HWND hTabCtrlWnd)
{
	TABCTRL_EX_PROP *pTabCtrlExProp;

	pTabCtrlExProp = (TABCTRL_EX_PROP *)GetProp(hTabCtrlWnd, _T("TabCtrlExProp"));
	if(!pTabCtrlExProp)
		return 0;

	return pTabCtrlExProp->dwFlags;
}

BOOL TabCtrlExSetFlags(HWND hTabCtrlWnd, DWORD dwFlags)
{
	TABCTRL_EX_PROP *pTabCtrlExProp;

	pTabCtrlExProp = (TABCTRL_EX_PROP *)GetProp(hTabCtrlWnd, _T("TabCtrlExProp"));
	if(!pTabCtrlExProp)
		return FALSE;

	if((pTabCtrlExProp->dwFlags & TCF_EX_REORDER) && !(dwFlags & TCF_EX_REORDER))
	{
		if(pTabCtrlExProp->bDragging && GetCapture() == hTabCtrlWnd)
			ReleaseCapture();
	}

	if((pTabCtrlExProp->dwFlags & TCF_EX_LABLEEDIT) != (dwFlags & TCF_EX_LABLEEDIT))
	{
		if(!(dwFlags & TCF_EX_LABLEEDIT))
		{
			if(g_hEditingTabCtrlWnd == hTabCtrlWnd)
				TabCtrl_Ex_EndEditLabelNow(hTabCtrlWnd, TRUE);

			SetWindowLongPtr(hTabCtrlWnd, GWL_STYLE, (pTabCtrlExProp->dwStyle & ~WS_CLIPCHILDREN));
		}
		else
			SetWindowLongPtr(hTabCtrlWnd, GWL_STYLE, (pTabCtrlExProp->dwStyle | WS_CLIPCHILDREN));
	}

	pTabCtrlExProp->dwFlags = dwFlags;

	return TRUE;
}

static LRESULT CALLBACK TabCtrlSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	TABCTRL_EX_PROP *pTabCtrlExProp;
	HDC hControlDC;
	TCHAR szEditedText[TABCTRL_EX_TEXTMAXBUFF];
	HWND hUpDownCtrlWnd;
	WORD wPos;
	int nCurTabId;
	LRESULT lResult;
	POINT pt;
	RECT rc;

	pTabCtrlExProp = (TABCTRL_EX_PROP *)GetProp(hWnd, _T("TabCtrlExProp"));
	if(!pTabCtrlExProp)
		return 0;

	switch(uMsg)
	{
		// Reduce flickering
	case WM_ERASEBKGND:
		if(pTabCtrlExProp->dwFlags & TCF_EX_REDUCEFLICKER)
			return 0;
		break;

	case WM_PAINT:
		if(pTabCtrlExProp->dwFlags & TCF_EX_REDUCEFLICKER)
		{
			ValidateRect(hWnd, NULL);

			hControlDC = GetDC(hWnd);

			CallWindowProc(pTabCtrlExProp->pOldTabCtrlProc, hWnd, WM_ERASEBKGND, (WPARAM)hControlDC, 0);
			CallWindowProc(pTabCtrlExProp->pOldTabCtrlProc, hWnd, WM_PRINTCLIENT, (WPARAM)hControlDC, PRF_CLIENT);

			ReleaseDC(hWnd, hControlDC);
			return 0;
		}
		break;

		// No focus on middle click
	case WM_MBUTTONDOWN:
		if(pTabCtrlExProp->dwFlags & TCF_EX_MBUTTONNOFOCUS)
		{
			if(!(pTabCtrlExProp->dwStyle & TCS_FOCUSONBUTTONDOWN))
				return 0;
		}
		break;

		// Reordering
	case WM_LBUTTONDOWN:
		if(pTabCtrlExProp->dwFlags & TCF_EX_REORDER)
		{
			lResult = CallWindowProc(pTabCtrlExProp->pOldTabCtrlProc, hWnd, uMsg, wParam, lParam);

			nCurTabId = TabCtrl_GetCurSel(hWnd);
			if(nCurTabId != -1)
			{
				pt.x = GET_X_LPARAM(lParam);
				pt.y = GET_Y_LPARAM(lParam);

				ClientToScreen(hWnd, &pt);

				if(DragDetect(hWnd, pt))
				{
					SetCapture(hWnd);

					hUpDownCtrlWnd = FindWindowEx(hWnd, NULL, _T("msctls_updown32"), NULL);
					if(hUpDownCtrlWnd && !IsWindowVisible(hUpDownCtrlWnd))
						hUpDownCtrlWnd = NULL;

					pTabCtrlExProp->bDragging = TRUE;
					pTabCtrlExProp->nDragFromId = nCurTabId;
					pTabCtrlExProp->hScrollUpDownWnd = hUpDownCtrlWnd;
				}
			}

			return lResult;
		}
		break;

	case WM_MOUSEMOVE:
		if(pTabCtrlExProp->dwFlags & TCF_EX_REORDER)
		{
			if(pTabCtrlExProp->bDragging && GetCapture() == hWnd)
			{
				GetClientRect(hWnd, &rc);

				if(GET_X_LPARAM(lParam) < rc.left)
				{
					if(pTabCtrlExProp->hScrollUpDownWnd)
						TabStripScroll(hWnd, pTabCtrlExProp->hScrollUpDownWnd, &pTabCtrlExProp->dwLastScrollTime, FALSE);
				}
				else if(GET_X_LPARAM(lParam) > rc.right)
				{
					if(pTabCtrlExProp->hScrollUpDownWnd)
						TabStripScroll(hWnd, pTabCtrlExProp->hScrollUpDownWnd, &pTabCtrlExProp->dwLastScrollTime, TRUE);
				}
				else
					TabMoveToX(hWnd, TabCtrl_GetCurSel(hWnd), GET_X_LPARAM(lParam));
			}
		}
		break;

	case WM_LBUTTONUP:
		if(pTabCtrlExProp->dwFlags & TCF_EX_REORDER)
		{
			if(pTabCtrlExProp->bDragging && GetCapture() == hWnd)
				ReleaseCapture();
		}
		break;

	case WM_CAPTURECHANGED:
		if(pTabCtrlExProp->dwFlags & TCF_EX_REORDER)
		{
			if(pTabCtrlExProp->bDragging)
			{
				nCurTabId = TabCtrl_GetCurSel(hWnd);

				if(nCurTabId != pTabCtrlExProp->nDragFromId)
					SendUserNotifyMessage(hWnd, pTabCtrlExProp->uUserNotifyMsg, TCN_EX_DRAGDROP, pTabCtrlExProp->nDragFromId, nCurTabId);

				pTabCtrlExProp->bDragging = FALSE;
			}
		}
		break;

		// Label editing
	case TCM_EX_EDITLABEL:
		if(pTabCtrlExProp->dwFlags & TCF_EX_LABLEEDIT)
		{
			if(InterlockedCompareExchangePointer((void **)&g_hEditingTabCtrlWnd, (void *)hWnd, 0))
				return 0;

			if(SendUserNotifyMessage(hWnd, pTabCtrlExProp->uUserNotifyMsg, TCN_EX_BEGINLABELEDIT, 0, 0) || 
				!(g_hEditCtrlWnd = TabEditLabel(hWnd, (int)wParam)))
			{
				g_hEditingTabCtrlWnd = NULL;
				return 0;
			}

			return (LRESULT)g_hEditCtrlWnd;
		}
		break;

	case TCM_EX_GETEDITCONTROL:
		if(pTabCtrlExProp->dwFlags & TCF_EX_LABLEEDIT)
		{
			if(g_hEditingTabCtrlWnd != hWnd)
				return 0;

			return (LRESULT)g_hEditCtrlWnd;
		}
		break;

	case TCM_EX_ENDEDITLABELNOW:
		if(pTabCtrlExProp->dwFlags & TCF_EX_LABLEEDIT)
		{
			if(g_hEditingTabCtrlWnd != hWnd || !g_hEditCtrlWnd)
				return FALSE;

			if(!wParam)
			{
				GetWindowText(g_hEditCtrlWnd, szEditedText, TABCTRL_EX_TEXTMAXBUFF);
				if(SendUserNotifyMessage(hWnd, pTabCtrlExProp->uUserNotifyMsg, TCN_EX_ENDLABELEDIT, 0, (LPARAM)szEditedText))
					TabApplyEditLabel(hWnd, szEditedText);
			}

			TabEndEditLabel(hWnd, g_hEditCtrlWnd);

			g_hEditingTabCtrlWnd = NULL;
			return TRUE;
		}
		break;

	case TCM_INSERTITEM:
	case TCM_DELETEALLITEMS:
	case TCM_DELETEITEM:
	case TCM_SETCURSEL:
		if(pTabCtrlExProp->dwFlags & TCF_EX_LABLEEDIT)
		{
			if(g_hEditingTabCtrlWnd == hWnd)
				TabCtrl_Ex_EndEditLabelNow(hWnd, FALSE);
		}

		// Fixes scroll
		if(uMsg == TCM_DELETEITEM)
		{
			lResult = CallWindowProc(pTabCtrlExProp->pOldTabCtrlProc, hWnd, uMsg, wParam, lParam);
			if(lResult)
			{
				hUpDownCtrlWnd = FindWindowEx(hWnd, NULL, _T("msctls_updown32"), NULL);
				if(hUpDownCtrlWnd && IsWindowVisible(hUpDownCtrlWnd))
				{
					wPos = LOWORD(SendMessage(hUpDownCtrlWnd, UDM_GETPOS, 0, 0));
					SendMessage(hWnd, WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, wPos), 0);
					SendMessage(hWnd, WM_HSCROLL, MAKEWPARAM(SB_ENDSCROLL, 0), 0);
				}
			}

			return lResult;
		}
		break;

		// etc.
	case WM_LBUTTONDBLCLK:
		SendUserNotifyMessage(hWnd, pTabCtrlExProp->uUserNotifyMsg, TCN_EX_DBLCLK, wParam, lParam);
		break;

	case WM_MBUTTONUP:
		SendUserNotifyMessage(hWnd, pTabCtrlExProp->uUserNotifyMsg, TCN_EX_MCLICK, wParam, lParam);
		break;

	case WM_CONTEXTMENU:
		SendUserNotifyMessage(hWnd, pTabCtrlExProp->uUserNotifyMsg, TCN_EX_CONTEXTMENU, wParam, lParam);
		break;

	case WM_STYLECHANGED:
		if(wParam == GWL_STYLE)
			pTabCtrlExProp->dwStyle = ((STYLESTRUCT *)lParam)->styleNew;
		break;
	}

	return CallWindowProc(pTabCtrlExProp->pOldTabCtrlProc, hWnd, uMsg, wParam, lParam);
}

static LRESULT SendUserNotifyMessage(HWND hTabCtrlWnd, UINT uUserNotifyMsg, UINT uCode, WPARAM wParam, LPARAM lParam)
{
	UNMTABCTRLEX usernotify_param;
	int nDlgCtrlId;

	nDlgCtrlId = GetDlgCtrlID(hTabCtrlWnd);

	usernotify_param.hdr.hwndFrom = hTabCtrlWnd;
	usernotify_param.hdr.idFrom = nDlgCtrlId;
	usernotify_param.hdr.code = uCode;

	usernotify_param.wParam = wParam;
	usernotify_param.lParam = lParam;

	return SendMessage(GetParent(hTabCtrlWnd), uUserNotifyMsg, nDlgCtrlId, (LPARAM)&usernotify_param);
}

static int TabMoveToX(HWND hTabCtrlWnd, int nTabIndex, long x)
{
	TCHITTESTINFO hti;
	int nHitTabIndex;
	RECT rc, rc_hit;
	struct {
		TCITEMHEADER header;
		BYTE extra[TABCTRL_EX_EXTRABYTES];
	} tci;
	TCHAR szTabText[TABCTRL_EX_TEXTMAXBUFF];

	TabCtrl_GetItemRect(hTabCtrlWnd, 0, &rc);

	hti.pt.x = x;
	hti.pt.y = rc.top;

	nHitTabIndex = TabCtrl_HitTest(hTabCtrlWnd, &hti);
	if(nHitTabIndex == -1)
		return -1;

	if(nHitTabIndex == nTabIndex)
		return -1;

	TabCtrl_GetItemRect(hTabCtrlWnd, nHitTabIndex, &rc_hit);
	TabCtrl_GetItemRect(hTabCtrlWnd, nTabIndex, &rc);

	if(nHitTabIndex < nTabIndex)
	{
		if(x > rc_hit.left+(rc_hit.right-rc_hit.left+rc.right-rc.left)/2)
			nHitTabIndex++;
	}
	else // if(nTabIndex > nTabIndex)
	{
		if(x < rc_hit.right-(rc_hit.right-rc_hit.left+rc.right-rc.left)/2)
			nHitTabIndex--;
	}

	if(nHitTabIndex == nTabIndex)
		return -1;

	tci.header.mask = TCIF_TEXT|TCIF_IMAGE|TCIF_PARAM;
	tci.header.pszText = szTabText;
	tci.header.cchTextMax = TABCTRL_EX_TEXTMAXBUFF;

	TabCtrl_GetItem(hTabCtrlWnd, nTabIndex, &tci);
	TabCtrl_DeleteItem(hTabCtrlWnd, nTabIndex);
	TabCtrl_InsertItem(hTabCtrlWnd, nHitTabIndex, &tci);

	return nHitTabIndex;
}

static BOOL TabStripScroll(HWND hTabCtrlWnd, HWND hUpDownCtrlWnd, DWORD *pdwLastScrollTime, BOOL bScrollRight)
{
	DWORD dwTickCount;
	DWORD dw;
	WORD wMin, wMax, wPos;

	dwTickCount = GetTickCount();
	if(dwTickCount - *pdwLastScrollTime < 100)
		return FALSE;

	dw = (DWORD)SendMessage(hUpDownCtrlWnd, UDM_GETPOS, 0, 0);
	wPos = LOWORD(dw);

	dw = (DWORD)SendMessage(hUpDownCtrlWnd, UDM_GETRANGE, 0, 0);
	wMin = HIWORD(dw);
	wMax = LOWORD(dw);

	if(bScrollRight)
	{
		if(wPos == wMax)
			return FALSE;

		wPos++;
	}
	else
	{
		if(wPos == wMin)
			return FALSE;

		wPos--;
	}

	SendMessage(hTabCtrlWnd, WM_HSCROLL, MAKEWPARAM(SB_THUMBPOSITION, wPos), 0);
	SendMessage(hTabCtrlWnd, WM_HSCROLL, MAKEWPARAM(SB_ENDSCROLL, 0), 0);

	*pdwLastScrollTime = GetTickCount();

	return TRUE;
}

static LRESULT CALLBACK EditCtrlSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_GETDLGCODE:
		return CallWindowProc(g_pOldEditCtrlProc, hWnd, uMsg, wParam, lParam) | DLGC_WANTALLKEYS;

	case WM_KEYDOWN:
		switch(wParam)
		{
		case VK_RETURN:
			TabCtrl_Ex_EndEditLabelNow(GetParent(hWnd), FALSE);
			return 0;

		case VK_ESCAPE:
			TabCtrl_Ex_EndEditLabelNow(GetParent(hWnd), TRUE);
			return 0;
		}
		break;

	case WM_KILLFOCUS:
		TabCtrl_Ex_EndEditLabelNow(GetParent(hWnd), FALSE);
		break;
	}

	return CallWindowProc(g_pOldEditCtrlProc, hWnd, uMsg, wParam, lParam);
}

static LRESULT CALLBACK EditLabelMouseProc(int nCode, WPARAM wParam, LPARAM lParam)
{
	if(nCode < 0)
		return CallNextHookEx(g_hLabelEditMouseHook, nCode, wParam, lParam);

	if(nCode == HC_ACTION)
	{
		if(((MOUSEHOOKSTRUCT *)lParam)->hwnd != g_hEditCtrlWnd && 
			(wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN || wParam == WM_MBUTTONDOWN || 
			wParam == WM_NCLBUTTONDOWN || wParam == WM_NCRBUTTONDOWN || wParam == WM_NCMBUTTONDOWN))
			TabCtrl_Ex_EndEditLabelNow(GetParent(g_hEditCtrlWnd), FALSE);
	}

	return CallNextHookEx(g_hLabelEditMouseHook, nCode, wParam, lParam);
}

static HWND TabEditLabel(HWND hTabCtrlWnd, int nTextLimit)
{
	HWND hEditCtrlWnd;
	int nCurrentTabIndex;
	TCITEM tci;
	TCHAR szTabText[TABCTRL_EX_TEXTMAXBUFF];
	RECT rc;

	nCurrentTabIndex = TabCtrl_GetCurSel(hTabCtrlWnd);
	if(nCurrentTabIndex == -1)
		return NULL;

	tci.mask = TCIF_TEXT;
	tci.pszText = szTabText;
	tci.cchTextMax = TABCTRL_EX_TEXTMAXBUFF;

	TabCtrl_GetItem(hTabCtrlWnd, nCurrentTabIndex, &tci);

	TabCtrl_GetItemRect(hTabCtrlWnd, nCurrentTabIndex, &rc);

	hEditCtrlWnd = CreateWindowEx(WS_EX_CLIENTEDGE, _T("edit"), szTabText, WS_CHILD|WS_VISIBLE|ES_LEFT|ES_AUTOHSCROLL, 
		rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, hTabCtrlWnd, NULL, NULL, NULL);
	if(!hEditCtrlWnd)
		return NULL;

	SendMessage(hEditCtrlWnd, WM_SETFONT, (WPARAM)SendMessage(hTabCtrlWnd, WM_GETFONT, 0, 0), FALSE);

	g_pOldEditCtrlProc = (WNDPROC)SetWindowLongPtr(hEditCtrlWnd, GWLP_WNDPROC, (LONG_PTR)EditCtrlSubclassProc);
	if(!g_pOldEditCtrlProc)
	{
		DestroyWindow(hEditCtrlWnd);
		return NULL;
	}

	g_hLabelEditMouseHook = SetWindowsHookEx(WH_MOUSE, EditLabelMouseProc, NULL, GetCurrentThreadId());
	if(!g_hLabelEditMouseHook)
	{
		DestroyWindow(hEditCtrlWnd);
		return NULL;
	}

	if(nTextLimit > 0 && nTextLimit < TABCTRL_EX_TEXTMAXBUFF-1)
		SendMessage(hEditCtrlWnd, EM_SETLIMITTEXT, nTextLimit, 0);
	else
		SendMessage(hEditCtrlWnd, EM_SETLIMITTEXT, TABCTRL_EX_TEXTMAXBUFF-1, 0);

	SetFocus(hEditCtrlWnd);
	SendMessage(hEditCtrlWnd, EM_SETSEL, 0, -1);

	return hEditCtrlWnd;
}

static void TabApplyEditLabel(HWND hTabCtrlWnd, TCHAR *pEditedText)
{
	TCITEM tci;

	tci.mask = TCIF_TEXT;
	tci.pszText = pEditedText;

	TabCtrl_SetItem(hTabCtrlWnd, TabCtrl_GetCurSel(hTabCtrlWnd), &tci);
}

static void TabEndEditLabel(HWND hTabCtrlWnd, HWND hEditCtrlWnd)
{
	UnhookWindowsHookEx(g_hLabelEditMouseHook);

	SetWindowLongPtr(hEditCtrlWnd, GWLP_WNDPROC, (LONG_PTR)g_pOldEditCtrlProc);

	if(GetFocus() == hEditCtrlWnd)
		SetFocus(GetParent(hTabCtrlWnd));

	DestroyWindow(hEditCtrlWnd);
	g_hEditCtrlWnd = NULL;
}



================================================
File: tabctrl_ex.h
================================================
#ifndef _TABCTRL_EX_H_
#define _TABCTRL_EX_H_

// Config
#include "assembler_dlg.h"

#define TABCTRL_EX_EXTRABYTES    sizeof(TCITEM_EXTRA)
#define TABCTRL_EX_TEXTMAXBUFF   MAX_PATH

// Flags
#define TCF_EX_REORDER           0x01
#define TCF_EX_LABLEEDIT         0x02
#define TCF_EX_REDUCEFLICKER     0x04
#define TCF_EX_MBUTTONNOFOCUS    0x08

// Messages
#define TCM_EX_EDITLABEL         WM_APP
#define TabCtrl_Ex_EditLabel(hwnd, nTextLimit) \
	(HWND)SNDMSG((hwnd), TCM_EX_EDITLABEL, (WPARAM)(int)(nTextLimit), 0L)

#define TCM_EX_GETEDITCONTROL    (WM_APP+1)
#define TabCtrl_Ex_GetEditControl(hwnd) \
	(HWND)SNDMSG((hwnd), TCM_EX_GETEDITCONTROL, 0L, 0L)

#define TCM_EX_ENDEDITLABELNOW   (WM_APP+2)
#define TabCtrl_Ex_EndEditLabelNow(hwnd, fCancel) \
	(BOOL)SNDMSG((hwnd), TCM_EX_ENDEDITLABELNOW, (WPARAM)(BOOL)(fCancel), 0L)

// Notifications
#define TCN_EX_DRAGDROP          0 // wParam: (int)nDragFromId, lParam: (int)nDropToId
#define TCN_EX_BEGINLABELEDIT    1 // wParam/lParam: 0, Return: TRUE to cancel, FALSE to proceed
#define TCN_EX_ENDLABELEDIT      2 // wParam: 0, lParam: (TCHAR *)pszEditedText, Return: TRUE to proceed, FALSE to cancel
#define TCN_EX_DBLCLK            3 // wParam/lParam: see WM_LBUTTONDBLCLK
#define TCN_EX_MCLICK            4 // wParam/lParam: see WM_MBUTTONUP
#define TCN_EX_CONTEXTMENU       5 // wParam/lParam: see WM_CONTEXTMENU

// Structures
typedef struct tagTABCTRL_EX_PROP {
	DWORD dwFlags;
	UINT uUserNotifyMsg;
	WNDPROC pOldTabCtrlProc;
	DWORD dwStyle;

	// Reordering
	BOOL bDragging;
	int nDragFromId;
	HWND hScrollUpDownWnd;
	DWORD dwLastScrollTime;
} TABCTRL_EX_PROP, *LPTABCTRL_EX_PROP;

typedef struct tagUNMTABCTRLEX {
	NMHDR hdr;
	WPARAM wParam;
	LPARAM lParam;
} UNMTABCTRLEX, *LPUNMTABCTRLEX;

// In case these aren't defined yet
#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lParam)	 ((int)(short)LOWORD(lParam))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lParam)	 ((int)(short)HIWORD(lParam))
#endif

// Functions
BOOL TabCtrlExInit(HWND hTabCtrlWnd, DWORD dwFlags, UINT uUserNotifyMsg);
BOOL TabCtrlExExit(HWND hTabCtrlWnd);
DWORD TabCtrlExGetFlags(HWND hTabCtrlWnd);
BOOL TabCtrlExSetFlags(HWND hTabCtrlWnd, DWORD dwFlags);
static LRESULT CALLBACK TabCtrlSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT SendUserNotifyMessage(HWND hTabCtrlWnd, UINT uUserNotifyMsg, UINT uCode, WPARAM wParam, LPARAM lParam);
static int TabMoveToX(HWND hTabCtrlWnd, int nTabIndex, long x);
static BOOL TabStripScroll(HWND hTabCtrlWnd, HWND hUpDownCtrlWnd, DWORD *pdwLastScrollTime, BOOL bScrollRight);
static LRESULT CALLBACK EditCtrlSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT CALLBACK EditLabelMouseProc(int nCode, WPARAM wParam, LPARAM lParam);
static HWND TabEditLabel(HWND hTabCtrlWnd, int nTextLimit);
static void TabApplyEditLabel(HWND hTabCtrlWnd, TCHAR *pEditedText);
static void TabEndEditLabel(HWND hTabCtrlWnd, HWND hEditCtrlWnd);

#endif // _TABCTRL_EX_H_



================================================
File: write_asm.c
================================================
#include "stdafx.h"
#include "write_asm.h"

extern OPTIONS options;

#ifdef _WIN64
#define HEXPTR_PADDED         _T("%016I64X")
#else // _WIN64
#define HEXPTR_PADDED         _T("%08X")
#endif // _WIN64

LONG_PTR WriteAsm(TCHAR *lpText, TCHAR *lpError)
{
	LABEL_HEAD label_head = {NULL, (LABEL_NODE *)&label_head};
	CMD_BLOCK_HEAD cmd_block_head = {NULL, (CMD_BLOCK_NODE *)&cmd_block_head};
	TCHAR *lpErrorSpot;

	// Fill the data linked lists using the given text, without replacing labels in commands yet
	lpErrorSpot = TextToData(&label_head, &cmd_block_head, lpText, lpError);

	// Replace labels in commands with addresses
	if(!lpErrorSpot)
		lpErrorSpot = ReplaceLabelsInCommands(&label_head, &cmd_block_head, lpError);

	// Patch!
	if(!lpErrorSpot)
		lpErrorSpot = PatchCommands(&cmd_block_head, lpError);

	// Insert comments
	if(!lpErrorSpot && options.asm_comments)
		lpErrorSpot = SetComments(&cmd_block_head, lpError);

	// Insert labels
	if(!lpErrorSpot && options.asm_labels)
		lpErrorSpot = SetLabels(&label_head, &cmd_block_head, lpError);

	FreeLabelList(&label_head);
	FreeCmdBlockList(&cmd_block_head);

	InvalidateGui();

	if(lpErrorSpot)
		return -(lpErrorSpot-lpText);
	else
		return 1;
}

static TCHAR *TextToData(LABEL_HEAD *p_label_head, CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpText, TCHAR *lpError)
{
	CMD_BLOCK_NODE *cmd_block_node;
	TCHAR *p, *lpNextLine, *lpBlockDeclaration;
	DWORD_PTR dwAddress, dwEndAddress;
	DWORD_PTR dwBaseAddress;
	TCHAR chCommentChar;
	LONG_PTR result;

	cmd_block_node = NULL;
	dwAddress = 0;
	dwEndAddress = 0;
	dwBaseAddress = 0;
	chCommentChar = _T('\0');

	for(p = lpText; p != NULL; p = lpNextLine)
	{
		p = SkipSpaces(p);
		lpNextLine = NullTerminateLine(p);

		if(IsInComment(&chCommentChar, p, lpError))
			continue;

		while(*p != _T('\0') && *p != _T(';'))
		{
			if(!cmd_block_node && *p != _T('<'))
			{
				lstrcpy(lpError, _T("Address expected"));
				return p;
			}

			switch(*p)
			{
			case _T('<'): // address
				if(dwEndAddress != 0 && dwAddress > dwEndAddress)
				{
					wsprintf(lpError, _T("End of code block exceeds the block end address (%Iu extra bytes)"), dwAddress - dwEndAddress);
					return lpBlockDeclaration;
				}

				lpBlockDeclaration = p;

				result = AddressToData(p_cmd_block_head, &cmd_block_node, &dwAddress, &dwEndAddress, &dwBaseAddress, p, lpError);
				break;

			case _T('@'): // label
				result = LabelToData(p_label_head, cmd_block_node, &dwAddress, p, lpError);
				break;

			case _T('!'): // special command
				result = SpecialCommandToData(cmd_block_node, &dwAddress, dwEndAddress, p, lpError);
				break;

			default: // an asm command or a string
				result = CommandToData(cmd_block_node, &dwAddress, dwBaseAddress, p, lpError);
				break;
			}

			if(result <= 0)
				return p + (-result);

			p += result;
			p = SkipSpaces(p);
		}
	}

	if(dwEndAddress != 0 && dwAddress > dwEndAddress)
	{
		wsprintf(lpError, _T("End of code block exceeds the block end address (%Iu extra bytes)"), dwAddress - dwEndAddress);
		return lpBlockDeclaration;
	}

	return NULL;
}

static LONG_PTR AddressToData(CMD_BLOCK_HEAD *p_cmd_block_head, CMD_BLOCK_NODE **p_cmd_block_node,
	DWORD_PTR *pdwAddress, DWORD_PTR *pdwEndAddress, DWORD_PTR *pdwBaseAddress, TCHAR *lpText, TCHAR *lpError)
{
	DWORD_PTR dwAddress;

	LONG_PTR result = ParseAddress(lpText, &dwAddress, pdwEndAddress, pdwBaseAddress, lpError);
	if(result <= 0)
		return result;

	if(!NewCmdBlock(p_cmd_block_head, dwAddress, lpError))
		return 0;

	*p_cmd_block_node = p_cmd_block_head->last;

	*pdwAddress = dwAddress;

	return result;
}

static LONG_PTR LabelToData(LABEL_HEAD *p_label_head, CMD_BLOCK_NODE *cmd_block_node, DWORD_PTR *pdwAddress, TCHAR *lpText, TCHAR *lpError)
{
	DWORD_PTR dwAddress = *pdwAddress;

	if(lpText[0] == _T('@') && lpText[1] == _T('@'))
		return ParseAnonLabel(lpText, dwAddress, &cmd_block_node->anon_label_head, lpError);

	DWORD_PTR dwPaddingSize = 0;
	LONG_PTR result = ParseLabel(lpText, dwAddress, p_label_head, &dwPaddingSize, lpError);
	if(result <= 0)
		return result;

	if(dwPaddingSize > 0)
	{
		if(!InsertBytes(lpText, dwPaddingSize, 0, &cmd_block_node->cmd_head, lpError))
			return 0;

		cmd_block_node->nSize += dwPaddingSize;
		dwAddress += dwPaddingSize;

		*pdwAddress = dwAddress;
	}

	return result;
}

static LONG_PTR SpecialCommandToData(CMD_BLOCK_NODE *cmd_block_node, DWORD_PTR *pdwAddress, DWORD_PTR dwEndAddress, TCHAR *lpText, TCHAR *lpError)
{
	UINT nSpecialCmd;
	LONG_PTR result = ParseSpecialCommand(lpText, &nSpecialCmd, lpError);
	if(result <= 0)
		return result;

	DWORD_PTR dwAddress = *pdwAddress;
	DWORD_PTR dwPaddingSize;
	BYTE bPaddingByteValue;

	switch(nSpecialCmd)
	{
	case SPECIAL_CMD_ALIGN:
		result = ParseAlignSpecialCommand(lpText, result, dwAddress, &dwPaddingSize, lpError);
		if(result <= 0)
			return result;

		if(dwPaddingSize > 0)
		{
			if(!InsertBytes(lpText, dwPaddingSize, 0, &cmd_block_node->cmd_head, lpError))
				return 0;

			cmd_block_node->nSize += dwPaddingSize;
			dwAddress += dwPaddingSize;

			*pdwAddress = dwAddress;
		}
		break;

	case SPECIAL_CMD_PAD:
		result = ParsePadSpecialCommand(lpText, result, &bPaddingByteValue, lpError);
		if(result <= 0)
			return result;

		if(dwEndAddress == 0)
		{
			lstrcpy(lpError, _T("The !pad special command can only be used with a defined block end address"));
			return 0;
		}

		if(dwEndAddress > dwAddress)
		{
			dwPaddingSize = dwEndAddress - dwAddress;

			if(!InsertBytes(lpText, dwPaddingSize, bPaddingByteValue, &cmd_block_node->cmd_head, lpError))
				return 0;

			cmd_block_node->nSize += dwPaddingSize;
			dwAddress += dwPaddingSize;

			*pdwAddress = dwAddress;
		}
		break;
	}

	return result;
}

static LONG_PTR CommandToData(CMD_BLOCK_NODE *cmd_block_node, DWORD_PTR *pdwAddress, DWORD_PTR dwBaseAddress, TCHAR *lpText, TCHAR *lpError)
{
	DWORD_PTR dwAddress = *pdwAddress;
	SIZE_T nSize;
	LONG_PTR result;

	if(lpText[0] == _T('\"'))
		result = ParseAsciiString(lpText, &cmd_block_node->cmd_head, &nSize, lpError);
	else if(lpText[0] == _T('L') && lpText[1] == _T('\"'))
		result = ParseUnicodeString(lpText, &cmd_block_node->cmd_head, &nSize, lpError);
	else
		result = ParseCommand(lpText, dwAddress, dwBaseAddress, &cmd_block_node->cmd_head, &nSize, lpError);

	if(result <= 0)
		return result;

	cmd_block_node->nSize += nSize;
	dwAddress += nSize;

	*pdwAddress = dwAddress;

	return result;
}

static BOOL IsInComment(TCHAR *pchCommentChar, TCHAR *lpText, TCHAR *lpError)
{
	TCHAR chCommentChar = *pchCommentChar;
	TCHAR *p = lpText;

	if(chCommentChar != _T('\0'))
	{
		while(*p != _T('\0'))
		{
			if(*p == chCommentChar)
			{
				*pchCommentChar = _T('\0');
				break;
			}

			p++;
		}

		return TRUE;
	}

	TCHAR *pszComment = _T("COMMENT");
	while(*pszComment != _T('\0'))
	{
		TCHAR c = *p;

		if(c >= _T('a') && c <= _T('z'))
			c += -_T('a') + _T('A');

		if(c != *pszComment)
			return FALSE;

		p++;
		pszComment++;
	}

	TCHAR *p2 = SkipSpaces(p);
	if(p2 == p || *p2 == _T('\0'))
		return FALSE;

	chCommentChar = *p2;
	p = p2 + 1;

	// A second occurrence of the char on the line
	// terminates the comment
	while(*p != _T('\0'))
	{
		if(*p == chCommentChar)
		{
			chCommentChar = _T('\0');
			break;
		}

		p++;
	}

	*pchCommentChar = chCommentChar;

	return TRUE;
}

static LONG_PTR ParseAddress(TCHAR *lpText, DWORD_PTR *pdwAddress, DWORD_PTR *pdwEndAddress, DWORD_PTR *pdwBaseAddress, TCHAR *lpError)
{
	TCHAR *p;
	DWORD_PTR dwAddress, dwBaseAddress;
	DWORD_PTR dwEndAddress, dwEndBaseAddress;
	LONG_PTR result;

	p = lpText;

	if(*p != _T('<'))
	{
		lstrcpy(lpError, _T("Could not parse address, '<' expected"));
		return -(p-lpText);
	}

	p++;
	p = SkipSpaces(p);

	// Start address
	if(*p == _T('$'))
	{
		result = ParseRVAAddress(p, &dwAddress, *pdwBaseAddress, &dwBaseAddress, lpError);
	}
	else
	{
		dwBaseAddress = 0;
		result = ParseDWORDPtr(p, &dwAddress, lpError);
	}

	if(result <= 0)
		return -(p-lpText)+result;

	p += result;
	p = SkipSpaces(p);

	if(p[0] == _T('.') && p[1] == _T('.'))
	{
		p += 2;
		p = SkipSpaces(p);

		// End address
		if(*p == _T('$'))
		{
			result = ParseRVAAddress(p, &dwEndAddress, *pdwBaseAddress, &dwEndBaseAddress, lpError);
		}
		else
		{
			dwEndBaseAddress = 0;
			result = ParseDWORDPtr(p, &dwEndAddress, lpError);
		}

		if(result <= 0)
			return -(p-lpText)+result;

		if(dwBaseAddress != dwEndBaseAddress)
		{
			lstrcpy(lpError, _T("The RVA base address of both the start address and the end address must match"));
			return -(p-lpText);
		}

		if(dwEndAddress <= dwAddress)
		{
			lstrcpy(lpError, _T("The end address must be greater than the start address"));
			return -(p-lpText);
		}

		p += result;
		p = SkipSpaces(p);
	}
	else
		dwEndAddress = 0;

	if(*p != _T('>'))
	{
		lstrcpy(lpError, _T("Could not parse address, '>' expected"));
		return -(p-lpText);
	}

	p++;

	*pdwAddress = dwAddress;
	*pdwEndAddress = dwEndAddress;
	*pdwBaseAddress = dwBaseAddress;

	return p-lpText;
}

static BOOL NewCmdBlock(CMD_BLOCK_HEAD *p_cmd_block_head, DWORD_PTR dwAddress, TCHAR *lpError)
{
	CMD_BLOCK_NODE *cmd_block_node;

	cmd_block_node = (CMD_BLOCK_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(CMD_BLOCK_NODE));
	if(!cmd_block_node)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return FALSE;
	}

	cmd_block_node->dwAddress = dwAddress;
	cmd_block_node->nSize = 0;
	cmd_block_node->cmd_head.next = NULL;
	cmd_block_node->cmd_head.last = (CMD_NODE *)&cmd_block_node->cmd_head;
	cmd_block_node->anon_label_head.next = NULL;
	cmd_block_node->anon_label_head.last = (ANON_LABEL_NODE *)&cmd_block_node->anon_label_head;

	cmd_block_node->next = NULL;

	p_cmd_block_head->last->next = cmd_block_node;
	p_cmd_block_head->last = cmd_block_node;

	return TRUE;
}

static LONG_PTR ParseAnonLabel(TCHAR *lpText, DWORD_PTR dwAddress, ANON_LABEL_HEAD *p_anon_label_head, TCHAR *lpError)
{
	ANON_LABEL_NODE *anon_label_node;
	TCHAR *p;

	p = lpText;

	if(*p != _T('@') || p[1] != _T('@'))
	{
		lstrcpy(lpError, _T("Could not parse anonymous label, '@@' expected"));
		return -(p-lpText);
	}

	p += 2;
	p = SkipSpaces(p);

	if(*p != _T(':'))
	{
		lstrcpy(lpError, _T("Could not parse anonymous label, ':' expected"));
		return -(p-lpText);
	}

	p++;

	anon_label_node = (ANON_LABEL_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(ANON_LABEL_NODE));
	if(!anon_label_node)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	anon_label_node->dwAddress = dwAddress;

	anon_label_node->next = NULL;

	p_anon_label_head->last->next = anon_label_node;
	p_anon_label_head->last = anon_label_node;

	return p-lpText;
}

static LONG_PTR ParseLabel(TCHAR *lpText, DWORD_PTR dwAddress, LABEL_HEAD *p_label_head, DWORD_PTR *pdwPaddingSize, TCHAR *lpError)
{
	LABEL_NODE *label_node;
	TCHAR *p;
	TCHAR *lpLabel, *lpLabelEnd;
	DWORD_PTR dwAlignValue;
	DWORD_PTR dwPaddingSize;
	LONG_PTR result;

	p = lpText;

	if(*p != _T('@'))
	{
		lstrcpy(lpError, _T("Could not parse label, '@' expected"));
		return -(p-lpText);
	}

	p++;
	lpLabel = p;

	if(
		(*p < _T('0') || *p > _T('9')) && 
		(*p < _T('A') || *p > _T('Z')) && 
		(*p < _T('a') || *p > _T('z')) && 
		*p != _T('_')
	)
	{
		lstrcpy(lpError, _T("Could not parse label"));
		return -(p-lpText);
	}

	p++;

	while(
		(*p >= _T('0') && *p <= _T('9')) || 
		(*p >= _T('A') && *p <= _T('Z')) || 
		(*p >= _T('a') && *p <= _T('z')) || 
		*p == _T('_')
	)
		p++;

	lpLabelEnd = p;

	if(*p == _T('@'))
	{
		p++;

		result = ParseDWORDPtr(p, &dwAlignValue, lpError);
		if(result <= 0)
			return -(p-lpText)+result;

		if(!GetAlignPaddingSize(dwAddress, dwAlignValue, &dwPaddingSize, lpError))
			return -(p-lpText);

		p += result;
	}
	else
	{
		dwAlignValue = 0;
		dwPaddingSize = 0;
	}

	p = SkipSpaces(p);

	if(*p != _T(':'))
	{
		lstrcpy(lpError, _T("Could not parse label, ':' expected"));
		return -(p-lpText);
	}

	p++;

	*lpLabelEnd = _T('\0');

	for(label_node = p_label_head->next; label_node != NULL; label_node = label_node->next)
	{
		if(lstrcmp(lpLabel, label_node->lpLabel) == 0)
		{
			lstrcpy(lpError, _T("Label redefinition"));
			return 0;
		}
	}

	label_node = (LABEL_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(LABEL_NODE));
	if(!label_node)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	label_node->dwAddress = dwAddress + dwPaddingSize;
	label_node->lpLabel = lpLabel;

	label_node->next = NULL;

	p_label_head->last->next = label_node;
	p_label_head->last = label_node;

	*pdwPaddingSize = dwPaddingSize;

	return p-lpText;
}

static LONG_PTR ParseAsciiString(TCHAR *lpText, CMD_HEAD *p_cmd_head, SIZE_T *pnSizeInBytes, TCHAR *lpError)
{
#ifdef UNICODE
	CMD_NODE *cmd_node;
	WCHAR *p, *p2;
	WCHAR *psubstr;
	SIZE_T nStringLength;
	WCHAR *lpComment;
	char *dest;
	SIZE_T nDestLen;
	BYTE bHexVal;
	int nBytesWritten;
	int i;

	// Check string, calc size
	p = lpText;

	if(*p != L'\"')
	{
		lstrcpy(lpError, L"Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	p++;

	psubstr = p;
	nStringLength = 0;

	while(*p != L'\"' && *p != L'\0')
	{
		if(*p == L'\\')
		{
			if(p-psubstr > 0)
			{
				nStringLength += WideCharToMultiByte(CP_ACP, 0, psubstr, p-psubstr, NULL, 0, NULL, NULL);
				psubstr = p;
			}

			p++;
			switch(*p)
			{
			case L'x':
				p++;

				if((*p < L'0' || *p > L'9') && (*p < L'A' || *p > L'F') && (*p < L'a' || *p > L'f'))
				{
					lstrcpy(lpError, L"Could not parse string, hex constants must have at least one hex digit");
					return -(psubstr-lpText);
				}

				while(*p == L'0')
					p++;

				for(i=0; (p[i] >= L'0' && p[i] <= L'9') || (p[i] >= L'A' && p[i] <= L'F') || (p[i] >= L'a' && p[i] <= L'f'); i++)
				{
					if(i >= 2)
					{
						lstrcpy(lpError, L"Could not parse string, value is too big for a character");
						return -(psubstr-lpText);
					}
				}

				p += i;
				break;

			case L'\\':
			case L'\"':
			case L'0':
			case L'a':
			case L'b':
			case L'f':
			case L'r':
			case L'n':
			case L't':
			case L'v':
				p++;
				break;

			default:
				lstrcpy(lpError, L"Could not parse string, unrecognized character escape sequence");
				return -(psubstr-lpText);
			}

			nStringLength++;

			psubstr = p;
		}
		else
			p++;
	}

	if(p-psubstr > 0)
		nStringLength += WideCharToMultiByte(CP_ACP, 0, psubstr, p-psubstr, NULL, 0, NULL, NULL);

	if(*p != L'\"')
	{
		lstrcpy(lpError, L"Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	if(nStringLength == 0)
	{
		lstrcpy(lpError, L"Empty strings are not allowed");
		return -(p-lpText);
	}

	p++;
	p = SkipSpaces(p);

	if(*p != L'\0' && *p != L';')
	{
		lstrcpy(lpError, L"Unexpected input after string definition");
		return -(p-lpText);
	}

	// Check for comment
	if(p[0] == L';' && p[1] != L';')
	{
		lpComment = SkipSpaces(p+1);
		if(*lpComment == L'\0')
			lpComment = NULL;
	}
	else
		lpComment = NULL;

	// Allocate
	cmd_node = (CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(CMD_NODE));
	if(!cmd_node)
	{
		lstrcpy(lpError, L"Allocation failed");
		return 0;
	}

	cmd_node->bCode = (BYTE *)HeapAlloc(GetProcessHeap(), 0, nStringLength);
	if(!cmd_node->bCode)
	{
		HeapFree(GetProcessHeap(), 0, cmd_node);

		lstrcpy(lpError, L"Allocation failed");
		return 0;
	}

	// Parse string
	p2 = lpText+1; // skip "

	psubstr = p2;
	dest = (char *)cmd_node->bCode;
	nDestLen = nStringLength;

	while(*p2 != L'\"')
	{
		if(*p2 == L'\\')
		{
			if(p2-psubstr > 0)
			{
				nBytesWritten = WideCharToMultiByte(CP_ACP, 0, psubstr, p2-psubstr, dest, nDestLen, NULL, NULL);
				dest += nBytesWritten;
				nDestLen -= nBytesWritten;

				psubstr = p2;
			}

			p2++;
			switch(*p2)
			{
			case L'x':
				p2++;
				bHexVal = 0;

				while((*p2 >= L'0' && *p2 <= L'9') || (*p2 >= L'A' && *p2 <= L'F') || (*p2 >= L'a' && *p2 <= L'f'))
				{
					bHexVal <<= 4;

					if(*p2 >= L'0' && *p2 <= L'9')
						bHexVal |= *p2-L'0';
					else if(*p2 >= L'A' && *p2 <= L'F')
						bHexVal |= *p2-L'A'+10;
					else if(*p2 >= L'a' && *p2 <= L'f')
						bHexVal |= *p2-L'a'+10;

					p2++;
				}

				*dest = bHexVal;
				break;

			case L'\\':
			case L'\"':
				*dest = (char)*p2;
				p2++;
				break;

			case L'0':
				*dest = L'\0';
				p2++;
				break;

			case L'a':
				*dest = L'\a';
				p2++;
				break;

			case L'b':
				*dest = L'\b';
				p2++;
				break;

			case L'f':
				*dest = L'\f';
				p2++;
				break;

			case L'r':
				*dest = L'\r';
				p2++;
				break;

			case L'n':
				*dest = L'\n';
				p2++;
				break;

			case L't':
				*dest = L'\t';
				p2++;
				break;

			case L'v':
				*dest = L'\v';
				p2++;
				break;
			}

			dest++;

			psubstr = p2;
		}
		else
			p2++;
	}

	if(p2-psubstr > 0)
		WideCharToMultiByte(CP_ACP, 0, psubstr, p2-psubstr, dest, nDestLen, NULL, NULL);

#else // if !UNICODE
	CMD_NODE *cmd_node;
	char *p, *p2;
	char *pescape;
	SIZE_T nStringLength;
	char *lpComment;
	char *dest;
	BYTE bHexVal;
	int i;

	// Check string, calc size
	p = lpText;

	if(*p != '\"')
	{
		lstrcpy(lpError, "Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	p++;
	nStringLength = 0;

	while(*p != '\"' && *p != '\0')
	{
		if(*p == '\\')
		{
			pescape = p;

			p++;
			switch(*p)
			{
			case 'x':
				p++;

				if((*p < '0' || *p > '9') && (*p < 'A' || *p > 'F') && (*p < 'a' || *p > 'f'))
				{
					lstrcpy(lpError, "Could not parse string, hex constants must have at least one hex digit");
					return -(pescape-lpText);
				}

				while(*p == '0')
					p++;

				for(i=0; (p[i] >= '0' && p[i] <= '9') || (p[i] >= 'A' && p[i] <= 'F') || (p[i] >= 'a' && p[i] <= 'f'); i++)
				{
					if(i >= 2)
					{
						lstrcpy(lpError, "Could not parse string, value is too big for a character");
						return -(pescape-lpText);
					}
				}

				p += i;
				break;

			case '\\':
			case '\"':
			case '0':
			case 'a':
			case 'b':
			case 'f':
			case 'r':
			case 'n':
			case 't':
			case 'v':
				p++;
				break;

			default:
				lstrcpy(lpError, "Could not parse string, unrecognized character escape sequence");
				return -(pescape-lpText);
			}
		}
		else
			p++;

		nStringLength++;
	}

	if(*p != '\"')
	{
		lstrcpy(lpError, "Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	if(nStringLength == 0)
	{
		lstrcpy(lpError, "Empty strings are not allowed");
		return -(p-lpText);
	}

	p++;
	p = SkipSpaces(p);

	if(*p != '\0' && *p != ';')
	{
		lstrcpy(lpError, "Unexpected input after string definition");
		return -(p-lpText);
	}

	// Check for comment
	if(p[0] == ';' && p[1] != ';')
	{
		lpComment = SkipSpaces(p+1);
		if(*lpComment == '\0')
			lpComment = NULL;
	}
	else
		lpComment = NULL;

	// Allocate
	cmd_node = (CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(CMD_NODE));
	if(!cmd_node)
	{
		lstrcpy(lpError, "Allocation failed");
		return 0;
	}

	cmd_node->bCode = (BYTE *)HeapAlloc(GetProcessHeap(), 0, nStringLength);
	if(!cmd_node->bCode)
	{
		HeapFree(GetProcessHeap(), 0, cmd_node);

		lstrcpy(lpError, "Allocation failed");
		return 0;
	}

	// Parse string
	p2 = lpText+1; // skip "

	dest = (char *)cmd_node->bCode;

	while(*p2 != '\"')
	{
		if(*p2 == '\\')
		{
			p2++;
			switch(*p2)
			{
			case 'x':
				p2++;
				bHexVal = 0;

				while((*p2 >= '0' && *p2 <= '9') || (*p2 >= 'A' && *p2 <= 'F') || (*p2 >= 'a' && *p2 <= 'f'))
				{
					bHexVal <<= 4;

					if(*p2 >= '0' && *p2 <= '9')
						bHexVal |= *p2-'0';
					else if(*p2 >= 'A' && *p2 <= 'F')
						bHexVal |= *p2-'A'+10;
					else if(*p2 >= 'a' && *p2 <= 'f')
						bHexVal |= *p2-'a'+10;

					p2++;
				}

				*dest = (char)bHexVal;
				break;

			case '\\':
			case '\"':
				*dest = *p2;
				p2++;
				break;

			case '0':
				*dest = '\0';
				p2++;
				break;

			case 'a':
				*dest = '\a';
				p2++;
				break;

			case 'b':
				*dest = '\b';
				p2++;
				break;

			case 'f':
				*dest = '\f';
				p2++;
				break;

			case 'r':
				*dest = '\r';
				p2++;
				break;

			case 'n':
				*dest = '\n';
				p2++;
				break;

			case 't':
				*dest = '\t';
				p2++;
				break;

			case 'v':
				*dest = '\v';
				p2++;
				break;
			}
		}
		else
		{
			*dest = *p2;
			p2++;
		}

		dest++;
	}

#endif // UNICODE

	cmd_node->nCodeSize = nStringLength;
	cmd_node->lpCommand = lpText;
	cmd_node->lpComment = lpComment;
	cmd_node->lpResolvedCommandWithLabels = NULL;

	cmd_node->next = NULL;

	p_cmd_head->last->next = cmd_node;
	p_cmd_head->last = cmd_node;

	*pnSizeInBytes = nStringLength;

	return p-lpText;
}

static LONG_PTR ParseUnicodeString(TCHAR *lpText, CMD_HEAD *p_cmd_head, SIZE_T *pnSizeInBytes, TCHAR *lpError)
{
#ifdef UNICODE
	CMD_NODE *cmd_node;
	WCHAR *p, *p2;
	WCHAR *pescape;
	SIZE_T nStringLength;
	WCHAR *lpComment;
	WCHAR *dest;
	WORD wHexVal;
	int i;

	// Check string, calc size
	p = lpText;

	if(*p != L'L')
	{
		lstrcpy(lpError, L"Could not parse string, 'L' expected");
		return -(p-lpText);
	}

	p++;

	if(*p != L'\"')
	{
		lstrcpy(lpError, L"Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	p++;
	nStringLength = 0;

	while(*p != L'\"' && *p != L'\0')
	{
		if(*p == L'\\')
		{
			pescape = p;

			p++;
			switch(*p)
			{
			case L'x':
				p++;

				if((*p < L'0' || *p > L'9') && (*p < L'A' || *p > L'F') && (*p < L'a' || *p > L'f'))
				{
					lstrcpy(lpError, L"Could not parse string, hex constants must have at least one hex digit");
					return -(pescape-lpText);
				}

				while(*p == L'0')
					p++;

				for(i=0; (p[i] >= L'0' && p[i] <= L'9') || (p[i] >= L'A' && p[i] <= L'F') || (p[i] >= L'a' && p[i] <= L'f'); i++)
				{
					if(i >= 4)
					{
						lstrcpy(lpError, L"Could not parse string, value is too big for a character");
						return -(pescape-lpText);
					}
				}

				p += i;
				break;

			case L'\\':
			case L'\"':
			case L'0':
			case L'a':
			case L'b':
			case L'f':
			case L'r':
			case L'n':
			case L't':
			case L'v':
				p++;
				break;

			default:
				lstrcpy(lpError, L"Could not parse string, unrecognized character escape sequence");
				return -(pescape-lpText);
			}
		}
		else
			p++;

		nStringLength++;
	}

	if(*p != L'\"')
	{
		lstrcpy(lpError, L"Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	if(nStringLength == 0)
	{
		lstrcpy(lpError, L"Empty strings are not allowed");
		return -(p-lpText);
	}

	p++;
	p = SkipSpaces(p);

	if(*p != L'\0' && *p != L';')
	{
		lstrcpy(lpError, L"Unexpected input after string definition");
		return -(p-lpText);
	}

	// Check for comment
	if(p[0] == L';' && p[1] != L';')
	{
		lpComment = SkipSpaces(p+1);
		if(*lpComment == L'\0')
			lpComment = NULL;
	}
	else
		lpComment = NULL;

	// Allocate
	cmd_node = (CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(CMD_NODE));
	if(!cmd_node)
	{
		lstrcpy(lpError, L"Allocation failed");
		return 0;
	}

	cmd_node->bCode = (BYTE *)HeapAlloc(GetProcessHeap(), 0, nStringLength*sizeof(WCHAR));
	if(!cmd_node->bCode)
	{
		HeapFree(GetProcessHeap(), 0, cmd_node);

		lstrcpy(lpError, L"Allocation failed");
		return 0;
	}

	// Parse string
	p2 = lpText+2; // skip L"

	dest = (WCHAR *)cmd_node->bCode;

	while(*p2 != L'\"')
	{
		if(*p2 == L'\\')
		{
			p2++;
			switch(*p2)
			{
			case L'x':
				p2++;
				wHexVal = 0;

				while((*p2 >= L'0' && *p2 <= L'9') || (*p2 >= L'A' && *p2 <= L'F') || (*p2 >= L'a' && *p2 <= L'f'))
				{
					wHexVal <<= 4;

					if(*p2 >= L'0' && *p2 <= L'9')
						wHexVal |= *p2-L'0';
					else if(*p2 >= L'A' && *p2 <= L'F')
						wHexVal |= *p2-L'A'+10;
					else if(*p2 >= L'a' && *p2 <= L'f')
						wHexVal |= *p2-L'a'+10;

					p2++;
				}

				*dest = (WCHAR)wHexVal;
				break;

			case L'\\':
			case L'\"':
				*dest = *p2;
				p2++;
				break;

			case L'0':
				*dest = L'\0';
				p2++;
				break;

			case L'a':
				*dest = L'\a';
				p2++;
				break;

			case L'b':
				*dest = L'\b';
				p2++;
				break;

			case L'f':
				*dest = L'\f';
				p2++;
				break;

			case L'r':
				*dest = L'\r';
				p2++;
				break;

			case L'n':
				*dest = L'\n';
				p2++;
				break;

			case L't':
				*dest = L'\t';
				p2++;
				break;

			case L'v':
				*dest = L'\v';
				p2++;
				break;
			}
		}
		else
		{
			*dest = *p2;
			p2++;
		}

		dest++;
	}

#else // if !UNICODE
	CMD_NODE *cmd_node;
	char *p, *p2;
	char *psubstr;
	SIZE_T nStringLength;
	char *lpComment;
	WCHAR *dest;
	SIZE_T nDestLen;
	WORD bHexVal;
	int nBytesWritten;
	int i;

	// Check string, calc size
	p = lpText;

	if(*p != 'L')
	{
		lstrcpy(lpError, "Could not parse string, 'L' expected");
		return -(p-lpText);
	}

	p++;

	if(*p != '\"')
	{
		lstrcpy(lpError, "Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	p++;

	psubstr = p;
	nStringLength = 0;

	while(*p != '\"' && *p != '\0')
	{
		if(*p == '\\')
		{
			if(p - psubstr > 0)
			{
				nStringLength += MultiByteToWideChar(CP_ACP, 0, psubstr, (int)(p - psubstr), NULL, 0);
				psubstr = p;
			}

			p++;
			switch(*p)
			{
			case 'x':
				p++;

				if((*p < '0' || *p > '9') && (*p < 'A' || *p > 'F') && (*p < 'a' || *p > 'f'))
				{
					lstrcpy(lpError, "Could not parse string, hex constants must have at least one hex digit");
					return -(psubstr-lpText);
				}

				while(*p == '0')
					p++;

				for(i=0; (p[i] >= '0' && p[i] <= '9') || (p[i] >= 'A' && p[i] <= 'F') || (p[i] >= 'a' && p[i] <= 'f'); i++)
				{
					if(i >= 4)
					{
						lstrcpy(lpError, "Could not parse string, value is too big for a character");
						return -(psubstr-lpText);
					}
				}

				p += i;
				break;

			case '\\':
			case '\"':
			case '0':
			case 'a':
			case 'b':
			case 'f':
			case 'r':
			case 'n':
			case 't':
			case 'v':
				p++;
				break;

			default:
				lstrcpy(lpError, "Could not parse string, unrecognized character escape sequence");
				return -(psubstr-lpText);
			}

			nStringLength++;

			psubstr = p;
		}
		else
			p++;
	}

	if(p - psubstr > 0)
		nStringLength += MultiByteToWideChar(CP_ACP, 0, psubstr, (int)(p - psubstr), NULL, 0);

	if(*p != '\"')
	{
		lstrcpy(lpError, "Could not parse string, '\"' expected");
		return -(p-lpText);
	}

	if(nStringLength == 0)
	{
		lstrcpy(lpError, "Empty strings are not allowed");
		return -(p-lpText);
	}

	p++;
	p = SkipSpaces(p);

	if(*p != '\0' && *p != ';')
	{
		lstrcpy(lpError, "Unexpected input after string definition");
		return -(p-lpText);
	}

	// Check for comment
	if(p[0] == ';' && p[1] != ';')
	{
		lpComment = SkipSpaces(p+1);
		if(*lpComment == '\0')
			lpComment = NULL;
	}
	else
		lpComment = NULL;

	// Allocate
	cmd_node = (CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(CMD_NODE));
	if(!cmd_node)
	{
		lstrcpy(lpError, "Allocation failed");
		return 0;
	}

	cmd_node->bCode = (BYTE *)HeapAlloc(GetProcessHeap(), 0, nStringLength*sizeof(WCHAR));
	if(!cmd_node->bCode)
	{
		HeapFree(GetProcessHeap(), 0, cmd_node);

		lstrcpy(lpError, "Allocation failed");
		return 0;
	}

	// Parse string
	p2 = lpText+2; // skip L"

	psubstr = p2;
	dest = (WCHAR *)cmd_node->bCode;
	nDestLen = nStringLength;

	while(*p2 != '\"')
	{
		if(*p2 == '\\')
		{
			if(p2 - psubstr > 0)
			{
				nBytesWritten = MultiByteToWideChar(CP_ACP, 0, psubstr, (int)(p2 - psubstr), dest, (int)nDestLen);
				dest += nBytesWritten;
				nDestLen -= nBytesWritten;

				psubstr = p2;
			}

			p2++;
			switch(*p2)
			{
			case 'x':
				p2++;
				bHexVal = 0;

				while((*p2 >= '0' && *p2 <= '9') || (*p2 >= 'A' && *p2 <= 'F') || (*p2 >= 'a' && *p2 <= 'f'))
				{
					bHexVal <<= 4;

					if(*p2 >= '0' && *p2 <= '9')
						bHexVal |= *p2-'0';
					else if(*p2 >= 'A' && *p2 <= 'F')
						bHexVal |= *p2-'A'+10;
					else if(*p2 >= 'a' && *p2 <= 'f')
						bHexVal |= *p2-'a'+10;

					p2++;
				}

				*dest = (WCHAR)bHexVal;
				break;

			case '\\':
			case '\"':
				*dest = (WCHAR)*p2;
				p2++;
				break;

			case '0':
				*dest = L'\0';
				p2++;
				break;

			case 'a':
				*dest = L'\a';
				p2++;
				break;

			case 'b':
				*dest = L'\b';
				p2++;
				break;

			case 'f':
				*dest = L'\f';
				p2++;
				break;

			case L'r':
				*dest = L'\r';
				p2++;
				break;

			case 'n':
				*dest = L'\n';
				p2++;
				break;

			case 't':
				*dest = L'\t';
				p2++;
				break;

			case 'v':
				*dest = L'\v';
				p2++;
				break;
			}

			dest++;

			psubstr = p2;
		}
		else
			p2++;
	}

	if(p2 - psubstr > 0)
		MultiByteToWideChar(CP_ACP, 0, psubstr, (int)(p2 - psubstr), dest, (int)nDestLen);

#endif // UNICODE

	cmd_node->nCodeSize = nStringLength*sizeof(WCHAR);
	cmd_node->lpCommand = lpText;
	cmd_node->lpComment = lpComment;
	cmd_node->lpResolvedCommandWithLabels = NULL;

	cmd_node->next = NULL;

	p_cmd_head->last->next = cmd_node;
	p_cmd_head->last = cmd_node;

	*pnSizeInBytes = nStringLength*sizeof(WCHAR);

	return p-lpText;
}

static LONG_PTR ParseCommand(TCHAR *lpText, DWORD_PTR dwAddress, DWORD_PTR dwBaseAddress, CMD_HEAD *p_cmd_head, SIZE_T *pnSizeInBytes, TCHAR *lpError)
{
	CMD_NODE *cmd_node;
	TCHAR *p;
	TCHAR *lpResolvedCommand;
	TCHAR *lpCommandWithoutLabels;
	BYTE bCode[MAXCMDSIZE];
	SIZE_T nCodeLength;
	UINT nDeltaSize;
	LONG_PTR result;
	TCHAR *lpComment;

	// Resolve RVA addresses
	result = ResolveCommand(lpText, dwBaseAddress, &lpResolvedCommand, &lpComment, lpError);
	if(result <= 0)
		return result;

	p = lpText + result;

	if(!lpResolvedCommand)
		lpResolvedCommand = lpText;

	// Assemble command (with a foo address instead of labels)
#ifdef _WIN64
	nDeltaSize = 64;
#else // _WIN64
	nDeltaSize = 32;
#endif // _WIN64
	result = ReplaceLabelsWithFooAddress(lpResolvedCommand, dwAddress, nDeltaSize, &lpCommandWithoutLabels, lpError);
	if(result > 0)
	{
		if(lpCommandWithoutLabels)
		{
			result = AssembleShortest(lpCommandWithoutLabels, dwAddress, bCode, lpError);
			result = ReplacedTextCorrectErrorSpot(lpText, lpCommandWithoutLabels, result);
			HeapFree(GetProcessHeap(), 0, lpCommandWithoutLabels);

#ifdef _WIN64
			if(result <= 0)
			{
				nDeltaSize = 32;
				result = ReplaceLabelsWithFooAddress(lpResolvedCommand, dwAddress, nDeltaSize, &lpCommandWithoutLabels, lpError);
				if(result > 0 && lpCommandWithoutLabels)
				{
					result = AssembleShortest(lpCommandWithoutLabels, dwAddress, bCode, lpError);
					result = ReplacedTextCorrectErrorSpot(lpText, lpCommandWithoutLabels, result);
					HeapFree(GetProcessHeap(), 0, lpCommandWithoutLabels);
				}
			}
#endif // _WIN64

			if(result <= 0)
			{
				nDeltaSize = 0;
				result = ReplaceLabelsWithFooAddress(lpResolvedCommand, dwAddress, nDeltaSize, &lpCommandWithoutLabels, lpError);
				if(result > 0 && lpCommandWithoutLabels)
				{
					result = AssembleShortest(lpCommandWithoutLabels, dwAddress, bCode, lpError);
					result = ReplacedTextCorrectErrorSpot(lpText, lpCommandWithoutLabels, result);
					HeapFree(GetProcessHeap(), 0, lpCommandWithoutLabels);
				}
			}
		}
		else
		{
			result = AssembleShortest(lpResolvedCommand, dwAddress, bCode, lpError);
			result = ReplacedTextCorrectErrorSpot(lpText, lpResolvedCommand, result);
		}
	}

	if(result <= 0)
	{
		if(lpResolvedCommand != lpText)
			HeapFree(GetProcessHeap(), 0, lpResolvedCommand);

		return result;
	}

	nCodeLength = result;

	// Allocate and fill data
	cmd_node = (CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(CMD_NODE));
	if(!cmd_node)
	{
		if(lpResolvedCommand != lpText)
			HeapFree(GetProcessHeap(), 0, lpResolvedCommand);

		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	cmd_node->bCode = (BYTE *)HeapAlloc(GetProcessHeap(), 0, nCodeLength);
	if(!cmd_node->bCode)
	{
		if(lpResolvedCommand != lpText)
			HeapFree(GetProcessHeap(), 0, lpResolvedCommand);

		HeapFree(GetProcessHeap(), 0, cmd_node);

		lstrcpy(lpError, _T("Allocation failed"));
		return 0;
	}

	CopyMemory(cmd_node->bCode, bCode, nCodeLength);
	cmd_node->nCodeSize = nCodeLength;
	cmd_node->lpCommand = lpText;
	cmd_node->lpComment = lpComment;

	if(lpCommandWithoutLabels)
		cmd_node->lpResolvedCommandWithLabels = lpResolvedCommand;
	else
		cmd_node->lpResolvedCommandWithLabels = NULL;

	cmd_node->next = NULL;

	p_cmd_head->last->next = cmd_node;
	p_cmd_head->last = cmd_node;

	*pnSizeInBytes = nCodeLength;

	return p-lpText;
}

static LONG_PTR ResolveCommand(TCHAR *lpCommand, DWORD_PTR dwBaseAddress, TCHAR **ppNewCommand, TCHAR **ppComment, TCHAR *lpError)
{
	TCHAR *p;
	SIZE_T text_start[4];
	SIZE_T text_end[4];
	DWORD_PTR dwAddress[4];
	int address_count;
	TCHAR *lpComment;
	LONG_PTR result;

	// Find and parse addresses
	p = lpCommand;
	address_count = 0;

	while(*p != _T('\0') && *p != _T(';'))
	{
		if(*p == _T('$'))
		{
			if(address_count == 4)
			{
				lstrcpy(lpError, _T("No more than 4 RVA addresses allowed for one command"));
				return -(p-lpCommand);
			}

			text_start[address_count] = p-lpCommand;

			result = ParseRVAAddress(p, &dwAddress[address_count], dwBaseAddress, NULL, lpError);
			if(result <= 0)
				return -(p-lpCommand)+result;

			p += result;
			text_end[address_count] = p-lpCommand;

			address_count++;
		}
		else
			p++;
	}

	lpComment = NULL;

	if(*p == _T(';'))
	{
		*p = _T('\0');

		if(p[1] != _T(';'))
		{
			lpComment = SkipSpaces(p+1);
			if(*lpComment == _T('\0'))
				lpComment = NULL;
		}
	}

	*ppComment = lpComment;

	if(address_count > 0)
	{
		// Replace
		if(!ReplaceTextsWithAddresses(lpCommand, ppNewCommand, address_count, text_start, text_end, dwAddress, lpError))
			return 0;
	}
	else
		*ppNewCommand = NULL;

	return p-lpCommand;
}

static LONG_PTR ReplaceLabelsWithFooAddress(TCHAR *lpCommand, DWORD_PTR dwCommandAddress, UINT nDeltaSize, TCHAR **ppNewCommand, TCHAR *lpError)
{
	TCHAR *p;
	DWORD_PTR dwReplaceAddress;
	LONG_PTR text_start[4];
	LONG_PTR text_end[4];
	DWORD_PTR dwAddress[4];
	int label_count;

	// Find labels
	p = lpCommand;
	label_count = 0;

	dwReplaceAddress = dwCommandAddress;

	while(*p != _T('\0') && *p != _T(';'))
	{
		if(*p == _T('@'))
		{
			if(label_count == 4)
			{
				lstrcpy(lpError, _T("No more than 4 labels allowed for one command"));
				return -(p-lpCommand);
			}

			text_start[label_count] = p-lpCommand;
			p++;

			while(
				(*p >= _T('0') && *p <= _T('9')) || 
				(*p >= _T('A') && *p <= _T('Z')) || 
				(*p >= _T('a') && *p <= _T('z')) || 
				*p == _T('_')
			)
				p++;

			text_end[label_count] = p-lpCommand;

			if(text_end[label_count]-text_start[label_count] == 1)
			{
				lstrcpy(lpError, _T("Could not parse label"));
				return -text_start[label_count];
			}

			switch(nDeltaSize)
			{
			case 64:
				dwReplaceAddress += (DWORD_PTR)0x1111111111111111;

				if((dwReplaceAddress & 0xFFFFFFFF00000000) == 0x0000000000000000 ||
					(dwReplaceAddress & 0xFFFFFFFF00000000) == 0xFFFFFFFF00000000)
				{
					dwReplaceAddress += (DWORD_PTR)0x1111111111111111;
				}
				break;

			case 32:
				dwReplaceAddress += 0x11111111;

				if((dwReplaceAddress & 0xFFFF0000) == 0x00000000 ||
					(dwReplaceAddress & 0xFFFF0000) == 0xFFFF0000)
				{
					dwReplaceAddress += 0x11111111;
				}
				break;

			case 0:
				break;

			default:
				lstrcpy(lpError, _T("Internal disassembler error"));
				return -text_start[label_count];
			}

			dwAddress[label_count] = dwReplaceAddress;

			label_count++;
		}
		else
			p++;
	}

	if(label_count == 0)
	{
		*ppNewCommand = NULL;
		return 1;
	}

	// Replace
	if(!ReplaceTextsWithAddresses(lpCommand, ppNewCommand, label_count, text_start, text_end, dwAddress, lpError))
		return 0;

	return 1;
}

static LONG_PTR ParseSpecialCommand(TCHAR *lpText, UINT *pnSpecialCmd, TCHAR *lpError)
{
	TCHAR *p;
	TCHAR *pCommandStart;
	UINT nSpecialCmd;

	p = lpText;

	if(*p != _T('!'))
	{
		lstrcpy(lpError, _T("Could not parse special command, '!' expected"));
		return -(p-lpText);
	}

	p++;
	pCommandStart = p;

	if(memcmp(p, _T("align"), (sizeof("align")-1)*sizeof(TCHAR)) == 0)
	{
		p += sizeof("align")-1;
		nSpecialCmd = SPECIAL_CMD_ALIGN;
	}
	else if(memcmp(p, _T("pad"), (sizeof("pad") - 1)*sizeof(TCHAR)) == 0)
	{
		p += sizeof("pad") - 1;
		nSpecialCmd = SPECIAL_CMD_PAD;
	}
	else
	{
		lstrcpy(lpError, _T("Unknown special command"));
		return -(pCommandStart-lpText);
	}
	
	if(
		*p != _T(' ') && 
		*p != _T('\t') && 
		*p != _T(';') && 
		*p != _T('\0')
	)
	{
		lstrcpy(lpError, _T("Unknown special command"));
		return -(pCommandStart-lpText);
	}

	*pnSpecialCmd = nSpecialCmd;

	return p-lpText;
}

static LONG_PTR ParseAlignSpecialCommand(TCHAR *lpText, LONG_PTR nArgsOffset, DWORD_PTR dwAddress, DWORD_PTR *pdwPaddingSize, TCHAR *lpError)
{
	TCHAR *p;
	TCHAR *pAfterWhiteSpace;
	DWORD_PTR dwAlignValue;
	DWORD_PTR dwPaddingSize;
	LONG_PTR result;

	p = lpText + nArgsOffset;

	pAfterWhiteSpace = SkipSpaces(p);
	if(pAfterWhiteSpace == p)
	{
		lstrcpy(lpError, _T("Could not parse command, whitespace expected"));
		return -(p-lpText);
	}

	p = pAfterWhiteSpace;

	result = ParseDWORDPtr(p, &dwAlignValue, lpError);
	if(result <= 0)
		return -(p-lpText)+result;

	if(!GetAlignPaddingSize(dwAddress, dwAlignValue, &dwPaddingSize, lpError))
		return -(p-lpText);

	p += result;
	p = SkipSpaces(p);

	if(*p != '\0' && *p != ';')
	{
		lstrcpy(lpError, _T("Unexpected input after end of command"));
		return -(p-lpText);
	}

	*pdwPaddingSize = dwPaddingSize;

	return p-lpText;
}

static LONG_PTR ParsePadSpecialCommand(TCHAR *lpText, LONG_PTR nArgsOffset, BYTE *pbPaddingByteValue, TCHAR *lpError)
{
	TCHAR *p;
	TCHAR *pAfterWhiteSpace;
	DWORD_PTR dwPaddingByteValue;
	LONG_PTR result;

	p = lpText + nArgsOffset;

	pAfterWhiteSpace = SkipSpaces(p);
	if(pAfterWhiteSpace == p)
	{
		lstrcpy(lpError, _T("Could not parse command, whitespace expected"));
		return -(p-lpText);
	}

	p = pAfterWhiteSpace;
	
	result = ParseDWORDPtr(p, &dwPaddingByteValue, lpError);
	if(result <= 0)
		return -(p-lpText)+result;

	if(dwPaddingByteValue > 0xFF)
	{
		lstrcpy(lpError, _T("Out of range error, byte value expected"));
		return -(p-lpText);
	}

	p += result;
	p = SkipSpaces(p);

	if(*p != '\0' && *p != ';')
	{
		lstrcpy(lpError, _T("Unexpected input after end of command"));
		return -(p-lpText);
	}

	*pbPaddingByteValue = (BYTE)dwPaddingByteValue;
	
	return p-lpText;
}

static BOOL GetAlignPaddingSize(DWORD_PTR dwAddress, DWORD_PTR dwAlignValue, DWORD_PTR *pdwPaddingSize, TCHAR *lpError)
{
	DWORD_PTR dwAlignedAddress;
	DWORD_PTR dwPaddingSize;

	if(dwAlignValue <= 1)
	{
		lstrcpy(lpError, _T("The align value must be greater than 1"));
		return FALSE;
	}

	if(!IsDWORDPtrPowerOfTwo(dwAlignValue))
	{
		lstrcpy(lpError, _T("The align value must be a power of 2"));
		return FALSE;
	}

	dwAlignedAddress = (dwAddress + (dwAlignValue - 1)) & ~(dwAlignValue - 1);
	dwPaddingSize = dwAlignedAddress - dwAddress;

	*pdwPaddingSize = dwPaddingSize;

	return TRUE;
}

static BOOL InsertBytes(TCHAR *lpText, SIZE_T nBytesCount, BYTE bByteValue, CMD_HEAD *p_cmd_head, TCHAR *lpError)
{
	CMD_NODE *cmd_node;

	// Allocate
	cmd_node = (CMD_NODE *)HeapAlloc(GetProcessHeap(), 0, sizeof(CMD_NODE));
	if(!cmd_node)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return FALSE;
	}

	cmd_node->bCode = (BYTE *)HeapAlloc(GetProcessHeap(), 0, nBytesCount);
	if(!cmd_node->bCode)
	{
		HeapFree(GetProcessHeap(), 0, cmd_node);

		lstrcpy(lpError, _T("Allocation failed"));
		return FALSE;
	}

	memset(cmd_node->bCode, bByteValue, nBytesCount);

	cmd_node->nCodeSize = nBytesCount;
	cmd_node->lpCommand = lpText;
	cmd_node->lpComment = NULL;
	cmd_node->lpResolvedCommandWithLabels = NULL;

	cmd_node->next = NULL;

	p_cmd_head->last->next = cmd_node;
	p_cmd_head->last = cmd_node;

	return TRUE;
}

static LONG_PTR ParseRVAAddress(TCHAR *lpText, DWORD_PTR *pdwAddress, DWORD_PTR dwParentBaseAddress, DWORD_PTR *pdwBaseAddress, TCHAR *lpError)
{
	TCHAR *p;
	TCHAR *pModuleName, *pModuleNameEnd;
	PLUGIN_MODULE module;
	DWORD_PTR dwBaseAddress;
	DWORD_PTR dwAddress;
	DWORD_PTR dwCPUBaseAddr;
	LONG_PTR result;
	TCHAR c;

	p = lpText;

	if(*p != _T('$'))
	{
		lstrcpy(lpError, _T("Could not parse RVA address, '$' expected"));
		return -(p-lpText);
	}

	p++;

	if(*p == _T('$'))
	{
		if(!dwParentBaseAddress)
		{
			lstrcpy(lpError, _T("Could not parse RVA address, there is no parent base address"));
			return 0;
		}

		dwBaseAddress = dwParentBaseAddress;
		pModuleName = NULL;

		p++;
	}
	else if(*p == _T('"'))
	{
		p++;
		pModuleName = p;

		while(*p != _T('"'))
		{
			if(*p == _T('\0'))
			{
				lstrcpy(lpError, _T("Could not parse RVA address, '\"' expected"));
				return -(p-lpText);
			}

			p++;
		}

		pModuleNameEnd = p;
		p++;

		if(*p != _T('.'))
		{
			lstrcpy(lpError, _T("Could not parse RVA address, '.' expected"));
			return -(p-lpText);
		}

		p++;
	}
	else
	{
		pModuleName = p;

		if(*p == _T('('))
		{
			result = ParseDWORDPtr(&p[1], &dwBaseAddress, lpError);
			if(result > 0 && p[1+result] == _T(')') && p[1+result+1] == _T('.'))
			{
				pModuleName = NULL;
				p += 1+result+1+1;
			}
		}

		if(pModuleName)
		{
			while(*p != _T('.'))
			{
				if(*p == _T(' ') || *p == _T('\t') || *p == _T('"') || *p == _T(';') || *p == _T('\0'))
				{
					lstrcpy(lpError, _T("Could not parse RVA address, '.' expected"));
					return -(p-lpText);
				}

				p++;
			}

			pModuleNameEnd = p;
			p++;
		}
	}

	if(pModuleName)
	{
		if(pModuleNameEnd != pModuleName)
		{
			c = *pModuleNameEnd;
			*pModuleNameEnd = _T('\0');

			module = FindModuleByName(pModuleName);
			if(!module)
			{
				wsprintf(lpError, _T("There is no module \"%s\""), pModuleName);
				*pModuleNameEnd = c;
				return -(pModuleName-lpText);
			}

			*pModuleNameEnd = c;
		}
		else
		{
			dwCPUBaseAddr = GetCpuBaseAddr();
			if(dwCPUBaseAddr)
				module = FindModuleByAddr(dwCPUBaseAddr);
			else
				module = NULL;

			if(!module)
			{
				wsprintf(lpError, _T("Can't identify the module currently loaded in the CPU disassembler"));
				return -(pModuleName-lpText);
			}
		}

		dwBaseAddress = GetModuleBase(module);
	}
	else
		module = NULL;

	result = ParseDWORDPtr(p, &dwAddress, lpError);
	if(result <= 0)
		return -(p-lpText)+result;

	if(module && dwAddress > GetModuleSize(module) - 1)
	{
		lstrcpy(lpError, _T("The RVA address exceeds the module size"));
		return -(p-lpText);
	}

	p += result;

	if(pdwBaseAddress)
		*pdwBaseAddress = dwBaseAddress;

	*pdwAddress = dwBaseAddress + dwAddress;

	return p-lpText;
}

static LONG_PTR ParseDWORDPtr(TCHAR *lpText, DWORD_PTR *pdw, TCHAR *lpError)
{
	TCHAR *p;
	DWORD_PTR dw;
	BOOL bZeroX;

	p = lpText;

	if(*p == _T('0') && (p[1] == _T('x') || p[1] == _T('X')))
	{
		bZeroX = TRUE;
		p += 2;
	}
	else
		bZeroX = FALSE;

	if((*p < _T('0') || *p > _T('9')) && (*p < _T('A') || *p > _T('F')) && (*p < _T('a') || *p > _T('f')))
	{
		lstrcpy(lpError, _T("Could not parse constant"));
		return -(p-lpText);
	}

	dw = 0;

	while((dw >> (sizeof(DWORD_PTR) * 8 - 4)) == 0)
	{
		dw <<= 4;

		if(*p >= _T('0') && *p <= _T('9'))
			dw |= *p - _T('0');
		else if(*p >= _T('A') && *p <= _T('F'))
			dw |= *p - _T('A') + 10;
		else if(*p >= _T('a') && *p <= _T('f'))
			dw |= *p - _T('a') + 10;
		else
		{
			dw >>= 4;
			break;
		}

		p++;
	}

	if((*p >= _T('0') && *p <= _T('9')) || (*p >= _T('A') && *p <= _T('F')) || (*p >= _T('a') && *p <= _T('f')))
	{
		lstrcpy(lpError, _T("Could not parse constant"));
		return -(p-lpText);
	}

	if(*p == _T('h') || *p == _T('H'))
	{
		if(bZeroX)
		{
			lstrcpy(lpError, _T("Please don't mix 0xXXXX and XXXXh forms"));
			return -(p-lpText);
		}

		p++;
	}

	*pdw = dw;

	return p-lpText;
}

static TCHAR *ReplaceLabelsInCommands(LABEL_HEAD *p_label_head, CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError)
{
	CMD_BLOCK_NODE *cmd_block_node;
	CMD_NODE *cmd_node;
	ANON_LABEL_NODE *anon_label_node;
	DWORD_PTR dwAddress;
	DWORD_PTR dwPrevAnonAddr, dwNextAnonAddr;
	TCHAR *lpCommandWithoutLabels;
	BYTE bCode[MAXCMDSIZE];
	LONG_PTR result;

	for(cmd_block_node = p_cmd_block_head->next; cmd_block_node != NULL; cmd_block_node = cmd_block_node->next)
	{
		dwAddress = cmd_block_node->dwAddress;

		anon_label_node = cmd_block_node->anon_label_head.next;
		dwPrevAnonAddr = 0;
		if(anon_label_node != NULL)
			dwNextAnonAddr = anon_label_node->dwAddress;
		else
			dwNextAnonAddr = 0;

		for(cmd_node = cmd_block_node->cmd_head.next; cmd_node != NULL; cmd_node = cmd_node->next)
		{
			while(dwNextAnonAddr && dwNextAnonAddr <= dwAddress)
			{
				dwPrevAnonAddr = dwNextAnonAddr;
				if(anon_label_node != NULL)
				{
					dwNextAnonAddr = anon_label_node->dwAddress;
					anon_label_node = anon_label_node->next;
				}
				else
					dwNextAnonAddr = 0;
			}

			if(cmd_node->lpResolvedCommandWithLabels)
			{
				result = ReplaceLabelsFromList(cmd_node->lpResolvedCommandWithLabels, dwPrevAnonAddr, dwNextAnonAddr, 
					p_label_head, &lpCommandWithoutLabels, lpError);

				if(cmd_node->lpResolvedCommandWithLabels != cmd_node->lpCommand)
					HeapFree(GetProcessHeap(), 0, cmd_node->lpResolvedCommandWithLabels);
				cmd_node->lpResolvedCommandWithLabels = NULL;

				if(result <= 0)
					return cmd_node->lpCommand+(-result);

				if(!lpCommandWithoutLabels)
				{
					lstrcpy(lpError, _T("Where are the labels?"));
					return cmd_node->lpCommand;
				}

				result = AssembleWithGivenSize(lpCommandWithoutLabels, dwAddress, (int)cmd_node->nCodeSize, bCode, lpError);
				result = ReplacedTextCorrectErrorSpot(cmd_node->lpCommand, lpCommandWithoutLabels, result);
				HeapFree(GetProcessHeap(), 0, lpCommandWithoutLabels);

				if(result <= 0)
					return cmd_node->lpCommand+(-result);

				CopyMemory(cmd_node->bCode, bCode, result);
			}

			dwAddress += cmd_node->nCodeSize;
		}
	}

	return NULL;
}

static LONG_PTR ReplaceLabelsFromList(TCHAR *lpCommand, DWORD_PTR dwPrevAnonAddr, DWORD_PTR dwNextAnonAddr,
	LABEL_HEAD *p_label_head, TCHAR **ppNewCommand, TCHAR *lpError)
{
	LABEL_NODE *label_node;
	TCHAR *p;
	LONG_PTR text_start[4];
	LONG_PTR text_end[4];
	DWORD_PTR dwAddress[4];
	int label_count;
	TCHAR temp_char;
	int i;

	// Find labels
	p = lpCommand;
	label_count = 0;

	while(*p != _T('\0') && *p != _T(';'))
	{
		if(*p == _T('@'))
		{
			if(label_count == 4)
			{
				lstrcpy(lpError, _T("No more than 4 labels allowed for one command"));
				return -(p-lpCommand);
			}

			text_start[label_count] = p-lpCommand;
			p++;

			while(
				(*p >= _T('0') && *p <= _T('9')) || 
				(*p >= _T('A') && *p <= _T('Z')) || 
				(*p >= _T('a') && *p <= _T('z')) || 
				*p == _T('_')
			)
				p++;

			text_end[label_count] = p-lpCommand;

			if(text_end[label_count]-text_start[label_count] == 1)
			{
				lstrcpy(lpError, _T("Could not parse label"));
				return -text_start[label_count];
			}

			label_count++;
		}
		else
			p++;
	}

	if(label_count == 0)
	{
		*ppNewCommand = NULL;
		return 1;
	}

	// Find these labels in our list
	for(i=0; i<label_count; i++)
	{
		p = lpCommand+text_start[i]+1;

		if(text_end[i]-(text_start[i]+1) == 1)
		{
			temp_char = *p;
			if(temp_char >= _T('A') && temp_char <= _T('Z'))
				temp_char += -_T('A')+_T('a');

			if(temp_char == _T('b') || temp_char == _T('r'))
				dwAddress[i] = dwPrevAnonAddr;
			else if(temp_char == _T('f'))
				dwAddress[i] = dwNextAnonAddr;
			else
				temp_char = _T('\0');

			if(temp_char != _T('\0'))
			{
				if(!dwAddress[i])
				{
					lstrcpy(lpError, _T("The anonymous label was not defined"));
					return -text_start[i];
				}

				continue;
			}
		}

		temp_char = lpCommand[text_end[i]];
		lpCommand[text_end[i]] = _T('\0');

		for(label_node = p_label_head->next; label_node != NULL; label_node = label_node->next)
			if(lstrcmp(p, label_node->lpLabel) == 0)
				break;

		lpCommand[text_end[i]] = temp_char;

		if(label_node == NULL)
		{
			lstrcpy(lpError, _T("The label was not defined"));
			return -text_start[i];
		}

		dwAddress[i] = label_node->dwAddress;
	}

	// Replace
	if(!ReplaceTextsWithAddresses(lpCommand, ppNewCommand, label_count, text_start, text_end, dwAddress, lpError))
		return 0;

	return 1;
}

static TCHAR *PatchCommands(CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError)
{
	CMD_BLOCK_NODE *cmd_block_node;
	CMD_NODE *cmd_node;
	BYTE *bBuffer;
	PLUGIN_MEMORY memory;
	DWORD_PTR dwMemoryBase;
	SIZE_T nMemorySize;
	SIZE_T nWritten;

	for(cmd_block_node = p_cmd_block_head->next; cmd_block_node != NULL; cmd_block_node = cmd_block_node->next)
	{
		if(cmd_block_node->nSize > 0)
		{
			memory = FindMemory(cmd_block_node->dwAddress);
			if(!memory)
			{
				wsprintf(lpError, _T("Failed to find memory block for address 0x" HEXPTR_PADDED), cmd_block_node->dwAddress);
				return cmd_block_node->cmd_head.next->lpCommand;
			}

			dwMemoryBase = GetMemoryBase(memory);
			nMemorySize = GetMemorySize(memory);

			if(cmd_block_node->dwAddress + cmd_block_node->nSize > dwMemoryBase + nMemorySize)
			{
				wsprintf(lpError, _T("End of code block exceeds end of memory block (%Iu extra bytes)"), 
					(cmd_block_node->dwAddress + cmd_block_node->nSize) - (dwMemoryBase + nMemorySize));
				return cmd_block_node->cmd_head.next->lpCommand;
			}

			bBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, cmd_block_node->nSize);
			if(!bBuffer)
			{
				lstrcpy(lpError, _T("Allocation failed"));
				return cmd_block_node->cmd_head.next->lpCommand;
			}

			nWritten = 0;

			for(cmd_node = cmd_block_node->cmd_head.next; cmd_node != NULL; cmd_node = cmd_node->next)
			{
				CopyMemory(bBuffer+nWritten, cmd_node->bCode, cmd_node->nCodeSize);
				nWritten += cmd_node->nCodeSize;
			}

			EnsureMemoryBackup(memory);

			if(!SimpleWriteMemory(bBuffer, cmd_block_node->dwAddress, cmd_block_node->nSize))
			{
				HeapFree(GetProcessHeap(), 0, bBuffer);
				wsprintf(lpError, _T("Failed to write memory on address 0x" HEXPTR_PADDED), cmd_block_node->dwAddress);
				return cmd_block_node->cmd_head.next->lpCommand;
			}

			HeapFree(GetProcessHeap(), 0, bBuffer);
		}
	}

	return NULL;
}

static TCHAR *SetComments(CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError)
{
	CMD_BLOCK_NODE *cmd_block_node;
	CMD_NODE *cmd_node;
	DWORD_PTR dwAddress;

	for(cmd_block_node = p_cmd_block_head->next; cmd_block_node != NULL; cmd_block_node = cmd_block_node->next)
	{
		if(cmd_block_node->nSize > 0)
		{
			dwAddress = cmd_block_node->dwAddress;
			DeleteRangeComments(dwAddress, dwAddress+cmd_block_node->nSize);

			for(cmd_node = cmd_block_node->cmd_head.next; cmd_node != NULL; cmd_node = cmd_node->next)
			{
				if(cmd_node->lpComment)
				{
					if(lstrlen(cmd_node->lpComment) > COMMENT_MAX_LEN - 1)
						lstrcpy(&cmd_node->lpComment[COMMENT_MAX_LEN - 1 - 3], _T("..."));

					if(!QuickInsertComment(dwAddress, cmd_node->lpComment))
					{
						MergeQuickData();
						wsprintf(lpError, _T("Failed to set comment on address 0x" HEXPTR_PADDED), dwAddress);
						return cmd_node->lpComment;
					}
				}

				dwAddress += cmd_node->nCodeSize;
			}
		}
	}

	MergeQuickData();
	return NULL;
}

static TCHAR *SetLabels(LABEL_HEAD *p_label_head, CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError)
{
	LABEL_NODE *label_node;
	CMD_BLOCK_NODE *cmd_block_node;
	TCHAR *lpLabel;
	UINT nLabelLen;
	UINT i;

	for(cmd_block_node = p_cmd_block_head->next; cmd_block_node != NULL; cmd_block_node = cmd_block_node->next)
		if(cmd_block_node->nSize > 0)
			DeleteRangeLabels(cmd_block_node->dwAddress, cmd_block_node->dwAddress+cmd_block_node->nSize);

	for(label_node = p_label_head->next; label_node != NULL; label_node = label_node->next)
	{
		lpLabel = label_node->lpLabel;
		nLabelLen = lstrlen(lpLabel);

		if(nLabelLen > LABEL_MAX_LEN - 1)
		{
			lstrcpy(&lpLabel[LABEL_MAX_LEN - 1 - 3], _T("..."));
		}
		else if(lpLabel[0] == _T('L'))
		{
			if(nLabelLen == 9 || (nLabelLen > 10 && lpLabel[1] == _T('_') && lpLabel[nLabelLen-8-1] == _T('_')))
			{
				for(i=nLabelLen-8; i<nLabelLen; i++)
				{
					if(lpLabel[i] < _T('0') || lpLabel[i] > _T('9'))
						break;
				}
			}
			else if(nLabelLen == 2+sizeof(DWORD_PTR)*2 && lpLabel[1] == _T('_'))
			{
				for(i=nLabelLen-sizeof(DWORD_PTR)*2; i<nLabelLen; i++)
				{
					if((lpLabel[i] < _T('0') || lpLabel[i] > _T('9')) && 
						(lpLabel[i] < _T('A') || lpLabel[i] > _T('F')))
						break;
				}
			}
			else
				i = 0;

			if(i == nLabelLen)
				continue;
		}

		if(!QuickInsertLabel(label_node->dwAddress, lpLabel))
		{
			MergeQuickData();
			wsprintf(lpError, _T("Failed to set label on address 0x" HEXPTR_PADDED), label_node->dwAddress);
			return lpLabel-1;
		}
	}

	MergeQuickData();
	return NULL;
}

static BOOL ReplaceTextsWithAddresses(TCHAR *lpCommand, TCHAR **ppNewCommand, 
	int text_count, LONG_PTR text_start[4], LONG_PTR text_end[4], DWORD_PTR dwAddress[4], TCHAR *lpError)
{
	int address_len[4];
	TCHAR szAddressText[4][2 + sizeof(DWORD_PTR) * 2 + 1];
	LONG_PTR new_command_len;
	TCHAR *lpNewCommand;
	TCHAR *dest, *src;
	int i;

	new_command_len = lstrlen(lpCommand);

	for(i=0; i<text_count; i++)
	{
		address_len[i] = wsprintf(szAddressText[i], _T("0x%IX"), dwAddress[i]);
		new_command_len += address_len[i]-(text_end[i]-text_start[i]);
	}

	lpNewCommand = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (new_command_len+1)*sizeof(TCHAR));
	if(!lpNewCommand)
	{
		lstrcpy(lpError, _T("Allocation failed"));
		return FALSE;
	}

	// Replace
	dest = lpNewCommand;
	src = lpCommand;

	CopyMemory(dest, src, text_start[0]*sizeof(TCHAR));
	CopyMemory(dest+text_start[0], szAddressText[0], address_len[0]*sizeof(TCHAR));
	dest += text_start[0]+address_len[0];
	src += text_end[0];

	for(i=1; i<text_count; i++)
	{
		CopyMemory(dest, src, (text_start[i]-text_end[i-1])*sizeof(TCHAR));
		CopyMemory(dest+text_start[i]-text_end[i-1], szAddressText[i], address_len[i]*sizeof(TCHAR));
		dest += text_start[i]-text_end[i-1]+address_len[i];
		src += text_end[i]-text_end[i-1];
	}

	lstrcpy(dest, src);

	*ppNewCommand = lpNewCommand;
	return TRUE;
}

static LONG_PTR ReplacedTextCorrectErrorSpot(TCHAR *lpCommand, TCHAR *lpReplacedCommand, LONG_PTR result)
{
	TCHAR *ptxt, *paddr;
	TCHAR *pTextStart, *pAddressStart;

	if(result > 0 || lpCommand == lpReplacedCommand)
		return result;

	ptxt = lpCommand;
	paddr = lpReplacedCommand;

	while(*ptxt != _T('\0') && *ptxt != _T(';'))
	{
		if(*ptxt == _T('@'))
		{
			pTextStart = ptxt;
			ptxt = SkipLabel(ptxt);
		}
		else if(*ptxt == _T('$'))
		{
			pTextStart = ptxt;
			ptxt = SkipRVAAddress(ptxt);
		}
		else
		{
			ptxt++;
			paddr++;

			continue;
		}

		pAddressStart = paddr;

		while((*paddr >= _T('0') && *paddr <= _T('9')) || (*paddr >= _T('A') && *paddr <= _T('F')))
			paddr++;

		if(-result < pTextStart-lpCommand)
			return result;

		if(-result < pTextStart-lpCommand+(paddr-pAddressStart))
			return -(pTextStart-lpCommand);

		result += paddr-pAddressStart;
		result -= ptxt-pTextStart;
	}

	return result;
}

static TCHAR *NullTerminateLine(TCHAR *p)
{
	while(*p != _T('\0'))
	{
		if(*p == _T('\n'))
		{
			*p = _T('\0');
			p++;

			return p;
		}
		else if(*p == _T('\r'))
		{
			*p = _T('\0');
			p++;

			if(*p == _T('\n'))
				p++;

			return p;
		}

		p++;
	}

	return NULL;
}

static TCHAR *SkipSpaces(TCHAR *p)
{
	while(*p == _T(' ') || *p == _T('\t'))
		p++;

	return p;
}

static TCHAR *SkipDWORD(TCHAR *p)
{
	BOOL bZeroX;

	if(*p == _T('0') && (p[1] == _T('x') || p[1] == _T('X')))
	{
		bZeroX = TRUE;
		p += 2;
	}
	else
		bZeroX = FALSE;

	while((*p >= _T('0') && *p <= _T('9')) || (*p >= _T('A') && *p <= _T('F')) || (*p >= _T('a') && *p <= _T('f')))
		p++;

	if(!bZeroX && (*p == _T('h') || *p == _T('H')))
		p++;

	return p;
}

static TCHAR *SkipLabel(TCHAR *p)
{
	if(*p == _T('@'))
	{
		p++;

		while(
			(*p >= _T('0') && *p <= _T('9')) || 
			(*p >= _T('A') && *p <= _T('Z')) || 
			(*p >= _T('a') && *p <= _T('z')) || 
			*p == _T('_')
		)
			p++;
	}

	return p;
}

static TCHAR *SkipRVAAddress(TCHAR *p)
{
	if(*p == _T('$'))
	{
		p++;

		switch(*p)
		{
		case _T('$'):
			p++;
			break;

		case _T('"'):
			p++;

			while(*p != _T('"'))
				p++;

			p++;
			break;

		default:
			while(*p != _T('.'))
				p++;

			p++;
			break;
		}

		p = SkipDWORD(p);
	}

	return p;
}

static BOOL IsDWORDPtrPowerOfTwo(DWORD_PTR dw)
{
	return (dw != 0) && ((dw & (dw - 1)) == 0);
}

static void FreeLabelList(LABEL_HEAD *p_label_head)
{
	LABEL_NODE *label_node, *next;

	for(label_node = p_label_head->next; label_node != NULL; label_node = next)
	{
		next = label_node->next;
		HeapFree(GetProcessHeap(), 0, label_node);
	}

	p_label_head->next = NULL;
	p_label_head->last = (LABEL_NODE *)p_label_head;
}

static void FreeCmdBlockList(CMD_BLOCK_HEAD *p_cmd_block_head)
{
	CMD_BLOCK_NODE *cmd_block_node, *next;

	for(cmd_block_node = p_cmd_block_head->next; cmd_block_node != NULL; cmd_block_node = next)
	{
		next = cmd_block_node->next;

		FreeCmdList(&cmd_block_node->cmd_head);
		FreeAnonLabelList(&cmd_block_node->anon_label_head);

		HeapFree(GetProcessHeap(), 0, cmd_block_node);
	}

	p_cmd_block_head->next = NULL;
	p_cmd_block_head->last = (CMD_BLOCK_NODE *)p_cmd_block_head;
}

static void FreeCmdList(CMD_HEAD *p_cmd_head)
{
	CMD_NODE *cmd_node, *next;

	for(cmd_node = p_cmd_head->next; cmd_node != NULL; cmd_node = next)
	{
		next = cmd_node->next;

		HeapFree(GetProcessHeap(), 0, cmd_node->bCode);
		if(cmd_node->lpResolvedCommandWithLabels && cmd_node->lpResolvedCommandWithLabels != cmd_node->lpCommand)
			HeapFree(GetProcessHeap(), 0, cmd_node->lpResolvedCommandWithLabels);

		HeapFree(GetProcessHeap(), 0, cmd_node);
	}

	p_cmd_head->next = NULL;
	p_cmd_head->last = (CMD_NODE *)p_cmd_head;
}

static void FreeAnonLabelList(ANON_LABEL_HEAD *p_anon_label_head)
{
	ANON_LABEL_NODE *anon_label_node, *next;

	for(anon_label_node = p_anon_label_head->next; anon_label_node != NULL; anon_label_node = next)
	{
		next = anon_label_node->next;
		HeapFree(GetProcessHeap(), 0, anon_label_node);
	}

	p_anon_label_head->next = NULL;
	p_anon_label_head->last = (ANON_LABEL_NODE *)p_anon_label_head;
}



================================================
File: write_asm.h
================================================
#ifndef _WRITE_ASM_H_
#define _WRITE_ASM_H_

#include "options_def.h"
#include "plugin.h"

// linked list of labels

typedef struct _label_node {
	struct _label_node *next;
	DWORD_PTR dwAddress;
	TCHAR *lpLabel;
} LABEL_NODE;

typedef struct _label_head {
	LABEL_NODE *next;
	LABEL_NODE *last;
} LABEL_HEAD;

// linked list of commands

typedef struct _cmd_node {
	struct _cmd_node *next;
	BYTE *bCode;
	SIZE_T nCodeSize;
	TCHAR *lpCommand;
	TCHAR *lpComment;
	TCHAR *lpResolvedCommandWithLabels;
} CMD_NODE;

typedef struct _cmd_head {
	CMD_NODE *next;
	CMD_NODE *last;
} CMD_HEAD;

// linked list of anonymous labels

typedef struct _anon_label_node {
	struct _anon_label_node *next;
	DWORD_PTR dwAddress;
} ANON_LABEL_NODE;

typedef struct _anon_label_head {
	ANON_LABEL_NODE *next;
	ANON_LABEL_NODE *last;
} ANON_LABEL_HEAD;

// linked list of blocks of commands

typedef struct _cmd_block_node {
	struct _cmd_block_node *next;
	DWORD_PTR dwAddress;
	SIZE_T nSize;
	CMD_HEAD cmd_head;
	ANON_LABEL_HEAD anon_label_head;
} CMD_BLOCK_NODE;

typedef struct _cmd_block_head {
	CMD_BLOCK_NODE *next;
	CMD_BLOCK_NODE *last;
} CMD_BLOCK_HEAD;

// special commands

#define SPECIAL_CMD_ALIGN     1
#define SPECIAL_CMD_PAD       2

// functions

LONG_PTR WriteAsm(TCHAR *lpText, TCHAR *lpError);

// 1
static TCHAR *TextToData(LABEL_HEAD *p_label_head, CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpText, TCHAR *lpError);
static LONG_PTR AddressToData(CMD_BLOCK_HEAD *p_cmd_block_head, CMD_BLOCK_NODE **p_cmd_block_node,
	DWORD_PTR *pdwAddress, DWORD_PTR *pdwEndAddress, DWORD_PTR *pdwBaseAddress, TCHAR *lpText, TCHAR *lpError);
static LONG_PTR LabelToData(LABEL_HEAD *p_label_head, CMD_BLOCK_NODE *cmd_block_node, DWORD_PTR *pdwAddress, TCHAR *lpText, TCHAR *lpError);
static LONG_PTR SpecialCommandToData(CMD_BLOCK_NODE *cmd_block_node, DWORD_PTR *pdwAddress, DWORD_PTR dwEndAddress, TCHAR *lpText, TCHAR *lpError);
static LONG_PTR CommandToData(CMD_BLOCK_NODE *cmd_block_node, DWORD_PTR *pdwAddress, DWORD_PTR dwBaseAddress, TCHAR *lpText, TCHAR *lpError);

static BOOL IsInComment(TCHAR *pchCommentChar, TCHAR *lpText, TCHAR *lpError);
static LONG_PTR ParseAddress(TCHAR *lpText, DWORD_PTR *pdwAddress, DWORD_PTR *pdwEndAddress, DWORD_PTR *pdwBaseAddress, TCHAR *lpError);
static BOOL NewCmdBlock(CMD_BLOCK_HEAD *p_cmd_block_head, DWORD_PTR dwAddress, TCHAR *lpError);
static LONG_PTR ParseAnonLabel(TCHAR *lpText, DWORD_PTR dwAddress, ANON_LABEL_HEAD *p_anon_label_head, TCHAR *lpError);
static LONG_PTR ParseLabel(TCHAR *lpText, DWORD_PTR dwAddress, LABEL_HEAD *p_label_head, DWORD_PTR *pdwPaddingSize, TCHAR *lpError);
static LONG_PTR ParseAsciiString(TCHAR *lpText, CMD_HEAD *p_cmd_head, SIZE_T *pnSizeInBytes, TCHAR *lpError);
static LONG_PTR ParseUnicodeString(TCHAR *lpText, CMD_HEAD *p_cmd_head, SIZE_T *pnSizeInBytes, TCHAR *lpError);
static LONG_PTR ParseCommand(TCHAR *lpText, DWORD_PTR dwAddress, DWORD_PTR dwBaseAddress, CMD_HEAD *p_cmd_head, SIZE_T *pnSizeInBytes, TCHAR *lpError);
static LONG_PTR ResolveCommand(TCHAR *lpCommand, DWORD_PTR dwBaseAddress, TCHAR **ppNewCommand, TCHAR **ppComment, TCHAR *lpError);
static LONG_PTR ReplaceLabelsWithFooAddress(TCHAR *lpCommand, DWORD_PTR dwCommandAddress, UINT nDeltaSize, TCHAR **ppNewCommand, TCHAR *lpError);
static LONG_PTR ParseSpecialCommand(TCHAR *lpText, UINT *pnSpecialCmd, TCHAR *lpError);
static LONG_PTR ParseAlignSpecialCommand(TCHAR *lpText, LONG_PTR nArgsOffset, DWORD_PTR dwAddress, DWORD_PTR *pdwPaddingSize, TCHAR *lpError);
static LONG_PTR ParsePadSpecialCommand(TCHAR *lpText, LONG_PTR nArgsOffset, BYTE *pbPaddingByteValue, TCHAR *lpError);
static BOOL GetAlignPaddingSize(DWORD_PTR dwAddress, DWORD_PTR dwAlignValue, DWORD_PTR *pdwPaddingSize, TCHAR *lpError);
static BOOL InsertBytes(TCHAR *lpText, SIZE_T nBytesCount, BYTE bByteValue, CMD_HEAD *p_cmd_head, TCHAR *lpError);

static LONG_PTR ParseRVAAddress(TCHAR *lpText, DWORD_PTR *pdwAddress, DWORD_PTR dwParentBaseAddress, DWORD_PTR *pdwBaseAddress, TCHAR *lpError);
static LONG_PTR ParseDWORDPtr(TCHAR *lpText, DWORD_PTR *pdw, TCHAR *lpError);

// 2
static TCHAR *ReplaceLabelsInCommands(LABEL_HEAD *p_label_head, CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError);
static LONG_PTR ReplaceLabelsFromList(TCHAR *lpCommand, DWORD_PTR dwPrevAnonAddr, DWORD_PTR dwNextAnonAddr,
	LABEL_HEAD *p_label_head, TCHAR **ppNewCommand, TCHAR *lpError);

// 3
static TCHAR *PatchCommands(CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError);
static TCHAR *SetComments(CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError);
static TCHAR *SetLabels(LABEL_HEAD *p_label_head, CMD_BLOCK_HEAD *p_cmd_block_head, TCHAR *lpError);

// Helper functions
static BOOL ReplaceTextsWithAddresses(TCHAR *lpCommand, TCHAR **ppNewCommand, 
	int text_count, LONG_PTR text_start[4], LONG_PTR text_end[4], DWORD_PTR dwAddress[4], TCHAR *lpError);
static LONG_PTR ReplacedTextCorrectErrorSpot(TCHAR *lpCommand, TCHAR *lpReplacedCommand, LONG_PTR result);
static TCHAR *NullTerminateLine(TCHAR *p);
static TCHAR *SkipSpaces(TCHAR *p);
static TCHAR *SkipDWORD(TCHAR *p);
static TCHAR *SkipLabel(TCHAR *p);
static TCHAR *SkipRVAAddress(TCHAR *p);
static BOOL IsDWORDPtrPowerOfTwo(DWORD_PTR dw);

// Cleanup function
static void FreeLabelList(LABEL_HEAD *p_label_head);
static void FreeCmdBlockList(CMD_BLOCK_HEAD *p_cmd_block_head);
static void FreeCmdList(CMD_HEAD *p_cmd_head);
static void FreeAnonLabelList(ANON_LABEL_HEAD *p_anon_label_head);

#endif // _WRITE_ASM_H_





================================================
File: raeditlib/RAEdit.Rc
================================================
#include "Res/RAEditRes.rc"



================================================
File: raeditlib/Res/Bookmark.bmp
================================================
[Non-text file]


================================================
File: raeditlib/Res/Button.bmp
================================================
[Non-text file]


================================================
File: raeditlib/Res/Collapse.bmp
================================================
[Non-text file]


================================================
File: raeditlib/Res/Expand.bmp
================================================
[Non-text file]


================================================
File: raeditlib/Res/Linenumber.bmp
================================================
[Non-text file]


================================================
File: raeditlib/Res/Lock.bmp
================================================
[Non-text file]


================================================
File: raeditlib/Res/RAEditRes.rc
================================================
#define IDB_RAEDITBUTTON				100
#define IDC_HSPLITTCUR					101
#define IDB_BOOKMARK					102
#define IDC_SELECTCUR					103
#define IDB_LINENUMBER					104
#define IDB_EXPAND						105
#define IDB_COLLAPSE					106
#define IDB_LOCK						107

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
LANGUAGE 0x00, 0x00 // LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1251)
IDB_RAEDITBUTTON		BITMAP   DISCARDABLE "Res/Button.bmp"
IDC_HSPLITTCUR			CURSOR   DISCARDABLE "Res/SplitH.cur"
IDB_BOOKMARK			BITMAP   DISCARDABLE "Res/Bookmark.bmp"
IDC_SELECTCUR			CURSOR   DISCARDABLE "Res/Select.cur"
IDB_LINENUMBER			BITMAP   DISCARDABLE "Res/Linenumber.bmp"
IDB_EXPAND				BITMAP   DISCARDABLE "Res/Expand.bmp"
IDB_COLLAPSE			BITMAP   DISCARDABLE "Res/Collapse.bmp"
IDB_LOCK				BITMAP   DISCARDABLE "Res/Lock.bmp"
#endif    // Neutral resources



================================================
File: raeditlib/Res/Select.cur
================================================
[Non-text file]


================================================
File: raeditlib/Res/SplitH.cur
================================================
[Non-text file]



================================================
File: x64dbg_pluginsdk/_dbgfunctions.h
================================================
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*GETSEHCHAIN)(DBGSEHCHAIN* sehchain);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line, duint* displacement);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool (*PATCHGETEX)(duint addr, DBGPATCHINFO* info);
typedef bool (*GETBRIDGEBP)(BPXTYPE type, duint addr, BRIDGEBP* bp);
typedef bool (*STRINGFORMATINLINE)(const char* format, size_t resultSize, char* result);
typedef void (*GETMNEMONICBRIEF)(const char* mnem, size_t resultSize, char* result);
typedef unsigned int (*GETTRACERECORDHITCOUNT)(duint address);
typedef TRACERECORDBYTETYPE(*GETTRACERECORDBYTETYPE)(duint address);
typedef bool (*SETTRACERECORDTYPE)(duint pageAddress, TRACERECORDTYPE type);
typedef TRACERECORDTYPE(*GETTRACERECORDTYPE)(duint pageAddress);
typedef bool (*ENUMHANDLES)(ListOf(HANDLEINFO) handles);
typedef bool (*GETHANDLENAME)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
typedef bool (*ENUMTCPCONNECTIONS)(ListOf(TCPCONNECTIONINFO) connections);
typedef duint(*GETDBGEVENTS)();
typedef int (*MODGETPARTY)(duint base);
typedef void (*MODSETPARTY)(duint base, int party);
typedef bool(*WATCHISWATCHDOGTRIGGERED)(unsigned int id);
typedef bool(*MEMISCODEPAGE)(duint addr, bool refresh);
typedef bool(*ANIMATECOMMAND)(const char* command);
typedef void(*DBGSETDEBUGGEEINITSCRIPT)(const char* fileName);
typedef const char* (*DBGGETDEBUGGEEINITSCRIPT)();

typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    GETSEHCHAIN GetSEHChain;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
    GETBRIDGEBP GetBridgeBp;
    STRINGFORMATINLINE StringFormatInline;
    GETMNEMONICBRIEF GetMnemonicBrief;
    GETTRACERECORDHITCOUNT GetTraceRecordHitCount;
    GETTRACERECORDBYTETYPE GetTraceRecordByteType;
    SETTRACERECORDTYPE SetTraceRecordType;
    GETTRACERECORDTYPE GetTraceRecordType;
    ENUMHANDLES EnumHandles;
    GETHANDLENAME GetHandleName;
    ENUMTCPCONNECTIONS EnumTcpConnections;
    GETDBGEVENTS GetDbgEvents;
    MODGETPARTY ModGetParty;
    MODSETPARTY ModSetParty;
    WATCHISWATCHDOGTRIGGERED WatchIsWatchdogTriggered;
    MEMISCODEPAGE MemIsCodePage;
    ANIMATECOMMAND AnimateCommand;
    DBGSETDEBUGGEEINITSCRIPT DbgSetDebuggeeInitScript;
    DBGGETDEBUGGEEINITSCRIPT DbgGetDebuggeeInitScript;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H



================================================
File: x64dbg_pluginsdk/_plugin_types.h
================================================
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"

#else

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#include <dbghelp.h>
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H



================================================
File: x64dbg_pluginsdk/_plugins.h
================================================
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB //PLUG_CB_LOADSAVEDB
} CBTYPE;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, duint* argv, void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H



================================================
File: x64dbg_pluginsdk/_scriptapi.h
================================================
#ifndef _SCRIPT_API_H
#define _SCRIPT_API_H

#include "_plugins.h"

#define SCRIPT_EXPORT PLUG_IMPEXP

#endif //_SCRIPT_API_H


================================================
File: x64dbg_pluginsdk/_scriptapi_argument.h
================================================
#ifndef _SCRIPTAPI_ARGUMENT_H
#define _SCRIPTAPI_ARGUMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Argument
    {
        struct ArgumentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const ArgumentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, ArgumentInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(ArgumentInfo) list); //caller has the responsibility to free the list
    }; //Argument
}; //Script

#endif //_SCRIPTAPI_ARGUMENT_H


================================================
File: x64dbg_pluginsdk/_scriptapi_assembler.h
================================================
#ifndef _SCRIPTAPI_ASSEMBLER_H
#define _SCRIPTAPI_ASSEMBLER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Assembler
    {
        SCRIPT_EXPORT bool Assemble(duint addr, unsigned char* dest, int* size, const char* instruction); //dest[16]
        SCRIPT_EXPORT bool AssembleEx(duint addr, unsigned char* dest, int* size, const char* instruction, char* error); //dest[16], error[MAX_ERROR_SIZE]
        SCRIPT_EXPORT bool AssembleMem(duint addr, const char* instruction);
        SCRIPT_EXPORT bool AssembleMemEx(duint addr, const char* instruction, int* size, char* error, bool fillnop); //error[MAX_ERROR_SIZE]
    }; //Assembler
}; //Script

#endif //_SCRIPTAPI_ASSEMBLER_H


================================================
File: x64dbg_pluginsdk/_scriptapi_bookmark.h
================================================
#ifndef _SCRIPTAPI_BOOKMARK_H
#define _SCRIPTAPI_BOOKMARK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Bookmark
    {
        struct BookmarkInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, bool manual = false);
        SCRIPT_EXPORT bool Set(const BookmarkInfo* info);
        SCRIPT_EXPORT bool Get(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, BookmarkInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(BookmarkInfo) list); //caller has the responsibility to free the list
    }; //Bookmark
}; //Script

#endif //_SCRIPTAPI_BOOKMARK_H


================================================
File: x64dbg_pluginsdk/_scriptapi_comment.h
================================================
#ifndef _SCRIPTAPI_COMMENT_H
#define _SCRIPTAPI_COMMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Comment
    {
        struct CommentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const CommentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_COMMENT_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, CommentInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(CommentInfo) list); //caller has the responsibility to free the list
    }; //Comment
}; //Script

#endif //_SCRIPTAPI_COMMENT_H


================================================
File: x64dbg_pluginsdk/_scriptapi_debug.h
================================================
#ifndef _SCRIPTAPI_DEBUG_H
#define _SCRIPTAPI_DEBUG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Debug
    {
        enum HardwareType
        {
            HardwareAccess,
            HardwareWrite,
            HardwareExecute
        };

        SCRIPT_EXPORT void Wait();
        SCRIPT_EXPORT void Run();
        SCRIPT_EXPORT void Pause();
        SCRIPT_EXPORT void Stop();
        SCRIPT_EXPORT void StepIn();
        SCRIPT_EXPORT void StepOver();
        SCRIPT_EXPORT void StepOut();
        SCRIPT_EXPORT bool SetBreakpoint(duint address);
        SCRIPT_EXPORT bool DeleteBreakpoint(duint address);
        SCRIPT_EXPORT bool DisableBreakpoint(duint address);
        SCRIPT_EXPORT bool SetHardwareBreakpoint(duint address, HardwareType type = HardwareExecute);
        SCRIPT_EXPORT bool DeleteHardwareBreakpoint(duint address);
    }; //Debug
}; //Script

#endif //_SCRIPTAPI_DEBUG_H


================================================
File: x64dbg_pluginsdk/_scriptapi_flag.h
================================================
#ifndef _SCRIPTAPI_FLAG_H
#define _SCRIPTAPI_FLAG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Flag
    {
        enum FlagEnum
        {
            ZF,
            OF,
            CF,
            PF,
            SF,
            TF,
            AF,
            DF,
            IF
        };

        SCRIPT_EXPORT bool Get(FlagEnum flag);
        SCRIPT_EXPORT bool Set(FlagEnum flag, bool value);

        SCRIPT_EXPORT bool GetZF();
        SCRIPT_EXPORT bool SetZF(bool value);
        SCRIPT_EXPORT bool GetOF();
        SCRIPT_EXPORT bool SetOF(bool value);
        SCRIPT_EXPORT bool GetCF();
        SCRIPT_EXPORT bool SetCF(bool value);
        SCRIPT_EXPORT bool GetPF();
        SCRIPT_EXPORT bool SetPF(bool value);
        SCRIPT_EXPORT bool GetSF();
        SCRIPT_EXPORT bool SetSF(bool value);
        SCRIPT_EXPORT bool GetTF();
        SCRIPT_EXPORT bool SetTF(bool value);
        SCRIPT_EXPORT bool GetAF();
        SCRIPT_EXPORT bool SetAF(bool value);
        SCRIPT_EXPORT bool GetDF();
        SCRIPT_EXPORT bool SetDF(bool value);
        SCRIPT_EXPORT bool GetIF();
        SCRIPT_EXPORT bool SetIF(bool value);
    };
};

#endif //_SCRIPTAPI_FLAG_H


================================================
File: x64dbg_pluginsdk/_scriptapi_function.h
================================================
#ifndef _SCRIPTAPI_FUNCTION_H
#define _SCRIPTAPI_FUNCTION_H

#include "_scriptapi.h"

namespace Script
{
    namespace Function
    {
        struct FunctionInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const FunctionInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, FunctionInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(FunctionInfo) list); //caller has the responsibility to free the list
    }; //Function
}; //Script

#endif //_SCRIPTAPI_FUNCTION_H


================================================
File: x64dbg_pluginsdk/_scriptapi_gui.h
================================================
#ifndef _SCRIPTAPI_GUI_H
#define _SCRIPTAPI_GUI_H

#include "_scriptapi.h"

namespace Script
{
    namespace Gui
    {
        namespace Disassembly
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Disassembly

        namespace Dump
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Dump

        namespace Stack
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Stack

        namespace Graph
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //Graph

        namespace MemMap
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //MemoryMap

        namespace SymMod
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //SymMod
    }; //Gui

    namespace Gui
    {
        enum Window
        {
            DisassemblyWindow,
            DumpWindow,
            StackWindow,
            GraphWindow,
            MemMapWindow,
            SymModWindow
        };

        SCRIPT_EXPORT bool SelectionGet(Window window, duint* start, duint* end);
        SCRIPT_EXPORT bool SelectionSet(Window window, duint start, duint end);
        SCRIPT_EXPORT duint SelectionGetStart(Window window);
        SCRIPT_EXPORT duint SelectionGetEnd(Window window);
        SCRIPT_EXPORT void Message(const char* message);
        SCRIPT_EXPORT bool MessageYesNo(const char* message);
        SCRIPT_EXPORT bool InputLine(const char* title, char* text); //text[GUI_MAX_LINE_SIZE]
        SCRIPT_EXPORT bool InputValue(const char* title, duint* value);
        SCRIPT_EXPORT void Refresh();
        SCRIPT_EXPORT void AddQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void ShowQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void CloseQWidgetTab(void* qWidget);

    }; //Gui
}; //Script

#endif //_SCRIPTAPI_GUI_H


================================================
File: x64dbg_pluginsdk/_scriptapi_label.h
================================================
#ifndef _SCRIPTAPI_LABEL_H
#define _SCRIPTAPI_LABEL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Label
    {
        struct LabelInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const LabelInfo* info);
        SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
    }; //Label
}; //Script

#endif //_SCRIPTAPI_LABEL_H


================================================
File: x64dbg_pluginsdk/_scriptapi_memory.h
================================================
#ifndef _SCRIPTAPI_MEMORY_H
#define _SCRIPTAPI_MEMORY_H

#include "_scriptapi.h"

namespace Script
{
    namespace Memory
    {
        SCRIPT_EXPORT bool Read(duint addr, void* data, duint size, duint* sizeRead);
        SCRIPT_EXPORT bool Write(duint addr, const void* data, duint size, duint* sizeWritten);
        SCRIPT_EXPORT bool IsValidPtr(duint addr);
        SCRIPT_EXPORT duint RemoteAlloc(duint addr, duint size);
        SCRIPT_EXPORT bool RemoteFree(duint addr);

        SCRIPT_EXPORT unsigned char ReadByte(duint addr);
        SCRIPT_EXPORT bool WriteByte(duint addr, unsigned char data);
        SCRIPT_EXPORT unsigned short ReadWord(duint addr);
        SCRIPT_EXPORT bool WriteWord(duint addr, unsigned short data);
        SCRIPT_EXPORT unsigned int ReadDword(duint addr);
        SCRIPT_EXPORT bool WriteDword(duint addr, unsigned int data);
        SCRIPT_EXPORT unsigned long long ReadQword(duint addr);
        SCRIPT_EXPORT bool WriteQword(duint addr, unsigned long long data);
        SCRIPT_EXPORT duint ReadPtr(duint addr);
        SCRIPT_EXPORT bool WritePtr(duint addr, duint data);
    }; //Memory
}; //Script

#endif //_SCRIPTAPI_MEMORY_H


================================================
File: x64dbg_pluginsdk/_scriptapi_misc.h
================================================
#ifndef _SCRIPTAPI_MISC_H
#define _SCRIPTAPI_MISC_H

#include "_scriptapi.h"

namespace Script
{
    namespace Misc
    {
        SCRIPT_EXPORT bool ParseExpression(const char* expression, duint* value);
        SCRIPT_EXPORT duint RemoteGetProcAddress(const char* module, const char* api);
        SCRIPT_EXPORT duint ResolveLabel(const char* label);
        SCRIPT_EXPORT void* Alloc(duint size);
        SCRIPT_EXPORT void Free(void* ptr);
    }; //Misc
}; //Script

#endif //_SCRIPTAPI_MISC_H


================================================
File: x64dbg_pluginsdk/_scriptapi_module.h
================================================
#ifndef _SCRIPTAPI_MODULE_H
#define _SCRIPTAPI_MODULE_H

#include "_scriptapi.h"

namespace Script
{
    namespace Module
    {
        struct ModuleInfo
        {
            duint base;
            duint size;
            duint entry;
            int sectionCount;
            char name[MAX_MODULE_SIZE];
            char path[MAX_PATH];
        };

        struct ModuleSectionInfo
        {
            duint addr;
            duint size;
            char name[MAX_SECTION_SIZE * 5];
        };

        SCRIPT_EXPORT bool InfoFromAddr(duint addr, ModuleInfo* info);
        SCRIPT_EXPORT bool InfoFromName(const char* name, ModuleInfo* info);
        SCRIPT_EXPORT duint BaseFromAddr(duint addr);
        SCRIPT_EXPORT duint BaseFromName(const char* name);
        SCRIPT_EXPORT duint SizeFromAddr(duint addr);
        SCRIPT_EXPORT duint SizeFromName(const char* name);
        SCRIPT_EXPORT bool NameFromAddr(duint addr, char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool PathFromAddr(duint addr, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool PathFromName(const char* name, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT duint EntryFromAddr(duint addr);
        SCRIPT_EXPORT duint EntryFromName(const char* name);
        SCRIPT_EXPORT int SectionCountFromAddr(duint addr);
        SCRIPT_EXPORT int SectionCountFromName(const char* name);
        SCRIPT_EXPORT bool SectionFromAddr(duint addr, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionFromName(const char* name, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionListFromAddr(duint addr, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool SectionListFromName(const char* name, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool GetMainModuleInfo(ModuleInfo* info);
        SCRIPT_EXPORT duint GetMainModuleBase();
        SCRIPT_EXPORT duint GetMainModuleSize();
        SCRIPT_EXPORT duint GetMainModuleEntry();
        SCRIPT_EXPORT int GetMainModuleSectionCount();
        SCRIPT_EXPORT bool GetMainModuleName(char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool GetMainModulePath(char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool GetMainModuleSectionList(ListOf(ModuleSectionInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetList(ListOf(ModuleInfo) list); //caller has the responsibility to free the list
    }; //Module
}; //Script

#endif //_SCRIPTAPI_MODULE_H


================================================
File: x64dbg_pluginsdk/_scriptapi_pattern.h
================================================
#ifndef _SCRIPTAPI_PATTERN_H
#define _SCRIPTAPI_PATTERN_H

#include "_scriptapi.h"

namespace Script
{
    namespace Pattern
    {
        SCRIPT_EXPORT duint Find(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT void Write(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT void WriteMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT bool SearchAndReplace(unsigned char* data, duint datasize, const char* searchpattern, const char* replacepattern);
        SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern);
    };
};

#endif //_SCRIPTAPI_FIND_H


================================================
File: x64dbg_pluginsdk/_scriptapi_register.h
================================================
#ifndef _SCRIPTAPI_REGISTER_H
#define _SCRIPTAPI_REGISTER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Register
    {
        enum RegisterEnum
        {
            DR0,
            DR1,
            DR2,
            DR3,
            DR6,
            DR7,

            EAX,
            AX,
            AH,
            AL,
            EBX,
            BX,
            BH,
            BL,
            ECX,
            CX,
            CH,
            CL,
            EDX,
            DX,
            DH,
            DL,
            EDI,
            DI,
            ESI,
            SI,
            EBP,
            BP,
            ESP,
            SP,
            EIP,

#ifdef _WIN64
            RAX,
            RBX,
            RCX,
            RDX,
            RSI,
            SIL,
            RDI,
            DIL,
            RBP,
            BPL,
            RSP,
            SPL,
            RIP,
            R8,
            R8D,
            R8W,
            R8B,
            R9,
            R9D,
            R9W,
            R9B,
            R10,
            R10D,
            R10W,
            R10B,
            R11,
            R11D,
            R11W,
            R11B,
            R12,
            R12D,
            R12W,
            R12B,
            R13,
            R13D,
            R13W,
            R13B,
            R14,
            R14D,
            R14W,
            R14B,
            R15,
            R15D,
            R15W,
            R15B,
#endif //_WIN64

            CIP,
            CSP,
        }; //RegisterEnum

        SCRIPT_EXPORT duint Get(RegisterEnum reg);
        SCRIPT_EXPORT bool Set(RegisterEnum reg, duint value);
        SCRIPT_EXPORT int Size(); //gets architecture register size in bytes

        SCRIPT_EXPORT duint GetDR0();
        SCRIPT_EXPORT bool SetDR0(duint value);
        SCRIPT_EXPORT duint GetDR1();
        SCRIPT_EXPORT bool SetDR1(duint value);
        SCRIPT_EXPORT duint GetDR2();
        SCRIPT_EXPORT bool SetDR2(duint value);
        SCRIPT_EXPORT duint GetDR3();
        SCRIPT_EXPORT bool SetDR3(duint value);
        SCRIPT_EXPORT duint GetDR6();
        SCRIPT_EXPORT bool SetDR6(duint value);
        SCRIPT_EXPORT duint GetDR7();
        SCRIPT_EXPORT bool SetDR7(duint value);

        SCRIPT_EXPORT unsigned int GetEAX();
        SCRIPT_EXPORT bool SetEAX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetAX();
        SCRIPT_EXPORT bool SetAX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetAH();
        SCRIPT_EXPORT bool SetAH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetAL();
        SCRIPT_EXPORT bool SetAL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEBX();
        SCRIPT_EXPORT bool SetEBX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBX();
        SCRIPT_EXPORT bool SetBX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetBH();
        SCRIPT_EXPORT bool SetBH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetBL();
        SCRIPT_EXPORT bool SetBL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetECX();
        SCRIPT_EXPORT bool SetECX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetCX();
        SCRIPT_EXPORT bool SetCX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetCH();
        SCRIPT_EXPORT bool SetCH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetCL();
        SCRIPT_EXPORT bool SetCL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDX();
        SCRIPT_EXPORT bool SetEDX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDX();
        SCRIPT_EXPORT bool SetDX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetDH();
        SCRIPT_EXPORT bool SetDH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetDL();
        SCRIPT_EXPORT bool SetDL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDI();
        SCRIPT_EXPORT bool SetEDI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDI();
        SCRIPT_EXPORT bool SetDI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESI();
        SCRIPT_EXPORT bool SetESI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSI();
        SCRIPT_EXPORT bool SetSI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEBP();
        SCRIPT_EXPORT bool SetEBP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBP();
        SCRIPT_EXPORT bool SetBP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESP();
        SCRIPT_EXPORT bool SetESP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSP();
        SCRIPT_EXPORT bool SetSP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEIP();
        SCRIPT_EXPORT bool SetEIP(unsigned int value);

#ifdef _WIN64
        SCRIPT_EXPORT unsigned long long GetRAX();
        SCRIPT_EXPORT bool SetRAX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRBX();
        SCRIPT_EXPORT bool SetRBX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRCX();
        SCRIPT_EXPORT bool SetRCX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRDX();
        SCRIPT_EXPORT bool SetRDX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRSI();
        SCRIPT_EXPORT bool SetRSI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSIL();
        SCRIPT_EXPORT bool SetSIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRDI();
        SCRIPT_EXPORT bool SetRDI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetDIL();
        SCRIPT_EXPORT bool SetDIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRBP();
        SCRIPT_EXPORT bool SetRBP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetBPL();
        SCRIPT_EXPORT bool SetBPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRSP();
        SCRIPT_EXPORT bool SetRSP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSPL();
        SCRIPT_EXPORT bool SetSPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRIP();
        SCRIPT_EXPORT bool SetRIP(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetR8();
        SCRIPT_EXPORT bool SetR8(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR8D();
        SCRIPT_EXPORT bool SetR8D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR8W();
        SCRIPT_EXPORT bool SetR8W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR8B();
        SCRIPT_EXPORT bool SetR8B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR9();
        SCRIPT_EXPORT bool SetR9(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR9D();
        SCRIPT_EXPORT bool SetR9D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR9W();
        SCRIPT_EXPORT bool SetR9W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR9B();
        SCRIPT_EXPORT bool SetR9B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR10();
        SCRIPT_EXPORT bool SetR10(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR10D();
        SCRIPT_EXPORT bool SetR10D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR10W();
        SCRIPT_EXPORT bool SetR10W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR10B();
        SCRIPT_EXPORT bool SetR10B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR11();
        SCRIPT_EXPORT bool SetR11(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR11D();
        SCRIPT_EXPORT bool SetR11D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR11W();
        SCRIPT_EXPORT bool SetR11W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR11B();
        SCRIPT_EXPORT bool SetR11B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR12();
        SCRIPT_EXPORT bool SetR12(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR12D();
        SCRIPT_EXPORT bool SetR12D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR12W();
        SCRIPT_EXPORT bool SetR12W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR12B();
        SCRIPT_EXPORT bool SetR12B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR13();
        SCRIPT_EXPORT bool SetR13(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR13D();
        SCRIPT_EXPORT bool SetR13D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR13W();
        SCRIPT_EXPORT bool SetR13W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR13B();
        SCRIPT_EXPORT bool SetR13B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR14();
        SCRIPT_EXPORT bool SetR14(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR14D();
        SCRIPT_EXPORT bool SetR14D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR14W();
        SCRIPT_EXPORT bool SetR14W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR14B();
        SCRIPT_EXPORT bool SetR14B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR15();
        SCRIPT_EXPORT bool SetR15(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR15D();
        SCRIPT_EXPORT bool SetR15D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR15W();
        SCRIPT_EXPORT bool SetR15W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR15B();
        SCRIPT_EXPORT bool SetR15B(unsigned char value);
#endif //_WIN64

        SCRIPT_EXPORT duint GetCIP();
        SCRIPT_EXPORT bool SetCIP(duint value);
        SCRIPT_EXPORT duint GetCSP();
        SCRIPT_EXPORT bool SetCSP(duint value);
    }; //Register
}; //Script

#endif //_SCRIPTAPI_REGISTER_H


================================================
File: x64dbg_pluginsdk/_scriptapi_stack.h
================================================
#ifndef _SCRIPTAPI_STACK_H
#define _SCRIPTAPI_STACK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Stack
    {
        SCRIPT_EXPORT duint Pop();
        SCRIPT_EXPORT duint Push(duint value); //returns the previous top, equal to Peek(1)
        SCRIPT_EXPORT duint Peek(int offset = 0); //offset is in multiples of Register::Size(), for easy x32/x64 portability
    }; //Stack
}; //Script

#endif //_SCRIPTAPI_STACK_H


================================================
File: x64dbg_pluginsdk/_scriptapi_symbol.h
================================================
#ifndef _SCRIPTAPI_SYMBOL_H
#define _SCRIPTAPI_SYMBOL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Symbol
    {
        enum SymbolType
        {
            Function,
            Import,
            Export
        };

        struct SymbolInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char name[MAX_LABEL_SIZE];
            bool manual;
            SymbolType type;
        };

        SCRIPT_EXPORT bool GetList(ListOf(SymbolInfo) list); //caller has the responsibility to free the list
    }; //Symbol
}; //Script

#endif //_SCRIPTAPI_SYMBOL_H


================================================
File: x64dbg_pluginsdk/bridgegraph.h
================================================
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo data; //block data
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if _MSC_VER >= 1700 && !defined(NO_CPP11)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    void* userdata; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<unsigned char> data; //block data

    explicit BridgeCFNode(BridgeCFNodeList* nodeList, bool freedata = true)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<unsigned char>::ToVector(&nodeList->data, data, freedata))
            __debugbreak();
    }

    explicit BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end),
          brtrue(0),
          brfalse(0),
          icount(0),
          terminal(false),
          split(false),
          userdata(nullptr)
    {
    }

    explicit BridgeCFNode()
        : BridgeCFNode(0, 0, 0)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<unsigned char>::CopyData(&out.data, data);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    explicit BridgeCFGraph(BridgeCFGraphList* graphList, bool freedata = true)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
            parents[child] = std::unordered_set<duint>(std::initializer_list<duint> { parent });
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H


================================================
File: x64dbg_pluginsdk/bridgelist.h
================================================
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type))  //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count()))  //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H


================================================
File: x64dbg_pluginsdk/bridgemain.h
================================================
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

//list structure (and C++ wrapper)
#include "bridgelist.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions
BRIDGE_IMPEXP const wchar_t* BridgeInit();
BRIDGE_IMPEXP const wchar_t* BridgeStart();
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);
BRIDGE_IMPEXP void BridgeFree(void* ptr);
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);
BRIDGE_IMPEXP bool BridgeSettingFlush();
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);
BRIDGE_IMPEXP int BridgeGetDbgVersion();

#ifdef __cplusplus
}
#endif

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 1,
    flaglabel = 2,
    flagcomment = 4,
    flagbookmark = 8,
    flagfunction = 16,
    flagloop = 32,
    flagargs = 64
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST              // param1=ListOf(WATCHINFO),         param2=unused
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes avx512 not supported
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;
typedef struct SYMBOLINFO_ SYMBOLINFO;
typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef void (*CBSYMBOLENUM)(SYMBOLINFO* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
} LOOP;

#ifndef _NO_ADDRINFO
typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} ADDRINFO;
#endif

struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    bool isImported;
};

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool IR;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, unsigned char* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const unsigned char* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDump(REGDUMP* regdump);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);

//Gui defines
#define GUI_PLUGIN_MENU 0
#define GUI_DISASM_MENU 1
#define GUI_DUMP_MENU 2
#define GUI_STACK_MENU 3

#define GUI_DISASSEMBLY 0
#define GUI_DUMP 1
#define GUI_STACK 2
#define GUI_GRAPH 3
#define GUI_MEMMAP 4
#define GUI_SYMMOD 5

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=int hWindow,          param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=int hWindow,          param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_UPDATE_SEHCHAIN,            // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=line
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACK,          param2=unused
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG,     // param1=int id,               param2=unused
    GUI_UPDATE_ARGUMENT_VIEW,       // param1=unused,               param2=unused
    GUI_FOCUS_VIEW,                 // param1=int hWindow,          param2=unused
    GUI_UPDATE_WATCH_VIEW,          // param1=unused,               param2=unused
    GUI_LOAD_GRAPH,                 // param1=BridgeCFGraphList*    param2=unused
    GUI_GRAPH_AT,                   // param1=duint addr            param2=unused
    GUI_UPDATE_GRAPH_VIEW,          // param1=unused,               param2=unused
    GUI_SET_LOG_ENABLED,            // param1=bool isEnabled        param2=unused
    GUI_ADD_FAVOURITE_TOOL,         // param1=const char* name      param2=const char* description
    GUI_ADD_FAVOURITE_COMMAND,      // param1=const char* command   param2=const char* shortcut
    GUI_SET_FAVOURITE_TOOL_SHORTCUT,// param1=const char* name      param2=const char* shortcut
    GUI_FOLD_DISASSEMBLY,           // param1=duint startAddress    param2=duint length
    GUI_SELECT_IN_MEMORY_MAP        // param1=duint addr,           param2=unused
} GUIMSG;

//GUI Typedefs
typedef void (*GUICALLBACK)();
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP const char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(int hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(int hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFile(const char* path, int line);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP void GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP bool GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_



================================================
File: x64dbg_pluginsdk/DeviceNameResolver/DeviceNameResolver.h
================================================
#ifndef _DEVICENAMERESOLVER_H
#define _DEVICENAMERESOLVER_H

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

__declspec(dllexport) bool DevicePathToPathW(const wchar_t* szDevicePath, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathToPathA(const char* szDevicePath, char* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleW(HANDLE hFile, wchar_t* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleA(HANDLE hFile, char* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleW(HANDLE hFile, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleA(HANDLE hFile, char* szPath, size_t nSizeInChars);

#ifdef __cplusplus
}
#endif

#endif // _DEVICENAMERESOLVER_H



================================================
File: x64dbg_pluginsdk/TitanEngine/TitanEngine.h
================================================
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <stdint.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, const char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(const char* szFileName, const char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(const wchar_t* szFileName, const wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(const char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(const char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(const wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(const char* szFileName, const char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(const wchar_t* szFileName, const wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(const char* szFileName, const char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(const wchar_t* szFileName, const wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(const char* szInFileName, const char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(const wchar_t* szInFileName, const wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(const char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(const char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(const char* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(const char* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(const char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(const wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(const char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(const wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(const char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(const char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(const wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(const char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(const char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(const wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(const char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(const wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(const char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(const wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(const char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(const wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(const char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(const wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(const char* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(const wchar_t* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, const char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, const wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const char* szDumpFile1, const char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const wchar_t* szDumpFile1, const wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(const char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(const wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(const char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(const wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(const char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(const char* szFileName, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(const wchar_t* szFileName, char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(const char* szFileName, const char* szResourceType, DWORD ResourceType, const char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(const wchar_t* szFileName, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(const char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(const wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(const char* szFileName, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(const char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(const wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(const char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(const char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(const char* szDumpFileName, const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(const wchar_t* szDumpFileName, const wchar_t* szExportFileName, const wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(const char* szDLLName, const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, const char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, const wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(const char* szOriginalFile, const char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(const char* szOriginalFile, const char* szDumpFile, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile, const char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, const char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, const wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, const char* szDumpedFile, const char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, const wchar_t* szDumpedFile, const wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, const char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, const wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(const char* szModuleName, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(const char* szModuleName, const char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(const char* szModuleName, const char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(const char* szModuleName, const char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, const char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, const char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(const char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(const wchar_t* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(const wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(const char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(const char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(const char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(const wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(const char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(const wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(const char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(const char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(const wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(const char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(const wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(const char* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(const wchar_t* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(const char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(const wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, const char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, const wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(const char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(const wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(const char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(const wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(const char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(const wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(const char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(const wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(const wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(const char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(const char* szFileName, const char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(const wchar_t* szFileName, const wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(const char* szFileName, const char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(const wchar_t* szFileName, const wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(const char* WindowUnpackerTitle, const char* WindowUnpackerLongTitle, const char* WindowUnpackerName, const char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(const char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);
// Global.Engine.Extension.Functions:
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginLoaded(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginEnabled(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerDisableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerDisablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerEnableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerEnablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadPlugin(const char* szPluginName);
__declspec(dllexport) void* TITCALL ExtensionManagerGetPluginInfo(const char* szPluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/



================================================
File: x64dbg_pluginsdk/XEDParse/XEDParse.h
================================================
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H



================================================
File: x64dbg_pluginsdk/capstone/arm.h
================================================
#ifndef CAPSTONE_ARM_H
#define CAPSTONE_ARM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM shift type
typedef enum arm_shifter
{
    ARM_SFT_INVALID = 0,
    ARM_SFT_ASR,    // shift with immediate const
    ARM_SFT_LSL,    // shift with immediate const
    ARM_SFT_LSR,    // shift with immediate const
    ARM_SFT_ROR,    // shift with immediate const
    ARM_SFT_RRX,    // shift with immediate const
    ARM_SFT_ASR_REG,    // shift with register
    ARM_SFT_LSL_REG,    // shift with register
    ARM_SFT_LSR_REG,    // shift with register
    ARM_SFT_ROR_REG,    // shift with register
    ARM_SFT_RRX_REG,    // shift with register
} arm_shifter;

//> ARM condition code
typedef enum arm_cc
{
    ARM_CC_INVALID = 0,
    ARM_CC_EQ,            // Equal                      Equal
    ARM_CC_NE,            // Not equal                  Not equal, or unordered
    ARM_CC_HS,            // Carry set                  >, ==, or unordered
    ARM_CC_LO,            // Carry clear                Less than
    ARM_CC_MI,            // Minus, negative            Less than
    ARM_CC_PL,            // Plus, positive or zero     >, ==, or unordered
    ARM_CC_VS,            // Overflow                   Unordered
    ARM_CC_VC,            // No overflow                Not unordered
    ARM_CC_HI,            // Unsigned higher            Greater than, or unordered
    ARM_CC_LS,            // Unsigned lower or same     Less than or equal
    ARM_CC_GE,            // Greater than or equal      Greater than or equal
    ARM_CC_LT,            // Less than                  Less than, or unordered
    ARM_CC_GT,            // Greater than               Greater than
    ARM_CC_LE,            // Less than or equal         <, ==, or unordered
    ARM_CC_AL             // Always (unconditional)     Always (unconditional)
} arm_cc;

typedef enum arm_sysreg
{
    //> Special registers for MSR
    ARM_SYSREG_INVALID = 0,

    // SPSR* registers can be OR combined
    ARM_SYSREG_SPSR_C = 1,
    ARM_SYSREG_SPSR_X = 2,
    ARM_SYSREG_SPSR_S = 4,
    ARM_SYSREG_SPSR_F = 8,

    // CPSR* registers can be OR combined
    ARM_SYSREG_CPSR_C = 16,
    ARM_SYSREG_CPSR_X = 32,
    ARM_SYSREG_CPSR_S = 64,
    ARM_SYSREG_CPSR_F = 128,

    // independent registers
    ARM_SYSREG_APSR = 256,
    ARM_SYSREG_APSR_G,
    ARM_SYSREG_APSR_NZCVQ,
    ARM_SYSREG_APSR_NZCVQG,

    ARM_SYSREG_IAPSR,
    ARM_SYSREG_IAPSR_G,
    ARM_SYSREG_IAPSR_NZCVQG,
    ARM_SYSREG_IAPSR_NZCVQ,

    ARM_SYSREG_EAPSR,
    ARM_SYSREG_EAPSR_G,
    ARM_SYSREG_EAPSR_NZCVQG,
    ARM_SYSREG_EAPSR_NZCVQ,

    ARM_SYSREG_XPSR,
    ARM_SYSREG_XPSR_G,
    ARM_SYSREG_XPSR_NZCVQG,
    ARM_SYSREG_XPSR_NZCVQ,

    ARM_SYSREG_IPSR,
    ARM_SYSREG_EPSR,
    ARM_SYSREG_IEPSR,

    ARM_SYSREG_MSP,
    ARM_SYSREG_PSP,
    ARM_SYSREG_PRIMASK,
    ARM_SYSREG_BASEPRI,
    ARM_SYSREG_BASEPRI_MAX,
    ARM_SYSREG_FAULTMASK,
    ARM_SYSREG_CONTROL,

    // Banked Registers
    ARM_SYSREG_R8_USR,
    ARM_SYSREG_R9_USR,
    ARM_SYSREG_R10_USR,
    ARM_SYSREG_R11_USR,
    ARM_SYSREG_R12_USR,
    ARM_SYSREG_SP_USR,
    ARM_SYSREG_LR_USR,
    ARM_SYSREG_R8_FIQ,
    ARM_SYSREG_R9_FIQ,
    ARM_SYSREG_R10_FIQ,
    ARM_SYSREG_R11_FIQ,
    ARM_SYSREG_R12_FIQ,
    ARM_SYSREG_SP_FIQ,
    ARM_SYSREG_LR_FIQ,
    ARM_SYSREG_LR_IRQ,
    ARM_SYSREG_SP_IRQ,
    ARM_SYSREG_LR_SVC,
    ARM_SYSREG_SP_SVC,
    ARM_SYSREG_LR_ABT,
    ARM_SYSREG_SP_ABT,
    ARM_SYSREG_LR_UND,
    ARM_SYSREG_SP_UND,
    ARM_SYSREG_LR_MON,
    ARM_SYSREG_SP_MON,
    ARM_SYSREG_ELR_HYP,
    ARM_SYSREG_SP_HYP,

    ARM_SYSREG_SPSR_FIQ,
    ARM_SYSREG_SPSR_IRQ,
    ARM_SYSREG_SPSR_SVC,
    ARM_SYSREG_SPSR_ABT,
    ARM_SYSREG_SPSR_UND,
    ARM_SYSREG_SPSR_MON,
    ARM_SYSREG_SPSR_HYP,
} arm_sysreg;

//> The memory barrier constants map directly to the 4-bit encoding of
//> the option field for Memory Barrier operations.
typedef enum arm_mem_barrier
{
    ARM_MB_INVALID = 0,
    ARM_MB_RESERVED_0,
    ARM_MB_OSHLD,
    ARM_MB_OSHST,
    ARM_MB_OSH,
    ARM_MB_RESERVED_4,
    ARM_MB_NSHLD,
    ARM_MB_NSHST,
    ARM_MB_NSH,
    ARM_MB_RESERVED_8,
    ARM_MB_ISHLD,
    ARM_MB_ISHST,
    ARM_MB_ISH,
    ARM_MB_RESERVED_12,
    ARM_MB_LD,
    ARM_MB_ST,
    ARM_MB_SY,
} arm_mem_barrier;

//> Operand type for instruction's operands
typedef enum arm_op_type
{
    ARM_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    ARM_OP_REG, // = CS_OP_REG (Register operand).
    ARM_OP_IMM, // = CS_OP_IMM (Immediate operand).
    ARM_OP_MEM, // = CS_OP_MEM (Memory operand).
    ARM_OP_FP,  // = CS_OP_FP (Floating-Point operand).
    ARM_OP_CIMM = 64, // C-Immediate (coprocessor registers)
    ARM_OP_PIMM, // P-Immediate (coprocessor registers)
    ARM_OP_SETEND,  // operand for SETEND instruction
    ARM_OP_SYSREG,  // MSR/MSR special register operand
} arm_op_type;

//> Operand type for SETEND instruction
typedef enum arm_setend_type
{
    ARM_SETEND_INVALID = 0, // Uninitialized.
    ARM_SETEND_BE,  // BE operand.
    ARM_SETEND_LE, // LE operand
} arm_setend_type;

typedef enum arm_cpsmode_type
{
    ARM_CPSMODE_INVALID = 0,
    ARM_CPSMODE_IE = 2,
    ARM_CPSMODE_ID = 3
} arm_cpsmode_type;

//> Operand type for SETEND instruction
typedef enum arm_cpsflag_type
{
    ARM_CPSFLAG_INVALID = 0,
    ARM_CPSFLAG_F = 1,
    ARM_CPSFLAG_I = 2,
    ARM_CPSFLAG_A = 4,
    ARM_CPSFLAG_NONE = 16,  // no flag
} arm_cpsflag_type;

//> Data type for elements of vector instructions.
typedef enum arm_vectordata_type
{
    ARM_VECTORDATA_INVALID = 0,

    // Integer type
    ARM_VECTORDATA_I8,
    ARM_VECTORDATA_I16,
    ARM_VECTORDATA_I32,
    ARM_VECTORDATA_I64,

    // Signed integer type
    ARM_VECTORDATA_S8,
    ARM_VECTORDATA_S16,
    ARM_VECTORDATA_S32,
    ARM_VECTORDATA_S64,

    // Unsigned integer type
    ARM_VECTORDATA_U8,
    ARM_VECTORDATA_U16,
    ARM_VECTORDATA_U32,
    ARM_VECTORDATA_U64,

    // Data type for VMUL/VMULL
    ARM_VECTORDATA_P8,

    // Floating type
    ARM_VECTORDATA_F32,
    ARM_VECTORDATA_F64,

    // Convert float <-> float
    ARM_VECTORDATA_F16F64,  // f16.f64
    ARM_VECTORDATA_F64F16,  // f64.f16
    ARM_VECTORDATA_F32F16,  // f32.f16
    ARM_VECTORDATA_F16F32,  // f32.f16
    ARM_VECTORDATA_F64F32,  // f64.f32
    ARM_VECTORDATA_F32F64,  // f32.f64

    // Convert integer <-> float
    ARM_VECTORDATA_S32F32,  // s32.f32
    ARM_VECTORDATA_U32F32,  // u32.f32
    ARM_VECTORDATA_F32S32,  // f32.s32
    ARM_VECTORDATA_F32U32,  // f32.u32
    ARM_VECTORDATA_F64S16,  // f64.s16
    ARM_VECTORDATA_F32S16,  // f32.s16
    ARM_VECTORDATA_F64S32,  // f64.s32
    ARM_VECTORDATA_S16F64,  // s16.f64
    ARM_VECTORDATA_S16F32,  // s16.f64
    ARM_VECTORDATA_S32F64,  // s32.f64
    ARM_VECTORDATA_U16F64,  // u16.f64
    ARM_VECTORDATA_U16F32,  // u16.f32
    ARM_VECTORDATA_U32F64,  // u32.f64
    ARM_VECTORDATA_F64U16,  // f64.u16
    ARM_VECTORDATA_F32U16,  // f32.u16
    ARM_VECTORDATA_F64U32,  // f64.u32
} arm_vectordata_type;

//> ARM registers
typedef enum arm_reg
{
    ARM_REG_INVALID = 0,
    ARM_REG_APSR,
    ARM_REG_APSR_NZCV,
    ARM_REG_CPSR,
    ARM_REG_FPEXC,
    ARM_REG_FPINST,
    ARM_REG_FPSCR,
    ARM_REG_FPSCR_NZCV,
    ARM_REG_FPSID,
    ARM_REG_ITSTATE,
    ARM_REG_LR,
    ARM_REG_PC,
    ARM_REG_SP,
    ARM_REG_SPSR,
    ARM_REG_D0,
    ARM_REG_D1,
    ARM_REG_D2,
    ARM_REG_D3,
    ARM_REG_D4,
    ARM_REG_D5,
    ARM_REG_D6,
    ARM_REG_D7,
    ARM_REG_D8,
    ARM_REG_D9,
    ARM_REG_D10,
    ARM_REG_D11,
    ARM_REG_D12,
    ARM_REG_D13,
    ARM_REG_D14,
    ARM_REG_D15,
    ARM_REG_D16,
    ARM_REG_D17,
    ARM_REG_D18,
    ARM_REG_D19,
    ARM_REG_D20,
    ARM_REG_D21,
    ARM_REG_D22,
    ARM_REG_D23,
    ARM_REG_D24,
    ARM_REG_D25,
    ARM_REG_D26,
    ARM_REG_D27,
    ARM_REG_D28,
    ARM_REG_D29,
    ARM_REG_D30,
    ARM_REG_D31,
    ARM_REG_FPINST2,
    ARM_REG_MVFR0,
    ARM_REG_MVFR1,
    ARM_REG_MVFR2,
    ARM_REG_Q0,
    ARM_REG_Q1,
    ARM_REG_Q2,
    ARM_REG_Q3,
    ARM_REG_Q4,
    ARM_REG_Q5,
    ARM_REG_Q6,
    ARM_REG_Q7,
    ARM_REG_Q8,
    ARM_REG_Q9,
    ARM_REG_Q10,
    ARM_REG_Q11,
    ARM_REG_Q12,
    ARM_REG_Q13,
    ARM_REG_Q14,
    ARM_REG_Q15,
    ARM_REG_R0,
    ARM_REG_R1,
    ARM_REG_R2,
    ARM_REG_R3,
    ARM_REG_R4,
    ARM_REG_R5,
    ARM_REG_R6,
    ARM_REG_R7,
    ARM_REG_R8,
    ARM_REG_R9,
    ARM_REG_R10,
    ARM_REG_R11,
    ARM_REG_R12,
    ARM_REG_S0,
    ARM_REG_S1,
    ARM_REG_S2,
    ARM_REG_S3,
    ARM_REG_S4,
    ARM_REG_S5,
    ARM_REG_S6,
    ARM_REG_S7,
    ARM_REG_S8,
    ARM_REG_S9,
    ARM_REG_S10,
    ARM_REG_S11,
    ARM_REG_S12,
    ARM_REG_S13,
    ARM_REG_S14,
    ARM_REG_S15,
    ARM_REG_S16,
    ARM_REG_S17,
    ARM_REG_S18,
    ARM_REG_S19,
    ARM_REG_S20,
    ARM_REG_S21,
    ARM_REG_S22,
    ARM_REG_S23,
    ARM_REG_S24,
    ARM_REG_S25,
    ARM_REG_S26,
    ARM_REG_S27,
    ARM_REG_S28,
    ARM_REG_S29,
    ARM_REG_S30,
    ARM_REG_S31,

    ARM_REG_ENDING,     // <-- mark the end of the list or registers

    //> alias registers
    ARM_REG_R13 = ARM_REG_SP,
    ARM_REG_R14 = ARM_REG_LR,
    ARM_REG_R15 = ARM_REG_PC,

    ARM_REG_SB = ARM_REG_R9,
    ARM_REG_SL = ARM_REG_R10,
    ARM_REG_FP = ARM_REG_R11,
    ARM_REG_IP = ARM_REG_R12,
} arm_reg;

// Instruction's operand referring to memory
// This is associated with ARM_OP_MEM operand type above
typedef struct arm_op_mem
{
    arm_reg base;   // base register
    arm_reg index;  // index register
    int scale;  // scale for index register (can be 1, or -1)
    int disp;   // displacement/offset value
    int lshift; // left-shift on index register, or 0 if irrelevant.
} arm_op_mem;

// Instruction operand
typedef struct cs_arm_op
{
    int vector_index;   // Vector Index for some vector operands (or -1 if irrelevant)

    struct
    {
        arm_shifter type;
        unsigned int value;
    } shift;

    arm_op_type type;   // operand type

    union
    {
        int reg;    // register value for REG/SYSREG operand
        int32_t imm;            // immediate value for C-IMM, P-IMM or IMM operand
        double fp;          // floating point value for FP operand
        arm_op_mem mem;     // base/index/scale/disp value for MEM operand
        arm_setend_type setend; // SETEND instruction's operand type
    };

    // in some instructions, an operand can be subtracted or added to
    // the base register,
    bool subtracted; // if TRUE, this operand is subtracted. otherwise, it is added.

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;

    // Neon lane index for NEON instructions (or -1 if irrelevant)
    int8_t neon_lane;
} cs_arm_op;

// Instruction structure
typedef struct cs_arm
{
    bool usermode;  // User-mode registers to be loaded (for LDM/STM instructions)
    int vector_size;    // Scalar size for vector instructions
    arm_vectordata_type vector_data; // Data type for elements of vector instructions
    arm_cpsmode_type cps_mode;  // CPS mode for CPS instruction
    arm_cpsflag_type cps_flag;  // CPS mode for CPS instruction
    arm_cc cc;          // conditional code for this insn
    bool update_flags;  // does this insn update flags?
    bool writeback;     // does this insn write-back?
    arm_mem_barrier mem_barrier;    // Option for some memory barrier instructions

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_arm_op operands[36]; // operands for this instruction.
} cs_arm;

//> ARM instruction
typedef enum arm_insn
{
    ARM_INS_INVALID = 0,

    ARM_INS_ADC,
    ARM_INS_ADD,
    ARM_INS_ADR,
    ARM_INS_AESD,
    ARM_INS_AESE,
    ARM_INS_AESIMC,
    ARM_INS_AESMC,
    ARM_INS_AND,
    ARM_INS_BFC,
    ARM_INS_BFI,
    ARM_INS_BIC,
    ARM_INS_BKPT,
    ARM_INS_BL,
    ARM_INS_BLX,
    ARM_INS_BX,
    ARM_INS_BXJ,
    ARM_INS_B,
    ARM_INS_CDP,
    ARM_INS_CDP2,
    ARM_INS_CLREX,
    ARM_INS_CLZ,
    ARM_INS_CMN,
    ARM_INS_CMP,
    ARM_INS_CPS,
    ARM_INS_CRC32B,
    ARM_INS_CRC32CB,
    ARM_INS_CRC32CH,
    ARM_INS_CRC32CW,
    ARM_INS_CRC32H,
    ARM_INS_CRC32W,
    ARM_INS_DBG,
    ARM_INS_DMB,
    ARM_INS_DSB,
    ARM_INS_EOR,
    ARM_INS_ERET,
    ARM_INS_VMOV,
    ARM_INS_FLDMDBX,
    ARM_INS_FLDMIAX,
    ARM_INS_VMRS,
    ARM_INS_FSTMDBX,
    ARM_INS_FSTMIAX,
    ARM_INS_HINT,
    ARM_INS_HLT,
    ARM_INS_HVC,
    ARM_INS_ISB,
    ARM_INS_LDA,
    ARM_INS_LDAB,
    ARM_INS_LDAEX,
    ARM_INS_LDAEXB,
    ARM_INS_LDAEXD,
    ARM_INS_LDAEXH,
    ARM_INS_LDAH,
    ARM_INS_LDC2L,
    ARM_INS_LDC2,
    ARM_INS_LDCL,
    ARM_INS_LDC,
    ARM_INS_LDMDA,
    ARM_INS_LDMDB,
    ARM_INS_LDM,
    ARM_INS_LDMIB,
    ARM_INS_LDRBT,
    ARM_INS_LDRB,
    ARM_INS_LDRD,
    ARM_INS_LDREX,
    ARM_INS_LDREXB,
    ARM_INS_LDREXD,
    ARM_INS_LDREXH,
    ARM_INS_LDRH,
    ARM_INS_LDRHT,
    ARM_INS_LDRSB,
    ARM_INS_LDRSBT,
    ARM_INS_LDRSH,
    ARM_INS_LDRSHT,
    ARM_INS_LDRT,
    ARM_INS_LDR,
    ARM_INS_MCR,
    ARM_INS_MCR2,
    ARM_INS_MCRR,
    ARM_INS_MCRR2,
    ARM_INS_MLA,
    ARM_INS_MLS,
    ARM_INS_MOV,
    ARM_INS_MOVT,
    ARM_INS_MOVW,
    ARM_INS_MRC,
    ARM_INS_MRC2,
    ARM_INS_MRRC,
    ARM_INS_MRRC2,
    ARM_INS_MRS,
    ARM_INS_MSR,
    ARM_INS_MUL,
    ARM_INS_MVN,
    ARM_INS_ORR,
    ARM_INS_PKHBT,
    ARM_INS_PKHTB,
    ARM_INS_PLDW,
    ARM_INS_PLD,
    ARM_INS_PLI,
    ARM_INS_QADD,
    ARM_INS_QADD16,
    ARM_INS_QADD8,
    ARM_INS_QASX,
    ARM_INS_QDADD,
    ARM_INS_QDSUB,
    ARM_INS_QSAX,
    ARM_INS_QSUB,
    ARM_INS_QSUB16,
    ARM_INS_QSUB8,
    ARM_INS_RBIT,
    ARM_INS_REV,
    ARM_INS_REV16,
    ARM_INS_REVSH,
    ARM_INS_RFEDA,
    ARM_INS_RFEDB,
    ARM_INS_RFEIA,
    ARM_INS_RFEIB,
    ARM_INS_RSB,
    ARM_INS_RSC,
    ARM_INS_SADD16,
    ARM_INS_SADD8,
    ARM_INS_SASX,
    ARM_INS_SBC,
    ARM_INS_SBFX,
    ARM_INS_SDIV,
    ARM_INS_SEL,
    ARM_INS_SETEND,
    ARM_INS_SHA1C,
    ARM_INS_SHA1H,
    ARM_INS_SHA1M,
    ARM_INS_SHA1P,
    ARM_INS_SHA1SU0,
    ARM_INS_SHA1SU1,
    ARM_INS_SHA256H,
    ARM_INS_SHA256H2,
    ARM_INS_SHA256SU0,
    ARM_INS_SHA256SU1,
    ARM_INS_SHADD16,
    ARM_INS_SHADD8,
    ARM_INS_SHASX,
    ARM_INS_SHSAX,
    ARM_INS_SHSUB16,
    ARM_INS_SHSUB8,
    ARM_INS_SMC,
    ARM_INS_SMLABB,
    ARM_INS_SMLABT,
    ARM_INS_SMLAD,
    ARM_INS_SMLADX,
    ARM_INS_SMLAL,
    ARM_INS_SMLALBB,
    ARM_INS_SMLALBT,
    ARM_INS_SMLALD,
    ARM_INS_SMLALDX,
    ARM_INS_SMLALTB,
    ARM_INS_SMLALTT,
    ARM_INS_SMLATB,
    ARM_INS_SMLATT,
    ARM_INS_SMLAWB,
    ARM_INS_SMLAWT,
    ARM_INS_SMLSD,
    ARM_INS_SMLSDX,
    ARM_INS_SMLSLD,
    ARM_INS_SMLSLDX,
    ARM_INS_SMMLA,
    ARM_INS_SMMLAR,
    ARM_INS_SMMLS,
    ARM_INS_SMMLSR,
    ARM_INS_SMMUL,
    ARM_INS_SMMULR,
    ARM_INS_SMUAD,
    ARM_INS_SMUADX,
    ARM_INS_SMULBB,
    ARM_INS_SMULBT,
    ARM_INS_SMULL,
    ARM_INS_SMULTB,
    ARM_INS_SMULTT,
    ARM_INS_SMULWB,
    ARM_INS_SMULWT,
    ARM_INS_SMUSD,
    ARM_INS_SMUSDX,
    ARM_INS_SRSDA,
    ARM_INS_SRSDB,
    ARM_INS_SRSIA,
    ARM_INS_SRSIB,
    ARM_INS_SSAT,
    ARM_INS_SSAT16,
    ARM_INS_SSAX,
    ARM_INS_SSUB16,
    ARM_INS_SSUB8,
    ARM_INS_STC2L,
    ARM_INS_STC2,
    ARM_INS_STCL,
    ARM_INS_STC,
    ARM_INS_STL,
    ARM_INS_STLB,
    ARM_INS_STLEX,
    ARM_INS_STLEXB,
    ARM_INS_STLEXD,
    ARM_INS_STLEXH,
    ARM_INS_STLH,
    ARM_INS_STMDA,
    ARM_INS_STMDB,
    ARM_INS_STM,
    ARM_INS_STMIB,
    ARM_INS_STRBT,
    ARM_INS_STRB,
    ARM_INS_STRD,
    ARM_INS_STREX,
    ARM_INS_STREXB,
    ARM_INS_STREXD,
    ARM_INS_STREXH,
    ARM_INS_STRH,
    ARM_INS_STRHT,
    ARM_INS_STRT,
    ARM_INS_STR,
    ARM_INS_SUB,
    ARM_INS_SVC,
    ARM_INS_SWP,
    ARM_INS_SWPB,
    ARM_INS_SXTAB,
    ARM_INS_SXTAB16,
    ARM_INS_SXTAH,
    ARM_INS_SXTB,
    ARM_INS_SXTB16,
    ARM_INS_SXTH,
    ARM_INS_TEQ,
    ARM_INS_TRAP,
    ARM_INS_TST,
    ARM_INS_UADD16,
    ARM_INS_UADD8,
    ARM_INS_UASX,
    ARM_INS_UBFX,
    ARM_INS_UDF,
    ARM_INS_UDIV,
    ARM_INS_UHADD16,
    ARM_INS_UHADD8,
    ARM_INS_UHASX,
    ARM_INS_UHSAX,
    ARM_INS_UHSUB16,
    ARM_INS_UHSUB8,
    ARM_INS_UMAAL,
    ARM_INS_UMLAL,
    ARM_INS_UMULL,
    ARM_INS_UQADD16,
    ARM_INS_UQADD8,
    ARM_INS_UQASX,
    ARM_INS_UQSAX,
    ARM_INS_UQSUB16,
    ARM_INS_UQSUB8,
    ARM_INS_USAD8,
    ARM_INS_USADA8,
    ARM_INS_USAT,
    ARM_INS_USAT16,
    ARM_INS_USAX,
    ARM_INS_USUB16,
    ARM_INS_USUB8,
    ARM_INS_UXTAB,
    ARM_INS_UXTAB16,
    ARM_INS_UXTAH,
    ARM_INS_UXTB,
    ARM_INS_UXTB16,
    ARM_INS_UXTH,
    ARM_INS_VABAL,
    ARM_INS_VABA,
    ARM_INS_VABDL,
    ARM_INS_VABD,
    ARM_INS_VABS,
    ARM_INS_VACGE,
    ARM_INS_VACGT,
    ARM_INS_VADD,
    ARM_INS_VADDHN,
    ARM_INS_VADDL,
    ARM_INS_VADDW,
    ARM_INS_VAND,
    ARM_INS_VBIC,
    ARM_INS_VBIF,
    ARM_INS_VBIT,
    ARM_INS_VBSL,
    ARM_INS_VCEQ,
    ARM_INS_VCGE,
    ARM_INS_VCGT,
    ARM_INS_VCLE,
    ARM_INS_VCLS,
    ARM_INS_VCLT,
    ARM_INS_VCLZ,
    ARM_INS_VCMP,
    ARM_INS_VCMPE,
    ARM_INS_VCNT,
    ARM_INS_VCVTA,
    ARM_INS_VCVTB,
    ARM_INS_VCVT,
    ARM_INS_VCVTM,
    ARM_INS_VCVTN,
    ARM_INS_VCVTP,
    ARM_INS_VCVTT,
    ARM_INS_VDIV,
    ARM_INS_VDUP,
    ARM_INS_VEOR,
    ARM_INS_VEXT,
    ARM_INS_VFMA,
    ARM_INS_VFMS,
    ARM_INS_VFNMA,
    ARM_INS_VFNMS,
    ARM_INS_VHADD,
    ARM_INS_VHSUB,
    ARM_INS_VLD1,
    ARM_INS_VLD2,
    ARM_INS_VLD3,
    ARM_INS_VLD4,
    ARM_INS_VLDMDB,
    ARM_INS_VLDMIA,
    ARM_INS_VLDR,
    ARM_INS_VMAXNM,
    ARM_INS_VMAX,
    ARM_INS_VMINNM,
    ARM_INS_VMIN,
    ARM_INS_VMLA,
    ARM_INS_VMLAL,
    ARM_INS_VMLS,
    ARM_INS_VMLSL,
    ARM_INS_VMOVL,
    ARM_INS_VMOVN,
    ARM_INS_VMSR,
    ARM_INS_VMUL,
    ARM_INS_VMULL,
    ARM_INS_VMVN,
    ARM_INS_VNEG,
    ARM_INS_VNMLA,
    ARM_INS_VNMLS,
    ARM_INS_VNMUL,
    ARM_INS_VORN,
    ARM_INS_VORR,
    ARM_INS_VPADAL,
    ARM_INS_VPADDL,
    ARM_INS_VPADD,
    ARM_INS_VPMAX,
    ARM_INS_VPMIN,
    ARM_INS_VQABS,
    ARM_INS_VQADD,
    ARM_INS_VQDMLAL,
    ARM_INS_VQDMLSL,
    ARM_INS_VQDMULH,
    ARM_INS_VQDMULL,
    ARM_INS_VQMOVUN,
    ARM_INS_VQMOVN,
    ARM_INS_VQNEG,
    ARM_INS_VQRDMULH,
    ARM_INS_VQRSHL,
    ARM_INS_VQRSHRN,
    ARM_INS_VQRSHRUN,
    ARM_INS_VQSHL,
    ARM_INS_VQSHLU,
    ARM_INS_VQSHRN,
    ARM_INS_VQSHRUN,
    ARM_INS_VQSUB,
    ARM_INS_VRADDHN,
    ARM_INS_VRECPE,
    ARM_INS_VRECPS,
    ARM_INS_VREV16,
    ARM_INS_VREV32,
    ARM_INS_VREV64,
    ARM_INS_VRHADD,
    ARM_INS_VRINTA,
    ARM_INS_VRINTM,
    ARM_INS_VRINTN,
    ARM_INS_VRINTP,
    ARM_INS_VRINTR,
    ARM_INS_VRINTX,
    ARM_INS_VRINTZ,
    ARM_INS_VRSHL,
    ARM_INS_VRSHRN,
    ARM_INS_VRSHR,
    ARM_INS_VRSQRTE,
    ARM_INS_VRSQRTS,
    ARM_INS_VRSRA,
    ARM_INS_VRSUBHN,
    ARM_INS_VSELEQ,
    ARM_INS_VSELGE,
    ARM_INS_VSELGT,
    ARM_INS_VSELVS,
    ARM_INS_VSHLL,
    ARM_INS_VSHL,
    ARM_INS_VSHRN,
    ARM_INS_VSHR,
    ARM_INS_VSLI,
    ARM_INS_VSQRT,
    ARM_INS_VSRA,
    ARM_INS_VSRI,
    ARM_INS_VST1,
    ARM_INS_VST2,
    ARM_INS_VST3,
    ARM_INS_VST4,
    ARM_INS_VSTMDB,
    ARM_INS_VSTMIA,
    ARM_INS_VSTR,
    ARM_INS_VSUB,
    ARM_INS_VSUBHN,
    ARM_INS_VSUBL,
    ARM_INS_VSUBW,
    ARM_INS_VSWP,
    ARM_INS_VTBL,
    ARM_INS_VTBX,
    ARM_INS_VCVTR,
    ARM_INS_VTRN,
    ARM_INS_VTST,
    ARM_INS_VUZP,
    ARM_INS_VZIP,
    ARM_INS_ADDW,
    ARM_INS_ASR,
    ARM_INS_DCPS1,
    ARM_INS_DCPS2,
    ARM_INS_DCPS3,
    ARM_INS_IT,
    ARM_INS_LSL,
    ARM_INS_LSR,
    ARM_INS_ORN,
    ARM_INS_ROR,
    ARM_INS_RRX,
    ARM_INS_SUBW,
    ARM_INS_TBB,
    ARM_INS_TBH,
    ARM_INS_CBNZ,
    ARM_INS_CBZ,
    ARM_INS_POP,
    ARM_INS_PUSH,

    // special instructions
    ARM_INS_NOP,
    ARM_INS_YIELD,
    ARM_INS_WFE,
    ARM_INS_WFI,
    ARM_INS_SEV,
    ARM_INS_SEVL,
    ARM_INS_VPUSH,
    ARM_INS_VPOP,

    ARM_INS_ENDING, // <-- mark the end of the list of instructions
} arm_insn;

//> Group of ARM instructions
typedef enum arm_insn_group
{
    ARM_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    ARM_GRP_JUMP,   // = CS_GRP_JUMP
    ARM_GRP_CALL,   // = CS_GRP_CALL
    ARM_GRP_INT = 4, // = CS_GRP_INT
    ARM_GRP_PRIVILEGE = 6, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    ARM_GRP_CRYPTO = 128,
    ARM_GRP_DATABARRIER,
    ARM_GRP_DIVIDE,
    ARM_GRP_FPARMV8,
    ARM_GRP_MULTPRO,
    ARM_GRP_NEON,
    ARM_GRP_T2EXTRACTPACK,
    ARM_GRP_THUMB2DSP,
    ARM_GRP_TRUSTZONE,
    ARM_GRP_V4T,
    ARM_GRP_V5T,
    ARM_GRP_V5TE,
    ARM_GRP_V6,
    ARM_GRP_V6T2,
    ARM_GRP_V7,
    ARM_GRP_V8,
    ARM_GRP_VFP2,
    ARM_GRP_VFP3,
    ARM_GRP_VFP4,
    ARM_GRP_ARM,
    ARM_GRP_MCLASS,
    ARM_GRP_NOTMCLASS,
    ARM_GRP_THUMB,
    ARM_GRP_THUMB1ONLY,
    ARM_GRP_THUMB2,
    ARM_GRP_PREV8,
    ARM_GRP_FPVMLX,
    ARM_GRP_MULOPS,
    ARM_GRP_CRC,
    ARM_GRP_DPVFP,
    ARM_GRP_V6M,
    ARM_GRP_VIRTUALIZATION,

    ARM_GRP_ENDING,
} arm_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/arm64.h
================================================
#ifndef CAPSTONE_ARM64_H
#define CAPSTONE_ARM64_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM64 shift type
typedef enum arm64_shifter
{
    ARM64_SFT_INVALID = 0,
    ARM64_SFT_LSL = 1,
    ARM64_SFT_MSL = 2,
    ARM64_SFT_LSR = 3,
    ARM64_SFT_ASR = 4,
    ARM64_SFT_ROR = 5,
} arm64_shifter;

//> ARM64 extender type
typedef enum arm64_extender
{
    ARM64_EXT_INVALID = 0,
    ARM64_EXT_UXTB = 1,
    ARM64_EXT_UXTH = 2,
    ARM64_EXT_UXTW = 3,
    ARM64_EXT_UXTX = 4,
    ARM64_EXT_SXTB = 5,
    ARM64_EXT_SXTH = 6,
    ARM64_EXT_SXTW = 7,
    ARM64_EXT_SXTX = 8,
} arm64_extender;

//> ARM64 condition code
typedef enum arm64_cc
{
    ARM64_CC_INVALID = 0,
    ARM64_CC_EQ = 1,     // Equal
    ARM64_CC_NE = 2,     // Not equal:                 Not equal, or unordered
    ARM64_CC_HS = 3,     // Unsigned higher or same:   >, ==, or unordered
    ARM64_CC_LO = 4,     // Unsigned lower or same:    Less than
    ARM64_CC_MI = 5,     // Minus, negative:           Less than
    ARM64_CC_PL = 6,     // Plus, positive or zero:    >, ==, or unordered
    ARM64_CC_VS = 7,     // Overflow:                  Unordered
    ARM64_CC_VC = 8,     // No overflow:               Ordered
    ARM64_CC_HI = 9,     // Unsigned higher:           Greater than, or unordered
    ARM64_CC_LS = 10,     // Unsigned lower or same:    Less than or equal
    ARM64_CC_GE = 11,     // Greater than or equal:     Greater than or equal
    ARM64_CC_LT = 12,     // Less than:                 Less than, or unordered
    ARM64_CC_GT = 13,     // Signed greater than:       Greater than
    ARM64_CC_LE = 14,     // Signed less than or equal: <, ==, or unordered
    ARM64_CC_AL = 15,     // Always (unconditional):    Always (unconditional)
    ARM64_CC_NV = 16,     // Always (unconditional):   Always (unconditional)
    // Note the NV exists purely to disassemble 0b1111. Execution
    // is "always".
} arm64_cc;

//> System registers
typedef enum arm64_mrs_reg
{
    //> System registers for MRS
    ARM64_SYSREG_INVALID           = 0,
    ARM64_SYSREG_MDCCSR_EL0        = 0x9808, // 10  011  0000  0001  000
    ARM64_SYSREG_DBGDTRRX_EL0      = 0x9828, // 10  011  0000  0101  000
    ARM64_SYSREG_MDRAR_EL1         = 0x8080, // 10  000  0001  0000  000
    ARM64_SYSREG_OSLSR_EL1         = 0x808c, // 10  000  0001  0001  100
    ARM64_SYSREG_DBGAUTHSTATUS_EL1 = 0x83f6, // 10  000  0111  1110  110
    ARM64_SYSREG_PMCEID0_EL0       = 0xdce6, // 11  011  1001  1100  110
    ARM64_SYSREG_PMCEID1_EL0       = 0xdce7, // 11  011  1001  1100  111
    ARM64_SYSREG_MIDR_EL1          = 0xc000, // 11  000  0000  0000  000
    ARM64_SYSREG_CCSIDR_EL1        = 0xc800, // 11  001  0000  0000  000
    ARM64_SYSREG_CLIDR_EL1         = 0xc801, // 11  001  0000  0000  001
    ARM64_SYSREG_CTR_EL0           = 0xd801, // 11  011  0000  0000  001
    ARM64_SYSREG_MPIDR_EL1         = 0xc005, // 11  000  0000  0000  101
    ARM64_SYSREG_REVIDR_EL1        = 0xc006, // 11  000  0000  0000  110
    ARM64_SYSREG_AIDR_EL1          = 0xc807, // 11  001  0000  0000  111
    ARM64_SYSREG_DCZID_EL0         = 0xd807, // 11  011  0000  0000  111
    ARM64_SYSREG_ID_PFR0_EL1       = 0xc008, // 11  000  0000  0001  000
    ARM64_SYSREG_ID_PFR1_EL1       = 0xc009, // 11  000  0000  0001  001
    ARM64_SYSREG_ID_DFR0_EL1       = 0xc00a, // 11  000  0000  0001  010
    ARM64_SYSREG_ID_AFR0_EL1       = 0xc00b, // 11  000  0000  0001  011
    ARM64_SYSREG_ID_MMFR0_EL1      = 0xc00c, // 11  000  0000  0001  100
    ARM64_SYSREG_ID_MMFR1_EL1      = 0xc00d, // 11  000  0000  0001  101
    ARM64_SYSREG_ID_MMFR2_EL1      = 0xc00e, // 11  000  0000  0001  110
    ARM64_SYSREG_ID_MMFR3_EL1      = 0xc00f, // 11  000  0000  0001  111
    ARM64_SYSREG_ID_ISAR0_EL1      = 0xc010, // 11  000  0000  0010  000
    ARM64_SYSREG_ID_ISAR1_EL1      = 0xc011, // 11  000  0000  0010  001
    ARM64_SYSREG_ID_ISAR2_EL1      = 0xc012, // 11  000  0000  0010  010
    ARM64_SYSREG_ID_ISAR3_EL1      = 0xc013, // 11  000  0000  0010  011
    ARM64_SYSREG_ID_ISAR4_EL1      = 0xc014, // 11  000  0000  0010  100
    ARM64_SYSREG_ID_ISAR5_EL1      = 0xc015, // 11  000  0000  0010  101
    ARM64_SYSREG_ID_A64PFR0_EL1   = 0xc020, // 11  000  0000  0100  000
    ARM64_SYSREG_ID_A64PFR1_EL1   = 0xc021, // 11  000  0000  0100  001
    ARM64_SYSREG_ID_A64DFR0_EL1   = 0xc028, // 11  000  0000  0101  000
    ARM64_SYSREG_ID_A64DFR1_EL1   = 0xc029, // 11  000  0000  0101  001
    ARM64_SYSREG_ID_A64AFR0_EL1   = 0xc02c, // 11  000  0000  0101  100
    ARM64_SYSREG_ID_A64AFR1_EL1   = 0xc02d, // 11  000  0000  0101  101
    ARM64_SYSREG_ID_A64ISAR0_EL1  = 0xc030, // 11  000  0000  0110  000
    ARM64_SYSREG_ID_A64ISAR1_EL1  = 0xc031, // 11  000  0000  0110  001
    ARM64_SYSREG_ID_A64MMFR0_EL1  = 0xc038, // 11  000  0000  0111  000
    ARM64_SYSREG_ID_A64MMFR1_EL1  = 0xc039, // 11  000  0000  0111  001
    ARM64_SYSREG_MVFR0_EL1         = 0xc018, // 11  000  0000  0011  000
    ARM64_SYSREG_MVFR1_EL1         = 0xc019, // 11  000  0000  0011  001
    ARM64_SYSREG_MVFR2_EL1         = 0xc01a, // 11  000  0000  0011  010
    ARM64_SYSREG_RVBAR_EL1         = 0xc601, // 11  000  1100  0000  001
    ARM64_SYSREG_RVBAR_EL2         = 0xe601, // 11  100  1100  0000  001
    ARM64_SYSREG_RVBAR_EL3         = 0xf601, // 11  110  1100  0000  001
    ARM64_SYSREG_ISR_EL1           = 0xc608, // 11  000  1100  0001  000
    ARM64_SYSREG_CNTPCT_EL0        = 0xdf01, // 11  011  1110  0000  001
    ARM64_SYSREG_CNTVCT_EL0        = 0xdf02,  // 11  011  1110  0000  010

    // Trace registers
    ARM64_SYSREG_TRCSTATR          = 0x8818, // 10  001  0000  0011  000
    ARM64_SYSREG_TRCIDR8           = 0x8806, // 10  001  0000  0000  110
    ARM64_SYSREG_TRCIDR9           = 0x880e, // 10  001  0000  0001  110
    ARM64_SYSREG_TRCIDR10          = 0x8816, // 10  001  0000  0010  110
    ARM64_SYSREG_TRCIDR11          = 0x881e, // 10  001  0000  0011  110
    ARM64_SYSREG_TRCIDR12          = 0x8826, // 10  001  0000  0100  110
    ARM64_SYSREG_TRCIDR13          = 0x882e, // 10  001  0000  0101  110
    ARM64_SYSREG_TRCIDR0           = 0x8847, // 10  001  0000  1000  111
    ARM64_SYSREG_TRCIDR1           = 0x884f, // 10  001  0000  1001  111
    ARM64_SYSREG_TRCIDR2           = 0x8857, // 10  001  0000  1010  111
    ARM64_SYSREG_TRCIDR3           = 0x885f, // 10  001  0000  1011  111
    ARM64_SYSREG_TRCIDR4           = 0x8867, // 10  001  0000  1100  111
    ARM64_SYSREG_TRCIDR5           = 0x886f, // 10  001  0000  1101  111
    ARM64_SYSREG_TRCIDR6           = 0x8877, // 10  001  0000  1110  111
    ARM64_SYSREG_TRCIDR7           = 0x887f, // 10  001  0000  1111  111
    ARM64_SYSREG_TRCOSLSR          = 0x888c, // 10  001  0001  0001  100
    ARM64_SYSREG_TRCPDSR           = 0x88ac, // 10  001  0001  0101  100
    ARM64_SYSREG_TRCDEVAFF0        = 0x8bd6, // 10  001  0111  1010  110
    ARM64_SYSREG_TRCDEVAFF1        = 0x8bde, // 10  001  0111  1011  110
    ARM64_SYSREG_TRCLSR            = 0x8bee, // 10  001  0111  1101  110
    ARM64_SYSREG_TRCAUTHSTATUS     = 0x8bf6, // 10  001  0111  1110  110
    ARM64_SYSREG_TRCDEVARCH        = 0x8bfe, // 10  001  0111  1111  110
    ARM64_SYSREG_TRCDEVID          = 0x8b97, // 10  001  0111  0010  111
    ARM64_SYSREG_TRCDEVTYPE        = 0x8b9f, // 10  001  0111  0011  111
    ARM64_SYSREG_TRCPIDR4          = 0x8ba7, // 10  001  0111  0100  111
    ARM64_SYSREG_TRCPIDR5          = 0x8baf, // 10  001  0111  0101  111
    ARM64_SYSREG_TRCPIDR6          = 0x8bb7, // 10  001  0111  0110  111
    ARM64_SYSREG_TRCPIDR7          = 0x8bbf, // 10  001  0111  0111  111
    ARM64_SYSREG_TRCPIDR0          = 0x8bc7, // 10  001  0111  1000  111
    ARM64_SYSREG_TRCPIDR1          = 0x8bcf, // 10  001  0111  1001  111
    ARM64_SYSREG_TRCPIDR2          = 0x8bd7, // 10  001  0111  1010  111
    ARM64_SYSREG_TRCPIDR3          = 0x8bdf, // 10  001  0111  1011  111
    ARM64_SYSREG_TRCCIDR0          = 0x8be7, // 10  001  0111  1100  111
    ARM64_SYSREG_TRCCIDR1          = 0x8bef, // 10  001  0111  1101  111
    ARM64_SYSREG_TRCCIDR2          = 0x8bf7, // 10  001  0111  1110  111
    ARM64_SYSREG_TRCCIDR3          = 0x8bff, // 10  001  0111  1111  111

    // GICv3 registers
    ARM64_SYSREG_ICC_IAR1_EL1      = 0xc660, // 11  000  1100  1100  000
    ARM64_SYSREG_ICC_IAR0_EL1      = 0xc640, // 11  000  1100  1000  000
    ARM64_SYSREG_ICC_HPPIR1_EL1    = 0xc662, // 11  000  1100  1100  010
    ARM64_SYSREG_ICC_HPPIR0_EL1    = 0xc642, // 11  000  1100  1000  010
    ARM64_SYSREG_ICC_RPR_EL1       = 0xc65b, // 11  000  1100  1011  011
    ARM64_SYSREG_ICH_VTR_EL2       = 0xe659, // 11  100  1100  1011  001
    ARM64_SYSREG_ICH_EISR_EL2      = 0xe65b, // 11  100  1100  1011  011
    ARM64_SYSREG_ICH_ELSR_EL2      = 0xe65d, // 11  100  1100  1011  101
} arm64_sysreg;

typedef enum arm64_msr_reg
{
    //> System registers for MSR
    ARM64_SYSREG_DBGDTRTX_EL0      = 0x9828, // 10  011  0000  0101  000
    ARM64_SYSREG_OSLAR_EL1         = 0x8084, // 10  000  0001  0000  100
    ARM64_SYSREG_PMSWINC_EL0       = 0xdce4,  // 11  011  1001  1100  100

    // Trace Registers
    ARM64_SYSREG_TRCOSLAR          = 0x8884, // 10  001  0001  0000  100
    ARM64_SYSREG_TRCLAR            = 0x8be6, // 10  001  0111  1100  110

    // GICv3 registers
    ARM64_SYSREG_ICC_EOIR1_EL1     = 0xc661, // 11  000  1100  1100  001
    ARM64_SYSREG_ICC_EOIR0_EL1     = 0xc641, // 11  000  1100  1000  001
    ARM64_SYSREG_ICC_DIR_EL1       = 0xc659, // 11  000  1100  1011  001
    ARM64_SYSREG_ICC_SGI1R_EL1     = 0xc65d, // 11  000  1100  1011  101
    ARM64_SYSREG_ICC_ASGI1R_EL1    = 0xc65e, // 11  000  1100  1011  110
    ARM64_SYSREG_ICC_SGI0R_EL1     = 0xc65f, // 11  000  1100  1011  111
} arm64_msr_reg;

//> System PState Field (MSR instruction)
typedef enum arm64_pstate
{
    ARM64_PSTATE_INVALID = 0,
    ARM64_PSTATE_SPSEL = 0x05,
    ARM64_PSTATE_DAIFSET = 0x1e,
    ARM64_PSTATE_DAIFCLR = 0x1f
} arm64_pstate;

//> Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)
typedef enum arm64_vas
{
    ARM64_VAS_INVALID = 0,
    ARM64_VAS_8B,
    ARM64_VAS_16B,
    ARM64_VAS_4H,
    ARM64_VAS_8H,
    ARM64_VAS_2S,
    ARM64_VAS_4S,
    ARM64_VAS_1D,
    ARM64_VAS_2D,
    ARM64_VAS_1Q,
} arm64_vas;

//> Vector element size specifier
typedef enum arm64_vess
{
    ARM64_VESS_INVALID = 0,
    ARM64_VESS_B,
    ARM64_VESS_H,
    ARM64_VESS_S,
    ARM64_VESS_D,
} arm64_vess;

//> Memory barrier operands
typedef enum arm64_barrier_op
{
    ARM64_BARRIER_INVALID = 0,
    ARM64_BARRIER_OSHLD = 0x1,
    ARM64_BARRIER_OSHST = 0x2,
    ARM64_BARRIER_OSH =   0x3,
    ARM64_BARRIER_NSHLD = 0x5,
    ARM64_BARRIER_NSHST = 0x6,
    ARM64_BARRIER_NSH =   0x7,
    ARM64_BARRIER_ISHLD = 0x9,
    ARM64_BARRIER_ISHST = 0xa,
    ARM64_BARRIER_ISH =   0xb,
    ARM64_BARRIER_LD =    0xd,
    ARM64_BARRIER_ST =    0xe,
    ARM64_BARRIER_SY =    0xf
} arm64_barrier_op;

//> Operand type for instruction's operands
typedef enum arm64_op_type
{
    ARM64_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    ARM64_OP_REG, // = CS_OP_REG (Register operand).
    ARM64_OP_IMM, // = CS_OP_IMM (Immediate operand).
    ARM64_OP_MEM, // = CS_OP_MEM (Memory operand).
    ARM64_OP_FP,  // = CS_OP_FP (Floating-Point operand).
    ARM64_OP_CIMM = 64, // C-Immediate
    ARM64_OP_REG_MRS, // MRS register operand.
    ARM64_OP_REG_MSR, // MSR register operand.
    ARM64_OP_PSTATE, // PState operand.
    ARM64_OP_SYS, // SYS operand for IC/DC/AT/TLBI instructions.
    ARM64_OP_PREFETCH, // Prefetch operand (PRFM).
    ARM64_OP_BARRIER, // Memory barrier operand (ISB/DMB/DSB instructions).
} arm64_op_type;

//> TLBI operations
typedef enum arm64_tlbi_op
{
    ARM64_TLBI_INVALID = 0,
    ARM64_TLBI_VMALLE1IS,
    ARM64_TLBI_VAE1IS,
    ARM64_TLBI_ASIDE1IS,
    ARM64_TLBI_VAAE1IS,
    ARM64_TLBI_VALE1IS,
    ARM64_TLBI_VAALE1IS,
    ARM64_TLBI_ALLE2IS,
    ARM64_TLBI_VAE2IS,
    ARM64_TLBI_ALLE1IS,
    ARM64_TLBI_VALE2IS,
    ARM64_TLBI_VMALLS12E1IS,
    ARM64_TLBI_ALLE3IS,
    ARM64_TLBI_VAE3IS,
    ARM64_TLBI_VALE3IS,
    ARM64_TLBI_IPAS2E1IS,
    ARM64_TLBI_IPAS2LE1IS,
    ARM64_TLBI_IPAS2E1,
    ARM64_TLBI_IPAS2LE1,
    ARM64_TLBI_VMALLE1,
    ARM64_TLBI_VAE1,
    ARM64_TLBI_ASIDE1,
    ARM64_TLBI_VAAE1,
    ARM64_TLBI_VALE1,
    ARM64_TLBI_VAALE1,
    ARM64_TLBI_ALLE2,
    ARM64_TLBI_VAE2,
    ARM64_TLBI_ALLE1,
    ARM64_TLBI_VALE2,
    ARM64_TLBI_VMALLS12E1,
    ARM64_TLBI_ALLE3,
    ARM64_TLBI_VAE3,
    ARM64_TLBI_VALE3,
} arm64_tlbi_op;

//> AT operations
typedef enum arm64_at_op
{
    ARM64_AT_S1E1R,
    ARM64_AT_S1E1W,
    ARM64_AT_S1E0R,
    ARM64_AT_S1E0W,
    ARM64_AT_S1E2R,
    ARM64_AT_S1E2W,
    ARM64_AT_S12E1R,
    ARM64_AT_S12E1W,
    ARM64_AT_S12E0R,
    ARM64_AT_S12E0W,
    ARM64_AT_S1E3R,
    ARM64_AT_S1E3W,
} arm64_at_op;

//> DC operations
typedef enum arm64_dc_op
{
    ARM64_DC_INVALID = 0,
    ARM64_DC_ZVA,
    ARM64_DC_IVAC,
    ARM64_DC_ISW,
    ARM64_DC_CVAC,
    ARM64_DC_CSW,
    ARM64_DC_CVAU,
    ARM64_DC_CIVAC,
    ARM64_DC_CISW,
} arm64_dc_op;

//> IC operations
typedef enum arm64_ic_op
{
    ARM64_IC_INVALID = 0,
    ARM64_IC_IALLUIS,
    ARM64_IC_IALLU,
    ARM64_IC_IVAU,
} arm64_ic_op;

//> Prefetch operations (PRFM)
typedef enum arm64_prefetch_op
{
    ARM64_PRFM_INVALID = 0,
    ARM64_PRFM_PLDL1KEEP = 0x00 + 1,
    ARM64_PRFM_PLDL1STRM = 0x01 + 1,
    ARM64_PRFM_PLDL2KEEP = 0x02 + 1,
    ARM64_PRFM_PLDL2STRM = 0x03 + 1,
    ARM64_PRFM_PLDL3KEEP = 0x04 + 1,
    ARM64_PRFM_PLDL3STRM = 0x05 + 1,
    ARM64_PRFM_PLIL1KEEP = 0x08 + 1,
    ARM64_PRFM_PLIL1STRM = 0x09 + 1,
    ARM64_PRFM_PLIL2KEEP = 0x0a + 1,
    ARM64_PRFM_PLIL2STRM = 0x0b + 1,
    ARM64_PRFM_PLIL3KEEP = 0x0c + 1,
    ARM64_PRFM_PLIL3STRM = 0x0d + 1,
    ARM64_PRFM_PSTL1KEEP = 0x10 + 1,
    ARM64_PRFM_PSTL1STRM = 0x11 + 1,
    ARM64_PRFM_PSTL2KEEP = 0x12 + 1,
    ARM64_PRFM_PSTL2STRM = 0x13 + 1,
    ARM64_PRFM_PSTL3KEEP = 0x14 + 1,
    ARM64_PRFM_PSTL3STRM = 0x15 + 1,
} arm64_prefetch_op;


//> ARM64 registers
typedef enum arm64_reg
{
    ARM64_REG_INVALID = 0,

    ARM64_REG_X29,
    ARM64_REG_X30,
    ARM64_REG_NZCV,
    ARM64_REG_SP,
    ARM64_REG_WSP,
    ARM64_REG_WZR,
    ARM64_REG_XZR,
    ARM64_REG_B0,
    ARM64_REG_B1,
    ARM64_REG_B2,
    ARM64_REG_B3,
    ARM64_REG_B4,
    ARM64_REG_B5,
    ARM64_REG_B6,
    ARM64_REG_B7,
    ARM64_REG_B8,
    ARM64_REG_B9,
    ARM64_REG_B10,
    ARM64_REG_B11,
    ARM64_REG_B12,
    ARM64_REG_B13,
    ARM64_REG_B14,
    ARM64_REG_B15,
    ARM64_REG_B16,
    ARM64_REG_B17,
    ARM64_REG_B18,
    ARM64_REG_B19,
    ARM64_REG_B20,
    ARM64_REG_B21,
    ARM64_REG_B22,
    ARM64_REG_B23,
    ARM64_REG_B24,
    ARM64_REG_B25,
    ARM64_REG_B26,
    ARM64_REG_B27,
    ARM64_REG_B28,
    ARM64_REG_B29,
    ARM64_REG_B30,
    ARM64_REG_B31,
    ARM64_REG_D0,
    ARM64_REG_D1,
    ARM64_REG_D2,
    ARM64_REG_D3,
    ARM64_REG_D4,
    ARM64_REG_D5,
    ARM64_REG_D6,
    ARM64_REG_D7,
    ARM64_REG_D8,
    ARM64_REG_D9,
    ARM64_REG_D10,
    ARM64_REG_D11,
    ARM64_REG_D12,
    ARM64_REG_D13,
    ARM64_REG_D14,
    ARM64_REG_D15,
    ARM64_REG_D16,
    ARM64_REG_D17,
    ARM64_REG_D18,
    ARM64_REG_D19,
    ARM64_REG_D20,
    ARM64_REG_D21,
    ARM64_REG_D22,
    ARM64_REG_D23,
    ARM64_REG_D24,
    ARM64_REG_D25,
    ARM64_REG_D26,
    ARM64_REG_D27,
    ARM64_REG_D28,
    ARM64_REG_D29,
    ARM64_REG_D30,
    ARM64_REG_D31,
    ARM64_REG_H0,
    ARM64_REG_H1,
    ARM64_REG_H2,
    ARM64_REG_H3,
    ARM64_REG_H4,
    ARM64_REG_H5,
    ARM64_REG_H6,
    ARM64_REG_H7,
    ARM64_REG_H8,
    ARM64_REG_H9,
    ARM64_REG_H10,
    ARM64_REG_H11,
    ARM64_REG_H12,
    ARM64_REG_H13,
    ARM64_REG_H14,
    ARM64_REG_H15,
    ARM64_REG_H16,
    ARM64_REG_H17,
    ARM64_REG_H18,
    ARM64_REG_H19,
    ARM64_REG_H20,
    ARM64_REG_H21,
    ARM64_REG_H22,
    ARM64_REG_H23,
    ARM64_REG_H24,
    ARM64_REG_H25,
    ARM64_REG_H26,
    ARM64_REG_H27,
    ARM64_REG_H28,
    ARM64_REG_H29,
    ARM64_REG_H30,
    ARM64_REG_H31,
    ARM64_REG_Q0,
    ARM64_REG_Q1,
    ARM64_REG_Q2,
    ARM64_REG_Q3,
    ARM64_REG_Q4,
    ARM64_REG_Q5,
    ARM64_REG_Q6,
    ARM64_REG_Q7,
    ARM64_REG_Q8,
    ARM64_REG_Q9,
    ARM64_REG_Q10,
    ARM64_REG_Q11,
    ARM64_REG_Q12,
    ARM64_REG_Q13,
    ARM64_REG_Q14,
    ARM64_REG_Q15,
    ARM64_REG_Q16,
    ARM64_REG_Q17,
    ARM64_REG_Q18,
    ARM64_REG_Q19,
    ARM64_REG_Q20,
    ARM64_REG_Q21,
    ARM64_REG_Q22,
    ARM64_REG_Q23,
    ARM64_REG_Q24,
    ARM64_REG_Q25,
    ARM64_REG_Q26,
    ARM64_REG_Q27,
    ARM64_REG_Q28,
    ARM64_REG_Q29,
    ARM64_REG_Q30,
    ARM64_REG_Q31,
    ARM64_REG_S0,
    ARM64_REG_S1,
    ARM64_REG_S2,
    ARM64_REG_S3,
    ARM64_REG_S4,
    ARM64_REG_S5,
    ARM64_REG_S6,
    ARM64_REG_S7,
    ARM64_REG_S8,
    ARM64_REG_S9,
    ARM64_REG_S10,
    ARM64_REG_S11,
    ARM64_REG_S12,
    ARM64_REG_S13,
    ARM64_REG_S14,
    ARM64_REG_S15,
    ARM64_REG_S16,
    ARM64_REG_S17,
    ARM64_REG_S18,
    ARM64_REG_S19,
    ARM64_REG_S20,
    ARM64_REG_S21,
    ARM64_REG_S22,
    ARM64_REG_S23,
    ARM64_REG_S24,
    ARM64_REG_S25,
    ARM64_REG_S26,
    ARM64_REG_S27,
    ARM64_REG_S28,
    ARM64_REG_S29,
    ARM64_REG_S30,
    ARM64_REG_S31,
    ARM64_REG_W0,
    ARM64_REG_W1,
    ARM64_REG_W2,
    ARM64_REG_W3,
    ARM64_REG_W4,
    ARM64_REG_W5,
    ARM64_REG_W6,
    ARM64_REG_W7,
    ARM64_REG_W8,
    ARM64_REG_W9,
    ARM64_REG_W10,
    ARM64_REG_W11,
    ARM64_REG_W12,
    ARM64_REG_W13,
    ARM64_REG_W14,
    ARM64_REG_W15,
    ARM64_REG_W16,
    ARM64_REG_W17,
    ARM64_REG_W18,
    ARM64_REG_W19,
    ARM64_REG_W20,
    ARM64_REG_W21,
    ARM64_REG_W22,
    ARM64_REG_W23,
    ARM64_REG_W24,
    ARM64_REG_W25,
    ARM64_REG_W26,
    ARM64_REG_W27,
    ARM64_REG_W28,
    ARM64_REG_W29,
    ARM64_REG_W30,
    ARM64_REG_X0,
    ARM64_REG_X1,
    ARM64_REG_X2,
    ARM64_REG_X3,
    ARM64_REG_X4,
    ARM64_REG_X5,
    ARM64_REG_X6,
    ARM64_REG_X7,
    ARM64_REG_X8,
    ARM64_REG_X9,
    ARM64_REG_X10,
    ARM64_REG_X11,
    ARM64_REG_X12,
    ARM64_REG_X13,
    ARM64_REG_X14,
    ARM64_REG_X15,
    ARM64_REG_X16,
    ARM64_REG_X17,
    ARM64_REG_X18,
    ARM64_REG_X19,
    ARM64_REG_X20,
    ARM64_REG_X21,
    ARM64_REG_X22,
    ARM64_REG_X23,
    ARM64_REG_X24,
    ARM64_REG_X25,
    ARM64_REG_X26,
    ARM64_REG_X27,
    ARM64_REG_X28,

    ARM64_REG_V0,
    ARM64_REG_V1,
    ARM64_REG_V2,
    ARM64_REG_V3,
    ARM64_REG_V4,
    ARM64_REG_V5,
    ARM64_REG_V6,
    ARM64_REG_V7,
    ARM64_REG_V8,
    ARM64_REG_V9,
    ARM64_REG_V10,
    ARM64_REG_V11,
    ARM64_REG_V12,
    ARM64_REG_V13,
    ARM64_REG_V14,
    ARM64_REG_V15,
    ARM64_REG_V16,
    ARM64_REG_V17,
    ARM64_REG_V18,
    ARM64_REG_V19,
    ARM64_REG_V20,
    ARM64_REG_V21,
    ARM64_REG_V22,
    ARM64_REG_V23,
    ARM64_REG_V24,
    ARM64_REG_V25,
    ARM64_REG_V26,
    ARM64_REG_V27,
    ARM64_REG_V28,
    ARM64_REG_V29,
    ARM64_REG_V30,
    ARM64_REG_V31,

    ARM64_REG_ENDING,       // <-- mark the end of the list of registers

    //> alias registers

    ARM64_REG_IP1 = ARM64_REG_X16,
    ARM64_REG_IP0 = ARM64_REG_X17,
    ARM64_REG_FP = ARM64_REG_X29,
    ARM64_REG_LR = ARM64_REG_X30,
} arm64_reg;

// Instruction's operand referring to memory
// This is associated with ARM64_OP_MEM operand type above
typedef struct arm64_op_mem
{
    arm64_reg base; // base register
    arm64_reg index;    // index register
    int32_t disp;   // displacement/offset value
} arm64_op_mem;

// Instruction operand
typedef struct cs_arm64_op
{
    int vector_index;   // Vector Index for some vector operands (or -1 if irrelevant)
    arm64_vas vas;      // Vector Arrangement Specifier
    arm64_vess vess;    // Vector Element Size Specifier
    struct
    {
        arm64_shifter type; // shifter type of this operand
        unsigned int value; // shifter value of this operand
    } shift;
    arm64_extender ext;     // extender type of this operand
    arm64_op_type type; // operand type
    union
    {
        arm64_reg reg;  // register value for REG operand
        int64_t imm;        // immediate value, or index for C-IMM or IMM operand
        double fp;          // floating point value for FP operand
        arm64_op_mem mem;       // base/index/scale/disp value for MEM operand
        arm64_pstate pstate;        // PState field of MSR instruction.
        unsigned int sys;  // IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)
        arm64_prefetch_op prefetch;  // PRFM operation.
        arm64_barrier_op barrier;  // Memory barrier operation (ISB/DMB/DSB instructions).
    };

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;
} cs_arm64_op;

// Instruction structure
typedef struct cs_arm64
{
    arm64_cc cc;    // conditional code for this insn
    bool update_flags;  // does this insn update flags?
    bool writeback; // does this insn request writeback? 'True' means 'yes'

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_arm64_op operands[8]; // operands for this instruction.
} cs_arm64;

//> ARM64 instruction
typedef enum arm64_insn
{
    ARM64_INS_INVALID = 0,

    ARM64_INS_ABS,
    ARM64_INS_ADC,
    ARM64_INS_ADDHN,
    ARM64_INS_ADDHN2,
    ARM64_INS_ADDP,
    ARM64_INS_ADD,
    ARM64_INS_ADDV,
    ARM64_INS_ADR,
    ARM64_INS_ADRP,
    ARM64_INS_AESD,
    ARM64_INS_AESE,
    ARM64_INS_AESIMC,
    ARM64_INS_AESMC,
    ARM64_INS_AND,
    ARM64_INS_ASR,
    ARM64_INS_B,
    ARM64_INS_BFM,
    ARM64_INS_BIC,
    ARM64_INS_BIF,
    ARM64_INS_BIT,
    ARM64_INS_BL,
    ARM64_INS_BLR,
    ARM64_INS_BR,
    ARM64_INS_BRK,
    ARM64_INS_BSL,
    ARM64_INS_CBNZ,
    ARM64_INS_CBZ,
    ARM64_INS_CCMN,
    ARM64_INS_CCMP,
    ARM64_INS_CLREX,
    ARM64_INS_CLS,
    ARM64_INS_CLZ,
    ARM64_INS_CMEQ,
    ARM64_INS_CMGE,
    ARM64_INS_CMGT,
    ARM64_INS_CMHI,
    ARM64_INS_CMHS,
    ARM64_INS_CMLE,
    ARM64_INS_CMLT,
    ARM64_INS_CMTST,
    ARM64_INS_CNT,
    ARM64_INS_MOV,
    ARM64_INS_CRC32B,
    ARM64_INS_CRC32CB,
    ARM64_INS_CRC32CH,
    ARM64_INS_CRC32CW,
    ARM64_INS_CRC32CX,
    ARM64_INS_CRC32H,
    ARM64_INS_CRC32W,
    ARM64_INS_CRC32X,
    ARM64_INS_CSEL,
    ARM64_INS_CSINC,
    ARM64_INS_CSINV,
    ARM64_INS_CSNEG,
    ARM64_INS_DCPS1,
    ARM64_INS_DCPS2,
    ARM64_INS_DCPS3,
    ARM64_INS_DMB,
    ARM64_INS_DRPS,
    ARM64_INS_DSB,
    ARM64_INS_DUP,
    ARM64_INS_EON,
    ARM64_INS_EOR,
    ARM64_INS_ERET,
    ARM64_INS_EXTR,
    ARM64_INS_EXT,
    ARM64_INS_FABD,
    ARM64_INS_FABS,
    ARM64_INS_FACGE,
    ARM64_INS_FACGT,
    ARM64_INS_FADD,
    ARM64_INS_FADDP,
    ARM64_INS_FCCMP,
    ARM64_INS_FCCMPE,
    ARM64_INS_FCMEQ,
    ARM64_INS_FCMGE,
    ARM64_INS_FCMGT,
    ARM64_INS_FCMLE,
    ARM64_INS_FCMLT,
    ARM64_INS_FCMP,
    ARM64_INS_FCMPE,
    ARM64_INS_FCSEL,
    ARM64_INS_FCVTAS,
    ARM64_INS_FCVTAU,
    ARM64_INS_FCVT,
    ARM64_INS_FCVTL,
    ARM64_INS_FCVTL2,
    ARM64_INS_FCVTMS,
    ARM64_INS_FCVTMU,
    ARM64_INS_FCVTNS,
    ARM64_INS_FCVTNU,
    ARM64_INS_FCVTN,
    ARM64_INS_FCVTN2,
    ARM64_INS_FCVTPS,
    ARM64_INS_FCVTPU,
    ARM64_INS_FCVTXN,
    ARM64_INS_FCVTXN2,
    ARM64_INS_FCVTZS,
    ARM64_INS_FCVTZU,
    ARM64_INS_FDIV,
    ARM64_INS_FMADD,
    ARM64_INS_FMAX,
    ARM64_INS_FMAXNM,
    ARM64_INS_FMAXNMP,
    ARM64_INS_FMAXNMV,
    ARM64_INS_FMAXP,
    ARM64_INS_FMAXV,
    ARM64_INS_FMIN,
    ARM64_INS_FMINNM,
    ARM64_INS_FMINNMP,
    ARM64_INS_FMINNMV,
    ARM64_INS_FMINP,
    ARM64_INS_FMINV,
    ARM64_INS_FMLA,
    ARM64_INS_FMLS,
    ARM64_INS_FMOV,
    ARM64_INS_FMSUB,
    ARM64_INS_FMUL,
    ARM64_INS_FMULX,
    ARM64_INS_FNEG,
    ARM64_INS_FNMADD,
    ARM64_INS_FNMSUB,
    ARM64_INS_FNMUL,
    ARM64_INS_FRECPE,
    ARM64_INS_FRECPS,
    ARM64_INS_FRECPX,
    ARM64_INS_FRINTA,
    ARM64_INS_FRINTI,
    ARM64_INS_FRINTM,
    ARM64_INS_FRINTN,
    ARM64_INS_FRINTP,
    ARM64_INS_FRINTX,
    ARM64_INS_FRINTZ,
    ARM64_INS_FRSQRTE,
    ARM64_INS_FRSQRTS,
    ARM64_INS_FSQRT,
    ARM64_INS_FSUB,
    ARM64_INS_HINT,
    ARM64_INS_HLT,
    ARM64_INS_HVC,
    ARM64_INS_INS,

    ARM64_INS_ISB,
    ARM64_INS_LD1,
    ARM64_INS_LD1R,
    ARM64_INS_LD2R,
    ARM64_INS_LD2,
    ARM64_INS_LD3R,
    ARM64_INS_LD3,
    ARM64_INS_LD4,
    ARM64_INS_LD4R,

    ARM64_INS_LDARB,
    ARM64_INS_LDARH,
    ARM64_INS_LDAR,
    ARM64_INS_LDAXP,
    ARM64_INS_LDAXRB,
    ARM64_INS_LDAXRH,
    ARM64_INS_LDAXR,
    ARM64_INS_LDNP,
    ARM64_INS_LDP,
    ARM64_INS_LDPSW,
    ARM64_INS_LDRB,
    ARM64_INS_LDR,
    ARM64_INS_LDRH,
    ARM64_INS_LDRSB,
    ARM64_INS_LDRSH,
    ARM64_INS_LDRSW,
    ARM64_INS_LDTRB,
    ARM64_INS_LDTRH,
    ARM64_INS_LDTRSB,

    ARM64_INS_LDTRSH,
    ARM64_INS_LDTRSW,
    ARM64_INS_LDTR,
    ARM64_INS_LDURB,
    ARM64_INS_LDUR,
    ARM64_INS_LDURH,
    ARM64_INS_LDURSB,
    ARM64_INS_LDURSH,
    ARM64_INS_LDURSW,
    ARM64_INS_LDXP,
    ARM64_INS_LDXRB,
    ARM64_INS_LDXRH,
    ARM64_INS_LDXR,
    ARM64_INS_LSL,
    ARM64_INS_LSR,
    ARM64_INS_MADD,
    ARM64_INS_MLA,
    ARM64_INS_MLS,
    ARM64_INS_MOVI,
    ARM64_INS_MOVK,
    ARM64_INS_MOVN,
    ARM64_INS_MOVZ,
    ARM64_INS_MRS,
    ARM64_INS_MSR,
    ARM64_INS_MSUB,
    ARM64_INS_MUL,
    ARM64_INS_MVNI,
    ARM64_INS_NEG,
    ARM64_INS_NOT,
    ARM64_INS_ORN,
    ARM64_INS_ORR,
    ARM64_INS_PMULL2,
    ARM64_INS_PMULL,
    ARM64_INS_PMUL,
    ARM64_INS_PRFM,
    ARM64_INS_PRFUM,
    ARM64_INS_RADDHN,
    ARM64_INS_RADDHN2,
    ARM64_INS_RBIT,
    ARM64_INS_RET,
    ARM64_INS_REV16,
    ARM64_INS_REV32,
    ARM64_INS_REV64,
    ARM64_INS_REV,
    ARM64_INS_ROR,
    ARM64_INS_RSHRN2,
    ARM64_INS_RSHRN,
    ARM64_INS_RSUBHN,
    ARM64_INS_RSUBHN2,
    ARM64_INS_SABAL2,
    ARM64_INS_SABAL,

    ARM64_INS_SABA,
    ARM64_INS_SABDL2,
    ARM64_INS_SABDL,
    ARM64_INS_SABD,
    ARM64_INS_SADALP,
    ARM64_INS_SADDLP,
    ARM64_INS_SADDLV,
    ARM64_INS_SADDL2,
    ARM64_INS_SADDL,
    ARM64_INS_SADDW2,
    ARM64_INS_SADDW,
    ARM64_INS_SBC,
    ARM64_INS_SBFM,
    ARM64_INS_SCVTF,
    ARM64_INS_SDIV,
    ARM64_INS_SHA1C,
    ARM64_INS_SHA1H,
    ARM64_INS_SHA1M,
    ARM64_INS_SHA1P,
    ARM64_INS_SHA1SU0,
    ARM64_INS_SHA1SU1,
    ARM64_INS_SHA256H2,
    ARM64_INS_SHA256H,
    ARM64_INS_SHA256SU0,
    ARM64_INS_SHA256SU1,
    ARM64_INS_SHADD,
    ARM64_INS_SHLL2,
    ARM64_INS_SHLL,
    ARM64_INS_SHL,
    ARM64_INS_SHRN2,
    ARM64_INS_SHRN,
    ARM64_INS_SHSUB,
    ARM64_INS_SLI,
    ARM64_INS_SMADDL,
    ARM64_INS_SMAXP,
    ARM64_INS_SMAXV,
    ARM64_INS_SMAX,
    ARM64_INS_SMC,
    ARM64_INS_SMINP,
    ARM64_INS_SMINV,
    ARM64_INS_SMIN,
    ARM64_INS_SMLAL2,
    ARM64_INS_SMLAL,
    ARM64_INS_SMLSL2,
    ARM64_INS_SMLSL,
    ARM64_INS_SMOV,
    ARM64_INS_SMSUBL,
    ARM64_INS_SMULH,
    ARM64_INS_SMULL2,
    ARM64_INS_SMULL,
    ARM64_INS_SQABS,
    ARM64_INS_SQADD,
    ARM64_INS_SQDMLAL,
    ARM64_INS_SQDMLAL2,
    ARM64_INS_SQDMLSL,
    ARM64_INS_SQDMLSL2,
    ARM64_INS_SQDMULH,
    ARM64_INS_SQDMULL,
    ARM64_INS_SQDMULL2,
    ARM64_INS_SQNEG,
    ARM64_INS_SQRDMULH,
    ARM64_INS_SQRSHL,
    ARM64_INS_SQRSHRN,
    ARM64_INS_SQRSHRN2,
    ARM64_INS_SQRSHRUN,
    ARM64_INS_SQRSHRUN2,
    ARM64_INS_SQSHLU,
    ARM64_INS_SQSHL,
    ARM64_INS_SQSHRN,
    ARM64_INS_SQSHRN2,
    ARM64_INS_SQSHRUN,
    ARM64_INS_SQSHRUN2,
    ARM64_INS_SQSUB,
    ARM64_INS_SQXTN2,
    ARM64_INS_SQXTN,
    ARM64_INS_SQXTUN2,
    ARM64_INS_SQXTUN,
    ARM64_INS_SRHADD,
    ARM64_INS_SRI,
    ARM64_INS_SRSHL,
    ARM64_INS_SRSHR,
    ARM64_INS_SRSRA,
    ARM64_INS_SSHLL2,
    ARM64_INS_SSHLL,
    ARM64_INS_SSHL,
    ARM64_INS_SSHR,
    ARM64_INS_SSRA,
    ARM64_INS_SSUBL2,
    ARM64_INS_SSUBL,
    ARM64_INS_SSUBW2,
    ARM64_INS_SSUBW,
    ARM64_INS_ST1,
    ARM64_INS_ST2,
    ARM64_INS_ST3,
    ARM64_INS_ST4,
    ARM64_INS_STLRB,
    ARM64_INS_STLRH,
    ARM64_INS_STLR,
    ARM64_INS_STLXP,
    ARM64_INS_STLXRB,
    ARM64_INS_STLXRH,
    ARM64_INS_STLXR,
    ARM64_INS_STNP,
    ARM64_INS_STP,
    ARM64_INS_STRB,
    ARM64_INS_STR,
    ARM64_INS_STRH,
    ARM64_INS_STTRB,
    ARM64_INS_STTRH,
    ARM64_INS_STTR,
    ARM64_INS_STURB,
    ARM64_INS_STUR,
    ARM64_INS_STURH,
    ARM64_INS_STXP,
    ARM64_INS_STXRB,
    ARM64_INS_STXRH,
    ARM64_INS_STXR,
    ARM64_INS_SUBHN,
    ARM64_INS_SUBHN2,
    ARM64_INS_SUB,
    ARM64_INS_SUQADD,
    ARM64_INS_SVC,
    ARM64_INS_SYSL,
    ARM64_INS_SYS,
    ARM64_INS_TBL,
    ARM64_INS_TBNZ,
    ARM64_INS_TBX,
    ARM64_INS_TBZ,
    ARM64_INS_TRN1,
    ARM64_INS_TRN2,
    ARM64_INS_UABAL2,
    ARM64_INS_UABAL,
    ARM64_INS_UABA,
    ARM64_INS_UABDL2,
    ARM64_INS_UABDL,
    ARM64_INS_UABD,
    ARM64_INS_UADALP,
    ARM64_INS_UADDLP,
    ARM64_INS_UADDLV,
    ARM64_INS_UADDL2,
    ARM64_INS_UADDL,
    ARM64_INS_UADDW2,
    ARM64_INS_UADDW,
    ARM64_INS_UBFM,
    ARM64_INS_UCVTF,
    ARM64_INS_UDIV,
    ARM64_INS_UHADD,
    ARM64_INS_UHSUB,
    ARM64_INS_UMADDL,
    ARM64_INS_UMAXP,
    ARM64_INS_UMAXV,
    ARM64_INS_UMAX,
    ARM64_INS_UMINP,
    ARM64_INS_UMINV,
    ARM64_INS_UMIN,
    ARM64_INS_UMLAL2,
    ARM64_INS_UMLAL,
    ARM64_INS_UMLSL2,
    ARM64_INS_UMLSL,
    ARM64_INS_UMOV,
    ARM64_INS_UMSUBL,
    ARM64_INS_UMULH,
    ARM64_INS_UMULL2,
    ARM64_INS_UMULL,
    ARM64_INS_UQADD,
    ARM64_INS_UQRSHL,
    ARM64_INS_UQRSHRN,
    ARM64_INS_UQRSHRN2,
    ARM64_INS_UQSHL,
    ARM64_INS_UQSHRN,
    ARM64_INS_UQSHRN2,
    ARM64_INS_UQSUB,
    ARM64_INS_UQXTN2,
    ARM64_INS_UQXTN,
    ARM64_INS_URECPE,
    ARM64_INS_URHADD,
    ARM64_INS_URSHL,
    ARM64_INS_URSHR,
    ARM64_INS_URSQRTE,
    ARM64_INS_URSRA,
    ARM64_INS_USHLL2,
    ARM64_INS_USHLL,
    ARM64_INS_USHL,
    ARM64_INS_USHR,
    ARM64_INS_USQADD,
    ARM64_INS_USRA,
    ARM64_INS_USUBL2,
    ARM64_INS_USUBL,
    ARM64_INS_USUBW2,
    ARM64_INS_USUBW,
    ARM64_INS_UZP1,
    ARM64_INS_UZP2,
    ARM64_INS_XTN2,
    ARM64_INS_XTN,
    ARM64_INS_ZIP1,
    ARM64_INS_ZIP2,

    // alias insn
    ARM64_INS_MNEG,
    ARM64_INS_UMNEGL,
    ARM64_INS_SMNEGL,
    ARM64_INS_NOP,
    ARM64_INS_YIELD,
    ARM64_INS_WFE,
    ARM64_INS_WFI,
    ARM64_INS_SEV,
    ARM64_INS_SEVL,
    ARM64_INS_NGC,
    ARM64_INS_SBFIZ,
    ARM64_INS_UBFIZ,
    ARM64_INS_SBFX,
    ARM64_INS_UBFX,
    ARM64_INS_BFI,
    ARM64_INS_BFXIL,
    ARM64_INS_CMN,
    ARM64_INS_MVN,
    ARM64_INS_TST,
    ARM64_INS_CSET,
    ARM64_INS_CINC,
    ARM64_INS_CSETM,
    ARM64_INS_CINV,
    ARM64_INS_CNEG,
    ARM64_INS_SXTB,
    ARM64_INS_SXTH,
    ARM64_INS_SXTW,
    ARM64_INS_CMP,
    ARM64_INS_UXTB,
    ARM64_INS_UXTH,
    ARM64_INS_UXTW,
    ARM64_INS_IC,
    ARM64_INS_DC,
    ARM64_INS_AT,
    ARM64_INS_TLBI,

    ARM64_INS_ENDING,  // <-- mark the end of the list of insn
} arm64_insn;

//> Group of ARM64 instructions
typedef enum arm64_insn_group
{
    ARM64_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    ARM64_GRP_JUMP, // = CS_GRP_JUMP
    ARM64_GRP_CALL,
    ARM64_GRP_RET,
    ARM64_GRP_INT,
    ARM64_GRP_PRIVILEGE = 6, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    ARM64_GRP_CRYPTO = 128,
    ARM64_GRP_FPARMV8,
    ARM64_GRP_NEON,
    ARM64_GRP_CRC,

    ARM64_GRP_ENDING,  // <-- mark the end of the list of groups
} arm64_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/capstone.h
================================================
#ifndef CAPSTONE_ENGINE_H
#define CAPSTONE_ENGINE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

#if defined(CAPSTONE_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#define CAPSTONE_API __cdecl
#ifdef CAPSTONE_SHARED
#define CAPSTONE_EXPORT __declspec(dllexport)
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#else
#define CAPSTONE_API
#ifdef __GNUC__
#define CAPSTONE_EXPORT __attribute__((visibility("default")))
#else
#define CAPSTONE_EXPORT
#endif
#endif

#ifdef __GNUC__
#define CAPSTONE_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define CAPSTONE_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement CAPSTONE_DEPRECATED for this compiler")
#define CAPSTONE_DEPRECATED
#endif

// Capstone API version
#define CS_API_MAJOR 4
#define CS_API_MINOR 0

// Version for bleeding edge code of the Github's "next" branch.
// Use this if you want the absolutely latest developement code.
// This version number will be bumped up whenever we have a new major change.
#define CS_NEXT_VERSION 3

// Macro to create combined version which can be compared to
// result of cs_version() API.
#define CS_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Maximum size of an instruction mnemonic string.
#define CS_MNEMONIC_SIZE 32

// Handle using with all API
typedef size_t csh;

// Architecture type
typedef enum cs_arch
{
    CS_ARCH_ARM = 0,    // ARM architecture (including Thumb, Thumb-2)
    CS_ARCH_ARM64,      // ARM-64, also called AArch64
    CS_ARCH_MIPS,       // Mips architecture
    CS_ARCH_X86,        // X86 architecture (including x86 & x86-64)
    CS_ARCH_PPC,        // PowerPC architecture
    CS_ARCH_SPARC,      // Sparc architecture
    CS_ARCH_SYSZ,       // SystemZ architecture
    CS_ARCH_XCORE,      // XCore architecture
    CS_ARCH_M68K,       // 68K architecture
    CS_ARCH_MAX,
    CS_ARCH_ALL = 0xFFFF, // All architectures - for cs_support()
} cs_arch;

// Support value to verify diet mode of the engine.
// If cs_support(CS_SUPPORT_DIET) return True, the engine was compiled
// in diet mode.
#define CS_SUPPORT_DIET (CS_ARCH_ALL + 1)

// Support value to verify X86 reduce mode of the engine.
// If cs_support(CS_SUPPORT_X86_REDUCE) return True, the engine was compiled
// in X86 reduce mode.
#define CS_SUPPORT_X86_REDUCE (CS_ARCH_ALL + 2)

// Mode type
typedef enum cs_mode
{
    CS_MODE_LITTLE_ENDIAN = 0,  // little-endian mode (default mode)
    CS_MODE_ARM = 0,    // 32-bit ARM
    CS_MODE_16 = 1 << 1,    // 16-bit mode (X86)
    CS_MODE_32 = 1 << 2,    // 32-bit mode (X86)
    CS_MODE_64 = 1 << 3,    // 64-bit mode (X86, PPC)
    CS_MODE_THUMB = 1 << 4, // ARM's Thumb mode, including Thumb-2
    CS_MODE_MCLASS = 1 << 5,    // ARM's Cortex-M series
    CS_MODE_V8 = 1 << 6,    // ARMv8 A32 encodings for ARM
    CS_MODE_MICRO = 1 << 4, // MicroMips mode (MIPS)
    CS_MODE_MIPS3 = 1 << 5, // Mips III ISA
    CS_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA
    CS_MODE_V9 = 1 << 4, // SparcV9 mode (Sparc)
    CS_MODE_QPX = 1 << 4, // Quad Processing eXtensions mode (PPC)
    CS_MODE_M68K_000 = 1 << 1, // M68K 68000 mode
    CS_MODE_M68K_010 = 1 << 2, // M68K 68010 mode
    CS_MODE_M68K_020 = 1 << 3, // M68K 68020 mode
    CS_MODE_M68K_030 = 1 << 4, // M68K 68030 mode
    CS_MODE_M68K_040 = 1 << 5, // M68K 68040 mode
    CS_MODE_M68K_060 = 1 << 6, // M68K 68060 mode
    CS_MODE_BIG_ENDIAN = 1 << 31,   // big-endian mode
    CS_MODE_MIPS32 = CS_MODE_32,    // Mips32 ISA (Mips)
    CS_MODE_MIPS64 = CS_MODE_64,    // Mips64 ISA (Mips)
} cs_mode;

typedef void* (CAPSTONE_API* cs_malloc_t)(size_t size);
typedef void* (CAPSTONE_API* cs_calloc_t)(size_t nmemb, size_t size);
typedef void* (CAPSTONE_API* cs_realloc_t)(void* ptr, size_t size);
typedef void (CAPSTONE_API* cs_free_t)(void* ptr);
typedef int (CAPSTONE_API* cs_vsnprintf_t)(char* str, size_t size, const char* format, va_list ap);


// User-defined dynamic memory related functions: malloc/calloc/realloc/free/vsnprintf()
// By default, Capstone uses system's malloc(), calloc(), realloc(), free() & vsnprintf().
typedef struct cs_opt_mem
{
    cs_malloc_t malloc;
    cs_calloc_t calloc;
    cs_realloc_t realloc;
    cs_free_t free;
    cs_vsnprintf_t vsnprintf;
} cs_opt_mem;

// Customize mnemonic for instructions with alternative name.
// To reset existing customized instruction to its default mnemonic,
// call cs_option(CS_OPT_MNEMONIC) again with the same @id and NULL value
// for @mnemonic.
typedef struct cs_opt_mnem
{
    // ID of instruction to be customized.
    unsigned int id;
    // Customized instruction mnemonic.
    char* mnemonic;
} cs_opt_mnem;

// Runtime option for the disassembled engine
typedef enum cs_opt_type
{
    CS_OPT_INVALID = 0, // No option specified
    CS_OPT_SYNTAX,  // Assembly output syntax
    CS_OPT_DETAIL,  // Break down instruction structure into details
    CS_OPT_MODE,    // Change engine's mode at run-time
    CS_OPT_MEM, // User-defined dynamic memory related functions
    CS_OPT_SKIPDATA, // Skip data when disassembling. Then engine is in SKIPDATA mode.
    CS_OPT_SKIPDATA_SETUP, // Setup user-defined function for SKIPDATA option
    CS_OPT_MNEMONIC, // Customize instruction mnemonic
    CS_OPT_UNSIGNED, // print immediate operands in unsigned form
} cs_opt_type;

// Runtime option value (associated with option type above)
typedef enum cs_opt_value
{
    CS_OPT_OFF = 0,  // Turn OFF an option - default for CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.
    CS_OPT_ON = 3, // Turn ON an option (CS_OPT_DETAIL, CS_OPT_SKIPDATA).
    CS_OPT_SYNTAX_DEFAULT = 0, // Default asm syntax (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_INTEL, // X86 Intel asm syntax - default on X86 (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_ATT,   // X86 ATT asm syntax (CS_OPT_SYNTAX).
    CS_OPT_SYNTAX_NOREGNAME, // Prints register name with only number (CS_OPT_SYNTAX)
    CS_OPT_SYNTAX_MASM, // X86 Intel Masm syntax (CS_OPT_SYNTAX).
} cs_opt_value;

//> Common instruction operand types - to be consistent across all architectures.
typedef enum cs_op_type
{
    CS_OP_INVALID = 0,  // uninitialized/invalid operand.
    CS_OP_REG,          // Register operand.
    CS_OP_IMM,          // Immediate operand.
    CS_OP_MEM,          // Memory operand.
    CS_OP_FP,           // Floating-Point operand.
} cs_op_type;

//> Common instruction operand access types - to be consistent across all architectures.
//> It is possible to combine access types, for example: CS_AC_READ | CS_AC_WRITE
typedef enum cs_ac_type
{
    CS_AC_INVALID = 0,        // Uninitialized/invalid access type.
    CS_AC_READ    = 1 << 0,   // Operand read from memory or register.
    CS_AC_WRITE   = 1 << 1,   // Operand write to memory or register.
} cs_ac_type;

//> Common instruction groups - to be consistent across all architectures.
typedef enum cs_group_type
{
    CS_GRP_INVALID = 0,  // uninitialized/invalid group.
    CS_GRP_JUMP,    // all jump instructions (conditional+direct+indirect jumps)
    CS_GRP_CALL,    // all call instructions
    CS_GRP_RET,     // all return instructions
    CS_GRP_INT,     // all interrupt instructions (int+syscall)
    CS_GRP_IRET,    // all interrupt return instructions
    CS_GRP_PRIVILEGE,    // all privileged instructions
} cs_group_type;

/*
 User-defined callback function for SKIPDATA option.
 See tests/test_skipdata.c for sample code demonstrating this API.

 @code: the input buffer containing code to be disassembled.
        This is the same buffer passed to cs_disasm().
 @code_size: size (in bytes) of the above @code buffer.
 @offset: the position of the currently-examining byte in the input
      buffer @code mentioned above.
 @user_data: user-data passed to cs_option() via @user_data field in
      cs_opt_skipdata struct below.

 @return: return number of bytes to skip, or 0 to immediately stop disassembling.
*/
typedef size_t (CAPSTONE_API* cs_skipdata_cb_t)(const uint8_t* code, size_t code_size, size_t offset, void* user_data);

// User-customized setup for SKIPDATA option
typedef struct cs_opt_skipdata
{
    // Capstone considers data to skip as special "instructions".
    // User can specify the string for this instruction's "mnemonic" here.
    // By default (if @mnemonic is NULL), Capstone use ".byte".
    const char* mnemonic;

    // User-defined callback function to be called when Capstone hits data.
    // If the returned value from this callback is positive (>0), Capstone
    // will skip exactly that number of bytes & continue. Otherwise, if
    // the callback returns 0, Capstone stops disassembling and returns
    // immediately from cs_disasm()
    // NOTE: if this callback pointer is NULL, Capstone would skip a number
    // of bytes depending on architectures, as following:
    // Arm:     2 bytes (Thumb mode) or 4 bytes.
    // Arm64:   4 bytes.
    // Mips:    4 bytes.
    // PowerPC: 4 bytes.
    // Sparc:   4 bytes.
    // SystemZ: 2 bytes.
    // X86:     1 bytes.
    // XCore:   2 bytes.
    cs_skipdata_cb_t callback;  // default value is NULL

    // User-defined data to be passed to @callback function pointer.
    void* user_data;
} cs_opt_skipdata;


#include "arm.h"
#include "arm64.h"
#include "m68k.h"
#include "mips.h"
#include "ppc.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"
#include "xcore.h"

// NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON
typedef struct cs_detail
{
    uint16_t regs_read[12]; // list of implicit registers read by this insn
    uint8_t regs_read_count; // number of implicit registers read by this insn

    uint16_t regs_write[20]; // list of implicit registers modified by this insn
    uint8_t regs_write_count; // number of implicit registers modified by this insn

    uint8_t groups[8]; // list of group this instruction belong to
    uint8_t groups_count; // number of groups this insn belongs to

    // Architecture-specific instruction info
    union
    {
        cs_x86 x86; // X86 architecture, including 16-bit, 32-bit & 64-bit mode
        cs_arm64 arm64; // ARM64 architecture (aka AArch64)
        cs_arm arm;     // ARM architecture (including Thumb/Thumb2)
        cs_m68k m68k;   // M68K architecture
        cs_mips mips;   // MIPS architecture
        cs_ppc ppc; // PowerPC architecture
        cs_sparc sparc; // Sparc architecture
        cs_sysz sysz;   // SystemZ architecture
        cs_xcore xcore; // XCore architecture
    };
} cs_detail;

// Detail information of disassembled instruction
typedef struct cs_insn
{
    // Instruction ID (basically a numeric ID for the instruction mnemonic)
    // Find the instruction id in the '[ARCH]_insn' enum in the header file
    // of corresponding architecture, such as 'arm_insn' in arm.h for ARM,
    // 'x86_insn' in x86.h for X86, etc...
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    // NOTE: in Skipdata mode, "data" instruction has 0 for this id field.
    unsigned int id;

    // Address (EIP) of this instruction
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint64_t address;

    // Size of this instruction
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint16_t size;

    // Machine bytes of this instruction, with number of bytes indicated by @size above
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    uint8_t bytes[16];

    // Ascii text of instruction mnemonic
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    char mnemonic[CS_MNEMONIC_SIZE];

    // Ascii text of instruction operands
    // This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
    char op_str[160];

    // Pointer to cs_detail.
    // NOTE: detail pointer is only valid when both requirements below are met:
    // (1) CS_OP_DETAIL = CS_OPT_ON
    // (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)
    //
    // NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer
    //     is not NULL, its content is still irrelevant.
    cs_detail* detail;
} cs_insn;


// Calculate the offset of a disassembled instruction in its buffer, given its position
// in its array of disassembled insn
// NOTE: this macro works with position (>=1), not index
#define CS_INSN_OFFSET(insns, post) (insns[post - 1].address - insns[0].address)


// All type of errors encountered by Capstone API.
// These are values returned by cs_errno()
typedef enum cs_err
{
    CS_ERR_OK = 0,   // No error: everything was fine
    CS_ERR_MEM,      // Out-Of-Memory error: cs_open(), cs_disasm(), cs_disasm_iter()
    CS_ERR_ARCH,     // Unsupported architecture: cs_open()
    CS_ERR_HANDLE,   // Invalid handle: cs_op_count(), cs_op_index()
    CS_ERR_CSH,      // Invalid csh argument: cs_close(), cs_errno(), cs_option()
    CS_ERR_MODE,     // Invalid/unsupported mode: cs_open()
    CS_ERR_OPTION,   // Invalid/unsupported option: cs_option()
    CS_ERR_DETAIL,   // Information is unavailable because detail option is OFF
    CS_ERR_MEMSETUP, // Dynamic memory management uninitialized (see CS_OPT_MEM)
    CS_ERR_VERSION,  // Unsupported version (bindings)
    CS_ERR_DIET,     // Access irrelevant data in "diet" engine
    CS_ERR_SKIPDATA, // Access irrelevant data for "data" instruction in SKIPDATA mode
    CS_ERR_X86_ATT,  // X86 AT&T syntax is unsupported (opt-out at compile time)
    CS_ERR_X86_INTEL, // X86 Intel syntax is unsupported (opt-out at compile time)
    CS_ERR_X86_MASM, // X86 Intel syntax is unsupported (opt-out at compile time)
} cs_err;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
     major & minor versions.
     NOTE: This returned value can be compared with version number made
     with macro CS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
CAPSTONE_EXPORT
unsigned int CAPSTONE_API cs_version(int* major, int* minor);


/*
 This API can be used to either ask for archs supported by this library,
 or check to see if the library was compile with 'diet' option (or called
 in 'diet' mode).

 To check if a particular arch is supported by this library, set @query to
 arch mode (CS_ARCH_* value).
 To verify if this library supports all the archs, use CS_ARCH_ALL.

 To check if this library is in 'diet' mode, set @query to CS_SUPPORT_DIET.

 @return True if this library supports the given arch, or in 'diet' mode.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_support(int query);

/*
 Initialize CS handle: this must be done before any usage of CS.

 @arch: architecture type (CS_ARCH_*)
 @mode: hardware mode. This is combined of CS_MODE_*
 @handle: pointer to handle, which will be updated at return time

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh* handle);

/*
 Close CS handle: MUST do to release the handle when it is not used anymore.
 NOTE: this must be only called when there is no longer usage of Capstone,
 not even access to cs_insn array. The reason is the this API releases some
 cached memory, thus access to any Capstone API after cs_close() might crash
 your application.

 In fact,this API invalidate @handle by ZERO out its value (i.e *handle = 0).

 @handle: pointer to a handle returned by cs_open()

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_close(csh* handle);

/*
 Set option for disassembling engine at runtime

 @handle: handle returned by cs_open()
 @type: type of option to be set
 @value: option value corresponding with @type

 @return: CS_ERR_OK on success, or other value on failure.
 Refer to cs_err enum for detailed error.

 NOTE: in the case of CS_OPT_MEM, handle's value can be anything,
 so that cs_option(handle, CS_OPT_MEM, value) can (i.e must) be called
 even before cs_open()
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);

/*
 Report the last error number when some API function fail.
 Like glibc's errno, cs_errno might not retain its old value once accessed.

 @handle: handle returned by cs_open()

 @return: error code of cs_err enum type (CS_ERR_*, see above)
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_errno(csh handle);


/*
 Return a string describing given error code.

 @code: error code (see CS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
    passed in the argument @code
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_strerror(cs_err code);

/*
 Disassemble binary code, given the code buffer, size, address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain disassembled instruction.
 Resulted instructions will be put into @*insn

 NOTE 1: this API will automatically determine memory needed to contain
 output disassembled instructions in @insn.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, the API cs_disasm_iter() might be a better choice than
 cs_disasm(). The reason is that with cs_disasm(), based on limited available
 memory, we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case @count=0,
 when cs_disasm() runs uncontrollably (until either end of input buffer, or
 when it encounters an invalid instruction).

 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled.
 @code_size: size of the above code buffer.
 @address: address of the first instruction in given raw code buffer.
 @insn: array of instructions filled in by this API.
       NOTE: @insn will be allocated by this function, and should be freed
       with cs_free() API.
 @count: number of instructions to be disassembled, or 0 to get all of them

 @return: the number of successfully disassembled instructions,
 or 0 if this function failed to disassemble the given code

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
size_t CAPSTONE_API cs_disasm(csh handle,
                              const uint8_t* code, size_t code_size,
                              uint64_t address,
                              size_t count,
                              cs_insn** insn);

/*
  Deprecated function - to be retired in the next version!
  Use cs_disasm() instead of cs_disasm_ex()
*/
CAPSTONE_EXPORT
CAPSTONE_DEPRECATED
size_t CAPSTONE_API cs_disasm_ex(csh handle,
                                 const uint8_t* code, size_t code_size,
                                 uint64_t address,
                                 size_t count,
                                 cs_insn** insn);

/*
 Free memory allocated by cs_malloc() or cs_disasm() (argument @insn)

 @insn: pointer returned by @insn argument in cs_disasm() or cs_malloc()
 @count: number of cs_insn structures returned by cs_disasm(), or 1
     to free memory allocated by cs_malloc().
*/
CAPSTONE_EXPORT
void CAPSTONE_API cs_free(cs_insn* insn, size_t count);


/*
 Allocate memory for 1 instruction to be used by cs_disasm_iter().

 @handle: handle returned by cs_open()

 NOTE: when no longer in use, you can reclaim the memory allocated for
 this instruction with cs_free(insn, 1)
*/
CAPSTONE_EXPORT
cs_insn* CAPSTONE_API cs_malloc(csh handle);

/*
 Fast API to disassemble binary code, given the code buffer, size, address
 and number of instructions to be decoded.
 This API put the resulted instruction into a given cache in @insn.
 See tests/test_iter.c for sample code demonstrating this API.

 NOTE 1: this API will update @code, @size & @address to point to the next
 instruction in the input buffer. Therefore, it is convenient to use
 cs_disasm_iter() inside a loop to quickly iterate all the instructions.
 While decoding one instruction at a time can also be achieved with
 cs_disasm(count=1), some benchmarks shown that cs_disasm_iter() can be 30%
 faster on random input.

 NOTE 2: the cache in @insn can be created with cs_malloc() API.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, this API is recommended over cs_disasm(), which
 allocates memory based on the number of instructions to be disassembled.
 The reason is that with cs_disasm(), based on limited available memory,
 we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case
 @count=0, when cs_disasm() runs uncontrollably (until either end of input
 buffer, or when it encounters an invalid instruction).

 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled
 @code_size: size of above code
 @address: address of the first insn in given raw code buffer
 @insn: pointer to instruction to be filled in by this API.

 @return: true if this API successfully decode 1 instruction,
 or false otherwise.

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_disasm_iter(csh handle,
                                 const uint8_t** code, size_t* size,
                                 uint64_t* address, cs_insn* insn);

/*
 Return friendly name of register in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM,
 x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store register name.

 @handle: handle returned by cs_open()
 @reg_id: register id

 @return: string name of the register, or NULL if @reg_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);

/*
 Return friendly name of an instruction in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store instruction name.

 @handle: handle returned by cs_open()
 @insn_id: instruction id

 @return: string name of the instruction, or NULL if @insn_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);

/*
 Return friendly name of a group id (that an instruction can belong to)
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store group name.

 @handle: handle returned by cs_open()
 @group_id: group id

 @return: string name of the group, or NULL if @group_id is invalid.
*/
CAPSTONE_EXPORT
const char* CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);

/*
 Check if a disassembled instruction belong to a particular group.
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @group_id matches any member of insn->groups array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default).

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @groups array.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @group_id: group that you want to check if this instruction belong to.

 @return: true if this instruction indeed belongs to aboved group, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn* insn, unsigned int group_id);

/*
 Check if a disassembled instruction IMPLICITLY used a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_read array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_read array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction used it.

 @return: true if this instruction indeed implicitly used aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn* insn, unsigned int reg_id);

/*
 Check if a disassembled instruction IMPLICITLY modified a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_write array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_write array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction modified it.

 @return: true if this instruction indeed implicitly modified aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn* insn, unsigned int reg_id);

/*
 Count the number of operands of a given type.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.

 @return: number of operands of given type @op_type in instruction @insn,
 or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_count(csh handle, const cs_insn* insn, unsigned int op_type);

/*
 Retrieve the position of operand of given type in <arch>.operands[] array.
 Later, the operand can be accessed using the returned position.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.
 @position: position of the operand to be found. This must be in the range
            [1, cs_op_count(handle, insn, op_type)]

 @return: index of operand of given type @op_type in <arch>.operands[] array
 in instruction @insn, or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_index(csh handle, const cs_insn* insn, unsigned int op_type,
                             unsigned int position);

// Type of array to keep the list of registers
typedef uint16_t cs_regs[64];

/*
 Retrieve all the registers accessed by an instruction, either explicitly or
 implicitly.

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store registers.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure returned from cs_disasm() or cs_disasm_iter()
 @regs_read: on return, this array contains all registers read by instruction.
 @regs_read_count: number of registers kept inside @regs_read array.
 @regs_write: on return, this array contains all registers written by instruction.
 @regs_write_count: number of registers kept inside @regs_write array.

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_regs_access(csh handle, const cs_insn* insn,
                                   cs_regs regs_read, uint8_t* regs_read_count,
                                   cs_regs regs_write, uint8_t* regs_write_count);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/m68k.h
================================================
#ifndef CAPSTONE_M68K_H
#define CAPSTONE_M68K_H

/* Capstone Disassembly Engine */
/* By Daniel Collin <daniel@collin.com>, 2015-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

#define M68K_OPERAND_COUNT 4

//> M68K registers and special registers
typedef enum m68k_reg
{
    M68K_REG_INVALID = 0,

    M68K_REG_D0,
    M68K_REG_D1,
    M68K_REG_D2,
    M68K_REG_D3,
    M68K_REG_D4,
    M68K_REG_D5,
    M68K_REG_D6,
    M68K_REG_D7,

    M68K_REG_A0,
    M68K_REG_A1,
    M68K_REG_A2,
    M68K_REG_A3,
    M68K_REG_A4,
    M68K_REG_A5,
    M68K_REG_A6,
    M68K_REG_A7,

    M68K_REG_FP0,
    M68K_REG_FP1,
    M68K_REG_FP2,
    M68K_REG_FP3,
    M68K_REG_FP4,
    M68K_REG_FP5,
    M68K_REG_FP6,
    M68K_REG_FP7,

    M68K_REG_PC,

    M68K_REG_SR,
    M68K_REG_CCR,
    M68K_REG_SFC,
    M68K_REG_DFC,
    M68K_REG_USP,
    M68K_REG_VBR,
    M68K_REG_CACR,
    M68K_REG_CAAR,
    M68K_REG_MSP,
    M68K_REG_ISP,
    M68K_REG_TC,
    M68K_REG_ITT0,
    M68K_REG_ITT1,
    M68K_REG_DTT0,
    M68K_REG_DTT1,
    M68K_REG_MMUSR,
    M68K_REG_URP,
    M68K_REG_SRP,

    M68K_REG_FPCR,
    M68K_REG_FPSR,
    M68K_REG_FPIAR,

    M68K_REG_ENDING,   // <-- mark the end of the list of registers
} m68k_reg;

//> M68K Addressing Modes
typedef enum m68k_address_mode
{
    M68K_AM_NONE = 0,           // No address mode.

    M68K_AM_REG_DIRECT_DATA,        // Register Direct - Data
    M68K_AM_REG_DIRECT_ADDR,        // Register Direct - Address

    M68K_AM_REGI_ADDR,              // Register Indirect - Address
    M68K_AM_REGI_ADDR_POST_INC,     // Register Indirect - Address with Postincrement
    M68K_AM_REGI_ADDR_PRE_DEC,      // Register Indirect - Address with Predecrement
    M68K_AM_REGI_ADDR_DISP,         // Register Indirect - Address with Displacement

    M68K_AM_AREGI_INDEX_8_BIT_DISP, // Address Register Indirect With Index- 8-bit displacement
    M68K_AM_AREGI_INDEX_BASE_DISP,  // Address Register Indirect With Index- Base displacement

    M68K_AM_MEMI_POST_INDEX,        // Memory indirect - Postindex
    M68K_AM_MEMI_PRE_INDEX,         // Memory indirect - Preindex

    M68K_AM_PCI_DISP,               // Program Counter Indirect - with Displacement

    M68K_AM_PCI_INDEX_8_BIT_DISP,   // Program Counter Indirect with Index - with 8-Bit Displacement
    M68K_AM_PCI_INDEX_BASE_DISP,    // Program Counter Indirect with Index - with Base Displacement

    M68K_AM_PC_MEMI_POST_INDEX,     // Program Counter Memory Indirect - Postindexed
    M68K_AM_PC_MEMI_PRE_INDEX,      // Program Counter Memory Indirect - Preindexed

    M68K_AM_ABSOLUTE_DATA_SHORT,    // Absolute Data Addressing  - Short
    M68K_AM_ABSOLUTE_DATA_LONG,     // Absolute Data Addressing  - Long
    M68K_AM_IMMEDIATE,              // Immediate value
} m68k_address_mode;

//> Operand type for instruction's operands
typedef enum m68k_op_type
{
    M68K_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    M68K_OP_REG,         // = CS_OP_REG (Register operand).
    M68K_OP_IMM,         // = CS_OP_IMM (Immediate operand).
    M68K_OP_MEM,         // = CS_OP_MEM (Memory operand).
    M68K_OP_FP_SINGLE,   // single precision Floating-Point operand
    M68K_OP_FP_DOUBLE,   // double precision Floating-Point operand
    M68K_OP_REG_BITS,    // Register bits move
    M68K_OP_REG_PAIR,    // Register pair in the same op (upper 4 bits for first reg, lower for second)
} m68k_op_type;

// Instruction's operand referring to memory
// This is associated with M68K_OP_MEM operand type above
typedef struct m68k_op_mem
{
    m68k_reg base_reg;      // base register (or M68K_REG_INVALID if irrelevant)
    m68k_reg index_reg;     // index register (or M68K_REG_INVALID if irrelevant)
    m68k_reg in_base_reg;   // indirect base register (or M68K_REG_INVALID if irrelevant)
    uint32_t in_disp;       // indirect displacement
    uint32_t out_disp;      // other displacement
    uint16_t disp;          // displacement value
    uint8_t scale;          // scale for index register
    uint8_t bitfield;       // set to true if the two values below should be used
    uint8_t width;          // used for bf* instructions
    uint8_t offset;         // used for bf* instructions
    uint8_t index_size;     // 0 = w, 1 = l
} m68k_op_mem;

// Instruction operand
typedef struct cs_m68k_op
{
    union
    {
        uint64_t imm;               // immediate value for IMM operand
        double dimm;            // double imm
        float simm;             // float imm
        m68k_reg reg;           // register value for REG operand
        struct              // register pair in one operand
        {
            m68k_reg reg_0;
            m68k_reg reg_1;
        } reg_pair;
        m68k_op_mem mem;        // data when operand is targeting memory
        uint32_t register_bits; // register bits for movem etc. (always in d0-d7, a0-a7, fp0 - fp7 order)
    };
    m68k_op_type type;
    m68k_address_mode address_mode; // M68K addressing mode for this op
} cs_m68k_op;

// Operation size of the CPU instructions
typedef enum m68k_cpu_size
{
    M68K_CPU_SIZE_NONE = 0,     // unsized or unspecified
    M68K_CPU_SIZE_BYTE = 1,     // 1 byte in size
    M68K_CPU_SIZE_WORD = 2,     // 2 bytes in size
    M68K_CPU_SIZE_LONG = 4,     // 4 bytes in size
} m68k_cpu_size;

// Operation size of the FPU instructions (Notice that FPU instruction can also use CPU sizes if needed)
typedef enum m68k_fpu_size
{
    M68K_FPU_SIZE_NONE = 0,     // unsized like fsave/frestore
    M68K_FPU_SIZE_SINGLE = 4,       // 4 byte in size (single float)
    M68K_FPU_SIZE_DOUBLE = 8,       // 8 byte in size (double)
    M68K_FPU_SIZE_EXTENDED = 12,    // 12 byte in size (extended real format)
} m68k_fpu_size;

// Type of size that is being used for the current instruction
typedef enum m68k_size_type
{
    M68K_SIZE_TYPE_INVALID = 0,

    M68K_SIZE_TYPE_CPU,
    M68K_SIZE_TYPE_FPU,
} m68k_size_type;

// Operation size of the current instruction (NOT the actually size of instruction)
typedef struct m68k_op_size
{
    m68k_size_type type;
    union
    {
        m68k_cpu_size cpu_size;
        m68k_fpu_size fpu_size;
    };
} m68k_op_size;

// The M68K instruction and it's operands
typedef struct cs_m68k
{
    // Number of operands of this instruction or 0 when instruction has no operand.
    cs_m68k_op operands[M68K_OPERAND_COUNT]; // operands for this instruction.
    m68k_op_size op_size;   // size of data operand works on in bytes (.b, .w, .l, etc)
    uint8_t op_count; // number of operands for the instruction
} cs_m68k;

//> M68K instruction
typedef enum m68k_insn
{
    M68K_INS_INVALID = 0,

    M68K_INS_ABCD,
    M68K_INS_ADD,
    M68K_INS_ADDA,
    M68K_INS_ADDI,
    M68K_INS_ADDQ,
    M68K_INS_ADDX,
    M68K_INS_AND,
    M68K_INS_ANDI,
    M68K_INS_ASL,
    M68K_INS_ASR,
    M68K_INS_BHS,
    M68K_INS_BLO,
    M68K_INS_BHI,
    M68K_INS_BLS,
    M68K_INS_BCC,
    M68K_INS_BCS,
    M68K_INS_BNE,
    M68K_INS_BEQ,
    M68K_INS_BVC,
    M68K_INS_BVS,
    M68K_INS_BPL,
    M68K_INS_BMI,
    M68K_INS_BGE,
    M68K_INS_BLT,
    M68K_INS_BGT,
    M68K_INS_BLE,
    M68K_INS_BRA,
    M68K_INS_BSR,
    M68K_INS_BCHG,
    M68K_INS_BCLR,
    M68K_INS_BSET,
    M68K_INS_BTST,
    M68K_INS_BFCHG,
    M68K_INS_BFCLR,
    M68K_INS_BFEXTS,
    M68K_INS_BFEXTU,
    M68K_INS_BFFFO,
    M68K_INS_BFINS,
    M68K_INS_BFSET,
    M68K_INS_BFTST,
    M68K_INS_BKPT,
    M68K_INS_CALLM,
    M68K_INS_CAS,
    M68K_INS_CAS2,
    M68K_INS_CHK,
    M68K_INS_CHK2,
    M68K_INS_CLR,
    M68K_INS_CMP,
    M68K_INS_CMPA,
    M68K_INS_CMPI,
    M68K_INS_CMPM,
    M68K_INS_CMP2,
    M68K_INS_CINVL,
    M68K_INS_CINVP,
    M68K_INS_CINVA,
    M68K_INS_CPUSHL,
    M68K_INS_CPUSHP,
    M68K_INS_CPUSHA,
    M68K_INS_DBT,
    M68K_INS_DBF,
    M68K_INS_DBHI,
    M68K_INS_DBLS,
    M68K_INS_DBCC,
    M68K_INS_DBCS,
    M68K_INS_DBNE,
    M68K_INS_DBEQ,
    M68K_INS_DBVC,
    M68K_INS_DBVS,
    M68K_INS_DBPL,
    M68K_INS_DBMI,
    M68K_INS_DBGE,
    M68K_INS_DBLT,
    M68K_INS_DBGT,
    M68K_INS_DBLE,
    M68K_INS_DBRA,
    M68K_INS_DIVS,
    M68K_INS_DIVSL,
    M68K_INS_DIVU,
    M68K_INS_DIVUL,
    M68K_INS_EOR,
    M68K_INS_EORI,
    M68K_INS_EXG,
    M68K_INS_EXT,
    M68K_INS_EXTB,
    M68K_INS_FABS,
    M68K_INS_FSABS,
    M68K_INS_FDABS,
    M68K_INS_FACOS,
    M68K_INS_FADD,
    M68K_INS_FSADD,
    M68K_INS_FDADD,
    M68K_INS_FASIN,
    M68K_INS_FATAN,
    M68K_INS_FATANH,
    M68K_INS_FBF,
    M68K_INS_FBEQ,
    M68K_INS_FBOGT,
    M68K_INS_FBOGE,
    M68K_INS_FBOLT,
    M68K_INS_FBOLE,
    M68K_INS_FBOGL,
    M68K_INS_FBOR,
    M68K_INS_FBUN,
    M68K_INS_FBUEQ,
    M68K_INS_FBUGT,
    M68K_INS_FBUGE,
    M68K_INS_FBULT,
    M68K_INS_FBULE,
    M68K_INS_FBNE,
    M68K_INS_FBT,
    M68K_INS_FBSF,
    M68K_INS_FBSEQ,
    M68K_INS_FBGT,
    M68K_INS_FBGE,
    M68K_INS_FBLT,
    M68K_INS_FBLE,
    M68K_INS_FBGL,
    M68K_INS_FBGLE,
    M68K_INS_FBNGLE,
    M68K_INS_FBNGL,
    M68K_INS_FBNLE,
    M68K_INS_FBNLT,
    M68K_INS_FBNGE,
    M68K_INS_FBNGT,
    M68K_INS_FBSNE,
    M68K_INS_FBST,
    M68K_INS_FCMP,
    M68K_INS_FCOS,
    M68K_INS_FCOSH,
    M68K_INS_FDBF,
    M68K_INS_FDBEQ,
    M68K_INS_FDBOGT,
    M68K_INS_FDBOGE,
    M68K_INS_FDBOLT,
    M68K_INS_FDBOLE,
    M68K_INS_FDBOGL,
    M68K_INS_FDBOR,
    M68K_INS_FDBUN,
    M68K_INS_FDBUEQ,
    M68K_INS_FDBUGT,
    M68K_INS_FDBUGE,
    M68K_INS_FDBULT,
    M68K_INS_FDBULE,
    M68K_INS_FDBNE,
    M68K_INS_FDBT,
    M68K_INS_FDBSF,
    M68K_INS_FDBSEQ,
    M68K_INS_FDBGT,
    M68K_INS_FDBGE,
    M68K_INS_FDBLT,
    M68K_INS_FDBLE,
    M68K_INS_FDBGL,
    M68K_INS_FDBGLE,
    M68K_INS_FDBNGLE,
    M68K_INS_FDBNGL,
    M68K_INS_FDBNLE,
    M68K_INS_FDBNLT,
    M68K_INS_FDBNGE,
    M68K_INS_FDBNGT,
    M68K_INS_FDBSNE,
    M68K_INS_FDBST,
    M68K_INS_FDIV,
    M68K_INS_FSDIV,
    M68K_INS_FDDIV,
    M68K_INS_FETOX,
    M68K_INS_FETOXM1,
    M68K_INS_FGETEXP,
    M68K_INS_FGETMAN,
    M68K_INS_FINT,
    M68K_INS_FINTRZ,
    M68K_INS_FLOG10,
    M68K_INS_FLOG2,
    M68K_INS_FLOGN,
    M68K_INS_FLOGNP1,
    M68K_INS_FMOD,
    M68K_INS_FMOVE,
    M68K_INS_FSMOVE,
    M68K_INS_FDMOVE,
    M68K_INS_FMOVECR,
    M68K_INS_FMOVEM,
    M68K_INS_FMUL,
    M68K_INS_FSMUL,
    M68K_INS_FDMUL,
    M68K_INS_FNEG,
    M68K_INS_FSNEG,
    M68K_INS_FDNEG,
    M68K_INS_FNOP,
    M68K_INS_FREM,
    M68K_INS_FRESTORE,
    M68K_INS_FSAVE,
    M68K_INS_FSCALE,
    M68K_INS_FSGLDIV,
    M68K_INS_FSGLMUL,
    M68K_INS_FSIN,
    M68K_INS_FSINCOS,
    M68K_INS_FSINH,
    M68K_INS_FSQRT,
    M68K_INS_FSSQRT,
    M68K_INS_FDSQRT,
    M68K_INS_FSF,
    M68K_INS_FSBEQ,
    M68K_INS_FSOGT,
    M68K_INS_FSOGE,
    M68K_INS_FSOLT,
    M68K_INS_FSOLE,
    M68K_INS_FSOGL,
    M68K_INS_FSOR,
    M68K_INS_FSUN,
    M68K_INS_FSUEQ,
    M68K_INS_FSUGT,
    M68K_INS_FSUGE,
    M68K_INS_FSULT,
    M68K_INS_FSULE,
    M68K_INS_FSNE,
    M68K_INS_FST,
    M68K_INS_FSSF,
    M68K_INS_FSSEQ,
    M68K_INS_FSGT,
    M68K_INS_FSGE,
    M68K_INS_FSLT,
    M68K_INS_FSLE,
    M68K_INS_FSGL,
    M68K_INS_FSGLE,
    M68K_INS_FSNGLE,
    M68K_INS_FSNGL,
    M68K_INS_FSNLE,
    M68K_INS_FSNLT,
    M68K_INS_FSNGE,
    M68K_INS_FSNGT,
    M68K_INS_FSSNE,
    M68K_INS_FSST,
    M68K_INS_FSUB,
    M68K_INS_FSSUB,
    M68K_INS_FDSUB,
    M68K_INS_FTAN,
    M68K_INS_FTANH,
    M68K_INS_FTENTOX,
    M68K_INS_FTRAPF,
    M68K_INS_FTRAPEQ,
    M68K_INS_FTRAPOGT,
    M68K_INS_FTRAPOGE,
    M68K_INS_FTRAPOLT,
    M68K_INS_FTRAPOLE,
    M68K_INS_FTRAPOGL,
    M68K_INS_FTRAPOR,
    M68K_INS_FTRAPUN,
    M68K_INS_FTRAPUEQ,
    M68K_INS_FTRAPUGT,
    M68K_INS_FTRAPUGE,
    M68K_INS_FTRAPULT,
    M68K_INS_FTRAPULE,
    M68K_INS_FTRAPNE,
    M68K_INS_FTRAPT,
    M68K_INS_FTRAPSF,
    M68K_INS_FTRAPSEQ,
    M68K_INS_FTRAPGT,
    M68K_INS_FTRAPGE,
    M68K_INS_FTRAPLT,
    M68K_INS_FTRAPLE,
    M68K_INS_FTRAPGL,
    M68K_INS_FTRAPGLE,
    M68K_INS_FTRAPNGLE,
    M68K_INS_FTRAPNGL,
    M68K_INS_FTRAPNLE,
    M68K_INS_FTRAPNLT,
    M68K_INS_FTRAPNGE,
    M68K_INS_FTRAPNGT,
    M68K_INS_FTRAPSNE,
    M68K_INS_FTRAPST,
    M68K_INS_FTST,
    M68K_INS_FTWOTOX,
    M68K_INS_HALT,
    M68K_INS_ILLEGAL,
    M68K_INS_JMP,
    M68K_INS_JSR,
    M68K_INS_LEA,
    M68K_INS_LINK,
    M68K_INS_LPSTOP,
    M68K_INS_LSL,
    M68K_INS_LSR,
    M68K_INS_MOVE,
    M68K_INS_MOVEA,
    M68K_INS_MOVEC,
    M68K_INS_MOVEM,
    M68K_INS_MOVEP,
    M68K_INS_MOVEQ,
    M68K_INS_MOVES,
    M68K_INS_MOVE16,
    M68K_INS_MULS,
    M68K_INS_MULU,
    M68K_INS_NBCD,
    M68K_INS_NEG,
    M68K_INS_NEGX,
    M68K_INS_NOP,
    M68K_INS_NOT,
    M68K_INS_OR,
    M68K_INS_ORI,
    M68K_INS_PACK,
    M68K_INS_PEA,
    M68K_INS_PFLUSH,
    M68K_INS_PFLUSHA,
    M68K_INS_PFLUSHAN,
    M68K_INS_PFLUSHN,
    M68K_INS_PLOADR,
    M68K_INS_PLOADW,
    M68K_INS_PLPAR,
    M68K_INS_PLPAW,
    M68K_INS_PMOVE,
    M68K_INS_PMOVEFD,
    M68K_INS_PTESTR,
    M68K_INS_PTESTW,
    M68K_INS_PULSE,
    M68K_INS_REMS,
    M68K_INS_REMU,
    M68K_INS_RESET,
    M68K_INS_ROL,
    M68K_INS_ROR,
    M68K_INS_ROXL,
    M68K_INS_ROXR,
    M68K_INS_RTD,
    M68K_INS_RTE,
    M68K_INS_RTM,
    M68K_INS_RTR,
    M68K_INS_RTS,
    M68K_INS_SBCD,
    M68K_INS_ST,
    M68K_INS_SF,
    M68K_INS_SHI,
    M68K_INS_SLS,
    M68K_INS_SCC,
    M68K_INS_SHS,
    M68K_INS_SCS,
    M68K_INS_SLO,
    M68K_INS_SNE,
    M68K_INS_SEQ,
    M68K_INS_SVC,
    M68K_INS_SVS,
    M68K_INS_SPL,
    M68K_INS_SMI,
    M68K_INS_SGE,
    M68K_INS_SLT,
    M68K_INS_SGT,
    M68K_INS_SLE,
    M68K_INS_STOP,
    M68K_INS_SUB,
    M68K_INS_SUBA,
    M68K_INS_SUBI,
    M68K_INS_SUBQ,
    M68K_INS_SUBX,
    M68K_INS_SWAP,
    M68K_INS_TAS,
    M68K_INS_TRAP,
    M68K_INS_TRAPV,
    M68K_INS_TRAPT,
    M68K_INS_TRAPF,
    M68K_INS_TRAPHI,
    M68K_INS_TRAPLS,
    M68K_INS_TRAPCC,
    M68K_INS_TRAPHS,
    M68K_INS_TRAPCS,
    M68K_INS_TRAPLO,
    M68K_INS_TRAPNE,
    M68K_INS_TRAPEQ,
    M68K_INS_TRAPVC,
    M68K_INS_TRAPVS,
    M68K_INS_TRAPPL,
    M68K_INS_TRAPMI,
    M68K_INS_TRAPGE,
    M68K_INS_TRAPLT,
    M68K_INS_TRAPGT,
    M68K_INS_TRAPLE,
    M68K_INS_TST,
    M68K_INS_UNLK,
    M68K_INS_UNPK,
    M68K_INS_ENDING,   // <-- mark the end of the list of instructions

} m68k_insn;

//> Group of M68K instructions
typedef enum m68k_group_type
{
    M68K_GRP_INVALID = 0,  // CS_GRUP_INVALID
    M68K_GRP_JUMP,  // = CS_GRP_JUMP
    M68K_GRP_RET = 3,  // = CS_GRP_RET
    M68K_GRP_IRET = 5, // = CS_GRP_IRET

    M68K_GRP_ENDING,// <-- mark the end of the list of groups
} m68k_group_type;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/mips.h
================================================
#ifndef CAPSTONE_MIPS_H
#define CAPSTONE_MIPS_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum mips_op_type
{
    MIPS_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    MIPS_OP_REG, // = CS_OP_REG (Register operand).
    MIPS_OP_IMM, // = CS_OP_IMM (Immediate operand).
    MIPS_OP_MEM, // = CS_OP_MEM (Memory operand).
} mips_op_type;

//> MIPS registers
typedef enum mips_reg
{
    MIPS_REG_INVALID = 0,
    //> General purpose registers
    MIPS_REG_PC,

    MIPS_REG_0,
    MIPS_REG_1,
    MIPS_REG_2,
    MIPS_REG_3,
    MIPS_REG_4,
    MIPS_REG_5,
    MIPS_REG_6,
    MIPS_REG_7,
    MIPS_REG_8,
    MIPS_REG_9,
    MIPS_REG_10,
    MIPS_REG_11,
    MIPS_REG_12,
    MIPS_REG_13,
    MIPS_REG_14,
    MIPS_REG_15,
    MIPS_REG_16,
    MIPS_REG_17,
    MIPS_REG_18,
    MIPS_REG_19,
    MIPS_REG_20,
    MIPS_REG_21,
    MIPS_REG_22,
    MIPS_REG_23,
    MIPS_REG_24,
    MIPS_REG_25,
    MIPS_REG_26,
    MIPS_REG_27,
    MIPS_REG_28,
    MIPS_REG_29,
    MIPS_REG_30,
    MIPS_REG_31,

    //> DSP registers
    MIPS_REG_DSPCCOND,
    MIPS_REG_DSPCARRY,
    MIPS_REG_DSPEFI,
    MIPS_REG_DSPOUTFLAG,
    MIPS_REG_DSPOUTFLAG16_19,
    MIPS_REG_DSPOUTFLAG20,
    MIPS_REG_DSPOUTFLAG21,
    MIPS_REG_DSPOUTFLAG22,
    MIPS_REG_DSPOUTFLAG23,
    MIPS_REG_DSPPOS,
    MIPS_REG_DSPSCOUNT,

    //> ACC registers
    MIPS_REG_AC0,
    MIPS_REG_AC1,
    MIPS_REG_AC2,
    MIPS_REG_AC3,

    //> COP registers
    MIPS_REG_CC0,
    MIPS_REG_CC1,
    MIPS_REG_CC2,
    MIPS_REG_CC3,
    MIPS_REG_CC4,
    MIPS_REG_CC5,
    MIPS_REG_CC6,
    MIPS_REG_CC7,

    //> FPU registers
    MIPS_REG_F0,
    MIPS_REG_F1,
    MIPS_REG_F2,
    MIPS_REG_F3,
    MIPS_REG_F4,
    MIPS_REG_F5,
    MIPS_REG_F6,
    MIPS_REG_F7,
    MIPS_REG_F8,
    MIPS_REG_F9,
    MIPS_REG_F10,
    MIPS_REG_F11,
    MIPS_REG_F12,
    MIPS_REG_F13,
    MIPS_REG_F14,
    MIPS_REG_F15,
    MIPS_REG_F16,
    MIPS_REG_F17,
    MIPS_REG_F18,
    MIPS_REG_F19,
    MIPS_REG_F20,
    MIPS_REG_F21,
    MIPS_REG_F22,
    MIPS_REG_F23,
    MIPS_REG_F24,
    MIPS_REG_F25,
    MIPS_REG_F26,
    MIPS_REG_F27,
    MIPS_REG_F28,
    MIPS_REG_F29,
    MIPS_REG_F30,
    MIPS_REG_F31,

    MIPS_REG_FCC0,
    MIPS_REG_FCC1,
    MIPS_REG_FCC2,
    MIPS_REG_FCC3,
    MIPS_REG_FCC4,
    MIPS_REG_FCC5,
    MIPS_REG_FCC6,
    MIPS_REG_FCC7,

    //> AFPR128
    MIPS_REG_W0,
    MIPS_REG_W1,
    MIPS_REG_W2,
    MIPS_REG_W3,
    MIPS_REG_W4,
    MIPS_REG_W5,
    MIPS_REG_W6,
    MIPS_REG_W7,
    MIPS_REG_W8,
    MIPS_REG_W9,
    MIPS_REG_W10,
    MIPS_REG_W11,
    MIPS_REG_W12,
    MIPS_REG_W13,
    MIPS_REG_W14,
    MIPS_REG_W15,
    MIPS_REG_W16,
    MIPS_REG_W17,
    MIPS_REG_W18,
    MIPS_REG_W19,
    MIPS_REG_W20,
    MIPS_REG_W21,
    MIPS_REG_W22,
    MIPS_REG_W23,
    MIPS_REG_W24,
    MIPS_REG_W25,
    MIPS_REG_W26,
    MIPS_REG_W27,
    MIPS_REG_W28,
    MIPS_REG_W29,
    MIPS_REG_W30,
    MIPS_REG_W31,

    MIPS_REG_HI,
    MIPS_REG_LO,

    MIPS_REG_P0,
    MIPS_REG_P1,
    MIPS_REG_P2,

    MIPS_REG_MPL0,
    MIPS_REG_MPL1,
    MIPS_REG_MPL2,

    MIPS_REG_ENDING,    // <-- mark the end of the list or registers

    // alias registers
    MIPS_REG_ZERO = MIPS_REG_0,
    MIPS_REG_AT = MIPS_REG_1,
    MIPS_REG_V0 = MIPS_REG_2,
    MIPS_REG_V1 = MIPS_REG_3,
    MIPS_REG_A0 = MIPS_REG_4,
    MIPS_REG_A1 = MIPS_REG_5,
    MIPS_REG_A2 = MIPS_REG_6,
    MIPS_REG_A3 = MIPS_REG_7,
    MIPS_REG_T0 = MIPS_REG_8,
    MIPS_REG_T1 = MIPS_REG_9,
    MIPS_REG_T2 = MIPS_REG_10,
    MIPS_REG_T3 = MIPS_REG_11,
    MIPS_REG_T4 = MIPS_REG_12,
    MIPS_REG_T5 = MIPS_REG_13,
    MIPS_REG_T6 = MIPS_REG_14,
    MIPS_REG_T7 = MIPS_REG_15,
    MIPS_REG_S0 = MIPS_REG_16,
    MIPS_REG_S1 = MIPS_REG_17,
    MIPS_REG_S2 = MIPS_REG_18,
    MIPS_REG_S3 = MIPS_REG_19,
    MIPS_REG_S4 = MIPS_REG_20,
    MIPS_REG_S5 = MIPS_REG_21,
    MIPS_REG_S6 = MIPS_REG_22,
    MIPS_REG_S7 = MIPS_REG_23,
    MIPS_REG_T8 = MIPS_REG_24,
    MIPS_REG_T9 = MIPS_REG_25,
    MIPS_REG_K0 = MIPS_REG_26,
    MIPS_REG_K1 = MIPS_REG_27,
    MIPS_REG_GP = MIPS_REG_28,
    MIPS_REG_SP = MIPS_REG_29,
    MIPS_REG_FP = MIPS_REG_30, MIPS_REG_S8 = MIPS_REG_30,
    MIPS_REG_RA = MIPS_REG_31,

    MIPS_REG_HI0 = MIPS_REG_AC0,
    MIPS_REG_HI1 = MIPS_REG_AC1,
    MIPS_REG_HI2 = MIPS_REG_AC2,
    MIPS_REG_HI3 = MIPS_REG_AC3,

    MIPS_REG_LO0 = MIPS_REG_HI0,
    MIPS_REG_LO1 = MIPS_REG_HI1,
    MIPS_REG_LO2 = MIPS_REG_HI2,
    MIPS_REG_LO3 = MIPS_REG_HI3,
} mips_reg;

// Instruction's operand referring to memory
// This is associated with MIPS_OP_MEM operand type above
typedef struct mips_op_mem
{
    mips_reg base;  // base register
    int64_t disp;   // displacement/offset value
} mips_op_mem;

// Instruction operand
typedef struct cs_mips_op
{
    mips_op_type type;  // operand type
    union
    {
        mips_reg reg;       // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        mips_op_mem mem;    // base/index/scale/disp value for MEM operand
    };
} cs_mips_op;

// Instruction structure
typedef struct cs_mips
{
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_mips_op operands[8]; // operands for this instruction.
} cs_mips;

//> MIPS instruction
typedef enum mips_insn
{
    MIPS_INS_INVALID = 0,

    MIPS_INS_ABSQ_S,
    MIPS_INS_ADD,
    MIPS_INS_ADDIUPC,
    MIPS_INS_ADDIUR1SP,
    MIPS_INS_ADDIUR2,
    MIPS_INS_ADDIUS5,
    MIPS_INS_ADDIUSP,
    MIPS_INS_ADDQH,
    MIPS_INS_ADDQH_R,
    MIPS_INS_ADDQ,
    MIPS_INS_ADDQ_S,
    MIPS_INS_ADDSC,
    MIPS_INS_ADDS_A,
    MIPS_INS_ADDS_S,
    MIPS_INS_ADDS_U,
    MIPS_INS_ADDU16,
    MIPS_INS_ADDUH,
    MIPS_INS_ADDUH_R,
    MIPS_INS_ADDU,
    MIPS_INS_ADDU_S,
    MIPS_INS_ADDVI,
    MIPS_INS_ADDV,
    MIPS_INS_ADDWC,
    MIPS_INS_ADD_A,
    MIPS_INS_ADDI,
    MIPS_INS_ADDIU,
    MIPS_INS_ALIGN,
    MIPS_INS_ALUIPC,
    MIPS_INS_AND,
    MIPS_INS_AND16,
    MIPS_INS_ANDI16,
    MIPS_INS_ANDI,
    MIPS_INS_APPEND,
    MIPS_INS_ASUB_S,
    MIPS_INS_ASUB_U,
    MIPS_INS_AUI,
    MIPS_INS_AUIPC,
    MIPS_INS_AVER_S,
    MIPS_INS_AVER_U,
    MIPS_INS_AVE_S,
    MIPS_INS_AVE_U,
    MIPS_INS_B16,
    MIPS_INS_BADDU,
    MIPS_INS_BAL,
    MIPS_INS_BALC,
    MIPS_INS_BALIGN,
    MIPS_INS_BBIT0,
    MIPS_INS_BBIT032,
    MIPS_INS_BBIT1,
    MIPS_INS_BBIT132,
    MIPS_INS_BC,
    MIPS_INS_BC0F,
    MIPS_INS_BC0FL,
    MIPS_INS_BC0T,
    MIPS_INS_BC0TL,
    MIPS_INS_BC1EQZ,
    MIPS_INS_BC1F,
    MIPS_INS_BC1FL,
    MIPS_INS_BC1NEZ,
    MIPS_INS_BC1T,
    MIPS_INS_BC1TL,
    MIPS_INS_BC2EQZ,
    MIPS_INS_BC2F,
    MIPS_INS_BC2FL,
    MIPS_INS_BC2NEZ,
    MIPS_INS_BC2T,
    MIPS_INS_BC2TL,
    MIPS_INS_BC3F,
    MIPS_INS_BC3FL,
    MIPS_INS_BC3T,
    MIPS_INS_BC3TL,
    MIPS_INS_BCLRI,
    MIPS_INS_BCLR,
    MIPS_INS_BEQ,
    MIPS_INS_BEQC,
    MIPS_INS_BEQL,
    MIPS_INS_BEQZ16,
    MIPS_INS_BEQZALC,
    MIPS_INS_BEQZC,
    MIPS_INS_BGEC,
    MIPS_INS_BGEUC,
    MIPS_INS_BGEZ,
    MIPS_INS_BGEZAL,
    MIPS_INS_BGEZALC,
    MIPS_INS_BGEZALL,
    MIPS_INS_BGEZALS,
    MIPS_INS_BGEZC,
    MIPS_INS_BGEZL,
    MIPS_INS_BGTZ,
    MIPS_INS_BGTZALC,
    MIPS_INS_BGTZC,
    MIPS_INS_BGTZL,
    MIPS_INS_BINSLI,
    MIPS_INS_BINSL,
    MIPS_INS_BINSRI,
    MIPS_INS_BINSR,
    MIPS_INS_BITREV,
    MIPS_INS_BITSWAP,
    MIPS_INS_BLEZ,
    MIPS_INS_BLEZALC,
    MIPS_INS_BLEZC,
    MIPS_INS_BLEZL,
    MIPS_INS_BLTC,
    MIPS_INS_BLTUC,
    MIPS_INS_BLTZ,
    MIPS_INS_BLTZAL,
    MIPS_INS_BLTZALC,
    MIPS_INS_BLTZALL,
    MIPS_INS_BLTZALS,
    MIPS_INS_BLTZC,
    MIPS_INS_BLTZL,
    MIPS_INS_BMNZI,
    MIPS_INS_BMNZ,
    MIPS_INS_BMZI,
    MIPS_INS_BMZ,
    MIPS_INS_BNE,
    MIPS_INS_BNEC,
    MIPS_INS_BNEGI,
    MIPS_INS_BNEG,
    MIPS_INS_BNEL,
    MIPS_INS_BNEZ16,
    MIPS_INS_BNEZALC,
    MIPS_INS_BNEZC,
    MIPS_INS_BNVC,
    MIPS_INS_BNZ,
    MIPS_INS_BOVC,
    MIPS_INS_BPOSGE32,
    MIPS_INS_BREAK,
    MIPS_INS_BREAK16,
    MIPS_INS_BSELI,
    MIPS_INS_BSEL,
    MIPS_INS_BSETI,
    MIPS_INS_BSET,
    MIPS_INS_BZ,
    MIPS_INS_BEQZ,
    MIPS_INS_B,
    MIPS_INS_BNEZ,
    MIPS_INS_BTEQZ,
    MIPS_INS_BTNEZ,
    MIPS_INS_CACHE,
    MIPS_INS_CEIL,
    MIPS_INS_CEQI,
    MIPS_INS_CEQ,
    MIPS_INS_CFC1,
    MIPS_INS_CFCMSA,
    MIPS_INS_CINS,
    MIPS_INS_CINS32,
    MIPS_INS_CLASS,
    MIPS_INS_CLEI_S,
    MIPS_INS_CLEI_U,
    MIPS_INS_CLE_S,
    MIPS_INS_CLE_U,
    MIPS_INS_CLO,
    MIPS_INS_CLTI_S,
    MIPS_INS_CLTI_U,
    MIPS_INS_CLT_S,
    MIPS_INS_CLT_U,
    MIPS_INS_CLZ,
    MIPS_INS_CMPGDU,
    MIPS_INS_CMPGU,
    MIPS_INS_CMPU,
    MIPS_INS_CMP,
    MIPS_INS_COPY_S,
    MIPS_INS_COPY_U,
    MIPS_INS_CTC1,
    MIPS_INS_CTCMSA,
    MIPS_INS_CVT,
    MIPS_INS_C,
    MIPS_INS_CMPI,
    MIPS_INS_DADD,
    MIPS_INS_DADDI,
    MIPS_INS_DADDIU,
    MIPS_INS_DADDU,
    MIPS_INS_DAHI,
    MIPS_INS_DALIGN,
    MIPS_INS_DATI,
    MIPS_INS_DAUI,
    MIPS_INS_DBITSWAP,
    MIPS_INS_DCLO,
    MIPS_INS_DCLZ,
    MIPS_INS_DDIV,
    MIPS_INS_DDIVU,
    MIPS_INS_DERET,
    MIPS_INS_DEXT,
    MIPS_INS_DEXTM,
    MIPS_INS_DEXTU,
    MIPS_INS_DI,
    MIPS_INS_DINS,
    MIPS_INS_DINSM,
    MIPS_INS_DINSU,
    MIPS_INS_DIV,
    MIPS_INS_DIVU,
    MIPS_INS_DIV_S,
    MIPS_INS_DIV_U,
    MIPS_INS_DLSA,
    MIPS_INS_DMFC0,
    MIPS_INS_DMFC1,
    MIPS_INS_DMFC2,
    MIPS_INS_DMOD,
    MIPS_INS_DMODU,
    MIPS_INS_DMTC0,
    MIPS_INS_DMTC1,
    MIPS_INS_DMTC2,
    MIPS_INS_DMUH,
    MIPS_INS_DMUHU,
    MIPS_INS_DMUL,
    MIPS_INS_DMULT,
    MIPS_INS_DMULTU,
    MIPS_INS_DMULU,
    MIPS_INS_DOTP_S,
    MIPS_INS_DOTP_U,
    MIPS_INS_DPADD_S,
    MIPS_INS_DPADD_U,
    MIPS_INS_DPAQX_SA,
    MIPS_INS_DPAQX_S,
    MIPS_INS_DPAQ_SA,
    MIPS_INS_DPAQ_S,
    MIPS_INS_DPAU,
    MIPS_INS_DPAX,
    MIPS_INS_DPA,
    MIPS_INS_DPOP,
    MIPS_INS_DPSQX_SA,
    MIPS_INS_DPSQX_S,
    MIPS_INS_DPSQ_SA,
    MIPS_INS_DPSQ_S,
    MIPS_INS_DPSUB_S,
    MIPS_INS_DPSUB_U,
    MIPS_INS_DPSU,
    MIPS_INS_DPSX,
    MIPS_INS_DPS,
    MIPS_INS_DROTR,
    MIPS_INS_DROTR32,
    MIPS_INS_DROTRV,
    MIPS_INS_DSBH,
    MIPS_INS_DSHD,
    MIPS_INS_DSLL,
    MIPS_INS_DSLL32,
    MIPS_INS_DSLLV,
    MIPS_INS_DSRA,
    MIPS_INS_DSRA32,
    MIPS_INS_DSRAV,
    MIPS_INS_DSRL,
    MIPS_INS_DSRL32,
    MIPS_INS_DSRLV,
    MIPS_INS_DSUB,
    MIPS_INS_DSUBU,
    MIPS_INS_EHB,
    MIPS_INS_EI,
    MIPS_INS_ERET,
    MIPS_INS_EXT,
    MIPS_INS_EXTP,
    MIPS_INS_EXTPDP,
    MIPS_INS_EXTPDPV,
    MIPS_INS_EXTPV,
    MIPS_INS_EXTRV_RS,
    MIPS_INS_EXTRV_R,
    MIPS_INS_EXTRV_S,
    MIPS_INS_EXTRV,
    MIPS_INS_EXTR_RS,
    MIPS_INS_EXTR_R,
    MIPS_INS_EXTR_S,
    MIPS_INS_EXTR,
    MIPS_INS_EXTS,
    MIPS_INS_EXTS32,
    MIPS_INS_ABS,
    MIPS_INS_FADD,
    MIPS_INS_FCAF,
    MIPS_INS_FCEQ,
    MIPS_INS_FCLASS,
    MIPS_INS_FCLE,
    MIPS_INS_FCLT,
    MIPS_INS_FCNE,
    MIPS_INS_FCOR,
    MIPS_INS_FCUEQ,
    MIPS_INS_FCULE,
    MIPS_INS_FCULT,
    MIPS_INS_FCUNE,
    MIPS_INS_FCUN,
    MIPS_INS_FDIV,
    MIPS_INS_FEXDO,
    MIPS_INS_FEXP2,
    MIPS_INS_FEXUPL,
    MIPS_INS_FEXUPR,
    MIPS_INS_FFINT_S,
    MIPS_INS_FFINT_U,
    MIPS_INS_FFQL,
    MIPS_INS_FFQR,
    MIPS_INS_FILL,
    MIPS_INS_FLOG2,
    MIPS_INS_FLOOR,
    MIPS_INS_FMADD,
    MIPS_INS_FMAX_A,
    MIPS_INS_FMAX,
    MIPS_INS_FMIN_A,
    MIPS_INS_FMIN,
    MIPS_INS_MOV,
    MIPS_INS_FMSUB,
    MIPS_INS_FMUL,
    MIPS_INS_MUL,
    MIPS_INS_NEG,
    MIPS_INS_FRCP,
    MIPS_INS_FRINT,
    MIPS_INS_FRSQRT,
    MIPS_INS_FSAF,
    MIPS_INS_FSEQ,
    MIPS_INS_FSLE,
    MIPS_INS_FSLT,
    MIPS_INS_FSNE,
    MIPS_INS_FSOR,
    MIPS_INS_FSQRT,
    MIPS_INS_SQRT,
    MIPS_INS_FSUB,
    MIPS_INS_SUB,
    MIPS_INS_FSUEQ,
    MIPS_INS_FSULE,
    MIPS_INS_FSULT,
    MIPS_INS_FSUNE,
    MIPS_INS_FSUN,
    MIPS_INS_FTINT_S,
    MIPS_INS_FTINT_U,
    MIPS_INS_FTQ,
    MIPS_INS_FTRUNC_S,
    MIPS_INS_FTRUNC_U,
    MIPS_INS_HADD_S,
    MIPS_INS_HADD_U,
    MIPS_INS_HSUB_S,
    MIPS_INS_HSUB_U,
    MIPS_INS_ILVEV,
    MIPS_INS_ILVL,
    MIPS_INS_ILVOD,
    MIPS_INS_ILVR,
    MIPS_INS_INS,
    MIPS_INS_INSERT,
    MIPS_INS_INSV,
    MIPS_INS_INSVE,
    MIPS_INS_J,
    MIPS_INS_JAL,
    MIPS_INS_JALR,
    MIPS_INS_JALRS16,
    MIPS_INS_JALRS,
    MIPS_INS_JALS,
    MIPS_INS_JALX,
    MIPS_INS_JIALC,
    MIPS_INS_JIC,
    MIPS_INS_JR,
    MIPS_INS_JR16,
    MIPS_INS_JRADDIUSP,
    MIPS_INS_JRC,
    MIPS_INS_JALRC,
    MIPS_INS_LB,
    MIPS_INS_LBU16,
    MIPS_INS_LBUX,
    MIPS_INS_LBU,
    MIPS_INS_LD,
    MIPS_INS_LDC1,
    MIPS_INS_LDC2,
    MIPS_INS_LDC3,
    MIPS_INS_LDI,
    MIPS_INS_LDL,
    MIPS_INS_LDPC,
    MIPS_INS_LDR,
    MIPS_INS_LDXC1,
    MIPS_INS_LH,
    MIPS_INS_LHU16,
    MIPS_INS_LHX,
    MIPS_INS_LHU,
    MIPS_INS_LI16,
    MIPS_INS_LL,
    MIPS_INS_LLD,
    MIPS_INS_LSA,
    MIPS_INS_LUXC1,
    MIPS_INS_LUI,
    MIPS_INS_LW,
    MIPS_INS_LW16,
    MIPS_INS_LWC1,
    MIPS_INS_LWC2,
    MIPS_INS_LWC3,
    MIPS_INS_LWL,
    MIPS_INS_LWM16,
    MIPS_INS_LWM32,
    MIPS_INS_LWPC,
    MIPS_INS_LWP,
    MIPS_INS_LWR,
    MIPS_INS_LWUPC,
    MIPS_INS_LWU,
    MIPS_INS_LWX,
    MIPS_INS_LWXC1,
    MIPS_INS_LWXS,
    MIPS_INS_LI,
    MIPS_INS_MADD,
    MIPS_INS_MADDF,
    MIPS_INS_MADDR_Q,
    MIPS_INS_MADDU,
    MIPS_INS_MADDV,
    MIPS_INS_MADD_Q,
    MIPS_INS_MAQ_SA,
    MIPS_INS_MAQ_S,
    MIPS_INS_MAXA,
    MIPS_INS_MAXI_S,
    MIPS_INS_MAXI_U,
    MIPS_INS_MAX_A,
    MIPS_INS_MAX,
    MIPS_INS_MAX_S,
    MIPS_INS_MAX_U,
    MIPS_INS_MFC0,
    MIPS_INS_MFC1,
    MIPS_INS_MFC2,
    MIPS_INS_MFHC1,
    MIPS_INS_MFHI,
    MIPS_INS_MFLO,
    MIPS_INS_MINA,
    MIPS_INS_MINI_S,
    MIPS_INS_MINI_U,
    MIPS_INS_MIN_A,
    MIPS_INS_MIN,
    MIPS_INS_MIN_S,
    MIPS_INS_MIN_U,
    MIPS_INS_MOD,
    MIPS_INS_MODSUB,
    MIPS_INS_MODU,
    MIPS_INS_MOD_S,
    MIPS_INS_MOD_U,
    MIPS_INS_MOVE,
    MIPS_INS_MOVEP,
    MIPS_INS_MOVF,
    MIPS_INS_MOVN,
    MIPS_INS_MOVT,
    MIPS_INS_MOVZ,
    MIPS_INS_MSUB,
    MIPS_INS_MSUBF,
    MIPS_INS_MSUBR_Q,
    MIPS_INS_MSUBU,
    MIPS_INS_MSUBV,
    MIPS_INS_MSUB_Q,
    MIPS_INS_MTC0,
    MIPS_INS_MTC1,
    MIPS_INS_MTC2,
    MIPS_INS_MTHC1,
    MIPS_INS_MTHI,
    MIPS_INS_MTHLIP,
    MIPS_INS_MTLO,
    MIPS_INS_MTM0,
    MIPS_INS_MTM1,
    MIPS_INS_MTM2,
    MIPS_INS_MTP0,
    MIPS_INS_MTP1,
    MIPS_INS_MTP2,
    MIPS_INS_MUH,
    MIPS_INS_MUHU,
    MIPS_INS_MULEQ_S,
    MIPS_INS_MULEU_S,
    MIPS_INS_MULQ_RS,
    MIPS_INS_MULQ_S,
    MIPS_INS_MULR_Q,
    MIPS_INS_MULSAQ_S,
    MIPS_INS_MULSA,
    MIPS_INS_MULT,
    MIPS_INS_MULTU,
    MIPS_INS_MULU,
    MIPS_INS_MULV,
    MIPS_INS_MUL_Q,
    MIPS_INS_MUL_S,
    MIPS_INS_NLOC,
    MIPS_INS_NLZC,
    MIPS_INS_NMADD,
    MIPS_INS_NMSUB,
    MIPS_INS_NOR,
    MIPS_INS_NORI,
    MIPS_INS_NOT16,
    MIPS_INS_NOT,
    MIPS_INS_OR,
    MIPS_INS_OR16,
    MIPS_INS_ORI,
    MIPS_INS_PACKRL,
    MIPS_INS_PAUSE,
    MIPS_INS_PCKEV,
    MIPS_INS_PCKOD,
    MIPS_INS_PCNT,
    MIPS_INS_PICK,
    MIPS_INS_POP,
    MIPS_INS_PRECEQU,
    MIPS_INS_PRECEQ,
    MIPS_INS_PRECEU,
    MIPS_INS_PRECRQU_S,
    MIPS_INS_PRECRQ,
    MIPS_INS_PRECRQ_RS,
    MIPS_INS_PRECR,
    MIPS_INS_PRECR_SRA,
    MIPS_INS_PRECR_SRA_R,
    MIPS_INS_PREF,
    MIPS_INS_PREPEND,
    MIPS_INS_RADDU,
    MIPS_INS_RDDSP,
    MIPS_INS_RDHWR,
    MIPS_INS_REPLV,
    MIPS_INS_REPL,
    MIPS_INS_RINT,
    MIPS_INS_ROTR,
    MIPS_INS_ROTRV,
    MIPS_INS_ROUND,
    MIPS_INS_SAT_S,
    MIPS_INS_SAT_U,
    MIPS_INS_SB,
    MIPS_INS_SB16,
    MIPS_INS_SC,
    MIPS_INS_SCD,
    MIPS_INS_SD,
    MIPS_INS_SDBBP,
    MIPS_INS_SDBBP16,
    MIPS_INS_SDC1,
    MIPS_INS_SDC2,
    MIPS_INS_SDC3,
    MIPS_INS_SDL,
    MIPS_INS_SDR,
    MIPS_INS_SDXC1,
    MIPS_INS_SEB,
    MIPS_INS_SEH,
    MIPS_INS_SELEQZ,
    MIPS_INS_SELNEZ,
    MIPS_INS_SEL,
    MIPS_INS_SEQ,
    MIPS_INS_SEQI,
    MIPS_INS_SH,
    MIPS_INS_SH16,
    MIPS_INS_SHF,
    MIPS_INS_SHILO,
    MIPS_INS_SHILOV,
    MIPS_INS_SHLLV,
    MIPS_INS_SHLLV_S,
    MIPS_INS_SHLL,
    MIPS_INS_SHLL_S,
    MIPS_INS_SHRAV,
    MIPS_INS_SHRAV_R,
    MIPS_INS_SHRA,
    MIPS_INS_SHRA_R,
    MIPS_INS_SHRLV,
    MIPS_INS_SHRL,
    MIPS_INS_SLDI,
    MIPS_INS_SLD,
    MIPS_INS_SLL,
    MIPS_INS_SLL16,
    MIPS_INS_SLLI,
    MIPS_INS_SLLV,
    MIPS_INS_SLT,
    MIPS_INS_SLTI,
    MIPS_INS_SLTIU,
    MIPS_INS_SLTU,
    MIPS_INS_SNE,
    MIPS_INS_SNEI,
    MIPS_INS_SPLATI,
    MIPS_INS_SPLAT,
    MIPS_INS_SRA,
    MIPS_INS_SRAI,
    MIPS_INS_SRARI,
    MIPS_INS_SRAR,
    MIPS_INS_SRAV,
    MIPS_INS_SRL,
    MIPS_INS_SRL16,
    MIPS_INS_SRLI,
    MIPS_INS_SRLRI,
    MIPS_INS_SRLR,
    MIPS_INS_SRLV,
    MIPS_INS_SSNOP,
    MIPS_INS_ST,
    MIPS_INS_SUBQH,
    MIPS_INS_SUBQH_R,
    MIPS_INS_SUBQ,
    MIPS_INS_SUBQ_S,
    MIPS_INS_SUBSUS_U,
    MIPS_INS_SUBSUU_S,
    MIPS_INS_SUBS_S,
    MIPS_INS_SUBS_U,
    MIPS_INS_SUBU16,
    MIPS_INS_SUBUH,
    MIPS_INS_SUBUH_R,
    MIPS_INS_SUBU,
    MIPS_INS_SUBU_S,
    MIPS_INS_SUBVI,
    MIPS_INS_SUBV,
    MIPS_INS_SUXC1,
    MIPS_INS_SW,
    MIPS_INS_SW16,
    MIPS_INS_SWC1,
    MIPS_INS_SWC2,
    MIPS_INS_SWC3,
    MIPS_INS_SWL,
    MIPS_INS_SWM16,
    MIPS_INS_SWM32,
    MIPS_INS_SWP,
    MIPS_INS_SWR,
    MIPS_INS_SWXC1,
    MIPS_INS_SYNC,
    MIPS_INS_SYNCI,
    MIPS_INS_SYSCALL,
    MIPS_INS_TEQ,
    MIPS_INS_TEQI,
    MIPS_INS_TGE,
    MIPS_INS_TGEI,
    MIPS_INS_TGEIU,
    MIPS_INS_TGEU,
    MIPS_INS_TLBP,
    MIPS_INS_TLBR,
    MIPS_INS_TLBWI,
    MIPS_INS_TLBWR,
    MIPS_INS_TLT,
    MIPS_INS_TLTI,
    MIPS_INS_TLTIU,
    MIPS_INS_TLTU,
    MIPS_INS_TNE,
    MIPS_INS_TNEI,
    MIPS_INS_TRUNC,
    MIPS_INS_V3MULU,
    MIPS_INS_VMM0,
    MIPS_INS_VMULU,
    MIPS_INS_VSHF,
    MIPS_INS_WAIT,
    MIPS_INS_WRDSP,
    MIPS_INS_WSBH,
    MIPS_INS_XOR,
    MIPS_INS_XOR16,
    MIPS_INS_XORI,

    //> some alias instructions
    MIPS_INS_NOP,
    MIPS_INS_NEGU,

    //> special instructions
    MIPS_INS_JALR_HB,   // jump and link with Hazard Barrier
    MIPS_INS_JR_HB,     // jump register with Hazard Barrier

    MIPS_INS_ENDING,
} mips_insn;

//> Group of MIPS instructions
typedef enum mips_insn_group
{
    MIPS_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    MIPS_GRP_JUMP,  // = CS_GRP_JUMP
    // all call instructions
    MIPS_GRP_CALL,  // = CS_GRP_CALL
    // all return instructions
    MIPS_GRP_RET,   // = CS_GRP_RET
    // all interrupt instructions (int+syscall)
    MIPS_GRP_INT,   // = CS_GRP_INT
    // all interrupt return instructions
    MIPS_GRP_IRET,  // = CS_GRP_IRET
    // all privileged instructions
    MIPS_GRP_PRIVILEGE, // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    MIPS_GRP_BITCOUNT = 128,
    MIPS_GRP_DSP,
    MIPS_GRP_DSPR2,
    MIPS_GRP_FPIDX,
    MIPS_GRP_MSA,
    MIPS_GRP_MIPS32R2,
    MIPS_GRP_MIPS64,
    MIPS_GRP_MIPS64R2,
    MIPS_GRP_SEINREG,
    MIPS_GRP_STDENC,
    MIPS_GRP_SWAP,
    MIPS_GRP_MICROMIPS,
    MIPS_GRP_MIPS16MODE,
    MIPS_GRP_FP64BIT,
    MIPS_GRP_NONANSFPMATH,
    MIPS_GRP_NOTFP64BIT,
    MIPS_GRP_NOTINMICROMIPS,
    MIPS_GRP_NOTNACL,
    MIPS_GRP_NOTMIPS32R6,
    MIPS_GRP_NOTMIPS64R6,
    MIPS_GRP_CNMIPS,
    MIPS_GRP_MIPS32,
    MIPS_GRP_MIPS32R6,
    MIPS_GRP_MIPS64R6,
    MIPS_GRP_MIPS2,
    MIPS_GRP_MIPS3,
    MIPS_GRP_MIPS3_32,
    MIPS_GRP_MIPS3_32R2,
    MIPS_GRP_MIPS4_32,
    MIPS_GRP_MIPS4_32R2,
    MIPS_GRP_MIPS5_32R2,
    MIPS_GRP_GP32BIT,
    MIPS_GRP_GP64BIT,

    MIPS_GRP_ENDING,
} mips_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/platform.h
================================================
/* Capstone Disassembly Engine */
/* By Axel Souchet & Nguyen Anh Quynh, 2014 */

#ifndef CAPSTONE_PLATFORM_H
#define CAPSTONE_PLATFORM_H


// handle C99 issue (for pre-2013 VisualStudio)
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < 1800) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif  // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif  // (_MSC_VER < 1800) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif  // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))


// handle inttypes.h / stdint.h compatibility
#if defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)
#include "windowsce/stdint.h"
#endif  // defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)

#if defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))
// this system does not have inttypes.h

#if defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE))
// this system does not have stdint.h
typedef signed char  int8_t;
typedef signed short int16_t;
typedef signed int   int32_t;
typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int   uint32_t;
typedef signed long long   int64_t;
typedef unsigned long long uint64_t;

#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64
#endif  // defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE))

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8         __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8         __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8         __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8         __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8         __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8         __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16        "hd"
#define PRIi16        "hi"
#define PRIo16        "ho"
#define PRIu16        "hu"
#define PRIx16        "hx"
#define PRIX16        "hX"

#if defined(_MSC_VER) && _MSC_VER <= 1700
#define PRId32        "ld"
#define PRIi32        "li"
#define PRIo32        "lo"
#define PRIu32        "lu"
#define PRIx32        "lx"
#define PRIX32        "lX"
#else   // OSX
#define PRId32        "d"
#define PRIi32        "i"
#define PRIo32        "o"
#define PRIu32        "u"
#define PRIx32        "x"
#define PRIX32        "X"
#endif  // defined(_MSC_VER) && _MSC_VER <= 1700

#define PRId64        __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64        __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64        __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64        __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64        __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64        __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif  // defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))

#endif



================================================
File: x64dbg_pluginsdk/capstone/ppc.h
================================================
#ifndef CAPSTONE_PPC_H
#define CAPSTONE_PPC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> PPC branch codes for some branch instructions
typedef enum ppc_bc
{
    PPC_BC_INVALID  = 0,
    PPC_BC_LT       = (0 << 5) | 12,
    PPC_BC_LE       = (1 << 5) |  4,
    PPC_BC_EQ       = (2 << 5) | 12,
    PPC_BC_GE       = (0 << 5) |  4,
    PPC_BC_GT       = (1 << 5) | 12,
    PPC_BC_NE       = (2 << 5) |  4,
    PPC_BC_UN       = (3 << 5) | 12,
    PPC_BC_NU       = (3 << 5) |  4,

    // extra conditions
    PPC_BC_SO = (4 << 5) | 12,  // summary overflow
    PPC_BC_NS = (4 << 5) | 4,   // not summary overflow
} ppc_bc;

//> PPC branch hint for some branch instructions
typedef enum ppc_bh
{
    PPC_BH_INVALID = 0, // no hint
    PPC_BH_PLUS,    // PLUS hint
    PPC_BH_MINUS,   // MINUS hint
} ppc_bh;

//> Operand type for instruction's operands
typedef enum ppc_op_type
{
    PPC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    PPC_OP_REG, // = CS_OP_REG (Register operand).
    PPC_OP_IMM, // = CS_OP_IMM (Immediate operand).
    PPC_OP_MEM, // = CS_OP_MEM (Memory operand).
    PPC_OP_CRX = 64,    // Condition Register field
} ppc_op_type;

//> PPC registers
typedef enum ppc_reg
{
    PPC_REG_INVALID = 0,

    PPC_REG_CARRY,
    PPC_REG_CR0,
    PPC_REG_CR1,
    PPC_REG_CR2,
    PPC_REG_CR3,
    PPC_REG_CR4,
    PPC_REG_CR5,
    PPC_REG_CR6,
    PPC_REG_CR7,
    PPC_REG_CTR,
    PPC_REG_F0,
    PPC_REG_F1,
    PPC_REG_F2,
    PPC_REG_F3,
    PPC_REG_F4,
    PPC_REG_F5,
    PPC_REG_F6,
    PPC_REG_F7,
    PPC_REG_F8,
    PPC_REG_F9,
    PPC_REG_F10,
    PPC_REG_F11,
    PPC_REG_F12,
    PPC_REG_F13,
    PPC_REG_F14,
    PPC_REG_F15,
    PPC_REG_F16,
    PPC_REG_F17,
    PPC_REG_F18,
    PPC_REG_F19,
    PPC_REG_F20,
    PPC_REG_F21,
    PPC_REG_F22,
    PPC_REG_F23,
    PPC_REG_F24,
    PPC_REG_F25,
    PPC_REG_F26,
    PPC_REG_F27,
    PPC_REG_F28,
    PPC_REG_F29,
    PPC_REG_F30,
    PPC_REG_F31,
    PPC_REG_LR,
    PPC_REG_R0,
    PPC_REG_R1,
    PPC_REG_R2,
    PPC_REG_R3,
    PPC_REG_R4,
    PPC_REG_R5,
    PPC_REG_R6,
    PPC_REG_R7,
    PPC_REG_R8,
    PPC_REG_R9,
    PPC_REG_R10,
    PPC_REG_R11,
    PPC_REG_R12,
    PPC_REG_R13,
    PPC_REG_R14,
    PPC_REG_R15,
    PPC_REG_R16,
    PPC_REG_R17,
    PPC_REG_R18,
    PPC_REG_R19,
    PPC_REG_R20,
    PPC_REG_R21,
    PPC_REG_R22,
    PPC_REG_R23,
    PPC_REG_R24,
    PPC_REG_R25,
    PPC_REG_R26,
    PPC_REG_R27,
    PPC_REG_R28,
    PPC_REG_R29,
    PPC_REG_R30,
    PPC_REG_R31,
    PPC_REG_V0,
    PPC_REG_V1,
    PPC_REG_V2,
    PPC_REG_V3,
    PPC_REG_V4,
    PPC_REG_V5,
    PPC_REG_V6,
    PPC_REG_V7,
    PPC_REG_V8,
    PPC_REG_V9,
    PPC_REG_V10,
    PPC_REG_V11,
    PPC_REG_V12,
    PPC_REG_V13,
    PPC_REG_V14,
    PPC_REG_V15,
    PPC_REG_V16,
    PPC_REG_V17,
    PPC_REG_V18,
    PPC_REG_V19,
    PPC_REG_V20,
    PPC_REG_V21,
    PPC_REG_V22,
    PPC_REG_V23,
    PPC_REG_V24,
    PPC_REG_V25,
    PPC_REG_V26,
    PPC_REG_V27,
    PPC_REG_V28,
    PPC_REG_V29,
    PPC_REG_V30,
    PPC_REG_V31,
    PPC_REG_VRSAVE,
    PPC_REG_VS0,
    PPC_REG_VS1,
    PPC_REG_VS2,
    PPC_REG_VS3,
    PPC_REG_VS4,
    PPC_REG_VS5,
    PPC_REG_VS6,
    PPC_REG_VS7,
    PPC_REG_VS8,
    PPC_REG_VS9,
    PPC_REG_VS10,
    PPC_REG_VS11,
    PPC_REG_VS12,
    PPC_REG_VS13,
    PPC_REG_VS14,
    PPC_REG_VS15,
    PPC_REG_VS16,
    PPC_REG_VS17,
    PPC_REG_VS18,
    PPC_REG_VS19,
    PPC_REG_VS20,
    PPC_REG_VS21,
    PPC_REG_VS22,
    PPC_REG_VS23,
    PPC_REG_VS24,
    PPC_REG_VS25,
    PPC_REG_VS26,
    PPC_REG_VS27,
    PPC_REG_VS28,
    PPC_REG_VS29,
    PPC_REG_VS30,
    PPC_REG_VS31,
    PPC_REG_VS32,
    PPC_REG_VS33,
    PPC_REG_VS34,
    PPC_REG_VS35,
    PPC_REG_VS36,
    PPC_REG_VS37,
    PPC_REG_VS38,
    PPC_REG_VS39,
    PPC_REG_VS40,
    PPC_REG_VS41,
    PPC_REG_VS42,
    PPC_REG_VS43,
    PPC_REG_VS44,
    PPC_REG_VS45,
    PPC_REG_VS46,
    PPC_REG_VS47,
    PPC_REG_VS48,
    PPC_REG_VS49,
    PPC_REG_VS50,
    PPC_REG_VS51,
    PPC_REG_VS52,
    PPC_REG_VS53,
    PPC_REG_VS54,
    PPC_REG_VS55,
    PPC_REG_VS56,
    PPC_REG_VS57,
    PPC_REG_VS58,
    PPC_REG_VS59,
    PPC_REG_VS60,
    PPC_REG_VS61,
    PPC_REG_VS62,
    PPC_REG_VS63,
    PPC_REG_Q0,
    PPC_REG_Q1,
    PPC_REG_Q2,
    PPC_REG_Q3,
    PPC_REG_Q4,
    PPC_REG_Q5,
    PPC_REG_Q6,
    PPC_REG_Q7,
    PPC_REG_Q8,
    PPC_REG_Q9,
    PPC_REG_Q10,
    PPC_REG_Q11,
    PPC_REG_Q12,
    PPC_REG_Q13,
    PPC_REG_Q14,
    PPC_REG_Q15,
    PPC_REG_Q16,
    PPC_REG_Q17,
    PPC_REG_Q18,
    PPC_REG_Q19,
    PPC_REG_Q20,
    PPC_REG_Q21,
    PPC_REG_Q22,
    PPC_REG_Q23,
    PPC_REG_Q24,
    PPC_REG_Q25,
    PPC_REG_Q26,
    PPC_REG_Q27,
    PPC_REG_Q28,
    PPC_REG_Q29,
    PPC_REG_Q30,
    PPC_REG_Q31,

    // extra registers for PPCMapping.c
    PPC_REG_RM,
    PPC_REG_CTR8,
    PPC_REG_LR8,
    PPC_REG_CR1EQ,
    PPC_REG_X2,

    PPC_REG_ENDING,   // <-- mark the end of the list of registers
} ppc_reg;

// Instruction's operand referring to memory
// This is associated with PPC_OP_MEM operand type above
typedef struct ppc_op_mem
{
    ppc_reg base;   // base register
    int32_t disp;   // displacement/offset value
} ppc_op_mem;

typedef struct ppc_op_crx
{
    unsigned int scale;
    ppc_reg reg;
    ppc_bc cond;
} ppc_op_crx;

// Instruction operand
typedef struct cs_ppc_op
{
    ppc_op_type type;   // operand type
    union
    {
        ppc_reg reg;    // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        ppc_op_mem mem;     // base/disp value for MEM operand
        ppc_op_crx crx;     // operand with condition register
    };
} cs_ppc_op;

// Instruction structure
typedef struct cs_ppc
{
    // branch code for branch instructions
    ppc_bc bc;

    // branch hint for branch instructions
    ppc_bh bh;

    // if update_cr0 = True, then this 'dot' insn updates CR0
    bool update_cr0;

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_ppc_op operands[8]; // operands for this instruction.
} cs_ppc;

//> PPC instruction
typedef enum ppc_insn
{
    PPC_INS_INVALID = 0,

    PPC_INS_ADD,
    PPC_INS_ADDC,
    PPC_INS_ADDE,
    PPC_INS_ADDI,
    PPC_INS_ADDIC,
    PPC_INS_ADDIS,
    PPC_INS_ADDME,
    PPC_INS_ADDZE,
    PPC_INS_AND,
    PPC_INS_ANDC,
    PPC_INS_ANDIS,
    PPC_INS_ANDI,
    PPC_INS_ATTN,
    PPC_INS_B,
    PPC_INS_BA,
    PPC_INS_BC,
    PPC_INS_BCCTR,
    PPC_INS_BCCTRL,
    PPC_INS_BCL,
    PPC_INS_BCLR,
    PPC_INS_BCLRL,
    PPC_INS_BCTR,
    PPC_INS_BCTRL,
    PPC_INS_BCT,
    PPC_INS_BDNZ,
    PPC_INS_BDNZA,
    PPC_INS_BDNZL,
    PPC_INS_BDNZLA,
    PPC_INS_BDNZLR,
    PPC_INS_BDNZLRL,
    PPC_INS_BDZ,
    PPC_INS_BDZA,
    PPC_INS_BDZL,
    PPC_INS_BDZLA,
    PPC_INS_BDZLR,
    PPC_INS_BDZLRL,
    PPC_INS_BL,
    PPC_INS_BLA,
    PPC_INS_BLR,
    PPC_INS_BLRL,
    PPC_INS_BRINC,
    PPC_INS_CMPB,
    PPC_INS_CMPD,
    PPC_INS_CMPDI,
    PPC_INS_CMPLD,
    PPC_INS_CMPLDI,
    PPC_INS_CMPLW,
    PPC_INS_CMPLWI,
    PPC_INS_CMPW,
    PPC_INS_CMPWI,
    PPC_INS_CNTLZD,
    PPC_INS_CNTLZW,
    PPC_INS_CREQV,
    PPC_INS_CRXOR,
    PPC_INS_CRAND,
    PPC_INS_CRANDC,
    PPC_INS_CRNAND,
    PPC_INS_CRNOR,
    PPC_INS_CROR,
    PPC_INS_CRORC,
    PPC_INS_DCBA,
    PPC_INS_DCBF,
    PPC_INS_DCBI,
    PPC_INS_DCBST,
    PPC_INS_DCBT,
    PPC_INS_DCBTST,
    PPC_INS_DCBZ,
    PPC_INS_DCBZL,
    PPC_INS_DCCCI,
    PPC_INS_DIVD,
    PPC_INS_DIVDU,
    PPC_INS_DIVW,
    PPC_INS_DIVWU,
    PPC_INS_DSS,
    PPC_INS_DSSALL,
    PPC_INS_DST,
    PPC_INS_DSTST,
    PPC_INS_DSTSTT,
    PPC_INS_DSTT,
    PPC_INS_EQV,
    PPC_INS_EVABS,
    PPC_INS_EVADDIW,
    PPC_INS_EVADDSMIAAW,
    PPC_INS_EVADDSSIAAW,
    PPC_INS_EVADDUMIAAW,
    PPC_INS_EVADDUSIAAW,
    PPC_INS_EVADDW,
    PPC_INS_EVAND,
    PPC_INS_EVANDC,
    PPC_INS_EVCMPEQ,
    PPC_INS_EVCMPGTS,
    PPC_INS_EVCMPGTU,
    PPC_INS_EVCMPLTS,
    PPC_INS_EVCMPLTU,
    PPC_INS_EVCNTLSW,
    PPC_INS_EVCNTLZW,
    PPC_INS_EVDIVWS,
    PPC_INS_EVDIVWU,
    PPC_INS_EVEQV,
    PPC_INS_EVEXTSB,
    PPC_INS_EVEXTSH,
    PPC_INS_EVLDD,
    PPC_INS_EVLDDX,
    PPC_INS_EVLDH,
    PPC_INS_EVLDHX,
    PPC_INS_EVLDW,
    PPC_INS_EVLDWX,
    PPC_INS_EVLHHESPLAT,
    PPC_INS_EVLHHESPLATX,
    PPC_INS_EVLHHOSSPLAT,
    PPC_INS_EVLHHOSSPLATX,
    PPC_INS_EVLHHOUSPLAT,
    PPC_INS_EVLHHOUSPLATX,
    PPC_INS_EVLWHE,
    PPC_INS_EVLWHEX,
    PPC_INS_EVLWHOS,
    PPC_INS_EVLWHOSX,
    PPC_INS_EVLWHOU,
    PPC_INS_EVLWHOUX,
    PPC_INS_EVLWHSPLAT,
    PPC_INS_EVLWHSPLATX,
    PPC_INS_EVLWWSPLAT,
    PPC_INS_EVLWWSPLATX,
    PPC_INS_EVMERGEHI,
    PPC_INS_EVMERGEHILO,
    PPC_INS_EVMERGELO,
    PPC_INS_EVMERGELOHI,
    PPC_INS_EVMHEGSMFAA,
    PPC_INS_EVMHEGSMFAN,
    PPC_INS_EVMHEGSMIAA,
    PPC_INS_EVMHEGSMIAN,
    PPC_INS_EVMHEGUMIAA,
    PPC_INS_EVMHEGUMIAN,
    PPC_INS_EVMHESMF,
    PPC_INS_EVMHESMFA,
    PPC_INS_EVMHESMFAAW,
    PPC_INS_EVMHESMFANW,
    PPC_INS_EVMHESMI,
    PPC_INS_EVMHESMIA,
    PPC_INS_EVMHESMIAAW,
    PPC_INS_EVMHESMIANW,
    PPC_INS_EVMHESSF,
    PPC_INS_EVMHESSFA,
    PPC_INS_EVMHESSFAAW,
    PPC_INS_EVMHESSFANW,
    PPC_INS_EVMHESSIAAW,
    PPC_INS_EVMHESSIANW,
    PPC_INS_EVMHEUMI,
    PPC_INS_EVMHEUMIA,
    PPC_INS_EVMHEUMIAAW,
    PPC_INS_EVMHEUMIANW,
    PPC_INS_EVMHEUSIAAW,
    PPC_INS_EVMHEUSIANW,
    PPC_INS_EVMHOGSMFAA,
    PPC_INS_EVMHOGSMFAN,
    PPC_INS_EVMHOGSMIAA,
    PPC_INS_EVMHOGSMIAN,
    PPC_INS_EVMHOGUMIAA,
    PPC_INS_EVMHOGUMIAN,
    PPC_INS_EVMHOSMF,
    PPC_INS_EVMHOSMFA,
    PPC_INS_EVMHOSMFAAW,
    PPC_INS_EVMHOSMFANW,
    PPC_INS_EVMHOSMI,
    PPC_INS_EVMHOSMIA,
    PPC_INS_EVMHOSMIAAW,
    PPC_INS_EVMHOSMIANW,
    PPC_INS_EVMHOSSF,
    PPC_INS_EVMHOSSFA,
    PPC_INS_EVMHOSSFAAW,
    PPC_INS_EVMHOSSFANW,
    PPC_INS_EVMHOSSIAAW,
    PPC_INS_EVMHOSSIANW,
    PPC_INS_EVMHOUMI,
    PPC_INS_EVMHOUMIA,
    PPC_INS_EVMHOUMIAAW,
    PPC_INS_EVMHOUMIANW,
    PPC_INS_EVMHOUSIAAW,
    PPC_INS_EVMHOUSIANW,
    PPC_INS_EVMRA,
    PPC_INS_EVMWHSMF,
    PPC_INS_EVMWHSMFA,
    PPC_INS_EVMWHSMI,
    PPC_INS_EVMWHSMIA,
    PPC_INS_EVMWHSSF,
    PPC_INS_EVMWHSSFA,
    PPC_INS_EVMWHUMI,
    PPC_INS_EVMWHUMIA,
    PPC_INS_EVMWLSMIAAW,
    PPC_INS_EVMWLSMIANW,
    PPC_INS_EVMWLSSIAAW,
    PPC_INS_EVMWLSSIANW,
    PPC_INS_EVMWLUMI,
    PPC_INS_EVMWLUMIA,
    PPC_INS_EVMWLUMIAAW,
    PPC_INS_EVMWLUMIANW,
    PPC_INS_EVMWLUSIAAW,
    PPC_INS_EVMWLUSIANW,
    PPC_INS_EVMWSMF,
    PPC_INS_EVMWSMFA,
    PPC_INS_EVMWSMFAA,
    PPC_INS_EVMWSMFAN,
    PPC_INS_EVMWSMI,
    PPC_INS_EVMWSMIA,
    PPC_INS_EVMWSMIAA,
    PPC_INS_EVMWSMIAN,
    PPC_INS_EVMWSSF,
    PPC_INS_EVMWSSFA,
    PPC_INS_EVMWSSFAA,
    PPC_INS_EVMWSSFAN,
    PPC_INS_EVMWUMI,
    PPC_INS_EVMWUMIA,
    PPC_INS_EVMWUMIAA,
    PPC_INS_EVMWUMIAN,
    PPC_INS_EVNAND,
    PPC_INS_EVNEG,
    PPC_INS_EVNOR,
    PPC_INS_EVOR,
    PPC_INS_EVORC,
    PPC_INS_EVRLW,
    PPC_INS_EVRLWI,
    PPC_INS_EVRNDW,
    PPC_INS_EVSLW,
    PPC_INS_EVSLWI,
    PPC_INS_EVSPLATFI,
    PPC_INS_EVSPLATI,
    PPC_INS_EVSRWIS,
    PPC_INS_EVSRWIU,
    PPC_INS_EVSRWS,
    PPC_INS_EVSRWU,
    PPC_INS_EVSTDD,
    PPC_INS_EVSTDDX,
    PPC_INS_EVSTDH,
    PPC_INS_EVSTDHX,
    PPC_INS_EVSTDW,
    PPC_INS_EVSTDWX,
    PPC_INS_EVSTWHE,
    PPC_INS_EVSTWHEX,
    PPC_INS_EVSTWHO,
    PPC_INS_EVSTWHOX,
    PPC_INS_EVSTWWE,
    PPC_INS_EVSTWWEX,
    PPC_INS_EVSTWWO,
    PPC_INS_EVSTWWOX,
    PPC_INS_EVSUBFSMIAAW,
    PPC_INS_EVSUBFSSIAAW,
    PPC_INS_EVSUBFUMIAAW,
    PPC_INS_EVSUBFUSIAAW,
    PPC_INS_EVSUBFW,
    PPC_INS_EVSUBIFW,
    PPC_INS_EVXOR,
    PPC_INS_EXTSB,
    PPC_INS_EXTSH,
    PPC_INS_EXTSW,
    PPC_INS_EIEIO,
    PPC_INS_FABS,
    PPC_INS_FADD,
    PPC_INS_FADDS,
    PPC_INS_FCFID,
    PPC_INS_FCFIDS,
    PPC_INS_FCFIDU,
    PPC_INS_FCFIDUS,
    PPC_INS_FCMPU,
    PPC_INS_FCPSGN,
    PPC_INS_FCTID,
    PPC_INS_FCTIDUZ,
    PPC_INS_FCTIDZ,
    PPC_INS_FCTIW,
    PPC_INS_FCTIWUZ,
    PPC_INS_FCTIWZ,
    PPC_INS_FDIV,
    PPC_INS_FDIVS,
    PPC_INS_FMADD,
    PPC_INS_FMADDS,
    PPC_INS_FMR,
    PPC_INS_FMSUB,
    PPC_INS_FMSUBS,
    PPC_INS_FMUL,
    PPC_INS_FMULS,
    PPC_INS_FNABS,
    PPC_INS_FNEG,
    PPC_INS_FNMADD,
    PPC_INS_FNMADDS,
    PPC_INS_FNMSUB,
    PPC_INS_FNMSUBS,
    PPC_INS_FRE,
    PPC_INS_FRES,
    PPC_INS_FRIM,
    PPC_INS_FRIN,
    PPC_INS_FRIP,
    PPC_INS_FRIZ,
    PPC_INS_FRSP,
    PPC_INS_FRSQRTE,
    PPC_INS_FRSQRTES,
    PPC_INS_FSEL,
    PPC_INS_FSQRT,
    PPC_INS_FSQRTS,
    PPC_INS_FSUB,
    PPC_INS_FSUBS,
    PPC_INS_ICBI,
    PPC_INS_ICBT,
    PPC_INS_ICCCI,
    PPC_INS_ISEL,
    PPC_INS_ISYNC,
    PPC_INS_LA,
    PPC_INS_LBZ,
    PPC_INS_LBZCIX,
    PPC_INS_LBZU,
    PPC_INS_LBZUX,
    PPC_INS_LBZX,
    PPC_INS_LD,
    PPC_INS_LDARX,
    PPC_INS_LDBRX,
    PPC_INS_LDCIX,
    PPC_INS_LDU,
    PPC_INS_LDUX,
    PPC_INS_LDX,
    PPC_INS_LFD,
    PPC_INS_LFDU,
    PPC_INS_LFDUX,
    PPC_INS_LFDX,
    PPC_INS_LFIWAX,
    PPC_INS_LFIWZX,
    PPC_INS_LFS,
    PPC_INS_LFSU,
    PPC_INS_LFSUX,
    PPC_INS_LFSX,
    PPC_INS_LHA,
    PPC_INS_LHAU,
    PPC_INS_LHAUX,
    PPC_INS_LHAX,
    PPC_INS_LHBRX,
    PPC_INS_LHZ,
    PPC_INS_LHZCIX,
    PPC_INS_LHZU,
    PPC_INS_LHZUX,
    PPC_INS_LHZX,
    PPC_INS_LI,
    PPC_INS_LIS,
    PPC_INS_LMW,
    PPC_INS_LSWI,
    PPC_INS_LVEBX,
    PPC_INS_LVEHX,
    PPC_INS_LVEWX,
    PPC_INS_LVSL,
    PPC_INS_LVSR,
    PPC_INS_LVX,
    PPC_INS_LVXL,
    PPC_INS_LWA,
    PPC_INS_LWARX,
    PPC_INS_LWAUX,
    PPC_INS_LWAX,
    PPC_INS_LWBRX,
    PPC_INS_LWZ,
    PPC_INS_LWZCIX,
    PPC_INS_LWZU,
    PPC_INS_LWZUX,
    PPC_INS_LWZX,
    PPC_INS_LXSDX,
    PPC_INS_LXVD2X,
    PPC_INS_LXVDSX,
    PPC_INS_LXVW4X,
    PPC_INS_MBAR,
    PPC_INS_MCRF,
    PPC_INS_MCRFS,
    PPC_INS_MFCR,
    PPC_INS_MFCTR,
    PPC_INS_MFDCR,
    PPC_INS_MFFS,
    PPC_INS_MFLR,
    PPC_INS_MFMSR,
    PPC_INS_MFOCRF,
    PPC_INS_MFSPR,
    PPC_INS_MFSR,
    PPC_INS_MFSRIN,
    PPC_INS_MFTB,
    PPC_INS_MFVSCR,
    PPC_INS_MSYNC,
    PPC_INS_MTCRF,
    PPC_INS_MTCTR,
    PPC_INS_MTDCR,
    PPC_INS_MTFSB0,
    PPC_INS_MTFSB1,
    PPC_INS_MTFSF,
    PPC_INS_MTFSFI,
    PPC_INS_MTLR,
    PPC_INS_MTMSR,
    PPC_INS_MTMSRD,
    PPC_INS_MTOCRF,
    PPC_INS_MTSPR,
    PPC_INS_MTSR,
    PPC_INS_MTSRIN,
    PPC_INS_MTVSCR,
    PPC_INS_MULHD,
    PPC_INS_MULHDU,
    PPC_INS_MULHW,
    PPC_INS_MULHWU,
    PPC_INS_MULLD,
    PPC_INS_MULLI,
    PPC_INS_MULLW,
    PPC_INS_NAND,
    PPC_INS_NEG,
    PPC_INS_NOP,
    PPC_INS_ORI,
    PPC_INS_NOR,
    PPC_INS_OR,
    PPC_INS_ORC,
    PPC_INS_ORIS,
    PPC_INS_POPCNTD,
    PPC_INS_POPCNTW,
    PPC_INS_QVALIGNI,
    PPC_INS_QVESPLATI,
    PPC_INS_QVFABS,
    PPC_INS_QVFADD,
    PPC_INS_QVFADDS,
    PPC_INS_QVFCFID,
    PPC_INS_QVFCFIDS,
    PPC_INS_QVFCFIDU,
    PPC_INS_QVFCFIDUS,
    PPC_INS_QVFCMPEQ,
    PPC_INS_QVFCMPGT,
    PPC_INS_QVFCMPLT,
    PPC_INS_QVFCPSGN,
    PPC_INS_QVFCTID,
    PPC_INS_QVFCTIDU,
    PPC_INS_QVFCTIDUZ,
    PPC_INS_QVFCTIDZ,
    PPC_INS_QVFCTIW,
    PPC_INS_QVFCTIWU,
    PPC_INS_QVFCTIWUZ,
    PPC_INS_QVFCTIWZ,
    PPC_INS_QVFLOGICAL,
    PPC_INS_QVFMADD,
    PPC_INS_QVFMADDS,
    PPC_INS_QVFMR,
    PPC_INS_QVFMSUB,
    PPC_INS_QVFMSUBS,
    PPC_INS_QVFMUL,
    PPC_INS_QVFMULS,
    PPC_INS_QVFNABS,
    PPC_INS_QVFNEG,
    PPC_INS_QVFNMADD,
    PPC_INS_QVFNMADDS,
    PPC_INS_QVFNMSUB,
    PPC_INS_QVFNMSUBS,
    PPC_INS_QVFPERM,
    PPC_INS_QVFRE,
    PPC_INS_QVFRES,
    PPC_INS_QVFRIM,
    PPC_INS_QVFRIN,
    PPC_INS_QVFRIP,
    PPC_INS_QVFRIZ,
    PPC_INS_QVFRSP,
    PPC_INS_QVFRSQRTE,
    PPC_INS_QVFRSQRTES,
    PPC_INS_QVFSEL,
    PPC_INS_QVFSUB,
    PPC_INS_QVFSUBS,
    PPC_INS_QVFTSTNAN,
    PPC_INS_QVFXMADD,
    PPC_INS_QVFXMADDS,
    PPC_INS_QVFXMUL,
    PPC_INS_QVFXMULS,
    PPC_INS_QVFXXCPNMADD,
    PPC_INS_QVFXXCPNMADDS,
    PPC_INS_QVFXXMADD,
    PPC_INS_QVFXXMADDS,
    PPC_INS_QVFXXNPMADD,
    PPC_INS_QVFXXNPMADDS,
    PPC_INS_QVGPCI,
    PPC_INS_QVLFCDUX,
    PPC_INS_QVLFCDUXA,
    PPC_INS_QVLFCDX,
    PPC_INS_QVLFCDXA,
    PPC_INS_QVLFCSUX,
    PPC_INS_QVLFCSUXA,
    PPC_INS_QVLFCSX,
    PPC_INS_QVLFCSXA,
    PPC_INS_QVLFDUX,
    PPC_INS_QVLFDUXA,
    PPC_INS_QVLFDX,
    PPC_INS_QVLFDXA,
    PPC_INS_QVLFIWAX,
    PPC_INS_QVLFIWAXA,
    PPC_INS_QVLFIWZX,
    PPC_INS_QVLFIWZXA,
    PPC_INS_QVLFSUX,
    PPC_INS_QVLFSUXA,
    PPC_INS_QVLFSX,
    PPC_INS_QVLFSXA,
    PPC_INS_QVLPCLDX,
    PPC_INS_QVLPCLSX,
    PPC_INS_QVLPCRDX,
    PPC_INS_QVLPCRSX,
    PPC_INS_QVSTFCDUX,
    PPC_INS_QVSTFCDUXA,
    PPC_INS_QVSTFCDUXI,
    PPC_INS_QVSTFCDUXIA,
    PPC_INS_QVSTFCDX,
    PPC_INS_QVSTFCDXA,
    PPC_INS_QVSTFCDXI,
    PPC_INS_QVSTFCDXIA,
    PPC_INS_QVSTFCSUX,
    PPC_INS_QVSTFCSUXA,
    PPC_INS_QVSTFCSUXI,
    PPC_INS_QVSTFCSUXIA,
    PPC_INS_QVSTFCSX,
    PPC_INS_QVSTFCSXA,
    PPC_INS_QVSTFCSXI,
    PPC_INS_QVSTFCSXIA,
    PPC_INS_QVSTFDUX,
    PPC_INS_QVSTFDUXA,
    PPC_INS_QVSTFDUXI,
    PPC_INS_QVSTFDUXIA,
    PPC_INS_QVSTFDX,
    PPC_INS_QVSTFDXA,
    PPC_INS_QVSTFDXI,
    PPC_INS_QVSTFDXIA,
    PPC_INS_QVSTFIWX,
    PPC_INS_QVSTFIWXA,
    PPC_INS_QVSTFSUX,
    PPC_INS_QVSTFSUXA,
    PPC_INS_QVSTFSUXI,
    PPC_INS_QVSTFSUXIA,
    PPC_INS_QVSTFSX,
    PPC_INS_QVSTFSXA,
    PPC_INS_QVSTFSXI,
    PPC_INS_QVSTFSXIA,
    PPC_INS_RFCI,
    PPC_INS_RFDI,
    PPC_INS_RFI,
    PPC_INS_RFID,
    PPC_INS_RFMCI,
    PPC_INS_RLDCL,
    PPC_INS_RLDCR,
    PPC_INS_RLDIC,
    PPC_INS_RLDICL,
    PPC_INS_RLDICR,
    PPC_INS_RLDIMI,
    PPC_INS_RLWIMI,
    PPC_INS_RLWINM,
    PPC_INS_RLWNM,
    PPC_INS_SC,
    PPC_INS_SLBIA,
    PPC_INS_SLBIE,
    PPC_INS_SLBMFEE,
    PPC_INS_SLBMTE,
    PPC_INS_SLD,
    PPC_INS_SLW,
    PPC_INS_SRAD,
    PPC_INS_SRADI,
    PPC_INS_SRAW,
    PPC_INS_SRAWI,
    PPC_INS_SRD,
    PPC_INS_SRW,
    PPC_INS_STB,
    PPC_INS_STBCIX,
    PPC_INS_STBU,
    PPC_INS_STBUX,
    PPC_INS_STBX,
    PPC_INS_STD,
    PPC_INS_STDBRX,
    PPC_INS_STDCIX,
    PPC_INS_STDCX,
    PPC_INS_STDU,
    PPC_INS_STDUX,
    PPC_INS_STDX,
    PPC_INS_STFD,
    PPC_INS_STFDU,
    PPC_INS_STFDUX,
    PPC_INS_STFDX,
    PPC_INS_STFIWX,
    PPC_INS_STFS,
    PPC_INS_STFSU,
    PPC_INS_STFSUX,
    PPC_INS_STFSX,
    PPC_INS_STH,
    PPC_INS_STHBRX,
    PPC_INS_STHCIX,
    PPC_INS_STHU,
    PPC_INS_STHUX,
    PPC_INS_STHX,
    PPC_INS_STMW,
    PPC_INS_STSWI,
    PPC_INS_STVEBX,
    PPC_INS_STVEHX,
    PPC_INS_STVEWX,
    PPC_INS_STVX,
    PPC_INS_STVXL,
    PPC_INS_STW,
    PPC_INS_STWBRX,
    PPC_INS_STWCIX,
    PPC_INS_STWCX,
    PPC_INS_STWU,
    PPC_INS_STWUX,
    PPC_INS_STWX,
    PPC_INS_STXSDX,
    PPC_INS_STXVD2X,
    PPC_INS_STXVW4X,
    PPC_INS_SUBF,
    PPC_INS_SUBFC,
    PPC_INS_SUBFE,
    PPC_INS_SUBFIC,
    PPC_INS_SUBFME,
    PPC_INS_SUBFZE,
    PPC_INS_SYNC,
    PPC_INS_TD,
    PPC_INS_TDI,
    PPC_INS_TLBIA,
    PPC_INS_TLBIE,
    PPC_INS_TLBIEL,
    PPC_INS_TLBIVAX,
    PPC_INS_TLBLD,
    PPC_INS_TLBLI,
    PPC_INS_TLBRE,
    PPC_INS_TLBSX,
    PPC_INS_TLBSYNC,
    PPC_INS_TLBWE,
    PPC_INS_TRAP,
    PPC_INS_TW,
    PPC_INS_TWI,
    PPC_INS_VADDCUW,
    PPC_INS_VADDFP,
    PPC_INS_VADDSBS,
    PPC_INS_VADDSHS,
    PPC_INS_VADDSWS,
    PPC_INS_VADDUBM,
    PPC_INS_VADDUBS,
    PPC_INS_VADDUDM,
    PPC_INS_VADDUHM,
    PPC_INS_VADDUHS,
    PPC_INS_VADDUWM,
    PPC_INS_VADDUWS,
    PPC_INS_VAND,
    PPC_INS_VANDC,
    PPC_INS_VAVGSB,
    PPC_INS_VAVGSH,
    PPC_INS_VAVGSW,
    PPC_INS_VAVGUB,
    PPC_INS_VAVGUH,
    PPC_INS_VAVGUW,
    PPC_INS_VCFSX,
    PPC_INS_VCFUX,
    PPC_INS_VCLZB,
    PPC_INS_VCLZD,
    PPC_INS_VCLZH,
    PPC_INS_VCLZW,
    PPC_INS_VCMPBFP,
    PPC_INS_VCMPEQFP,
    PPC_INS_VCMPEQUB,
    PPC_INS_VCMPEQUD,
    PPC_INS_VCMPEQUH,
    PPC_INS_VCMPEQUW,
    PPC_INS_VCMPGEFP,
    PPC_INS_VCMPGTFP,
    PPC_INS_VCMPGTSB,
    PPC_INS_VCMPGTSD,
    PPC_INS_VCMPGTSH,
    PPC_INS_VCMPGTSW,
    PPC_INS_VCMPGTUB,
    PPC_INS_VCMPGTUD,
    PPC_INS_VCMPGTUH,
    PPC_INS_VCMPGTUW,
    PPC_INS_VCTSXS,
    PPC_INS_VCTUXS,
    PPC_INS_VEQV,
    PPC_INS_VEXPTEFP,
    PPC_INS_VLOGEFP,
    PPC_INS_VMADDFP,
    PPC_INS_VMAXFP,
    PPC_INS_VMAXSB,
    PPC_INS_VMAXSD,
    PPC_INS_VMAXSH,
    PPC_INS_VMAXSW,
    PPC_INS_VMAXUB,
    PPC_INS_VMAXUD,
    PPC_INS_VMAXUH,
    PPC_INS_VMAXUW,
    PPC_INS_VMHADDSHS,
    PPC_INS_VMHRADDSHS,
    PPC_INS_VMINUD,
    PPC_INS_VMINFP,
    PPC_INS_VMINSB,
    PPC_INS_VMINSD,
    PPC_INS_VMINSH,
    PPC_INS_VMINSW,
    PPC_INS_VMINUB,
    PPC_INS_VMINUH,
    PPC_INS_VMINUW,
    PPC_INS_VMLADDUHM,
    PPC_INS_VMRGHB,
    PPC_INS_VMRGHH,
    PPC_INS_VMRGHW,
    PPC_INS_VMRGLB,
    PPC_INS_VMRGLH,
    PPC_INS_VMRGLW,
    PPC_INS_VMSUMMBM,
    PPC_INS_VMSUMSHM,
    PPC_INS_VMSUMSHS,
    PPC_INS_VMSUMUBM,
    PPC_INS_VMSUMUHM,
    PPC_INS_VMSUMUHS,
    PPC_INS_VMULESB,
    PPC_INS_VMULESH,
    PPC_INS_VMULESW,
    PPC_INS_VMULEUB,
    PPC_INS_VMULEUH,
    PPC_INS_VMULEUW,
    PPC_INS_VMULOSB,
    PPC_INS_VMULOSH,
    PPC_INS_VMULOSW,
    PPC_INS_VMULOUB,
    PPC_INS_VMULOUH,
    PPC_INS_VMULOUW,
    PPC_INS_VMULUWM,
    PPC_INS_VNAND,
    PPC_INS_VNMSUBFP,
    PPC_INS_VNOR,
    PPC_INS_VOR,
    PPC_INS_VORC,
    PPC_INS_VPERM,
    PPC_INS_VPKPX,
    PPC_INS_VPKSHSS,
    PPC_INS_VPKSHUS,
    PPC_INS_VPKSWSS,
    PPC_INS_VPKSWUS,
    PPC_INS_VPKUHUM,
    PPC_INS_VPKUHUS,
    PPC_INS_VPKUWUM,
    PPC_INS_VPKUWUS,
    PPC_INS_VPOPCNTB,
    PPC_INS_VPOPCNTD,
    PPC_INS_VPOPCNTH,
    PPC_INS_VPOPCNTW,
    PPC_INS_VREFP,
    PPC_INS_VRFIM,
    PPC_INS_VRFIN,
    PPC_INS_VRFIP,
    PPC_INS_VRFIZ,
    PPC_INS_VRLB,
    PPC_INS_VRLD,
    PPC_INS_VRLH,
    PPC_INS_VRLW,
    PPC_INS_VRSQRTEFP,
    PPC_INS_VSEL,
    PPC_INS_VSL,
    PPC_INS_VSLB,
    PPC_INS_VSLD,
    PPC_INS_VSLDOI,
    PPC_INS_VSLH,
    PPC_INS_VSLO,
    PPC_INS_VSLW,
    PPC_INS_VSPLTB,
    PPC_INS_VSPLTH,
    PPC_INS_VSPLTISB,
    PPC_INS_VSPLTISH,
    PPC_INS_VSPLTISW,
    PPC_INS_VSPLTW,
    PPC_INS_VSR,
    PPC_INS_VSRAB,
    PPC_INS_VSRAD,
    PPC_INS_VSRAH,
    PPC_INS_VSRAW,
    PPC_INS_VSRB,
    PPC_INS_VSRD,
    PPC_INS_VSRH,
    PPC_INS_VSRO,
    PPC_INS_VSRW,
    PPC_INS_VSUBCUW,
    PPC_INS_VSUBFP,
    PPC_INS_VSUBSBS,
    PPC_INS_VSUBSHS,
    PPC_INS_VSUBSWS,
    PPC_INS_VSUBUBM,
    PPC_INS_VSUBUBS,
    PPC_INS_VSUBUDM,
    PPC_INS_VSUBUHM,
    PPC_INS_VSUBUHS,
    PPC_INS_VSUBUWM,
    PPC_INS_VSUBUWS,
    PPC_INS_VSUM2SWS,
    PPC_INS_VSUM4SBS,
    PPC_INS_VSUM4SHS,
    PPC_INS_VSUM4UBS,
    PPC_INS_VSUMSWS,
    PPC_INS_VUPKHPX,
    PPC_INS_VUPKHSB,
    PPC_INS_VUPKHSH,
    PPC_INS_VUPKLPX,
    PPC_INS_VUPKLSB,
    PPC_INS_VUPKLSH,
    PPC_INS_VXOR,
    PPC_INS_WAIT,
    PPC_INS_WRTEE,
    PPC_INS_WRTEEI,
    PPC_INS_XOR,
    PPC_INS_XORI,
    PPC_INS_XORIS,
    PPC_INS_XSABSDP,
    PPC_INS_XSADDDP,
    PPC_INS_XSCMPODP,
    PPC_INS_XSCMPUDP,
    PPC_INS_XSCPSGNDP,
    PPC_INS_XSCVDPSP,
    PPC_INS_XSCVDPSXDS,
    PPC_INS_XSCVDPSXWS,
    PPC_INS_XSCVDPUXDS,
    PPC_INS_XSCVDPUXWS,
    PPC_INS_XSCVSPDP,
    PPC_INS_XSCVSXDDP,
    PPC_INS_XSCVUXDDP,
    PPC_INS_XSDIVDP,
    PPC_INS_XSMADDADP,
    PPC_INS_XSMADDMDP,
    PPC_INS_XSMAXDP,
    PPC_INS_XSMINDP,
    PPC_INS_XSMSUBADP,
    PPC_INS_XSMSUBMDP,
    PPC_INS_XSMULDP,
    PPC_INS_XSNABSDP,
    PPC_INS_XSNEGDP,
    PPC_INS_XSNMADDADP,
    PPC_INS_XSNMADDMDP,
    PPC_INS_XSNMSUBADP,
    PPC_INS_XSNMSUBMDP,
    PPC_INS_XSRDPI,
    PPC_INS_XSRDPIC,
    PPC_INS_XSRDPIM,
    PPC_INS_XSRDPIP,
    PPC_INS_XSRDPIZ,
    PPC_INS_XSREDP,
    PPC_INS_XSRSQRTEDP,
    PPC_INS_XSSQRTDP,
    PPC_INS_XSSUBDP,
    PPC_INS_XSTDIVDP,
    PPC_INS_XSTSQRTDP,
    PPC_INS_XVABSDP,
    PPC_INS_XVABSSP,
    PPC_INS_XVADDDP,
    PPC_INS_XVADDSP,
    PPC_INS_XVCMPEQDP,
    PPC_INS_XVCMPEQSP,
    PPC_INS_XVCMPGEDP,
    PPC_INS_XVCMPGESP,
    PPC_INS_XVCMPGTDP,
    PPC_INS_XVCMPGTSP,
    PPC_INS_XVCPSGNDP,
    PPC_INS_XVCPSGNSP,
    PPC_INS_XVCVDPSP,
    PPC_INS_XVCVDPSXDS,
    PPC_INS_XVCVDPSXWS,
    PPC_INS_XVCVDPUXDS,
    PPC_INS_XVCVDPUXWS,
    PPC_INS_XVCVSPDP,
    PPC_INS_XVCVSPSXDS,
    PPC_INS_XVCVSPSXWS,
    PPC_INS_XVCVSPUXDS,
    PPC_INS_XVCVSPUXWS,
    PPC_INS_XVCVSXDDP,
    PPC_INS_XVCVSXDSP,
    PPC_INS_XVCVSXWDP,
    PPC_INS_XVCVSXWSP,
    PPC_INS_XVCVUXDDP,
    PPC_INS_XVCVUXDSP,
    PPC_INS_XVCVUXWDP,
    PPC_INS_XVCVUXWSP,
    PPC_INS_XVDIVDP,
    PPC_INS_XVDIVSP,
    PPC_INS_XVMADDADP,
    PPC_INS_XVMADDASP,
    PPC_INS_XVMADDMDP,
    PPC_INS_XVMADDMSP,
    PPC_INS_XVMAXDP,
    PPC_INS_XVMAXSP,
    PPC_INS_XVMINDP,
    PPC_INS_XVMINSP,
    PPC_INS_XVMSUBADP,
    PPC_INS_XVMSUBASP,
    PPC_INS_XVMSUBMDP,
    PPC_INS_XVMSUBMSP,
    PPC_INS_XVMULDP,
    PPC_INS_XVMULSP,
    PPC_INS_XVNABSDP,
    PPC_INS_XVNABSSP,
    PPC_INS_XVNEGDP,
    PPC_INS_XVNEGSP,
    PPC_INS_XVNMADDADP,
    PPC_INS_XVNMADDASP,
    PPC_INS_XVNMADDMDP,
    PPC_INS_XVNMADDMSP,
    PPC_INS_XVNMSUBADP,
    PPC_INS_XVNMSUBASP,
    PPC_INS_XVNMSUBMDP,
    PPC_INS_XVNMSUBMSP,
    PPC_INS_XVRDPI,
    PPC_INS_XVRDPIC,
    PPC_INS_XVRDPIM,
    PPC_INS_XVRDPIP,
    PPC_INS_XVRDPIZ,
    PPC_INS_XVREDP,
    PPC_INS_XVRESP,
    PPC_INS_XVRSPI,
    PPC_INS_XVRSPIC,
    PPC_INS_XVRSPIM,
    PPC_INS_XVRSPIP,
    PPC_INS_XVRSPIZ,
    PPC_INS_XVRSQRTEDP,
    PPC_INS_XVRSQRTESP,
    PPC_INS_XVSQRTDP,
    PPC_INS_XVSQRTSP,
    PPC_INS_XVSUBDP,
    PPC_INS_XVSUBSP,
    PPC_INS_XVTDIVDP,
    PPC_INS_XVTDIVSP,
    PPC_INS_XVTSQRTDP,
    PPC_INS_XVTSQRTSP,
    PPC_INS_XXLAND,
    PPC_INS_XXLANDC,
    PPC_INS_XXLEQV,
    PPC_INS_XXLNAND,
    PPC_INS_XXLNOR,
    PPC_INS_XXLOR,
    PPC_INS_XXLORC,
    PPC_INS_XXLXOR,
    PPC_INS_XXMRGHW,
    PPC_INS_XXMRGLW,
    PPC_INS_XXPERMDI,
    PPC_INS_XXSEL,
    PPC_INS_XXSLDWI,
    PPC_INS_XXSPLTW,
    PPC_INS_BCA,
    PPC_INS_BCLA,

    // extra & alias instructions
    PPC_INS_SLWI,
    PPC_INS_SRWI,
    PPC_INS_SLDI,

    PPC_INS_BTA,
    PPC_INS_CRSET,
    PPC_INS_CRNOT,
    PPC_INS_CRMOVE,
    PPC_INS_CRCLR,
    PPC_INS_MFBR0,
    PPC_INS_MFBR1,
    PPC_INS_MFBR2,
    PPC_INS_MFBR3,
    PPC_INS_MFBR4,
    PPC_INS_MFBR5,
    PPC_INS_MFBR6,
    PPC_INS_MFBR7,
    PPC_INS_MFXER,
    PPC_INS_MFRTCU,
    PPC_INS_MFRTCL,
    PPC_INS_MFDSCR,
    PPC_INS_MFDSISR,
    PPC_INS_MFDAR,
    PPC_INS_MFSRR2,
    PPC_INS_MFSRR3,
    PPC_INS_MFCFAR,
    PPC_INS_MFAMR,
    PPC_INS_MFPID,
    PPC_INS_MFTBLO,
    PPC_INS_MFTBHI,
    PPC_INS_MFDBATU,
    PPC_INS_MFDBATL,
    PPC_INS_MFIBATU,
    PPC_INS_MFIBATL,
    PPC_INS_MFDCCR,
    PPC_INS_MFICCR,
    PPC_INS_MFDEAR,
    PPC_INS_MFESR,
    PPC_INS_MFSPEFSCR,
    PPC_INS_MFTCR,
    PPC_INS_MFASR,
    PPC_INS_MFPVR,
    PPC_INS_MFTBU,
    PPC_INS_MTCR,
    PPC_INS_MTBR0,
    PPC_INS_MTBR1,
    PPC_INS_MTBR2,
    PPC_INS_MTBR3,
    PPC_INS_MTBR4,
    PPC_INS_MTBR5,
    PPC_INS_MTBR6,
    PPC_INS_MTBR7,
    PPC_INS_MTXER,
    PPC_INS_MTDSCR,
    PPC_INS_MTDSISR,
    PPC_INS_MTDAR,
    PPC_INS_MTSRR2,
    PPC_INS_MTSRR3,
    PPC_INS_MTCFAR,
    PPC_INS_MTAMR,
    PPC_INS_MTPID,
    PPC_INS_MTTBL,
    PPC_INS_MTTBU,
    PPC_INS_MTTBLO,
    PPC_INS_MTTBHI,
    PPC_INS_MTDBATU,
    PPC_INS_MTDBATL,
    PPC_INS_MTIBATU,
    PPC_INS_MTIBATL,
    PPC_INS_MTDCCR,
    PPC_INS_MTICCR,
    PPC_INS_MTDEAR,
    PPC_INS_MTESR,
    PPC_INS_MTSPEFSCR,
    PPC_INS_MTTCR,
    PPC_INS_NOT,
    PPC_INS_MR,
    PPC_INS_ROTLD,
    PPC_INS_ROTLDI,
    PPC_INS_CLRLDI,
    PPC_INS_ROTLWI,
    PPC_INS_CLRLWI,
    PPC_INS_ROTLW,
    PPC_INS_SUB,
    PPC_INS_SUBC,
    PPC_INS_LWSYNC,
    PPC_INS_PTESYNC,
    PPC_INS_TDLT,
    PPC_INS_TDEQ,
    PPC_INS_TDGT,
    PPC_INS_TDNE,
    PPC_INS_TDLLT,
    PPC_INS_TDLGT,
    PPC_INS_TDU,
    PPC_INS_TDLTI,
    PPC_INS_TDEQI,
    PPC_INS_TDGTI,
    PPC_INS_TDNEI,
    PPC_INS_TDLLTI,
    PPC_INS_TDLGTI,
    PPC_INS_TDUI,
    PPC_INS_TLBREHI,
    PPC_INS_TLBRELO,
    PPC_INS_TLBWEHI,
    PPC_INS_TLBWELO,
    PPC_INS_TWLT,
    PPC_INS_TWEQ,
    PPC_INS_TWGT,
    PPC_INS_TWNE,
    PPC_INS_TWLLT,
    PPC_INS_TWLGT,
    PPC_INS_TWU,
    PPC_INS_TWLTI,
    PPC_INS_TWEQI,
    PPC_INS_TWGTI,
    PPC_INS_TWNEI,
    PPC_INS_TWLLTI,
    PPC_INS_TWLGTI,
    PPC_INS_TWUI,
    PPC_INS_WAITRSV,
    PPC_INS_WAITIMPL,
    PPC_INS_XNOP,
    PPC_INS_XVMOVDP,
    PPC_INS_XVMOVSP,
    PPC_INS_XXSPLTD,
    PPC_INS_XXMRGHD,
    PPC_INS_XXMRGLD,
    PPC_INS_XXSWAPD,
    PPC_INS_BT,
    PPC_INS_BF,
    PPC_INS_BDNZT,
    PPC_INS_BDNZF,
    PPC_INS_BDZF,
    PPC_INS_BDZT,
    PPC_INS_BFA,
    PPC_INS_BDNZTA,
    PPC_INS_BDNZFA,
    PPC_INS_BDZTA,
    PPC_INS_BDZFA,
    PPC_INS_BTCTR,
    PPC_INS_BFCTR,
    PPC_INS_BTCTRL,
    PPC_INS_BFCTRL,
    PPC_INS_BTL,
    PPC_INS_BFL,
    PPC_INS_BDNZTL,
    PPC_INS_BDNZFL,
    PPC_INS_BDZTL,
    PPC_INS_BDZFL,
    PPC_INS_BTLA,
    PPC_INS_BFLA,
    PPC_INS_BDNZTLA,
    PPC_INS_BDNZFLA,
    PPC_INS_BDZTLA,
    PPC_INS_BDZFLA,
    PPC_INS_BTLR,
    PPC_INS_BFLR,
    PPC_INS_BDNZTLR,
    PPC_INS_BDZTLR,
    PPC_INS_BDZFLR,
    PPC_INS_BTLRL,
    PPC_INS_BFLRL,
    PPC_INS_BDNZTLRL,
    PPC_INS_BDNZFLRL,
    PPC_INS_BDZTLRL,
    PPC_INS_BDZFLRL,

    // QPX
    PPC_INS_QVFAND,
    PPC_INS_QVFCLR,
    PPC_INS_QVFANDC,
    PPC_INS_QVFCTFB,
    PPC_INS_QVFXOR,
    PPC_INS_QVFOR,
    PPC_INS_QVFNOR,
    PPC_INS_QVFEQU,
    PPC_INS_QVFNOT,
    PPC_INS_QVFORC,
    PPC_INS_QVFNAND,
    PPC_INS_QVFSET,

    PPC_INS_ENDING,   // <-- mark the end of the list of instructions
} ppc_insn;

//> Group of PPC instructions
typedef enum ppc_insn_group
{
    PPC_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    PPC_GRP_JUMP,   // = CS_GRP_JUMP

    //> Architecture-specific groups
    PPC_GRP_ALTIVEC = 128,
    PPC_GRP_MODE32,
    PPC_GRP_MODE64,
    PPC_GRP_BOOKE,
    PPC_GRP_NOTBOOKE,
    PPC_GRP_SPE,
    PPC_GRP_VSX,
    PPC_GRP_E500,
    PPC_GRP_PPC4XX,
    PPC_GRP_PPC6XX,
    PPC_GRP_ICBT,
    PPC_GRP_P8ALTIVEC,
    PPC_GRP_P8VECTOR,
    PPC_GRP_QPX,

    PPC_GRP_ENDING,   // <-- mark the end of the list of groups
} ppc_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/sparc.h
================================================
#ifndef CAPSTONE_SPARC_H
#define CAPSTONE_SPARC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to Sparc condition codes, both icc's and fcc's.
typedef enum sparc_cc
{
    SPARC_CC_INVALID = 0,   // invalid CC (default)
    //> Integer condition codes
    SPARC_CC_ICC_A   =  8 + 256, // Always
    SPARC_CC_ICC_N   =  0 + 256, // Never
    SPARC_CC_ICC_NE  =  9 + 256, // Not Equal
    SPARC_CC_ICC_E   =  1 + 256, // Equal
    SPARC_CC_ICC_G   = 10 + 256, // Greater
    SPARC_CC_ICC_LE  =  2 + 256, // Less or Equal
    SPARC_CC_ICC_GE  = 11 + 256, // Greater or Equal
    SPARC_CC_ICC_L   =  3 + 256, // Less
    SPARC_CC_ICC_GU  = 12 + 256, // Greater Unsigned
    SPARC_CC_ICC_LEU =  4 + 256, // Less or Equal Unsigned
    SPARC_CC_ICC_CC  = 13 + 256, // Carry Clear/Great or Equal Unsigned
    SPARC_CC_ICC_CS  =  5 + 256, // Carry Set/Less Unsigned
    SPARC_CC_ICC_POS = 14 + 256, // Positive
    SPARC_CC_ICC_NEG =  6 + 256, // Negative
    SPARC_CC_ICC_VC  = 15 + 256, // Overflow Clear
    SPARC_CC_ICC_VS  =  7 + 256, // Overflow Set

    //> Floating condition codes
    SPARC_CC_FCC_A   =  8 + 16 + 256, // Always
    SPARC_CC_FCC_N   =  0 + 16 + 256, // Never
    SPARC_CC_FCC_U   =  7 + 16 + 256, // Unordered
    SPARC_CC_FCC_G   =  6 + 16 + 256, // Greater
    SPARC_CC_FCC_UG  =  5 + 16 + 256, // Unordered or Greater
    SPARC_CC_FCC_L   =  4 + 16 + 256, // Less
    SPARC_CC_FCC_UL  =  3 + 16 + 256, // Unordered or Less
    SPARC_CC_FCC_LG  =  2 + 16 + 256, // Less or Greater
    SPARC_CC_FCC_NE  =  1 + 16 + 256, // Not Equal
    SPARC_CC_FCC_E   =  9 + 16 + 256, // Equal
    SPARC_CC_FCC_UE  = 10 + 16 + 256, // Unordered or Equal
    SPARC_CC_FCC_GE  = 11 + 16 + 256, // Greater or Equal
    SPARC_CC_FCC_UGE = 12 + 16 + 256, // Unordered or Greater or Equal
    SPARC_CC_FCC_LE  = 13 + 16 + 256, // Less or Equal
    SPARC_CC_FCC_ULE = 14 + 16 + 256, // Unordered or Less or Equal
    SPARC_CC_FCC_O   = 15 + 16 + 256, // Ordered
} sparc_cc;

//> Branch hint
typedef enum sparc_hint
{
    SPARC_HINT_INVALID = 0, // no hint
    SPARC_HINT_A    = 1 << 0,   // annul delay slot instruction
    SPARC_HINT_PT   = 1 << 1,   // branch taken
    SPARC_HINT_PN   = 1 << 2,   // branch NOT taken
} sparc_hint;

//> Operand type for instruction's operands
typedef enum sparc_op_type
{
    SPARC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    SPARC_OP_REG, // = CS_OP_REG (Register operand).
    SPARC_OP_IMM, // = CS_OP_IMM (Immediate operand).
    SPARC_OP_MEM, // = CS_OP_MEM (Memory operand).
} sparc_op_type;

//> SPARC registers
typedef enum sparc_reg
{
    SPARC_REG_INVALID = 0,

    SPARC_REG_F0,
    SPARC_REG_F1,
    SPARC_REG_F2,
    SPARC_REG_F3,
    SPARC_REG_F4,
    SPARC_REG_F5,
    SPARC_REG_F6,
    SPARC_REG_F7,
    SPARC_REG_F8,
    SPARC_REG_F9,
    SPARC_REG_F10,
    SPARC_REG_F11,
    SPARC_REG_F12,
    SPARC_REG_F13,
    SPARC_REG_F14,
    SPARC_REG_F15,
    SPARC_REG_F16,
    SPARC_REG_F17,
    SPARC_REG_F18,
    SPARC_REG_F19,
    SPARC_REG_F20,
    SPARC_REG_F21,
    SPARC_REG_F22,
    SPARC_REG_F23,
    SPARC_REG_F24,
    SPARC_REG_F25,
    SPARC_REG_F26,
    SPARC_REG_F27,
    SPARC_REG_F28,
    SPARC_REG_F29,
    SPARC_REG_F30,
    SPARC_REG_F31,
    SPARC_REG_F32,
    SPARC_REG_F34,
    SPARC_REG_F36,
    SPARC_REG_F38,
    SPARC_REG_F40,
    SPARC_REG_F42,
    SPARC_REG_F44,
    SPARC_REG_F46,
    SPARC_REG_F48,
    SPARC_REG_F50,
    SPARC_REG_F52,
    SPARC_REG_F54,
    SPARC_REG_F56,
    SPARC_REG_F58,
    SPARC_REG_F60,
    SPARC_REG_F62,
    SPARC_REG_FCC0, // Floating condition codes
    SPARC_REG_FCC1,
    SPARC_REG_FCC2,
    SPARC_REG_FCC3,
    SPARC_REG_FP,
    SPARC_REG_G0,
    SPARC_REG_G1,
    SPARC_REG_G2,
    SPARC_REG_G3,
    SPARC_REG_G4,
    SPARC_REG_G5,
    SPARC_REG_G6,
    SPARC_REG_G7,
    SPARC_REG_I0,
    SPARC_REG_I1,
    SPARC_REG_I2,
    SPARC_REG_I3,
    SPARC_REG_I4,
    SPARC_REG_I5,
    SPARC_REG_I7,
    SPARC_REG_ICC,  // Integer condition codes
    SPARC_REG_L0,
    SPARC_REG_L1,
    SPARC_REG_L2,
    SPARC_REG_L3,
    SPARC_REG_L4,
    SPARC_REG_L5,
    SPARC_REG_L6,
    SPARC_REG_L7,
    SPARC_REG_O0,
    SPARC_REG_O1,
    SPARC_REG_O2,
    SPARC_REG_O3,
    SPARC_REG_O4,
    SPARC_REG_O5,
    SPARC_REG_O7,
    SPARC_REG_SP,
    SPARC_REG_Y,

    // special register
    SPARC_REG_XCC,

    SPARC_REG_ENDING,   // <-- mark the end of the list of registers

    // extras
    SPARC_REG_O6 = SPARC_REG_SP,
    SPARC_REG_I6 = SPARC_REG_FP,
} sparc_reg;

// Instruction's operand referring to memory
// This is associated with SPARC_OP_MEM operand type above
typedef struct sparc_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `sparc_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    int32_t disp;       // displacement/offset value
} sparc_op_mem;

// Instruction operand
typedef struct cs_sparc_op
{
    sparc_op_type type; // operand type
    union
    {
        sparc_reg reg;  // register value for REG operand
        int32_t imm;        // immediate value for IMM operand
        sparc_op_mem mem;       // base/disp value for MEM operand
    };
} cs_sparc_op;

// Instruction structure
typedef struct cs_sparc
{
    sparc_cc cc;    // code condition for this insn
    sparc_hint hint;    // branch hint: encoding as bitwise OR of sparc_hint.
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_sparc_op operands[4]; // operands for this instruction.
} cs_sparc;

//> SPARC instruction
typedef enum sparc_insn
{
    SPARC_INS_INVALID = 0,

    SPARC_INS_ADDCC,
    SPARC_INS_ADDX,
    SPARC_INS_ADDXCC,
    SPARC_INS_ADDXC,
    SPARC_INS_ADDXCCC,
    SPARC_INS_ADD,
    SPARC_INS_ALIGNADDR,
    SPARC_INS_ALIGNADDRL,
    SPARC_INS_ANDCC,
    SPARC_INS_ANDNCC,
    SPARC_INS_ANDN,
    SPARC_INS_AND,
    SPARC_INS_ARRAY16,
    SPARC_INS_ARRAY32,
    SPARC_INS_ARRAY8,
    SPARC_INS_B,
    SPARC_INS_JMP,
    SPARC_INS_BMASK,
    SPARC_INS_FB,
    SPARC_INS_BRGEZ,
    SPARC_INS_BRGZ,
    SPARC_INS_BRLEZ,
    SPARC_INS_BRLZ,
    SPARC_INS_BRNZ,
    SPARC_INS_BRZ,
    SPARC_INS_BSHUFFLE,
    SPARC_INS_CALL,
    SPARC_INS_CASX,
    SPARC_INS_CAS,
    SPARC_INS_CMASK16,
    SPARC_INS_CMASK32,
    SPARC_INS_CMASK8,
    SPARC_INS_CMP,
    SPARC_INS_EDGE16,
    SPARC_INS_EDGE16L,
    SPARC_INS_EDGE16LN,
    SPARC_INS_EDGE16N,
    SPARC_INS_EDGE32,
    SPARC_INS_EDGE32L,
    SPARC_INS_EDGE32LN,
    SPARC_INS_EDGE32N,
    SPARC_INS_EDGE8,
    SPARC_INS_EDGE8L,
    SPARC_INS_EDGE8LN,
    SPARC_INS_EDGE8N,
    SPARC_INS_FABSD,
    SPARC_INS_FABSQ,
    SPARC_INS_FABSS,
    SPARC_INS_FADDD,
    SPARC_INS_FADDQ,
    SPARC_INS_FADDS,
    SPARC_INS_FALIGNDATA,
    SPARC_INS_FAND,
    SPARC_INS_FANDNOT1,
    SPARC_INS_FANDNOT1S,
    SPARC_INS_FANDNOT2,
    SPARC_INS_FANDNOT2S,
    SPARC_INS_FANDS,
    SPARC_INS_FCHKSM16,
    SPARC_INS_FCMPD,
    SPARC_INS_FCMPEQ16,
    SPARC_INS_FCMPEQ32,
    SPARC_INS_FCMPGT16,
    SPARC_INS_FCMPGT32,
    SPARC_INS_FCMPLE16,
    SPARC_INS_FCMPLE32,
    SPARC_INS_FCMPNE16,
    SPARC_INS_FCMPNE32,
    SPARC_INS_FCMPQ,
    SPARC_INS_FCMPS,
    SPARC_INS_FDIVD,
    SPARC_INS_FDIVQ,
    SPARC_INS_FDIVS,
    SPARC_INS_FDMULQ,
    SPARC_INS_FDTOI,
    SPARC_INS_FDTOQ,
    SPARC_INS_FDTOS,
    SPARC_INS_FDTOX,
    SPARC_INS_FEXPAND,
    SPARC_INS_FHADDD,
    SPARC_INS_FHADDS,
    SPARC_INS_FHSUBD,
    SPARC_INS_FHSUBS,
    SPARC_INS_FITOD,
    SPARC_INS_FITOQ,
    SPARC_INS_FITOS,
    SPARC_INS_FLCMPD,
    SPARC_INS_FLCMPS,
    SPARC_INS_FLUSHW,
    SPARC_INS_FMEAN16,
    SPARC_INS_FMOVD,
    SPARC_INS_FMOVQ,
    SPARC_INS_FMOVRDGEZ,
    SPARC_INS_FMOVRQGEZ,
    SPARC_INS_FMOVRSGEZ,
    SPARC_INS_FMOVRDGZ,
    SPARC_INS_FMOVRQGZ,
    SPARC_INS_FMOVRSGZ,
    SPARC_INS_FMOVRDLEZ,
    SPARC_INS_FMOVRQLEZ,
    SPARC_INS_FMOVRSLEZ,
    SPARC_INS_FMOVRDLZ,
    SPARC_INS_FMOVRQLZ,
    SPARC_INS_FMOVRSLZ,
    SPARC_INS_FMOVRDNZ,
    SPARC_INS_FMOVRQNZ,
    SPARC_INS_FMOVRSNZ,
    SPARC_INS_FMOVRDZ,
    SPARC_INS_FMOVRQZ,
    SPARC_INS_FMOVRSZ,
    SPARC_INS_FMOVS,
    SPARC_INS_FMUL8SUX16,
    SPARC_INS_FMUL8ULX16,
    SPARC_INS_FMUL8X16,
    SPARC_INS_FMUL8X16AL,
    SPARC_INS_FMUL8X16AU,
    SPARC_INS_FMULD,
    SPARC_INS_FMULD8SUX16,
    SPARC_INS_FMULD8ULX16,
    SPARC_INS_FMULQ,
    SPARC_INS_FMULS,
    SPARC_INS_FNADDD,
    SPARC_INS_FNADDS,
    SPARC_INS_FNAND,
    SPARC_INS_FNANDS,
    SPARC_INS_FNEGD,
    SPARC_INS_FNEGQ,
    SPARC_INS_FNEGS,
    SPARC_INS_FNHADDD,
    SPARC_INS_FNHADDS,
    SPARC_INS_FNOR,
    SPARC_INS_FNORS,
    SPARC_INS_FNOT1,
    SPARC_INS_FNOT1S,
    SPARC_INS_FNOT2,
    SPARC_INS_FNOT2S,
    SPARC_INS_FONE,
    SPARC_INS_FONES,
    SPARC_INS_FOR,
    SPARC_INS_FORNOT1,
    SPARC_INS_FORNOT1S,
    SPARC_INS_FORNOT2,
    SPARC_INS_FORNOT2S,
    SPARC_INS_FORS,
    SPARC_INS_FPACK16,
    SPARC_INS_FPACK32,
    SPARC_INS_FPACKFIX,
    SPARC_INS_FPADD16,
    SPARC_INS_FPADD16S,
    SPARC_INS_FPADD32,
    SPARC_INS_FPADD32S,
    SPARC_INS_FPADD64,
    SPARC_INS_FPMERGE,
    SPARC_INS_FPSUB16,
    SPARC_INS_FPSUB16S,
    SPARC_INS_FPSUB32,
    SPARC_INS_FPSUB32S,
    SPARC_INS_FQTOD,
    SPARC_INS_FQTOI,
    SPARC_INS_FQTOS,
    SPARC_INS_FQTOX,
    SPARC_INS_FSLAS16,
    SPARC_INS_FSLAS32,
    SPARC_INS_FSLL16,
    SPARC_INS_FSLL32,
    SPARC_INS_FSMULD,
    SPARC_INS_FSQRTD,
    SPARC_INS_FSQRTQ,
    SPARC_INS_FSQRTS,
    SPARC_INS_FSRA16,
    SPARC_INS_FSRA32,
    SPARC_INS_FSRC1,
    SPARC_INS_FSRC1S,
    SPARC_INS_FSRC2,
    SPARC_INS_FSRC2S,
    SPARC_INS_FSRL16,
    SPARC_INS_FSRL32,
    SPARC_INS_FSTOD,
    SPARC_INS_FSTOI,
    SPARC_INS_FSTOQ,
    SPARC_INS_FSTOX,
    SPARC_INS_FSUBD,
    SPARC_INS_FSUBQ,
    SPARC_INS_FSUBS,
    SPARC_INS_FXNOR,
    SPARC_INS_FXNORS,
    SPARC_INS_FXOR,
    SPARC_INS_FXORS,
    SPARC_INS_FXTOD,
    SPARC_INS_FXTOQ,
    SPARC_INS_FXTOS,
    SPARC_INS_FZERO,
    SPARC_INS_FZEROS,
    SPARC_INS_JMPL,
    SPARC_INS_LDD,
    SPARC_INS_LD,
    SPARC_INS_LDQ,
    SPARC_INS_LDSB,
    SPARC_INS_LDSH,
    SPARC_INS_LDSW,
    SPARC_INS_LDUB,
    SPARC_INS_LDUH,
    SPARC_INS_LDX,
    SPARC_INS_LZCNT,
    SPARC_INS_MEMBAR,
    SPARC_INS_MOVDTOX,
    SPARC_INS_MOV,
    SPARC_INS_MOVRGEZ,
    SPARC_INS_MOVRGZ,
    SPARC_INS_MOVRLEZ,
    SPARC_INS_MOVRLZ,
    SPARC_INS_MOVRNZ,
    SPARC_INS_MOVRZ,
    SPARC_INS_MOVSTOSW,
    SPARC_INS_MOVSTOUW,
    SPARC_INS_MULX,
    SPARC_INS_NOP,
    SPARC_INS_ORCC,
    SPARC_INS_ORNCC,
    SPARC_INS_ORN,
    SPARC_INS_OR,
    SPARC_INS_PDIST,
    SPARC_INS_PDISTN,
    SPARC_INS_POPC,
    SPARC_INS_RD,
    SPARC_INS_RESTORE,
    SPARC_INS_RETT,
    SPARC_INS_SAVE,
    SPARC_INS_SDIVCC,
    SPARC_INS_SDIVX,
    SPARC_INS_SDIV,
    SPARC_INS_SETHI,
    SPARC_INS_SHUTDOWN,
    SPARC_INS_SIAM,
    SPARC_INS_SLLX,
    SPARC_INS_SLL,
    SPARC_INS_SMULCC,
    SPARC_INS_SMUL,
    SPARC_INS_SRAX,
    SPARC_INS_SRA,
    SPARC_INS_SRLX,
    SPARC_INS_SRL,
    SPARC_INS_STBAR,
    SPARC_INS_STB,
    SPARC_INS_STD,
    SPARC_INS_ST,
    SPARC_INS_STH,
    SPARC_INS_STQ,
    SPARC_INS_STX,
    SPARC_INS_SUBCC,
    SPARC_INS_SUBX,
    SPARC_INS_SUBXCC,
    SPARC_INS_SUB,
    SPARC_INS_SWAP,
    SPARC_INS_TADDCCTV,
    SPARC_INS_TADDCC,
    SPARC_INS_T,
    SPARC_INS_TSUBCCTV,
    SPARC_INS_TSUBCC,
    SPARC_INS_UDIVCC,
    SPARC_INS_UDIVX,
    SPARC_INS_UDIV,
    SPARC_INS_UMULCC,
    SPARC_INS_UMULXHI,
    SPARC_INS_UMUL,
    SPARC_INS_UNIMP,
    SPARC_INS_FCMPED,
    SPARC_INS_FCMPEQ,
    SPARC_INS_FCMPES,
    SPARC_INS_WR,
    SPARC_INS_XMULX,
    SPARC_INS_XMULXHI,
    SPARC_INS_XNORCC,
    SPARC_INS_XNOR,
    SPARC_INS_XORCC,
    SPARC_INS_XOR,

    // alias instructions
    SPARC_INS_RET,
    SPARC_INS_RETL,

    SPARC_INS_ENDING,   // <-- mark the end of the list of instructions
} sparc_insn;

//> Group of SPARC instructions
typedef enum sparc_insn_group
{
    SPARC_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    SPARC_GRP_JUMP, // = CS_GRP_JUMP

    //> Architecture-specific groups
    SPARC_GRP_HARDQUAD = 128,
    SPARC_GRP_V9,
    SPARC_GRP_VIS,
    SPARC_GRP_VIS2,
    SPARC_GRP_VIS3,
    SPARC_GRP_32BIT,
    SPARC_GRP_64BIT,

    SPARC_GRP_ENDING,   // <-- mark the end of the list of groups
} sparc_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/systemz.h
================================================
#ifndef CAPSTONE_SYSTEMZ_H
#define CAPSTONE_SYSTEMZ_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to SystemZ condition codes
typedef enum sysz_cc
{
    SYSZ_CC_INVALID = 0,    // invalid CC (default)

    SYSZ_CC_O,
    SYSZ_CC_H,
    SYSZ_CC_NLE,
    SYSZ_CC_L,
    SYSZ_CC_NHE,
    SYSZ_CC_LH,
    SYSZ_CC_NE,
    SYSZ_CC_E,
    SYSZ_CC_NLH,
    SYSZ_CC_HE,
    SYSZ_CC_NL,
    SYSZ_CC_LE,
    SYSZ_CC_NH,
    SYSZ_CC_NO,
} sysz_cc;

//> Operand type for instruction's operands
typedef enum sysz_op_type
{
    SYSZ_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    SYSZ_OP_REG, // = CS_OP_REG (Register operand).
    SYSZ_OP_IMM, // = CS_OP_IMM (Immediate operand).
    SYSZ_OP_MEM, // = CS_OP_MEM (Memory operand).
    SYSZ_OP_ACREG = 64, // Access register operand.
} sysz_op_type;

//> SystemZ registers
typedef enum sysz_reg
{
    SYSZ_REG_INVALID = 0,

    SYSZ_REG_0,
    SYSZ_REG_1,
    SYSZ_REG_2,
    SYSZ_REG_3,
    SYSZ_REG_4,
    SYSZ_REG_5,
    SYSZ_REG_6,
    SYSZ_REG_7,
    SYSZ_REG_8,
    SYSZ_REG_9,
    SYSZ_REG_10,
    SYSZ_REG_11,
    SYSZ_REG_12,
    SYSZ_REG_13,
    SYSZ_REG_14,
    SYSZ_REG_15,
    SYSZ_REG_CC,
    SYSZ_REG_F0,
    SYSZ_REG_F1,
    SYSZ_REG_F2,
    SYSZ_REG_F3,
    SYSZ_REG_F4,
    SYSZ_REG_F5,
    SYSZ_REG_F6,
    SYSZ_REG_F7,
    SYSZ_REG_F8,
    SYSZ_REG_F9,
    SYSZ_REG_F10,
    SYSZ_REG_F11,
    SYSZ_REG_F12,
    SYSZ_REG_F13,
    SYSZ_REG_F14,
    SYSZ_REG_F15,

    SYSZ_REG_R0L,

    SYSZ_REG_ENDING,
} sysz_reg;

// Instruction's operand referring to memory
// This is associated with SYSZ_OP_MEM operand type above
typedef struct sysz_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `sysz_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    uint64_t length;    // BDLAddr operand
    int64_t disp;   // displacement/offset value
} sysz_op_mem;

// Instruction operand
typedef struct cs_sysz_op
{
    sysz_op_type type;  // operand type
    union
    {
        sysz_reg reg;       // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        sysz_op_mem mem;    // base/disp value for MEM operand
    };
} cs_sysz_op;

// Instruction structure
typedef struct cs_sysz
{
    sysz_cc cc;     // Code condition
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_sysz_op operands[6]; // operands for this instruction.
} cs_sysz;

//> SystemZ instruction
typedef enum sysz_insn
{
    SYSZ_INS_INVALID = 0,

    SYSZ_INS_A,
    SYSZ_INS_ADB,
    SYSZ_INS_ADBR,
    SYSZ_INS_AEB,
    SYSZ_INS_AEBR,
    SYSZ_INS_AFI,
    SYSZ_INS_AG,
    SYSZ_INS_AGF,
    SYSZ_INS_AGFI,
    SYSZ_INS_AGFR,
    SYSZ_INS_AGHI,
    SYSZ_INS_AGHIK,
    SYSZ_INS_AGR,
    SYSZ_INS_AGRK,
    SYSZ_INS_AGSI,
    SYSZ_INS_AH,
    SYSZ_INS_AHI,
    SYSZ_INS_AHIK,
    SYSZ_INS_AHY,
    SYSZ_INS_AIH,
    SYSZ_INS_AL,
    SYSZ_INS_ALC,
    SYSZ_INS_ALCG,
    SYSZ_INS_ALCGR,
    SYSZ_INS_ALCR,
    SYSZ_INS_ALFI,
    SYSZ_INS_ALG,
    SYSZ_INS_ALGF,
    SYSZ_INS_ALGFI,
    SYSZ_INS_ALGFR,
    SYSZ_INS_ALGHSIK,
    SYSZ_INS_ALGR,
    SYSZ_INS_ALGRK,
    SYSZ_INS_ALHSIK,
    SYSZ_INS_ALR,
    SYSZ_INS_ALRK,
    SYSZ_INS_ALY,
    SYSZ_INS_AR,
    SYSZ_INS_ARK,
    SYSZ_INS_ASI,
    SYSZ_INS_AXBR,
    SYSZ_INS_AY,
    SYSZ_INS_BCR,
    SYSZ_INS_BRC,
    SYSZ_INS_BRCL,
    SYSZ_INS_CGIJ,
    SYSZ_INS_CGRJ,
    SYSZ_INS_CIJ,
    SYSZ_INS_CLGIJ,
    SYSZ_INS_CLGRJ,
    SYSZ_INS_CLIJ,
    SYSZ_INS_CLRJ,
    SYSZ_INS_CRJ,
    SYSZ_INS_BER,
    SYSZ_INS_JE,
    SYSZ_INS_JGE,
    SYSZ_INS_LOCE,
    SYSZ_INS_LOCGE,
    SYSZ_INS_LOCGRE,
    SYSZ_INS_LOCRE,
    SYSZ_INS_STOCE,
    SYSZ_INS_STOCGE,
    SYSZ_INS_BHR,
    SYSZ_INS_BHER,
    SYSZ_INS_JHE,
    SYSZ_INS_JGHE,
    SYSZ_INS_LOCHE,
    SYSZ_INS_LOCGHE,
    SYSZ_INS_LOCGRHE,
    SYSZ_INS_LOCRHE,
    SYSZ_INS_STOCHE,
    SYSZ_INS_STOCGHE,
    SYSZ_INS_JH,
    SYSZ_INS_JGH,
    SYSZ_INS_LOCH,
    SYSZ_INS_LOCGH,
    SYSZ_INS_LOCGRH,
    SYSZ_INS_LOCRH,
    SYSZ_INS_STOCH,
    SYSZ_INS_STOCGH,
    SYSZ_INS_CGIJNLH,
    SYSZ_INS_CGRJNLH,
    SYSZ_INS_CIJNLH,
    SYSZ_INS_CLGIJNLH,
    SYSZ_INS_CLGRJNLH,
    SYSZ_INS_CLIJNLH,
    SYSZ_INS_CLRJNLH,
    SYSZ_INS_CRJNLH,
    SYSZ_INS_CGIJE,
    SYSZ_INS_CGRJE,
    SYSZ_INS_CIJE,
    SYSZ_INS_CLGIJE,
    SYSZ_INS_CLGRJE,
    SYSZ_INS_CLIJE,
    SYSZ_INS_CLRJE,
    SYSZ_INS_CRJE,
    SYSZ_INS_CGIJNLE,
    SYSZ_INS_CGRJNLE,
    SYSZ_INS_CIJNLE,
    SYSZ_INS_CLGIJNLE,
    SYSZ_INS_CLGRJNLE,
    SYSZ_INS_CLIJNLE,
    SYSZ_INS_CLRJNLE,
    SYSZ_INS_CRJNLE,
    SYSZ_INS_CGIJH,
    SYSZ_INS_CGRJH,
    SYSZ_INS_CIJH,
    SYSZ_INS_CLGIJH,
    SYSZ_INS_CLGRJH,
    SYSZ_INS_CLIJH,
    SYSZ_INS_CLRJH,
    SYSZ_INS_CRJH,
    SYSZ_INS_CGIJNL,
    SYSZ_INS_CGRJNL,
    SYSZ_INS_CIJNL,
    SYSZ_INS_CLGIJNL,
    SYSZ_INS_CLGRJNL,
    SYSZ_INS_CLIJNL,
    SYSZ_INS_CLRJNL,
    SYSZ_INS_CRJNL,
    SYSZ_INS_CGIJHE,
    SYSZ_INS_CGRJHE,
    SYSZ_INS_CIJHE,
    SYSZ_INS_CLGIJHE,
    SYSZ_INS_CLGRJHE,
    SYSZ_INS_CLIJHE,
    SYSZ_INS_CLRJHE,
    SYSZ_INS_CRJHE,
    SYSZ_INS_CGIJNHE,
    SYSZ_INS_CGRJNHE,
    SYSZ_INS_CIJNHE,
    SYSZ_INS_CLGIJNHE,
    SYSZ_INS_CLGRJNHE,
    SYSZ_INS_CLIJNHE,
    SYSZ_INS_CLRJNHE,
    SYSZ_INS_CRJNHE,
    SYSZ_INS_CGIJL,
    SYSZ_INS_CGRJL,
    SYSZ_INS_CIJL,
    SYSZ_INS_CLGIJL,
    SYSZ_INS_CLGRJL,
    SYSZ_INS_CLIJL,
    SYSZ_INS_CLRJL,
    SYSZ_INS_CRJL,
    SYSZ_INS_CGIJNH,
    SYSZ_INS_CGRJNH,
    SYSZ_INS_CIJNH,
    SYSZ_INS_CLGIJNH,
    SYSZ_INS_CLGRJNH,
    SYSZ_INS_CLIJNH,
    SYSZ_INS_CLRJNH,
    SYSZ_INS_CRJNH,
    SYSZ_INS_CGIJLE,
    SYSZ_INS_CGRJLE,
    SYSZ_INS_CIJLE,
    SYSZ_INS_CLGIJLE,
    SYSZ_INS_CLGRJLE,
    SYSZ_INS_CLIJLE,
    SYSZ_INS_CLRJLE,
    SYSZ_INS_CRJLE,
    SYSZ_INS_CGIJNE,
    SYSZ_INS_CGRJNE,
    SYSZ_INS_CIJNE,
    SYSZ_INS_CLGIJNE,
    SYSZ_INS_CLGRJNE,
    SYSZ_INS_CLIJNE,
    SYSZ_INS_CLRJNE,
    SYSZ_INS_CRJNE,
    SYSZ_INS_CGIJLH,
    SYSZ_INS_CGRJLH,
    SYSZ_INS_CIJLH,
    SYSZ_INS_CLGIJLH,
    SYSZ_INS_CLGRJLH,
    SYSZ_INS_CLIJLH,
    SYSZ_INS_CLRJLH,
    SYSZ_INS_CRJLH,
    SYSZ_INS_BLR,
    SYSZ_INS_BLER,
    SYSZ_INS_JLE,
    SYSZ_INS_JGLE,
    SYSZ_INS_LOCLE,
    SYSZ_INS_LOCGLE,
    SYSZ_INS_LOCGRLE,
    SYSZ_INS_LOCRLE,
    SYSZ_INS_STOCLE,
    SYSZ_INS_STOCGLE,
    SYSZ_INS_BLHR,
    SYSZ_INS_JLH,
    SYSZ_INS_JGLH,
    SYSZ_INS_LOCLH,
    SYSZ_INS_LOCGLH,
    SYSZ_INS_LOCGRLH,
    SYSZ_INS_LOCRLH,
    SYSZ_INS_STOCLH,
    SYSZ_INS_STOCGLH,
    SYSZ_INS_JL,
    SYSZ_INS_JGL,
    SYSZ_INS_LOCL,
    SYSZ_INS_LOCGL,
    SYSZ_INS_LOCGRL,
    SYSZ_INS_LOCRL,
    SYSZ_INS_LOC,
    SYSZ_INS_LOCG,
    SYSZ_INS_LOCGR,
    SYSZ_INS_LOCR,
    SYSZ_INS_STOCL,
    SYSZ_INS_STOCGL,
    SYSZ_INS_BNER,
    SYSZ_INS_JNE,
    SYSZ_INS_JGNE,
    SYSZ_INS_LOCNE,
    SYSZ_INS_LOCGNE,
    SYSZ_INS_LOCGRNE,
    SYSZ_INS_LOCRNE,
    SYSZ_INS_STOCNE,
    SYSZ_INS_STOCGNE,
    SYSZ_INS_BNHR,
    SYSZ_INS_BNHER,
    SYSZ_INS_JNHE,
    SYSZ_INS_JGNHE,
    SYSZ_INS_LOCNHE,
    SYSZ_INS_LOCGNHE,
    SYSZ_INS_LOCGRNHE,
    SYSZ_INS_LOCRNHE,
    SYSZ_INS_STOCNHE,
    SYSZ_INS_STOCGNHE,
    SYSZ_INS_JNH,
    SYSZ_INS_JGNH,
    SYSZ_INS_LOCNH,
    SYSZ_INS_LOCGNH,
    SYSZ_INS_LOCGRNH,
    SYSZ_INS_LOCRNH,
    SYSZ_INS_STOCNH,
    SYSZ_INS_STOCGNH,
    SYSZ_INS_BNLR,
    SYSZ_INS_BNLER,
    SYSZ_INS_JNLE,
    SYSZ_INS_JGNLE,
    SYSZ_INS_LOCNLE,
    SYSZ_INS_LOCGNLE,
    SYSZ_INS_LOCGRNLE,
    SYSZ_INS_LOCRNLE,
    SYSZ_INS_STOCNLE,
    SYSZ_INS_STOCGNLE,
    SYSZ_INS_BNLHR,
    SYSZ_INS_JNLH,
    SYSZ_INS_JGNLH,
    SYSZ_INS_LOCNLH,
    SYSZ_INS_LOCGNLH,
    SYSZ_INS_LOCGRNLH,
    SYSZ_INS_LOCRNLH,
    SYSZ_INS_STOCNLH,
    SYSZ_INS_STOCGNLH,
    SYSZ_INS_JNL,
    SYSZ_INS_JGNL,
    SYSZ_INS_LOCNL,
    SYSZ_INS_LOCGNL,
    SYSZ_INS_LOCGRNL,
    SYSZ_INS_LOCRNL,
    SYSZ_INS_STOCNL,
    SYSZ_INS_STOCGNL,
    SYSZ_INS_BNOR,
    SYSZ_INS_JNO,
    SYSZ_INS_JGNO,
    SYSZ_INS_LOCNO,
    SYSZ_INS_LOCGNO,
    SYSZ_INS_LOCGRNO,
    SYSZ_INS_LOCRNO,
    SYSZ_INS_STOCNO,
    SYSZ_INS_STOCGNO,
    SYSZ_INS_BOR,
    SYSZ_INS_JO,
    SYSZ_INS_JGO,
    SYSZ_INS_LOCO,
    SYSZ_INS_LOCGO,
    SYSZ_INS_LOCGRO,
    SYSZ_INS_LOCRO,
    SYSZ_INS_STOCO,
    SYSZ_INS_STOCGO,
    SYSZ_INS_STOC,
    SYSZ_INS_STOCG,
    SYSZ_INS_BASR,
    SYSZ_INS_BR,
    SYSZ_INS_BRAS,
    SYSZ_INS_BRASL,
    SYSZ_INS_J,
    SYSZ_INS_JG,
    SYSZ_INS_BRCT,
    SYSZ_INS_BRCTG,
    SYSZ_INS_C,
    SYSZ_INS_CDB,
    SYSZ_INS_CDBR,
    SYSZ_INS_CDFBR,
    SYSZ_INS_CDGBR,
    SYSZ_INS_CDLFBR,
    SYSZ_INS_CDLGBR,
    SYSZ_INS_CEB,
    SYSZ_INS_CEBR,
    SYSZ_INS_CEFBR,
    SYSZ_INS_CEGBR,
    SYSZ_INS_CELFBR,
    SYSZ_INS_CELGBR,
    SYSZ_INS_CFDBR,
    SYSZ_INS_CFEBR,
    SYSZ_INS_CFI,
    SYSZ_INS_CFXBR,
    SYSZ_INS_CG,
    SYSZ_INS_CGDBR,
    SYSZ_INS_CGEBR,
    SYSZ_INS_CGF,
    SYSZ_INS_CGFI,
    SYSZ_INS_CGFR,
    SYSZ_INS_CGFRL,
    SYSZ_INS_CGH,
    SYSZ_INS_CGHI,
    SYSZ_INS_CGHRL,
    SYSZ_INS_CGHSI,
    SYSZ_INS_CGR,
    SYSZ_INS_CGRL,
    SYSZ_INS_CGXBR,
    SYSZ_INS_CH,
    SYSZ_INS_CHF,
    SYSZ_INS_CHHSI,
    SYSZ_INS_CHI,
    SYSZ_INS_CHRL,
    SYSZ_INS_CHSI,
    SYSZ_INS_CHY,
    SYSZ_INS_CIH,
    SYSZ_INS_CL,
    SYSZ_INS_CLC,
    SYSZ_INS_CLFDBR,
    SYSZ_INS_CLFEBR,
    SYSZ_INS_CLFHSI,
    SYSZ_INS_CLFI,
    SYSZ_INS_CLFXBR,
    SYSZ_INS_CLG,
    SYSZ_INS_CLGDBR,
    SYSZ_INS_CLGEBR,
    SYSZ_INS_CLGF,
    SYSZ_INS_CLGFI,
    SYSZ_INS_CLGFR,
    SYSZ_INS_CLGFRL,
    SYSZ_INS_CLGHRL,
    SYSZ_INS_CLGHSI,
    SYSZ_INS_CLGR,
    SYSZ_INS_CLGRL,
    SYSZ_INS_CLGXBR,
    SYSZ_INS_CLHF,
    SYSZ_INS_CLHHSI,
    SYSZ_INS_CLHRL,
    SYSZ_INS_CLI,
    SYSZ_INS_CLIH,
    SYSZ_INS_CLIY,
    SYSZ_INS_CLR,
    SYSZ_INS_CLRL,
    SYSZ_INS_CLST,
    SYSZ_INS_CLY,
    SYSZ_INS_CPSDR,
    SYSZ_INS_CR,
    SYSZ_INS_CRL,
    SYSZ_INS_CS,
    SYSZ_INS_CSG,
    SYSZ_INS_CSY,
    SYSZ_INS_CXBR,
    SYSZ_INS_CXFBR,
    SYSZ_INS_CXGBR,
    SYSZ_INS_CXLFBR,
    SYSZ_INS_CXLGBR,
    SYSZ_INS_CY,
    SYSZ_INS_DDB,
    SYSZ_INS_DDBR,
    SYSZ_INS_DEB,
    SYSZ_INS_DEBR,
    SYSZ_INS_DL,
    SYSZ_INS_DLG,
    SYSZ_INS_DLGR,
    SYSZ_INS_DLR,
    SYSZ_INS_DSG,
    SYSZ_INS_DSGF,
    SYSZ_INS_DSGFR,
    SYSZ_INS_DSGR,
    SYSZ_INS_DXBR,
    SYSZ_INS_EAR,
    SYSZ_INS_FIDBR,
    SYSZ_INS_FIDBRA,
    SYSZ_INS_FIEBR,
    SYSZ_INS_FIEBRA,
    SYSZ_INS_FIXBR,
    SYSZ_INS_FIXBRA,
    SYSZ_INS_FLOGR,
    SYSZ_INS_IC,
    SYSZ_INS_ICY,
    SYSZ_INS_IIHF,
    SYSZ_INS_IIHH,
    SYSZ_INS_IIHL,
    SYSZ_INS_IILF,
    SYSZ_INS_IILH,
    SYSZ_INS_IILL,
    SYSZ_INS_IPM,
    SYSZ_INS_L,
    SYSZ_INS_LA,
    SYSZ_INS_LAA,
    SYSZ_INS_LAAG,
    SYSZ_INS_LAAL,
    SYSZ_INS_LAALG,
    SYSZ_INS_LAN,
    SYSZ_INS_LANG,
    SYSZ_INS_LAO,
    SYSZ_INS_LAOG,
    SYSZ_INS_LARL,
    SYSZ_INS_LAX,
    SYSZ_INS_LAXG,
    SYSZ_INS_LAY,
    SYSZ_INS_LB,
    SYSZ_INS_LBH,
    SYSZ_INS_LBR,
    SYSZ_INS_LCDBR,
    SYSZ_INS_LCEBR,
    SYSZ_INS_LCGFR,
    SYSZ_INS_LCGR,
    SYSZ_INS_LCR,
    SYSZ_INS_LCXBR,
    SYSZ_INS_LD,
    SYSZ_INS_LDEB,
    SYSZ_INS_LDEBR,
    SYSZ_INS_LDGR,
    SYSZ_INS_LDR,
    SYSZ_INS_LDXBR,
    SYSZ_INS_LDXBRA,
    SYSZ_INS_LDY,
    SYSZ_INS_LE,
    SYSZ_INS_LEDBR,
    SYSZ_INS_LEDBRA,
    SYSZ_INS_LER,
    SYSZ_INS_LEXBR,
    SYSZ_INS_LEXBRA,
    SYSZ_INS_LEY,
    SYSZ_INS_LFH,
    SYSZ_INS_LG,
    SYSZ_INS_LGB,
    SYSZ_INS_LGBR,
    SYSZ_INS_LGDR,
    SYSZ_INS_LGF,
    SYSZ_INS_LGFI,
    SYSZ_INS_LGFR,
    SYSZ_INS_LGFRL,
    SYSZ_INS_LGH,
    SYSZ_INS_LGHI,
    SYSZ_INS_LGHR,
    SYSZ_INS_LGHRL,
    SYSZ_INS_LGR,
    SYSZ_INS_LGRL,
    SYSZ_INS_LH,
    SYSZ_INS_LHH,
    SYSZ_INS_LHI,
    SYSZ_INS_LHR,
    SYSZ_INS_LHRL,
    SYSZ_INS_LHY,
    SYSZ_INS_LLC,
    SYSZ_INS_LLCH,
    SYSZ_INS_LLCR,
    SYSZ_INS_LLGC,
    SYSZ_INS_LLGCR,
    SYSZ_INS_LLGF,
    SYSZ_INS_LLGFR,
    SYSZ_INS_LLGFRL,
    SYSZ_INS_LLGH,
    SYSZ_INS_LLGHR,
    SYSZ_INS_LLGHRL,
    SYSZ_INS_LLH,
    SYSZ_INS_LLHH,
    SYSZ_INS_LLHR,
    SYSZ_INS_LLHRL,
    SYSZ_INS_LLIHF,
    SYSZ_INS_LLIHH,
    SYSZ_INS_LLIHL,
    SYSZ_INS_LLILF,
    SYSZ_INS_LLILH,
    SYSZ_INS_LLILL,
    SYSZ_INS_LMG,
    SYSZ_INS_LNDBR,
    SYSZ_INS_LNEBR,
    SYSZ_INS_LNGFR,
    SYSZ_INS_LNGR,
    SYSZ_INS_LNR,
    SYSZ_INS_LNXBR,
    SYSZ_INS_LPDBR,
    SYSZ_INS_LPEBR,
    SYSZ_INS_LPGFR,
    SYSZ_INS_LPGR,
    SYSZ_INS_LPR,
    SYSZ_INS_LPXBR,
    SYSZ_INS_LR,
    SYSZ_INS_LRL,
    SYSZ_INS_LRV,
    SYSZ_INS_LRVG,
    SYSZ_INS_LRVGR,
    SYSZ_INS_LRVR,
    SYSZ_INS_LT,
    SYSZ_INS_LTDBR,
    SYSZ_INS_LTEBR,
    SYSZ_INS_LTG,
    SYSZ_INS_LTGF,
    SYSZ_INS_LTGFR,
    SYSZ_INS_LTGR,
    SYSZ_INS_LTR,
    SYSZ_INS_LTXBR,
    SYSZ_INS_LXDB,
    SYSZ_INS_LXDBR,
    SYSZ_INS_LXEB,
    SYSZ_INS_LXEBR,
    SYSZ_INS_LXR,
    SYSZ_INS_LY,
    SYSZ_INS_LZDR,
    SYSZ_INS_LZER,
    SYSZ_INS_LZXR,
    SYSZ_INS_MADB,
    SYSZ_INS_MADBR,
    SYSZ_INS_MAEB,
    SYSZ_INS_MAEBR,
    SYSZ_INS_MDB,
    SYSZ_INS_MDBR,
    SYSZ_INS_MDEB,
    SYSZ_INS_MDEBR,
    SYSZ_INS_MEEB,
    SYSZ_INS_MEEBR,
    SYSZ_INS_MGHI,
    SYSZ_INS_MH,
    SYSZ_INS_MHI,
    SYSZ_INS_MHY,
    SYSZ_INS_MLG,
    SYSZ_INS_MLGR,
    SYSZ_INS_MS,
    SYSZ_INS_MSDB,
    SYSZ_INS_MSDBR,
    SYSZ_INS_MSEB,
    SYSZ_INS_MSEBR,
    SYSZ_INS_MSFI,
    SYSZ_INS_MSG,
    SYSZ_INS_MSGF,
    SYSZ_INS_MSGFI,
    SYSZ_INS_MSGFR,
    SYSZ_INS_MSGR,
    SYSZ_INS_MSR,
    SYSZ_INS_MSY,
    SYSZ_INS_MVC,
    SYSZ_INS_MVGHI,
    SYSZ_INS_MVHHI,
    SYSZ_INS_MVHI,
    SYSZ_INS_MVI,
    SYSZ_INS_MVIY,
    SYSZ_INS_MVST,
    SYSZ_INS_MXBR,
    SYSZ_INS_MXDB,
    SYSZ_INS_MXDBR,
    SYSZ_INS_N,
    SYSZ_INS_NC,
    SYSZ_INS_NG,
    SYSZ_INS_NGR,
    SYSZ_INS_NGRK,
    SYSZ_INS_NI,
    SYSZ_INS_NIHF,
    SYSZ_INS_NIHH,
    SYSZ_INS_NIHL,
    SYSZ_INS_NILF,
    SYSZ_INS_NILH,
    SYSZ_INS_NILL,
    SYSZ_INS_NIY,
    SYSZ_INS_NR,
    SYSZ_INS_NRK,
    SYSZ_INS_NY,
    SYSZ_INS_O,
    SYSZ_INS_OC,
    SYSZ_INS_OG,
    SYSZ_INS_OGR,
    SYSZ_INS_OGRK,
    SYSZ_INS_OI,
    SYSZ_INS_OIHF,
    SYSZ_INS_OIHH,
    SYSZ_INS_OIHL,
    SYSZ_INS_OILF,
    SYSZ_INS_OILH,
    SYSZ_INS_OILL,
    SYSZ_INS_OIY,
    SYSZ_INS_OR,
    SYSZ_INS_ORK,
    SYSZ_INS_OY,
    SYSZ_INS_PFD,
    SYSZ_INS_PFDRL,
    SYSZ_INS_RISBG,
    SYSZ_INS_RISBHG,
    SYSZ_INS_RISBLG,
    SYSZ_INS_RLL,
    SYSZ_INS_RLLG,
    SYSZ_INS_RNSBG,
    SYSZ_INS_ROSBG,
    SYSZ_INS_RXSBG,
    SYSZ_INS_S,
    SYSZ_INS_SDB,
    SYSZ_INS_SDBR,
    SYSZ_INS_SEB,
    SYSZ_INS_SEBR,
    SYSZ_INS_SG,
    SYSZ_INS_SGF,
    SYSZ_INS_SGFR,
    SYSZ_INS_SGR,
    SYSZ_INS_SGRK,
    SYSZ_INS_SH,
    SYSZ_INS_SHY,
    SYSZ_INS_SL,
    SYSZ_INS_SLB,
    SYSZ_INS_SLBG,
    SYSZ_INS_SLBR,
    SYSZ_INS_SLFI,
    SYSZ_INS_SLG,
    SYSZ_INS_SLBGR,
    SYSZ_INS_SLGF,
    SYSZ_INS_SLGFI,
    SYSZ_INS_SLGFR,
    SYSZ_INS_SLGR,
    SYSZ_INS_SLGRK,
    SYSZ_INS_SLL,
    SYSZ_INS_SLLG,
    SYSZ_INS_SLLK,
    SYSZ_INS_SLR,
    SYSZ_INS_SLRK,
    SYSZ_INS_SLY,
    SYSZ_INS_SQDB,
    SYSZ_INS_SQDBR,
    SYSZ_INS_SQEB,
    SYSZ_INS_SQEBR,
    SYSZ_INS_SQXBR,
    SYSZ_INS_SR,
    SYSZ_INS_SRA,
    SYSZ_INS_SRAG,
    SYSZ_INS_SRAK,
    SYSZ_INS_SRK,
    SYSZ_INS_SRL,
    SYSZ_INS_SRLG,
    SYSZ_INS_SRLK,
    SYSZ_INS_SRST,
    SYSZ_INS_ST,
    SYSZ_INS_STC,
    SYSZ_INS_STCH,
    SYSZ_INS_STCY,
    SYSZ_INS_STD,
    SYSZ_INS_STDY,
    SYSZ_INS_STE,
    SYSZ_INS_STEY,
    SYSZ_INS_STFH,
    SYSZ_INS_STG,
    SYSZ_INS_STGRL,
    SYSZ_INS_STH,
    SYSZ_INS_STHH,
    SYSZ_INS_STHRL,
    SYSZ_INS_STHY,
    SYSZ_INS_STMG,
    SYSZ_INS_STRL,
    SYSZ_INS_STRV,
    SYSZ_INS_STRVG,
    SYSZ_INS_STY,
    SYSZ_INS_SXBR,
    SYSZ_INS_SY,
    SYSZ_INS_TM,
    SYSZ_INS_TMHH,
    SYSZ_INS_TMHL,
    SYSZ_INS_TMLH,
    SYSZ_INS_TMLL,
    SYSZ_INS_TMY,
    SYSZ_INS_X,
    SYSZ_INS_XC,
    SYSZ_INS_XG,
    SYSZ_INS_XGR,
    SYSZ_INS_XGRK,
    SYSZ_INS_XI,
    SYSZ_INS_XIHF,
    SYSZ_INS_XILF,
    SYSZ_INS_XIY,
    SYSZ_INS_XR,
    SYSZ_INS_XRK,
    SYSZ_INS_XY,

    SYSZ_INS_ENDING,   // <-- mark the end of the list of instructions
} sysz_insn;

//> Group of SystemZ instructions
typedef enum sysz_insn_group
{
    SYSZ_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    SYSZ_GRP_JUMP,  // = CS_GRP_JUMP

    //> Architecture-specific groups
    SYSZ_GRP_DISTINCTOPS = 128,
    SYSZ_GRP_FPEXTENSION,
    SYSZ_GRP_HIGHWORD,
    SYSZ_GRP_INTERLOCKEDACCESS1,
    SYSZ_GRP_LOADSTOREONCOND,

    SYSZ_GRP_ENDING,   // <-- mark the end of the list of groups
} sysz_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/x86.h
================================================
#ifndef CAPSTONE_X86_H
#define CAPSTONE_X86_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// Calculate relative address for X86-64, given cs_insn structure
#define X86_REL_ADDR(insn) (insn.address + insn.size + insn.detail->x86.disp)

//> X86 registers
typedef enum x86_reg
{
    X86_REG_INVALID = 0,
    X86_REG_AH, X86_REG_AL, X86_REG_AX, X86_REG_BH, X86_REG_BL,
    X86_REG_BP, X86_REG_BPL, X86_REG_BX, X86_REG_CH, X86_REG_CL,
    X86_REG_CS, X86_REG_CX, X86_REG_DH, X86_REG_DI, X86_REG_DIL,
    X86_REG_DL, X86_REG_DS, X86_REG_DX, X86_REG_EAX, X86_REG_EBP,
    X86_REG_EBX, X86_REG_ECX, X86_REG_EDI, X86_REG_EDX, X86_REG_EFLAGS,
    X86_REG_EIP, X86_REG_EIZ, X86_REG_ES, X86_REG_ESI, X86_REG_ESP,
    X86_REG_FPSW, X86_REG_FS, X86_REG_GS, X86_REG_IP, X86_REG_RAX,
    X86_REG_RBP, X86_REG_RBX, X86_REG_RCX, X86_REG_RDI, X86_REG_RDX,
    X86_REG_RIP, X86_REG_RIZ, X86_REG_RSI, X86_REG_RSP, X86_REG_SI,
    X86_REG_SIL, X86_REG_SP, X86_REG_SPL, X86_REG_SS, X86_REG_CR0,
    X86_REG_CR1, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR5,
    X86_REG_CR6, X86_REG_CR7, X86_REG_CR8, X86_REG_CR9, X86_REG_CR10,
    X86_REG_CR11, X86_REG_CR12, X86_REG_CR13, X86_REG_CR14, X86_REG_CR15,
    X86_REG_DR0, X86_REG_DR1, X86_REG_DR2, X86_REG_DR3, X86_REG_DR4,
    X86_REG_DR5, X86_REG_DR6, X86_REG_DR7, X86_REG_DR8, X86_REG_DR9,
    X86_REG_DR10, X86_REG_DR11, X86_REG_DR12, X86_REG_DR13, X86_REG_DR14,
    X86_REG_DR15, X86_REG_FP0, X86_REG_FP1, X86_REG_FP2, X86_REG_FP3,
    X86_REG_FP4, X86_REG_FP5, X86_REG_FP6, X86_REG_FP7,
    X86_REG_K0, X86_REG_K1, X86_REG_K2, X86_REG_K3, X86_REG_K4,
    X86_REG_K5, X86_REG_K6, X86_REG_K7, X86_REG_MM0, X86_REG_MM1,
    X86_REG_MM2, X86_REG_MM3, X86_REG_MM4, X86_REG_MM5, X86_REG_MM6,
    X86_REG_MM7, X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
    X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
    X86_REG_ST0, X86_REG_ST1, X86_REG_ST2, X86_REG_ST3,
    X86_REG_ST4, X86_REG_ST5, X86_REG_ST6, X86_REG_ST7,
    X86_REG_XMM0, X86_REG_XMM1, X86_REG_XMM2, X86_REG_XMM3, X86_REG_XMM4,
    X86_REG_XMM5, X86_REG_XMM6, X86_REG_XMM7, X86_REG_XMM8, X86_REG_XMM9,
    X86_REG_XMM10, X86_REG_XMM11, X86_REG_XMM12, X86_REG_XMM13, X86_REG_XMM14,
    X86_REG_XMM15, X86_REG_XMM16, X86_REG_XMM17, X86_REG_XMM18, X86_REG_XMM19,
    X86_REG_XMM20, X86_REG_XMM21, X86_REG_XMM22, X86_REG_XMM23, X86_REG_XMM24,
    X86_REG_XMM25, X86_REG_XMM26, X86_REG_XMM27, X86_REG_XMM28, X86_REG_XMM29,
    X86_REG_XMM30, X86_REG_XMM31, X86_REG_YMM0, X86_REG_YMM1, X86_REG_YMM2,
    X86_REG_YMM3, X86_REG_YMM4, X86_REG_YMM5, X86_REG_YMM6, X86_REG_YMM7,
    X86_REG_YMM8, X86_REG_YMM9, X86_REG_YMM10, X86_REG_YMM11, X86_REG_YMM12,
    X86_REG_YMM13, X86_REG_YMM14, X86_REG_YMM15, X86_REG_YMM16, X86_REG_YMM17,
    X86_REG_YMM18, X86_REG_YMM19, X86_REG_YMM20, X86_REG_YMM21, X86_REG_YMM22,
    X86_REG_YMM23, X86_REG_YMM24, X86_REG_YMM25, X86_REG_YMM26, X86_REG_YMM27,
    X86_REG_YMM28, X86_REG_YMM29, X86_REG_YMM30, X86_REG_YMM31, X86_REG_ZMM0,
    X86_REG_ZMM1, X86_REG_ZMM2, X86_REG_ZMM3, X86_REG_ZMM4, X86_REG_ZMM5,
    X86_REG_ZMM6, X86_REG_ZMM7, X86_REG_ZMM8, X86_REG_ZMM9, X86_REG_ZMM10,
    X86_REG_ZMM11, X86_REG_ZMM12, X86_REG_ZMM13, X86_REG_ZMM14, X86_REG_ZMM15,
    X86_REG_ZMM16, X86_REG_ZMM17, X86_REG_ZMM18, X86_REG_ZMM19, X86_REG_ZMM20,
    X86_REG_ZMM21, X86_REG_ZMM22, X86_REG_ZMM23, X86_REG_ZMM24, X86_REG_ZMM25,
    X86_REG_ZMM26, X86_REG_ZMM27, X86_REG_ZMM28, X86_REG_ZMM29, X86_REG_ZMM30,
    X86_REG_ZMM31, X86_REG_R8B, X86_REG_R9B, X86_REG_R10B, X86_REG_R11B,
    X86_REG_R12B, X86_REG_R13B, X86_REG_R14B, X86_REG_R15B, X86_REG_R8D,
    X86_REG_R9D, X86_REG_R10D, X86_REG_R11D, X86_REG_R12D, X86_REG_R13D,
    X86_REG_R14D, X86_REG_R15D, X86_REG_R8W, X86_REG_R9W, X86_REG_R10W,
    X86_REG_R11W, X86_REG_R12W, X86_REG_R13W, X86_REG_R14W, X86_REG_R15W,

    X86_REG_ENDING      // <-- mark the end of the list of registers
} x86_reg;

//> Sub-flags of EFLAGS
#define X86_EFLAGS_MODIFY_AF (1ULL << 0)
#define X86_EFLAGS_MODIFY_CF (1ULL << 1)
#define X86_EFLAGS_MODIFY_SF (1ULL << 2)
#define X86_EFLAGS_MODIFY_ZF (1ULL << 3)
#define X86_EFLAGS_MODIFY_PF (1ULL << 4)
#define X86_EFLAGS_MODIFY_OF (1ULL << 5)
#define X86_EFLAGS_MODIFY_TF (1ULL << 6)
#define X86_EFLAGS_MODIFY_IF (1ULL << 7)
#define X86_EFLAGS_MODIFY_DF (1ULL << 8)
#define X86_EFLAGS_MODIFY_NT (1ULL << 9)
#define X86_EFLAGS_MODIFY_RF (1ULL << 10)
#define X86_EFLAGS_PRIOR_OF (1ULL << 11)
#define X86_EFLAGS_PRIOR_SF (1ULL << 12)
#define X86_EFLAGS_PRIOR_ZF (1ULL << 13)
#define X86_EFLAGS_PRIOR_AF (1ULL << 14)
#define X86_EFLAGS_PRIOR_PF (1ULL << 15)
#define X86_EFLAGS_PRIOR_CF (1ULL << 16)
#define X86_EFLAGS_PRIOR_TF (1ULL << 17)
#define X86_EFLAGS_PRIOR_IF (1ULL << 18)
#define X86_EFLAGS_PRIOR_DF (1ULL << 19)
#define X86_EFLAGS_PRIOR_NT (1ULL << 20)
#define X86_EFLAGS_RESET_OF (1ULL << 21)
#define X86_EFLAGS_RESET_CF (1ULL << 22)
#define X86_EFLAGS_RESET_DF (1ULL << 23)
#define X86_EFLAGS_RESET_IF (1ULL << 24)
#define X86_EFLAGS_RESET_SF (1ULL << 25)
#define X86_EFLAGS_RESET_AF (1ULL << 26)
#define X86_EFLAGS_RESET_TF (1ULL << 27)
#define X86_EFLAGS_RESET_NT (1ULL << 28)
#define X86_EFLAGS_RESET_PF (1ULL << 29)
#define X86_EFLAGS_SET_CF (1ULL << 30)
#define X86_EFLAGS_SET_DF (1ULL << 31)
#define X86_EFLAGS_SET_IF (1ULL << 32)
#define X86_EFLAGS_TEST_OF (1ULL << 33)
#define X86_EFLAGS_TEST_SF (1ULL << 34)
#define X86_EFLAGS_TEST_ZF (1ULL << 35)
#define X86_EFLAGS_TEST_PF (1ULL << 36)
#define X86_EFLAGS_TEST_CF (1ULL << 37)
#define X86_EFLAGS_TEST_NT (1ULL << 38)
#define X86_EFLAGS_TEST_DF (1ULL << 39)
#define X86_EFLAGS_UNDEFINED_OF (1ULL << 40)
#define X86_EFLAGS_UNDEFINED_SF (1ULL << 41)
#define X86_EFLAGS_UNDEFINED_ZF (1ULL << 42)
#define X86_EFLAGS_UNDEFINED_PF (1ULL << 43)
#define X86_EFLAGS_UNDEFINED_AF (1ULL << 44)
#define X86_EFLAGS_UNDEFINED_CF (1ULL << 45)

//> Operand type for instruction's operands
typedef enum x86_op_type
{
    X86_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    X86_OP_REG, // = CS_OP_REG (Register operand).
    X86_OP_IMM, // = CS_OP_IMM (Immediate operand).
    X86_OP_MEM, // = CS_OP_MEM (Memory operand).
} x86_op_type;

//> XOP Code Condition type
typedef enum x86_xop_cc
{
    X86_XOP_CC_INVALID = 0, // Uninitialized.
    X86_XOP_CC_LT,
    X86_XOP_CC_LE,
    X86_XOP_CC_GT,
    X86_XOP_CC_GE,
    X86_XOP_CC_EQ,
    X86_XOP_CC_NEQ,
    X86_XOP_CC_FALSE,
    X86_XOP_CC_TRUE,
} x86_xop_cc;

//> AVX broadcast type
typedef enum x86_avx_bcast
{
    X86_AVX_BCAST_INVALID = 0,  // Uninitialized.
    X86_AVX_BCAST_2,    // AVX512 broadcast type {1to2}
    X86_AVX_BCAST_4,    // AVX512 broadcast type {1to4}
    X86_AVX_BCAST_8,    // AVX512 broadcast type {1to8}
    X86_AVX_BCAST_16,   // AVX512 broadcast type {1to16}
} x86_avx_bcast;

//> SSE Code Condition type
typedef enum x86_sse_cc
{
    X86_SSE_CC_INVALID = 0, // Uninitialized.
    X86_SSE_CC_EQ,
    X86_SSE_CC_LT,
    X86_SSE_CC_LE,
    X86_SSE_CC_UNORD,
    X86_SSE_CC_NEQ,
    X86_SSE_CC_NLT,
    X86_SSE_CC_NLE,
    X86_SSE_CC_ORD,
} x86_sse_cc;

//> AVX Code Condition type
typedef enum x86_avx_cc
{
    X86_AVX_CC_INVALID = 0, // Uninitialized.
    X86_AVX_CC_EQ,
    X86_AVX_CC_LT,
    X86_AVX_CC_LE,
    X86_AVX_CC_UNORD,
    X86_AVX_CC_NEQ,
    X86_AVX_CC_NLT,
    X86_AVX_CC_NLE,
    X86_AVX_CC_ORD,
    X86_AVX_CC_EQ_UQ,
    X86_AVX_CC_NGE,
    X86_AVX_CC_NGT,
    X86_AVX_CC_FALSE,
    X86_AVX_CC_NEQ_OQ,
    X86_AVX_CC_GE,
    X86_AVX_CC_GT,
    X86_AVX_CC_TRUE,
    X86_AVX_CC_EQ_OS,
    X86_AVX_CC_LT_OQ,
    X86_AVX_CC_LE_OQ,
    X86_AVX_CC_UNORD_S,
    X86_AVX_CC_NEQ_US,
    X86_AVX_CC_NLT_UQ,
    X86_AVX_CC_NLE_UQ,
    X86_AVX_CC_ORD_S,
    X86_AVX_CC_EQ_US,
    X86_AVX_CC_NGE_UQ,
    X86_AVX_CC_NGT_UQ,
    X86_AVX_CC_FALSE_OS,
    X86_AVX_CC_NEQ_OS,
    X86_AVX_CC_GE_OQ,
    X86_AVX_CC_GT_OQ,
    X86_AVX_CC_TRUE_US,
} x86_avx_cc;

//> AVX static rounding mode type
typedef enum x86_avx_rm
{
    X86_AVX_RM_INVALID = 0, // Uninitialized.
    X86_AVX_RM_RN,  // Round to nearest
    X86_AVX_RM_RD,  // Round down
    X86_AVX_RM_RU,  // Round up
    X86_AVX_RM_RZ,  // Round toward zero
} x86_avx_rm;

//> Instruction prefixes - to be used in cs_x86.prefix[]
typedef enum x86_prefix
{
    X86_PREFIX_LOCK     =   0xf0,   // lock (cs_x86.prefix[0]
    X86_PREFIX_REP      =   0xf3,   // rep (cs_x86.prefix[0]
    X86_PREFIX_REPE     =   0xf3,   // repe/repz (cs_x86.prefix[0]
    X86_PREFIX_REPNE    =   0xf2,   // repne/repnz (cs_x86.prefix[0]

    X86_PREFIX_CS       =   0x2e,   // segment override CS (cs_x86.prefix[1]
    X86_PREFIX_SS       =   0x36,   // segment override SS (cs_x86.prefix[1]
    X86_PREFIX_DS       =   0x3e,   // segment override DS (cs_x86.prefix[1]
    X86_PREFIX_ES       =   0x26,   // segment override ES (cs_x86.prefix[1]
    X86_PREFIX_FS       =   0x64,   // segment override FS (cs_x86.prefix[1]
    X86_PREFIX_GS       =   0x65,   // segment override GS (cs_x86.prefix[1]

    X86_PREFIX_OPSIZE   =   0x66,   // operand-size override (cs_x86.prefix[2]
    X86_PREFIX_ADDRSIZE =   0x67,   // address-size override (cs_x86.prefix[3]
} x86_prefix;

// Instruction's operand referring to memory
// This is associated with X86_OP_MEM operand type above
typedef struct x86_op_mem
{
    x86_reg segment; // segment register (or X86_REG_INVALID if irrelevant)
    x86_reg base;   // base register (or X86_REG_INVALID if irrelevant)
    x86_reg index;  // index register (or X86_REG_INVALID if irrelevant)
    int scale;  // scale for index register
    int64_t disp;   // displacement value
} x86_op_mem;

// Instruction operand
typedef struct cs_x86_op
{
    x86_op_type type;   // operand type
    union
    {
        x86_reg reg;      // register value for REG operand
        int64_t imm;        // immediate value for IMM operand
        x86_op_mem mem;     // base/index/scale/disp value for MEM operand
    };

    // size of this operand (in bytes).
    uint8_t size;

    // How is this operand accessed? (READ, WRITE or READ|WRITE)
    // This field is combined of cs_ac_type.
    // NOTE: this field is irrelevant if engine is compiled in DIET mode.
    uint8_t access;

    // AVX broadcast type, or 0 if irrelevant
    x86_avx_bcast avx_bcast;

    // AVX zero opmask {z}
    bool avx_zero_opmask;
} cs_x86_op;

// Instruction structure
typedef struct cs_x86
{
    // Instruction prefix, which can be up to 4 bytes.
    // A prefix byte gets value 0 when irrelevant.
    // prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
    // prefix[1] indicates segment override (irrelevant for x86_64):
    // See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
    // prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
    // prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
    uint8_t prefix[4];

    // Instruction opcode, wich can be from 1 to 4 bytes in size.
    // This contains VEX opcode as well.
    // An trailing opcode byte gets value 0 when irrelevant.
    uint8_t opcode[4];

    // REX prefix: only a non-zero value is relavant for x86_64
    uint8_t rex;

    // Address size, which can be overrided with above prefix[5].
    uint8_t addr_size;

    // ModR/M byte
    uint8_t modrm;

    // SIB value, or 0 when irrelevant.
    uint8_t sib;

    // Displacement value, or 0 when irrelevant.
    int32_t disp;

    /* SIB state */
    // SIB index register, or X86_REG_INVALID when irrelevant.
    x86_reg sib_index;
    // SIB scale. only applicable if sib_index is relavant.
    int8_t sib_scale;
    // SIB base register, or X86_REG_INVALID when irrelevant.
    x86_reg sib_base;

    // XOP Code Condition
    x86_xop_cc xop_cc;

    // SSE Code Condition
    x86_sse_cc sse_cc;

    // AVX Code Condition
    x86_avx_cc avx_cc;

    // AVX Suppress all Exception
    bool avx_sae;

    // AVX static rounding mode
    x86_avx_rm avx_rm;

    // EFLAGS updated by this instruction.
    // This can be formed from OR combination of X86_EFLAGS_* symbols in x86.h
    uint64_t eflags;

    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;

    cs_x86_op operands[8];  // operands for this instruction.
} cs_x86;

//> X86 instructions
typedef enum x86_insn
{
    X86_INS_INVALID = 0,

    X86_INS_AAA,
    X86_INS_AAD,
    X86_INS_AAM,
    X86_INS_AAS,
    X86_INS_FABS,
    X86_INS_ADC,
    X86_INS_ADCX,
    X86_INS_ADD,
    X86_INS_ADDPD,
    X86_INS_ADDPS,
    X86_INS_ADDSD,
    X86_INS_ADDSS,
    X86_INS_ADDSUBPD,
    X86_INS_ADDSUBPS,
    X86_INS_FADD,
    X86_INS_FIADD,
    X86_INS_FADDP,
    X86_INS_ADOX,
    X86_INS_AESDECLAST,
    X86_INS_AESDEC,
    X86_INS_AESENCLAST,
    X86_INS_AESENC,
    X86_INS_AESIMC,
    X86_INS_AESKEYGENASSIST,
    X86_INS_AND,
    X86_INS_ANDN,
    X86_INS_ANDNPD,
    X86_INS_ANDNPS,
    X86_INS_ANDPD,
    X86_INS_ANDPS,
    X86_INS_ARPL,
    X86_INS_BEXTR,
    X86_INS_BLCFILL,
    X86_INS_BLCI,
    X86_INS_BLCIC,
    X86_INS_BLCMSK,
    X86_INS_BLCS,
    X86_INS_BLENDPD,
    X86_INS_BLENDPS,
    X86_INS_BLENDVPD,
    X86_INS_BLENDVPS,
    X86_INS_BLSFILL,
    X86_INS_BLSI,
    X86_INS_BLSIC,
    X86_INS_BLSMSK,
    X86_INS_BLSR,
    X86_INS_BOUND,
    X86_INS_BSF,
    X86_INS_BSR,
    X86_INS_BSWAP,
    X86_INS_BT,
    X86_INS_BTC,
    X86_INS_BTR,
    X86_INS_BTS,
    X86_INS_BZHI,
    X86_INS_CALL,
    X86_INS_CBW,
    X86_INS_CDQ,
    X86_INS_CDQE,
    X86_INS_FCHS,
    X86_INS_CLAC,
    X86_INS_CLC,
    X86_INS_CLD,
    X86_INS_CLFLUSH,
    X86_INS_CLFLUSHOPT,
    X86_INS_CLGI,
    X86_INS_CLI,
    X86_INS_CLTS,
    X86_INS_CLWB,
    X86_INS_CMC,
    X86_INS_CMOVA,
    X86_INS_CMOVAE,
    X86_INS_CMOVB,
    X86_INS_CMOVBE,
    X86_INS_FCMOVBE,
    X86_INS_FCMOVB,
    X86_INS_CMOVE,
    X86_INS_FCMOVE,
    X86_INS_CMOVG,
    X86_INS_CMOVGE,
    X86_INS_CMOVL,
    X86_INS_CMOVLE,
    X86_INS_FCMOVNBE,
    X86_INS_FCMOVNB,
    X86_INS_CMOVNE,
    X86_INS_FCMOVNE,
    X86_INS_CMOVNO,
    X86_INS_CMOVNP,
    X86_INS_FCMOVNU,
    X86_INS_CMOVNS,
    X86_INS_CMOVO,
    X86_INS_CMOVP,
    X86_INS_FCMOVU,
    X86_INS_CMOVS,
    X86_INS_CMP,
    X86_INS_CMPPD,
    X86_INS_CMPPS,
    X86_INS_CMPSB,
    X86_INS_CMPSD,
    X86_INS_CMPSQ,
    X86_INS_CMPSS,
    X86_INS_CMPSW,
    X86_INS_CMPXCHG16B,
    X86_INS_CMPXCHG,
    X86_INS_CMPXCHG8B,
    X86_INS_COMISD,
    X86_INS_COMISS,
    X86_INS_FCOMP,
    X86_INS_FCOMPI,
    X86_INS_FCOMI,
    X86_INS_FCOM,
    X86_INS_FCOS,
    X86_INS_CPUID,
    X86_INS_CQO,
    X86_INS_CRC32,
    X86_INS_CVTDQ2PD,
    X86_INS_CVTDQ2PS,
    X86_INS_CVTPD2DQ,
    X86_INS_CVTPD2PS,
    X86_INS_CVTPS2DQ,
    X86_INS_CVTPS2PD,
    X86_INS_CVTSD2SI,
    X86_INS_CVTSD2SS,
    X86_INS_CVTSI2SD,
    X86_INS_CVTSI2SS,
    X86_INS_CVTSS2SD,
    X86_INS_CVTSS2SI,
    X86_INS_CVTTPD2DQ,
    X86_INS_CVTTPS2DQ,
    X86_INS_CVTTSD2SI,
    X86_INS_CVTTSS2SI,
    X86_INS_CWD,
    X86_INS_CWDE,
    X86_INS_DAA,
    X86_INS_DAS,
    X86_INS_DATA16,
    X86_INS_DEC,
    X86_INS_DIV,
    X86_INS_DIVPD,
    X86_INS_DIVPS,
    X86_INS_FDIVR,
    X86_INS_FIDIVR,
    X86_INS_FDIVRP,
    X86_INS_DIVSD,
    X86_INS_DIVSS,
    X86_INS_FDIV,
    X86_INS_FIDIV,
    X86_INS_FDIVP,
    X86_INS_DPPD,
    X86_INS_DPPS,
    X86_INS_RET,
    X86_INS_ENCLS,
    X86_INS_ENCLU,
    X86_INS_ENTER,
    X86_INS_EXTRACTPS,
    X86_INS_EXTRQ,
    X86_INS_F2XM1,
    X86_INS_LCALL,
    X86_INS_LJMP,
    X86_INS_FBLD,
    X86_INS_FBSTP,
    X86_INS_FCOMPP,
    X86_INS_FDECSTP,
    X86_INS_FEMMS,
    X86_INS_FFREE,
    X86_INS_FICOM,
    X86_INS_FICOMP,
    X86_INS_FINCSTP,
    X86_INS_FLDCW,
    X86_INS_FLDENV,
    X86_INS_FLDL2E,
    X86_INS_FLDL2T,
    X86_INS_FLDLG2,
    X86_INS_FLDLN2,
    X86_INS_FLDPI,
    X86_INS_FNCLEX,
    X86_INS_FNINIT,
    X86_INS_FNOP,
    X86_INS_FNSTCW,
    X86_INS_FNSTSW,
    X86_INS_FPATAN,
    X86_INS_FPREM,
    X86_INS_FPREM1,
    X86_INS_FPTAN,
    X86_INS_FFREEP,
    X86_INS_FRNDINT,
    X86_INS_FRSTOR,
    X86_INS_FNSAVE,
    X86_INS_FSCALE,
    X86_INS_FSETPM,
    X86_INS_FSINCOS,
    X86_INS_FNSTENV,
    X86_INS_FXAM,
    X86_INS_FXRSTOR,
    X86_INS_FXRSTOR64,
    X86_INS_FXSAVE,
    X86_INS_FXSAVE64,
    X86_INS_FXTRACT,
    X86_INS_FYL2X,
    X86_INS_FYL2XP1,
    X86_INS_MOVAPD,
    X86_INS_MOVAPS,
    X86_INS_ORPD,
    X86_INS_ORPS,
    X86_INS_VMOVAPD,
    X86_INS_VMOVAPS,
    X86_INS_XORPD,
    X86_INS_XORPS,
    X86_INS_GETSEC,
    X86_INS_HADDPD,
    X86_INS_HADDPS,
    X86_INS_HLT,
    X86_INS_HSUBPD,
    X86_INS_HSUBPS,
    X86_INS_IDIV,
    X86_INS_FILD,
    X86_INS_IMUL,
    X86_INS_IN,
    X86_INS_INC,
    X86_INS_INSB,
    X86_INS_INSERTPS,
    X86_INS_INSERTQ,
    X86_INS_INSD,
    X86_INS_INSW,
    X86_INS_INT,
    X86_INS_INT1,
    X86_INS_INT3,
    X86_INS_INTO,
    X86_INS_INVD,
    X86_INS_INVEPT,
    X86_INS_INVLPG,
    X86_INS_INVLPGA,
    X86_INS_INVPCID,
    X86_INS_INVVPID,
    X86_INS_IRET,
    X86_INS_IRETD,
    X86_INS_IRETQ,
    X86_INS_FISTTP,
    X86_INS_FIST,
    X86_INS_FISTP,
    X86_INS_UCOMISD,
    X86_INS_UCOMISS,
    X86_INS_VCOMISD,
    X86_INS_VCOMISS,
    X86_INS_VCVTSD2SS,
    X86_INS_VCVTSI2SD,
    X86_INS_VCVTSI2SS,
    X86_INS_VCVTSS2SD,
    X86_INS_VCVTTSD2SI,
    X86_INS_VCVTTSD2USI,
    X86_INS_VCVTTSS2SI,
    X86_INS_VCVTTSS2USI,
    X86_INS_VCVTUSI2SD,
    X86_INS_VCVTUSI2SS,
    X86_INS_VUCOMISD,
    X86_INS_VUCOMISS,
    X86_INS_JAE,
    X86_INS_JA,
    X86_INS_JBE,
    X86_INS_JB,
    X86_INS_JCXZ,
    X86_INS_JECXZ,
    X86_INS_JE,
    X86_INS_JGE,
    X86_INS_JG,
    X86_INS_JLE,
    X86_INS_JL,
    X86_INS_JMP,
    X86_INS_JNE,
    X86_INS_JNO,
    X86_INS_JNP,
    X86_INS_JNS,
    X86_INS_JO,
    X86_INS_JP,
    X86_INS_JRCXZ,
    X86_INS_JS,
    X86_INS_KANDB,
    X86_INS_KANDD,
    X86_INS_KANDNB,
    X86_INS_KANDND,
    X86_INS_KANDNQ,
    X86_INS_KANDNW,
    X86_INS_KANDQ,
    X86_INS_KANDW,
    X86_INS_KMOVB,
    X86_INS_KMOVD,
    X86_INS_KMOVQ,
    X86_INS_KMOVW,
    X86_INS_KNOTB,
    X86_INS_KNOTD,
    X86_INS_KNOTQ,
    X86_INS_KNOTW,
    X86_INS_KORB,
    X86_INS_KORD,
    X86_INS_KORQ,
    X86_INS_KORTESTB,
    X86_INS_KORTESTD,
    X86_INS_KORTESTQ,
    X86_INS_KORTESTW,
    X86_INS_KORW,
    X86_INS_KSHIFTLB,
    X86_INS_KSHIFTLD,
    X86_INS_KSHIFTLQ,
    X86_INS_KSHIFTLW,
    X86_INS_KSHIFTRB,
    X86_INS_KSHIFTRD,
    X86_INS_KSHIFTRQ,
    X86_INS_KSHIFTRW,
    X86_INS_KUNPCKBW,
    X86_INS_KXNORB,
    X86_INS_KXNORD,
    X86_INS_KXNORQ,
    X86_INS_KXNORW,
    X86_INS_KXORB,
    X86_INS_KXORD,
    X86_INS_KXORQ,
    X86_INS_KXORW,
    X86_INS_LAHF,
    X86_INS_LAR,
    X86_INS_LDDQU,
    X86_INS_LDMXCSR,
    X86_INS_LDS,
    X86_INS_FLDZ,
    X86_INS_FLD1,
    X86_INS_FLD,
    X86_INS_LEA,
    X86_INS_LEAVE,
    X86_INS_LES,
    X86_INS_LFENCE,
    X86_INS_LFS,
    X86_INS_LGDT,
    X86_INS_LGS,
    X86_INS_LIDT,
    X86_INS_LLDT,
    X86_INS_LMSW,
    X86_INS_OR,
    X86_INS_SUB,
    X86_INS_XOR,
    X86_INS_LODSB,
    X86_INS_LODSD,
    X86_INS_LODSQ,
    X86_INS_LODSW,
    X86_INS_LOOP,
    X86_INS_LOOPE,
    X86_INS_LOOPNE,
    X86_INS_RETF,
    X86_INS_RETFQ,
    X86_INS_LSL,
    X86_INS_LSS,
    X86_INS_LTR,
    X86_INS_XADD,
    X86_INS_LZCNT,
    X86_INS_MASKMOVDQU,
    X86_INS_MAXPD,
    X86_INS_MAXPS,
    X86_INS_MAXSD,
    X86_INS_MAXSS,
    X86_INS_MFENCE,
    X86_INS_MINPD,
    X86_INS_MINPS,
    X86_INS_MINSD,
    X86_INS_MINSS,
    X86_INS_CVTPD2PI,
    X86_INS_CVTPI2PD,
    X86_INS_CVTPI2PS,
    X86_INS_CVTPS2PI,
    X86_INS_CVTTPD2PI,
    X86_INS_CVTTPS2PI,
    X86_INS_EMMS,
    X86_INS_MASKMOVQ,
    X86_INS_MOVD,
    X86_INS_MOVDQ2Q,
    X86_INS_MOVNTQ,
    X86_INS_MOVQ2DQ,
    X86_INS_MOVQ,
    X86_INS_PABSB,
    X86_INS_PABSD,
    X86_INS_PABSW,
    X86_INS_PACKSSDW,
    X86_INS_PACKSSWB,
    X86_INS_PACKUSWB,
    X86_INS_PADDB,
    X86_INS_PADDD,
    X86_INS_PADDQ,
    X86_INS_PADDSB,
    X86_INS_PADDSW,
    X86_INS_PADDUSB,
    X86_INS_PADDUSW,
    X86_INS_PADDW,
    X86_INS_PALIGNR,
    X86_INS_PANDN,
    X86_INS_PAND,
    X86_INS_PAVGB,
    X86_INS_PAVGW,
    X86_INS_PCMPEQB,
    X86_INS_PCMPEQD,
    X86_INS_PCMPEQW,
    X86_INS_PCMPGTB,
    X86_INS_PCMPGTD,
    X86_INS_PCMPGTW,
    X86_INS_PEXTRW,
    X86_INS_PHADDSW,
    X86_INS_PHADDW,
    X86_INS_PHADDD,
    X86_INS_PHSUBD,
    X86_INS_PHSUBSW,
    X86_INS_PHSUBW,
    X86_INS_PINSRW,
    X86_INS_PMADDUBSW,
    X86_INS_PMADDWD,
    X86_INS_PMAXSW,
    X86_INS_PMAXUB,
    X86_INS_PMINSW,
    X86_INS_PMINUB,
    X86_INS_PMOVMSKB,
    X86_INS_PMULHRSW,
    X86_INS_PMULHUW,
    X86_INS_PMULHW,
    X86_INS_PMULLW,
    X86_INS_PMULUDQ,
    X86_INS_POR,
    X86_INS_PSADBW,
    X86_INS_PSHUFB,
    X86_INS_PSHUFW,
    X86_INS_PSIGNB,
    X86_INS_PSIGND,
    X86_INS_PSIGNW,
    X86_INS_PSLLD,
    X86_INS_PSLLQ,
    X86_INS_PSLLW,
    X86_INS_PSRAD,
    X86_INS_PSRAW,
    X86_INS_PSRLD,
    X86_INS_PSRLQ,
    X86_INS_PSRLW,
    X86_INS_PSUBB,
    X86_INS_PSUBD,
    X86_INS_PSUBQ,
    X86_INS_PSUBSB,
    X86_INS_PSUBSW,
    X86_INS_PSUBUSB,
    X86_INS_PSUBUSW,
    X86_INS_PSUBW,
    X86_INS_PUNPCKHBW,
    X86_INS_PUNPCKHDQ,
    X86_INS_PUNPCKHWD,
    X86_INS_PUNPCKLBW,
    X86_INS_PUNPCKLDQ,
    X86_INS_PUNPCKLWD,
    X86_INS_PXOR,
    X86_INS_MONITOR,
    X86_INS_MONTMUL,
    X86_INS_MOV,
    X86_INS_MOVABS,
    X86_INS_MOVBE,
    X86_INS_MOVDDUP,
    X86_INS_MOVDQA,
    X86_INS_MOVDQU,
    X86_INS_MOVHLPS,
    X86_INS_MOVHPD,
    X86_INS_MOVHPS,
    X86_INS_MOVLHPS,
    X86_INS_MOVLPD,
    X86_INS_MOVLPS,
    X86_INS_MOVMSKPD,
    X86_INS_MOVMSKPS,
    X86_INS_MOVNTDQA,
    X86_INS_MOVNTDQ,
    X86_INS_MOVNTI,
    X86_INS_MOVNTPD,
    X86_INS_MOVNTPS,
    X86_INS_MOVNTSD,
    X86_INS_MOVNTSS,
    X86_INS_MOVSB,
    X86_INS_MOVSD,
    X86_INS_MOVSHDUP,
    X86_INS_MOVSLDUP,
    X86_INS_MOVSQ,
    X86_INS_MOVSS,
    X86_INS_MOVSW,
    X86_INS_MOVSX,
    X86_INS_MOVSXD,
    X86_INS_MOVUPD,
    X86_INS_MOVUPS,
    X86_INS_MOVZX,
    X86_INS_MPSADBW,
    X86_INS_MUL,
    X86_INS_MULPD,
    X86_INS_MULPS,
    X86_INS_MULSD,
    X86_INS_MULSS,
    X86_INS_MULX,
    X86_INS_FMUL,
    X86_INS_FIMUL,
    X86_INS_FMULP,
    X86_INS_MWAIT,
    X86_INS_NEG,
    X86_INS_NOP,
    X86_INS_NOT,
    X86_INS_OUT,
    X86_INS_OUTSB,
    X86_INS_OUTSD,
    X86_INS_OUTSW,
    X86_INS_PACKUSDW,
    X86_INS_PAUSE,
    X86_INS_PAVGUSB,
    X86_INS_PBLENDVB,
    X86_INS_PBLENDW,
    X86_INS_PCLMULQDQ,
    X86_INS_PCMPEQQ,
    X86_INS_PCMPESTRI,
    X86_INS_PCMPESTRM,
    X86_INS_PCMPGTQ,
    X86_INS_PCMPISTRI,
    X86_INS_PCMPISTRM,
    X86_INS_PCOMMIT,
    X86_INS_PDEP,
    X86_INS_PEXT,
    X86_INS_PEXTRB,
    X86_INS_PEXTRD,
    X86_INS_PEXTRQ,
    X86_INS_PF2ID,
    X86_INS_PF2IW,
    X86_INS_PFACC,
    X86_INS_PFADD,
    X86_INS_PFCMPEQ,
    X86_INS_PFCMPGE,
    X86_INS_PFCMPGT,
    X86_INS_PFMAX,
    X86_INS_PFMIN,
    X86_INS_PFMUL,
    X86_INS_PFNACC,
    X86_INS_PFPNACC,
    X86_INS_PFRCPIT1,
    X86_INS_PFRCPIT2,
    X86_INS_PFRCP,
    X86_INS_PFRSQIT1,
    X86_INS_PFRSQRT,
    X86_INS_PFSUBR,
    X86_INS_PFSUB,
    X86_INS_PHMINPOSUW,
    X86_INS_PI2FD,
    X86_INS_PI2FW,
    X86_INS_PINSRB,
    X86_INS_PINSRD,
    X86_INS_PINSRQ,
    X86_INS_PMAXSB,
    X86_INS_PMAXSD,
    X86_INS_PMAXUD,
    X86_INS_PMAXUW,
    X86_INS_PMINSB,
    X86_INS_PMINSD,
    X86_INS_PMINUD,
    X86_INS_PMINUW,
    X86_INS_PMOVSXBD,
    X86_INS_PMOVSXBQ,
    X86_INS_PMOVSXBW,
    X86_INS_PMOVSXDQ,
    X86_INS_PMOVSXWD,
    X86_INS_PMOVSXWQ,
    X86_INS_PMOVZXBD,
    X86_INS_PMOVZXBQ,
    X86_INS_PMOVZXBW,
    X86_INS_PMOVZXDQ,
    X86_INS_PMOVZXWD,
    X86_INS_PMOVZXWQ,
    X86_INS_PMULDQ,
    X86_INS_PMULHRW,
    X86_INS_PMULLD,
    X86_INS_POP,
    X86_INS_POPAW,
    X86_INS_POPAL,
    X86_INS_POPCNT,
    X86_INS_POPF,
    X86_INS_POPFD,
    X86_INS_POPFQ,
    X86_INS_PREFETCH,
    X86_INS_PREFETCHNTA,
    X86_INS_PREFETCHT0,
    X86_INS_PREFETCHT1,
    X86_INS_PREFETCHT2,
    X86_INS_PREFETCHW,
    X86_INS_PSHUFD,
    X86_INS_PSHUFHW,
    X86_INS_PSHUFLW,
    X86_INS_PSLLDQ,
    X86_INS_PSRLDQ,
    X86_INS_PSWAPD,
    X86_INS_PTEST,
    X86_INS_PUNPCKHQDQ,
    X86_INS_PUNPCKLQDQ,
    X86_INS_PUSH,
    X86_INS_PUSHAW,
    X86_INS_PUSHAL,
    X86_INS_PUSHF,
    X86_INS_PUSHFD,
    X86_INS_PUSHFQ,
    X86_INS_RCL,
    X86_INS_RCPPS,
    X86_INS_RCPSS,
    X86_INS_RCR,
    X86_INS_RDFSBASE,
    X86_INS_RDGSBASE,
    X86_INS_RDMSR,
    X86_INS_RDPMC,
    X86_INS_RDRAND,
    X86_INS_RDSEED,
    X86_INS_RDTSC,
    X86_INS_RDTSCP,
    X86_INS_ROL,
    X86_INS_ROR,
    X86_INS_RORX,
    X86_INS_ROUNDPD,
    X86_INS_ROUNDPS,
    X86_INS_ROUNDSD,
    X86_INS_ROUNDSS,
    X86_INS_RSM,
    X86_INS_RSQRTPS,
    X86_INS_RSQRTSS,
    X86_INS_SAHF,
    X86_INS_SAL,
    X86_INS_SALC,
    X86_INS_SAR,
    X86_INS_SARX,
    X86_INS_SBB,
    X86_INS_SCASB,
    X86_INS_SCASD,
    X86_INS_SCASQ,
    X86_INS_SCASW,
    X86_INS_SETAE,
    X86_INS_SETA,
    X86_INS_SETBE,
    X86_INS_SETB,
    X86_INS_SETE,
    X86_INS_SETGE,
    X86_INS_SETG,
    X86_INS_SETLE,
    X86_INS_SETL,
    X86_INS_SETNE,
    X86_INS_SETNO,
    X86_INS_SETNP,
    X86_INS_SETNS,
    X86_INS_SETO,
    X86_INS_SETP,
    X86_INS_SETS,
    X86_INS_SFENCE,
    X86_INS_SGDT,
    X86_INS_SHA1MSG1,
    X86_INS_SHA1MSG2,
    X86_INS_SHA1NEXTE,
    X86_INS_SHA1RNDS4,
    X86_INS_SHA256MSG1,
    X86_INS_SHA256MSG2,
    X86_INS_SHA256RNDS2,
    X86_INS_SHL,
    X86_INS_SHLD,
    X86_INS_SHLX,
    X86_INS_SHR,
    X86_INS_SHRD,
    X86_INS_SHRX,
    X86_INS_SHUFPD,
    X86_INS_SHUFPS,
    X86_INS_SIDT,
    X86_INS_FSIN,
    X86_INS_SKINIT,
    X86_INS_SLDT,
    X86_INS_SMSW,
    X86_INS_SQRTPD,
    X86_INS_SQRTPS,
    X86_INS_SQRTSD,
    X86_INS_SQRTSS,
    X86_INS_FSQRT,
    X86_INS_STAC,
    X86_INS_STC,
    X86_INS_STD,
    X86_INS_STGI,
    X86_INS_STI,
    X86_INS_STMXCSR,
    X86_INS_STOSB,
    X86_INS_STOSD,
    X86_INS_STOSQ,
    X86_INS_STOSW,
    X86_INS_STR,
    X86_INS_FST,
    X86_INS_FSTP,
    X86_INS_FSTPNCE,
    X86_INS_FXCH,
    X86_INS_SUBPD,
    X86_INS_SUBPS,
    X86_INS_FSUBR,
    X86_INS_FISUBR,
    X86_INS_FSUBRP,
    X86_INS_SUBSD,
    X86_INS_SUBSS,
    X86_INS_FSUB,
    X86_INS_FISUB,
    X86_INS_FSUBP,
    X86_INS_SWAPGS,
    X86_INS_SYSCALL,
    X86_INS_SYSENTER,
    X86_INS_SYSEXIT,
    X86_INS_SYSRET,
    X86_INS_T1MSKC,
    X86_INS_TEST,
    X86_INS_UD2,
    X86_INS_FTST,
    X86_INS_TZCNT,
    X86_INS_TZMSK,
    X86_INS_FUCOMPI,
    X86_INS_FUCOMI,
    X86_INS_FUCOMPP,
    X86_INS_FUCOMP,
    X86_INS_FUCOM,
    X86_INS_UD2B,
    X86_INS_UNPCKHPD,
    X86_INS_UNPCKHPS,
    X86_INS_UNPCKLPD,
    X86_INS_UNPCKLPS,
    X86_INS_VADDPD,
    X86_INS_VADDPS,
    X86_INS_VADDSD,
    X86_INS_VADDSS,
    X86_INS_VADDSUBPD,
    X86_INS_VADDSUBPS,
    X86_INS_VAESDECLAST,
    X86_INS_VAESDEC,
    X86_INS_VAESENCLAST,
    X86_INS_VAESENC,
    X86_INS_VAESIMC,
    X86_INS_VAESKEYGENASSIST,
    X86_INS_VALIGND,
    X86_INS_VALIGNQ,
    X86_INS_VANDNPD,
    X86_INS_VANDNPS,
    X86_INS_VANDPD,
    X86_INS_VANDPS,
    X86_INS_VBLENDMPD,
    X86_INS_VBLENDMPS,
    X86_INS_VBLENDPD,
    X86_INS_VBLENDPS,
    X86_INS_VBLENDVPD,
    X86_INS_VBLENDVPS,
    X86_INS_VBROADCASTF128,
    X86_INS_VBROADCASTI32X4,
    X86_INS_VBROADCASTI64X4,
    X86_INS_VBROADCASTSD,
    X86_INS_VBROADCASTSS,
    X86_INS_VCMPPD,
    X86_INS_VCMPPS,
    X86_INS_VCMPSD,
    X86_INS_VCMPSS,
    X86_INS_VCOMPRESSPD,
    X86_INS_VCOMPRESSPS,
    X86_INS_VCVTDQ2PD,
    X86_INS_VCVTDQ2PS,
    X86_INS_VCVTPD2DQX,
    X86_INS_VCVTPD2DQ,
    X86_INS_VCVTPD2PSX,
    X86_INS_VCVTPD2PS,
    X86_INS_VCVTPD2UDQ,
    X86_INS_VCVTPH2PS,
    X86_INS_VCVTPS2DQ,
    X86_INS_VCVTPS2PD,
    X86_INS_VCVTPS2PH,
    X86_INS_VCVTPS2UDQ,
    X86_INS_VCVTSD2SI,
    X86_INS_VCVTSD2USI,
    X86_INS_VCVTSS2SI,
    X86_INS_VCVTSS2USI,
    X86_INS_VCVTTPD2DQX,
    X86_INS_VCVTTPD2DQ,
    X86_INS_VCVTTPD2UDQ,
    X86_INS_VCVTTPS2DQ,
    X86_INS_VCVTTPS2UDQ,
    X86_INS_VCVTUDQ2PD,
    X86_INS_VCVTUDQ2PS,
    X86_INS_VDIVPD,
    X86_INS_VDIVPS,
    X86_INS_VDIVSD,
    X86_INS_VDIVSS,
    X86_INS_VDPPD,
    X86_INS_VDPPS,
    X86_INS_VERR,
    X86_INS_VERW,
    X86_INS_VEXP2PD,
    X86_INS_VEXP2PS,
    X86_INS_VEXPANDPD,
    X86_INS_VEXPANDPS,
    X86_INS_VEXTRACTF128,
    X86_INS_VEXTRACTF32X4,
    X86_INS_VEXTRACTF64X4,
    X86_INS_VEXTRACTI128,
    X86_INS_VEXTRACTI32X4,
    X86_INS_VEXTRACTI64X4,
    X86_INS_VEXTRACTPS,
    X86_INS_VFMADD132PD,
    X86_INS_VFMADD132PS,
    X86_INS_VFMADDPD,
    X86_INS_VFMADD213PD,
    X86_INS_VFMADD231PD,
    X86_INS_VFMADDPS,
    X86_INS_VFMADD213PS,
    X86_INS_VFMADD231PS,
    X86_INS_VFMADDSD,
    X86_INS_VFMADD213SD,
    X86_INS_VFMADD132SD,
    X86_INS_VFMADD231SD,
    X86_INS_VFMADDSS,
    X86_INS_VFMADD213SS,
    X86_INS_VFMADD132SS,
    X86_INS_VFMADD231SS,
    X86_INS_VFMADDSUB132PD,
    X86_INS_VFMADDSUB132PS,
    X86_INS_VFMADDSUBPD,
    X86_INS_VFMADDSUB213PD,
    X86_INS_VFMADDSUB231PD,
    X86_INS_VFMADDSUBPS,
    X86_INS_VFMADDSUB213PS,
    X86_INS_VFMADDSUB231PS,
    X86_INS_VFMSUB132PD,
    X86_INS_VFMSUB132PS,
    X86_INS_VFMSUBADD132PD,
    X86_INS_VFMSUBADD132PS,
    X86_INS_VFMSUBADDPD,
    X86_INS_VFMSUBADD213PD,
    X86_INS_VFMSUBADD231PD,
    X86_INS_VFMSUBADDPS,
    X86_INS_VFMSUBADD213PS,
    X86_INS_VFMSUBADD231PS,
    X86_INS_VFMSUBPD,
    X86_INS_VFMSUB213PD,
    X86_INS_VFMSUB231PD,
    X86_INS_VFMSUBPS,
    X86_INS_VFMSUB213PS,
    X86_INS_VFMSUB231PS,
    X86_INS_VFMSUBSD,
    X86_INS_VFMSUB213SD,
    X86_INS_VFMSUB132SD,
    X86_INS_VFMSUB231SD,
    X86_INS_VFMSUBSS,
    X86_INS_VFMSUB213SS,
    X86_INS_VFMSUB132SS,
    X86_INS_VFMSUB231SS,
    X86_INS_VFNMADD132PD,
    X86_INS_VFNMADD132PS,
    X86_INS_VFNMADDPD,
    X86_INS_VFNMADD213PD,
    X86_INS_VFNMADD231PD,
    X86_INS_VFNMADDPS,
    X86_INS_VFNMADD213PS,
    X86_INS_VFNMADD231PS,
    X86_INS_VFNMADDSD,
    X86_INS_VFNMADD213SD,
    X86_INS_VFNMADD132SD,
    X86_INS_VFNMADD231SD,
    X86_INS_VFNMADDSS,
    X86_INS_VFNMADD213SS,
    X86_INS_VFNMADD132SS,
    X86_INS_VFNMADD231SS,
    X86_INS_VFNMSUB132PD,
    X86_INS_VFNMSUB132PS,
    X86_INS_VFNMSUBPD,
    X86_INS_VFNMSUB213PD,
    X86_INS_VFNMSUB231PD,
    X86_INS_VFNMSUBPS,
    X86_INS_VFNMSUB213PS,
    X86_INS_VFNMSUB231PS,
    X86_INS_VFNMSUBSD,
    X86_INS_VFNMSUB213SD,
    X86_INS_VFNMSUB132SD,
    X86_INS_VFNMSUB231SD,
    X86_INS_VFNMSUBSS,
    X86_INS_VFNMSUB213SS,
    X86_INS_VFNMSUB132SS,
    X86_INS_VFNMSUB231SS,
    X86_INS_VFRCZPD,
    X86_INS_VFRCZPS,
    X86_INS_VFRCZSD,
    X86_INS_VFRCZSS,
    X86_INS_VORPD,
    X86_INS_VORPS,
    X86_INS_VXORPD,
    X86_INS_VXORPS,
    X86_INS_VGATHERDPD,
    X86_INS_VGATHERDPS,
    X86_INS_VGATHERPF0DPD,
    X86_INS_VGATHERPF0DPS,
    X86_INS_VGATHERPF0QPD,
    X86_INS_VGATHERPF0QPS,
    X86_INS_VGATHERPF1DPD,
    X86_INS_VGATHERPF1DPS,
    X86_INS_VGATHERPF1QPD,
    X86_INS_VGATHERPF1QPS,
    X86_INS_VGATHERQPD,
    X86_INS_VGATHERQPS,
    X86_INS_VHADDPD,
    X86_INS_VHADDPS,
    X86_INS_VHSUBPD,
    X86_INS_VHSUBPS,
    X86_INS_VINSERTF128,
    X86_INS_VINSERTF32X4,
    X86_INS_VINSERTF32X8,
    X86_INS_VINSERTF64X2,
    X86_INS_VINSERTF64X4,
    X86_INS_VINSERTI128,
    X86_INS_VINSERTI32X4,
    X86_INS_VINSERTI32X8,
    X86_INS_VINSERTI64X2,
    X86_INS_VINSERTI64X4,
    X86_INS_VINSERTPS,
    X86_INS_VLDDQU,
    X86_INS_VLDMXCSR,
    X86_INS_VMASKMOVDQU,
    X86_INS_VMASKMOVPD,
    X86_INS_VMASKMOVPS,
    X86_INS_VMAXPD,
    X86_INS_VMAXPS,
    X86_INS_VMAXSD,
    X86_INS_VMAXSS,
    X86_INS_VMCALL,
    X86_INS_VMCLEAR,
    X86_INS_VMFUNC,
    X86_INS_VMINPD,
    X86_INS_VMINPS,
    X86_INS_VMINSD,
    X86_INS_VMINSS,
    X86_INS_VMLAUNCH,
    X86_INS_VMLOAD,
    X86_INS_VMMCALL,
    X86_INS_VMOVQ,
    X86_INS_VMOVDDUP,
    X86_INS_VMOVD,
    X86_INS_VMOVDQA32,
    X86_INS_VMOVDQA64,
    X86_INS_VMOVDQA,
    X86_INS_VMOVDQU16,
    X86_INS_VMOVDQU32,
    X86_INS_VMOVDQU64,
    X86_INS_VMOVDQU8,
    X86_INS_VMOVDQU,
    X86_INS_VMOVHLPS,
    X86_INS_VMOVHPD,
    X86_INS_VMOVHPS,
    X86_INS_VMOVLHPS,
    X86_INS_VMOVLPD,
    X86_INS_VMOVLPS,
    X86_INS_VMOVMSKPD,
    X86_INS_VMOVMSKPS,
    X86_INS_VMOVNTDQA,
    X86_INS_VMOVNTDQ,
    X86_INS_VMOVNTPD,
    X86_INS_VMOVNTPS,
    X86_INS_VMOVSD,
    X86_INS_VMOVSHDUP,
    X86_INS_VMOVSLDUP,
    X86_INS_VMOVSS,
    X86_INS_VMOVUPD,
    X86_INS_VMOVUPS,
    X86_INS_VMPSADBW,
    X86_INS_VMPTRLD,
    X86_INS_VMPTRST,
    X86_INS_VMREAD,
    X86_INS_VMRESUME,
    X86_INS_VMRUN,
    X86_INS_VMSAVE,
    X86_INS_VMULPD,
    X86_INS_VMULPS,
    X86_INS_VMULSD,
    X86_INS_VMULSS,
    X86_INS_VMWRITE,
    X86_INS_VMXOFF,
    X86_INS_VMXON,
    X86_INS_VPABSB,
    X86_INS_VPABSD,
    X86_INS_VPABSQ,
    X86_INS_VPABSW,
    X86_INS_VPACKSSDW,
    X86_INS_VPACKSSWB,
    X86_INS_VPACKUSDW,
    X86_INS_VPACKUSWB,
    X86_INS_VPADDB,
    X86_INS_VPADDD,
    X86_INS_VPADDQ,
    X86_INS_VPADDSB,
    X86_INS_VPADDSW,
    X86_INS_VPADDUSB,
    X86_INS_VPADDUSW,
    X86_INS_VPADDW,
    X86_INS_VPALIGNR,
    X86_INS_VPANDD,
    X86_INS_VPANDND,
    X86_INS_VPANDNQ,
    X86_INS_VPANDN,
    X86_INS_VPANDQ,
    X86_INS_VPAND,
    X86_INS_VPAVGB,
    X86_INS_VPAVGW,
    X86_INS_VPBLENDD,
    X86_INS_VPBLENDMB,
    X86_INS_VPBLENDMD,
    X86_INS_VPBLENDMQ,
    X86_INS_VPBLENDMW,
    X86_INS_VPBLENDVB,
    X86_INS_VPBLENDW,
    X86_INS_VPBROADCASTB,
    X86_INS_VPBROADCASTD,
    X86_INS_VPBROADCASTMB2Q,
    X86_INS_VPBROADCASTMW2D,
    X86_INS_VPBROADCASTQ,
    X86_INS_VPBROADCASTW,
    X86_INS_VPCLMULQDQ,
    X86_INS_VPCMOV,
    X86_INS_VPCMPB,
    X86_INS_VPCMPD,
    X86_INS_VPCMPEQB,
    X86_INS_VPCMPEQD,
    X86_INS_VPCMPEQQ,
    X86_INS_VPCMPEQW,
    X86_INS_VPCMPESTRI,
    X86_INS_VPCMPESTRM,
    X86_INS_VPCMPGTB,
    X86_INS_VPCMPGTD,
    X86_INS_VPCMPGTQ,
    X86_INS_VPCMPGTW,
    X86_INS_VPCMPISTRI,
    X86_INS_VPCMPISTRM,
    X86_INS_VPCMPQ,
    X86_INS_VPCMPUB,
    X86_INS_VPCMPUD,
    X86_INS_VPCMPUQ,
    X86_INS_VPCMPUW,
    X86_INS_VPCMPW,
    X86_INS_VPCOMB,
    X86_INS_VPCOMD,
    X86_INS_VPCOMPRESSD,
    X86_INS_VPCOMPRESSQ,
    X86_INS_VPCOMQ,
    X86_INS_VPCOMUB,
    X86_INS_VPCOMUD,
    X86_INS_VPCOMUQ,
    X86_INS_VPCOMUW,
    X86_INS_VPCOMW,
    X86_INS_VPCONFLICTD,
    X86_INS_VPCONFLICTQ,
    X86_INS_VPERM2F128,
    X86_INS_VPERM2I128,
    X86_INS_VPERMD,
    X86_INS_VPERMI2D,
    X86_INS_VPERMI2PD,
    X86_INS_VPERMI2PS,
    X86_INS_VPERMI2Q,
    X86_INS_VPERMIL2PD,
    X86_INS_VPERMIL2PS,
    X86_INS_VPERMILPD,
    X86_INS_VPERMILPS,
    X86_INS_VPERMPD,
    X86_INS_VPERMPS,
    X86_INS_VPERMQ,
    X86_INS_VPERMT2D,
    X86_INS_VPERMT2PD,
    X86_INS_VPERMT2PS,
    X86_INS_VPERMT2Q,
    X86_INS_VPEXPANDD,
    X86_INS_VPEXPANDQ,
    X86_INS_VPEXTRB,
    X86_INS_VPEXTRD,
    X86_INS_VPEXTRQ,
    X86_INS_VPEXTRW,
    X86_INS_VPGATHERDD,
    X86_INS_VPGATHERDQ,
    X86_INS_VPGATHERQD,
    X86_INS_VPGATHERQQ,
    X86_INS_VPHADDBD,
    X86_INS_VPHADDBQ,
    X86_INS_VPHADDBW,
    X86_INS_VPHADDDQ,
    X86_INS_VPHADDD,
    X86_INS_VPHADDSW,
    X86_INS_VPHADDUBD,
    X86_INS_VPHADDUBQ,
    X86_INS_VPHADDUBW,
    X86_INS_VPHADDUDQ,
    X86_INS_VPHADDUWD,
    X86_INS_VPHADDUWQ,
    X86_INS_VPHADDWD,
    X86_INS_VPHADDWQ,
    X86_INS_VPHADDW,
    X86_INS_VPHMINPOSUW,
    X86_INS_VPHSUBBW,
    X86_INS_VPHSUBDQ,
    X86_INS_VPHSUBD,
    X86_INS_VPHSUBSW,
    X86_INS_VPHSUBWD,
    X86_INS_VPHSUBW,
    X86_INS_VPINSRB,
    X86_INS_VPINSRD,
    X86_INS_VPINSRQ,
    X86_INS_VPINSRW,
    X86_INS_VPLZCNTD,
    X86_INS_VPLZCNTQ,
    X86_INS_VPMACSDD,
    X86_INS_VPMACSDQH,
    X86_INS_VPMACSDQL,
    X86_INS_VPMACSSDD,
    X86_INS_VPMACSSDQH,
    X86_INS_VPMACSSDQL,
    X86_INS_VPMACSSWD,
    X86_INS_VPMACSSWW,
    X86_INS_VPMACSWD,
    X86_INS_VPMACSWW,
    X86_INS_VPMADCSSWD,
    X86_INS_VPMADCSWD,
    X86_INS_VPMADDUBSW,
    X86_INS_VPMADDWD,
    X86_INS_VPMASKMOVD,
    X86_INS_VPMASKMOVQ,
    X86_INS_VPMAXSB,
    X86_INS_VPMAXSD,
    X86_INS_VPMAXSQ,
    X86_INS_VPMAXSW,
    X86_INS_VPMAXUB,
    X86_INS_VPMAXUD,
    X86_INS_VPMAXUQ,
    X86_INS_VPMAXUW,
    X86_INS_VPMINSB,
    X86_INS_VPMINSD,
    X86_INS_VPMINSQ,
    X86_INS_VPMINSW,
    X86_INS_VPMINUB,
    X86_INS_VPMINUD,
    X86_INS_VPMINUQ,
    X86_INS_VPMINUW,
    X86_INS_VPMOVDB,
    X86_INS_VPMOVDW,
    X86_INS_VPMOVM2B,
    X86_INS_VPMOVM2D,
    X86_INS_VPMOVM2Q,
    X86_INS_VPMOVM2W,
    X86_INS_VPMOVMSKB,
    X86_INS_VPMOVQB,
    X86_INS_VPMOVQD,
    X86_INS_VPMOVQW,
    X86_INS_VPMOVSDB,
    X86_INS_VPMOVSDW,
    X86_INS_VPMOVSQB,
    X86_INS_VPMOVSQD,
    X86_INS_VPMOVSQW,
    X86_INS_VPMOVSXBD,
    X86_INS_VPMOVSXBQ,
    X86_INS_VPMOVSXBW,
    X86_INS_VPMOVSXDQ,
    X86_INS_VPMOVSXWD,
    X86_INS_VPMOVSXWQ,
    X86_INS_VPMOVUSDB,
    X86_INS_VPMOVUSDW,
    X86_INS_VPMOVUSQB,
    X86_INS_VPMOVUSQD,
    X86_INS_VPMOVUSQW,
    X86_INS_VPMOVZXBD,
    X86_INS_VPMOVZXBQ,
    X86_INS_VPMOVZXBW,
    X86_INS_VPMOVZXDQ,
    X86_INS_VPMOVZXWD,
    X86_INS_VPMOVZXWQ,
    X86_INS_VPMULDQ,
    X86_INS_VPMULHRSW,
    X86_INS_VPMULHUW,
    X86_INS_VPMULHW,
    X86_INS_VPMULLD,
    X86_INS_VPMULLQ,
    X86_INS_VPMULLW,
    X86_INS_VPMULUDQ,
    X86_INS_VPORD,
    X86_INS_VPORQ,
    X86_INS_VPOR,
    X86_INS_VPPERM,
    X86_INS_VPROTB,
    X86_INS_VPROTD,
    X86_INS_VPROTQ,
    X86_INS_VPROTW,
    X86_INS_VPSADBW,
    X86_INS_VPSCATTERDD,
    X86_INS_VPSCATTERDQ,
    X86_INS_VPSCATTERQD,
    X86_INS_VPSCATTERQQ,
    X86_INS_VPSHAB,
    X86_INS_VPSHAD,
    X86_INS_VPSHAQ,
    X86_INS_VPSHAW,
    X86_INS_VPSHLB,
    X86_INS_VPSHLD,
    X86_INS_VPSHLQ,
    X86_INS_VPSHLW,
    X86_INS_VPSHUFB,
    X86_INS_VPSHUFD,
    X86_INS_VPSHUFHW,
    X86_INS_VPSHUFLW,
    X86_INS_VPSIGNB,
    X86_INS_VPSIGND,
    X86_INS_VPSIGNW,
    X86_INS_VPSLLDQ,
    X86_INS_VPSLLD,
    X86_INS_VPSLLQ,
    X86_INS_VPSLLVD,
    X86_INS_VPSLLVQ,
    X86_INS_VPSLLW,
    X86_INS_VPSRAD,
    X86_INS_VPSRAQ,
    X86_INS_VPSRAVD,
    X86_INS_VPSRAVQ,
    X86_INS_VPSRAW,
    X86_INS_VPSRLDQ,
    X86_INS_VPSRLD,
    X86_INS_VPSRLQ,
    X86_INS_VPSRLVD,
    X86_INS_VPSRLVQ,
    X86_INS_VPSRLW,
    X86_INS_VPSUBB,
    X86_INS_VPSUBD,
    X86_INS_VPSUBQ,
    X86_INS_VPSUBSB,
    X86_INS_VPSUBSW,
    X86_INS_VPSUBUSB,
    X86_INS_VPSUBUSW,
    X86_INS_VPSUBW,
    X86_INS_VPTESTMD,
    X86_INS_VPTESTMQ,
    X86_INS_VPTESTNMD,
    X86_INS_VPTESTNMQ,
    X86_INS_VPTEST,
    X86_INS_VPUNPCKHBW,
    X86_INS_VPUNPCKHDQ,
    X86_INS_VPUNPCKHQDQ,
    X86_INS_VPUNPCKHWD,
    X86_INS_VPUNPCKLBW,
    X86_INS_VPUNPCKLDQ,
    X86_INS_VPUNPCKLQDQ,
    X86_INS_VPUNPCKLWD,
    X86_INS_VPXORD,
    X86_INS_VPXORQ,
    X86_INS_VPXOR,
    X86_INS_VRCP14PD,
    X86_INS_VRCP14PS,
    X86_INS_VRCP14SD,
    X86_INS_VRCP14SS,
    X86_INS_VRCP28PD,
    X86_INS_VRCP28PS,
    X86_INS_VRCP28SD,
    X86_INS_VRCP28SS,
    X86_INS_VRCPPS,
    X86_INS_VRCPSS,
    X86_INS_VRNDSCALEPD,
    X86_INS_VRNDSCALEPS,
    X86_INS_VRNDSCALESD,
    X86_INS_VRNDSCALESS,
    X86_INS_VROUNDPD,
    X86_INS_VROUNDPS,
    X86_INS_VROUNDSD,
    X86_INS_VROUNDSS,
    X86_INS_VRSQRT14PD,
    X86_INS_VRSQRT14PS,
    X86_INS_VRSQRT14SD,
    X86_INS_VRSQRT14SS,
    X86_INS_VRSQRT28PD,
    X86_INS_VRSQRT28PS,
    X86_INS_VRSQRT28SD,
    X86_INS_VRSQRT28SS,
    X86_INS_VRSQRTPS,
    X86_INS_VRSQRTSS,
    X86_INS_VSCATTERDPD,
    X86_INS_VSCATTERDPS,
    X86_INS_VSCATTERPF0DPD,
    X86_INS_VSCATTERPF0DPS,
    X86_INS_VSCATTERPF0QPD,
    X86_INS_VSCATTERPF0QPS,
    X86_INS_VSCATTERPF1DPD,
    X86_INS_VSCATTERPF1DPS,
    X86_INS_VSCATTERPF1QPD,
    X86_INS_VSCATTERPF1QPS,
    X86_INS_VSCATTERQPD,
    X86_INS_VSCATTERQPS,
    X86_INS_VSHUFPD,
    X86_INS_VSHUFPS,
    X86_INS_VSQRTPD,
    X86_INS_VSQRTPS,
    X86_INS_VSQRTSD,
    X86_INS_VSQRTSS,
    X86_INS_VSTMXCSR,
    X86_INS_VSUBPD,
    X86_INS_VSUBPS,
    X86_INS_VSUBSD,
    X86_INS_VSUBSS,
    X86_INS_VTESTPD,
    X86_INS_VTESTPS,
    X86_INS_VUNPCKHPD,
    X86_INS_VUNPCKHPS,
    X86_INS_VUNPCKLPD,
    X86_INS_VUNPCKLPS,
    X86_INS_VZEROALL,
    X86_INS_VZEROUPPER,
    X86_INS_WAIT,
    X86_INS_WBINVD,
    X86_INS_WRFSBASE,
    X86_INS_WRGSBASE,
    X86_INS_WRMSR,
    X86_INS_XABORT,
    X86_INS_XACQUIRE,
    X86_INS_XBEGIN,
    X86_INS_XCHG,
    X86_INS_XCRYPTCBC,
    X86_INS_XCRYPTCFB,
    X86_INS_XCRYPTCTR,
    X86_INS_XCRYPTECB,
    X86_INS_XCRYPTOFB,
    X86_INS_XEND,
    X86_INS_XGETBV,
    X86_INS_XLATB,
    X86_INS_XRELEASE,
    X86_INS_XRSTOR,
    X86_INS_XRSTOR64,
    X86_INS_XRSTORS,
    X86_INS_XRSTORS64,
    X86_INS_XSAVE,
    X86_INS_XSAVE64,
    X86_INS_XSAVEC,
    X86_INS_XSAVEC64,
    X86_INS_XSAVEOPT,
    X86_INS_XSAVEOPT64,
    X86_INS_XSAVES,
    X86_INS_XSAVES64,
    X86_INS_XSETBV,
    X86_INS_XSHA1,
    X86_INS_XSHA256,
    X86_INS_XSTORE,
    X86_INS_XTEST,
    X86_INS_FDISI8087_NOP,
    X86_INS_FENI8087_NOP,

    X86_INS_ENDING, // mark the end of the list of insn
} x86_insn;

//> Group of X86 instructions
typedef enum  x86_insn_group
{
    X86_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    X86_GRP_JUMP,   // = CS_GRP_JUMP
    // all call instructions
    X86_GRP_CALL,   // = CS_GRP_CALL
    // all return instructions
    X86_GRP_RET,    // = CS_GRP_RET
    // all interrupt instructions (int+syscall)
    X86_GRP_INT,    // = CS_GRP_INT
    // all interrupt return instructions
    X86_GRP_IRET,   // = CS_GRP_IRET
    // all privileged instructions
    X86_GRP_PRIVILEGE,  // = CS_GRP_PRIVILEGE

    //> Architecture-specific groups
    X86_GRP_VM = 128,   // all virtualization instructions (VT-x + AMD-V)
    X86_GRP_3DNOW,
    X86_GRP_AES,
    X86_GRP_ADX,
    X86_GRP_AVX,
    X86_GRP_AVX2,
    X86_GRP_AVX512,
    X86_GRP_BMI,
    X86_GRP_BMI2,
    X86_GRP_CMOV,
    X86_GRP_F16C,
    X86_GRP_FMA,
    X86_GRP_FMA4,
    X86_GRP_FSGSBASE,
    X86_GRP_HLE,
    X86_GRP_MMX,
    X86_GRP_MODE32,
    X86_GRP_MODE64,
    X86_GRP_RTM,
    X86_GRP_SHA,
    X86_GRP_SSE1,
    X86_GRP_SSE2,
    X86_GRP_SSE3,
    X86_GRP_SSE41,
    X86_GRP_SSE42,
    X86_GRP_SSE4A,
    X86_GRP_SSSE3,
    X86_GRP_PCLMUL,
    X86_GRP_XOP,
    X86_GRP_CDI,
    X86_GRP_ERI,
    X86_GRP_TBM,
    X86_GRP_16BITMODE,
    X86_GRP_NOT64BITMODE,
    X86_GRP_SGX,
    X86_GRP_DQI,
    X86_GRP_BWI,
    X86_GRP_PFI,
    X86_GRP_VLX,
    X86_GRP_SMAP,
    X86_GRP_NOVLX,

    X86_GRP_ENDING
} x86_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/capstone/xcore.h
================================================
#ifndef CAPSTONE_XCORE_H
#define CAPSTONE_XCORE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum xcore_op_type
{
    XCORE_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
    XCORE_OP_REG, // = CS_OP_REG (Register operand).
    XCORE_OP_IMM, // = CS_OP_IMM (Immediate operand).
    XCORE_OP_MEM, // = CS_OP_MEM (Memory operand).
} xcore_op_type;

//> XCore registers
typedef enum xcore_reg
{
    XCORE_REG_INVALID = 0,

    XCORE_REG_CP,
    XCORE_REG_DP,
    XCORE_REG_LR,
    XCORE_REG_SP,
    XCORE_REG_R0,
    XCORE_REG_R1,
    XCORE_REG_R2,
    XCORE_REG_R3,
    XCORE_REG_R4,
    XCORE_REG_R5,
    XCORE_REG_R6,
    XCORE_REG_R7,
    XCORE_REG_R8,
    XCORE_REG_R9,
    XCORE_REG_R10,
    XCORE_REG_R11,

    //> pseudo registers
    XCORE_REG_PC,   // pc

    // internal thread registers
    // see The-XMOS-XS1-Architecture(X7879A).pdf
    XCORE_REG_SCP,  // save pc
    XCORE_REG_SSR,  // save status
    XCORE_REG_ET,   // exception type
    XCORE_REG_ED,   // exception data
    XCORE_REG_SED,  // save exception data
    XCORE_REG_KEP,  // kernel entry pointer
    XCORE_REG_KSP,  // kernel stack pointer
    XCORE_REG_ID,   // thread ID

    XCORE_REG_ENDING,   // <-- mark the end of the list of registers
} xcore_reg;

// Instruction's operand referring to memory
// This is associated with XCORE_OP_MEM operand type above
typedef struct xcore_op_mem
{
    uint8_t base;       // base register, can be safely interpreted as
    // a value of type `xcore_reg`, but it is only
    // one byte wide
    uint8_t index;      // index register, same conditions apply here
    int32_t disp;   // displacement/offset value
    int     direct; // +1: forward, -1: backward
} xcore_op_mem;

// Instruction operand
typedef struct cs_xcore_op
{
    xcore_op_type type; // operand type
    union
    {
        xcore_reg reg;  // register value for REG operand
        int32_t imm;        // immediate value for IMM operand
        xcore_op_mem mem;       // base/disp value for MEM operand
    };
} cs_xcore_op;

// Instruction structure
typedef struct cs_xcore
{
    // Number of operands of this instruction,
    // or 0 when instruction has no operand.
    uint8_t op_count;
    cs_xcore_op operands[8]; // operands for this instruction.
} cs_xcore;

//> XCore instruction
typedef enum xcore_insn
{
    XCORE_INS_INVALID = 0,

    XCORE_INS_ADD,
    XCORE_INS_ANDNOT,
    XCORE_INS_AND,
    XCORE_INS_ASHR,
    XCORE_INS_BAU,
    XCORE_INS_BITREV,
    XCORE_INS_BLA,
    XCORE_INS_BLAT,
    XCORE_INS_BL,
    XCORE_INS_BF,
    XCORE_INS_BT,
    XCORE_INS_BU,
    XCORE_INS_BRU,
    XCORE_INS_BYTEREV,
    XCORE_INS_CHKCT,
    XCORE_INS_CLRE,
    XCORE_INS_CLRPT,
    XCORE_INS_CLRSR,
    XCORE_INS_CLZ,
    XCORE_INS_CRC8,
    XCORE_INS_CRC32,
    XCORE_INS_DCALL,
    XCORE_INS_DENTSP,
    XCORE_INS_DGETREG,
    XCORE_INS_DIVS,
    XCORE_INS_DIVU,
    XCORE_INS_DRESTSP,
    XCORE_INS_DRET,
    XCORE_INS_ECALLF,
    XCORE_INS_ECALLT,
    XCORE_INS_EDU,
    XCORE_INS_EEF,
    XCORE_INS_EET,
    XCORE_INS_EEU,
    XCORE_INS_ENDIN,
    XCORE_INS_ENTSP,
    XCORE_INS_EQ,
    XCORE_INS_EXTDP,
    XCORE_INS_EXTSP,
    XCORE_INS_FREER,
    XCORE_INS_FREET,
    XCORE_INS_GETD,
    XCORE_INS_GET,
    XCORE_INS_GETN,
    XCORE_INS_GETR,
    XCORE_INS_GETSR,
    XCORE_INS_GETST,
    XCORE_INS_GETTS,
    XCORE_INS_INCT,
    XCORE_INS_INIT,
    XCORE_INS_INPW,
    XCORE_INS_INSHR,
    XCORE_INS_INT,
    XCORE_INS_IN,
    XCORE_INS_KCALL,
    XCORE_INS_KENTSP,
    XCORE_INS_KRESTSP,
    XCORE_INS_KRET,
    XCORE_INS_LADD,
    XCORE_INS_LD16S,
    XCORE_INS_LD8U,
    XCORE_INS_LDA16,
    XCORE_INS_LDAP,
    XCORE_INS_LDAW,
    XCORE_INS_LDC,
    XCORE_INS_LDW,
    XCORE_INS_LDIVU,
    XCORE_INS_LMUL,
    XCORE_INS_LSS,
    XCORE_INS_LSUB,
    XCORE_INS_LSU,
    XCORE_INS_MACCS,
    XCORE_INS_MACCU,
    XCORE_INS_MJOIN,
    XCORE_INS_MKMSK,
    XCORE_INS_MSYNC,
    XCORE_INS_MUL,
    XCORE_INS_NEG,
    XCORE_INS_NOT,
    XCORE_INS_OR,
    XCORE_INS_OUTCT,
    XCORE_INS_OUTPW,
    XCORE_INS_OUTSHR,
    XCORE_INS_OUTT,
    XCORE_INS_OUT,
    XCORE_INS_PEEK,
    XCORE_INS_REMS,
    XCORE_INS_REMU,
    XCORE_INS_RETSP,
    XCORE_INS_SETCLK,
    XCORE_INS_SET,
    XCORE_INS_SETC,
    XCORE_INS_SETD,
    XCORE_INS_SETEV,
    XCORE_INS_SETN,
    XCORE_INS_SETPSC,
    XCORE_INS_SETPT,
    XCORE_INS_SETRDY,
    XCORE_INS_SETSR,
    XCORE_INS_SETTW,
    XCORE_INS_SETV,
    XCORE_INS_SEXT,
    XCORE_INS_SHL,
    XCORE_INS_SHR,
    XCORE_INS_SSYNC,
    XCORE_INS_ST16,
    XCORE_INS_ST8,
    XCORE_INS_STW,
    XCORE_INS_SUB,
    XCORE_INS_SYNCR,
    XCORE_INS_TESTCT,
    XCORE_INS_TESTLCL,
    XCORE_INS_TESTWCT,
    XCORE_INS_TSETMR,
    XCORE_INS_START,
    XCORE_INS_WAITEF,
    XCORE_INS_WAITET,
    XCORE_INS_WAITEU,
    XCORE_INS_XOR,
    XCORE_INS_ZEXT,

    XCORE_INS_ENDING,   // <-- mark the end of the list of instructions
} xcore_insn;

//> Group of XCore instructions
typedef enum xcore_insn_group
{
    XCORE_GRP_INVALID = 0, // = CS_GRP_INVALID

    //> Generic groups
    // all jump instructions (conditional+direct+indirect jumps)
    XCORE_GRP_JUMP, // = CS_GRP_JUMP

    XCORE_GRP_ENDING,   // <-- mark the end of the list of groups
} xcore_insn_group;

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/dbghelp/dbghelp.h
================================================
#ifndef _DBGHELP_
#define _DBGHELP_


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif

#pragma pack(push,8)

// For those without specstrings.h
// Since there are different versions of this header, I need to
// individually test each item and define it if it is not around.

#ifndef __in
#define __in
#endif
#ifndef __out
#define __out
#endif
#ifndef __inout
#define __inout
#endif
#ifndef __in_opt
#define __in_opt
#endif
#ifndef __out_opt
#define __out_opt
#endif
#ifndef __inout_opt
#define __inout_opt
#endif
#ifndef __in_ecount
#define __in_ecount(x)
#endif
#ifndef __out_ecount
#define __out_ecount(x)
#endif
#ifndef __inout_ecount
#define __inout_ecount(x)
#endif
#ifndef __in_bcount
#define __in_bcount(x)
#endif
#ifndef __out_bcount
#define __out_bcount(x)
#endif
#ifndef __inout_bcount
#define __inout_bcount(x)
#endif
#ifndef __out_xcount
#define __out_xcount(x)
#endif
#ifndef __deref_opt_out
#define __deref_opt_out
#endif
#ifndef __deref_out
#define __deref_out
#endif
#ifndef __out_ecount_opt
#define __out_ecount_opt(x)
#endif
#ifndef __in_bcount_opt
#define __in_bcount_opt(x)
#endif
#ifndef __out_bcount_opt
#define __out_bcount_opt(x)
#endif
#ifndef __deref_out_opt
#define __deref_out_opt
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DBHLP_DEPRECIATED   __declspec(deprecated)
#else
#define DBHLP_DEPRECIATED
#endif
#endif

#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

// Observant readers may notice that 2 new fields,
// 'fReadOnly' and 'Version' have been added to
// the LOADED_IMAGE structure after 'fDOSImage'.
// This does not change the size of the structure
// from previous headers.  That is because while
// 'fDOSImage' is a byte, it is padded by the
// compiler to 4 bytes.  So the 2 new fields are
// slipped into the extra space.

typedef struct _LOADED_IMAGE
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

#define MAX_SYM_NAME            2000


// Error codes set by dbghelp functions.  Call GetLastError
// to see them.
// Dbghelp also sets error codes found in winerror.h

#define ERROR_IMAGE_NOT_STRIPPED    0x8800  // the image is not stripped.  No dbg file available.
#define ERROR_NO_DBG_POINTER        0x8801  // image is stripped but there is no pointer to a dbg file
#define ERROR_NO_PDB_POINTER        0x8802  // image does not point to a pdb file

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFile(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in PVOID  CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFileW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFile(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath
);

HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR  DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFileExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACK)(
    __in PCSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPath(
    __in HANDLE hprocess,
    __in_opt PCSTR SearchPath,
    __in PCSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACK callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACKW)(
    __in PCWSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPathW(
    __in HANDLE hprocess,
    __in_opt PCWSTR SearchPath,
    __in PCWSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PWSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACKW callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImage(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACK Callback,
    __in PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImageW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImage(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath
);

HANDLE
IMAGEAPI
FindExecutableImageEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImageExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader(
    __in PVOID Base
);

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size,
    __out_opt PIMAGE_SECTION_HEADER* FoundHeader
);

PVOID
IMAGEAPI
ImageDirectoryEntryToData(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size
);

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva
);

PVOID
IMAGEAPI
ImageRvaToVa(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva,
    __in_opt OUT PIMAGE_SECTION_HEADER* LastRvaSection
);

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION
{
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    __in_opt HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PCSTR SymbolPath,
    __in ULONG ImageBase
);

BOOL
IMAGEAPI
UnmapDebugInformation(
    __out_xcount(unknown) PIMAGE_DEBUG_INFORMATION DebugInfo
);

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PSTR OutputPathBuffer
);

BOOL
IMAGEAPI
SearchTreeForFileW(
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PWSTR OutputPathBuffer
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACK)(
    __in PCSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTree(
    __in_opt HANDLE hProcess,
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACK cb,
    __in_opt PVOID data
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACKW)(
    __in PCWSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTreeW(
    __in_opt HANDLE hProcess,
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PWSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACKW cb,
    __in_opt PVOID data
);

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    __in PCSTR DirPath
);

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
//  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    __in PCSTR name,
    __out_ecount(maxStringLength) PSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolNameW(
    __in PCWSTR name,
    __out_ecount(maxStringLength) PWSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1
#define DBHHEADER_CVMISC        0x2
#define DBHHEADER_PDBGUID       0x3
typedef struct _MODLOAD_DATA
{
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

typedef struct _MODLOAD_CVMISC
{
    DWORD   oCV;                    // ofset to the codeview record
    size_t  cCV;                    // size of the codeview record
    DWORD   oMisc;                  // offset to the misc record
    size_t  cMisc;                  // size of the misc record
    DWORD   dtImage;                // datetime stamp of the image
    DWORD   cImage;                 // size of the image
} MODLOAD_CVMISC, *PMODLOAD_CVMISC;

typedef struct _MODLOAD_PDBGUID_PDBAGE
{
    GUID    PdbGuid;                // Pdb Guid
    DWORD   PdbAge;                 // Pdb Age
} MODLOAD_PDBGUID_PDBAGE, *PMODLOAD_PDBGUID_PDBAGE;

//
// StackWalking API
//

typedef enum
{
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64
{
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS
{
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    __in LPADDRESS a32,
    __out LPADDRESS64 a64
)
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    __in LPADDRESS64 a64,
    __out LPADDRESS a32
)
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD64   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD64   StackBase;
    DWORD64   StackLimit;

    DWORD64   Reserved[5];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD   StackBase;
    DWORD   StackLimit;

    DWORD   Reserved[5];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    __in PKDHELP p32,
    __out PKDHELP64 p64
)
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
    p64->KiUserExceptionDispatcher = p32->KiUserExceptionDispatcher;
    p64->StackBase = p32->StackBase;
    p64->StackLimit = p32->StackLimit;
}
#endif

typedef struct _tagSTACKFRAME64
{
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME
{
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 qwBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out LPDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    __in HANDLE ahProcess,
    __in DWORD64 AddrBase
);

typedef
DWORD64
(__stdcall* PGET_MODULE_BASE_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 Address
);

typedef
DWORD64
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE64)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __in LPADDRESS64 lpaddr
);

BOOL
IMAGEAPI
StackWalk64(
    __in DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME64 StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD lpBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out PDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);

typedef
DWORD
(__stdcall* PGET_MODULE_BASE_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD Address
);

typedef
DWORD
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __out LPADDRESS lpaddr
);

BOOL
IMAGEAPI
StackWalk(
    DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE TranslateAddress
);

#endif


#define API_VERSION_NUMBER 11

typedef struct API_VERSION
{
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
);

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    __in LPAPI_VERSION AppVersion
);

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    __in HMODULE Module
);

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64)(
    __in PCSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64W)(
    __in PCWSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt ULONG64 CallbackData,
    __in_opt ULONG64 UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK)(
    __in HANDLE hProcess,
    __in DWORD AddrBase,
    __in_opt PVOID UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG64 AddrBase,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK)(
    __in PCSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACKW)(
    __in PCWSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt PVOID CallbackData,
    __in_opt PVOID UserContext
);

#endif


// values found in SYMBOL_INFO.Tag
//
// This was taken from cvconst.h and should
// not override any values found there.
//
// #define _NO_CVCONST_H_ if you don't
// have access to that file...

#ifdef _NO_CVCONST_H

// DIA enums

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

#endif

//
// flags found in SYMBOL_INFO.Flags
//

#define SYMFLAG_VALUEPRESENT     0x00000001
#define SYMFLAG_REGISTER         0x00000008
#define SYMFLAG_REGREL           0x00000010
#define SYMFLAG_FRAMEREL         0x00000020
#define SYMFLAG_PARAMETER        0x00000040
#define SYMFLAG_LOCAL            0x00000080
#define SYMFLAG_CONSTANT         0x00000100
#define SYMFLAG_EXPORT           0x00000200
#define SYMFLAG_FORWARDER        0x00000400
#define SYMFLAG_FUNCTION         0x00000800
#define SYMFLAG_VIRTUAL          0x00001000
#define SYMFLAG_THUNK            0x00002000
#define SYMFLAG_TLSREL           0x00004000
#define SYMFLAG_SLOT             0x00008000
#define SYMFLAG_ILREL            0x00010000
#define SYMFLAG_METADATA         0x00020000
#define SYMFLAG_CLR_TOKEN        0x00040000

// this resets SymNext/Prev to the beginning
// of the module passed in the address field

#define SYMFLAG_RESET            0x80000000

//
// symbol type enumeration
//
typedef enum
{
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    SymVirtual,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR    Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

typedef struct _IMAGEHLP_SYMBOL64_PACKAGE
{
    IMAGEHLP_SYMBOL64 sym;
    CHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL64_PACKAGE, *PIMAGEHLP_SYMBOL64_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR   Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW64, *PIMAGEHLP_SYMBOLW64;

typedef struct _IMAGEHLP_SYMBOLW64_PACKAGE
{
    IMAGEHLP_SYMBOLW64 sym;
    WCHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW64_PACKAGE, *PIMAGEHLP_SYMBOLW64_PACKAGE;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#define IMAGEHLP_SYMBOL_PACKAGE IMAGEHLP_SYMBOL64_PACKAGE
#define PIMAGEHLP_SYMBOL_PACKAGE PIMAGEHLP_SYMBOL64_PACKAGE
#define IMAGEHLP_SYMBOLW IMAGEHLP_SYMBOLW64
#define PIMAGEHLP_SYMBOLW PIMAGEHLP_SYMBOLW64
#define IMAGEHLP_SYMBOLW_PACKAGE IMAGEHLP_SYMBOLW64_PACKAGE
#define PIMAGEHLP_SYMBOLW_PACKAGE PIMAGEHLP_SYMBOLW64_PACKAGE

#else

typedef struct _IMAGEHLP_SYMBOL
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef struct _IMAGEHLP_SYMBOL_PACKAGE
{
    IMAGEHLP_SYMBOL sym;
    CHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL_PACKAGE, *PIMAGEHLP_SYMBOL_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR                       Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW, *PIMAGEHLP_SYMBOLW;

typedef struct _IMAGEHLP_SYMBOLW_PACKAGE
{
    IMAGEHLP_SYMBOLW sym;
    WCHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW_PACKAGE, *PIMAGEHLP_SYMBOLW_PACKAGE;

#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
    // new elements: 07-Jun-2002
    CHAR     LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    // new elements: 07-Jun-2002
    WCHAR    LoadedImageName[256];   // symbol file name
    WCHAR    LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    WCHAR        CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    WCHAR    LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

typedef struct _IMAGEHLP_LINEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PWSTR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW64, *PIMAGEHLP_LINEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD    Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;

typedef struct _IMAGEHLP_LINEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW, *PIMAGEHLP_LINEW;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE
{
    DWORD64  ModBase;                // base address of loaded module
    PCHAR    FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

typedef struct _SOURCEFILEW
{
    DWORD64  ModBase;                // base address of loaded module
    PWSTR    FileName;               // full filename of source
} SOURCEFILEW, *PSOURCEFILEW;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000
#define CBA_SRCSRV_INFO                         0x20000000
#define CBA_SRCSRV_EVENT                        0x40000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY
{
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD*    bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum
{
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

#define EVENT_SRCSPEW_START 100
#define EVENT_SRCSPEW       100
#define EVENT_SRCSPEW_END   199

typedef struct _IMAGEHLP_CBA_EVENT
{
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_CBA_EVENTW
{
    DWORD  severity;                                     // values from sevInfo to sevFatal
    DWORD  code;                                         // numerical code IDs the error
    PCWSTR desc;                                         // may contain a text description of the error
    PVOID  object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENTW, *PIMAGEHLP_CBA_EVENTW;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;                     //
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOADW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOADW64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    WCHAR    FileName[MAX_PATH + 1]; // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;         //
} IMAGEHLP_DEFERRED_SYMBOL_LOADW64, *PIMAGEHLP_DEFERRED_SYMBOL_LOADW64;

#define DSLFLAG_MISMATCHED_PDB  0x1
#define DSLFLAG_MISMATCHED_DBG  0x2

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64
{
    DWORD              SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD              NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64 Symbol;                 // array of duplicate symbols
    DWORD              SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL
{
    DWORD            SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD            NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL Symbol;                 // array of duplicate symbols
    DWORD            SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
IMAGEAPI
SymSetParentWindow(
    __in HWND hwnd
);

PCHAR
IMAGEAPI
SymSetHomeDirectory(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR dir
);

PWSTR
IMAGEAPI
SymSetHomeDirectoryW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR dir
);

PCHAR
IMAGEAPI
SymGetHomeDirectory(
    __in DWORD type,
    __out_ecount(size) PSTR dir,
    __in size_t size
);

PWSTR
IMAGEAPI
SymGetHomeDirectoryW(
    __in DWORD type,
    __out_ecount(size) PWSTR dir,
    __in size_t size
);

enum
{
    hdBase = 0, // root directory for dbghelp
    hdSym,      // where symbols are stored
    hdSrc,      // where source is stored
    hdMax       // end marker
};

typedef struct _OMAP
{
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

BOOL
IMAGEAPI
SymGetOmaps(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll,
    __out POMAP* OmapTo,
    __out PDWORD64 cOmapTo,
    __out POMAP* OmapFrom,
    __out PDWORD64 cOmapFrom
);

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE          0x00000001
#define SYMOPT_UNDNAME                   0x00000002
#define SYMOPT_DEFERRED_LOADS            0x00000004
#define SYMOPT_NO_CPP                    0x00000008
#define SYMOPT_LOAD_LINES                0x00000010
#define SYMOPT_OMAP_FIND_NEAREST         0x00000020
#define SYMOPT_LOAD_ANYTHING             0x00000040
#define SYMOPT_IGNORE_CVREC              0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS      0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS      0x00000200
#define SYMOPT_EXACT_SYMBOLS             0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS    0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH         0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES     0x00002000
#define SYMOPT_PUBLICS_ONLY              0x00004000
#define SYMOPT_NO_PUBLICS                0x00008000
#define SYMOPT_AUTO_PUBLICS              0x00010000
#define SYMOPT_NO_IMAGE_SEARCH           0x00020000
#define SYMOPT_SECURE                    0x00040000
#define SYMOPT_NO_PROMPTS                0x00080000
#define SYMOPT_OVERWRITE                 0x00100000
#define SYMOPT_IGNORE_IMAGEDIR           0x00200000
#define SYMOPT_FLAT_DIRECTORY            0x00400000
#define SYMOPT_FAVOR_COMPRESSED          0x00800000
#define SYMOPT_ALLOW_ZERO_ADDRESS        0x01000000
#define SYMOPT_DISABLE_SYMSRV_AUTODETECT 0x02000000

#define SYMOPT_DEBUG                     0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    __in DWORD   SymOptions
);

DWORD
IMAGEAPI
SymGetOptions(
    VOID
);

BOOL
IMAGEAPI
SymCleanup(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymMatchString(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringA(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringW(
    __in PCWSTR string,
    __in PCWSTR expression,
    __in BOOL fCase
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACK)(
    __in PSOURCEFILE pSourceFile,
    __in_opt PVOID UserContext
);

// for backwards compatibility - don't use this
#define PSYM_ENUMSOURCFILES_CALLBACK PSYM_ENUMSOURCEFILES_CALLBACK

BOOL
IMAGEAPI
SymEnumSourceFiles(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACKW)(
    __in PSOURCEFILEW pSourceFile,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceFilesW(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModules64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModulesW64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    __in_opt PVOID UserContext
);
#endif

BOOL
IMAGEAPI
EnumerateLoadedModulesEx(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesExW(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesW64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    __in HANDLE hProcess,
    __in DWORD64 AddrBase
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);
#endif

BOOL
IMAGEAPI
SymGetUnwindInfo(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_bcount_opt(*Size) PVOID Buffer,
    __inout PULONG Size
);

BOOL
IMAGEAPI
SymGetModuleInfo64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULE64 ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULEW64 ModuleInfo
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULE ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULEW ModuleInfo
);
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    __in HANDLE hProcess,
    __in DWORD dwAddr
);
#endif

typedef struct _SRCCODEINFO
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    CHAR    Obj[MAX_PATH + 1];      // the object file within the module
    CHAR    FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFO, *PSRCCODEINFO;

typedef struct _SRCCODEINFOW
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    WCHAR   Obj[MAX_PATH + 1];      // the object file within the module
    WCHAR   FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFOW, *PSRCCODEINFOW;

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACK)(
    __in PSRCCODEINFO LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACKW)(
    __in PSRCCODEINFOW LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE64 Line64
);

BOOL
IMAGEAPI
SymGetLineFromAddrW64(
    __in HANDLE hProcess,
    __in DWORD64 dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW64 Line
);

BOOL
IMAGEAPI
SymEnumSourceLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

// flags for SymEnumSourceLines

#define ESLFLAG_FULLPATH        0x1
#define ESLFLAG_NEAREST         0x2
#define ESLFLAG_PREV            0x4
#define ESLFLAG_NEXT            0x8

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#define SymGetLineFromAddrW SymGetLineFromAddrW64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineFromAddrW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineFromNameW64(
    __in HANDLE hProcess,
    __in_opt PCWSTR ModuleName,
    __in_opt PCWSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE Line
);
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLinePrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLinePrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in PCSTR FileName,
    __out_ecount(BufferLines) PDWORD64 Buffer,
    __in ULONG BufferLines
);

BOOL
IMAGEAPI
SymMatchFileName(
    __in PCSTR FileName,
    __in PCSTR Match,
    __deref_opt_out PSTR* FileNameStop,
    __deref_opt_out PSTR* MatchStop
);

BOOL
IMAGEAPI
SymMatchFileNameW(
    __in PCWSTR FileName,
    __in PCWSTR Match,
    __deref_opt_out PWSTR* FileNameStop,
    __deref_opt_out PWSTR* MatchStop
);

BOOL
IMAGEAPI
SymGetSourceFile(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Params,
    __in PCSTR FileSpec,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Params,
    __in PCWSTR FileSpec,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileToken(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileTokenW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __in PCSTR VarName,
    __out_ecount(Size) PSTR Value,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __in PCWSTR VarName,
    __out_ecount(Size) PWSTR Value,
    __in DWORD Size
);

typedef BOOL (CALLBACK* PENUMSOURCEFILETOKENSCALLBACK)(__in PVOID token,  __in size_t size);

BOOL
IMAGEAPI
SymEnumSourceFileTokens(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PENUMSOURCEFILETOKENSCALLBACK Callback
);

BOOL
IMAGEAPI
SymInitialize(
    __in HANDLE hProcess,
    __in_opt PCSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymInitializeW(
    __in HANDLE hProcess,
    __in_opt PCWSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymGetSearchPath(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymGetSearchPathW(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PWSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymSetSearchPath(
    __in HANDLE hProcess,
    __in_opt PCSTR SearchPath
);

BOOL
IMAGEAPI
SymSetSearchPathW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SearchPath
);

#define SLMFLAG_VIRTUAL     0x1
#define SLMFLAG_ALT_INDEX   0x2
#define SLMFLAG_NO_SYMBOLS  0x4

DWORD64
IMAGEAPI
SymLoadModuleEx(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

DWORD64
IMAGEAPI
SymLoadModuleExW(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCWSTR ImageName,
    __in_opt PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

BOOL
IMAGEAPI
SymUnloadModule64(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    __in HANDLE hProcess,
    __in DWORD BaseOfDll
);
#endif

BOOL
IMAGEAPI
SymUnDName64(
    __in PIMAGEHLP_SYMBOL64 sym,            // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    __in PIMAGEHLP_SYMBOL sym,              // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterCallbackW64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC
{
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO   // AKA TYPTYP
{
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef struct _SYMBOL_INFO
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _SYMBOL_INFO_PACKAGE
{
    SYMBOL_INFO si;
    CHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGE, *PSYMBOL_INFO_PACKAGE;

typedef struct _SYMBOL_INFOW
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    WCHAR       Name[1];          // Name of symbol
} SYMBOL_INFOW, *PSYMBOL_INFOW;

typedef struct _SYMBOL_INFO_PACKAGEW
{
    SYMBOL_INFOW si;
    WCHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGEW, *PSYMBOL_INFO_PACKAGEW;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


BOOL
IMAGEAPI
SymSetContext(
    __in HANDLE hProcess,
    __in PIMAGEHLP_STACK_FRAME StackFrame,
    __in_opt PIMAGEHLP_CONTEXT Context
);

BOOL
IMAGEAPI
SymSetScopeFromAddr(
    __in HANDLE hProcess,
    __in ULONG64 Address
);

BOOL
IMAGEAPI
SymSetScopeFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index
);

typedef BOOL
(CALLBACK* PSYM_ENUMPROCESSES_CALLBACK)(
    __in HANDLE hProcess,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumProcesses(
    __in PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymFromAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromToken(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromTokenW(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymNext(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymNextW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

BOOL
IMAGEAPI
SymPrev(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymPrevW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromNameW(
    __in HANDLE hProcess,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACK)(
    __in PSYMBOL_INFO pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbols(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACKW)(
    __in PSYMBOL_INFOW pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

#define SYMSEARCH_MASKOBJS      0x01    // used internally to implement other APIs
#define SYMSEARCH_RECURSE       0X02    // recurse scopes
#define SYMSEARCH_GLOBALSONLY   0X04    // search only for global symbols
#define SYMSEARCH_ALLITEMS      0X08    // search for everything in the pdb, not just normal scoped symbols

BOOL
IMAGEAPI
SymSearch(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymSearchW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCWSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymGetScope(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetScopeW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromIndexW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO
{
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
    TI_GET_UDTKIND,
    TI_IS_EQUIV_TO,
    TI_GET_CALLING_CONVENTION,
    TI_IS_CLOSE_EQUIV_TO,
    TI_GTIEX_REQS_VALID,
    TI_GET_VIRTUALBASEOFFSET,
    TI_GET_VIRTUALBASEDISPINDEX,
    TI_GET_IS_REFERENCE,
    TI_GET_INDIRECTVIRTUALBASECLASS,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS
{
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __in ULONG TypeId,
    __in IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    __out PVOID pInfo
);

#define IMAGEHLP_GET_TYPE_INFO_UNCACHED 0x00000001
#define IMAGEHLP_GET_TYPE_INFO_CHILDREN 0x00000002

typedef struct _IMAGEHLP_GET_TYPE_INFO_PARAMS
{
    IN  ULONG    SizeOfStruct;
    IN  ULONG    Flags;
    IN  ULONG    NumIds;
    IN  PULONG   TypeIds;
    IN  ULONG64  TagFilter;
    IN  ULONG    NumReqs;
    IN  IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
    IN  PULONG_PTR ReqOffsets;
    IN  PULONG   ReqSizes;
    IN  ULONG_PTR ReqStride;
    IN  ULONG_PTR BufferSize;
    OUT PVOID    Buffer;
    OUT ULONG    EntriesMatched;
    OUT ULONG    EntriesFilled;
    OUT ULONG64  TagsFound;
    OUT ULONG64  AllReqsValid;
    IN  ULONG    NumReqsValid;
    OUT PULONG64 ReqsValid OPTIONAL;
} IMAGEHLP_GET_TYPE_INFO_PARAMS, *PIMAGEHLP_GET_TYPE_INFO_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfoEx(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __inout PIMAGEHLP_GET_TYPE_INFO_PARAMS Params
);

BOOL
IMAGEAPI
SymEnumTypes(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetTypeFromName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetTypeFromNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymAddSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymAddSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymRefreshModuleList(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymAddSourceStream(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAM)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamA(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAMA)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR FileSpec,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

BOOL
IMAGEAPI
SymSrvIsStoreW(
    __in_opt HANDLE hProcess,
    __in PCWSTR path
);

BOOL
IMAGEAPI
SymSrvIsStore(
    __in_opt HANDLE hProcess,
    __in PCSTR path
);

PCSTR
IMAGEAPI
SymSrvDeltaName(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Type,
    __in PCSTR File1,
    __in PCSTR File2
);

PCWSTR
IMAGEAPI
SymSrvDeltaNameW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Type,
    __in PCWSTR File1,
    __in PCWSTR File2
);

PCSTR
IMAGEAPI
SymSrvGetSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Node,
    __in PCSTR File
);

PCWSTR
IMAGEAPI
SymSrvGetSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File
);

BOOL
IMAGEAPI
SymSrvGetFileIndexes(
    __in PCSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexesW(
    __in PCWSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexStringW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __out_ecount(Size) PWSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexString(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __out_ecount(Size) PSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

typedef struct
{
    DWORD sizeofstruct;
    char file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    char dbgfile[MAX_PATH + 1];
    char pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFO, *PSYMSRV_INDEX_INFO;

typedef struct
{
    DWORD sizeofstruct;
    WCHAR file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    WCHAR dbgfile[MAX_PATH + 1];
    WCHAR pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFOW, *PSYMSRV_INDEX_INFOW;

BOOL
IMAGEAPI
SymSrvGetFileIndexInfo(
    __in PCSTR File,
    __out PSYMSRV_INDEX_INFO Info,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexInfoW(
    __in PCWSTR File,
    __out PSYMSRV_INDEX_INFOW Info,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR Node,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __in DWORD Flags
);

// used by SymGetSymbolFile's "Type" parameter

enum
{
    sfImage = 0,
    sfDbg,
    sfPdb,
    sfMpd,
    sfMax
};

BOOL
IMAGEAPI
SymGetSymbolFile(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
);

BOOL
IMAGEAPI
SymGetSymbolFileW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PWSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PWSTR DbgFile,
    __in size_t cDbgFile
);

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI* PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    __in DWORD DataType,
    __in PVOID* Data,
    __out LPDWORD DataLength,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDump(
    __in_opt LPCSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    __in_opt LPCWSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out_opt PDWORD64 pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL64  Symbol
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out_opt PDWORD pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif


// Symbol server exports

typedef BOOL (WINAPI* PSYMBOLSERVERPROC)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCA)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROC)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCA)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCW)(PCWSTR, PCWSTR, PCWSTR, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSWPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR(WINAPI* PSYMBOLSERVERGETOPTIONSPROC)();
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROC)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCA)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCW)(PCWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERGETVERSION)(LPAPI_VERSION);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAME)(PCSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAMEW)(PCWSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRING)(PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRINGW)(PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILE)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILEW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTORE)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTOREW)(PCWSTR);
typedef DWORD (WINAPI* PSYMBOLSERVERVERSION)();
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERMESSAGEPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);

#define SYMSRV_VERSION              2

#define SSRVOPT_CALLBACK            0x00000001
#define SSRVOPT_DWORD               0x00000002
#define SSRVOPT_DWORDPTR            0x00000004
#define SSRVOPT_GUIDPTR             0x00000008
#define SSRVOPT_OLDGUIDPTR          0x00000010
#define SSRVOPT_UNATTENDED          0x00000020
#define SSRVOPT_NOCOPY              0x00000040
#define SSRVOPT_GETPATH             0x00000040
#define SSRVOPT_PARENTWIN           0x00000080
#define SSRVOPT_PARAMTYPE           0x00000100
#define SSRVOPT_SECURE              0x00000200
#define SSRVOPT_TRACE               0x00000400
#define SSRVOPT_SETCONTEXT          0x00000800
#define SSRVOPT_PROXY               0x00001000
#define SSRVOPT_DOWNSTREAM_STORE    0x00002000
#define SSRVOPT_OVERWRITE           0x00004000
#define SSRVOPT_RESETTOU            0x00008000
#define SSRVOPT_CALLBACKW           0x00010000
#define SSRVOPT_FLAT_DEFAULT_STORE  0x00020000
#define SSRVOPT_PROXYW              0x00040000
#define SSRVOPT_MESSAGE             0x00080000
#define SSRVOPT_SERVICE             0x00100000   // deprecated
#define SSRVOPT_FAVOR_COMPRESSED    0x00200000
#define SSRVOPT_STRING              0x00400000
#define SSRVOPT_WINHTTP             0x00800000
#define SSRVOPT_WININET             0x01000000

#define SSRVOPT_MAX                 0x0100000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#define SSRVACTION_SIZE         5

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
#define SymInitialize                     SymInitializeW
#define SymAddSymbol                      SymAddSymbolW
#define SymDeleteSymbol                   SymDeleteSymbolW
#define SearchTreeForFile                 SearchTreeForFileW
#define UnDecorateSymbolName              UnDecorateSymbolNameW
#define SymGetLineFromName64              SymGetLineFromNameW64
#define SymGetLineFromAddr64              SymGetLineFromAddrW64
#define SymGetLineNext64                  SymGetLineNextW64
#define SymGetLinePrev64                  SymGetLinePrevW64
#define SymFromName                       SymFromNameW
#define SymFindExecutableImage            SymFindExecutableImageW
#define FindExecutableImageEx             FindExecutableImageExW
#define SymSearch                         SymSearchW
#define SymEnumLines                      SymEnumLinesW
#define SymEnumSourceLines                SymEnumSourceLinesW
#define SymGetTypeFromName                SymGetTypeFromNameW
#define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
#define SymFromAddr                       SymFromAddrW
#define SymMatchString                    SymMatchStringW
#define SymEnumSourceFiles                SymEnumSourceFilesW
#define SymEnumSymbols                    SymEnumSymbolsW
#define SymLoadModuleEx                   SymLoadModuleExW
#define SymSetSearchPath                  SymSetSearchPathW
#define SymGetSearchPath                  SymGetSearchPathW
#define EnumDirTree                       EnumDirTreeW
#define SymFromToken                      SymFromTokenW
#define SymFromIndex                      SymFromIndexW
#define SymGetScope                       SymGetScopeW
#define SymNext                           SymNextW
#define SymPrev                           SymPrevW
#define SymEnumTypes                      SymEnumTypesW
#define SymEnumTypesByName                SymEnumTypesByNameW
#define SymRegisterCallback64             SymRegisterCallbackW64
#define SymFindDebugInfoFile              SymFindDebugInfoFileW
#define FindDebugInfoFileEx               FindDebugInfoFileExW
#define SymFindFileInPath                 SymFindFileInPathW
#define SymEnumerateModules64             SymEnumerateModulesW64
#define SymSetHomeDirectory               SymSetHomeDirectoryW
#define SymGetHomeDirectory               SymGetHomeDirectoryW
#define SymGetSourceFile                  SymGetSourceFileW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
#define SymFindFileInPath                 SymFindFileInPathW
#define SymMatchFileName                  SymMatchFileNameW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetModuleInfo64                SymGetModuleInfoW64
#define SymSrvIsStore                     SymSrvIsStoreW
#define SymSrvDeltaName                   SymSrvDeltaNameW
#define SymSrvGetSupplement               SymSrvGetSupplementW
#define SymSrvStoreSupplement             SymSrvStoreSupplementW
#define SymSrvGetFileIndexes              SymSrvGetFileIndexes
#define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
#define SymSrvStoreFile                   SymSrvStoreFileW
#define SymGetSymbolFile                  SymGetSymbolFileW
#define EnumerateLoadedModules64          EnumerateLoadedModulesW64
#define EnumerateLoadedModulesEx          EnumerateLoadedModulesExW
#define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW

#define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
#define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
#define SYMBOL_INFO                       SYMBOL_INFOW
#define PSYMBOL_INFO                      PSYMBOL_INFOW
#define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
#define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
#define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
#define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
#define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
#define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
#define SRCCODEINFO                       SRCCODEINFOW
#define PSRCCODEINFO                      PSRCCODEINFOW
#define SOURCEFILE                        SOURCEFILEW
#define PSOURCEFILE                       PSOURCEFILEW
#define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
#define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
#define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
#define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
#define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
#define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
#define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
#define SYMSRV_INDEX_INFO                 SYMSRV_INDEX_INFOW
#define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

#define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
#define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
);
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000

#pragma pack(pop)


#pragma pack(push,4)

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR
{
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64
{
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR
{
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64
{
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER
{
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union
    {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY
{
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING
{
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE
{

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,
    TokenStream                 = 19,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005,
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,
    ceStreamProcessModuleMap    = 0x800B,
    ceStreamDiagnosisList       = 0x800C,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
//

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION
{

    //
    // X86 platforms use CPUID function to obtain processor information.
    //

    struct
    {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //

        ULONG32 VendorId [ 3 ];

        //
        // CPUID Subfunction 1, register EAX
        //

        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //

        ULONG32 FeatureInformation;


        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //

        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //

    struct
    {

        ULONG64 ProcessorFeatures [ 2 ];

    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;

typedef struct _MINIDUMP_SYSTEM_INFO
{

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //

    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union
    {
        USHORT Reserved0;
        struct
        {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //

    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //

    RVA CSDVersionRva;

    union
    {
        ULONG32 Reserved1;
        struct
        {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT(sizeof(((PPROCESS_INFORMATION)0)->dwThreadId) == 4);

typedef struct _MINIDUMP_THREAD
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION
{
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM
{
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST
{
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST
{
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST
{
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION
{
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64
{
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE
{
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION
{
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N* PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
{
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID            0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES         0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO  0x00000004
#define MINIDUMP_MISC3_PROCESS_INTEGRITY     0x00000010
#define MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS 0x00000020
#define MINIDUMP_MISC3_TIMEZONE              0x00000040
#define MINIDUMP_MISC3_PROTECTED_PROCESS     0x00000080

typedef struct _MINIDUMP_MISC_INFO
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

typedef struct _MINIDUMP_MISC_INFO_3
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
    ULONG32 ProcessIntegrityLevel;
    ULONG32 ProcessExecuteFlags;
    ULONG32 ProtectedProcess;
    ULONG32 TimeZoneId;
    TIME_ZONE_INFORMATION TimeZone;
} MINIDUMP_MISC_INFO_3, *PMINIDUMP_MISC_INFO_3;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_3 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO
{
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO
{
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;

//
// Support for token information.
//
typedef struct _MINIDUMP_TOKEN_INFO_HEADER
{
    ULONG   TokenSize;   // The size of the token structure.
    ULONG   TokenId;     // The PID in NtOpenProcessToken() call or TID in NtOpenThreadToken() call.
    ULONG64 TokenHandle; // The handle value returned.
} MINIDUMP_TOKEN_INFO_HEADER, *PMINIDUMP_TOKEN_INFO_HEADER;

typedef struct _MINIDUMP_TOKEN_INFO_LIST
{
    ULONG TokenListSize;
    ULONG TokenListEntries;
    ULONG ListHeaderSize;
    ULONG ElementHeaderSize;
} MINIDUMP_TOKEN_INFO_LIST, *PMINIDUMP_TOKEN_INFO_LIST;

//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD
{
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM
{
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION
{
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE
{
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK
{
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS
{
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK
{
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord;
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK
{
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS
{
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK
{
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
*PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT
{
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union
    {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT
{
    union
    {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct
        {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct
        {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct
        {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;


//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE
{
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    MiniDumpWithPrivateWriteCopyMemory     = 0x00010000,
    MiniDumpIgnoreInaccessibleMemory       = 0x00020000,
    MiniDumpWithTokenInformation           = 0x00040000,
    MiniDumpValidTypeFlags                 = 0x0007ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//

typedef enum _MINIDUMP_SECONDARY_FLAGS
{
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI* MINIDUMP_CALLBACK_ROUTINE)(
    __inout PVOID CallbackParam,
    __in    PMINIDUMP_CALLBACK_INPUT CallbackInput,
    __inout PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
);

typedef struct _MINIDUMP_CALLBACK_INFORMATION
{
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    __in HANDLE hProcess,
    __in DWORD ProcessId,
    __in HANDLE hFile,
    __in MINIDUMP_TYPE DumpType,
    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
);

BOOL
WINAPI
MiniDumpReadDumpStream(
    __in PVOID BaseOfDump,
    __in ULONG StreamNumber,
    __deref_out_opt PMINIDUMP_DIRECTORY* Dir,
    __deref_out_opt PVOID* StreamPointer,
    __out_opt ULONG* StreamSize
);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_




================================================
File: x64dbg_pluginsdk/jansson/jansson.h
================================================
/*
 * Copyright (c) 2009-2014 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  7
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.7"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: x64dbg_pluginsdk/jansson/jansson_config.h
================================================
/*
 * Copyright (c) 2010-2014 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint _strtoi64
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1



#endif



================================================
File: x64dbg_pluginsdk/jansson/jansson_x64dbg.h
================================================
typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
#ifdef _WIN64
    sprintf(hexvalue, "0x%llX", value);
#else //x64
    sprintf(hexvalue, "0x%X", value);
#endif //_WIN64
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
#ifdef _WIN64
    sscanf(hexvalue, "0x%llX", &ret);
#else //x64
    sscanf(hexvalue, "0x%X", &ret);
#endif //_WIN64
    return ret;
}


================================================
File: x64dbg_pluginsdk/lz4/lz4.h
================================================
/*
   LZ4 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4_H
#define _LZ4_H

#if defined (__cplusplus)
extern "C"
{
#endif


/**************************************
   Version
**************************************/
#define LZ4_VERSION_MAJOR    1    /* for major interface/format changes  */
#define LZ4_VERSION_MINOR    1    /* for minor interface/format changes  */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */


/**************************************
   Compiler Options
**************************************/
#if (defined(__GNUC__) && defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__cplusplus))   /* Visual Studio */
#  define inline __inline           /* Visual C is not C99, but supports some kind of inline */
#endif


/**************************************
   Simple Functions
**************************************/

__declspec(dllimport) int LZ4_compress(const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_decompress_safe(const char* source, char* dest, int inputSize, int maxOutputSize);

/*
LZ4_compress() :
    Compresses 'inputSize' bytes from 'source' into 'dest'.
    Destination buffer must be already allocated,
    and must be sized to handle worst cases situations (input data not compressible)
    Worst case size evaluation is provided by function LZ4_compressBound()
    inputSize : Max supported value is LZ4_MAX_INPUT_VALUE
    return : the number of bytes written in buffer dest
             or 0 if the compression fails

LZ4_decompress_safe() :
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits (never writes outside of output buffer, and never reads outside of input buffer). Therefore, it is protected against malicious data packets
*/


/**************************************
   Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*
LZ4_compressBound() :
    Provides the maximum size that LZ4 may output in a "worst case" scenario (input data not compressible)
    primarily useful for memory allocation of output buffer.
    inline function is recommended for the general case,
    macro is also provided when result needs to be evaluated at compilation (such as stack memory allocation).

    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE
    return : maximum output size in a "worst case" scenario
             or 0, if input size is too large ( > LZ4_MAX_INPUT_SIZE)
*/
__declspec(dllimport) int LZ4_compressBound(int isize);


/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is LZ4_MAX_INPUT_VALUE
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes written in buffer 'dest'
             or 0 if the compression fails
*/
__declspec(dllimport) int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);


/*
LZ4_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is malformed, the function will stop decoding and return a negative result.
    note : This function is a bit faster than LZ4_decompress_safe()
           This function never writes outside of output buffers, but may read beyond input buffer in case of malicious data packet.
           Use this function preferably into a trusted environment (data to decode comes from a trusted source).
           Destination buffer must be already allocated. Its size must be a minimum of 'outputSize' bytes.
*/
__declspec(dllimport) int LZ4_decompress_fast(const char* source, char* dest, int originalSize);


/*
LZ4_decompress_safe_partial() :
    This function decompress a compressed block of size 'inputSize' at position 'source'
    into output buffer 'dest' of size 'maxOutputSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*/
__declspec(dllimport) int LZ4_decompress_safe_partial(const char* source, char* dest, int inputSize, int targetOutputSize, int maxOutputSize);


/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofState();

Note that tables must be aligned on 4-bytes boundaries, otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withState() and LZ4_compress_limitedOutput_withState() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/
__declspec(dllimport) int LZ4_sizeofState(void);
__declspec(dllimport) int LZ4_compress_withState(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compress_limitedOutput_withState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_create(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compress_continue(void* LZ4_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compress_limitedOutput_continue(void* LZ4_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBuffer(void* LZ4_Data);
__declspec(dllimport) int   LZ4_free(void* LZ4_Data);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4 Data Structure, thanks to the function :

void* LZ4_create (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4 Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compress_continue() or LZ4_compress_limitedOutput_continue().
Their behavior are identical to LZ4_compress() or LZ4_compress_limitedOutput(),
but require the LZ4 Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBuffer(void* LZ4_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compress_continue() or LZ4_compress_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_free() will release the memory used by the LZ4 Data Structure.
*/


__declspec(dllimport) int LZ4_sizeofStreamState(void);
__declspec(dllimport) int LZ4_resetStreamState(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_create (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamState();
Note also that space must be 4-bytes aligned.

Once space is allocated, you must initialize it using : LZ4_resetStreamState(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned on 4-bytes boundaries, and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamState() must be 0 is OK.
Any other value means there was an error (typically, pointer is not aligned on 4-bytes boundaries).
*/


__declspec(dllimport) int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int outputSize);

/*
*_withPrefix64k() :
    These decoding functions work the same as their "normal name" versions,
    but can use up to 64KB of data in front of 'char* dest'.
    These functions are necessary to decode inter-dependant blocks.
*/


/**************************************
   Obsolete Functions
**************************************/
/*
These functions are deprecated and should no longer be used.
They are provided here for compatibility with existing user programs.
*/
__declspec(dllimport) int LZ4_uncompress(const char* source, char* dest, int outputSize);
__declspec(dllimport) int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int isize, int maxOutputSize);


#if defined (__cplusplus)
}
#endif

#endif //_LZ4_H


================================================
File: x64dbg_pluginsdk/lz4/lz4file.h
================================================
#ifndef _LZ4FILE_H
#define _LZ4FILE_H

typedef enum _LZ4_STATUS
{
    LZ4_SUCCESS,
    LZ4_FAILED_OPEN_INPUT,
    LZ4_FAILED_OPEN_OUTPUT,
    LZ4_NOT_ENOUGH_MEMORY,
    LZ4_INVALID_ARCHIVE,
    LZ4_CORRUPTED_ARCHIVE
} LZ4_STATUS;

#if defined (__cplusplus)
extern "C"
{
#endif

__declspec(dllimport) LZ4_STATUS LZ4_compress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_compress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);

#if defined (__cplusplus)
}
#endif

#endif //_LZ4FILE_H


================================================
File: x64dbg_pluginsdk/lz4/lz4hc.h
================================================
/*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4HC_H
#define _LZ4HC_H

#if defined (__cplusplus)
extern "C"
{
#endif


__declspec(dllimport) int LZ4_compressHC(const char* source, char* dest, int inputSize);
/*
LZ4_compressHC :
    return : the number of bytes in compressed buffer dest
             or 0 if compression fails.
    note : destination buffer must be already allocated.
        To avoid any problem, size it to handle worst cases situations (input data not compressible)
        Worst case size evaluation is provided by function LZ4_compressBound() (see "lz4.h")
*/

__declspec(dllimport) int LZ4_compressHC_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);
/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is 1 GB
    maxOutputSize : is maximum allowed size into the destination buffer (which must be already allocated)
    return : the number of output bytes written in buffer 'dest'
             or 0 if compression fails.
*/


__declspec(dllimport) int LZ4_compressHC2(const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);
/*
    Same functions as above, but with programmable 'compressionLevel'.
    Recommended values are between 4 and 9, although any value between 0 and 16 will work.
    'compressionLevel'==0 means use default 'compressionLevel' value.
    Values above 16 behave the same as 16.
    Equivalent variants exist for all other compression functions below.
*/

/* Note :
Decompression functions are provided within LZ4 source code (see "lz4.h") (BSD license)
*/


/**************************************
   Using an external allocation
**************************************/
__declspec(dllimport) int LZ4_sizeofStateHC(void);
__declspec(dllimport) int LZ4_compressHC_withStateHC(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compressHC_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);

__declspec(dllimport) int LZ4_compressHC2_withStateHC(void* state, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofStateHC();

Note that tables must be aligned for pointer (32 or 64 bits), otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withStateHC() and LZ4_compress_limitedOutput_withStateHC() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_createHC(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compressHC_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compressHC_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
__declspec(dllimport) int   LZ4_freeHC(void* LZ4HC_Data);

__declspec(dllimport) int   LZ4_compressHC2_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int   LZ4_compressHC2_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4HC Data Structure, thanks to the function :

void* LZ4_createHC (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4HC Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue().
Their behavior are identical to LZ4_compressHC() or LZ4_compressHC_limitedOutput(),
but require the LZ4HC Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_freeHC() will release the memory used by the LZ4HC Data Structure.
*/

__declspec(dllimport) int LZ4_sizeofStreamStateHC(void);
__declspec(dllimport) int LZ4_resetStreamStateHC(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_createHC (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamStateHC();
Note also that space must be aligned for pointers (32 or 64 bits).

Once space is allocated, you must initialize it using : LZ4_resetStreamStateHC(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned for pointers (32 or 64 bits), and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamStateHC() must be 0 is OK.
Any other value means there was an error (typically, state is not aligned for pointers (32 or 64 bits)).
*/


#if defined (__cplusplus)
}
#endif

#endif //_LZ4HC_H



================================================
File: x64dbg_pluginsdk/yara/yara.h
================================================
/*
Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_YARA_H
#define YR_YARA_H

#include "yara/utils.h"
#include "yara/filemap.h"
#include "yara/compiler.h"
#include "yara/modules.h"
#include "yara/object.h"
#include "yara/libyara.h"
#include "yara/error.h"
#include "yara/stream.h"
#include "yara/hash.h"

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/ahocorasick.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _AHOCORASICK_H
#define _AHOCORASICK_H

#include "limits.h"
#include "atoms.h"
#include "types.h"


#define YR_AC_ROOT_STATE                0
#define YR_AC_NEXT_STATE(t)             (t >> 32)
#define YR_AC_INVALID_TRANSITION(t, c)  (((t) & 0xFFFF) != c)

#define YR_AC_MAKE_TRANSITION(state, code, flags) \
  ((uint64_t)((((uint64_t) state) << 32) | ((flags) << 16) | (code)))

#define YR_AC_USED_FLAG    0x1

#define YR_AC_USED_TRANSITION_SLOT(x)   ((x) & (YR_AC_USED_FLAG << 16))
#define YR_AC_UNUSED_TRANSITION_SLOT(x) (!YR_AC_USED_TRANSITION_SLOT(x))


typedef struct _YR_AC_TABLES
{
    YR_AC_TRANSITION* transitions;
    YR_AC_MATCH_TABLE_ENTRY* matches;

} YR_AC_TABLES;


int yr_ac_automaton_create(
    YR_AC_AUTOMATON** automaton);


int yr_ac_automaton_destroy(
    YR_AC_AUTOMATON* automaton);


int yr_ac_add_string(
    YR_AC_AUTOMATON* automaton,
    YR_STRING* string,
    YR_ATOM_LIST_ITEM* atom,
    YR_ARENA* matches_arena);


int yr_ac_compile(
    YR_AC_AUTOMATON* automaton,
    YR_ARENA* arena,
    YR_AC_TABLES* tables);


void yr_ac_print_automaton(
    YR_AC_AUTOMATON* automaton);


#endif



================================================
File: x64dbg_pluginsdk/yara/yara/arena.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ARENA_H
#define YR_ARENA_H

#include <stddef.h>

#include "integers.h"
#include "stream.h"

#define ARENA_FLAGS_FIXED_SIZE   1
#define ARENA_FLAGS_COALESCED    2
#define ARENA_FILE_VERSION       11

#define EOL ((size_t) -1)


typedef struct _YR_RELOC
{
    uint32_t offset;
    struct _YR_RELOC* next;

} YR_RELOC;


typedef struct _YR_ARENA_PAGE
{

    uint8_t* new_address;
    uint8_t* address;

    size_t size;
    size_t used;

    YR_RELOC* reloc_list_head;
    YR_RELOC* reloc_list_tail;

    struct _YR_ARENA_PAGE* next;
    struct _YR_ARENA_PAGE* prev;

} YR_ARENA_PAGE;


typedef struct _YR_ARENA
{
    int flags;

    YR_ARENA_PAGE* page_list_head;
    YR_ARENA_PAGE* current_page;

} YR_ARENA;


int yr_arena_create(
    size_t initial_size,
    int flags,
    YR_ARENA** arena);


void yr_arena_destroy(
    YR_ARENA* arena);


void* yr_arena_base_address(
    YR_ARENA* arena);


void* yr_arena_next_address(
    YR_ARENA* arena,
    void* address,
    size_t offset);


int yr_arena_coalesce(
    YR_ARENA* arena);


int yr_arena_reserve_memory(
    YR_ARENA* arena,
    size_t size);


int yr_arena_allocate_memory(
    YR_ARENA* arena,
    size_t size,
    void** allocated_memory);


int yr_arena_allocate_struct(
    YR_ARENA* arena,
    size_t size,
    void** allocated_memory,
    ...);


int yr_arena_make_relocatable(
    YR_ARENA* arena,
    void* base,
    ...);


int yr_arena_write_data(
    YR_ARENA* arena,
    void* data,
    size_t size,
    void** written_data);


int yr_arena_write_string(
    YR_ARENA* arena,
    const char* string,
    char** written_string);


int yr_arena_append(
    YR_ARENA* target_arena,
    YR_ARENA* source_arena);


int yr_arena_load_stream(
    YR_STREAM* stream,
    YR_ARENA** arena);


int yr_arena_save_stream(
    YR_ARENA* arena,
    YR_STREAM* stream);


int yr_arena_duplicate(
    YR_ARENA* arena,
    YR_ARENA** duplicated);


void yr_arena_print(
    YR_ARENA* arena);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/atoms.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ATOMS_H
#define YR_ATOMS_H

#include "limits.h"
#include "re.h"

#define ATOM_TREE_LEAF  1
#define ATOM_TREE_AND   2
#define ATOM_TREE_OR    3


typedef struct _ATOM_TREE_NODE
{
    uint8_t type;
    uint8_t atom_length;
    uint8_t atom[MAX_ATOM_LENGTH];

    uint8_t* forward_code;
    uint8_t* backward_code;

    RE_NODE* recent_nodes[MAX_ATOM_LENGTH];

    struct _ATOM_TREE_NODE* children_head;
    struct _ATOM_TREE_NODE* children_tail;
    struct _ATOM_TREE_NODE* next_sibling;

} ATOM_TREE_NODE;


typedef struct _ATOM_TREE
{
    ATOM_TREE_NODE* current_leaf;
    ATOM_TREE_NODE* root_node;

} ATOM_TREE;


typedef struct _YR_ATOM_LIST_ITEM
{
    uint8_t atom_length;
    uint8_t atom[MAX_ATOM_LENGTH];

    uint16_t backtrack;

    uint8_t* forward_code;
    uint8_t* backward_code;

    struct _YR_ATOM_LIST_ITEM* next;

} YR_ATOM_LIST_ITEM;


int yr_atoms_extract_from_re(
    RE* re,
    int flags,
    YR_ATOM_LIST_ITEM** atoms);


int yr_atoms_extract_from_string(
    uint8_t* string,
    int string_length,
    int flags,
    YR_ATOM_LIST_ITEM** atoms);


int yr_atoms_min_quality(
    YR_ATOM_LIST_ITEM* atom_list);


void yr_atoms_list_destroy(
    YR_ATOM_LIST_ITEM* list_head);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/compiler.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_COMPILER_H
#define YR_COMPILER_H

#include <stdio.h>
#include <setjmp.h>

#include "ahocorasick.h"
#include "arena.h"
#include "hash.h"
#include "utils.h"


#define YARA_ERROR_LEVEL_ERROR   0
#define YARA_ERROR_LEVEL_WARNING 1


typedef void (*YR_COMPILER_CALLBACK_FUNC)(
    int error_level,
    const char* file_name,
    int line_number,
    const char* message,
    void* user_data);


typedef struct _YR_FIXUP
{
    int64_t* address;
    struct _YR_FIXUP* next;

} YR_FIXUP;


typedef struct _YR_COMPILER
{
    int               errors;
    int               error_line;
    int               last_error;
    int               last_error_line;
    int               last_result;

    jmp_buf           error_recovery;

    YR_ARENA*         sz_arena;
    YR_ARENA*         rules_arena;
    YR_ARENA*         strings_arena;
    YR_ARENA*         code_arena;
    YR_ARENA*         re_code_arena;
    YR_ARENA*         compiled_rules_arena;
    YR_ARENA*         externals_arena;
    YR_ARENA*         namespaces_arena;
    YR_ARENA*         metas_arena;
    YR_ARENA*         matches_arena;
    YR_ARENA*         automaton_arena;

    YR_AC_AUTOMATON*  automaton;
    YR_HASH_TABLE*    rules_table;
    YR_HASH_TABLE*    objects_table;
    YR_HASH_TABLE*    strings_table;
    YR_NAMESPACE*     current_namespace;
    YR_RULE*          current_rule;

    YR_FIXUP*         fixup_stack_head;

    int               namespaces_count;

    uint8_t*          loop_address[MAX_LOOP_NESTING];
    char*             loop_identifier[MAX_LOOP_NESTING];
    int               loop_depth;
    int               loop_for_of_mem_offset;

    int               allow_includes;

    char*             file_name_stack[MAX_INCLUDE_DEPTH];
    int               file_name_stack_ptr;

    FILE*             file_stack[MAX_INCLUDE_DEPTH];
    int               file_stack_ptr;

    char              last_error_extra_info[MAX_COMPILER_ERROR_EXTRA_INFO];

    char              lex_buf[LEX_BUF_SIZE];
    char*             lex_buf_ptr;
    unsigned short    lex_buf_len;

    char              include_base_dir[MAX_PATH];
    void*             user_data;

    YR_COMPILER_CALLBACK_FUNC  callback;

} YR_COMPILER;


#define yr_compiler_set_error_extra_info(compiler, info) \
    strlcpy( \
        compiler->last_error_extra_info, \
        info, \
        sizeof(compiler->last_error_extra_info)); \
 

#define yr_compiler_set_error_extra_info_fmt(compiler, fmt, ...) \
    snprintf( \
        compiler->last_error_extra_info, \
        sizeof(compiler->last_error_extra_info), \
        fmt, __VA_ARGS__);


int _yr_compiler_push_file(
    YR_COMPILER* compiler,
    FILE* fh);


FILE* _yr_compiler_pop_file(
    YR_COMPILER* compiler);


int _yr_compiler_push_file_name(
    YR_COMPILER* compiler,
    const char* file_name);


void _yr_compiler_pop_file_name(
    YR_COMPILER* compiler);


YR_API int yr_compiler_create(
    YR_COMPILER** compiler);


YR_API void yr_compiler_destroy(
    YR_COMPILER* compiler);


YR_API void yr_compiler_set_callback(
    YR_COMPILER* compiler,
    YR_COMPILER_CALLBACK_FUNC callback,
    void* user_data);


YR_API int yr_compiler_add_file(
    YR_COMPILER* compiler,
    FILE* rules_file,
    const char* namespace_,
    const char* file_name);


YR_API int yr_compiler_add_string(
    YR_COMPILER* compiler,
    const char* rules_string,
    const char* namespace_);


YR_API char* yr_compiler_get_error_message(
    YR_COMPILER* compiler,
    char* buffer,
    int buffer_size);


YR_API char* yr_compiler_get_current_file_name(
    YR_COMPILER* context);


YR_API int yr_compiler_define_integer_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    int64_t value);


YR_API int yr_compiler_define_boolean_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    int value);


YR_API int yr_compiler_define_float_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    double value);


YR_API int yr_compiler_define_string_variable(
    YR_COMPILER* compiler,
    const char* identifier,
    const char* value);


YR_API int yr_compiler_get_rules(
    YR_COMPILER* compiler,
    YR_RULES** rules);


#endif



================================================
File: x64dbg_pluginsdk/yara/yara/elf.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _ELF_H
#define _ELF_H

#include "integers.h"


// 32-bit ELF base types

typedef uint32_t elf32_addr_t;
typedef uint16_t elf32_half_t;
typedef uint32_t elf32_off_t;
typedef uint32_t elf32_word_t;

// 64-bit ELF base types

typedef uint64_t elf64_addr_t;
typedef uint16_t elf64_half_t;
typedef uint64_t elf64_off_t;
typedef uint32_t elf64_word_t;
typedef uint64_t elf64_xword_t;

#define ELF_MAGIC       0x464C457F

#define ELF_ET_NONE     0x0000  // no type
#define ELF_ET_REL      0x0001  // relocatable
#define ELF_ET_EXEC     0x0002  // executeable
#define ELF_ET_DYN      0x0003  // Shared-Object-File
#define ELF_ET_CORE     0x0004  // Corefile
#define ELF_ET_LOPROC   0xFF00  // Processor-specific
#define ELF_ET_HIPROC   0x00FF  // Processor-specific

#define ELF_EM_NONE         0x0000  // no type
#define ELF_EM_M32          0x0001  // AT&T WE 32100
#define ELF_EM_SPARC        0x0002  // SPARC
#define ELF_EM_386          0x0003  // Intel 80386
#define ELF_EM_68K          0x0004  // Motorola 68000
#define ELF_EM_88K          0x0005  // Motorola 88000
#define ELF_EM_860          0x0007  // Intel 80860
#define ELF_EM_MIPS         0x0008  // MIPS I Architecture
#define ELF_EM_MIPS_RS3_LE  0x000A  // MIPS RS3000 Little-endian
#define ELF_EM_PPC          0x0014  // PowerPC
#define ELF_EM_PPC64        0x0015  // 64-bit PowerPC
#define ELF_EM_ARM          0x0028  // ARM
#define ELF_EM_X86_64       0x003E  // AMD/Intel x86_64
#define ELF_EM_AARCH64      0x00B7  // 64-bit ARM

#define ELF_CLASS_NONE  0x0000
#define ELF_CLASS_32    0x0001  // 32bit file
#define ELF_CLASS_64    0x0002  // 64bit file

#define ELF_DATA_NONE   0x0000
#define ELF_DATA_2LSB   0x0001
#define ELF_DATA_2MSB   0x002


#define ELF_SHT_NULL         0     // Section header table entry unused
#define ELF_SHT_PROGBITS     1     // Program data
#define ELF_SHT_SYMTAB       2     // Symbol table
#define ELF_SHT_STRTAB       3     // String table
#define ELF_SHT_RELA         4     // Relocation entries with addends
#define ELF_SHT_HASH         5     // Symbol hash table
#define ELF_SHT_DYNAMIC      6     // Dynamic linking information
#define ELF_SHT_NOTE         7     // Notes
#define ELF_SHT_NOBITS       8     // Program space with no data (bss)
#define ELF_SHT_REL          9     // Relocation entries, no addends
#define ELF_SHT_SHLIB        10    // Reserved
#define ELF_SHT_DYNSYM       11    // Dynamic linker symbol table
#define ELF_SHT_NUM          12    // Number of defined types

#define ELF_SHF_WRITE        0x1   // Section is writable
#define ELF_SHF_ALLOC        0x2   // Section is present during execution
#define ELF_SHF_EXECINSTR    0x4   // Section contains executable instructions

#define ELF_SHN_LORESERVE    0xFF00

#define ELF_PT_NULL          0     // The array element is unused
#define ELF_PT_LOAD          1     // Loadable segment
#define ELF_PT_DYNAMIC       2     // Segment contains dynamic linking info
#define ELF_PT_INTERP        3     // Contains interpreter pathname
#define ELF_PT_NOTE          4     // Location & size of auxiliary info
#define ELF_PT_SHLIB         5     // Reserved, unspecified semantics
#define ELF_PT_PHDR          6     // Location and size of program header table
#define ELF_PT_TLS           7     // Thread-Local Storage
#define ELF_PT_GNU_EH_FRAME  0x6474e550
#define ELF_PT_GNU_STACK     0x6474e551

#define ELF_PF_X             0x1   // Segment is executable
#define ELF_PF_W             0x2   // Segment is writable
#define ELF_PF_R             0x4   // Segment is readable

#define ELF_PN_XNUM          0xffff

#pragma pack(push,1)

typedef struct
{
    uint32_t magic;
    uint8_t _class;
    uint8_t data;
    uint8_t version;
    uint8_t pad[8];
    uint8_t nident;

} elf_ident_t;


typedef struct
{
    elf_ident_t     ident;
    elf32_half_t    type;
    elf32_half_t    machine;
    elf32_word_t    version;
    elf32_addr_t    entry;
    elf32_off_t     ph_offset;
    elf32_off_t     sh_offset;
    elf32_word_t    flags;
    elf32_half_t    header_size;
    elf32_half_t    ph_entry_size;
    elf32_half_t    ph_entry_count;
    elf32_half_t    sh_entry_size;
    elf32_half_t    sh_entry_count;
    elf32_half_t    sh_str_table_index;

} elf32_header_t;


typedef struct
{
    elf_ident_t     ident;
    elf64_half_t    type;
    elf64_half_t    machine;
    elf64_word_t    version;
    elf64_addr_t    entry;
    elf64_off_t     ph_offset;
    elf64_off_t     sh_offset;
    elf64_word_t    flags;
    elf64_half_t    header_size;
    elf64_half_t    ph_entry_size;
    elf64_half_t    ph_entry_count;
    elf64_half_t    sh_entry_size;
    elf64_half_t    sh_entry_count;
    elf64_half_t    sh_str_table_index;

} elf64_header_t;


typedef struct
{
    elf32_word_t    type;
    elf32_off_t     offset;
    elf32_addr_t    virt_addr;
    elf32_addr_t    phys_addr;
    elf32_word_t    file_size;
    elf32_word_t    mem_size;
    elf32_word_t    flags;
    elf32_word_t    alignment;

} elf32_program_header_t;


typedef struct
{
    elf64_word_t    type;
    elf64_word_t    flags;
    elf64_off_t     offset;
    elf64_addr_t    virt_addr;
    elf64_addr_t    phys_addr;
    elf64_xword_t   file_size;
    elf64_xword_t   mem_size;
    elf64_xword_t   alignment;

} elf64_program_header_t;


typedef struct
{
    elf32_word_t    name;
    elf32_word_t    type;
    elf32_word_t    flags;
    elf32_addr_t    addr;
    elf32_off_t     offset;
    elf32_word_t    size;
    elf32_word_t    link;
    elf32_word_t    info;
    elf32_word_t    align;
    elf32_word_t    entry_size;

} elf32_section_header_t;


typedef struct
{
    elf64_word_t    name;
    elf64_word_t    type;
    elf64_xword_t   flags;
    elf64_addr_t    addr;
    elf64_off_t     offset;
    elf64_xword_t   size;
    elf64_word_t    link;
    elf64_word_t    info;
    elf64_xword_t   align;
    elf64_xword_t   entry_size;

} elf64_section_header_t;


#pragma pack(pop)

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/error.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_ERROR_H
#define YR_ERROR_H

#include <string.h>

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#endif

#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS                           0
#endif

#define ERROR_INSUFICIENT_MEMORY                1
#define ERROR_COULD_NOT_ATTACH_TO_PROCESS       2
#define ERROR_COULD_NOT_OPEN_FILE               3
#define ERROR_COULD_NOT_MAP_FILE                4
#define ERROR_INVALID_FILE                      6
#define ERROR_CORRUPT_FILE                      7
#define ERROR_UNSUPPORTED_FILE_VERSION          8
#define ERROR_INVALID_REGULAR_EXPRESSION        9
#define ERROR_INVALID_HEX_STRING                10
#define ERROR_SYNTAX_ERROR                      11
#define ERROR_LOOP_NESTING_LIMIT_EXCEEDED       12
#define ERROR_DUPLICATED_LOOP_IDENTIFIER        13
#define ERROR_DUPLICATED_IDENTIFIER             14
#define ERROR_DUPLICATED_TAG_IDENTIFIER         15
#define ERROR_DUPLICATED_META_IDENTIFIER        16
#define ERROR_DUPLICATED_STRING_IDENTIFIER      17
#define ERROR_UNREFERENCED_STRING               18
#define ERROR_UNDEFINED_STRING                  19
#define ERROR_UNDEFINED_IDENTIFIER              20
#define ERROR_MISPLACED_ANONYMOUS_STRING        21
#define ERROR_INCLUDES_CIRCULAR_REFERENCE       22
#define ERROR_INCLUDE_DEPTH_EXCEEDED            23
#define ERROR_WRONG_TYPE                        24
#define ERROR_EXEC_STACK_OVERFLOW               25
#define ERROR_SCAN_TIMEOUT                      26
#define ERROR_TOO_MANY_SCAN_THREADS             27
#define ERROR_CALLBACK_ERROR                    28
#define ERROR_INVALID_ARGUMENT                  29
#define ERROR_TOO_MANY_MATCHES                  30
#define ERROR_INTERNAL_FATAL_ERROR              31
#define ERROR_NESTED_FOR_OF_LOOP                32
#define ERROR_INVALID_FIELD_NAME                33
#define ERROR_UNKNOWN_MODULE                    34
#define ERROR_NOT_A_STRUCTURE                   35
#define ERROR_NOT_INDEXABLE                     36
#define ERROR_NOT_A_FUNCTION                    37
#define ERROR_INVALID_FORMAT                    38
#define ERROR_TOO_MANY_ARGUMENTS                39
#define ERROR_WRONG_ARGUMENTS                   40
#define ERROR_WRONG_RETURN_TYPE                 41
#define ERROR_DUPLICATED_STRUCTURE_MEMBER       42
#define ERROR_EMPTY_STRING                      43
#define ERROR_DIVISION_BY_ZERO                  44
#define ERROR_REGULAR_EXPRESSION_TOO_LARGE      45
#define ERROR_TOO_MANY_RE_FIBERS                46
#define ERROR_COULD_NOT_READ_PROCESS_MEMORY     47
#define ERROR_INVALID_EXTERNAL_VARIABLE_TYPE    48


#define FAIL_ON_ERROR(x) { \
  int result = (x); \
  if (result != ERROR_SUCCESS) \
    return result; \
}

#define FAIL_ON_ERROR_WITH_CLEANUP(x, cleanup) { \
  int result = (x); \
  if (result != ERROR_SUCCESS) { \
    cleanup; \
    return result; \
  } \
}

#define FAIL_ON_COMPILER_ERROR(x) { \
  compiler->last_result = (x); \
  if (compiler->last_result != ERROR_SUCCESS) \
    return compiler->last_result; \
}


#ifdef NDEBUG
#define assertf(expr, msg, ...)  ((void)0)
#else
#define assertf(expr, msg, ...) \
    if(!(expr)) { \
      fprintf(stderr, "%s:%d: " msg "\n", __FILE__, __LINE__, ##__VA_ARGS__); \
      abort(); \
    }
#endif

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/exec.h
================================================
/*
Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_EXEC_H
#define YR_EXEC_H

#include "hash.h"
#include "scan.h"
#include "types.h"
#include "rules.h"


#define UNDEFINED           0xFFFABADAFABADAFFLL
#define IS_UNDEFINED(x)     ((size_t)(x) == (size_t) UNDEFINED)

#define OP_ERROR          0
#define OP_HALT           255

#define OP_AND            1
#define OP_OR             2
#define OP_NOT            3
#define OP_BITWISE_NOT    4
#define OP_BITWISE_AND    5
#define OP_BITWISE_OR     6
#define OP_BITWISE_XOR    7
#define OP_SHL            8
#define OP_SHR            9
#define OP_MOD            10
#define OP_INT_TO_DBL     11
#define OP_STR_TO_BOOL    12
#define OP_PUSH           13
#define OP_POP            14
#define OP_CALL           15
#define OP_OBJ_LOAD       16
#define OP_OBJ_VALUE      17
#define OP_OBJ_FIELD      18
#define OP_INDEX_ARRAY    19
#define OP_COUNT          20
#define OP_LENGTH         21
#define OP_FOUND          22
#define OP_FOUND_AT       23
#define OP_FOUND_IN       24
#define OP_OFFSET         25
#define OP_OF             26
#define OP_PUSH_RULE      27
#define OP_INIT_RULE      28
#define OP_MATCH_RULE     29
#define OP_INCR_M         30
#define OP_CLEAR_M        31
#define OP_ADD_M          32
#define OP_POP_M          33
#define OP_PUSH_M         34
#define OP_SWAPUNDEF      35
#define OP_JNUNDEF        36
#define OP_JLE            37
#define OP_FILESIZE       38
#define OP_ENTRYPOINT     39
#define OP_CONTAINS       40
#define OP_MATCHES        41
#define OP_IMPORT         42
#define OP_LOOKUP_DICT    43
#define OP_JFALSE         44
#define OP_JTRUE          45


#define _OP_EQ            0
#define _OP_NEQ           1
#define _OP_LT            2
#define _OP_GT            3
#define _OP_LE            4
#define _OP_GE            5
#define _OP_ADD           6
#define _OP_SUB           7
#define _OP_MUL           8
#define _OP_DIV           9
#define _OP_MINUS         10


#define OP_INT_BEGIN      100
#define OP_INT_EQ         (OP_INT_BEGIN + _OP_EQ)
#define OP_INT_NEQ        (OP_INT_BEGIN + _OP_NEQ)
#define OP_INT_LT         (OP_INT_BEGIN + _OP_LT)
#define OP_INT_GT         (OP_INT_BEGIN + _OP_GT)
#define OP_INT_LE         (OP_INT_BEGIN + _OP_LE)
#define OP_INT_GE         (OP_INT_BEGIN + _OP_GE)
#define OP_INT_ADD        (OP_INT_BEGIN + _OP_ADD)
#define OP_INT_SUB        (OP_INT_BEGIN + _OP_SUB)
#define OP_INT_MUL        (OP_INT_BEGIN + _OP_MUL)
#define OP_INT_DIV        (OP_INT_BEGIN + _OP_DIV)
#define OP_INT_MINUS      (OP_INT_BEGIN + _OP_MINUS)
#define OP_INT_END        OP_INT_MINUS

#define OP_DBL_BEGIN      120
#define OP_DBL_EQ         (OP_DBL_BEGIN + _OP_EQ)
#define OP_DBL_NEQ        (OP_DBL_BEGIN + _OP_NEQ)
#define OP_DBL_LT         (OP_DBL_BEGIN + _OP_LT)
#define OP_DBL_GT         (OP_DBL_BEGIN + _OP_GT)
#define OP_DBL_LE         (OP_DBL_BEGIN + _OP_LE)
#define OP_DBL_GE         (OP_DBL_BEGIN + _OP_GE)
#define OP_DBL_ADD        (OP_DBL_BEGIN + _OP_ADD)
#define OP_DBL_SUB        (OP_DBL_BEGIN + _OP_SUB)
#define OP_DBL_MUL        (OP_DBL_BEGIN + _OP_MUL)
#define OP_DBL_DIV        (OP_DBL_BEGIN + _OP_DIV)
#define OP_DBL_MINUS      (OP_DBL_BEGIN + _OP_MINUS)
#define OP_DBL_END        OP_DBL_MINUS

#define OP_STR_BEGIN      140
#define OP_STR_EQ         (OP_STR_BEGIN + _OP_EQ)
#define OP_STR_NEQ        (OP_STR_BEGIN + _OP_NEQ)
#define OP_STR_LT         (OP_STR_BEGIN + _OP_LT)
#define OP_STR_GT         (OP_STR_BEGIN + _OP_GT)
#define OP_STR_LE         (OP_STR_BEGIN + _OP_LE)
#define OP_STR_GE         (OP_STR_BEGIN + _OP_GE)
#define OP_STR_END        OP_STR_GE

#define IS_INT_OP(x)      ((x) >= OP_INT_BEGIN && (x) <= OP_INT_END)
#define IS_DBL_OP(x)      ((x) >= OP_DBL_BEGIN && (x) <= OP_DBL_END)
#define IS_STR_OP(x)      ((x) >= OP_STR_BEGIN && (x) <= OP_STR_END)

#define OP_READ_INT       240
#define OP_INT8           (OP_READ_INT + 0)
#define OP_INT16          (OP_READ_INT + 1)
#define OP_INT32          (OP_READ_INT + 2)
#define OP_UINT8          (OP_READ_INT + 3)
#define OP_UINT16         (OP_READ_INT + 4)
#define OP_UINT32         (OP_READ_INT + 5)
#define OP_INT8BE         (OP_READ_INT + 6)
#define OP_INT16BE        (OP_READ_INT + 7)
#define OP_INT32BE        (OP_READ_INT + 8)
#define OP_UINT8BE        (OP_READ_INT + 9)
#define OP_UINT16BE       (OP_READ_INT + 10)
#define OP_UINT32BE       (OP_READ_INT + 11)


#define OPERATION(operator, op1, op2) \
    (IS_UNDEFINED(op1) || IS_UNDEFINED(op2)) ? (UNDEFINED) : (op1 operator op2)


#define COMPARISON(operator, op1, op2) \
    (IS_UNDEFINED(op1) || IS_UNDEFINED(op2)) ? (0) : (op1 operator op2)


int yr_execute_code(
    YR_RULES* rules,
    YR_SCAN_CONTEXT* context,
    int timeout,
    time_t start_time);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/exefiles.h
================================================
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_EXEFILES_H
#define YR_EXEFILES_H

uint64_t yr_get_entry_point_offset(
    uint8_t* buffer,
    size_t buffer_length);


uint64_t yr_get_entry_point_address(
    uint8_t* buffer,
    size_t buffer_length,
    size_t base_address);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/filemap.h
================================================
/*
Copyright (c) 2007-2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_FILEMAP_H
#define YR_FILEMAP_H

#ifdef _MSC_VER
#define off_t              int64_t
#else
#include <sys/types.h>
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#define YR_FILE_DESCRIPTOR    HANDLE
#else
#define YR_FILE_DESCRIPTOR    int
#endif

#include <stdlib.h>

#include "integers.h"
#include "utils.h"


typedef struct _YR_MAPPED_FILE
{
    YR_FILE_DESCRIPTOR  file;
    size_t              size;
    uint8_t*            data;
#if defined(_WIN32) || defined(__CYGWIN__)
    HANDLE              mapping;
#endif

} YR_MAPPED_FILE;


YR_API int yr_filemap_map(
    const char* file_path,
    YR_MAPPED_FILE* pmapped_file);


YR_API int yr_filemap_map_fd(
    YR_FILE_DESCRIPTOR file,
    off_t offset,
    size_t size,
    YR_MAPPED_FILE* pmapped_file);


YR_API int yr_filemap_map_ex(
    const char* file_path,
    off_t offset,
    size_t size,
    YR_MAPPED_FILE* pmapped_file);


YR_API void yr_filemap_unmap(
    YR_MAPPED_FILE* pmapped_file);


YR_API void yr_filemap_unmap_fd(
    YR_MAPPED_FILE* pmapped_file);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/globals.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_GLOBALS_H
#define YR_GLOBALS_H

extern char lowercase[256];
extern char altercase[256];

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/hash.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_HASH_H
#define YR_HASH_H

#include <stddef.h>

#include "utils.h"

typedef struct _YR_HASH_TABLE_ENTRY
{
    void* key;
    size_t key_length;
    char* ns;
    void* value;

    struct _YR_HASH_TABLE_ENTRY* next;

} YR_HASH_TABLE_ENTRY;


typedef struct _YR_HASH_TABLE
{
    int size;

    YR_HASH_TABLE_ENTRY* buckets[1];

} YR_HASH_TABLE;


typedef int (*YR_HASH_TABLE_FREE_VALUE_FUNC)(void* value);


YR_API int yr_hash_table_create(
    int size,
    YR_HASH_TABLE** table);


YR_API void yr_hash_table_clean(
    YR_HASH_TABLE* table,
    YR_HASH_TABLE_FREE_VALUE_FUNC free_value);


YR_API void yr_hash_table_destroy(
    YR_HASH_TABLE* table,
    YR_HASH_TABLE_FREE_VALUE_FUNC free_value);


YR_API void* yr_hash_table_lookup(
    YR_HASH_TABLE* table,
    const char* key,
    const char* ns);


YR_API int yr_hash_table_add(
    YR_HASH_TABLE* table,
    const char* key,
    const char* ns,
    void* value);


YR_API void* yr_hash_table_lookup_raw_key(
    YR_HASH_TABLE* table,
    const void* key,
    size_t key_length,
    const char* ns);


YR_API int yr_hash_table_add_raw_key(
    YR_HASH_TABLE* table,
    const void* key,
    size_t key_length,
    const char* ns,
    void* value);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/hex_lexer.h
================================================
/*
Copyright (c) 2007. Victor M. Alvarez [plusvic@gmail.com].

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "re.h"

#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_FATAL_ERROR
#undef YY_DECL
#undef LEX_ENV

#define yyparse         hex_yyparse
#define yylex           hex_yylex
#define yyerror         hex_yyerror
#define yyfatal         hex_yyfatal
#define yychar          hex_yychar
#define yydebug         hex_yydebug
#define yynerrs         hex_yynerrs
#define yyget_extra     hex_yyget_extra
#define yyget_lineno    hex_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#define YY_EXTRA_TYPE RE*
#define YY_USE_CONST


typedef struct _HEX_LEX_ENVIRONMENT
{
    int token_count;
    int inside_or;
    int last_error_code;
    char last_error_message[256];

} HEX_LEX_ENVIRONMENT;


#define YY_FATAL_ERROR(msg) hex_yyfatal(yyscanner, msg)

#define LEX_ENV  ((HEX_LEX_ENVIRONMENT*) lex_env)

#include <hex_grammar.h>

#define YY_DECL int hex_yylex \
    (YYSTYPE * yylval_param , yyscan_t yyscanner, HEX_LEX_ENVIRONMENT* lex_env)


YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yylex(
    YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env);

int yyparse(
    void* yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env);

void yyerror(
    yyscan_t yyscanner,
    HEX_LEX_ENVIRONMENT* lex_env,
    const char* error_message);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

int yr_parse_hex_string(
    const char* hex_string,
    int flags,
    RE** re,
    RE_ERROR* error);



================================================
File: x64dbg_pluginsdk/yara/yara/integers.h
================================================
/*
Copyright (c) 2007-2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_INTEGERS_H
#define YR_INTEGERS_H

/* Integer type definitions
 */
#if ( defined( _MSC_VER ) && ( _MSC_VER < 1600 ) ) || ( defined( __BORLANDC__ ) && ( __BORLANDC__ <= 0x0560 ) )

#ifdef __cplusplus
extern "C" {
#endif

/* Microsoft Visual Studio C++ before Visual Studio 2010 or earlier versions of the Borland C++ Builder
 * do not support the (u)int#_t type definitions but have __int# defintions instead
 */
typedef __int8 int8_t;
typedef unsigned __int8 uint8_t;
typedef __int16 int16_t;
typedef unsigned __int16 uint16_t;
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;

#ifdef __cplusplus
}
#endif

#else

/* Other "compilers" and later versions of Microsoft Visual Studio C++ and
 * Borland C/C++ define the types in <stdint.h>
 */
#include <stdint.h>

#endif

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/lexer.h
================================================
/*
Copyright (c) 2007. Victor M. Alvarez [plusvic@gmail.com].

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "compiler.h"


#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_DECL
#undef YY_FATAL_ERROR
#undef YY_EXTRA_TYPE

#define yyparse       yara_yyparse
#define yylex         yara_yylex
#define yyerror       yara_yyerror
#define yyfatal       yara_yyfatal
#define yywarning     yara_yywarning
#define yychar        yara_yychar
#define yydebug       yara_yydebug
#define yynerrs       yara_yynerrs
#define yyget_extra   yara_yyget_extra
#define yyget_lineno  yara_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#ifndef YY_TYPEDEF_EXPRESSION_T
#define YY_TYPEDEF_EXPRESSION_T


// Expression type constants are powers of two because they are used as flags.
// For example:
//   CHECK_TYPE(whatever, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT)
// The expression above is used to ensure that the type of "whatever" is either
// integer or float.

#define EXPRESSION_TYPE_BOOLEAN   1
#define EXPRESSION_TYPE_INTEGER   2
#define EXPRESSION_TYPE_STRING    4
#define EXPRESSION_TYPE_REGEXP    8
#define EXPRESSION_TYPE_OBJECT    16
#define EXPRESSION_TYPE_FLOAT     32

typedef struct _EXPRESSION
{
    int type;

    union
    {
        int64_t integer;
        YR_OBJECT* object;
        SIZED_STRING* sized_string;
    } value;

    const char* identifier;

} EXPRESSION;

union YYSTYPE;

#endif


#define YY_DECL int yylex( \
    union YYSTYPE* yylval_param, yyscan_t yyscanner, YR_COMPILER* compiler)


#define YY_FATAL_ERROR(msg) yara_yyfatal(yyscanner, msg)


#define YY_EXTRA_TYPE YR_COMPILER*
#define YY_USE_CONST


int yyget_lineno(yyscan_t yyscanner);

int yylex(
    union YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    YR_COMPILER* compiler);

int yyparse(
    void* yyscanner,
    YR_COMPILER* compiler);

void yyerror(
    yyscan_t yyscanner,
    YR_COMPILER* compiler,
    const char* error_message);

void yywarning(
    yyscan_t yyscanner,
    const char* message_fmt,
    ...);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yr_lex_parse_rules_string(
    const char* rules_string,
    YR_COMPILER* compiler);

int yr_lex_parse_rules_file(
    FILE* rules_file,
    YR_COMPILER* compiler);



================================================
File: x64dbg_pluginsdk/yara/yara/libyara.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_LIBYARA_H
#define YR_LIBYARA_H

#include "utils.h"

#define YR_MAJOR_VERSION   3
#define YR_MINOR_VERSION   5
#define YR_MICRO_VERSION   0

// Version as a string
#define YR_VERSION         "3.5.0"


// Version as a single 4-byte hex number, e.g. 0x030401 == 3.4.1.
#define YR_VERSION_HEX ((YR_MAJOR_VERSION << 16) | \
    (YR_MINOR_VERSION << 8) | \
    (YR_MICRO_VERSION << 0))


// Enumerated type listing configuration options
typedef enum _YR_CONFIG_NAME
{
    YR_CONFIG_STACK_SIZE,
    YR_CONFIG_MAX

} YR_CONFIG_NAME;


#define DEFAULT_STACK_SIZE 16384


YR_API int yr_initialize(void);


YR_API int yr_finalize(void);


YR_API void yr_finalize_thread(void);


YR_API int yr_get_tidx(void);


YR_API void yr_set_tidx(int);


YR_API int yr_set_configuration(YR_CONFIG_NAME, void*);


YR_API int yr_get_configuration(YR_CONFIG_NAME, void*);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/limits.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_LIMITS_H
#define YR_LIMITS_H

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>
#endif


// MAX_THREADS is the number of threads that can use a YR_RULES
// object simultaneosly. This value is limited by the number of
// bits in tidx_mask.

#define MAX_THREADS 32


#ifndef MAX_PATH
#define MAX_PATH 1024
#endif

#define MAX_COMPILER_ERROR_EXTRA_INFO   256
#define MAX_ATOM_LENGTH                 4
#define MAX_LOOP_NESTING                4
#define MAX_ARENA_PAGES                 32
#define MAX_INCLUDE_DEPTH               16
#define MAX_STRING_MATCHES              1000000
#define MAX_FUNCTION_ARGS               128
#define MAX_FAST_HEX_RE_STACK           300
#define MAX_OVERLOADED_FUNCTIONS        10
#define MAX_HEX_STRING_TOKENS           10000
#define MAX_MATCH_DATA                  4096

#define LOOP_LOCAL_VARS                 4
#define STRING_CHAINING_THRESHOLD       200
#define LEX_BUF_SIZE                    8192


#endif



================================================
File: x64dbg_pluginsdk/yara/yara/mem.h
================================================
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MEM_H
#define YR_MEM_H

#include <stdio.h>

#include "config.h"

#ifdef DMALLOC

#define yr_malloc malloc
#define yr_calloc calloc
#define yr_realloc realloc
#define yr_free free
#define yr_strdup strdup
#define yr_strndup strndup

#include <dmalloc.h>

#else

void* yr_calloc(
    size_t count,
    size_t size);

void* yr_malloc(
    size_t size);

void* yr_realloc(
    void* ptr,
    size_t size);

void yr_free(
    void* ptr);

char* yr_strdup(
    const char* str);

char* yr_strndup(
    const char* str, size_t n);

#endif

int yr_heap_alloc(void);

int yr_heap_free(void);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/modules.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MODULES_H
#define YR_MODULES_H

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "limits.h"
#include "exec.h"
#include "types.h"
#include "object.h"
#include "libyara.h"

// Concatenation that macro-expands its arguments.

#define CONCAT(arg1, arg2) YARA_CONCAT(arg1, arg2) // expands the arguments.
#define YARA_CONCAT(arg1, arg2) arg1 ## arg2       // do the actual concatenation.


#define module_declarations CONCAT(MODULE_NAME, __declarations)
#define module_load CONCAT(MODULE_NAME, __load)
#define module_unload CONCAT(MODULE_NAME, __unload)
#define module_initialize CONCAT(MODULE_NAME, __initialize)
#define module_finalize CONCAT(MODULE_NAME, __finalize)

#define begin_declarations \
    int module_declarations(YR_OBJECT* module) { \
      YR_OBJECT* stack[64]; \
      int stack_top = 0; \
      stack[stack_top] = module;


#define end_declarations \
    return ERROR_SUCCESS; }


#define begin_struct(name) { \
    YR_OBJECT* structure; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        stack[stack_top], \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define begin_struct_array(name) { \
    YR_OBJECT* structure; \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        array, \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define begin_struct_dictionary(name) { \
    YR_OBJECT* structure; \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRUCTURE, \
        name, \
        array, \
        &structure)); \
    assertf( \
        stack_top < sizeof(stack)/sizeof(stack[0]) - 1, \
        "too many nested structures"); \
    stack[++stack_top] = structure; \
  }


#define end_struct(name) { \
    assert(stack[stack_top]->type == OBJECT_TYPE_STRUCTURE); \
    assertf( \
        strcmp(stack[stack_top]->identifier, name) == 0, \
        "unbalanced begin_struct/end_struct"); \
    stack_top--; \
  }


#define end_struct_array(name) end_struct(name)


#define end_struct_dictionary(name) end_struct(name)


#define declare_integer(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_integer_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        array, \
        NULL)); \
  }


#define declare_integer_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_INTEGER, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_float(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_float_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        array, \
        NULL)); \
  }


#define declare_float_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_FLOAT, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_string(name) { \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        stack[stack_top], \
        NULL)); \
  }


#define declare_string_array(name) { \
    YR_OBJECT* array; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_ARRAY, \
        name, \
        stack[stack_top], \
        &array)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        array, \
        NULL)); \
  }


#define declare_string_dictionary(name) { \
    YR_OBJECT* dict; \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_DICTIONARY, \
        name, \
        stack[stack_top], \
        &dict)); \
    FAIL_ON_ERROR(yr_object_create( \
        OBJECT_TYPE_STRING, \
        name, \
        dict, \
        NULL)); \
  }


#define declare_function(name, args_fmt, ret_fmt, func) { \
    YR_OBJECT* function; \
    FAIL_ON_ERROR(yr_object_function_create( \
        name, \
        args_fmt, \
        ret_fmt, \
        func, \
        stack[stack_top], \
        &function)); \
    }


#define define_function(func) \
    int func ( \
        void* __args, \
        YR_SCAN_CONTEXT* __context, \
        YR_OBJECT_FUNCTION* __function_obj)


#define sized_string_argument(n) \
    ((SIZED_STRING*)(size_t)((int64_t*) __args)[n-1])

#define string_argument(n) \
    (sized_string_argument(n)->c_string)

#define integer_argument(n) \
    (((int64_t*) __args)[n-1])

#define float_argument(n) \
    (((double*) __args)[n-1])

#define regexp_argument(n) \
    ((RE_CODE)((int64_t*) __args)[n-1])


#define module()        yr_object_get_root((YR_OBJECT*) __function_obj)
#define parent()        (__function_obj->parent)
#define scan_context()  (__context)


#define foreach_memory_block(iterator, block) \
  for (block = iterator->first(iterator); \
       block != NULL; \
       block = iterator->next(iterator)) \
 

#define first_memory_block(context) \
      (context)->iterator->first((context)->iterator)


#define is_undefined(object, ...) \
    yr_object_has_undefined_value(object, __VA_ARGS__)


#define get_object(object, ...) \
    yr_object_lookup(object, 0, __VA_ARGS__)


#define get_integer(object, ...) \
    yr_object_get_integer(object, __VA_ARGS__)


#define get_float(object, ...) \
    yr_object_get_float(object, __VA_ARGS__)


#define get_string(object, ...) \
    yr_object_get_string(object, __VA_ARGS__)


#define set_integer(value, object, ...) \
    yr_object_set_integer(value, object, __VA_ARGS__)


#define set_float(value, object, ...) \
    yr_object_set_float(value, object, __VA_ARGS__)


#define set_sized_string(value, len, object, ...) \
    yr_object_set_string(value, len, object, __VA_ARGS__)


#define set_string(value, object, ...) \
    set_sized_string(value, strlen(value), object, __VA_ARGS__)


#define return_integer(integer) { \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_INTEGER, \
          "return type differs from function declaration"); \
      yr_object_set_integer( \
          (integer), \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


#define return_float(double_) { \
      double d = (double) (double_); \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_FLOAT, \
          "return type differs from function declaration"); \
      yr_object_set_float( \
          (d != (double) UNDEFINED) ? d : NAN, \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


#define return_string(string) { \
      char* s = (char*) (string); \
      assertf( \
          __function_obj->return_obj->type == OBJECT_TYPE_STRING, \
          "return type differs from function declaration"); \
      yr_object_set_string( \
          (s != (char*) UNDEFINED) ? s : NULL, \
          (s != (char*) UNDEFINED) ? strlen(s) : 0, \
          __function_obj->return_obj, \
          NULL); \
      return ERROR_SUCCESS; \
    }


struct _YR_MODULE;


typedef int (*YR_EXT_INITIALIZE_FUNC)(
    struct _YR_MODULE* module);


typedef int (*YR_EXT_FINALIZE_FUNC)(
    struct _YR_MODULE* module);


typedef int (*YR_EXT_DECLARATIONS_FUNC)(
    YR_OBJECT* module_object);


typedef int (*YR_EXT_LOAD_FUNC)(
    YR_SCAN_CONTEXT* context,
    YR_OBJECT* module_object,
    void* module_data,
    size_t module_data_size);


typedef int (*YR_EXT_UNLOAD_FUNC)(
    YR_OBJECT* module_object);


typedef struct _YR_MODULE
{
    char* name;

    YR_EXT_DECLARATIONS_FUNC declarations;
    YR_EXT_LOAD_FUNC load;
    YR_EXT_UNLOAD_FUNC unload;
    YR_EXT_INITIALIZE_FUNC initialize;
    YR_EXT_FINALIZE_FUNC finalize;

} YR_MODULE;


typedef struct _YR_MODULE_IMPORT
{
    const char* module_name;
    void* module_data;
    size_t module_data_size;

} YR_MODULE_IMPORT;


int yr_modules_initialize(void);


int yr_modules_finalize(void);


int yr_modules_do_declarations(
    const char* module_name,
    YR_OBJECT* main_structure);


int yr_modules_load(
    const char* module_name,
    YR_SCAN_CONTEXT* context);


int yr_modules_unload_all(
    YR_SCAN_CONTEXT* context);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/object.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_OBJECT_H
#define YR_OBJECT_H

#ifdef _MSC_VER

#include <float.h>
#define isnan _isnan

#ifndef INFINITY
#define INFINITY (DBL_MAX + DBL_MAX)
#endif

#ifndef NAN
#define NAN (INFINITY-INFINITY)
#endif

#endif

#include "types.h"


#define OBJECT_CREATE           1

#define OBJECT_TYPE_INTEGER     1
#define OBJECT_TYPE_STRING      2
#define OBJECT_TYPE_STRUCTURE   3
#define OBJECT_TYPE_ARRAY       4
#define OBJECT_TYPE_FUNCTION    5
#define OBJECT_TYPE_REGEXP      6
#define OBJECT_TYPE_DICTIONARY  7
#define OBJECT_TYPE_FLOAT       8


int yr_object_create(
    int8_t type,
    const char* identifier,
    YR_OBJECT* parent,
    YR_OBJECT** object);


int yr_object_function_create(
    const char* identifier,
    const char* arguments_fmt,
    const char* return_fmt,
    YR_MODULE_FUNC func,
    YR_OBJECT* parent,
    YR_OBJECT** function);


int yr_object_from_external_variable(
    YR_EXTERNAL_VARIABLE* external,
    YR_OBJECT** object);


void yr_object_destroy(
    YR_OBJECT* object);


YR_OBJECT* yr_object_lookup_field(
    YR_OBJECT* object,
    const char* field_name);


YR_OBJECT* yr_object_lookup(
    YR_OBJECT* root,
    int flags,
    const char* pattern,
    ...);


int yr_object_has_undefined_value(
    YR_OBJECT* object,
    const char* field,
    ...);

int64_t yr_object_get_integer(
    YR_OBJECT* object,
    const char* field,
    ...);


SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_integer(
    int64_t value,
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_float(
    double value,
    YR_OBJECT* object,
    const char* field,
    ...);


int yr_object_set_string(
    const char* value,
    size_t len,
    YR_OBJECT* object,
    const char* field,
    ...);


YR_OBJECT* yr_object_array_get_item(
    YR_OBJECT* object,
    int flags,
    int index);


int yr_object_array_set_item(
    YR_OBJECT* object,
    YR_OBJECT* item,
    int index);


YR_OBJECT* yr_object_dict_get_item(
    YR_OBJECT* object,
    int flags,
    const char* key);


int yr_object_dict_set_item(
    YR_OBJECT* object,
    YR_OBJECT* item,
    const char* key);


int yr_object_structure_set_member(
    YR_OBJECT* object,
    YR_OBJECT* member);


YR_OBJECT* yr_object_get_root(
    YR_OBJECT* object);


YR_API void yr_object_print_data(
    YR_OBJECT* object,
    int indent,
    int print_identifier);


#endif



================================================
File: x64dbg_pluginsdk/yara/yara/parser.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PARSER_H
#define YR_PARSER_H


#include "lexer.h"


int yr_parser_emit(
    yyscan_t yyscanner,
    uint8_t instruction,
    uint8_t** instruction_address);


int yr_parser_emit_with_arg(
    yyscan_t yyscanner,
    uint8_t instruction,
    int64_t argument,
    uint8_t** instruction_address,
    int64_t** argument_address);


int yr_parser_emit_with_arg_double(
    yyscan_t yyscanner,
    uint8_t instruction,
    double argument,
    uint8_t** instruction_address,
    double** argument_address);


int yr_parser_emit_with_arg_reloc(
    yyscan_t yyscanner,
    uint8_t instruction,
    int64_t argument,
    uint8_t** instruction_address,
    int64_t** argument_address);


int yr_parser_check_types(
    YR_COMPILER* compiler,
    YR_OBJECT_FUNCTION* function,
    const char* actual_args_fmt);


YR_STRING* yr_parser_lookup_string(
    yyscan_t yyscanner,
    const char* identifier);


int yr_parser_lookup_loop_variable(
    yyscan_t yyscanner,
    const char* identifier);


YR_RULE* yr_parser_reduce_rule_declaration_phase_1(
    yyscan_t yyscanner,
    int32_t flags,
    const char* identifier);


int yr_parser_reduce_rule_declaration_phase_2(
    yyscan_t yyscanner,
    YR_RULE* rule);


YR_STRING* yr_parser_reduce_string_declaration(
    yyscan_t yyscanner,
    int32_t flags,
    const char* identifier,
    SIZED_STRING* str);


YR_META* yr_parser_reduce_meta_declaration(
    yyscan_t yyscanner,
    int32_t type,
    const char* identifier,
    const char* string,
    int64_t integer);


int yr_parser_reduce_string_identifier(
    yyscan_t yyscanner,
    const char* identifier,
    uint8_t instruction,
    uint64_t at_offset);


int yr_parser_emit_pushes_for_strings(
    yyscan_t yyscanner,
    const char* identifier);


int yr_parser_reduce_external(
    yyscan_t yyscanner,
    const char* identifier,
    uint8_t intruction);


int yr_parser_reduce_import(
    yyscan_t yyscanner,
    SIZED_STRING* module_name);


int yr_parser_reduce_operation(
    yyscan_t yyscanner,
    const char* operation,
    EXPRESSION left_operand,
    EXPRESSION right_operand);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/pe.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#pragma pack(push, 1)

#if defined(_WIN32) || defined(__CYGWIN__)
#include <windows.h>

// These definitions are not present in older Windows headers.

#ifndef IMAGE_FILE_MACHINE_ARMNT
#define IMAGE_FILE_MACHINE_ARMNT             0x01c4
#endif

#ifndef IMAGE_FILE_MACHINE_ARM64
#define IMAGE_FILE_MACHINE_ARM64             0xaa64
#endif

#else

#include <stdlib.h>

#include "integers.h"

typedef uint8_t   BYTE;
typedef uint16_t  WORD;
typedef uint32_t  DWORD;
typedef int32_t   LONG;
typedef uint32_t  ULONG;
typedef uint64_t  ULONGLONG;


#define FIELD_OFFSET(type, field)    ((size_t)&(((type *)0)->field))

#ifndef _MAC

#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE                 0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x454C      // LE
#define IMAGE_VXD_SIGNATURE                 0x454C      // LE
#define IMAGE_NT_SIGNATURE                  0x00004550  // PE00

#else

#define IMAGE_DOS_SIGNATURE                 0x4D5A      // MZ
#define IMAGE_OS2_SIGNATURE                 0x4E45      // NE
#define IMAGE_OS2_SIGNATURE_LE              0x4C45      // LE
#define IMAGE_NT_SIGNATURE                  0x50450000  // PE00

#endif

#pragma pack(push, 2)

typedef struct _IMAGE_DOS_HEADER        // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

#pragma pack(pop)

//
// File header format.
//

#pragma pack(push,4)

typedef struct _IMAGE_FILE_HEADER
{
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;



#define IMAGE_SIZEOF_FILE_HEADER             20


#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Agressively trim working set
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle >2gb addresses
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.


#define IMAGE_FILE_MACHINE_UNKNOWN           0x0000
#define IMAGE_FILE_MACHINE_AM33              0x01d3
#define IMAGE_FILE_MACHINE_AMD64             0x8664
#define IMAGE_FILE_MACHINE_ARM               0x01c0
#define IMAGE_FILE_MACHINE_ARMNT             0x01c4
#define IMAGE_FILE_MACHINE_ARM64             0xaa64
#define IMAGE_FILE_MACHINE_EBC               0x0ebc
#define IMAGE_FILE_MACHINE_I386              0x014c
#define IMAGE_FILE_MACHINE_IA64              0x0200
#define IMAGE_FILE_MACHINE_M32R              0x9041
#define IMAGE_FILE_MACHINE_MIPS16            0x0266
#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366
#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466
#define IMAGE_FILE_MACHINE_POWERPC           0x01f0
#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1
#define IMAGE_FILE_MACHINE_R4000             0x0166
#define IMAGE_FILE_MACHINE_SH3               0x01a2
#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3
#define IMAGE_FILE_MACHINE_SH4               0x01a6
#define IMAGE_FILE_MACHINE_SH5               0x01a8
#define IMAGE_FILE_MACHINE_THUMB             0x01c2
#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169

// Section characteristics
#define IMAGE_SCN_CNT_CODE                   0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080
#define IMAGE_SCN_GPREL                      0x00008000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000
#define IMAGE_SCN_MEM_SHARED                 0x10000000
#define IMAGE_SCN_MEM_EXECUTE                0x20000000
#define IMAGE_SCN_MEM_READ                   0x40000000
#define IMAGE_SCN_MEM_WRITE                  0x80000000

//
// Directory format.
//

typedef struct _IMAGE_DATA_DIRECTORY
{
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16


#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor


//
// Optional header format.
//

typedef struct _IMAGE_OPTIONAL_HEADER32
{
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;


typedef struct _IMAGE_OPTIONAL_HEADER64
{
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;


#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b


typedef struct _IMAGE_NT_HEADERS32
{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;

} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;


typedef struct _IMAGE_NT_HEADERS64
{
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;

} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;


// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is
// the same either way.

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER) \
    ((BYTE*)ntheader + \
     FIELD_OFFSET( IMAGE_NT_HEADERS32, OptionalHeader ) + \
     ((PIMAGE_NT_HEADERS32)(ntheader))->FileHeader.SizeOfOptionalHeader \
    ))

// Subsystem Values

#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.
#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.
#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.
#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image runs in the Posix character subsystem.
#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   // image is a native Win9x driver.

//
// Section header format.
//

#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER
{
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union
    {
        DWORD   PhysicalAddress;
        DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;

} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#define IMAGE_SIZEOF_SECTION_HEADER          40


typedef struct _IMAGE_EXPORT_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;


typedef struct _IMAGE_IMPORT_DESCRIPTOR
{
    union
    {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    } ;
    DWORD TimeDateStamp;
    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;

} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;


typedef struct _IMAGE_IMPORT_BY_NAME
{
    WORD Hint;
    BYTE Name[1];

} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_THUNK_DATA32
{
    union
    {
        DWORD ForwarderString;
        DWORD Function;
        DWORD Ordinal;
        DWORD AddressOfData;
    } u1;

} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;


#define IMAGE_ORDINAL_FLAG32  0x80000000
#define IMAGE_ORDINAL_FLAG64  0x8000000000000000L

typedef struct _IMAGE_THUNK_DATA64
{
    union
    {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    } u1;

} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64;


typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY
{
    DWORD Name;
    DWORD OffsetToData;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;


typedef struct _IMAGE_RESOURCE_DATA_ENTRY
{
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;


typedef struct _IMAGE_RESOURCE_DIRECTORY
{
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    WORD  NumberOfNamedEntries;
    WORD  NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

#pragma pack(pop)

#endif  // _WIN32

typedef struct _VERSION_INFO
{
    WORD   Length;
    WORD   ValueLength;
    WORD   Type;
    char   Key[0];
} VERSION_INFO, *PVERSION_INFO;


#define WIN_CERT_REVISION_1_0 0x0100
#define WIN_CERT_REVISION_2_0 0x0200

#define WIN_CERT_TYPE_X509             0x0001
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA 0x0002
#define WIN_CERT_TYPE_RESERVED_1       0x0003
#define WIN_CERT_TYPE_TS_STACK_SIGNED  0x0004

typedef struct _WIN_CERTIFICATE
{
    DWORD Length;
    WORD  Revision;
    WORD  CertificateType;
    BYTE  Certificate[0];
} WIN_CERTIFICATE, *PWIN_CERTIFICATE;


//
// Rich signature.
// http://www.ntcore.com/files/richsign.htm
//

#define RICH_VERSION_ID(id_version) (id_version >> 16)
#define RICH_VERSION_VERSION(id_version) (id_version & 0xFFFF)

typedef struct _RICH_VERSION_INFO
{
    DWORD id_version; //tool id and version (use RICH_VERSION_ID and RICH_VERSION_VERSION macros)
    DWORD times; //number of times this tool was used
} RICH_VERSION_INFO, *PRICH_VERSION_INFO;

typedef struct _RICH_SIGNATURE
{
    DWORD dans;
    DWORD key1;
    DWORD key2;
    DWORD key3;
    RICH_VERSION_INFO versions[0];
} RICH_SIGNATURE, *PRICH_SIGNATURE;

#define RICH_DANS 0x536e6144 // "DanS"
#define RICH_RICH 0x68636952 // "Rich"

typedef struct _RICH_DATA
{
    size_t len;
    BYTE* raw_data;
    BYTE* clear_data;
} RICH_DATA, *PRICH_DATA;

#pragma pack(pop)



================================================
File: x64dbg_pluginsdk/yara/yara/proc.h
================================================
/*
Copyright (c) 2007. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_PROC_H
#define YR_PROC_H

#include "types.h"

int yr_process_open_iterator(
    int pid,
    YR_MEMORY_BLOCK_ITERATOR* iterator);

int yr_process_close_iterator(
    YR_MEMORY_BLOCK_ITERATOR* iterator);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/re.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_RE_H
#define YR_RE_H

#include <ctype.h>

#include "arena.h"
#include "sizedstr.h"

#define RE_NODE_LITERAL             1
#define RE_NODE_MASKED_LITERAL      2
#define RE_NODE_ANY                 3
#define RE_NODE_CONCAT              4
#define RE_NODE_ALT                 5
#define RE_NODE_RANGE               6
#define RE_NODE_STAR                7
#define RE_NODE_PLUS                8
#define RE_NODE_CLASS               9
#define RE_NODE_WORD_CHAR           10
#define RE_NODE_NON_WORD_CHAR       11
#define RE_NODE_SPACE               12
#define RE_NODE_NON_SPACE           13
#define RE_NODE_DIGIT               14
#define RE_NODE_NON_DIGIT           15
#define RE_NODE_EMPTY               16
#define RE_NODE_ANCHOR_START        17
#define RE_NODE_ANCHOR_END          18
#define RE_NODE_WORD_BOUNDARY       19
#define RE_NODE_NON_WORD_BOUNDARY   20


#define RE_OPCODE_ANY                   0xA0
#define RE_OPCODE_ANY_EXCEPT_NEW_LINE   0xA1
#define RE_OPCODE_LITERAL               0xA2
#define RE_OPCODE_LITERAL_NO_CASE       0xA3
#define RE_OPCODE_MASKED_LITERAL        0xA4
#define RE_OPCODE_CLASS                 0xA5
#define RE_OPCODE_CLASS_NO_CASE         0xA6
#define RE_OPCODE_WORD_CHAR             0xA7
#define RE_OPCODE_NON_WORD_CHAR         0xA8
#define RE_OPCODE_SPACE                 0xA9
#define RE_OPCODE_NON_SPACE             0xAA
#define RE_OPCODE_DIGIT                 0xAB
#define RE_OPCODE_NON_DIGIT             0xAC
#define RE_OPCODE_MATCH                 0xAD

#define RE_OPCODE_MATCH_AT_END          0xB0
#define RE_OPCODE_MATCH_AT_START        0xB1
#define RE_OPCODE_WORD_BOUNDARY         0xB2
#define RE_OPCODE_NON_WORD_BOUNDARY     0xB3

#define RE_OPCODE_SPLIT_A               0xC0
#define RE_OPCODE_SPLIT_B               0xC1
#define RE_OPCODE_PUSH                  0xC2
#define RE_OPCODE_POP                   0xC3
#define RE_OPCODE_JNZ                   0xC4
#define RE_OPCODE_JUMP                  0xC5


#define RE_FLAGS_FAST_HEX_REGEXP        0x02
#define RE_FLAGS_BACKWARDS              0x04
#define RE_FLAGS_EXHAUSTIVE             0x08
#define RE_FLAGS_WIDE                   0x10
#define RE_FLAGS_NO_CASE                0x20
#define RE_FLAGS_SCAN                   0x40
#define RE_FLAGS_DOT_ALL                0x80
#define RE_FLAGS_NOT_AT_START          0x100
#define RE_FLAGS_GREEDY                0x400
#define RE_FLAGS_UNGREEDY              0x800


typedef struct RE RE;
typedef struct RE_NODE RE_NODE;
typedef struct RE_ERROR RE_ERROR;

typedef uint8_t RE_SPLIT_ID_TYPE;
typedef uint8_t* RE_CODE;

#define CHAR_IN_CLASS(chr, cls)  \
    ((cls)[(chr) / 8] & 1 << ((chr) % 8))


#define IS_WORD_CHAR(chr) \
    (isalnum(chr) || (chr) == '_')


struct RE_NODE
{
    int type;

    union
    {
        int value;
        int count;
        int start;
    };

    union
    {
        int mask;
        int end;
    };

    int greedy;

    uint8_t* class_vector;

    RE_NODE* left;
    RE_NODE* right;

    RE_CODE forward_code;
    RE_CODE backward_code;
};


struct RE
{

    uint32_t flags;
    RE_NODE* root_node;
    YR_ARENA* code_arena;
    RE_CODE code;
};


struct RE_ERROR
{

    char message[512];

};


typedef int RE_MATCH_CALLBACK_FUNC(
    uint8_t* match,
    int match_length,
    int flags,
    void* args);


int yr_re_create(
    RE** re);


int yr_re_parse(
    const char* re_string,
    int flags,
    RE** re,
    RE_ERROR* error);


int yr_re_parse_hex(
    const char* hex_string,
    int flags,
    RE** re,
    RE_ERROR* error);


int yr_re_compile(
    const char* re_string,
    int flags,
    YR_ARENA* code_arena,
    RE** re,
    RE_ERROR* error);


void yr_re_destroy(
    RE* re);


void yr_re_print(
    RE* re);


RE_NODE* yr_re_node_create(
    int type,
    RE_NODE* left,
    RE_NODE* right);


void yr_re_node_destroy(
    RE_NODE* node);


SIZED_STRING* yr_re_extract_literal(
    RE* re);


int yr_re_contains_dot_star(
    RE* re);


int yr_re_split_at_chaining_point(
    RE* re,
    RE** result_re,
    RE** remainder_re,
    int32_t* min_gap,
    int32_t* max_gap);


int yr_re_emit_code(
    RE* re,
    YR_ARENA* arena);


int yr_re_exec(
    RE_CODE re_code,
    uint8_t* input,
    size_t input_size,
    int flags,
    RE_MATCH_CALLBACK_FUNC callback,
    void* callback_args);


int yr_re_match(
    RE_CODE re_code,
    const char* target);


int yr_re_initialize(void);


int yr_re_finalize(void);


int yr_re_finalize_thread(void);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/re_lexer.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#undef yyparse
#undef yylex
#undef yyerror
#undef yyfatal
#undef yychar
#undef yydebug
#undef yynerrs
#undef yyget_extra
#undef yyget_lineno

#undef YY_FATAL_ERROR
#undef YY_DECL
#undef LEX_ENV


#define yyparse         re_yyparse
#define yylex           re_yylex
#define yyerror         re_yyerror
#define yyfatal         re_yyfatal
#define yychar          re_yychar
#define yydebug         re_yydebug
#define yynerrs         re_yynerrs
#define yyget_extra     re_yyget_extra
#define yyget_lineno    re_yyget_lineno


#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

#define YY_EXTRA_TYPE RE*
#define YY_USE_CONST


typedef struct _RE_LEX_ENVIRONMENT
{
    int negated_class;
    uint8_t class_vector[32];
    int last_error_code;
    char last_error_message[256];

} RE_LEX_ENVIRONMENT;


#define LEX_ENV  ((RE_LEX_ENVIRONMENT*) lex_env)

#define YY_FATAL_ERROR(msg) re_yyfatal(yyscanner, msg)

#include <re_grammar.h>

#define YY_DECL int re_yylex \
    (YYSTYPE * yylval_param , yyscan_t yyscanner, RE_LEX_ENVIRONMENT* lex_env)


YY_EXTRA_TYPE yyget_extra(
    yyscan_t yyscanner);

int yylex(
    YYSTYPE* yylval_param,
    yyscan_t yyscanner,
    RE_LEX_ENVIRONMENT* lex_env);

int yyparse(
    void* yyscanner,
    RE_LEX_ENVIRONMENT* lex_env);

void yyerror(
    yyscan_t yyscanner,
    RE_LEX_ENVIRONMENT* lex_env,
    const char* error_message);

void yyfatal(
    yyscan_t yyscanner,
    const char* error_message);

int yr_parse_re_string(
    const char* re_string,
    int flags,
    RE** re,
    RE_ERROR* error);



================================================
File: x64dbg_pluginsdk/yara/yara/rules.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_RULES_H
#define YR_RULES_H

#include "types.h"
#include "utils.h"
#include "filemap.h"


#define CALLBACK_MSG_RULE_MATCHING              1
#define CALLBACK_MSG_RULE_NOT_MATCHING          2
#define CALLBACK_MSG_SCAN_FINISHED              3
#define CALLBACK_MSG_IMPORT_MODULE              4
#define CALLBACK_MSG_MODULE_IMPORTED            5

#define CALLBACK_CONTINUE   0
#define CALLBACK_ABORT      1
#define CALLBACK_ERROR      2


#define yr_rule_tags_foreach(rule, tag_name) \
    for (tag_name = rule->tags; \
         tag_name != NULL && *tag_name != '\0'; \
         tag_name += strlen(tag_name) + 1)


#define yr_rule_metas_foreach(rule, meta) \
    for (meta = rule->metas; !META_IS_NULL(meta); meta++)


#define yr_rule_strings_foreach(rule, string) \
    for (string = rule->strings; !STRING_IS_NULL(string); string++)


#define yr_string_matches_foreach(string, match) \
    for (match = STRING_MATCHES(string).head; match != NULL; match = match->next)


#define yr_rules_foreach(rules, rule) \
    for (rule = rules->rules_list_head; !RULE_IS_NULL(rule); rule++)



YR_API int yr_rules_scan_mem(
    YR_RULES* rules,
    uint8_t* buffer,
    size_t buffer_size,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_file(
    YR_RULES* rules,
    const char* filename,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_fd(
    YR_RULES* rules,
    YR_FILE_DESCRIPTOR fd,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);


YR_API int yr_rules_scan_proc(
    YR_RULES* rules,
    int pid,
    int flags,
    YR_CALLBACK_FUNC callback,
    void* user_data,
    int timeout);

YR_API int yr_rules_save(
    YR_RULES* rules,
    const char* filename);


YR_API int yr_rules_save_stream(
    YR_RULES* rules,
    YR_STREAM* stream);


YR_API int yr_rules_load(
    const char* filename,
    YR_RULES** rules);


YR_API int yr_rules_load_stream(
    YR_STREAM* stream,
    YR_RULES** rules);


YR_API int yr_rules_destroy(
    YR_RULES* rules);


YR_API int yr_rules_define_integer_variable(
    YR_RULES* rules,
    const char* identifier,
    int64_t value);


YR_API int yr_rules_define_boolean_variable(
    YR_RULES* rules,
    const char* identifier,
    int value);


YR_API int yr_rules_define_float_variable(
    YR_RULES* rules,
    const char* identifier,
    double value);


YR_API int yr_rules_define_string_variable(
    YR_RULES* rules,
    const char* identifier,
    const char* value);


YR_API void yr_rules_print_profiling_info(
    YR_RULES* rules);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/scan.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_SCAN_H
#define YR_SCAN_H

#include "types.h"

// Bitmasks for flags.
#define SCAN_FLAGS_FAST_MODE         1
#define SCAN_FLAGS_PROCESS_MEMORY    2


int yr_scan_verify_match(
    YR_SCAN_CONTEXT* context,
    YR_AC_MATCH* ac_match,
    uint8_t* data,
    size_t data_size,
    size_t data_base,
    size_t offset);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/sizedstr.h
================================================
/*
Copyright (c) 2007-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _SIZEDSTR_H
#define _SIZEDSTR_H

#include <stddef.h>

#include "integers.h"

//
// This struct is used to support strings containing null chars. The length of
// the string is stored along the string data. However the string data is also
// terminated with a null char.
//

#define SIZED_STRING_FLAGS_NO_CASE  1
#define SIZED_STRING_FLAGS_DOT_ALL  2

#pragma pack(push)
#pragma pack(8)


typedef struct _SIZED_STRING
{
    uint32_t length;
    uint32_t flags;

    char c_string[1];

} SIZED_STRING;

#pragma pack(pop)


int sized_string_cmp(
    SIZED_STRING* s1,
    SIZED_STRING* s2);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/stream.h
================================================
/*
Copyright (c) 2015. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_STREAM_H
#define YR_STREAM_H

#include <stddef.h>

typedef size_t (*YR_STREAM_READ_FUNC)(
    void* ptr,
    size_t size,
    size_t count,
    void* user_data);


typedef size_t (*YR_STREAM_WRITE_FUNC)(
    const void* ptr,
    size_t size,
    size_t count,
    void* user_data);


typedef struct _YR_STREAM
{
    void* user_data;

    YR_STREAM_READ_FUNC read;
    YR_STREAM_WRITE_FUNC write;

} YR_STREAM;


size_t yr_stream_read(
    void* ptr,
    size_t size,
    size_t count,
    YR_STREAM* stream);


size_t yr_stream_write(
    const void* ptr,
    size_t size,
    size_t count,
    YR_STREAM* stream);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/strutils.h
================================================
/*
Copyright (c) 2007-2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_STRUTILS_H
#define YR_STRUTILS_H

#include <assert.h>
#include <stdlib.h>

#include "integers.h"

#include "config.h"

// Cygwin already has these functions.
#if defined(_WIN32) && !defined(__CYGWIN__)
#if defined(_MSC_VER) && _MSC_VER < 1900
#define snprintf _snprintf
#endif
#define strcasecmp _stricmp
#define strncasecmp _strnicmp
#endif


uint64_t xtoi(
    const char* hexstr);


#if !HAVE_STRLCPY && !defined(strlcpy)
size_t strlcpy(
    char* dst,
    const char* src,
    size_t size);
#endif


#if !HAVE_STRLCAT && !defined(strlcat)
size_t strlcat(
    char* dst,
    const char* src,
    size_t size);
#endif


#if !HAVE_MEMMEM && !defined(memmem)
void* memmem(
    const void* haystack,
    size_t haystack_size,
    const void* needle,
    size_t needle_size);
#endif


int strnlen_w(
    const char* w_str);


int strcmp_w(
    const char* w_str,
    const char* str);


size_t strlcpy_w(
    char* dst,
    const char* w_src,
    size_t n);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/threading.h
================================================
/*
Copyright (c) 2016. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_MUTEX_H
#define YR_MUTEX_H



#if defined(_WIN32) || defined(__CYGWIN__)

#include <windows.h>

typedef DWORD YR_THREAD_ID;
typedef DWORD YR_THREAD_STORAGE_KEY;
typedef HANDLE YR_MUTEX;

#else

#include <pthread.h>

typedef pthread_t YR_THREAD_ID;
typedef pthread_key_t YR_THREAD_STORAGE_KEY;
typedef pthread_mutex_t YR_MUTEX;

#endif

YR_THREAD_ID yr_current_thread_id(void);

int yr_mutex_create(YR_MUTEX*);
int yr_mutex_destroy(YR_MUTEX*);
int yr_mutex_lock(YR_MUTEX*);
int yr_mutex_unlock(YR_MUTEX*);

int yr_thread_storage_create(YR_THREAD_STORAGE_KEY*);
int yr_thread_storage_destroy(YR_THREAD_STORAGE_KEY*);
int yr_thread_storage_set_value(YR_THREAD_STORAGE_KEY*, void*);
void* yr_thread_storage_get_value(YR_THREAD_STORAGE_KEY*);

#endif



================================================
File: x64dbg_pluginsdk/yara/yara/types.h
================================================
/*
Copyright (c) 2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef YR_TYPES_H
#define YR_TYPES_H


#include "arena.h"
#include "re.h"
#include "limits.h"
#include "hash.h"
#include "utils.h"
#include "threading.h"



#ifdef PROFILING_ENABLED
#include <time.h>
#endif

typedef int32_t tidx_mask_t;


#define DECLARE_REFERENCE(type, name) \
    union { type name; int64_t name##_; } YR_ALIGN(8)



#define NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL      0x01


#define STRING_GFLAGS_REFERENCED        0x01
#define STRING_GFLAGS_HEXADECIMAL       0x02
#define STRING_GFLAGS_NO_CASE           0x04
#define STRING_GFLAGS_ASCII             0x08
#define STRING_GFLAGS_WIDE              0x10
#define STRING_GFLAGS_REGEXP            0x20
#define STRING_GFLAGS_FAST_HEX_REGEXP   0x40
#define STRING_GFLAGS_FULL_WORD         0x80
#define STRING_GFLAGS_ANONYMOUS         0x100
#define STRING_GFLAGS_SINGLE_MATCH      0x200
#define STRING_GFLAGS_LITERAL           0x400
#define STRING_GFLAGS_FITS_IN_ATOM      0x800
#define STRING_GFLAGS_NULL              0x1000
#define STRING_GFLAGS_CHAIN_PART        0x2000
#define STRING_GFLAGS_CHAIN_TAIL        0x4000
#define STRING_GFLAGS_FIXED_OFFSET      0x8000
#define STRING_GFLAGS_GREEDY_REGEXP     0x10000

#define STRING_IS_HEX(x) \
    (((x)->g_flags) & STRING_GFLAGS_HEXADECIMAL)

#define STRING_IS_NO_CASE(x) \
    (((x)->g_flags) & STRING_GFLAGS_NO_CASE)

#define STRING_IS_ASCII(x) \
    (((x)->g_flags) & STRING_GFLAGS_ASCII)

#define STRING_IS_WIDE(x) \
    (((x)->g_flags) & STRING_GFLAGS_WIDE)

#define STRING_IS_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_REGEXP)

#define STRING_IS_GREEDY_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_GREEDY_REGEXP)

#define STRING_IS_FULL_WORD(x) \
    (((x)->g_flags) & STRING_GFLAGS_FULL_WORD)

#define STRING_IS_ANONYMOUS(x) \
    (((x)->g_flags) & STRING_GFLAGS_ANONYMOUS)

#define STRING_IS_REFERENCED(x) \
    (((x)->g_flags) & STRING_GFLAGS_REFERENCED)

#define STRING_IS_SINGLE_MATCH(x) \
    (((x)->g_flags) & STRING_GFLAGS_SINGLE_MATCH)

#define STRING_IS_FIXED_OFFSET(x) \
    (((x)->g_flags) & STRING_GFLAGS_FIXED_OFFSET)

#define STRING_IS_LITERAL(x) \
    (((x)->g_flags) & STRING_GFLAGS_LITERAL)

#define STRING_IS_FAST_HEX_REGEXP(x) \
    (((x)->g_flags) & STRING_GFLAGS_FAST_HEX_REGEXP)

#define STRING_IS_CHAIN_PART(x) \
    (((x)->g_flags) & STRING_GFLAGS_CHAIN_PART)

#define STRING_IS_CHAIN_TAIL(x) \
    (((x)->g_flags) & STRING_GFLAGS_CHAIN_TAIL)

#define STRING_IS_NULL(x) \
    ((x) == NULL || ((x)->g_flags) & STRING_GFLAGS_NULL)

#define STRING_FITS_IN_ATOM(x) \
    (((x)->g_flags) & STRING_GFLAGS_FITS_IN_ATOM)

#define STRING_FOUND(x) \
    ((x)->matches[yr_get_tidx()].tail != NULL)

#define STRING_MATCHES(x) \
    ((x)->matches[yr_get_tidx()])


#define RULE_TFLAGS_MATCH                0x01

#define RULE_GFLAGS_PRIVATE              0x01
#define RULE_GFLAGS_GLOBAL               0x02
#define RULE_GFLAGS_REQUIRE_EXECUTABLE   0x04
#define RULE_GFLAGS_REQUIRE_FILE         0x08
#define RULE_GFLAGS_NULL                 0x1000

#define RULE_IS_PRIVATE(x) \
    (((x)->g_flags) & RULE_GFLAGS_PRIVATE)

#define RULE_IS_GLOBAL(x) \
    (((x)->g_flags) & RULE_GFLAGS_GLOBAL)

#define RULE_IS_NULL(x) \
    (((x)->g_flags) & RULE_GFLAGS_NULL)

#define RULE_MATCHES(x) \
    ((x)->t_flags[yr_get_tidx()] & RULE_TFLAGS_MATCH)


#define META_TYPE_NULL      0
#define META_TYPE_INTEGER   1
#define META_TYPE_STRING    2
#define META_TYPE_BOOLEAN   3

#define META_IS_NULL(x) \
    ((x) != NULL ? (x)->type == META_TYPE_NULL : TRUE)


#define EXTERNAL_VARIABLE_TYPE_NULL           0
#define EXTERNAL_VARIABLE_TYPE_FLOAT          1
#define EXTERNAL_VARIABLE_TYPE_INTEGER        2
#define EXTERNAL_VARIABLE_TYPE_BOOLEAN        3
#define EXTERNAL_VARIABLE_TYPE_STRING         4
#define EXTERNAL_VARIABLE_TYPE_MALLOC_STRING  5

#define EXTERNAL_VARIABLE_IS_NULL(x) \
    ((x) != NULL ? (x)->type == EXTERNAL_VARIABLE_TYPE_NULL : TRUE)


#pragma pack(push)
#pragma pack(8)


typedef struct _YR_NAMESPACE
{
    int32_t t_flags[MAX_THREADS];     // Thread-specific flags
    DECLARE_REFERENCE(char*, name);

} YR_NAMESPACE;


typedef struct _YR_META
{
    int32_t type;
    YR_ALIGN(8) int64_t integer;

    DECLARE_REFERENCE(const char*, identifier);
    DECLARE_REFERENCE(char*, string);

} YR_META;


struct _YR_MATCH;


typedef struct _YR_MATCHES
{
    int32_t count;

    DECLARE_REFERENCE(struct _YR_MATCH*, head);
    DECLARE_REFERENCE(struct _YR_MATCH*, tail);

} YR_MATCHES;


typedef struct _YR_STRING
{
    int32_t g_flags;
    int32_t length;

    DECLARE_REFERENCE(char*, identifier);
    DECLARE_REFERENCE(uint8_t*, string);
    DECLARE_REFERENCE(struct _YR_STRING*, chained_to);

    int32_t chain_gap_min;
    int32_t chain_gap_max;

    int64_t fixed_offset;

    YR_MATCHES matches[MAX_THREADS];
    YR_MATCHES unconfirmed_matches[MAX_THREADS];

#ifdef PROFILING_ENABLED
    clock_t clock_ticks;
#endif

} YR_STRING;


typedef struct _YR_RULE
{
    int32_t g_flags;               // Global flags
    int32_t t_flags[MAX_THREADS];  // Thread-specific flags

    DECLARE_REFERENCE(const char*, identifier);
    DECLARE_REFERENCE(const char*, tags);
    DECLARE_REFERENCE(YR_META*, metas);
    DECLARE_REFERENCE(YR_STRING*, strings);
    DECLARE_REFERENCE(YR_NAMESPACE*, ns);

#ifdef PROFILING_ENABLED
    clock_t clock_ticks;
#endif

} YR_RULE;


typedef struct _YR_EXTERNAL_VARIABLE
{
    int32_t type;

    YR_ALIGN(8) union
    {
        int64_t i;
        double f;
        char* s;
    } value;

    DECLARE_REFERENCE(char*, identifier);

} YR_EXTERNAL_VARIABLE;


typedef struct _YR_AC_MATCH
{
    uint16_t backtrack;

    DECLARE_REFERENCE(YR_STRING*, string);
    DECLARE_REFERENCE(uint8_t*, forward_code);
    DECLARE_REFERENCE(uint8_t*, backward_code);
    DECLARE_REFERENCE(struct _YR_AC_MATCH*, next);

} YR_AC_MATCH;


typedef struct _YR_AC_MATCH_TABLE_ENTRY
{
    DECLARE_REFERENCE(YR_AC_MATCH*, match);

} YR_AC_MATCH_TABLE_ENTRY;


typedef uint64_t                  YR_AC_TRANSITION;
typedef YR_AC_TRANSITION*         YR_AC_TRANSITION_TABLE;
typedef YR_AC_MATCH_TABLE_ENTRY*  YR_AC_MATCH_TABLE;


typedef struct _YARA_RULES_FILE_HEADER
{
    uint32_t version;

    DECLARE_REFERENCE(YR_RULE*, rules_list_head);
    DECLARE_REFERENCE(YR_EXTERNAL_VARIABLE*, externals_list_head);
    DECLARE_REFERENCE(uint8_t*, code_start);
    DECLARE_REFERENCE(YR_AC_MATCH_TABLE, match_table);
    DECLARE_REFERENCE(YR_AC_TRANSITION_TABLE, transition_table);

} YARA_RULES_FILE_HEADER;

#pragma pack(pop)


//
// Structs defined below are never stored in the compiled rules file
//

typedef struct _YR_MATCH
{
    int64_t base;              // Base address for the match
    int64_t offset;            // Offset relative to base for the match
    int32_t match_length;      // Match length
    int32_t data_length;

    // Pointer to a buffer containing a portion of the matched data. The size of
    // the buffer is data_length. data_length is always <= length and is limited
    // to MAX_MATCH_DATA bytes.

    uint8_t* data;

    // If the match belongs to a chained string chain_length contains the
    // length of the chain. This field is used only in unconfirmed matches.

    int32_t chain_length;

    struct _YR_MATCH* prev;
    struct _YR_MATCH* next;

} YR_MATCH;


struct _YR_AC_STATE;


typedef struct _YR_AC_STATE
{
    uint8_t depth;
    uint8_t input;

    uint32_t t_table_slot;

    struct _YR_AC_STATE* failure;
    struct _YR_AC_STATE* first_child;
    struct _YR_AC_STATE* siblings;

    YR_AC_MATCH* matches;

} YR_AC_STATE;


typedef struct _YR_AC_AUTOMATON
{
    // Both m_table and t_table have the same number of elements, which is
    // stored in tables_size.

    uint32_t tables_size;
    uint32_t t_table_unused_candidate;

    YR_AC_TRANSITION_TABLE t_table;
    YR_AC_MATCH_TABLE m_table;

    YR_AC_STATE* root;

} YR_AC_AUTOMATON;


typedef struct _YR_RULES
{

    tidx_mask_t tidx_mask;
    uint8_t* code_start;

    YR_MUTEX mutex;
    YR_ARENA* arena;
    YR_RULE* rules_list_head;
    YR_EXTERNAL_VARIABLE* externals_list_head;
    YR_AC_TRANSITION_TABLE transition_table;
    YR_AC_MATCH_TABLE match_table;

} YR_RULES;



struct _YR_MEMORY_BLOCK;
struct _YR_MEMORY_BLOCK_ITERATOR;


typedef uint8_t* (*YR_MEMORY_BLOCK_FETCH_DATA_FUNC)(
    struct _YR_MEMORY_BLOCK* self);


typedef struct _YR_MEMORY_BLOCK* (*YR_MEMORY_BLOCK_ITERATOR_FUNC)(
    struct _YR_MEMORY_BLOCK_ITERATOR* self);


typedef struct _YR_MEMORY_BLOCK
{
    size_t size;
    size_t base;

    void* context;

    YR_MEMORY_BLOCK_FETCH_DATA_FUNC fetch_data;

} YR_MEMORY_BLOCK;


typedef struct _YR_MEMORY_BLOCK_ITERATOR
{
    void* context;

    YR_MEMORY_BLOCK_ITERATOR_FUNC  first;
    YR_MEMORY_BLOCK_ITERATOR_FUNC  next;

} YR_MEMORY_BLOCK_ITERATOR;


typedef int (*YR_CALLBACK_FUNC)(
    int message,
    void* message_data,
    void* user_data);


typedef struct _YR_SCAN_CONTEXT
{
    uint64_t  file_size;
    uint64_t  entry_point;

    int flags;
    int tidx;

    void* user_data;

    YR_MEMORY_BLOCK_ITERATOR*  iterator;
    YR_HASH_TABLE*  objects_table;
    YR_CALLBACK_FUNC  callback;

    YR_ARENA* matches_arena;
    YR_ARENA* matching_strings_arena;

} YR_SCAN_CONTEXT;



#define OBJECT_COMMON_FIELDS \
    int8_t type; \
    const char* identifier; \
    void* data; \
    struct _YR_OBJECT* parent;


typedef struct _YR_OBJECT
{
    OBJECT_COMMON_FIELDS

} YR_OBJECT;


typedef struct _YR_OBJECT_INTEGER
{
    OBJECT_COMMON_FIELDS
    int64_t value;

} YR_OBJECT_INTEGER;


typedef struct _YR_OBJECT_DOUBLE
{
    OBJECT_COMMON_FIELDS
    double value;

} YR_OBJECT_DOUBLE;


typedef struct _YR_OBJECT_STRING
{
    OBJECT_COMMON_FIELDS
    SIZED_STRING* value;

} YR_OBJECT_STRING;


typedef struct _YR_OBJECT_REGEXP
{
    OBJECT_COMMON_FIELDS
    RE* value;

} YR_OBJECT_REGEXP;


typedef struct _YR_OBJECT_STRUCTURE
{
    OBJECT_COMMON_FIELDS
    struct _YR_STRUCTURE_MEMBER* members;

} YR_OBJECT_STRUCTURE;


typedef struct _YR_OBJECT_ARRAY
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* prototype_item;
    struct _YR_ARRAY_ITEMS* items;

} YR_OBJECT_ARRAY;


typedef struct _YR_OBJECT_DICTIONARY
{
    OBJECT_COMMON_FIELDS
    YR_OBJECT* prototype_item;
    struct _YR_DICTIONARY_ITEMS* items;

} YR_OBJECT_DICTIONARY;


struct _YR_OBJECT_FUNCTION;


typedef int (*YR_MODULE_FUNC)(
    void* args,
    YR_SCAN_CONTEXT* context,
    struct _YR_OBJECT_FUNCTION* function_obj);


typedef struct _YR_OBJECT_FUNCTION
{
    OBJECT_COMMON_FIELDS

    YR_OBJECT* return_obj;

    struct
    {
        const char* arguments_fmt;
        YR_MODULE_FUNC code;
    } prototypes[MAX_OVERLOADED_FUNCTIONS];

} YR_OBJECT_FUNCTION;


typedef struct _YR_STRUCTURE_MEMBER
{
    YR_OBJECT* object;
    struct _YR_STRUCTURE_MEMBER* next;

} YR_STRUCTURE_MEMBER;


typedef struct _YR_ARRAY_ITEMS
{
    int count;
    YR_OBJECT* objects[1];

} YR_ARRAY_ITEMS;


typedef struct _YR_DICTIONARY_ITEMS
{
    int used;
    int free;

    struct
    {

        char* key;
        YR_OBJECT* obj;

    } objects[1];

} YR_DICTIONARY_ITEMS;


#endif



================================================
File: x64dbg_pluginsdk/yara/yara/utils.h
================================================
/*
Copyright (c) 2014. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef YR_UTILS_H
#define YR_UTILS_H

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define YR_API EXTERNC __attribute__((visibility("default")))
#elif defined(_MSC_VER)
#define YR_API EXTERNC __declspec(dllexport)
#else
#define YR_API EXTERNC
#endif

#if defined(__GNUC__)
#define YR_ALIGN(n) __attribute__((aligned(n)))
#elif defined(_MSC_VER)
#define YR_ALIGN(n) __declspec(align(n))
#else
#define YR_ALIGN(n)
#endif

#define yr_min(x, y) ((x < y) ? (x) : (y))
#define yr_max(x, y) ((x > y) ? (x) : (y))

#define PTR_TO_INT64(x)  ((int64_t) (size_t) x)


#ifdef NDEBUG

#define assertf(expr, msg, ...)  ((void)0)

#else

#include <stdlib.h>

#define assertf(expr, msg, ...) \
    if(!(expr)) { \
      fprintf(stderr, "%s:%d: " msg "\n", __FILE__, __LINE__, ##__VA_ARGS__); \
      abort(); \
    }

#endif

#endif


